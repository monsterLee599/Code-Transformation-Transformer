{"28": "public class Notification { \n@ SuppressWarnings ( \"unchecked\" ) @ Nullable public T getValue ( ) { \nObject o = value ; \nif ( o != null ) { \nif ( ! NotificationLite . isError ( o ) ) { \nreturn ( T ) value ; \n} \n} \nreturn null ; \n} \n} \n"}
{"41": "public class SubscriptionArbiter { \npublic final void setSubscription ( Subscription s ) { \nif ( cancelled ) { \ns . cancel ( ) ; \nreturn ; \n} \nObjectHelper . requireNonNull ( s , \"s is null\" ) ; \nif ( get ( ) == 0 ) { \nif ( compareAndSet ( 0 , 1 ) ) { \nSubscription a = actual ; \nif ( a != null ) { \nif ( cancelOnReplace ) { \na . cancel ( ) ; \n} \n} \nactual = s ; \nlong r = requested ; \nif ( decrementAndGet ( ) != 0 ) { \ndrainLoop ( ) ; \n} \nif ( r != 0L ) { \ns . request ( r ) ; \n} \nreturn ; \n} \n} \nSubscription a = missedSubscription . getAndSet ( s ) ; \nif ( a != null ) { \nif ( cancelOnReplace ) { \na . cancel ( ) ; \n} \n} \ndrain ( ) ; \n} \n} \n"}
{"65": "public class PublishSubject { \n@ SuppressWarnings ( \"unchecked\" ) void remove ( PublishDisposable < T > ps ) { \nfor ( ; \n; \n) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED ) { \nreturn ; \n} \nelse if ( a == EMPTY ) { \nreturn ; \n} \nint n = a . length ; \nint j = - 1 ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nif ( a [ i ] == ps ) { \nj = i ; \nbreak ; \n} \n} \nif ( j < 0 ) { \nreturn ; \n} \nPublishDisposable < T > [ ] b ; \nif ( n == 1 ) { \nb = EMPTY ; \n} \nelse { \nb = new PublishDisposable [ n - 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , j ) ; \nSystem . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; \n} \nif ( subscribers . compareAndSet ( a , b ) ) { \nreturn ; \n} \n} \n} \n} \n"}
{"67": "public class HttpServiceMethod { \nstatic < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { \nboolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; \nboolean continuationWantsResponse = false ; \nboolean continuationBodyNullable = false ; \nAnnotation [ ] annotations = method . getAnnotations ( ) ; \nType adapterType ; \nif ( isKotlinSuspendFunction ) { \nType [ ] parameterTypes = method . getGenericParameterTypes ( ) ; \nType responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; \nif ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) { \nresponseType = Utils . getParameterUpperBound ( 0 , ( ParameterizedType ) responseType ) ; \ncontinuationWantsResponse = true ; \n} \nelse { \n} \nadapterType = new Utils . ParameterizedTypeImpl ( null , Call . class , responseType ) ; \nannotations = SkipCallbackExecutorImpl . ensurePresent ( annotations ) ; \n} \nelse { \nadapterType = method . getGenericReturnType ( ) ; \n} \nCallAdapter < ResponseT , ReturnT > callAdapter = createCallAdapter ( retrofit , method , adapterType , annotations ) ; \nType responseType = callAdapter . responseType ( ) ; \nif ( responseType == okhttp3 . Response . class ) { \nthrow methodError ( method , \"'\" + getRawType ( responseType ) . getName ( ) + \"' is not a valid response body type. Did you mean ResponseBody?\" ) ; \n} \nif ( responseType == Response . class ) { \nthrow methodError ( method , \"Response must include generic type (e.g., Response<String>)\" ) ; \n} \nif ( requestFactory . httpMethod . equals ( \"HEAD\" ) ) { \nif ( ! Void . class . equals ( responseType ) ) { \nthrow methodError ( method , \"HEAD method must use Void as response type.\" ) ; \n} \n} \nConverter < ResponseBody , ResponseT > responseConverter = createResponseConverter ( retrofit , method , responseType ) ; \nokhttp3 . Call . Factory callFactory = retrofit . callFactory ; \nif ( ! isKotlinSuspendFunction ) { \nreturn new CallAdapted < > ( requestFactory , callFactory , responseConverter , callAdapter ) ; \n} \nelse if ( continuationWantsResponse ) { \nreturn ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForResponse < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter ) ; \n} \nelse { \nreturn ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForBody < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter , continuationBodyNullable ) ; \n} \n} \n} \n"}
{"77": "public class SpringSecurityCoreVersion { \nprivate static boolean disableChecks ( String springVersion , String springSecurityVersion ) { \nif ( springVersion == null ) { \nreturn true ; \n} \nelse if ( springVersion . equals ( springSecurityVersion ) ) { \nreturn true ; \n} \nreturn Boolean . getBoolean ( DISABLE_CHECKS ) ; \n} \n} \n"}
{"101": "public class AbstractPreAuthenticatedProcessingFilter { \nprotected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { \nObject principal = getPreAuthenticatedPrincipal ( request ) ; \nif ( principal instanceof String ) { \nif ( currentAuthentication . getName ( ) . equals ( principal ) ) { \nreturn false ; \n} \n} \nif ( principal != null ) { \nif ( principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { \nreturn false ; \n} \n} \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Pre-authenticated principal has changed to \" + principal + \" and will be reauthenticated\" ) ; \n} \nreturn true ; \n} \n} \n"}
{"103": "public class OnCommittedResponseWrapper { \nprivate void checkContentLength ( long contentLengthToWrite ) { \nthis . contentWritten += contentLengthToWrite ; \nboolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; \nint bufferSize = getBufferSize ( ) ; \nboolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; \nif ( isBodyFullyWritten ) { \ndoOnResponseCommitted ( ) ; \n} \nelse if ( requiresFlush ) { \ndoOnResponseCommitted ( ) ; \n} \n} \n} \n"}
{"106": "public class AbstractAuthenticationFilterConfigurer { \nprotected final void updateAuthenticationDefaults ( ) { \nif ( loginProcessingUrl == null ) { \nloginProcessingUrl ( loginPage ) ; \n} \nif ( failureHandler == null ) { \nfailureUrl ( loginPage + \"?error\" ) ; \n} \nfinal LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; \nif ( logoutConfigurer != null ) { \nif ( ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { \nlogoutConfigurer . logoutSuccessUrl ( loginPage + \"?logout\" ) ; \n} \n} \n} \n} \n"}
{"109": "public class AbstractRememberMeServices { \nprotected String extractRememberMeCookie ( HttpServletRequest request ) { \nCookie [ ] cookies = request . getCookies ( ) ; \nif ( cookies == null ) { \nreturn null ; \n} \nelse if ( cookies . length == 0 ) { \nreturn null ; \n} \nfor ( Cookie cookie : cookies ) { \nif ( cookieName . equals ( cookie . getName ( ) ) ) { \nreturn cookie . getValue ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"117": "public class AbstractJaasAuthenticationProvider { \npublic Authentication authenticate ( Authentication auth ) throws AuthenticationException { \nif ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { \nreturn null ; \n} \nUsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; \nSet < GrantedAuthority > authorities ; \ntry { \nLoginContext loginContext = createLoginContext ( new InternalCallbackHandler ( auth ) ) ; \nloginContext . login ( ) ; \nauthorities = new HashSet < > ( ) ; \nSet < Principal > principals = loginContext . getSubject ( ) . getPrincipals ( ) ; \nfor ( Principal principal : principals ) { \nfor ( AuthorityGranter granter : this . authorityGranters ) { \nSet < String > roles = granter . grant ( principal ) ; \nif ( roles != null ) { \nif ( ! roles . isEmpty ( ) ) { \nfor ( String role : roles ) { \nauthorities . add ( new JaasGrantedAuthority ( role , principal ) ) ; \n} \n} \n} \n} \n} \nJaasAuthenticationToken result = new JaasAuthenticationToken ( request . getPrincipal ( ) , request . getCredentials ( ) , new ArrayList < > ( authorities ) , loginContext ) ; \npublishSuccessEvent ( result ) ; \nreturn result ; \n} \ncatch ( LoginException loginException ) { \nAuthenticationException ase = this . loginExceptionResolver . resolveException ( loginException ) ; \npublishFailureEvent ( request , ase ) ; \nthrow ase ; \n} \n} \n} \n"}
{"121": "public class JspAuthorizeTag { \npublic int doEndTag ( ) throws JspException { \ntry { \nif ( ! authorized ) { \nif ( TagLibConfig . isUiSecurityDisabled ( ) ) { \npageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; \n} \n} \n} \ncatch ( IOException e ) { \nthrow new JspException ( e ) ; \n} \nreturn EVAL_PAGE ; \n} \n} \n"}
{"151": "public class SwitchUserFilter { \nprotected Authentication attemptExitUser ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException { \nAuthentication current = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; \nif ( null == current ) { \nthrow new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( \"SwitchUserFilter.noCurrentUser\" , \"No current user associated with this request\" ) ) ; \n} \nAuthentication original = getSourceAuthentication ( current ) ; \nif ( original == null ) { \nthis . logger . debug ( \"Could not find original user Authentication object!\" ) ; \nthrow new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( \"SwitchUserFilter.noOriginalAuthentication\" , \"Could not find original Authentication object\" ) ) ; \n} \nUserDetails originalUser = null ; \nObject obj = original . getPrincipal ( ) ; \nif ( obj != null ) { \nif ( obj instanceof UserDetails ) { \noriginalUser = ( UserDetails ) obj ; \n} \n} \nif ( this . eventPublisher != null ) { \nthis . eventPublisher . publishEvent ( new AuthenticationSwitchUserEvent ( current , originalUser ) ) ; \n} \nreturn original ; \n} \n} \n"}
{"164": "public class SecurityExpressionRoot { \nprivate static String getRoleWithDefaultPrefix ( String defaultRolePrefix , String role ) { \nif ( role == null ) { \nreturn role ; \n} \nif ( defaultRolePrefix == null ) { \nreturn role ; \n} \nelse if ( defaultRolePrefix . length ( ) == 0 ) { \nreturn role ; \n} \nif ( role . startsWith ( defaultRolePrefix ) ) { \nreturn role ; \n} \nreturn defaultRolePrefix + role ; \n} \n} \n"}
{"200": "public class HttpSessionRequestCache { \npublic void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { \nif ( requestMatcher . matches ( request ) ) { \nDefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; \nif ( createSessionAllowed ) { \nrequest . getSession ( ) . setAttribute ( this . sessionAttrName , savedRequest ) ; \nlogger . debug ( \"DefaultSavedRequest added to Session: \" + savedRequest ) ; \n} \nelse if ( request . getSession ( false ) != null ) { \nrequest . getSession ( ) . setAttribute ( this . sessionAttrName , savedRequest ) ; \nlogger . debug ( \"DefaultSavedRequest added to Session: \" + savedRequest ) ; \n} \n} \nelse { \nlogger . debug ( \"Request not saved as configured RequestMatcher did not match\" ) ; \n} \n} \n} \n"}
{"208": "public class AbstractAuthenticationTargetUrlRequestHandler { \nprotected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response ) { \nif ( isAlwaysUseDefaultTargetUrl ( ) ) { \nreturn defaultTargetUrl ; \n} \nString targetUrl = null ; \nif ( targetUrlParameter != null ) { \ntargetUrl = request . getParameter ( targetUrlParameter ) ; \nif ( StringUtils . hasText ( targetUrl ) ) { \nlogger . debug ( \"Found targetUrlParameter in request: \" + targetUrl ) ; \nreturn targetUrl ; \n} \n} \nif ( useReferer ) { \nif ( ! StringUtils . hasLength ( targetUrl ) ) { \ntargetUrl = request . getHeader ( \"Referer\" ) ; \nlogger . debug ( \"Using Referer header: \" + targetUrl ) ; \n} \n} \nif ( ! StringUtils . hasText ( targetUrl ) ) { \ntargetUrl = defaultTargetUrl ; \nlogger . debug ( \"Using default Url: \" + targetUrl ) ; \n} \nreturn targetUrl ; \n} \n} \n"}
{"210": "public class DocumentDaoImpl { \nprivate Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { \nreturn getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { \nid } \n, new RowMapper < Directory > ( ) { \npublic Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { \nLong parentDirectoryId = new Long ( rs . getLong ( \"parent_directory_id\" ) ) ; \nDirectory parentDirectory = Directory . ROOT_DIRECTORY ; \nif ( parentDirectoryId != null ) { \nif ( ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) { \nparentDirectory = getDirectoryWithImmediateParentPopulated ( parentDirectoryId ) ; \n} \n} \nDirectory directory = new Directory ( rs . getString ( \"directory_name\" ) , parentDirectory ) ; \nFieldUtils . setProtectedFieldValue ( \"id\" , directory , new Long ( rs . getLong ( \"id\" ) ) ) ; \nreturn directory ; \n} \n} \n) ; \n} \n} \n"}
{"222": "public class ConcurrentSessionControlAuthenticationStrategy { \nprotected void allowableSessionsExceeded ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { \nif ( exceptionIfMaximumExceeded ) { \nthrow new SessionAuthenticationException ( messages . getMessage ( \"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\" , new Object [ ] { \nInteger . valueOf ( allowableSessions ) } \n, \"Maximum sessions of {0} for this principal exceeded\" ) ) ; \n} \nelse if ( sessions == null ) { \nthrow new SessionAuthenticationException ( messages . getMessage ( \"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\" , new Object [ ] { \nInteger . valueOf ( allowableSessions ) } \n, \"Maximum sessions of {0} for this principal exceeded\" ) ) ; \n} \nSessionInformation leastRecentlyUsed = null ; \nfor ( SessionInformation session : sessions ) { \nif ( leastRecentlyUsed == null ) { \nleastRecentlyUsed = session ; \n} \nelse if ( session . getLastRequest ( ) . before ( leastRecentlyUsed . getLastRequest ( ) ) ) { \nleastRecentlyUsed = session ; \n} \n} \nleastRecentlyUsed . expireNow ( ) ; \n} \n} \n"}
{"223": "public class ProviderManager { \nprivate void copyDetails ( Authentication source , Authentication dest ) { \nif ( dest instanceof AbstractAuthenticationToken ) { \nif ( dest . getDetails ( ) == null ) { \nAbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; \ntoken . setDetails ( source . getDetails ( ) ) ; \n} \n} \n} \n} \n"}
{"236": "public class ResponsePrinter { \npublic static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { \nfinal StringBuilder builder = new StringBuilder ( ) ; \nif ( logDetail == ALL ) { \nbuilder . append ( responseOptions . statusLine ( ) ) ; \n} \nelse if ( logDetail == STATUS ) { \nbuilder . append ( responseOptions . statusLine ( ) ) ; \n} \nif ( logDetail == ALL || logDetail == HEADERS ) { \nfinal Headers headers = responseOptions . headers ( ) ; \nif ( headers . exist ( ) ) { \nappendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; \n} \n} \nelse if ( logDetail == COOKIES ) { \nfinal Cookies cookies = responseOptions . detailedCookies ( ) ; \nif ( cookies . exist ( ) ) { \nappendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; \n} \n} \nif ( logDetail == ALL ) { \nString responseBodyToAppend ; \nif ( shouldPrettyPrint ) { \nresponseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; \n} \nelse { \nresponseBodyToAppend = responseBody . asString ( ) ; \n} \nif ( logDetail == ALL ) { \nif ( ! isBlank ( responseBodyToAppend ) ) { \nbuilder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; \n} \n} \nbuilder . append ( responseBodyToAppend ) ; \n} \nelse if ( logDetail == BODY ) { \nString responseBodyToAppend ; \nif ( shouldPrettyPrint ) { \nresponseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; \n} \nelse { \nresponseBodyToAppend = responseBody . asString ( ) ; \n} \nif ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { \nbuilder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; \n} \nbuilder . append ( responseBodyToAppend ) ; \n} \nString response = builder . toString ( ) ; \nstream . println ( response ) ; \nreturn response ; \n} \n} \n"}
{"266": "public class ResponseBuilder { \npublic Response build ( ) { \nfinal int statusCode = restAssuredResponse . statusCode ( ) ; \nif ( statusCode < 100 ) { \nthrow new IllegalArgumentException ( format ( \"Status code must be greater than 100 and less than 600, was %d.\" , statusCode ) ) ; \n} \nelse if ( statusCode >= 600 ) { \nthrow new IllegalArgumentException ( format ( \"Status code must be greater than 100 and less than 600, was %d.\" , statusCode ) ) ; \n} \nif ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { \nrestAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; \n} \nrestAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; \nreturn restAssuredResponse ; \n} \n} \n"}
{"314": "public class InjectorImpl { \nprivate < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors errors ) throws ErrorsException { \nKey < String > stringKey = key . ofType ( STRING_TYPE ) ; \nBindingImpl < String > stringBinding = state . getExplicitBinding ( stringKey ) ; \nif ( stringBinding == null ) { \nreturn null ; \n} \nelse if ( ! stringBinding . isConstant ( ) ) { \nreturn null ; \n} \n@ SuppressWarnings ( \"unchecked\" ) String stringValue = ( ( InstanceBinding < String > ) stringBinding ) . getInstance ( ) ; \nObject source = stringBinding . getSource ( ) ; \nTypeLiteral < T > type = key . getTypeLiteral ( ) ; \nTypeConverterBinding typeConverterBinding = state . getConverter ( stringValue , type , errors , source ) ; \nif ( typeConverterBinding == null ) { \nreturn null ; \n} \ntry { \n@ SuppressWarnings ( \"unchecked\" ) T converted = ( T ) typeConverterBinding . getTypeConverter ( ) . convert ( stringValue , type ) ; \nif ( converted == null ) { \nthrow errors . converterReturnedNull ( stringValue , source , type , typeConverterBinding ) . toException ( ) ; \n} \nif ( ! type . getRawType ( ) . isInstance ( converted ) ) { \nthrow errors . conversionTypeError ( stringValue , source , type , typeConverterBinding , converted ) . toException ( ) ; \n} \nreturn new ConvertedConstantBindingImpl < T > ( this , key , converted , stringBinding , typeConverterBinding ) ; \n} \ncatch ( ErrorsException e ) { \nthrow e ; \n} \ncatch ( RuntimeException e ) { \nthrow errors . conversionError ( stringValue , source , type , typeConverterBinding , e ) . toException ( ) ; \n} \n} \n} \n"}
{"318": "public class InjectorImpl { \n< T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { \nClass < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; \nImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ; \nif ( rawType . isArray ( ) ) { \nthrow errors . missingImplementationWithHint ( key , this ) . toException ( ) ; \n} \nelse if ( rawType . isEnum ( ) && implementedBy != null ) { \nthrow errors . missingImplementationWithHint ( key , this ) . toException ( ) ; \n} \nif ( rawType == TypeLiteral . class ) { \n@ SuppressWarnings ( \"unchecked\" ) BindingImpl < T > binding = ( BindingImpl < T > ) createTypeLiteralBinding ( ( Key < TypeLiteral < Object > > ) key , errors ) ; \nreturn binding ; \n} \nif ( implementedBy != null ) { \nAnnotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; \nreturn createImplementedByBinding ( key , scoping , implementedBy , errors ) ; \n} \nProvidedBy providedBy = rawType . getAnnotation ( ProvidedBy . class ) ; \nif ( providedBy != null ) { \nAnnotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; \nreturn createProvidedByBinding ( key , scoping , providedBy , errors ) ; \n} \nreturn ConstructorBindingImpl . create ( this , key , null , source , scoping , errors , jitBinding && options . jitDisabled , options . atInjectRequired ) ; \n} \n} \n"}
{"323": "public class InjectionPoint { \nprivate static boolean overrides ( Method a , Method b ) { \nint modifiers = b . getModifiers ( ) ; \nif ( Modifier . isPublic ( modifiers ) ) { \nreturn true ; \n} \nelse if ( Modifier . isProtected ( modifiers ) ) { \nreturn true ; \n} \nif ( Modifier . isPrivate ( modifiers ) ) { \nreturn false ; \n} \nreturn a . getDeclaringClass ( ) . getPackage ( ) . equals ( b . getDeclaringClass ( ) . getPackage ( ) ) ; \n} \n} \n"}
{"333": "public class Initializer { \n< T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { \ncheckNotNull ( source ) ; \nPreconditions . checkState ( ! validationStarted , \"Member injection could not be requested after validation is started\" ) ; \nProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ; \nif ( instance == null ) { \nreturn Initializables . of ( instance ) ; \n} \nelse if ( injectionPoints . isEmpty ( ) && ! injector . membersInjectorStore . hasTypeListeners ( ) && provisionCallback == null ) { \nreturn Initializables . of ( instance ) ; \n} \nif ( initializablesCache . containsKey ( instance ) ) { \n@ SuppressWarnings ( \"unchecked\" ) Initializable < T > cached = ( Initializable < T > ) initializablesCache . get ( instance ) ; \nreturn cached ; \n} \nInjectableReference < T > injectableReference = new InjectableReference < T > ( injector , instance , binding == null ? null : binding . getKey ( ) , provisionCallback , source , cycleDetectingLockFactory . create ( instance . getClass ( ) ) ) ; \ninitializablesCache . put ( instance , injectableReference ) ; \npendingInjections . add ( injectableReference ) ; \nreturn injectableReference ; \n} \n} \n"}
{"358": "public class FactoryProvider2 { \nprivate Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { \nImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; \nfor ( Dependency < ? > dep : deps ) { \nClass < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; \nif ( annotationType == null ) { \nbuilder . add ( dep ) ; \n} \nelse if ( ! annotationType . equals ( Assisted . class ) ) { \nbuilder . add ( dep ) ; \n} \n} \nreturn builder . build ( ) ; \n} \n} \n"}
{"359": "public class FactoryProvider2 { \nprivate boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { \nSet < Dependency < ? > > badDeps = null ; \nfor ( Dependency < ? > dep : dependencies ) { \nif ( isInjectorOrAssistedProvider ( dep ) ) { \nif ( badDeps == null ) { \nbadDeps = Sets . newHashSet ( ) ; \n} \nbadDeps . add ( dep ) ; \n} \n} \nif ( badDeps != null ) { \nif ( ! badDeps . isEmpty ( ) ) { \nlogger . log ( Level . WARNING , \"AssistedInject factory {0} will be slow \" + \"because {1} has assisted Provider dependencies or injects the Injector. \" + \"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \" + \"or Injector to speed things up. (It will be a ~6500% speed bump!)  \" + \"The exact offending deps are: {2}\" , new Object [ ] { \nfactoryType , implementation , badDeps } \n) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"361": "public class FactoryProvider2 { \n@ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { \nif ( methodHandleByMethod . containsKey ( method ) ) { \nreturn methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; \n} \nif ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { \nif ( \"equals\" . equals ( method . getName ( ) ) ) { \nreturn proxy == args [ 0 ] ; \n} \nelse if ( \"hashCode\" . equals ( method . getName ( ) ) ) { \nreturn System . identityHashCode ( proxy ) ; \n} \nelse { \nreturn method . invoke ( this , args ) ; \n} \n} \nAssistData data = assistDataByMethod . get ( method ) ; \ncheckState ( data != null , \"No data for method: %s\" , method ) ; \nProvider < ? > provider ; \nif ( data . cachedBinding != null ) { \nprovider = data . cachedBinding . getProvider ( ) ; \n} \nelse { \nprovider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; \n} \ntry { \nint p = 0 ; \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . set ( args [ p ++ ] ) ; \n} \nreturn provider . get ( ) ; \n} \ncatch ( ProvisionException e ) { \nif ( e . getErrorMessages ( ) . size ( ) == 1 ) { \nMessage onlyError = getOnlyElement ( e . getErrorMessages ( ) ) ; \nThrowable cause = onlyError . getCause ( ) ; \nif ( cause != null ) { \nif ( canRethrow ( method , cause ) ) { \nthrow cause ; \n} \n} \n} \nthrow e ; \n} \nfinally { \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . remove ( ) ; \n} \n} \n} \n} \n"}
{"362": "public class Errors { \n< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( format ( \"No implementation for %s was bound.\" , key ) ) ; \nList < String > possibleMatches = new ArrayList < > ( ) ; \nTypeLiteral < T > type = key . getTypeLiteral ( ) ; \nList < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; \nif ( ! sameTypes . isEmpty ( ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nint howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; \nfor ( int i = 0 ; \ni < howMany ; \n++ i ) { \nsb . append ( format ( \"%n    * %s\" , sameTypes . get ( i ) . getKey ( ) ) ) ; \n} \nint remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; \nif ( remaining > 0 ) { \nString plural = ( remaining == 1 ) ? \"\" : \"s\" ; \nsb . append ( format ( \"%n    %d more binding%s with other annotations.\" , remaining , plural ) ) ; \n} \n} \nelse { \nString want = type . toString ( ) ; \nMap < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; \nfor ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { \nString have = bindingKey . getTypeLiteral ( ) . toString ( ) ; \nif ( have . contains ( want ) ) { \nFormatter fmt = new Formatter ( ) ; \nMessages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; \nString match = String . format ( \"%s bound%s\" , convert ( bindingKey ) , fmt . toString ( ) ) ; \npossibleMatches . add ( match ) ; \nif ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) { \nbreak ; \n} \n} \nelse if ( want . contains ( have ) ) { \nFormatter fmt = new Formatter ( ) ; \nMessages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; \nString match = String . format ( \"%s bound%s\" , convert ( bindingKey ) , fmt . toString ( ) ) ; \npossibleMatches . add ( match ) ; \nif ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) { \nbreak ; \n} \n} \n} \nif ( possibleMatches . size ( ) > 0 ) { \nif ( possibleMatches . size ( ) <= MAX_RELATED_TYPES_REPORTED ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nfor ( String possibleMatch : possibleMatches ) { \nsb . append ( format ( \"%n    %s\" , possibleMatch ) ) ; \n} \n} \n} \n} \nif ( sameTypes . isEmpty ( ) && possibleMatches . isEmpty ( ) && key . getAnnotation ( ) == null ) { \nif ( COMMON_AMBIGUOUS_TYPES . contains ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { \nsb . append ( format ( \"%nThe key seems very generic, did you forget an annotation?\" ) ) ; \n} \n} \nreturn addMessage ( sb . toString ( ) ) ; \n} \n} \n"}
{"370": "public class ProviderMethodsModule { \nprivate Annotation getAnnotation ( Binder binder , Method method ) { \nif ( method . isBridge ( ) ) { \nreturn null ; \n} \nelse if ( method . isSynthetic ( ) ) { \nreturn null ; \n} \nAnnotation annotation = null ; \nfor ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { \nAnnotation foundAnnotation = method . getAnnotation ( annotationClass ) ; \nif ( foundAnnotation != null ) { \nif ( annotation != null ) { \nbinder . addError ( \"More than one annotation claimed by %s on method %s.\" + \" Methods can only have one annotation claimed per scanner.\" , scanner , method ) ; \nreturn null ; \n} \nannotation = foundAnnotation ; \n} \n} \nreturn annotation ; \n} \n} \n"}
{"375": "public class ServletScopes { \nprivate static Object validateAndCanonicalizeValue ( Key < ? > key , Object object ) { \nif ( object == null ) { \nreturn NullObject . INSTANCE ; \n} \nelse if ( object == NullObject . INSTANCE ) { \nreturn NullObject . INSTANCE ; \n} \nif ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { \nthrow new IllegalArgumentException ( \"Value[\" + object + \"] of type[\" + object . getClass ( ) . getName ( ) + \"] is not compatible with key[\" + key + \"]\" ) ; \n} \nreturn object ; \n} \n} \n"}
{"377": "public class MembersInjectorStore { \nprivate < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { \nint numErrorsBefore = errors . size ( ) ; \nSet < InjectionPoint > injectionPoints ; \ntry { \ninjectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; \n} \ncatch ( ConfigurationException e ) { \nerrors . merge ( e . getErrorMessages ( ) ) ; \ninjectionPoints = e . getPartialValue ( ) ; \n} \nImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; \nerrors . throwIfNewErrors ( numErrorsBefore ) ; \nEncounterImpl < T > encounter = new EncounterImpl < > ( errors , injector . lookups ) ; \nSet < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; \nfor ( TypeListenerBinding binding : typeListenerBindings ) { \nTypeListener typeListener = binding . getListener ( ) ; \nif ( ! alreadySeenListeners . contains ( typeListener ) ) { \nif ( binding . getTypeMatcher ( ) . matches ( type ) ) { \nalreadySeenListeners . add ( typeListener ) ; \ntry { \ntypeListener . hear ( type , encounter ) ; \n} \ncatch ( RuntimeException e ) { \nerrors . errorNotifyingTypeListener ( binding , type , e ) ; \n} \n} \n} \n} \nencounter . invalidate ( ) ; \nerrors . throwIfNewErrors ( numErrorsBefore ) ; \nreturn new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; \n} \n} \n"}
{"382": "public class InterceptorStackCallback { \nprivate void pruneStacktrace ( Throwable throwable ) { \nfor ( Throwable t = throwable ; \nt != null ; \nt = t . getCause ( ) ) { \nStackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; \nList < StackTraceElement > pruned = Lists . newArrayList ( ) ; \nfor ( StackTraceElement element : stackTrace ) { \nString className = element . getClassName ( ) ; \nif ( ! AOP_INTERNAL_CLASSES . contains ( className ) ) { \nif ( ! className . contains ( \"$EnhancerByGuice$\" ) ) { \npruned . add ( element ) ; \n} \n} \n} \nt . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; \n} \n} \n} \n"}
{"384": "public class Messages { \npublic static String formatMessages ( String heading , Collection < Message > errorMessages ) { \nFormatter fmt = new Formatter ( ) . format ( heading ) . format ( \":%n%n\" ) ; \nint index = 1 ; \nboolean displayCauses = getOnlyCause ( errorMessages ) == null ; \nMap < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; \nfor ( Message errorMessage : errorMessages ) { \nint thisIdx = index ++ ; \nfmt . format ( \"%s) %s%n\" , thisIdx , errorMessage . getMessage ( ) ) ; \nList < Object > dependencies = errorMessage . getSources ( ) ; \nfor ( int i = dependencies . size ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nObject source = dependencies . get ( i ) ; \nformatSource ( fmt , source ) ; \n} \nThrowable cause = errorMessage . getCause ( ) ; \nif ( displayCauses ) { \nif ( cause != null ) { \nEquivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; \nif ( ! causes . containsKey ( causeEquivalence ) ) { \ncauses . put ( causeEquivalence , thisIdx ) ; \nfmt . format ( \"Caused by: %s\" , Throwables . getStackTraceAsString ( cause ) ) ; \n} \nelse { \nint causeIdx = causes . get ( causeEquivalence ) ; \nfmt . format ( \"Caused by: %s (same stack trace as error #%s)\" , cause . getClass ( ) . getName ( ) , causeIdx ) ; \n} \n} \n} \nfmt . format ( \"%n\" ) ; \n} \nif ( errorMessages . size ( ) == 1 ) { \nfmt . format ( \"1 error\" ) ; \n} \nelse { \nfmt . format ( \"%s errors\" , errorMessages . size ( ) ) ; \n} \nreturn fmt . toString ( ) ; \n} \n} \n"}
{"395": "public class ProviderInternalFactory { \nprotected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { \nT t = provider . get ( ) ; \nif ( t == null ) { \nif ( ! dependency . isNullable ( ) ) { \nInternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; \n} \n} \nconstructionContext . setProxyDelegates ( t ) ; \nreturn t ; \n} \n} \n"}
{"406": "public class DefaultConnectionManager { \n@ Override public void scan ( ) { \nif ( null != this . connTasks ) { \nif ( ! this . connTasks . isEmpty ( ) ) { \nIterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nString poolKey = iter . next ( ) ; \nConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; \nif ( null != pool ) { \npool . scan ( ) ; \nif ( pool . isEmpty ( ) ) { \nif ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { \niter . remove ( ) ; \nlogger . warn ( \"Remove expired pool task of poolKey {} which is empty.\" , poolKey ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"410": "public class DefaultConnectionManager { \nprivate void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { \nString poolKey = url . getUniqueKey ( ) ; \nif ( pool . isAsyncCreationDone ( ) ) { \nif ( pool . size ( ) < url . getConnNum ( ) ) { \nFutureTask < Integer > task = this . healTasks . get ( poolKey ) ; \nif ( null == task ) { \ntask = new FutureTask < Integer > ( new HealConnectionCall ( url , pool ) ) ; \ntask = this . healTasks . putIfAbsent ( poolKey , task ) ; \nif ( null == task ) { \ntask = this . healTasks . get ( poolKey ) ; \ntask . run ( ) ; \n} \n} \ntry { \nint numAfterHeal = task . get ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\" , numAfterHeal , url . getConnNum ( ) , url . isConnWarmup ( ) ) ; \n} \n} \ncatch ( InterruptedException e ) { \nthis . healTasks . remove ( poolKey ) ; \nthrow e ; \n} \ncatch ( ExecutionException e ) { \nthis . healTasks . remove ( poolKey ) ; \nThrowable cause = e . getCause ( ) ; \nif ( cause instanceof RemotingException ) { \nthrow ( RemotingException ) cause ; \n} \nelse { \nFutureTaskUtil . launderThrowable ( cause ) ; \n} \n} \nthis . healTasks . remove ( poolKey ) ; \n} \n} \n} \n} \n"}
{"411": "public class DefaultConnectionManager { \nprivate void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { \nfinal int actualNum = pool . size ( ) ; \nfinal int expectNum = url . getConnNum ( ) ; \nif ( actualNum < expectNum ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"actual num {}, expect num {}, task name {}\" , actualNum , expectNum , taskName ) ; \n} \nif ( url . isConnWarmup ( ) ) { \nfor ( int i = actualNum ; \ni < expectNum ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \n} \nelse { \nif ( syncCreateNumWhenNotWarmup < 0 ) { \nthrow new IllegalArgumentException ( \"sync create number when not warmup should be [0,\" + url . getConnNum ( ) + \"]\" ) ; \n} \nelse if ( syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { \nthrow new IllegalArgumentException ( \"sync create number when not warmup should be [0,\" + url . getConnNum ( ) + \"]\" ) ; \n} \nif ( syncCreateNumWhenNotWarmup > 0 ) { \nfor ( int i = 0 ; \ni < syncCreateNumWhenNotWarmup ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \nif ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) { \nreturn ; \n} \n} \ninitializeExecutor ( ) ; \npool . markAsyncCreationStart ( ) ; \ntry { \nthis . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { \n@ Override public void run ( ) { \ntry { \nfor ( int i = pool . size ( ) ; \ni < url . getConnNum ( ) ; \n++ i ) { \nConnection conn = null ; \ntry { \nconn = create ( url ) ; \n} \ncatch ( RemotingException e ) { \nlogger . error ( \"Exception occurred in async create connection thread for {}, taskName {}\" , url . getUniqueKey ( ) , taskName , e ) ; \n} \npool . add ( conn ) ; \n} \n} \nfinally { \npool . markAsyncCreationDone ( ) ; \n} \n} \n} \n) ; \n} \ncatch ( RejectedExecutionException e ) { \npool . markAsyncCreationDone ( ) ; \nthrow e ; \n} \n} \n} \n} \n} \n"}
{"417": "public class UserProcessorRegisterHelper { \nprivate static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { \nif ( null == processor . multiInterest ( ) ) { \nthrow new RuntimeException ( \"Processor interest should not be blank!\" ) ; \n} \nelse if ( processor . multiInterest ( ) . isEmpty ( ) ) { \nthrow new RuntimeException ( \"Processor interest should not be blank!\" ) ; \n} \nfor ( String interest : processor . multiInterest ( ) ) { \nUserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , processor ) ; \nif ( preProcessor != null ) { \nString errMsg = \"Processor with interest key [\" + interest + \"] has already been registered to rpc server, can not register again!\" ; \nthrow new RuntimeException ( errMsg ) ; \n} \n} \n} \n} \n"}
{"427": "public class ProtocolSwitch { \npublic static BitSet toBitSet ( int value ) { \nif ( value > Byte . MAX_VALUE ) { \nthrow new IllegalArgumentException ( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \n} \nelse if ( value < Byte . MIN_VALUE ) { \nthrow new IllegalArgumentException ( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \n} \nBitSet bs = new BitSet ( ) ; \nint index = 0 ; \nwhile ( value != 0 ) { \nif ( value % 2 != 0 ) { \nbs . set ( index ) ; \n} \n++ index ; \nvalue = ( byte ) ( value >> 1 ) ; \n} \nreturn bs ; \n} \n} \n"}
{"430": "public class RpcRemoting { \nprotected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { \nRpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; \nif ( null != invokeContext ) { \nObject clientCustomSerializer = invokeContext . get ( InvokeContext . BOLT_CUSTOM_SERIALIZER ) ; \nif ( null != clientCustomSerializer ) { \ntry { \ncommand . setSerializer ( ( Byte ) clientCustomSerializer ) ; \n} \ncatch ( ClassCastException e ) { \nthrow new IllegalArgumentException ( \"Illegal custom serializer [\" + clientCustomSerializer + \"], the type of value should be [byte], but now is [\" + clientCustomSerializer . getClass ( ) . getName ( ) + \"].\" ) ; \n} \n} \nBoolean crcSwitch = invokeContext . get ( InvokeContext . BOLT_CRC_SWITCH , ProtocolSwitch . CRC_SWITCH_DEFAULT_VALUE ) ; \nif ( null != crcSwitch ) { \nif ( crcSwitch ) { \ncommand . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { \nProtocolSwitch . CRC_SWITCH_INDEX } \n) ) ; \n} \n} \n} \nelse { \ncommand . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { \nProtocolSwitch . CRC_SWITCH_INDEX } \n) ) ; \n} \ncommand . setTimeout ( timeoutMillis ) ; \ncommand . setRequestClass ( request . getClass ( ) . getName ( ) ) ; \ncommand . setInvokeContext ( invokeContext ) ; \ncommand . serialize ( ) ; \nlogDebugInfo ( command ) ; \nreturn command ; \n} \n} \n"}
{"431": "public class ScheduledDisconnectStrategy { \n@ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { \nList < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; \nList < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; \nMap < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; \nfor ( Connection connection : connections ) { \nString serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; \nif ( serviceStatus != null ) { \nif ( connection . isInvokeFutureMapFinish ( ) ) { \nif ( ! freshSelectConnections . containsValue ( connection ) ) { \nserviceOffConnections . add ( connection ) ; \n} \n} \n} \nelse { \nserviceOnConnections . add ( connection ) ; \n} \n} \nfilteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; \nfilteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; \nreturn filteredConnections ; \n} \n} \n"}
{"432": "public class ScheduledDisconnectStrategy { \n@ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { \ntry { \nif ( null != connPools ) { \nif ( ! connPools . isEmpty ( ) ) { \nIterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; \nString poolKey = entry . getKey ( ) ; \nConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; \nList < Connection > connections = pool . getAll ( ) ; \nMap < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; \nList < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; \nList < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; \nif ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { \nConnection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; \nfreshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \nfreshSelectConnections . put ( poolKey , freshSelectConnect ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nelse { \nif ( freshSelectConnections . containsKey ( poolKey ) ) { \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nif ( logger . isInfoEnabled ( ) ) { \nlogger . info ( \"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\" , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; \n} \n} \nfor ( Connection offConn : serviceOffConnections ) { \nif ( offConn . isFine ( ) ) { \noffConn . close ( ) ; \n} \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"ScheduledDisconnectStrategy monitor error\" , e ) ; \n} \n} \n} \n"}
{"436": "public class RemotingContext { \npublic boolean isRequestTimeout ( ) { \nif ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) ) { \nif ( ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"438": "public class RandomSelectStrategy { \nprivate Connection randomGet ( List < Connection > conns ) { \nif ( null == conns ) { \nreturn null ; \n} \nelse if ( conns . isEmpty ( ) ) { \nreturn null ; \n} \nint size = conns . size ( ) ; \nint tries = 0 ; \nConnection result = null ; \nwhile ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { \nresult = conns . get ( this . random . nextInt ( size ) ) ; \n} \nif ( result != null ) { \nif ( ! result . isFine ( ) ) { \nresult = null ; \n} \n} \nreturn result ; \n} \n} \n"}
{"443": "public class RpcResponseResolver { \nprivate static Throwable toThrowable ( ResponseCommand responseCommand ) throws CodecException { \nRpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; \nresp . deserialize ( ) ; \nObject ex = resp . getResponseObject ( ) ; \nif ( ex != null ) { \nif ( ex instanceof Throwable ) { \nreturn ( Throwable ) ex ; \n} \n} \nreturn null ; \n} \n} \n"}
{"467": "public class SocketChannelIOHelper { \npublic static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { \nif ( ws == null ) { \nreturn false ; \n} \nByteBuffer buffer = ws . outQueue . peek ( ) ; \nWrappedByteChannel c = null ; \nif ( buffer == null ) { \nif ( sockchannel instanceof WrappedByteChannel ) { \nc = ( WrappedByteChannel ) sockchannel ; \nif ( c . isNeedWrite ( ) ) { \nc . writeMore ( ) ; \n} \n} \n} \nelse { \ndo { \nsockchannel . write ( buffer ) ; \nif ( buffer . remaining ( ) > 0 ) { \nreturn false ; \n} \nelse { \nws . outQueue . poll ( ) ; \nbuffer = ws . outQueue . peek ( ) ; \n} \n} \nwhile ( buffer != null ) ; \n} \nif ( ws . outQueue . isEmpty ( ) && ws . isFlushAndClose ( ) && ws . getDraft ( ) != null && ws . getDraft ( ) . getRole ( ) != null ) { \nif ( ws . getDraft ( ) . getRole ( ) == Role . SERVER ) { \nws . closeConnection ( ) ; \n} \n} \nreturn c == null || ! ( ( WrappedByteChannel ) sockchannel ) . isNeedWrite ( ) ; \n} \n} \n"}
{"475": "public class Draft_6455 { \nprivate void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { \nif ( curop != Opcode . CONTINUOUS ) { \nprocessFrameIsNotFin ( frame ) ; \n} \nelse if ( frame . isFin ( ) ) { \nprocessFrameIsFin ( webSocketImpl , frame ) ; \n} \nelse if ( currentContinuousFrame == null ) { \nlog . error ( \"Protocol error: Continuous frame sequence was not started.\" ) ; \nthrow new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , \"Continuous frame sequence was not started.\" ) ; \n} \nif ( curop == Opcode . TEXT ) { \nif ( ! Charsetfunctions . isValidUTF8 ( frame . getPayloadData ( ) ) ) { \nlog . error ( \"Protocol error: Payload is not UTF8\" ) ; \nthrow new InvalidDataException ( CloseFrame . NO_UTF8 ) ; \n} \n} \nif ( curop == Opcode . CONTINUOUS ) { \nif ( currentContinuousFrame != null ) { \naddToBufferList ( frame . getPayloadData ( ) ) ; \n} \n} \n} \n} \n"}
{"487": "public class WebSocketImpl { \npublic void decode ( ByteBuffer socketBuffer ) { \nassert ( socketBuffer . hasRemaining ( ) ) ; \nlog . trace ( \"process({}): ({})\" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? \"too big to display\" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; \nif ( readyState != ReadyState . NOT_YET_CONNECTED ) { \nif ( readyState == ReadyState . OPEN ) { \ndecodeFrames ( socketBuffer ) ; \n} \n} \nelse { \nif ( decodeHandshake ( socketBuffer ) ) { \nif ( ! isClosing ( ) && ! isClosed ( ) ) { \nassert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ; \nif ( socketBuffer . hasRemaining ( ) ) { \ndecodeFrames ( socketBuffer ) ; \n} \nelse if ( tmpHandshakeBytes . hasRemaining ( ) ) { \ndecodeFrames ( tmpHandshakeBytes ) ; \n} \n} \n} \n} \n} \n} \n"}
{"492": "public class WebSocketClient { \nprivate void reset ( ) { \nThread current = Thread . currentThread ( ) ; \nif ( current == writeThread ) { \nthrow new IllegalStateException ( \"You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup.\" ) ; \n} \nelse if ( current == connectReadThread ) { \nthrow new IllegalStateException ( \"You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup.\" ) ; \n} \ntry { \ncloseBlocking ( ) ; \nif ( writeThread != null ) { \nthis . writeThread . interrupt ( ) ; \nthis . writeThread = null ; \n} \nif ( connectReadThread != null ) { \nthis . connectReadThread . interrupt ( ) ; \nthis . connectReadThread = null ; \n} \nthis . draft . reset ( ) ; \nif ( this . socket != null ) { \nthis . socket . close ( ) ; \nthis . socket = null ; \n} \n} \ncatch ( Exception e ) { \nonError ( e ) ; \nengine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; \nreturn ; \n} \nconnectLatch = new CountDownLatch ( 1 ) ; \ncloseLatch = new CountDownLatch ( 1 ) ; \nthis . engine = new WebSocketImpl ( this , this . draft ) ; \n} \n} \n"}
{"497": "public class AbstractWebSocket { \nprotected void stopConnectionLostTimer ( ) { \nsynchronized ( syncConnectionLost ) { \nif ( connectionLostCheckerService != null ) { \nthis . websocketRunning = false ; \nlog . trace ( \"Connection lost timer stopped\" ) ; \ncancelConnectionLostTimer ( ) ; \n} \nelse if ( connectionLostCheckerFuture != null ) { \nthis . websocketRunning = false ; \nlog . trace ( \"Connection lost timer stopped\" ) ; \ncancelConnectionLostTimer ( ) ; \n} \n} \n} \n} \n"}
{"504": "public class WebSocketServer { \npublic void stop ( int timeout ) throws InterruptedException { \nif ( ! isclosed . compareAndSet ( false , true ) ) { \nreturn ; \n} \nList < WebSocket > socketsToClose ; \nsynchronized ( connections ) { \nsocketsToClose = new ArrayList < WebSocket > ( connections ) ; \n} \nfor ( WebSocket ws : socketsToClose ) { \nws . close ( CloseFrame . GOING_AWAY ) ; \n} \nwsf . close ( ) ; \nsynchronized ( this ) { \nif ( selectorthread != null ) { \nif ( selector != null ) { \nselector . wakeup ( ) ; \nselectorthread . join ( timeout ) ; \n} \n} \n} \n} \n} \n"}
{"505": "public class WebSocketServer { \npublic int getPort ( ) { \nint port = getAddress ( ) . getPort ( ) ; \nif ( port == 0 ) { \nif ( server != null ) { \nport = server . socket ( ) . getLocalPort ( ) ; \n} \n} \nreturn port ; \n} \n} \n"}
{"508": "public class WebSocketServer { \nprivate boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { \nWebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; \nByteBuffer buf = takeBuffer ( ) ; \nif ( conn . getChannel ( ) == null ) { \nkey . cancel ( ) ; \nhandleIOException ( key , conn , new IOException ( ) ) ; \nreturn false ; \n} \ntry { \nif ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { \nif ( buf . hasRemaining ( ) ) { \nconn . inQueue . put ( buf ) ; \nqueue ( conn ) ; \ni . remove ( ) ; \nif ( conn . getChannel ( ) instanceof WrappedByteChannel ) { \nif ( ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { \niqueue . add ( conn ) ; \n} \n} \n} \nelse { \npushBuffer ( buf ) ; \n} \n} \nelse { \npushBuffer ( buf ) ; \n} \n} \ncatch ( IOException e ) { \npushBuffer ( buf ) ; \nthrow e ; \n} \nreturn true ; \n} \n} \n"}
{"514": "public class WebSocketServer { \npublic void broadcast ( byte [ ] data , Collection < WebSocket > clients ) { \nif ( data == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nelse if ( clients == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nbroadcast ( ByteBuffer . wrap ( data ) , clients ) ; \n} \n} \n"}
{"515": "public class WebSocketServer { \npublic void broadcast ( String text , Collection < WebSocket > clients ) { \nif ( text == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nelse if ( clients == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \ndoBroadcast ( text , clients ) ; \n} \n} \n"}
{"516": "public class WebSocketServer { \nprivate void doBroadcast ( Object data , Collection < WebSocket > clients ) { \nString sData = null ; \nif ( data instanceof String ) { \nsData = ( String ) data ; \n} \nByteBuffer bData = null ; \nif ( data instanceof ByteBuffer ) { \nbData = ( ByteBuffer ) data ; \n} \nif ( sData == null ) { \nif ( bData == null ) { \nreturn ; \n} \n} \nMap < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; \nfor ( WebSocket client : clients ) { \nif ( client != null ) { \nDraft draft = client . getDraft ( ) ; \nfillFrames ( draft , draftFrames , sData , bData ) ; \ntry { \nclient . sendFrame ( draftFrames . get ( draft ) ) ; \n} \ncatch ( WebsocketNotConnectedException e ) { \n} \n} \n} \n} \n} \n"}
{"518": "public class ByteBufferUtils { \npublic static int transferByteBuffer ( ByteBuffer source , ByteBuffer dest ) { \nif ( source == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nelse if ( dest == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nint fremain = source . remaining ( ) ; \nint toremain = dest . remaining ( ) ; \nif ( fremain > toremain ) { \nint limit = Math . min ( fremain , toremain ) ; \nsource . limit ( limit ) ; \ndest . put ( source ) ; \nreturn limit ; \n} \nelse { \ndest . put ( source ) ; \nreturn fremain ; \n} \n} \n} \n"}
{"551": "public class MethodUtils { \npublic static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { \ntry { \nfinal Method method = cls . getMethod ( methodName , parameterTypes ) ; \nMemberUtils . setAccessibleWorkaround ( method ) ; \nreturn method ; \n} \ncatch ( final NoSuchMethodException e ) { \n} \nMethod bestMatch = null ; \nfinal Method [ ] methods = cls . getMethods ( ) ; \nfor ( final Method method : methods ) { \nif ( method . getName ( ) . equals ( methodName ) ) { \nif ( MemberUtils . isMatchingMethod ( method , parameterTypes ) ) { \nfinal Method accessibleMethod = getAccessibleMethod ( method ) ; \nif ( accessibleMethod != null ) { \nif ( bestMatch == null || MemberUtils . compareMethodFit ( accessibleMethod , bestMatch , parameterTypes ) < 0 ) { \nbestMatch = accessibleMethod ; \n} \n} \n} \n} \n} \nif ( bestMatch != null ) { \nMemberUtils . setAccessibleWorkaround ( bestMatch ) ; \n} \nif ( bestMatch != null && bestMatch . isVarArgs ( ) && bestMatch . getParameterTypes ( ) . length > 0 ) { \nif ( parameterTypes . length > 0 ) { \nfinal Class < ? > [ ] methodParameterTypes = bestMatch . getParameterTypes ( ) ; \nfinal Class < ? > methodParameterComponentType = methodParameterTypes [ methodParameterTypes . length - 1 ] . getComponentType ( ) ; \nfinal String methodParameterComponentTypeName = ClassUtils . primitiveToWrapper ( methodParameterComponentType ) . getName ( ) ; \nfinal String parameterTypeName = parameterTypes [ parameterTypes . length - 1 ] . getName ( ) ; \nfinal String parameterTypeSuperClassName = parameterTypes [ parameterTypes . length - 1 ] . getSuperclass ( ) . getName ( ) ; \nif ( ! methodParameterComponentTypeName . equals ( parameterTypeName ) ) { \nif ( ! methodParameterComponentTypeName . equals ( parameterTypeSuperClassName ) ) { \nreturn null ; \n} \n} \n} \n} \nreturn bestMatch ; \n} \n} \n"}
{"589": "public class Paths { \npublic static String canonical ( String url ) { \nString [ ] urlPath = toSegments ( url ) ; \nStack < String > canonical = new Stack < > ( ) ; \nfor ( String comp : urlPath ) { \nif ( comp . isEmpty ( ) ) continue ; \nelse if ( comp . equals ( CURRENT_DIR ) ) continue ; \nif ( ! comp . equals ( PARENT_DIR ) || ( ! canonical . empty ( ) && canonical . peek ( ) . equals ( PARENT_DIR ) ) ) canonical . push ( comp ) ; \nelse canonical . pop ( ) ; \n} \nString prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : \"\" ; \nString trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : \"\" ; \nreturn prefixSep + canonical . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; \n} \n} \n"}
{"648": "public class MemberUtils { \nstatic boolean setAccessibleWorkaround ( final AccessibleObject o ) { \nif ( o == null ) { \nreturn false ; \n} \nelse if ( o . isAccessible ( ) ) { \nreturn false ; \n} \nfinal Member m = ( Member ) o ; \nif ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) ) { \nif ( isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { \ntry { \no . setAccessible ( true ) ; \nreturn true ; \n} \ncatch ( final SecurityException e ) { \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"651": "public class MemberUtils { \nprivate static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { \nif ( destClass . isPrimitive ( ) ) { \nreturn getPrimitivePromotionCost ( srcClass , destClass ) ; \n} \nfloat cost = 0.0f ; \nwhile ( srcClass != null && ! destClass . equals ( srcClass ) ) { \nif ( destClass . isInterface ( ) ) { \nif ( ClassUtils . isAssignable ( srcClass , destClass ) ) { \ncost += 0.25f ; \nbreak ; \n} \n} \ncost ++ ; \nsrcClass = srcClass . getSuperclass ( ) ; \n} \nif ( srcClass == null ) { \ncost += 1.5f ; \n} \nreturn cost ; \n} \n} \n"}
{"669": "public class BeanGenerator { \npublic void setSuperclass ( Class superclass ) { \nif ( superclass != null ) { \nif ( superclass . equals ( Object . class ) ) { \nsuperclass = null ; \n} \n} \nthis . superclass = superclass ; \n} \n} \n"}
{"689": "public class HttpRequest { \npublic HttpRequest cookies ( final Cookie ... cookies ) { \nif ( cookies . length == 0 ) { \nreturn this ; \n} \nStringBuilder cookieString = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( Cookie cookie : cookies ) { \nInteger maxAge = cookie . getMaxAge ( ) ; \nif ( maxAge != null ) { \nif ( maxAge . intValue ( ) == 0 ) { \ncontinue ; \n} \n} \nif ( ! first ) { \ncookieString . append ( \"; \" ) ; \n} \nfirst = false ; \ncookieString . append ( cookie . getName ( ) ) ; \ncookieString . append ( '=' ) ; \ncookieString . append ( cookie . getValue ( ) ) ; \n} \nheaderOverwrite ( \"cookie\" , cookieString . toString ( ) ) ; \nreturn this ; \n} \n} \n"}
{"695": "public class HttpRequest { \npublic HttpRequest basicAuthentication ( final String username , final String password ) { \nif ( username != null ) { \nif ( password != null ) { \nString data = username . concat ( StringPool . COLON ) . concat ( password ) ; \nString base64 = Base64 . encodeToString ( data ) ; \nheaderOverwrite ( HEADER_AUTHORIZATION , \"Basic \" + base64 ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"697": "public class HttpRequest { \n@ Override protected Buffer buffer ( final boolean fullRequest ) { \nif ( header ( HEADER_HOST ) == null ) { \nsetHostHeader ( ) ; \n} \nBuffer formBuffer = formBuffer ( ) ; \nString queryString = queryString ( ) ; \nif ( header ( \"User-Agent\" ) == null ) { \nheader ( \"User-Agent\" , Defaults . userAgent ) ; \n} \nif ( method . equals ( \"POST\" ) ) { \nif ( contentLength ( ) == null ) { \ncontentLength ( 0 ) ; \n} \n} \nBuffer request = new Buffer ( ) ; \nrequest . append ( method ) . append ( SPACE ) . append ( path ) ; \nif ( query != null ) { \nif ( ! query . isEmpty ( ) ) { \nrequest . append ( '?' ) ; \nrequest . append ( queryString ) ; \n} \n} \nrequest . append ( SPACE ) . append ( httpVersion ) . append ( CRLF ) ; \npopulateHeaderAndBody ( request , formBuffer , fullRequest ) ; \nreturn request ; \n} \n} \n"}
{"699": "public class Handler { \nstatic Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { \nif ( firstHandler == null ) { \nreturn null ; \n} \nelse { \nfirstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; \n} \nint handlerStart = firstHandler . startPc . bytecodeOffset ; \nint handlerEnd = firstHandler . endPc . bytecodeOffset ; \nint rangeStart = start . bytecodeOffset ; \nint rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; \nif ( rangeStart >= handlerEnd ) { \nreturn firstHandler ; \n} \nelse if ( rangeEnd <= handlerStart ) { \nreturn firstHandler ; \n} \nif ( rangeStart <= handlerStart ) { \nif ( rangeEnd >= handlerEnd ) { \nreturn firstHandler . nextHandler ; \n} \nelse { \nreturn new Handler ( firstHandler , end , firstHandler . endPc ) ; \n} \n} \nelse if ( rangeEnd >= handlerEnd ) { \nreturn new Handler ( firstHandler , firstHandler . startPc , start ) ; \n} \nelse { \nfirstHandler . nextHandler = new Handler ( firstHandler , end , firstHandler . endPc ) ; \nreturn new Handler ( firstHandler , firstHandler . startPc , start ) ; \n} \n} \n} \n"}
{"721": "public class RequestScope { \nprotected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { \nif ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { \nreturn ; \n} \nfinal MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; \nif ( ! multipartRequest . isMultipart ( ) ) { \nreturn ; \n} \nfinal Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nfinal FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; \nif ( ignoreInvalidUploadFiles ) { \nfor ( int j = 0 ; \nj < paramValues . length ; \nj ++ ) { \nfinal FileUpload paramValue = paramValues [ j ] ; \nif ( ! paramValue . isValid ( ) ) { \nparamValues [ j ] = null ; \n} \nelse if ( ! paramValue . isUploaded ( ) ) { \nparamValues [ j ] = null ; \n} \n} \n} \nfinal Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"731": "public class FileNameUtil { \nprivate static String doGetPath ( final String filename , final int separatorAdd ) { \nif ( filename == null ) { \nreturn null ; \n} \nint prefix = getPrefixLength ( filename ) ; \nif ( prefix < 0 ) { \nreturn null ; \n} \nint index = indexOfLastSeparator ( filename ) ; \nint endIndex = index + separatorAdd ; \nif ( prefix >= filename . length ( ) || index < 0 ) { \nreturn StringPool . EMPTY ; \n} \nelse if ( prefix >= endIndex ) { \nreturn StringPool . EMPTY ; \n} \nreturn filename . substring ( prefix , endIndex ) ; \n} \n} \n"}
{"752": "public class Base64 { \npublic static byte [ ] decode ( final char [ ] arr ) { \nint length = arr . length ; \nif ( length == 0 ) { \nreturn new byte [ 0 ] ; \n} \nint sndx = 0 , endx = length - 1 ; \nint pad = arr [ endx ] == '=' ? ( arr [ endx - 1 ] == '=' ? 2 : 1 ) : 0 ; \nint cnt = endx - sndx + 1 ; \nint sepCnt = length > 76 ? ( arr [ 76 ] == '\\r' ? cnt / 78 : 0 ) << 1 : 0 ; \nint len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; \nbyte [ ] dest = new byte [ len ] ; \nint d = 0 ; \nfor ( int cc = 0 , eLen = ( len / 3 ) * 3 ; \nd < eLen ; \n) { \nint i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; \ndest [ d ++ ] = ( byte ) ( i >> 16 ) ; \ndest [ d ++ ] = ( byte ) ( i >> 8 ) ; \ndest [ d ++ ] = ( byte ) i ; \nif ( sepCnt > 0 ) { \nif ( ++ cc == 19 ) { \nsndx += 2 ; \ncc = 0 ; \n} \n} \n} \nif ( d < len ) { \nint i = 0 ; \nfor ( int j = 0 ; \nsndx <= endx - pad ; \nj ++ ) { \ni |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; \n} \nfor ( int r = 16 ; \nd < len ; \nr -= 8 ) { \ndest [ d ++ ] = ( byte ) ( i >> r ) ; \n} \n} \nreturn dest ; \n} \n} \n"}
{"754": "public class CsrfShield { \nprotected static void assureSize ( final Set < Token > tokenSet ) { \nif ( tokenSet . size ( ) < maxTokensPerSession ) { \nreturn ; \n} \nlong validUntilMin = Long . MAX_VALUE ; \nToken tokenToRemove = null ; \nIterator < Token > iterator = tokenSet . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nToken token = iterator . next ( ) ; \nif ( token . isExpired ( ) ) { \niterator . remove ( ) ; \ncontinue ; \n} \nif ( token . validUntil < validUntilMin ) { \nvalidUntilMin = token . validUntil ; \ntokenToRemove = token ; \n} \n} \nif ( tokenToRemove != null ) { \nif ( tokenSet . size ( ) >= maxTokensPerSession ) { \ntokenSet . remove ( tokenToRemove ) ; \n} \n} \n} \n} \n"}
{"755": "public class CsrfShield { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { \nSet < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; \nif ( tokenSet == null ) { \nif ( tokenValue == null ) { \nreturn true ; \n} \n} \nif ( tokenSet == null ) { \nreturn false ; \n} \nelse if ( tokenValue == null ) { \nreturn false ; \n} \nboolean found = false ; \nIterator < Token > it = tokenSet . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nToken t = it . next ( ) ; \nif ( t . isExpired ( ) ) { \nit . remove ( ) ; \ncontinue ; \n} \nif ( t . getValue ( ) . equals ( tokenValue ) ) { \nit . remove ( ) ; \nfound = true ; \n} \n} \nreturn found ; \n} \n} \n"}
{"765": "public class PetiteBeans { \npublic void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nConstructor constructor = null ; \nif ( paramTypes == null ) { \nCtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; \nif ( ctors != null ) { \nif ( ctors . length > 0 ) { \nif ( ctors . length > 1 ) { \nthrow new PetiteException ( ctors . length + \" suitable constructor found as injection point for: \" + beanDefinition . type . getName ( ) ) ; \n} \nconstructor = ctors [ 0 ] . getConstructor ( ) ; \n} \n} \n} \nelse { \nCtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , true ) ; \nif ( ctorDescriptor != null ) { \nconstructor = ctorDescriptor . getConstructor ( ) ; \n} \n} \nif ( constructor == null ) { \nthrow new PetiteException ( \"Constructor not found: \" + beanDefinition . type . getName ( ) ) ; \n} \nBeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; \nbeanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; \n} \n} \n"}
{"768": "public class PetiteBeans { \npublic void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nMethod method = null ; \nif ( arguments == null ) { \nMethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; \nif ( methods != null ) { \nif ( methods . length > 0 ) { \nif ( methods . length > 1 ) { \nthrow new PetiteException ( methods . length + \" suitable methods found as injection points for: \" + beanDefinition . type . getName ( ) + '#' + methodName ) ; \n} \nmethod = methods [ 0 ] . getMethod ( ) ; \n} \n} \n} \nelse { \nMethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; \nif ( md != null ) { \nmethod = md . getMethod ( ) ; \n} \n} \nif ( method == null ) { \nthrow new PetiteException ( \"Method not found: \" + beanDefinition . type . getName ( ) + '#' + methodName ) ; \n} \nBeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; \nMethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; \nbeanDefinition . addMethodInjectionPoint ( mip ) ; \n} \n} \n"}
{"778": "public class ProxettaAsmUtil { \npublic static void checkArgumentIndex ( final MethodInfo methodInfo , final int argIndex ) { \nif ( argIndex < 1 ) { \nthrow new ProxettaException ( \"Invalid argument index: \" + argIndex ) ; \n} \nelse if ( argIndex > methodInfo . getArgumentsCount ( ) ) { \nthrow new ProxettaException ( \"Invalid argument index: \" + argIndex ) ; \n} \n} \n} \n"}
{"791": "public class EmailUtil { \npublic static boolean isEmptyFlags ( Flags flags ) { \nif ( flags == null ) return true ; \nFlags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; \nif ( systemFlags != null ) { \nif ( systemFlags . length > 0 ) { \nreturn false ; \n} \n} \nString [ ] userFlags = flags . getUserFlags ( ) ; \nif ( userFlags != null ) { \nif ( userFlags . length > 0 ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"795": "public class ServletUtil { \npublic static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { \nif ( mimeType == null ) { \nif ( fileName != null ) { \nString extension = FileNameUtil . getExtension ( fileName ) ; \nmimeType = MimeTypes . getMimeType ( extension ) ; \n} \n} \nif ( mimeType != null ) { \nresponse . setContentType ( mimeType ) ; \n} \nif ( fileSize >= 0 ) { \nresponse . setContentLength ( fileSize ) ; \n} \nif ( fileName != null ) { \nString name = FileNameUtil . getName ( fileName ) ; \nString encodedFileName = URLCoder . encode ( name ) ; \nresponse . setHeader ( CONTENT_DISPOSITION , \"attachment;filename=\\\"\" + name + \"\\\";filename*=utf8''\" + encodedFileName ) ; \n} \n} \n} \n"}
{"802": "public class ServletUtil { \npublic static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { \nif ( treatEmptyParamsAsNull ) { \nint emptyCount = 0 ; \nint total = paramValues . length ; \nfor ( int i = 0 ; \ni < paramValues . length ; \ni ++ ) { \nString paramValue = paramValues [ i ] ; \nif ( paramValue == null ) { \nemptyCount ++ ; \ncontinue ; \n} \nif ( paramValue . length ( ) == 0 ) { \nemptyCount ++ ; \nif ( treatEmptyParamsAsNull ) { \nparamValue = null ; \n} \n} \nparamValues [ i ] = paramValue ; \n} \nif ( ignoreEmptyRequestParams ) { \nif ( emptyCount == total ) { \nreturn null ; \n} \n} \n} \nelse if ( ignoreEmptyRequestParams ) { \nint emptyCount = 0 ; \nint total = paramValues . length ; \nfor ( int i = 0 ; \ni < paramValues . length ; \ni ++ ) { \nString paramValue = paramValues [ i ] ; \nif ( paramValue == null ) { \nemptyCount ++ ; \ncontinue ; \n} \nif ( paramValue . length ( ) == 0 ) { \nemptyCount ++ ; \nif ( treatEmptyParamsAsNull ) { \nparamValue = null ; \n} \n} \nparamValues [ i ] = paramValue ; \n} \nif ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { \nreturn null ; \n} \n} \nreturn paramValues ; \n} \n} \n"}
{"813": "public class PropsData { \nprotected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { \nString realValue = value ; \nif ( append ) { \nPropsEntry pv = map . get ( key ) ; \nif ( pv != null ) { \nrealValue = pv . value + APPEND_SEPARATOR + realValue ; \n} \n} \nelse if ( appendDuplicateProps ) { \nPropsEntry pv = map . get ( key ) ; \nif ( pv != null ) { \nrealValue = pv . value + APPEND_SEPARATOR + realValue ; \n} \n} \nPropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ; \nif ( first == null ) { \nfirst = propsEntry ; \n} \nelse { \nlast . next = propsEntry ; \n} \nlast = propsEntry ; \nmap . put ( key , propsEntry ) ; \n} \n} \n"}
{"820": "public class BCrypt { \npublic static String hashpw ( String password , String salt ) { \nBCrypt B ; \nString real_salt ; \nbyte [ ] passwordb , saltb , hashed ; \nchar minor = ( char ) 0 ; \nint rounds , off ; \nStringBuffer rs = new StringBuffer ( ) ; \nif ( salt . charAt ( 0 ) != '$' ) { \nthrow new IllegalArgumentException ( \"Invalid salt version\" ) ; \n} \nelse if ( salt . charAt ( 1 ) != '2' ) { \nthrow new IllegalArgumentException ( \"Invalid salt version\" ) ; \n} \nif ( salt . charAt ( 2 ) == '$' ) { \noff = 3 ; \n} \nelse { \nminor = salt . charAt ( 2 ) ; \nif ( minor != 'a' ) { \nthrow new IllegalArgumentException ( \"Invalid salt revision\" ) ; \n} \nelse if ( salt . charAt ( 3 ) != '$' ) { \nthrow new IllegalArgumentException ( \"Invalid salt revision\" ) ; \n} \noff = 4 ; \n} \nif ( salt . charAt ( off + 2 ) > '$' ) { \nthrow new IllegalArgumentException ( \"Missing salt rounds\" ) ; \n} \nrounds = Integer . parseInt ( salt . substring ( off , off + 2 ) ) ; \nreal_salt = salt . substring ( off + 3 , off + 25 ) ; \ntry { \npasswordb = ( password + ( minor >= 'a' ? \"\\000\" : \"\" ) ) . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \nthrow new AssertionError ( \"UTF-8 is not supported\" ) ; \n} \nsaltb = decode_base64 ( real_salt , BCRYPT_SALT_LEN ) ; \nB = new BCrypt ( ) ; \nhashed = B . crypt_raw ( passwordb , saltb , rounds , ( int [ ] ) bf_crypt_ciphertext . clone ( ) ) ; \nrs . append ( \"$2\" ) ; \nif ( minor >= 'a' ) { \nrs . append ( minor ) ; \n} \nrs . append ( '$' ) ; \nif ( rounds < 10 ) { \nrs . append ( '0' ) ; \n} \nif ( rounds > 30 ) { \nthrow new IllegalArgumentException ( \"rounds exceeds maximum (30)\" ) ; \n} \nrs . append ( rounds ) . append ( '$' ) . append ( encode_base64 ( saltb , saltb . length ) ) . append ( encode_base64 ( hashed , bf_crypt_ciphertext . length * 4 - 1 ) ) ; \nreturn rs . toString ( ) ; \n} \n} \n"}
{"833": "public class DecoraResponseWrapper { \n@ Override protected void preResponseCommit ( ) { \nlong lastModified = lastModifiedData . getLastModified ( ) ; \nlong ifModifiedSince = request . getDateHeader ( \"If-Modified-Since\" ) ; \nif ( lastModified > - 1 ) { \nif ( ! response . containsHeader ( \"Last-Modified\" ) ) { \nif ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { \nresponse . setDateHeader ( \"Last-Modified\" , lastModified ) ; \n} \nelse { \nresponse . reset ( ) ; \nresponse . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; \n} \n} \n} \n} \n} \n"}
{"851": "public class SymbolTable { \nprivate Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { \nint hashCode = hash ( tag , owner , name , descriptor ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) ) { \nif ( entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; \n} \n} \n"}
{"853": "public class SymbolTable { \nprivate Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode ) { \nif ( entry . data == value ) { \nreturn entry ; \n} \n} \nentry = entry . next ; \n} \nconstantPool . putByte ( tag ) . putInt ( value ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; \n} \n} \n"}
{"855": "public class SymbolTable { \nprivate Symbol addConstantLongOrDouble ( final int tag , final long value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode ) { \nif ( entry . data == value ) { \nreturn entry ; \n} \n} \nentry = entry . next ; \n} \nint index = constantPoolCount ; \nconstantPool . putByte ( tag ) . putLong ( value ) ; \nconstantPoolCount += 2 ; \nreturn put ( new Entry ( index , tag , value , hashCode ) ) ; \n} \n} \n"}
{"857": "public class SymbolTable { \nint addConstantNameAndType ( final String name , final String descriptor ) { \nfinal int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; \nint hashCode = hash ( tag , name , descriptor ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) ) { \nif ( entry . value . equals ( descriptor ) ) { \nreturn entry . index ; \n} \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; \n} \n} \n"}
{"859": "public class SymbolTable { \nint addConstantUtf8 ( final String value ) { \nint hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode ) { \nif ( entry . value . equals ( value ) ) { \nreturn entry . index ; \n} \n} \nentry = entry . next ; \n} \nconstantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; \nreturn put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; \n} \n} \n"}
{"861": "public class SymbolTable { \nSymbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { \nfinal int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; \nint hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) ) { \nif ( entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \n} \nentry = entry . next ; \n} \nif ( referenceKind <= Opcodes . H_PUTSTATIC ) { \nconstantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; \n} \nelse { \nconstantPool . put112 ( tag , referenceKind , addConstantMethodref ( owner , name , descriptor , isInterface ) . index ) ; \n} \nreturn put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; \n} \n} \n"}
{"865": "public class SymbolTable { \nprivate Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { \nint hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) ) { \nif ( entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; \n} \n} \n"}
{"867": "public class SymbolTable { \nprivate Symbol addConstantUtf8Reference ( final int tag , final String value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode ) { \nif ( entry . value . equals ( value ) ) { \nreturn entry ; \n} \n} \nentry = entry . next ; \n} \nconstantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; \nreturn put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; \n} \n} \n"}
{"870": "public class SymbolTable { \nint addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) { \nlong data = typeTableIndex1 | ( ( ( long ) typeTableIndex2 ) << 32 ) ; \nint hashCode = hash ( Symbol . MERGED_TYPE_TAG , typeTableIndex1 + typeTableIndex2 ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == Symbol . MERGED_TYPE_TAG && entry . hashCode == hashCode ) { \nif ( entry . data == data ) { \nreturn entry . info ; \n} \n} \nentry = entry . next ; \n} \nString type1 = typeTable [ typeTableIndex1 ] . value ; \nString type2 = typeTable [ typeTableIndex2 ] . value ; \nint commonSuperTypeIndex = addType ( classWriter . getCommonSuperClass ( type1 , type2 ) ) ; \nput ( new Entry ( typeCount , Symbol . MERGED_TYPE_TAG , data , hashCode ) ) . info = commonSuperTypeIndex ; \nreturn commonSuperTypeIndex ; \n} \n} \n"}
{"871": "public class HttpMultiMap { \nprivate int hash ( final String name ) { \nint h = 0 ; \nfor ( int i = name . length ( ) - 1 ; \ni >= 0 ; \ni -- ) { \nchar c = name . charAt ( i ) ; \nif ( ! caseSensitive ) { \nif ( c >= 'A' ) { \nif ( c <= 'Z' ) { \nc += 32 ; \n} \n} \n} \nh = 31 * h + c ; \n} \nif ( h > 0 ) { \nreturn h ; \n} \nif ( h == Integer . MIN_VALUE ) { \nreturn Integer . MAX_VALUE ; \n} \nreturn - h ; \n} \n} \n"}
{"873": "public class HttpMultiMap { \npublic List < V > getAll ( final String name ) { \nLinkedList < V > values = new LinkedList < > ( ) ; \nint h = hash ( name ) ; \nint i = index ( h ) ; \nMapEntry < V > e = entries [ i ] ; \nwhile ( e != null ) { \nif ( e . hash == h ) { \nif ( eq ( name , e . key ) ) { \nvalues . addFirst ( e . getValue ( ) ) ; \n} \n} \ne = e . next ; \n} \nreturn values ; \n} \n} \n"}
{"903": "public class ReceiveMailSession { \nReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { \nuseAndOpenFolderIfNotSet ( ) ; \nfinal Message [ ] messages ; \ntry { \nif ( filter == null ) { \nmessages = folder . getMessages ( ) ; \n} \nelse { \nmessages = folder . search ( filter . getSearchTerm ( ) ) ; \n} \nif ( messages . length == 0 ) { \nreturn ReceivedEmail . EMPTY_ARRAY ; \n} \nif ( envelope ) { \nfinal FetchProfile fetchProfile = new FetchProfile ( ) ; \nfetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; \nfetchProfile . add ( FetchProfile . Item . FLAGS ) ; \nfolder . fetch ( messages , fetchProfile ) ; \n} \nfinal ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; \nfor ( int i = 0 ; \ni < messages . length ; \ni ++ ) { \nfinal Message msg = messages [ i ] ; \nemails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nemails [ i ] . flags ( flagsToSet ) ; \nmsg . setFlags ( flagsToSet , true ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { \nemails [ i ] . flags ( ) . remove ( flagsToUnset ) ; \nmsg . setFlags ( flagsToUnset , false ) ; \n} \nif ( EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nif ( ! emails [ i ] . isSeen ( ) ) { \nmsg . setFlag ( Flags . Flag . SEEN , false ) ; \n} \n} \n} \nif ( processedMessageConsumer != null ) { \nprocessedMessageConsumer . accept ( messages ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nif ( flagsToSet . contains ( Flags . Flag . DELETED ) ) { \nfolder . expunge ( ) ; \n} \n} \nreturn emails ; \n} \ncatch ( final MessagingException msgexc ) { \nthrow new MailException ( \"Failed to fetch messages\" , msgexc ) ; \n} \n} \n} \n"}
{"916": "public class ProxettaFactory { \npublic byte [ ] create ( ) { \nprocess ( ) ; \nbyte [ ] result = toByteArray ( ) ; \ndumpClassInDebugFolder ( result ) ; \nif ( ! proxetta . isForced ( ) ) { \nif ( ! isProxyApplied ( ) ) { \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Proxy not applied: \" + StringUtil . toSafeString ( targetClassName ) ) ; \n} \nreturn null ; \n} \n} \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Proxy created \" + StringUtil . toSafeString ( targetClassName ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"917": "public class ProxettaFactory { \npublic Class define ( ) { \nprocess ( ) ; \nif ( ! proxetta . isForced ( ) ) { \nif ( ! isProxyApplied ( ) ) { \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Proxy not applied: \" + StringUtil . toSafeString ( targetClassName ) ) ; \n} \nif ( targetClass != null ) { \nreturn targetClass ; \n} \nif ( targetClassName != null ) { \ntry { \nreturn ClassLoaderUtil . loadClass ( targetClassName ) ; \n} \ncatch ( ClassNotFoundException cnfex ) { \nthrow new ProxettaException ( cnfex ) ; \n} \n} \n} \n} \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Proxy created: \" + StringUtil . toSafeString ( targetClassName ) ) ; \n} \ntry { \nClassLoader classLoader = proxetta . getClassLoader ( ) ; \nif ( classLoader == null ) { \nclassLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; \nif ( classLoader == null ) { \nif ( targetClass != null ) { \nclassLoader = targetClass . getClassLoader ( ) ; \n} \n} \n} \nfinal byte [ ] bytes = toByteArray ( ) ; \ndumpClassInDebugFolder ( bytes ) ; \nreturn DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; \n} \ncatch ( Exception ex ) { \nthrow new ProxettaException ( \"Class definition failed\" , ex ) ; \n} \n} \n} \n"}
{"919": "public class ProxettaFactory { \nprotected void dumpClassInDebugFolder ( final byte [ ] bytes ) { \nFile debugFolder = proxetta . getDebugFolder ( ) ; \nif ( debugFolder == null ) { \nreturn ; \n} \nif ( ! debugFolder . exists ( ) ) { \nlog . warn ( \"Invalid debug folder: \" + debugFolder ) ; \n} \nelse if ( ! debugFolder . isDirectory ( ) ) { \nlog . warn ( \"Invalid debug folder: \" + debugFolder ) ; \n} \nString fileName = proxyClassName ; \nif ( fileName == null ) { \nfileName = \"proxetta-\" + System . currentTimeMillis ( ) ; \n} \nfileName += \".class\" ; \nFile file = new File ( debugFolder , fileName ) ; \ntry { \nFileUtil . writeBytes ( file , bytes ) ; \n} \ncatch ( IOException ioex ) { \nlog . warn ( \"Error writing class as \" + file , ioex ) ; \n} \n} \n} \n"}
{"933": "public class KeyValueJsonSerializer { \nprotected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { \nif ( value == null ) { \nif ( jsonContext . isExcludeNulls ( ) ) { \nreturn count ; \n} \n} \nif ( key != null ) { \ncurrentPath . push ( key . toString ( ) ) ; \n} \nelse { \ncurrentPath . push ( StringPool . NULL ) ; \n} \nboolean include = true ; \nif ( value != null ) { \ninclude = jsonContext . matchIgnoredPropertyTypes ( value . getClass ( ) , false , include ) ; \ninclude = jsonContext . matchPathToQueries ( include ) ; \n} \nif ( ! include ) { \ncurrentPath . pop ( ) ; \nreturn count ; \n} \nif ( key == null ) { \njsonContext . pushName ( null , count > 0 ) ; \n} \nelse { \njsonContext . pushName ( key . toString ( ) , count > 0 ) ; \n} \njsonContext . serialize ( value ) ; \nif ( jsonContext . isNamePopped ( ) ) { \ncount ++ ; \n} \ncurrentPath . pop ( ) ; \nreturn count ; \n} \n} \n"}
{"942": "public class DbMetaUtil { \npublic static String resolveSchemaName ( final Class < ? > type , final String defaultSchemaName ) { \nString schemaName = null ; \nfinal DbTable dbTable = type . getAnnotation ( DbTable . class ) ; \nif ( dbTable != null ) { \nschemaName = dbTable . schema ( ) . trim ( ) ; \n} \nif ( schemaName == null ) { \nschemaName = defaultSchemaName ; \n} \nelse if ( schemaName . length ( ) == 0 ) { \nschemaName = defaultSchemaName ; \n} \nreturn schemaName ; \n} \n} \n"}
{"943": "public class DbMetaUtil { \npublic static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { \nString columnName = null ; \nboolean isId = false ; \nClass < ? extends SqlType > sqlTypeClass = null ; \nDbId dbId = null ; \nif ( property . getFieldDescriptor ( ) != null ) { \ndbId = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbId . class ) ; \n} \nif ( dbId == null ) { \nif ( property . getReadMethodDescriptor ( ) != null ) { \ndbId = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; \n} \n} \nif ( dbId == null ) { \nif ( property . getWriteMethodDescriptor ( ) != null ) { \ndbId = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; \n} \n} \nif ( dbId != null ) { \ncolumnName = dbId . value ( ) . trim ( ) ; \nsqlTypeClass = dbId . sqlType ( ) ; \nisId = true ; \n} \nelse { \nDbColumn dbColumn = null ; \nif ( property . getFieldDescriptor ( ) != null ) { \ndbColumn = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbColumn . class ) ; \n} \nif ( dbColumn == null ) { \nif ( property . getReadMethodDescriptor ( ) != null ) { \ndbColumn = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; \n} \n} \nif ( dbColumn == null ) { \nif ( property . getWriteMethodDescriptor ( ) != null ) { \ndbColumn = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; \n} \n} \nif ( dbColumn != null ) { \ncolumnName = dbColumn . value ( ) . trim ( ) ; \nsqlTypeClass = dbColumn . sqlType ( ) ; \n} \nelse { \nif ( isAnnotated ) { \nreturn null ; \n} \n} \n} \nif ( StringUtil . isEmpty ( columnName ) ) { \ncolumnName = columnNamingStrategy . convertPropertyNameToColumnName ( property . getName ( ) ) ; \n} \nelse { \nif ( ! columnNamingStrategy . isStrictAnnotationNames ( ) ) { \ncolumnName = columnNamingStrategy . applyToColumnName ( columnName ) ; \n} \n} \nif ( sqlTypeClass == SqlType . class ) { \nsqlTypeClass = null ; \n} \nreturn new DbEntityColumnDescriptor ( dbEntityDescriptor , quoteIfRequired ( columnName , columnNamingStrategy . isAlwaysQuoteNames ( ) , columnNamingStrategy . getQuoteChar ( ) ) , property . getName ( ) , property . getType ( ) , isId , sqlTypeClass ) ; \n} \n} \n"}
{"951": "public class RFC2822AddressParser { \nprivate static String removeAnyBounding ( final char s , final char e , final String str ) { \nif ( str == null ) { \nreturn str ; \n} \nelse if ( str . length ( ) < 2 ) { \nreturn str ; \n} \nif ( str . startsWith ( String . valueOf ( s ) ) ) { \nif ( str . endsWith ( String . valueOf ( e ) ) ) { \nreturn str . substring ( 1 , str . length ( ) - 1 ) ; \n} \n} \nreturn str ; \n} \n} \n"}
{"958": "public class ZipUtil { \npublic static void addToZip ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { \nif ( ! file . exists ( ) ) { \nthrow new FileNotFoundException ( file . toString ( ) ) ; \n} \nif ( path == null ) { \npath = file . getName ( ) ; \n} \nwhile ( path . length ( ) != 0 && path . charAt ( 0 ) == '/' ) { \npath = path . substring ( 1 ) ; \n} \nboolean isDir = file . isDirectory ( ) ; \nif ( isDir ) { \nif ( ! StringUtil . endsWithChar ( path , '/' ) ) { \npath += '/' ; \n} \n} \nZipEntry zipEntry = new ZipEntry ( path ) ; \nzipEntry . setTime ( file . lastModified ( ) ) ; \nif ( comment != null ) { \nzipEntry . setComment ( comment ) ; \n} \nif ( isDir ) { \nzipEntry . setSize ( 0 ) ; \nzipEntry . setCrc ( 0 ) ; \n} \nzos . putNextEntry ( zipEntry ) ; \nif ( ! isDir ) { \nInputStream is = new FileInputStream ( file ) ; \ntry { \nStreamUtil . copy ( is , zos ) ; \n} \nfinally { \nStreamUtil . close ( is ) ; \n} \n} \nzos . closeEntry ( ) ; \nif ( recursive ) { \nif ( file . isDirectory ( ) ) { \nboolean noRelativePath = StringUtil . isEmpty ( path ) ; \nfinal File [ ] children = file . listFiles ( ) ; \nif ( children != null ) { \nif ( children . length != 0 ) { \nfor ( File child : children ) { \nString childRelativePath = ( noRelativePath ? StringPool . EMPTY : path ) + child . getName ( ) ; \naddToZip ( zos , child , childRelativePath , comment , recursive ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"961": "public class ClassDescriptor { \npublic PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { \nPropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; \nif ( propertyDescriptor != null ) { \nif ( propertyDescriptor . matchDeclared ( declared ) ) { \nreturn propertyDescriptor ; \n} \n} \nreturn null ; \n} \n} \n"}
{"970": "public class ClassReader { \nprivate int getTypeAnnotationBytecodeOffset ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { \nif ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length ) { \nreturn - 1 ; \n} \nelse if ( readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { \nreturn - 1 ; \n} \nreturn readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; \n} \n} \n"}
{"990": "public class AnnotationResolver { \npublic String resolveBeanName ( final Class type , final boolean useLongTypeName ) { \nPetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; \nString name = null ; \nif ( petiteBean != null ) { \nname = petiteBean . value ( ) . trim ( ) ; \n} \nif ( name == null ) { \nif ( useLongTypeName ) { \nname = type . getName ( ) ; \n} \nelse { \nname = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; \n} \n} \nelse if ( name . length ( ) == 0 ) { \nif ( useLongTypeName ) { \nname = type . getName ( ) ; \n} \nelse { \nname = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; \n} \n} \nreturn name ; \n} \n} \n"}
{"1000": "public class JtxTransaction { \npublic void setRollbackOnly ( final Throwable th ) { \nif ( ! isNoTransaction ( ) ) { \nif ( status != STATUS_MARKED_ROLLBACK ) { \nif ( status != STATUS_ACTIVE ) { \nthrow new JtxException ( \"TNo active TX that can be marked as rollback only\" ) ; \n} \n} \n} \nrollbackCause = th ; \nstatus = STATUS_MARKED_ROLLBACK ; \n} \n} \n"}
{"1003": "public class JtxTransaction { \npublic < E > E requestResource ( final Class < E > resourceType ) { \nif ( isCompleted ( ) ) { \nthrow new JtxException ( \"TX is already completed, resource are not available after commit or rollback\" ) ; \n} \nif ( isRollbackOnly ( ) ) { \nthrow new JtxException ( \"TX is marked as rollback only, resource are not available\" , rollbackCause ) ; \n} \nif ( ! isNoTransaction ( ) ) { \nif ( ! isActive ( ) ) { \nthrow new JtxException ( \"Resources are not available since TX is not active\" ) ; \n} \n} \ncheckTimeout ( ) ; \nE resource = lookupResource ( resourceType ) ; \nif ( resource == null ) { \nint maxResources = txManager . getMaxResourcesPerTransaction ( ) ; \nif ( maxResources != - 1 ) { \nif ( resources . size ( ) >= maxResources ) { \nthrow new JtxException ( \"TX already has attached max. number of resources\" ) ; \n} \n} \nJtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; \nresource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; \nresources . add ( new JtxResource < > ( this , resourceManager , resource ) ) ; \n} \nreturn resource ; \n} \n} \n"}
{"1017": "public class ProxettaClassBuilder { \nprotected void processSuperMethods ( ) { \nfor ( ClassReader cr : targetClassInfo . superClassReaders ) { \ncr . accept ( new EmptyClassVisitor ( ) { \nString declaredClassName ; \n@ Override public void visit ( final int version , final int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { \ndeclaredClassName = name ; \n} \n@ Override public MethodVisitor visitMethod ( final int access , final String name , final String desc , final String signature , final String [ ] exceptions ) { \nif ( name . equals ( INIT ) ) { \nreturn null ; \n} \nelse if ( name . equals ( CLINIT ) ) { \nreturn null ; \n} \nMethodSignatureVisitor msign = targetClassInfo . lookupMethodSignatureVisitor ( access , name , desc , declaredClassName ) ; \nif ( msign == null ) { \nreturn null ; \n} \nreturn applyProxy ( msign ) ; \n} \n} \n, 0 ) ; \n} \n} \n} \n"}
{"1032": "public class JtxTransactionManager { \nprotected void continueTx ( final JtxTransaction sourceTx , final JtxTransactionMode destMode ) { \nif ( ! validateExistingTransaction ) { \nreturn ; \n} \nJtxTransactionMode sourceMode = sourceTx . getTransactionMode ( ) ; \nJtxIsolationLevel destIsolationLevel = destMode . getIsolationLevel ( ) ; \nif ( destIsolationLevel != ISOLATION_DEFAULT ) { \nJtxIsolationLevel currentIsolationLevel = sourceMode . getIsolationLevel ( ) ; \nif ( currentIsolationLevel != destIsolationLevel ) { \nthrow new JtxException ( \"Participating TX specifies isolation level: \" + destIsolationLevel + \" which is incompatible with existing TX: \" + currentIsolationLevel ) ; \n} \n} \nif ( ! destMode . isReadOnly ( ) ) { \nif ( sourceMode . isReadOnly ( ) ) { \nthrow new JtxException ( \"Participating TX is not marked as read-only, but existing TX is\" ) ; \n} \n} \n} \n} \n"}
{"1095": "public class StringUtil { \npublic static boolean isCharAtEqual ( final String string , final int index , final char charToCompare ) { \nif ( index < 0 ) { \nreturn false ; \n} \nelse if ( index >= string . length ( ) ) { \nreturn false ; \n} \nreturn string . charAt ( index ) == charToCompare ; \n} \n} \n"}
{"1110": "public class StringUtil { \npublic static String toUpperCase ( final String s , Locale locale ) { \nif ( s == null ) { \nreturn null ; \n} \nStringBuilder sb = null ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c > 127 ) { \nif ( locale == null ) { \nlocale = Locale . getDefault ( ) ; \n} \nreturn s . toUpperCase ( locale ) ; \n} \nif ( c >= 'a' ) { \nif ( c <= 'z' ) { \nif ( sb == null ) { \nsb = new StringBuilder ( s ) ; \n} \nsb . setCharAt ( i , ( char ) ( c - 32 ) ) ; \n} \n} \n} \nif ( sb == null ) { \nreturn s ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1111": "public class StringUtil { \npublic static String removeQuotes ( final String string ) { \nif ( ( startsWithChar ( string , '\\'' ) && endsWithChar ( string , '\\'' ) ) || ( startsWithChar ( string , '\"' ) && endsWithChar ( string , '\"' ) ) ) { \nreturn substring ( string , 1 , - 1 ) ; \n} \nelse if ( startsWithChar ( string , '`' ) && endsWithChar ( string , '`' ) ) { \nreturn substring ( string , 1 , - 1 ) ; \n} \nreturn string ; \n} \n} \n"}
{"1114": "public class StringUtil { \npublic static char detectQuoteChar ( final String str ) { \nif ( str . length ( ) < 2 ) { \nreturn 0 ; \n} \nfinal char c = str . charAt ( 0 ) ; \nif ( c != str . charAt ( str . length ( ) - 1 ) ) { \nreturn 0 ; \n} \nif ( c == '\\'' || c == '\"' ) { \nreturn c ; \n} \nelse if ( c == '`' ) { \nreturn c ; \n} \nreturn 0 ; \n} \n} \n"}
{"1124": "public class AnnotatedPropertyInterceptor { \nprotected PropertyDescriptor [ ] lookupAnnotatedProperties ( final Class type ) { \nPropertyDescriptor [ ] properties = annotatedProperties . get ( type ) ; \nif ( properties != null ) { \nreturn properties ; \n} \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nPropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; \nList < PropertyDescriptor > list = new ArrayList < > ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \nAnnotation ann = null ; \nif ( propertyDescriptor . getFieldDescriptor ( ) != null ) { \nann = propertyDescriptor . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( annotations ) ; \n} \nif ( ann == null ) { \nif ( propertyDescriptor . getWriteMethodDescriptor ( ) != null ) { \nann = propertyDescriptor . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( annotations ) ; \n} \n} \nif ( ann == null ) { \nif ( propertyDescriptor . getReadMethodDescriptor ( ) != null ) { \nann = propertyDescriptor . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( annotations ) ; \n} \n} \nif ( ann != null ) { \nlist . add ( propertyDescriptor ) ; \n} \n} \nif ( list . isEmpty ( ) ) { \nproperties = EMPTY ; \n} \nelse { \nproperties = list . toArray ( new PropertyDescriptor [ 0 ] ) ; \n} \nannotatedProperties . put ( type , properties ) ; \nreturn properties ; \n} \n} \n"}
{"1174": "public class DirWatcher { \npublic DirWatcher useWatchFile ( final String name ) { \nwatchFile = new File ( dir , name ) ; \nif ( ! watchFile . isFile ( ) ) { \ntry { \nFileUtil . touch ( watchFile ) ; \n} \ncatch ( IOException ioex ) { \nthrow new DirWatcherException ( \"Invalid watch file: \" + name , ioex ) ; \n} \n} \nelse if ( ! watchFile . exists ( ) ) { \ntry { \nFileUtil . touch ( watchFile ) ; \n} \ncatch ( IOException ioex ) { \nthrow new DirWatcherException ( \"Invalid watch file: \" + name , ioex ) ; \n} \n} \nwatchFileLastAccessTime = watchFile . lastModified ( ) ; \nreturn this ; \n} \n} \n"}
{"1178": "public class FieldWriter { \nint computeFieldInfoSize ( ) { \nint size = 8 ; \nif ( constantValueIndex != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ; \nsize += 8 ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 ) { \nif ( symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ) { \nsymbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ; \nsize += 6 ; \n} \n} \nif ( signatureIndex != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ; \nsize += 8 ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ; \nsize += 6 ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \nsize += lastRuntimeVisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \nsize += lastRuntimeInvisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \nsize += lastRuntimeVisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \nsize += lastRuntimeInvisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) ; \n} \nif ( firstAttribute != null ) { \nsize += firstAttribute . computeAttributesSize ( symbolTable ) ; \n} \nreturn size ; \n} \n} \n"}
{"1179": "public class FieldWriter { \nvoid putFieldInfo ( final ByteVector output ) { \nboolean useSyntheticAttribute = symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ; \nint mask = useSyntheticAttribute ? Opcodes . ACC_SYNTHETIC : 0 ; \noutput . putShort ( accessFlags & ~ mask ) . putShort ( nameIndex ) . putShort ( descriptorIndex ) ; \nint attributesCount = 0 ; \nif ( constantValueIndex != 0 ) { \n++ attributesCount ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 ) { \nif ( useSyntheticAttribute ) { \n++ attributesCount ; \n} \n} \nif ( signatureIndex != 0 ) { \n++ attributesCount ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \n++ attributesCount ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \n++ attributesCount ; \n} \nif ( firstAttribute != null ) { \nattributesCount += firstAttribute . getAttributeCount ( ) ; \n} \noutput . putShort ( attributesCount ) ; \nif ( constantValueIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ) . putInt ( 2 ) . putShort ( constantValueIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 ) { \nif ( useSyntheticAttribute ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ) . putInt ( 0 ) ; \n} \n} \nif ( signatureIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ) . putInt ( 2 ) . putShort ( signatureIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ) . putInt ( 0 ) ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \nlastRuntimeVisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \nlastRuntimeInvisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \nlastRuntimeVisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \nlastRuntimeInvisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( firstAttribute != null ) { \nfirstAttribute . putAttributes ( symbolTable , output ) ; \n} \n} \n} \n"}
{"1213": "public class PropsParser { \nprotected void add ( final String section , final String key , final StringBuilder value , final boolean trim , final Operator operator ) { \nif ( key == null ) { \nreturn ; \n} \nString fullKey = key ; \nif ( section != null ) { \nif ( fullKey . length ( ) != 0 ) { \nfullKey = section + '.' + fullKey ; \n} \nelse { \nfullKey = section ; \n} \n} \nString v = value . toString ( ) ; \nif ( trim ) { \nif ( valueTrimLeft && valueTrimRight ) { \nv = v . trim ( ) ; \n} \nelse if ( valueTrimLeft ) { \nv = StringUtil . trimLeft ( v ) ; \n} \nelse { \nv = StringUtil . trimRight ( v ) ; \n} \n} \nif ( v . length ( ) == 0 ) { \nif ( skipEmptyProps ) { \nreturn ; \n} \n} \nextractProfilesAndAdd ( fullKey , v , operator ) ; \n} \n} \n"}
{"1227": "public class Label { \nfinal void accept ( final MethodVisitor methodVisitor , final boolean visitLineNumbers ) { \nmethodVisitor . visitLabel ( this ) ; \nif ( visitLineNumbers ) { \nif ( lineNumber != 0 ) { \nmethodVisitor . visitLineNumber ( lineNumber & 0xFFFF , this ) ; \nif ( otherLineNumbers != null ) { \nfor ( int i = 1 ; \ni <= otherLineNumbers [ 0 ] ; \n++ i ) { \nmethodVisitor . visitLineNumber ( otherLineNumbers [ i ] , this ) ; \n} \n} \n} \n} \n} \n} \n"}
{"1230": "public class Label { \nfinal boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { \nthis . flags |= FLAG_RESOLVED ; \nthis . bytecodeOffset = bytecodeOffset ; \nif ( forwardReferences == null ) { \nreturn false ; \n} \nboolean hasAsmInstructions = false ; \nfor ( int i = forwardReferences [ 0 ] ; \ni > 0 ; \ni -= 2 ) { \nfinal int sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; \nfinal int reference = forwardReferences [ i ] ; \nfinal int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; \nint handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; \nif ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) { \nif ( relativeOffset < Short . MIN_VALUE ) { \nint opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; \nif ( opcode < Opcodes . IFNULL ) { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; \n} \nelse { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; \n} \nhasAsmInstructions = true ; \n} \nelse if ( relativeOffset > Short . MAX_VALUE ) { \nint opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; \nif ( opcode < Opcodes . IFNULL ) { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; \n} \nelse { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; \n} \nhasAsmInstructions = true ; \n} \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \nelse { \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 24 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 16 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \n} \nreturn hasAsmInstructions ; \n} \n} \n"}
{"1232": "public class Label { \nfinal void addSubroutineRetSuccessors ( final Label subroutineCaller ) { \nLabel listOfProcessedBlocks = EMPTY_LIST ; \nLabel listOfBlocksToProcess = this ; \nlistOfBlocksToProcess . nextListElement = EMPTY_LIST ; \nwhile ( listOfBlocksToProcess != EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = basicBlock . nextListElement ; \nbasicBlock . nextListElement = listOfProcessedBlocks ; \nlistOfProcessedBlocks = basicBlock ; \nif ( ( basicBlock . flags & FLAG_SUBROUTINE_END ) != 0 ) { \nif ( basicBlock . subroutineId != subroutineCaller . subroutineId ) { \nbasicBlock . outgoingEdges = new Edge ( basicBlock . outputStackSize , subroutineCaller . outgoingEdges . successor , basicBlock . outgoingEdges ) ; \n} \n} \nlistOfBlocksToProcess = basicBlock . pushSuccessors ( listOfBlocksToProcess ) ; \n} \nwhile ( listOfProcessedBlocks != EMPTY_LIST ) { \nLabel newListOfProcessedBlocks = listOfProcessedBlocks . nextListElement ; \nlistOfProcessedBlocks . nextListElement = null ; \nlistOfProcessedBlocks = newListOfProcessedBlocks ; \n} \n} \n} \n"}
{"1233": "public class NaturalOrderComparator { \nprotected int [ ] compareDigits ( final String str1 , int ndx1 , final String str2 , int ndx2 ) { \nint zeroCount1 = 0 ; \nwhile ( charAt ( str1 , ndx1 ) == '0' ) { \nzeroCount1 ++ ; \nndx1 ++ ; \n} \nint len1 = 0 ; \nwhile ( true ) { \nfinal char char1 = charAt ( str1 , ndx1 ) ; \nfinal boolean isDigitChar1 = CharUtil . isDigit ( char1 ) ; \nif ( ! isDigitChar1 ) { \nbreak ; \n} \nlen1 ++ ; \nndx1 ++ ; \n} \nint zeroCount2 = 0 ; \nwhile ( charAt ( str2 , ndx2 ) == '0' ) { \nzeroCount2 ++ ; \nndx2 ++ ; \n} \nint len2 = 0 ; \nint ndx1_new = ndx1 - len1 ; \nint equalNumbers = 0 ; \nwhile ( true ) { \nfinal char char2 = charAt ( str2 , ndx2 ) ; \nfinal boolean isDigitChar2 = CharUtil . isDigit ( char2 ) ; \nif ( ! isDigitChar2 ) { \nbreak ; \n} \nif ( equalNumbers == 0 ) { \nif ( ndx1_new < ndx1 ) { \nequalNumbers = charAt ( str1 , ndx1_new ++ ) - char2 ; \n} \n} \nlen2 ++ ; \nndx2 ++ ; \n} \nif ( len1 != len2 ) { \nreturn new int [ ] { \nlen1 - len2 } \n; \n} \nif ( equalNumbers != 0 ) { \nreturn new int [ ] { \nequalNumbers } \n; \n} \nreturn new int [ ] { \n0 , zeroCount1 - zeroCount2 , ndx1 , ndx2 } \n; \n} \n} \n"}
{"1316": "public class HttpResponse { \npublic HttpResponse unzip ( ) { \nString contentEncoding = contentEncoding ( ) ; \nif ( contentEncoding != null ) { \nif ( contentEncoding ( ) . equals ( \"gzip\" ) ) { \nif ( body != null ) { \nheaderRemove ( HEADER_CONTENT_ENCODING ) ; \ntry { \nByteArrayInputStream in = new ByteArrayInputStream ( body . getBytes ( StringPool . ISO_8859_1 ) ) ; \nGZIPInputStream gzipInputStream = new GZIPInputStream ( in ) ; \nByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; \nStreamUtil . copy ( gzipInputStream , out ) ; \nbody ( out . toString ( StringPool . ISO_8859_1 ) ) ; \n} \ncatch ( IOException ioex ) { \nthrow new HttpException ( ioex ) ; \n} \n} \n} \n} \nreturn this ; \n} \n} \n"}
{"1322": "public class MapToBean { \npublic Object map2bean ( final Map map , Class targetType ) { \nObject target = null ; \nString className = ( String ) map . get ( classMetadataName ) ; \nif ( className == null ) { \nif ( targetType == null ) { \ntarget = map ; \n} \n} \nelse { \ncheckClassName ( jsonParser . classnameWhitelist , className ) ; \ntry { \ntargetType = ClassLoaderUtil . loadClass ( className ) ; \n} \ncatch ( ClassNotFoundException cnfex ) { \nthrow new JsonException ( cnfex ) ; \n} \n} \nif ( target == null ) { \ntarget = jsonParser . newObjectInstance ( targetType ) ; \n} \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( target . getClass ( ) ) ; \nboolean targetIsMap = target instanceof Map ; \nfor ( Object key : map . keySet ( ) ) { \nString keyName = key . toString ( ) ; \nif ( classMetadataName != null ) { \nif ( keyName . equals ( classMetadataName ) ) { \ncontinue ; \n} \n} \nPropertyDescriptor pd = cd . getPropertyDescriptor ( keyName , declared ) ; \nif ( ! targetIsMap ) { \nif ( pd == null ) { \ncontinue ; \n} \n} \nObject value = map . get ( key ) ; \nClass propertyType = pd == null ? null : pd . getType ( ) ; \nClass componentType = pd == null ? null : pd . resolveComponentType ( true ) ; \nif ( value != null ) { \nif ( value instanceof List ) { \nif ( componentType != null ) { \nif ( componentType != String . class ) { \nvalue = generifyList ( ( List ) value , componentType ) ; \n} \n} \n} \nelse if ( value instanceof Map ) { \nif ( ! ClassUtil . isTypeOf ( propertyType , Map . class ) ) { \nvalue = map2bean ( ( Map ) value , propertyType ) ; \n} \nelse { \nClass keyType = pd == null ? null : pd . resolveKeyType ( true ) ; \nif ( keyType != String . class ) { \nvalue = generifyMap ( ( Map ) value , keyType , componentType ) ; \n} \nelse if ( componentType != String . class ) { \nvalue = generifyMap ( ( Map ) value , keyType , componentType ) ; \n} \n} \n} \n} \nif ( targetIsMap ) { \n( ( Map ) target ) . put ( keyName , value ) ; \n} \nelse { \ntry { \nsetValue ( target , pd , value ) ; \n} \ncatch ( Exception ignore ) { \nignore . printStackTrace ( ) ; \n} \n} \n} \nreturn target ; \n} \n} \n"}
{"1328": "public class HttpBrowser { \npublic HttpResponse sendRequest ( HttpRequest httpRequest ) { \nelapsedTime = System . currentTimeMillis ( ) ; \nhttpRequest . followRedirects ( false ) ; \nwhile ( true ) { \nthis . httpRequest = httpRequest ; \nHttpResponse previousResponse = this . httpResponse ; \nthis . httpResponse = null ; \naddDefaultHeaders ( httpRequest ) ; \naddCookies ( httpRequest ) ; \nif ( catchTransportExceptions ) { \ntry { \nthis . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; \n} \ncatch ( HttpException httpException ) { \nhttpResponse = new HttpResponse ( ) ; \nhttpResponse . assignHttpRequest ( httpRequest ) ; \nhttpResponse . statusCode ( 503 ) ; \nhttpResponse . statusPhrase ( \"Service unavailable. \" + ExceptionUtil . message ( httpException ) ) ; \n} \n} \nelse { \nthis . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; \n} \nreadCookies ( httpResponse ) ; \nint statusCode = httpResponse . statusCode ( ) ; \nif ( statusCode == 301 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nhttpRequest = HttpRequest . get ( newPath ) ; \ncontinue ; \n} \nif ( statusCode == 302 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nhttpRequest = HttpRequest . get ( newPath ) ; \ncontinue ; \n} \nelse if ( statusCode == 303 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nhttpRequest = HttpRequest . get ( newPath ) ; \ncontinue ; \n} \nif ( statusCode == 307 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nString originalMethod = httpRequest . method ( ) ; \nhttpRequest = new HttpRequest ( ) . method ( originalMethod ) . set ( newPath ) ; \ncontinue ; \n} \nelse if ( statusCode == 308 ) { \nString newPath = httpResponse . location ( ) ; \nif ( newPath == null ) { \nbreak ; \n} \nString originalMethod = httpRequest . method ( ) ; \nhttpRequest = new HttpRequest ( ) . method ( originalMethod ) . set ( newPath ) ; \ncontinue ; \n} \nbreak ; \n} \nelapsedTime = System . currentTimeMillis ( ) - elapsedTime ; \nreturn this . httpResponse ; \n} \n} \n"}
{"1357": "public class PetiteConfig { \npublic PetiteConfig setDefaultWiringMode ( final WiringMode defaultWiringMode ) { \nif ( defaultWiringMode == null ) { \nthrow new PetiteException ( \"Invalid default wiring mode: \" + defaultWiringMode ) ; \n} \nelse if ( defaultWiringMode == WiringMode . DEFAULT ) { \nthrow new PetiteException ( \"Invalid default wiring mode: \" + defaultWiringMode ) ; \n} \nthis . defaultWiringMode = defaultWiringMode ; \nreturn this ; \n} \n} \n"}
{"1400": "public class FileUtil { \npublic static byte [ ] readBytes ( final File file , final int count ) throws IOException { \ncheckExists ( file ) ; \ncheckIsFile ( file ) ; \nlong numToRead = file . length ( ) ; \nif ( numToRead >= Integer . MAX_VALUE ) { \nthrow new IOException ( \"File is larger then max array size\" ) ; \n} \nif ( count > NEGATIVE_ONE ) { \nif ( count < numToRead ) { \nnumToRead = count ; \n} \n} \nbyte [ ] bytes = new byte [ ( int ) numToRead ] ; \nRandomAccessFile randomAccessFile = new RandomAccessFile ( file , \"r\" ) ; \nrandomAccessFile . readFully ( bytes ) ; \nrandomAccessFile . close ( ) ; \nreturn bytes ; \n} \n} \n"}
{"1406": "public class FileUtil { \npublic static boolean isBinary ( final File file ) throws IOException { \nbyte [ ] bytes = readBytes ( file , 128 ) ; \nfor ( byte b : bytes ) { \nif ( b < 32 && b != 9 && b != 10 ) { \nif ( b != 13 ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"1408": "public class FileUtil { \nprivate static void checkFileCopy ( final File srcFile , final File destFile ) throws IOException { \ncheckExists ( srcFile ) ; \ncheckIsFile ( srcFile ) ; \nif ( equals ( srcFile , destFile ) ) { \nthrow new IOException ( \"Files '\" + srcFile + \"' and '\" + destFile + \"' are equal\" ) ; \n} \nFile destParent = destFile . getParentFile ( ) ; \nif ( destParent != null ) { \nif ( ! destParent . exists ( ) ) { \ncheckCreateDirectory ( destParent ) ; \n} \n} \n} \n} \n"}
{"1422": "public class MultipartStreamParser { \npublic void parseRequestStream ( final InputStream inputStream , final String encoding ) throws IOException { \nsetParsed ( ) ; \nMultipartRequestInputStream input = new MultipartRequestInputStream ( inputStream ) ; \ninput . readBoundary ( ) ; \nwhile ( true ) { \nFileUploadHeader header = input . readDataHeader ( encoding ) ; \nif ( header == null ) { \nbreak ; \n} \nif ( header . isFile ) { \nString fileName = header . fileName ; \nif ( fileName . length ( ) > 0 ) { \nif ( header . contentType . indexOf ( \"application/x-macbinary\" ) > 0 ) { \ninput . skipBytes ( 128 ) ; \n} \n} \nFileUpload newFile = fileUploadFactory . create ( input ) ; \nnewFile . processStream ( ) ; \nif ( fileName . length ( ) == 0 ) { \nif ( newFile . getSize ( ) == 0 ) { \nnewFile . size = - 1 ; \n} \n} \nputFile ( header . formFieldName , newFile ) ; \n} \nelse { \nFastByteArrayOutputStream fbos = new FastByteArrayOutputStream ( ) ; \ninput . copyAll ( fbos ) ; \nString value = encoding != null ? new String ( fbos . toByteArray ( ) , encoding ) : new String ( fbos . toByteArray ( ) ) ; \nputParameter ( header . formFieldName , value ) ; \n} \ninput . skipBytes ( 1 ) ; \ninput . mark ( 1 ) ; \nint nextByte = input . read ( ) ; \nif ( nextByte == - 1 ) { \ninput . reset ( ) ; \nbreak ; \n} \nelse if ( nextByte == '-' ) { \ninput . reset ( ) ; \nbreak ; \n} \ninput . reset ( ) ; \n} \n} \n} \n"}
{"1423": "public class MultipartStreamParser { \npublic String getParameter ( final String paramName ) { \nif ( requestParameters == null ) { \nreturn null ; \n} \nString [ ] values = requestParameters . get ( paramName ) ; \nif ( values != null ) { \nif ( values . length > 0 ) { \nreturn values [ 0 ] ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1425": "public class MultipartStreamParser { \npublic FileUpload getFile ( final String paramName ) { \nif ( requestFiles == null ) { \nreturn null ; \n} \nFileUpload [ ] values = requestFiles . get ( paramName ) ; \nif ( values != null ) { \nif ( values . length > 0 ) { \nreturn values [ 0 ] ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1444": "public class JsonParser { \nprivate void skipObject ( ) { \nint bracketCount = 1 ; \nboolean insideString = false ; \nwhile ( ndx < total ) { \nfinal char c = input [ ndx ] ; \nif ( insideString ) { \nif ( c == '\\\"' ) { \nif ( notPrecededByEvenNumberOfBackslashes ( ) ) { \ninsideString = false ; \n} \n} \n} \nelse if ( c == '\\\"' ) { \ninsideString = true ; \n} \nelse if ( c == '{' ) { \nbracketCount ++ ; \n} \nelse if ( c == '}' ) { \nbracketCount -- ; \nif ( bracketCount == 0 ) { \nndx ++ ; \nreturn ; \n} \n} \nndx ++ ; \n} \n} \n} \n"}
{"1448": "public class JsonParser { \nprotected String parseUnquotedStringContent ( ) { \nfinal int startNdx = ndx ; \nwhile ( true ) { \nfinal char c = input [ ndx ] ; \nif ( c <= ' ' ) { \nfinal int currentNdx = ndx ; \nskipWhiteSpaces ( ) ; \nreturn new String ( input , startNdx , currentNdx - startNdx ) ; \n} \nelse if ( CharUtil . equalsOne ( c , UNQUOTED_DELIMETERS ) ) { \nfinal int currentNdx = ndx ; \nskipWhiteSpaces ( ) ; \nreturn new String ( input , startNdx , currentNdx - startNdx ) ; \n} \nndx ++ ; \n} \n} \n} \n"}
{"1449": "public class JsonParser { \nprotected Number parseNumber ( ) { \nfinal int startIndex = ndx ; \nchar c = input [ ndx ] ; \nboolean isDouble = false ; \nboolean isExp = false ; \nif ( c == '-' ) { \nndx ++ ; \n} \nwhile ( true ) { \nif ( isEOF ( ) ) { \nbreak ; \n} \nc = input [ ndx ] ; \nif ( c >= '0' ) { \nif ( c <= '9' ) { \nndx ++ ; \ncontinue ; \n} \n} \nif ( c <= 32 ) { \nbreak ; \n} \nif ( c == ',' || c == '}' ) { \nbreak ; \n} \nelse if ( c == ']' ) { \nbreak ; \n} \nif ( c == '.' ) { \nisDouble = true ; \n} \nelse if ( c == 'e' ) { \nisExp = true ; \n} \nelse if ( c == 'E' ) { \nisExp = true ; \n} \nndx ++ ; \n} \nfinal String value = new String ( input , startIndex , ndx - startIndex ) ; \nif ( isDouble ) { \nreturn Double . valueOf ( value ) ; \n} \nlong longNumber ; \nif ( isExp ) { \nlongNumber = Double . valueOf ( value ) . longValue ( ) ; \n} \nelse { \nif ( value . length ( ) >= 19 ) { \nBigInteger bigInteger = new BigInteger ( value ) ; \nif ( isGreaterThanLong ( bigInteger ) ) { \nreturn bigInteger ; \n} \nlongNumber = bigInteger . longValue ( ) ; \n} \nelse { \nlongNumber = Long . parseLong ( value ) ; \n} \n} \nif ( longNumber >= Integer . MIN_VALUE ) { \nif ( longNumber <= Integer . MAX_VALUE ) { \nreturn ( int ) longNumber ; \n} \n} \nreturn longNumber ; \n} \n} \n"}
{"1450": "public class JsonParser { \nprotected Object parseArrayContent ( Class targetType , Class componentType ) { \nif ( targetType == Object . class ) { \ntargetType = List . class ; \n} \ntargetType = replaceWithMappedTypeForPath ( targetType ) ; \nif ( componentType == null && targetType != null ) { \nif ( targetType . isArray ( ) ) { \ncomponentType = targetType . getComponentType ( ) ; \n} \n} \npath . push ( VALUES ) ; \ncomponentType = replaceWithMappedTypeForPath ( componentType ) ; \nCollection < Object > target = newArrayInstance ( targetType ) ; \nboolean koma = false ; \nmainloop : while ( true ) { \nskipWhiteSpaces ( ) ; \nchar c = input [ ndx ] ; \nif ( c == ']' ) { \nif ( koma ) { \nsyntaxError ( \"Trailing comma\" ) ; \n} \nndx ++ ; \npath . pop ( ) ; \nreturn target ; \n} \nObject value = parseValue ( componentType , null , null ) ; \ntarget . add ( value ) ; \nskipWhiteSpaces ( ) ; \nc = input [ ndx ] ; \nswitch ( c ) { \ncase ']' : ndx ++ ; \nbreak mainloop ; \ncase ',' : ndx ++ ; \nkoma = true ; \nbreak ; \ndefault : syntaxError ( \"Invalid char: expected ] or ,\" ) ; \n} \n} \npath . pop ( ) ; \nif ( targetType != null ) { \nreturn convertType ( target , targetType ) ; \n} \nreturn target ; \n} \n} \n"}
{"1455": "public class ReferencesResolver { \npublic BeanReferences [ ] resolveReferenceFromValues ( final Executable methodOrCtor , final String ... parameterReferences ) { \nBeanReferences [ ] references = convertRefToReferences ( parameterReferences ) ; \nif ( references == null ) { \nreferences = buildDefaultReferences ( methodOrCtor ) ; \n} \nelse if ( references . length == 0 ) { \nreferences = buildDefaultReferences ( methodOrCtor ) ; \n} \nif ( methodOrCtor . getParameterTypes ( ) . length != references . length ) { \nthrow new PetiteException ( \"Different number of method parameters and references for: \" + methodOrCtor . getDeclaringClass ( ) . getName ( ) + '#' + methodOrCtor . getName ( ) ) ; \n} \nremoveAllDuplicateNames ( references ) ; \nreturn references ; \n} \n} \n"}
{"1470": "public class ClassUtil { \npublic static Class < ? > childClassOf ( final Class < ? > parentClass , final Object instance ) { \nif ( instance == null ) { \nreturn null ; \n} \nelse if ( instance == Object . class ) { \nreturn null ; \n} \nif ( parentClass != null ) { \nif ( parentClass . isInterface ( ) ) { \nreturn null ; \n} \n} \nClass < ? > childClass = instance . getClass ( ) ; \nwhile ( true ) { \nClass < ? > parent = childClass . getSuperclass ( ) ; \nif ( parent == parentClass ) { \nreturn childClass ; \n} \nif ( parent == null ) { \nreturn null ; \n} \nchildClass = parent ; \n} \n} \n} \n"}
{"1491": "public class DbListIterator { \nprivate boolean moveToNext ( ) { \nif ( last ) { \nif ( closeOnEnd ) { \nquery . close ( ) ; \n} \nelse { \nquery . closeResultSet ( resultSetMapper . getResultSet ( ) ) ; \n} \nreturn false ; \n} \nwhile ( true ) { \nif ( ! resultSetMapper . next ( ) ) { \nlast = true ; \nreturn entityAwareMode ; \n} \nObject [ ] objects = resultSetMapper . parseObjects ( types ) ; \nObject row = query . resolveRowResults ( objects ) ; \nnewElement = ( T ) row ; \nif ( entityAwareMode ) { \nif ( count == 0 ) { \nif ( previousElement == null ) { \npreviousElement = newElement ; \ncontinue ; \n} \n} \nif ( previousElement != null ) { \nif ( newElement != null ) { \nboolean equals ; \nif ( newElement . getClass ( ) . isArray ( ) ) { \nequals = Arrays . equals ( ( Object [ ] ) previousElement , ( Object [ ] ) newElement ) ; \n} \nelse { \nequals = previousElement . equals ( newElement ) ; \n} \nif ( equals ) { \ncontinue ; \n} \n} \n} \n} \nbreak ; \n} \nreturn true ; \n} \n} \n"}
{"1503": "public class MethodWriter { \nprivate void computeMaxStackAndLocal ( ) { \nHandler handler = firstHandler ; \nwhile ( handler != null ) { \nLabel handlerBlock = handler . handlerPc ; \nLabel handlerRangeBlock = handler . startPc ; \nLabel handlerRangeEnd = handler . endPc ; \nwhile ( handlerRangeBlock != handlerRangeEnd ) { \nif ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) { \nhandlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; \n} \nelse { \nhandlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; \n} \nhandlerRangeBlock = handlerRangeBlock . nextBasicBlock ; \n} \nhandler = handler . nextHandler ; \n} \nif ( hasSubroutines ) { \nshort numSubroutines = 1 ; \nfirstBasicBlock . markSubroutine ( numSubroutines ) ; \nfor ( short currentSubroutine = 1 ; \ncurrentSubroutine <= numSubroutines ; \n++ currentSubroutine ) { \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \nif ( basicBlock . subroutineId == currentSubroutine ) { \nLabel jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; \nif ( jsrTarget . subroutineId == 0 ) { \njsrTarget . markSubroutine ( ++ numSubroutines ) ; \n} \n} \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \nLabel subroutine = basicBlock . outgoingEdges . nextEdge . successor ; \nsubroutine . addSubroutineRetSuccessors ( basicBlock ) ; \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel listOfBlocksToProcess = firstBasicBlock ; \nlistOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; \nint maxStackSize = maxStack ; \nwhile ( listOfBlocksToProcess != Label . EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; \nint inputStackTop = basicBlock . inputStackSize ; \nint maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; \nif ( maxBlockStackSize > maxStackSize ) { \nmaxStackSize = maxBlockStackSize ; \n} \nEdge outgoingEdge = basicBlock . outgoingEdges ; \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \noutgoingEdge = outgoingEdge . nextEdge ; \n} \nwhile ( outgoingEdge != null ) { \nLabel successorBlock = outgoingEdge . successor ; \nif ( successorBlock . nextListElement == null ) { \nsuccessorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; \nsuccessorBlock . nextListElement = listOfBlocksToProcess ; \nlistOfBlocksToProcess = successorBlock ; \n} \noutgoingEdge = outgoingEdge . nextEdge ; \n} \n} \nthis . maxStack = maxStackSize ; \n} \n} \n"}
{"1511": "public class BeanVisitor { \npublic void visit ( ) { \nString [ ] properties = resolveProperties ( source , declared ) ; \nfor ( String name : properties ) { \nif ( name == null ) { \ncontinue ; \n} \nif ( ! rules . match ( name , blacklist ) ) { \ncontinue ; \n} \nObject value ; \nString propertyName = name ; \nif ( isSourceMap ) { \npropertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; \n} \nif ( declared ) { \nvalue = BeanUtil . declared . getProperty ( source , propertyName ) ; \n} \nelse { \nvalue = BeanUtil . pojo . getProperty ( source , propertyName ) ; \n} \nif ( value == null ) { \nif ( ignoreNullValues ) { \ncontinue ; \n} \n} \nif ( value instanceof String ) { \nif ( StringUtil . isEmpty ( ( String ) value ) ) { \ncontinue ; \n} \n} \nvisitProperty ( name , value ) ; \n} \n} \n} \n"}
{"1516": "public class HtmlStaplerBundlesManager { \npublic File lookupBundleFile ( String bundleId ) { \nif ( mirrors != null ) { \nif ( ! mirrors . isEmpty ( ) ) { \nString realBundleId = mirrors . remove ( bundleId ) ; \nif ( realBundleId != null ) { \nbundleId = realBundleId ; \n} \n} \n} \nreturn createBundleFile ( bundleId ) ; \n} \n} \n"}
{"1518": "public class HtmlStaplerBundlesManager { \npublic synchronized String registerBundle ( final String contextPath , final String actionPath , final String tempBundleId , final String bundleContentType , final List < String > sources ) { \nif ( tempBundleId == null ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , StringPool . EMPTY ) ; \n} \nreturn null ; \n} \nelse if ( sources . isEmpty ( ) ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , StringPool . EMPTY ) ; \n} \nreturn null ; \n} \nString [ ] sourcesArray = sources . toArray ( new String [ 0 ] ) ; \nfor ( int i = 0 , sourcesArrayLength = sourcesArray . length ; \ni < sourcesArrayLength ; \ni ++ ) { \nsourcesArray [ i ] = sourcesArray [ i ] . trim ( ) . toLowerCase ( ) ; \n} \nif ( sortResources ) { \nArrays . sort ( sourcesArray ) ; \n} \nStringBand sb = new StringBand ( sourcesArray . length ) ; \nfor ( String src : sourcesArray ) { \nsb . append ( src ) ; \n} \nString sourcesString = sb . toString ( ) ; \nString bundleId = createDigest ( sourcesString ) ; \nbundleId += '.' + bundleContentType ; \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , bundleId ) ; \nmirrors . put ( tempBundleId , bundleId ) ; \n} \ntry { \ncreateBundle ( contextPath , actionPath , bundleId , sources ) ; \n} \ncatch ( IOException ioex ) { \nthrow new HtmlStaplerException ( \"Can't create bundle\" , ioex ) ; \n} \nreturn bundleId ; \n} \n} \n"}
{"1528": "public class SetResolver { \npublic SetInjectionPoint [ ] resolve ( final Class type , final boolean autowire ) { \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; \nList < SetInjectionPoint > list = new ArrayList < > ( ) ; \nPropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \nif ( propertyDescriptor . isGetterOnly ( ) ) { \ncontinue ; \n} \nClass propertyType = propertyDescriptor . getType ( ) ; \nif ( ! ClassUtil . isTypeOf ( propertyType , Collection . class ) ) { \ncontinue ; \n} \nMethodDescriptor writeMethodDescriptor = propertyDescriptor . getWriteMethodDescriptor ( ) ; \nFieldDescriptor fieldDescriptor = propertyDescriptor . getFieldDescriptor ( ) ; \nPetiteInject ref = null ; \nif ( writeMethodDescriptor != null ) { \nref = writeMethodDescriptor . getMethod ( ) . getAnnotation ( PetiteInject . class ) ; \n} \nif ( ref == null ) { \nif ( fieldDescriptor != null ) { \nref = fieldDescriptor . getField ( ) . getAnnotation ( PetiteInject . class ) ; \n} \n} \nif ( ! autowire ) { \nif ( ref == null ) { \ncontinue ; \n} \n} \nlist . add ( new SetInjectionPoint ( propertyDescriptor ) ) ; \n} \nSetInjectionPoint [ ] fields ; \nif ( list . isEmpty ( ) ) { \nfields = SetInjectionPoint . EMPTY ; \n} \nelse { \nfields = list . toArray ( new SetInjectionPoint [ 0 ] ) ; \n} \nreturn fields ; \n} \n} \n"}
{"1563": "public class Node { \npublic boolean check ( ) { \nif ( childNodes == null ) { \nreturn true ; \n} \nint siblingElementIndex = 0 ; \nfor ( int i = 0 , childNodesSize = childNodes . size ( ) ; \ni < childNodesSize ; \ni ++ ) { \nNode childNode = childNodes . get ( i ) ; \nif ( childNode . siblingIndex != i ) { \nreturn false ; \n} \nif ( childNode . getNodeType ( ) == NodeType . ELEMENT ) { \nif ( childNode . siblingElementIndex != siblingElementIndex ) { \nreturn false ; \n} \nsiblingElementIndex ++ ; \n} \n} \nif ( childElementNodesCount != siblingElementIndex ) { \nreturn false ; \n} \nif ( childElementNodes != null ) { \nif ( childElementNodes . length != childElementNodesCount ) { \nreturn false ; \n} \nint childCount = getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) { \nNode child = getChild ( i ) ; \nif ( child . siblingElementIndex >= 0 ) { \nif ( childElementNodes [ child . siblingElementIndex ] != child ) { \nreturn false ; \n} \n} \n} \n} \nif ( siblingNameIndex != - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \nfor ( int i = 0 , siblingsSize = siblings . size ( ) ; \ni < siblingsSize ; \ni ++ ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT ) { \nif ( nodeName . equals ( sibling . getNodeName ( ) ) ) { \nif ( sibling . siblingNameIndex != index ++ ) { \nreturn false ; \n} \n} \n} \n} \n} \nfor ( Node childNode : childNodes ) { \nif ( ! childNode . check ( ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1565": "public class Node { \nprotected void initSiblingNames ( ) { \nif ( siblingNameIndex == - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \nfor ( int i = 0 , siblingsSize = siblings . size ( ) ; \ni < siblingsSize ; \ni ++ ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT ) { \nif ( nodeName . equals ( sibling . getNodeName ( ) ) ) { \nsibling . siblingNameIndex = index ++ ; \n} \n} \n} \n} \n} \n} \n"}
{"1568": "public class Node { \npublic Node getPreviousSiblingName ( ) { \nif ( nodeName == null ) { \nreturn null ; \n} \ninitSiblingNames ( ) ; \nint index = siblingNameIndex - 1 ; \nfor ( int i = siblingIndex ; \ni >= 0 ; \ni -- ) { \nNode sibling = parentNode . childNodes . get ( i ) ; \nif ( index == sibling . siblingNameIndex ) { \nif ( nodeName . equals ( sibling . getNodeName ( ) ) ) { \nreturn sibling ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"1607": "public class CommandLine { \npublic CommandLine args ( final String ... arguments ) { \nif ( arguments != null ) { \nif ( arguments . length > 0 ) { \nCollections . addAll ( cmdLine , arguments ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"1614": "public class Frame { \nfinal void setInputFrameFromApiFormat ( final SymbolTable symbolTable , final int numLocal , final Object [ ] local , final int numStack , final Object [ ] stack ) { \nint inputLocalIndex = 0 ; \nfor ( int i = 0 ; \ni < numLocal ; \n++ i ) { \ninputLocals [ inputLocalIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , local [ i ] ) ; \nif ( local [ i ] == Opcodes . LONG ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \nelse if ( local [ i ] == Opcodes . DOUBLE ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \n} \nwhile ( inputLocalIndex < inputLocals . length ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \nint numStackTop = 0 ; \nfor ( int i = 0 ; \ni < numStack ; \n++ i ) { \nif ( stack [ i ] == Opcodes . LONG ) { \n++ numStackTop ; \n} \nelse if ( stack [ i ] == Opcodes . DOUBLE ) { \n++ numStackTop ; \n} \n} \ninputStack = new int [ numStack + numStackTop ] ; \nint inputStackIndex = 0 ; \nfor ( int i = 0 ; \ni < numStack ; \n++ i ) { \ninputStack [ inputStackIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , stack [ i ] ) ; \nif ( stack [ i ] == Opcodes . LONG ) { \ninputStack [ inputStackIndex ++ ] = TOP ; \n} \nelse if ( stack [ i ] == Opcodes . DOUBLE ) { \ninputStack [ inputStackIndex ++ ] = TOP ; \n} \n} \noutputStackTop = 0 ; \ninitializationCount = 0 ; \n} \n} \n"}
{"1618": "public class Frame { \nprivate void push ( final SymbolTable symbolTable , final String descriptor ) { \nint typeDescriptorOffset = descriptor . charAt ( 0 ) == '(' ? descriptor . indexOf ( ')' ) + 1 : 0 ; \nint abstractType = getAbstractTypeFromDescriptor ( symbolTable , descriptor , typeDescriptorOffset ) ; \nif ( abstractType != 0 ) { \npush ( abstractType ) ; \nif ( abstractType == LONG ) { \npush ( TOP ) ; \n} \nelse if ( abstractType == DOUBLE ) { \npush ( TOP ) ; \n} \n} \n} \n} \n"}
{"1622": "public class Frame { \nprivate int getInitializedType ( final SymbolTable symbolTable , final int abstractType ) { \nif ( abstractType == UNINITIALIZED_THIS ) { \nfor ( int i = 0 ; \ni < initializationCount ; \n++ i ) { \nint initializedType = initializations [ i ] ; \nint dim = initializedType & DIM_MASK ; \nint kind = initializedType & KIND_MASK ; \nint value = initializedType & VALUE_MASK ; \nif ( kind == LOCAL_KIND ) { \ninitializedType = dim + inputLocals [ value ] ; \n} \nelse if ( kind == STACK_KIND ) { \ninitializedType = dim + inputStack [ inputStack . length - value ] ; \n} \nif ( abstractType == initializedType ) { \nif ( abstractType == UNINITIALIZED_THIS ) { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; \n} \nelse { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; \n} \n} \n} \n} \nelse if ( ( abstractType & ( DIM_MASK | KIND_MASK ) ) == UNINITIALIZED_KIND ) { \nfor ( int i = 0 ; \ni < initializationCount ; \n++ i ) { \nint initializedType = initializations [ i ] ; \nint dim = initializedType & DIM_MASK ; \nint kind = initializedType & KIND_MASK ; \nint value = initializedType & VALUE_MASK ; \nif ( kind == LOCAL_KIND ) { \ninitializedType = dim + inputLocals [ value ] ; \n} \nelse if ( kind == STACK_KIND ) { \ninitializedType = dim + inputStack [ inputStack . length - value ] ; \n} \nif ( abstractType == initializedType ) { \nif ( abstractType == UNINITIALIZED_THIS ) { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; \n} \nelse { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; \n} \n} \n} \n} \nreturn abstractType ; \n} \n} \n"}
{"1688": "public class BeanProperty { \npublic void updateBean ( final Object bean ) { \nthis . setBean ( bean ) ; \nif ( this . cd != null ) { \nif ( this . cd . isSupplier ( ) ) { \nfinal Object newBean = ( ( Supplier ) this . bean ) . get ( ) ; \nsetBean ( newBean ) ; \n} \n} \n} \n} \n"}
{"1703": "public class JsonParserBase { \n@ SuppressWarnings ( \"unchecked\" ) protected Collection < Object > newArrayInstance ( final Class targetType ) { \nif ( targetType == null || targetType == List . class || targetType == Collection . class ) { \nreturn listSupplier . get ( ) ; \n} \nelse if ( targetType . isArray ( ) ) { \nreturn listSupplier . get ( ) ; \n} \nif ( targetType == Set . class ) { \nreturn new HashSet < > ( ) ; \n} \ntry { \nreturn ( Collection < Object > ) targetType . getDeclaredConstructor ( ) . newInstance ( ) ; \n} \ncatch ( Exception e ) { \nthrow new JsonException ( e ) ; \n} \n} \n} \n"}
{"1712": "public class NetUtil { \npublic static boolean validateAgaintIPAdressV4Format ( final String input ) { \nif ( input == null ) { \nreturn false ; \n} \nint hitDots = 0 ; \nchar [ ] data = input . toCharArray ( ) ; \nfor ( int i = 0 ; \ni < data . length ; \ni ++ ) { \nchar c = data [ i ] ; \nint b = 0 ; \ndo { \nif ( c < '0' ) { \nreturn false ; \n} \nelse if ( c > '9' ) { \nreturn false ; \n} \nb = ( b * 10 + c ) - 48 ; \nif ( ++ i >= data . length ) { \nbreak ; \n} \nc = data [ i ] ; \n} \nwhile ( c != '.' ) ; \nif ( b > 255 ) { \nreturn false ; \n} \nhitDots ++ ; \n} \nreturn hitDots == 4 ; \n} \n} \n"}
{"1722": "public class DefaultClassLoaderStrategy { \n@ Override public Class loadClass ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { \nString arrayClassName = prepareArrayClassnameForLoading ( className ) ; \nif ( className . indexOf ( '.' ) == - 1 ) { \nif ( arrayClassName == null ) { \nint primitiveNdx = getPrimitiveClassNameIndex ( className ) ; \nif ( primitiveNdx >= 0 ) { \nreturn PRIMITIVE_TYPES [ primitiveNdx ] ; \n} \n} \n} \nif ( classLoader != null ) { \nClass klass = loadClass ( className , arrayClassName , classLoader ) ; \nif ( klass != null ) { \nreturn klass ; \n} \n} \nClassLoader currentThreadClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nif ( currentThreadClassLoader != null ) { \nif ( currentThreadClassLoader != classLoader ) { \nClass klass = loadClass ( className , arrayClassName , currentThreadClassLoader ) ; \nif ( klass != null ) { \nreturn klass ; \n} \n} \n} \nClass callerClass = ClassUtil . getCallerClass ( ) ; \nClassLoader callerClassLoader = callerClass . getClassLoader ( ) ; \nif ( callerClassLoader != classLoader ) { \nif ( callerClassLoader != currentThreadClassLoader ) { \nClass klass = loadClass ( className , arrayClassName , callerClassLoader ) ; \nif ( klass != null ) { \nreturn klass ; \n} \n} \n} \nif ( arrayClassName != null ) { \ntry { \nreturn loadArrayClassByComponentType ( className , classLoader ) ; \n} \ncatch ( ClassNotFoundException ignore ) { \n} \n} \nthrow new ClassNotFoundException ( \"Class not found: \" + className ) ; \n} \n} \n"}
{"1749": "public class DispatcherUtil { \npublic static String getUrl ( final HttpServletRequest request ) { \nString servletPath = request . getServletPath ( ) ; \nString query = request . getQueryString ( ) ; \nif ( query != null ) { \nif ( query . length ( ) != 0 ) { \nservletPath += '?' + query ; \n} \n} \nreturn servletPath ; \n} \n} \n"}
{"1771": "public class GzipFilter { \nprotected boolean isGzipEligible ( final HttpServletRequest request ) { \nif ( requestParameterName . length ( ) != 0 ) { \nString forceGzipString = request . getParameter ( requestParameterName ) ; \nif ( forceGzipString != null ) { \nreturn Converter . get ( ) . toBooleanValue ( forceGzipString , false ) ; \n} \n} \nString uri = request . getRequestURI ( ) ; \nif ( uri == null ) { \nreturn false ; \n} \nuri = uri . toLowerCase ( ) ; \nboolean result = false ; \nif ( matches == null ) { \nif ( extensions == null ) { \nreturn true ; \n} \nString extension = FileNameUtil . getExtension ( uri ) ; \nif ( extension . length ( ) > 0 ) { \nextension = extension . toLowerCase ( ) ; \nif ( StringUtil . equalsOne ( extension , extensions ) != - 1 ) { \nresult = true ; \n} \n} \n} \nelse { \nif ( wildcards ) { \nresult = Wildcard . matchPathOne ( uri , matches ) != - 1 ; \n} \nelse { \nfor ( String match : matches ) { \nif ( uri . contains ( match ) ) { \nresult = true ; \nbreak ; \n} \n} \n} \n} \nif ( result ) { \nif ( excludes != null ) { \nif ( wildcards ) { \nif ( Wildcard . matchPathOne ( uri , excludes ) != - 1 ) { \nresult = false ; \n} \n} \nelse { \nfor ( String exclude : excludes ) { \nif ( uri . contains ( exclude ) ) { \nresult = false ; \nbreak ; \n} \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"1776": "public class Vtor { \nprotected boolean matchProfiles ( final String [ ] checkProfiles ) { \nif ( ( checkProfiles != null ) && ( checkProfiles . length == 1 ) ) { \nif ( checkProfiles [ 0 ] . equals ( ALL_PROFILES ) ) { \nreturn true ; \n} \n} \nif ( enabledProfiles == null ) { \nif ( validateAllProfilesByDefault ) { \nreturn true ; \n} \nif ( checkProfiles == null ) { \nreturn true ; \n} \nelse if ( checkProfiles . length == 0 ) { \nreturn true ; \n} \nfor ( String profile : checkProfiles ) { \nif ( StringUtil . isEmpty ( profile ) ) { \nreturn true ; \n} \nif ( profile . equals ( DEFAULT_PROFILE ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nelse if ( enabledProfiles . isEmpty ( ) ) { \nif ( validateAllProfilesByDefault ) { \nreturn true ; \n} \nif ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) { \nreturn true ; \n} \nfor ( String profile : checkProfiles ) { \nif ( StringUtil . isEmpty ( profile ) ) { \nreturn true ; \n} \nif ( profile . equals ( DEFAULT_PROFILE ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nif ( checkProfiles == null ) { \nreturn enabledProfiles . contains ( DEFAULT_PROFILE ) ; \n} \nelse if ( checkProfiles . length == 0 ) { \nreturn enabledProfiles . contains ( DEFAULT_PROFILE ) ; \n} \nboolean result = false ; \nfor ( String profile : checkProfiles ) { \nboolean b = true ; \nboolean must = false ; \nif ( StringUtil . isEmpty ( profile ) ) { \nprofile = DEFAULT_PROFILE ; \n} \nelse if ( profile . charAt ( 0 ) == '-' ) { \nprofile = profile . substring ( 1 ) ; \nb = false ; \n} \nelse if ( profile . charAt ( 0 ) == '+' ) { \nprofile = profile . substring ( 1 ) ; \nmust = true ; \n} \nif ( enabledProfiles . contains ( profile ) ) { \nif ( ! b ) { \nreturn false ; \n} \nresult = true ; \n} \nelse { \nif ( must ) { \nreturn false ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"1783": "public class LagartoParser { \nprotected void emitComment ( final int from , final int to ) { \nif ( config . enableConditionalComments ) { \nif ( match ( CC_IF , from ) ) { \nint endBracketNdx = find ( ']' , from + 3 , to ) ; \nCharSequence expression = charSequence ( from + 1 , endBracketNdx ) ; \nndx = endBracketNdx + 1 ; \nchar c = input [ ndx ] ; \nif ( c != '>' ) { \nerrorInvalidToken ( ) ; \n} \nvisitor . condComment ( expression , true , true , false ) ; \nstate = DATA_STATE ; \nreturn ; \n} \nif ( to > CC_ENDIF2 . length ) { \nif ( match ( CC_ENDIF2 , to - CC_ENDIF2 . length ) ) { \nvisitor . condComment ( _ENDIF , false , true , true ) ; \nstate = DATA_STATE ; \nreturn ; \n} \n} \n} \nCharSequence comment = charSequence ( from , to ) ; \nvisitor . comment ( comment ) ; \ncommentStart = - 1 ; \n} \n} \n"}
{"1789": "public class EmailAttachmentBuilder { \npublic EmailAttachmentBuilder name ( final String name ) { \nif ( name != null ) { \nif ( ! name . trim ( ) . isEmpty ( ) ) { \nthis . name = name ; \n} \n} \nreturn this ; \n} \n} \n"}
{"1800": "public class TargetClassInfoReader { \n@ Override public void visitEnd ( ) { \nif ( classAnnotations != null ) { \nannotations = classAnnotations . toArray ( new AnnotationInfo [ 0 ] ) ; \nclassAnnotations = null ; \n} \nList < String > superList = new ArrayList < > ( ) ; \nSet < String > allInterfaces = new HashSet < > ( ) ; \nif ( nextInterfaces != null ) { \nallInterfaces . addAll ( nextInterfaces ) ; \n} \nwhile ( nextSupername != null ) { \nInputStream inputStream = null ; \nClassReader cr ; \ntry { \ninputStream = ClassLoaderUtil . getClassAsStream ( nextSupername , classLoader ) ; \ncr = new ClassReader ( inputStream ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ProxettaException ( \"Unable to inspect super class: \" + nextSupername , ioex ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \nsuperList . add ( nextSupername ) ; \nsuperClassReaders . add ( cr ) ; \ncr . accept ( new SuperClassVisitor ( ) , 0 ) ; \nif ( cr . getInterfaces ( ) != null ) { \nCollections . addAll ( allInterfaces , cr . getInterfaces ( ) ) ; \n} \n} \nsuperClasses = superList . toArray ( new String [ 0 ] ) ; \nSet < String > todoInterfaces = new HashSet < > ( allInterfaces ) ; \nSet < String > newCollectedInterfaces = new HashSet < > ( ) ; \nwhile ( true ) { \nfor ( String next : todoInterfaces ) { \nInputStream inputStream = null ; \nClassReader cr ; \ntry { \ninputStream = ClassLoaderUtil . getClassAsStream ( next , classLoader ) ; \ncr = new ClassReader ( inputStream ) ; \n} \ncatch ( IOException ioex ) { \nthrow new ProxettaException ( \"Unable to inspect super interface: \" + next , ioex ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \nsuperClassReaders . add ( cr ) ; \ncr . accept ( new SuperClassVisitor ( ) , 0 ) ; \nif ( cr . getInterfaces ( ) != null ) { \nfor ( String newInterface : cr . getInterfaces ( ) ) { \nif ( ! allInterfaces . contains ( newInterface ) ) { \nif ( ! todoInterfaces . contains ( newInterface ) ) { \nnewCollectedInterfaces . add ( newInterface ) ; \n} \n} \n} \n} \n} \nallInterfaces . addAll ( todoInterfaces ) ; \nif ( newCollectedInterfaces . isEmpty ( ) ) { \nbreak ; \n} \ntodoInterfaces . clear ( ) ; \ntodoInterfaces . addAll ( newCollectedInterfaces ) ; \nnewCollectedInterfaces . clear ( ) ; \n} \n} \n} \n"}
{"1802": "public class CsvUtil { \npublic static String toCsvString ( final Object ... elements ) { \nStringBuilder line = new StringBuilder ( ) ; \nint last = elements . length - 1 ; \nfor ( int i = 0 ; \ni < elements . length ; \ni ++ ) { \nif ( elements [ i ] == null ) { \nif ( i != last ) { \nline . append ( FIELD_SEPARATOR ) ; \n} \ncontinue ; \n} \nString field = elements [ i ] . toString ( ) ; \nint ndx = field . indexOf ( FIELD_SEPARATOR ) ; \nif ( ndx == - 1 ) { \nndx = field . indexOf ( FIELD_QUOTE ) ; \n} \nif ( ndx == - 1 ) { \nif ( field . startsWith ( StringPool . SPACE ) ) { \nndx = 1 ; \n} \nelse if ( field . endsWith ( StringPool . SPACE ) ) { \nndx = 1 ; \n} \n} \nif ( ndx == - 1 ) { \nndx = StringUtil . indexOfChars ( field , SPECIAL_CHARS ) ; \n} \nif ( ndx != - 1 ) { \nline . append ( FIELD_QUOTE ) ; \n} \nfield = StringUtil . replace ( field , StringPool . QUOTE , DOUBLE_QUOTE ) ; \nline . append ( field ) ; \nif ( ndx != - 1 ) { \nline . append ( FIELD_QUOTE ) ; \n} \nif ( i != last ) { \nline . append ( FIELD_SEPARATOR ) ; \n} \n} \nreturn line . toString ( ) ; \n} \n} \n"}
{"1803": "public class CsvUtil { \npublic static String [ ] toStringArray ( final String line ) { \nList < String > row = new ArrayList < > ( ) ; \nboolean inQuotedField = false ; \nint fieldStart = 0 ; \nfinal int len = line . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = line . charAt ( i ) ; \nif ( c == FIELD_SEPARATOR ) { \nif ( ! inQuotedField ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 1 ; \n} \n} \nelse if ( c == FIELD_QUOTE ) { \nif ( inQuotedField ) { \nif ( i + 1 == len ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 2 ; \ni ++ ; \ninQuotedField = false ; \n} \nelse if ( line . charAt ( i + 1 ) == FIELD_SEPARATOR ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 2 ; \ni ++ ; \ninQuotedField = false ; \n} \n} \nelse if ( fieldStart == i ) { \ninQuotedField = true ; \nfieldStart ++ ; \n} \n} \n} \nif ( len > 0 ) { \nif ( fieldStart <= len ) { \naddField ( row , line , fieldStart , len , inQuotedField ) ; \n} \n} \nreturn row . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"1810": "public class Cookie { \nprivate void setName ( final String name ) { \nif ( name . contains ( \";\" ) || name . contains ( \",\" ) ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \nelse if ( name . startsWith ( \"$\" ) ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \nfor ( int n = 0 ; \nn < name . length ( ) ; \nn ++ ) { \nchar c = name . charAt ( n ) ; \nif ( c <= 0x20 ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \nelse if ( c >= 0x7f ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \n} \nthis . name = name ; \n} \n} \n"}
{"1827": "public class AeronArchive { \npublic String pollForErrorResponse ( ) { \nlock . lock ( ) ; \ntry { \nensureOpen ( ) ; \nif ( controlResponsePoller . poll ( ) != 0 ) { \nif ( controlResponsePoller . isPollComplete ( ) ) { \nif ( controlResponsePoller . controlSessionId ( ) == controlSessionId && controlResponsePoller . templateId ( ) == ControlResponseDecoder . TEMPLATE_ID ) { \nif ( controlResponsePoller . code ( ) == ControlResponseCode . ERROR ) { \nreturn controlResponsePoller . errorMessage ( ) ; \n} \n} \n} \n} \nreturn null ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"1833": "public class BufferBuilder { \npublic void limit ( final int limit ) { \nif ( limit < 0 ) { \nthrow new IllegalArgumentException ( \"limit outside range: capacity=\" + buffer . capacity ( ) + \" limit=\" + limit ) ; \n} \nelse if ( limit >= buffer . capacity ( ) ) { \nthrow new IllegalArgumentException ( \"limit outside range: capacity=\" + buffer . capacity ( ) + \" limit=\" + limit ) ; \n} \nthis . limit = limit ; \n} \n} \n"}
{"1837": "public class StreamStat { \npublic Map < StreamCompositeKey , List < StreamPosition > > snapshot ( ) { \nfinal Map < StreamCompositeKey , List < StreamPosition > > streams = new HashMap < > ( ) ; \ncounters . forEach ( ( counterId , typeId , keyBuffer , label ) -> { \nif ( ( typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID ) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID ) { \nfinal StreamCompositeKey key = new StreamCompositeKey ( keyBuffer . getInt ( SESSION_ID_OFFSET ) , keyBuffer . getInt ( STREAM_ID_OFFSET ) , keyBuffer . getStringAscii ( CHANNEL_OFFSET ) ) ; \nfinal StreamPosition position = new StreamPosition ( keyBuffer . getLong ( REGISTRATION_ID_OFFSET ) , counters . getCounterValue ( counterId ) , typeId ) ; \nstreams . computeIfAbsent ( key , ( ignore ) -> new ArrayList < > ( ) ) . add ( position ) ; \n} \nelse if ( typeId == PUBLISHER_POS_TYPE_ID ) { \nfinal StreamCompositeKey key = new StreamCompositeKey ( keyBuffer . getInt ( SESSION_ID_OFFSET ) , keyBuffer . getInt ( STREAM_ID_OFFSET ) , keyBuffer . getStringAscii ( CHANNEL_OFFSET ) ) ; \nfinal StreamPosition position = new StreamPosition ( keyBuffer . getLong ( REGISTRATION_ID_OFFSET ) , counters . getCounterValue ( counterId ) , typeId ) ; \nstreams . computeIfAbsent ( key , ( ignore ) -> new ArrayList < > ( ) ) . add ( position ) ; \n} \n} \n) ; \nreturn streams ; \n} \n} \n"}
{"1839": "public class CounterMessageFlyweight { \npublic CounterMessageFlyweight keyBuffer ( final DirectBuffer keyBuffer , final int keyOffset , final int keyLength ) { \nbuffer . putInt ( KEY_LENGTH_OFFSET , keyLength ) ; \nif ( null != keyBuffer ) { \nif ( keyLength > 0 ) { \nbuffer . putBytes ( keyBufferOffset ( ) , keyBuffer , keyOffset , keyLength ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"1855": "public class UdpChannel { \npublic boolean matchesTag ( final UdpChannel udpChannel ) { \nif ( ! hasTag || ! udpChannel . hasTag ( ) ) { \nreturn false ; \n} \nelse if ( tag != udpChannel . tag ( ) ) { \nreturn false ; \n} \nif ( udpChannel . remoteData ( ) . getAddress ( ) . isAnyLocalAddress ( ) && udpChannel . remoteData ( ) . getPort ( ) == 0 && udpChannel . localData ( ) . getAddress ( ) . isAnyLocalAddress ( ) ) { \nif ( udpChannel . localData ( ) . getPort ( ) == 0 ) { \nreturn true ; \n} \n} \nthrow new IllegalArgumentException ( \"matching tag has set endpoint or control address\" ) ; \n} \n} \n"}
{"1859": "public class PublicationImage { \nint insertPacket ( final int termId , final int termOffset , final UnsafeBuffer buffer , final int length , final int transportIndex , final InetSocketAddress srcAddress ) { \nfinal boolean isHeartbeat = DataHeaderFlyweight . isHeartbeat ( buffer , length ) ; \nfinal long packetPosition = computePosition ( termId , termOffset , positionBitsToShift , initialTermId ) ; \nfinal long proposedPosition = isHeartbeat ? packetPosition : packetPosition + length ; \nif ( ! isFlowControlUnderRun ( packetPosition ) ) { \nif ( ! isFlowControlOverRun ( proposedPosition ) ) { \ntrackConnection ( transportIndex , srcAddress , lastPacketTimestampNs ) ; \nif ( isHeartbeat ) { \nif ( DataHeaderFlyweight . isEndOfStream ( buffer ) && ! isEndOfStream ) { \nif ( allEos ( transportIndex ) ) { \nLogBufferDescriptor . endOfStreamPosition ( rawLog . metaData ( ) , proposedPosition ) ; \nisEndOfStream = true ; \n} \n} \nheartbeatsReceived . incrementOrdered ( ) ; \n} \nelse { \nfinal UnsafeBuffer termBuffer = termBuffers [ indexByPosition ( packetPosition , positionBitsToShift ) ] ; \nTermRebuilder . insert ( termBuffer , termOffset , buffer , length ) ; \n} \nlastPacketTimestampNs = cachedNanoClock . nanoTime ( ) ; \nhwmPosition . proposeMaxOrdered ( proposedPosition ) ; \n} \n} \nreturn length ; \n} \n} \n"}
{"1860": "public class ClusterControl { \npublic static AtomicCounter findControlToggle ( final CountersReader counters ) { \nfinal AtomicBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = counters . maxCounterId ( ) ; \ni < size ; \ni ++ ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == CONTROL_TOGGLE_TYPE_ID ) { \nreturn new AtomicCounter ( counters . valuesBuffer ( ) , i , null ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"1872": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder validate ( ) { \nif ( null == media ) { \nthrow new IllegalStateException ( \"media type is mandatory\" ) ; \n} \nif ( CommonContext . UDP_MEDIA . equals ( media ) ) { \nif ( null == endpoint && null == controlEndpoint ) { \nthrow new IllegalStateException ( \"either 'endpoint' or 'control' must be specified for UDP.\" ) ; \n} \n} \nint count = 0 ; \ncount += null == initialTermId ? 0 : 1 ; \ncount += null == termId ? 0 : 1 ; \ncount += null == termOffset ? 0 : 1 ; \nif ( count > 0 ) { \nif ( count < 3 ) { \nthrow new IllegalStateException ( \"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\" ) ; \n} \nif ( termId - initialTermId < 0 ) { \nthrow new IllegalStateException ( \"difference greater than 2^31 - 1: termId=\" + termId + \" - initialTermId=\" + initialTermId ) ; \n} \nif ( null != termLength ) { \nif ( termOffset > termLength ) { \nthrow new IllegalStateException ( \"termOffset=\" + termOffset + \" > termLength=\" + termLength ) ; \n} \n} \n} \nreturn this ; \n} \n} \n"}
{"1873": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder prefix ( final String prefix ) { \nif ( null != prefix && ! prefix . equals ( \"\" ) ) { \nif ( ! prefix . equals ( SPY_QUALIFIER ) ) { \nthrow new IllegalArgumentException ( \"invalid prefix: \" + prefix ) ; \n} \n} \nthis . prefix = prefix ; \nreturn this ; \n} \n} \n"}
{"1875": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder controlMode ( final String controlMode ) { \nif ( null != controlMode && ! controlMode . equals ( CommonContext . MDC_CONTROL_MODE_MANUAL ) ) { \nif ( ! controlMode . equals ( CommonContext . MDC_CONTROL_MODE_DYNAMIC ) ) { \nthrow new IllegalArgumentException ( \"invalid control mode: \" + controlMode ) ; \n} \n} \nthis . controlMode = controlMode ; \nreturn this ; \n} \n} \n"}
{"1877": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder termOffset ( final Integer termOffset ) { \nif ( null != termOffset ) { \nif ( termOffset < 0 ) { \nthrow new IllegalArgumentException ( \"term offset not in range 0-1g: \" + termOffset ) ; \n} \nelse if ( termOffset > LogBufferDescriptor . TERM_MAX_LENGTH ) { \nthrow new IllegalArgumentException ( \"term offset not in range 0-1g: \" + termOffset ) ; \n} \nif ( 0 != ( termOffset & ( FRAME_ALIGNMENT - 1 ) ) ) { \nthrow new IllegalArgumentException ( \"term offset not multiple of FRAME_ALIGNMENT: \" + termOffset ) ; \n} \n} \nthis . termOffset = termOffset ; \nreturn this ; \n} \n} \n"}
{"1878": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder linger ( final Long lingerNs ) { \nif ( null != lingerNs ) { \nif ( lingerNs < 0 ) { \nthrow new IllegalArgumentException ( \"linger value cannot be negative: \" + lingerNs ) ; \n} \n} \nthis . linger = lingerNs ; \nreturn this ; \n} \n} \n"}
{"1880": "public class UdpChannelTransport { \npublic void close ( ) { \nif ( ! isClosed ) { \nisClosed = true ; \ntry { \nif ( null != selectionKey ) { \nselectionKey . cancel ( ) ; \n} \nif ( null != transportPoller ) { \ntransportPoller . cancelRead ( this ) ; \ntransportPoller . selectNowWithoutProcessing ( ) ; \n} \nif ( null != sendDatagramChannel ) { \nsendDatagramChannel . close ( ) ; \n} \nif ( receiveDatagramChannel != sendDatagramChannel ) { \nif ( null != receiveDatagramChannel ) { \nreceiveDatagramChannel . close ( ) ; \n} \n} \nif ( null != transportPoller ) { \ntransportPoller . selectNowWithoutProcessing ( ) ; \n} \n} \ncatch ( final IOException ex ) { \nerrorLog . record ( ex ) ; \n} \n} \n} \n} \n"}
{"1883": "public class RetransmitHandler { \npublic void onNak ( final int termId , final int termOffset , final int length , final int termLength , final RetransmitSender retransmitSender ) { \nif ( ! isInvalid ( termOffset , termLength ) ) { \nif ( null == activeRetransmitsMap . get ( termId , termOffset ) ) { \nif ( activeRetransmitsMap . size ( ) < MAX_RETRANSMITS_DEFAULT ) { \nfinal RetransmitAction action = assignRetransmitAction ( ) ; \naction . termId = termId ; \naction . termOffset = termOffset ; \naction . length = Math . min ( length , termLength - termOffset ) ; \nfinal long delay = delayGenerator . generateDelay ( ) ; \nif ( 0 == delay ) { \nretransmitSender . resend ( termId , termOffset , action . length ) ; \naction . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; \n} \nelse { \naction . delay ( delay , nanoClock . nanoTime ( ) ) ; \n} \nactiveRetransmitsMap . put ( termId , termOffset , action ) ; \n} \n} \n} \n} \n} \n"}
{"1884": "public class RetransmitHandler { \npublic void processTimeouts ( final long nowNs , final RetransmitSender retransmitSender ) { \nif ( activeRetransmitsMap . size ( ) > 0 ) { \nfor ( final RetransmitAction action : retransmitActionPool ) { \nif ( DELAYED == action . state && ( action . expireNs - nowNs < 0 ) ) { \nretransmitSender . resend ( action . termId , action . termOffset , action . length ) ; \naction . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; \n} \nelse if ( LINGERING == action . state ) { \nif ( action . expireNs - nowNs < 0 ) { \naction . cancel ( ) ; \nactiveRetransmitsMap . remove ( action . termId , action . termOffset ) ; \n} \n} \n} \n} \n} \n} \n"}
{"1888": "public class DirectBufferVector { \npublic DirectBufferVector validate ( ) { \nfinal int capacity = buffer . capacity ( ) ; \nif ( offset < 0 ) { \nthrow new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity ) ; \n} \nelse if ( offset >= capacity ) { \nthrow new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity ) ; \n} \nif ( length < 0 ) { \nthrow new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity + \" length=\" + length ) ; \n} \nelse if ( length > ( capacity - offset ) ) { \nthrow new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity + \" length=\" + length ) ; \n} \nreturn this ; \n} \n} \n"}
{"1900": "public class ClusterMember { \npublic static boolean hasActiveQuorum ( final ClusterMember [ ] clusterMembers , final long nowMs , final long timeoutMs ) { \nint threshold = quorumThreshold ( clusterMembers . length ) ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( member . isLeader ( ) ) { \nif ( -- threshold <= 0 ) { \nreturn true ; \n} \n} \nelse if ( nowMs <= ( member . timeOfLastAppendPositionMs ( ) + timeoutMs ) ) { \nif ( -- threshold <= 0 ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"1903": "public class ClusterMember { \npublic static boolean haveVotersReachedPosition ( final ClusterMember [ ] clusterMembers , final long position , final long leadershipTermId ) { \nfor ( final ClusterMember member : clusterMembers ) { \nif ( member . vote != null ) { \nif ( member . logPosition < position || member . leadershipTermId != leadershipTermId ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"1904": "public class ClusterMember { \npublic static boolean hasWonVoteOnFullCount ( final ClusterMember [ ] members , final long candidateTermId ) { \nint votes = 0 ; \nfor ( final ClusterMember member : members ) { \nif ( null == member . vote ) { \nreturn false ; \n} \nelse if ( member . candidateTermId != candidateTermId ) { \nreturn false ; \n} \nvotes += member . vote ? 1 : 0 ; \n} \nreturn votes >= ClusterMember . quorumThreshold ( members . length ) ; \n} \n} \n"}
{"1905": "public class ClusterMember { \npublic static boolean hasMajorityVote ( final ClusterMember [ ] clusterMembers , final long candidateTermId ) { \nint votes = 0 ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( Boolean . TRUE . equals ( member . vote ) ) { \nif ( member . candidateTermId == candidateTermId ) { \n++ votes ; \n} \n} \n} \nreturn votes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; \n} \n} \n"}
{"1909": "public class ClusterMember { \npublic static boolean isUnanimousCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { \nfor ( final ClusterMember member : clusterMembers ) { \nif ( NULL_POSITION == member . logPosition ) { \nreturn false ; \n} \nelse if ( compareLog ( candidate , member ) < 0 ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1910": "public class ClusterMember { \npublic static boolean isQuorumCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { \nint possibleVotes = 0 ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( NULL_POSITION == member . logPosition ) { \ncontinue ; \n} \nelse if ( compareLog ( candidate , member ) < 0 ) { \ncontinue ; \n} \n++ possibleVotes ; \n} \nreturn possibleVotes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; \n} \n} \n"}
{"1915": "public class CommonContext { \npublic MappedByteBuffer mapExistingCncFile ( final Consumer < String > logger ) { \nfinal File cncFile = new File ( aeronDirectory , CncFileDescriptor . CNC_FILE ) ; \nif ( cncFile . exists ( ) ) { \nif ( cncFile . length ( ) > 0 ) { \nif ( null != logger ) { \nlogger . accept ( \"INFO: Aeron CnC file exists: \" + cncFile ) ; \n} \nreturn IoUtil . mapExistingFile ( cncFile , CncFileDescriptor . CNC_FILE ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1916": "public class CommonContext { \npublic static boolean isDriverActive ( final File directory , final long driverTimeoutMs , final Consumer < String > logger ) { \nfinal File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; \nif ( cncFile . exists ( ) ) { \nif ( cncFile . length ( ) > 0 ) { \nlogger . accept ( \"INFO: Aeron CnC file exists: \" + cncFile ) ; \nfinal MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , \"CnC file\" ) ; \ntry { \nreturn isDriverActive ( driverTimeoutMs , logger , cncByteBuffer ) ; \n} \nfinally { \nIoUtil . unmap ( cncByteBuffer ) ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"1919": "public class CommonContext { \npublic static boolean requestDriverTermination ( final File directory , final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { \nfinal File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; \nif ( cncFile . exists ( ) ) { \nif ( cncFile . length ( ) > 0 ) { \nfinal MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , \"CnC file\" ) ; \ntry { \nfinal UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; \nfinal int cncVersion = cncMetaDataBuffer . getIntVolatile ( cncVersionOffset ( 0 ) ) ; \nif ( CncFileDescriptor . CNC_VERSION != cncVersion ) { \nthrow new AeronException ( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion ) ; \n} \nfinal ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; \nfinal long clientId = toDriverBuffer . nextCorrelationId ( ) ; \nfinal DriverProxy driverProxy = new DriverProxy ( toDriverBuffer , clientId ) ; \nreturn driverProxy . terminateDriver ( tokenBuffer , tokenOffset , tokenLength ) ; \n} \nfinally { \nIoUtil . unmap ( cncByteBuffer ) ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"1926": "public class RecordingPos { \npublic static int findCounterIdByRecording ( final CountersReader countersReader , final long recordingId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = countersReader . maxCounterId ( ) ; \ni < size ; \ni ++ ) { \nif ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID ) { \nif ( buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ) { \nreturn i ; \n} \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1927": "public class RecordingPos { \npublic static int findCounterIdBySession ( final CountersReader countersReader , final int sessionId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = countersReader . maxCounterId ( ) ; \ni < size ; \ni ++ ) { \nif ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID ) { \nif ( buffer . getInt ( recordOffset + KEY_OFFSET + SESSION_ID_OFFSET ) == sessionId ) { \nreturn i ; \n} \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1935": "public class RecordingLog { \npublic void appendTerm ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long timestamp ) { \nfinal int size = entries . size ( ) ; \nif ( size > 0 ) { \nfinal Entry lastEntry = entries . get ( size - 1 ) ; \nif ( lastEntry . type != NULL_VALUE ) { \nif ( lastEntry . leadershipTermId >= leadershipTermId ) { \nthrow new ClusterException ( \"leadershipTermId out of sequence: previous \" + lastEntry . leadershipTermId + \" this \" + leadershipTermId ) ; \n} \n} \n} \nindexByLeadershipTermIdMap . put ( leadershipTermId , nextEntryIndex ) ; \nappend ( ENTRY_TYPE_TERM , recordingId , leadershipTermId , termBaseLogPosition , NULL_POSITION , timestamp , NULL_VALUE ) ; \n} \n} \n"}
{"1936": "public class RecordingLog { \npublic void appendSnapshot ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long logPosition , final long timestamp , final int serviceId ) { \nfinal int size = entries . size ( ) ; \nif ( size > 0 ) { \nfinal Entry entry = entries . get ( size - 1 ) ; \nif ( entry . type == ENTRY_TYPE_TERM ) { \nif ( entry . leadershipTermId != leadershipTermId ) { \nthrow new ClusterException ( \"leadershipTermId out of sequence: previous \" + entry . leadershipTermId + \" this \" + leadershipTermId ) ; \n} \n} \n} \nappend ( ENTRY_TYPE_SNAPSHOT , recordingId , leadershipTermId , termBaseLogPosition , logPosition , timestamp , serviceId ) ; \n} \n} \n"}
{"1938": "public class RecordingLog { \npublic void tombstoneEntry ( final long leadershipTermId , final int entryIndex ) { \nint index = - 1 ; \nfor ( int i = 0 , size = entries . size ( ) ; \ni < size ; \ni ++ ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( entry . leadershipTermId == leadershipTermId ) { \nif ( entry . entryIndex == entryIndex ) { \nindex = entry . entryIndex ; \nif ( ENTRY_TYPE_TERM == entry . type ) { \nindexByLeadershipTermIdMap . remove ( leadershipTermId ) ; \n} \nbreak ; \n} \n} \n} \nif ( - 1 == index ) { \nthrow new ClusterException ( \"unknown entry index: \" + entryIndex ) ; \n} \nbuffer . putInt ( 0 , NULL_VALUE , LITTLE_ENDIAN ) ; \nbyteBuffer . limit ( SIZE_OF_INT ) . position ( 0 ) ; \nfinal long filePosition = ( index * ( long ) ENTRY_LENGTH ) + ENTRY_TYPE_OFFSET ; \ntry { \nif ( SIZE_OF_INT != fileChannel . write ( byteBuffer , filePosition ) ) { \nthrow new ClusterException ( \"failed to write field atomically\" ) ; \n} \n} \ncatch ( final Exception ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \n} \n} \n"}
{"1939": "public class AeronCluster { \npublic void close ( ) { \nif ( null != publication ) { \nif ( publication . isConnected ( ) ) { \ncloseSession ( ) ; \n} \n} \nif ( ! ctx . ownsAeronClient ( ) ) { \nCloseHelper . close ( subscription ) ; \nCloseHelper . close ( publication ) ; \n} \nctx . close ( ) ; \n} \n} \n"}
{"1941": "public class LogBufferUnblocker { \npublic static boolean unblock ( final UnsafeBuffer [ ] termBuffers , final UnsafeBuffer logMetaDataBuffer , final long blockedPosition , final int termLength ) { \nfinal int positionBitsToShift = LogBufferDescriptor . positionBitsToShift ( termLength ) ; \nfinal int blockedTermCount = ( int ) ( blockedPosition >> positionBitsToShift ) ; \nfinal int blockedOffset = ( int ) blockedPosition & ( termLength - 1 ) ; \nfinal int activeTermCount = activeTermCount ( logMetaDataBuffer ) ; \nif ( activeTermCount == ( blockedTermCount - 1 ) ) { \nif ( blockedOffset == 0 ) { \nfinal int currentTermId = termId ( rawTailVolatile ( logMetaDataBuffer , indexByTermCount ( activeTermCount ) ) ) ; \nreturn rotateLog ( logMetaDataBuffer , activeTermCount , currentTermId ) ; \n} \n} \nfinal int blockedIndex = indexByTermCount ( blockedTermCount ) ; \nfinal long rawTail = rawTailVolatile ( logMetaDataBuffer , blockedIndex ) ; \nfinal int termId = termId ( rawTail ) ; \nfinal int tailOffset = termOffset ( rawTail , termLength ) ; \nfinal UnsafeBuffer termBuffer = termBuffers [ blockedIndex ] ; \nswitch ( TermUnblocker . unblock ( logMetaDataBuffer , termBuffer , blockedOffset , tailOffset , termId ) ) { \ncase UNBLOCKED_TO_END : rotateLog ( logMetaDataBuffer , blockedTermCount , termId ) ; \ncase UNBLOCKED : return true ; \n} \nreturn false ; \n} \n} \n"}
{"1956": "public class TerminateDriverFlyweight { \npublic TerminateDriverFlyweight tokenBuffer ( final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { \nbuffer . putInt ( TOKEN_LENGTH_OFFSET , tokenLength ) ; \nif ( null != tokenBuffer ) { \nif ( tokenLength > 0 ) { \nbuffer . putBytes ( tokenBufferOffset ( ) , tokenBuffer , tokenOffset , tokenLength ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"1960": "public class RecoveryState { \npublic static long getSnapshotRecordingId ( final CountersReader counters , final int counterId , final int serviceId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nif ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( counterId ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { \nfinal int serviceCount = buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_COUNT_OFFSET ) ; \nif ( serviceId < 0 ) { \nthrow new ClusterException ( \"invalid serviceId \" + serviceId + \" for count of \" + serviceCount ) ; \n} \nelse if ( serviceId >= serviceCount ) { \nthrow new ClusterException ( \"invalid serviceId \" + serviceId + \" for count of \" + serviceCount ) ; \n} \nreturn buffer . getLong ( recordOffset + KEY_OFFSET + SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceId * SIZE_OF_LONG ) ) ; \n} \n} \nthrow new ClusterException ( \"Active counter not found \" + counterId ) ; \n} \n} \n"}
{"1968": "public class MediaDriver { \npublic void close ( ) { \nCloseHelper . close ( sharedRunner ) ; \nCloseHelper . close ( sharedNetworkRunner ) ; \nCloseHelper . close ( receiverRunner ) ; \nCloseHelper . close ( senderRunner ) ; \nCloseHelper . close ( conductorRunner ) ; \nCloseHelper . close ( sharedInvoker ) ; \nif ( ctx . useWindowsHighResTimer ( ) ) { \nif ( SystemUtil . osName ( ) . startsWith ( \"win\" ) ) { \nif ( ! wasHighResTimerEnabled ) { \nHighResolutionTimer . disable ( ) ; \n} \n} \n} \n} \n} \n"}
{"1971": "public class ServiceHeartbeat { \npublic static int findCounterId ( final CountersReader counters , final int serviceId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = counters . maxCounterId ( ) ; \ni < size ; \ni ++ ) { \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == SERVICE_HEARTBEAT_TYPE_ID ) { \nif ( buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET ) == serviceId ) { \nreturn i ; \n} \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1972": "public class BacklogStat { \npublic Map < StreamCompositeKey , StreamBacklog > snapshot ( ) { \nfinal Map < StreamCompositeKey , StreamBacklog > streams = new HashMap < > ( ) ; \ncounters . forEach ( ( counterId , typeId , keyBuffer , label ) -> { \nif ( ( typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID ) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID ) { \nfinal StreamCompositeKey key = new StreamCompositeKey ( keyBuffer . getInt ( SESSION_ID_OFFSET ) , keyBuffer . getInt ( STREAM_ID_OFFSET ) , keyBuffer . getStringAscii ( CHANNEL_OFFSET ) ) ; \nfinal StreamBacklog streamBacklog = streams . computeIfAbsent ( key , ( ignore ) -> new StreamBacklog ( ) ) ; \nfinal long registrationId = keyBuffer . getLong ( REGISTRATION_ID_OFFSET ) ; \nfinal long value = counters . getCounterValue ( counterId ) ; \nswitch ( typeId ) { \ncase PublisherLimit . PUBLISHER_LIMIT_TYPE_ID : streamBacklog . createPublisherIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createPublisherIfAbsent ( ) . limit ( value ) ; \nbreak ; \ncase PublisherPos . PUBLISHER_POS_TYPE_ID : streamBacklog . createPublisherIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createPublisherIfAbsent ( ) . position ( value ) ; \nbreak ; \ncase SenderPos . SENDER_POSITION_TYPE_ID : streamBacklog . createSenderIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createSenderIfAbsent ( ) . position ( value ) ; \nbreak ; \ncase SenderLimit . SENDER_LIMIT_TYPE_ID : streamBacklog . createSenderIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createSenderIfAbsent ( ) . limit ( value ) ; \nbreak ; \ncase ReceiverHwm . RECEIVER_HWM_TYPE_ID : streamBacklog . createReceiverIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createReceiverIfAbsent ( ) . highWaterMark ( value ) ; \nbreak ; \ncase ReceiverPos . RECEIVER_POS_TYPE_ID : streamBacklog . createReceiverIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createReceiverIfAbsent ( ) . position ( value ) ; \nbreak ; \ncase SubscriberPos . SUBSCRIBER_POSITION_TYPE_ID : streamBacklog . subscriberBacklogs ( ) . put ( registrationId , new Subscriber ( value ) ) ; \nbreak ; \n} \n} \nelse if ( typeId == PUBLISHER_POS_TYPE_ID ) { \nfinal StreamCompositeKey key = new StreamCompositeKey ( keyBuffer . getInt ( SESSION_ID_OFFSET ) , keyBuffer . getInt ( STREAM_ID_OFFSET ) , keyBuffer . getStringAscii ( CHANNEL_OFFSET ) ) ; \nfinal StreamBacklog streamBacklog = streams . computeIfAbsent ( key , ( ignore ) -> new StreamBacklog ( ) ) ; \nfinal long registrationId = keyBuffer . getLong ( REGISTRATION_ID_OFFSET ) ; \nfinal long value = counters . getCounterValue ( counterId ) ; \nswitch ( typeId ) { \ncase PublisherLimit . PUBLISHER_LIMIT_TYPE_ID : streamBacklog . createPublisherIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createPublisherIfAbsent ( ) . limit ( value ) ; \nbreak ; \ncase PublisherPos . PUBLISHER_POS_TYPE_ID : streamBacklog . createPublisherIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createPublisherIfAbsent ( ) . position ( value ) ; \nbreak ; \ncase SenderPos . SENDER_POSITION_TYPE_ID : streamBacklog . createSenderIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createSenderIfAbsent ( ) . position ( value ) ; \nbreak ; \ncase SenderLimit . SENDER_LIMIT_TYPE_ID : streamBacklog . createSenderIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createSenderIfAbsent ( ) . limit ( value ) ; \nbreak ; \ncase ReceiverHwm . RECEIVER_HWM_TYPE_ID : streamBacklog . createReceiverIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createReceiverIfAbsent ( ) . highWaterMark ( value ) ; \nbreak ; \ncase ReceiverPos . RECEIVER_POS_TYPE_ID : streamBacklog . createReceiverIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createReceiverIfAbsent ( ) . position ( value ) ; \nbreak ; \ncase SubscriberPos . SUBSCRIBER_POSITION_TYPE_ID : streamBacklog . subscriberBacklogs ( ) . put ( registrationId , new Subscriber ( value ) ) ; \nbreak ; \n} \n} \n} \n) ; \nreturn streams ; \n} \n} \n"}
{"1988": "public class ParquetFileReader { \npublic PageReadStore readNextRowGroup ( ) throws IOException { \nif ( currentBlock == blocks . size ( ) ) { \nreturn null ; \n} \nBlockMetaData block = blocks . get ( currentBlock ) ; \nif ( block . getRowCount ( ) == 0 ) { \nthrow new RuntimeException ( \"Illegal row group of 0 rows\" ) ; \n} \nthis . currentRowGroup = new ColumnChunkPageReadStore ( block . getRowCount ( ) ) ; \nList < ConsecutivePartList > allParts = new ArrayList < ConsecutivePartList > ( ) ; \nConsecutivePartList currentParts = null ; \nfor ( ColumnChunkMetaData mc : block . getColumns ( ) ) { \nColumnPath pathKey = mc . getPath ( ) ; \nBenchmarkCounter . incrementTotalBytes ( mc . getTotalSize ( ) ) ; \nColumnDescriptor columnDescriptor = paths . get ( pathKey ) ; \nif ( columnDescriptor != null ) { \nlong startingPos = mc . getStartingPos ( ) ; \nif ( currentParts == null ) { \ncurrentParts = new ConsecutivePartList ( startingPos ) ; \nallParts . add ( currentParts ) ; \n} \nelse if ( currentParts . endPos ( ) != startingPos ) { \ncurrentParts = new ConsecutivePartList ( startingPos ) ; \nallParts . add ( currentParts ) ; \n} \ncurrentParts . addChunk ( new ChunkDescriptor ( columnDescriptor , mc , startingPos , ( int ) mc . getTotalSize ( ) ) ) ; \n} \n} \nChunkListBuilder builder = new ChunkListBuilder ( ) ; \nfor ( ConsecutivePartList consecutiveChunks : allParts ) { \nconsecutiveChunks . readAll ( f , builder ) ; \n} \nfor ( Chunk chunk : builder . build ( ) ) { \ncurrentRowGroup . addColumn ( chunk . descriptor . col , chunk . readAllPages ( ) ) ; \n} \nif ( nextDictionaryReader != null ) { \nnextDictionaryReader . setRowGroup ( currentRowGroup ) ; \n} \nadvanceToNextBlock ( ) ; \nreturn currentRowGroup ; \n} \n} \n"}
{"1989": "public class ParquetFileReader { \npublic PageReadStore readNextFilteredRowGroup ( ) throws IOException { \nif ( currentBlock == blocks . size ( ) ) { \nreturn null ; \n} \nif ( ! options . useColumnIndexFilter ( ) ) { \nreturn readNextRowGroup ( ) ; \n} \nBlockMetaData block = blocks . get ( currentBlock ) ; \nif ( block . getRowCount ( ) == 0 ) { \nthrow new RuntimeException ( \"Illegal row group of 0 rows\" ) ; \n} \nColumnIndexStore ciStore = getColumnIndexStore ( currentBlock ) ; \nRowRanges rowRanges = getRowRanges ( currentBlock ) ; \nlong rowCount = rowRanges . rowCount ( ) ; \nif ( rowCount == 0 ) { \nadvanceToNextBlock ( ) ; \nreturn readNextFilteredRowGroup ( ) ; \n} \nif ( rowCount == block . getRowCount ( ) ) { \nreturn readNextRowGroup ( ) ; \n} \nthis . currentRowGroup = new ColumnChunkPageReadStore ( rowRanges ) ; \nChunkListBuilder builder = new ChunkListBuilder ( ) ; \nList < ConsecutivePartList > allParts = new ArrayList < ConsecutivePartList > ( ) ; \nConsecutivePartList currentParts = null ; \nfor ( ColumnChunkMetaData mc : block . getColumns ( ) ) { \nColumnPath pathKey = mc . getPath ( ) ; \nColumnDescriptor columnDescriptor = paths . get ( pathKey ) ; \nif ( columnDescriptor != null ) { \nOffsetIndex offsetIndex = ciStore . getOffsetIndex ( mc . getPath ( ) ) ; \nOffsetIndex filteredOffsetIndex = filterOffsetIndex ( offsetIndex , rowRanges , block . getRowCount ( ) ) ; \nfor ( OffsetRange range : calculateOffsetRanges ( filteredOffsetIndex , mc , offsetIndex . getOffset ( 0 ) ) ) { \nBenchmarkCounter . incrementTotalBytes ( range . getLength ( ) ) ; \nlong startingPos = range . getOffset ( ) ; \nif ( currentParts == null ) { \ncurrentParts = new ConsecutivePartList ( startingPos ) ; \nallParts . add ( currentParts ) ; \n} \nelse if ( currentParts . endPos ( ) != startingPos ) { \ncurrentParts = new ConsecutivePartList ( startingPos ) ; \nallParts . add ( currentParts ) ; \n} \nChunkDescriptor chunkDescriptor = new ChunkDescriptor ( columnDescriptor , mc , startingPos , ( int ) range . getLength ( ) ) ; \ncurrentParts . addChunk ( chunkDescriptor ) ; \nbuilder . setOffsetIndex ( chunkDescriptor , filteredOffsetIndex ) ; \n} \n} \n} \nfor ( ConsecutivePartList consecutiveChunks : allParts ) { \nconsecutiveChunks . readAll ( f , builder ) ; \n} \nfor ( Chunk chunk : builder . build ( ) ) { \ncurrentRowGroup . addColumn ( chunk . descriptor . col , chunk . readAllPages ( ) ) ; \n} \nif ( nextDictionaryReader != null ) { \nnextDictionaryReader . setRowGroup ( currentRowGroup ) ; \n} \nadvanceToNextBlock ( ) ; \nreturn currentRowGroup ; \n} \n} \n"}
{"1990": "public class ParquetFileReader { \nDictionaryPage readDictionary ( ColumnChunkMetaData meta ) throws IOException { \nif ( ! meta . getEncodings ( ) . contains ( Encoding . PLAIN_DICTIONARY ) ) { \nif ( ! meta . getEncodings ( ) . contains ( Encoding . RLE_DICTIONARY ) ) { \nreturn null ; \n} \n} \nif ( f . getPos ( ) != meta . getStartingPos ( ) ) { \nf . seek ( meta . getStartingPos ( ) ) ; \n} \nPageHeader pageHeader = Util . readPageHeader ( f ) ; \nif ( ! pageHeader . isSetDictionary_page_header ( ) ) { \nreturn null ; \n} \nDictionaryPage compressedPage = readCompressedDictionary ( pageHeader , f ) ; \nBytesInputDecompressor decompressor = options . getCodecFactory ( ) . getDecompressor ( meta . getCodec ( ) ) ; \nreturn new DictionaryPage ( decompressor . decompress ( compressedPage . getBytes ( ) , compressedPage . getUncompressedSize ( ) ) , compressedPage . getDictionarySize ( ) , compressedPage . getEncoding ( ) ) ; \n} \n} \n"}
{"1993": "public class MemoryManager { \nprivate void updateAllocation ( ) { \nlong totalAllocations = 0 ; \nfor ( Long allocation : writerList . values ( ) ) { \ntotalAllocations += allocation ; \n} \nif ( totalAllocations <= totalMemoryPool ) { \nscale = 1.0 ; \n} \nelse { \nscale = ( double ) totalMemoryPool / totalAllocations ; \nLOG . warn ( String . format ( \"Total allocation exceeds %.2f%% (%,d bytes) of heap memory\\n\" + \"Scaling row group sizes to %.2f%% for %d writers\" , 100 * memoryPoolRatio , totalMemoryPool , 100 * scale , writerList . size ( ) ) ) ; \nfor ( Runnable callBack : callBacks . values ( ) ) { \ncallBack . run ( ) ; \n} \n} \nint maxColCount = 0 ; \nfor ( InternalParquetRecordWriter w : writerList . keySet ( ) ) { \nmaxColCount = Math . max ( w . getSchema ( ) . getColumns ( ) . size ( ) , maxColCount ) ; \n} \nfor ( Map . Entry < InternalParquetRecordWriter , Long > entry : writerList . entrySet ( ) ) { \nlong newSize = ( long ) Math . floor ( entry . getValue ( ) * scale ) ; \nif ( scale < 1.0 && minMemoryAllocation > 0 ) { \nif ( newSize < minMemoryAllocation ) { \nthrow new ParquetRuntimeException ( String . format ( \"New Memory allocation %d bytes\" + \" is smaller than the minimum allocation size of %d bytes.\" , newSize , minMemoryAllocation ) ) { \n} \n; \n} \n} \nentry . getKey ( ) . setRowGroupSizeThreshold ( newSize ) ; \nLOG . debug ( String . format ( \"Adjust block size from %,d to %,d for writer: %s\" , entry . getValue ( ) , newSize , entry . getKey ( ) ) ) ; \n} \n} \n} \n"}
{"2008": "public class ColumnReaderBase { \npublic void readValue ( ) { \ntry { \nif ( ! valueRead ) { \nbinding . read ( ) ; \nvalueRead = true ; \n} \n} \ncatch ( RuntimeException e ) { \nif ( CorruptDeltaByteArrays . requiresSequentialReads ( writerVersion , currentEncoding ) ) { \nif ( e instanceof ArrayIndexOutOfBoundsException ) { \nthrow new ParquetDecodingException ( \"Read failure possibly due to \" + \"PARQUET-246: try setting parquet.split.files to false\" , new ParquetDecodingException ( format ( \"Can't read value in column %s at value %d out of %d, \" + \"%d out of %d in currentPage. repetition level: \" + \"%d, definition level: %d\" , path , readValues , totalValueCount , readValues - ( endOfPageValueCount - pageValueCount ) , pageValueCount , repetitionLevel , definitionLevel ) , e ) ) ; \n} \n} \nthrow new ParquetDecodingException ( format ( \"Can't read value in column %s at value %d out of %d, \" + \"%d out of %d in currentPage. repetition level: \" + \"%d, definition level: %d\" , path , readValues , totalValueCount , readValues - ( endOfPageValueCount - pageValueCount ) , pageValueCount , repetitionLevel , definitionLevel ) , e ) ; \n} \n} \n} \n"}
{"2012": "public class ThriftMetaData { \npublic static ThriftMetaData fromExtraMetaData ( Map < String , String > extraMetaData ) { \nfinal String thriftClassName = extraMetaData . get ( THRIFT_CLASS ) ; \nfinal String thriftDescriptorString = extraMetaData . get ( THRIFT_DESCRIPTOR ) ; \nif ( thriftClassName == null ) { \nreturn null ; \n} \nelse if ( thriftDescriptorString == null ) { \nreturn null ; \n} \nfinal StructType descriptor = parseDescriptor ( thriftDescriptorString ) ; \nreturn new ThriftMetaData ( thriftClassName , descriptor ) ; \n} \n} \n"}
{"2013": "public class ThriftMetaData { \n@ SuppressWarnings ( \"unchecked\" ) public static ThriftMetaData fromThriftClass ( Class < ? > thriftClass ) { \nif ( thriftClass != null ) { \nif ( TBase . class . isAssignableFrom ( thriftClass ) ) { \nClass < ? extends TBase < ? , ? > > tClass = ( Class < ? extends TBase < ? , ? > > ) thriftClass ; \nStructType descriptor = new ThriftSchemaConverter ( ) . toStructType ( tClass ) ; \nreturn new ThriftMetaData ( thriftClass . getName ( ) , descriptor ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2029": "public class GroupType { \nList < Type > mergeFields ( GroupType toMerge , boolean strict ) { \nList < Type > newFields = new ArrayList < Type > ( ) ; \nfor ( Type type : this . getFields ( ) ) { \nType merged ; \nif ( toMerge . containsField ( type . getName ( ) ) ) { \nType fieldToMerge = toMerge . getType ( type . getName ( ) ) ; \nif ( type . getLogicalTypeAnnotation ( ) != null ) { \nif ( ! type . getLogicalTypeAnnotation ( ) . equals ( fieldToMerge . getLogicalTypeAnnotation ( ) ) ) { \nthrow new IncompatibleSchemaModificationException ( \"cannot merge logical type \" + fieldToMerge . getLogicalTypeAnnotation ( ) + \" into \" + type . getLogicalTypeAnnotation ( ) ) ; \n} \n} \nmerged = type . union ( fieldToMerge , strict ) ; \n} \nelse { \nmerged = type ; \n} \nnewFields . add ( merged ) ; \n} \nfor ( Type type : toMerge . getFields ( ) ) { \nif ( ! this . containsField ( type . getName ( ) ) ) { \nnewFields . add ( type ) ; \n} \n} \nreturn newFields ; \n} \n} \n"}
{"2053": "public class LruCache { \npublic void put ( final K key , final V newValue ) { \nif ( newValue == null ) { \nif ( LOG . isWarnEnabled ( ) ) { \nLOG . warn ( \"Ignoring new cache entry for '{}' because it is {}\" , key , ( newValue == null ? \"null\" : \"not current\" ) ) ; \n} \nreturn ; \n} \nelse if ( ! newValue . isCurrent ( key ) ) { \nif ( LOG . isWarnEnabled ( ) ) { \nLOG . warn ( \"Ignoring new cache entry for '{}' because it is {}\" , key , ( newValue == null ? \"null\" : \"not current\" ) ) ; \n} \nreturn ; \n} \nV oldValue = cacheMap . get ( key ) ; \nif ( oldValue != null ) { \nif ( oldValue . isNewerThan ( newValue ) ) { \nif ( LOG . isWarnEnabled ( ) ) { \nLOG . warn ( \"Ignoring new cache entry for '{}' because \" + \"existing cache entry is newer\" , key ) ; \n} \nreturn ; \n} \n} \noldValue = cacheMap . put ( key , newValue ) ; \nif ( LOG . isDebugEnabled ( ) ) { \nif ( oldValue == null ) { \nLOG . debug ( \"Added new cache entry for '{}'\" , key ) ; \n} \nelse { \nLOG . debug ( \"Overwrote existing cache entry for '{}'\" , key ) ; \n} \n} \n} \n} \n"}
{"2054": "public class LruCache { \npublic V getCurrentValue ( final K key ) { \nV value = cacheMap . get ( key ) ; \nLOG . debug ( \"Value for '{}' {} in cache\" , key , ( value == null ? \"not \" : \"\" ) ) ; \nif ( value != null ) { \nif ( ! value . isCurrent ( key ) ) { \nremove ( key ) ; \nreturn null ; \n} \n} \nreturn value ; \n} \n} \n"}
{"2057": "public class PathGlobPattern { \npublic void set ( String glob ) { \nStringBuilder regex = new StringBuilder ( ) ; \nint setOpen = 0 ; \nint curlyOpen = 0 ; \nint len = glob . length ( ) ; \nhasWildcard = false ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = glob . charAt ( i ) ; \nswitch ( c ) { \ncase BACKSLASH : if ( ++ i >= len ) { \nerror ( \"Missing escaped character\" , glob , i ) ; \n} \nregex . append ( c ) . append ( glob . charAt ( i ) ) ; \ncontinue ; \ncase '.' : case '$' : case '(' : case ')' : case '|' : case '+' : regex . append ( BACKSLASH ) ; \nbreak ; \ncase '*' : if ( i + 1 < len ) { \nif ( glob . charAt ( i + 1 ) == '*' ) { \nregex . append ( '.' ) ; \ni ++ ; \nbreak ; \n} \n} \nregex . append ( \"[^\" + PATH_SEPARATOR + \"]\" ) ; \nhasWildcard = true ; \nbreak ; \ncase '?' : regex . append ( '.' ) ; \nhasWildcard = true ; \ncontinue ; \ncase '{' : regex . append ( \"(?:\" ) ; \ncurlyOpen ++ ; \nhasWildcard = true ; \ncontinue ; \ncase ',' : regex . append ( curlyOpen > 0 ? '|' : c ) ; \ncontinue ; \ncase '}' : if ( curlyOpen > 0 ) { \ncurlyOpen -- ; \nregex . append ( \")\" ) ; \ncontinue ; \n} \nbreak ; \ncase '[' : if ( setOpen > 0 ) { \nerror ( \"Unclosed character class\" , glob , i ) ; \n} \nsetOpen ++ ; \nhasWildcard = true ; \nbreak ; \ncase '^' : if ( setOpen == 0 ) { \nregex . append ( BACKSLASH ) ; \n} \nbreak ; \ncase '!' : regex . append ( setOpen > 0 && '[' == glob . charAt ( i - 1 ) ? '^' : '!' ) ; \ncontinue ; \ncase ']' : setOpen = 0 ; \nbreak ; \ndefault : } \nregex . append ( c ) ; \n} \nif ( setOpen > 0 ) { \nerror ( \"Unclosed character class\" , glob , len ) ; \n} \nif ( curlyOpen > 0 ) { \nerror ( \"Unclosed group\" , glob , len ) ; \n} \ncompiled = Pattern . compile ( regex . toString ( ) ) ; \n} \n} \n"}
{"2066": "public class AvroRecordConverter { \nprivate static Map < String , Class < ? > > getFieldsByName ( Class < ? > recordClass , boolean excludeJava ) { \nMap < String , Class < ? > > fields = new LinkedHashMap < String , Class < ? > > ( ) ; \nif ( recordClass != null ) { \nClass < ? > current = recordClass ; \ndo { \nif ( excludeJava && current . getPackage ( ) != null ) { \nif ( current . getPackage ( ) . getName ( ) . startsWith ( \"java.\" ) ) { \nbreak ; \n} \n} \nfor ( Field field : current . getDeclaredFields ( ) ) { \nif ( field . isAnnotationPresent ( AvroIgnore . class ) ) { \ncontinue ; \n} \nelse if ( isTransientOrStatic ( field ) ) { \ncontinue ; \n} \nAvroName altName = field . getAnnotation ( AvroName . class ) ; \nClass < ? > existing = fields . put ( altName != null ? altName . value ( ) : field . getName ( ) , field . getType ( ) ) ; \nif ( existing != null ) { \nthrow new AvroTypeException ( current + \" contains two fields named: \" + field . getName ( ) ) ; \n} \n} \ncurrent = current . getSuperclass ( ) ; \n} \nwhile ( current != null ) ; \n} \nreturn fields ; \n} \n} \n"}
{"2069": "public class MergeCommand { \nprivate void checkParquetFiles ( List < Path > inputFiles ) throws IOException { \nif ( inputFiles == null ) { \nthrow new IllegalArgumentException ( \"Not enough files to merge\" ) ; \n} \nelse if ( inputFiles . size ( ) <= 1 ) { \nthrow new IllegalArgumentException ( \"Not enough files to merge\" ) ; \n} \nfor ( Path inputFile : inputFiles ) { \nFileSystem fs = inputFile . getFileSystem ( conf ) ; \nFileStatus status = fs . getFileStatus ( inputFile ) ; \nif ( status . isDir ( ) ) { \nthrow new IllegalArgumentException ( \"Illegal parquet file: \" + inputFile . toUri ( ) ) ; \n} \n} \n} \n} \n"}
{"2073": "public class Hive010Binding { \nprivate void init ( final JobConf job ) { \nfinal String plan = HiveConf . getVar ( job , HiveConf . ConfVars . PLAN ) ; \nif ( mrwork == null && plan != null ) { \nif ( plan . length ( ) > 0 ) { \nmrwork = Utilities . getMapRedWork ( job ) ; \npathToPartitionInfo . clear ( ) ; \nfor ( final Map . Entry < String , PartitionDesc > entry : mrwork . getPathToPartitionInfo ( ) . entrySet ( ) ) { \npathToPartitionInfo . put ( new Path ( entry . getKey ( ) ) . toUri ( ) . getPath ( ) . toString ( ) , entry . getValue ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"2081": "public class MapR52StreamsValidationUtil09 { \n@ Override public void createTopicIfNotExists ( String topic , Map < String , Object > kafkaClientConfigs , String metadataBrokerList ) throws StageException { \nif ( topic . startsWith ( \"/\" ) ) { \nif ( topic . contains ( \":\" ) ) { \nString [ ] path = topic . split ( \":\" ) ; \nif ( path . length != 2 ) { \nthrow new StageException ( MapRStreamsErrors . MAPRSTREAMS_21 , topic ) ; \n} \nString streamPath = path [ 0 ] ; \nif ( ! streamCache . contains ( streamPath ) ) { \nConfiguration conf = new Configuration ( ) ; \nkafkaClientConfigs . forEach ( ( k , v ) -> { \nconf . set ( k , v . toString ( ) ) ; \n} \n) ; \nAdmin streamAdmin = null ; \ntry { \nstreamAdmin = Streams . newAdmin ( conf ) ; \nstreamAdmin . countTopics ( streamPath ) ; \nstreamCache . add ( streamPath ) ; \n} \ncatch ( TableNotFoundException e ) { \nLOG . debug ( \"Stream not found. Creating a new stream: \" + streamPath ) ; \ntry { \nstreamAdmin . createStream ( streamPath , Streams . newStreamDescriptor ( ) ) ; \nstreamCache . add ( streamPath ) ; \n} \ncatch ( IOException ioex ) { \nthrow new StageException ( MapRStreamsErrors . MAPRSTREAMS_22 , streamPath , e . getMessage ( ) , e ) ; \n} \n} \ncatch ( IOException | IllegalArgumentException e ) { \nthrow new StageException ( MapRStreamsErrors . MAPRSTREAMS_23 , e . getMessage ( ) , e ) ; \n} \nfinally { \nif ( streamAdmin != null ) { \nstreamAdmin . close ( ) ; \n} \n} \n} \n} \n} \nKafkaProducer < String , String > kafkaProducer = createProducerTopicMetadataClient ( kafkaClientConfigs ) ; \nkafkaProducer . partitionsFor ( topic ) ; \n} \n} \n"}
{"2088": "public class AvroTypeUtil { \npublic static String getAvroSchemaFromHeader ( Record record , String headerName ) throws DataGeneratorException { \nString jsonSchema = record . getHeader ( ) . getAttribute ( headerName ) ; \nif ( jsonSchema == null ) { \nthrow new DataGeneratorException ( Errors . AVRO_GENERATOR_03 , record . getHeader ( ) . getSourceId ( ) ) ; \n} \nelse if ( jsonSchema . isEmpty ( ) ) { \nthrow new DataGeneratorException ( Errors . AVRO_GENERATOR_03 , record . getHeader ( ) . getSourceId ( ) ) ; \n} \nreturn jsonSchema ; \n} \n} \n"}
{"2097": "public class PipelineConfigurationUpgrader { \npublic PipelineConfiguration upgradeIfNecessary ( StageLibraryTask library , PipelineConfiguration pipelineConf , List < Issue > issues ) { \nPreconditions . checkArgument ( issues . isEmpty ( ) , \"Given list of issues must be empty.\" ) ; \nboolean upgrade ; \nupgrade = needsSchemaUpgrade ( pipelineConf , issues ) ; \nif ( upgrade ) { \nif ( issues . isEmpty ( ) ) { \npipelineConf = upgradeSchema ( library , pipelineConf , issues ) ; \n} \n} \nif ( ! issues . isEmpty ( ) ) { \nreturn null ; \n} \nupgrade = needsUpgrade ( library , pipelineConf , issues ) ; \nif ( upgrade ) { \nif ( issues . isEmpty ( ) ) { \npipelineConf = upgrade ( library , pipelineConf , issues ) ; \n} \n} \nreturn ( issues . isEmpty ( ) ) ? pipelineConf : null ; \n} \n} \n"}
{"2103": "public class SystemPackage { \nprivate static boolean isSystemClass ( String name , List < String > packageList ) { \nboolean result = false ; \nif ( packageList != null ) { \nString canonicalName = ClassLoaderUtil . canonicalizeClassOrResource ( name ) ; \nfor ( String c : packageList ) { \nboolean shouldInclude = true ; \nif ( c . startsWith ( \"-\" ) ) { \nc = c . substring ( 1 ) ; \nshouldInclude = false ; \n} \nif ( canonicalName . startsWith ( c ) ) { \nif ( c . endsWith ( \".\" ) || canonicalName . length ( ) == c . length ( ) ) { \nif ( shouldInclude ) { \nresult = true ; \n} \nelse { \nreturn false ; \n} \n} \nelse if ( canonicalName . length ( ) > c . length ( ) && canonicalName . charAt ( c . length ( ) ) == '$' ) { \nif ( shouldInclude ) { \nresult = true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"2133": "public class HttpClientSource { \nprivate Optional < String > processResponse ( long start , int maxRecords , BatchMaker batchMaker ) throws StageException { \nOptional < String > newSourceOffset = Optional . empty ( ) ; \nif ( getResponse ( ) == null ) { \nreturn newSourceOffset ; \n} \nint status = getResponse ( ) . getStatus ( ) ; \nif ( status < 200 ) { \nlastRequestCompletedTime = System . currentTimeMillis ( ) ; \nString reason = getResponse ( ) . getStatusInfo ( ) . getReasonPhrase ( ) ; \nString respString = getResponse ( ) . readEntity ( String . class ) ; \ngetResponse ( ) . close ( ) ; \nsetResponse ( null ) ; \nfinal String errorMsg = reason + \" : \" + respString ; \nLOG . warn ( Errors . HTTP_01 . getMessage ( ) , status , errorMsg ) ; \nerrorRecordHandler . onError ( Errors . HTTP_01 , status , errorMsg ) ; \nreturn newSourceOffset ; \n} \nelse if ( status >= 300 ) { \nlastRequestCompletedTime = System . currentTimeMillis ( ) ; \nString reason = getResponse ( ) . getStatusInfo ( ) . getReasonPhrase ( ) ; \nString respString = getResponse ( ) . readEntity ( String . class ) ; \ngetResponse ( ) . close ( ) ; \nsetResponse ( null ) ; \nfinal String errorMsg = reason + \" : \" + respString ; \nLOG . warn ( Errors . HTTP_01 . getMessage ( ) , status , errorMsg ) ; \nerrorRecordHandler . onError ( Errors . HTTP_01 , status , errorMsg ) ; \nreturn newSourceOffset ; \n} \nif ( conf . pagination . mode == PaginationMode . LINK_HEADER ) { \nnext = getResponse ( ) . getLink ( \"next\" ) ; \nif ( next == null ) { \nhaveMorePages = false ; \n} \n} \nif ( getResponse ( ) . hasEntity ( ) ) { \nnewSourceOffset = Optional . of ( parseResponse ( start , maxRecords , batchMaker ) ) ; \n} \nelse if ( conf . httpMethod . getLabel ( ) == \"HEAD\" ) { \nnewSourceOffset = Optional . of ( parseHeadersOnly ( batchMaker ) ) ; \n} \nreturn newSourceOffset ; \n} \n} \n"}
{"2137": "public class GoogleCloudCredentialsConfig { \nprivate Credentials getCredentials ( Stage . Context context , List < Stage . ConfigIssue > issues ) { \nCredentials credentials = null ; \nFile credentialsFile ; \nif ( Paths . get ( path ) . isAbsolute ( ) ) { \ncredentialsFile = new File ( path ) ; \n} \nelse { \ncredentialsFile = new File ( context . getResourcesDirectory ( ) , path ) ; \n} \nif ( ! credentialsFile . exists ( ) ) { \nLOG . error ( GOOGLE_01 . getMessage ( ) , credentialsFile . getPath ( ) ) ; \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , CONF_CREDENTIALS_CREDENTIALS_PROVIDER , GOOGLE_01 , credentialsFile . getPath ( ) ) ) ; \nreturn null ; \n} \nelse if ( ! credentialsFile . isFile ( ) ) { \nLOG . error ( GOOGLE_01 . getMessage ( ) , credentialsFile . getPath ( ) ) ; \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , CONF_CREDENTIALS_CREDENTIALS_PROVIDER , GOOGLE_01 , credentialsFile . getPath ( ) ) ) ; \nreturn null ; \n} \ntry ( InputStream in = new FileInputStream ( credentialsFile ) ) { \ncredentials = ServiceAccountCredentials . fromStream ( in ) ; \n} \ncatch ( IOException | IllegalArgumentException e ) { \nLOG . error ( GOOGLE_02 . getMessage ( ) , e ) ; \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , CONF_CREDENTIALS_CREDENTIALS_PROVIDER , GOOGLE_02 ) ) ; \n} \nreturn credentials ; \n} \n} \n"}
{"2150": "public class GrokDictionary { \nprivate String digestExpressionAux ( String originalExpression ) { \nfinal String PATTERN_START = \"%{\" ; \nfinal String PATTERN_STOP = \"}\" ; \nfinal char PATTERN_DELIMITER = ':' ; \nwhile ( true ) { \nint PATTERN_START_INDEX = originalExpression . indexOf ( PATTERN_START ) ; \nint PATTERN_STOP_INDEX = originalExpression . indexOf ( PATTERN_STOP , PATTERN_START_INDEX + PATTERN_START . length ( ) ) ; \nif ( PATTERN_START_INDEX < 0 ) { \nbreak ; \n} \nelse if ( PATTERN_STOP_INDEX < 0 ) { \nbreak ; \n} \nString grokPattern = originalExpression . substring ( PATTERN_START_INDEX + PATTERN_START . length ( ) , PATTERN_STOP_INDEX ) ; \nint PATTERN_DELIMITER_INDEX = grokPattern . indexOf ( PATTERN_DELIMITER ) ; \nString regexName = grokPattern ; \nString groupName = null ; \nif ( PATTERN_DELIMITER_INDEX >= 0 ) { \nregexName = grokPattern . substring ( 0 , PATTERN_DELIMITER_INDEX ) ; \ngroupName = grokPattern . substring ( PATTERN_DELIMITER_INDEX + 1 , grokPattern . length ( ) ) ; \n} \nfinal String dictionaryValue = regexDictionary . get ( regexName ) ; \nif ( dictionaryValue == null ) { \nthrow new GrokCompilationException ( \"Missing value for regex name : \" + regexName ) ; \n} \nif ( dictionaryValue . contains ( PATTERN_START ) ) { \nbreak ; \n} \nString replacement = dictionaryValue ; \nif ( null != groupName ) { \nreplacement = \"(?<\" + groupName + \">\" + dictionaryValue + \")\" ; \n} \noriginalExpression = new StringBuilder ( originalExpression ) . replace ( PATTERN_START_INDEX , PATTERN_STOP_INDEX + PATTERN_STOP . length ( ) , replacement ) . toString ( ) ; \n} \nreturn originalExpression ; \n} \n} \n"}
{"2168": "public class HiveMetastoreUtil { \npublic static Field newSchemaMetadataFieldBuilder ( String database , String tableName , LinkedHashMap < String , HiveTypeInfo > columnList , LinkedHashMap < String , HiveTypeInfo > partitionTypeList , boolean internal , String location , String avroSchema , HMPDataFormat dataFormat ) throws HiveStageCheckedException { \nLinkedHashMap < String , Field > metadata = new LinkedHashMap < > ( ) ; \nmetadata . put ( VERSION , Field . create ( SCHEMA_CHANGE_METADATA_RECORD_VERSION ) ) ; \nmetadata . put ( METADATA_RECORD_TYPE , Field . create ( MetadataRecordType . TABLE . name ( ) ) ) ; \nmetadata . put ( DATABASE_FIELD , Field . create ( database ) ) ; \nmetadata . put ( TABLE_FIELD , Field . create ( tableName ) ) ; \nmetadata . put ( LOCATION_FIELD , Field . create ( location ) ) ; \nmetadata . put ( DATA_FORMAT , Field . create ( dataFormat . name ( ) ) ) ; \nmetadata . put ( COLUMNS_FIELD , generateInnerFieldFromTheList ( columnList , COLUMN_NAME , TYPE_INFO , true ) ) ; \nif ( partitionTypeList != null ) { \nif ( ! partitionTypeList . isEmpty ( ) ) { \nmetadata . put ( PARTITION_FIELD , generateInnerFieldFromTheList ( partitionTypeList , PARTITION_NAME , TYPE_INFO , true ) ) ; \n} \n} \nmetadata . put ( INTERNAL_FIELD , Field . create ( internal ) ) ; \nmetadata . put ( AVRO_SCHEMA , Field . create ( avroSchema ) ) ; \nreturn Field . createListMap ( metadata ) ; \n} \n} \n"}
{"2174": "public class SyslogDecoder { \npublic static long parseRfc3164Time ( String ts ) throws OnRecordErrorException { \nLocalDateTime now = LocalDateTime . now ( ) ; \nint year = now . getYear ( ) ; \nts = TWO_SPACES . matcher ( ts ) . replaceFirst ( \" \" ) ; \nLocalDateTime date ; \ntry { \nMonthDay monthDay = MonthDay . parse ( ts , rfc3164Format ) ; \nLocalTime time = LocalTime . parse ( ts , rfc3164Format ) ; \ndate = now ; \ndate = date . with ( ChronoField . MILLI_OF_SECOND , 0 ) ; \ndate = date . withMonth ( monthDay . getMonthValue ( ) ) . withDayOfMonth ( monthDay . getDayOfMonth ( ) ) ; \ndate = date . withHour ( time . getHour ( ) ) . withMinute ( time . getMinute ( ) ) . withSecond ( time . getSecond ( ) ) ; \n} \ncatch ( DateTimeParseException e ) { \nthrow new OnRecordErrorException ( Errors . SYSLOG_10 , ts , e ) ; \n} \nLocalDateTime fixed = date ; \nif ( fixed . isAfter ( now ) && fixed . minusMonths ( 1 ) . isAfter ( now ) ) { \nfixed = date . withYear ( year - 1 ) ; \n} \nelse if ( fixed . isBefore ( now ) ) { \nif ( fixed . plusMonths ( 11 ) . isBefore ( now ) ) { \nfixed = date . withYear ( year + 1 ) ; \n} \n} \ndate = fixed ; \nreturn date . toInstant ( ZoneOffset . UTC ) . toEpochMilli ( ) ; \n} \n} \n"}
{"2175": "public class Utils { \npublic static String format ( String template , Object ... args ) { \nString [ ] templateArr = TEMPLATES . get ( template ) ; \nif ( templateArr == null ) { \ntemplateArr = prepareTemplate ( template ) ; \nTEMPLATES . put ( template , templateArr ) ; \n} \nStringBuilder sb = new StringBuilder ( template . length ( ) * 2 ) ; \nfor ( int i = 0 ; \ni < templateArr . length ; \ni ++ ) { \nsb . append ( templateArr [ i ] ) ; \nif ( args != null ) { \nif ( i < templateArr . length - 1 ) { \nsb . append ( ( i < args . length ) ? args [ i ] : TOKEN ) ; \n} \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2188": "public class CouchbaseTarget { \nprivate WriteOperationType getOperationFromHeader ( Record record , String key ) { \nString op = record . getHeader ( ) . getAttribute ( OperationType . SDC_OPERATION_TYPE ) ; \nif ( op == null ) { \nreturn config . defaultWriteOperation ; \n} \nelse if ( op . isEmpty ( ) ) { \nreturn config . defaultWriteOperation ; \n} \nint opCode ; \ntry { \nopCode = Integer . parseInt ( op ) ; \n} \ncatch ( NumberFormatException e ) { \nLOG . debug ( \"Unparsable CDC operation. Sending record to error.\" ) ; \nhandleError ( record , Errors . COUCHBASE_08 , e ) ; \nreturn null ; \n} \nswitch ( opCode ) { \ncase OperationType . INSERT_CODE : return WriteOperationType . INSERT ; \ncase OperationType . UPDATE_CODE : return WriteOperationType . REPLACE ; \ncase OperationType . UPSERT_CODE : return WriteOperationType . UPSERT ; \ncase OperationType . DELETE_CODE : return WriteOperationType . DELETE ; \ndefault : switch ( config . unsupportedOperation ) { \ncase DISCARD : LOG . debug ( \"Unsupported CDC operation for key: {}. Discarding record per configuration.\" , key ) ; \nreturn null ; \ncase TOERROR : LOG . debug ( \"Unsupported CDC operation for key: {}. Sending record to error configuration.\" , key ) ; \nhandleError ( record , Errors . COUCHBASE_09 , new RuntimeException ( ) ) ; \nreturn null ; \ndefault : LOG . debug ( \"Unsupported CDC operation for key: {}. Using default write operation per configuration.\" , key ) ; \nreturn config . defaultWriteOperation ; \n} \n} \n} \n} \n"}
{"2200": "public class SQLParserUtils { \nprivate static String formatValue ( String value ) { \nif ( value == null ) { \nreturn null ; \n} \nelse if ( NULL_STRING . equalsIgnoreCase ( value ) ) { \nreturn null ; \n} \nString returnValue = format ( value ) ; \nreturn returnValue . replaceAll ( \"''\" , \"'\" ) ; \n} \n} \n"}
{"2230": "public class HiveMetadataProcessor { \nprivate Map < PartitionInfoCacheSupport . PartitionValues , String > detectNewPartition ( PartitionInfoCacheSupport . PartitionValues partitionValues , PartitionInfoCacheSupport . PartitionInfo pCache , String location ) throws StageException { \nMap < PartitionInfoCacheSupport . PartitionValues , String > partitionInfoDiff = new HashMap < > ( ) ; \npartitionInfoDiff . put ( partitionValues , location ) ; \npartitionInfoDiff = ( pCache != null ) ? pCache . getDiff ( partitionInfoDiff ) : partitionInfoDiff ; \nif ( pCache == null ) { \nreturn partitionInfoDiff ; \n} \nelse if ( ! partitionInfoDiff . isEmpty ( ) ) { \nreturn partitionInfoDiff ; \n} \nreturn null ; \n} \n} \n"}
{"2265": "public class ApiClient { \npublic ApiClient setDPMBaseURL ( String dpmBaseURL ) { \nif ( dpmBaseURL != null ) { \nif ( authentication != null ) { \nauthentication . setDPMBaseURL ( dpmBaseURL ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"2279": "public class ForceSource { \nprivate boolean checkConditionExpressions ( SOQLParser . ConditionExpressionsContext conditionExpressions , String fieldName ) { \nfor ( SOQLParser . ConditionExpressionContext ce : conditionExpressions . conditionExpression ( ) ) { \nif ( ce . conditionExpressions ( ) != null && checkConditionExpressions ( ce . conditionExpressions ( ) , fieldName ) ) { \nreturn true ; \n} \nelse if ( ce . fieldExpression ( ) != null && ce . fieldExpression ( ) . fieldElement ( ) . getText ( ) . equalsIgnoreCase ( fieldName ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2283": "public class BigQueryDelegate { \npublic TableResult runQuery ( QueryJobConfiguration queryConfig , long timeout , long pageSize ) throws StageException { \ncheckArgument ( timeout >= 1000 , \"Timeout must be at least one second.\" ) ; \nInstant maxTime = Instant . now ( ) . plusMillis ( timeout ) ; \nJobId jobId = JobId . of ( UUID . randomUUID ( ) . toString ( ) ) ; \nJobInfo jobInfo = JobInfo . newBuilder ( queryConfig ) . setJobId ( jobId ) . build ( ) ; \nJob queryJob = bigquery . create ( jobInfo ) ; \nif ( queryJob == null ) { \nLOG . error ( \"Job no longer exists: {}\" , jobInfo ) ; \nthrow new RuntimeException ( \"Job no longer exists: \" + jobInfo ) ; \n} \nelse if ( queryJob . getStatus ( ) . getError ( ) != null ) { \nBigQueryError error = queryJob . getStatus ( ) . getError ( ) ; \nLOG . error ( \"Query Job execution error: {}\" , error ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , error ) ; \n} \nwhile ( ! queryJob . isDone ( ) ) { \nif ( Instant . now ( clock ) . isAfter ( maxTime ) ) { \nif ( bigquery . cancel ( queryJob . getJobId ( ) ) ) { \nLOG . info ( \"Job {} cancelled successfully.\" , queryJob . getJobId ( ) ) ; \n} \nelse { \nLOG . warn ( \"Job {} not found\" , queryJob . getJobId ( ) ) ; \n} \nthrow new StageException ( Errors . BIGQUERY_00 ) ; \n} \nelse if ( ! ThreadUtil . sleep ( 100 ) ) { \nif ( bigquery . cancel ( queryJob . getJobId ( ) ) ) { \nLOG . info ( \"Job {} cancelled successfully.\" , queryJob . getJobId ( ) ) ; \n} \nelse { \nLOG . warn ( \"Job {} not found\" , queryJob . getJobId ( ) ) ; \n} \nthrow new StageException ( Errors . BIGQUERY_00 ) ; \n} \n} \nif ( queryJob . getStatus ( ) . getError ( ) != null ) { \nString errorMsg = queryJob . getStatus ( ) . getError ( ) . toString ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nTableResult result = null ; \ntry { \nresult = queryJob . getQueryResults ( QueryResultsOption . pageSize ( pageSize ) ) ; \n} \ncatch ( InterruptedException e ) { \nString errorMsg = e . getMessage ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nreturn result ; \n} \n} \n"}
{"2285": "public class KineticaTableUtils { \nprivate List < String > getTableDescription ( ) throws GPUdbException { \nList < List < String > > descriptions = showTableResponse . getTableDescriptions ( ) ; \nif ( descriptions == null ) { \nthrow new GPUdbException ( \"Error getting description for table \" + tableName ) ; \n} \nelse if ( descriptions . size ( ) != 1 ) { \nthrow new GPUdbException ( \"Error getting description for table \" + tableName ) ; \n} \nreturn descriptions . get ( 0 ) ; \n} \n} \n"}
{"2289": "public class KineticaTableUtils { \nprivate JSONObject getTableSchema ( String tableName , ShowTableResponse showTableResponse ) throws GPUdbException { \nList < String > schemas = showTableResponse . getTypeSchemas ( ) ; \nif ( schemas == null ) { \nthrow new GPUdbException ( \"Error getting schema for table \" + tableName ) ; \n} \nelse if ( schemas . size ( ) != 1 ) { \nthrow new GPUdbException ( \"Error getting schema for table \" + tableName ) ; \n} \nreturn new JSONObject ( schemas . get ( 0 ) ) ; \n} \n} \n"}
{"2290": "public class KineticaTableUtils { \nprivate Map < String , List < String > > getColumnProperties ( String tableName , ShowTableResponse showTableResponse ) throws GPUdbException { \nList < Map < String , List < String > > > columnPropertiesList = showTableResponse . getProperties ( ) ; \nif ( columnPropertiesList == null ) { \nthrow new GPUdbException ( \"Error getting properties for table \" + tableName ) ; \n} \nelse if ( columnPropertiesList . size ( ) != 1 ) { \nthrow new GPUdbException ( \"Error getting properties for table \" + tableName ) ; \n} \nreturn columnPropertiesList . get ( 0 ) ; \n} \n} \n"}
{"2293": "public class MqttClientTarget { \nString getTopic ( Record record ) throws StageException { \nString result = publisherConf . topic ; \nif ( publisherConf . runtimeTopicResolution ) { \nRecordEL . setRecordInContext ( topicVars , record ) ; \ntry { \nresult = topicEval . eval ( topicVars , publisherConf . topicExpression , String . class ) ; \nif ( isEmpty ( result ) ) { \nthrow new StageException ( Errors . MQTT_08 , publisherConf . topicExpression , record . getHeader ( ) . getSourceId ( ) ) ; \n} \nif ( ! allowedTopics . contains ( result ) ) { \nif ( ! allowAllTopics ) { \nthrow new StageException ( Errors . MQTT_09 , result , record . getHeader ( ) . getSourceId ( ) ) ; \n} \n} \n} \ncatch ( ELEvalException e ) { \nthrow new StageException ( Errors . MQTT_10 , publisherConf . topicExpression , record . getHeader ( ) . getSourceId ( ) , e . toString ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"2309": "public class FileFilter { \nprivate static String globToRegex ( String glob ) { \nif ( glob . charAt ( 0 ) == '.' || glob . contains ( \"/\" ) ) { \nthrow new IllegalArgumentException ( \"Invalid character in file glob\" ) ; \n} \nelse if ( glob . contains ( \"~\" ) ) { \nthrow new IllegalArgumentException ( \"Invalid character in file glob\" ) ; \n} \nglob = glob . replace ( \".\" , \"\\\\.\" ) ; \nglob = glob . replace ( \"*\" , \".+\" ) ; \nglob = glob . replace ( \"?\" , \".{1}+\" ) ; \nreturn glob ; \n} \n} \n"}
{"2314": "public class CassandraTarget { \n@ SuppressWarnings ( \"unchecked\" ) private BoundStatement recordToBoundStatement ( Record record ) throws StageException { \nImmutableList . Builder < Object > values = new ImmutableList . Builder < > ( ) ; \nSortedSet < String > columnsPresent = Sets . newTreeSet ( columnMappings . keySet ( ) ) ; \nfor ( Map . Entry < String , String > mapping : columnMappings . entrySet ( ) ) { \nString columnName = mapping . getKey ( ) ; \nString fieldPath = mapping . getValue ( ) ; \nif ( ! record . has ( fieldPath ) ) { \ncolumnsPresent . remove ( columnName ) ; \ncontinue ; \n} \nelse if ( record . get ( fieldPath ) . getValue ( ) == null ) { \ncolumnsPresent . remove ( columnName ) ; \ncontinue ; \n} \nfinal Object value = record . get ( fieldPath ) . getValue ( ) ; \nif ( value instanceof List ) { \nList < Object > unpackedList = new ArrayList < > ( ) ; \nfor ( Field item : ( List < Field > ) value ) { \nunpackedList . add ( item . getValue ( ) ) ; \n} \nvalues . add ( unpackedList ) ; \n} \nelse if ( value instanceof Map ) { \nMap < Object , Object > unpackedMap = new HashMap < > ( ) ; \nfor ( Map . Entry < String , Field > entry : ( ( Map < String , Field > ) value ) . entrySet ( ) ) { \nunpackedMap . put ( entry . getKey ( ) , entry . getValue ( ) . getValue ( ) ) ; \n} \nvalues . add ( unpackedMap ) ; \n} \nelse { \nvalues . add ( value ) ; \n} \n} \nPreparedStatement stmt = statementCache . getUnchecked ( columnsPresent ) ; \nObject [ ] valuesArray = values . build ( ) . toArray ( ) ; \nBoundStatement boundStmt = null ; \ntry { \nboundStmt = stmt . bind ( valuesArray ) ; \n} \ncatch ( CodecNotFoundException | InvalidTypeException | NullPointerException e ) { \nerrorRecordHandler . onError ( new OnRecordErrorException ( record , Errors . CASSANDRA_06 , record . getHeader ( ) . getSourceId ( ) , e . toString ( ) , e ) ) ; \n} \nreturn boundStmt ; \n} \n} \n"}
{"2317": "public class MultithreadedTableProvider { \nprivate void handlePartitioningTurnedOffOrOn ( SortedSetMultimap < TableContext , TableRuntimeContext > reconstructedPartitions ) { \nfor ( TableContext tableContext : reconstructedPartitions . keySet ( ) ) { \nfinal SortedSet < TableRuntimeContext > partitions = reconstructedPartitions . get ( tableContext ) ; \nfinal TableRuntimeContext lastPartition = partitions . last ( ) ; \nfinal TableContext sourceTableContext = lastPartition . getSourceTableContext ( ) ; \nUtils . checkState ( sourceTableContext . equals ( tableContext ) , String . format ( \"Source table context for %s should match TableContext map key of %s\" , lastPartition . getDescription ( ) , tableContext . getQualifiedName ( ) ) ) ; \nfinal boolean partitioningTurnedOff = lastPartition . isPartitioned ( ) && sourceTableContext . getPartitioningMode ( ) == PartitioningMode . DISABLED ; \nfinal boolean partitioningTurnedOn = ! lastPartition . isPartitioned ( ) && sourceTableContext . isPartitionable ( ) && sourceTableContext . getPartitioningMode ( ) != PartitioningMode . DISABLED ; \nif ( ! partitioningTurnedOff ) { \nif ( ! partitioningTurnedOn ) { \ncontinue ; \n} \n} \nfinal Map < String , String > nextStartingOffsets = new HashMap < > ( ) ; \nfinal Map < String , String > nextMaxOffsets = new HashMap < > ( ) ; \nfinal int newPartitionSequence = lastPartition . getPartitionSequence ( ) > 0 ? lastPartition . getPartitionSequence ( ) + 1 : 1 ; \nif ( partitioningTurnedOff ) { \nLOG . info ( \"Table {} has switched from partitioned to non-partitioned; partition sequence {} will be the last (with\" + \" no max offsets)\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStartOffset = lastPartition . generateNextPartitionOffset ( col , off ) ; \nnextStartingOffsets . put ( col , basedOnStartOffset ) ; \n} \n) ; \n} \nelse if ( partitioningTurnedOn ) { \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStoredOffset = lastPartition . getInitialStoredOffsets ( ) . get ( col ) ; \nnextStartingOffsets . put ( col , basedOnStoredOffset ) ; \n} \n) ; \nnextStartingOffsets . forEach ( ( col , off ) -> nextMaxOffsets . put ( col , lastPartition . generateNextPartitionOffset ( col , off ) ) ) ; \nif ( ! reconstructedPartitions . remove ( sourceTableContext , lastPartition ) ) { \nthrow new IllegalStateException ( String . format ( \"Failed to remove partition %s for table %s in switching partitioning from off to on\" , lastPartition . getDescription ( ) , sourceTableContext . getQualifiedName ( ) ) ) ; \n} \nLOG . info ( \"Table {} has switched from non-partitioned to partitioned; using last stored offsets as the starting\" + \" offsets for the new partition {}\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \n} \nfinal TableRuntimeContext nextPartition = new TableRuntimeContext ( sourceTableContext , lastPartition . isUsingNonIncrementalLoad ( ) , ( lastPartition . isPartitioned ( ) && ! partitioningTurnedOff ) || partitioningTurnedOn , newPartitionSequence , nextStartingOffsets , nextMaxOffsets ) ; \nreconstructedPartitions . put ( sourceTableContext , nextPartition ) ; \n} \n} \n} \n"}
{"2320": "public class SchAdmin { \npublic static void enableDPM ( DPMInfoJson dpmInfo , Context context ) throws IOException { \nUtils . checkNotNull ( dpmInfo , \"DPMInfo\" ) ; \nString dpmBaseURL = normalizeDpmBaseURL ( dpmInfo . getBaseURL ( ) ) ; \nString currentDPMBaseURL = context . configuration . get ( RemoteSSOService . DPM_BASE_URL_CONFIG , \"\" ) ; \nString currentAppAuthToken = context . configuration . get ( RemoteSSOService . SECURITY_SERVICE_APP_AUTH_TOKEN_CONFIG , \"\" ) . trim ( ) ; \nif ( ! currentDPMBaseURL . equals ( dpmBaseURL ) ) { \nString userAuthToken = retrieveUserToken ( dpmBaseURL , dpmInfo . getUserID ( ) , dpmInfo . getUserPassword ( ) ) ; \nString appAuthToken = null ; \nResponse response = null ; \ntry { \nMap < String , Object > newComponentJson = new HashMap < > ( ) ; \nnewComponentJson . put ( \"organization\" , dpmInfo . getOrganization ( ) ) ; \nnewComponentJson . put ( \"componentType\" , \"dc\" ) ; \nnewComponentJson . put ( \"numberOfComponents\" , 1 ) ; \nnewComponentJson . put ( \"active\" , true ) ; \nresponse = ClientBuilder . newClient ( ) . target ( dpmBaseURL + \"/security/rest/v1/organization/\" + dpmInfo . getOrganization ( ) + \"/components\" ) . register ( new CsrfProtectionFilter ( \"CSRF\" ) ) . request ( ) . header ( SSOConstants . X_USER_AUTH_TOKEN , userAuthToken ) . put ( Entity . json ( newComponentJson ) ) ; \nif ( response . getStatus ( ) != Response . Status . CREATED . getStatusCode ( ) ) { \nthrow new RuntimeException ( Utils . format ( \"DPM Create Application Token failed, status code '{}': {}\" , response . getStatus ( ) , response . readEntity ( String . class ) ) ) ; \n} \nList < Map < String , Object > > newComponent = response . readEntity ( new GenericType < List < Map < String , Object > > > ( ) { \n} \n) ; \nif ( newComponent . size ( ) > 0 ) { \nappAuthToken = ( String ) newComponent . get ( 0 ) . get ( \"fullAuthToken\" ) ; \n} \nelse { \nthrow new RuntimeException ( \"DPM Create Application Token failed: No token data from DPM Server.\" ) ; \n} \n} \nfinally { \nif ( response != null ) { \nresponse . close ( ) ; \n} \nlogout ( dpmBaseURL , userAuthToken ) ; \n} \nupdateTokenFile ( context , appAuthToken ) ; \n} \nelse if ( currentAppAuthToken . length ( ) == 0 ) { \nString userAuthToken = retrieveUserToken ( dpmBaseURL , dpmInfo . getUserID ( ) , dpmInfo . getUserPassword ( ) ) ; \nString appAuthToken = null ; \nResponse response = null ; \ntry { \nMap < String , Object > newComponentJson = new HashMap < > ( ) ; \nnewComponentJson . put ( \"organization\" , dpmInfo . getOrganization ( ) ) ; \nnewComponentJson . put ( \"componentType\" , \"dc\" ) ; \nnewComponentJson . put ( \"numberOfComponents\" , 1 ) ; \nnewComponentJson . put ( \"active\" , true ) ; \nresponse = ClientBuilder . newClient ( ) . target ( dpmBaseURL + \"/security/rest/v1/organization/\" + dpmInfo . getOrganization ( ) + \"/components\" ) . register ( new CsrfProtectionFilter ( \"CSRF\" ) ) . request ( ) . header ( SSOConstants . X_USER_AUTH_TOKEN , userAuthToken ) . put ( Entity . json ( newComponentJson ) ) ; \nif ( response . getStatus ( ) != Response . Status . CREATED . getStatusCode ( ) ) { \nthrow new RuntimeException ( Utils . format ( \"DPM Create Application Token failed, status code '{}': {}\" , response . getStatus ( ) , response . readEntity ( String . class ) ) ) ; \n} \nList < Map < String , Object > > newComponent = response . readEntity ( new GenericType < List < Map < String , Object > > > ( ) { \n} \n) ; \nif ( newComponent . size ( ) > 0 ) { \nappAuthToken = ( String ) newComponent . get ( 0 ) . get ( \"fullAuthToken\" ) ; \n} \nelse { \nthrow new RuntimeException ( \"DPM Create Application Token failed: No token data from DPM Server.\" ) ; \n} \n} \nfinally { \nif ( response != null ) { \nresponse . close ( ) ; \n} \nlogout ( dpmBaseURL , userAuthToken ) ; \n} \nupdateTokenFile ( context , appAuthToken ) ; \n} \nupdateDpmProperties ( context , dpmBaseURL , dpmInfo . getLabels ( ) , true ) ; \n} \n} \n"}
{"2330": "public class AvroSchemaGenerator { \nprivate JsonNode getDefaultValue ( Schema schema ) { \nif ( getConfig ( ) . avroNullableFields ) { \nif ( getConfig ( ) . avroDefaultNullable ) { \nreturn NullNode . getInstance ( ) ; \n} \n} \nif ( ! getConfig ( ) . avroNullableFields ) { \nif ( defaultValuesForTypes . containsKey ( schema . getType ( ) ) ) { \nreturn defaultValuesForTypes . get ( schema . getType ( ) ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2332": "public class LocalFileSystem { \npublic int compare ( WrappedFile path1 , WrappedFile path2 , boolean useLastModified ) { \ntry { \nif ( useLastModified ) { \nif ( ! exists ( path2 ) ) { \nreturn 1 ; \n} \n} \nreturn getComparator ( useLastModified ) . compare ( path1 , path2 ) ; \n} \ncatch ( RuntimeException ex ) { \nThrowable cause = ex . getCause ( ) ; \nif ( cause != null ) { \nif ( cause instanceof NoSuchFileException ) { \nLOG . debug ( \"Starting file may have already been archived.\" , cause ) ; \nreturn 1 ; \n} \n} \nLOG . warn ( \"Error while comparing files\" , ex ) ; \nthrow ex ; \n} \n} \n} \n"}
{"2342": "public class OracleCDCSource { \nprivate boolean refreshSchema ( BigDecimal scnDecimal , SchemaAndTable schemaAndTable ) throws SQLException { \ntry { \nif ( ! tableSchemaLastUpdate . containsKey ( schemaAndTable ) ) { \nif ( containerized ) { \ntry ( Statement switchToPdb = connection . createStatement ( ) ) { \nswitchToPdb . execute ( \"ALTER SESSION SET CONTAINER = \" + configBean . pdb ) ; \n} \n} \ntableSchemas . put ( schemaAndTable , getTableSchema ( schemaAndTable ) ) ; \ntableSchemaLastUpdate . put ( schemaAndTable , scnDecimal ) ; \nreturn true ; \n} \nelse if ( scnDecimal . compareTo ( tableSchemaLastUpdate . get ( schemaAndTable ) ) > 0 ) { \nif ( containerized ) { \ntry ( Statement switchToPdb = connection . createStatement ( ) ) { \nswitchToPdb . execute ( \"ALTER SESSION SET CONTAINER = \" + configBean . pdb ) ; \n} \n} \ntableSchemas . put ( schemaAndTable , getTableSchema ( schemaAndTable ) ) ; \ntableSchemaLastUpdate . put ( schemaAndTable , scnDecimal ) ; \nreturn true ; \n} \nreturn false ; \n} \nfinally { \nalterSession ( ) ; \n} \n} \n} \n"}
{"2348": "public class CollectdParser { \nprivate int parsePart ( int startOffset , ByteBuf buf , Map < String , Field > fields ) throws OnRecordErrorException { \nint offset = startOffset ; \nint type = buf . getUnsignedShort ( offset ) ; \noffset += 2 ; \nfinal int length = buf . getUnsignedShort ( offset ) ; \noffset += 2 ; \nswitch ( type ) { \ncase HOST : case PLUGIN : case PLUGIN_INSTANCE : case TYPE : case TYPE_INSTANCE : case MESSAGE : pruneFields ( type ) ; \nfields . put ( PART_TYPES . get ( type ) , Field . create ( parseString ( offset , length , buf ) ) ) ; \noffset += length - 4 ; \nbreak ; \ncase TIME_HIRES : case INTERVAL_HIRES : if ( type != INTERVAL_HIRES ) { \nlong value = parseNumeric ( offset , buf ) ; \nif ( convertTime ) { \nvalue *= ( Math . pow ( 2 , - 30 ) * 1000 ) ; \ntype = type == TIME_HIRES ? TIME : INTERVAL ; \n} \nfields . put ( PART_TYPES . get ( type ) , Field . create ( value ) ) ; \n} \nelse if ( ! excludeInterval ) { \nlong value = parseNumeric ( offset , buf ) ; \nif ( convertTime ) { \nvalue *= ( Math . pow ( 2 , - 30 ) * 1000 ) ; \ntype = type == TIME_HIRES ? TIME : INTERVAL ; \n} \nfields . put ( PART_TYPES . get ( type ) , Field . create ( value ) ) ; \n} \noffset += 8 ; \nbreak ; \ncase TIME : case INTERVAL : case SEVERITY : if ( type != INTERVAL ) { \nfields . put ( PART_TYPES . get ( type ) , Field . create ( parseNumeric ( offset , buf ) ) ) ; \n} \nelse if ( ! excludeInterval ) { \nfields . put ( PART_TYPES . get ( type ) , Field . create ( parseNumeric ( offset , buf ) ) ) ; \n} \noffset += 8 ; \nbreak ; \ncase VALUES : offset = parseValues ( offset , buf ) ; \nstartNewRecord ( ) ; \nbreak ; \ncase SIGNATURE : if ( ! verifySignature ( offset , length , buf ) ) { \nthrow new OnRecordErrorException ( Errors . COLLECTD_02 ) ; \n} \noffset += length - 4 ; \nbreak ; \ncase ENCRYPTION : String user = parseUser ( offset , buf ) ; \noffset += ( 2 + user . length ( ) ) ; \nbyte [ ] iv = parseIv ( offset , buf ) ; \noffset += 16 ; \ndecrypt ( offset , length , buf , user , iv ) ; \noffset += 20 ; \nbreak ; \ndefault : LOG . warn ( \"Unrecognized part type: {}\" , type ) ; \noffset += length - 4 ; \nbreak ; \n} \nreturn offset ; \n} \n} \n"}
{"2364": "public class OffsetQueryUtil { \npublic static Map < String , String > validateStoredAndSpecifiedOffset ( TableContext tableContext , String offset ) throws StageException { \nSet < String > expectedColumns = Sets . newHashSet ( tableContext . getOffsetColumns ( ) ) ; \nfinal Map < String , String > actualOffsets = getColumnsToOffsetMapFromOffsetFormat ( offset ) ; \nif ( actualOffsets . size ( ) == 0 ) { \nreturn actualOffsets ; \n} \nSet < String > actualColumns = actualOffsets . keySet ( ) ; \nSet < String > expectedSetDifference = Sets . difference ( expectedColumns , actualColumns ) ; \nSet < String > actualSetDifference = Sets . difference ( actualColumns , expectedColumns ) ; \nif ( expectedSetDifference . size ( ) > 0 ) { \nthrow new StageException ( JdbcErrors . JDBC_71 , tableContext . getQualifiedName ( ) , COMMA_SPACE_JOINER . join ( actualColumns ) , COMMA_SPACE_JOINER . join ( expectedColumns ) ) ; \n} \nelse if ( actualSetDifference . size ( ) > 0 ) { \nthrow new StageException ( JdbcErrors . JDBC_71 , tableContext . getQualifiedName ( ) , COMMA_SPACE_JOINER . join ( actualColumns ) , COMMA_SPACE_JOINER . join ( expectedColumns ) ) ; \n} \nreturn actualOffsets ; \n} \n} \n"}
{"2370": "public class LiveDirectoryScanner { \npublic long getPendingFiles ( LiveFile current ) throws IOException { \nif ( current == null ) { \nreturn findToBeProcessedMatchingFiles ( current != null ? current . refresh ( ) : null ) . size ( ) ; \n} \nelse if ( rollMode . isCurrentAcceptable ( current . getPath ( ) . getFileName ( ) . toString ( ) ) ) { \nreturn findToBeProcessedMatchingFiles ( current != null ? current . refresh ( ) : null ) . size ( ) ; \n} \nreturn 0 ; \n} \n} \n"}
{"2371": "public class CollisionWhitelist { \npublic static boolean isWhitelisted ( String name , Properties specificWhitelist , Map < String , List < Dependency > > dependencies ) { \nif ( specificWhitelist != null ) { \nif ( specificWhitelist . containsKey ( name ) ) { \nreturn versionsMatch ( specificWhitelist . getProperty ( name ) , dependencies . keySet ( ) ) ; \n} \n} \nWhitelistRule rule = WHITELIST_RULES . get ( name ) ; \nreturn rule != null && rule . isWhitelisted ( dependencies ) ; \n} \n} \n"}
{"2374": "public class PipelineConfigurationValidator { \nprivate void propagateRuntimeConfiguration ( ) { \nif ( pipelineBean == null ) { \nreturn ; \n} \nelse if ( pipelineBean . getPipelineStageBeans ( ) == null ) { \nreturn ; \n} \nfor ( StageBean stageBean : pipelineBean . getPipelineStageBeans ( ) . getStages ( ) ) { \nfor ( ServiceDependencyDefinition serviceDependency : stageBean . getDefinition ( ) . getServices ( ) ) { \nServiceBean stageService = stageBean . getService ( serviceDependency . getService ( ) ) ; \nif ( stageService == null ) { \ncontinue ; \n} \nServiceConfiguration serviceConfiguration = stageService . getConf ( ) ; \nList < Config > configs = serviceConfiguration . getConfiguration ( ) ; \nconfigs . removeAll ( serviceDependency . getConfiguration ( ) . keySet ( ) . stream ( ) . map ( serviceConfiguration :: getConfig ) . collect ( Collectors . toList ( ) ) ) ; \nserviceDependency . getConfiguration ( ) . forEach ( ( key , value ) -> configs . add ( new Config ( key , value ) ) ) ; \nserviceConfiguration . setConfig ( configs ) ; \n} \n} \n} \n} \n"}
{"2379": "public class Grok { \npublic Map < String , String > extractNamedGroups ( final CharSequence rawData ) { \nMatcher matcher = compiledPattern . matcher ( rawData ) ; \nif ( matcher . find ( ) ) { \nMatchResult r = matcher . toMatchResult ( ) ; \nif ( r != null ) { \nif ( r . namedGroups ( ) != null ) { \nreturn r . namedGroups ( ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"2406": "public class SobjectRecordCreator { \nprotected String fixOffset ( String offsetColumn , String offset ) { \ncom . sforce . soap . partner . Field sfdcField = getFieldMetadata ( sobjectType , offsetColumn ) ; \nif ( SobjectRecordCreator . DECIMAL_TYPES . contains ( sfdcField . getType ( ) . toString ( ) ) ) { \nif ( offset . contains ( \"E\" ) ) { \nBigDecimal val = new BigDecimal ( offset ) ; \noffset = val . toPlainString ( ) ; \nif ( val . compareTo ( MAX_OFFSET_INT ) > 0 ) { \nif ( ! offset . contains ( \".\" ) ) { \noffset += \".0\" ; \n} \n} \n} \n} \nreturn offset ; \n} \n} \n"}
{"2415": "public class PipeRunner { \npublic OffsetCommitTrigger getOffsetCommitTrigger ( ) { \nfor ( Pipe pipe : pipes ) { \nStage stage = pipe . getStage ( ) . getStage ( ) ; \nif ( stage instanceof Target ) { \nif ( stage instanceof OffsetCommitTrigger ) { \nreturn ( OffsetCommitTrigger ) stage ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"2422": "public class CouchbaseProcessor { \nprivate Observable < Record > setN1QLRowInRecord ( Record record , AsyncN1qlQueryRow row ) { \nfor ( N1QLMappingConfig n1qlMapping : config . n1qlMappingConfigs ) { \nif ( config . multipleValueOperation == MultipleValueType . FIRST ) { \nif ( record . get ( n1qlMapping . sdcField ) != null ) { \nLOG . debug ( \"Only populating output field with first record. Skipping additional result.\" ) ; \nreturn Observable . empty ( ) ; \n} \n} \nObject property = row . value ( ) . get ( n1qlMapping . property ) ; \nif ( property == null ) { \nLOG . debug ( \"Requested property not returned: {}\" , n1qlMapping . property ) ; \nreturn handleError ( record , Errors . COUCHBASE_27 , true ) ; \n} \ntry { \nrecord . set ( n1qlMapping . sdcField , jsonToField ( property ) ) ; \n} \ncatch ( IOException e ) { \ntry { \nrecord . set ( n1qlMapping . sdcField , jsonToField ( JsonObject . fromJson ( property . toString ( ) ) . toMap ( ) ) ) ; \n} \ncatch ( IOException ex ) { \nLOG . debug ( \"Unable to set N1QL property in record\" ) ; \nreturn handleError ( record , Errors . COUCHBASE_19 , ex , false ) ; \n} \n} \n} \nreturn Observable . just ( record ) ; \n} \n} \n"}
{"2430": "public class SdcSecurityManager { \nprivate void ensureProperPermissions ( String path ) { \nClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nif ( cl instanceof ContainerClassLoader ) { \nreturn ; \n} \nif ( exceptions . contains ( path ) ) { \nreturn ; \n} \nif ( cl instanceof SDCClassLoader ) { \nString libraryName = ( ( SDCClassLoader ) cl ) . getName ( ) ; \nif ( stageLibExceptions . containsKey ( libraryName ) ) { \nif ( stageLibExceptions . get ( libraryName ) . contains ( path ) ) { \nreturn ; \n} \n} \n} \nthrow new SecurityException ( Utils . format ( \"Classloader {} is not allowed access to Data Collector internal directories ({}).\" , cl . toString ( ) , path ) ) ; \n} \n} \n"}
{"2434": "public class RecordWriterManager { \npublic boolean shouldRoll ( RecordWriter writer , Record record ) { \nif ( rollIfHeader ) { \nif ( record . getHeader ( ) . getAttribute ( rollHeaderName ) != null ) { \nLOG . debug ( \"Path[{}] - will be rolled because of roll attribute '{}' set to '{}' in the record : '{}'\" , writer . getPath ( ) , rollHeaderName , record . getHeader ( ) . getAttribute ( rollHeaderName ) , record . getHeader ( ) . getSourceId ( ) ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2443": "public class HTTPSession { \nprivate int findHeaderEnd ( final byte [ ] buf , int rlen ) { \nint splitbyte = 0 ; \nwhile ( splitbyte + 1 < rlen ) { \nif ( buf [ splitbyte ] == '\\r' && buf [ splitbyte + 1 ] == '\\n' && splitbyte + 3 < rlen && buf [ splitbyte + 2 ] == '\\r' ) { \nif ( buf [ splitbyte + 3 ] == '\\n' ) { \nreturn splitbyte + 4 ; \n} \n} \nif ( buf [ splitbyte ] == '\\n' ) { \nif ( buf [ splitbyte + 1 ] == '\\n' ) { \nreturn splitbyte + 2 ; \n} \n} \nsplitbyte ++ ; \n} \nreturn 0 ; \n} \n} \n"}
{"2462": "public class SpringSessionBackedSessionInformation { \nprivate static String resolvePrincipal ( Session session ) { \nString principalName = session . getAttribute ( FindByIndexNameSessionRepository . PRINCIPAL_NAME_INDEX_NAME ) ; \nif ( principalName != null ) { \nreturn principalName ; \n} \nSecurityContext securityContext = session . getAttribute ( SPRING_SECURITY_CONTEXT ) ; \nif ( securityContext != null ) { \nif ( securityContext . getAuthentication ( ) != null ) { \nreturn securityContext . getAuthentication ( ) . getName ( ) ; \n} \n} \nreturn \"\" ; \n} \n} \n"}
{"2463": "public class RedisOperationsSessionRepository { \nprivate RedisSession getSession ( String id , boolean allowExpired ) { \nMap < Object , Object > entries = getSessionBoundHashOperations ( id ) . entries ( ) ; \nif ( entries . isEmpty ( ) ) { \nreturn null ; \n} \nMapSession loaded = loadSession ( id , entries ) ; \nif ( ! allowExpired ) { \nif ( loaded . isExpired ( ) ) { \nreturn null ; \n} \n} \nRedisSession result = new RedisSession ( loaded ) ; \nresult . originalLastAccessTime = loaded . getLastAccessedTime ( ) ; \nreturn result ; \n} \n} \n"}
{"2469": "public class KernelDeploymentModuleProcessor { \n@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit unit = phaseContext . getDeploymentUnit ( ) ; \nfinal List < KernelDeploymentXmlDescriptor > kdXmlDescriptors = unit . getAttachment ( KernelDeploymentXmlDescriptor . ATTACHMENT_KEY ) ; \nif ( kdXmlDescriptors == null ) return ; \nelse if ( kdXmlDescriptors . isEmpty ( ) ) return ; \nfor ( KernelDeploymentXmlDescriptor kdxd : kdXmlDescriptors ) { \nif ( kdxd . getBeanFactoriesCount ( ) > 0 ) { \nfinal ModuleSpecification moduleSpecification = unit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nModuleDependency dependency = new ModuleDependency ( moduleLoader , POJO_MODULE , false , false , false , false ) ; \nPathFilter filter = PathFilters . isChildOf ( BaseBeanFactory . class . getPackage ( ) . getName ( ) ) ; \ndependency . addImportFilter ( filter , true ) ; \ndependency . addImportFilter ( PathFilters . rejectAll ( ) , false ) ; \nmoduleSpecification . addSystemDependency ( dependency ) ; \nreturn ; \n} \n} \n} \n} \n"}
{"2477": "public class WeldDeployment { \nprivate void makeTopLevelBdasVisibleFromStaticModules ( ) { \nfor ( BeanDeploymentArchiveImpl bda : beanDeploymentArchives ) { \nif ( bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . EXTERNAL ) ) { \nfor ( BeanDeploymentArchiveImpl topLevelBda : rootBeanDeploymentModule . getBeanDeploymentArchives ( ) ) { \nbda . addBeanDeploymentArchive ( topLevelBda ) ; \n} \n} \nelse if ( bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . SYNTHETIC ) ) { \nfor ( BeanDeploymentArchiveImpl topLevelBda : rootBeanDeploymentModule . getBeanDeploymentArchives ( ) ) { \nbda . addBeanDeploymentArchive ( topLevelBda ) ; \n} \n} \n} \n} \n} \n"}
{"2483": "public class EjbInjectionSource { \nprivate void resolve ( ) { \nif ( ! resolved ) { \nsynchronized ( this ) { \nif ( ! resolved ) { \nfinal Set < ViewDescription > views = getViews ( ) ; \nfinal Set < EJBViewDescription > ejbsForViewName = new HashSet < EJBViewDescription > ( ) ; \nfor ( final ViewDescription view : views ) { \nif ( view instanceof EJBViewDescription ) { \nfinal MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; \nif ( viewType == MethodIntf . SERVICE_ENDPOINT ) { \ncontinue ; \n} \nelse if ( viewType == MethodIntf . MESSAGE_ENDPOINT ) { \ncontinue ; \n} \nejbsForViewName . add ( ( EJBViewDescription ) view ) ; \n} \n} \nif ( ejbsForViewName . isEmpty ( ) ) { \nif ( beanName == null ) { \nerror = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , bindingName ) ; \n} \nelse { \nerror = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , beanName , bindingName ) ; \n} \n} \nelse if ( ejbsForViewName . size ( ) > 1 ) { \nif ( beanName == null ) { \nerror = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , bindingName , ejbsForViewName ) ; \n} \nelse { \nerror = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , beanName , bindingName , ejbsForViewName ) ; \n} \n} \nelse { \nfinal EJBViewDescription description = ejbsForViewName . iterator ( ) . next ( ) ; \nfinal EJBViewDescription ejbViewDescription = ( EJBViewDescription ) description ; \nif ( ejbViewDescription . getMethodIntf ( ) == MethodIntf . REMOTE ) { \nfinal EJBComponentDescription componentDescription = ( EJBComponentDescription ) description . getComponentDescription ( ) ; \nfinal EEModuleDescription moduleDescription = componentDescription . getModuleDescription ( ) ; \nfinal String earApplicationName = moduleDescription . getEarApplicationName ( ) ; \nfinal Value < ClassLoader > viewClassLoader = new Value < ClassLoader > ( ) { \n@ Override public ClassLoader getValue ( ) throws IllegalStateException , IllegalArgumentException { \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nreturn module != null ? module . getClassLoader ( ) : null ; \n} \n} \n; \nremoteFactory = new RemoteViewManagedReferenceFactory ( earApplicationName , moduleDescription . getModuleName ( ) , moduleDescription . getDistinctName ( ) , componentDescription . getComponentName ( ) , description . getViewClassName ( ) , componentDescription . isStateful ( ) , viewClassLoader , appclient ) ; \n} \nelse if ( ejbViewDescription . getMethodIntf ( ) == MethodIntf . HOME ) { \nfinal EJBComponentDescription componentDescription = ( EJBComponentDescription ) description . getComponentDescription ( ) ; \nfinal EEModuleDescription moduleDescription = componentDescription . getModuleDescription ( ) ; \nfinal String earApplicationName = moduleDescription . getEarApplicationName ( ) ; \nfinal Value < ClassLoader > viewClassLoader = new Value < ClassLoader > ( ) { \n@ Override public ClassLoader getValue ( ) throws IllegalStateException , IllegalArgumentException { \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nreturn module != null ? module . getClassLoader ( ) : null ; \n} \n} \n; \nremoteFactory = new RemoteViewManagedReferenceFactory ( earApplicationName , moduleDescription . getModuleName ( ) , moduleDescription . getDistinctName ( ) , componentDescription . getComponentName ( ) , description . getViewClassName ( ) , componentDescription . isStateful ( ) , viewClassLoader , appclient ) ; \n} \nfinal ServiceName serviceName = description . getServiceName ( ) ; \nresolvedViewName = serviceName ; \n} \nresolved = true ; \n} \n} \n} \n} \n} \n"}
{"2502": "public class WebMetaDataModifier { \nprivate void configureEndpoints ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { \nfinal String transportClassName = this . getTransportClassName ( dep ) ; \nWSLogger . ROOT_LOGGER . trace ( \"Modifying servlets\" ) ; \nfinal Set < String > epNames = new HashSet < String > ( ) ; \nfor ( Endpoint ep : dep . getService ( ) . getEndpoints ( ) ) { \nepNames . add ( ep . getTargetBeanName ( ) ) ; \n} \nfor ( final ServletMetaData servletMD : jbossWebMD . getServlets ( ) ) { \nfinal String endpointClassName = ASHelper . getEndpointClassName ( servletMD ) ; \nif ( endpointClassName != null ) { \nif ( endpointClassName . length ( ) > 0 ) { \nif ( epNames . contains ( endpointClassName ) ) { \nservletMD . setServletClass ( WSFServlet . class . getName ( ) ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting transport class: %s for endpoint: %s\" , transportClassName , endpointClassName ) ; \nfinal List < ParamValueMetaData > initParams = WebMetaDataHelper . getServletInitParams ( servletMD ) ; \nWebMetaDataHelper . newParamValue ( WSFServlet . STACK_SERVLET_DELEGATE_CLASS , transportClassName , initParams ) ; \nWebMetaDataHelper . newParamValue ( Endpoint . SEPID_DOMAIN_ENDPOINT , endpointClassName , initParams ) ; \n} \nelse if ( endpointClassName . startsWith ( \"org.apache.cxf\" ) ) { \nthrow WSLogger . ROOT_LOGGER . invalidWSServlet ( endpointClassName ) ; \n} \n} \n} \n} \n} \n} \n"}
{"2510": "public class Injection { \nprotected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Method > hits = null ; \nMethod [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nfinal Method method = methods [ i ] ; \nif ( methodName . equals ( method . getName ( ) ) ) { \nif ( method . getParameterTypes ( ) . length == 1 ) { \nif ( propertyType == null ) { \nif ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; \nSecurityActions . setAccessible ( method ) ; \nhits . add ( method ) ; \n} \nelse if ( argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; \nSecurityActions . setAccessible ( method ) ; \nhits . add ( method ) ; \n} \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new MethodSorter ( ) ) ; \nif ( propertyType != null ) { \nfor ( Method m : hits ) { \nif ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) return m ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2511": "public class Injection { \nprotected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Field > hits = null ; \nField [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; \nfor ( int i = 0 ; \ni < fields . length ; \ni ++ ) { \nfinal Field field = fields [ i ] ; \nif ( fieldName . equals ( field . getName ( ) ) ) { \nif ( fieldType == null ) { \nif ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; \nSecurityActions . setAccessible ( field ) ; \nhits . add ( field ) ; \n} \nelse if ( argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; \nSecurityActions . setAccessible ( field ) ; \nhits . add ( field ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new FieldSorter ( ) ) ; \nif ( fieldType != null ) { \nfor ( Field f : hits ) { \nif ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) return f ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2533": "public class AttributeAnalysis { \nvoid setIDLName ( String idlName ) { \nsuper . setIDLName ( idlName ) ; \nif ( idlName . charAt ( 0 ) >= 0x41 && idlName . charAt ( 0 ) <= 0x5a ) { \nif ( idlName . length ( ) <= 1 || idlName . charAt ( 1 ) < 0x41 || idlName . charAt ( 1 ) > 0x5a ) { \nidlName = idlName . substring ( 0 , 1 ) . toLowerCase ( Locale . ENGLISH ) + idlName . substring ( 1 ) ; \n} \n} \nif ( accessorAnalysis != null ) accessorAnalysis . setIDLName ( \"_get_\" + idlName ) ; \nif ( mutatorAnalysis != null ) mutatorAnalysis . setIDLName ( \"_set_\" + idlName ) ; \n} \n} \n"}
{"2535": "public class JndiName { \npublic static JndiName of ( final String name ) { \nif ( name == null ) throw NamingLogger . ROOT_LOGGER . invalidJndiName ( name ) ; \nelse if ( name . isEmpty ( ) ) throw NamingLogger . ROOT_LOGGER . invalidJndiName ( name ) ; \nfinal String [ ] parts = name . split ( ENTRY_SEPARATOR ) ; \nJndiName current = null ; \nfor ( String part : parts ) { \ncurrent = new JndiName ( current , part ) ; \n} \nreturn current ; \n} \n} \n"}
{"2550": "public class CommonIronJacamarParser { \nprivate String parseConnectionAttributes_5_0 ( final XMLExtendedStreamReader reader , final ModelNode connectionDefinitionNode ) throws XMLStreamException { \nString poolName = null ; \nString jndiName = null ; \nint attributeSize = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < attributeSize ; \ni ++ ) { \nConnectionDefinition . Attribute attribute = ConnectionDefinition . Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nString value = reader . getAttributeValue ( i ) ; \nswitch ( attribute ) { \ncase ENABLED : { \nENABLED . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CONNECTABLE : { \nCONNECTABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase TRACKING : { \nTRACKING . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase JNDI_NAME : { \njndiName = value ; \nJNDINAME . parseAndSetParameter ( jndiName , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase POOL_NAME : { \npoolName = value ; \nbreak ; \n} \ncase USE_JAVA_CONTEXT : { \nUSE_JAVA_CONTEXT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase USE_CCM : { \nUSE_CCM . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase SHARABLE : { \nSHARABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT : { \nENLISTMENT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CLASS_NAME : { \nCLASS_NAME . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase MCP : { \nMCP . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT_TRACE : ENLISTMENT_TRACE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \ndefault : throw ParseUtils . unexpectedAttribute ( reader , i ) ; \n} \n} \nif ( poolName == null ) { \nif ( jndiName != null && jndiName . trim ( ) . length ( ) != 0 ) { \nif ( jndiName . contains ( \"/\" ) ) { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \"/\" ) + 1 ) ; \n} \nelse { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \":\" ) + 1 ) ; \n} \n} \nelse { \nthrow ParseUtils . missingRequired ( reader , EnumSet . of ( ConnectionDefinition . Attribute . JNDI_NAME ) ) ; \n} \n} \nelse if ( poolName . trim ( ) . equals ( \"\" ) ) { \nif ( jndiName != null && jndiName . trim ( ) . length ( ) != 0 ) { \nif ( jndiName . contains ( \"/\" ) ) { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \"/\" ) + 1 ) ; \n} \nelse { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \":\" ) + 1 ) ; \n} \n} \nelse { \nthrow ParseUtils . missingRequired ( reader , EnumSet . of ( ConnectionDefinition . Attribute . JNDI_NAME ) ) ; \n} \n} \nreturn poolName ; \n} \n} \n"}
{"2573": "public class JPAInterceptorProcessor { \nprivate void registerSessionBeanInterceptors ( SessionBeanComponentDescription componentDescription , final DeploymentUnit deploymentUnit ) { \nif ( componentDescription . isStateful ( ) ) { \ncomponentDescription . getConfigurators ( ) . addFirst ( new ComponentConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { \nconfiguration . addPostConstructInterceptor ( SFSBPreCreateInterceptor . FACTORY , InterceptorOrder . ComponentPostConstruct . JPA_SFSB_PRE_CREATE ) ; \nconfiguration . addPostConstructInterceptor ( SFSBCreateInterceptor . FACTORY , InterceptorOrder . ComponentPostConstruct . JPA_SFSB_CREATE ) ; \nconfiguration . addPreDestroyInterceptor ( SFSBDestroyInterceptor . FACTORY , InterceptorOrder . ComponentPreDestroy . JPA_SFSB_DESTROY ) ; \nconfiguration . addComponentInterceptor ( SFSBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SFSB_INTERCEPTOR , false ) ; \nconfiguration . getInterceptorContextKeys ( ) . add ( SFSBInvocationInterceptor . CONTEXT_KEY ) ; \n} \n} \n) ; \n} \nif ( componentDescription . isStateful ( ) ) { \ncomponentDescription . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { \nconfiguration . addComponentInterceptor ( SBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SESSION_BEAN_INTERCEPTOR , false ) ; \n} \n} \n) ; \n} \nelse if ( componentDescription . isStateless ( ) ) { \ncomponentDescription . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { \nconfiguration . addComponentInterceptor ( SBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SESSION_BEAN_INTERCEPTOR , false ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"2579": "public class JMSConnectionFactoryDefinitionInjectionSource { \nstatic boolean targetsPooledConnectionFactory ( String server , String resourceAdapter , ServiceRegistry serviceRegistry ) { \nif ( resourceAdapter == null ) { \nreturn true ; \n} \nelse if ( resourceAdapter . isEmpty ( ) ) { \nreturn true ; \n} \nServiceName activeMQServiceName = MessagingServices . getActiveMQServiceName ( server ) ; \nServiceName pcfName = JMSServices . getPooledConnectionFactoryBaseServiceName ( activeMQServiceName ) . append ( resourceAdapter ) ; \nreturn serviceRegistry . getServiceNames ( ) . contains ( pcfName ) ; \n} \n} \n"}
{"2580": "public class JMSConnectionFactoryDefinitionInjectionSource { \nstatic boolean targetsExternalPooledConnectionFactory ( String resourceAdapter , ServiceRegistry serviceRegistry ) { \nif ( resourceAdapter == null ) { \nreturn false ; \n} \nelse if ( resourceAdapter . isEmpty ( ) ) { \nreturn false ; \n} \nServiceName pcfName = JMSServices . getPooledConnectionFactoryBaseServiceName ( MessagingServices . getActiveMQServiceName ( \"\" ) ) . append ( resourceAdapter ) ; \nreturn serviceRegistry . getServiceNames ( ) . contains ( pcfName ) ; \n} \n} \n"}
{"2582": "public class PersistenceUnitSearch { \nprivate static String defaultPersistenceUnitName ( String persistenceUnitName , PersistenceUnitMetadataHolder holder ) { \nif ( persistenceUnitName == null ) { \nfor ( PersistenceUnitMetadata persistenceUnit : holder . getPersistenceUnits ( ) ) { \nString defaultPU = persistenceUnit . getProperties ( ) . getProperty ( Configuration . JPA_DEFAULT_PERSISTENCE_UNIT ) ; \nif ( Boolean . TRUE . toString ( ) . equals ( defaultPU ) ) { \npersistenceUnitName = persistenceUnit . getPersistenceUnitName ( ) ; \n} \n} \n} \nelse if ( persistenceUnitName . length ( ) == 0 ) { \nfor ( PersistenceUnitMetadata persistenceUnit : holder . getPersistenceUnits ( ) ) { \nString defaultPU = persistenceUnit . getProperties ( ) . getProperty ( Configuration . JPA_DEFAULT_PERSISTENCE_UNIT ) ; \nif ( Boolean . TRUE . toString ( ) . equals ( defaultPU ) ) { \npersistenceUnitName = persistenceUnit . getPersistenceUnitName ( ) ; \n} \n} \n} \nreturn persistenceUnitName ; \n} \n} \n"}
{"2587": "public class EJBSuspendHandlerService { \npublic void invocationComplete ( ) { \nint activeInvocations = activeInvocationCountUpdater . decrementAndGet ( this ) ; \nif ( suspended && activeInvocations == 0 ) { \nif ( ! gracefulTxnShutdown || ( activeTransactionCountUpdater . get ( this ) == 0 ) ) { \ndoneSuspended ( ) ; \n} \n} \n} \n} \n"}
{"2591": "public class MessagingServices { \npublic static ServiceName getCapabilityServiceName ( String capabilityBaseName , String ... dynamicParts ) { \nif ( capabilityServiceSupport == null ) { \nthrow new IllegalStateException ( ) ; \n} \nif ( dynamicParts == null ) { \nreturn capabilityServiceSupport . getCapabilityServiceName ( capabilityBaseName ) ; \n} \nelse if ( dynamicParts . length == 0 ) { \nreturn capabilityServiceSupport . getCapabilityServiceName ( capabilityBaseName ) ; \n} \nreturn capabilityServiceSupport . getCapabilityServiceName ( capabilityBaseName , dynamicParts ) ; \n} \n} \n"}
{"2597": "public class Configuration { \npublic static boolean skipMixedSynchronizationTypeCheck ( EntityManagerFactory emf , Map targetEntityManagerProperties ) { \nboolean result = false ; \nif ( targetEntityManagerProperties != null && targetEntityManagerProperties . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) { \nresult = Boolean . parseBoolean ( ( String ) targetEntityManagerProperties . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; \n} \nelse if ( emf . getProperties ( ) != null ) { \nif ( emf . getProperties ( ) . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) { \nresult = Boolean . parseBoolean ( ( String ) emf . getProperties ( ) . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"2622": "public class SFSBCallStack { \npublic static Map < String , ExtendedEntityManager > currentSFSBCallStackInvocation ( ) { \nArrayList < Map < String , ExtendedEntityManager > > stack = CURRENT . get ( ) . invocationStack ; \nif ( stack != null ) { \nif ( stack . size ( ) > 0 ) { \nreturn stack . get ( stack . size ( ) - 1 ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2627": "public class JSFComponentProcessor { \nprivate void processXmlManagedBeans ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder className = null ; \nint indent = 0 ; \nboolean managedBean = false ; \nboolean managedBeanClass = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN ) ) { \nmanagedBean = true ; \n} \n} \nelse if ( indent == 3 ) { \nif ( managedBean ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN_CLASS ) ) { \nmanagedBeanClass = true ; \nclassName = new StringBuilder ( ) ; \n} \n} \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nmanagedBeanClass = false ; \nif ( indent == 1 ) { \nmanagedBean = false ; \n} \nif ( className != null ) { \nmanagedBeanClasses . add ( className . toString ( ) . trim ( ) ) ; \nclassName = null ; \n} \n} \nelse if ( managedBeanClass ) { \nif ( event == XMLStreamConstants . CHARACTERS ) { \nclassName . append ( parser . getText ( ) ) ; \n} \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . managedBeansConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2628": "public class JSFComponentProcessor { \nprivate void processPhaseListeners ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder phaseListenerName = null ; \nint indent = 0 ; \nboolean lifecycle = false ; \nboolean phaseListener = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( LIFECYCLE ) ) { \nlifecycle = true ; \n} \n} \nelse if ( indent == 3 ) { \nif ( lifecycle ) { \nif ( parser . getLocalName ( ) . equals ( PHASE_LISTENER ) ) { \nphaseListener = true ; \nphaseListenerName = new StringBuilder ( ) ; \n} \n} \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nphaseListener = false ; \nif ( indent == 1 ) { \nlifecycle = false ; \n} \nif ( phaseListenerName != null ) { \nmanagedBeanClasses . add ( phaseListenerName . toString ( ) . trim ( ) ) ; \nphaseListenerName = null ; \n} \n} \nelse if ( phaseListener ) { \nif ( event == XMLStreamConstants . CHARACTERS ) { \nphaseListenerName . append ( parser . getText ( ) ) ; \n} \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . phaseListenersConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2629": "public class Util { \npublic static String getTypeIDLName ( Class cls ) throws RMIIIOPViolationException { \nif ( cls . isPrimitive ( ) ) return PrimitiveAnalysis . getPrimitiveAnalysis ( cls ) . getIDLName ( ) ; \nif ( cls . isArray ( ) ) { \nClass componentClass = cls ; \nint sequence = 0 ; \nwhile ( componentClass . isArray ( ) ) { \ncomponentClass = componentClass . getComponentType ( ) ; \n++ sequence ; \n} \nString idlName = getTypeIDLName ( componentClass ) ; \nint idx = idlName . lastIndexOf ( \"::\" ) ; \nString idlModule = idlName . substring ( 0 , idx + 2 ) ; \nString baseName = idlName . substring ( idx + 2 ) ; \nreturn \"::org::omg::boxedRMI\" + idlModule + \"seq\" + sequence + \"_\" + baseName ; \n} \nif ( cls == java . lang . String . class ) return \"::CORBA::WStringValue\" ; \nif ( cls == java . lang . Object . class ) return \"::java::lang::_Object\" ; \nif ( cls == java . lang . Class . class ) return \"::javax::rmi::CORBA::ClassDesc\" ; \nif ( cls == java . io . Serializable . class ) return \"::java::io::Serializable\" ; \nif ( cls == java . io . Externalizable . class ) return \"::java::io::Externalizable\" ; \nif ( cls == java . rmi . Remote . class ) return \"::java::rmi::Remote\" ; \nif ( cls == org . omg . CORBA . Object . class ) return \"::CORBA::Object\" ; \nif ( cls . isInterface ( ) ) { \nif ( java . rmi . Remote . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \n} \nif ( cls . isInterface ( ) && org . omg . CORBA . Object . class . isAssignableFrom ( cls ) ) { \nif ( org . omg . CORBA . portable . IDLEntity . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \n} \nif ( Throwable . class . isAssignableFrom ( cls ) ) { \nif ( Exception . class . isAssignableFrom ( cls ) ) { \nif ( ! RuntimeException . class . isAssignableFrom ( cls ) ) { \nExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; \nreturn ea . getIDLModuleName ( ) + \"::\" + ea . getIDLName ( ) ; \n} \n} \n} \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \nreturn va . getIDLModuleName ( ) + \"::\" + va . getIDLName ( ) ; \n} \n} \n"}
{"2631": "public class Util { \npublic static String javaToIDLName ( String name ) { \nif ( name == null || \"\" . equals ( name ) ) throw IIOPLogger . ROOT_LOGGER . nameCannotBeNullEmptyOrQualified ( ) ; \nelse if ( name . indexOf ( '.' ) != - 1 ) throw IIOPLogger . ROOT_LOGGER . nameCannotBeNullEmptyOrQualified ( ) ; \nStringBuffer res = new StringBuffer ( name . length ( ) ) ; \nif ( name . charAt ( 0 ) == '_' ) res . append ( 'J' ) ; \nfor ( int i = 0 ; \ni < name . length ( ) ; \n++ i ) { \nchar c = name . charAt ( i ) ; \nif ( isLegalIDLIdentifierChar ( c ) ) res . append ( c ) ; \nelse res . append ( 'U' ) . append ( toHexString ( ( int ) c ) ) ; \n} \nString s = res . toString ( ) ; \nif ( isReservedIDLKeyword ( s ) ) return \"_\" + s ; \nelse return s ; \n} \n} \n"}
{"2640": "public class FileTimerPersistence { \nprivate TimerImpl mostRecentEntityVersion ( final TimerImpl timerImpl ) { \ntry { \nfinal int status = ContextTransactionManager . getInstance ( ) . getStatus ( ) ; \nif ( status == Status . STATUS_UNKNOWN ) { \nreturn timerImpl ; \n} \nelse if ( status == Status . STATUS_NO_TRANSACTION ) { \nreturn timerImpl ; \n} \nfinal String key = timerTransactionKey ( timerImpl ) ; \nTimerImpl existing = ( TimerImpl ) transactionSynchronizationRegistry . getValue ( ) . getResource ( key ) ; \nreturn existing != null ? existing : timerImpl ; \n} \ncatch ( SystemException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"2645": "public class NamingEventCoordinator { \nvoid fireEvent ( final EventContext context , final Name name , final Binding existingBinding , final Binding newBinding , int type , final String changeInfo , final Integer ... scopes ) { \nfinal String target = name . toString ( ) ; \nfinal Set < Integer > scopeSet = new HashSet < Integer > ( Arrays . asList ( scopes ) ) ; \nfinal NamingEvent event = new NamingEvent ( context , type , newBinding , existingBinding , changeInfo ) ; \nfinal Set < ListenerHolder > holdersToFire = new HashSet < ListenerHolder > ( ) ; \nif ( scopeSet . contains ( EventContext . OBJECT_SCOPE ) ) { \nfinal TargetScope targetScope = new TargetScope ( target , EventContext . OBJECT_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \nif ( scopeSet . contains ( EventContext . ONELEVEL_SCOPE ) ) { \nif ( ! name . isEmpty ( ) ) { \nfinal TargetScope targetScope = new TargetScope ( name . getPrefix ( name . size ( ) - 1 ) . toString ( ) , EventContext . ONELEVEL_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \n} \nif ( scopeSet . contains ( EventContext . SUBTREE_SCOPE ) ) { \nif ( ! name . isEmpty ( ) ) { \nfor ( int i = 1 ; \ni < name . size ( ) ; \ni ++ ) { \nfinal Name parentName = name . getPrefix ( i ) ; \nfinal TargetScope targetScope = new TargetScope ( parentName . toString ( ) , EventContext . SUBTREE_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \n} \n} \nexecutor . execute ( new FireEventTask ( holdersToFire , event ) ) ; \n} \n} \n"}
{"2693": "public class EJBComponentDescription { \nprotected void addRemoteTransactionsDependency ( ) { \nthis . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration componentConfiguration ) throws DeploymentUnitProcessingException { \nif ( this . hasRemoteView ( ( EJBComponentDescription ) description ) ) { \ncomponentConfiguration . getCreateDependencies ( ) . add ( ( sb , cs ) -> sb . requires ( TxnServices . JBOSS_TXN_REMOTE_TRANSACTION_SERVICE ) ) ; \n} \n} \nprivate boolean hasRemoteView ( final EJBComponentDescription ejbComponentDescription ) { \nfinal Set < ViewDescription > views = ejbComponentDescription . getViews ( ) ; \nfor ( final ViewDescription view : views ) { \nif ( ! ( view instanceof EJBViewDescription ) ) { \ncontinue ; \n} \nfinal MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; \nif ( viewType == MethodIntf . REMOTE ) { \nreturn true ; \n} \nelse if ( viewType == MethodIntf . HOME ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n) ; \n} \n} \n"}
{"2696": "public class MessagingSubsystemParser { \nprotected static void checkOnlyOneOfElements ( XMLExtendedStreamReader reader , Set < Element > seen , Element element1 , Element element2 ) throws XMLStreamException { \nif ( ! seen . contains ( element1 ) ) { \nif ( ! seen . contains ( element2 ) ) { \nthrow new XMLStreamException ( MessagingLogger . ROOT_LOGGER . required ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; \n} \n} \nif ( seen . contains ( element1 ) ) { \nif ( seen . contains ( element2 ) ) { \nthrow new XMLStreamException ( MessagingLogger . ROOT_LOGGER . onlyOneRequired ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; \n} \n} \n} \n} \n"}
{"2710": "public class WildFlyBindingRegistry { \n@ Override public void unbind ( String name ) { \nif ( name == null ) { \nthrow MessagingLogger . ROOT_LOGGER . cannotUnbindJndiName ( ) ; \n} \nelse if ( name . isEmpty ( ) ) { \nthrow MessagingLogger . ROOT_LOGGER . cannotUnbindJndiName ( ) ; \n} \nfinal ContextNames . BindInfo bindInfo = ContextNames . bindInfoFor ( name ) ; \nServiceController < ? > bindingService = container . getService ( bindInfo . getBinderServiceName ( ) ) ; \nif ( bindingService == null ) { \nROOT_LOGGER . debugf ( \"Cannot unbind %s since no binding exists with that name\" , name ) ; \nreturn ; \n} \nbindingService . setMode ( ServiceController . Mode . REMOVE ) ; \nfinal StabilityMonitor monitor = new StabilityMonitor ( ) ; \nmonitor . addController ( bindingService ) ; \ntry { \nmonitor . awaitStability ( ) ; \nROOT_LOGGER . unboundJndiName ( bindInfo . getAbsoluteJndiName ( ) ) ; \n} \ncatch ( InterruptedException e ) { \nROOT_LOGGER . failedToUnbindJndiName ( name , 5 , SECONDS . toString ( ) . toLowerCase ( Locale . US ) ) ; \n} \nfinally { \nmonitor . removeController ( bindingService ) ; \n} \n} \n} \n"}
{"2711": "public class BeanUtils { \npublic static Object instantiateBean ( BeanMetaDataConfig beanConfig , BeanInfo beanInfo , DeploymentReflectionIndex index , Module module ) throws Throwable { \nJoinpoint instantiateJoinpoint = null ; \nValueConfig [ ] parameters = new ValueConfig [ 0 ] ; \nString [ ] types = Configurator . NO_PARAMS_TYPES ; \nConstructorConfig ctorConfig = beanConfig . getConstructor ( ) ; \nif ( ctorConfig != null ) { \nparameters = ctorConfig . getParameters ( ) ; \ntypes = Configurator . getTypes ( parameters ) ; \nString factoryClass = ctorConfig . getFactoryClass ( ) ; \nFactoryConfig factory = ctorConfig . getFactory ( ) ; \nif ( factoryClass != null ) { \nString factoryMethod = ctorConfig . getFactoryMethod ( ) ; \nif ( factoryMethod == null ) throw PojoLogger . ROOT_LOGGER . missingFactoryMethod ( beanConfig ) ; \nif ( factoryClass != null ) { \nClass < ? > factoryClazz = Class . forName ( factoryClass , false , module . getClassLoader ( ) ) ; \nMethod method = Configurator . findMethod ( index , factoryClazz , factoryMethod , types , true , true , true ) ; \nMethodJoinpoint mj = new MethodJoinpoint ( method ) ; \nmj . setTarget ( new ImmediateValue < Object > ( null ) ) ; \nmj . setParameters ( parameters ) ; \ninstantiateJoinpoint = mj ; \n} \nelse if ( factory != null ) { \nReflectionJoinpoint rj = new ReflectionJoinpoint ( factory . getBeanInfo ( ) , factoryMethod , types ) ; \nrj . setTarget ( new ImmediateValue < Object > ( factory . getValue ( null ) ) ) ; \nrj . setParameters ( parameters ) ; \ninstantiateJoinpoint = rj ; \n} \n} \nelse if ( factory != null ) { \nString factoryMethod = ctorConfig . getFactoryMethod ( ) ; \nif ( factoryMethod == null ) throw PojoLogger . ROOT_LOGGER . missingFactoryMethod ( beanConfig ) ; \nif ( factoryClass != null ) { \nClass < ? > factoryClazz = Class . forName ( factoryClass , false , module . getClassLoader ( ) ) ; \nMethod method = Configurator . findMethod ( index , factoryClazz , factoryMethod , types , true , true , true ) ; \nMethodJoinpoint mj = new MethodJoinpoint ( method ) ; \nmj . setTarget ( new ImmediateValue < Object > ( null ) ) ; \nmj . setParameters ( parameters ) ; \ninstantiateJoinpoint = mj ; \n} \nelse if ( factory != null ) { \nReflectionJoinpoint rj = new ReflectionJoinpoint ( factory . getBeanInfo ( ) , factoryMethod , types ) ; \nrj . setTarget ( new ImmediateValue < Object > ( factory . getValue ( null ) ) ) ; \nrj . setParameters ( parameters ) ; \ninstantiateJoinpoint = rj ; \n} \n} \n} \nif ( instantiateJoinpoint == null ) { \nif ( beanInfo == null ) throw new StartException ( PojoLogger . ROOT_LOGGER . missingBeanInfo ( beanConfig ) ) ; \nConstructor ctor = ( types . length == 0 ) ? beanInfo . getConstructor ( ) : beanInfo . findConstructor ( types ) ; \nConstructorJoinpoint constructorJoinpoint = new ConstructorJoinpoint ( ctor ) ; \nconstructorJoinpoint . setParameters ( parameters ) ; \ninstantiateJoinpoint = constructorJoinpoint ; \n} \nreturn instantiateJoinpoint . dispatch ( ) ; \n} \n} \n"}
{"2713": "public class BeanUtils { \npublic static void dispatchLifecycleJoinpoint ( BeanInfo beanInfo , Object bean , LifecycleConfig config , String defaultMethod ) throws Throwable { \nif ( config != null ) { \nif ( config . isIgnored ( ) ) return ; \n} \nJoinpoint joinpoint = createJoinpoint ( beanInfo , bean , config , defaultMethod ) ; \nif ( joinpoint != null ) joinpoint . dispatch ( ) ; \n} \n} \n"}
{"2724": "public class ServiceDeploymentParsingProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal VirtualFile deploymentRoot = phaseContext . getDeploymentUnit ( ) . getAttachment ( Attachments . DEPLOYMENT_ROOT ) . getRoot ( ) ; \nif ( deploymentRoot == null ) return ; \nelse if ( ! deploymentRoot . exists ( ) ) return ; \nVirtualFile serviceXmlFile = null ; \nif ( deploymentRoot . isDirectory ( ) ) { \nserviceXmlFile = deploymentRoot . getChild ( SERVICE_DESCRIPTOR_PATH ) ; \n} \nelse if ( deploymentRoot . getName ( ) . toLowerCase ( Locale . ENGLISH ) . endsWith ( SERVICE_DESCRIPTOR_SUFFIX ) ) { \nserviceXmlFile = deploymentRoot ; \n} \nif ( serviceXmlFile == null ) return ; \nelse if ( ! serviceXmlFile . exists ( ) ) return ; \nfinal XMLMapper xmlMapper = XMLMapper . Factory . create ( ) ; \nfinal JBossServiceXmlDescriptorParser jBossServiceXmlDescriptorParser = new JBossServiceXmlDescriptorParser ( JBossDescriptorPropertyReplacement . propertyReplacer ( phaseContext . getDeploymentUnit ( ) ) ) ; \nxmlMapper . registerRootElement ( new QName ( \"urn:jboss:service:7.0\" , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nxmlMapper . registerRootElement ( new QName ( null , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nInputStream xmlStream = null ; \ntry { \nxmlStream = serviceXmlFile . openStream ( ) ; \nfinal XMLStreamReader reader = inputFactory . createXMLStreamReader ( xmlStream ) ; \nfinal ParseResult < JBossServiceXmlDescriptor > result = new ParseResult < JBossServiceXmlDescriptor > ( ) ; \nxmlMapper . parseDocument ( result , reader ) ; \nfinal JBossServiceXmlDescriptor xmlDescriptor = result . getResult ( ) ; \nif ( xmlDescriptor != null ) phaseContext . getDeploymentUnit ( ) . putAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; \nelse throw SarLogger . ROOT_LOGGER . failedXmlParsing ( serviceXmlFile ) ; \n} \ncatch ( Exception e ) { \nthrow SarLogger . ROOT_LOGGER . failedXmlParsing ( e , serviceXmlFile ) ; \n} \nfinally { \nVFSUtils . safeClose ( xmlStream ) ; \n} \n} \n} \n"}
{"2735": "public class PersistenceUnitServiceHandler { \nprivate static PersistenceProviderAdaptor getPersistenceProviderAdaptor ( final PersistenceUnitMetadata pu , final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , final DeploymentUnit deploymentUnit , final PersistenceProvider provider , final Platform platform ) throws DeploymentUnitProcessingException { \nString adapterClass = pu . getProperties ( ) . getProperty ( Configuration . ADAPTER_CLASS ) ; \nif ( persistenceProviderDeploymentHolder != null ) { \nif ( adapterClass != null ) { \nList < PersistenceProviderAdaptor > persistenceProviderAdaptors = persistenceProviderDeploymentHolder . getAdapters ( ) ; \nfor ( PersistenceProviderAdaptor persistenceProviderAdaptor : persistenceProviderAdaptors ) { \nif ( adapterClass . equals ( persistenceProviderAdaptor . getClass ( ) . getName ( ) ) ) { \nreturn persistenceProviderAdaptor ; \n} \n} \n} \n} \nString adaptorModule = pu . getProperties ( ) . getProperty ( Configuration . ADAPTER_MODULE ) ; \nPersistenceProviderAdaptor adaptor ; \nadaptor = getPerDeploymentSharedPersistenceProviderAdaptor ( deploymentUnit , adaptorModule , provider ) ; \nif ( adaptor == null ) { \ntry { \nif ( adaptorModule != null ) { \nadaptor = PersistenceProviderAdaptorLoader . loadPersistenceAdapterModule ( adaptorModule , platform , createManager ( deploymentUnit ) ) ; \n} \nelse { \nadaptor = PersistenceProviderAdaptorLoader . loadPersistenceAdapter ( provider , platform , createManager ( deploymentUnit ) ) ; \n} \n} \ncatch ( ModuleLoadException e ) { \nthrow JpaLogger . ROOT_LOGGER . persistenceProviderAdaptorModuleLoadError ( e , adaptorModule ) ; \n} \nadaptor = savePerDeploymentSharedPersistenceProviderAdaptor ( deploymentUnit , adaptorModule , adaptor , provider ) ; \n} \nif ( adaptor == null ) { \nthrow JpaLogger . ROOT_LOGGER . failedToGetAdapter ( pu . getPersistenceProviderClassName ( ) ) ; \n} \nreturn adaptor ; \n} \n} \n"}
{"2737": "public class PersistenceUnitServiceHandler { \nprivate static PersistenceProvider lookupProvider ( PersistenceUnitMetadata pu , PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , DeploymentUnit deploymentUnit ) throws DeploymentUnitProcessingException { \nMap < String , PersistenceProvider > providerMap = persistenceProviderDeploymentHolder != null ? persistenceProviderDeploymentHolder . getProviders ( ) : null ; \nif ( providerMap != null ) { \nsynchronized ( providerMap ) { \nif ( providerMap . containsKey ( pu . getPersistenceProviderClassName ( ) ) ) { \nROOT_LOGGER . tracef ( \"deployment %s is using %s\" , deploymentUnit . getName ( ) , pu . getPersistenceProviderClassName ( ) ) ; \nreturn providerMap . get ( pu . getPersistenceProviderClassName ( ) ) ; \n} \n} \n} \nString configuredPersistenceProviderModule = pu . getProperties ( ) . getProperty ( Configuration . PROVIDER_MODULE ) ; \nString persistenceProviderClassName = pu . getPersistenceProviderClassName ( ) ; \nif ( persistenceProviderClassName == null ) { \npersistenceProviderClassName = Configuration . PROVIDER_CLASS_DEFAULT ; \n} \nif ( configuredPersistenceProviderModule != null ) { \nList < PersistenceProvider > providers ; \nif ( Configuration . PROVIDER_MODULE_APPLICATION_SUPPLIED . equals ( configuredPersistenceProviderModule ) ) { \ntry { \nfinal ModuleClassLoader classLoader = deploymentUnit . getAttachment ( Attachments . MODULE ) . getClassLoader ( ) ; \nPersistenceProvider provider = PersistenceProviderLoader . loadProviderFromDeployment ( classLoader , persistenceProviderClassName ) ; \nproviders = new ArrayList < > ( ) ; \nproviders . add ( provider ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nreturn provider ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \ncatch ( InstantiationException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; \n} \n} \nelse { \ntry { \nproviders = PersistenceProviderLoader . loadProviderModuleByName ( configuredPersistenceProviderModule ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nPersistenceProvider provider = getProviderByName ( pu , providers ) ; \nif ( provider != null ) { \nreturn provider ; \n} \n} \ncatch ( ModuleLoadException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , configuredPersistenceProviderModule , persistenceProviderClassName ) ; \n} \n} \n} \nString providerNameDerivedFromClassName = Configuration . getProviderModuleNameFromProviderClassName ( persistenceProviderClassName ) ; \nPersistenceProvider provider = getProviderByName ( pu ) ; \nif ( provider == null ) { \nif ( providerNameDerivedFromClassName != null ) { \ntry { \nList < PersistenceProvider > providers = PersistenceProviderLoader . loadProviderModuleByName ( providerNameDerivedFromClassName ) ; \nPersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; \nprovider = getProviderByName ( pu , providers ) ; \n} \ncatch ( ModuleLoadException e ) { \nthrow JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , providerNameDerivedFromClassName , persistenceProviderClassName ) ; \n} \n} \n} \nif ( provider == null ) throw JpaLogger . ROOT_LOGGER . persistenceProviderNotFound ( persistenceProviderClassName ) ; \nreturn provider ; \n} \n} \n"}
{"2748": "public class ContainerAnalysis { \nprotected boolean isAccessor ( Method m ) { \nClass returnType = m . getReturnType ( ) ; \nString name = m . getName ( ) ; \nif ( ! ( name . startsWith ( \"get\" ) && name . length ( ) > \"get\" . length ( ) ) ) if ( ! ( name . startsWith ( \"is\" ) && name . length ( ) > \"is\" . length ( ) ) ) return false ; \nelse if ( ! ( returnType == Boolean . TYPE ) ) return false ; \nif ( returnType == Void . TYPE ) return false ; \nif ( m . getParameterTypes ( ) . length != 0 ) return false ; \nreturn hasNonAppExceptions ( m ) ; \n} \n} \n"}
{"2757": "public class XTSSubsystemParser { \nprivate void parseDefaultContextPropagationElement ( XMLExtendedStreamReader reader , ModelNode subsystem ) throws XMLStreamException { \nprocessAttributes ( reader , ( index , attribute ) -> { \nfinal String value = reader . getAttributeValue ( index ) ; \nswitch ( attribute ) { \ncase ENABLED : if ( value == null ) { \nthrow ParseUtils . invalidAttributeValue ( reader , index ) ; \n} \nelse if ( ! value . toLowerCase ( ) . equals ( \"true\" ) && ! value . toLowerCase ( ) . equals ( \"false\" ) ) { \nthrow ParseUtils . invalidAttributeValue ( reader , index ) ; \n} \nDEFAULT_CONTEXT_PROPAGATION . parseAndSetParameter ( value , subsystem , reader ) ; \nbreak ; \ndefault : throw ParseUtils . unexpectedAttribute ( reader , index ) ; \n} \n} \n) ; \nParseUtils . requireNoContent ( reader ) ; \n} \n} \n"}
{"2761": "public class EjbDependencyDeploymentUnitProcessor { \n@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nDeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nfinal ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_API , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , JAX_RPC_API , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_CLIENT , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_NAMING_CLIENT , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_IIOP_CLIENT , false , false , false , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_SUBSYSTEM , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_EJB , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_NAMING , false , false , true , false ) ) ; \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_TRANSACTION , false , false , true , false ) ) ; \nif ( IIOPDeploymentMarker . isIIOPDeployment ( deploymentUnit ) ) { \nmoduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , IIOP_OPENJDK , false , false , false , false ) ) ; \n} \nif ( ! isEjbDeployment ( deploymentUnit ) ) { \nif ( ! DeploymentTypeMarker . isType ( DeploymentType . APPLICATION_CLIENT , deploymentUnit ) ) { \nreturn ; \n} \n} \nif ( Boolean . getBoolean ( \"org.jboss.as.ejb3.EMBEDDED\" ) ) moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , ModuleIdentifier . CLASSPATH , false , false , false , false ) ) ; \n} \n} \n"}
{"2766": "public class WSEndpointHandlersMapping { \npublic void registerEndpointHandlers ( final String endpointClass , final Set < String > endpointHandlers ) { \nif ( endpointClass == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nelse if ( endpointHandlers == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nendpointHandlersMap . put ( endpointClass , Collections . unmodifiableSet ( endpointHandlers ) ) ; \n} \n} \n"}
{"2769": "public class JbossAuthorizationManager { \nprotected String requestURI ( HttpServerExchange request ) { \nString uri = request . getRelativePath ( ) ; \nif ( uri == null ) { \nuri = \"\" ; \n} \nelse if ( uri . equals ( \"/\" ) ) { \nuri = \"\" ; \n} \nreturn uri ; \n} \n} \n"}
{"2776": "public class CNCtx { \npublic void destroySubcontext ( Name name ) throws NamingException { \nif ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; \nNamingContext the_nc = _nc ; \nNameComponent [ ] path = org . wildfly . iiop . openjdk . naming . jndi . CNNameParser . nameToCosName ( name ) ; \nif ( name . size ( ) > 0 ) { \ntry { \njavax . naming . Context ctx = ( javax . naming . Context ) callResolve ( path ) ; \nCNCtx cnc = ( CNCtx ) ctx ; \nthe_nc = cnc . _nc ; \ncnc . close ( ) ; \n} \ncatch ( ClassCastException e ) { \nthrow new NotContextException ( name . toString ( ) ) ; \n} \ncatch ( CannotProceedException e ) { \njavax . naming . Context cctx = getContinuationContext ( e ) ; \ncctx . destroySubcontext ( e . getRemainingName ( ) ) ; \nreturn ; \n} \ncatch ( NameNotFoundException e ) { \nif ( e . getRootCause ( ) instanceof NotFound ) { \nif ( leafNotFound ( ( NotFound ) e . getRootCause ( ) , path [ path . length - 1 ] ) ) { \nreturn ; \n} \n} \nthrow e ; \n} \ncatch ( NamingException e ) { \nthrow e ; \n} \n} \ncallDestroy ( the_nc ) ; \ncallUnbind ( path ) ; \n} \n} \n"}
{"2781": "public class CNCtx { \npublic java . lang . Object removeFromEnvironment ( String propName ) throws NamingException { \nif ( _env != null ) { \nif ( _env . get ( propName ) != null ) { \n_env = ( Hashtable ) _env . clone ( ) ; \nreturn _env . remove ( propName ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2783": "public class DsXmlParser { \n@ Override protected Credential parseCredential ( XMLStreamReader reader ) throws XMLStreamException , ParserException , ValidateException { \nString userName = null ; \nString password = null ; \nString securityDomain = null ; \nboolean elytronEnabled = false ; \nString authenticationContext = null ; \nwhile ( reader . hasNext ( ) ) { \nswitch ( reader . nextTag ( ) ) { \ncase END_ELEMENT : { \nif ( DataSource . Tag . forName ( reader . getLocalName ( ) ) == DataSource . Tag . SECURITY || Recovery . Tag . forName ( reader . getLocalName ( ) ) == Recovery . Tag . RECOVER_CREDENTIAL ) { \nreturn new CredentialImpl ( userName , password , elytronEnabled ? authenticationContext : securityDomain , elytronEnabled , null ) ; \n} \nelse { \nif ( Credential . Tag . forName ( reader . getLocalName ( ) ) == Credential . Tag . UNKNOWN ) { \nthrow new ParserException ( bundle . unexpectedEndTag ( reader . getLocalName ( ) ) ) ; \n} \n} \nbreak ; \n} \ncase START_ELEMENT : { \nswitch ( Credential . Tag . forName ( reader . getLocalName ( ) ) ) { \ncase PASSWORD : { \npassword = elementAsString ( reader ) ; \nif ( propertyResolver != null ) { \nif ( password != null ) { \nString resolvedPassword = propertyResolver . resolve ( password ) ; \nif ( resolvedPassword != null ) password = resolvedPassword ; \n} \n} \nbreak ; \n} \ncase USER_NAME : { \nuserName = elementAsString ( reader ) ; \nbreak ; \n} \ncase SECURITY_DOMAIN : { \nsecurityDomain = elementAsString ( reader ) ; \nbreak ; \n} \ncase ELYTRON_ENABLED : { \nBoolean value = elementAsBoolean ( reader ) ; \nelytronEnabled = value == null ? true : value ; \nbreak ; \n} \ncase AUTHENTICATION_CONTEXT : { \nauthenticationContext = elementAsString ( reader ) ; \nbreak ; \n} \ndefault : throw new ParserException ( bundle . unexpectedElement ( reader . getLocalName ( ) ) ) ; \n} \nbreak ; \n} \n} \n} \nthrow new ParserException ( bundle . unexpectedEndOfDocument ( ) ) ; \n} \n} \n"}
{"2789": "public class IDLTypeImpl { \nstatic LocalIDLType getIDLType ( TypeCode typeCode , RepositoryImpl repository ) { \nTCKind tcKind = typeCode . kind ( ) ; \nif ( PrimitiveDefImpl . isPrimitiveTCKind ( tcKind ) ) return new PrimitiveDefImpl ( typeCode , repository ) ; \nif ( tcKind == TCKind . tk_sequence ) return repository . getSequenceImpl ( typeCode ) ; \nif ( tcKind == TCKind . tk_value || tcKind == TCKind . tk_value_box || tcKind == TCKind . tk_alias || tcKind == TCKind . tk_struct || tcKind == TCKind . tk_union || tcKind == TCKind . tk_enum ) { \ntry { \nreturn ( LocalIDLType ) repository . _lookup_id ( typeCode . id ( ) ) ; \n} \ncatch ( BadKind ex ) { \nthrow IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; \n} \n} \nelse if ( tcKind == TCKind . tk_objref ) { \ntry { \nreturn ( LocalIDLType ) repository . _lookup_id ( typeCode . id ( ) ) ; \n} \ncatch ( BadKind ex ) { \nthrow IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; \n} \n} \nthrow IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; \n} \n} \n"}
{"2866": "public class Configurator { \n@ SuppressWarnings ( \"unchecked\" ) public static Object convertValue ( Class < ? > clazz , Object value , boolean replaceProperties , boolean trim ) throws Throwable { \nif ( clazz == null ) return value ; \nif ( value == null ) return null ; \nClass < ? > valueClass = value . getClass ( ) ; \nif ( valueClass == String . class ) { \nString string = ( String ) value ; \nif ( trim ) string = string . trim ( ) ; \nif ( replaceProperties ) value = PropertiesValueResolver . replaceProperties ( string ) ; \n} \nif ( clazz . isAssignableFrom ( valueClass ) ) return value ; \nif ( clazz . isEnum ( ) ) { \nClass < ? extends Enum > eclazz = clazz . asSubclass ( Enum . class ) ; \nreturn Enum . valueOf ( eclazz , value . toString ( ) ) ; \n} \nif ( valueClass == String . class ) { \nPropertyEditor editor = PropertyEditorManager . findEditor ( clazz ) ; \nif ( editor != null ) { \neditor . setAsText ( ( String ) value ) ; \nreturn editor . getValue ( ) ; \n} \n} \ntry { \nMethod method = clazz . getMethod ( \"valueOf\" , valueClass ) ; \nint modifiers = method . getModifiers ( ) ; \nif ( Modifier . isPublic ( modifiers ) && Modifier . isStatic ( modifiers ) ) { \nif ( clazz . isAssignableFrom ( method . getReturnType ( ) ) ) return method . invoke ( null , value ) ; \n} \n} \ncatch ( Exception ignored ) { \n} \nif ( valueClass == String . class ) { \ntry { \nConstructor constructor = clazz . getConstructor ( valueClass ) ; \nif ( Modifier . isPublic ( constructor . getModifiers ( ) ) ) return constructor . newInstance ( value ) ; \n} \ncatch ( Exception ignored ) { \n} \n} \nreturn value ; \n} \n} \n"}
{"2867": "public class Configurator { \npublic static String [ ] getTypes ( ValueConfig [ ] values ) { \nif ( values == null ) return NO_PARAMS_TYPES ; \nelse if ( values . length == 0 ) return NO_PARAMS_TYPES ; \nString [ ] types = new String [ values . length ] ; \nfor ( int i = 0 ; \ni < types . length ; \ni ++ ) types [ i ] = values [ i ] . getType ( ) ; \nreturn types ; \n} \n} \n"}
{"2869": "public class CNBindingEnumeration { \npublic java . lang . Object next ( ) throws NamingException { \nif ( more ) { \nif ( counter >= _bindingList . value . length ) { \ngetMore ( ) ; \n} \n} \nif ( more && counter < _bindingList . value . length ) { \norg . omg . CosNaming . Binding bndg = _bindingList . value [ counter ] ; \ncounter ++ ; \nreturn mapBinding ( bndg ) ; \n} \nelse { \nthrow new NoSuchElementException ( ) ; \n} \n} \n} \n"}
{"2878": "public class Messaging13SubsystemParser { \nprotected static void checkNotBothElements ( XMLExtendedStreamReader reader , Set < Element > seen , Element element1 , Element element2 ) throws XMLStreamException { \nif ( seen . contains ( element1 ) ) { \nif ( seen . contains ( element2 ) ) { \nthrow new XMLStreamException ( MessagingLogger . ROOT_LOGGER . onlyOneRequired ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; \n} \n} \n} \n} \n"}
{"2897": "public class WSEndpointConfigMapping { \npublic void registerEndpointConfig ( final String endpointClass , final EndpointConfig config ) { \nif ( endpointClass == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nelse if ( config == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nendpointConfigMap . put ( endpointClass , config ) ; \n} \n} \n"}
{"2899": "public class TimerTask { \nprotected void postTimeoutProcessing ( TimerImpl timer ) throws InterruptedException { \ntimer . lock ( ) ; \ntry { \nTimerState timerState = timer . getState ( ) ; \nif ( timerState != TimerState . CANCELED ) { \nif ( timerState != TimerState . EXPIRED ) { \nif ( timer . getInterval ( ) == 0 ) { \ntimerService . expireTimer ( timer ) ; \n} \nelse { \ntimer . setTimerState ( TimerState . ACTIVE , null ) ; \n} \ntimerService . persistTimer ( timer , false ) ; \n} \n} \n} \nfinally { \ntimer . unlock ( ) ; \n} \n} \n} \n"}
{"2911": "public class OWhereClause { \npublic long estimate ( OClass oClass , long threshold , OCommandContext ctx ) { \nlong count = oClass . count ( ) ; \nif ( count > 1 ) { \ncount = count / 2 ; \n} \nif ( count < threshold ) { \nreturn count ; \n} \nlong indexesCount = 0l ; \nList < OAndBlock > flattenedConditions = flatten ( ) ; \nSet < OIndex < ? > > indexes = oClass . getIndexes ( ) ; \nfor ( OAndBlock condition : flattenedConditions ) { \nList < OBinaryCondition > indexedFunctConditions = condition . getIndexedFunctionConditions ( oClass , ( ODatabaseDocumentInternal ) ctx . getDatabase ( ) ) ; \nlong conditionEstimation = Long . MAX_VALUE ; \nif ( indexedFunctConditions != null ) { \nfor ( OBinaryCondition cond : indexedFunctConditions ) { \nOFromClause from = new OFromClause ( - 1 ) ; \nOFromItem item = new OFromItem ( - 1 ) ; \nfrom . item = item ; \nfrom . item . setIdentifier ( new OIdentifier ( oClass . getName ( ) ) ) ; \nlong newCount = cond . estimateIndexed ( from , ctx ) ; \nif ( newCount < conditionEstimation ) { \nconditionEstimation = newCount ; \n} \n} \n} \nelse { \nMap < String , Object > conditions = getEqualityOperations ( condition , ctx ) ; \nfor ( OIndex index : indexes ) { \nif ( index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT . name ( ) ) ) { \ncontinue ; \n} \nelse if ( index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT_HASH_INDEX . name ( ) ) ) { \ncontinue ; \n} \nList < String > indexedFields = index . getDefinition ( ) . getFields ( ) ; \nint nMatchingKeys = 0 ; \nfor ( String indexedField : indexedFields ) { \nif ( conditions . containsKey ( indexedField ) ) { \nnMatchingKeys ++ ; \n} \nelse { \nbreak ; \n} \n} \nif ( nMatchingKeys > 0 ) { \nlong newCount = estimateFromIndex ( index , conditions , nMatchingKeys ) ; \nif ( newCount < conditionEstimation ) { \nconditionEstimation = newCount ; \n} \n} \n} \n} \nif ( conditionEstimation > count ) { \nreturn count ; \n} \nindexesCount += conditionEstimation ; \n} \nreturn Math . min ( indexesCount , count ) ; \n} \n} \n"}
{"2914": "public class OReflectionHelper { \npublic static Class < ? > getGenericMultivalueType ( final Field p ) { \nif ( p . getType ( ) instanceof Class < ? > ) { \nfinal Type genericType = p . getGenericType ( ) ; \nif ( genericType != null && genericType instanceof ParameterizedType ) { \nfinal ParameterizedType pt = ( ParameterizedType ) genericType ; \nif ( pt . getActualTypeArguments ( ) != null ) { \nif ( pt . getActualTypeArguments ( ) . length > 0 ) { \nif ( ( ( Class < ? > ) pt . getRawType ( ) ) . isAssignableFrom ( Map . class ) ) { \nif ( pt . getActualTypeArguments ( ) [ 1 ] instanceof Class < ? > ) { \nreturn ( Class < ? > ) pt . getActualTypeArguments ( ) [ 1 ] ; \n} \nelse if ( pt . getActualTypeArguments ( ) [ 1 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 1 ] ) . getRawType ( ) ; \n} \nelse if ( pt . getActualTypeArguments ( ) [ 0 ] instanceof Class < ? > ) { \nreturn ( Class < ? > ) pt . getActualTypeArguments ( ) [ 0 ] ; \n} \nelse if ( pt . getActualTypeArguments ( ) [ 0 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 0 ] ) . getRawType ( ) ; \n} \n} \n} \nelse if ( p . getType ( ) . isArray ( ) ) return p . getType ( ) . getComponentType ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2915": "public class OQueryOperatorContainsText { \n@ Override public Object evaluateRecord ( final OIdentifiable iRecord , ODocument iCurrentResult , final OSQLFilterCondition iCondition , final Object iLeft , final Object iRight , OCommandContext iContext , final ODocumentSerializer serializer ) { \nif ( iLeft == null ) return false ; \nelse if ( iRight == null ) return false ; \nreturn iLeft . toString ( ) . indexOf ( iRight . toString ( ) ) > - 1 ; \n} \n} \n"}
{"2917": "public class OLocalRecordCache { \npublic void updateRecord ( final ORecord record ) { \nif ( record . getIdentity ( ) . getClusterId ( ) != excludedCluster && record . getIdentity ( ) . isValid ( ) && ! record . isDirty ( ) ) { \nif ( ! ORecordVersionHelper . isTombstone ( record . getVersion ( ) ) ) { \nif ( underlying . get ( record . getIdentity ( ) ) != record ) underlying . put ( record ) ; \n} \n} \n} \n} \n"}
{"2921": "public class OSelectExecutionPlanner { \nprivate static void addOrderByProjections ( QueryPlanningInfo info ) { \nif ( info . orderApplied || info . expand || info . unwind != null || info . orderBy == null || info . orderBy . getItems ( ) . size ( ) == 0 || info . projection == null || info . projection . getItems ( ) == null ) { \nreturn ; \n} \nelse if ( info . projection . getItems ( ) . size ( ) == 1 && info . projection . getItems ( ) . get ( 0 ) . isAll ( ) ) { \nreturn ; \n} \nOOrderBy newOrderBy = info . orderBy == null ? null : info . orderBy . copy ( ) ; \nList < OProjectionItem > additionalOrderByProjections = calculateAdditionalOrderByProjections ( info . projection . getAllAliases ( ) , newOrderBy ) ; \nif ( additionalOrderByProjections . size ( ) > 0 ) { \ninfo . orderBy = newOrderBy ; \n} \nif ( additionalOrderByProjections . size ( ) > 0 ) { \ninfo . projectionAfterOrderBy = new OProjection ( - 1 ) ; \ninfo . projectionAfterOrderBy . setItems ( new ArrayList < > ( ) ) ; \nfor ( String alias : info . projection . getAllAliases ( ) ) { \ninfo . projectionAfterOrderBy . getItems ( ) . add ( projectionFromAlias ( new OIdentifier ( alias ) ) ) ; \n} \nfor ( OProjectionItem item : additionalOrderByProjections ) { \nif ( info . preAggregateProjection != null ) { \ninfo . preAggregateProjection . getItems ( ) . add ( item ) ; \ninfo . aggregateProjection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; \ninfo . projection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; \n} \nelse { \ninfo . projection . getItems ( ) . add ( item ) ; \n} \n} \n} \n} \n} \n"}
{"2924": "public class OSelectExecutionPlanner { \nprivate boolean handleClassWithIndexForSortOnly ( OSelectExecutionPlan plan , OIdentifier queryTarget , Set < String > filterClusters , QueryPlanningInfo info , OCommandContext ctx , boolean profilingEnabled ) { \nOSchema schema = getSchemaFromContext ( ctx ) ; \nOClass clazz = schema . getClass ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nclazz = schema . getView ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nthrow new OCommandExecutionException ( \"Class not found: \" + queryTarget ) ; \n} \n} \nfor ( OIndex idx : clazz . getIndexes ( ) . stream ( ) . filter ( i -> i . supportsOrderedIterations ( ) ) . filter ( i -> i . getDefinition ( ) != null ) . collect ( Collectors . toList ( ) ) ) { \nList < String > indexFields = idx . getDefinition ( ) . getFields ( ) ; \nif ( indexFields . size ( ) < info . orderBy . getItems ( ) . size ( ) ) { \ncontinue ; \n} \nboolean indexFound = true ; \nString orderType = null ; \nfor ( int i = 0 ; \ni < info . orderBy . getItems ( ) . size ( ) ; \ni ++ ) { \nOOrderByItem orderItem = info . orderBy . getItems ( ) . get ( i ) ; \nif ( orderItem . getCollate ( ) != null ) { \nreturn false ; \n} \nString indexField = indexFields . get ( i ) ; \nif ( i == 0 ) { \norderType = orderItem . getType ( ) ; \n} \nelse { \nif ( orderType == null ) { \nindexFound = false ; \nbreak ; \n} \nelse if ( ! orderType . equals ( orderItem . getType ( ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( ! ( indexField . equals ( orderItem . getAlias ( ) ) || isInOriginalProjection ( indexField , orderItem . getAlias ( ) ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( indexFound ) { \nif ( orderType != null ) { \nplan . chain ( new FetchFromIndexValuesStep ( idx , orderType . equals ( OOrderByItem . ASC ) , ctx , profilingEnabled ) ) ; \nint [ ] filterClusterIds = null ; \nif ( filterClusters != null ) { \nfilterClusterIds = filterClusters . stream ( ) . map ( name -> ctx . getDatabase ( ) . getClusterIdByName ( name ) ) . mapToInt ( i -> i ) . toArray ( ) ; \n} \nplan . chain ( new GetValueFromIndexEntryStep ( ctx , filterClusterIds , profilingEnabled ) ) ; \nif ( info . serverToClusters . size ( ) == 1 ) { \ninfo . orderApplied = true ; \n} \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"2929": "public class OSelectExecutionPlanner { \nprivate IndexSearchDescriptor buildIndexSearchDescriptorForFulltext ( OCommandContext ctx , OIndex < ? > index , OAndBlock block , OClass clazz ) { \nList < String > indexFields = index . getDefinition ( ) . getFields ( ) ; \nOBinaryCondition keyCondition = new OBinaryCondition ( - 1 ) ; \nOIdentifier key = new OIdentifier ( \"key\" ) ; \nkeyCondition . setLeft ( new OExpression ( key ) ) ; \nboolean found = false ; \nOAndBlock blockCopy = block . copy ( ) ; \nIterator < OBooleanExpression > blockIterator ; \nOAndBlock indexKeyValue = new OAndBlock ( - 1 ) ; \nIndexSearchDescriptor result = new IndexSearchDescriptor ( ) ; \nresult . idx = index ; \nresult . keyCondition = indexKeyValue ; \nfor ( String indexField : indexFields ) { \nblockIterator = blockCopy . getSubBlocks ( ) . iterator ( ) ; \nboolean breakHere = false ; \nboolean indexFieldFound = false ; \nwhile ( blockIterator . hasNext ( ) ) { \nOBooleanExpression singleExp = blockIterator . next ( ) ; \nif ( singleExp instanceof OContainsTextCondition ) { \nOExpression left = ( ( OContainsTextCondition ) singleExp ) . getLeft ( ) ; \nif ( left . isBaseIdentifier ( ) ) { \nString fieldName = left . getDefaultAlias ( ) . getStringValue ( ) ; \nif ( indexField . equals ( fieldName ) ) { \nfound = true ; \nindexFieldFound = true ; \nOContainsTextCondition condition = new OContainsTextCondition ( - 1 ) ; \ncondition . setLeft ( left ) ; \ncondition . setRight ( ( ( OContainsTextCondition ) singleExp ) . getRight ( ) . copy ( ) ) ; \nindexKeyValue . getSubBlocks ( ) . add ( condition ) ; \nblockIterator . remove ( ) ; \nbreak ; \n} \n} \n} \n} \nif ( breakHere ) { \nbreak ; \n} \nelse if ( ! indexFieldFound ) { \nbreak ; \n} \n} \nif ( result . keyCondition . getSubBlocks ( ) . size ( ) < index . getDefinition ( ) . getFields ( ) . size ( ) ) { \nif ( ! index . supportsOrderedIterations ( ) ) { \nreturn null ; \n} \n} \nif ( found ) { \nresult . remainingCondition = blockCopy ; \nreturn result ; \n} \nreturn null ; \n} \n} \n"}
{"2932": "public class OUser { \npublic ORole allow ( final ORule . ResourceGeneric resourceGeneric , String resourceSpecific , final int iOperation ) { \nif ( roles == null ) { \nif ( document . field ( \"roles\" ) != null && ! ( ( Collection < OIdentifiable > ) document . field ( \"roles\" ) ) . isEmpty ( ) ) { \nfinal ODocument doc = document ; \ndocument = null ; \nfromStream ( doc ) ; \n} \nelse throw new OSecurityAccessException ( document . getDatabase ( ) . getName ( ) , \"User '\" + document . field ( \"name\" ) + \"' has no role defined\" ) ; \n} \nelse if ( roles . isEmpty ( ) ) { \nif ( document . field ( \"roles\" ) != null && ! ( ( Collection < OIdentifiable > ) document . field ( \"roles\" ) ) . isEmpty ( ) ) { \nfinal ODocument doc = document ; \ndocument = null ; \nfromStream ( doc ) ; \n} \nelse throw new OSecurityAccessException ( document . getDatabase ( ) . getName ( ) , \"User '\" + document . field ( \"name\" ) + \"' has no role defined\" ) ; \n} \nfinal ORole role = checkIfAllowed ( resourceGeneric , resourceSpecific , iOperation ) ; \nif ( role == null ) throw new OSecurityAccessException ( document . getDatabase ( ) . getName ( ) , \"User '\" + document . field ( \"name\" ) + \"' does not have permission to execute the operation '\" + ORole . permissionToString ( iOperation ) + \"' against the resource: \" + resourceGeneric + \".\" + resourceSpecific ) ; \nreturn role ; \n} \n} \n"}
{"2938": "public class OHazelcastPlugin { \n@ Override public String electNewLockManager ( ) { \nif ( hazelcastInstance == null ) throw new HazelcastInstanceNotActiveException ( ) ; \nfinal ILock lock = hazelcastInstance . getLock ( \"orientdb.lockManagerElection\" ) ; \nlock . lock ( ) ; \ntry { \nString lockManagerServer = getLockManagerRequester ( ) . getServer ( ) ; \nif ( lockManagerServer != null ) { \nif ( getActiveServers ( ) . contains ( lockManagerServer ) ) return lockManagerServer ; \n} \nfinal String originalLockManager = lockManagerServer ; \nODistributedServerLog . debug ( this , nodeName , originalLockManager , DIRECTION . OUT , \"lock '%s' is unreachable, electing a new lock...\" , originalLockManager ) ; \nint lockManagerServerId = - 1 ; \nif ( lockManagerServer != null ) { \nif ( registeredNodeByName . containsKey ( lockManagerServer ) ) lockManagerServerId = registeredNodeByName . get ( lockManagerServer ) ; \n} \nString newServer = null ; \nint currIndex = lockManagerServerId ; \nfor ( int i = 0 ; \ni < registeredNodeById . size ( ) ; \n++ i ) { \ncurrIndex ++ ; \nif ( currIndex >= registeredNodeById . size ( ) ) currIndex = 0 ; \nnewServer = registeredNodeById . get ( currIndex ) ; \nif ( newServer == null ) throw new OConfigurationException ( \"Found null server at index \" + currIndex + \" of server list \" + registeredNodeById ) ; \nif ( newServer . equalsIgnoreCase ( getLocalNodeName ( ) ) ) { \nODistributedServerLog . debug ( this , nodeName , newServer , DIRECTION . OUT , \"Trying to elected server '%s' as new lock (old=%s)...\" , newServer , originalLockManager ) ; \ntry { \ngetLockManagerRequester ( ) . setServer ( newServer ) ; \nconfigurationMap . put ( CONFIG_LOCKMANAGER , getLockManagerRequester ( ) . getServer ( ) ) ; \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Elected server '%s' as new lock (old=%s)\" , newServer , originalLockManager ) ; \nbreak ; \n} \ncatch ( Exception e ) { \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Error on electing server '%s' as new lock (error: %s)\" , newServer , e ) ; \n} \n} \nelse if ( activeNodes . containsKey ( newServer ) ) { \nODistributedServerLog . debug ( this , nodeName , newServer , DIRECTION . OUT , \"Trying to elected server '%s' as new lock (old=%s)...\" , newServer , originalLockManager ) ; \ntry { \ngetLockManagerRequester ( ) . setServer ( newServer ) ; \nconfigurationMap . put ( CONFIG_LOCKMANAGER , getLockManagerRequester ( ) . getServer ( ) ) ; \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Elected server '%s' as new lock (old=%s)\" , newServer , originalLockManager ) ; \nbreak ; \n} \ncatch ( Exception e ) { \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Error on electing server '%s' as new lock (error: %s)\" , newServer , e ) ; \n} \n} \n} \nreturn newServer ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"2939": "public class OHazelcastPlugin { \nprivate void assignLockManagerFromCluster ( ) { \nString lockManagerServer = null ; \nwhile ( lockManagerServer == null ) { \nif ( activeNodes . size ( ) == 1 ) { \nlockManagerServer = nodeName ; \nif ( configurationMap . putIfAbsent ( CONFIG_LOCKMANAGER , lockManagerServer ) == null ) break ; \n} \nelse { \nlockManagerServer = ( String ) configurationMap . get ( CONFIG_LOCKMANAGER ) ; \nif ( lockManagerServer != null ) { \nif ( lockManagerServer . equals ( nodeName ) ) { \nOLogManager . instance ( ) . info ( this , \"Found lock as current node, even if it was offline. Forcing a new election...\" ) ; \ngetLockManagerRequester ( ) . setServer ( lockManagerServer ) ; \nlockManagerServer = electNewLockManager ( ) ; \nbreak ; \n} \n} \nif ( lockManagerServer != null ) break ; \n} \ntry { \nThread . sleep ( 100 ) ; \n} \ncatch ( InterruptedException e ) { \nbreak ; \n} \n} \ngetLockManagerRequester ( ) . setServer ( lockManagerServer ) ; \nOLogManager . instance ( ) . info ( this , \"Distributed Lock Manager server is '%s'\" , lockManagerServer ) ; \n} \n} \n"}
{"2947": "public class ODistributedStorage { \nprotected boolean executeOnlyLocally ( final String localNodeName , final ODistributedConfiguration dbCfg , final OCommandExecutor exec , final Collection < String > involvedClusters , final Collection < String > nodes ) { \nboolean executeLocally = false ; \nif ( exec . isIdempotent ( ) ) { \nfinal int availableNodes = nodes . size ( ) ; \nint maxReadQuorum ; \nif ( involvedClusters . isEmpty ( ) ) maxReadQuorum = dbCfg . getReadQuorum ( null , availableNodes , localNodeName ) ; \nelse { \nmaxReadQuorum = 0 ; \nfor ( String cl : involvedClusters ) maxReadQuorum = Math . max ( maxReadQuorum , dbCfg . getReadQuorum ( cl , availableNodes , localNodeName ) ) ; \n} \nif ( nodes . contains ( localNodeName ) ) { \nif ( maxReadQuorum <= 1 ) executeLocally = true ; \n} \n} \nreturn executeLocally ; \n} \npublic boolean isLocalEnv ( ) { \nreturn localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal . INSTANCE . isRunModeDistributed ( ) ; \n} \npublic OStorageOperationResult < ORawBuffer > readRecord ( final ORecordId iRecordId , final String iFetchPlan , final boolean iIgnoreCache , final boolean prefetchRecords , final ORecordCallback < ORawBuffer > iCallback ) { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( iRecordId ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( iRecordId ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \n} \n) ; \n} \nelse if ( nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \n} \n) ; \n} \nfinal OReadRecordTask task = ( ( OReadRecordTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordTask . FACTORYID ) ) . init ( iRecordId ) ; \nfinal ODistributedResponse response = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) ; \nfinal Object dResult = response != null ? response . getPayload ( ) : null ; \nif ( dResult instanceof ONeedRetryException ) throw ( ONeedRetryException ) dResult ; \nelse if ( dResult instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) dResult ) ; \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) dResult ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , iRecordId ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < ORawBuffer > readRecordIfVersionIsNotLatest ( final ORecordId rid , final String fetchPlan , final boolean ignoreCache , final int recordVersion ) throws ORecordNotFoundException { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( rid ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( rid ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \n} \n) ; \n} \nelse if ( nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \n} \n) ; \n} \nfinal OReadRecordIfNotLatestTask task = ( OReadRecordIfNotLatestTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordIfNotLatestTask . FACTORYID ) ; \ntask . init ( rid , recordVersion ) ; \nfinal Object result = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) . getPayload ( ) ; \nif ( result instanceof ONeedRetryException ) throw ( ONeedRetryException ) result ; \nelse if ( result instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) result ) ; \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) result ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , rid ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < Boolean > deleteRecord ( final ORecordId iRecordId , final int iVersion , final int iMode , final ORecordCallback < Boolean > iCallback ) { \nreturn wrapped . deleteRecord ( iRecordId , iVersion , iMode , iCallback ) ; \n} \n} \n"}
{"2958": "public class OFileClassic { \nprivate long checkRegions ( final long iOffset , final long iLength ) { \nacquireReadLock ( ) ; \ntry { \nif ( iOffset < 0 ) { \nthrow new OIOException ( \"You cannot access outside the file size (\" + size + \" bytes). You have requested portion \" + iOffset + \"-\" + ( iOffset + iLength ) + \" bytes. File: \" + this ) ; \n} \nelse if ( iOffset + iLength > size ) { \nthrow new OIOException ( \"You cannot access outside the file size (\" + size + \" bytes). You have requested portion \" + iOffset + \"-\" + ( iOffset + iLength ) + \" bytes. File: \" + this ) ; \n} \nreturn iOffset + HEADER_SIZE ; \n} \nfinally { \nreleaseReadLock ( ) ; \n} \n} \n} \n"}
{"2962": "public class OStorageRemote { \nprotected String addHost ( String host ) { \nif ( host . startsWith ( LOCALHOST ) ) host = LOCAL_IP + host . substring ( \"localhost\" . length ( ) ) ; \nif ( host . contains ( \"/\" ) ) host = host . substring ( 0 , host . indexOf ( \"/\" ) ) ; \nif ( ! host . contains ( \":\" ) ) host += \":\" + ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \nelse if ( host . split ( \":\" ) . length < 2 ) host += ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \nelse if ( host . split ( \":\" ) [ 1 ] . trim ( ) . length ( ) == 0 ) host += ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \nsynchronized ( serverURLs ) { \nif ( ! serverURLs . contains ( host ) ) { \nserverURLs . add ( host ) ; \nOLogManager . instance ( ) . debug ( this , \"Registered the new available server '%s'\" , host ) ; \n} \n} \nreturn host ; \n} \n} \n"}
{"2969": "public class OClientConnectionManager { \npublic void pushDistribCfg2Clients ( final ODocument iConfig ) { \nif ( iConfig == null ) return ; \nfinal Set < String > pushed = new HashSet < String > ( ) ; \nfor ( OClientConnection c : connections . values ( ) ) { \nif ( ! c . getData ( ) . supportsLegacyPushMessages ) continue ; \ntry { \nfinal String remoteAddress = c . getRemoteAddress ( ) ; \nif ( pushed . contains ( remoteAddress ) ) continue ; \n} \ncatch ( Exception e ) { \ncontinue ; \n} \nif ( ! ( c . getProtocol ( ) instanceof ONetworkProtocolBinary ) ) continue ; \nelse if ( c . getData ( ) . getSerializationImpl ( ) == null ) continue ; \nfinal ONetworkProtocolBinary p = ( ONetworkProtocolBinary ) c . getProtocol ( ) ; \nfinal OChannelBinary channel = p . getChannel ( ) ; \nfinal ORecordSerializer ser = ORecordSerializerFactory . instance ( ) . getFormat ( c . getData ( ) . getSerializationImpl ( ) ) ; \nif ( ser == null ) return ; \nfinal byte [ ] content = ser . toStream ( iConfig , false ) ; \ntry { \nif ( channel . tryAcquireWriteLock ( TIMEOUT_PUSH ) ) { \ntry { \nchannel . writeByte ( OChannelBinaryProtocol . PUSH_DATA ) ; \nchannel . writeInt ( Integer . MIN_VALUE ) ; \nchannel . writeByte ( OChannelBinaryProtocol . REQUEST_PUSH_DISTRIB_CONFIG ) ; \nchannel . writeBytes ( content ) ; \nchannel . flush ( ) ; \npushed . add ( c . getRemoteAddress ( ) ) ; \nOLogManager . instance ( ) . debug ( this , \"Sent updated cluster configuration to the remote client %s\" , c . getRemoteAddress ( ) ) ; \n} \nfinally { \nchannel . releaseWriteLock ( ) ; \n} \n} \nelse { \nOLogManager . instance ( ) . info ( this , \"Timeout on sending updated cluster configuration to the remote client %s\" , c . getRemoteAddress ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . warn ( this , \"Cannot push cluster configuration to the client %s\" , e , c . getRemoteAddress ( ) ) ; \n} \n} \n} \n} \n"}
{"2972": "public class OSchemaProxyObject { \npublic synchronized void synchronizeSchema ( ) { \nOObjectDatabaseTx database = ( ( OObjectDatabaseTx ) ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getDatabaseOwner ( ) ) ; \nCollection < Class < ? > > registeredEntities = database . getEntityManager ( ) . getRegisteredEntities ( ) ; \nboolean automaticSchemaGeneration = database . isAutomaticSchemaGeneration ( ) ; \nboolean reloadSchema = false ; \nfor ( Class < ? > iClass : registeredEntities ) { \nif ( Proxy . class . isAssignableFrom ( iClass ) || iClass . isEnum ( ) || OReflectionHelper . isJavaType ( iClass ) ) return ; \nelse if ( iClass . isAnonymousClass ( ) ) return ; \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( iClass . getSimpleName ( ) ) ) { \ndatabase . getMetadata ( ) . getSchema ( ) . createClass ( iClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nfor ( Class < ? > currentClass = iClass ; \ncurrentClass != Object . class ; \n) { \nif ( automaticSchemaGeneration && ! currentClass . equals ( Object . class ) ) { \nif ( ! currentClass . equals ( ODocument . class ) ) { \n( ( OSchemaProxyObject ) database . getMetadata ( ) . getSchema ( ) ) . generateSchema ( currentClass , database . getUnderlying ( ) ) ; \n} \n} \nString iClassName = currentClass . getSimpleName ( ) ; \ncurrentClass = currentClass . getSuperclass ( ) ; \nif ( currentClass == null ) currentClass = Object . class ; \nelse if ( currentClass . equals ( ODocument . class ) ) currentClass = Object . class ; \nif ( database != null && ! database . isClosed ( ) ) { \nif ( ! currentClass . equals ( Object . class ) ) { \nOClass oSuperClass ; \nOClass currentOClass = database . getMetadata ( ) . getSchema ( ) . getClass ( iClassName ) ; \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( currentClass . getSimpleName ( ) ) ) { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . createClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nelse { \noSuperClass = database . getMetadata ( ) . getSchema ( ) . getClass ( currentClass . getSimpleName ( ) ) ; \nreloadSchema = true ; \n} \nif ( ! currentOClass . getSuperClasses ( ) . contains ( oSuperClass ) ) { \ncurrentOClass . setSuperClasses ( Arrays . asList ( oSuperClass ) ) ; \nreloadSchema = true ; \n} \n} \n} \n} \n} \nif ( database != null && ! database . isClosed ( ) ) { \nif ( reloadSchema ) { \ndatabase . getMetadata ( ) . getSchema ( ) . reload ( ) ; \n} \n} \n} \n} \n"}
{"2973": "public class OAbstractProfiler { \nprotected void updateMetadata ( final String iName , final String iDescription , final METRIC_TYPE iType ) { \nif ( iDescription != null ) { \nif ( dictionary . putIfAbsent ( iName , iDescription ) == null ) types . put ( iName , iType ) ; \n} \n} \n} \n"}
{"2974": "public class ORecordIteratorClusters { \n@ Override public ORecordIteratorClusters < REC > last ( ) { \nif ( clusterIds . length == 0 ) return this ; \nbrowsedRecords = 0 ; \ncurrentClusterIdx = clusterIds . length - 1 ; \nupdateClusterRange ( ) ; \ncurrent . setClusterId ( clusterIds [ currentClusterIdx ] ) ; \nresetCurrentPosition ( ) ; \nprevPosition ( ) ; \nfinal ORecord record = getRecord ( ) ; \ncurrentRecord = readCurrentRecord ( record , 0 ) ; \nif ( currentRecord != null ) { \nif ( ! include ( currentRecord ) ) { \ncurrentRecord = null ; \nhasPrevious ( ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"2976": "public class OCommandExecutorSQLFindReferences { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( recordIds . isEmpty ( ) ) { \nif ( subQuery == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nif ( subQuery != null ) { \nfinal List < OIdentifiable > result = new OCommandSQL ( subQuery . toString ( ) ) . execute ( ) ; \nfor ( OIdentifiable id : result ) recordIds . add ( id . getIdentity ( ) ) ; \n} \nreturn OFindReferenceHelper . findReferences ( recordIds , classList ) ; \n} \n} \n"}
{"2986": "public class OCommandExecutorSQLMoveVertex { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nODatabaseDocumentInternal db = getDatabase ( ) ; \ndb . begin ( ) ; \nif ( className == null ) { \nif ( clusterName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nOModifiableBoolean shutdownGraph = new OModifiableBoolean ( ) ; \nfinal boolean txAlreadyBegun = getDatabase ( ) . getTransaction ( ) . isActive ( ) ; \ntry { \nfinal Set < OIdentifiable > sourceRIDs = OSQLEngine . getInstance ( ) . parseRIDTarget ( db , source , context , iArgs ) ; \nfinal List < ODocument > result = new ArrayList < ODocument > ( sourceRIDs . size ( ) ) ; \nfor ( OIdentifiable from : sourceRIDs ) { \nfinal OVertex fromVertex = toVertex ( from ) ; \nif ( fromVertex == null ) continue ; \nfinal ORID oldVertex = fromVertex . getIdentity ( ) . copy ( ) ; \nfinal ORID newVertex = fromVertex . moveTo ( className , clusterName ) ; \nfinal ODocument newVertexDoc = newVertex . getRecord ( ) ; \nif ( fields != null ) { \nfor ( final OPair < String , Object > f : fields ) { \nif ( f . getValue ( ) instanceof OSQLFunctionRuntime ) f . setValue ( ( ( OSQLFunctionRuntime ) f . getValue ( ) ) . getValue ( newVertex . getRecord ( ) , null , context ) ) ; \n} \nOSQLHelper . bindParameters ( newVertexDoc , fields , new OCommandParameters ( iArgs ) , context ) ; \n} \nif ( merge != null ) newVertexDoc . merge ( merge , true , false ) ; \nnewVertexDoc . save ( ) ; \nresult . add ( new ODocument ( ) . setTrackingChanges ( false ) . field ( \"old\" , oldVertex , OType . LINK ) . field ( \"new\" , newVertex , OType . LINK ) ) ; \nif ( batch > 0 ) { \nif ( result . size ( ) % batch == 0 ) { \ndb . commit ( ) ; \ndb . begin ( ) ; \n} \n} \n} \ndb . commit ( ) ; \nreturn result ; \n} \nfinally { \n} \n} \n} \n"}
{"2994": "public class OSQLFilterItemField { \npublic OCollate getCollate ( Object doc ) { \nif ( collate != null || operationsChain == null ) { \nreturn collate ; \n} \nelse if ( ! isFieldChain ( ) ) { \nreturn collate ; \n} \nif ( ! ( doc instanceof OIdentifiable ) ) { \nreturn null ; \n} \nFieldChain chain = getFieldChain ( ) ; \nODocument lastDoc = ( ( OIdentifiable ) doc ) . getRecord ( ) ; \nfor ( int i = 0 ; \ni < chain . getItemCount ( ) - 1 ; \ni ++ ) { \nif ( lastDoc == null ) { \nreturn null ; \n} \nObject nextDoc = lastDoc . field ( chain . getItemName ( i ) ) ; \nif ( nextDoc == null ) { \nreturn null ; \n} \nelse if ( ! ( nextDoc instanceof OIdentifiable ) ) { \nreturn null ; \n} \nlastDoc = ( ( OIdentifiable ) nextDoc ) . getRecord ( ) ; \n} \nif ( lastDoc == null ) { \nreturn null ; \n} \nOClass schemaClass = lastDoc . getSchemaClass ( ) ; \nif ( schemaClass == null ) { \nreturn null ; \n} \nOProperty property = schemaClass . getProperty ( chain . getItemName ( chain . getItemCount ( ) - 1 ) ) ; \nif ( property == null ) { \nreturn null ; \n} \nreturn property . getCollate ( ) ; \n} \n} \n"}
{"3001": "public class OSecurityManager { \nprivate static boolean isAlgorithmSupported ( final String algorithm ) { \nif ( Runtime . class . getPackage ( ) != null ) { \nif ( Runtime . class . getPackage ( ) . getImplementationVersion ( ) != null ) { \nif ( Runtime . class . getPackage ( ) . getImplementationVersion ( ) . startsWith ( \"1.7\" ) ) { \nif ( algorithm != null ) { \nif ( algorithm . equals ( PBKDF2_SHA256_ALGORITHM ) ) { \nreturn false ; \n} \n} \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"3003": "public class OrientGraphQuery { \n@ Override public Iterable < Vertex > vertices ( ) { \nif ( limit == 0 ) return Collections . emptyList ( ) ; \nOTransaction transaction = ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) ; \nif ( transaction . isActive ( ) && transaction . getEntryCount ( ) > 0 ) { \nString [ ] classes = allSubClassesLabels ( ) ; \nreturn new OrientGraphQueryIterable < Vertex > ( true , classes ) ; \n} \nelse if ( hasCustomPredicate ( ) ) { \nString [ ] classes = allSubClassesLabels ( ) ; \nreturn new OrientGraphQueryIterable < Vertex > ( true , classes ) ; \n} \nfinal StringBuilder text = new StringBuilder ( 512 ) ; \ntext . append ( QUERY_SELECT_FROM ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) && labels != null && labels . length > 0 ) { \nif ( labels . length == 1 ) text . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; \nelse { \nString [ ] classes = allSubClassesLabels ( ) ; \nreturn new OrientGraphQueryIterable < Vertex > ( true , classes ) ; \n} \n} \nelse text . append ( OrientVertexType . CLASS_NAME ) ; \nfinal List < Object > queryParams = manageFilters ( text ) ; \nif ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) ) manageLabels ( queryParams . size ( ) > 0 , text ) ; \nif ( orderBy . length ( ) > 1 ) { \ntext . append ( ORDERBY ) ; \ntext . append ( orderBy ) ; \ntext . append ( \" \" ) . append ( orderByDir ) . append ( \" \" ) ; \n} \nif ( skip > 0 ) { \nif ( skip < Integer . MAX_VALUE ) { \ntext . append ( SKIP ) ; \ntext . append ( skip ) ; \n} \n} \nif ( limit > 0 ) { \nif ( limit < Integer . MAX_VALUE ) { \ntext . append ( LIMIT ) ; \ntext . append ( limit ) ; \n} \n} \nfinal OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; \nif ( fetchPlan != null ) query . setFetchPlan ( fetchPlan ) ; \nreturn new OrientElementIterable < Vertex > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; \n} \n} \n"}
{"3004": "public class OrientGraphQuery { \n@ Override public Iterable < Edge > edges ( ) { \nif ( limit == 0 ) return Collections . emptyList ( ) ; \nif ( ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) . isActive ( ) ) return new OrientGraphQueryIterable < Edge > ( false , labels ) ; \nelse if ( hasCustomPredicate ( ) ) return new OrientGraphQueryIterable < Edge > ( false , labels ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseLightweightEdges ( ) ) return new OrientGraphQueryIterable < Edge > ( false , labels ) ; \nfinal StringBuilder text = new StringBuilder ( 512 ) ; \ntext . append ( QUERY_SELECT_FROM ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) && labels != null && labels . length > 0 ) { \nif ( labels . length == 1 ) text . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; \nelse { \nreturn new OrientGraphQueryIterable < Edge > ( false , labels ) ; \n} \n} \nelse text . append ( OrientEdgeType . CLASS_NAME ) ; \nList < Object > queryParams = manageFilters ( text ) ; \nif ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) ) manageLabels ( queryParams . size ( ) > 0 , text ) ; \nfinal OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; \nif ( fetchPlan != null ) query . setFetchPlan ( fetchPlan ) ; \nif ( limit > 0 ) { \nif ( limit < Integer . MAX_VALUE ) query . setLimit ( limit ) ; \n} \nreturn new OrientElementIterable < Edge > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; \n} \n} \n"}
{"3010": "public class OCommandExecutorSQLAbstract { \nprotected String parseLock ( ) throws OCommandSQLParsingException { \nfinal String lockStrategy = parserNextWord ( true ) ; \nif ( ! lockStrategy . equalsIgnoreCase ( \"DEFAULT\" ) && ! lockStrategy . equalsIgnoreCase ( \"NONE\" ) ) { \nif ( ! lockStrategy . equalsIgnoreCase ( \"RECORD\" ) ) throwParsingException ( \"Invalid \" + KEYWORD_LOCK + \" value set to '\" + lockStrategy + \"' but it should be NONE (default) or RECORD. Example: \" + KEYWORD_LOCK + \" RECORD\" ) ; \n} \nreturn lockStrategy ; \n} \n} \n"}
{"3018": "public class OCommandExecutorSQLDelete { \npublic boolean result ( final Object iRecord ) { \nfinal ORecordAbstract record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; \nif ( record instanceof ODocument && compiledFilter != null ) { \nif ( ! Boolean . TRUE . equals ( this . compiledFilter . evaluate ( record , ( ODocument ) record , getContext ( ) ) ) ) { \nreturn true ; \n} \n} \ntry { \nif ( record . getIdentity ( ) . isValid ( ) ) { \nif ( returning . equalsIgnoreCase ( \"BEFORE\" ) ) allDeletedRecords . add ( record ) ; \nif ( ! unsafe ) { \nif ( record instanceof ODocument ) { \nfinal OClass cls = ( ( ODocument ) record ) . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( cls . isSubClassOf ( \"V\" ) ) throw new OCommandExecutionException ( \"'DELETE' command cannot delete vertices. Use 'DELETE VERTEX' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \nelse if ( cls . isSubClassOf ( \"E\" ) ) throw new OCommandExecutionException ( \"'DELETE' command cannot delete edges. Use 'DELETE EDGE' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \n} \nrecord . delete ( ) ; \nrecordCount ++ ; \nreturn true ; \n} \nreturn false ; \n} \nfinally { \nif ( lockStrategy . equalsIgnoreCase ( \"RECORD\" ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) ) . releaseWriteLock ( record . getIdentity ( ) ) ; \n} \n} \n} \n"}
{"3019": "public class OSQLPredicate { \npublic void bindParameters ( final Map < Object , Object > iArgs ) { \nif ( parameterItems == null || iArgs == null ) return ; \nelse if ( iArgs . size ( ) == 0 ) return ; \nfor ( int i = 0 ; \ni < parameterItems . size ( ) ; \ni ++ ) { \nOSQLFilterItemParameter value = parameterItems . get ( i ) ; \nif ( \"?\" . equals ( value . getName ( ) ) ) { \nvalue . setValue ( iArgs . get ( i ) ) ; \n} \nelse { \nvalue . setValue ( iArgs . get ( value . getName ( ) ) ) ; \n} \n} \n} \n} \n"}
{"3025": "public class OPropertyImpl { \n@ Deprecated public OIndex < ? > getIndex ( ) { \nacquireSchemaReadLock ( ) ; \ntry { \nSet < OIndex < ? > > indexes = owner . getInvolvedIndexes ( globalRef . getName ( ) ) ; \nif ( indexes != null ) { \nif ( ! indexes . isEmpty ( ) ) return indexes . iterator ( ) . next ( ) ; \n} \nreturn null ; \n} \nfinally { \nreleaseSchemaReadLock ( ) ; \n} \n} \n} \n"}
{"3026": "public class OPropertyImpl { \npublic OClass getLinkedClass ( ) { \nacquireSchemaReadLock ( ) ; \ntry { \nif ( linkedClass == null ) { \nif ( linkedClassName != null ) linkedClass = owner . owner . getClass ( linkedClassName ) ; \n} \nreturn linkedClass ; \n} \nfinally { \nreleaseSchemaReadLock ( ) ; \n} \n} \n} \n"}
{"3034": "public class OCommandExecutorUtility { \npublic static Object transformResult ( Object result ) { \nif ( java8MethodIsArray == null ) { \nreturn result ; \n} \nelse if ( ! ( result instanceof Map ) ) { \nreturn result ; \n} \ntry { \nif ( ( Boolean ) java8MethodIsArray . invoke ( result ) ) { \nList < ? > partial = new ArrayList ( ( ( Map ) result ) . values ( ) ) ; \nList < Object > finalResult = new ArrayList < Object > ( ) ; \nfor ( Object o : partial ) { \nfinalResult . add ( transformResult ( o ) ) ; \n} \nreturn finalResult ; \n} \nelse { \nMap < Object , Object > mapResult = ( Map ) result ; \nList < Object > keys = new ArrayList < Object > ( mapResult . keySet ( ) ) ; \nfor ( Object key : keys ) { \nmapResult . put ( key , transformResult ( mapResult . get ( key ) ) ) ; \n} \nreturn mapResult ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( OCommandExecutorUtility . class , \"\" , e ) ; \n} \nreturn result ; \n} \n} \n"}
{"3049": "public class ODatabaseDocumentTxPooled { \n@ Override public void close ( ) { \nif ( isClosed ( ) ) return ; \ncheckOpenness ( ) ; \nif ( ownerPool != null ) { \nif ( ownerPool . getConnectionsInCurrentThread ( getURL ( ) , userName ) > 1 ) { \nownerPool . release ( this ) ; \nreturn ; \n} \n} \ntry { \ncommit ( true ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error on releasing database '%s' in pool\" , e , getName ( ) ) ; \n} \ntry { \ncallOnCloseListeners ( ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error on releasing database '%s' in pool\" , e , getName ( ) ) ; \n} \ngetLocalCache ( ) . clear ( ) ; \nif ( ownerPool != null ) { \nfinal ODatabaseDocumentPool localCopy = ownerPool ; \nownerPool = null ; \nlocalCopy . release ( this ) ; \n} \nODatabaseRecordThreadLocal . instance ( ) . remove ( ) ; \n} \n} \n"}
{"3050": "public class OSBTreeCollectionManagerShared { \n@ Override public UUID listenForChanges ( ORidBag collection ) { \nUUID ownerUUID = collection . getTemporaryId ( ) ; \nif ( ownerUUID != null ) { \nfinal OBonsaiCollectionPointer pointer = collection . getPointer ( ) ; \nMap < UUID , OBonsaiCollectionPointer > changedPointers = collectionPointerChanges . get ( ) ; \nif ( pointer != null ) { \nif ( pointer . isValid ( ) ) { \nchangedPointers . put ( ownerUUID , pointer ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"3073": "public class OTransactionRealAbstract { \npublic List < ORecordOperation > getNewRecordEntriesByClass ( final OClass iClass , final boolean iPolymorphic ) { \nfinal List < ORecordOperation > result = new ArrayList < ORecordOperation > ( ) ; \nif ( iClass == null ) for ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) result . add ( entry ) ; \n} \nelse { \nfor ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) if ( entry . getRecord ( ) != null ) { \nif ( entry . getRecord ( ) instanceof ODocument ) { \nif ( iPolymorphic ) { \nif ( iClass . isSuperClassOf ( ( ( ODocument ) entry . getRecord ( ) ) . getSchemaClass ( ) ) ) result . add ( entry ) ; \n} \nelse if ( iClass . getName ( ) . equals ( ( ( ODocument ) entry . getRecord ( ) ) . getClassName ( ) ) ) result . add ( entry ) ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"3074": "public class OTransactionRealAbstract { \npublic List < ORecordOperation > getNewRecordEntriesByClusterIds ( final int [ ] iIds ) { \nfinal List < ORecordOperation > result = new ArrayList < ORecordOperation > ( ) ; \nif ( iIds == null ) for ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) result . add ( entry ) ; \n} \nelse for ( ORecordOperation entry : allEntries . values ( ) ) { \nfor ( int id : iIds ) { \nif ( entry . getRecord ( ) != null && entry . getRecord ( ) . getIdentity ( ) . getClusterId ( ) == id ) { \nif ( entry . type == ORecordOperation . CREATED ) { \nresult . add ( entry ) ; \nbreak ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"3077": "public class OCommandExecutorSQLUpdate { \n@ SuppressWarnings ( \"unchecked\" ) public boolean result ( final Object iRecord ) { \nfinal ODocument record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; \nif ( isUpdateEdge ( ) ) { \nif ( ! isRecordInstanceOf ( iRecord , \"E\" ) ) { \nthrow new OCommandExecutionException ( \"Using UPDATE EDGE on a record that is not an instance of E\" ) ; \n} \n} \nif ( compiledFilter != null ) { \nif ( ! ( Boolean ) compiledFilter . evaluate ( record , null , context ) ) return false ; \n} \nparameters . reset ( ) ; \nreturnHandler . beforeUpdate ( record ) ; \nboolean updated = handleContent ( record ) ; \nupdated |= handleMerge ( record ) ; \nupdated |= handleSetEntries ( record ) ; \nupdated |= handleIncrementEntries ( record ) ; \nupdated |= handleAddEntries ( record ) ; \nupdated |= handlePutEntries ( record ) ; \nupdated |= handleRemoveEntries ( record ) ; \nif ( updated ) { \nhandleUpdateEdge ( record ) ; \nrecord . setDirty ( ) ; \nrecord . save ( ) ; \nreturnHandler . afterUpdate ( record ) ; \nthis . updated = true ; \n} \nreturn true ; \n} \n} \n"}
{"3081": "public class OWALSegmentCache { \nbyte [ ] readPage ( long pageIndex ) throws IOException { \nsynchronized ( lockObject ) { \nlastAccessTime = System . nanoTime ( ) ; \nif ( pageIndex == lastWrittenPageIndex ) { \nreturn lastWrittenPage . array ( ) ; \n} \nif ( pageIndex >= firstCachedPage ) { \nif ( pageIndex < firstCachedPage + pageCache . size ( ) ) { \nfinal ByteBuffer buffer = pageCache . get ( ( int ) ( pageIndex - firstCachedPage ) ) ; \nreturn buffer . array ( ) ; \n} \n} \nfinal ByteBuffer buffer = ByteBuffer . allocate ( OWALPage . PAGE_SIZE ) . order ( ByteOrder . nativeOrder ( ) ) ; \ninitFile ( ) ; \nsegChannel . position ( pageIndex * OWALPage . PAGE_SIZE ) ; \nreadByteBuffer ( buffer , segChannel ) ; \nreturn buffer . array ( ) ; \n} \n} \n} \n"}
{"3084": "public class ODistributedConfiguration { \npublic boolean isReplicationActive ( final String iClusterName , final String iLocalNode ) { \nfinal Collection < String > servers = getClusterConfiguration ( iClusterName ) . field ( SERVERS ) ; \nif ( servers != null ) { \nif ( ! servers . isEmpty ( ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3088": "public class ODistributedConfiguration { \npublic Map < String , Collection < String > > getServerClusterMap ( Collection < String > iClusterNames , final String iLocalNode , final boolean optimizeForLocalOnly ) { \nif ( iClusterNames == null ) iClusterNames = DEFAULT_CLUSTER_NAME ; \nelse if ( iClusterNames . isEmpty ( ) ) iClusterNames = DEFAULT_CLUSTER_NAME ; \nfinal Map < String , Collection < String > > servers = new HashMap < String , Collection < String > > ( iClusterNames . size ( ) ) ; \nboolean canUseLocalNode = true ; \nfor ( String p : iClusterNames ) { \nfinal List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nif ( ! serverList . contains ( iLocalNode ) ) { \ncanUseLocalNode = false ; \nbreak ; \n} \n} \n} \nif ( optimizeForLocalOnly ) { \nif ( canUseLocalNode ) { \nservers . put ( iLocalNode , iClusterNames ) ; \nreturn servers ; \n} \n} \nfinal Map < String , Collection < String > > serverMap = new HashMap < String , Collection < String > > ( ) ; \nfor ( String p : iClusterNames ) { \nfinal List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; \nfor ( String s : serverList ) { \nif ( NEW_NODE_TAG . equalsIgnoreCase ( s ) ) continue ; \nCollection < String > clustersInServer = serverMap . get ( s ) ; \nif ( clustersInServer == null ) { \nclustersInServer = new HashSet < String > ( ) ; \nserverMap . put ( s , clustersInServer ) ; \n} \nclustersInServer . add ( p ) ; \n} \n} \nif ( serverMap . size ( ) == 1 ) return serverMap ; \nif ( ! optimizeForLocalOnly ) return serverMap ; \nfinal List < String > orderedServers = new ArrayList < String > ( serverMap . keySet ( ) ) ; \nCollections . sort ( orderedServers , new Comparator < String > ( ) { \n@ Override public int compare ( final String o1 , final String o2 ) { \nreturn ( ( Integer ) serverMap . get ( o2 ) . size ( ) ) . compareTo ( ( Integer ) serverMap . get ( o1 ) . size ( ) ) ; \n} \n} \n) ; \nfinal Set < String > remainingClusters = new HashSet < String > ( iClusterNames ) ; \nfinal Set < String > includedClusters = new HashSet < String > ( iClusterNames . size ( ) ) ; \nfor ( String s : orderedServers ) { \nfinal Collection < String > clusters = serverMap . get ( s ) ; \nif ( ! servers . isEmpty ( ) ) { \nclusters . removeAll ( includedClusters ) ; \n} \nservers . put ( s , clusters ) ; \nremainingClusters . removeAll ( clusters ) ; \nincludedClusters . addAll ( clusters ) ; \nif ( remainingClusters . isEmpty ( ) ) break ; \n} \nreturn servers ; \n} \n} \n"}
{"3089": "public class ODistributedConfiguration { \npublic Set < String > getServers ( Collection < String > iClusterNames ) { \nif ( iClusterNames == null ) return getAllConfiguredServers ( ) ; \nelse if ( iClusterNames . isEmpty ( ) ) return getAllConfiguredServers ( ) ; \nfinal Set < String > partitions = new HashSet < String > ( iClusterNames . size ( ) ) ; \nfor ( String p : iClusterNames ) { \nfinal List < String > serverList = getClusterConfiguration ( p ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nfor ( String s : serverList ) if ( ! s . equals ( NEW_NODE_TAG ) ) partitions . add ( s ) ; \n} \n} \nreturn partitions ; \n} \n} \n"}
{"3090": "public class ODistributedConfiguration { \npublic boolean isServerContainingAllClusters ( final String server , Collection < String > clusters ) { \nif ( clusters == null ) clusters = DEFAULT_CLUSTER_NAME ; \nelse if ( clusters . isEmpty ( ) ) clusters = DEFAULT_CLUSTER_NAME ; \nfor ( String cluster : clusters ) { \nfinal List < String > serverList = getClusterConfiguration ( cluster ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nif ( ! serverList . contains ( server ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3096": "public class ODistributedConfiguration { \npublic String getClusterOwner ( final String iClusterName ) { \nString owner ; \nfinal ODocument clusters = getConfiguredClusters ( ) ; \nfinal ODocument cfg = iClusterName != null ? ( ODocument ) clusters . field ( iClusterName ) : null ; \nif ( cfg != null ) { \nowner = cfg . field ( OWNER ) ; \nif ( owner != null ) return owner ; \nfinal List < String > serverList = cfg . field ( SERVERS ) ; \nif ( serverList != null ) { \nif ( ! serverList . isEmpty ( ) ) { \nowner = serverList . get ( 0 ) ; \nif ( NEW_NODE_TAG . equals ( owner ) ) { \nif ( serverList . size ( ) > 1 ) owner = serverList . get ( 1 ) ; \n} \n} \n} \n} \nelse return getClusterOwner ( ALL_WILDCARD ) ; \nreturn owner ; \n} \n} \n"}
{"3102": "public class ODistributedConfiguration { \npublic boolean isSharded ( ) { \nfinal ODocument allCluster = getClusterConfiguration ( ALL_WILDCARD ) ; \nif ( allCluster != null ) { \nfinal List < String > allServers = allCluster . field ( SERVERS ) ; \nif ( allServers != null ) { \nif ( ! allServers . isEmpty ( ) ) { \nfor ( String cl : getClusterNames ( ) ) { \nfinal List < String > servers = getServers ( cl , null ) ; \nif ( servers != null && ! servers . isEmpty ( ) ) { \nif ( ! allServers . containsAll ( servers ) ) return false ; \n} \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3103": "public class ODistributedConfiguration { \npublic List < String > getDataCenterServers ( final String dataCenter ) { \nfinal ODocument dc = getDataCenterConfiguration ( dataCenter ) ; \nfinal List < String > servers = dc . field ( SERVERS ) ; \nif ( servers == null ) throw new OConfigurationException ( \"Data center '\" + dataCenter + \"' does not contain any server in distributed database configuration\" ) ; \nelse if ( servers . isEmpty ( ) ) throw new OConfigurationException ( \"Data center '\" + dataCenter + \"' does not contain any server in distributed database configuration\" ) ; \nreturn new ArrayList < String > ( servers ) ; \n} \n} \n"}
{"3104": "public class ODistributedConfiguration { \npublic String getDataCenterOfServer ( final String server ) { \nfinal ODocument dcs = configuration . field ( DCS ) ; \nif ( dcs != null ) { \nfor ( String dc : dcs . fieldNames ( ) ) { \nfinal ODocument dcConfig = dcs . field ( dc ) ; \nif ( dcConfig != null ) { \nfinal List < String > dcServers = dcConfig . field ( \"servers\" ) ; \nif ( dcServers != null ) { \nif ( ! dcServers . isEmpty ( ) ) { \nif ( dcServers . contains ( server ) ) return dc ; \n} \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"3110": "public class OrientBaseGraph { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public < T extends Element > Index < T > getIndex ( final String indexName , final Class < T > indexClass ) { \nmakeActive ( ) ; \nfinal OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfinal OIndex idx = indexManager . getIndex ( indexName ) ; \nif ( idx == null ) return null ; \nelse if ( ! hasIndexClass ( idx ) ) return null ; \nfinal Index < ? extends Element > index = new OrientIndex ( this , idx ) ; \nif ( indexClass . isAssignableFrom ( index . getIndexClass ( ) ) ) return ( Index < T > ) index ; \nelse throw ExceptionFactory . indexDoesNotSupportClass ( indexName , indexClass ) ; \n} \n} \n"}
{"3114": "public class OrientBaseGraph { \npublic OrientVertex getVertex ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) throw ExceptionFactory . vertexIdCanNotBeNull ( ) ; \nif ( id instanceof OrientVertex ) return ( OrientVertex ) id ; \nelse if ( id instanceof ODocument ) return getVertexInstance ( ( OIdentifiable ) id ) ; \nsetCurrentGraphInThreadLocal ( ) ; \nORID rid ; \nif ( id instanceof OIdentifiable ) rid = ( ( OIdentifiable ) id ) . getIdentity ( ) ; \nelse { \ntry { \nrid = new ORecordId ( id . toString ( ) ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \n} \nif ( ! rid . isValid ( ) ) return null ; \nfinal ORecord rec = rid . getRecord ( ) ; \nif ( rec == null ) return null ; \nelse if ( ! ( rec instanceof ODocument ) ) return null ; \nfinal OClass cls = ( ( ODocument ) rec ) . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( cls . isEdgeType ( ) ) throw new IllegalArgumentException ( \"Cannot retrieve a vertex with the RID \" + rid + \" because it is an edge\" ) ; \n} \nreturn getVertexInstance ( rec ) ; \n} \n} \n"}
{"3129": "public class OWOWCache { \n@ Override public void removeBackgroundExceptionListener ( final OBackgroundExceptionListener listener ) { \nfinal List < WeakReference < OBackgroundExceptionListener > > itemsToRemove = new ArrayList < > ( 1 ) ; \nfor ( final WeakReference < OBackgroundExceptionListener > ref : backgroundExceptionListeners ) { \nfinal OBackgroundExceptionListener l = ref . get ( ) ; \nif ( l != null ) { \nif ( l . equals ( listener ) ) { \nitemsToRemove . add ( ref ) ; \n} \n} \n} \nbackgroundExceptionListeners . removeAll ( itemsToRemove ) ; \n} \n} \n"}
{"3137": "public class OHttpResponse { \npublic byte [ ] compress ( String jsonStr ) { \nif ( jsonStr == null ) { \nreturn null ; \n} \nelse if ( jsonStr . length ( ) == 0 ) { \nreturn null ; \n} \nGZIPOutputStream gout = null ; \nByteArrayOutputStream baos = null ; \ntry { \nbyte [ ] incoming = jsonStr . getBytes ( \"UTF-8\" ) ; \nbaos = new ByteArrayOutputStream ( ) ; \ngout = new GZIPOutputStream ( baos , 16384 ) ; \ngout . write ( incoming ) ; \ngout . finish ( ) ; \nreturn baos . toByteArray ( ) ; \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"Error on compressing HTTP response\" , ex ) ; \n} \nfinally { \ntry { \nif ( gout != null ) { \ngout . close ( ) ; \n} \nif ( baos != null ) { \nbaos . close ( ) ; \n} \n} \ncatch ( Exception ex ) { \n} \n} \nreturn null ; \n} \n} \n"}
{"3149": "public class ODistributedResponseManagerImpl { \nprivate boolean computeQuorumResponse ( boolean reachedTimeout ) { \nif ( quorumResponse != null ) return true ; \nif ( groupResponsesByResult ) { \nfor ( List < ODistributedResponse > group : responseGroups ) { \nif ( group . size ( ) >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( ODistributedResponse r : group ) { \nif ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { \nfinal Object payload = r . getPayload ( ) ; \nif ( payload instanceof Throwable ) { \nif ( payload instanceof ODistributedRecordLockedException ) break ; \nif ( payload instanceof OConcurrentCreateException ) break ; \n} \nelse if ( ++ responsesForQuorum >= quorum ) { \nsetQuorumResponse ( r ) ; \nreturn true ; \n} \n} \n} \n} \n} \n} \nelse { \nif ( receivedResponses >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { \nif ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) ) { \nif ( ++ responsesForQuorum >= quorum ) { \nODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; \nif ( resp != null ) { \nif ( ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; \n} \nreturn true ; \n} \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3159": "public class OStringParser { \npublic static int indexOfOutsideStrings ( final String iText , final char iToFind , int iFrom , int iTo ) { \nif ( iTo == - 1 ) iTo = iText . length ( ) - 1 ; \nif ( iFrom == - 1 ) iFrom = iText . length ( ) - 1 ; \nchar c ; \nchar stringChar = ' ' ; \nboolean escape = false ; \nfinal StringBuilder buffer = new StringBuilder ( 1024 ) ; \nint i = iFrom ; \nwhile ( true ) { \nc = iText . charAt ( i ) ; \nif ( ! escape && c == '\\\\' && ( ( i + 1 ) < iText . length ( ) ) ) { \nif ( iText . charAt ( i + 1 ) == 'u' ) { \ni = readUnicode ( iText , i + 2 , buffer ) ; \n} \nelse escape = true ; \n} \nelse { \nif ( c == '\\'' ) { \nif ( stringChar == ' ' ) { \nstringChar = c ; \n} \nelse { \nif ( ! escape ) { \nif ( c == stringChar ) stringChar = ' ' ; \n} \n} \n} \nelse if ( c == '\"' ) { \nif ( stringChar == ' ' ) { \nstringChar = c ; \n} \nelse { \nif ( ! escape && c == stringChar ) stringChar = ' ' ; \n} \n} \nif ( c == iToFind ) { \nif ( stringChar == ' ' ) return i ; \n} \nif ( escape ) escape = false ; \n} \nif ( iFrom < iTo ) { \nif ( ++ i > iTo ) break ; \n} \nelse { \nif ( -- i < iFrom ) break ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3163": "public class OConflictResolverDatabaseRepairer { \n@ Override public void enqueueRepairRecord ( final ORecordId rid ) { \nif ( ! active ) return ; \nif ( rid == null ) return ; \nelse if ( ! rid . isPersistent ( ) ) return ; \nif ( rid . getClusterPosition ( ) < - 1 ) return ; \nrecordProcessed . incrementAndGet ( ) ; \nrecords . put ( rid , Boolean . TRUE ) ; \n} \n} \n"}
{"3166": "public class OMatchExecutionPlanner { \nprivate Map < String , Set < String > > getDependencies ( Pattern pattern ) { \nMap < String , Set < String > > result = new HashMap < String , Set < String > > ( ) ; \nfor ( PatternNode node : pattern . aliasToNode . values ( ) ) { \nSet < String > currentDependencies = new HashSet < String > ( ) ; \nOWhereClause filter = aliasFilters . get ( node . alias ) ; \nif ( filter != null ) { \nif ( filter . getBaseExpression ( ) != null ) { \nList < String > involvedAliases = filter . getBaseExpression ( ) . getMatchPatternInvolvedAliases ( ) ; \nif ( involvedAliases != null ) { \ncurrentDependencies . addAll ( involvedAliases ) ; \n} \n} \n} \nresult . put ( node . alias , currentDependencies ) ; \n} \nreturn result ; \n} \n} \n"}
{"3174": "public class OCommandExecutorSQLHASyncCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nfinal ODatabaseDocumentInternal database = getDatabase ( ) ; \ndatabase . checkSecurity ( ORule . ResourceGeneric . CLUSTER , \"sync\" , ORole . PERMISSION_UPDATE ) ; \nif ( ! ( database instanceof ODatabaseDocumentDistributed ) ) { \nthrow new OCommandExecutionException ( \"OrientDB is not started in distributed mode\" ) ; \n} \nfinal OHazelcastPlugin dManager = ( OHazelcastPlugin ) ( ( ODatabaseDocumentDistributed ) database ) . getDistributedManager ( ) ; \nif ( dManager == null ) throw new OCommandExecutionException ( \"OrientDB is not started in distributed mode\" ) ; \nelse if ( ! dManager . isEnabled ( ) ) throw new OCommandExecutionException ( \"OrientDB is not started in distributed mode\" ) ; \nfinal String databaseName = database . getName ( ) ; \ntry { \nif ( this . parsedStatement . modeFull ) { \nreturn replaceCluster ( dManager , database , dManager . getServerInstance ( ) , databaseName , this . parsedStatement . clusterName . getStringValue ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nthrow OException . wrapException ( new OCommandExecutionException ( \"Cannot execute synchronization of cluster\" ) , e ) ; \n} \nreturn \"Mode not supported\" ; \n} \n} \n"}
{"3176": "public class OMemory { \npublic static void checkCacheMemoryConfiguration ( ) { \nfinal long maxHeapSize = Runtime . getRuntime ( ) . maxMemory ( ) ; \nfinal long maxCacheSize = getMaxCacheMemorySize ( ) ; \nfinal ONative . MemoryLimitResult physicalMemory = ONative . instance ( ) . getMemoryLimit ( false ) ; \nif ( maxHeapSize != Long . MAX_VALUE && physicalMemory != null ) { \nif ( maxHeapSize + maxCacheSize > physicalMemory . memoryLimit ) OLogManager . instance ( ) . warnNoDb ( OMemory . class , \"The sum of the configured JVM maximum heap size (\" + maxHeapSize + \" bytes) \" + \"and the OrientDB maximum cache size (\" + maxCacheSize + \" bytes) is larger than the available physical memory size \" + \"(\" + physicalMemory + \" bytes). That may cause out of memory errors, please tune the configuration up. Use the \" + \"-Xmx JVM option to lower the JVM maximum heap memory size or storage.diskCache.bufferSize OrientDB option to \" + \"lower memory requirements of the cache.\" ) ; \n} \n} \n} \n"}
{"3192": "public class OBasicCommandContext { \npublic synchronized boolean addToUniqueResult ( Object o ) { \nObject toAdd = o ; \nif ( o instanceof ODocument ) { \nif ( ( ( ODocument ) o ) . getIdentity ( ) . isNew ( ) ) { \ntoAdd = new ODocumentEqualityWrapper ( ( ODocument ) o ) ; \n} \n} \nreturn this . uniqueResult . add ( toAdd ) ; \n} \n} \n"}
{"3193": "public class ORecordSerializerJSON { \nprivate Object getValueAsObjectOrMap ( ODocument iRecord , String iFieldValue , OType iType , OType iLinkedType , Map < String , Character > iFieldTypes , boolean iNoMap , String iOptions ) { \nfinal String [ ] fields = OStringParser . getWords ( iFieldValue . substring ( 1 , iFieldValue . length ( ) - 1 ) , \":,\" , true ) ; \nif ( fields == null ) if ( iNoMap ) { \nODocument res = new ODocument ( ) ; \nODocumentInternal . addOwner ( res , iRecord ) ; \nreturn res ; \n} \nelse return new HashMap < String , Object > ( ) ; \nelse if ( fields . length == 0 ) if ( iNoMap ) { \nODocument res = new ODocument ( ) ; \nODocumentInternal . addOwner ( res , iRecord ) ; \nreturn res ; \n} \nelse return new HashMap < String , Object > ( ) ; \nif ( iNoMap || hasTypeField ( fields ) ) { \nreturn getValueAsRecord ( iRecord , iFieldValue , iType , iOptions , fields ) ; \n} \nelse { \nreturn getValueAsMap ( iRecord , iFieldValue , iLinkedType , iFieldTypes , false , iOptions , fields ) ; \n} \n} \n} \n"}
{"3195": "public class ODocumentHelper { \n@ SuppressWarnings ( \"unchecked\" ) public static Object getMapEntry ( final Map < String , ? > iMap , final Object iKey ) { \nif ( iMap == null ) return null ; \nelse if ( iKey == null ) return null ; \nif ( iKey instanceof String ) { \nString iName = ( String ) iKey ; \nint pos = iName . indexOf ( '.' ) ; \nif ( pos > - 1 ) iName = iName . substring ( 0 , pos ) ; \nfinal Object value = iMap . get ( iName ) ; \nif ( value == null ) return null ; \nif ( pos > - 1 ) { \nfinal String restFieldName = iName . substring ( pos + 1 ) ; \nif ( value instanceof ODocument ) return getFieldValue ( value , restFieldName ) ; \nelse if ( value instanceof Map < ? , ? > ) return getMapEntry ( ( Map < String , ? > ) value , restFieldName ) ; \n} \nreturn value ; \n} \nelse return iMap . get ( iKey ) ; \n} \n} \n"}
{"3197": "public class OIdentifiableIterator { \nprotected ORecord readCurrentRecord ( ORecord iRecord , final int iMovement ) { \nif ( limit > - 1 ) { \nif ( browsedRecords >= limit ) return null ; \n} \ndo { \nfinal boolean moveResult ; \nswitch ( iMovement ) { \ncase 1 : moveResult = nextPosition ( ) ; \nbreak ; \ncase - 1 : moveResult = prevPosition ( ) ; \nbreak ; \ncase 0 : moveResult = checkCurrentPosition ( ) ; \nbreak ; \ndefault : throw new IllegalStateException ( \"Invalid movement value : \" + iMovement ) ; \n} \nif ( ! moveResult ) return null ; \ntry { \nif ( iRecord != null ) { \nORecordInternal . setIdentity ( iRecord , new ORecordId ( current . getClusterId ( ) , current . getClusterPosition ( ) ) ) ; \niRecord = database . load ( iRecord , fetchPlan , false ) ; \n} \nelse iRecord = database . load ( current , fetchPlan , false ) ; \n} \ncatch ( ODatabaseException e ) { \nif ( Thread . interrupted ( ) ) throw e ; \nelse if ( database . isClosed ( ) ) throw e ; \nif ( e . getCause ( ) instanceof OSecurityException ) throw e ; \nbrokenRIDs . add ( current . copy ( ) ) ; \nOLogManager . instance ( ) . error ( this , \"Error on fetching record during browsing. The record has been skipped\" , e ) ; \n} \nif ( iRecord != null ) { \nbrowsedRecords ++ ; \nreturn iRecord ; \n} \n} \nwhile ( iMovement != 0 ) ; \nreturn null ; \n} \n} \n"}
{"3202": "public class OrientTransactionalGraph { \n@ SuppressWarnings ( \"deprecation\" ) @ Override public void stopTransaction ( final Conclusion conclusion ) { \nmakeActive ( ) ; \nif ( getDatabase ( ) . isClosed ( ) || getDatabase ( ) . getTransaction ( ) instanceof OTransactionNoTx ) return ; \nelse if ( getDatabase ( ) . getTransaction ( ) . getStatus ( ) != TXSTATUS . BEGUN ) return ; \nif ( Conclusion . SUCCESS == conclusion ) commit ( ) ; \nelse rollback ( ) ; \n} \n} \n"}
{"3208": "public class OrientVertex { \n@ Override public void remove ( ) { \ncheckClass ( ) ; \nfinal OrientBaseGraph graph = checkIfAttached ( ) ; \ngraph . setCurrentGraphInThreadLocal ( ) ; \ngraph . autoStartTransaction ( ) ; \nfinal ODocument doc = getRecord ( ) ; \nif ( doc == null ) throw ExceptionFactory . vertexWithIdDoesNotExist ( this . getId ( ) ) ; \nMap < String , List < ODocument > > treeRidbagEdgesToRemove = new HashMap < String , List < ODocument > > ( ) ; \nif ( ! graph . getRawGraph ( ) . getTransaction ( ) . isActive ( ) ) { \nfor ( String fieldName : doc . fieldNames ( ) ) { \nfinal OPair < Direction , String > connection = getConnection ( Direction . BOTH , fieldName ) ; \nif ( connection == null ) continue ; \nObject fv = doc . field ( fieldName ) ; \nif ( fv instanceof ORidBag ) { \nif ( ! ( ( ORidBag ) fv ) . isEmbedded ( ) ) { \nList < ODocument > docs = new ArrayList < ODocument > ( ) ; \nfor ( OIdentifiable id : ( ORidBag ) fv ) docs . add ( OrientBaseGraph . getDocument ( id , true ) ) ; \ntreeRidbagEdgesToRemove . put ( fieldName , docs ) ; \n} \n} \n} \n} \nsuper . removeRecord ( ) ; \nfinal Iterator < Index < ? extends Element > > it = graph . getIndices ( ) . iterator ( ) ; \nif ( it . hasNext ( ) ) { \nfinal Set < Edge > allEdges = new HashSet < Edge > ( ) ; \nfor ( Edge e : getEdges ( Direction . BOTH ) ) allEdges . add ( e ) ; \nwhile ( it . hasNext ( ) ) { \nfinal Index < ? extends Element > index = it . next ( ) ; \nif ( Vertex . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { \nOrientIndex < OrientVertex > idx = ( OrientIndex < OrientVertex > ) index ; \nidx . removeElement ( this ) ; \n} \nif ( Edge . class . isAssignableFrom ( index . getIndexClass ( ) ) ) { \nOrientIndex < OrientEdge > idx = ( OrientIndex < OrientEdge > ) index ; \nfor ( Edge e : allEdges ) idx . removeElement ( ( OrientEdge ) e ) ; \n} \n} \n} \nfor ( Map . Entry < String , List < ODocument > > entry : treeRidbagEdgesToRemove . entrySet ( ) ) { \ndoc . removeField ( entry . getKey ( ) ) ; \nIterator < ODocument > iter = entry . getValue ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nODocument docEdge = iter . next ( ) ; \nOrientBaseGraph . deleteEdgeIfAny ( docEdge , false ) ; \n} \n} \ngraph . removeEdgesInternal ( this , doc , null , true , settings . isUseVertexFieldsForEdgeLabels ( ) , settings . isAutoScaleEdgeType ( ) ) ; \n} \n} \n"}
{"3212": "public class OrientVertex { \nprotected OPair < Direction , String > getConnection ( final Direction iDirection , final String iFieldName , String ... iClassNames ) { \nif ( iClassNames != null && iClassNames . length == 1 ) { \nif ( iClassNames [ 0 ] . equalsIgnoreCase ( \"E\" ) ) iClassNames = null ; \n} \nfinal OrientBaseGraph graph = getGraph ( ) ; \nif ( iDirection == Direction . OUT ) { \nif ( settings . isUseVertexFieldsForEdgeLabels ( ) ) { \nif ( iFieldName . startsWith ( CONNECTION_OUT_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . OUT , iFieldName ) ; \nif ( iClassNames == null ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; \nelse if ( iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) { \nfor ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; \n} \n} \n} \n} \nelse if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_OUT ) ) return new OPair < Direction , String > ( Direction . OUT , null ) ; \n} \nelse if ( iDirection == Direction . BOTH ) { \nif ( settings . isUseVertexFieldsForEdgeLabels ( ) ) { \nif ( iFieldName . startsWith ( CONNECTION_OUT_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . OUT , iFieldName ) ; \nif ( iClassNames == null || iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) { \nfor ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; \n} \n} \n} \n} \nelse if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_OUT ) ) return new OPair < Direction , String > ( Direction . OUT , null ) ; \n} \nif ( iDirection == Direction . IN ) { \nif ( settings . isUseVertexFieldsForEdgeLabels ( ) ) { \nif ( iFieldName . startsWith ( CONNECTION_IN_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . IN , iFieldName ) ; \nif ( iClassNames == null ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; \nelse if ( iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) { \nfor ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; \n} \n} \n} \n} \nelse if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_IN ) ) return new OPair < Direction , String > ( Direction . IN , null ) ; \n} \nelse if ( iDirection == Direction . BOTH ) { \nif ( settings . isUseVertexFieldsForEdgeLabels ( ) ) { \nif ( iFieldName . startsWith ( CONNECTION_IN_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . IN , iFieldName ) ; \nif ( iClassNames == null || iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) { \nfor ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; \n} \n} \n} \n} \nelse if ( iFieldName . equals ( OrientBaseGraph . CONNECTION_IN ) ) return new OPair < Direction , String > ( Direction . IN , null ) ; \n} \nreturn null ; \n} \n} \n"}
{"3214": "public class OConsoleApplication { \nprotected Map < Method , Object > getConsoleMethods ( ) { \nif ( methods != null ) return methods ; \nfinal Iterator < OConsoleCommandCollection > ite = ServiceLoader . load ( OConsoleCommandCollection . class ) . iterator ( ) ; \nfinal Collection < Object > candidates = new ArrayList < Object > ( ) ; \ncandidates . add ( this ) ; \nwhile ( ite . hasNext ( ) ) { \ntry { \nfinal OConsoleCommandCollection cc = ite . next ( ) . getClass ( ) . newInstance ( ) ; \ncc . setContext ( this ) ; \ncandidates . add ( cc ) ; \n} \ncatch ( InstantiationException ex ) { \nLogger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; \n} \ncatch ( IllegalAccessException ex ) { \nLogger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; \n} \n} \nmethods = new TreeMap < Method , Object > ( new Comparator < Method > ( ) { \npublic int compare ( Method o1 , Method o2 ) { \nfinal ConsoleCommand ann1 = o1 . getAnnotation ( ConsoleCommand . class ) ; \nfinal ConsoleCommand ann2 = o2 . getAnnotation ( ConsoleCommand . class ) ; \nif ( ann1 != null ) { \nif ( ann2 != null ) { \nif ( ann1 . priority ( ) != ann2 . priority ( ) ) return ann1 . priority ( ) - ann2 . priority ( ) ; \n} \n} \nint res = o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; \nif ( res == 0 ) res = o1 . toString ( ) . compareTo ( o2 . toString ( ) ) ; \nreturn res ; \n} \n} \n) ; \nfor ( final Object candidate : candidates ) { \nfinal Method [ ] classMethods = candidate . getClass ( ) . getMethods ( ) ; \nfor ( Method m : classMethods ) { \nif ( Modifier . isAbstract ( m . getModifiers ( ) ) || Modifier . isStatic ( m . getModifiers ( ) ) ) { \ncontinue ; \n} \nelse if ( ! Modifier . isPublic ( m . getModifiers ( ) ) ) { \ncontinue ; \n} \nif ( m . getReturnType ( ) != Void . TYPE ) { \ncontinue ; \n} \nmethods . put ( m , candidate ) ; \n} \n} \nreturn methods ; \n} \n} \n"}
{"3215": "public class ODistributedAbstractPlugin { \n@ Override public Object executeOnLocalNode ( final ODistributedRequestId reqId , final ORemoteTask task , final ODatabaseDocumentInternal database ) { \nif ( database != null ) { \nif ( ! ( database . getStorage ( ) instanceof ODistributedStorage ) ) throw new ODistributedException ( \"Distributed storage was not installed for database '\" + database . getName ( ) + \"'. Implementation found: \" + database . getStorage ( ) . getClass ( ) . getName ( ) ) ; \n} \nfinal ODistributedAbstractPlugin manager = this ; \nreturn OScenarioThreadLocal . executeAsDistributed ( new Callable < Object > ( ) { \n@ Override public Object call ( ) throws Exception { \ntry { \nfinal Object result = task . execute ( reqId , serverInstance , manager , database ) ; \nif ( result instanceof Throwable && ! ( result instanceof OException ) ) ODistributedServerLog . debug ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Error on executing request %d (%s) on local node: \" , ( Throwable ) result , reqId , task ) ; \nelse { \nfinal String sourceNodeName = task . getNodeSource ( ) ; \nif ( database != null ) { \nfinal ODistributedDatabaseImpl ddb = getMessageService ( ) . getDatabase ( database . getName ( ) ) ; \nif ( ddb != null && ! ( result instanceof Throwable ) && task instanceof OAbstractReplicatedTask ) { \nif ( ! task . isIdempotent ( ) ) { \nddb . setLSN ( sourceNodeName , ( ( OAbstractReplicatedTask ) task ) . getLastLSN ( ) , true ) ; \nddb . setLSN ( getLocalNodeName ( ) , ( ( OAbstractPaginatedStorage ) database . getStorage ( ) . getUnderlying ( ) ) . getLSN ( ) , true ) ; \n} \n} \n} \n} \nreturn result ; \n} \ncatch ( InterruptedException e ) { \nODistributedServerLog . debug ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Interrupted execution on executing distributed request %s on local node: %s\" , e , reqId , task ) ; \nreturn e ; \n} \ncatch ( Exception e ) { \nif ( ! ( e instanceof OException ) ) ODistributedServerLog . error ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Error on executing distributed request %s on local node: %s\" , e , reqId , task ) ; \nreturn e ; \n} \n} \n} \n) ; \n} \n} \n"}
{"3220": "public class OHttpRequestWrapper { \npublic int hasParameters ( final String ... iNames ) { \nint found = 0 ; \nif ( iNames != null ) { \nif ( request . parameters != null ) for ( String name : iNames ) found += request . parameters . containsKey ( name ) ? 1 : 0 ; \n} \nreturn found ; \n} \n} \n"}
{"3229": "public class OCommandExecutorSQLCreateIndex { \n@ SuppressWarnings ( \"rawtypes\" ) public Object execute ( final Map < Object , Object > iArgs ) { \nif ( indexName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal OIndex < ? > idx ; \nList < OCollate > collatesList = null ; \nif ( collates != null ) { \ncollatesList = new ArrayList < OCollate > ( ) ; \nfor ( String collate : collates ) { \nif ( collate != null ) { \nfinal OCollate col = OSQLEngine . getCollate ( collate ) ; \ncollatesList . add ( col ) ; \n} \nelse collatesList . add ( null ) ; \n} \n} \nif ( fields == null || fields . length == 0 ) { \nOIndexFactory factory = OIndexes . getFactory ( indexType . toString ( ) , null ) ; \nif ( keyTypes != null ) idx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new OSimpleKeyIndexDefinition ( keyTypes , collatesList ) , null , null , metadataDoc , engine ) ; \nelse if ( serializerKeyId != 0 ) { \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new ORuntimeKeyIndexDefinition ( serializerKeyId ) , null , null , metadataDoc , engine ) ; \n} \nelse { \nthrow new ODatabaseException ( \"Impossible to create an index without specify the key type or the associated property\" ) ; \n} \n} \nelse { \nif ( ( keyTypes == null || keyTypes . length == 0 ) && collates == null ) { \nidx = oClass . createIndex ( indexName , indexType . toString ( ) , null , metadataDoc , engine , fields ) ; \n} \nelse { \nfinal List < OType > fieldTypeList ; \nif ( keyTypes == null ) { \nfor ( final String fieldName : fields ) { \nif ( ! fieldName . equals ( \"@rid\" ) ) { \nif ( ! oClass . existsProperty ( fieldName ) ) throw new OIndexException ( \"Index with name : '\" + indexName + \"' cannot be created on class : '\" + oClass . getName ( ) + \"' because field: '\" + fieldName + \"' is absent in class definition.\" ) ; \n} \n} \nfieldTypeList = ( ( OClassImpl ) oClass ) . extractFieldTypes ( fields ) ; \n} \nelse fieldTypeList = Arrays . asList ( keyTypes ) ; \nfinal OIndexDefinition idxDef = OIndexDefinitionFactory . createIndexDefinition ( oClass , Arrays . asList ( fields ) , fieldTypeList , collatesList , indexType . toString ( ) , null ) ; \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . name ( ) , idxDef , oClass . getPolymorphicClusterIds ( ) , null , metadataDoc , engine ) ; \n} \n} \nif ( idx != null ) return idx . getSize ( ) ; \nreturn null ; \n} \n} \n"}
{"3230": "public class OGraphCommandExecutorSQLFactory { \npublic static OrientGraph getGraph ( final boolean autoStartTx , OModifiableBoolean shouldBeShutDown ) { \nfinal ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal . instance ( ) . get ( ) ; \nfinal OrientBaseGraph result = OrientBaseGraph . getActiveGraph ( ) ; \nif ( result != null ) { \nif ( result instanceof OrientGraph ) { \nfinal ODatabaseDocumentInternal graphDb = result . getRawGraph ( ) ; \nif ( canReuseActiveGraph ( graphDb , database ) ) { \nif ( ! graphDb . isClosed ( ) ) { \nODatabaseRecordThreadLocal . instance ( ) . set ( graphDb ) ; \nif ( autoStartTx ) { \nif ( autoTxStartRequired ( graphDb ) ) ( ( OrientGraph ) result ) . begin ( ) ; \n} \nshouldBeShutDown . setValue ( false ) ; \nreturn ( OrientGraph ) result ; \n} \n} \n} \n} \nODatabaseRecordThreadLocal . instance ( ) . set ( database ) ; \nshouldBeShutDown . setValue ( true ) ; \nfinal OrientGraph g = ( OrientGraph ) OrientGraphFactory . getTxGraphImplFactory ( ) . getGraph ( database , false ) ; \nif ( autoStartTx ) { \nif ( autoTxStartRequired ( database ) ) g . begin ( ) ; \n} \nreturn g ; \n} \n} \n"}
{"3235": "public class OSystemUserAuthenticator { \npublic String authenticate ( final String username , final String password ) { \nString principal = null ; \ntry { \nif ( getServer ( ) != null ) { \nOUser user = getServer ( ) . getSecurity ( ) . getSystemUser ( username , null ) ; \nif ( user != null ) { \nif ( user . getAccountStatus ( ) == OSecurityUser . STATUSES . ACTIVE ) { \nif ( user . checkPassword ( password ) ) principal = username ; \n} \n} \n} \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"authenticate()\" , ex ) ; \n} \nreturn principal ; \n} \n} \n"}
{"3236": "public class OSystemUserAuthenticator { \npublic boolean isAuthorized ( final String username , final String resource ) { \nif ( username == null ) return false ; \nelse if ( resource == null ) return false ; \ntry { \nif ( getServer ( ) != null ) { \nOUser user = getServer ( ) . getSecurity ( ) . getSystemUser ( username , null ) ; \nif ( user != null ) { \nif ( user . getAccountStatus ( ) == OSecurityUser . STATUSES . ACTIVE ) { \nORole role = null ; \nORule . ResourceGeneric rg = ORule . mapLegacyResourceToGenericResource ( resource ) ; \nif ( rg != null ) { \nString specificResource = ORule . mapLegacyResourceToSpecificResource ( resource ) ; \nif ( specificResource == null ) { \nspecificResource = null ; \n} \nelse if ( specificResource . equals ( \"*\" ) ) { \nspecificResource = null ; \n} \nrole = user . checkIfAllowed ( rg , specificResource , ORole . PERMISSION_EXECUTE ) ; \n} \nreturn role != null ; \n} \n} \n} \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"isAuthorized()\" , ex ) ; \n} \nreturn false ; \n} \n} \n"}
{"3245": "public class OServerNetworkListener { \nprivate void readParameters ( final OContextConfiguration iServerConfig , final OServerParameterConfiguration [ ] iParameters ) { \nconfiguration = new OContextConfiguration ( iServerConfig ) ; \nif ( iParameters != null ) { \nif ( iParameters . length > 0 ) { \nfor ( OServerParameterConfiguration param : iParameters ) configuration . setValue ( param . name , param . value ) ; \n} \n} \nsocketBufferSize = configuration . getValueAsInteger ( OGlobalConfiguration . NETWORK_SOCKET_BUFFER_SIZE ) ; \n} \n} \n"}
{"3267": "public class OSecurityShared { \npublic OUser authenticate ( final OToken authToken ) { \nfinal String dbName = getDatabase ( ) . getName ( ) ; \nif ( authToken . getIsValid ( ) != true ) { \nthrow new OSecurityAccessException ( dbName , \"Token not valid\" ) ; \n} \nOUser user = authToken . getUser ( getDatabase ( ) ) ; \nif ( user == null ) { \nif ( authToken . getUserName ( ) != null ) { \nuser = getUser ( authToken . getUserName ( ) ) ; \n} \n} \nif ( user == null ) { \nthrow new OSecurityAccessException ( dbName , \"Authentication failed, could not load user from token\" ) ; \n} \nif ( user . getAccountStatus ( ) != STATUSES . ACTIVE ) throw new OSecurityAccessException ( dbName , \"User '\" + user . getName ( ) + \"' is not active\" ) ; \nreturn user ; \n} \n} \n"}
{"3269": "public class OReadersWriterSpinLock { \npublic boolean tryAcquireReadLock ( long timeout ) { \nfinal OModifiableInteger lHolds = lockHolds . get ( ) ; \nfinal int holds = lHolds . intValue ( ) ; \nif ( holds > 0 ) { \nlHolds . increment ( ) ; \nreturn true ; \n} \nelse if ( holds < 0 ) { \nreturn true ; \n} \ndistributedCounter . increment ( ) ; \nWNode wNode = tail . get ( ) ; \nfinal long start = System . nanoTime ( ) ; \nwhile ( wNode . locked ) { \ndistributedCounter . decrement ( ) ; \nwhile ( wNode . locked && wNode == tail . get ( ) ) { \nwNode . waitingReaders . put ( Thread . currentThread ( ) , Boolean . TRUE ) ; \nif ( wNode . locked ) { \nif ( wNode == tail . get ( ) ) { \nfinal long parkTimeout = timeout - ( System . nanoTime ( ) - start ) ; \nif ( parkTimeout > 0 ) { \nLockSupport . parkNanos ( this , parkTimeout ) ; \n} \nelse { \nreturn false ; \n} \n} \n} \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \nreturn false ; \n} \n} \ndistributedCounter . increment ( ) ; \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \ndistributedCounter . decrement ( ) ; \nreturn false ; \n} \n} \nlHolds . increment ( ) ; \nassert lHolds . intValue ( ) == 1 ; \nreturn true ; \n} \n} \n"}
{"3280": "public class OCommandExecutorSQLInsert { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( newRecords == null && content == null ) { \nif ( subQuery == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal OCommandParameters commandParameters = new OCommandParameters ( iArgs ) ; \nif ( indexName != null ) { \nif ( newRecords == null ) throw new OCommandExecutionException ( \"No key/value found\" ) ; \nfinal OIndex < ? > index = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) . getIndex ( indexName ) ; \nif ( index == null ) throw new OCommandExecutionException ( \"Target index '\" + indexName + \"' not found\" ) ; \nMap < String , Object > result = new HashMap < String , Object > ( ) ; \nfor ( Map < String , Object > candidate : newRecords ) { \nObject indexKey = getIndexKeyValue ( commandParameters , candidate ) ; \nOIdentifiable indexValue = getIndexValue ( commandParameters , candidate ) ; \nif ( index instanceof OIndexMultiValues ) { \nfinal Collection < ORID > rids = ( ( OIndexMultiValues ) index ) . get ( indexKey ) ; \nif ( ! rids . contains ( indexValue . getIdentity ( ) ) ) { \nindex . put ( indexKey , indexValue ) ; \n} \n} \nelse { \nindex . put ( indexKey , indexValue ) ; \n} \nresult . put ( KEYWORD_KEY , indexKey ) ; \nresult . put ( KEYWORD_RID , indexValue ) ; \n} \nreturn prepareReturnItem ( new ODocument ( result ) ) ; \n} \nelse { \nfinal List < ODocument > docs = new ArrayList < ODocument > ( ) ; \nif ( newRecords != null ) { \nfor ( Map < String , Object > candidate : newRecords ) { \nfinal ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; \nOSQLHelper . bindParameters ( doc , candidate , commandParameters , context ) ; \nsaveRecord ( doc ) ; \ndocs . add ( doc ) ; \n} \nif ( docs . size ( ) == 1 ) return prepareReturnItem ( docs . get ( 0 ) ) ; \nelse return prepareReturnResult ( docs ) ; \n} \nelse if ( content != null ) { \nfinal ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; \ndoc . merge ( content , true , false ) ; \nsaveRecord ( doc ) ; \nreturn prepareReturnItem ( doc ) ; \n} \nelse if ( subQuery != null ) { \nsubQuery . execute ( ) ; \nif ( queryResult != null ) return prepareReturnResult ( queryResult ) ; \nreturn saved . longValue ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3281": "public class ODatabaseRepair { \nprotected boolean fixLink ( final Object fieldValue ) { \nif ( fieldValue instanceof OIdentifiable ) { \nfinal ORID id = ( ( OIdentifiable ) fieldValue ) . getIdentity ( ) ; \nif ( id . getClusterId ( ) == 0 ) { \nif ( id . getClusterPosition ( ) == 0 ) return true ; \n} \nif ( id . isValid ( ) ) if ( id . isPersistent ( ) ) { \nfinal ORecord connected = ( ( OIdentifiable ) fieldValue ) . getRecord ( ) ; \nif ( connected == null ) return true ; \n} \nelse return true ; \n} \nreturn false ; \n} \n} \n"}
{"3288": "public class ORecordLazyMap { \nprivate void convertLink2Record ( final Object iKey ) { \nif ( status == MULTIVALUE_CONTENT_TYPE . ALL_RECORDS ) return ; \nfinal Object value ; \nif ( iKey instanceof ORID ) value = iKey ; \nelse value = super . get ( iKey ) ; \nif ( value != null ) { \nif ( value instanceof ORID ) { \nfinal ORID rid = ( ORID ) value ; \nmarshalling = true ; \ntry { \ntry { \nORecord record = rid . getRecord ( ) ; \nif ( record != null ) { \nORecordInternal . unTrack ( sourceRecord , rid ) ; \nORecordInternal . track ( sourceRecord , record ) ; \n} \nsuper . put ( iKey , record ) ; \n} \ncatch ( ORecordNotFoundException ignore ) { \n} \n} \nfinally { \nmarshalling = false ; \n} \n} \n} \n} \n} \n"}
{"3290": "public class ODefaultPasswordAuthenticator { \nprotected OServerUserConfiguration createServerUser ( final ODocument userDoc ) { \nOServerUserConfiguration userCfg = null ; \nif ( userDoc . containsField ( \"username\" ) ) { \nif ( userDoc . containsField ( \"resources\" ) ) { \nfinal String user = userDoc . field ( \"username\" ) ; \nfinal String resources = userDoc . field ( \"resources\" ) ; \nString password = userDoc . field ( \"password\" ) ; \nif ( password == null ) password = \"\" ; \nuserCfg = new OServerUserConfiguration ( user , password , resources ) ; \n} \n} \nreturn userCfg ; \n} \n} \n"}
{"3291": "public class OFilterAnalyzer { \npublic List < OIndexSearchResult > analyzeCondition ( OSQLFilterCondition condition , final OClass schemaClass , OCommandContext context ) { \nfinal List < OIndexSearchResult > indexSearchResults = new ArrayList < OIndexSearchResult > ( ) ; \nOIndexSearchResult lastCondition = analyzeFilterBranch ( schemaClass , condition , indexSearchResults , context ) ; \nif ( indexSearchResults . isEmpty ( ) ) { \nif ( lastCondition != null ) { \nindexSearchResults . add ( lastCondition ) ; \n} \n} \nCollections . sort ( indexSearchResults , new Comparator < OIndexSearchResult > ( ) { \npublic int compare ( final OIndexSearchResult searchResultOne , final OIndexSearchResult searchResultTwo ) { \nreturn searchResultTwo . getFieldCount ( ) - searchResultOne . getFieldCount ( ) ; \n} \n} \n) ; \nreturn indexSearchResults ; \n} \n} \n"}
{"3292": "public class OFilterAnalyzer { \nprivate OIndexSearchResult createIndexedProperty ( final OSQLFilterCondition iCondition , final Object iItem , OCommandContext ctx ) { \nif ( iItem == null ) { \nreturn null ; \n} \nelse if ( ! ( iItem instanceof OSQLFilterItemField ) ) { \nreturn null ; \n} \nif ( iCondition . getLeft ( ) instanceof OSQLFilterItemField ) { \nif ( iCondition . getRight ( ) instanceof OSQLFilterItemField ) { \nreturn null ; \n} \n} \nfinal OSQLFilterItemField item = ( OSQLFilterItemField ) iItem ; \nif ( item . hasChainOperators ( ) ) { \nif ( ! item . isFieldChain ( ) ) { \nreturn null ; \n} \n} \nboolean inverted = iCondition . getRight ( ) == iItem ; \nfinal Object origValue = inverted ? iCondition . getLeft ( ) : iCondition . getRight ( ) ; \nOQueryOperator operator = iCondition . getOperator ( ) ; \nif ( inverted ) { \nif ( operator instanceof OQueryOperatorIn ) { \noperator = new OQueryOperatorContains ( ) ; \n} \nelse if ( operator instanceof OQueryOperatorContains ) { \noperator = new OQueryOperatorIn ( ) ; \n} \nelse if ( operator instanceof OQueryOperatorMajor ) { \noperator = new OQueryOperatorMinor ( ) ; \n} \nelse if ( operator instanceof OQueryOperatorMinor ) { \noperator = new OQueryOperatorMajor ( ) ; \n} \nelse if ( operator instanceof OQueryOperatorMajorEquals ) { \noperator = new OQueryOperatorMinorEquals ( ) ; \n} \nelse if ( operator instanceof OQueryOperatorMinorEquals ) { \noperator = new OQueryOperatorMajorEquals ( ) ; \n} \n} \nif ( iCondition . getOperator ( ) instanceof OQueryOperatorBetween ) { \nreturn new OIndexSearchResult ( operator , item . getFieldChain ( ) , origValue ) ; \n} \nelse if ( operator instanceof OQueryOperatorIn ) { \nreturn new OIndexSearchResult ( operator , item . getFieldChain ( ) , origValue ) ; \n} \nfinal Object value = OSQLHelper . getValue ( origValue , null , ctx ) ; \nreturn new OIndexSearchResult ( operator , item . getFieldChain ( ) , value ) ; \n} \n} \n"}
{"3293": "public class OObjectProxyMethodHandler { \npublic void attach ( final Object self ) throws IllegalArgumentException , IllegalAccessException , NoSuchMethodException , InvocationTargetException { \nfor ( Class < ? > currentClass = self . getClass ( ) ; \ncurrentClass != Object . class ; \n) { \nif ( Proxy . class . isAssignableFrom ( currentClass ) ) { \ncurrentClass = currentClass . getSuperclass ( ) ; \ncontinue ; \n} \nfor ( Field f : currentClass . getDeclaredFields ( ) ) { \nfinal String fieldName = f . getName ( ) ; \nfinal Class < ? > declaringClass = f . getDeclaringClass ( ) ; \nif ( OObjectEntitySerializer . isTransientField ( declaringClass , fieldName ) || OObjectEntitySerializer . isVersionField ( declaringClass , fieldName ) ) continue ; \nelse if ( OObjectEntitySerializer . isIdField ( declaringClass , fieldName ) ) continue ; \nObject value = OObjectEntitySerializer . getFieldValue ( f , self ) ; \nvalue = setValue ( self , fieldName , value ) ; \nOObjectEntitySerializer . setFieldValue ( f , self , value ) ; \n} \ncurrentClass = currentClass . getSuperclass ( ) ; \nif ( currentClass == null ) currentClass = Object . class ; \nelse if ( currentClass . equals ( ODocument . class ) ) currentClass = Object . class ; \n} \n} \n} \n"}
{"3304": "public class ODistributedAbstractPlugin { \n@ Override public void onOpen ( final ODatabaseInternal iDatabase ) { \nif ( ! isRelatedToLocalServer ( iDatabase ) ) return ; \nif ( isOffline ( ) ) { \nif ( status != NODE_STATUS . STARTING ) return ; \n} \nfinal ODatabaseDocumentInternal currDb = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; \ntry { \nfinal String dbName = iDatabase . getName ( ) ; \nfinal ODistributedConfiguration cfg = getDatabaseConfiguration ( dbName ) ; \nif ( cfg == null ) return ; \n} \ncatch ( HazelcastException e ) { \nthrow OException . wrapException ( new OOfflineNodeException ( \"Hazelcast instance is not available\" ) , e ) ; \n} \ncatch ( HazelcastInstanceNotActiveException e ) { \nthrow OException . wrapException ( new OOfflineNodeException ( \"Hazelcast instance is not available\" ) , e ) ; \n} \nfinally { \nODatabaseRecordThreadLocal . instance ( ) . set ( currDb ) ; \n} \n} \n} \n"}
{"3310": "public class OCommandExecutorSQLSelect { \n@ Override protected boolean handleResult ( final OIdentifiable iRecord , final OCommandContext iContext ) { \nlastRecord = iRecord ; \nif ( ( orderedFields . isEmpty ( ) || fullySortedByIndex || isRidOnlySort ( ) ) && skip > 0 && this . unwindFields == null ) { \nif ( this . expandTarget == null ) { \nlastRecord = null ; \nskip -- ; \nreturn true ; \n} \n} \nif ( ! addResult ( lastRecord , iContext ) ) { \nreturn false ; \n} \nreturn continueSearching ( ) ; \n} \n} \n"}
{"3324": "public class OCommandExecutorSQLCreateClass { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( className == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nboolean alreadyExists = database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ; \nif ( ! alreadyExists ) { \nif ( clusters != null ) database . getMetadata ( ) . getSchema ( ) . createClass ( className , clusters , superClasses . toArray ( new OClass [ 0 ] ) ) ; \nelse database . getMetadata ( ) . getSchema ( ) . createClass ( className , clusterIds , superClasses . toArray ( new OClass [ 0 ] ) ) ; \n} \nelse if ( ! ifNotExists ) { \nif ( clusters != null ) database . getMetadata ( ) . getSchema ( ) . createClass ( className , clusters , superClasses . toArray ( new OClass [ 0 ] ) ) ; \nelse database . getMetadata ( ) . getSchema ( ) . createClass ( className , clusterIds , superClasses . toArray ( new OClass [ 0 ] ) ) ; \n} \nreturn database . getMetadata ( ) . getSchema ( ) . getClasses ( ) . size ( ) ; \n} \n} \n"}
{"3325": "public class OCommandExecutorSQLHASyncDatabase { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nfinal ODatabaseDocumentInternal database = getDatabase ( ) ; \ndatabase . checkSecurity ( ORule . ResourceGeneric . DATABASE , \"sync\" , ORole . PERMISSION_UPDATE ) ; \nfinal OStorage stg = database . getStorage ( ) ; \nif ( ! ( stg instanceof ODistributedStorage ) ) throw new ODistributedException ( \"SYNC DATABASE command cannot be executed against a non distributed server\" ) ; \nfinal ODistributedStorage dStg = ( ODistributedStorage ) stg ; \nfinal OHazelcastPlugin dManager = ( OHazelcastPlugin ) dStg . getDistributedManager ( ) ; \nif ( dManager == null ) throw new OCommandExecutionException ( \"OrientDB is not started in distributed mode\" ) ; \nelse if ( ! dManager . isEnabled ( ) ) throw new OCommandExecutionException ( \"OrientDB is not started in distributed mode\" ) ; \nfinal String databaseName = database . getName ( ) ; \nreturn dManager . installDatabase ( true , databaseName , parsedStatement . isForce ( ) , ! parsedStatement . isFull ( ) ) ; \n} \n} \n"}
{"3327": "public class ODatabaseDocumentAbstract { \npublic ORecordHook . RESULT callbackHooks ( final ORecordHook . TYPE type , final OIdentifiable id ) { \nif ( id == null || hooks . isEmpty ( ) ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \nelse if ( id . getIdentity ( ) . getClusterId ( ) == 0 ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \nfinal ORecordHook . SCOPE scope = ORecordHook . SCOPE . typeToScope ( type ) ; \nfinal int scopeOrdinal = scope . ordinal ( ) ; \nfinal ORID identity = id . getIdentity ( ) . copy ( ) ; \nif ( ! pushInHook ( identity ) ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \ntry { \nfinal ORecord rec = id . getRecord ( ) ; \nif ( rec == null ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \nfinal OScenarioThreadLocal . RUN_MODE runMode = OScenarioThreadLocal . INSTANCE . getRunMode ( ) ; \nboolean recordChanged = false ; \nfor ( ORecordHook hook : hooksByScope [ scopeOrdinal ] ) { \nswitch ( runMode ) { \ncase DEFAULT : if ( getStorage ( ) . isDistributed ( ) ) { \nif ( hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . TARGET_NODE ) continue ; \n} \nbreak ; \ncase RUNNING_DISTRIBUTED : if ( hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . SOURCE_NODE ) continue ; \n} \nfinal ORecordHook . RESULT res = hook . onTrigger ( type , rec ) ; \nif ( res == ORecordHook . RESULT . RECORD_CHANGED ) recordChanged = true ; \nelse if ( res == ORecordHook . RESULT . SKIP_IO ) return res ; \nelse if ( res == ORecordHook . RESULT . SKIP ) return res ; \nelse if ( res == ORecordHook . RESULT . RECORD_REPLACED ) return res ; \n} \nreturn recordChanged ? ORecordHook . RESULT . RECORD_CHANGED : ORecordHook . RESULT . RECORD_NOT_CHANGED ; \n} \nfinally { \npopInHook ( identity ) ; \n} \n} \n} \n"}
{"3335": "public class OBaseParser { \nprotected String parserRequiredWord ( final boolean iUpperCase , final String iCustomMessage , String iSeparators ) { \nif ( iSeparators == null ) iSeparators = \" ()=><,\\r\\n\" ; \nparserNextWord ( iUpperCase , iSeparators ) ; \nif ( parserLastWord . length ( ) == 0 ) throwSyntaxErrorException ( iCustomMessage ) ; \nif ( parserLastWord . charAt ( 0 ) == '`' ) { \nif ( parserLastWord . charAt ( parserLastWord . length ( ) - 1 ) == '`' ) { \nreturn parserLastWord . substring ( 1 , parserLastWord . length ( ) - 1 ) ; \n} \n} \nreturn parserLastWord . toString ( ) ; \n} \n} \n"}
{"3336": "public class OBaseParser { \nprotected int parserNextChars ( final boolean iUpperCase , final boolean iMandatory , final String ... iCandidateWords ) { \nparserPreviousPos = parserCurrentPos ; \nparserSkipWhiteSpaces ( ) ; \nparserEscapeSequenceCount = 0 ; \nparserLastWord . setLength ( 0 ) ; \nfinal String [ ] processedWords = Arrays . copyOf ( iCandidateWords , iCandidateWords . length ) ; \nfinal String text2Use = iUpperCase ? parserTextUpperCase : parserText ; \nfinal int max = text2Use . length ( ) ; \nparserCurrentPos = parserCurrentPos + parserTextUpperCase . length ( ) - parserText . length ( ) ; \nfor ( int i = 0 ; \nparserCurrentPos <= max ; \n++ i ) { \nfinal char ch = parserCurrentPos < max ? text2Use . charAt ( parserCurrentPos ) : '\\n' ; \nfinal boolean separator = ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t' || ch == '(' ; \nif ( ! separator ) parserLastWord . append ( ch ) ; \nint candidatesWordsCount = 0 ; \nint candidatesWordsPos = - 1 ; \nfor ( int c = 0 ; \nc < processedWords . length ; \n++ c ) { \nfinal String w = processedWords [ c ] ; \nif ( w != null ) { \nfinal int wordSize = w . length ( ) ; \nif ( ( separator && wordSize > i ) || ( ! separator && ( i > wordSize - 1 || w . charAt ( i ) != ch ) ) ) processedWords [ c ] = null ; \nelse { \ncandidatesWordsCount ++ ; \nif ( candidatesWordsCount == 1 ) candidatesWordsPos = c ; \n} \n} \n} \nif ( candidatesWordsCount == 1 ) { \nfinal String w = processedWords [ candidatesWordsPos ] ; \nif ( w . length ( ) == i + ( separator ? 0 : 1 ) ) { \nif ( ! Character . isLetter ( ch ) ) return candidatesWordsPos ; \n} \n} \nif ( candidatesWordsCount == 0 ) break ; \nelse if ( separator ) break ; \nparserCurrentPos ++ ; \n} \nif ( iMandatory ) throwSyntaxErrorException ( \"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\" + Arrays . toString ( iCandidateWords ) + \"'\" ) ; \nreturn - 1 ; \n} \n} \n"}
{"3339": "public class OCommandExecutorSQLDropClass { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( className == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal ODatabaseDocument database = getDatabase ( ) ; \nif ( ifExists ) { \nif ( ! database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ) { \nreturn true ; \n} \n} \nfinal OClass cls = database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; \nif ( cls == null ) { \nreturn null ; \n} \nfinal long records = cls . count ( true ) ; \nif ( records > 0 ) { \nif ( ! unsafe ) { \nif ( cls . isSubClassOf ( \"V\" ) ) { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to avoid broken edges in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \nelse if ( cls . isSubClassOf ( \"E\" ) ) { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Edges. Use 'DELETE EDGE' command first to avoid broken vertices in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \n} \ndatabase . getMetadata ( ) . getSchema ( ) . dropClass ( className ) ; \nif ( records > 0 ) { \nif ( unsafe ) { \nif ( cls . isSubClassOf ( \"V\" ) ) { \nif ( unsafe ) OLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d vertices using UNSAFE mode. Database could contain broken edges\" , className , records ) ; \n} \nelse if ( cls . isSubClassOf ( \"E\" ) ) { \nOLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d edges using UNSAFE mode. Database could contain broken vertices\" , className , records ) ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"3343": "public class OAuth2FeignRequestInterceptor { \nprotected OAuth2AccessToken acquireAccessToken ( ) throws UserRedirectRequiredException { \nAccessTokenRequest tokenRequest = oAuth2ClientContext . getAccessTokenRequest ( ) ; \nif ( tokenRequest == null ) { \nthrow new AccessTokenRequiredException ( \"Cannot find valid context on request for resource '\" + resource . getId ( ) + \"'.\" , resource ) ; \n} \nString stateKey = tokenRequest . getStateKey ( ) ; \nif ( stateKey != null ) { \ntokenRequest . setPreservedState ( oAuth2ClientContext . removePreservedState ( stateKey ) ) ; \n} \nOAuth2AccessToken existingToken = oAuth2ClientContext . getAccessToken ( ) ; \nif ( existingToken != null ) { \noAuth2ClientContext . setAccessToken ( existingToken ) ; \n} \nOAuth2AccessToken obtainableAccessToken ; \nobtainableAccessToken = accessTokenProvider . obtainAccessToken ( resource , tokenRequest ) ; \nif ( obtainableAccessToken == null ) { \nthrow new IllegalStateException ( \" Access token provider returned a null token, which is illegal according to the contract.\" ) ; \n} \nelse if ( obtainableAccessToken . getValue ( ) == null ) { \nthrow new IllegalStateException ( \" Access token provider returned a null token, which is illegal according to the contract.\" ) ; \n} \noAuth2ClientContext . setAccessToken ( obtainableAccessToken ) ; \nreturn obtainableAccessToken ; \n} \n} \n"}
{"3363": "public class HollowFilesystemBlobStorageCleaner { \n@ Override public void cleanSnapshots ( ) { \nFile [ ] files = getFilesByType ( HollowProducer . Blob . Type . SNAPSHOT . prefix ) ; \nif ( files == null ) { \nreturn ; \n} \nelse if ( files . length <= numOfSnapshotsToKeep ) { \nreturn ; \n} \nsortByLastModified ( files ) ; \nfor ( int i = numOfSnapshotsToKeep ; \ni < files . length ; \ni ++ ) { \nFile file = files [ i ] ; \nboolean deleted = file . delete ( ) ; \nif ( ! deleted ) { \nlog . warning ( \"Could not delete snapshot \" + file . getPath ( ) ) ; \n} \n} \n} \n} \n"}
{"3365": "public class HollowReadFieldUtils { \npublic static boolean fieldsAreEqual ( HollowObjectTypeDataAccess typeAccess1 , int ordinal1 , int fieldPosition1 , HollowObjectTypeDataAccess typeAccess2 , int ordinal2 , int fieldPosition2 ) { \nHollowObjectSchema schema1 = typeAccess1 . getSchema ( ) ; \nswitch ( schema1 . getFieldType ( fieldPosition1 ) ) { \ncase BOOLEAN : Boolean bool1 = typeAccess1 . readBoolean ( ordinal1 , fieldPosition1 ) ; \nBoolean bool2 = typeAccess2 . readBoolean ( ordinal2 , fieldPosition2 ) ; \nreturn bool1 == bool2 ; \ncase BYTES : byte [ ] data1 = typeAccess1 . readBytes ( ordinal1 , fieldPosition1 ) ; \nbyte [ ] data2 = typeAccess2 . readBytes ( ordinal2 , fieldPosition2 ) ; \nreturn Arrays . equals ( data1 , data2 ) ; \ncase DOUBLE : double d1 = typeAccess1 . readDouble ( ordinal1 , fieldPosition1 ) ; \ndouble d2 = typeAccess2 . readDouble ( ordinal2 , fieldPosition2 ) ; \nreturn Double . compare ( d1 , d2 ) == 0 ; \ncase FLOAT : float f1 = typeAccess1 . readFloat ( ordinal1 , fieldPosition1 ) ; \nfloat f2 = typeAccess2 . readFloat ( ordinal2 , fieldPosition2 ) ; \nreturn Float . compare ( f1 , f2 ) == 0 ; \ncase INT : int i1 = typeAccess1 . readInt ( ordinal1 , fieldPosition1 ) ; \nint i2 = typeAccess2 . readInt ( ordinal2 , fieldPosition2 ) ; \nreturn i1 == i2 ; \ncase LONG : long l1 = typeAccess1 . readLong ( ordinal1 , fieldPosition1 ) ; \nlong l2 = typeAccess2 . readLong ( ordinal2 , fieldPosition2 ) ; \nreturn l1 == l2 ; \ncase STRING : String s1 = typeAccess1 . readString ( ordinal1 , fieldPosition1 ) ; \nreturn typeAccess2 . isStringFieldEqual ( ordinal2 , fieldPosition2 , s1 ) ; \ncase REFERENCE : if ( typeAccess1 == typeAccess2 ) { \nif ( fieldPosition1 == fieldPosition2 ) return typeAccess1 . readOrdinal ( ordinal1 , fieldPosition1 ) == typeAccess2 . readOrdinal ( ordinal2 , fieldPosition2 ) ; \n} \ndefault : } \nthrow new IllegalStateException ( \"I don't know how to test equality for a \" + schema1 . getFieldType ( fieldPosition1 ) ) ; \n} \n} \n"}
{"3366": "public class TransitiveSetTraverser { \npublic static void removeReferencedOutsideClosure ( HollowReadStateEngine stateEngine , Map < String , BitSet > matches ) { \nList < HollowSchema > orderedSchemas = HollowSchemaSorter . dependencyOrderedSchemaList ( stateEngine ) ; \nCollections . reverse ( orderedSchemas ) ; \nfor ( HollowSchema referencedSchema : orderedSchemas ) { \nif ( matches . containsKey ( referencedSchema . getName ( ) ) ) { \nfor ( HollowSchema referencerSchema : orderedSchemas ) { \nif ( referencerSchema == referencedSchema ) break ; \nif ( matches . containsKey ( referencedSchema . getName ( ) ) ) { \nif ( matches . get ( referencedSchema . getName ( ) ) . cardinality ( ) > 0 ) traverseReferencesOutsideClosure ( stateEngine , referencerSchema . getName ( ) , referencedSchema . getName ( ) , matches , REMOVE_REFERENCED_OUTSIDE_CLOSURE ) ; \n} \n} \n} \n} \n} \n} \n"}
{"3385": "public class HollowAPIGenerator { \nprotected static boolean hasCollectionsInDataSet ( HollowDataset dataset ) { \nfor ( HollowSchema schema : dataset . getSchemas ( ) ) { \nif ( ( schema instanceof HollowListSchema ) || ( schema instanceof HollowSetSchema ) ) { \nreturn true ; \n} \nelse if ( schema instanceof HollowMapSchema ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3386": "public class HollowAPIGenerator { \npublic void generateFiles ( File directory ) throws IOException { \nif ( packageName != null ) { \nif ( ! packageName . trim ( ) . isEmpty ( ) ) { \nString packageDir = packageName . replace ( \".\" , File . separator ) ; \nif ( ! directory . getAbsolutePath ( ) . endsWith ( packageDir ) ) { \ndirectory = new File ( directory , packageDir ) ; \n} \n} \n} \ndirectory . mkdirs ( ) ; \nHollowAPIClassJavaGenerator apiClassGenerator = new HollowAPIClassJavaGenerator ( packageName , apiClassname , dataset , parameterizeClassNames , config ) ; \nHollowAPIFactoryJavaGenerator apiFactoryGenerator = new HollowAPIFactoryJavaGenerator ( packageName , apiClassname , dataset , config ) ; \nHollowHashIndexGenerator hashIndexGenerator = new HollowHashIndexGenerator ( packageName , apiClassname , dataset , config ) ; \ngenerateFile ( directory , apiClassGenerator ) ; \ngenerateFile ( directory , apiFactoryGenerator ) ; \ngenerateFile ( directory , hashIndexGenerator ) ; \ngenerateFilesForHollowSchemas ( directory ) ; \n} \n} \n"}
{"3387": "public class HollowAPIGenerator { \nprotected void generateFilesForHollowSchemas ( File directory ) throws IOException { \nfor ( HollowSchema schema : dataset . getSchemas ( ) ) { \nString type = schema . getName ( ) ; \nif ( config . isUseHollowPrimitiveTypes ( ) ) { \nif ( HollowCodeGenerationUtils . isPrimitiveType ( type ) ) continue ; \n} \ngenerateFile ( directory , getStaticAPIGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowObjectGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowFactoryGenerator ( schema ) ) ; \nif ( schema . getSchemaType ( ) == SchemaType . OBJECT ) { \nHollowObjectSchema objSchema = ( HollowObjectSchema ) schema ; \ngenerateFile ( directory , new HollowObjectDelegateInterfaceGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateCachedImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateLookupImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowDataAccessorGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \nif ( ! config . isReservePrimaryKeyIndexForTypeWithPrimaryKey ( ) ) { \ngenerateFile ( directory , new LegacyHollowPrimaryKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \n} \nelse if ( ( objSchema ) . getPrimaryKey ( ) != null ) { \ngenerateFile ( directory , new HollowPrimaryKeyIndexGenerator ( dataset , packageName , apiClassname , objSchema , config ) ) ; \ngenerateFile ( directory , new HollowUniqueKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \n} \n} \n} \n} \n} \n"}
{"3400": "public class GrowingSegmentedLongArray { \npublic long get ( long index ) { \nint segmentIndex = ( int ) ( index >> log2OfSegmentSize ) ; \nif ( segmentIndex >= segments . length ) return 0 ; \nelse if ( segments [ segmentIndex ] == null ) return 0 ; \nint longInSegment = ( int ) ( index & bitmask ) ; \nreturn segments [ segmentIndex ] [ longInSegment ] ; \n} \n} \n"}
{"3406": "public class HollowIncrementalProducer { \npublic void restoreFromLastState ( ) { \nproducer . initializeDataModel ( dataModel ) ; \nlong latestAnnouncedVersion = announcementWatcher . getLatestVersion ( ) ; \nif ( latestAnnouncedVersion == HollowFilesystemAnnouncementWatcher . NO_ANNOUNCEMENT_AVAILABLE ) { \nreturn ; \n} \nelse if ( latestAnnouncedVersion < 0 ) { \nreturn ; \n} \nrestore ( latestAnnouncedVersion , blobRetriever ) ; \n} \n} \n"}
{"3420": "public class ByteArrayOrdinalMap { \nprivate int findFreeOrdinal ( int preferredOrdinal ) { \nif ( preferredOrdinal != - 1 ) { \nif ( unusedPreviousOrdinals . get ( preferredOrdinal ) ) { \nunusedPreviousOrdinals . clear ( preferredOrdinal ) ; \nreturn preferredOrdinal ; \n} \n} \nreturn freeOrdinalTracker . getFreeOrdinal ( ) ; \n} \n} \n"}
{"3430": "public class HollowProducer { \npublic long runCompactionCycle ( HollowCompactor . CompactionConfig config ) { \nif ( config != null ) { \nif ( readStates . hasCurrent ( ) ) { \nfinal HollowCompactor compactor = new HollowCompactor ( getWriteEngine ( ) , readStates . current ( ) . getStateEngine ( ) , config ) ; \nif ( compactor . needsCompaction ( ) ) { \nreturn runCycle ( newState -> compactor . compact ( ) ) ; \n} \n} \n} \nreturn NO_ANNOUNCEMENT_AVAILABLE ; \n} \n} \n"}
{"3433": "public class HollowConsumerJavaFileGenerator { \nprivate void addToSetIfNotPrimitiveOrCollection ( Set < String > schemaNameSet , String ... schemaNames ) { \nfor ( String schemaName : schemaNames ) { \nif ( ! HollowCodeGenerationUtils . isCollectionType ( schemaName , dataset ) ) { \nif ( ! HollowCodeGenerationUtils . isPrimitiveType ( schemaName ) ) { \nschemaNameSet . add ( schemaName ) ; \n} \n} \n} \n} \n} \n"}
{"3441": "public class VarInt { \npublic static void writeVLong ( OutputStream out , long value ) throws IOException { \nif ( value < 0 ) out . write ( ( byte ) 0x81 ) ; \nif ( value > 0xFFFFFFFFFFFFFFL ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 56 ) & 0x7FL ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 56 ) & 0x7FL ) ) ) ; \nif ( value > 0x1FFFFFFFFFFFFL ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 49 ) & 0x7FL ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 49 ) & 0x7FL ) ) ) ; \nif ( value > 0x3FFFFFFFFFFL ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 42 ) & 0x7FL ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 42 ) & 0x7FL ) ) ) ; \nif ( value > 0x7FFFFFFFFL ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 35 ) & 0x7FL ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 35 ) & 0x7FL ) ) ) ; \nif ( value > 0xFFFFFFFL ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 28 ) & 0x7FL ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 28 ) & 0x7FL ) ) ) ; \nif ( value > 0x1FFFFFL ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7FL ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7FL ) ) ) ; \nif ( value > 0x3FFFL ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7FL ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7FL ) ) ) ; \nif ( value > 0x7FL ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7FL ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7FL ) ) ) ; \nout . write ( ( byte ) ( value & 0x7FL ) ) ; \n} \n} \n"}
{"3442": "public class VarInt { \npublic static void writeVInt ( OutputStream out , int value ) throws IOException { \nif ( value > 0x0FFFFFFF ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 28 ) ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 28 ) ) ) ) ; \nif ( value > 0x1FFFFF ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7F ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7F ) ) ) ; \nif ( value > 0x3FFF ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7F ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7F ) ) ) ; \nif ( value > 0x7F ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7F ) ) ) ; \nelse if ( value < 0 ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7F ) ) ) ; \nout . write ( ( byte ) ( value & 0x7F ) ) ; \n} \n} \n"}
{"3443": "public class VarInt { \npublic static int writeVInt ( byte data [ ] , int pos , int value ) { \nif ( value > 0x0FFFFFFF ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 28 ) ) ) ) ; \nelse if ( value < 0 ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 28 ) ) ) ) ; \nif ( value > 0x1FFFFF ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7F ) ) ) ; \nelse if ( value < 0 ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7F ) ) ) ; \nif ( value > 0x3FFF ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7F ) ) ) ; \nelse if ( value < 0 ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7F ) ) ) ; \nif ( value > 0x7F ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7F ) ) ) ; \nelse if ( value < 0 ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7F ) ) ) ; \ndata [ pos ++ ] = ( byte ) ( value & 0x7F ) ; \nreturn pos ; \n} \n} \n"}
{"3449": "public class PullToRefreshBase { \nprivate void pullEvent ( ) { \nfinal int newScrollValue ; \nfinal int itemDimension ; \nfinal float initialMotionValue , lastMotionValue ; \nswitch ( getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : initialMotionValue = mInitialMotionX ; \nlastMotionValue = mLastMotionX ; \nbreak ; \ncase VERTICAL : default : initialMotionValue = mInitialMotionY ; \nlastMotionValue = mLastMotionY ; \nbreak ; \n} \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getFooterSize ( ) ; \nbreak ; \ncase PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getHeaderSize ( ) ; \nbreak ; \n} \nsetHeaderScroll ( newScrollValue ) ; \nif ( newScrollValue != 0 ) { \nif ( ! isRefreshing ( ) ) { \nfloat scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : mFooterLayout . onPull ( scale ) ; \nbreak ; \ncase PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; \nbreak ; \n} \nif ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { \nsetState ( State . PULL_TO_REFRESH ) ; \n} \nelse if ( mState == State . PULL_TO_REFRESH ) { \nif ( itemDimension < Math . abs ( newScrollValue ) ) { \nsetState ( State . RELEASE_TO_REFRESH ) ; \n} \n} \n} \n} \n} \n} \n"}
{"3450": "public class OverscrollHelper { \npublic static void overScrollBy ( final PullToRefreshBase < ? > view , final int deltaX , final int scrollX , final int deltaY , final int scrollY , final int scrollRange , final int fuzzyThreshold , final float scaleFactor , final boolean isTouchEvent ) { \nfinal int deltaValue , currentScrollValue , scrollValue ; \nswitch ( view . getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : deltaValue = deltaX ; \nscrollValue = scrollX ; \ncurrentScrollValue = view . getScrollX ( ) ; \nbreak ; \ncase VERTICAL : default : deltaValue = deltaY ; \nscrollValue = scrollY ; \ncurrentScrollValue = view . getScrollY ( ) ; \nbreak ; \n} \nif ( view . isPullToRefreshOverScrollEnabled ( ) ) { \nif ( ! view . isRefreshing ( ) ) { \nfinal Mode mode = view . getMode ( ) ; \nif ( mode . permitsPullToRefresh ( ) && ! isTouchEvent && deltaValue != 0 ) { \nfinal int newScrollValue = ( deltaValue + scrollValue ) ; \nif ( PullToRefreshBase . DEBUG ) { \nLog . d ( LOG_TAG , \"OverScroll. DeltaX: \" + deltaX + \", ScrollX: \" + scrollX + \", DeltaY: \" + deltaY + \", ScrollY: \" + scrollY + \", NewY: \" + newScrollValue + \", ScrollRange: \" + scrollRange + \", CurrentScroll: \" + currentScrollValue ) ; \n} \nif ( newScrollValue < ( 0 - fuzzyThreshold ) ) { \nif ( mode . showHeaderLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue ) ) ) ; \n} \n} \nelse if ( newScrollValue > ( scrollRange + fuzzyThreshold ) ) { \nif ( mode . showFooterLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue - scrollRange ) ) ) ; \n} \n} \nelse if ( Math . abs ( newScrollValue ) <= fuzzyThreshold ) { \nview . setState ( State . RESET ) ; \n} \nelse if ( Math . abs ( newScrollValue - scrollRange ) <= fuzzyThreshold ) { \nview . setState ( State . RESET ) ; \n} \n} \nelse if ( isTouchEvent ) { \nif ( State . OVERSCROLLING == view . getState ( ) ) { \nview . setState ( State . RESET ) ; \n} \n} \n} \n} \n} \n} \n"}
{"3473": "public class AsciiDocParser { \nprivate String readEmptyLineOrEndTable ( final BufferedReader tableContent ) throws IOException { \nfinal String column = tableContent . readLine ( ) ; \nif ( column != null ) { \nif ( column . startsWith ( END_TABLE ) ) { \nreturn END_TABLE ; \n} \n} \nif ( column == null ) { \nthrow new IllegalArgumentException ( String . format ( \"Trying to read an empty line for end of row, but content %s was found or EOF\" , column ) ) ; \n} \nelse if ( ! column . isEmpty ( ) ) { \nthrow new IllegalArgumentException ( String . format ( \"Trying to read an empty line for end of row, but content %s was found or EOF\" , column ) ) ; \n} \nreturn \"\" ; \n} \n} \n"}
{"3480": "public class DefaultServiceEnricher { \nprivate void addMissingServiceParts ( ServiceBuilder service , Service defaultService ) { \nif ( ! service . hasSpec ( ) ) { \nservice . withNewSpecLike ( defaultService . getSpec ( ) ) . endSpec ( ) ; \nreturn ; \n} \nList < ServicePort > ports = service . buildSpec ( ) . getPorts ( ) ; \nif ( ports == null ) { \nservice . editSpec ( ) . withPorts ( defaultService . getSpec ( ) . getPorts ( ) ) . endSpec ( ) ; \nreturn ; \n} \nelse if ( ports . isEmpty ( ) ) { \nservice . editSpec ( ) . withPorts ( defaultService . getSpec ( ) . getPorts ( ) ) . endSpec ( ) ; \nreturn ; \n} \nservice . editSpec ( ) . withPorts ( addMissingDefaultPorts ( ports , defaultService ) ) . endSpec ( ) ; \n} \n} \n"}
{"3493": "public class KubernetesHelper { \npublic static boolean isPodReady ( Pod pod ) { \nif ( ! isPodRunning ( pod ) ) { \nreturn false ; \n} \nPodStatus podStatus = pod . getStatus ( ) ; \nif ( podStatus == null ) { \nreturn true ; \n} \nList < PodCondition > conditions = podStatus . getConditions ( ) ; \nif ( conditions == null ) { \nreturn true ; \n} \nelse if ( conditions . isEmpty ( ) ) { \nreturn true ; \n} \nfor ( PodCondition condition : conditions ) { \nif ( \"ready\" . equalsIgnoreCase ( condition . getType ( ) ) ) { \nreturn Boolean . parseBoolean ( condition . getStatus ( ) ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3495": "public class RouteEnricher { \nprivate boolean hasRoute ( final KubernetesListBuilder listBuilder , final String name ) { \nfinal AtomicBoolean answer = new AtomicBoolean ( false ) ; \nlistBuilder . accept ( new TypedVisitor < RouteBuilder > ( ) { \n@ Override public void visit ( RouteBuilder builder ) { \nObjectMeta metadata = builder . getMetadata ( ) ; \nif ( metadata != null ) { \nif ( name . equals ( metadata . getName ( ) ) ) { \nanswer . set ( true ) ; \n} \n} \n} \n} \n) ; \nreturn answer . get ( ) ; \n} \n} \n"}
{"3497": "public class KubernetesResourceUtil { \nprivate static Map < String , Object > readAndEnrichFragment ( PlatformMode platformMode , ResourceVersioning apiVersions , File file , String appName ) throws IOException { \nPattern pattern = Pattern . compile ( FILENAME_PATTERN , Pattern . CASE_INSENSITIVE ) ; \nMatcher matcher = pattern . matcher ( file . getName ( ) ) ; \nif ( ! matcher . matches ( ) ) { \nthrow new IllegalArgumentException ( String . format ( \"Resource file name '%s' does not match pattern <name>-<type>.(yaml|yml|json)\" , file . getName ( ) ) ) ; \n} \nString name = matcher . group ( \"name\" ) ; \nString type = matcher . group ( \"type\" ) ; \nString ext = matcher . group ( \"ext\" ) . toLowerCase ( ) ; \nString kind ; \nMap < String , Object > fragment = readFragment ( file , ext ) ; \nif ( type != null ) { \nkind = getAndValidateKindFromType ( file , type ) ; \n} \nelse { \nkind = FILENAME_TO_KIND_MAPPER . get ( name . toLowerCase ( ) ) ; \nif ( kind != null ) { \nname = null ; \n} \n} \naddKind ( fragment , kind , file . getName ( ) ) ; \nString apiVersion = apiVersions . getCoreVersion ( ) ; \nif ( Objects . equals ( kind , \"Ingress\" ) ) { \napiVersion = apiVersions . getExtensionsVersion ( ) ; \n} \nelse if ( Objects . equals ( kind , \"StatefulSet\" ) || Objects . equals ( kind , \"Deployment\" ) ) { \napiVersion = apiVersions . getAppsVersion ( ) ; \n} \nelse if ( Objects . equals ( kind , \"Job\" ) ) { \napiVersion = apiVersions . getJobVersion ( ) ; \n} \nelse if ( Objects . equals ( kind , \"DeploymentConfig\" ) ) { \nif ( platformMode == PlatformMode . openshift ) { \napiVersion = apiVersions . getOpenshiftV1version ( ) ; \n} \n} \naddIfNotExistent ( fragment , \"apiVersion\" , apiVersion ) ; \nMap < String , Object > metaMap = getMetadata ( fragment ) ; \naddIfNotExistent ( metaMap , \"name\" , StringUtils . isNotBlank ( name ) ? name : appName ) ; \nreturn fragment ; \n} \n} \n"}
{"3499": "public class KubernetesResourceUtil { \npublic static HasMetadata mergeResources ( HasMetadata item1 , HasMetadata item2 , Logger log , boolean switchOnLocalCustomisation ) { \nif ( item1 instanceof Deployment ) { \nif ( item2 instanceof Deployment ) { \nreturn mergeDeployments ( ( Deployment ) item1 , ( Deployment ) item2 , log , switchOnLocalCustomisation ) ; \n} \n} \nif ( item1 instanceof ConfigMap ) { \nif ( item2 instanceof ConfigMap ) { \nConfigMap cm1 = ( ConfigMap ) item1 ; \nConfigMap cm2 = ( ConfigMap ) item2 ; \nreturn mergeConfigMaps ( cm1 , cm2 , log , switchOnLocalCustomisation ) ; \n} \n} \nmergeMetadata ( item1 , item2 ) ; \nreturn item1 ; \n} \n} \n"}
{"3500": "public class KubernetesResourceUtil { \nprivate static Map < String , String > mergeMapsAndRemoveEmptyStrings ( Map < String , String > overrideMap , Map < String , String > originalMap ) { \nMap < String , String > answer = MapUtil . mergeMaps ( overrideMap , originalMap ) ; \nSet < Map . Entry < String , String > > entries = overrideMap . entrySet ( ) ; \nfor ( Map . Entry < String , String > entry : entries ) { \nString value = entry . getValue ( ) ; \nif ( value == null ) { \nString key = entry . getKey ( ) ; \nanswer . remove ( key ) ; \n} \nelse if ( value . isEmpty ( ) ) { \nString key = entry . getKey ( ) ; \nanswer . remove ( key ) ; \n} \n} \nreturn answer ; \n} \n} \n"}
{"3527": "public class DefaultNamespaceEnricher { \n@ Override public void create ( PlatformMode platformMode , KubernetesListBuilder builder ) { \nfinal String name = config . getNamespace ( ) ; \nif ( name == null ) { \nreturn ; \n} \nelse if ( name . isEmpty ( ) ) { \nreturn ; \n} \nif ( ! KubernetesResourceUtil . checkForKind ( builder , NAMESPACE_KINDS ) ) { \nString type = getConfig ( Config . type ) ; \nif ( \"project\" . equalsIgnoreCase ( type ) ) { \nif ( platformMode == PlatformMode . kubernetes ) { \nlog . info ( \"Adding a default Namespace:\" + config . getNamespace ( ) ) ; \nNamespace namespace = handlerHub . getNamespaceHandler ( ) . getNamespace ( config . getNamespace ( ) ) ; \nbuilder . addToNamespaceItems ( namespace ) ; \n} \nelse { \nlog . info ( \"Adding a default Project\" + config . getNamespace ( ) ) ; \nProject project = handlerHub . getProjectHandler ( ) . getProject ( config . getNamespace ( ) ) ; \nbuilder . addToProjectItems ( project ) ; \n} \n} \nelse if ( \"namespace\" . equalsIgnoreCase ( type ) ) { \nif ( platformMode == PlatformMode . kubernetes ) { \nlog . info ( \"Adding a default Namespace:\" + config . getNamespace ( ) ) ; \nNamespace namespace = handlerHub . getNamespaceHandler ( ) . getNamespace ( config . getNamespace ( ) ) ; \nbuilder . addToNamespaceItems ( namespace ) ; \n} \nelse { \nlog . info ( \"Adding a default Project\" + config . getNamespace ( ) ) ; \nProject project = handlerHub . getProjectHandler ( ) . getProject ( config . getNamespace ( ) ) ; \nbuilder . addToProjectItems ( project ) ; \n} \n} \n} \n} \n} \n"}
{"3528": "public class DefaultNamespaceEnricher { \n@ Override public void enrich ( PlatformMode platformMode , KubernetesListBuilder builder ) { \nbuilder . accept ( new TypedVisitor < ObjectMetaBuilder > ( ) { \nprivate String getNamespaceName ( ) { \nString name = null ; \nif ( config . getNamespace ( ) != null ) { \nif ( ! config . getNamespace ( ) . isEmpty ( ) ) { \nname = config . getNamespace ( ) ; \n} \n} \nname = builder . getItems ( ) . stream ( ) . filter ( item -> Arrays . asList ( NAMESPACE_KINDS ) . contains ( item . getKind ( ) ) ) . findFirst ( ) . get ( ) . getMetadata ( ) . getName ( ) ; \nreturn name ; \n} \n@ Override public void visit ( ObjectMetaBuilder metaBuilder ) { \nif ( ! KubernetesResourceUtil . checkForKind ( builder , NAMESPACE_KINDS ) ) { \nreturn ; \n} \nString name = getNamespaceName ( ) ; \nif ( name == null ) { \nreturn ; \n} \nelse if ( name . isEmpty ( ) ) { \nreturn ; \n} \nmetaBuilder . withNamespace ( name ) . build ( ) ; \n} \n} \n) ; \nbuilder . accept ( new TypedVisitor < NamespaceBuilder > ( ) { \n@ Override public void visit ( NamespaceBuilder builder ) { \nbuilder . withNewStatus ( \"active\" ) . editMetadata ( ) . withNamespace ( null ) . endMetadata ( ) . build ( ) ; \n} \n} \n) ; \nbuilder . accept ( new TypedVisitor < ProjectBuilder > ( ) { \n@ Override public void visit ( ProjectBuilder builder ) { \nbuilder . withNewStatus ( \"active\" ) . editMetadata ( ) . withNamespace ( null ) . endMetadata ( ) . build ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"3540": "public class IconEnricher { \nprivate String getDefaultIconRef ( ) { \nProjectClassLoaders cls = getContext ( ) . getProjectClassLoaders ( ) ; \nif ( cls . isClassInCompileClasspath ( false , \"io.fabric8.funktion.runtime.Main\" ) ) { \nreturn \"funktion\" ; \n} \nelse if ( getContext ( ) . hasDependency ( \"io.fabric8.funktion\" , null ) ) { \nreturn \"funktion\" ; \n} \nif ( cls . isClassInCompileClasspath ( false , \"org.apache.camel.CamelContext\" ) ) { \nreturn \"camel\" ; \n} \nif ( getContext ( ) . hasPlugin ( null , SpringBootConfigurationHelper . SPRING_BOOT_MAVEN_PLUGIN_ARTIFACT_ID ) ) { \nreturn \"spring-boot\" ; \n} \nelse if ( cls . isClassInCompileClasspath ( false , \"org.springframework.boot.SpringApplication\" ) ) { \nreturn \"spring-boot\" ; \n} \nif ( cls . isClassInCompileClasspath ( false , \"org.springframework.core.Constants\" ) ) { \nreturn \"spring\" ; \n} \nif ( cls . isClassInCompileClasspath ( false , \"org.vertx.java.core.Handler\" , \"io.vertx.core.Handler\" ) ) { \nreturn \"vertx\" ; \n} \nif ( getContext ( ) . hasPlugin ( \"org.wildfly.swarm\" , \"wildfly-swarm-plugin\" ) ) { \nreturn \"wildfly-swarm\" ; \n} \nelse if ( getContext ( ) . hasDependency ( \"org.wildfly.swarm\" , null ) ) { \nreturn \"wildfly-swarm\" ; \n} \nif ( getContext ( ) . hasPlugin ( \"io.thorntail\" , \"thorntail-maven-plugin\" ) ) { \nreturn \"wildfly-swarm\" ; \n} \nelse if ( getContext ( ) . hasDependency ( \"io.thorntail\" , null ) ) { \nreturn \"wildfly-swarm\" ; \n} \nreturn null ; \n} \n} \n"}
{"3549": "public class ResourceMojo { \nprotected static Template getSingletonTemplate ( KubernetesList resources ) { \nif ( resources != null ) { \nList < HasMetadata > items = resources . getItems ( ) ; \nif ( items != null ) { \nif ( items . size ( ) == 1 ) { \nHasMetadata singleEntity = items . get ( 0 ) ; \nif ( singleEntity instanceof Template ) { \nreturn ( Template ) singleEntity ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"3559": "public class AbstractLiveEnricher { \nprotected String getExternalServiceURL ( String serviceName , String protocol ) { \nif ( ! isOnline ( ) ) { \ngetLog ( ) . info ( \"Not looking for service \" + serviceName + \" as we are in offline mode\" ) ; \nreturn null ; \n} \nelse { \ntry { \nKubernetesClient kubernetes = getKubernetes ( ) ; \nString ns = kubernetes . getNamespace ( ) ; \nif ( StringUtils . isBlank ( ns ) ) { \nns = getNamespace ( ) ; \n} \nService service = kubernetes . services ( ) . inNamespace ( ns ) . withName ( serviceName ) . get ( ) ; \nreturn service != null ? ServiceUrlUtil . getServiceURL ( kubernetes , serviceName , ns , protocol , true ) : null ; \n} \ncatch ( Throwable e ) { \nThrowable cause = e ; \nboolean notFound = false ; \nboolean connectError = false ; \nStack < Throwable > stack = unfoldExceptions ( e ) ; \nwhile ( ! stack . isEmpty ( ) ) { \nThrowable t = stack . pop ( ) ; \nif ( t instanceof ConnectException || \"No route to host\" . equals ( t . getMessage ( ) ) ) { \ngetLog ( ) . warn ( \"Cannot connect to Kubernetes to find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \nelse if ( t instanceof IllegalArgumentException ) { \ngetLog ( ) . warn ( \"%s\" , cause . getMessage ( ) ) ; \nreturn null ; \n} \nelse if ( t . getMessage ( ) != null && t . getMessage ( ) . matches ( \"^No.*found.*$\" ) ) { \ngetLog ( ) . warn ( \"%s\" , cause . getMessage ( ) ) ; \nreturn null ; \n} \n; \n} \ngetLog ( ) . warn ( \"Cannot find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \n} \n} \n} \n"}
{"3588": "public class PayPal { \nprivate static PayPalAccountBuilder parseResponse ( PayPalRequest paypalRequest , Request request , Result result , Intent intent ) { \nPayPalAccountBuilder paypalAccountBuilder = new PayPalAccountBuilder ( ) . clientMetadataId ( request . getClientMetadataId ( ) ) ; \nif ( paypalRequest != null ) { \nif ( paypalRequest . getMerchantAccountId ( ) != null ) { \npaypalAccountBuilder . merchantAccountId ( paypalRequest . getMerchantAccountId ( ) ) ; \n} \n} \nif ( request instanceof CheckoutRequest ) { \nif ( paypalRequest != null ) { \npaypalAccountBuilder . intent ( paypalRequest . getIntent ( ) ) ; \n} \n} \nif ( isAppSwitch ( intent ) ) { \npaypalAccountBuilder . source ( \"paypal-app\" ) ; \n} \nelse { \npaypalAccountBuilder . source ( \"paypal-browser\" ) ; \n} \npaypalAccountBuilder . oneTouchCoreData ( result . getResponse ( ) ) ; \nreturn paypalAccountBuilder ; \n} \n} \n"}
{"3591": "public class OpenKoreanTextProcessorJava { \npublic static List < String > tokensToJavaStringList ( Seq < KoreanToken > tokens , boolean keepSpace ) { \nIterator < KoreanToken > tokenized = tokens . iterator ( ) ; \nList < String > output = new LinkedList < > ( ) ; \nwhile ( tokenized . hasNext ( ) ) { \nfinal KoreanToken token = tokenized . next ( ) ; \nif ( keepSpace ) { \noutput . add ( token . text ( ) ) ; \n} \nelse if ( token . pos ( ) != KoreanPos . Space ( ) ) { \noutput . add ( token . text ( ) ) ; \n} \n} \nreturn output ; \n} \n} \n"}
{"3598": "public class BaseResampler { \npublic static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { \ndouble sum = 0 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \nsum += taps [ i ] ; \n} \nint sumFix = 0 ; \nint precNum = 1 << precBits ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ndouble d = ( taps [ i ] * precNum ) / sum + precNum ; \nint s = ( int ) d ; \ntaps [ i ] = d - s ; \nout [ i ] = ( short ) ( s - precNum ) ; \nsumFix += out [ i ] ; \n} \nlong tapsTaken = 0 ; \nwhile ( sumFix < precNum ) { \nint maxI = - 1 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \nif ( ( tapsTaken & ( 1 << i ) ) == 0 ) { \nif ( maxI == - 1 || taps [ i ] > taps [ maxI ] ) maxI = i ; \n} \n} \nout [ maxI ] ++ ; \nsumFix ++ ; \ntapsTaken |= ( 1 << maxI ) ; \n} \nfor ( int i = 0 ; \ni < taps . length ; \ni ++ ) { \ntaps [ i ] += out [ i ] ; \nif ( ( tapsTaken & ( 1 << i ) ) != 0 ) taps [ i ] -= 1 ; \n} \n} \n} \n"}
{"3599": "public class SegmentReader { \npublic final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { \nif ( done ) return State . STOP ; \nint skipOneMarker = curMarker >= 0x100 && curMarker <= 0x1ff ? 1 : 0 ; \nint written = out . position ( ) ; \ndo { \nwhile ( buf . hasRemaining ( ) ) { \nif ( curMarker >= 0x100 ) { \nif ( curMarker <= 0x1ff ) { \nif ( skipOneMarker == 0 ) { \nreturn State . DONE ; \n} \n-- skipOneMarker ; \n} \n} \nif ( ! out . hasRemaining ( ) ) return State . MORE_DATA ; \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; \n} \nbuf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; \npos += buf . remaining ( ) ; \n} \nwhile ( buf . hasRemaining ( ) ) ; \nwritten = out . position ( ) - written ; \nif ( written > 0 && curMarker >= 0x100 ) { \nif ( curMarker <= 0x1ff ) return State . DONE ; \n} \nfor ( ; \nbytesInMarker > 0 && out . hasRemaining ( ) ; \n) { \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) ; \n-- bytesInMarker ; \nif ( curMarker >= 0x100 ) { \nif ( curMarker <= 0x1ff ) return State . DONE ; \n} \n} \nif ( bytesInMarker == 0 ) { \ndone = true ; \nreturn State . STOP ; \n} \nelse { \nreturn State . MORE_DATA ; \n} \n} \n} \n"}
{"3607": "public class QTTimeUtil { \npublic static long mediaToEdited ( TrakBox trak , long mediaTv , int movieTimescale ) { \nif ( trak . getEdits ( ) == null ) return mediaTv ; \nlong accum = 0 ; \nfor ( Edit edit : trak . getEdits ( ) ) { \nif ( mediaTv < edit . getMediaTime ( ) ) return accum ; \nlong duration = trak . rescale ( edit . getDuration ( ) , movieTimescale ) ; \nif ( edit . getMediaTime ( ) != - 1 ) { \nif ( mediaTv >= edit . getMediaTime ( ) && mediaTv < edit . getMediaTime ( ) + duration ) { \naccum += mediaTv - edit . getMediaTime ( ) ; \nbreak ; \n} \n} \naccum += duration ; \n} \nreturn accum ; \n} \n} \n"}
{"3615": "public class ColorSpace { \npublic boolean matches ( ColorSpace inputColor ) { \nif ( inputColor == this ) return true ; \nif ( inputColor == ANY ) return true ; \nelse if ( this == ANY ) return true ; \nif ( inputColor == ANY_INTERLEAVED || this == ANY_INTERLEAVED || inputColor == ANY_PLANAR || this == ANY_PLANAR ) { \nif ( inputColor . planar == this . planar ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"3616": "public class ColorSpace { \npublic Size compSize ( Size size , int comp ) { \nif ( compWidth [ comp ] == 0 ) { \nif ( compHeight [ comp ] == 0 ) return size ; \n} \nreturn new Size ( size . getWidth ( ) >> compWidth [ comp ] , size . getHeight ( ) >> compHeight [ comp ] ) ; \n} \n} \n"}
{"3632": "public class FLVReader { \npublic boolean repositionFile ( ) throws IOException { \nint payloadSize = 0 ; \nfor ( int i = 0 ; \ni < REPOSITION_BUFFER_READS ; \ni ++ ) { \nwhile ( readBuf . hasRemaining ( ) ) { \npayloadSize = ( ( payloadSize & 0xffff ) << 8 ) | ( readBuf . get ( ) & 0xff ) ; \nint pointerPos = readBuf . position ( ) + 7 + payloadSize ; \nif ( readBuf . position ( ) >= 8 && pointerPos < readBuf . limit ( ) - 4 ) { \nif ( readBuf . getInt ( pointerPos ) - payloadSize == 11 ) { \nreadBuf . position ( readBuf . position ( ) - 8 ) ; \nreturn true ; \n} \n} \n} \ninitialRead ( ch ) ; \nif ( ! readBuf . hasRemaining ( ) ) break ; \n} \nreturn false ; \n} \n} \n"}
{"3635": "public class MPEGUtil { \npublic static final ByteBuffer gotoMarker ( ByteBuffer buf , int n , int mmin , int mmax ) { \nif ( ! buf . hasRemaining ( ) ) return null ; \nint from = buf . position ( ) ; \nByteBuffer result = buf . slice ( ) ; \nresult . order ( ByteOrder . BIG_ENDIAN ) ; \nint val = 0xffffffff ; \nwhile ( buf . hasRemaining ( ) ) { \nval = ( val << 8 ) | ( buf . get ( ) & 0xff ) ; \nif ( val >= mmin ) { \nif ( val <= mmax ) { \nif ( n == 0 ) { \nbuf . position ( buf . position ( ) - 4 ) ; \nresult . limit ( buf . position ( ) - from ) ; \nbreak ; \n} \n-- n ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"3649": "public class AudioUtil { \npublic static void toFloat ( AudioFormat format , ByteBuffer buf , FloatBuffer floatBuf ) { \nif ( ! format . isSigned ( ) ) throw new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \nif ( format . getSampleSizeInBits ( ) != 16 ) { \nif ( format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \n} \nif ( format . isBigEndian ( ) ) { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \ntoFloat16BE ( buf , floatBuf ) ; \n} \nelse { \ntoFloat24BE ( buf , floatBuf ) ; \n} \n} \nelse { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \ntoFloat16LE ( buf , floatBuf ) ; \n} \nelse { \ntoFloat24LE ( buf , floatBuf ) ; \n} \n} \n} \n} \n"}
{"3650": "public class AudioUtil { \npublic static void fromFloat ( FloatBuffer floatBuf , AudioFormat format , ByteBuffer buf ) { \nif ( ! format . isSigned ( ) ) throw new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \nif ( format . getSampleSizeInBits ( ) != 16 ) { \nif ( format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \n} \nif ( format . isBigEndian ( ) ) { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \nfromFloat16BE ( buf , floatBuf ) ; \n} \nelse { \nfromFloat24BE ( buf , floatBuf ) ; \n} \n} \nelse { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \nfromFloat16LE ( buf , floatBuf ) ; \n} \nelse { \nfromFloat24LE ( buf , floatBuf ) ; \n} \n} \n} \n} \n"}
{"3658": "public class MBlockDecoderUtils { \npublic static int calcMVPredictionMedian ( int a , int b , int c , int d , boolean aAvb , boolean bAvb , boolean cAvb , boolean dAvb , int ref , int comp ) { \nif ( ! cAvb ) { \nc = d ; \ncAvb = dAvb ; \n} \nif ( aAvb && ! bAvb ) { \nif ( ! cAvb ) { \nb = c = a ; \nbAvb = cAvb = aAvb ; \n} \n} \na = aAvb ? a : NULL_VECTOR ; \nb = bAvb ? b : NULL_VECTOR ; \nc = cAvb ? c : NULL_VECTOR ; \nif ( mvRef ( a ) == ref && mvRef ( b ) != ref && mvRef ( c ) != ref ) return mvC ( a , comp ) ; \nelse if ( mvRef ( b ) == ref && mvRef ( a ) != ref && mvRef ( c ) != ref ) return mvC ( b , comp ) ; \nelse if ( mvRef ( c ) == ref && mvRef ( a ) != ref ) { \nif ( mvRef ( b ) != ref ) return mvC ( c , comp ) ; \n} \nreturn mvC ( a , comp ) + mvC ( b , comp ) + mvC ( c , comp ) - min ( mvC ( a , comp ) , mvC ( b , comp ) , mvC ( c , comp ) ) - max ( mvC ( a , comp ) , mvC ( b , comp ) , mvC ( c , comp ) ) ; \n} \n} \n"}
{"3662": "public class ContainerFormat { \npublic java . util . Collection < Codec . ID > getSupportedCodecs ( ) { \nfinal java . util . List < Codec . ID > retval = new java . util . LinkedList < Codec . ID > ( ) ; \nfinal java . util . Set < Codec . ID > uniqueSet = new java . util . HashSet < Codec . ID > ( ) ; \nint numCodecs = getNumSupportedCodecs ( ) ; \nfor ( int i = 0 ; \ni < numCodecs ; \ni ++ ) { \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE ) { \nif ( ! uniqueSet . contains ( id ) ) retval . add ( id ) ; \n} \nuniqueSet . add ( id ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3663": "public class ContainerFormat { \npublic java . util . Collection < Long > getSupportedTags ( ) { \nfinal java . util . List < Long > retval = new java . util . LinkedList < Long > ( ) ; \nfinal java . util . Set < Long > uniqueSet = new java . util . HashSet < Long > ( ) ; \nint numCodecs = getNumSupportedCodecs ( ) ; \nfor ( int i = 0 ; \ni < numCodecs ; \ni ++ ) { \nlong tag = getSupportedCodecTag ( i ) ; \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE ) { \nif ( ! uniqueSet . contains ( tag ) ) retval . add ( tag ) ; \n} \nuniqueSet . add ( tag ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3669": "public class JNILibrary { \nprivate static void deleteTemporaryFiles ( ) { \nfinal File dir = getTmpDir ( ) ; \nfinal FilenameFilter filter = new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . endsWith ( HUMBLE_TEMP_EXTENSION ) ; \n} \n} \n; \nfinal File markers [ ] = dir . listFiles ( filter ) ; \nfor ( File marker : markers ) { \nfinal String markerName = marker . getName ( ) ; \nfinal String libName = markerName . substring ( 0 , markerName . length ( ) - HUMBLE_TEMP_EXTENSION . length ( ) ) ; \nfinal File lib = new File ( marker . getParentFile ( ) , libName ) ; \nif ( ! lib . exists ( ) ) marker . delete ( ) ; \nelse if ( lib . delete ( ) ) marker . delete ( ) ; \n} \n} \n} \n"}
{"3676": "public class DecodeAndPlayVideo { \nprivate static void playVideo ( String filename ) throws InterruptedException , IOException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint videoStreamId = - 1 ; \nlong streamStartTime = Global . NO_PTS ; \nDecoder videoDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nstreamStartTime = stream . getStartTime ( ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null ) { \nif ( decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { \nvideoStreamId = i ; \nvideoDecoder = decoder ; \nbreak ; \n} \n} \n} \nif ( videoStreamId == - 1 ) throw new RuntimeException ( \"could not find video stream in container: \" + filename ) ; \nvideoDecoder . open ( null , null ) ; \nfinal MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; \nfinal MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; \nBufferedImage image = null ; \nfinal ImageFrame window = ImageFrame . make ( ) ; \nif ( window == null ) { \nthrow new RuntimeException ( \"Attempting this demo on a headless machine, and that will not work. Sad day for you.\" ) ; \n} \nlong systemStartTime = System . nanoTime ( ) ; \nfinal Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; \nfinal Rational streamTimebase = videoDecoder . getTimeBase ( ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == videoStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += videoDecoder . decode ( picture , packet , offset ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \nvideoDecoder . decode ( picture , null , 0 ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \n} \nwhile ( picture . isComplete ( ) ) ; \ndemuxer . close ( ) ; \nwindow . dispose ( ) ; \n} \n} \n"}
{"3684": "public class Codec { \npublic java . util . Collection < PixelFormat . Type > getSupportedVideoPixelFormats ( ) { \njava . util . List < PixelFormat . Type > retval = new java . util . LinkedList < PixelFormat . Type > ( ) ; \nint count = getNumSupportedVideoPixelFormats ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nPixelFormat . Type type = getSupportedVideoPixelFormat ( i ) ; \nif ( type != null ) { \nif ( type != PixelFormat . Type . PIX_FMT_NONE ) retval . add ( type ) ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3686": "public class Codec { \npublic java . util . Collection < AudioFormat . Type > getSupportedAudioFormats ( ) { \njava . util . List < AudioFormat . Type > retval = new java . util . LinkedList < AudioFormat . Type > ( ) ; \nint count = getNumSupportedAudioFormats ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nAudioFormat . Type fmt = getSupportedAudioFormat ( i ) ; \nif ( fmt != null ) { \nif ( fmt != AudioFormat . Type . SAMPLE_FMT_NONE ) retval . add ( fmt ) ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3699": "public class AMediaPictureConverter { \nprotected void validatePicture ( MediaPicture picture ) { \nif ( picture == null ) throw new IllegalArgumentException ( \"The picture is NULL.\" ) ; \nif ( ! picture . isComplete ( ) ) throw new IllegalArgumentException ( \"The picture is not complete.\" ) ; \nPixelFormat . Type type = picture . getFormat ( ) ; \nif ( type != getPictureType ( ) ) { \nif ( willResample ( ) && type != mToImageResampler . getOutputFormat ( ) ) throw new IllegalArgumentException ( \"Picture is of type: \" + type + \", but must be \" + getPictureType ( ) + ( willResample ( ) ? \" or \" + mToImageResampler . getOutputFormat ( ) : \"\" ) + \".\" ) ; \n} \n} \n} \n"}
{"3706": "public class DecodeAndPlayAudio { \nprivate static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint audioStreamId = - 1 ; \nDecoder audioDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null ) { \nif ( decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { \naudioStreamId = i ; \naudioDecoder = decoder ; \nbreak ; \n} \n} \n} \nif ( audioStreamId == - 1 ) throw new RuntimeException ( \"could not find audio stream in container: \" + filename ) ; \naudioDecoder . open ( null , null ) ; \nfinal MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; \nfinal MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; \nfinal AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; \nif ( audioFrame == null ) throw new LineUnavailableException ( ) ; \nByteBuffer rawAudio = null ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == audioStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += audioDecoder . decode ( samples , packet , offset ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \naudioDecoder . decode ( samples , null , 0 ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \n} \nwhile ( samples . isComplete ( ) ) ; \ndemuxer . close ( ) ; \naudioFrame . dispose ( ) ; \n} \n} \n"}
{"3707": "public class JNILibraryLoader { \nsynchronized void loadLibrary0 ( String aLibraryName , Long aMajorVersion ) { \nif ( alreadyLoadedLibrary ( aLibraryName , aMajorVersion ) ) return ; \nList < String > libCandidates = getLibraryCandidates ( aLibraryName , aMajorVersion ) ; \nif ( libCandidates != null && libCandidates . size ( ) > 0 ) { \nif ( ! loadCandidateLibrary ( aLibraryName , aMajorVersion , libCandidates ) ) { \ntry { \nSystem . loadLibrary ( aLibraryName ) ; \n} \ncatch ( UnsatisfiedLinkError e ) { \nlog . error ( \"Could not load library: {}; version: {}.\" , aLibraryName , aMajorVersion == null ? \"\" : aMajorVersion ) ; \nthrow e ; \n} \nsetLoadedLibrary ( aLibraryName , aMajorVersion ) ; \n} \n} \nlog . trace ( \"Successfully Loaded library: {}; Version: {}\" , aLibraryName , aMajorVersion ) ; \n} \n} \n"}
{"3726": "public class Node { \npublic String compileScript ( String script ) throws IOException { \nif ( script == null ) { \nreturn null ; \n} \nelse if ( script . isEmpty ( ) ) { \nreturn null ; \n} \nHttpPost request = new HttpPost ( uri . resolve ( \"/utils/script/compile\" ) ) ; \nrequest . setEntity ( new StringEntity ( script ) ) ; \nreturn parse ( exec ( request ) , \"script\" ) . asText ( ) ; \n} \n} \n"}
{"3736": "public class FSTStreamEncoder { \nvoid writeStringAsc ( String name ) throws IOException { \nint len = name . length ( ) ; \nif ( len >= 127 ) { \nthrow new RuntimeException ( \"Ascii String too long\" ) ; \n} \nwriteFByte ( ( byte ) len ) ; \nbuffout . ensureFree ( len ) ; \nif ( ascStringCache == null ) ascStringCache = new byte [ len ] ; \nelse if ( ascStringCache . length < len ) ascStringCache = new byte [ len ] ; \nname . getBytes ( 0 , len , ascStringCache , 0 ) ; \nwriteRawBytes ( ascStringCache , 0 , len ) ; \n} \n} \n"}
{"3738": "public class FSTConfiguration { \npublic static FSTConfiguration createJsonConfiguration ( boolean prettyPrint , boolean shareReferences ) { \nif ( shareReferences ) { \nif ( prettyPrint ) { \nthrow new RuntimeException ( \"unsupported flag combination\" ) ; \n} \n} \nreturn createJsonConfiguration ( prettyPrint , shareReferences , null ) ; \n} \n} \n"}
{"3748": "public class MBOut { \npublic void writeInt ( byte type , long data ) { \nif ( ! MinBin . isPrimitive ( type ) ) throw new RuntimeException ( \"illegal type code\" ) ; \nelse if ( MinBin . isArray ( type ) ) throw new RuntimeException ( \"illegal type code\" ) ; \nwriteOut ( type ) ; \nwriteRawInt ( type , data ) ; \n} \n} \n"}
{"3750": "public class MBOut { \npublic void writeIntPacked ( long data ) { \nif ( data <= Byte . MAX_VALUE && data >= Byte . MIN_VALUE ) writeInt ( MinBin . INT_8 , data ) ; \nelse if ( data <= Short . MAX_VALUE && data >= Short . MIN_VALUE ) writeInt ( MinBin . INT_16 , data ) ; \nelse if ( data <= Integer . MAX_VALUE && data >= Integer . MIN_VALUE ) writeInt ( MinBin . INT_32 , data ) ; \nelse if ( data <= Long . MAX_VALUE ) { \nif ( data >= Long . MIN_VALUE ) writeInt ( MinBin . INT_64 , data ) ; \n} \n} \n} \n"}
{"3768": "public class HproseTcpServer { \npublic void setThreadPoolEnabled ( boolean value ) { \nif ( value ) { \nif ( threadPool == null ) { \nthreadPool = Executors . newCachedThreadPool ( ) ; \n} \n} \nthreadPoolEnabled = value ; \n} \n} \n"}
{"3773": "public class CheckSocket { \npublic static boolean remotePortTaken ( String node , int port , int timeout ) { \nSocket s = null ; \ntry { \ns = new Socket ( ) ; \ns . setReuseAddress ( true ) ; \nSocketAddress sa = new InetSocketAddress ( node , port ) ; \ns . connect ( sa , timeout * 1000 ) ; \n} \ncatch ( IOException e ) { \nif ( e . getMessage ( ) . equals ( \"Connection refused\" ) ) { \nreturn false ; \n} \nif ( e instanceof SocketTimeoutException ) { \nthrow e ; \n} \nelse if ( e instanceof UnknownHostException ) { \nthrow e ; \n} \n} \nfinally { \nif ( s != null ) { \nif ( s . isConnected ( ) ) { \nreturn true ; \n} \nelse { \n} \ntry { \ns . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nreturn false ; \n} \n} \n} \n"}
{"3791": "public class VoidParameterServer { \npublic void shutdown ( ) { \nif ( initLocker . get ( ) ) { \nif ( shutdownLocker . compareAndSet ( false , true ) ) { \nlog . info ( \"Shutting down transport...\" ) ; \ntransport . shutdown ( ) ; \nexecutor . shutdown ( ) ; \n} \n} \n} \n} \n"}
{"3855": "public class MultipleEpochsIterator { \n@ Override public DataSet next ( ) { \nif ( ! iter . hasNext ( ) ) { \nif ( passes < numPasses ) { \npasses ++ ; \nbatch = 0 ; \nlog . info ( \"Epoch \" + passes + \" batch \" + batch ) ; \niter . reset ( ) ; \n} \n} \nbatch ++ ; \nDataSet next = iter . next ( ) ; \nif ( preProcessor != null ) preProcessor . preProcess ( next ) ; \nreturn next ; \n} \n} \n"}
{"3860": "public class AsynchronousFlowController { \nprotected void sweepTail ( ) { \nInteger deviceId = allocator . getDeviceId ( ) ; \nint cnt = 0 ; \nlong lastCommandId = deviceClocks . get ( deviceId ) . get ( ) ; \nfor ( int l = 0 ; \nl < configuration . getCommandLanesNumber ( ) ; \nl ++ ) { \nQueue < cudaEvent_t > queue = eventsBarrier . get ( deviceId ) . get ( l ) ; \nif ( queue . size ( ) >= MAX_EXECUTION_QUEUE ) { \ncudaEvent_t event = queue . poll ( ) ; \nif ( event != null ) { \nif ( ! event . isDestroyed ( ) ) { \nevent . synchronize ( ) ; \nevent . destroy ( ) ; \ncnt ++ ; \n} \n} \n} \nelse if ( laneClocks . get ( deviceId ) . get ( l ) . get ( ) < lastCommandId - MAX_EXECUTION_QUEUE ) { \ncudaEvent_t event = queue . poll ( ) ; \nif ( event != null && ! event . isDestroyed ( ) ) { \nevent . synchronize ( ) ; \nevent . destroy ( ) ; \ncnt ++ ; \n} \n} \n} \ndeviceClocks . get ( deviceId ) . incrementAndGet ( ) ; \n} \n} \n"}
{"3873": "public class LibUtils { \npublic static ARCHType calculateArch ( ) { \nString osArch = System . getProperty ( \"os.arch\" ) ; \nosArch = osArch . toLowerCase ( Locale . ENGLISH ) ; \nif ( osArch . equals ( \"i386\" ) || osArch . equals ( \"x86\" ) ) { \nreturn ARCHType . X86 ; \n} \nelse if ( osArch . equals ( \"i686\" ) ) { \nreturn ARCHType . X86 ; \n} \nif ( osArch . startsWith ( \"amd64\" ) ) { \nreturn ARCHType . X86_64 ; \n} \nelse if ( osArch . startsWith ( \"x86_64\" ) ) { \nreturn ARCHType . X86_64 ; \n} \nif ( osArch . equals ( \"ppc\" ) ) { \nreturn ARCHType . PPC ; \n} \nelse if ( osArch . equals ( \"powerpc\" ) ) { \nreturn ARCHType . PPC ; \n} \nif ( osArch . startsWith ( \"ppc\" ) ) { \nreturn ARCHType . PPC_64 ; \n} \nif ( osArch . startsWith ( \"sparc\" ) ) { \nreturn ARCHType . SPARC ; \n} \nif ( osArch . startsWith ( \"arm\" ) ) { \nreturn ARCHType . ARM ; \n} \nif ( osArch . startsWith ( \"mips\" ) ) { \nreturn ARCHType . MIPS ; \n} \nif ( osArch . contains ( \"risc\" ) ) { \nreturn ARCHType . RISC ; \n} \nreturn ARCHType . UNKNOWN ; \n} \n} \n"}
{"3877": "public class DefaultOpExecutioner { \nprotected void interceptIntDataType ( Op op ) { \nif ( op . x ( ) != null ) { \nif ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . INT ) throw new ND4JIllegalStateException ( \"Op.X contains INT data. Operations on INT dataType are not supported yet\" ) ; \n} \nif ( op . z ( ) != null ) { \nif ( op . z ( ) . data ( ) . dataType ( ) == DataBuffer . Type . INT ) throw new ND4JIllegalStateException ( \"Op.Z contains INT data. Operations on INT dataType are not supported yet\" ) ; \n} \nif ( op . y ( ) != null ) { \nif ( op . y ( ) . data ( ) . dataType ( ) == DataBuffer . Type . INT ) throw new ND4JIllegalStateException ( \"Op.Y contains INT data. Operations on INT dataType are not supported yet.\" ) ; \n} \n} \n} \n"}
{"3884": "public class SDVariable { \npublic INDArray storeAndAllocateNewArray ( ) { \nval shape = sameDiff . getShapeForVarName ( getVarName ( ) ) ; \nif ( getArr ( ) != null ) { \nif ( Arrays . equals ( getArr ( ) . shape ( ) , shape ) ) return getArr ( ) ; \n} \nif ( varName == null ) throw new ND4JIllegalStateException ( \"Unable to store array for null variable name!\" ) ; \nif ( shape == null ) { \nthrow new ND4JIllegalStateException ( \"Unable to allocate new array. No shape found for variable \" + varName ) ; \n} \nval arr = getWeightInitScheme ( ) . create ( shape ) ; \nsameDiff . putArrayForVarName ( getVarName ( ) , arr ) ; \nreturn arr ; \n} \n} \n"}
{"3899": "public class BigDecimalMath { \nstatic public BigDecimal exp ( BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nfinal BigDecimal invx = exp ( x . negate ( ) ) ; \nMathContext mc = new MathContext ( invx . precision ( ) ) ; \nreturn BigDecimal . ONE . divide ( invx , mc ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; \n} \nelse { \nfinal double xDbl = x . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nif ( Math . pow ( xDbl , TAYLOR_NTERM ) < TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl ) { \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; \nfor ( int i = 1 ; \ni <= TAYLOR_NTERM ; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; \nxpowi = xpowi . multiply ( x ) ; \nfinal BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( c ) ; \nif ( Math . abs ( xpowi . doubleValue ( ) ) < i ) { \nif ( Math . abs ( c . doubleValue ( ) ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \n} \nMathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nint exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; \nBigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; \nBigDecimal expxby10 = exp ( xby10 ) ; \nMathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; \nwhile ( exSc > 0 ) { \nint exsub = Math . min ( 8 , exSc ) ; \nexSc -= exsub ; \nMathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; \nint pex = 1 ; \nwhile ( exsub -- > 0 ) { \npex *= 10 ; \n} \nexpxby10 = expxby10 . pow ( pex , mctmp ) ; \n} \nreturn expxby10 . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3938": "public class SameDiff { \npublic void addAsPlaceHolder ( String varName ) { \nplaceHolderVarNames . add ( varName ) ; \nif ( getVariable ( varName ) != null ) { \nif ( getVariable ( varName ) . getShape ( ) != null ) { \nplaceHolderOriginalShapes . put ( varName , getVariable ( varName ) . getShape ( ) ) ; \n} \n} \n} \n} \n"}
{"3965": "public class GridFlowController { \n@ Override public void synchronizeToHost ( AllocationPoint point ) { \nif ( ! point . isConstant ( ) ) { \nif ( point . isEnqueued ( ) ) { \nwaitTillFinished ( point ) ; \n} \n} \nsuper . synchronizeToHost ( point ) ; \n} \n} \n"}
{"3970": "public class NDArrayStrings { \npublic String format ( INDArray arr , boolean summarize ) { \nthis . scientificFormat = \"0.\" ; \nint addPrecision = this . precision ; \nwhile ( addPrecision > 0 ) { \nthis . scientificFormat += \"#\" ; \naddPrecision -= 1 ; \n} \nthis . scientificFormat = this . scientificFormat + \"E0\" ; \nif ( this . scientificFormat . length ( ) + 2 > this . padding ) this . padding = this . scientificFormat . length ( ) + 2 ; \nthis . maxToPrintWithoutSwitching = Math . pow ( 10 , this . precision ) ; \nthis . minToPrintWithoutSwitching = 1.0 / ( this . maxToPrintWithoutSwitching ) ; \nif ( summarize ) { \nif ( arr . length ( ) > 1000 ) return format ( arr , 0 , true ) ; \n} \nreturn format ( arr , 0 , false ) ; \n} \n} \n"}
{"3971": "public class BaseGraphMapper { \n@ Override public SameDiff importGraph ( GRAPH_TYPE tfGraph ) { \nSameDiff diff = SameDiff . create ( ) ; \nImportState < GRAPH_TYPE , TENSOR_TYPE > importState = new ImportState < > ( ) ; \nimportState . setSameDiff ( diff ) ; \nimportState . setGraph ( tfGraph ) ; \nval variablesForGraph = variablesForGraph ( tfGraph ) ; \nimportState . setVariables ( variablesForGraph ) ; \nfor ( Map . Entry < String , TENSOR_TYPE > entry : variablesForGraph . entrySet ( ) ) { \nif ( dataTypeForTensor ( entry . getValue ( ) ) == DataBuffer . Type . UNKNOWN ) { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , null , new ZeroInitScheme ( 'c' ) ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nif ( var . getShape ( ) != null ) importState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , var . getShape ( ) ) ; \n} \ncontinue ; \n} \nval arr = getNDArrayFromTensor ( entry . getKey ( ) , entry . getValue ( ) , tfGraph ) ; \nif ( arr != null ) { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , arr ) ; \ndiff . associateArrayWithVariable ( arr , var ) ; \n} \nelse if ( getShapeFromTensor ( entry . getValue ( ) ) == null ) { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , null , new ZeroInitScheme ( 'c' ) ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nval originalShape = getShapeFromTensor ( entry . getValue ( ) ) ; \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nif ( var . getShape ( ) != null ) importState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , originalShape ) ; \n} \n} \nelse { \nval originalShape = getShapeFromTensor ( entry . getValue ( ) ) ; \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , originalShape ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nimportState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , originalShape ) ; \n} \n} \n} \nval tfNodesList = getNodeList ( tfGraph ) ; \nfor ( NODE_TYPE tfNode : tfNodesList ) { \nif ( ! opsToIgnore ( ) . contains ( getOpType ( tfNode ) ) ) mapNodeType ( tfNode , importState ) ; \nelse if ( isOpIgnoreException ( tfNode ) ) mapNodeType ( tfNode , importState ) ; \n} \nreturn diff ; \n} \n} \n"}
{"4022": "public class GenericTypeReflector { \nprivate static Type [ ] getExactDirectSuperTypes ( Type type ) { \nif ( type instanceof ParameterizedType || type instanceof Class ) { \nClass < ? > clazz ; \nif ( type instanceof ParameterizedType ) { \nclazz = ( Class < ? > ) ( ( ParameterizedType ) type ) . getRawType ( ) ; \n} \nelse { \nclazz = ( Class < ? > ) type ; \nif ( clazz . isArray ( ) ) return getArrayExactDirectSuperTypes ( clazz ) ; \n} \nType [ ] superInterfaces = clazz . getGenericInterfaces ( ) ; \nType superClass = clazz . getGenericSuperclass ( ) ; \nif ( superClass == null && superInterfaces . length == 0 ) { \nif ( clazz . isInterface ( ) ) { \nreturn new Type [ ] { \nObject . class } \n; \n} \n} \nType [ ] result ; \nint resultIndex ; \nif ( superClass == null ) { \nresult = new Type [ superInterfaces . length ] ; \nresultIndex = 0 ; \n} \nelse { \nresult = new Type [ superInterfaces . length + 1 ] ; \nresultIndex = 1 ; \nresult [ 0 ] = mapTypeParameters ( superClass , type ) ; \n} \nfor ( Type superInterface : superInterfaces ) { \nresult [ resultIndex ++ ] = mapTypeParameters ( superInterface , type ) ; \n} \nreturn result ; \n} \nelse if ( type instanceof TypeVariable ) { \nTypeVariable < ? > tv = ( TypeVariable < ? > ) type ; \nreturn tv . getBounds ( ) ; \n} \nelse if ( type instanceof WildcardType ) { \nreturn ( ( WildcardType ) type ) . getUpperBounds ( ) ; \n} \nelse if ( type instanceof CaptureType ) { \nreturn ( ( CaptureType ) type ) . getUpperBounds ( ) ; \n} \nelse if ( type instanceof GenericArrayType ) { \nreturn getArrayExactDirectSuperTypes ( type ) ; \n} \nelse if ( type == null ) { \nthrow new NullPointerException ( ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented type: \" + type ) ; \n} \n} \n} \n"}
{"4026": "public class ClassPopulator { \nprivate Boolean getIndexInstruction ( Class < P > clazz ) { \nIndex ind = clazz . getAnnotation ( Index . class ) ; \nUnindex unind = clazz . getAnnotation ( Unindex . class ) ; \nif ( ind != null ) { \nif ( unind != null ) throw new IllegalStateException ( \"You cannot have @Index and @Unindex on the same class: \" + clazz ) ; \n} \nif ( ind != null ) return true ; \nelse if ( unind != null ) return false ; \nelse return null ; \n} \n} \n"}
{"4031": "public class Round { \npublic void execute ( ) { \nif ( needsExecution ( ) ) { \nlog . trace ( \"Executing round: {}\" , pending ) ; \nResult < Map < com . google . cloud . datastore . Key , Entity > > fetched = fetchPending ( ) ; \ntranslated = loadEngine . translate ( fetched ) ; \nif ( loadEngine . ofy . getTransaction ( ) != null ) { \nif ( depth > 0 ) translated . now ( ) ; \n} \n} \n} \n} \n"}
{"4033": "public class ClassTranslator { \nprivate void addIndexedDiscriminators ( final Class < ? > clazz ) { \nif ( clazz == Object . class ) return ; \nthis . addIndexedDiscriminators ( clazz . getSuperclass ( ) ) ; \nfinal Subclass sub = clazz . getAnnotation ( Subclass . class ) ; \nif ( sub != null ) { \nif ( sub . index ( ) ) { \nfinal String disc = ( sub . name ( ) . length ( ) > 0 ) ? sub . name ( ) : clazz . getSimpleName ( ) ; \nthis . indexedDiscriminators . add ( StringValue . of ( disc ) ) ; \n} \n} \n} \n} \n"}
{"4046": "public class KeyMetadata { \nprivate void findKeyFields ( Class < ? > inspect , CreateContext ctx , Path path ) { \nif ( inspect == Object . class ) return ; \nfindKeyFields ( inspect . getSuperclass ( ) , ctx , path ) ; \nfor ( Field field : inspect . getDeclaredFields ( ) ) { \nif ( field . getAnnotation ( Id . class ) != null ) { \nif ( this . idMeta != null ) throw new IllegalStateException ( \"Multiple @Id fields in the class hierarchy of \" + clazz . getName ( ) ) ; \nif ( ( field . getType ( ) != Long . class ) && ( field . getType ( ) != long . class ) ) { \nif ( field . getType ( ) != String . class ) throw new IllegalStateException ( \"@Id field '\" + field . getName ( ) + \"' in \" + inspect . getName ( ) + \" must be of type Long, long, or String\" ) ; \n} \nProperty prop = new FieldProperty ( ctx . getFactory ( ) , clazz , field ) ; \nTranslator < Object , Object > translator = ctx . getTranslator ( new TypeKey < > ( prop ) , ctx , path . extend ( prop . getName ( ) ) ) ; \nthis . idMeta = new PropertyPopulator < > ( prop , translator ) ; \n} \nelse if ( field . getAnnotation ( Parent . class ) != null ) { \nif ( this . parentMeta != null ) throw new IllegalStateException ( \"Multiple @Parent fields in the class hierarchy of \" + clazz . getName ( ) ) ; \nif ( ! isAllowedParentFieldType ( field . getType ( ) ) ) throw new IllegalStateException ( \"@Parent fields must be Ref<?>, Key<?>, or datastore Key. Illegal parent: \" + field ) ; \nProperty prop = new FieldProperty ( ctx . getFactory ( ) , clazz , field ) ; \nTranslator < Object , Object > translator = ctx . getTranslator ( new TypeKey < > ( prop ) , ctx , path . extend ( prop . getName ( ) ) ) ; \nthis . parentMeta = new PropertyPopulator < > ( prop , translator ) ; \n} \n} \n} \n} \n"}
{"4051": "public class TypeFactory { \nprivate static boolean couldHaveCommonSubtype ( Type type1 , Type type2 ) { \nClass < ? > erased1 = GenericTypeReflector . erase ( type1 ) ; \nClass < ? > erased2 = GenericTypeReflector . erase ( type2 ) ; \nif ( ! erased1 . isInterface ( ) ) { \nif ( ! erased2 . isInterface ( ) ) { \nif ( ! erased1 . isAssignableFrom ( erased2 ) ) { \nif ( ! erased2 . isAssignableFrom ( erased1 ) ) { \nreturn false ; \n} \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"4068": "public class LiveRef { \nprivate Objectify ofy ( ) { \nif ( ofy == null ) ofy = ObjectifyService . ofy ( ) ; \nelse if ( ofy . getTransaction ( ) != null && ! ofy . getTransaction ( ) . isActive ( ) ) ofy = ObjectifyService . ofy ( ) ; \nreturn ofy ; \n} \n} \n"}
{"4078": "public class TriggerFuture { \n@ Override public boolean isDone ( ) { \nboolean done = this . raw . isDone ( ) ; \nif ( ! triggered ) { \nif ( done ) { \nthis . triggered = true ; \nPendingFutures . removePending ( this ) ; \nthis . trigger ( ) ; \n} \n} \nreturn done ; \n} \n} \n"}
{"4110": "public class OpenRtbJsonUtils { \npublic static void startObject ( JsonParser par ) throws IOException { \nJsonToken token = par . getCurrentToken ( ) ; \nif ( token == null ) { \ntoken = par . nextToken ( ) ; \n} \nelse if ( token == JsonToken . FIELD_NAME ) { \ntoken = par . nextToken ( ) ; \n} \nif ( token == JsonToken . START_OBJECT ) { \npar . nextToken ( ) ; \n} \nelse { \nthrow new JsonParseException ( par , \"Expected start of object\" ) ; \n} \n} \n} \n"}
{"4111": "public class OpenRtbJsonUtils { \npublic static void startArray ( JsonParser par ) throws IOException { \nJsonToken token = par . getCurrentToken ( ) ; \nif ( token == null ) { \ntoken = par . nextToken ( ) ; \n} \nelse if ( token == JsonToken . FIELD_NAME ) { \ntoken = par . nextToken ( ) ; \n} \nif ( token == JsonToken . START_ARRAY ) { \npar . nextToken ( ) ; \n} \nelse { \nthrow new JsonParseException ( par , \"Expected start of array\" ) ; \n} \n} \n} \n"}
{"4112": "public class OpenRtbJsonUtils { \npublic static JsonToken peekToken ( JsonParser par ) throws IOException { \nJsonToken token = par . getCurrentToken ( ) ; \nif ( token == null ) { \ntoken = par . nextToken ( ) ; \n} \nelse if ( token == JsonToken . FIELD_NAME ) { \ntoken = par . nextToken ( ) ; \n} \nreturn token ; \n} \n} \n"}
{"4124": "public class ConfUtils { \npublic static Map extractConfigElement ( Map conf ) { \nif ( conf . size ( ) == 1 ) { \nObject confNode = conf . get ( \"config\" ) ; \nif ( confNode != null ) { \nif ( confNode instanceof Map ) { \nconf = ( Map ) confNode ; \n} \n} \n} \nreturn conf ; \n} \n} \n"}
{"4131": "public class CloudSearchUtils { \npublic static String cleanFieldName ( String name ) { \nString lowercase = name . toLowerCase ( ) ; \nlowercase = lowercase . replaceAll ( \"[^a-z_0-9]\" , \"_\" ) ; \nif ( lowercase . length ( ) < 3 ) throw new RuntimeException ( \"Field name must be between 3 and 64 chars : \" + lowercase ) ; \nelse if ( lowercase . length ( ) > 64 ) throw new RuntimeException ( \"Field name must be between 3 and 64 chars : \" + lowercase ) ; \nif ( lowercase . equals ( \"score\" ) ) throw new RuntimeException ( \"Field name must be score\" ) ; \nreturn lowercase ; \n} \n} \n"}
{"4133": "public class CharsetIdentification { \nprivate static String getCharsetFromText ( byte [ ] content , String declaredCharset , int maxLengthCharsetDetection ) { \nString charset = null ; \nCharsetDetector charsetDetector = new CharsetDetector ( ) ; \ncharsetDetector . enableInputFilter ( true ) ; \nif ( declaredCharset != null ) charsetDetector . setDeclaredEncoding ( declaredCharset ) ; \nbyte [ ] subContent = content ; \nif ( maxLengthCharsetDetection != - 1 ) { \nif ( content . length > maxLengthCharsetDetection ) { \nsubContent = Arrays . copyOfRange ( content , 0 , maxLengthCharsetDetection ) ; \n} \n} \ncharsetDetector . setText ( subContent ) ; \ntry { \nCharsetMatch charsetMatch = charsetDetector . detect ( ) ; \ncharset = validateCharset ( charsetMatch . getName ( ) ) ; \n} \ncatch ( Exception e ) { \ncharset = null ; \n} \nreturn charset ; \n} \n} \n"}
{"4134": "public class CharsetIdentification { \nprivate static String getCharsetFromMeta ( byte buffer [ ] , int maxlength ) { \nint len = buffer . length ; \nif ( maxlength > 0 ) { \nif ( maxlength < len ) { \nlen = maxlength ; \n} \n} \nString html = new String ( buffer , 0 , len , DEFAULT_CHARSET ) ; \nDocument doc = Parser . htmlParser ( ) . parseInput ( html , \"dummy\" ) ; \nElements metaElements = doc . select ( \"meta[http-equiv=content-type], meta[charset]\" ) ; \nString foundCharset = null ; \nfor ( Element meta : metaElements ) { \nif ( meta . hasAttr ( \"http-equiv\" ) ) foundCharset = getCharsetFromContentType ( meta . attr ( \"content\" ) ) ; \nif ( foundCharset == null ) { \nif ( meta . hasAttr ( \"charset\" ) ) foundCharset = meta . attr ( \"charset\" ) ; \n} \nif ( foundCharset != null ) return foundCharset ; \n} \nreturn foundCharset ; \n} \n} \n"}
{"4135": "public class SiteMapParserBolt { \nprivate final boolean sniff ( byte [ ] content ) { \nbyte [ ] beginning = content ; \nif ( content . length > maxOffsetGuess ) { \nif ( maxOffsetGuess > 0 ) { \nbeginning = Arrays . copyOfRange ( content , 0 , maxOffsetGuess ) ; \n} \n} \nint position = Bytes . indexOf ( beginning , clue ) ; \nif ( position != - 1 ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4138": "public class CookieConverter { \npublic static List < Cookie > getCookies ( String [ ] cookiesStrings , URL targetURL ) { \nArrayList < Cookie > list = new ArrayList < Cookie > ( ) ; \nfor ( String cs : cookiesStrings ) { \nString name = null ; \nString value = null ; \nString expires = null ; \nString domain = null ; \nString path = null ; \nboolean secure = false ; \nString [ ] tokens = cs . split ( \";\" ) ; \nint equals = tokens [ 0 ] . indexOf ( \"=\" ) ; \nname = tokens [ 0 ] . substring ( 0 , equals ) ; \nvalue = tokens [ 0 ] . substring ( equals + 1 ) ; \nfor ( int i = 1 ; \ni < tokens . length ; \ni ++ ) { \nString ti = tokens [ i ] . trim ( ) ; \nif ( ti . equalsIgnoreCase ( \"secure\" ) ) secure = true ; \nif ( ti . toLowerCase ( ) . startsWith ( \"path=\" ) ) { \npath = ti . substring ( 5 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"domain=\" ) ) { \ndomain = ti . substring ( 7 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"expires=\" ) ) { \nexpires = ti . substring ( 8 ) ; \n} \n} \nBasicClientCookie cookie = new BasicClientCookie ( name , value ) ; \nif ( domain != null ) { \ncookie . setDomain ( domain ) ; \nif ( ! checkDomainMatchToUrl ( domain , targetURL . getHost ( ) ) ) continue ; \n} \nif ( path != null ) { \ncookie . setPath ( path ) ; \nif ( ! path . equals ( \"\" ) && ! path . equals ( \"/\" ) ) { \nif ( ! targetURL . getPath ( ) . startsWith ( path ) ) continue ; \n} \n} \nif ( secure ) { \ncookie . setSecure ( secure ) ; \nif ( ! targetURL . getProtocol ( ) . equalsIgnoreCase ( \"https\" ) ) continue ; \n} \nif ( expires != null ) { \ntry { \nDate expirationDate = DATE_FORMAT . parse ( expires ) ; \ncookie . setExpiryDate ( expirationDate ) ; \nif ( cookie . isExpired ( new Date ( ) ) ) continue ; \ncookie . setExpiryDate ( expirationDate ) ; \n} \ncatch ( ParseException e ) { \n} \n} \nlist . add ( cookie ) ; \n} \nreturn list ; \n} \n} \n"}
{"4142": "public class RobotsTags { \npublic void extractMetaTags ( DocumentFragment doc ) throws XPathExpressionException { \nNodeList nodes = ( NodeList ) expression . evaluate ( doc , XPathConstants . NODESET ) ; \nif ( nodes == null ) return ; \nint numNodes = nodes . getLength ( ) ; \nfor ( int i = 0 ; \ni < numNodes ; \ni ++ ) { \nNode n = ( Node ) nodes . item ( i ) ; \nboolean isRobots = false ; \nString content = null ; \nNamedNodeMap attrs = n . getAttributes ( ) ; \nfor ( int att = 0 ; \natt < attrs . getLength ( ) ; \natt ++ ) { \nNode keyval = attrs . item ( att ) ; \nif ( \"name\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) ) { \nif ( \"robots\" . equalsIgnoreCase ( keyval . getNodeValue ( ) ) ) { \nisRobots = true ; \ncontinue ; \n} \n} \nif ( \"content\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) ) { \ncontent = keyval . getNodeValue ( ) ; \ncontinue ; \n} \n} \nif ( isRobots ) { \nif ( content != null ) { \nString [ ] vals = content . split ( \" *, *\" ) ; \nparseValues ( vals ) ; \nreturn ; \n} \n} \n} \n} \n} \n"}
{"4147": "public class BasicURLNormalizer { \nprivate String processQueryElements ( String urlToFilter ) { \ntry { \nURL url = new URL ( urlToFilter ) ; \nString query = url . getQuery ( ) ; \nString path = url . getPath ( ) ; \nif ( path . contains ( \";\" ) ) { \nString [ ] pathElements = path . split ( \"/\" ) ; \nString last = pathElements [ pathElements . length - 1 ] ; \nint semicolon = last . indexOf ( \";\" ) ; \nif ( semicolon != - 1 ) { \npathElements [ pathElements . length - 1 ] = last . substring ( 0 , semicolon ) ; \nString params = last . substring ( semicolon + 1 ) . replaceAll ( \";\" , \"&\" ) ; \nif ( query == null ) { \nquery = params ; \n} \nelse { \nquery += \"&\" + params ; \n} \nStringBuilder newPath = new StringBuilder ( ) ; \nfor ( String p : pathElements ) { \nif ( StringUtils . isNotBlank ( p ) ) { \nnewPath . append ( \"/\" ) . append ( p ) ; \n} \n} \npath = newPath . toString ( ) ; \n} \n} \nif ( StringUtils . isEmpty ( query ) ) { \nreturn urlToFilter ; \n} \nList < NameValuePair > pairs = URLEncodedUtils . parse ( query , StandardCharsets . UTF_8 ) ; \nIterator < NameValuePair > pairsIterator = pairs . iterator ( ) ; \nwhile ( pairsIterator . hasNext ( ) ) { \nNameValuePair param = pairsIterator . next ( ) ; \nif ( queryElementsToRemove . contains ( param . getName ( ) ) ) { \npairsIterator . remove ( ) ; \n} \nelse if ( removeHashes ) { \nif ( param . getValue ( ) != null ) { \nMatcher m = thirtytwobithash . matcher ( param . getValue ( ) ) ; \nif ( m . matches ( ) ) { \npairsIterator . remove ( ) ; \n} \n} \n} \n} \nStringBuilder newFile = new StringBuilder ( ) ; \nif ( StringUtils . isNotBlank ( path ) ) { \nnewFile . append ( path ) ; \n} \nif ( ! pairs . isEmpty ( ) ) { \nCollections . sort ( pairs , comp ) ; \nString newQueryString = URLEncodedUtils . format ( pairs , StandardCharsets . UTF_8 ) ; \nnewFile . append ( '?' ) . append ( newQueryString ) ; \n} \nif ( url . getRef ( ) != null ) { \nnewFile . append ( '#' ) . append ( url . getRef ( ) ) ; \n} \nreturn new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , newFile . toString ( ) ) . toString ( ) ; \n} \ncatch ( MalformedURLException e ) { \nLOG . warn ( \"Invalid urlToFilter {}. {}\" , urlToFilter , e ) ; \nreturn null ; \n} \n} \n} \n"}
{"4151": "public class AbstractQueryingSpout { \nprivate boolean triggerQueries ( ) { \nif ( timeLastQueryReceived != 0 ) { \nif ( maxDelayBetweenQueries > 0 ) { \nlong difference = System . currentTimeMillis ( ) - timeLastQueryReceived ; \nif ( difference > maxDelayBetweenQueries ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"4153": "public class DOMBuilder { \nprotected void append ( Node newNode ) throws org . xml . sax . SAXException { \nNode currentNode = m_currentNode ; \nif ( null != currentNode ) { \ncurrentNode . appendChild ( newNode ) ; \n} \nelse if ( null != m_docFrag ) { \nm_docFrag . appendChild ( newNode ) ; \n} \nelse { \nboolean ok = true ; \nshort type = newNode . getNodeType ( ) ; \nif ( type == Node . TEXT_NODE ) { \nString data = newNode . getNodeValue ( ) ; \nif ( null != data ) { \nif ( data . trim ( ) . length ( ) > 0 ) { \nthrow new org . xml . sax . SAXException ( \"Warning: can't output text before document element!  Ignoring...\" ) ; \n} \n} \nok = false ; \n} \nelse if ( type == Node . ELEMENT_NODE ) { \nif ( m_doc . getDocumentElement ( ) != null ) { \nthrow new org . xml . sax . SAXException ( \"Can't have more than one root on a DOM!\" ) ; \n} \n} \nif ( ok ) { \nm_doc . appendChild ( newNode ) ; \n} \n} \n} \n} \n"}
{"4156": "public class DOMBuilder { \n@ Override public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { \nif ( ch == null || start < 0 || length >= ( ch . length - start ) ) { \nreturn ; \n} \nelse if ( length < 0 ) { \nreturn ; \n} \nappend ( m_doc . createComment ( new String ( ch , start , length ) ) ) ; \n} \n} \n"}
{"4157": "public class DOMBuilder { \npublic void cdata ( char ch [ ] , int start , int length ) { \nif ( isOutsideDocElem ( ) ) { \nif ( XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) { \nreturn ; \n} \n} \nString s = new String ( ch , start , length ) ; \nNode n = m_currentNode . getLastChild ( ) ; \nif ( n instanceof CDATASection ) { \n( ( CDATASection ) n ) . appendData ( s ) ; \n} \nelse if ( n instanceof Comment ) { \n( ( Comment ) n ) . appendData ( s ) ; \n} \n} \n} \n"}
{"4191": "public class DateRange { \npublic void extend ( DateRange dr ) { \nboolean localEmpty = isEmpty ; \nif ( localEmpty ) setStart ( dr . getStart ( ) ) ; \nelse if ( dr . getStart ( ) . before ( getStart ( ) ) ) setStart ( dr . getStart ( ) ) ; \nif ( localEmpty ) setEnd ( dr . getEnd ( ) ) ; \nelse if ( getEnd ( ) . before ( dr . getEnd ( ) ) ) setEnd ( dr . getEnd ( ) ) ; \n} \n} \n"}
{"4206": "public class CatalogWatcher { \npublic void processEvents ( ) { \nif ( ! enable ) return ; \nfor ( ; \n; \n) { \nWatchKey key ; \ntry { \nkey = watcher . take ( ) ; \n} \ncatch ( InterruptedException x ) { \nreturn ; \n} \nPath dir = keys . get ( key ) ; \nif ( dir == null ) { \nSystem . err . println ( \"WatchKey not recognized!!\" ) ; \ncontinue ; \n} \nfor ( WatchEvent < ? > event : key . pollEvents ( ) ) { \nWatchEvent . Kind kind = event . kind ( ) ; \nif ( kind == OVERFLOW ) { \ncontinue ; \n} \nWatchEvent < Path > ev = cast ( event ) ; \nPath name = ev . context ( ) ; \nPath child = dir . resolve ( name ) ; \nSystem . out . format ( \"%s: %s%n\" , event . kind ( ) . name ( ) , child ) ; \nif ( recursive ) { \nif ( kind == ENTRY_CREATE ) { \ntry { \nif ( Files . isDirectory ( child , NOFOLLOW_LINKS ) ) { \nregisterAll ( child ) ; \n} \n} \ncatch ( IOException x ) { \n} \n} \n} \n} \nboolean valid = key . reset ( ) ; \nif ( ! valid ) { \nkeys . remove ( key ) ; \nif ( keys . isEmpty ( ) ) { \nbreak ; \n} \n} \n} \n} \n} \n"}
{"4208": "public class FeatureDatasetFactoryManager { \nstatic public FeatureDataset open ( FeatureType wantFeatureType , String location , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { \nif ( location . startsWith ( DataFactory . SCHEME ) ) { \nDataFactory . Result result = new DataFactory ( ) . openFeatureDataset ( wantFeatureType , location , task ) ; \nerrlog . format ( \"%s\" , result . errLog ) ; \nif ( ! featureTypeOk ( wantFeatureType , result . featureType ) ) { \nerrlog . format ( \"wanted %s but dataset is of type %s%n\" , wantFeatureType , result . featureType ) ; \nresult . close ( ) ; \nreturn null ; \n} \nreturn result . featureDataset ; \n} \nelse if ( location . startsWith ( CdmrFeatureDataset . SCHEME ) ) { \nOptional < FeatureDataset > opt = CdmrFeatureDataset . factory ( wantFeatureType , location ) ; \nif ( opt . isPresent ( ) ) return opt . get ( ) ; \nerrlog . format ( \"%s\" , opt . getErrorMessage ( ) ) ; \nreturn null ; \n} \nelse if ( location . startsWith ( ucar . nc2 . ft . point . collection . CompositeDatasetFactory . SCHEME ) ) { \nString spec = location . substring ( CompositeDatasetFactory . SCHEME . length ( ) ) ; \nMFileCollectionManager dcm = MFileCollectionManager . open ( spec , spec , null , errlog ) ; \nreturn CompositeDatasetFactory . factory ( location , wantFeatureType , dcm , errlog ) ; \n} \nDatasetUrl durl = DatasetUrl . findDatasetUrl ( location ) ; \nif ( durl . serviceType == null ) { \nOptional < FeatureDatasetCoverage > opt = CoverageDatasetFactory . openGrib ( location ) ; \nif ( opt . isPresent ( ) ) { \nreturn opt . get ( ) ; \n} \nelse if ( ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NOT_GRIB_FILE ) ) { \nif ( ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NO_GRIB_CLASS ) ) { \nerrlog . format ( \"%s%n\" , opt . getErrorMessage ( ) ) ; \nreturn null ; \n} \n} \n} \nNetcdfDataset ncd = NetcdfDataset . acquireDataset ( durl , true , task ) ; \nFeatureDataset fd = wrap ( wantFeatureType , ncd , task , errlog ) ; \nif ( fd == null ) ncd . close ( ) ; \nreturn fd ; \n} \n} \n"}
{"4209": "public class FeatureDatasetFactoryManager { \nstatic public FeatureDataset wrap ( FeatureType wantFeatureType , NetcdfDataset ncd , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { \nif ( debug ) System . out . println ( \"wrap \" + ncd . getLocation ( ) + \" want = \" + wantFeatureType ) ; \nif ( wantFeatureType == null ) { \nreturn wrapUnknown ( ncd , task , errlog ) ; \n} \nelse if ( wantFeatureType == FeatureType . ANY ) { \nreturn wrapUnknown ( ncd , task , errlog ) ; \n} \nObject analysis = null ; \nFeatureDatasetFactory useFactory = null ; \nfor ( Factory fac : factoryList ) { \nif ( ! featureTypeOk ( wantFeatureType , fac . featureType ) ) continue ; \nif ( debug ) System . out . println ( \" wrap try factory \" + fac . factory . getClass ( ) . getName ( ) ) ; \nanalysis = fac . factory . isMine ( wantFeatureType , ncd , errlog ) ; \nif ( analysis != null ) { \nuseFactory = fac . factory ; \nbreak ; \n} \n} \nif ( null == useFactory ) { \nerrlog . format ( \"**Failed to find FeatureDatasetFactory for= %s datatype=%s%n\" , ncd . getLocation ( ) , wantFeatureType ) ; \nreturn null ; \n} \nreturn useFactory . open ( wantFeatureType , ncd , analysis , task , errlog ) ; \n} \n} \n"}
{"4217": "public class CatalogManager { \nprivate void addGlobalServices ( CatalogBuilder cat ) { \nSet < String > allServiceNames = new HashSet < > ( ) ; \nfindServices ( cat . getDatasets ( ) , allServiceNames ) ; \nif ( ! allServiceNames . isEmpty ( ) ) { \nList < Service > servicesMissing = new ArrayList < > ( ) ; \nfor ( String name : allServiceNames ) { \nif ( cat . hasServiceInDataset ( name ) ) continue ; \nService s = globalServices . findGlobalService ( name ) ; \nif ( s != null ) servicesMissing . add ( s ) ; \n} \nservicesMissing . forEach ( cat :: addService ) ; \n} \nfor ( DatasetBuilder node : cat . getDatasets ( ) ) { \nString sname = ( String ) node . getFldOrInherited ( Dataset . ServiceName ) ; \nString urlPath = ( String ) node . get ( Dataset . UrlPath ) ; \nString ftypeS = ( String ) node . getFldOrInherited ( Dataset . FeatureType ) ; \nif ( sname == null && urlPath != null ) { \nif ( ftypeS != null ) { \nService s = globalServices . getStandardServices ( ftypeS ) ; \nif ( s != null ) { \nnode . put ( Dataset . ServiceName , s . getName ( ) ) ; \ncat . addService ( s ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4219": "public class HttpClientManager { \n@ Urlencoded @ Deprecated public static String getContentAsString ( HTTPSession session , String urlencoded ) throws IOException { \nHTTPSession useSession = session ; \ntry { \nif ( useSession == null ) useSession = HTTPFactory . newSession ( urlencoded ) ; \ntry ( HTTPMethod m = HTTPFactory . Get ( useSession , urlencoded ) ) { \nm . execute ( ) ; \nreturn m . getResponseAsString ( ) ; \n} \n} \nfinally { \nif ( session == null ) { \nif ( useSession != null ) useSession . close ( ) ; \n} \n} \n} \n} \n"}
{"4222": "public class InvDatasetFcGrib { \n@ Override public CatalogBuilder makeCatalog ( String match , String reqPath , URI catURI ) throws IOException { \nStateGrib localState = ( StateGrib ) checkState ( ) ; \nif ( localState == null ) return null ; \nif ( localState . gribCollection == null ) return null ; \ntry { \nif ( match == null ) { \nreturn makeCatalogTop ( catURI , localState ) ; \n} \nelse if ( match . length ( ) == 0 ) { \nreturn makeCatalogTop ( catURI , localState ) ; \n} \nif ( localState . gribCollection instanceof PartitionCollectionImmutable ) { \nString [ ] paths = match . split ( \"/\" ) ; \nPartitionCollectionImmutable pc = ( PartitionCollectionImmutable ) localState . gribCollection ; \nreturn makeCatalogFromPartition ( pc , paths , 0 , catURI ) ; \n} \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \nlogger . error ( \"Error making catalog for \" + configPath , e ) ; \n} \nreturn null ; \n} \n} \n"}
{"4228": "public class NOWRadheader { \nint readTop ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint pos = 0 ; \nraf . seek ( pos ) ; \nint readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nint rc = raf . read ( b ) ; \nif ( rc != readLen ) { \nreturn 0 ; \n} \nif ( ( convertunsignedByte2Short ( b [ 0 ] ) != 0x00 ) || ( convertunsignedByte2Short ( b [ 1 ] ) != 0xF0 ) ) { \nreturn 0 ; \n} \nelse if ( convertunsignedByte2Short ( b [ 2 ] ) != 0x09 ) { \nreturn 0 ; \n} \nString pidd = new String ( b , 15 , 5 , CDM . utf8Charset ) ; \nif ( pidd . contains ( \"NOWRA\" ) || pidd . contains ( \"USRAD\" ) || pidd . contains ( \"NEX\" ) ) { \nreturn 1 ; \n} \nelse { \nreturn 0 ; \n} \n} \n} \n"}
{"4232": "public class N3iosp { \npublic static String makeValidNetcdfObjectName ( String name ) { \nStringBuilder sb = new StringBuilder ( name ) ; \nwhile ( sb . length ( ) > 0 ) { \nint cp = sb . codePointAt ( 0 ) ; \nif ( cp <= 0x7f ) { \nif ( ! ( 'A' <= cp && cp <= 'Z' ) && ! ( 'a' <= cp && cp <= 'z' ) && ! ( '0' <= cp && cp <= '9' ) ) { \nif ( cp != '_' ) { \nsb . deleteCharAt ( 0 ) ; \ncontinue ; \n} \n} \n} \nbreak ; \n} \nfor ( int pos = 1 ; \npos < sb . length ( ) ; \n++ pos ) { \nint cp = sb . codePointAt ( pos ) ; \nif ( cp <= 0x7F ) { \nif ( cp < ' ' || cp > 0x7E ) { \nsb . deleteCharAt ( pos ) ; \n-- pos ; \n} \nelse if ( cp == '/' ) { \nsb . deleteCharAt ( pos ) ; \n-- pos ; \n} \n} \n} \nwhile ( sb . length ( ) > 0 ) { \nint cp = sb . codePointAt ( sb . length ( ) - 1 ) ; \nif ( cp <= 0x7f && Character . isWhitespace ( cp ) ) { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \nelse { \nbreak ; \n} \n} \nif ( sb . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( String . format ( \"Illegal NetCDF object name: '%s'\" , name ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"4249": "public class McIDASLookup { \npublic final boolean isVerticalCoordinate ( GridRecord gr ) { \nif ( cust != null ) { \nreturn cust . isVerticalCoordinate ( gr . getLevelType1 ( ) ) ; \n} \nint type = gr . getLevelType1 ( ) ; \nif ( ( ( McIDASGridRecord ) gr ) . hasGribInfo ( ) ) { \nif ( type == 20 ) { \nreturn true ; \n} \nif ( type == 100 ) { \nreturn true ; \n} \nif ( type == 101 ) { \nreturn true ; \n} \nif ( type >= 103 ) { \nif ( type <= 128 ) { \nreturn true ; \n} \n} \nif ( type == 141 ) { \nreturn true ; \n} \nif ( type == 160 ) { \nreturn true ; \n} \n} \nelse if ( getLevelUnit ( gr ) . equals ( \"hPa\" ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4272": "public class LogReader { \npublic void readAll ( File dir , FileFilter ff , Closure closure , LogFilter logf , Stats stat ) throws IOException { \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) { \nSystem . out . printf ( \"Dir has no files= %s%n\" , dir ) ; \nreturn ; \n} \nList < File > list = Arrays . asList ( files ) ; \nCollections . sort ( list ) ; \nfor ( File f : list ) { \nif ( ff != null ) { \nif ( ! ff . accept ( f ) ) continue ; \n} \nif ( f . isDirectory ( ) ) readAll ( f , ff , closure , logf , stat ) ; \nelse scanLogFile ( f , closure , logf , stat ) ; \n} \n} \n} \n"}
{"4273": "public class LogReader { \npublic void scanLogFile ( File file , Closure closure , LogFilter logf , Stats stat ) throws IOException { \ntry ( InputStream ios = new FileInputStream ( file ) ) { \nSystem . out . printf ( \"-----Reading %s %n\" , file . getPath ( ) ) ; \nBufferedReader dataIS = new BufferedReader ( new InputStreamReader ( ios , CDM . utf8Charset ) , 40 * 1000 ) ; \nint total = 0 ; \nint count = 0 ; \nwhile ( ( maxLines < 0 ) || ( count < maxLines ) ) { \nLog log = parser . nextLog ( dataIS ) ; \nif ( log == null ) break ; \ntotal ++ ; \nif ( logf != null ) { \nif ( ! logf . pass ( log ) ) continue ; \n} \nclosure . process ( log ) ; \ncount ++ ; \n} \nif ( stat != null ) { \nstat . total += total ; \nstat . passed += count ; \n} \nSystem . out . printf ( \"----- %s total requests=%d passed=%d %n\" , file . getPath ( ) , total , count ) ; \n} \n} \n} \n"}
{"4274": "public class GempakGridReader { \npublic int getGridPackingType ( int gridNumber ) throws IOException { \nint irow = 1 ; \nif ( gridNumber < 1 ) { \nlogWarning ( \"bad grid number \" + gridNumber ) ; \nreturn - 9 ; \n} \nelse if ( gridNumber > dmLabel . kcol ) { \nlogWarning ( \"bad grid number \" + gridNumber ) ; \nreturn - 9 ; \n} \nint iprt = getPartNumber ( \"GRID\" ) ; \nif ( iprt == 0 ) { \nlogWarning ( \"couldn't find part: GRID\" ) ; \nreturn - 10 ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( part . ktyprt != MDGRID ) { \nlogWarning ( \"Not a valid type: \" + GempakUtil . getDataType ( part . ktyprt ) ) ; \nreturn - 21 ; \n} \nint ilenhd = part . klnhdr ; \nint ipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( gridNumber - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nint istart = DM_RINT ( ipoint ) ; \nif ( istart == 0 ) { \nreturn - 15 ; \n} \nint length = DM_RINT ( istart ) ; \nint isword = istart + 1 ; \nif ( length <= ilenhd ) { \nlogWarning ( \"length (\" + length + \") is less than header length (\" + ilenhd + \")\" ) ; \nreturn - 15 ; \n} \nelse if ( Math . abs ( length ) > 10000000 ) { \nlogWarning ( \"length is huge: \" + length ) ; \nreturn - 34 ; \n} \nint [ ] header = new int [ ilenhd ] ; \nDM_RINT ( isword , header ) ; \nisword += ilenhd ; \nreturn DM_RINT ( isword ) ; \n} \n} \n"}
{"4278": "public class GempakGridReader { \nprivate synchronized float [ ] DP_UGRB ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalScale ) throws IOException { \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfloat [ ] grid = new float [ kxky ] ; \nif ( nbits <= 1 ) { \nreturn grid ; \n} \nelse if ( nbits > 31 ) { \nreturn grid ; \n} \nif ( scale == 0. ) { \nreturn grid ; \n} \nint imax = ( int ) ( Math . pow ( 2 , nbits ) - 1 ) ; \nint iword = 0 ; \nint ibit = 1 ; \nfor ( int i = 0 ; \ni < kxky ; \ni ++ ) { \nint jshft = nbits + ibit - 33 ; \nint idat = 0 ; \nidat = ( jshft < 0 ) ? idata [ iword ] >>> Math . abs ( jshft ) : idata [ iword ] << jshft ; \nidat = idat & imax ; \nif ( jshft > 0 ) { \njshft -= 32 ; \nint idat2 = 0 ; \nidat2 = idata [ iword + 1 ] >>> Math . abs ( jshft ) ; \nidat = idat | idat2 ; \n} \nif ( ( idat == imax ) && misflg ) { \ngrid [ i ] = RMISSD ; \n} \nelse { \ngrid [ i ] = ( qmin + idat * scale ) * scaleFactor ; \n} \nibit += nbits ; \nif ( ibit > 32 ) { \nibit -= 32 ; \niword ++ ; \n} \n} \nreturn grid ; \n} \n} \n"}
{"4295": "public class CDMUtil { \nstatic public int [ ] computeEffectiveShape ( List < DapDimension > dimset ) { \nif ( dimset == null ) return new int [ 0 ] ; \nelse if ( dimset . size ( ) == 0 ) return new int [ 0 ] ; \nint effectiverank = dimset . size ( ) ; \nint [ ] shape = new int [ effectiverank ] ; \nfor ( int i = 0 ; \ni < effectiverank ; \ni ++ ) { \nshape [ i ] = ( int ) dimset . get ( i ) . getSize ( ) ; \n} \nreturn shape ; \n} \n} \n"}
{"4307": "public class StationTimeSeriesCollectionImpl { \n@ Override public PointFeatureCollection flatten ( List < String > stationNames , CalendarDateRange dateRange , List < VariableSimpleIF > varList ) throws IOException { \nif ( stationNames == null ) return new StationTimeSeriesCollectionFlattened ( this , dateRange ) ; \nelse if ( stationNames . size ( ) == 0 ) return new StationTimeSeriesCollectionFlattened ( this , dateRange ) ; \nList < StationFeature > subsetStations = getStationHelper ( ) . getStationFeaturesFromNames ( stationNames ) ; \nreturn new StationTimeSeriesCollectionFlattened ( new StationSubset ( this , subsetStations ) , dateRange ) ; \n} \n} \n"}
{"4336": "public class GridServiceProvider { \npublic boolean isMissingXY ( Variable v2 , int timeIdx , int ensIdx , int levIdx ) throws InvalidRangeException { \nGridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; \nif ( timeIdx < 0 ) { \nthrow new InvalidRangeException ( \"timeIdx=\" + timeIdx ) ; \n} \nelse if ( timeIdx >= pv . getNTimes ( ) ) { \nthrow new InvalidRangeException ( \"timeIdx=\" + timeIdx ) ; \n} \nif ( levIdx < 0 ) { \nthrow new InvalidRangeException ( \"levIdx=\" + levIdx ) ; \n} \nelse if ( levIdx >= pv . getVertNlevels ( ) ) { \nthrow new InvalidRangeException ( \"levIdx=\" + levIdx ) ; \n} \nif ( ensIdx < 0 ) { \nthrow new InvalidRangeException ( \"ensIdx=\" + ensIdx ) ; \n} \nelse if ( ensIdx >= pv . getNEnsembles ( ) ) { \nthrow new InvalidRangeException ( \"ensIdx=\" + ensIdx ) ; \n} \nreturn ( null == pv . findRecord ( ensIdx , timeIdx , levIdx ) ) ; \n} \n} \n"}
{"4337": "public class DtCoverageCS { \npublic LatLonRect getLatLonBoundingBox ( ) { \nif ( llbb == null ) { \nif ( getXHorizAxis ( ) instanceof CoordinateAxis2D ) { \nif ( getYHorizAxis ( ) instanceof CoordinateAxis2D ) { \nreturn null ; \n} \n} \nCoordinateAxis horizXaxis = getXHorizAxis ( ) ; \nCoordinateAxis horizYaxis = getYHorizAxis ( ) ; \nif ( isLatLon ( ) ) { \ndouble startLat = horizYaxis . getMinValue ( ) ; \ndouble startLon = horizXaxis . getMinValue ( ) ; \ndouble deltaLat = horizYaxis . getMaxValue ( ) - startLat ; \ndouble deltaLon = horizXaxis . getMaxValue ( ) - startLon ; \nLatLonPoint llpt = new LatLonPointImpl ( startLat , startLon ) ; \nllbb = new LatLonRect ( llpt , deltaLat , deltaLon ) ; \n} \nelse { \nProjectionImpl dataProjection = getProjection ( ) ; \nProjectionRect bb = getBoundingBox ( ) ; \nif ( bb != null ) llbb = dataProjection . projToLatLonBB ( bb ) ; \n} \n} \nreturn llbb ; \n} \n} \n"}
{"4347": "public class Slice { \npublic Slice finish ( ) throws DapException { \nif ( this . first == UNDEFINED ) this . first = 0 ; \nif ( this . stride == UNDEFINED ) this . stride = 1 ; \nif ( this . stop == UNDEFINED ) { \nif ( this . maxsize != UNDEFINED ) this . stop = this . maxsize ; \n} \nif ( this . stop == UNDEFINED ) { \nif ( this . maxsize == UNDEFINED ) this . stop = this . first + 1 ; \n} \nif ( this . maxsize == UNDEFINED ) { \nif ( this . stop != UNDEFINED ) this . maxsize = this . stop ; \n} \nassert ( this . first != UNDEFINED ) ; \nassert ( this . stride != UNDEFINED ) ; \nassert ( this . stop != UNDEFINED ) ; \nif ( this . first > this . maxsize ) throw new DapException ( \"Slice: first index > max size\" ) ; \nif ( this . stop > ( this . maxsize + 1 ) ) throw new DapException ( \"Slice: stop > max size\" ) ; \nif ( this . first < 0 ) throw new DapException ( \"Slice: first index < 0\" ) ; \nif ( this . stop < 0 ) throw new DapException ( \"Slice: stop index < 0\" ) ; \nif ( this . stride <= 0 ) throw new DapException ( \"Slice: stride index <= 0\" ) ; \nif ( this . first > this . stop ) throw new DapException ( \"Slice: first index > last\" ) ; \nreturn this ; \n} \n} \n"}
{"4352": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 ) { \nint stop = buf0 . limit ( ) ; \nint size = stop + 8 ; \nint savepos = buf0 . position ( ) ; \nassert savepos == 0 ; \nbyte [ ] bytes = new byte [ size ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . get ( bytes , 0 , stop ) ; \nbuf0 . position ( savepos ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \nbuf . position ( 0 ) ; \nbuf . limit ( size ) ; \nint i = 0 ; \ntry { \nfor ( i = 0 ; \nbuf . position ( ) < stop ; \ni ++ ) { \nsavepos = buf . position ( ) ; \nint iv = buf . getInt ( ) ; \nbuf . position ( savepos ) ; \nlong lv = buf . getLong ( ) ; \nbuf . position ( savepos ) ; \nshort sv = buf . getShort ( ) ; \nbuf . position ( savepos ) ; \nbyte b = buf . get ( ) ; \nint ub = ( ( int ) b ) & 0x000000FF ; \nlong uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; \nint usv = ( ( int ) sv ) & 0xFFFF ; \nint ib = ( int ) b ; \nchar c = ( char ) ub ; \nString s = Character . toString ( c ) ; \nif ( c == '\\r' ) s = \"\\\\r\" ; \nelse if ( c == '\\n' ) s = \"\\\\n\" ; \nelse if ( c < ' ' ) s = \"?\" ; \nelse if ( c >= 0x7f ) s = \"?\" ; \nSystem . err . printf ( \"[%03d] %02x %03d %4d '%s'\" , i , ub , ub , ib , s ) ; \nSystem . err . printf ( \"\\t%12d 0x%08x\" , iv , uiv ) ; \nSystem . err . printf ( \"\\t%5d\\t0x%04x\" , sv , usv ) ; \nSystem . err . println ( ) ; \nSystem . err . flush ( ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"failure:\" + e ) ; \n} \nfinally { \nSystem . err . flush ( ) ; \nSystem . err . flush ( ) ; \n} \n} \n} \n"}
{"4373": "public class GridHorizCoordSys { \nprivate double getGridSpacingInKm ( String type ) { \ndouble value = gds . getDouble ( type ) ; \nif ( Double . isNaN ( value ) ) return value ; \nString gridUnit = gds . getParam ( GridDefRecord . GRID_UNITS ) ; \nSimpleUnit unit ; \nif ( gridUnit == null || gridUnit . length ( ) == 0 ) { \nunit = SimpleUnit . meterUnit ; \n} \nelse { \nunit = SimpleUnit . factory ( gridUnit ) ; \n} \nif ( unit != null ) { \nif ( SimpleUnit . isCompatible ( unit . getUnitString ( ) , \"km\" ) ) { \nvalue = unit . convertTo ( value , SimpleUnit . kmUnit ) ; \n} \n} \nreturn value ; \n} \n} \n"}
{"4376": "public class GridHorizCoordSys { \nprivate boolean makeProjection ( NetcdfFile ncfile , int projType ) { \nswitch ( projType ) { \ncase GridTableLookup . RotatedLatLon : makeRotatedLatLon ( ncfile ) ; \nbreak ; \ncase GridTableLookup . PolarStereographic : makePS ( ) ; \nbreak ; \ncase GridTableLookup . LambertConformal : makeLC ( ) ; \nbreak ; \ncase GridTableLookup . Mercator : makeMercator ( ) ; \nbreak ; \ncase GridTableLookup . Orthographic : makeMSGgeostationary ( ) ; \nbreak ; \ncase GridTableLookup . Curvilinear : makeCurvilinearAxis ( ncfile ) ; \nbreak ; \ndefault : throw new UnsupportedOperationException ( \"unknown projection = \" + gds . getInt ( GridDefRecord . GRID_TYPE ) ) ; \n} \nVariable v = new Variable ( ncfile , g , null , grid_name ) ; \nv . setDataType ( DataType . CHAR ) ; \nv . setDimensions ( \"\" ) ; \nchar [ ] data = new char [ ] { \n'd' } \n; \nArray dataArray = Array . factory ( DataType . CHAR , new int [ 0 ] , data ) ; \nv . setCachedData ( dataArray , false ) ; \nfor ( Attribute att : attributes ) v . addAttribute ( att ) ; \nv . addAttribute ( new Attribute ( GridCF . EARTH_SHAPE , shape_name ) ) ; \ndouble radius_spherical_earth = gds . getDouble ( GridDefRecord . RADIUS_SPHERICAL_EARTH ) ; \nif ( Double . isNaN ( radius_spherical_earth ) ) radius_spherical_earth = gds . getDouble ( \"radius_spherical_earth\" ) ; \nif ( ! Double . isNaN ( radius_spherical_earth ) ) { \nif ( radius_spherical_earth < 10000.00 ) radius_spherical_earth *= 1000.0 ; \nv . addAttribute ( new Attribute ( GridCF . EARTH_RADIUS , radius_spherical_earth ) ) ; \n} \nelse { \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( \"major_axis_earth\" ) ; \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \nif ( ! Double . isNaN ( major_axis ) ) { \nif ( ! Double . isNaN ( minor_axis ) ) { \nv . addAttribute ( new Attribute ( GridCF . SEMI_MAJOR_AXIS , major_axis ) ) ; \nv . addAttribute ( new Attribute ( GridCF . SEMI_MINOR_AXIS , minor_axis ) ) ; \n} \n} \n} \naddGDSparams ( v ) ; \nncfile . addVariable ( g , v ) ; \nreturn true ; \n} \n} \n"}
{"4383": "public class GridHorizCoordSys { \nprivate void setDxDy ( double startx , double starty , ProjectionImpl proj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nif ( Double . isNaN ( Lo2 ) ) { \nreturn ; \n} \nelse if ( Double . isNaN ( La2 ) ) { \nreturn ; \n} \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nProjectionPointImpl end = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \ndouble dx = Math . abs ( end . getX ( ) - startx ) / ( gds . getInt ( GridDefRecord . NX ) - 1 ) ; \ndouble dy = Math . abs ( end . getY ( ) - starty ) / ( gds . getInt ( GridDefRecord . NY ) - 1 ) ; \ngds . addParam ( GridDefRecord . DX , String . valueOf ( dx ) ) ; \ngds . addParam ( GridDefRecord . DY , String . valueOf ( dy ) ) ; \ngds . addParam ( GridDefRecord . GRID_UNITS , \"km\" ) ; \n} \n} \n"}
{"4391": "public class UnidataPointDatasetHelper { \nstatic public String getCoordinateName ( NetcdfDataset ds , AxisType a ) { \nList < Variable > varList = ds . getVariables ( ) ; \nfor ( Variable v : varList ) { \nif ( v instanceof Structure ) { \nList < Variable > vars = ( ( Structure ) v ) . getVariables ( ) ; \nfor ( Variable vs : vars ) { \nString axisType = ds . findAttValueIgnoreCase ( vs , _Coordinate . AxisType , null ) ; \nif ( axisType != null ) { \nif ( axisType . equals ( a . toString ( ) ) ) return vs . getShortName ( ) ; \n} \n} \n} \nelse { \nString axisType = ds . findAttValueIgnoreCase ( v , _Coordinate . AxisType , null ) ; \nif ( axisType != null ) { \nif ( axisType . equals ( a . toString ( ) ) ) return v . getShortName ( ) ; \n} \n} \n} \nif ( a == AxisType . Lat ) return findVariableName ( ds , \"latitude\" ) ; \nif ( a == AxisType . Lon ) return findVariableName ( ds , \"longitude\" ) ; \nif ( a == AxisType . Time ) return findVariableName ( ds , \"time\" ) ; \nif ( a == AxisType . Height ) { \nVariable v = findVariable ( ds , \"altitude\" ) ; \nif ( null == v ) v = findVariable ( ds , \"depth\" ) ; \nif ( v != null ) return v . getShortName ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"4417": "public class ThreddsMetadata { \npublic void addDocumentation ( String type , String content ) { \nif ( content == null ) { \nremoveDocumentation ( type ) ; \nreturn ; \n} \ncontent = content . trim ( ) ; \nfor ( InvDocumentation doc : getDocumentation ( ) ) { \nString dtype = doc . getType ( ) ; \nif ( dtype != null ) { \nif ( dtype . equalsIgnoreCase ( type ) ) { \ndoc . setInlineContent ( content ) ; \nreturn ; \n} \n} \n} \nif ( content . length ( ) > 0 ) addDocumentation ( new InvDocumentation ( null , null , null , type , content ) ) ; \n} \n} \n"}
{"4418": "public class ThreddsMetadata { \npublic void removeDocumentation ( String type ) { \nIterator iter = docs . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nInvDocumentation doc = ( InvDocumentation ) iter . next ( ) ; \nString dtype = doc . getType ( ) ; \nif ( dtype != null ) { \nif ( dtype . equalsIgnoreCase ( type ) ) iter . remove ( ) ; \n} \n} \n} \n} \n"}
{"4420": "public class NsslRadarMosaicConvention { \npublic static boolean isMine ( NetcdfFile ncfile ) { \nString cs = ncfile . findAttValueIgnoreCase ( null , CDM . CONVENTIONS , null ) ; \nif ( cs != null ) return false ; \nString s = ncfile . findAttValueIgnoreCase ( null , \"DataType\" , null ) ; \nif ( s == null ) return false ; \nelse if ( ! ( s . equalsIgnoreCase ( \"LatLonGrid\" ) || s . equalsIgnoreCase ( \"LatLonHeightGrid\" ) ) ) return false ; \nif ( ( null == ncfile . findGlobalAttribute ( \"Latitude\" ) ) || ( null == ncfile . findGlobalAttribute ( \"Longitude\" ) ) || ( null == ncfile . findGlobalAttribute ( \"LatGridSpacing\" ) ) || ( null == ncfile . findGlobalAttribute ( \"LonGridSpacing\" ) ) ) return false ; \nelse if ( null == ncfile . findGlobalAttribute ( \"Time\" ) ) return false ; \nreturn ! ( null == ncfile . findDimension ( \"Lat\" ) || null == ncfile . findDimension ( \"Lon\" ) ) ; \n} \n} \n"}
{"4428": "public class CoordSysBuilder { \nprotected void makeCoordinateSystemsMaximal ( NetcdfDataset ncDataset ) { \nboolean requireCompleteCoordSys = ! ncDataset . getEnhanceMode ( ) . contains ( NetcdfDataset . Enhance . IncompleteCoordSystems ) ; \nfor ( VarProcess vp : varList ) { \nVariableEnhanced ve = ( VariableEnhanced ) vp . v ; \nif ( vp . hasCoordinateSystem ( ) ) continue ; \nelse if ( ! vp . isData ( ) ) continue ; \nList < CoordinateAxis > axisList = new ArrayList < > ( ) ; \nList < CoordinateAxis > axes = ncDataset . getCoordinateAxes ( ) ; \nfor ( CoordinateAxis axis : axes ) { \nif ( isCoordinateAxisForVariable ( axis , ve ) ) axisList . add ( axis ) ; \n} \nif ( axisList . size ( ) < 2 ) continue ; \nString csName = CoordinateSystem . makeName ( axisList ) ; \nCoordinateSystem cs = ncDataset . findCoordinateSystem ( csName ) ; \nboolean okToBuild = false ; \nif ( requireCompleteCoordSys ) { \nif ( cs != null ) { \nokToBuild = cs . isComplete ( ve ) ; \n} \n} \nelse { \nokToBuild = true ; \n} \nif ( cs != null && okToBuild ) { \nve . addCoordinateSystem ( cs ) ; \nparseInfo . format ( \" assigned maximal CoordSystem '%s' for var= %s%n\" , cs . getName ( ) , ve . getFullName ( ) ) ; \n} \nelse { \nCoordinateSystem csnew = new CoordinateSystem ( ncDataset , axisList , null ) ; \nif ( requireCompleteCoordSys ) { \nokToBuild = csnew . isComplete ( ve ) ; \n} \nif ( okToBuild ) { \ncsnew . setImplicit ( true ) ; \nve . addCoordinateSystem ( csnew ) ; \nncDataset . addCoordinateSystem ( csnew ) ; \nparseInfo . format ( \" created maximal CoordSystem '%s' for var= %s%n\" , csnew . getName ( ) , ve . getFullName ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"4442": "public class TimeParamsValidator { \nprivate boolean hasValidDateRange ( String time_start , String time_end , String time_duration ) { \nif ( ( null == time_start ) && ( null == time_end ) ) { \nif ( null == time_duration ) return false ; \n} \nif ( null != time_start ) { \nif ( null != time_end ) return true ; \n} \nif ( null != time_start ) { \nif ( null != time_duration ) return true ; \n} \nif ( null != time_end ) { \nif ( null != time_duration ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"4449": "public class Grib2Tables { \npublic double getForecastTimeIntervalSizeInHours ( Grib2Pds pds ) { \nGrib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; \nint timeUnitOrg = pds . getTimeUnit ( ) ; \nint range = 0 ; \nfor ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { \nif ( ti . timeRangeUnit == 255 ) continue ; \nif ( ti . timeRangeUnit != timeUnitOrg ) { \nlogger . warn ( \"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti . timeIncrementUnit ) ; \nthrow new RuntimeException ( \"TimeInterval(2) has different units\" ) ; \n} \nelse if ( ti . timeIncrementUnit != timeUnitOrg && ti . timeIncrementUnit != 255 && ti . timeIncrement != 0 ) { \nlogger . warn ( \"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti . timeIncrementUnit ) ; \nthrow new RuntimeException ( \"TimeInterval(2) has different units\" ) ; \n} \nrange += ti . timeRangeLength ; \nif ( ti . timeIncrementUnit != 255 ) range += ti . timeIncrement ; \n} \nCalendarPeriod timeUnitPeriod = Grib2Utils . getCalendarPeriod ( convertTimeUnit ( timeUnitOrg ) ) ; \nif ( timeUnitPeriod == null ) return GribNumbers . UNDEFINEDD ; \nif ( timeUnitPeriod . equals ( CalendarPeriod . Hour ) ) return range ; \ndouble fac ; \nif ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Month ) { \nfac = 30.0 * 24.0 ; \n} \nelse if ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Year ) { \nfac = 365.0 * 24.0 ; \n} \nelse { \nfac = CalendarPeriod . Hour . getConvertFactor ( timeUnitPeriod ) ; \n} \nreturn fac * range ; \n} \n} \n"}
{"4456": "public class Evaluator { \nstatic public Variable findVariableWithAttributeValue ( NetcdfDataset ds , String attName , String attValue ) { \nfor ( Variable v : ds . getVariables ( ) ) { \nString haveValue = ds . findAttValueIgnoreCase ( v , attName , null ) ; \nif ( haveValue != null ) { \nif ( haveValue . equals ( attValue ) ) return v ; \n} \n} \nfor ( Variable v : ds . getVariables ( ) ) { \nif ( v instanceof Structure ) { \nVariable vn = findVariableWithAttributeValue ( ( Structure ) v , attName , attValue ) ; \nif ( null != vn ) return vn ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4458": "public class Evaluator { \nstatic public Variable findVariableWithAttributeValue ( Structure struct , String attName , String attValue ) { \nfor ( Variable v : struct . getVariables ( ) ) { \nAttribute att = v . findAttributeIgnoreCase ( attName ) ; \nif ( att != null ) { \nif ( att . getStringValue ( ) . equals ( attValue ) ) return v ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4461": "public class Evaluator { \nstatic public String getLiteral ( NetcdfDataset ds , String key , Formatter errlog ) { \nif ( key . startsWith ( \":\" ) ) { \nString val = ds . findAttValueIgnoreCase ( null , key . substring ( 1 ) , null ) ; \nif ( val == null ) { \nif ( errlog != null ) errlog . format ( \" Cant find global attribute %s%n\" , key ) ; \n} \nreturn val ; \n} \nreturn key ; \n} \n} \n"}
{"4462": "public class Evaluator { \nstatic public FeatureType getFeatureType ( NetcdfDataset ds , String key , Formatter errlog ) { \nFeatureType ft = null ; \nString fts = getLiteral ( ds , key , errlog ) ; \nif ( fts != null ) { \nft = FeatureType . valueOf ( fts . toUpperCase ( ) ) ; \nif ( ft == null ) { \nif ( errlog != null ) errlog . format ( \" Cant find Feature type %s from %s%n\" , fts , key ) ; \n} \n} \nreturn ft ; \n} \n} \n"}
{"4463": "public class Evaluator { \nstatic public String getVariableName ( NetcdfDataset ds , String key , Formatter errlog ) { \nVariable v = null ; \nString vs = getLiteral ( ds , key , errlog ) ; \nif ( vs != null ) { \nv = ds . findVariable ( vs ) ; \nif ( v == null ) { \nif ( errlog != null ) errlog . format ( \" Cant find Variable %s from %s%n\" , vs , key ) ; \n} \n} \nreturn v == null ? null : v . getShortName ( ) ; \n} \n} \n"}
{"4481": "public class RandomValue { \npublic int nextCount ( int max ) throws DapException { \nint min = 1 ; \nif ( max < min ) throw new DapException ( \"bad range\" ) ; \nelse if ( min < 1 ) throw new DapException ( \"bad range\" ) ; \nint range = ( max + 1 ) - min ; \nint n = random . nextInt ( range ) ; \nn = n + min ; \nif ( DEBUG ) System . err . println ( \"RandomValue.nextCount: \" + n ) ; \nreturn n ; \n} \n} \n"}
{"4482": "public class DapNetcdfFile { \n@ Override protected Array readData ( Variable cdmvar , Section section ) throws IOException , InvalidRangeException { \nassert this . dsp != null ; \nArray result = arraymap . get ( cdmvar ) ; \nif ( result == null ) throw new IOException ( \"No data for variable: \" + cdmvar . getFullName ( ) ) ; \nif ( section != null ) { \nif ( cdmvar . getRank ( ) != section . getRank ( ) ) throw new InvalidRangeException ( String . format ( \"Section rank != %s rank\" , cdmvar . getFullName ( ) ) ) ; \nList < Range > ranges = section . getRanges ( ) ; \nif ( CDMUtil . hasVLEN ( ranges ) ) { \nranges = ranges . subList ( 0 , ranges . size ( ) - 1 ) ; \n} \nif ( ranges . size ( ) > 0 ) { \nif ( ! CDMUtil . isWhole ( ranges , cdmvar ) ) result = result . sectionNoReduce ( ranges ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"4514": "public class GempakParameterTable { \nprivate GempakParameter makeParameter ( String [ ] words ) { \nint num = 0 ; \nString description ; \nif ( words [ 0 ] != null ) { \nnum = ( int ) Double . parseDouble ( words [ 0 ] ) ; \n} \nif ( words [ 3 ] == null ) { \nreturn null ; \n} \nelse if ( words [ 3 ] . equals ( \"\" ) ) { \nreturn null ; \n} \nString name = words [ 3 ] ; \nif ( name . contains ( \"-\" ) ) { \nint first = name . indexOf ( \"-\" ) ; \nint last = name . lastIndexOf ( \"-\" ) ; \nStringBuilder buf = new StringBuilder ( name . substring ( 0 , first ) ) ; \nbuf . append ( \"(\" ) ; \nfor ( int i = first ; \ni <= last ; \ni ++ ) { \nbuf . append ( \"\\\\d\" ) ; \n} \nbuf . append ( \")\" ) ; \nbuf . append ( name . substring ( last + 1 ) ) ; \nname = buf . toString ( ) ; \n} \nif ( ( words [ 1 ] == null ) || words [ 1 ] . equals ( \"\" ) ) { \ndescription = words [ 3 ] ; \n} \nelse { \ndescription = words [ 1 ] ; \n} \nString unit = words [ 2 ] ; \nif ( unit != null ) { \nunit = unit . replaceAll ( \"\\\\*\\\\*\" , \"\" ) ; \nif ( unit . equals ( \"-\" ) ) { \nunit = \"\" ; \n} \n} \nint decimalScale ; \ntry { \ndecimalScale = Integer . parseInt ( words [ 4 ] . trim ( ) ) ; \n} \ncatch ( NumberFormatException ne ) { \ndecimalScale = 0 ; \n} \nreturn new GempakParameter ( num , name , description , unit , decimalScale ) ; \n} \n} \n"}
{"4525": "public class DODSNetcdfFile { \nNamePieces parseName ( String name ) { \nNamePieces pieces = new NamePieces ( ) ; \nint dotpos = name . lastIndexOf ( '.' ) ; \nint slashpos = name . lastIndexOf ( '/' ) ; \nif ( slashpos < 0 && dotpos < 0 ) { \npieces . name = name ; \n} \nelse if ( slashpos >= 0 && dotpos < 0 ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse if ( slashpos < 0 && dotpos >= 0 ) { \npieces . var = name . substring ( 0 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \nelse { \nif ( slashpos > dotpos ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . var = name . substring ( slashpos + 1 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \n} \nif ( pieces . prefix != null ) { \nif ( pieces . prefix . length ( ) == 0 ) pieces . prefix = null ; \n} \nif ( pieces . var != null ) { \nif ( pieces . var . length ( ) == 0 ) pieces . var = null ; \n} \nif ( pieces . name . length ( ) == 0 ) pieces . name = null ; \nreturn pieces ; \n} \n} \n"}
{"4528": "public class DODSNetcdfFile { \nDimension getSharedDimension ( Group group , Dimension d ) { \nif ( d . getShortName ( ) == null ) return d ; \nif ( group == null ) group = rootGroup ; \nfor ( Dimension sd : group . getDimensions ( ) ) { \nif ( sd . getShortName ( ) . equals ( d . getShortName ( ) ) ) { \nif ( sd . getLength ( ) == d . getLength ( ) ) return sd ; \n} \n} \nd . setShared ( true ) ; \ngroup . addDimension ( d ) ; \nreturn d ; \n} \n} \n"}
{"4545": "public class CDMArrayStructure { \npublic StructureData getScalarStructure ( int index , StructureMembers . Member m ) { \nif ( m . getDataType ( ) != DataType . STRUCTURE ) throw new ForbiddenConversionException ( \"Atomic field cannot be converted to Structure\" ) ; \nArray ca = memberArray ( index , memberIndex ( m ) ) ; \nif ( ca . getDataType ( ) != DataType . STRUCTURE ) { \nif ( ca . getDataType ( ) != DataType . SEQUENCE ) throw new ForbiddenConversionException ( \"Attempt to access non-structure member\" ) ; \n} \nCDMArrayStructure as = ( CDMArrayStructure ) ca ; \nreturn as . getStructureData ( 0 ) ; \n} \n} \n"}
{"4561": "public class DatasetFilter { \nboolean validate ( StringBuilder out ) { \nthis . isValid = true ; \nif ( this . log . length ( ) > 0 ) { \nout . append ( this . log ) ; \n} \nif ( this . getName ( ) == null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (4): null value for name is not valid.\" ) ; \n} \nif ( this . getType ( ) == null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (5): null value for type is not valid (set with bad string?).\" ) ; \n} \nif ( this . type == DatasetFilter . Type . REGULAR_EXPRESSION ) { \nif ( this . matchPattern == null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (6): null value for matchPattern not valid when type is 'RegExp'.\" ) ; \n} \n} \nif ( this . type != DatasetFilter . Type . REGULAR_EXPRESSION && this . type != null ) { \nif ( this . matchPattern != null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (7): matchPattern value (\" + this . matchPattern + \") must be null if type is not 'RegExp'.\" ) ; \n} \n} \nreturn ( this . isValid ) ; \n} \n} \n"}
{"4562": "public class DatasetFilter { \nprivate boolean match ( InvDataset dataset ) { \nif ( this . getParentDatasetSource ( ) . isCollection ( dataset ) ) { \nif ( ! this . applyToCollectionDatasets ) return ( false ) ; \n} \nif ( ! this . getParentDatasetSource ( ) . isCollection ( dataset ) ) { \nif ( ! this . applyToAtomicDatasets ) return ( false ) ; \n} \nif ( this . matchPatternTarget == null ) { \nif ( this . getParentDatasetSource ( ) . isCollection ( dataset ) ) { \nthis . setMatchPatternTarget ( \"name\" ) ; \n} \nelse { \nthis . setMatchPatternTarget ( \"urlPath\" ) ; \n} \n} \nif ( this . type == DatasetFilter . Type . REGULAR_EXPRESSION ) { \nboolean isMatch ; \nif ( this . getMatchPatternTarget ( ) . equals ( \"name\" ) ) { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( dataset . getName ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nelse if ( this . getMatchPatternTarget ( ) . equals ( \"urlPath\" ) ) { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( ( ( InvDatasetImpl ) dataset ) . getUrlPath ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nelse { \nisMatch = false ; \n} \nreturn ( isMatch ) ; \n} \nelse { \nSystem . err . println ( \"WARNING -- DatasetFilter.accept(): unsupported type\" + \" <\" + this . type . toString ( ) + \">.\" ) ; \nreturn ( false ) ; \n} \n} \n} \n"}
{"4581": "public class URLDumpPane { \nprivate void openURL ( String urlString , Command command ) { \ntry { \nURL u = new URL ( urlString ) ; \ncurrentConnection = ( HttpURLConnection ) u . openConnection ( ) ; \ncurrentConnection . setRequestMethod ( command . toString ( ) ) ; \ncurrentConnection . setAllowUserInteraction ( true ) ; \nclear ( ) ; \nappendLine ( command + \" request for \" + urlString ) ; \nMap < String , List < String > > reqs = currentConnection . getRequestProperties ( ) ; \nfor ( Map . Entry < String , List < String > > ent : reqs . entrySet ( ) ) { \nappend ( \" \" + ent . getKey ( ) + \": \" ) ; \nfor ( String v : ent . getValue ( ) ) append ( v + \" \" ) ; \nappendLine ( \"\" ) ; \n} \nappendLine ( \"\" ) ; \nappendLine ( \"getFollowRedirects=\" + HttpURLConnection . getFollowRedirects ( ) ) ; \nappendLine ( \"getInstanceFollowRedirects=\" + currentConnection . getInstanceFollowRedirects ( ) ) ; \nappendLine ( \"AllowUserInteraction=\" + currentConnection . getAllowUserInteraction ( ) ) ; \nappendLine ( \"\" ) ; \nint code = currentConnection . getResponseCode ( ) ; \nString response = currentConnection . getResponseMessage ( ) ; \nappendLine ( \" HTTP/1.x \" + code + \" \" + response ) ; \nappendLine ( \" content-length: \" + currentConnection . getContentLength ( ) ) ; \nappendLine ( \" content-encoding: \" + currentConnection . getContentEncoding ( ) ) ; \nappendLine ( \" content-type: \" + currentConnection . getContentType ( ) ) ; \nappendLine ( \"\\nHeaders: \" ) ; \nfor ( int j = 1 ; \ntrue ; \nj ++ ) { \nString header = currentConnection . getHeaderField ( j ) ; \nString key = currentConnection . getHeaderFieldKey ( j ) ; \nif ( header == null ) break ; \nelse if ( key == null ) break ; \nappendLine ( \" \" + key + \": \" + header ) ; \n} \nappendLine ( \"\" ) ; \nappendLine ( \"contents:\" ) ; \njava . io . InputStream is = currentConnection . getInputStream ( ) ; \nByteArrayOutputStream bout = new ByteArrayOutputStream ( 200000 ) ; \nIO . copy ( is , bout ) ; \nis . close ( ) ; \nappend ( new String ( bout . toByteArray ( ) , CDM . utf8Charset ) ) ; \nappendLine ( \"end contents\" ) ; \n} \ncatch ( MalformedURLException e ) { \nappend ( urlString + \" is not a parseable URL\" ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"4599": "public class CatalogUtils { \npublic static List < InvCatalogRef > findAllCatRefsInDatasetTree ( List < InvDataset > datasets , StringBuilder log , boolean onlyRelativeUrls ) { \nList < InvCatalogRef > catRefList = new ArrayList < InvCatalogRef > ( ) ; \nfor ( InvDataset invds : datasets ) { \nInvDatasetImpl curDs = ( InvDatasetImpl ) invds ; \nif ( curDs instanceof InvDatasetScan ) continue ; \nif ( curDs instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) curDs ; \nString name = catRef . getName ( ) ; \nString href = catRef . getXlinkHref ( ) ; \nURI uri ; \ntry { \nuri = new URI ( href ) ; \n} \ncatch ( URISyntaxException e ) { \nlog . append ( log . length ( ) > 0 ? \"\\n\" : \"\" ) . append ( \"***WARN - CatalogRef [\" ) . append ( name ) . append ( \"] with bad HREF [\" ) . append ( href ) . append ( \"] \" ) ; \ncontinue ; \n} \nif ( onlyRelativeUrls ) { \nif ( uri . isAbsolute ( ) ) continue ; \n} \ncatRefList . add ( catRef ) ; \ncontinue ; \n} \nif ( curDs . hasNestedDatasets ( ) ) catRefList . addAll ( findAllCatRefsInDatasetTree ( curDs . getDatasets ( ) , log , onlyRelativeUrls ) ) ; \n} \nreturn catRefList ; \n} \n} \n"}
{"4607": "public class GempakStationFileIOSP { \nprotected Variable makeParamVariable ( GempakParameter param , List < Dimension > dims ) { \nVariable var = new Variable ( ncfile , null , null , param . getName ( ) ) ; \nvar . setDataType ( DataType . FLOAT ) ; \nvar . setDimensions ( dims ) ; \nvar . addAttribute ( new Attribute ( CDM . LONG_NAME , param . getDescription ( ) ) ) ; \nString units = param . getUnit ( ) ; \nif ( units != null ) { \nif ( ! units . equals ( \"\" ) ) { \nvar . addAttribute ( new Attribute ( CDM . UNITS , units ) ) ; \n} \n} \nvar . addAttribute ( new Attribute ( CDM . MISSING_VALUE , RMISS ) ) ; \nreturn var ; \n} \n} \n"}
{"4612": "public class CeParser { \nprivate String yysyntax_error ( int yystate , int tok ) { \nif ( yyErrorVerbose ) { \nif ( tok != yyempty_ ) { \nStringBuffer res = new StringBuffer ( \"syntax error, unexpected \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ tok ] ) ) ; \nint yyn = yypact_ [ yystate ] ; \nif ( ! yy_pact_value_is_default_ ( yyn ) ) { \nint yyxbegin = yyn < 0 ? - yyn : 0 ; \nint yychecklim = yylast_ - yyn + 1 ; \nint yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_ ; \nint count = 0 ; \nfor ( int x = yyxbegin ; \nx < yyxend ; \n++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ ) { \nif ( ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) ++ count ; \n} \nif ( count < 5 ) { \ncount = 0 ; \nfor ( int x = yyxbegin ; \nx < yyxend ; \n++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ ) { \nif ( ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) { \nres . append ( count ++ == 0 ? \", expecting \" : \" or \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ x ] ) ) ; \n} \n} \n} \n} \nreturn res . toString ( ) ; \n} \n} \nreturn \"syntax error\" ; \n} \n} \n"}
{"4616": "public class ChunkInputStream { \npublic int read ( byte [ ] buf , int off , int len ) throws IOException { \nif ( off < 0 ) throw new IndexOutOfBoundsException ( ) ; \nelse if ( len < 0 ) throw new IndexOutOfBoundsException ( ) ; \nif ( off >= buf . length ) throw new IndexOutOfBoundsException ( ) ; \nelse if ( buf . length < ( off + len ) ) throw new IndexOutOfBoundsException ( ) ; \nif ( requestmode == RequestMode . DMR ) throw new UnsupportedOperationException ( \"Attempt to read databuffer when DMR only\" ) ; \nint count = len ; \nint pos = off ; \nwhile ( count > 0 ) { \nif ( avail <= 0 ) { \nif ( ( flags & DapUtil . CHUNK_END ) != 0 ) return ( len - count ) ; \nelse if ( ! readHeader ( input ) ) return ( len - count ) ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) { \nString document = readError ( ) ; \nthrowError ( document ) ; \n} \n} \nelse { \nint actual = ( this . avail < count ? this . avail : count ) ; \nint red = input . read ( buf , pos , actual ) ; \nif ( red < 0 ) throw new IOException ( \"Unexpected EOF\" ) ; \npos += red ; \ncount -= red ; \nthis . avail -= red ; \n} \n} \nreturn len ; \n} \n} \n"}
{"4620": "public class DatasetConstructor { \nstatic private void transferGroup ( NetcdfFile ds , NetcdfDataset targetDs , Group src , Group targetGroup , ReplaceVariableCheck replaceCheck ) { \nboolean unlimitedOK = true ; \ntransferGroupAttributes ( src , targetGroup ) ; \nfor ( Dimension d : src . getDimensions ( ) ) { \nif ( null == targetGroup . findDimensionLocal ( d . getShortName ( ) ) ) { \nDimension newd = new Dimension ( d . getShortName ( ) , d . getLength ( ) , d . isShared ( ) , unlimitedOK && d . isUnlimited ( ) , d . isVariableLength ( ) ) ; \ntargetGroup . addDimension ( newd ) ; \n} \n} \nfor ( Variable v : src . getVariables ( ) ) { \nVariable targetV = targetGroup . findVariable ( v . getShortName ( ) ) ; \nVariableEnhanced targetVe = ( VariableEnhanced ) targetV ; \nboolean replace = ( replaceCheck != null ) && replaceCheck . replace ( v ) ; \nif ( replace || ( null == targetV ) ) { \nif ( ( v instanceof Structure ) && ! ( v instanceof StructureDS ) ) { \nv = new StructureDS ( targetGroup , ( Structure ) v ) ; \n} \nelse if ( ! ( v instanceof VariableDS ) ) { \nv = new VariableDS ( targetGroup , v , false ) ; \n} \nif ( null != targetV ) targetGroup . remove ( targetV ) ; \ntargetGroup . addVariable ( v ) ; \nv . resetDimensions ( ) ; \n} \nelse if ( ! targetV . hasCachedData ( ) ) { \nif ( targetVe . getOriginalVariable ( ) == null ) { \ntargetVe . setOriginalVariable ( v ) ; \n} \n} \n} \nfor ( Group srcNested : src . getGroups ( ) ) { \nGroup nested = targetGroup . findGroup ( srcNested . getShortName ( ) ) ; \nif ( null == nested ) { \nnested = new Group ( ds , targetGroup , srcNested . getShortName ( ) ) ; \ntargetGroup . addGroup ( nested ) ; \n} \ntransferGroup ( ds , targetDs , srcNested , nested , replaceCheck ) ; \n} \n} \n} \n"}
{"4635": "public class DodsV { \nDodsV findDodsV ( String name , boolean useDone ) { \nfor ( DodsV dodsV : children ) { \nif ( useDone ) { \nif ( dodsV . isDone ) continue ; \n} \nif ( ( name == null ) || ( dodsV == null ) ) { \nlogger . warn ( \"Corrupted structure\" ) ; \ncontinue ; \n} \nelse if ( dodsV . bt == null ) { \nlogger . warn ( \"Corrupted structure\" ) ; \ncontinue ; \n} \nif ( name . equals ( dodsV . bt . getEncodedName ( ) ) ) return dodsV ; \n} \nreturn null ; \n} \n} \n"}
{"4639": "public class Variable { \npublic Dimension getDimension ( int i ) { \nif ( i < 0 ) return null ; \nelse if ( i >= getRank ( ) ) return null ; \nreturn dimensions . get ( i ) ; \n} \n} \n"}
{"4641": "public class Variable { \npublic String getUnitsString ( ) { \nString units = null ; \nAttribute att = findAttribute ( CDM . UNITS ) ; \nif ( att == null ) att = findAttributeIgnoreCase ( CDM . UNITS ) ; \nif ( att != null ) { \nif ( att . isString ( ) ) { \nunits = att . getStringValue ( ) ; \nif ( units != null ) units = units . trim ( ) ; \n} \n} \nreturn units ; \n} \n} \n"}
{"4643": "public class Variable { \npublic Variable slice ( int dim , int value ) throws InvalidRangeException { \nif ( dim < 0 ) throw new InvalidRangeException ( \"Slice dim invalid= \" + dim ) ; \nelse if ( dim >= shape . length ) throw new InvalidRangeException ( \"Slice dim invalid= \" + dim ) ; \nboolean recordSliceOk = false ; \nif ( dim == 0 ) { \nif ( value == 0 ) { \nDimension d = getDimension ( 0 ) ; \nrecordSliceOk = d . isUnlimited ( ) ; \n} \n} \nif ( ! recordSliceOk ) { \nif ( value < 0 ) throw new InvalidRangeException ( \"Slice value invalid= \" + value + \" for dimension \" + dim ) ; \nelse if ( value >= shape [ dim ] ) throw new InvalidRangeException ( \"Slice value invalid= \" + value + \" for dimension \" + dim ) ; \n} \nVariable sliceV = copy ( ) ; \nSection slice = new Section ( getShapeAsSection ( ) ) ; \nslice . replaceRange ( dim , new Range ( value , value ) ) . makeImmutable ( ) ; \nsliceV . setProxyReader ( new SliceReader ( this , dim , slice ) ) ; \nsliceV . createNewCache ( ) ; \nsliceV . setCaching ( false ) ; \nsliceV . dimensions . remove ( dim ) ; \nsliceV . resetShape ( ) ; \nreturn sliceV ; \n} \n} \n"}
{"4648": "public class Variable { \nprotected Array _read ( Section section ) throws IOException , InvalidRangeException { \nif ( null == section ) return _read ( ) ; \nelse if ( section . computeSize ( ) == getSize ( ) ) return _read ( ) ; \nif ( isCaching ( ) ) { \nif ( cache . data == null ) { \nsetCachedData ( _read ( ) ) ; \nif ( debugCaching ) System . out . println ( \"cache \" + getFullName ( ) ) ; \n} \nif ( debugCaching ) System . out . println ( \"got data from cache \" + getFullName ( ) ) ; \nreturn cache . data . sectionNoReduce ( section . getRanges ( ) ) . copy ( ) ; \n} \nreturn proxyReader . reallyRead ( this , section , null ) ; \n} \n} \n"}
{"4657": "public class Variable { \npublic void setCachedData ( Array cacheData , boolean isMetadata ) { \nif ( cacheData != null ) { \nif ( cacheData . getElementType ( ) != getDataType ( ) . getPrimitiveClassType ( ) ) throw new IllegalArgumentException ( \"setCachedData type=\" + cacheData . getElementType ( ) + \" incompatible with variable type=\" + getDataType ( ) ) ; \n} \nthis . cache . data = cacheData ; \nthis . isMetadata = isMetadata ; \nthis . cache . cachingSet = true ; \nthis . cache . isCaching = true ; \n} \n} \n"}
{"4665": "public class CDMDSP { \nprotected void buildseqtypes ( Variable cdmvar ) throws DapException { \nif ( CDMUtil . hasVLEN ( cdmvar ) ) { \nbuildseqtype ( cdmvar ) ; \n} \nif ( cdmvar . getDataType ( ) == DataType . STRUCTURE ) { \nStructure struct = ( Structure ) cdmvar ; \nList < Variable > fields = struct . getVariables ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nVariable field = fields . get ( i ) ; \nbuildseqtypes ( field ) ; \n} \n} \nelse if ( cdmvar . getDataType ( ) == DataType . SEQUENCE ) { \nStructure struct = ( Structure ) cdmvar ; \nList < Variable > fields = struct . getVariables ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni ++ ) { \nVariable field = fields . get ( i ) ; \nbuildseqtypes ( field ) ; \n} \n} \n} \n} \n"}
{"4666": "public class CDMDSP { \nprotected void builddimrefs ( DapVariable dapvar , List < Dimension > cdmdims ) throws DapException { \nif ( cdmdims == null ) return ; \nelse if ( cdmdims . size ( ) == 0 ) return ; \nfor ( Dimension cdmdim : cdmdims ) { \nDapDimension dapdim = null ; \nif ( cdmdim . isShared ( ) ) { \nDimension declareddim = finddimdecl ( cdmdim ) ; \nif ( declareddim == null ) throw new DapException ( \"Unprocessed cdm dimension: \" + cdmdim ) ; \ndapdim = ( DapDimension ) this . nodemap . get ( declareddim ) ; \nassert dapdim != null ; \n} \nelse if ( cdmdim . isVariableLength ( ) ) { \ncontinue ; \n} \nelse { \ndapdim = builddim ( cdmdim ) ; \n} \nassert ( dapdim != null ) : \"Internal error\" ; \ndapvar . addDimension ( dapdim ) ; \n} \n} \n} \n"}
{"4667": "public class CDMDSP { \nprotected EnumTypedef findMatchingEnum ( EnumTypedef varenum ) throws DapException { \nList < EnumTypedef > candidates = new ArrayList < > ( ) ; \nfor ( Map . Entry < DapNode , CDMNode > entry : this . nodemap . getCDMMap ( ) . entrySet ( ) ) { \nCDMNode cdmnode = entry . getValue ( ) ; \nif ( cdmnode . getSort ( ) != CDMSort . ENUMERATION ) continue ; \nEnumTypedef target = ( EnumTypedef ) cdmnode ; \nMap < Integer , String > targetmap = target . getMap ( ) ; \nMap < Integer , String > varmap = varenum . getMap ( ) ; \nif ( targetmap . size ( ) != varmap . size ( ) ) continue ; \nboolean match = true ; \nfor ( Map . Entry < Integer , String > tpair : targetmap . entrySet ( ) ) { \nString tname = tpair . getValue ( ) ; \nint value = ( int ) tpair . getKey ( ) ; \nboolean found = false ; \nfor ( Map . Entry < Integer , String > vpair : varmap . entrySet ( ) ) { \nif ( tname . equals ( vpair . getValue ( ) ) ) { \nif ( value == ( int ) vpair . getKey ( ) ) { \nfound = true ; \nbreak ; \n} \n} \n} \nif ( ! found ) { \nmatch = false ; \nbreak ; \n} \n} \nif ( ! match ) continue ; \nboolean shadowed = false ; \nfor ( EnumTypedef etd : candidates ) { \nif ( shadows ( etd . getGroup ( ) , target . getGroup ( ) ) ) { \nshadowed = true ; \nbreak ; \n} \n} \nif ( ! shadowed ) candidates . add ( target ) ; \n} \nswitch ( candidates . size ( ) ) { \ncase 0 : throw new DapException ( \"CDMDSP: No matching enum type decl: \" + varenum . getShortName ( ) ) ; \ncase 1 : break ; \ndefault : throw new DapException ( \"CDMDSP: Multiple matching enum type decls: \" + varenum . getShortName ( ) ) ; \n} \nreturn candidates . get ( 0 ) ; \n} \n} \n"}
{"4668": "public class CDMDSP { \nstatic List < Dimension > getCoreDimset ( List < Dimension > dimset ) throws DapException { \nif ( dimset == null ) return null ; \nList < Dimension > core = new ArrayList < > ( ) ; \nint pos = - 1 ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < dimset . size ( ) ; \ni ++ ) { \nif ( dimset . get ( i ) . isVariableLength ( ) ) { \npos = i ; \ncount ++ ; \n} \nelse core . add ( dimset . get ( i ) ) ; \n} \nif ( pos != dimset . size ( ) - 1 ) throw new DapException ( \"Unsupported use of (*) Dimension\" ) ; \nelse if ( count > 1 ) throw new DapException ( \"Unsupported use of (*) Dimension\" ) ; \nreturn core ; \n} \n} \n"}
{"4677": "public class Navigation { \npublic void zoom ( double startx , double starty , double width , double height ) { \nif ( debugZoom ) System . out . println ( \"zoom \" + startx + \" \" + starty + \" \" + width + \" \" + height + \" \" ) ; \nif ( width < 5 ) return ; \nelse if ( height < 5 ) return ; \nzoom . push ( ) ; \npix_x0 -= startx + width / 2 - pwidth / 2 ; \npix_y0 -= starty + height / 2 - pheight / 2 ; \nzoom ( pwidth / width ) ; \n} \n} \n"}
{"4681": "public class ListenerManager { \npublic synchronized void sendEvent ( java . util . EventObject event ) { \nif ( ! hasListeners ) return ; \nelse if ( ! enabled ) return ; \nObject [ ] args = new Object [ 1 ] ; \nargs [ 0 ] = event ; \nListIterator iter = listeners . listIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nObject client = iter . next ( ) ; \ntry { \nmethod . invoke ( client , args ) ; \n} \ncatch ( IllegalAccessException e ) { \nlogger . error ( \"ListenerManager IllegalAccessException\" , e ) ; \niter . remove ( ) ; \n} \ncatch ( IllegalArgumentException e ) { \nlogger . error ( \"ListenerManager IllegalArgumentException\" , e ) ; \niter . remove ( ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new RuntimeException ( e . getCause ( ) ) ; \n} \n} \n} \n} \n"}
{"4682": "public class ListenerManager { \npublic synchronized void sendEventExcludeSource ( java . util . EventObject event ) { \nif ( ! hasListeners ) return ; \nelse if ( ! enabled ) return ; \nObject source = event . getSource ( ) ; \nObject [ ] args = new Object [ 1 ] ; \nargs [ 0 ] = event ; \nListIterator iter = listeners . listIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nObject client = iter . next ( ) ; \nif ( client == source ) continue ; \ntry { \nmethod . invoke ( client , args ) ; \n} \ncatch ( IllegalAccessException | InvocationTargetException | IllegalArgumentException e ) { \ne . printStackTrace ( ) ; \nif ( e . getCause ( ) != null ) e . getCause ( ) . printStackTrace ( ) ; \nlogger . error ( \"ListenerManager calling \" + method + \" threw exception \" , e ) ; \n} \n} \n} \n} \n"}
{"4684": "public class NCdumpW { \npublic static boolean print ( NetcdfFile nc , String command , Writer out , ucar . nc2 . util . CancelTask ct ) throws IOException { \nWantValues showValues = WantValues . none ; \nboolean ncml = false ; \nboolean strict = false ; \nString varNames = null ; \nString trueDataset = null ; \nString fakeDataset = null ; \nif ( command != null ) { \nStringTokenizer stoke = new StringTokenizer ( command ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString toke = stoke . nextToken ( ) ; \nif ( toke . equalsIgnoreCase ( \"-help\" ) ) { \nout . write ( usage ) ; \nout . write ( '\\n' ) ; \nreturn true ; \n} \nif ( toke . equalsIgnoreCase ( \"-vall\" ) ) showValues = WantValues . all ; \nif ( toke . equalsIgnoreCase ( \"-c\" ) ) { \nif ( showValues == WantValues . none ) showValues = WantValues . coordsOnly ; \n} \nif ( toke . equalsIgnoreCase ( \"-ncml\" ) ) ncml = true ; \nif ( toke . equalsIgnoreCase ( \"-cdl\" ) ) strict = true ; \nelse if ( toke . equalsIgnoreCase ( \"-strict\" ) ) strict = true ; \nif ( toke . equalsIgnoreCase ( \"-v\" ) ) { \nif ( stoke . hasMoreTokens ( ) ) varNames = stoke . nextToken ( ) ; \n} \nif ( toke . equalsIgnoreCase ( \"-datasetname\" ) ) { \nif ( stoke . hasMoreTokens ( ) ) { \nfakeDataset = stoke . nextToken ( ) ; \nif ( fakeDataset . length ( ) == 0 ) fakeDataset = null ; \nif ( fakeDataset != null ) { \ntrueDataset = nc . getLocation ( ) ; \nnc . setLocation ( fakeDataset ) ; \n} \n} \n} \n} \n} \nboolean ok = print ( nc , out , showValues , ncml , strict , varNames , ct ) ; \nif ( trueDataset != null ) { \nif ( fakeDataset != null ) nc . setLocation ( trueDataset ) ; \n} \nreturn ok ; \n} \n} \n"}
{"4695": "public class GempakLookup { \npublic final boolean isPositiveUp ( GridRecord gr ) { \nint type = gr . getLevelType1 ( ) ; \nif ( type == 1 ) { \nreturn false ; \n} \nelse if ( type == 5 ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"4701": "public class DConnect2 { \nprivate void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { \nInputStream is = null ; \ntry { \ntry ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { \nif ( acceptCompress ) method . setCompression ( \"deflate,gzip\" ) ; \nif ( allowSessions ) method . setUseSessions ( true ) ; \nint statusCode ; \nfor ( ; \n; \n) { \nstatusCode = method . execute ( ) ; \nif ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) break ; \nThread . sleep ( 5000 ) ; \nSystem . err . println ( \"Service Unavailable\" ) ; \n} \nif ( statusCode == HttpStatus . SC_NOT_FOUND ) { \nthrow new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + \": \" + urlString ) ; \n} \nif ( statusCode == HttpStatus . SC_UNAUTHORIZED ) { \nthrow new InvalidCredentialsException ( method . getStatusText ( ) ) ; \n} \nelse if ( statusCode == HttpStatus . SC_FORBIDDEN ) { \nthrow new InvalidCredentialsException ( method . getStatusText ( ) ) ; \n} \nif ( statusCode != HttpStatus . SC_OK ) { \nthrow new DAP2Exception ( \"Method failed:\" + method . getStatusText ( ) + \" on URL= \" + urlString ) ; \n} \nis = method . getResponseAsStream ( ) ; \nHeader header = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( header != null ) { \nif ( header . getValue ( ) . equals ( \"dods-error\" ) || header . getValue ( ) . equals ( \"dods_error\" ) ) { \nDAP2Exception ds = new DAP2Exception ( ) ; \nds . parse ( is ) ; \nthrow ds ; \n} \n} \nver = new ServerVersion ( method ) ; \ncheckHeaders ( method ) ; \nHeader h = method . getResponseHeader ( \"content-encoding\" ) ; \nString encoding = ( h == null ) ? null : h . getValue ( ) ; \nif ( encoding != null && encoding . equals ( \"deflate\" ) ) { \nis = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"deflate %s%n\" , urlString ) ; \n} \nelse if ( encoding != null && encoding . equals ( \"gzip\" ) ) { \nis = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"gzip %s%n\" , urlString ) ; \n} \nelse { \nif ( showCompress ) System . out . printf ( \"none %s%n\" , urlString ) ; \n} \ncommand . process ( is ) ; \n} \n} \ncatch ( IOException | DAP2Exception e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nUtil . check ( e ) ; \nthrow new DAP2Exception ( e ) ; \n} \n} \n} \n"}
{"4704": "public class DConnect2 { \nprivate String getCompleteCE ( String CE ) { \nString localProjString = null ; \nString localSelString = null ; \nif ( CE == null ) return \"\" ; \nif ( CE . startsWith ( \"?\" ) ) CE = CE . substring ( 1 ) ; \nint selIndex = CE . indexOf ( '&' ) ; \nif ( selIndex == 0 ) { \nlocalProjString = \"\" ; \nlocalSelString = CE ; \n} \nelse if ( selIndex > 0 ) { \nlocalSelString = CE . substring ( selIndex ) ; \nlocalProjString = CE . substring ( 0 , selIndex ) ; \n} \nelse { \nlocalProjString = CE ; \nlocalSelString = \"\" ; \n} \nString ce = projString ; \nif ( ! localProjString . equals ( \"\" ) ) { \nif ( ! ce . equals ( \"\" ) ) { \nif ( localProjString . indexOf ( ',' ) != 0 ) ce += \",\" ; \n} \nce += localProjString ; \n} \nif ( ! selString . equals ( \"\" ) ) { \nif ( selString . indexOf ( '&' ) != 0 ) ce += \"&\" ; \nce += selString ; \n} \nif ( ! localSelString . equals ( \"\" ) ) { \nif ( localSelString . indexOf ( '&' ) != 0 ) ce += \"&\" ; \nce += localSelString ; \n} \nif ( ce . length ( ) > 0 ) ce = \"?\" + ce ; \nif ( false ) { \nDAPNode . log . debug ( \"projString: '\" + projString + \"'\" ) ; \nDAPNode . log . debug ( \"localProjString: '\" + localProjString + \"'\" ) ; \nDAPNode . log . debug ( \"selString: '\" + selString + \"'\" ) ; \nDAPNode . log . debug ( \"localSelString: '\" + localSelString + \"'\" ) ; \nDAPNode . log . debug ( \"Complete CE: \" + ce ) ; \n} \nreturn ce ; \n} \n} \n"}
{"4732": "public class GridCoordSys { \nvoid addLevels ( List < GridRecord > records ) { \nfor ( GridRecord record : records ) { \nDouble d = new Double ( record . getLevel1 ( ) ) ; \nif ( ! levels . contains ( d ) ) { \nlevels . add ( d ) ; \n} \nif ( dontUseVertical ) { \nif ( levels . size ( ) > 1 ) { \nif ( GridServiceProvider . debugVert ) { \nSystem . out . println ( \"GribCoordSys: unused level coordinate has > 1 levels = \" + verticalName + \" \" + record . getLevelType1 ( ) + \" \" + levels . size ( ) ) ; \n} \n} \n} \n} \nCollections . sort ( levels ) ; \nif ( positive . equals ( \"down\" ) ) { \nCollections . reverse ( levels ) ; \n} \n} \n} \n"}
{"4735": "public class GridCoordSys { \nvoid findCoordinateTransform ( Group g , String nameStartsWith , int levelType ) { \nList < Variable > vars = g . getVariables ( ) ; \nfor ( Variable v : vars ) { \nif ( v . getShortName ( ) . equals ( nameStartsWith ) ) { \nAttribute att = v . findAttribute ( \"grid_level_type\" ) ; \nif ( att == null ) { \ncontinue ; \n} \nelse if ( att . getNumericValue ( ) . intValue ( ) != levelType ) { \ncontinue ; \n} \nv . addAttribute ( new Attribute ( _Coordinate . TransformType , \"Vertical\" ) ) ; \nv . addAttribute ( new Attribute ( \"transform_name\" , \"Existing3DField\" ) ) ; \n} \n} \n} \n} \n"}
{"4738": "public class DiskCache2 { \npublic File getFile ( String fileLocation ) { \nif ( ! alwaysUseCache ) { \nFile f = new File ( fileLocation ) ; \nif ( f . exists ( ) ) return f ; \nif ( canWrite ( f ) ) return f ; \n} \nif ( neverUseCache ) { \nthrow new IllegalStateException ( \"neverUseCache=true, but file does not exist and directory is not writeable =\" + fileLocation ) ; \n} \nFile f = new File ( makeCachePath ( fileLocation ) ) ; \nif ( cachePathPolicy == CachePathPolicy . NestedDirectory ) { \nFile dir = f . getParentFile ( ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! dir . mkdirs ( ) ) cacheLog . warn ( \"Cant create directories for file \" + dir . getPath ( ) ) ; \n} \n} \nreturn f ; \n} \n} \n"}
{"4741": "public class DiskCache2 { \npublic void cleanCache ( File dir , Formatter sbuff , boolean isRoot ) { \nlong now = System . currentTimeMillis ( ) ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) { \nthrow new IllegalStateException ( \"DiskCache2: not a directory or I/O error on dir=\" + dir . getAbsolutePath ( ) ) ; \n} \nif ( ! isRoot ) { \nif ( files . length == 0 ) { \nlong duration = now - dir . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = dir . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + dir . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , dir . getPath ( ) , CalendarDate . of ( dir . lastModified ( ) ) ) ; \n} \nreturn ; \n} \n} \nfor ( File file : files ) { \nif ( file . isDirectory ( ) ) { \ncleanCache ( file , sbuff , false ) ; \n} \nelse { \nlong duration = now - file . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( duration > persistMinutes ) { \nboolean ok = file . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + file . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , file . getPath ( ) , CalendarDate . of ( file . lastModified ( ) ) ) ; \n} \n} \n} \n} \n} \n"}
{"4759": "public class DataDescriptor { \npublic boolean equals2 ( Object o ) { \nif ( this == o ) return true ; \nif ( o == null ) return false ; \nelse if ( getClass ( ) != o . getClass ( ) ) return false ; \nDataDescriptor that = ( DataDescriptor ) o ; \nif ( fxy != that . fxy ) return false ; \nif ( replication != that . replication ) return false ; \nif ( type != that . type ) return false ; \nif ( subKeys != null ? ! subKeys . equals ( that . subKeys ) : that . subKeys != null ) return false ; \nreturn true ; \n} \n} \n"}
{"4766": "public class DbaseFile { \npublic String getFieldName ( int i ) { \nif ( i >= nfields ) { \nreturn null ; \n} \nelse if ( i < 0 ) { \nreturn null ; \n} \nreturn ( FieldDesc [ i ] . Name ) ; \n} \n} \n"}
{"4776": "public class DapNode { \npublic List < DapGroup > getGroupPath ( ) { \nList < DapGroup > path = new ArrayList < DapGroup > ( ) ; \nDapNode current = this ; \nfor ( ; \n; \n) { \nif ( current . getSort ( ) == DapSort . GROUP ) path . add ( 0 , ( DapGroup ) current ) ; \nelse if ( current . getSort ( ) == DapSort . DATASET ) path . add ( 0 , ( DapGroup ) current ) ; \nif ( current . getContainer ( ) == null ) break ; \ncurrent = current . getContainer ( ) ; \n} \nreturn path ; \n} \n} \n"}
{"4780": "public class PreferencesExt { \npublic void putBeanCollection ( String key , Collection newValue ) { \nObject oldValue = getBean ( key , null ) ; \nif ( oldValue == null ) keyValues . put ( key , new Bean . Collection ( newValue ) ) ; \nelse if ( ! oldValue . equals ( newValue ) ) keyValues . put ( key , new Bean . Collection ( newValue ) ) ; \n} \n} \n"}
{"4799": "public class CoordAxisHelper { \nprivate int findClosest ( double target ) { \ndouble minDiff = Double . MAX_VALUE ; \ndouble useValue = Double . MIN_VALUE ; \nint idxFound = - 1 ; \nfor ( int i = 0 ; \ni < axis . getNcoords ( ) ; \ni ++ ) { \ndouble coord = axis . getCoordMidpoint ( i ) ; \ndouble diff = Math . abs ( coord - target ) ; \nif ( diff < minDiff ) { \nminDiff = diff ; \nidxFound = i ; \nuseValue = coord ; \n} \nelse if ( diff == minDiff && coord > useValue ) { \nminDiff = diff ; \nidxFound = i ; \nuseValue = coord ; \n} \n} \nreturn idxFound ; \n} \n} \n"}
{"4805": "public class XURI { \npublic String assemble ( EnumSet < Parts > parts ) { \nStringBuilder uri = new StringBuilder ( ) ; \nint useformat = ( parts . contains ( Parts . FORMAT ) ? 1 : 0 ) ; \nint usebase = ( parts . contains ( Parts . BASE ) ? 2 : 0 ) ; \nswitch ( useformat + usebase ) { \ncase 0 + 0 : break ; \ncase 1 + 0 : uri . append ( this . formatprotocol + \":\" ) ; \nbreak ; \ncase 2 + 0 : uri . append ( this . baseprotocol + \":\" ) ; \nbreak ; \ncase 2 + 1 : uri . append ( this . formatprotocol + \":\" ) ; \nif ( ! this . baseprotocol . equals ( this . formatprotocol ) ) uri . append ( this . formatprotocol + \":\" ) ; \nbreak ; \n} \nuri . append ( this . baseprotocol . equals ( \"file\" ) ? \"/\" : \"//\" ) ; \nif ( userinfo != null ) { \nif ( parts . contains ( Parts . PWD ) ) uri . append ( this . userinfo + \":\" ) ; \n} \nif ( this . host != null ) { \nif ( parts . contains ( Parts . HOST ) ) uri . append ( this . host ) ; \n} \nif ( this . path != null ) { \nif ( parts . contains ( Parts . PATH ) ) uri . append ( this . path ) ; \n} \nif ( this . query != null ) { \nif ( parts . contains ( Parts . QUERY ) ) uri . append ( \"?\" + this . query ) ; \n} \nif ( this . frag != null ) { \nif ( parts . contains ( Parts . FRAG ) ) uri . append ( \"#\" + this . frag ) ; \n} \nreturn uri . toString ( ) ; \n} \n} \n"}
{"4811": "public class SortedTable { \npublic synchronized Object put ( Object key , Object value ) throws NullPointerException { \nif ( key == null ) throw new NullPointerException ( ) ; \nelse if ( value == null ) throw new NullPointerException ( ) ; \nint index = keys . indexOf ( key ) ; \nif ( index != - 1 ) { \nObject prev = elements . elementAt ( index ) ; \nelements . setElementAt ( value , index ) ; \nreturn prev ; \n} \nelse { \nkeys . addElement ( key ) ; \nelements . addElement ( value ) ; \nreturn null ; \n} \n} \n} \n"}
{"4813": "public class DMRPrinter { \nvoid printXMLAttributes ( DapNode node , CEConstraint ce , int flags ) throws IOException { \nif ( ( flags & PERLINE ) != 0 ) printer . indent ( 2 ) ; \nString name = node . getShortName ( ) ; \nif ( name != null ) { \nif ( ( flags & NONAME ) == 0 ) { \nname = node . getShortName ( ) ; \nprintXMLAttribute ( \"name\" , name , flags ) ; \n} \n} \nswitch ( node . getSort ( ) ) { \ncase DATASET : DapDataset dataset = ( DapDataset ) node ; \nprintXMLAttribute ( \"dapVersion\" , dataset . getDapVersion ( ) , flags ) ; \nprintXMLAttribute ( \"dmrVersion\" , dataset . getDMRVersion ( ) , flags ) ; \nprintXMLAttribute ( \"xmlns\" , \"http://xml.opendap.org/ns/DAP/4.0#\" , flags ) ; \nprintXMLAttribute ( \"xmlns:dap\" , \"http://xml.opendap.org/ns/DAP/4.0#\" , flags ) ; \nbreak ; \ncase DIMENSION : DapDimension orig = ( DapDimension ) node ; \nif ( orig . isShared ( ) ) { \nDapDimension actual = this . ce . getRedefDim ( orig ) ; \nif ( actual == null ) actual = orig ; \nlong size = actual . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , flags ) ; \n} \nbreak ; \ncase ENUMERATION : printXMLAttribute ( \"basetype\" , ( ( DapEnumeration ) node ) . getBaseType ( ) . getTypeName ( ) , flags ) ; \nbreak ; \ncase VARIABLE : DapVariable var = ( DapVariable ) node ; \nDapType basetype = var . getBaseType ( ) ; \nif ( basetype . isEnumType ( ) ) { \nprintXMLAttribute ( \"enum\" , basetype . getTypeName ( ) , flags ) ; \n} \nbreak ; \ncase ATTRIBUTE : DapAttribute attr = ( DapAttribute ) node ; \nbasetype = attr . getBaseType ( ) ; \nprintXMLAttribute ( \"type\" , basetype . getTypeName ( ) , flags ) ; \nif ( attr . getBaseType ( ) . isEnumType ( ) ) { \nprintXMLAttribute ( \"enum\" , basetype . getTypeName ( ) , flags ) ; \n} \nbreak ; \ndefault : break ; \n} \nif ( ! this . testing ) printReserved ( node ) ; \nif ( ( flags & PERLINE ) != 0 ) { \nprinter . outdent ( 2 ) ; \n} \n} \n} \n"}
{"4814": "public class DMRPrinter { \nprotected void printXMLAttribute ( String name , String value , int flags ) throws DapException { \nif ( name == null ) return ; \nif ( ( flags & NONNIL ) == 0 ) { \nif ( value == null || value . length ( ) == 0 ) return ; \n} \nif ( ( flags & PERLINE ) != 0 ) { \nprinter . eol ( ) ; \nprinter . margin ( ) ; \n} \nprinter . print ( \" \" + name + \"=\" ) ; \nprinter . print ( \"\\\"\" ) ; \nif ( value != null ) { \nif ( ( flags & XMLESCAPED ) == 0 ) value = Escape . entityEscape ( value , \"\\\"\" ) ; \nprinter . print ( value ) ; \n} \nprinter . print ( \"\\\"\" ) ; \n} \n} \n"}
{"4818": "public class AreaReader { \nprivate void setAreaDirectoryAttributes ( Variable v ) { \nif ( dirBlock == null ) { \nreturn ; \n} \nelse if ( ad == null ) { \nreturn ; \n} \nfor ( int i = 1 ; \ni < 14 ; \ni ++ ) { \nif ( i == 7 ) { \ncontinue ; \n} \nv . addAttribute ( new Attribute ( getADDescription ( i ) , dirBlock [ i ] ) ) ; \n} \n} \n} \n"}
{"4819": "public class AreaReader { \nprivate void setNavBlockAttributes ( Variable v ) { \nif ( navBlock == null ) { \nreturn ; \n} \nelse if ( ad == null ) { \nreturn ; \n} \nv . addAttribute ( new Attribute ( \"navigation_type\" , McIDASUtil . intBitsToString ( navBlock [ 0 ] ) ) ) ; \n} \n} \n"}
{"4828": "public class CoordsSet { \nprivate CoverageCoordAxis1D findDependent ( CoverageCoordAxis independentAxis , AxisType axisType ) { \nfor ( CoverageCoordAxis axis : axes ) { \nif ( axis . getDependenceType ( ) == CoverageCoordAxis . DependenceType . dependent ) { \nfor ( String axisName : axis . dependsOn ) { \nif ( axisName . equalsIgnoreCase ( independentAxis . getName ( ) ) ) { \nif ( axis . getAxisType ( ) == axisType ) return ( CoverageCoordAxis1D ) axis ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4840": "public class StationRegionDateChooser { \nprotected void redraw ( ) { \nlong tstart = System . currentTimeMillis ( ) ; \njava . awt . Graphics2D gNP = np . getBufferedImageGraphics ( ) ; \nif ( gNP == null ) return ; \ngNP . setBackground ( np . getBackgroundColor ( ) ) ; \njava . awt . Rectangle r = gNP . getClipBounds ( ) ; \ngNP . clearRect ( r . x , r . y , r . width , r . height ) ; \nif ( regionSelect ) { \nif ( geoSelectionMode ) { \nif ( geoSelection != null ) drawBB ( gNP , geoSelection , Color . cyan ) ; \nif ( geoBounds != null ) drawBB ( gNP , geoBounds , null ) ; \nif ( geoSelection != null ) { \nNavigation navigate = np . getNavigation ( ) ; \ndouble handleSize = RubberbandRectangleHandles . handleSizePixels / navigate . getPixPerWorld ( ) ; \nRectangle2D rect = new Rectangle2D . Double ( geoSelection . getX ( ) , geoSelection . getY ( ) , geoSelection . getWidth ( ) , geoSelection . getHeight ( ) ) ; \nRubberbandRectangleHandles . drawHandledRect ( gNP , rect , handleSize ) ; \nif ( debug ) System . out . println ( \"GeoRegionChooser.drawHandledRect=\" + handleSize + \" = \" + geoSelection ) ; \n} \n} \n} \nfor ( int i = 0 ; \ni < renderers . size ( ) ; \ni ++ ) { \nucar . nc2 . ui . util . Renderer rend = ( Renderer ) renderers . get ( i ) ; \nrend . draw ( gNP , atI ) ; \n} \ngNP . dispose ( ) ; \nif ( debug ) { \nlong tend = System . currentTimeMillis ( ) ; \nSystem . out . println ( \"StationRegionDateChooser draw time = \" + ( tend - tstart ) / 1000.0 + \" secs\" ) ; \n} \nnp . repaint ( ) ; \n} \n} \n"}
{"4849": "public class UnitDBImpl { \nprivate static final void addUnique ( final Map < String , Unit > map , final String key , final Unit newUnit ) throws UnitExistsException { \nfinal Unit oldUnit = map . put ( key , newUnit ) ; \nif ( oldUnit != null ) { \nif ( ! oldUnit . equals ( newUnit ) ) { \nthrow new UnitExistsException ( oldUnit , newUnit ) ; \n} \n} \n} \n} \n"}
{"4869": "public class PicturePane { \npublic void zoomToFit ( ) { \nsclPic . setScaleSize ( getSize ( ) ) ; \nif ( sclPic . getStatusCode ( ) == sclPic . LOADED ) { \nsclPic . createScaledPictureInThread ( Thread . MAX_PRIORITY ) ; \n} \nelse if ( sclPic . getStatusCode ( ) == sclPic . READY ) { \nsclPic . createScaledPictureInThread ( Thread . MAX_PRIORITY ) ; \n} \n} \n} \n"}
{"4872": "public class GempakUtil { \npublic static String TG_ITOC ( int [ ] intdtf ) { \nString gdattim = \"\" ; \nif ( ( intdtf [ 0 ] == 0 ) && ( intdtf [ 1 ] == 0 ) ) { \nif ( intdtf [ 2 ] == 0 ) { \nreturn gdattim ; \n} \n} \ngdattim = TI_CDTM ( intdtf [ 0 ] , intdtf [ 1 ] ) ; \nif ( intdtf [ 2 ] != 0 ) { \nString [ ] timeType = TG_CFTM ( intdtf [ 2 ] ) ; \nString ftype = timeType [ 0 ] ; \nString ftime = timeType [ 1 ] ; \ngdattim = gdattim . substring ( 0 , 11 ) + ftype + ftime ; \n} \nreturn gdattim ; \n} \n} \n"}
{"4874": "public class GempakUtil { \npublic static int TI_DAYM ( int iyear , int imon ) { \nint iday = 0 ; \nif ( imon > 0 ) { \nif ( imon < 13 ) { \niday = month [ imon - 1 ] ; \nif ( imon == 2 ) { \nif ( LEAP ( iyear ) ) { \niday = iday + 1 ; \n} \n} \n} \n} \nreturn iday ; \n} \n} \n"}
{"4879": "public class DataDDS { \npublic void readData ( InputStream is , StatusUI statusUI ) throws IOException , EOFException , DAP2Exception { \nBufferedInputStream bufferedIS = new BufferedInputStream ( is ) ; \nDataInputStream dataIS = new DataInputStream ( bufferedIS ) ; \nfor ( Enumeration e = getVariables ( ) ; \ne . hasMoreElements ( ) ; \n) { \nif ( statusUI != null ) { \nif ( statusUI . userCancelled ( ) ) throw new DataReadException ( \"User cancelled\" ) ; \n} \nClientIO bt = ( ClientIO ) e . nextElement ( ) ; \nbt . deserialize ( dataIS , ver , statusUI ) ; \n} \nif ( statusUI != null ) statusUI . finished ( ) ; \n} \n} \n"}
{"4888": "public class SpatialGrid { \npublic boolean markIfClear ( Rectangle2D rect , Object o ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( debugMark ) System . out . println ( \"markIfClear \" + rect + \" \" + indexX + \" \" + indexY ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) ) return false ; \nelse if ( indexY >= countY ) return false ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return false ; \nif ( null != findIntersection ( rect ) ) return false ; \ngwant . used = true ; \ngwant . objectBB = rect ; \ngwant . o = o ; \nreturn true ; \n} \n} \n"}
{"4889": "public class SpatialGrid { \npublic Object findIntersection ( Rectangle2D rect ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) ) return null ; \nelse if ( indexY >= countY ) return null ; \nfor ( int y = Math . max ( 0 , indexY - 1 ) ; \ny <= Math . min ( countY - 1 , indexY + 1 ) ; \ny ++ ) { \nfor ( int x = Math . max ( 0 , indexX - 1 ) ; \nx <= Math . min ( countX - 1 , indexX + 1 ) ; \nx ++ ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) continue ; \nif ( intersectsOverlap ( rect , gtest . objectBB ) ) return gtest . o ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4890": "public class SpatialGrid { \npublic Object findIntersection ( Point2D p ) { \nint indexX = ( int ) ( ( p . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( p . getY ( ) - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) ) return null ; \nelse if ( indexY >= countY ) return null ; \nfor ( int y = Math . max ( 0 , indexY - 1 ) ; \ny <= Math . min ( countY - 1 , indexY + 1 ) ; \ny ++ ) { \nfor ( int x = Math . max ( 0 , indexX - 1 ) ; \nx <= Math . min ( countX - 1 , indexX + 1 ) ; \nx ++ ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) continue ; \nif ( gtest . objectBB . contains ( p . getX ( ) , p . getY ( ) ) ) return gtest . o ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4891": "public class SpatialGrid { \npublic Object findClosest ( Point2D pt ) { \nObject o = null ; \nint indexX = ( int ) ( ( pt . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( pt . getY ( ) - offsetY ) / gridHeight ) ; \nif ( debugClosest ) System . out . println ( \"findClosest \" + pt + \" \" + indexX + \" \" + indexY ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) ) return null ; \nelse if ( indexY >= countY ) return null ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return gwant . o ; \nfor ( int p = 1 ; \np < Math . max ( countX - 1 , countY - 1 ) ; \np ++ ) if ( null != ( o = findClosestAlongPerimeter ( pt , indexX , indexY , p ) ) ) return o ; \nreturn null ; \n} \n} \n"}
{"4892": "public class SpatialGrid { \nprivate double distanceSq ( Point2D pt , int indexX , int indexY ) { \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) ) return MAX_DOUBLE ; \nelse if ( indexY >= countY ) return MAX_DOUBLE ; \nGridCell gtest = gridArray [ indexY ] [ indexX ] ; \nif ( ! gtest . used ) return MAX_DOUBLE ; \nRectangle2D rect = gtest . objectBB ; \ndouble dx = rect . getX ( ) + rect . getWidth ( ) / 2 - pt . getX ( ) ; \ndouble dy = rect . getY ( ) + rect . getHeight ( ) / 2 - pt . getY ( ) ; \nreturn ( dx * dx + dy * dy ) ; \n} \n} \n"}
{"4893": "public class BaseUnit { \npublic static synchronized BaseUnit getOrCreate ( final UnitName id , final BaseQuantity baseQuantity ) throws NameException , UnitExistsException { \nBaseUnit baseUnit ; \nfinal BaseUnit nameUnit = nameMap . get ( id ) ; \nfinal BaseUnit quantityUnit = quantityMap . get ( baseQuantity ) ; \nif ( nameUnit != null || quantityUnit != null ) { \nbaseUnit = nameUnit != null ? nameUnit : quantityUnit ; \nif ( nameUnit != null && ! baseQuantity . equals ( nameUnit . getBaseQuantity ( ) ) ) { \nthrow new UnitExistsException ( \"Attempt to incompatibly redefine base unit \\\"\" + baseUnit + '\"' ) ; \n} \nelse if ( quantityUnit != null && ! id . equals ( quantityUnit . getUnitName ( ) ) ) { \nthrow new UnitExistsException ( \"Attempt to incompatibly redefine base unit \\\"\" + baseUnit + '\"' ) ; \n} \n} \nelse { \nbaseUnit = new BaseUnit ( id , baseQuantity ) ; \nquantityMap . put ( baseQuantity , baseUnit ) ; \nnameMap . put ( id , baseUnit ) ; \n} \nreturn baseUnit ; \n} \n} \n"}
{"4894": "public class DatasetUrl { \nstatic private ServiceType searchFragment ( String fragment ) { \nif ( fragment . length ( ) == 0 ) return null ; \nMap < String , String > map = parseFragment ( fragment ) ; \nif ( map == null ) return null ; \nString protocol = map . get ( \"protocol\" ) ; \nif ( protocol == null ) { \nfor ( String p : FRAGPROTOCOLS ) { \nif ( map . get ( p ) != null ) { \nprotocol = p ; \nbreak ; \n} \n} \n} \nif ( protocol != null ) { \nif ( protocol . equalsIgnoreCase ( \"dap\" ) ) return ServiceType . OPENDAP ; \nelse if ( protocol . equalsIgnoreCase ( \"dods\" ) ) return ServiceType . OPENDAP ; \nif ( protocol . equalsIgnoreCase ( \"dap4\" ) ) return ServiceType . DAP4 ; \nif ( protocol . equalsIgnoreCase ( \"cdmremote\" ) ) return ServiceType . CdmRemote ; \nif ( protocol . equalsIgnoreCase ( \"thredds\" ) ) return ServiceType . THREDDS ; \nif ( protocol . equalsIgnoreCase ( \"ncml\" ) ) return ServiceType . NCML ; \n} \nreturn null ; \n} \n} \n"}
{"4895": "public class DatasetUrl { \nstatic private ServiceType searchPath ( String url ) { \nif ( false ) { \nif ( url == null ) return null ; \nelse if ( url . length ( ) == 0 ) return null ; \nurl = url . toLowerCase ( ) ; \nfor ( int i = 0 ; \ni < FRAGPROTOCOLS . length ; \ni ++ ) { \nString p = FRAGPROTOCOLS [ i ] ; \nif ( url . indexOf ( \"/thredds/\" + p . toLowerCase ( ) + \"/\" ) >= 0 ) { \nreturn FRAGPROTOSVCTYPE [ i ] ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4896": "public class DatasetUrl { \nstatic private ServiceType decodePathExtension ( String path ) { \nif ( path . endsWith ( \".dds\" ) || path . endsWith ( \".das\" ) ) return ServiceType . OPENDAP ; \nelse if ( path . endsWith ( \".dods\" ) ) return ServiceType . OPENDAP ; \nif ( path . endsWith ( \".dmr\" ) || path . endsWith ( \".dap\" ) ) return ServiceType . DAP4 ; \nelse if ( path . endsWith ( \".dsr\" ) ) return ServiceType . DAP4 ; \nif ( path . endsWith ( \".xml\" ) ) return ServiceType . NCML ; \nelse if ( path . endsWith ( \".ncml\" ) ) return ServiceType . NCML ; \nreturn null ; \n} \n} \n"}
{"4897": "public class DatasetUrl { \nstatic private ServiceType checkIfDods ( String location ) throws IOException { \nint len = location . length ( ) ; \nif ( location . endsWith ( \".dds\" ) ) location = location . substring ( 0 , len - \".dds\" . length ( ) ) ; \nif ( location . endsWith ( \".das\" ) ) location = location . substring ( 0 , len - \".das\" . length ( ) ) ; \nif ( location . endsWith ( \".dods\" ) ) location = location . substring ( 0 , len - \".dods\" . length ( ) ) ; \ntry ( HTTPMethod method = HTTPFactory . Get ( location + \".dds\" ) ) { \nint status = method . execute ( ) ; \nif ( status == 200 ) { \nHeader h = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( h != null ) { \nif ( h . getValue ( ) != null ) { \nString v = h . getValue ( ) ; \nif ( v . equalsIgnoreCase ( \"dods-dds\" ) || v . equalsIgnoreCase ( \"dods_dds\" ) ) return ServiceType . OPENDAP ; \nelse throw new IOException ( \"OPeNDAP Server Error= \" + method . getResponseAsString ( ) ) ; \n} \n} \n} \nif ( status == HttpStatus . SC_UNAUTHORIZED ) throw new IOException ( \"Unauthorized to open dataset \" + location ) ; \nelse if ( status == HttpStatus . SC_FORBIDDEN ) throw new IOException ( \"Unauthorized to open dataset \" + location ) ; \nreturn null ; \n} \n} \n} \n"}
{"4898": "public class DatasetUrl { \nstatic private ServiceType checkIfDap4 ( String location ) throws IOException { \nif ( location . endsWith ( \".dap\" ) ) location = location . substring ( 0 , location . length ( ) - \".dap\" . length ( ) ) ; \nelse if ( location . endsWith ( \".dmr\" ) ) location = location . substring ( 0 , location . length ( ) - \".dmr\" . length ( ) ) ; \nelse if ( location . endsWith ( \".dmr.xml\" ) ) location = location . substring ( 0 , location . length ( ) - \".dmr.xml\" . length ( ) ) ; \nelse if ( location . endsWith ( \".dsr\" ) ) location = location . substring ( 0 , location . length ( ) - \".dsr\" . length ( ) ) ; \ntry ( HTTPMethod method = HTTPFactory . Get ( location + \".dmr.xml\" ) ) { \nint status = method . execute ( ) ; \nif ( status == 200 ) { \nHeader h = method . getResponseHeader ( \"Content-Type\" ) ; \nif ( h != null ) { \nif ( h . getValue ( ) != null ) { \nString v = h . getValue ( ) ; \nif ( v . startsWith ( \"application/vnd.opendap.org\" ) ) return ServiceType . DAP4 ; \n} \n} \n} \nif ( status == HttpStatus . SC_UNAUTHORIZED ) throw new IOException ( \"Unauthorized to open dataset \" + location ) ; \nelse if ( status == HttpStatus . SC_FORBIDDEN ) throw new IOException ( \"Unauthorized to open dataset \" + location ) ; \nreturn null ; \n} \n} \n} \n"}
{"4902": "public class DapUtil { \nstatic public String locateFile ( String filename , String abspath , boolean wantdir ) { \nDeque < String > q = new ArrayDeque < String > ( ) ; \nfilename = filename . trim ( ) . replace ( '\\\\' , '/' ) ; \nabspath = abspath . trim ( ) . replace ( '\\\\' , '/' ) ; \nif ( filename . charAt ( 0 ) == '/' ) filename = filename . substring ( 1 ) ; \nif ( filename . endsWith ( \"/\" ) ) filename = filename . substring ( 0 , filename . length ( ) - 1 ) ; \nif ( abspath . endsWith ( \"/\" ) ) abspath = abspath . substring ( 0 , abspath . length ( ) - 1 ) ; \nq . addFirst ( abspath ) ; \nfor ( ; \n; \n) { \nString currentpath = q . poll ( ) ; \nif ( currentpath == null ) break ; \nFile current = new File ( currentpath ) ; \nFile [ ] contents = current . listFiles ( ) ; \nif ( contents != null ) { \nfor ( File subfile : contents ) { \nif ( ! subfile . getName ( ) . equals ( filename ) ) continue ; \nif ( wantdir && subfile . isDirectory ( ) ) { \nreturn DapUtil . canonicalpath ( subfile . getAbsolutePath ( ) ) ; \n} \nelse if ( ! wantdir && subfile . isFile ( ) ) { \nreturn DapUtil . canonicalpath ( subfile . getAbsolutePath ( ) ) ; \n} \n} \nfor ( File subfile : contents ) { \nif ( subfile . isDirectory ( ) ) q . addFirst ( currentpath + \"/\" + subfile . getName ( ) ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4907": "public class DapUtil { \nstatic public String join ( String [ ] array , String sep , int from , int upto ) { \nif ( sep == null ) sep = \"\" ; \nif ( from < 0 ) throw new IndexOutOfBoundsException ( ) ; \nelse if ( upto > array . length ) throw new IndexOutOfBoundsException ( ) ; \nif ( upto <= from ) return \"\" ; \nStringBuilder result = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( int i = from ; \ni < upto ; \ni ++ , first = false ) { \nif ( ! first ) result . append ( sep ) ; \nresult . append ( array [ i ] ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"4908": "public class DapUtil { \nstatic public boolean hasDriveLetter ( String path ) { \nboolean hasdr = false ; \nif ( path != null ) { \nif ( path . length ( ) >= 2 ) { \nhasdr = ( DRIVELETTERS . indexOf ( path . charAt ( 0 ) ) >= 0 && path . charAt ( 1 ) == ':' ) ; \n} \n} \nreturn hasdr ; \n} \n} \n"}
{"4909": "public class DapUtil { \nstatic public List < String > getProtocols ( String url , int [ ] breakpoint ) { \nList < String > allprotocols = new ArrayList < > ( ) ; \nStringBuilder buf = new StringBuilder ( url ) ; \nint protosize = 0 ; \nfor ( ; \n; \n) { \nint index = buf . indexOf ( \":\" ) ; \nif ( index < 0 ) break ; \nString protocol = buf . substring ( 0 , index ) ; \nif ( index == 1 ) { \nif ( \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" . indexOf ( buf . charAt ( 0 ) ) >= 0 ) break ; \n} \nallprotocols . add ( protocol ) ; \nbuf . delete ( 0 , index + 1 ) ; \nprotosize += ( index + 1 ) ; \nif ( buf . indexOf ( \"/\" ) == 0 ) break ; \n} \nbreakpoint [ 0 ] = protosize ; \nreturn allprotocols ; \n} \n} \n"}
{"4919": "public class DapGroup { \npublic void addDecl ( DapNode newdecl ) throws DapException { \nDapSort newsort = newdecl . getSort ( ) ; \nString newname = newdecl . getShortName ( ) ; \nboolean suppress = false ; \nif ( newsort != DapSort . DIMENSION || newname != null ) { \nfor ( DapNode decl : decls ) { \nif ( newsort == decl . getSort ( ) ) { \nif ( newname . equals ( decl . getShortName ( ) ) ) throw new DapException ( \"DapGroup: attempt to add duplicate decl: \" + newname ) ; \n} \n} \n} \nelse { \nDapDimension anon = ( DapDimension ) newdecl ; \nassert ( newsort == DapSort . DIMENSION && newname == null ) ; \nboolean found = false ; \nfor ( DapDimension dim : dimensions ) { \nif ( ! dim . isShared ( ) ) { \nif ( dim . getSize ( ) == anon . getSize ( ) ) { \nfound = true ; \nbreak ; \n} \n} \n} \nif ( ! found ) { \nif ( ! isTopLevel ( ) ) getDataset ( ) . addDecl ( anon ) ; \n} \nsuppress = found || ! isTopLevel ( ) ; \n} \nif ( ! suppress ) { \ndecls . add ( newdecl ) ; \nnewdecl . setParent ( this ) ; \n} \nswitch ( newdecl . getSort ( ) ) { \ncase ATTRIBUTE : case ATTRIBUTESET : case OTHERXML : super . addAttribute ( ( DapAttribute ) newdecl ) ; \nbreak ; \ncase DIMENSION : if ( ! suppress ) dimensions . add ( ( DapDimension ) newdecl ) ; \nbreak ; \ncase ENUMERATION : enums . add ( ( DapEnumeration ) newdecl ) ; \nbreak ; \ncase ATOMICTYPE : break ; \ncase STRUCTURE : case SEQUENCE : compounds . add ( ( DapStructure ) newdecl ) ; \nbreak ; \ncase VARIABLE : variables . add ( ( DapVariable ) newdecl ) ; \nbreak ; \ncase GROUP : case DATASET : if ( this != ( DapGroup ) newdecl ) groups . add ( ( DapGroup ) newdecl ) ; \nbreak ; \ndefault : throw new ClassCastException ( newdecl . getShortName ( ) ) ; \n} \n} \n} \n"}
{"4922": "public class COARDSConvention { \nprotected AxisType getAxisType ( NetcdfDataset ncDataset , VariableEnhanced v ) { \nString unit = v . getUnitsString ( ) ; \nif ( unit == null ) return null ; \nunit = unit . trim ( ) ; \nif ( unit . equalsIgnoreCase ( \"degrees_east\" ) || unit . equalsIgnoreCase ( \"degrees_E\" ) || unit . equalsIgnoreCase ( \"degreesE\" ) || unit . equalsIgnoreCase ( \"degree_east\" ) || unit . equalsIgnoreCase ( \"degree_E\" ) ) return AxisType . Lon ; \nelse if ( unit . equalsIgnoreCase ( \"degreeE\" ) ) return AxisType . Lon ; \nif ( unit . equalsIgnoreCase ( \"degrees_north\" ) || unit . equalsIgnoreCase ( \"degrees_N\" ) || unit . equalsIgnoreCase ( \"degreesN\" ) || unit . equalsIgnoreCase ( \"degree_north\" ) || unit . equalsIgnoreCase ( \"degree_N\" ) ) return AxisType . Lat ; \nelse if ( unit . equalsIgnoreCase ( \"degreeN\" ) ) return AxisType . Lat ; \nif ( SimpleUnit . isDateUnit ( unit ) ) { \nreturn AxisType . Time ; \n} \nif ( SimpleUnit . isCompatible ( \"mbar\" , unit ) ) return AxisType . Pressure ; \nif ( unit . equalsIgnoreCase ( \"level\" ) || unit . equalsIgnoreCase ( \"layer\" ) ) return AxisType . GeoZ ; \nelse if ( unit . equalsIgnoreCase ( \"sigma_level\" ) ) return AxisType . GeoZ ; \nString positive = ncDataset . findAttValueIgnoreCase ( ( Variable ) v , CF . POSITIVE , null ) ; \nif ( positive != null ) { \nif ( SimpleUnit . isCompatible ( \"m\" , unit ) ) return AxisType . Height ; \nelse return AxisType . GeoZ ; \n} \nreturn null ; \n} \n} \n"}
{"4931": "public class HTTPSession { \nsynchronized protected void setAuthenticationAndProxy ( HttpClientBuilder cb ) throws HTTPException { \ncb . setSSLSocketFactory ( ( SSLConnectionSocketFactory ) authcontrols . get ( AuthProp . SSLFACTORY ) ) ; \nAuthScope bestMatch = HTTPAuthUtil . bestmatch ( scope , localcreds . keySet ( ) ) ; \nCredentialsProvider cp = null ; \nif ( bestMatch != null ) { \ncp = localcreds . get ( bestMatch ) ; \n} \nelse { \nbestMatch = HTTPAuthUtil . bestmatch ( scope , globalcredfactories . keySet ( ) ) ; \nif ( bestMatch != null ) { \nHTTPProviderFactory factory = globalcredfactories . get ( bestMatch ) ; \ncp = factory . getProvider ( bestMatch ) ; \n} \n} \nCredentials proxycreds = null ; \nAuthScope proxyscope = null ; \nString user = ( String ) authcontrols . get ( AuthProp . PROXYUSER ) ; \nString pwd = ( String ) authcontrols . get ( AuthProp . PROXYPWD ) ; \nHttpHost httpproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPPROXY ) ; \nHttpHost httpsproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPSPROXY ) ; \nif ( user != null ) { \nif ( httpproxy != null || httpsproxy != null ) { \nif ( httpproxy != null ) proxyscope = HTTPAuthUtil . hostToAuthScope ( httpproxy ) ; \nelse proxyscope = HTTPAuthUtil . hostToAuthScope ( httpsproxy ) ; \nproxycreds = new UsernamePasswordCredentials ( user , pwd ) ; \n} \n} \nif ( cp == null && proxycreds != null && proxyscope != null ) { \ncp = new BasicCredentialsProvider ( ) ; \ncp . setCredentials ( proxyscope , proxycreds ) ; \n} \nelse if ( cp != null && proxycreds != null ) { \nif ( proxyscope != null ) { \ncp . setCredentials ( proxyscope , proxycreds ) ; \n} \n} \nif ( cp != null ) this . sessioncontext . setCredentialsProvider ( cp ) ; \n} \n} \n"}
{"4937": "public class Index { \nIndex section ( List < Range > ranges ) throws InvalidRangeException { \nif ( ranges . size ( ) != rank ) throw new InvalidRangeException ( \"Bad ranges [] length\" ) ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) continue ; \nif ( r == Range . VLEN ) continue ; \nif ( r . first ( ) < 0 ) throw new InvalidRangeException ( \"Bad range starting value at index \" + ii + \" == \" + r . first ( ) ) ; \nelse if ( r . first ( ) >= shape [ ii ] ) throw new InvalidRangeException ( \"Bad range starting value at index \" + ii + \" == \" + r . first ( ) ) ; \nif ( r . last ( ) < 0 ) throw new InvalidRangeException ( \"Bad range ending value at index \" + ii + \" == \" + r . last ( ) ) ; \nelse if ( r . last ( ) >= shape [ ii ] ) throw new InvalidRangeException ( \"Bad range ending value at index \" + ii + \" == \" + r . last ( ) ) ; \n} \nint reducedRank = rank ; \nfor ( Range r : ranges ) { \nif ( r != null ) { \nif ( r . length ( ) == 1 ) reducedRank -- ; \n} \n} \nIndex newindex = Index . factory ( reducedRank ) ; \nnewindex . offset = offset ; \nint newDim = 0 ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) { \nnewindex . shape [ newDim ] = shape [ ii ] ; \nnewindex . stride [ newDim ] = stride [ ii ] ; \nnewDim ++ ; \n} \nelse if ( r . length ( ) != 1 ) { \nnewindex . shape [ newDim ] = r . length ( ) ; \nnewindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; \nnewindex . offset += stride [ ii ] * r . first ( ) ; \nnewDim ++ ; \n} \nelse { \nnewindex . offset += stride [ ii ] * r . first ( ) ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator && ( newindex . size == size ) ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4939": "public class Index { \nIndex reduce ( int dim ) { \nif ( dim < 0 ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim ) ; \nelse if ( dim >= rank ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim ) ; \nif ( shape [ dim ] != 1 ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim + \" : length != 1\" ) ; \nIndex newindex = Index . factory ( rank - 1 ) ; \nnewindex . offset = offset ; \nint count = 0 ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nif ( ii != dim ) { \nnewindex . shape [ count ] = shape [ ii ] ; \nnewindex . stride [ count ] = stride [ ii ] ; \ncount ++ ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4940": "public class Index { \nIndex transpose ( int index1 , int index2 ) { \nif ( index1 < 0 ) throw new IllegalArgumentException ( ) ; \nelse if ( index1 >= rank ) throw new IllegalArgumentException ( ) ; \nif ( index2 < 0 ) throw new IllegalArgumentException ( ) ; \nelse if ( index2 >= rank ) throw new IllegalArgumentException ( ) ; \nIndex newIndex = ( Index ) this . clone ( ) ; \nnewIndex . stride [ index1 ] = stride [ index2 ] ; \nnewIndex . stride [ index2 ] = stride [ index1 ] ; \nnewIndex . shape [ index1 ] = shape [ index2 ] ; \nnewIndex . shape [ index2 ] = shape [ index1 ] ; \nnewIndex . fastIterator = false ; \nnewIndex . precalc ( ) ; \nreturn newIndex ; \n} \n} \n"}
{"4941": "public class Index { \nIndex permute ( int [ ] dims ) { \nif ( dims . length != shape . length ) throw new IllegalArgumentException ( ) ; \nfor ( int dim : dims ) if ( dim < 0 ) throw new IllegalArgumentException ( ) ; \nelse if ( dim >= rank ) throw new IllegalArgumentException ( ) ; \nboolean isPermuted = false ; \nIndex newIndex = ( Index ) this . clone ( ) ; \nfor ( int i = 0 ; \ni < dims . length ; \ni ++ ) { \nnewIndex . stride [ i ] = stride [ dims [ i ] ] ; \nnewIndex . shape [ i ] = shape [ dims [ i ] ] ; \nif ( i != dims [ i ] ) isPermuted = true ; \n} \nnewIndex . fastIterator = fastIterator && ! isPermuted ; \nnewIndex . precalc ( ) ; \nreturn newIndex ; \n} \n} \n"}
{"4945": "public class Index { \npublic void setDim ( int dim , int value ) { \nif ( value < 0 ) throw new ArrayIndexOutOfBoundsException ( ) ; \nelse if ( value >= shape [ dim ] ) throw new ArrayIndexOutOfBoundsException ( ) ; \nif ( shape [ dim ] >= 0 ) current [ dim ] = value ; \n} \n} \n"}
{"4949": "public class AbstractGempakStationFileReader { \nprotected List < String > makeDateList ( boolean unique ) { \nKey date = dateTimeKeys . get ( 0 ) ; \nKey time = dateTimeKeys . get ( 1 ) ; \nList < int [ ] > toCheck ; \nif ( date . type . equals ( ROW ) ) { \ntoCheck = headers . rowHeaders ; \n} \nelse { \ntoCheck = headers . colHeaders ; \n} \nList < String > fileDates = new ArrayList < > ( ) ; \nfor ( int [ ] header : toCheck ) { \nif ( header [ 0 ] != IMISSD ) { \nint idate = header [ date . loc + 1 ] ; \nint itime = header [ time . loc + 1 ] ; \nString dateTime = GempakUtil . TI_CDTM ( idate , itime ) ; \nfileDates . add ( dateTime ) ; \n} \n} \nif ( unique ) { \nif ( ! fileDates . isEmpty ( ) ) { \nSortedSet < String > uniqueTimes = Collections . synchronizedSortedSet ( new TreeSet < String > ( ) ) ; \nuniqueTimes . addAll ( fileDates ) ; \nfileDates . clear ( ) ; \nfileDates . addAll ( uniqueTimes ) ; \n} \n} \nreturn fileDates ; \n} \n} \n"}
{"4952": "public class AbstractGempakStationFileReader { \nprivate GempakStation makeStation ( int [ ] header ) { \nif ( stationKeys == null ) { \nreturn null ; \n} \nelse if ( stationKeys . isEmpty ( ) ) { \nreturn null ; \n} \nGempakStation newStation = new GempakStation ( ) ; \nfor ( Key key : stationKeys ) { \nint loc = key . loc + 1 ; \nswitch ( key . name ) { \ncase GempakStation . STID : newStation . setSTID ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . STNM : newStation . setSTNM ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SLAT : newStation . setSLAT ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SLON : newStation . setSLON ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SELV : newStation . setSELV ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . SPRI : newStation . setSPRI ( header [ loc ] ) ; \nbreak ; \ncase GempakStation . STAT : newStation . setSTAT ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . COUN : newStation . setCOUN ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . SWFO : newStation . setSWFO ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . WFO2 : newStation . setWFO2 ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \ncase GempakStation . STD2 : newStation . setSTD2 ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; \nbreak ; \n} \n} \nreturn newStation ; \n} \n} \n"}
{"4953": "public class AbstractGempakStationFileReader { \npublic List < String > getStationKeyNames ( ) { \nList < String > keys = new ArrayList < > ( ) ; \nif ( stationKeys != null ) { \nif ( ! stationKeys . isEmpty ( ) ) { \nfor ( Key key : stationKeys ) { \nkeys . add ( key . name ) ; \n} \n} \n} \nreturn keys ; \n} \n} \n"}
{"4954": "public class AbstractGempakStationFileReader { \npublic List < Date > getDates ( ) { \nif ( dates == null || dates . isEmpty ( ) ) { \nif ( ! dateList . isEmpty ( ) ) { \ndates = new ArrayList < > ( dateList . size ( ) ) ; \ndateFmt . setTimeZone ( TimeZone . getTimeZone ( \"GMT\" ) ) ; \nfor ( String dateString : dateList ) { \nDate d = dateFmt . parse ( dateString , new ParsePosition ( 0 ) ) ; \ndates . add ( d ) ; \n} \n} \n} \nreturn dates ; \n} \n} \n"}
{"4960": "public class MFileCollectionManager { \npublic void addDirectoryScan ( String dirName , String suffix , String regexpPatternString , String subdirsS , String olderS , Object auxInfo ) { \nCompositeMFileFilter filters = new CompositeMFileFilter ( ) ; \nif ( null != regexpPatternString ) filters . addIncludeFilter ( new RegExpMatchOnName ( regexpPatternString ) ) ; \nelse if ( suffix != null ) filters . addIncludeFilter ( new WildcardMatchOnPath ( \"*\" + suffix + \"$\" ) ) ; \nif ( olderS != null ) { \ntry { \nTimeDuration tu = new TimeDuration ( olderS ) ; \nfilters . addAndFilter ( new LastModifiedLimit ( ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ) ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( collectionName + \": Invalid time unit for olderThan = {}\" , olderS ) ; \n} \n} \nboolean wantSubdirs = true ; \nif ( subdirsS != null ) { \nif ( subdirsS . equalsIgnoreCase ( \"false\" ) ) wantSubdirs = false ; \n} \nCollectionConfig mc = new CollectionConfig ( dirName , dirName , wantSubdirs , filters , auxInfo ) ; \nStringBuilder sb = new StringBuilder ( dirName ) ; \nif ( wantSubdirs ) sb . append ( \"**/\" ) ; \nif ( null != regexpPatternString ) sb . append ( regexpPatternString ) ; \nelse if ( suffix != null ) sb . append ( suffix ) ; \nelse sb . append ( \"noFilter\" ) ; \ncollectionName = sb . toString ( ) ; \nscanList . add ( mc ) ; \n} \n} \n"}
{"4961": "public class MFileCollectionManager { \n@ Override public boolean isScanNeeded ( ) { \nif ( recheck == null ) { \nlogger . debug ( \"{}: scan not needed, recheck null\" , collectionName ) ; \nreturn false ; \n} \nif ( ! hasScans ( ) ) { \nlogger . debug ( \"{}: scan not needed, no scanners\" , collectionName ) ; \nreturn false ; \n} \nsynchronized ( this ) { \nif ( map == null ) { \nif ( ! isStatic ( ) ) { \nlogger . debug ( \"{}: scan needed, never scanned\" , collectionName ) ; \nreturn true ; \n} \n} \n} \nDate now = new Date ( ) ; \nDate lastCheckedDate = new Date ( getLastScanned ( ) ) ; \nDate need = recheck . add ( lastCheckedDate ) ; \nif ( now . before ( need ) ) { \nlogger . debug ( \"{}: scan not needed, last scanned={}, now={}\" , collectionName , lastCheckedDate , now ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"4965": "public class FileWriter2 { \npublic NetcdfFile write ( CancelTask cancel ) throws IOException { \ntry { \nif ( version . isExtendedModel ( ) ) addGroupExtended ( null , fileIn . getRootGroup ( ) ) ; \nelse addGroupClassic ( ) ; \nif ( cancel != null ) { \nif ( cancel . isCancel ( ) ) return null ; \n} \nwriter . create ( ) ; \nif ( cancel != null ) { \nif ( cancel . isCancel ( ) ) return null ; \n} \ndouble total = copyVarData ( varList , null , cancel ) ; \nif ( cancel != null ) { \nif ( cancel . isCancel ( ) ) return null ; \n} \nwriter . flush ( ) ; \nif ( debug ) System . out . println ( \"FileWriter done total bytes = \" + total ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \nwriter . abort ( ) ; \nthrow ioe ; \n} \nreturn writer . getNetcdfFile ( ) ; \n} \n} \n"}
{"4966": "public class MarshallingUtil { \npublic static void validate ( XmlObject doc , boolean strict ) throws XmlException { \nSet < XmlError > validationErrors = new HashSet < > ( ) ; \nXmlOptions validationOptions = new XmlOptions ( ) ; \nvalidationOptions . setErrorListener ( validationErrors ) ; \nfinal boolean isValid = doc . validate ( validationOptions ) ; \nif ( ! isValid ) { \nif ( ! strict ) { \nvalidationErrors = filterToOnlySerious ( validationErrors ) ; \n} \n} \nif ( ! validationErrors . isEmpty ( ) ) { \nthrow new XmlException ( createErrorMessage ( validationErrors ) ) ; \n} \n} \n} \n"}
{"4971": "public class StructureDS { \nprivate boolean convertNeeded ( StructureMembers smData ) { \nfor ( Variable v : getVariables ( ) ) { \nif ( v instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v ; \nif ( vds . needConvert ( ) ) return true ; \n} \nelse if ( v instanceof StructureDS ) { \nStructureDS nested = ( StructureDS ) v ; \nif ( nested . convertNeeded ( null ) ) return true ; \n} \nif ( smData != null ) { \nif ( ! varHasData ( v , smData ) ) return true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4972": "public class StructureDS { \nprotected ArrayStructure convert ( Array data , Section section ) throws IOException { \nArrayStructure orgAS = ( ArrayStructure ) data ; \nif ( ! convertNeeded ( orgAS . getStructureMembers ( ) ) ) { \nconvertMemberInfo ( orgAS . getStructureMembers ( ) ) ; \nreturn orgAS ; \n} \nArrayStructure newAS = ArrayStructureMA . factoryMA ( orgAS ) ; \nfor ( StructureMembers . Member m : newAS . getMembers ( ) ) { \nVariableEnhanced v2 = ( VariableEnhanced ) findVariable ( m . getName ( ) ) ; \nif ( v2 == null ) { \nif ( orgVar != null ) v2 = findVariableFromOrgName ( m . getName ( ) ) ; \n} \nif ( v2 == null ) continue ; \nif ( v2 instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v2 ; \nif ( vds . needConvert ( ) ) { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = vds . convert ( mdata , vds . getEnhanceMode ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \nelse if ( v2 instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v2 ; \nif ( innerStruct . convertNeeded ( null ) ) { \nif ( innerStruct . getDataType ( ) == DataType . SEQUENCE ) { \nArrayObject . D1 seqArray = ( ArrayObject . D1 ) newAS . extractMemberArray ( m ) ; \nArrayObject . D1 newSeq = ( ArrayObject . D1 ) Array . factory ( DataType . SEQUENCE , new int [ ] { \n( int ) seqArray . getSize ( ) } \n) ; \nm . setDataArray ( newSeq ) ; \nfor ( int i = 0 ; \ni < seqArray . getSize ( ) ; \ni ++ ) { \nArraySequence innerSeq = ( ArraySequence ) seqArray . get ( i ) ; \nnewSeq . set ( i , new SequenceConverter ( innerStruct , innerSeq ) ) ; \n} \n} \nelse { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = innerStruct . convert ( mdata , null ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \nStructureMembers sm = newAS . getStructureMembers ( ) ; \nconvertMemberInfo ( sm ) ; \nfor ( Variable v : getVariables ( ) ) { \nif ( ! varHasData ( v , sm ) ) { \ntry { \nVariable completeVar = getParentGroup ( ) . findVariable ( v . getShortName ( ) ) ; \nArray mdata = completeVar . read ( section ) ; \nStructureMembers . Member m = sm . addMember ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) , v . getShape ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \ncatch ( InvalidRangeException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \nreturn newAS ; \n} \n} \n"}
{"4973": "public class StructureDS { \nprivate void convertMemberInfo ( StructureMembers wrapperSm ) { \nfor ( StructureMembers . Member m : wrapperSm . getMembers ( ) ) { \nVariable v = findVariable ( m . getName ( ) ) ; \nif ( v == null ) { \nif ( orgVar != null ) v = ( Variable ) findVariableFromOrgName ( m . getName ( ) ) ; \n} \nif ( v != null ) { \nm . setVariableInfo ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) ) ; \n} \nif ( v instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v ; \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \n} \n} \n"}
{"4974": "public class StructureDS { \nprivate VariableEnhanced findVariableFromOrgName ( String orgName ) { \nfor ( Variable vTop : getVariables ( ) ) { \nVariable v = vTop ; \nwhile ( v instanceof VariableEnhanced ) { \nVariableEnhanced ve = ( VariableEnhanced ) v ; \nif ( ve . getOriginalName ( ) != null ) { \nif ( ve . getOriginalName ( ) . equals ( orgName ) ) return ( VariableEnhanced ) vTop ; \n} \nv = ve . getOriginalVariable ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4981": "public class GempakSoundingIOSP { \nprivate void addVerticalCoordAttribute ( Variable v ) { \nGempakSoundingFileReader gsfr = ( GempakSoundingFileReader ) gemreader ; \nint vertType = gsfr . getVerticalCoordinate ( ) ; \nString pName = v . getFullName ( ) ; \nif ( gemreader . getFileSubType ( ) . equals ( GempakSoundingFileReader . MERGED ) ) { \nif ( ( vertType == GempakSoundingFileReader . PRES_COORD ) && pName . equals ( \"PRES\" ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \n} \nelse if ( vertType == GempakSoundingFileReader . HGHT_COORD ) { \nif ( pName . equals ( \"HGHT\" ) || pName . equals ( \"MHGT\" ) || pName . equals ( \"DHGT\" ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Height . name ( ) ) ) ; \n} \n} \n} \nelse if ( pName . equals ( \"PRES\" ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \n} \n} \n} \n"}
{"5000": "public class CFSimpleGeometryHelper { \npublic static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { \nif ( var == null ) return null ; \nString subStr = \"\" ; \nList < Dimension > dimList = var . getDimensions ( ) ; \nif ( dimList . size ( ) > 2 ) { \nreturn null ; \n} \nelse if ( dimList . size ( ) < 1 ) { \nreturn null ; \n} \nfor ( int i = 0 ; \ni < dimList . size ( ) ; \ni ++ ) { \nDimension dim = dimList . get ( i ) ; \nif ( dim == null ) continue ; \nif ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) { \nsubStr += id ; \n} \nelse { \nif ( beginInd < 0 || endInd < 0 ) subStr += \":\" ; \nelse subStr += ( beginInd + \":\" + endInd ) ; \n} \nif ( i < dimList . size ( ) - 1 ) { \nsubStr += \",\" ; \n} \n} \nreturn subStr ; \n} \n} \n"}
{"5007": "public class CECompiler { \npublic void compilefilter ( DapVariable var , DapSequence seq , CEAST expr ) throws DapException { \nif ( expr == null ) return ; \nif ( expr . sort == CEAST . Sort . SEGMENT ) { \nif ( expr . subnodes != null ) throw new DapException ( \"compilefilter: Non-simple segment:\" + expr . name ) ; \nDapVariable field = seq . findByName ( expr . name ) ; \nif ( field == null ) throw new DapException ( \"compilefilter: Unknown filter variable:\" + expr . name ) ; \nexpr . field = field ; \n} \nelse if ( expr . sort == CEAST . Sort . EXPR ) { \nif ( expr . lhs != null ) compilefilter ( var , seq , expr . lhs ) ; \nif ( expr . rhs != null ) compilefilter ( var , seq , expr . rhs ) ; \nif ( expr . lhs != null ) { \nif ( expr . rhs != null ) { \nboolean leftvar = ( expr . lhs . sort == CEAST . Sort . SEGMENT ) ; \nboolean rightvar = ( expr . rhs . sort == CEAST . Sort . SEGMENT ) ; \nif ( rightvar ) { \nif ( ! leftvar ) { \nCEAST tmp = expr . lhs ; \nexpr . lhs = expr . rhs ; \nexpr . rhs = tmp ; \nswitch ( expr . op ) { \ncase LT : expr . op = CEAST . Operator . GT ; \nbreak ; \ncase LE : expr . op = CEAST . Operator . GE ; \nbreak ; \ncase GT : expr . op = CEAST . Operator . LT ; \nbreak ; \ncase GE : expr . op = CEAST . Operator . LE ; \nbreak ; \ndefault : break ; \n} \n} \n} \n} \n} \n} \nelse if ( expr . sort == CEAST . Sort . CONSTANT ) { \nreturn ; \n} \nelse throw new DapException ( \"compilefilter: Unexpected node type:\" + expr . sort ) ; \n} \n} \n"}
{"5011": "public class LatLonRect { \npublic void extend ( LatLonPoint p ) { \nif ( contains ( p ) ) return ; \ndouble lat = p . getLatitude ( ) ; \ndouble lon = p . getLongitude ( ) ; \nif ( lat > upperRight . getLatitude ( ) ) { \nupperRight . setLatitude ( lat ) ; \n} \nif ( lat < lowerLeft . getLatitude ( ) ) { \nlowerLeft . setLatitude ( lat ) ; \n} \nif ( allLongitude ) { \n} \nelse if ( crossDateline ) { \ndouble d1 = lon - upperRight . getLongitude ( ) ; \ndouble d2 = lowerLeft . getLongitude ( ) - lon ; \nif ( d1 > 0.0 ) { \nif ( d2 > 0.0 ) { \nif ( d1 > d2 ) { \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \n} \n} \nelse { \nif ( lon > upperRight . getLongitude ( ) ) { \nif ( lon - upperRight . getLongitude ( ) > lowerLeft . getLongitude ( ) - lon + 360 ) { \ncrossDateline = true ; \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \nelse if ( lon < lowerLeft . getLongitude ( ) ) { \nif ( lowerLeft . getLongitude ( ) - lon > lon + 360.0 - upperRight . getLongitude ( ) ) { \ncrossDateline = true ; \nupperRight . setLongitude ( lon ) ; \n} \nelse { \nlowerLeft . setLongitude ( lon ) ; \n} \n} \n} \nwidth = upperRight . getLongitude ( ) - lowerLeft . getLongitude ( ) ; \nlon0 = ( upperRight . getLongitude ( ) + lowerLeft . getLongitude ( ) ) / 2 ; \nif ( crossDateline ) { \nwidth += 360 ; \nlon0 -= 180 ; \n} \nthis . allLongitude = this . allLongitude || ( this . width >= 360.0 ) ; \n} \n} \n"}
{"5030": "public class EscapeStrings { \npublic static List < String > tokenizeEscapedName ( String escapedName ) { \nList < String > result = new ArrayList < > ( ) ; \nint pos = 0 ; \nint start = 0 ; \nwhile ( true ) { \npos = escapedName . indexOf ( sep , pos + 1 ) ; \nif ( pos <= 0 ) break ; \nif ( pos > 0 ) { \nif ( escapedName . charAt ( pos - 1 ) != '\\\\' ) { \nresult . add ( escapedName . substring ( start , pos ) ) ; \nstart = pos + 1 ; \n} \n} \n} \nresult . add ( escapedName . substring ( start , escapedName . length ( ) ) ) ; \nreturn result ; \n} \n} \n"}
{"5031": "public class EscapeStrings { \npublic static int indexOf ( String escapedName , char c ) { \nint pos = 0 ; \nwhile ( true ) { \npos = escapedName . indexOf ( c , pos + 1 ) ; \nif ( pos <= 0 ) return pos ; \nif ( pos > 0 ) { \nif ( escapedName . charAt ( pos - 1 ) != '\\\\' ) return pos ; \n} \n} \n} \n} \n"}
{"5032": "public class EscapeStrings { \npublic static String backslashToDAP ( String bs ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint len = bs . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = bs . charAt ( i ) ; \nif ( i < ( len - 1 ) ) { \nif ( c == '\\\\' ) { \nc = bs . charAt ( ++ i ) ; \n} \n} \nif ( _allowableInDAP . indexOf ( c ) < 0 ) { \nbuf . append ( _URIEscape ) ; \nString ashex = Integer . toHexString ( ( int ) c ) ; \nif ( ashex . length ( ) < 2 ) buf . append ( '0' ) ; \nbuf . append ( ashex ) ; \n} \nelse buf . append ( c ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5059": "public class DoradeRADD { \npublic float getCellSpacing ( ) throws DescriptorException { \nfloat [ ] cellRanges = myCELV . getCellRanges ( ) ; \nfloat cellSpacing = cellRanges [ 1 ] - cellRanges [ 0 ] ; \nfor ( int i = 2 ; \ni < cellRanges . length ; \ni ++ ) { \nfloat space = cellRanges [ i ] - cellRanges [ i - 1 ] ; \nif ( ! Misc . nearlyEquals ( space , cellSpacing ) ) { \nif ( Math . abs ( space / cellSpacing - 1.0 ) > 0.01 ) { \nthrow new DescriptorException ( \"variable cell spacing\" ) ; \n} \n} \n} \nreturn cellSpacing ; \n} \n} \n"}
{"5065": "public class Grib1ParamTables { \npublic static Grib1ParamTables factory ( String paramTablePath , String lookupTablePath ) throws IOException { \nif ( paramTablePath == null ) { \nif ( lookupTablePath == null ) return new Grib1ParamTables ( ) ; \n} \nLookup lookup = null ; \nGrib1ParamTableReader override = null ; \nGrib1ParamTableReader table ; \nif ( paramTablePath != null ) { \ntable = localTableHash . get ( paramTablePath ) ; \nif ( table == null ) { \ntable = new Grib1ParamTableReader ( paramTablePath ) ; \nlocalTableHash . put ( paramTablePath , table ) ; \noverride = table ; \n} \n} \nif ( lookupTablePath != null ) { \nlookup = new Lookup ( ) ; \nif ( ! lookup . readLookupTable ( lookupTablePath ) ) throw new FileNotFoundException ( \"cant read lookup table=\" + lookupTablePath ) ; \n} \nreturn new Grib1ParamTables ( lookup , override ) ; \n} \n} \n"}
{"5091": "public class GridVertCoord { \nprivate int coordIndex ( GridRecord record ) { \ndouble val = record . getLevel1 ( ) ; \ndouble val2 = record . getLevel2 ( ) ; \nif ( usesBounds ) { \nif ( val > val2 ) { \nval = record . getLevel2 ( ) ; \nval2 = record . getLevel1 ( ) ; \n} \n} \nfor ( int i = 0 ; \ni < levels . size ( ) ; \ni ++ ) { \nLevelCoord lc = ( LevelCoord ) levels . get ( i ) ; \nif ( usesBounds ) { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) ) { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value2 , val2 ) ) { \nreturn i ; \n} \n} \n} \nelse { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) ) { \nreturn i ; \n} \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5098": "public class NavigatedPanel { \nvoid fireMapAreaEvent ( ) { \nif ( debugZoom ) System . out . println ( \"NP.fireMapAreaEvent \" ) ; \nif ( project . isLatLon ( ) ) { \nLatLonProjection llproj = ( LatLonProjection ) project ; \nProjectionRect box = getMapArea ( ) ; \ndouble center = llproj . getCenterLon ( ) ; \ndouble lonBeg = LatLonPointImpl . lonNormal ( box . getMinX ( ) , center ) ; \ndouble lonEnd = lonBeg + box . getMaxX ( ) - box . getMinX ( ) ; \nboolean showShift = Debug . isSet ( \"projection/LatLonShift\" ) || debugNewProjection ; \nif ( showShift ) System . out . println ( \"projection/LatLonShift: min,max = \" + box . getMinX ( ) + \" \" + box . getMaxX ( ) + \" beg,end= \" + lonBeg + \" \" + lonEnd + \" center = \" + center ) ; \nif ( lonBeg < center - 180 ) { \ndouble wx0 = box . getX ( ) + box . getWidth ( ) / 2 ; \nllproj . setCenterLon ( wx0 ) ; \ndouble newWx0 = llproj . getCenterLon ( ) ; \nsetWorldCenterX ( newWx0 ) ; \nif ( showShift ) System . out . println ( \"projection/LatLonShift: shift center to \" + wx0 + \"->\" + newWx0 ) ; \nlmProject . sendEvent ( new NewProjectionEvent ( this , llproj ) ) ; \nreturn ; \n} \nelse if ( lonEnd > center + 180 ) { \ndouble wx0 = box . getX ( ) + box . getWidth ( ) / 2 ; \nllproj . setCenterLon ( wx0 ) ; \ndouble newWx0 = llproj . getCenterLon ( ) ; \nsetWorldCenterX ( newWx0 ) ; \nif ( showShift ) System . out . println ( \"projection/LatLonShift: shift center to \" + wx0 + \"->\" + newWx0 ) ; \nlmProject . sendEvent ( new NewProjectionEvent ( this , llproj ) ) ; \nreturn ; \n} \n} \nlmMapArea . sendEvent ( new NewMapAreaEvent ( this , getMapArea ( ) ) ) ; \n} \n} \n"}
{"5102": "public class NavigatedPanel { \npublic void setProjectionImpl ( ProjectionImpl p ) { \nif ( geoSelection != null ) { \nLatLonRect geoLL = project . projToLatLonBB ( geoSelection ) ; \nsetGeoSelection ( p . latLonToProjBB ( geoLL ) ) ; \n} \nproject = p ; \nnavigate . setMapArea ( project . getDefaultMapArea ( ) ) ; \nif ( Debug . isSet ( \"projection/set\" ) ) System . out . println ( \"projection/set NP=\" + project ) ; \nelse if ( debugNewProjection ) System . out . println ( \"projection/set NP=\" + project ) ; \nif ( hasReference ) { \nrefWorld . setLocation ( project . latLonToProj ( refLatLon ) ) ; \n} \n} \n} \n"}
{"5105": "public class NavigatedPanel { \nprivate void newScreenSize ( Rectangle b ) { \nboolean sameSize = ( b . width == myBounds . width ) && ( b . height == myBounds . height ) ; \nif ( debugBounds ) System . out . println ( \"NavigatedPanel newScreenSize old= \" + myBounds ) ; \nif ( sameSize && ( b . x == myBounds . x ) ) { \nif ( b . y == myBounds . y ) return ; \n} \nmyBounds . setBounds ( b ) ; \nif ( sameSize ) return ; \nif ( debugBounds ) System . out . println ( \"  newBounds = \" + b ) ; \nif ( ( b . width > 0 ) && ( b . height > 0 ) ) { \nbImage = new BufferedImage ( b . width , b . height , BufferedImage . TYPE_INT_RGB ) ; \n} \nelse { \nbImage = null ; \n} \nnavigate . setScreenSize ( b . width , b . height ) ; \n} \n} \n"}
{"5116": "public class GradsDataDescriptorFile { \npublic String getFileName ( int eIndex , int tIndex ) { \nString dataFilePath = dataFile ; \nif ( getTemplateType ( ) == ENS_TEMPLATE ) { \ndataFilePath = getEnsembleDimension ( ) . replaceFileTemplate ( dataFilePath , eIndex ) ; \n} \nelse if ( getTemplateType ( ) == ENS_TIME_TEMPLATE ) { \ndataFilePath = getEnsembleDimension ( ) . replaceFileTemplate ( dataFilePath , eIndex ) ; \n} \ndataFilePath = getTimeDimension ( ) . replaceFileTemplate ( dataFilePath , tIndex ) ; \nif ( chsubs != null ) { \nif ( dataFilePath . contains ( CHSUB_TEMPLATE_ID ) ) { \nfor ( Chsub ch : chsubs ) { \nif ( tIndex >= ch . startTimeIndex ) { \nif ( tIndex <= ch . endTimeIndex ) { \ndataFilePath = dataFilePath . replace ( CHSUB_TEMPLATE_ID , ch . subString ) ; \nbreak ; \n} \n} \n} \n} \n} \nreturn getFullPath ( dataFilePath ) ; \n} \n} \n"}
{"5117": "public class GradsDataDescriptorFile { \nprivate List < String > getFileNames ( ) throws IOException { \nif ( fileNames == null ) { \nfileNames = new ArrayList < > ( ) ; \ntimeStepsPerFile = tDim . getSize ( ) ; \nif ( ! isTemplate ( ) ) { \nfileNames . add ( getFullPath ( getDataFile ( ) ) ) ; \n} \nelse { \nlong start = System . currentTimeMillis ( ) ; \nList < String > fileSet = new ArrayList < > ( ) ; \nString template = getDataFile ( ) ; \nif ( GradsTimeDimension . hasTimeTemplate ( template ) ) { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TIME_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nelse { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nif ( templateType == ENS_TEMPLATE ) { \nfor ( int e = 0 ; \ne < eDim . getSize ( ) ; \ne ++ ) { \nfileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; \n} \n} \nelse if ( templateType == TIME_TEMPLATE ) { \nint numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; \nfor ( int t = 0 ; \nt < tDim . getSize ( ) ; \nt ++ ) { \nfor ( int e = 0 ; \ne < numens ; \ne ++ ) { \nString file = getFileName ( e , t ) ; \nif ( ! fileSet . contains ( file ) ) { \nfileSet . add ( file ) ; \n} \n} \n} \ntimeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; \n} \nelse if ( templateType == ENS_TIME_TEMPLATE ) { \nint numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; \nfor ( int t = 0 ; \nt < tDim . getSize ( ) ; \nt ++ ) { \nfor ( int e = 0 ; \ne < numens ; \ne ++ ) { \nString file = getFileName ( e , t ) ; \nif ( ! fileSet . contains ( file ) ) { \nfileSet . add ( file ) ; \n} \n} \n} \ntimeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; \n} \nfileNames . addAll ( fileSet ) ; \n} \nfor ( String file : fileNames ) { \nFile f = new File ( file ) ; \nif ( ! f . exists ( ) ) { \nlog . error ( \"File: \" + f + \" does not exist\" ) ; \nthrow new IOException ( \"File: \" + f + \" does not exist\" ) ; \n} \n} \n} \nreturn fileNames ; \n} \n} \n"}
{"5122": "public class Nidsheader { \nint readWMO ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint pos = 0 ; \nraf . seek ( pos ) ; \nint readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nint rc = raf . read ( b ) ; \nif ( rc != readLen ) { \nreturn 0 ; \n} \nint iarr2_1 = bytesToInt ( b [ 0 ] , b [ 1 ] , false ) ; \nint iarr2_16 = bytesToInt ( b [ 30 ] , b [ 31 ] , false ) ; \nint iarr2_10 = bytesToInt ( b [ 18 ] , b [ 19 ] , false ) ; \nint iarr2_7 = bytesToInt ( b [ 12 ] , b [ 13 ] , false ) ; \nif ( ( iarr2_1 == iarr2_16 ) && ( ( iarr2_1 >= 16 ) && ( iarr2_1 <= 299 ) ) && ( iarr2_10 == - 1 ) ) { \nif ( iarr2_7 < 10000 ) { \nnoHeader = true ; \nreturn 1 ; \n} \n} \nString pib = new String ( b , CDM . utf8Charset ) ; \nif ( pib . indexOf ( \"SDUS\" ) != - 1 ) { \nnoHeader = false ; \nreturn 1 ; \n} \nelse if ( raf . getLocation ( ) . indexOf ( \".nids\" ) != - 1 ) { \nnoHeader = true ; \nreturn 1 ; \n} \nelse return 0 ; \n} \n} \n"}
{"5166": "public class ArrayStructureBBsection { \nstatic public ArrayStructureBB factory ( ArrayStructureBB org , Section section ) { \nif ( section == null ) return org ; \nelse if ( section . computeSize ( ) == org . getSize ( ) ) return org ; \nreturn new ArrayStructureBBsection ( org . getStructureMembers ( ) , org . getShape ( ) , org . getByteBuffer ( ) , section ) ; \n} \n} \n"}
{"5178": "public class EnhancementsImpl { \npublic String getUnitsString ( ) { \nString result = units ; \nif ( result == null ) { \nif ( forVar != null ) { \nAttribute att = forVar . findAttribute ( CDM . UNITS ) ; \nif ( att == null ) att = forVar . findAttributeIgnoreCase ( CDM . UNITS ) ; \nif ( att != null ) { \nif ( att . isString ( ) ) result = att . getStringValue ( ) ; \n} \n} \n} \nreturn ( result == null ) ? null : result . trim ( ) ; \n} \n} \n"}
{"5181": "public class ConfigCatalogInitialization { \nprivate void processDatasets ( long catId , ReadMode readMode , String dirPath , List < Dataset > datasets , Set < String > idMap ) throws IOException { \nif ( exceedLimit ) return ; \nfor ( Dataset ds : datasets ) { \nif ( datasetTracker . trackDataset ( catId , ds , callback ) ) countDatasets ++ ; \nif ( maxDatasetsProcess > 0 ) { \nif ( countDatasets > maxDatasetsProcess ) exceedLimit = true ; \n} \nString id = ds . getID ( ) ; \nif ( id != null ) { \nif ( idMap . contains ( id ) ) { \nlogCatalogInit . error ( ERROR + \"Duplicate id on  '\" + ds . getName ( ) + \"' id= '\" + id + \"'\" ) ; \n} \nelse { \nidMap . add ( id ) ; \n} \n} \nif ( ds instanceof DatasetScan ) continue ; \nelse if ( ds instanceof FeatureCollectionRef ) continue ; \nif ( ds instanceof CatalogScan ) continue ; \nif ( ds instanceof CatalogRef ) { \nCatalogRef catref = ( CatalogRef ) ds ; \nString href = catref . getXlinkHref ( ) ; \nif ( ! href . startsWith ( \"http:\" ) ) { \nif ( href . startsWith ( \"./\" ) ) { \nhref = href . substring ( 2 ) ; \n} \nString path ; \nString contextPathPlus = this . contextPath + \"/\" ; \nif ( href . startsWith ( contextPathPlus ) ) { \npath = href . substring ( contextPathPlus . length ( ) ) ; \n} \nelse if ( href . startsWith ( \"/\" ) ) { \nlogCatalogInit . error ( ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" + \"Parent catalog info: Name=\\\"\" + catref . getParentCatalog ( ) . getName ( ) + \"\\\"; Base URI=\\\"\" + catref . getParentCatalog ( ) . getUriString ( ) + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\" ) ; \ncontinue ; \n} \nelse { \npath = dirPath + href ; \n} \nCatalogExt ext = catalogTracker . get ( path ) ; \nlong lastRead = ( ext == null ) ? 0 : ext . getLastRead ( ) ; \ncheckCatalogToRead ( readMode , path , false , lastRead ) ; \n} \n} \nelse { \nprocessDatasets ( catId , readMode , dirPath , ds . getDatasetsLocal ( ) , idMap ) ; \n} \n} \n} \n} \n"}
{"5186": "public class BaseQuantity { \npublic int compareTo ( final BaseQuantity that ) { \nint comp ; \nif ( this == that ) { \ncomp = 0 ; \n} \nelse { \ncomp = getName ( ) . compareToIgnoreCase ( that . getName ( ) ) ; \nif ( comp == 0 ) { \nif ( getSymbol ( ) != null ) { \ncomp = getSymbol ( ) . compareTo ( that . getSymbol ( ) ) ; \n} \n} \n} \nreturn comp ; \n} \n} \n"}
{"5202": "public class Grib1SectionBitMap { \n@ Nullable public byte [ ] getBitmap ( RandomAccessFile raf ) throws IOException { \nif ( startingPosition <= 0 ) { \nthrow new IllegalStateException ( \"Grib1 Bit map has bad starting position\" ) ; \n} \nraf . seek ( startingPosition ) ; \nint length = GribNumbers . uint3 ( raf ) ; \nraf . read ( ) ; \nint bm = raf . readShort ( ) ; \nif ( bm != 0 ) { \nlogger . warn ( \"Grib1 Bit map section pre-defined (provided by center) bitmap number = {}\" , bm ) ; \nreturn null ; \n} \nif ( length <= 6 ) { \nreturn null ; \n} \nelse if ( length > 10e6 ) { \nreturn null ; \n} \nint n = length - 6 ; \nbyte [ ] data = new byte [ n ] ; \nraf . readFully ( data ) ; \nreturn data ; \n} \n} \n"}
{"5203": "public class JTreeTableSorted { \npublic void restoreState ( PreferencesExt store ) { \nif ( store == null ) return ; \nint ncols = table . getColumnCount ( ) ; \nint [ ] modelIndex = ( int [ ] ) store . getBean ( \"ColumnOrder\" , null ) ; \nif ( modelIndex != null ) { \nif ( modelIndex . length == ncols ) { \nboolean [ ] visible = new boolean [ ncols ] ; \nfor ( int aModelIndex : modelIndex ) if ( aModelIndex < ncols ) visible [ aModelIndex ] = true ; \nfor ( int i = 0 ; \ni < ncols ; \ni ++ ) if ( ! visible [ i ] ) { \nacts [ i ] . hideColumn ( ) ; \nacts [ i ] . putValue ( BAMutil . STATE , new Boolean ( false ) ) ; \n} \nTableColumnModel tcm = table . getColumnModel ( ) ; \nint n = Math . min ( modelIndex . length , table . getColumnCount ( ) ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \ntc . setModelIndex ( modelIndex [ i ] ) ; \nString name = model . getColumnName ( modelIndex [ i ] ) ; \ntc . setHeaderValue ( name ) ; \ntc . setIdentifier ( name ) ; \nif ( useThreads && ( modelIndex [ i ] == threadCol ) ) { \nthreadHeaderRenderer = new ThreadHeaderRenderer ( threadCol ) ; \ntc . setHeaderRenderer ( threadHeaderRenderer ) ; \n} \nelse tc . setHeaderRenderer ( new SortedHeaderRenderer ( name , modelIndex [ i ] ) ) ; \n} \n} \n} \nObject colWidths = store . getBean ( \"ColumnWidths\" , null ) ; \nif ( colWidths == null ) return ; \nint [ ] size = ( int [ ] ) colWidths ; \nsetColumnWidths ( size ) ; \nif ( debug ) { \nSystem . out . println ( \" read widths = \" ) ; \nfor ( int aSize : size ) System . out . print ( \" \" + aSize ) ; \nSystem . out . println ( ) ; \n} \nboolean isThreadsOn = store . getBoolean ( \"isThreadsOn\" , false ) ; \nif ( useThreads ) { \nmodel . setThreadsOn ( isThreadsOn ) ; \nthreadHeaderRenderer . setOn ( isThreadsOn ) ; \n} \nint colNo = store . getInt ( \"SortOnCol\" , 0 ) ; \nboolean reverse = store . getBoolean ( \"SortReverse\" , false ) ; \nmodel . setSortCol ( colNo ) ; \nmodel . setReverse ( reverse ) ; \nsetSortCol ( colNo , reverse ) ; \nmodel . sort ( ) ; \ntable . fireDataChanged ( ) ; \n} \nprivate void setColumnWidths ( int [ ] sizes ) { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( int i = 0 ; \ni < table . getColumnCount ( ) ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nint maxw = ( ( sizes == null ) || ( i >= sizes . length ) ) ? 10 : sizes [ i ] ; \ntc . setPreferredWidth ( maxw ) ; \n} \n} \npublic void setColOn ( int colno , boolean state , int pos ) { \nacts [ colno ] . putValue ( BAMutil . STATE , new Boolean ( state ) ) ; \nif ( state ) acts [ colno ] . addAtPos ( pos ) ; \nelse acts [ colno ] . hideColumn ( ) ; \n} \n} \n"}
{"5204": "public class JTreeTableSorted { \npublic Iterator getSelectedRows ( ) { \nTreePath [ ] paths = table . getSelectionPaths ( ) ; \nif ( paths == null ) return null ; \nelse if ( paths . length < 1 ) return null ; \nHashSet set = new HashSet ( 2 * paths . length ) ; \nfor ( TreePath path : paths ) { \nmodel . addRowsToSetFromPath ( table . getTree ( ) , path , set ) ; \n} \nreturn set . iterator ( ) ; \n} \n} \n"}
{"5222": "public class DIFWriter { \npublic boolean isDatasetUseable ( InvDataset ds , StringBuilder sbuff ) { \nboolean ok = true ; \nsbuff . append ( \"Dataset \" + ds . getName ( ) + \" id = \" + ds . getID ( ) + \": \" ) ; \nif ( ! ds . isHarvest ( ) ) { \nok = false ; \nsbuff . append ( \"Dataset \" + ds . getName ( ) + \" id = \" + ds . getID ( ) + \" has harvest = false\\n\" ) ; \n} \nif ( ds . getName ( ) == null ) { \nok = false ; \nsbuff . append ( \" missing Name field\\n\" ) ; \n} \nif ( ds . getUniqueID ( ) == null ) { \nok = false ; \nsbuff . append ( \" missing ID field\\n\" ) ; \n} \nThreddsMetadata . Variables vs = ds . getVariables ( \"DIF\" ) ; \nif ( vs == null ) vs = ds . getVariables ( \"GRIB-1\" ) ; \nelse if ( vs . getVariableList ( ) . size ( ) == 0 ) vs = ds . getVariables ( \"GRIB-1\" ) ; \nif ( vs == null ) vs = ds . getVariables ( \"GRIB-2\" ) ; \nelse if ( vs . getVariableList ( ) . size ( ) == 0 ) vs = ds . getVariables ( \"GRIB-2\" ) ; \nif ( vs == null ) { \nok = false ; \nsbuff . append ( \" missing Variables with DIF or GRIB compatible vocabulary\\n\" ) ; \n} \nelse if ( vs . getVariableList ( ) . size ( ) == 0 ) { \nok = false ; \nsbuff . append ( \" missing Variables with DIF or GRIB compatible vocabulary\\n\" ) ; \n} \nList list = ds . getPublishers ( ) ; \nif ( list == null ) { \nok = false ; \nsbuff . append ( \" must have publisher element that defines the data center\\n\" ) ; \n} \nelse if ( list . size ( ) == 0 ) { \nok = false ; \nsbuff . append ( \" must have publisher element that defines the data center\\n\" ) ; \n} \nString summary = ds . getDocumentation ( \"summary\" ) ; \nif ( summary == null ) { \nok = false ; \nsbuff . append ( \" must have documentation element of type summary\\n\" ) ; \n} \nsbuff . append ( \" useable= \" + ok + \"\\n\" ) ; \nreturn ok ; \n} \n} \n"}
{"5224": "public class DatasetBuilder { \npublic void transferMetadata ( DatasetNode from , boolean parentsAlso ) { \nif ( parentsAlso ) { \nThreddsMetadata inherit = getInheritableMetadata ( ) ; \ninheritMetadata ( from , inherit . getFlds ( ) ) ; \n} \nfor ( Map . Entry < String , Object > entry : from . getFldIterator ( ) ) { \nif ( parentsAlso ) { \nif ( entry . getKey ( ) . equals ( Dataset . ThreddsMetadataInheritable ) ) continue ; \n} \nif ( Dataset . listFlds . contains ( entry . getKey ( ) ) ) addToNewList ( flds , entry . getKey ( ) , entry . getValue ( ) ) ; \nelse flds . put ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nThreddsMetadata tmiOld = ( ThreddsMetadata ) get ( Dataset . ThreddsMetadataInheritable ) ; \nif ( tmiOld != null ) { \nif ( tmiOld . isImmutable ( ) ) { \nThreddsMetadata tmiNew = new ThreddsMetadata ( tmiOld ) ; \nflds . put ( Dataset . ThreddsMetadataInheritable , tmiNew ) ; \n} \n} \n} \n} \n"}
{"5233": "public class NCheader { \nstatic boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { \nif ( b1 == b2 ) return true ; \nif ( b1 == null ) return false ; \nelse if ( b2 == null ) return false ; \nif ( b1 . length < len ) return false ; \nelse if ( b2 . length < len ) return false ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nif ( b1 [ i ] != b2 [ i ] ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"5236": "public class CoordinatePartitionUnionizer { \npublic void addCoords ( List < Coordinate > coords , PartitionCollectionMutable . Partition part ) { \nCoordinate runtime = null ; \nfor ( Coordinate coord : coords ) { \nswitch ( coord . getType ( ) ) { \ncase runtime : CoordinateRuntime rtime = ( CoordinateRuntime ) coord ; \nif ( runtimeBuilder == null ) runtimeBuilder = new CoordinateRuntime . Builder2 ( rtime . getTimeUnits ( ) ) ; \nruntimeBuilder . addAll ( coord ) ; \nruntime = coord ; \nif ( debugPartitionErrors && ! duplicateRuntimeMessage ) { \nif ( part != null ) testDuplicateRuntime ( rtime , part ) ; \n} \nbreak ; \ncase time : CoordinateTime time = ( CoordinateTime ) coord ; \nif ( timeBuilder == null ) timeBuilder = new CoordinateTime . Builder2 ( coord . getCode ( ) , time . getTimeUnit ( ) , time . getRefDate ( ) ) ; \ntimeBuilder . addAll ( coord ) ; \nbreak ; \ncase timeIntv : CoordinateTimeIntv timeIntv = ( CoordinateTimeIntv ) coord ; \nif ( timeIntvBuilder == null ) timeIntvBuilder = new CoordinateTimeIntv . Builder2 ( null , coord . getCode ( ) , timeIntv . getTimeUnit ( ) , timeIntv . getRefDate ( ) ) ; \ntimeIntvBuilder . addAll ( intervalFilter ( ( CoordinateTimeIntv ) coord ) ) ; \nbreak ; \ncase time2D : CoordinateTime2D time2D = ( CoordinateTime2D ) coord ; \nif ( time2DBuilder == null ) time2DBuilder = new CoordinateTime2DUnionizer ( time2D . isTimeInterval ( ) , time2D . getTimeUnit ( ) , coord . getCode ( ) , false , logger ) ; \ntime2DBuilder . addAll ( time2D ) ; \nCoordinateRuntime runtimeFrom2D = time2D . getRuntimeCoordinate ( ) ; \nif ( ! runtimeFrom2D . equals ( runtime ) ) logger . warn ( \"HEY CoordinateUnionizer runtimes not equal\" ) ; \nbreak ; \ncase ens : if ( ensBuilder == null ) ensBuilder = new CoordinateEns . Builder2 ( coord . getCode ( ) ) ; \nensBuilder . addAll ( coord ) ; \nbreak ; \ncase vert : CoordinateVert vertCoord = ( CoordinateVert ) coord ; \nif ( vertBuilder == null ) vertBuilder = new CoordinateVert . Builder2 ( coord . getCode ( ) , vertCoord . getVertUnit ( ) ) ; \nvertBuilder . addAll ( coord ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"5244": "public class CFpointObs { \nprotected String matchAxisTypeAndDimension ( NetcdfDataset ds , AxisType type , final Dimension outer ) { \nVariable var = CoordSysEvaluator . findCoordByType ( ds , type , new CoordSysEvaluator . Predicate ( ) { \npublic boolean match ( CoordinateAxis axis ) { \nif ( outer == null ) { \nif ( axis . getRank ( ) == 0 ) return true ; \n} \nif ( ( outer != null ) && ( axis . getRank ( ) == 1 ) ) { \nif ( outer . equals ( axis . getDimension ( 0 ) ) ) return true ; \n} \nif ( axis . getParentStructure ( ) != null ) { \nStructure parent = axis . getParentStructure ( ) ; \nif ( ( outer != null ) && ( parent . getRank ( ) == 1 ) ) { \nif ( outer . equals ( parent . getDimension ( 0 ) ) ) return true ; \n} \n} \nreturn false ; \n} \n} \n) ; \nif ( var == null ) return null ; \nreturn var . getFullName ( ) ; \n} \n} \n"}
{"5250": "public class HTTPUtil { \nstatic public String nullify ( String s ) { \nif ( s != null ) { \nif ( s . length ( ) == 0 ) s = null ; \n} \nreturn s ; \n} \n} \n"}
{"5251": "public class HTTPUtil { \nstatic public String canonjoin ( String prefix , String suffix ) { \nif ( prefix == null ) prefix = \"\" ; \nif ( suffix == null ) suffix = \"\" ; \nprefix = HTTPUtil . canonicalpath ( prefix ) ; \nsuffix = HTTPUtil . canonicalpath ( suffix ) ; \nStringBuilder result = new StringBuilder ( ) ; \nresult . append ( prefix ) ; \nint prelen = prefix . length ( ) ; \nif ( prelen > 0 ) { \nif ( result . charAt ( prelen - 1 ) != '/' ) { \nresult . append ( '/' ) ; \nprelen ++ ; \n} \n} \nif ( suffix . length ( ) > 0 && suffix . charAt ( 0 ) == '/' ) result . append ( suffix . substring ( 1 ) ) ; \nelse result . append ( suffix ) ; \nint len = result . length ( ) ; \nif ( len > 0 ) { \nif ( result . charAt ( len - 1 ) == '/' ) { \nresult . deleteCharAt ( len - 1 ) ; \nlen -- ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"5272": "public class ChunkWriter { \npublic void writeDSR ( String dsr ) throws IOException { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to write DSR twice\" ) ; \nif ( dsr == null ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \nint len = dsr . length ( ) ; \nwhile ( len > 0 ) { \nchar c = dsr . charAt ( len - 1 ) ; \nif ( c != '\\r' ) { \nif ( c != '\\n' ) break ; \n} \nlen -- ; \n} \nif ( dsr . length ( ) == 0 ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \ndsr = dsr . substring ( 0 , len ) + DapUtil . CRLF ; \ndsr = XMLDOCUMENTHEADER + \"\\n\" + dsr ; \nbyte [ ] dsr8 = DapUtil . extract ( DapUtil . UTF8 . encode ( dsr ) ) ; \nsendDXR ( dsr8 ) ; \nstate = State . END ; \n} \n} \n"}
{"5273": "public class ChunkWriter { \nvoid sendDXR ( byte [ ] dxr8 ) throws IOException { \nif ( dxr8 == null ) return ; \nelse if ( dxr8 . length == 0 ) return ; \nif ( mode == RequestMode . DMR || mode == RequestMode . DSR ) { \nstate = State . END ; \n} \nelse { \nint flags = DapUtil . CHUNK_DATA ; \nif ( this . writeorder == ByteOrder . LITTLE_ENDIAN ) flags |= DapUtil . CHUNK_LITTLE_ENDIAN ; \nchunkheader ( dxr8 . length , flags , this . header ) ; \noutput . write ( DapUtil . extract ( this . header ) ) ; \nstate = State . DATA ; \n} \noutput . write ( dxr8 ) ; \noutput . flush ( ) ; \n} \n} \n"}
{"5275": "public class ChunkWriter { \npublic void close ( ) throws IOException { \nif ( closed ) return ; \nclosed = true ; \nif ( dmr8 != null ) { \nsendDXR ( dmr8 ) ; \ndmr8 = null ; \n} \nif ( mode == RequestMode . DMR ) return ; \nif ( chunk == null ) return ; \nelse if ( chunk . position ( ) == 0 ) return ; \nverifystate ( ) ; \nstate = State . DATA ; \nint flags = DapUtil . CHUNK_END ; \nwriteChunk ( flags ) ; \nstate = State . END ; \nthis . output . flush ( ) ; \nif ( this . saveoutput != null ) { \nthis . saveoutput . write ( ( ( ByteArrayOutputStream ) this . output ) . toByteArray ( ) ) ; \n} \n} \n} \n"}
{"5282": "public class N3raf { \nprotected long readData ( Layout index , DataType dataType , WritableByteChannel out ) throws java . io . IOException { \nlong count = 0 ; \nif ( dataType . getPrimitiveClassType ( ) == byte . class || dataType == DataType . CHAR ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , chunk . getNelems ( ) ) ; \n} \n} \nelse if ( dataType . getPrimitiveClassType ( ) == short . class ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 2 * chunk . getNelems ( ) ) ; \n} \n} \nelse if ( dataType . getPrimitiveClassType ( ) == int . class || ( dataType == DataType . FLOAT ) ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 4 * chunk . getNelems ( ) ) ; \n} \n} \nelse if ( dataType == DataType . DOUBLE ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 8 * chunk . getNelems ( ) ) ; \n} \n} \nelse if ( dataType . getPrimitiveClassType ( ) == long . class ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 8 * chunk . getNelems ( ) ) ; \n} \n} \nreturn count ; \n} \n} \n"}
{"5292": "public class Dap4Controller { \n@ Override public String getResourcePath ( DapRequest drq , String location ) throws DapException { \nString realpath ; \nif ( TdsRequestedDataset . getDatasetManager ( ) != null ) { \nrealpath = TdsRequestedDataset . getLocationFromRequestPath ( location ) ; \n} \nelse { \nassert TdsRequestedDataset . getDatasetManager ( ) == null ; \nString prefix = drq . getResourceRoot ( ) ; \nassert ( prefix != null ) ; \nrealpath = DapUtil . canonjoin ( prefix , location ) ; \n} \nif ( ! TESTING ) { \nif ( ! TdsRequestedDataset . resourceControlOk ( drq . getRequest ( ) , drq . getResponse ( ) , realpath ) ) throw new DapException ( \"Not authorized: \" + location ) . setCode ( DapCodes . SC_FORBIDDEN ) ; \n} \nFile f = new File ( realpath ) ; \nif ( ! f . exists ( ) ) throw new DapException ( \"Not found: \" + location ) . setCode ( DapCodes . SC_NOT_FOUND ) ; \nelse if ( ! f . canRead ( ) ) throw new DapException ( \"Not found: \" + location ) . setCode ( DapCodes . SC_NOT_FOUND ) ; \nreturn realpath ; \n} \n} \n"}
{"5295": "public class InvDatasetImpl { \npublic boolean finish ( ) { \nboolean ok = true ; \njava . util . Iterator iter ; \nlogger . debug ( \"Now finish \" + getName ( ) + \" id= \" + getID ( ) ) ; \nauthorityName = null ; \ndataType = null ; \ndataFormatType = null ; \ndefaultService = null ; \ngc = null ; \ntc = null ; \ndocs = new ArrayList < > ( ) ; \nmetadata = new ArrayList < > ( ) ; \nproperties = new ArrayList < > ( ) ; \ncreators = new ArrayList < > ( ) ; \ncontributors = new ArrayList < > ( ) ; \ndates = new ArrayList < > ( ) ; \nkeywords = new ArrayList < > ( ) ; \nprojects = new ArrayList < > ( ) ; \npublishers = new ArrayList < > ( ) ; \nvariables = new ArrayList < > ( ) ; \ncanonicalize ( ) ; \ntransfer2PublicMetadata ( tm , true ) ; \ntransfer2PublicMetadata ( tmi , true ) ; \ntransferInheritable2PublicMetadata ( ( InvDatasetImpl ) getParent ( ) ) ; \naccess = new ArrayList < > ( ) ; \nif ( urlPath != null ) { \nif ( getServiceDefault ( ) != null ) { \nInvAccessImpl a = new InvAccessImpl ( this , urlPath , getServiceDefault ( ) ) ; \na . setSize ( size ) ; \na . finish ( ) ; \naddExpandedAccess ( a ) ; \n} \n} \niter = accessLocal . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nInvAccessImpl a = ( InvAccessImpl ) iter . next ( ) ; \na . finish ( ) ; \naddExpandedAccess ( a ) ; \n} \nif ( ! ( this instanceof InvCatalogRef ) ) { \nfor ( InvDataset invDataset : this . getDatasets ( ) ) { \nInvDatasetImpl curDs = ( InvDatasetImpl ) invDataset ; \nok &= curDs . finish ( ) ; \n} \n} \nreturn ok ; \n} \n} \n"}
{"5308": "public class DatasetNamer { \nboolean validate ( StringBuilder out ) { \nthis . isValid = true ; \nif ( this . msgLog . length ( ) > 0 ) { \nout . append ( this . msgLog ) ; \n} \nif ( this . getName ( ) == null ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (1): null value for name is not valid.\" ) ; \n} \nif ( this . getType ( ) == null ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (3): null value for type is not valid (set with bad string?).\" ) ; \n} \nif ( this . getType ( ) == DatasetNamerType . REGULAR_EXPRESSION ) { \nif ( this . getMatchPattern ( ) == null || this . getSubstitutePattern ( ) == null ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (4): invalid datasetNamer <\" + this . getName ( ) + \">;\" + \" type is \" + this . getType ( ) . toString ( ) + \": matchPattern(\" + this . getMatchPattern ( ) + \") and substitutionPattern(\" + this . getSubstitutePattern ( ) + \") \" + \"must not be null.\" ) ; \n} \n} \nif ( this . getType ( ) == DatasetNamerType . DODS_ATTRIBUTE ) { \nif ( this . getAttribContainer ( ) == null || this . getAttribName ( ) == null ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (5): invalid datasetNamer <\" + this . getName ( ) + \">;\" + \" type is \" + this . getType ( ) . toString ( ) + \": attriuteContainer(\" + this . getAttribContainer ( ) + \") and attributeName(\" + this . getAttribName ( ) + \") must not be null.\" ) ; \n} \n} \nreturn ( this . isValid ) ; \n} \n} \n"}
{"5313": "public class WFSController { \nprivate WFSExceptionWriter checkParametersForError ( String request , String version , String service , String typeName ) { \nif ( service != null ) { \nif ( ! service . equalsIgnoreCase ( \"WFS\" ) ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. SERVICE parameter must be of value WFS.\" , \"service\" , \"InvalidParameterValue\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. SERVICE parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( request != null ) { \nif ( ! request . equalsIgnoreCase ( WFSRequestType . GetCapabilities . toString ( ) ) ) { \nif ( version != null ) { \nString [ ] versionParts = version . split ( \"\\\\.\" ) ; \nfor ( int ind = 0 ; \nind < versionParts . length ; \nind ++ ) { \ntry { \nInteger . valueOf ( versionParts [ ind ] ) ; \n} \ncatch ( NumberFormatException excep ) { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter consists of invalid characters.\" , \"version\" , \"InvalidParameterValue\" ) ; \n} \n} \nboolean validVersion = false ; \nif ( versionParts . length == 1 ) if ( versionParts [ 0 ] . equals ( \"2\" ) ) validVersion = true ; \nif ( versionParts . length >= 2 ) if ( versionParts [ 0 ] . equals ( \"2\" ) ) { \nif ( versionParts [ 1 ] . equals ( \"0\" ) ) validVersion = true ; \n} \nif ( ! validVersion ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. Version requested is not supported.\" , null , \"VersionNegotiationFailed\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( typeName == null ) { \nreturn new WFSExceptionWriter ( \"WFS server error. For the specifed request, parameter typename or typenames must be specified.\" , request , \"MissingParameterValue\" ) ; \n} \n} \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nif ( reqToProc == null ) return new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is not valid. Possible values: GetCapabilities, \" + \"DescribeFeatureType, GetFeature\" , \"request\" , \"InvalidParameterValue\" ) ; \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nreturn null ; \n} \n} \n"}
{"5314": "public class WFSController { \n@ RequestMapping ( \"**\" ) public void httpHandler ( HttpServletRequest hsreq , HttpServletResponse hsres ) { \ntry { \nPrintWriter wr = hsres . getWriter ( ) ; \nList < String > paramNames = new LinkedList < String > ( ) ; \nEnumeration < String > paramNamesE = hsreq . getParameterNames ( ) ; \nwhile ( paramNamesE . hasMoreElements ( ) ) paramNames . add ( paramNamesE . nextElement ( ) ) ; \nString request = null ; \nString version = null ; \nString service = null ; \nString typeNames = null ; \nString datasetReqPath = null ; \nString actualPath = null ; \nString actualFTName = null ; \nNetcdfDataset dataset = null ; \nif ( hsreq . getServletPath ( ) . length ( ) > 4 ) { \ndatasetReqPath = hsreq . getServletPath ( ) . substring ( 4 , hsreq . getServletPath ( ) . length ( ) ) ; \n} \nactualPath = TdsRequestedDataset . getLocationFromRequestPath ( datasetReqPath ) ; \nif ( actualPath != null ) dataset = NetcdfDataset . openDataset ( actualPath ) ; \nelse return ; \nList < CoordinateSystem > csList = dataset . getCoordinateSystems ( ) ; \nSimpleGeometryCSBuilder cs = new SimpleGeometryCSBuilder ( dataset , csList . get ( 0 ) , null ) ; \nfor ( String paramName : paramNames ) { \nif ( paramName . equalsIgnoreCase ( \"REQUEST\" ) ) { \nrequest = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"VERSION\" ) ) { \nversion = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"SERVICE\" ) ) { \nservice = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"TYPENAMES\" ) ) { \ntypeNames = hsreq . getParameter ( paramName ) ; \nif ( typeNames != null ) if ( typeNames . length ( ) > TDSNAMESPACE . length ( ) ) { \nactualFTName = typeNames . substring ( TDSNAMESPACE . length ( ) + 1 , typeNames . length ( ) ) ; \n} \n} \nelse if ( paramName . equalsIgnoreCase ( \"TYPENAME\" ) ) { \ntypeNames = hsreq . getParameter ( paramName ) ; \nif ( typeNames != null ) if ( typeNames . length ( ) > TDSNAMESPACE . length ( ) ) { \nactualFTName = typeNames . substring ( TDSNAMESPACE . length ( ) + 1 , typeNames . length ( ) ) ; \n} \n} \n} \nWFSExceptionWriter paramError = checkParametersForError ( request , version , service , typeNames ) ; \nWFSExceptionWriter requestProcessingError = null ; \nif ( paramError == null ) { \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nswitch ( reqToProc ) { \ncase GetCapabilities : getCapabilities ( wr , hsreq , cs ) ; \nbreak ; \ncase DescribeFeatureType : describeFeatureType ( wr , hsreq , actualFTName ) ; \nbreak ; \ncase GetFeature : requestProcessingError = getFeature ( wr , hsreq , cs , actualFTName , typeNames ) ; \nbreak ; \n} \n} \nelse { \nparamError . write ( hsres ) ; \nreturn ; \n} \nif ( requestProcessingError != null ) { \nrequestProcessingError . write ( hsres ) ; \nreturn ; \n} \n} \ncatch ( IOException io ) { \nthrow new RuntimeException ( \"The writer may not have been able to been have retrieved\" + \" or the requested dataset was not found\" , io ) ; \n} \n} \n} \n"}
{"5319": "public class ServletUtil { \npublic static void returnFile ( HttpServlet servlet , String contentPath , String path , HttpServletRequest req , HttpServletResponse res , String contentType ) throws IOException { \nString filename = ServletUtil . formFilename ( contentPath , path ) ; \nlog . debug ( \"returnFile(): returning file <\" + filename + \">.\" ) ; \nif ( filename == null ) { \nres . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; \nreturn ; \n} \nif ( filename . contains ( \"..\" ) ) { \nres . sendError ( HttpServletResponse . SC_FORBIDDEN ) ; \nreturn ; \n} \nString upper = filename . toUpperCase ( ) ; \nif ( upper . contains ( \"WEB-INF\" ) ) { \nres . sendError ( HttpServletResponse . SC_FORBIDDEN ) ; \nreturn ; \n} \nelse if ( upper . contains ( \"META-INF\" ) ) { \nres . sendError ( HttpServletResponse . SC_FORBIDDEN ) ; \nreturn ; \n} \nreturnFile ( servlet , req , res , new File ( filename ) , contentType ) ; \n} \n} \n"}
{"5327": "public class HtmlWriting { \npublic int writeDirectory ( HttpServletResponse res , File dir , String path ) throws IOException { \nif ( dir == null ) { \nres . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; \nreturn 0 ; \n} \nif ( ! dir . exists ( ) ) { \nres . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; \nreturn 0 ; \n} \nelse if ( ! dir . isDirectory ( ) ) { \nres . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; \nreturn 0 ; \n} \nString dirHtmlString = getDirectory ( path , dir ) ; \nthredds . servlet . ServletUtil . setResponseContentLength ( res , dirHtmlString ) ; \nres . setContentType ( ContentType . html . getContentHeader ( ) ) ; \nPrintWriter writer = res . getWriter ( ) ; \nwriter . write ( dirHtmlString ) ; \nwriter . flush ( ) ; \nreturn dirHtmlString . length ( ) ; \n} \n} \n"}
{"5332": "public class FeatureDatasetCapabilitiesWriter { \npublic Document makeStationCollectionDocument ( LatLonRect bb , String [ ] names ) throws IOException { \nList < DsgFeatureCollection > list = fdp . getPointFeatureCollectionList ( ) ; \nDsgFeatureCollection fc = list . get ( 0 ) ; \nif ( ! ( fc instanceof StationTimeSeriesFeatureCollection ) ) { \nthrow new UnsupportedOperationException ( fc . getClass ( ) . getName ( ) + \" not a StationTimeSeriesFeatureCollection\" ) ; \n} \nStationTimeSeriesFeatureCollection sobs = ( StationTimeSeriesFeatureCollection ) fc ; \nElement rootElem = new Element ( \"stationCollection\" ) ; \nDocument doc = new Document ( rootElem ) ; \nList < StationFeature > stations ; \nif ( bb != null ) stations = sobs . getStationFeatures ( bb ) ; \nelse if ( names != null ) stations = sobs . getStationFeatures ( Arrays . asList ( names ) ) ; \nelse stations = sobs . getStationFeatures ( ) ; \nfor ( Station s : stations ) { \nElement sElem = new Element ( \"station\" ) ; \nsElem . setAttribute ( \"name\" , s . getName ( ) ) ; \nif ( s . getWmoId ( ) != null ) sElem . setAttribute ( \"wmo_id\" , s . getWmoId ( ) ) ; \nif ( s . getDescription ( ) != null ) { \nif ( s . getDescription ( ) . length ( ) > 0 ) sElem . addContent ( new Element ( \"description\" ) . addContent ( s . getDescription ( ) ) ) ; \n} \nsElem . addContent ( new Element ( \"longitude\" ) . addContent ( Double . toString ( s . getLongitude ( ) ) ) ) ; \nsElem . addContent ( new Element ( \"latitide\" ) . addContent ( Double . toString ( s . getLatitude ( ) ) ) ) ; \nif ( ! Double . isNaN ( s . getAltitude ( ) ) ) sElem . addContent ( new Element ( \"altitude\" ) . addContent ( Double . toString ( s . getAltitude ( ) ) ) ) ; \nrootElem . addContent ( sElem ) ; \n} \nreturn doc ; \n} \n} \n"}
{"5338": "public class Odometer { \npublic Slice slice ( int i ) { \nif ( i < 0 ) throw new IllegalArgumentException ( ) ; \nelse if ( i >= this . rank ) throw new IllegalArgumentException ( ) ; \nreturn this . slices . get ( i ) ; \n} \n} \n"}
{"5366": "public class NcmlCollectionReader { \nstatic public NcmlCollectionReader open ( String ncmlLocation , Formatter errlog ) throws IOException { \nif ( ! ncmlLocation . startsWith ( \"http:\" ) ) { \nif ( ! ncmlLocation . startsWith ( \"file:\" ) ) ncmlLocation = \"file:\" + ncmlLocation ; \n} \nURL url = new URL ( ncmlLocation ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \nif ( debugURL ) System . out . println ( \" NetcdfDataset URL = <\" + url + \">\" ) ; \ndoc = builder . build ( url ) ; \n} \ncatch ( JDOMException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \nif ( debugXML ) System . out . println ( \" SAXBuilder done\" ) ; \nreturn readXML ( doc , errlog , ncmlLocation ) ; \n} \n} \n"}
{"5367": "public class StringUtil2 { \nstatic public String allow ( String x , String allowChars , char replaceChar ) { \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int pos = 0 ; \npos < sb . length ( ) ; \npos ++ ) { \nchar c = sb . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) ) { \ncontinue ; \n} \nelse if ( 0 <= allowChars . indexOf ( c ) ) { \ncontinue ; \n} \nsb . setCharAt ( pos , replaceChar ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5368": "public class StringUtil2 { \npublic static String cleanup ( byte [ ] h ) { \nbyte [ ] bb = new byte [ h . length ] ; \nint count = 0 ; \nfor ( byte b : h ) { \nif ( b >= 32 ) { \nif ( b < 127 ) bb [ count ++ ] = b ; \n} \n} \nreturn new String ( bb , 0 , count , CDM . utf8Charset ) ; \n} \n} \n"}
{"5369": "public class StringUtil2 { \nstatic public String filter ( String x , String okChars ) { \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) { \nreturn x ; \n} \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) ) { \nsb . append ( c ) ; \n} \nelse if ( 0 <= okChars . indexOf ( c ) ) { \nsb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5370": "public class StringUtil2 { \nstatic public String filter7bits ( String s ) { \nif ( s == null ) return null ; \nchar [ ] bo = new char [ s . length ( ) ] ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ( c < 128 ) && ( c > 31 ) ) { \nbo [ count ++ ] = c ; \n} \nelse if ( ( c == '\\n' ) || ( c == '\\t' ) ) { \nbo [ count ++ ] = c ; \n} \n} \nreturn new String ( bo , 0 , count ) ; \n} \n} \n"}
{"5396": "public class StructureDataDeep { \nstatic public ArrayStructureBB copyToArrayBB ( ArrayStructure as , ByteOrder bo , boolean canonical ) throws IOException { \nif ( ! canonical ) { \nif ( as . getClass ( ) . equals ( ArrayStructureBB . class ) ) { \nArrayStructureBB abb = ( ArrayStructureBB ) as ; \nByteBuffer bb = abb . getByteBuffer ( ) ; \nif ( bo == null ) return abb ; \nelse if ( bo . equals ( bb . order ( ) ) ) return abb ; \n} \n} \nStructureMembers smo = as . getStructureMembers ( ) ; \nStructureMembers sm = new StructureMembers ( smo ) ; \nArrayStructureBB abb = new ArrayStructureBB ( sm , as . getShape ( ) ) ; \nArrayStructureBB . setOffsets ( sm ) ; \nif ( bo != null ) { \nByteBuffer bb = abb . getByteBuffer ( ) ; \nbb . order ( bo ) ; \n} \ntry ( StructureDataIterator iter = as . getStructureDataIterator ( ) ) { \nwhile ( iter . hasNext ( ) ) copyToArrayBB ( iter . next ( ) , abb ) ; \n} \nreturn abb ; \n} \n} \n"}
{"5425": "public class GeotiffWriter { \npublic void writeGrid ( GridDataset dataset , GridDatatype grid , Array data , boolean greyScale ) throws IOException { \nGridCoordSystem gcs = grid . getCoordinateSystem ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) { \nthrow new IllegalArgumentException ( \"Must have 1D x and y axes for \" + grid . getFullName ( ) ) ; \n} \nCoordinateAxis1D xaxis = ( CoordinateAxis1D ) gcs . getXHorizAxis ( ) ; \nCoordinateAxis1D yaxis = ( CoordinateAxis1D ) gcs . getYHorizAxis ( ) ; \ndouble scaler = ( xaxis . getUnitsString ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge ( 0 ) * scaler ; \ndouble xInc = xaxis . getIncrement ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getIncrement ( ) ) * scaler ; \nif ( yaxis . getCoordValue ( 0 ) < yaxis . getCoordValue ( 1 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdge ( ( int ) yaxis . getSize ( ) ) * scaler ; \n} \nif ( ! xaxis . isRegular ( ) ) { \nthrow new IllegalArgumentException ( \"Must be evenly spaced grid = \" + grid . getFullName ( ) ) ; \n} \nelse if ( ! yaxis . isRegular ( ) ) { \nthrow new IllegalArgumentException ( \"Must be evenly spaced grid = \" + grid . getFullName ( ) ) ; \n} \nif ( pageNumber > 1 ) { \ngeotiff . initTags ( ) ; \n} \nwriteGrid ( grid , data , greyScale , xStart , yStart , xInc , yInc , pageNumber ) ; \npageNumber ++ ; \n} \n} \n"}
{"5439": "public class RC { \nstatic boolean urlMatch ( URL pattern , URL url ) { \nint relation ; \nif ( pattern == null ) return ( url == null ) ; \nif ( ! ( url . getHost ( ) . endsWith ( pattern . getHost ( ) ) ) ) return false ; \nif ( ! ( url . getPath ( ) . startsWith ( pattern . getPath ( ) ) ) ) return false ; \nif ( pattern . getPort ( ) > 0 ) { \nif ( pattern . getPort ( ) != url . getPort ( ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"5443": "public class RC { \npublic boolean load ( String abspath ) { \nabspath = abspath . replace ( '\\\\' , '/' ) ; \nFile rcFile = new File ( abspath ) ; \nif ( ! rcFile . exists ( ) ) { \nreturn false ; \n} \nelse if ( ! rcFile . canRead ( ) ) { \nreturn false ; \n} \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \ntry ( BufferedReader rdr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( rcFile ) , CDM . UTF8 ) ) ) { \nfor ( int lineno = 1 ; \n; \nlineno ++ ) { \nURL url = null ; \nString line = rdr . readLine ( ) ; \nif ( line == null ) break ; \nline = line . trim ( ) ; \nif ( line . length ( ) == 0 ) continue ; \nif ( line . charAt ( 0 ) == '#' ) continue ; \nif ( line . charAt ( 0 ) == LTAG ) { \nint rindex = line . indexOf ( RTAG ) ; \nif ( rindex < 0 ) return false ; \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \nString surl = line . substring ( 1 , rindex ) ; \ntry { \nurl = new URL ( surl ) ; \n} \ncatch ( MalformedURLException mue ) { \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \n} \nline = line . substring ( rindex + 1 ) ; \nline = line . trim ( ) ; \n} \nString [ ] pieces = line . split ( \"\\\\s*=\\\\s*\" ) ; \nassert ( pieces . length == 1 || pieces . length == 2 ) ; \nString value = \"1\" ; \nif ( pieces . length == 2 ) value = pieces [ 1 ] . trim ( ) ; \nTriple triple = new Triple ( pieces [ 0 ] . trim ( ) , value , url ) ; \nList < Triple > list = triplestore . get ( triple . key ) ; \nif ( list == null ) list = new ArrayList < Triple > ( ) ; \nTriple prev = addtriple ( list , triple ) ; \ntriplestore . put ( triple . key , list ) ; \n} \n} \ncatch ( FileNotFoundException fe ) { \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \nreturn false ; \n} \ncatch ( IOException ioe ) { \nif ( showlog ) log . error ( \"File \" + abspath + \": IO exception: \" + ioe . getMessage ( ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"5448": "public class GisFeatureRendererMulti { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nlong startTime = System . currentTimeMillis ( ) ; \nif ( featSetList == null ) { \ninitFeatSetList ( ) ; \nassert ! featSetList . isEmpty ( ) ; \n} \nFeatureSet fs = ( FeatureSet ) featSetList . get ( 0 ) ; \nif ( featSetList . size ( ) > 1 ) { \ndouble scale = 1.0 ; \ntry { \nAffineTransform world2device = g . getTransform ( ) ; \nAffineTransform world2normal = normal2device . createInverse ( ) ; \nworld2normal . concatenate ( world2device ) ; \nscale = Math . max ( Math . abs ( world2normal . getScaleX ( ) ) , Math . abs ( world2normal . getShearX ( ) ) ) ; \nif ( Debug . isSet ( \"GisFeature/showTransform\" ) ) { \nSystem . out . println ( \"GisFeature/showTransform: \" + world2normal + \"\\n scale = \" + scale ) ; \n} \n} \ncatch ( java . awt . geom . NoninvertibleTransformException e ) { \nSystem . out . println ( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device ) ; \n} \nif ( ! displayProject . isLatLon ( ) ) scale *= 111.0 ; \ndouble minD = Double . MAX_VALUE ; \nfor ( Object aFeatSetList : featSetList ) { \nFeatureSet tryfs = ( FeatureSet ) aFeatSetList ; \ndouble d = Math . abs ( scale * tryfs . minDist - pixelMatch ) ; \nif ( d < minD ) { \nminD = d ; \nfs = tryfs ; \n} \n} \nif ( Debug . isSet ( \"GisFeature/MapResolution\" ) ) { \nSystem . out . println ( \"GisFeature/MapResolution: scale = \" + scale + \" minDist = \" + fs . minDist ) ; \n} \n} \nif ( fs . featureList == null ) fs . createFeatures ( ) ; \nif ( ! displayProject . equals ( fs . project ) ) { \nfs . setProjection ( displayProject ) ; \n} \nelse { \nif ( fs . newProjection ) { \nif ( displayProject . isLatLon ( ) ) { \nfs . setProjection ( displayProject ) ; \n} \n} \n} \nfs . newProjection = false ; \nif ( Debug . isSet ( \"GisFeature/timing/getShapes\" ) ) { \nlong tookTime = System . currentTimeMillis ( ) - startTime ; \nSystem . out . println ( \"timing.getShapes: \" + tookTime * .001 + \" seconds\" ) ; \n} \nreturn fs . getShapes ( ) ; \n} \n} \n"}
{"5459": "public class ArrayStructure { \npublic int convertScalarInt ( int recnum , StructureMembers . Member m ) { \nif ( m . getDataType ( ) == DataType . INT ) return getScalarInt ( recnum , m ) ; \nelse if ( m . getDataType ( ) == DataType . UINT ) return getScalarInt ( recnum , m ) ; \nif ( m . getDataType ( ) == DataType . SHORT ) return ( int ) getScalarShort ( recnum , m ) ; \nif ( m . getDataType ( ) == DataType . USHORT ) return DataType . unsignedShortToInt ( getScalarShort ( recnum , m ) ) ; \nif ( m . getDataType ( ) == DataType . BYTE ) return ( int ) getScalarByte ( recnum , m ) ; \nif ( m . getDataType ( ) == DataType . UBYTE ) return ( int ) DataType . unsignedByteToShort ( getScalarByte ( recnum , m ) ) ; \nif ( m . getDataType ( ) == DataType . LONG ) return ( int ) getScalarLong ( recnum , m ) ; \nelse if ( m . getDataType ( ) == DataType . ULONG ) return ( int ) getScalarLong ( recnum , m ) ; \nObject o = getScalarObject ( recnum , m ) ; \nif ( o instanceof Number ) return ( ( Number ) o ) . intValue ( ) ; \nthrow new ForbiddenConversionException ( \"Type is \" + m . getDataType ( ) + \", not convertible to int\" ) ; \n} \n} \n"}
{"5465": "public class ArrayStructure { \npublic ArrayStructure getArrayStructure ( int recnum , StructureMembers . Member m ) { \nif ( m . getDataType ( ) != DataType . STRUCTURE ) { \nif ( m . getDataType ( ) != DataType . SEQUENCE ) throw new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be Structure or Sequence\" ) ; \n} \nif ( m . getDataType ( ) == DataType . SEQUENCE ) return getArraySequence ( recnum , m ) ; \nArrayStructure array = ( ArrayStructure ) m . getDataArray ( ) ; \nint count = m . getSize ( ) ; \nStructureData [ ] this_sdata = new StructureData [ count ] ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) this_sdata [ i ] = array . getStructureData ( recnum * count + i ) ; \nStructureMembers membersw = new StructureMembers ( array . getStructureMembers ( ) ) ; \nreturn new ArrayStructureW ( membersw , m . getShape ( ) , this_sdata ) ; \n} \n} \n"}
{"5476": "public class CEConstraint { \nstatic public CEConstraint compile ( String sce , DapDataset dmr ) throws DapException { \nif ( sce == null ) return CEConstraint . getUniversal ( dmr ) ; \nelse if ( sce . length ( ) == 0 ) return CEConstraint . getUniversal ( dmr ) ; \nCEParserImpl ceparser = new CEParserImpl ( dmr ) ; \nif ( PARSEDEBUG ) ceparser . setDebugLevel ( 1 ) ; \nif ( DEBUG ) { \nSystem . err . println ( \"Dap4Servlet: parsing constraint: |\" + sce + \"|\" ) ; \n} \nboolean ok ; \ntry { \nok = ceparser . parse ( sce ) ; \n} \ncatch ( ParseException pe ) { \nok = false ; \n} \nif ( ! ok ) throw new DapException ( \"Constraint parse failed: \" + sce ) ; \nCEAST root = ceparser . getCEAST ( ) ; \nCECompiler compiler = new CECompiler ( ) ; \nCEConstraint ce = compiler . compile ( dmr , root ) ; \nce . expand ( ) ; \nce . finish ( ) ; \nreturn ce ; \n} \n} \n"}
{"5479": "public class GempakFileReader { \npublic int getByteOrder ( int kmachn ) { \nif ( ( kmachn == MTVAX ) || ( kmachn == MTULTX ) || ( kmachn == MTALPH ) || ( kmachn == MTLNUX ) ) { \nreturn RandomAccessFile . LITTLE_ENDIAN ; \n} \nelse if ( kmachn == MTIGPH ) { \nreturn RandomAccessFile . LITTLE_ENDIAN ; \n} \nreturn RandomAccessFile . BIG_ENDIAN ; \n} \n} \n"}
{"5482": "public class GempakFileReader { \npublic DMFileHeaderInfo findFileHeader ( String name ) { \nif ( fileHeaderInfo == null ) { \nreturn null ; \n} \nelse if ( fileHeaderInfo . isEmpty ( ) ) { \nreturn null ; \n} \nfor ( DMFileHeaderInfo fhi : fileHeaderInfo ) { \nif ( name . equals ( fhi . kfhnam ) ) { \nreturn fhi ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5483": "public class GempakFileReader { \npublic float [ ] getFileHeader ( String name ) throws IOException { \nDMFileHeaderInfo fh = findFileHeader ( name ) ; \nif ( fh == null ) { \nreturn null ; \n} \nelse if ( fh . kfhtyp != MDREAL ) { \nreturn null ; \n} \nint knt = fileHeaderInfo . indexOf ( fh ) ; \nint iread = dmLabel . kpfile + 3 * dmLabel . kfhdrs ; \nfor ( int i = 0 ; \ni < knt ; \ni ++ ) { \nDMFileHeaderInfo fhi = fileHeaderInfo . get ( i ) ; \niread = iread + fhi . kfhlen + 1 ; \n} \nint nword = DM_RINT ( iread ) ; \nif ( nword <= 0 ) { \nlogError ( \"Invalid header length for \" + name ) ; \nreturn null ; \n} \niread ++ ; \nfloat [ ] rheader = new float [ nword ] ; \nif ( name . equals ( \"NAVB\" ) && needToSwap ) { \nDM_RFLT ( iread , 1 , rheader , 0 ) ; \nneedToSwap = false ; \niread ++ ; \nDM_RFLT ( iread , 1 , rheader , 1 ) ; \nneedToSwap = true ; \niread ++ ; \nDM_RFLT ( iread , nword - 2 , rheader , 2 ) ; \n} \nelse { \nDM_RFLT ( iread , rheader ) ; \n} \nreturn rheader ; \n} \n} \n"}
{"5485": "public class GempakFileReader { \npublic int getDataPointer ( int irow , int icol , String partName ) { \nint ipoint = - 1 ; \nif ( ( irow < 1 ) || ( irow > dmLabel . krow ) || ( icol < 1 ) ) { \nSystem . out . println ( \"bad row or column number: \" + irow + \"/\" + icol ) ; \nreturn ipoint ; \n} \nelse if ( icol > dmLabel . kcol ) { \nSystem . out . println ( \"bad row or column number: \" + irow + \"/\" + icol ) ; \nreturn ipoint ; \n} \nint iprt = getPartNumber ( partName ) ; \nif ( iprt == 0 ) { \nSystem . out . println ( \"couldn't find part\" ) ; \nreturn ipoint ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( ( part . ktyprt != MDREAL ) && ( part . ktyprt != MDGRID ) ) { \nif ( part . ktyprt != MDRPCK ) { \nSystem . out . println ( \"Not a valid type\" ) ; \nreturn ipoint ; \n} \n} \nint ilenhd = part . klnhdr ; \nipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( icol - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nreturn ipoint ; \n} \n} \n"}
{"5495": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { \nList < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; \nIterator < DataDescriptor > dkIter = keys . iterator ( ) ; \nwhile ( dkIter . hasNext ( ) ) { \nDataDescriptor dk = dkIter . next ( ) ; \nif ( dk . f == 1 ) { \ndk . subKeys = new ArrayList < DataDescriptor > ( ) ; \ndk . replication = dk . y ; \nif ( dk . replication == 0 ) { \nroot . isVarLength = true ; \nDataDescriptor replication = dkIter . next ( ) ; \nif ( replication . y == 0 ) dk . replicationCountSize = 1 ; \nelse if ( replication . y == 1 ) dk . replicationCountSize = 8 ; \nelse if ( replication . y == 2 ) dk . replicationCountSize = 16 ; \nelse if ( replication . y == 11 ) dk . repetitionCountSize = 8 ; \nelse if ( replication . y == 12 ) dk . repetitionCountSize = 16 ; \nelse log . error ( \"Unknown replication type= \" + replication ) ; \n} \nfor ( int j = 0 ; \nj < dk . x && dkIter . hasNext ( ) ; \nj ++ ) { \ndk . subKeys . add ( dkIter . next ( ) ) ; \n} \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \nelse if ( dk . f == 3 ) { \nif ( dk . subKeys != null ) { \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \n} \ntree . add ( dk ) ; \n} \nreturn tree ; \n} \n} \n"}
{"5507": "public class Attribute { \npublic Array getValues ( ) { \nif ( values == null ) { \nif ( svalue != null ) { \nvalues = Array . factory ( DataType . STRING , new int [ ] { \n1 } \n) ; \nvalues . setObject ( values . getIndex ( ) , svalue ) ; \n} \n} \nreturn values ; \n} \n} \n"}
{"5508": "public class Attribute { \npublic Number getNumericValue ( int index ) { \nif ( index < 0 ) return null ; \nelse if ( index >= nelems ) return null ; \nswitch ( dataType ) { \ncase STRING : try { \nreturn new Double ( getStringValue ( index ) ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn null ; \n} \ncase BYTE : case UBYTE : return values . getByte ( index ) ; \ncase SHORT : case USHORT : return values . getShort ( index ) ; \ncase INT : case UINT : return values . getInt ( index ) ; \ncase FLOAT : return values . getFloat ( index ) ; \ncase DOUBLE : return values . getDouble ( index ) ; \ncase LONG : case ULONG : return values . getLong ( index ) ; \n} \nreturn null ; \n} \n} \n"}
{"5509": "public class Attribute { \nprotected void writeCDL ( Formatter f , boolean strict , String parentname ) { \nif ( strict ) { \nif ( isString ( ) || this . getEnumType ( ) != null ) f . format ( \"string \" ) ; \n} \nif ( strict ) { \nif ( parentname != null ) f . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; \n} \nf . format ( \":\" ) ; \nf . format ( \"%s\" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; \nif ( isString ( ) ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nString val = getStringValue ( i ) ; \nif ( val != null ) f . format ( \"\\\"%s\\\"\" , encodeString ( val ) ) ; \n} \n} \nelse if ( getEnumType ( ) != null ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nEnumTypedef en = getEnumType ( ) ; \nString econst = getStringValue ( i ) ; \nInteger ecint = en . lookupEnumInt ( econst ) ; \nif ( ecint == null ) throw new ForbiddenConversionException ( \"Illegal enum constant: \" + econst ) ; \nf . format ( \"\\\"%s\\\"\" , encodeString ( econst ) ) ; \n} \n} \nelse { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nNumber number = getNumericValue ( i ) ; \nif ( dataType . isUnsigned ( ) ) { \nnumber = DataType . widenNumber ( number ) ; \n} \nf . format ( \"%s\" , number ) ; \nif ( dataType . isUnsigned ( ) ) { \nf . format ( \"U\" ) ; \n} \nif ( dataType == DataType . FLOAT ) f . format ( \"f\" ) ; \nelse if ( dataType == DataType . SHORT || dataType == DataType . USHORT ) { \nf . format ( \"S\" ) ; \n} \nelse if ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) { \nf . format ( \"B\" ) ; \n} \nelse if ( dataType == DataType . LONG ) { \nf . format ( \"L\" ) ; \n} \nelse if ( dataType == DataType . ULONG ) { \nf . format ( \"L\" ) ; \n} \n} \n} \n} \n} \n"}
{"5511": "public class Attribute { \npublic void setValues ( List values ) { \nif ( values == null ) throw new IllegalArgumentException ( \"Cannot determine attribute's type\" ) ; \nelse if ( values . size ( ) == 0 ) throw new IllegalArgumentException ( \"Cannot determine attribute's type\" ) ; \nint n = values . size ( ) ; \nClass c = values . get ( 0 ) . getClass ( ) ; \nObject pa ; \nif ( c == String . class ) { \nString [ ] va = new String [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( String ) values . get ( i ) ; \n} \nelse if ( c == Integer . class ) { \nint [ ] va = new int [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Integer ) values . get ( i ) ; \n} \nelse if ( c == Double . class ) { \ndouble [ ] va = new double [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Double ) values . get ( i ) ; \n} \nelse if ( c == Float . class ) { \nfloat [ ] va = new float [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Float ) values . get ( i ) ; \n} \nelse if ( c == Short . class ) { \nshort [ ] va = new short [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Short ) values . get ( i ) ; \n} \nelse if ( c == Byte . class ) { \nbyte [ ] va = new byte [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Byte ) values . get ( i ) ; \n} \nelse if ( c == Long . class ) { \nlong [ ] va = new long [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Long ) values . get ( i ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Unknown type for Attribute = \" + c . getName ( ) ) ; \n} \nsetValues ( Array . factory ( this . dataType , new int [ ] { \nn } \n, pa ) ) ; \n} \n} \n"}
{"5524": "public class CoordinateSystem { \npublic CoordinateAxis findAxis ( AxisType type ) { \nCoordinateAxis result = null ; \nfor ( CoordinateAxis axis : coordAxes ) { \nAxisType axisType = axis . getAxisType ( ) ; \nif ( axisType != null ) { \nif ( axisType == type ) result = lesserRank ( result , axis ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"5526": "public class CoordinateSystem { \npublic boolean isGeoXY ( ) { \nif ( xAxis == null ) return false ; \nelse if ( yAxis == null ) return false ; \nreturn null != getProjection ( ) && ! ( projection instanceof LatLonProjection ) ; \n} \n} \n"}
{"5547": "public class NestedTable { \nStationFeature makeStation ( StructureData stationData ) { \nif ( stnVE . isMissing ( stationData ) ) return null ; \nString stationName = stnVE . getCoordValueAsString ( stationData ) ; \nString stationDesc = ( stnDescVE == null ) ? \"\" : stnDescVE . getCoordValueAsString ( stationData ) ; \nString stnWmoId = ( wmoVE == null ) ? \"\" : wmoVE . getCoordValueAsString ( stationData ) ; \ndouble lat = latVE . getCoordValue ( stationData ) ; \ndouble lon = lonVE . getCoordValue ( stationData ) ; \ndouble elev = ( stnAltVE == null ) ? Double . NaN : stnAltVE . getCoordValue ( stationData ) ; \nif ( Double . isNaN ( lat ) ) return null ; \nelse if ( Double . isNaN ( lon ) ) return null ; \nreturn new StationFeatureImpl ( stationName , stationDesc , stnWmoId , lat , lon , elev , - 1 , stationData ) ; \n} \n} \n"}
{"5563": "public class CatalogCrawler { \npublic int crawl ( InvCatalogImpl cat , CancelTask task , PrintWriter out , Object context ) { \nif ( out != null ) out . println ( \"***CATALOG \" + cat . getCreateFrom ( ) ) ; \ncountCatrefs = 0 ; \nfor ( InvDataset ds : cat . getDatasets ( ) ) { \nif ( type == Type . all ) crawlDataset ( ds , task , out , context , true ) ; \nelse crawlDirectDatasets ( ds , task , out , context , true ) ; \nif ( task != null ) { \nif ( task . isCancel ( ) ) break ; \n} \n} \nreturn 1 + countCatrefs ; \n} \n} \n"}
{"5564": "public class CatalogCrawler { \npublic void crawlDataset ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null ) { \nif ( filter . skipAll ( ds ) ) { \nif ( isCatRef ) { \nif ( release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \n} \nreturn ; \n} \n} \nboolean isDataScan = ds . findProperty ( \"DatasetScan\" ) != null ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nif ( ! isCatRef ) listen . getDataset ( ds , context ) ; \nelse if ( isDataScan ) listen . getDataset ( ds , context ) ; \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( ! isDataScan ) { \nlisten . getDataset ( catref . getProxyDataset ( ) , context ) ; \n} \n} \nfor ( InvDataset dds : dlist ) { \ncrawlDataset ( dds , task , out , context , release ) ; \nif ( task != null ) { \nif ( task . isCancel ( ) ) break ; \n} \n} \nif ( isCatRef ) { \nif ( release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n} \n"}
{"5565": "public class CatalogCrawler { \npublic void crawlDirectDatasets ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null ) { \nif ( filter . skipAll ( ds ) ) { \nif ( isCatRef ) { \nif ( release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \n} \nreturn ; \n} \n} \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nList < InvDataset > leaves = new ArrayList < InvDataset > ( ) ; \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasAccess ( ) ) leaves . add ( dds ) ; \n} \nif ( leaves . size ( ) > 0 ) { \nif ( type == Type . first_direct ) { \nInvDataset dds = leaves . get ( 0 ) ; \nlisten . getDataset ( dds , context ) ; \n} \nelse if ( type == Type . random_direct ) { \nlisten . getDataset ( chooseRandom ( leaves ) , context ) ; \n} \nelse if ( type == Type . random_direct_middle ) { \nlisten . getDataset ( chooseRandomNotFirstOrLast ( leaves ) , context ) ; \n} \nelse { \nfor ( InvDataset dds : leaves ) { \nlisten . getDataset ( dds , context ) ; \nif ( task != null ) { \nif ( task . isCancel ( ) ) break ; \n} \n} \n} \n} \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasNestedDatasets ( ) ) crawlDirectDatasets ( dds , task , out , context , release ) ; \nif ( task != null ) { \nif ( task . isCancel ( ) ) break ; \n} \n} \nif ( ds instanceof InvCatalogRef ) { \nif ( release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n} \n"}
{"5567": "public class GribIndexCache { \npublic static File getExistingFileOrCache ( String fileLocation ) { \nFile result = getDiskCache2 ( ) . getExistingFileOrCache ( fileLocation ) ; \nif ( result == null && Grib . debugGbxIndexOnly ) { \nif ( fileLocation . endsWith ( \".gbx9.ncx4\" ) ) { \nint length = fileLocation . length ( ) ; \nString maybeIndexAlreadyExists = fileLocation . substring ( 0 , length - 10 ) + \".ncx4\" ; \nresult = getDiskCache2 ( ) . getExistingFileOrCache ( maybeIndexAlreadyExists ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"5570": "public class RandomAccessFile { \npublic synchronized void close ( ) throws IOException { \nif ( cache != null ) { \nif ( cacheState > 0 ) { \nif ( cacheState == 1 ) { \ncacheState = 2 ; \nif ( cache . release ( this ) ) return ; \ncacheState = 0 ; \n} \nelse { \nreturn ; \n} \n} \n} \nif ( debugLeaks ) { \nopenFiles . remove ( location ) ; \nif ( showOpen ) System . out . println ( \"  close \" + location ) ; \n} \nif ( file == null ) return ; \nflush ( ) ; \nlong fileSize = file . length ( ) ; \nif ( ! readonly && ( minLength != 0 ) ) { \nif ( minLength != fileSize ) { \nfile . setLength ( minLength ) ; \n} \n} \nfile . close ( ) ; \nfile = null ; \n} \n} \n"}
{"5571": "public class RandomAccessFile { \npublic void seek ( long pos ) throws IOException { \nif ( pos < 0 ) throw new java . io . IOException ( \"Negative seek offset\" ) ; \nif ( pos >= bufferStart ) { \nif ( pos < dataEnd ) { \nfilePosition = pos ; \nreturn ; \n} \n} \nreadBuffer ( pos ) ; \n} \n} \n"}
{"5597": "public class DirectoryBuilder { \nprivate void scanForChildren ( ) { \nif ( debug ) System . out . printf ( \"DirectoryBuilder.scanForChildren on %s \" , dir ) ; \nint count = 0 ; \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( dir ) ) { \nfor ( Path p : ds ) { \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( attr . isDirectory ( ) ) { \nchildren . add ( new DirectoryBuilder ( topCollectionName , p , attr , suffix ) ) ; \nif ( debug ) { \nif ( ++ count % 10 == 0 ) System . out . printf ( \"%d \" , count ) ; \n} \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nif ( debug ) System . out . printf ( \"done=%d%n\" , count ) ; \nchildrenConstructed = true ; \n} \n} \n"}
{"5604": "public class BufrNumbers { \nprivate static int int4 ( int a , int b , int c , int d ) { \nif ( a == 0xff && b == 0xff && c == 0xff ) { \nif ( d == 0xff ) return UNDEFINED ; \n} \nreturn ( 1 - ( ( a & 128 ) >> 6 ) ) * ( ( a & 127 ) << 24 | b << 16 | c << 8 | d ) ; \n} \n} \n"}
{"5605": "public class FileCacheARC { \nprivate CacheElement updateInCache ( CacheElement elem ) { \nif ( shadowCache . firstKey ( ) == elem ) return elem ; \nelem . updateAccessed ( ) ; \nCacheElement prev = shadowCache . put ( elem , elem ) ; \nif ( prev != null ) { \nif ( elem != prev ) { \nCacheElementComparator cc = new CacheElementComparator ( ) ; \nSystem . out . printf ( \"elem != prev compare=%d%n\" , cc . compare ( elem , prev ) ) ; \nSystem . out . printf ( \"hash elem =%d prev=%d%n\" , elem . hashCode ( ) , prev . hashCode ( ) ) ; \n} \n} \nreturn elem ; \n} \n} \n"}
{"5606": "public class FileCacheARC { \npublic synchronized void clearCache ( boolean force ) { \nList < CacheElement . CacheFile > deleteList = new ArrayList < > ( 2 * cache . size ( ) ) ; \nif ( force ) { \ncache . clear ( ) ; \ndeleteList . addAll ( files . values ( ) ) ; \nfiles . clear ( ) ; \n} \nelse { \nIterator < CacheElement . CacheFile > iter = files . values ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nCacheElement . CacheFile file = iter . next ( ) ; \nif ( file . isLocked . compareAndSet ( false , true ) ) { \nfile . remove ( ) ; \ndeleteList . add ( file ) ; \niter . remove ( ) ; \n} \n} \nfor ( CacheElement elem : cache . values ( ) ) { \nif ( elem . list . size ( ) == 0 ) cache . remove ( elem . hashKey ) ; \n} \n} \nfor ( CacheElement . CacheFile file : deleteList ) { \nif ( force ) { \nif ( file . isLocked . get ( ) ) cacheLog . warn ( \"FileCacheARC \" + name + \" force close locked file= \" + file ) ; \n} \nif ( file . ncfile == null ) continue ; \ntry { \nfile . ncfile . setFileCache ( null ) ; \nfile . ncfile . close ( ) ; \nfile . ncfile = null ; \n} \ncatch ( IOException e ) { \nlog . error ( \"FileCacheARC \" + name + \" close failed on \" + file ) ; \n} \n} \nif ( cacheLog . isDebugEnabled ( ) ) cacheLog . debug ( \"*FileCacheARC \" + name + \" clearCache force= \" + force + \" deleted= \" + deleteList . size ( ) + \" left=\" + files . size ( ) ) ; \n} \n} \n"}
{"5610": "public class GridCoordSys { \n@ Override public int [ ] findXYindexFromCoord ( double x_coord , double y_coord , int [ ] result ) { \nif ( result == null ) result = new int [ 2 ] ; \nif ( ( horizXaxis instanceof CoordinateAxis1D ) && ( horizYaxis instanceof CoordinateAxis1D ) ) { \nresult [ 0 ] = ( ( CoordinateAxis1D ) horizXaxis ) . findCoordElement ( x_coord ) ; \nresult [ 1 ] = ( ( CoordinateAxis1D ) horizYaxis ) . findCoordElement ( y_coord ) ; \nreturn result ; \n} \nelse if ( horizXaxis instanceof CoordinateAxis2D ) { \nif ( horizYaxis instanceof CoordinateAxis2D ) { \nif ( g2d == null ) g2d = new GridCoordinate2D ( ( CoordinateAxis2D ) horizYaxis , ( CoordinateAxis2D ) horizXaxis ) ; \nint [ ] result2 = new int [ 2 ] ; \nboolean found = g2d . findCoordElement ( y_coord , x_coord , result2 ) ; \nif ( found ) { \nresult [ 0 ] = result2 [ 1 ] ; \nresult [ 1 ] = result2 [ 0 ] ; \n} \nelse { \nresult [ 0 ] = - 1 ; \nresult [ 1 ] = - 1 ; \n} \nreturn result ; \n} \n} \nthrow new IllegalStateException ( \"GridCoordSystem.findXYindexFromCoord\" ) ; \n} \n} \n"}
{"5611": "public class GridCoordSys { \n@ Override public int [ ] findXYindexFromCoordBounded ( double x_coord , double y_coord , int [ ] result ) { \nif ( result == null ) result = new int [ 2 ] ; \nif ( ( horizXaxis instanceof CoordinateAxis1D ) && ( horizYaxis instanceof CoordinateAxis1D ) ) { \nresult [ 0 ] = ( ( CoordinateAxis1D ) horizXaxis ) . findCoordElementBounded ( x_coord ) ; \nresult [ 1 ] = ( ( CoordinateAxis1D ) horizYaxis ) . findCoordElementBounded ( y_coord ) ; \nreturn result ; \n} \nelse if ( horizXaxis instanceof CoordinateAxis2D ) { \nif ( horizYaxis instanceof CoordinateAxis2D ) { \nif ( g2d == null ) g2d = new GridCoordinate2D ( ( CoordinateAxis2D ) horizYaxis , ( CoordinateAxis2D ) horizXaxis ) ; \nint [ ] result2 = new int [ 2 ] ; \ng2d . findCoordElement ( y_coord , x_coord , result2 ) ; \nresult [ 0 ] = result2 [ 1 ] ; \nresult [ 1 ] = result2 [ 0 ] ; \nreturn result ; \n} \n} \nthrow new IllegalStateException ( \"GridCoordSystem.findXYindexFromCoord\" ) ; \n} \n} \n"}
{"5623": "public class CalendarPeriod { \npublic double getConvertFactor ( CalendarPeriod from ) { \nif ( field == CalendarPeriod . Field . Month ) { \nlog . warn ( \" CalendarDate.convert on Month or Year\" ) ; \n} \nelse if ( field == CalendarPeriod . Field . Year ) { \nlog . warn ( \" CalendarDate.convert on Month or Year\" ) ; \n} \nreturn ( double ) from . millisecs ( ) / millisecs ( ) ; \n} \n} \n"}
{"5626": "public class GempakGridServiceProvider { \npublic boolean sync ( ) throws IOException { \nif ( gemreader . getInitFileSize ( ) < raf . length ( ) ) { \nif ( extendIndex ) { \ngemreader . init ( true ) ; \nGridIndex index = gemreader . getGridIndex ( ) ; \nncfile . empty ( ) ; \nopen ( index , null ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5647": "public class ConvertD2N { \npublic Array convertTopVariable ( ucar . nc2 . Variable v , List < Range > section , DodsV dataV ) throws IOException , DAP2Exception { \nArray data = convert ( dataV ) ; \nif ( dataV . darray != null ) { \nif ( dataV . bt instanceof DString ) { \nif ( v . getDataType ( ) == DataType . STRING ) return convertStringArray ( data , v ) ; \nelse if ( v . getDataType ( ) == DataType . CHAR ) return convertStringArrayToChar ( dataV . darray , v , section ) ; \nelse { \nString mess = \"DODSVariable convertArray String invalid dataType= \" + v . getDataType ( ) ; \nlogger . error ( mess ) ; \nthrow new IllegalArgumentException ( mess ) ; \n} \n} \n} \nif ( dataV . bt instanceof DString ) { \nif ( v . getDataType ( ) == DataType . CHAR ) { \nreturn convertStringToChar ( data , v ) ; \n} \n} \nreturn data ; \n} \n} \n"}
{"5658": "public class Grib2Pds { \nprotected CalendarDate calcTime ( int startIndex ) { \nint year = GribNumbers . int2 ( getOctet ( startIndex ++ ) , getOctet ( startIndex ++ ) ) ; \nint month = getOctet ( startIndex ++ ) ; \nint day = getOctet ( startIndex ++ ) ; \nint hour = getOctet ( startIndex ++ ) ; \nint minute = getOctet ( startIndex ++ ) ; \nint second = getOctet ( startIndex ++ ) ; \nif ( ( year == 0 ) && ( month == 0 ) && ( day == 0 ) && ( hour == 0 ) && ( minute == 0 ) ) { \nif ( second == 0 ) return CalendarDate . UNKNOWN ; \n} \nif ( hour > 23 ) { \nday += ( hour / 24 ) ; \nhour = hour % 24 ; \n} \nreturn CalendarDate . of ( null , year , month , day , hour , minute , second ) ; \n} \n} \n"}
{"5661": "public class EcmwfLocalConcepts { \nprivate void addLocalConcept ( InputStream is , String conceptName ) throws IOException { \ntry ( BufferedReader br = new BufferedReader ( new InputStreamReader ( is , ENCODING ) ) ) { \nString line = br . readLine ( ) ; \nwhile ( ! line . startsWith ( \"#\" ) ) line = br . readLine ( ) ; \nwhile ( true ) { \nHashMap < String , String > items = new HashMap < > ( ) ; \nline = br . readLine ( ) ; \nif ( line == null ) break ; \nif ( line . length ( ) == 0 ) continue ; \nelse if ( line . startsWith ( \"#\" ) ) continue ; \nline = cleanLine ( line ) ; \nif ( line . contains ( \"{\" ) ) { \nString paramName = line . split ( \"=\" ) [ 0 ] . trim ( ) ; \nline = br . readLine ( ) ; \nif ( line == null ) break ; \nline = cleanLine ( line ) ; \nwhile ( line . contains ( \"=\" ) ) { \nString [ ] kvp = line . split ( \"=\" ) ; \nitems . put ( kvp [ 0 ] . trim ( ) , kvp [ 1 ] . trim ( ) ) ; \nline = br . readLine ( ) ; \nif ( line == null ) break ; \nline = cleanLine ( line ) ; \n} \nString tableVersion = items . get ( TABLE_VERSION_ID ) ; \nString parameterNumber = items . get ( PARAM_NUM_ID ) ; \nstoreConcept ( tableVersion , parameterNumber , conceptName , paramName ) ; \n} \n} \n} \n} \n} \n"}
{"5673": "public class DatasetSource { \nprivate void nameDatasetTree ( InvDatasetImpl dataset ) { \nif ( dataset . getName ( ) . equals ( \"\" ) ) { \nlogger . debug ( \"nameDatasetTree(): naming dataset ({})...\" , dataset . getUrlPath ( ) ) ; \nDatasetNamer dsN = null ; \nfor ( int i = 0 ; \ni < this . datasetNamerList . size ( ) ; \ni ++ ) { \ndsN = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nif ( dsN . nameDataset ( dataset ) ) { \nlogger . debug ( \"nameDatasetTree(): ... used namer ({})\" , dsN . getName ( ) ) ; \nbreak ; \n} \n} \n} \nelse if ( ! dataset . hasAccess ( ) ) { \nlogger . debug ( \"nameDatasetTree(): naming dataset ({})...\" , dataset . getUrlPath ( ) ) ; \nDatasetNamer dsN = null ; \nfor ( int i = 0 ; \ni < this . datasetNamerList . size ( ) ; \ni ++ ) { \ndsN = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nif ( dsN . nameDataset ( dataset ) ) { \nlogger . debug ( \"nameDatasetTree(): ... used namer ({})\" , dsN . getName ( ) ) ; \nbreak ; \n} \n} \n} \nInvDatasetImpl curDs = null ; \nfor ( int j = 0 ; \nj < dataset . getDatasets ( ) . size ( ) ; \nj ++ ) { \ncurDs = ( InvDatasetImpl ) dataset . getDatasets ( ) . get ( j ) ; \nlogger . debug ( \"nameDatasetTree(): recurse to name child dataset ({})\" , curDs . getUrlPath ( ) ) ; \nthis . nameDatasetTree ( curDs ) ; \n} \nreturn ; \n} \n} \n"}
{"5687": "public class DiskCache { \nstatic public File getCacheFile ( String fileLocation ) { \nFile f = new File ( makeCachePath ( fileLocation ) ) ; \nif ( f . exists ( ) ) { \nif ( ! f . setLastModified ( System . currentTimeMillis ( ) ) ) logger . warn ( \"Failed to setLastModified on \" + f . getPath ( ) ) ; \n} \nif ( ! checkExist ) { \nFile dir = f . getParentFile ( ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! dir . mkdirs ( ) ) logger . warn ( \"Failed to mkdirs on \" + dir . getPath ( ) ) ; \n} \ncheckExist = true ; \n} \nreturn f ; \n} \n} \n"}
{"5689": "public class DiskCache { \nstatic public void cleanCache ( long maxBytes , Comparator < File > fileComparator , StringBuilder sbuff ) { \nif ( sbuff != null ) sbuff . append ( \"DiskCache clean maxBytes= \" ) . append ( maxBytes ) . append ( \"on dir \" ) . append ( root ) . append ( \"\\n\" ) ; \nFile dir = new File ( root ) ; \nlong total = 0 , total_delete = 0 ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files != null ) { \nList < File > fileList = Arrays . asList ( files ) ; \nCollections . sort ( fileList , fileComparator ) ; \nfor ( File file : fileList ) { \nif ( file . length ( ) + total > maxBytes ) { \ntotal_delete += file . length ( ) ; \nif ( sbuff != null ) sbuff . append ( \" delete \" ) . append ( file ) . append ( \" (\" ) . append ( file . length ( ) ) . append ( \")\\n\" ) ; \nif ( ! file . delete ( ) ) { \nif ( sbuff != null ) sbuff . append ( \"Error deleting \" ) . append ( file ) . append ( \"\\n\" ) ; \n} \n} \nelse { \ntotal += file . length ( ) ; \n} \n} \n} \nif ( sbuff != null ) { \nsbuff . append ( \"Total bytes deleted= \" ) . append ( total_delete ) . append ( \"\\n\" ) ; \nsbuff . append ( \"Total bytes left in cache= \" ) . append ( total ) . append ( \"\\n\" ) ; \n} \n} \n} \n"}
{"5698": "public class JTableSorted { \npublic void incrSelected ( boolean increment ) { \nif ( list . size ( ) == 0 ) return ; \nint curr = jtable . getSelectedRow ( ) ; \nif ( increment && ( curr < list . size ( ) - 1 ) ) setSelected ( curr + 1 ) ; \nelse if ( ! increment ) { \nif ( curr > 0 ) setSelected ( curr - 1 ) ; \n} \n} \n} \n"}
{"5705": "public class XMLStore { \nstatic public XMLStore createFromFile ( String fileName , XMLStore storedDefaults ) throws java . io . IOException { \nFile prefsFile = new File ( fileName ) ; \nInputStream primIS = null , objIS = null ; \nif ( prefsFile . exists ( ) ) { \nif ( prefsFile . length ( ) > 0 ) { \nprimIS = new BufferedInputStream ( new FileInputStream ( prefsFile ) ) ; \nobjIS = new BufferedInputStream ( new FileInputStream ( prefsFile ) ) ; \n} \n} \nif ( debugWhichStore ) System . out . println ( \"XMLStore read from file \" + fileName ) ; \nXMLStore store = new XMLStore ( primIS , objIS , storedDefaults ) ; \nstore . prefsFile = prefsFile ; \nreturn store ; \n} \n} \n"}
{"5722": "public class CDMCursor { \n@ Override public Object read ( List < Slice > slices ) throws DapException { \nswitch ( this . scheme ) { \ncase ATOMIC : return readAtomic ( slices ) ; \ncase STRUCTURE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \nelse if ( DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \nCDMCursor [ ] instances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase SEQUENCE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \nelse if ( DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \ninstances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase STRUCTARRAY : Odometer odom = Odometer . factory ( slices ) ; \ninstances = new CDMCursor [ ( int ) odom . totalSize ( ) ] ; \nfor ( int i = 0 ; \nodom . hasNext ( ) ; \ni ++ ) { \ninstances [ i ] = readStructure ( odom . next ( ) ) ; \n} \nreturn instances ; \ncase SEQARRAY : instances = readSequence ( slices ) ; \nreturn instances ; \ndefault : throw new DapException ( \"Attempt to slice a scalar object\" ) ; \n} \n} \n} \n"}
{"5728": "public class StationRenderer { \npublic ucar . unidata . geoloc . Station pick ( Point2D pickPt ) { \nif ( world2Normal == null || pickPt == null ) return null ; \nelse if ( stations . isEmpty ( ) ) return null ; \nworld2Normal . transform ( pickPt , ptN ) ; \nStationUI closest = ( StationUI ) stationGrid . findIntersection ( ptN ) ; \nsetSelectedStation ( closest ) ; \nreturn getSelectedStation ( ) ; \n} \n} \n"}
{"5729": "public class StationRenderer { \npublic ucar . unidata . geoloc . Station pickClosest ( Point2D pickPt ) { \nif ( world2Normal == null || pickPt == null ) return null ; \nelse if ( stations . isEmpty ( ) ) return null ; \nworld2Normal . transform ( pickPt , ptN ) ; \nStationUI closest = ( StationUI ) stationGrid . findClosest ( ptN ) ; \nif ( debug ) System . out . println ( \"closest= \" + closest ) ; \nsetSelectedStation ( closest ) ; \nreturn getSelectedStation ( ) ; \n} \n} \n"}
{"5757": "public class TimeOffsetAxis { \npublic Optional < TimeOffsetAxis > subsetFromTime ( SubsetParams params , CalendarDate runDate ) { \nCoordAxisHelper helper = new CoordAxisHelper ( this ) ; \nCoverageCoordAxisBuilder builder = null ; \nif ( params . isTrue ( SubsetParams . timePresent ) ) { \ndouble offset = getOffsetInTimeUnits ( runDate , CalendarDate . present ( ) ) ; \nbuilder = helper . subsetClosest ( offset ) ; \n} \nCalendarDate dateWanted = ( CalendarDate ) params . get ( SubsetParams . time ) ; \nif ( dateWanted != null ) { \ndouble offset = getOffsetInTimeUnits ( runDate , dateWanted ) ; \nbuilder = helper . subsetClosest ( offset ) ; \n} \nInteger stride = ( Integer ) params . get ( SubsetParams . timeStride ) ; \nif ( stride == null ) stride = 1 ; \nelse if ( stride < 0 ) stride = 1 ; \nCalendarDateRange dateRange = ( CalendarDateRange ) params . get ( SubsetParams . timeRange ) ; \nif ( dateRange != null ) { \ndouble min = getOffsetInTimeUnits ( runDate , dateRange . getStart ( ) ) ; \ndouble max = getOffsetInTimeUnits ( runDate , dateRange . getEnd ( ) ) ; \nOptional < CoverageCoordAxisBuilder > buildero = helper . subset ( min , max , stride ) ; \nif ( buildero . isPresent ( ) ) builder = buildero . get ( ) ; \nelse return Optional . empty ( buildero . getErrorMessage ( ) ) ; \n} \nassert ( builder != null ) ; \nbuilder . setReferenceDate ( runDate ) ; \nreturn Optional . of ( new TimeOffsetAxis ( builder ) ) ; \n} \n} \n"}
{"5783": "public class NetcdfFile { \nprotected Boolean makeRecordStructure ( ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nBoolean didit = false ; \nif ( ( spi != null ) && ( spi instanceof N3iosp ) ) { \nif ( hasUnlimitedDimension ( ) ) { \ndidit = ( Boolean ) spi . sendIospMessage ( IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) ; \n} \n} \nreturn didit ; \n} \n} \n"}
{"5786": "public class NetcdfFile { \nprotected long readToByteChannel ( ucar . nc2 . Variable v , Section section , WritableByteChannel wbc ) throws java . io . IOException , ucar . ma2 . InvalidRangeException { \nif ( spi == null ) return IospHelper . copyToByteChannel ( v . read ( section ) , wbc ) ; \nelse if ( v . hasCachedData ( ) ) return IospHelper . copyToByteChannel ( v . read ( section ) , wbc ) ; \nreturn spi . readToByteChannel ( v , section , wbc ) ; \n} \n} \n"}
{"5789": "public class NetcdfFile { \nstatic protected String makeFullName ( CDMNode node , String reservedChars ) { \nGroup parent = node . getParentGroup ( ) ; \nif ( ( parent == null ) || parent . isRoot ( ) ) { \nif ( ! node . isMemberOfStructure ( ) ) return EscapeStrings . backslashEscape ( node . getShortName ( ) , reservedChars ) ; \n} \nStringBuilder sbuff = new StringBuilder ( ) ; \nappendGroupName ( sbuff , parent , reservedChars ) ; \nappendStructureName ( sbuff , node , reservedChars ) ; \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"5796": "public class Attribute { \nprivate static String forceValue ( int type , String value ) throws AttributeBadValueException { \ntry { \ndispatchCheckValue ( type , value ) ; \n} \ncatch ( AttributeBadValueException abe ) { \nif ( type == BYTE ) { \nshort val = Short . parseShort ( value ) ; \nif ( val > 255 ) { \nif ( val < - 128 ) throw new AttributeBadValueException ( \"Cannot convert to byte: \" + value ) ; \n} \nvalue = Integer . toString ( ( val & 0xFF ) ) ; \n} \n} \nreturn value ; \n} \n} \n"}
{"5801": "public class Attribute { \nprivate static final boolean checkFloat ( String s ) { \ntry { \nfloat val = Float . parseFloat ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkFloat() - string: '\" + s + \"'   value: \" + val ) ; \n} \nreturn true ; \n} \ncatch ( NumberFormatException e ) { \nif ( s . equalsIgnoreCase ( \"nan\" ) ) return true ; \nelse if ( s . equalsIgnoreCase ( \"inf\" ) ) return true ; \nreturn false ; \n} \n} \n} \n"}
{"5802": "public class Attribute { \nprivate static final boolean checkDouble ( String s ) { \ntry { \ndouble val = Double . parseDouble ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkDouble() - string: '\" + s + \"'   value: \" + val ) ; \n} \nreturn true ; \n} \ncatch ( NumberFormatException e ) { \nif ( s . equalsIgnoreCase ( \"nan\" ) ) return true ; \nelse if ( s . equalsIgnoreCase ( \"inf\" ) ) return true ; \nreturn false ; \n} \n} \n} \n"}
{"5807": "public class StringValidateEncodeUtils { \npublic static boolean validAlphanumericStringConstrainedSet ( String alphNumString , String [ ] constrainedSet , boolean ignoreCase ) { \nif ( alphNumString == null || constrainedSet == null ) return false ; \nelse if ( constrainedSet . length == 0 ) return false ; \nMatcher m = VALID_CHARACTERS_FOR_ALPHANUMERIC_STRING_PATTERN . matcher ( alphNumString ) ; \nif ( ! m . matches ( ) ) return false ; \nfor ( String s : constrainedSet ) { \nif ( ignoreCase ? alphNumString . equalsIgnoreCase ( s ) : alphNumString . equals ( s ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"5810": "public class GridDefRecord { \npublic final String getParam ( String key ) { \nString value = paramStr . get ( key ) ; \nif ( value == null ) { \nDouble result = paramDbl . get ( key ) ; \nif ( result != null ) { \nvalue = result . toString ( ) ; \n} \nelse { \nInteger intResult = paramInt . get ( key ) ; \nif ( intResult != null ) { \nvalue = intResult . toString ( ) ; \n} \n} \nif ( value != null ) { \nparamStr . put ( key , value ) ; \n} \n} \nif ( debug ) { \nif ( value == null ) { \nSystem . out . println ( key + \" value not found\" ) ; \n} \n} \nreturn value ; \n} \n} \n"}
{"5811": "public class GridDefRecord { \npublic static boolean compare ( GridDefRecord local , GridDefRecord other ) { \njava . util . Set < String > keys = local . getKeys ( ) ; \njava . util . Set < String > okeys = other . getKeys ( ) ; \nif ( keys . size ( ) != okeys . size ( ) ) return false ; \nfor ( String key : keys ) { \nif ( key . equals ( WIND_FLAG ) || key . equals ( RESOLUTION ) || key . equals ( VECTOR_COMPONENT_FLAG ) ) continue ; \nelse if ( key . equals ( GDS_KEY ) ) continue ; \nString val = local . getParam ( key ) ; \nString oval = other . getParam ( key ) ; \nif ( val . matches ( \"^[0-9]+\\\\.[0-9]*\" ) ) { \ndouble d = local . getDouble ( key ) ; \ndouble od = other . getDouble ( key ) ; \nif ( ! Misc . nearlyEquals ( d , od ) ) return false ; \n} \nelse if ( val . matches ( \"^[0-9]+\" ) ) { \nif ( ! val . equals ( oval ) ) return false ; \n} \nelse { \nif ( ! val . equals ( oval ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5817": "public class TdsConfigMapper { \nprivate static String getValueFromThreddsConfig ( String key , String alternateKey , String defaultValue ) { \nString value = ThreddsConfig . get ( key , null ) ; \nif ( value == null ) { \nif ( alternateKey != null ) value = ThreddsConfig . get ( alternateKey , null ) ; \n} \nif ( value == null ) value = defaultValue ; \nreturn value ; \n} \n} \n"}
{"5845": "public class CoverageRenderer { \nprivate void setColorScaleParams ( ) { \nif ( dataMinMaxType == ColorScale . MinMaxType . hold ) { \nif ( ! isNewField ) return ; \n} \nisNewField = false ; \nGeoReferencedArray dataArr = readHSlice ( wantLevel , wantTime , wantEnsemble , wantRunTime ) ; \nif ( dataArr != null ) { \nMAMath . MinMax minmax = MAMath . getMinMaxSkipMissingData ( dataArr . getData ( ) , dataState . grid ) ; \ncolorScale . setMinMax ( minmax . min , minmax . max ) ; \ncolorScale . setGeoGrid ( dataState . grid ) ; \n} \n} \n} \n"}
{"5846": "public class CoverageRenderer { \npublic void renderPlanView ( java . awt . Graphics2D g , AffineTransform dFromN ) { \nif ( ( dataState . grid == null ) || ( colorScale == null ) ) return ; \nelse if ( drawProjection == null ) return ; \nif ( ! drawGrid ) { \nif ( ! drawContours ) return ; \n} \ng . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_OFF ) ; \ndataH = readHSlice ( wantLevel , wantTime , wantEnsemble , wantRunTime ) ; \nif ( dataH == null ) return ; \nsetColorScaleParams ( ) ; \nif ( drawGrid ) drawGridHoriz ( g , dataH ) ; \nif ( drawGridLines ) drawGridLines ( g , dataH ) ; \nif ( drawBB ) drawGridBB ( g , this . dataState . coverageDataset . getLatlonBoundingBox ( ) ) ; \n} \n} \n"}
{"5854": "public class CoreSocketFactory { \npublic Socket connect ( Properties props , String socketPathFormat ) throws IOException { \nfinal String csqlInstanceName = props . getProperty ( CLOUD_SQL_INSTANCE_PROPERTY ) ; \nfinal List < String > ipTypes = listIpTypes ( props . getProperty ( \"ipTypes\" , DEFAULT_IP_TYPES ) ) ; \nfinal boolean forceUnixSocket = System . getenv ( \"CLOUD_SQL_FORCE_UNIX_SOCKET\" ) != null ; \nPreconditions . checkArgument ( csqlInstanceName != null , \"cloudSqlInstance property not set. Please specify this property in the JDBC URL or the \" + \"connection Properties with value in form \\\"project:region:instance\\\"\" ) ; \nif ( forceUnixSocket ) { \nlogger . info ( String . format ( \"Connecting to Cloud SQL instance [%s] via unix socket.\" , csqlInstanceName ) ) ; \nUnixSocketAddress socketAddress = new UnixSocketAddress ( new File ( String . format ( socketPathFormat , csqlInstanceName ) ) ) ; \nreturn UnixSocketChannel . open ( socketAddress ) . socket ( ) ; \n} \nelse if ( runningOnGaeStandard ( ) ) { \nlogger . info ( String . format ( \"Connecting to Cloud SQL instance [%s] via unix socket.\" , csqlInstanceName ) ) ; \nUnixSocketAddress socketAddress = new UnixSocketAddress ( new File ( String . format ( socketPathFormat , csqlInstanceName ) ) ) ; \nreturn UnixSocketChannel . open ( socketAddress ) . socket ( ) ; \n} \nlogger . info ( String . format ( \"Connecting to Cloud SQL instance [%s] via SSL socket.\" , csqlInstanceName ) ) ; \nreturn getInstance ( ) . createSslSocket ( csqlInstanceName , ipTypes ) ; \n} \n} \n"}
{"5858": "public class InMemoryJavaCompiler { \npublic Map < String , Class < ? > > compileAll ( ) throws Exception { \nif ( sourceCodes . size ( ) == 0 ) { \nthrow new CompilationException ( \"No source code to compile\" ) ; \n} \nCollection < SourceCode > compilationUnits = sourceCodes . values ( ) ; \nCompiledCode [ ] code ; \ncode = new CompiledCode [ compilationUnits . size ( ) ] ; \nIterator < SourceCode > iter = compilationUnits . iterator ( ) ; \nfor ( int i = 0 ; \ni < code . length ; \ni ++ ) { \ncode [ i ] = new CompiledCode ( iter . next ( ) . getClassName ( ) ) ; \n} \nDiagnosticCollector < JavaFileObject > collector = new DiagnosticCollector < > ( ) ; \nExtendedStandardJavaFileManager fileManager = new ExtendedStandardJavaFileManager ( javac . getStandardFileManager ( null , null , null ) , classLoader ) ; \nJavaCompiler . CompilationTask task = javac . getTask ( null , fileManager , collector , options , null , compilationUnits ) ; \nboolean result = task . call ( ) ; \nif ( ! result ) { \nStringBuffer exceptionMsg = new StringBuffer ( ) ; \nexceptionMsg . append ( \"Unable to compile the source\" ) ; \nboolean hasWarnings = false ; \nboolean hasErrors = false ; \nfor ( Diagnostic < ? extends JavaFileObject > d : collector . getDiagnostics ( ) ) { \nswitch ( d . getKind ( ) ) { \ncase NOTE : case MANDATORY_WARNING : case WARNING : hasWarnings = true ; \nbreak ; \ncase OTHER : case ERROR : default : hasErrors = true ; \nbreak ; \n} \nexceptionMsg . append ( \"\\n\" ) . append ( \"[kind=\" ) . append ( d . getKind ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"line=\" ) . append ( d . getLineNumber ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"message=\" ) . append ( d . getMessage ( Locale . US ) ) . append ( \"]\" ) ; \n} \nif ( hasWarnings && ! ignoreWarnings ) { \nthrow new CompilationException ( exceptionMsg . toString ( ) ) ; \n} \nelse if ( hasErrors ) { \nthrow new CompilationException ( exceptionMsg . toString ( ) ) ; \n} \n} \nelse if ( collector . getDiagnostics ( ) . size ( ) > 0 ) { \nStringBuffer exceptionMsg = new StringBuffer ( ) ; \nexceptionMsg . append ( \"Unable to compile the source\" ) ; \nboolean hasWarnings = false ; \nboolean hasErrors = false ; \nfor ( Diagnostic < ? extends JavaFileObject > d : collector . getDiagnostics ( ) ) { \nswitch ( d . getKind ( ) ) { \ncase NOTE : case MANDATORY_WARNING : case WARNING : hasWarnings = true ; \nbreak ; \ncase OTHER : case ERROR : default : hasErrors = true ; \nbreak ; \n} \nexceptionMsg . append ( \"\\n\" ) . append ( \"[kind=\" ) . append ( d . getKind ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"line=\" ) . append ( d . getLineNumber ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"message=\" ) . append ( d . getMessage ( Locale . US ) ) . append ( \"]\" ) ; \n} \nif ( hasWarnings && ! ignoreWarnings || hasErrors ) { \nthrow new CompilationException ( exceptionMsg . toString ( ) ) ; \n} \n} \nMap < String , Class < ? > > classes = new HashMap < String , Class < ? > > ( ) ; \nfor ( String className : sourceCodes . keySet ( ) ) { \nclasses . put ( className , classLoader . loadClass ( className ) ) ; \n} \nreturn classes ; \n} \n} \n"}
{"5862": "public class GifDecoder { \nsynchronized Bitmap getNextFrame ( ) { \nif ( header . frameCount <= 0 ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) { \nLog . d ( TAG , \"unable to decode frame, frameCount=\" + header . frameCount + \" framePointer=\" + framePointer ) ; \n} \nstatus = STATUS_FORMAT_ERROR ; \n} \nelse if ( framePointer < 0 ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) { \nLog . d ( TAG , \"unable to decode frame, frameCount=\" + header . frameCount + \" framePointer=\" + framePointer ) ; \n} \nstatus = STATUS_FORMAT_ERROR ; \n} \nif ( status == STATUS_FORMAT_ERROR ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) { \nLog . d ( TAG , \"Unable to decode frame, status=\" + status ) ; \n} \nreturn null ; \n} \nelse if ( status == STATUS_OPEN_ERROR ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) { \nLog . d ( TAG , \"Unable to decode frame, status=\" + status ) ; \n} \nreturn null ; \n} \nstatus = STATUS_OK ; \nGifFrame currentFrame = header . frames . get ( framePointer ) ; \nGifFrame previousFrame = null ; \nint previousIndex = framePointer - 1 ; \nif ( previousIndex >= 0 ) { \npreviousFrame = header . frames . get ( previousIndex ) ; \n} \nact = currentFrame . lct != null ? currentFrame . lct : header . gct ; \nif ( act == null ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) { \nLog . d ( TAG , \"No Valid Color Table for frame #\" + framePointer ) ; \n} \nstatus = STATUS_FORMAT_ERROR ; \nreturn null ; \n} \nif ( currentFrame . transparency ) { \nSystem . arraycopy ( act , 0 , pct , 0 , act . length ) ; \nact = pct ; \nact [ currentFrame . transIndex ] = 0 ; \n} \nreturn setPixels ( currentFrame , previousFrame ) ; \n} \n} \n"}
{"5871": "public class DataFxCountrySelector { \nvoid loadSubdivisions ( ) { \nInputStream iso3166_2Resource = this . getClass ( ) . getResourceAsStream ( ISO_3166_2_LOCATION ) ; \nif ( iso3166_2Resource == null ) { \nthrow new IllegalStateException ( \"Can't find the list of subdivisions! Expected location was:\" + ISO_3166_2_LOCATION ) ; \n} \nXmlConverter < ISO3166_2_CountryEntity > converter = new XmlConverter < > ( \"iso_3166_country\" , ISO3166_2_CountryEntity . class ) ; \nObservableList < ISO3166_2_CountryEntity > subdivisionsEntities = FXCollections . observableArrayList ( ) ; \ntry { \nDataReader < ISO3166_2_CountryEntity > dataSource = new InputStreamSource < > ( iso3166_2Resource , converter ) ; \nListDataProvider < ISO3166_2_CountryEntity > listDataProvider = new ListDataProvider < > ( dataSource ) ; \nlistDataProvider . setResultObservableList ( subdivisionsEntities ) ; \nWorker < ObservableList < ISO3166_2_CountryEntity > > worker = listDataProvider . retrieve ( ) ; \nworker . stateProperty ( ) . addListener ( obs -> { \nif ( worker . getState ( ) == Worker . State . SUCCEEDED ) { \nsubdivisionsEntities . forEach ( entity -> { \nif ( entity . subsets != null ) { \nif ( ! entity . subsets . isEmpty ( ) ) { \nCountry country = findCountryByCode ( entity . code ) ; \nif ( ! countryCodeSubdivisionMap . containsKey ( country ) ) { \ncountryCodeSubdivisionMap . put ( country , new ArrayList < > ( ) ) ; \n} \nList < Subdivision > subdivisionList = countryCodeSubdivisionMap . get ( country ) ; \nentity . subsets . forEach ( subset -> { \nsubset . entryList . forEach ( entry -> { \nsubdivisionList . add ( new Subdivision ( entry . name , entry . code , country ) ) ; \n} \n) ; \n} \n) ; \nString subdivisionName = entity . subsets . stream ( ) . map ( subset -> subset . subdivisionType ) . collect ( Collectors . joining ( \"/\" ) ) ; \ncountryCodeSubdivisionNameMap . put ( country , subdivisionName ) ; \n} \n} \n} \n) ; \ninProgress . set ( false ) ; \n} \n} \n) ; \n} \ncatch ( IOException e ) { \nLOG . error ( \"A problem was detected while loading the XML file with the available subdivisions.\" , e ) ; \n} \n} \n} \n"}
{"5884": "public class CoverageDataPng { \npublic static void validateImageType ( PngReader reader ) { \nif ( reader == null ) { \nthrow new GeoPackageException ( \"The image is null\" ) ; \n} \nif ( reader . imgInfo . channels != 1 ) { \nthrow new GeoPackageException ( \"The coverage data tile is expected to be a single channel 16 bit unsigned short, channels: \" + reader . imgInfo . channels + \", bits: \" + reader . imgInfo . bitDepth ) ; \n} \nelse if ( reader . imgInfo . bitDepth != 16 ) { \nthrow new GeoPackageException ( \"The coverage data tile is expected to be a single channel 16 bit unsigned short, channels: \" + reader . imgInfo . channels + \", bits: \" + reader . imgInfo . bitDepth ) ; \n} \n} \n} \n"}
{"5899": "public class CoverageData { \nprivate CoverageDataTileMatrixResults getResultsZoom ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { \nCoverageDataTileMatrixResults results = null ; \nif ( zoomIn ) { \nif ( zoomInBeforeOut ) { \nresults = getResultsZoomIn ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; \n} \n} \nif ( results == null ) { \nif ( zoomOut ) { \nresults = getResultsZoomOut ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; \n} \n} \nif ( results == null && zoomIn ) { \nif ( ! zoomInBeforeOut ) { \nresults = getResultsZoomIn ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; \n} \n} \nreturn results ; \n} \n} \n"}
{"5905": "public class Icons { \npublic IconRow getIcon ( GeometryType geometryType ) { \nIconRow iconRow = null ; \nif ( geometryType != null ) { \nif ( ! icons . isEmpty ( ) ) { \nList < GeometryType > geometryTypes = GeometryUtils . parentHierarchy ( geometryType ) ; \ngeometryTypes . add ( 0 , geometryType ) ; \nfor ( GeometryType type : geometryTypes ) { \niconRow = icons . get ( type ) ; \nif ( iconRow != null ) { \nbreak ; \n} \n} \n} \n} \nif ( iconRow == null ) { \niconRow = defaultIcon ; \n} \nif ( iconRow == null && geometryType == null ) { \nif ( icons . size ( ) == 1 ) { \niconRow = icons . values ( ) . iterator ( ) . next ( ) ; \n} \n} \nreturn iconRow ; \n} \n} \n"}
{"5925": "public class ManualFeatureQuery { \npublic ManualFeatureQueryResults query ( double minX , double minY , double maxX , double maxY ) { \nList < Long > featureIds = new ArrayList < > ( ) ; \nlong offset = 0 ; \nboolean hasResults = true ; \nminX -= tolerance ; \nmaxX += tolerance ; \nminY -= tolerance ; \nmaxY += tolerance ; \nwhile ( hasResults ) { \nhasResults = false ; \nFeatureCursor featureCursor = featureDao . queryForChunk ( chunkLimit , offset ) ; \ntry { \nwhile ( featureCursor . moveToNext ( ) ) { \nhasResults = true ; \nFeatureRow featureRow = featureCursor . getRow ( ) ; \nGeometryEnvelope envelope = featureRow . getGeometryEnvelope ( ) ; \nif ( envelope != null ) { \ndouble minXMax = Math . max ( minX , envelope . getMinX ( ) ) ; \ndouble maxXMin = Math . min ( maxX , envelope . getMaxX ( ) ) ; \ndouble minYMax = Math . max ( minY , envelope . getMinY ( ) ) ; \ndouble maxYMin = Math . min ( maxY , envelope . getMaxY ( ) ) ; \nif ( minXMax <= maxXMin ) { \nif ( minYMax <= maxYMin ) { \nfeatureIds . add ( featureRow . getId ( ) ) ; \n} \n} \n} \n} \n} \nfinally { \nfeatureCursor . close ( ) ; \n} \noffset += chunkLimit ; \n} \nManualFeatureQueryResults results = new ManualFeatureQueryResults ( featureDao , featureIds ) ; \nreturn results ; \n} \n} \n"}
{"5941": "public class TileDao { \npublic TileGrid queryForTileGrid ( long zoomLevel ) { \nString where = buildWhere ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel ) ; \nString [ ] whereArgs = buildWhereArgs ( new Object [ ] { \nzoomLevel } \n) ; \nInteger minX = min ( TileTable . COLUMN_TILE_COLUMN , where , whereArgs ) ; \nInteger maxX = max ( TileTable . COLUMN_TILE_COLUMN , where , whereArgs ) ; \nInteger minY = min ( TileTable . COLUMN_TILE_ROW , where , whereArgs ) ; \nInteger maxY = max ( TileTable . COLUMN_TILE_ROW , where , whereArgs ) ; \nTileGrid tileGrid = null ; \nif ( minX != null && maxX != null && minY != null ) { \nif ( maxY != null ) { \ntileGrid = new TileGrid ( minX , minY , maxX , maxY ) ; \n} \n} \nreturn tileGrid ; \n} \n} \n"}
{"5944": "public class TileDao { \npublic boolean isGoogleTiles ( ) { \nBoundingBox boundingBox = tileMatrixSet . getBoundingBox ( ) ; \nBoundingBox wgs84BoundingBox = boundingBox . transform ( projection . getTransformation ( ProjectionConstants . EPSG_WORLD_GEODETIC_SYSTEM ) ) ; \nboolean googleTiles = false ; \nif ( wgs84BoundingBox . getMinLatitude ( ) <= ProjectionConstants . WEB_MERCATOR_MIN_LAT_RANGE && wgs84BoundingBox . getMaxLatitude ( ) >= ProjectionConstants . WEB_MERCATOR_MAX_LAT_RANGE && wgs84BoundingBox . getMinLongitude ( ) <= - ProjectionConstants . WGS84_HALF_WORLD_LON_WIDTH ) { \nif ( wgs84BoundingBox . getMaxLongitude ( ) >= ProjectionConstants . WGS84_HALF_WORLD_LON_WIDTH ) { \ngoogleTiles = true ; \nfor ( TileMatrix tileMatrix : tileMatrices ) { \nlong zoomLevel = tileMatrix . getZoomLevel ( ) ; \nlong tilesPerSide = TileBoundingBoxUtils . tilesPerSide ( ( int ) zoomLevel ) ; \nif ( tileMatrix . getMatrixWidth ( ) != tilesPerSide ) { \ngoogleTiles = false ; \nbreak ; \n} \nelse if ( tileMatrix . getMatrixHeight ( ) != tilesPerSide ) { \ngoogleTiles = false ; \nbreak ; \n} \n} \n} \n} \nreturn googleTiles ; \n} \n} \n"}
{"5947": "public class CoverageDataTiff { \npublic static void validateImageType ( FileDirectory directory ) { \nif ( directory == null ) { \nthrow new GeoPackageException ( \"The image is null\" ) ; \n} \nint samplesPerPixel = directory . getSamplesPerPixel ( ) ; \nInteger bitsPerSample = null ; \nif ( directory . getBitsPerSample ( ) != null ) { \nif ( ! directory . getBitsPerSample ( ) . isEmpty ( ) ) { \nbitsPerSample = directory . getBitsPerSample ( ) . get ( 0 ) ; \n} \n} \nInteger sampleFormat = null ; \nif ( directory . getSampleFormat ( ) != null ) { \nif ( ! directory . getSampleFormat ( ) . isEmpty ( ) ) { \nsampleFormat = directory . getSampleFormat ( ) . get ( 0 ) ; \n} \n} \nif ( samplesPerPixel != SAMPLES_PER_PIXEL || bitsPerSample == null || bitsPerSample != BITS_PER_SAMPLE || sampleFormat == null ) { \nthrow new GeoPackageException ( \"The coverage data tile is expected to be a single sample 32 bit float. Samples Per Pixel: \" + samplesPerPixel + \", Bits Per Sample: \" + bitsPerSample + \", Sample Format: \" + sampleFormat ) ; \n} \nelse if ( sampleFormat != TiffConstants . SAMPLE_FORMAT_FLOAT ) { \nthrow new GeoPackageException ( \"The coverage data tile is expected to be a single sample 32 bit float. Samples Per Pixel: \" + samplesPerPixel + \", Bits Per Sample: \" + bitsPerSample + \", Sample Format: \" + sampleFormat ) ; \n} \n} \n} \n"}
{"5951": "public class UserCursor { \nprivate TRow getCurrentRow ( ) { \nTRow row = null ; \nif ( table != null ) { \nint [ ] columnTypes = new int [ table . columnCount ( ) ] ; \nObject [ ] values = new Object [ table . columnCount ( ) ] ; \nboolean valid = true ; \nfor ( TColumn column : table . getColumns ( ) ) { \nint index = column . getIndex ( ) ; \nint columnType = getType ( index ) ; \nif ( column . isPrimaryKey ( ) ) { \nif ( columnType == FIELD_TYPE_NULL ) { \nvalid = false ; \n} \n} \ncolumnTypes [ index ] = columnType ; \nvalues [ index ] = getValue ( column ) ; \n} \nrow = getRow ( columnTypes , values ) ; \nif ( ! valid ) { \ninvalidPositions . add ( getPosition ( ) ) ; \nrow . setValid ( false ) ; \n} \n} \nreturn row ; \n} \n} \n"}
{"5952": "public class UserCursor { \nprivate boolean moveToNextInvalid ( ) { \nboolean hasNext = false ; \nif ( invalidCursor == null && dao != null ) { \nif ( hasInvalidPositions ( ) ) { \nsuper . close ( ) ; \nList < TColumn > blobColumns = dao . getTable ( ) . columnsOfType ( GeoPackageDataType . BLOB ) ; \nString [ ] columnsAs = dao . buildColumnsAsNull ( blobColumns ) ; \nquery . set ( UserQueryParamType . COLUMNS_AS , columnsAs ) ; \nUserCursor < TColumn , TTable , TRow > requeryCursor = dao . query ( query ) ; \ninvalidCursor = createInvalidCursor ( dao , requeryCursor , getInvalidPositions ( ) , blobColumns ) ; \n} \n} \nif ( invalidCursor != null ) { \nhasNext = invalidCursor . moveToNext ( ) ; \n} \nreturn hasNext ; \n} \n} \n"}
{"5965": "public class GeoPackageManagerImpl { \nprivate void addInternalDatabases ( Collection < String > databases ) { \nString [ ] databaseArray = context . databaseList ( ) ; \nfor ( String database : databaseArray ) { \nif ( ! isTemporary ( database ) ) { \nif ( ! database . equalsIgnoreCase ( GeoPackageMetadataDb . DATABASE_NAME ) ) { \ndatabases . add ( database ) ; \n} \n} \n} \n} \n} \n"}
{"5967": "public class GeoPackageManagerImpl { \nprivate boolean importGeoPackage ( String database , boolean override , InputStream geoPackageStream , GeoPackageProgress progress ) { \ntry { \nif ( exists ( database ) ) { \nif ( override ) { \nif ( ! delete ( database ) ) { \nthrow new GeoPackageException ( \"Failed to delete existing database: \" + database ) ; \n} \n} \nelse { \nthrow new GeoPackageException ( \"GeoPackage database already exists: \" + database ) ; \n} \n} \nFile newDbFile = context . getDatabasePath ( database ) ; \ntry { \nSQLiteDatabase db = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null ) ; \ndb . close ( ) ; \nGeoPackageIOUtils . copyStream ( geoPackageStream , newDbFile , progress ) ; \n} \ncatch ( IOException e ) { \nthrow new GeoPackageException ( \"Failed to import GeoPackage database: \" + database , e ) ; \n} \n} \nfinally { \nGeoPackageIOUtils . closeQuietly ( geoPackageStream ) ; \n} \nif ( progress == null ) { \ntry { \nSQLiteDatabase sqlite = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null , new DatabaseErrorHandler ( ) { \n@ Override public void onCorruption ( SQLiteDatabase dbObj ) { \n} \n} \n) ; \nvalidateDatabaseAndClose ( sqlite , importHeaderValidation , importIntegrityValidation ) ; \nGeoPackageMetadataDb metadataDb = new GeoPackageMetadataDb ( context ) ; \nmetadataDb . open ( ) ; \ntry { \nGeoPackageMetadataDataSource dataSource = new GeoPackageMetadataDataSource ( metadataDb ) ; \nGeoPackageMetadata metadata = new GeoPackageMetadata ( ) ; \nmetadata . setName ( database ) ; \ndataSource . create ( metadata ) ; \n} \nfinally { \nmetadataDb . close ( ) ; \n} \n} \ncatch ( Exception e ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file\" , e ) ; \n} \nGeoPackage geoPackage = open ( database , false ) ; \nif ( geoPackage != null ) { \ntry { \nif ( ! geoPackage . getSpatialReferenceSystemDao ( ) . isTableExists ( ) ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file. Does not contain required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; \n} \nelse if ( ! geoPackage . getContentsDao ( ) . isTableExists ( ) ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file. Does not contain required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; \n} \n} \ncatch ( SQLException e ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file. Could not verify existence of required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; \n} \nfinally { \ngeoPackage . close ( ) ; \n} \n} \nelse { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Unable to open GeoPackage database. Database: \" + database ) ; \n} \n} \nelse if ( progress . isActive ( ) ) { \ntry { \nSQLiteDatabase sqlite = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null , new DatabaseErrorHandler ( ) { \n@ Override public void onCorruption ( SQLiteDatabase dbObj ) { \n} \n} \n) ; \nvalidateDatabaseAndClose ( sqlite , importHeaderValidation , importIntegrityValidation ) ; \nGeoPackageMetadataDb metadataDb = new GeoPackageMetadataDb ( context ) ; \nmetadataDb . open ( ) ; \ntry { \nGeoPackageMetadataDataSource dataSource = new GeoPackageMetadataDataSource ( metadataDb ) ; \nGeoPackageMetadata metadata = new GeoPackageMetadata ( ) ; \nmetadata . setName ( database ) ; \ndataSource . create ( metadata ) ; \n} \nfinally { \nmetadataDb . close ( ) ; \n} \n} \ncatch ( Exception e ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file\" , e ) ; \n} \nGeoPackage geoPackage = open ( database , false ) ; \nif ( geoPackage != null ) { \ntry { \nif ( ! geoPackage . getSpatialReferenceSystemDao ( ) . isTableExists ( ) || ! geoPackage . getContentsDao ( ) . isTableExists ( ) ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file. Does not contain required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; \n} \n} \ncatch ( SQLException e ) { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Invalid GeoPackage database file. Could not verify existence of required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; \n} \nfinally { \ngeoPackage . close ( ) ; \n} \n} \nelse { \ndelete ( database ) ; \nthrow new GeoPackageException ( \"Unable to open GeoPackage database. Database: \" + database ) ; \n} \n} \nreturn exists ( database ) ; \n} \n} \n"}
{"5978": "public class NumberFeaturesTile { \nprivate Bitmap drawTile ( int tileWidth , int tileHeight , String text ) { \nBitmap bitmap = Bitmap . createBitmap ( tileWidth , tileHeight , Bitmap . Config . ARGB_8888 ) ; \nCanvas canvas = new Canvas ( bitmap ) ; \nif ( tileFillPaint != null ) { \ncanvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileFillPaint ) ; \n} \nif ( tileBorderPaint != null ) { \ncanvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileBorderPaint ) ; \n} \nRect textBounds = new Rect ( ) ; \ntextPaint . getTextBounds ( text , 0 , text . length ( ) , textBounds ) ; \nint centerX = ( int ) ( bitmap . getWidth ( ) / 2.0f ) ; \nint centerY = ( int ) ( bitmap . getHeight ( ) / 2.0f ) ; \nif ( circlePaint != null ) { \nint diameter = Math . max ( textBounds . width ( ) , textBounds . height ( ) ) ; \nfloat radius = diameter / 2.0f ; \nradius = radius + ( diameter * circlePaddingPercentage ) ; \nif ( circleFillPaint != null ) { \ncanvas . drawCircle ( centerX , centerY , radius , circleFillPaint ) ; \n} \nif ( circlePaint != null ) { \ncanvas . drawCircle ( centerX , centerY , radius , circlePaint ) ; \n} \n} \nelse if ( circleFillPaint != null ) { \nint diameter = Math . max ( textBounds . width ( ) , textBounds . height ( ) ) ; \nfloat radius = diameter / 2.0f ; \nradius = radius + ( diameter * circlePaddingPercentage ) ; \nif ( circleFillPaint != null ) { \ncanvas . drawCircle ( centerX , centerY , radius , circleFillPaint ) ; \n} \nif ( circlePaint != null ) { \ncanvas . drawCircle ( centerX , centerY , radius , circlePaint ) ; \n} \n} \ncanvas . drawText ( text , centerX - textBounds . exactCenterX ( ) , centerY - textBounds . exactCenterY ( ) , textPaint ) ; \nreturn bitmap ; \n} \n} \n"}
{"5993": "public class FeatureTiles { \npublic void calculateDrawOverlap ( ) { \nif ( pointIcon != null ) { \nheightOverlap = this . density * pointIcon . getHeight ( ) ; \nwidthOverlap = this . density * pointIcon . getWidth ( ) ; \n} \nelse { \nheightOverlap = this . density * pointRadius ; \nwidthOverlap = this . density * pointRadius ; \n} \nfloat linePaintHalfStroke = this . density * lineStrokeWidth / 2.0f ; \nheightOverlap = Math . max ( heightOverlap , linePaintHalfStroke ) ; \nwidthOverlap = Math . max ( widthOverlap , linePaintHalfStroke ) ; \nfloat polygonPaintHalfStroke = this . density * polygonStrokeWidth / 2.0f ; \nheightOverlap = Math . max ( heightOverlap , polygonPaintHalfStroke ) ; \nwidthOverlap = Math . max ( widthOverlap , polygonPaintHalfStroke ) ; \nif ( featureTableStyles != null ) { \nif ( featureTableStyles . has ( ) ) { \nSet < Long > styleRowIds = new HashSet < > ( ) ; \nList < Long > tableStyleIds = featureTableStyles . getAllTableStyleIds ( ) ; \nif ( tableStyleIds != null ) { \nstyleRowIds . addAll ( tableStyleIds ) ; \n} \nList < Long > styleIds = featureTableStyles . getAllStyleIds ( ) ; \nif ( styleIds != null ) { \nstyleRowIds . addAll ( styleIds ) ; \n} \nStyleDao styleDao = featureTableStyles . getStyleDao ( ) ; \nfor ( long styleRowId : styleRowIds ) { \nStyleRow styleRow = styleDao . getRow ( styleDao . queryForIdRow ( styleRowId ) ) ; \nfloat styleHalfWidth = this . density * ( float ) ( styleRow . getWidthOrDefault ( ) / 2.0f ) ; \nwidthOverlap = Math . max ( widthOverlap , styleHalfWidth ) ; \nheightOverlap = Math . max ( heightOverlap , styleHalfWidth ) ; \n} \nSet < Long > iconRowIds = new HashSet < > ( ) ; \nList < Long > tableIconIds = featureTableStyles . getAllTableIconIds ( ) ; \nif ( tableIconIds != null ) { \niconRowIds . addAll ( tableIconIds ) ; \n} \nList < Long > iconIds = featureTableStyles . getAllIconIds ( ) ; \nif ( iconIds != null ) { \niconRowIds . addAll ( iconIds ) ; \n} \nIconDao iconDao = featureTableStyles . getIconDao ( ) ; \nfor ( long iconRowId : iconRowIds ) { \nIconRow iconRow = iconDao . getRow ( iconDao . queryForIdRow ( iconRowId ) ) ; \ndouble [ ] iconDimensions = iconRow . getDerivedDimensions ( ) ; \nfloat iconWidth = this . density * ( float ) Math . ceil ( iconDimensions [ 0 ] ) ; \nfloat iconHeight = this . density * ( float ) Math . ceil ( iconDimensions [ 1 ] ) ; \nwidthOverlap = Math . max ( widthOverlap , iconWidth ) ; \nheightOverlap = Math . max ( heightOverlap , iconHeight ) ; \n} \n} \n} \n} \n} \n"}
{"6005": "public class FeatureTiles { \nprotected List < Point > simplifyPoints ( double simplifyTolerance , List < Point > points ) { \nList < Point > simplifiedPoints = null ; \nif ( simplifyGeometries ) { \nif ( projection != null ) { \nif ( ! projection . isUnit ( Units . METRES ) ) { \nProjectionTransform toWebMercator = projection . getTransformation ( WEB_MERCATOR_PROJECTION ) ; \npoints = toWebMercator . transform ( points ) ; \n} \n} \nsimplifiedPoints = GeometryUtils . simplifyPoints ( points , simplifyTolerance ) ; \nif ( projection != null ) { \nif ( ! projection . isUnit ( Units . METRES ) ) { \nProjectionTransform fromWebMercator = WEB_MERCATOR_PROJECTION . getTransformation ( projection ) ; \nsimplifiedPoints = fromWebMercator . transform ( simplifiedPoints ) ; \n} \n} \n} \nelse { \nsimplifiedPoints = points ; \n} \nreturn simplifiedPoints ; \n} \n} \n"}
{"6009": "public class FeatureTiles { \nprotected Paint getPolygonFillPaint ( FeatureStyle featureStyle ) { \nPaint paint = null ; \nboolean hasStyleColor = false ; \nif ( featureStyle != null ) { \nStyleRow style = featureStyle . getStyle ( ) ; \nif ( style != null ) { \nif ( style . hasFillColor ( ) ) { \npaint = getStylePaint ( style , FeatureDrawType . FILL ) ; \n} \nelse { \nhasStyleColor = style . hasColor ( ) ; \n} \n} \n} \nif ( paint == null && ! hasStyleColor ) { \nif ( fillPolygon ) { \npaint = polygonFillPaint ; \n} \n} \nreturn paint ; \n} \n} \n"}
{"6010": "public class FeatureTiles { \nprivate Paint getFeatureStylePaint ( FeatureStyle featureStyle , FeatureDrawType drawType ) { \nPaint paint = null ; \nif ( featureStyle != null ) { \nStyleRow style = featureStyle . getStyle ( ) ; \nif ( style != null ) { \nif ( style . hasColor ( ) ) { \npaint = getStylePaint ( style , drawType ) ; \n} \n} \n} \nreturn paint ; \n} \n} \n"}
{"6015": "public class IconCache { \npublic static Bitmap createIcon ( IconRow icon , float density , IconCache iconCache ) { \nBitmap iconImage = null ; \nif ( icon != null ) { \nif ( iconCache != null ) { \niconImage = iconCache . get ( icon . getId ( ) ) ; \n} \nif ( iconImage == null ) { \nBitmapFactory . Options options = icon . getDataBounds ( ) ; \nint dataWidth = options . outWidth ; \nint dataHeight = options . outHeight ; \ndouble styleWidth = dataWidth ; \ndouble styleHeight = dataHeight ; \ndouble widthDensity = DisplayMetrics . DENSITY_DEFAULT ; \ndouble heightDensity = DisplayMetrics . DENSITY_DEFAULT ; \nif ( icon . getWidth ( ) != null ) { \nstyleWidth = icon . getWidth ( ) ; \ndouble widthRatio = dataWidth / styleWidth ; \nwidthDensity *= widthRatio ; \nif ( icon . getHeight ( ) == null ) { \nheightDensity = widthDensity ; \n} \n} \nif ( icon . getHeight ( ) != null ) { \nstyleHeight = icon . getHeight ( ) ; \ndouble heightRatio = dataHeight / styleHeight ; \nheightDensity *= heightRatio ; \nif ( icon . getWidth ( ) == null ) { \nwidthDensity = heightDensity ; \n} \n} \noptions = new BitmapFactory . Options ( ) ; \noptions . inDensity = ( int ) ( Math . min ( widthDensity , heightDensity ) + 0.5f ) ; \noptions . inTargetDensity = ( int ) ( DisplayMetrics . DENSITY_DEFAULT * density + 0.5f ) ; \niconImage = icon . getDataBitmap ( options ) ; \nif ( widthDensity != heightDensity ) { \nint width = ( int ) ( styleWidth * density + 0.5f ) ; \nint height = ( int ) ( styleHeight * density + 0.5f ) ; \nif ( width != iconImage . getWidth ( ) ) { \nBitmap scaledBitmap = Bitmap . createScaledBitmap ( iconImage , width , height , false ) ; \niconImage . recycle ( ) ; \niconImage = scaledBitmap ; \n} \nelse if ( height != iconImage . getHeight ( ) ) { \nBitmap scaledBitmap = Bitmap . createScaledBitmap ( iconImage , width , height , false ) ; \niconImage . recycle ( ) ; \niconImage = scaledBitmap ; \n} \n} \nif ( iconCache != null ) { \niconCache . put ( icon . getId ( ) , iconImage ) ; \n} \n} \n} \nreturn iconImage ; \n} \n} \n"}
{"6025": "public class FeatureStyleExtension { \npublic FeatureStyles getTableFeatureStyles ( String featureTable ) { \nFeatureStyles featureStyles = null ; \nLong id = contentsId . getId ( featureTable ) ; \nif ( id != null ) { \nStyles styles = getTableStyles ( featureTable , id ) ; \nIcons icons = getTableIcons ( featureTable , id ) ; \nif ( styles != null ) { \nfeatureStyles = new FeatureStyles ( styles , icons ) ; \n} \nelse if ( icons != null ) { \nfeatureStyles = new FeatureStyles ( styles , icons ) ; \n} \n} \nreturn featureStyles ; \n} \n} \n"}
{"6031": "public class FeatureStyleExtension { \npublic FeatureStyles getFeatureStyles ( String featureTable , long featureId ) { \nStyles styles = getStyles ( featureTable , featureId ) ; \nIcons icons = getIcons ( featureTable , featureId ) ; \nFeatureStyles featureStyles = null ; \nif ( styles != null ) { \nfeatureStyles = new FeatureStyles ( styles , icons ) ; \n} \nelse if ( icons != null ) { \nfeatureStyles = new FeatureStyles ( styles , icons ) ; \n} \nreturn featureStyles ; \n} \n} \n"}
{"6078": "public class IconRow { \npublic void setWidth ( Double width ) { \nif ( width != null ) { \nif ( width < 0.0 ) { \nthrow new GeoPackageException ( \"Width must be greater than or equal to 0.0, invalid value: \" + width ) ; \n} \n} \nsetValue ( getWidthColumnIndex ( ) , width ) ; \n} \n} \n"}
{"6079": "public class IconRow { \npublic void setHeight ( Double height ) { \nif ( height != null ) { \nif ( height < 0.0 ) { \nthrow new GeoPackageException ( \"Height must be greater than or equal to 0.0, invalid value: \" + height ) ; \n} \n} \nsetValue ( getHeightColumnIndex ( ) , height ) ; \n} \n} \n"}
{"6080": "public class IconRow { \npublic double [ ] getDerivedDimensions ( ) { \nDouble width = getWidth ( ) ; \nDouble height = getHeight ( ) ; \nif ( width == null ) { \nBitmapFactory . Options options = getDataBounds ( ) ; \nint dataWidth = options . outWidth ; \nint dataHeight = options . outHeight ; \nif ( width == null ) { \nwidth = ( double ) dataWidth ; \nif ( height != null ) { \nwidth *= ( height / dataHeight ) ; \n} \n} \nif ( height == null ) { \nheight = ( double ) dataHeight ; \nif ( width != null ) { \nheight *= ( width / dataWidth ) ; \n} \n} \n} \nelse if ( height == null ) { \nBitmapFactory . Options options = getDataBounds ( ) ; \nint dataWidth = options . outWidth ; \nint dataHeight = options . outHeight ; \nif ( width == null ) { \nwidth = ( double ) dataWidth ; \nif ( height != null ) { \nwidth *= ( height / dataHeight ) ; \n} \n} \nif ( height == null ) { \nheight = ( double ) dataHeight ; \nif ( width != null ) { \nheight *= ( width / dataWidth ) ; \n} \n} \n} \nreturn new double [ ] { \nwidth , height } \n; \n} \n} \n"}
{"6086": "public class StyleRow { \nprivate Color createColor ( String hexColor , Double opacity ) { \nColor color = null ; \nif ( hexColor != null ) { \ncolor = new Color ( ) ; \nif ( hexColor != null ) { \ncolor . setColor ( hexColor ) ; \n} \nif ( opacity != null ) { \ncolor . setOpacity ( opacity . floatValue ( ) ) ; \n} \n} \nelse if ( opacity != null ) { \ncolor = new Color ( ) ; \nif ( hexColor != null ) { \ncolor . setColor ( hexColor ) ; \n} \nif ( opacity != null ) { \ncolor . setOpacity ( opacity . floatValue ( ) ) ; \n} \n} \nreturn color ; \n} \n} \n"}
{"6155": "public class ParallaxLayoutInflater { \nprivate View createCustomViewInternal ( View parent , View view , String name , Context context , AttributeSet attrs ) { \nif ( view == null ) { \nif ( name . indexOf ( '.' ) > - 1 ) { \nif ( mConstructorArgs == null ) { \nmConstructorArgs = ReflectionUtils . getField ( LayoutInflater . class , \"mConstructorArgs\" ) ; \n} \nfinal Object [ ] mConstructorArgsArr = ( Object [ ] ) ReflectionUtils . getValue ( mConstructorArgs , this ) ; \nfinal Object lastContext = mConstructorArgsArr [ 0 ] ; \nmConstructorArgsArr [ 0 ] = parent != null ? parent . getContext ( ) : context ; \nReflectionUtils . setValue ( mConstructorArgs , this , mConstructorArgsArr ) ; \ntry { \nview = createView ( name , null , attrs ) ; \n} \ncatch ( ClassNotFoundException ignored ) { \n} \nfinally { \nmConstructorArgsArr [ 0 ] = lastContext ; \nReflectionUtils . setValue ( mConstructorArgs , this , mConstructorArgsArr ) ; \n} \n} \n} \nreturn view ; \n} \n} \n"}
{"6165": "public class InterpretationContext { \npublic void addSubstitutionProperty ( String key , String value ) { \nif ( key == null ) { \nreturn ; \n} \nelse if ( value == null ) { \nreturn ; \n} \nvalue = value . trim ( ) ; \npropertiesMap . put ( key , value ) ; \n} \n} \n"}
{"6177": "public class AndroidContextUtil { \npublic String getMountedExternalStorageDirectoryPath ( ) { \nString path = null ; \nString state = Environment . getExternalStorageState ( ) ; \nif ( state . equals ( Environment . MEDIA_MOUNTED ) ) { \npath = absPath ( Environment . getExternalStorageDirectory ( ) ) ; \n} \nelse if ( state . equals ( Environment . MEDIA_MOUNTED_READ_ONLY ) ) { \npath = absPath ( Environment . getExternalStorageDirectory ( ) ) ; \n} \nreturn path ; \n} \n} \n"}
{"6179": "public class FileAppender { \nprivate String getAbsoluteFilePath ( String filename ) { \nif ( EnvUtil . isAndroidOS ( ) ) { \nif ( ! new File ( filename ) . isAbsolute ( ) ) { \nString dataDir = context . getProperty ( CoreConstants . DATA_DIR_KEY ) ; \nfilename = FileUtil . prefixRelativePath ( dataDir , filename ) ; \n} \n} \nreturn filename ; \n} \n} \n"}
{"6183": "public class FilterAttachableImpl { \npublic FilterReply getFilterChainDecision ( E event ) { \nfinal Filter < E > [ ] filterArrray = filterList . asTypedArray ( ) ; \nfinal int len = filterArrray . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nfinal FilterReply r = filterArrray [ i ] . decide ( event ) ; \nif ( r == FilterReply . DENY ) { \nreturn r ; \n} \nelse if ( r == FilterReply . ACCEPT ) { \nreturn r ; \n} \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6187": "public class SSLContextFactoryBean { \nprivate String locationFromSystemProperty ( String name ) { \nString location = System . getProperty ( name ) ; \nif ( location != null ) { \nif ( ! location . startsWith ( \"file:\" ) ) { \nlocation = \"file:\" + location ; \n} \n} \nreturn location ; \n} \n} \n"}
{"6197": "public class FormatInfo { \npublic static FormatInfo valueOf ( String str ) throws IllegalArgumentException { \nif ( str == null ) { \nthrow new NullPointerException ( \"Argument cannot be null\" ) ; \n} \nFormatInfo fi = new FormatInfo ( ) ; \nint indexOfDot = str . indexOf ( '.' ) ; \nString minPart = null ; \nString maxPart = null ; \nif ( indexOfDot != - 1 ) { \nminPart = str . substring ( 0 , indexOfDot ) ; \nif ( indexOfDot + 1 == str . length ( ) ) { \nthrow new IllegalArgumentException ( \"Formatting string [\" + str + \"] should not end with '.'\" ) ; \n} \nelse { \nmaxPart = str . substring ( indexOfDot + 1 ) ; \n} \n} \nelse { \nminPart = str ; \n} \nif ( minPart != null ) { \nif ( minPart . length ( ) > 0 ) { \nint min = Integer . parseInt ( minPart ) ; \nif ( min >= 0 ) { \nfi . min = min ; \n} \nelse { \nfi . min = - min ; \nfi . leftPad = false ; \n} \n} \n} \nif ( maxPart != null ) { \nif ( maxPart . length ( ) > 0 ) { \nint max = Integer . parseInt ( maxPart ) ; \nif ( max >= 0 ) { \nfi . max = max ; \n} \nelse { \nfi . max = - max ; \nfi . leftTruncate = false ; \n} \n} \n} \nreturn fi ; \n} \n} \n"}
{"6211": "public class SystemPropertiesProxy { \npublic String get ( String key , String def ) throws IllegalArgumentException { \nif ( SystemProperties == null ) return null ; \nelse if ( getString == null ) return null ; \nString ret = null ; \ntry { \nret = ( String ) getString . invoke ( SystemProperties , new Object [ ] { \nkey , def } \n) ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \n} \nif ( ret == null ) { \nret = def ; \n} \nelse if ( ret . length ( ) == 0 ) { \nret = def ; \n} \nreturn ret ; \n} \n} \n"}
{"6212": "public class SystemPropertiesProxy { \npublic Boolean getBoolean ( String key , boolean def ) throws IllegalArgumentException { \nif ( SystemProperties == null ) return def ; \nelse if ( getBoolean == null ) return def ; \nBoolean ret = def ; \ntry { \nret = ( Boolean ) getBoolean . invoke ( SystemProperties , new Object [ ] { \nkey , def } \n) ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \n} \nreturn ret ; \n} \n} \n"}
{"6215": "public class Introspector { \nstatic public PropertyDescriptor [ ] getPropertyDescriptors ( Class < ? > clazz ) { \nfinal String SETTER_PREFIX = \"set\" ; \nfinal String GETTER_PREFIX = \"get\" ; \nfinal int LEN_PREFIX = SETTER_PREFIX . length ( ) ; \nMap < String , PropertyDescriptor > map = new HashMap < String , PropertyDescriptor > ( ) ; \nfor ( Method m : clazz . getMethods ( ) ) { \nPropertyDescriptor pd = null ; \nString mName = m . getName ( ) ; \nboolean isGet = mName . startsWith ( GETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; \nboolean isSet = mName . startsWith ( SETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; \nif ( isGet ) { \nString propName = decapitalize ( mName . substring ( LEN_PREFIX ) ) ; \npd = map . get ( propName ) ; \nif ( pd == null ) { \npd = new PropertyDescriptor ( propName ) ; \nmap . put ( propName , pd ) ; \n} \nClass < ? > [ ] parmTypes = m . getParameterTypes ( ) ; \nif ( isSet ) { \nif ( parmTypes . length == 1 ) { \npd . setWriteMethod ( m ) ; \npd . setPropertyType ( parmTypes [ 0 ] ) ; \n} \n} \nelse if ( isGet ) { \nif ( parmTypes . length == 0 ) { \npd . setReadMethod ( m ) ; \nif ( pd . getPropertyType ( ) == null ) { \npd . setPropertyType ( m . getReturnType ( ) ) ; \n} \n} \n} \n} \nelse if ( isSet ) { \nString propName = decapitalize ( mName . substring ( LEN_PREFIX ) ) ; \npd = map . get ( propName ) ; \nif ( pd == null ) { \npd = new PropertyDescriptor ( propName ) ; \nmap . put ( propName , pd ) ; \n} \nClass < ? > [ ] parmTypes = m . getParameterTypes ( ) ; \nif ( isSet ) { \nif ( parmTypes . length == 1 ) { \npd . setWriteMethod ( m ) ; \npd . setPropertyType ( parmTypes [ 0 ] ) ; \n} \n} \nelse if ( isGet ) { \nif ( parmTypes . length == 0 ) { \npd . setReadMethod ( m ) ; \nif ( pd . getPropertyType ( ) == null ) { \npd . setPropertyType ( m . getReturnType ( ) ) ; \n} \n} \n} \n} \n} \nreturn map . values ( ) . toArray ( new PropertyDescriptor [ 0 ] ) ; \n} \n} \n"}
{"6246": "public class LogcatAppender { \n@ Override public void start ( ) { \nif ( this . encoder == null ) { \naddError ( \"No layout set for the appender named [\" + name + \"].\" ) ; \nreturn ; \n} \nelse if ( this . encoder . getLayout ( ) == null ) { \naddError ( \"No layout set for the appender named [\" + name + \"].\" ) ; \nreturn ; \n} \nif ( this . tagEncoder != null ) { \nfinal Layout < ? > layout = this . tagEncoder . getLayout ( ) ; \nif ( layout == null ) { \naddError ( \"No tag layout set for the appender named [\" + name + \"].\" ) ; \nreturn ; \n} \nif ( layout instanceof PatternLayout ) { \nString pattern = this . tagEncoder . getPattern ( ) ; \nif ( ! pattern . contains ( \"%nopex\" ) ) { \nthis . tagEncoder . stop ( ) ; \nthis . tagEncoder . setPattern ( pattern + \"%nopex\" ) ; \nthis . tagEncoder . start ( ) ; \n} \nPatternLayout tagLayout = ( PatternLayout ) layout ; \ntagLayout . setPostCompileProcessor ( null ) ; \n} \n} \nsuper . start ( ) ; \n} \n} \n"}
{"6247": "public class LogcatAppender { \nprotected String getTag ( ILoggingEvent event ) { \nString tag = ( this . tagEncoder != null ) ? this . tagEncoder . getLayout ( ) . doLayout ( event ) : event . getLoggerName ( ) ; \nif ( checkLoggable ) { \nif ( tag . length ( ) > MAX_TAG_LENGTH ) { \ntag = tag . substring ( 0 , MAX_TAG_LENGTH - 1 ) + \"*\" ; \n} \n} \nreturn tag ; \n} \n} \n"}
{"6249": "public class LoggerNameUtil { \npublic static int getSeparatorIndexOf ( String name , int fromIndex ) { \nint dotIndex = name . indexOf ( CoreConstants . DOT , fromIndex ) ; \nint dollarIndex = name . indexOf ( CoreConstants . DOLLAR , fromIndex ) ; \nif ( dotIndex == - 1 ) { \nif ( dollarIndex == - 1 ) return - 1 ; \n} \nif ( dotIndex == - 1 ) return dollarIndex ; \nif ( dollarIndex == - 1 ) return dotIndex ; \nreturn dotIndex < dollarIndex ? dotIndex : dollarIndex ; \n} \n} \n"}
{"6267": "public class ContextBase { \npublic void setName ( String name ) throws IllegalStateException { \nif ( name != null ) { \nif ( name . equals ( this . name ) ) { \nreturn ; \n} \n} \nif ( this . name == null || CoreConstants . DEFAULT_CONTEXT_NAME . equals ( this . name ) ) { \nthis . name = name ; \n} \nelse { \nthrow new IllegalStateException ( \"Context has been already given a name\" ) ; \n} \n} \n} \n"}
{"6281": "public class TurboFilterList { \npublic FilterReply getTurboFilterChainDecision ( final Marker marker , final Logger logger , final Level level , final String format , final Object [ ] params , final Throwable t ) { \nfinal int size = size ( ) ; \nif ( size == 1 ) { \ntry { \nTurboFilter tf = get ( 0 ) ; \nreturn tf . decide ( marker , logger , level , format , params , t ) ; \n} \ncatch ( IndexOutOfBoundsException iobe ) { \nreturn FilterReply . NEUTRAL ; \n} \n} \nObject [ ] tfa = toArray ( ) ; \nfinal int len = tfa . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nfinal TurboFilter tf = ( TurboFilter ) tfa [ i ] ; \nfinal FilterReply r = tf . decide ( marker , logger , level , format , params , t ) ; \nif ( r == FilterReply . DENY ) { \nreturn r ; \n} \nelse if ( r == FilterReply . ACCEPT ) { \nreturn r ; \n} \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6284": "public class FileFilterUtil { \npublic static File [ ] filesInFolderMatchingStemRegex ( File file , final String stemRegex ) { \nif ( file == null ) { \nreturn new File [ 0 ] ; \n} \nif ( ! file . exists ( ) ) { \nreturn new File [ 0 ] ; \n} \nelse if ( ! file . isDirectory ( ) ) { \nreturn new File [ 0 ] ; \n} \nreturn file . listFiles ( new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . matches ( stemRegex ) ; \n} \n} \n) ; \n} \n} \n"}
{"6287": "public class SQLiteAppender { \npublic File getDatabaseFile ( String filename ) { \nFile dbFile = null ; \nif ( filename != null ) { \nif ( filename . trim ( ) . length ( ) > 0 ) { \ndbFile = new File ( filename ) ; \n} \n} \nif ( dbFile == null ) { \ndbFile = new File ( new AndroidContextUtil ( ) . getDatabasePath ( \"logback.db\" ) ) ; \n} \nelse if ( dbFile . isDirectory ( ) ) { \ndbFile = new File ( new AndroidContextUtil ( ) . getDatabasePath ( \"logback.db\" ) ) ; \n} \nreturn dbFile ; \n} \n} \n"}
{"6289": "public class SQLiteAppender { \nprivate boolean lastCheckExpired ( Duration expiry , long lastCleanupTime ) { \nboolean isExpired = false ; \nif ( expiry != null ) { \nif ( expiry . getMilliseconds ( ) > 0 ) { \nfinal long now = this . clock . currentTimeMillis ( ) ; \nfinal long timeDiff = now - lastCleanupTime ; \nisExpired = ( lastCleanupTime <= 0 ) || ( timeDiff >= expiry . getMilliseconds ( ) ) ; \n} \n} \nreturn isExpired ; \n} \n} \n"}
{"6293": "public class SQLiteAppender { \nprivate String asStringTruncatedTo254 ( Object o ) { \nString s = null ; \nif ( o != null ) { \ns = o . toString ( ) ; \n} \nif ( s != null ) { \nif ( s . length ( ) > 254 ) { \ns = s . substring ( 0 , 254 ) ; \n} \n} \nreturn s == null ? \"\" : s ; \n} \n} \n"}
{"6294": "public class SQLiteAppender { \nprivate static short computeReferenceMask ( ILoggingEvent event ) { \nshort mask = 0 ; \nint mdcPropSize = 0 ; \nif ( event . getMDCPropertyMap ( ) != null ) { \nmdcPropSize = event . getMDCPropertyMap ( ) . keySet ( ) . size ( ) ; \n} \nint contextPropSize = 0 ; \nif ( event . getLoggerContextVO ( ) . getPropertyMap ( ) != null ) { \ncontextPropSize = event . getLoggerContextVO ( ) . getPropertyMap ( ) . size ( ) ; \n} \nif ( mdcPropSize > 0 ) { \nmask = PROPERTIES_EXIST ; \n} \nelse if ( contextPropSize > 0 ) { \nmask = PROPERTIES_EXIST ; \n} \nif ( event . getThrowableProxy ( ) != null ) { \nmask |= EXCEPTION_EXISTS ; \n} \nreturn mask ; \n} \n} \n"}
{"6297": "public class ElementSelector { \npublic int getPrefixMatchLength ( ElementPath p ) { \nif ( p == null ) { \nreturn 0 ; \n} \nint lSize = this . partList . size ( ) ; \nint rSize = p . partList . size ( ) ; \nif ( lSize == 0 ) { \nreturn 0 ; \n} \nelse if ( rSize == 0 ) { \nreturn 0 ; \n} \nint minLen = ( lSize <= rSize ) ? lSize : rSize ; \nint match = 0 ; \nfor ( int i = 0 ; \ni < minLen ; \ni ++ ) { \nString l = this . partList . get ( i ) ; \nString r = p . partList . get ( i ) ; \nif ( equalityCheck ( l , r ) ) { \nmatch ++ ; \n} \nelse { \nbreak ; \n} \n} \nreturn match ; \n} \n} \n"}
{"6304": "public class IncludeAction { \nprivate void trimHeadAndTail ( SaxEventRecorder recorder ) { \nList < SaxEvent > saxEventList = recorder . getSaxEventList ( ) ; \nif ( saxEventList . size ( ) == 0 ) { \nreturn ; \n} \nboolean includedTagFound = false ; \nboolean configTagFound = false ; \nSaxEvent first = saxEventList . get ( 0 ) ; \nif ( first != null ) { \nString elemName = getEventName ( first ) ; \nincludedTagFound = INCLUDED_TAG . equalsIgnoreCase ( elemName ) ; \nconfigTagFound = CONFIG_TAG . equalsIgnoreCase ( elemName ) ; \n} \nif ( includedTagFound ) { \nsaxEventList . remove ( 0 ) ; \nfinal int listSize = saxEventList . size ( ) ; \nif ( listSize == 0 ) { \nreturn ; \n} \nfinal int lastIndex = listSize - 1 ; \nSaxEvent last = saxEventList . get ( lastIndex ) ; \nif ( last != null ) { \nString elemName = getEventName ( last ) ; \nif ( includedTagFound && INCLUDED_TAG . equalsIgnoreCase ( elemName ) ) { \nsaxEventList . remove ( lastIndex ) ; \n} \nelse if ( configTagFound && CONFIG_TAG . equalsIgnoreCase ( elemName ) ) { \nsaxEventList . remove ( lastIndex ) ; \n} \n} \n} \nelse if ( configTagFound ) { \nsaxEventList . remove ( 0 ) ; \nfinal int listSize = saxEventList . size ( ) ; \nif ( listSize == 0 ) { \nreturn ; \n} \nfinal int lastIndex = listSize - 1 ; \nSaxEvent last = saxEventList . get ( lastIndex ) ; \nif ( last != null ) { \nString elemName = getEventName ( last ) ; \nif ( ( includedTagFound && INCLUDED_TAG . equalsIgnoreCase ( elemName ) ) || ( configTagFound && CONFIG_TAG . equalsIgnoreCase ( elemName ) ) ) { \nsaxEventList . remove ( lastIndex ) ; \n} \n} \n} \n} \n} \n"}
{"6310": "public class MirroredIndex { \npublic void syncIfNeeded ( ) { \nlong currentDate = System . currentTimeMillis ( ) ; \nif ( currentDate - mirrorSettings . getLastSyncDate ( ) . getTime ( ) > delayBetweenSyncs ) { \nsync ( ) ; \n} \nelse if ( mirrorSettings . getQueriesModificationDate ( ) . compareTo ( mirrorSettings . getLastSyncDate ( ) ) > 0 ) { \nsync ( ) ; \n} \n} \n} \n"}
{"6320": "public class ExpiringCache { \nsynchronized public V get ( K key ) { \nfinal Pair < V , Long > cachePair = lruCache . get ( key ) ; \nif ( cachePair != null ) { \nif ( cachePair . first != null ) { \nif ( cachePair . second > System . currentTimeMillis ( ) ) { \nreturn cachePair . first ; \n} \nelse { \nlruCache . remove ( key ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6339": "public class JsonProtocol { \nprivate double readJsonDouble ( ) throws IOException { \ncontext . read ( ) ; \nif ( reader . peek ( ) == QUOTE [ 0 ] ) { \nByteString str = readJsonString ( true ) ; \ndouble dub = Double . valueOf ( str . utf8 ( ) ) ; \nif ( ! context . escapeNum ( ) && ! Double . isNaN ( dub ) ) { \nif ( ! Double . isInfinite ( dub ) ) { \nthrow new ProtocolException ( \"Numeric data unexpectedly quoted\" ) ; \n} \n} \nreturn dub ; \n} \nelse { \nif ( context . escapeNum ( ) ) { \nreadJsonSyntaxChar ( QUOTE ) ; \n} \ntry { \nreturn Double . valueOf ( readJsonNumericChars ( ) ) ; \n} \ncatch ( NumberFormatException ex ) { \nthrow new ProtocolException ( \"Bad data encountered in numeric data\" ) ; \n} \n} \n} \n} \n"}
{"6371": "public class RuleCompletionProcessor { \nprivate boolean isSubtypeOf ( String class1 , String class2 ) { \nif ( class1 == null ) { \nreturn false ; \n} \nelse if ( class2 == null ) { \nreturn false ; \n} \nclass1 = convertToNonPrimitiveClass ( class1 ) ; \nclass2 = convertToNonPrimitiveClass ( class2 ) ; \nClassTypeResolver resolver = new ClassTypeResolver ( getUniqueImports ( ) , ProjectClassLoader . getProjectClassLoader ( getEditor ( ) ) ) ; \ntry { \nClass < ? > clazz1 = resolver . resolveType ( class1 ) ; \nClass < ? > clazz2 = resolver . resolveType ( class2 ) ; \nif ( clazz1 == null ) { \nreturn false ; \n} \nelse if ( clazz2 == null ) { \nreturn false ; \n} \nreturn clazz2 . isAssignableFrom ( clazz1 ) ; \n} \ncatch ( ClassNotFoundException exc ) { \nreturn false ; \n} \n} \n} \n"}
{"6376": "public class GraphicalVertex { \npublic void addConnection ( Connection conn ) { \nif ( conn == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nelse if ( conn . getSource ( ) == conn . getTarget ( ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( conn . getSource ( ) == this ) { \nsourceConnections . add ( conn ) ; \nfirePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; \n} \nelse if ( conn . getTarget ( ) == this ) { \ntargetConnections . add ( conn ) ; \nfirePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; \n} \n} \n} \n"}
{"6384": "public class ReteGraph { \npublic boolean addChild ( BaseVertex vertex ) { \nif ( vertex != null ) { \nif ( vertices . add ( vertex ) ) { \nfirePropertyChange ( PROP_CHILD_ADDED , null , vertex ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"6385": "public class ReteGraph { \npublic boolean removeChild ( BaseVertex vertex ) { \nif ( vertex != null ) { \nif ( vertices . remove ( vertex ) ) { \nfirePropertyChange ( PROP_CHILD_REMOVED , null , vertex ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"6413": "public class Precondition { \npublic void addCondition ( Condition condition ) throws WebDAVException { \nEnumeration conditions = getConditions ( ) ; \nif ( condition . getResourceURI ( ) != null ) { \nwhile ( conditions . hasMoreElements ( ) ) { \nCondition existingCondition = ( Condition ) conditions . nextElement ( ) ; \nif ( existingCondition . getResourceURI ( ) != null ) { \nif ( existingCondition . getResourceURI ( ) . equals ( condition . getResourceURI ( ) ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( \"error.parseMultipleSpecification\" , condition . getResourceURI ( ) ) ) ; \n} \n} \n} \nthis . conditions . addElement ( condition ) ; \n} \n} \n"}
{"6420": "public class DSLRuleCompletionProcessor { \npublic String getLastNonDashLine ( String backText ) { \nBufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; \nString last = \"\" ; \nString line = null ; \ntry { \nwhile ( ( line = breader . readLine ( ) ) != null ) { \nline = line . trim ( ) ; \nif ( line . length ( ) > 0 ) { \nif ( ! line . startsWith ( \"-\" ) ) { \nlast = line ; \n} \n} \n} \n} \ncatch ( IOException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \nif ( last . indexOf ( \"(\" ) > - 1 && ! last . endsWith ( \")\" ) ) { \nlast = last . substring ( 0 , last . indexOf ( \"(\" ) ) ; \n} \nelse if ( last . indexOf ( \"(\" ) > - 1 ) { \nif ( last . endsWith ( \")\" ) ) { \nlast = \"\" ; \n} \n} \nreturn last ; \n} \n} \n"}
{"6434": "public class Status { \npublic boolean sameAs ( Object obj ) { \nif ( obj == null ) return false ; \nelse if ( ! ( obj instanceof Status ) ) return false ; \nStatus other = ( Status ) obj ; \nif ( other . code != code ) return false ; \nelse if ( ! other . message . equals ( message ) ) return false ; \nreturn other . extendedStatus . equals ( extendedStatus ) ; \n} \n} \n"}
{"6438": "public class KieServiceDelegate { \nprotected String httpDelete ( String request ) throws IOException { \nString host = getKieRESTUrl ( ) ; \nURL url = new URL ( host + \"/\" + request ) ; \nActivator . println ( \"[DELETE] \" + url . toString ( ) ) ; \nHttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; \nconn . setRequestMethod ( \"DELETE\" ) ; \nconn . setRequestProperty ( \"Content\" , \"application/json\" ) ; \nsetHttpCredentials ( conn ) ; \nString response = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) . readLine ( ) ; \nActivator . println ( \"[DELETE] response: \" + response ) ; \nif ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_ACCEPTED ) { \nthrow new IOException ( \"HTTP DELETE failed : HTTP error code : \" + conn . getResponseCode ( ) ) ; \n} \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nif ( status != null ) { \nif ( ! status . isEmpty ( ) ) { \nif ( ! \"APPROVED\" . equals ( status ) ) throw new IOException ( \"HTTP DELETE failed : Request status code : \" + status ) ; \n} \n} \nString jobId = jo . get ( \"jobId\" ) . asString ( ) ; \nif ( jobId != null ) { \nif ( ! jobId . isEmpty ( ) ) return jobId ; \n} \nreturn response ; \n} \n} \n"}
{"6439": "public class KieServiceDelegate { \nprotected String httpPost ( String request , JsonObject body ) throws IOException , RuntimeException { \nString host = getKieRESTUrl ( ) ; \nURL url = new URL ( host + \"/\" + request ) ; \nActivator . println ( \"[POST] \" + url . toString ( ) + \" body: \" + body ) ; \nHttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; \nconn . setDoOutput ( body != null ) ; \nconn . setRequestMethod ( \"POST\" ) ; \nconn . setRequestProperty ( \"Content-Type\" , \"application/json\" ) ; \nsetHttpCredentials ( conn ) ; \nif ( body != null ) { \njava . io . OutputStream os = conn . getOutputStream ( ) ; \nWriter writer = new OutputStreamWriter ( os , \"UTF-8\" ) ; \nbody . writeTo ( writer ) ; \nwriter . close ( ) ; \nos . flush ( ) ; \n} \nString response = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) . readLine ( ) ; \nActivator . println ( \"[POST] response: \" + response ) ; \nif ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_ACCEPTED ) { \nthrow new IOException ( \"HTTP POST failed : HTTP error code : \" + conn . getResponseCode ( ) ) ; \n} \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nif ( status != null ) { \nif ( ! status . isEmpty ( ) ) { \nif ( ! \"APPROVED\" . equals ( status ) ) throw new IOException ( \"HTTP POST failed : Request status code : \" + status ) ; \n} \n} \nString jobId = jo . get ( \"jobId\" ) . asString ( ) ; \nif ( jobId != null ) { \nif ( ! jobId . isEmpty ( ) ) return jobId ; \n} \nreturn response ; \n} \n} \n"}
{"6440": "public class KieServiceDelegate { \npublic String getJobStatus ( final String jobId , final String title ) throws IOException , InterruptedException { \nfinal AtomicReference < String > ar = new AtomicReference < String > ( ) ; \nIWorkbench wb = PlatformUI . getWorkbench ( ) ; \nIProgressService ps = wb . getProgressService ( ) ; \ntry { \nps . busyCursorWhile ( new IRunnableWithProgress ( ) { \npublic void run ( IProgressMonitor pm ) throws InterruptedException { \npm . beginTask ( \"Waiting for Job \" + jobId + \":\\n\\n\" + title , STATUS_REQUEST_TIMEOUT ) ; \npm . subTask ( title ) ; \nlong startTime = System . currentTimeMillis ( ) ; \nlong stopTime = startTime ; \ndo { \ntry { \nThread . sleep ( STATUS_REQUEST_DELAY ) ; \nString response = httpGet ( \"jobs/\" + jobId ) ; \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nString result = jo . get ( \"result\" ) . asString ( ) ; \nif ( \"null\" . equals ( result ) ) { \nif ( ! \"SUCCESS\" . equals ( status ) ) result = null ; \n} \nif ( status != null ) { \nif ( result != null ) ar . set ( status + \":\" + result ) ; \n} \nstopTime = System . currentTimeMillis ( ) ; \npm . worked ( STATUS_REQUEST_DELAY ) ; \nActivator . println ( \"status=\" + status ) ; \nActivator . println ( \"result=\" + result ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nif ( pm . isCanceled ( ) ) throw new InterruptedException ( \"Operation canceled\" ) ; \n} \nwhile ( ar . get ( ) == null && stopTime - startTime < STATUS_REQUEST_TIMEOUT ) ; \npm . done ( ) ; \nActivator . println ( \"\\n----------------------------------\\n\" + \"Job \" + jobId + \"\\n\" + title + \"\\ncompleted in \" + ( stopTime - startTime ) / 1000.0 + \" sec\\n\" + \"Status: \" + ar . get ( ) + \"\\n----------------------------------\\n\" ) ; \n} \n} \n) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \nreturn ar . get ( ) ; \n} \n} \n"}
{"6442": "public class PullOperationUI { \nprivate void handlePullResults ( final Map < Repository , Object > resultsMap ) { \nif ( tasksToWaitFor . decrementAndGet ( ) == 0 ) { \nif ( ! results . isEmpty ( ) ) showResults ( ) ; \n} \n} \n} \n"}
{"6445": "public class AbstractCompletionProcessor { \nprotected static void filterProposalsOnPrefix ( String prefix , List < ICompletionProposal > props ) { \nif ( prefix != null ) { \nif ( prefix . trim ( ) . length ( ) > 0 ) { \nIterator < ICompletionProposal > iterator = props . iterator ( ) ; \nString prefixLc = prefix . toLowerCase ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nICompletionProposal item = iterator . next ( ) ; \nString content = item . getDisplayString ( ) . toLowerCase ( ) ; \nif ( ! content . toLowerCase ( ) . startsWith ( prefixLc ) ) { \niterator . remove ( ) ; \n} \n} \n} \n} \n} \n} \n"}
{"6459": "public class ReteViewer { \npublic void drawGraph ( ReteGraph newGraph ) { \nLayerManager manager = ( LayerManager ) getGraphicalViewer ( ) . getEditPartRegistry ( ) . get ( LayerManager . ID ) ; \nConnectionLayer connLayer = ( ConnectionLayer ) manager . getLayer ( LayerConstants . CONNECTION_LAYER ) ; \nif ( getGraphicalViewer ( ) . getContents ( ) == null ) { \ngetGraphicalViewer ( ) . setContents ( getModel ( ) ) ; \n} \nfinal boolean isNewDiagram = newGraph != null && newGraph != diagram ; \nif ( isNewDiagram ) { \ndiagram . removeAll ( ) ; \n} \nConnectionRouter router ; \nif ( ( isNewDiagram && newGraph . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) || ( ! isNewDiagram && getModel ( ) . getChildren ( ) . size ( ) < SIMPLE_ROUTER_MIN_NODES ) ) { \nrouter = new ShortestPathConnectionRouter ( ( IFigure ) rootEditPart . getContentPane ( ) . getChildren ( ) . get ( 0 ) ) ; \n} \nelse { \nrouter = ConnectionRouter . NULL ; \n} \nconnLayer . setConnectionRouter ( router ) ; \nif ( newGraph != null ) { \nif ( newGraph != diagram ) { \ndiagram . addAll ( newGraph . getChildren ( ) ) ; \n} \n} \n} \n} \n"}
{"6460": "public class DroolsDebugTarget { \npublic DroolsLineBreakpoint getDroolsBreakpoint ( String source ) { \nif ( source == null ) { \nreturn null ; \n} \nIterator < IBreakpoint > iterator = getBreakpoints ( ) . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nIJavaBreakpoint element = ( IJavaBreakpoint ) iterator . next ( ) ; \nif ( element instanceof DroolsLineBreakpoint ) { \nif ( ( ( DroolsLineBreakpoint ) element ) . getDialectName ( ) . equals ( \"mvel\" ) ) { \nDroolsLineBreakpoint l = ( DroolsLineBreakpoint ) element ; \ntry { \nint matchLine = l . getLineNumber ( ) ; \nString matchSource = l . getRuleName ( ) ; \nif ( source . equals ( matchSource ) ) { \nreturn l ; \n} \nelse if ( l . getFileRuleMappings ( ) . containsKey ( source ) ) { \nreturn l ; \n} \n} \ncatch ( CoreException e ) { \nlogError ( e ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6482": "public class AbstractResourceHandle { \npublic void delete ( boolean mustExist ) throws DAVException { \nIResponse response = null ; \ntry { \nresponse = davClient . delete ( locator , newContext ( ) ) ; \nif ( ! mustExist ) { \nif ( response . getStatusCode ( ) == IResponse . SC_NOT_FOUND ) return ; \n} \nexamineResponse ( response ) ; \nexamineMultiStatusResponse ( response ) ; \n} \ncatch ( IOException exception ) { \nthrow new SystemException ( exception ) ; \n} \nfinally { \ncloseResponse ( response ) ; \n} \n} \n} \n"}
{"6483": "public class AbstractResourceHandle { \nprotected void examineStatusCode ( int code , String message ) throws WebDAVException { \nif ( code >= 300 ) { \nif ( code <= 399 ) throw new RedirectionException ( code , message ) ; \n} \nif ( code >= 400 ) { \nif ( code <= 499 ) throw new ClientException ( code , message ) ; \n} \nif ( code >= 500 ) { \nif ( code <= 599 ) throw new ServerException ( code , message ) ; \n} \n} \n} \n"}
{"6491": "public class CompletionUtil { \npublic static String stripLastWord ( String prefix ) { \nif ( \"\" . equals ( prefix ) ) { \nreturn prefix ; \n} \nif ( prefix . charAt ( prefix . length ( ) - 1 ) == ' ' ) { \nreturn \"\" ; \n} \nelse { \nchar [ ] c = prefix . toCharArray ( ) ; \nint start = 0 ; \nfor ( int i = c . length - 1 ; \ni >= 0 ; \ni -- ) { \nif ( Character . isWhitespace ( c [ i ] ) || c [ i ] == '(' || c [ i ] == ':' || c [ i ] == ';' || c [ i ] == '=' || c [ i ] == '<' || c [ i ] == '>' || c [ i ] == '.' || c [ i ] == '{' ) { \nstart = i + 1 ; \nbreak ; \n} \nelse if ( c [ i ] == '}' ) { \nstart = i + 1 ; \nbreak ; \n} \n} \nprefix = prefix . substring ( start , prefix . length ( ) ) ; \nreturn prefix ; \n} \n} \n} \n"}
{"6492": "public class RuleContentOutlinePage { \npublic void update ( ) { \nTreeViewer viewer = getTreeViewer ( ) ; \nif ( viewer != null ) { \nControl control = viewer . getControl ( ) ; \nif ( control != null ) { \nif ( ! control . isDisposed ( ) ) { \ninitRules ( ) ; \npopulatePackageTreeNode ( ) ; \nviewer . refresh ( ) ; \ncontrol . setRedraw ( false ) ; \nviewer . expandToLevel ( 2 ) ; \ncontrol . setRedraw ( true ) ; \n} \n} \n} \n} \n} \n"}
{"6494": "public class DroolsThread { \npublic synchronized void stepOver ( ) throws DebugException { \nif ( ! ( getTopStackFrame ( ) instanceof MVELStackFrame ) ) { \nsuper . stepOver ( ) ; \nreturn ; \n} \nMVELStackFrame mvelStack = ( MVELStackFrame ) getTopStackFrame ( ) ; \nif ( ! canStepOver ( ) ) { \nreturn ; \n} \nelse if ( ! mvelStack . canStepOver ( ) ) { \nreturn ; \n} \nif ( ! setRemoteOnBreakReturn ( Debugger . STEP ) ) { \nreturn ; \n} \nsetRunning ( true ) ; \npreserveStackFrames ( ) ; \nfireEvent ( new DebugEvent ( this , DebugEvent . RESUME , DebugEvent . STEP_OVER ) ) ; \ntry { \ngetUnderlyingThread ( ) . resume ( ) ; \n} \ncatch ( RuntimeException e ) { \ntargetRequestFailed ( MessageFormat . format ( JDIDebugModelMessages . JDIThread_exception_stepping , e . toString ( ) ) , e ) ; \n} \n} \n} \n"}
{"6513": "public class DSLTree { \npublic Node [ ] getChildren ( String obj , String text ) { \nNode thenode = this . rootCond . getChild ( obj ) ; \nif ( thenode == null ) { \nfor ( Node child : this . rootCond . getChildren ( ) ) { \nString tokenText = child . getToken ( ) ; \nif ( tokenText != null ) { \nint index = tokenText . indexOf ( \"{\" ) ; \nif ( index != - 1 ) { \nString substring = tokenText . substring ( 0 , index ) ; \nif ( obj != null ) { \nif ( obj . startsWith ( substring ) ) { \nthenode = child ; \n} \n} \n} \n} \n} \n} \nif ( thenode != null ) { \nif ( text . length ( ) > 0 ) { \nStringTokenizer tokenz = new StringTokenizer ( text ) ; \nthis . last = this . current ; \nwhile ( tokenz . hasMoreTokens ( ) ) { \nString strtk = tokenz . nextToken ( ) ; \nNode ch = thenode . getChild ( strtk ) ; \nif ( ch != null ) { \nthenode = ch ; \n} \nelse { \nbreak ; \n} \n} \nif ( thenode != this . rootCond ) { \nthis . current = thenode ; \n} \n} \n} \nif ( thenode == null ) { \nreturn null ; \n} \nCollection < Node > children = thenode . getChildren ( ) ; \nNode [ ] nchild = new Node [ children . size ( ) ] ; \nreturn children . toArray ( nchild ) ; \n} \n} \n"}
{"6514": "public class DSLTree { \npublic void addChildToList ( Node n , String prefix , ArrayList < String > list ) { \nif ( n . getChildren ( ) . size ( ) > 0 ) { \nfor ( Node child : n . getChildren ( ) ) { \nif ( prefix != null ) { \nif ( \"-\" . equals ( child . getToken ( ) ) ) { \nif ( ! list . contains ( prefix ) ) { \nlist . add ( prefix ) ; \n} \nreturn ; \n} \n} \nString text = ( prefix == null ? \"\" : prefix + \" \" ) + child . getToken ( ) ; \naddChildToList ( child , text , list ) ; \n} \n} \nelse { \nif ( ! list . contains ( prefix ) ) { \nlist . add ( prefix ) ; \n} \n} \n} \n} \n"}
{"6520": "public class HttpClient { \npublic Response invoke ( Request request ) throws IOException { \nAssert . isNotNull ( request ) ; \ntry { \nopen ( ) ; \nURL resourceUrl = request . getResourceUrl ( ) ; \nURL originServerUrl = new URL ( resourceUrl . getProtocol ( ) , resourceUrl . getHost ( ) , resourceUrl . getPort ( ) , \"/\" ) ; \nURL proxyServerUrl = getProxyServerUrl ( originServerUrl ) ; \nif ( proxyServerUrl == null ) { \nif ( ! matchesProxyServerException ( originServerUrl ) ) { \nproxyServerUrl = getDefaultProxyServerUrl ( ) ; \n} \n} \nIContext context = webDAVFactory . newContext ( request . getContext ( ) ) ; \nIContext defaultContext = getContext ( originServerUrl ) ; \nif ( defaultContext == null ) { \ndefaultContext = getDefaultContext ( ) ; \n} \nif ( defaultContext != null ) { \nEnumeration e = defaultContext . keys ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nString key = ( String ) e . nextElement ( ) ; \ncontext . put ( key , defaultContext . get ( key ) ) ; \n} \n} \nif ( authority != null ) { \nauthority . authorize ( request , null , context , proxyServerUrl , true ) ; \nauthority . authorize ( request , null , context , proxyServerUrl , false ) ; \n} \nreturn invoke1 ( request , context , proxyServerUrl , originServerUrl , 0 , 0 ) ; \n} \nfinally { \nrequest . close ( ) ; \n} \n} \n} \n"}
{"6539": "public class Connection { \npublic BaseVertex getOpposite ( BaseVertex vertex ) { \nif ( vertex == null ) { \nreturn null ; \n} \nelse if ( ! vertex . equals ( getSource ( ) ) && ! vertex . equals ( getTarget ( ) ) ) { \nreturn null ; \n} \nif ( vertex . equals ( getSource ( ) ) ) { \nreturn getTarget ( ) ; \n} \nreturn getSource ( ) ; \n} \n} \n"}
{"6546": "public class YubicoClient { \npublic static String getPublicId ( String otp ) { \nif ( otp == null ) { \nthrow new IllegalArgumentException ( \"The OTP is too short to be valid\" ) ; \n} \nelse if ( otp . length ( ) < OTP_MIN_LEN ) { \nthrow new IllegalArgumentException ( \"The OTP is too short to be valid\" ) ; \n} \nInteger len = otp . length ( ) ; \nreturn otp . substring ( 0 , len - 32 ) . toLowerCase ( ) ; \n} \n} \n"}
{"6547": "public class YubicoClient { \npublic static boolean isValidOTPFormat ( String otp ) { \nif ( otp == null ) { \nreturn false ; \n} \nint len = otp . length ( ) ; \nfor ( char c : otp . toCharArray ( ) ) { \nif ( c < 0x20 ) { \nreturn false ; \n} \nelse if ( c > 0x7E ) { \nreturn false ; \n} \n} \nreturn OTP_MIN_LEN <= len && len <= OTP_MAX_LEN ; \n} \n} \n"}
{"6557": "public class OgnlRuntime { \npublic static Method getAppropriateMethod ( OgnlContext context , Object source , Object target , String propertyName , String methodName , List methods , Object [ ] args , Object [ ] actualArgs ) { \nMethod result = null ; \nif ( methods != null ) { \nClass typeClass = target != null ? target . getClass ( ) : null ; \nif ( typeClass == null && source != null ) { \nif ( Class . class . isInstance ( source ) ) { \ntypeClass = ( Class ) source ; \n} \n} \nClass [ ] argClasses = getArgClasses ( args ) ; \nMatchingMethod mm = findBestMethod ( methods , typeClass , methodName , argClasses ) ; \nif ( mm != null ) { \nresult = mm . mMethod ; \nClass [ ] mParameterTypes = mm . mParameterTypes ; \nSystem . arraycopy ( args , 0 , actualArgs , 0 , args . length ) ; \nfor ( int j = 0 ; \nj < mParameterTypes . length ; \nj ++ ) { \nClass type = mParameterTypes [ j ] ; \nif ( mm . report . conversionNeeded [ j ] ) { \nactualArgs [ j ] = getConvertedType ( context , source , result , propertyName , args [ j ] , type ) ; \n} \nelse if ( type . isPrimitive ( ) && ( actualArgs [ j ] == null ) ) { \nactualArgs [ j ] = getConvertedType ( context , source , result , propertyName , args [ j ] , type ) ; \n} \n} \n} \n} \nif ( result == null ) { \nresult = getConvertedMethodAndArgs ( context , target , propertyName , methods , args , actualArgs ) ; \n} \nreturn result ; \n} \n} \n"}
{"6558": "public class OgnlRuntime { \npublic static final Object getMethodValue ( OgnlContext context , Object target , String propertyName , boolean checkAccessAndExistence ) throws OgnlException , IllegalAccessException , NoSuchMethodException , IntrospectionException { \nObject result = null ; \nMethod m = getGetMethod ( context , ( target == null ) ? null : target . getClass ( ) , propertyName ) ; \nif ( m == null ) m = getReadMethod ( ( target == null ) ? null : target . getClass ( ) , propertyName , null ) ; \nif ( checkAccessAndExistence ) { \nif ( m == null ) { \nresult = NotFound ; \n} \nelse if ( ! context . getMemberAccess ( ) . isAccessible ( context , target , m , propertyName ) ) { \nresult = NotFound ; \n} \n} \nif ( result == null ) { \nif ( m != null ) { \ntry { \nresult = invokeMethod ( target , m , NoArguments ) ; \n} \ncatch ( InvocationTargetException ex ) { \nthrow new OgnlException ( propertyName , ex . getTargetException ( ) ) ; \n} \n} \nelse { \nthrow new NoSuchMethodException ( propertyName ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6559": "public class OgnlRuntime { \npublic static Map getPropertyDescriptors ( Class targetClass ) throws IntrospectionException , OgnlException { \nMap result ; \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { \nsynchronized ( _propertyDescriptorCache ) { \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { \nPropertyDescriptor [ ] pda = Introspector . getBeanInfo ( targetClass ) . getPropertyDescriptors ( ) ; \nresult = new HashMap ( 101 ) ; \nfor ( int i = 0 , icount = pda . length ; \ni < icount ; \ni ++ ) { \nif ( pda [ i ] . getReadMethod ( ) != null ) { \nif ( ! isMethodCallable ( pda [ i ] . getReadMethod ( ) ) ) { \npda [ i ] . setReadMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getReadMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , true ) ) ; \n} \n} \nif ( pda [ i ] . getWriteMethod ( ) != null ) { \nif ( ! isMethodCallable ( pda [ i ] . getWriteMethod ( ) ) ) { \npda [ i ] . setWriteMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getWriteMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , false ) ) ; \n} \n} \nresult . put ( pda [ i ] . getName ( ) , pda [ i ] ) ; \n} \nfindObjectIndexedPropertyDescriptors ( targetClass , result ) ; \n_propertyDescriptorCache . put ( targetClass , result ) ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"6562": "public class JavaCharStream { \npublic char readChar ( ) throws java . io . IOException { \nif ( inBuf > 0 ) { \n-- inBuf ; \nif ( ++ bufpos == bufsize ) bufpos = 0 ; \nreturn buffer [ bufpos ] ; \n} \nchar c ; \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) == '\\\\' ) { \nUpdateLineColumn ( c ) ; \nint backSlashCnt = 1 ; \nfor ( ; \n; \n) { \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \ntry { \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) != '\\\\' ) { \nUpdateLineColumn ( c ) ; \nif ( c == 'u' ) { \nif ( ( backSlashCnt & 1 ) == 1 ) { \nif ( -- bufpos < 0 ) bufpos = bufsize - 1 ; \nbreak ; \n} \n} \nbackup ( backSlashCnt ) ; \nreturn '\\\\' ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( backSlashCnt > 1 ) backup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \nUpdateLineColumn ( c ) ; \nbackSlashCnt ++ ; \n} \ntry { \nwhile ( ( c = ReadByte ( ) ) == 'u' ) ++ column ; \nbuffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ReadByte ( ) ) << 8 | hexval ( ReadByte ( ) ) << 4 | hexval ( ReadByte ( ) ) ) ; \ncolumn += 4 ; \n} \ncatch ( java . io . IOException e ) { \nthrow new Error ( \"Invalid escape character at line \" + line + \" column \" + column + \".\" ) ; \n} \nif ( backSlashCnt == 1 ) return c ; \nelse { \nbackup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \n} \nelse { \nUpdateLineColumn ( c ) ; \nreturn c ; \n} \n} \n} \n"}
{"6573": "public class OgnlOps { \npublic static int getNumericType ( int t1 , int t2 , boolean canBeNonNumeric ) { \nif ( t1 == t2 ) return t1 ; \nif ( canBeNonNumeric ) { \nif ( t1 == NONNUMERIC || t2 == NONNUMERIC || t1 == CHAR || t2 == CHAR ) return NONNUMERIC ; \n} \nif ( t1 == NONNUMERIC ) t1 = DOUBLE ; \nif ( t2 == NONNUMERIC ) t2 = DOUBLE ; \nif ( t1 >= MIN_REAL_TYPE ) { \nif ( t2 >= MIN_REAL_TYPE ) return Math . max ( t1 , t2 ) ; \nif ( t2 < INT ) return t1 ; \nif ( t2 == BIGINT ) return BIGDEC ; \nreturn Math . max ( DOUBLE , t1 ) ; \n} \nelse if ( t2 >= MIN_REAL_TYPE ) { \nif ( t1 < INT ) return t2 ; \nif ( t1 == BIGINT ) return BIGDEC ; \nreturn Math . max ( DOUBLE , t2 ) ; \n} \nelse return Math . max ( t1 , t2 ) ; \n} \n} \n"}
{"6588": "public class AbstractPlay2StartServerMojo { \nprotected void waitForServerStarted ( String rootUrl , JavaRunnable runner , int startTimeout , boolean spawned ) throws MojoExecutionException , IOException { \nlong endTimeMillis = startTimeout > 0 ? System . currentTimeMillis ( ) + startTimeout : 0L ; \nboolean started = false ; \nURL connectUrl = new URL ( rootUrl ) ; \nint verifyWaitDelay = 1000 ; \nwhile ( ! started ) { \nif ( startTimeout > 0 ) { \nif ( endTimeMillis - System . currentTimeMillis ( ) < 0L ) { \nif ( spawned ) { \nInternalPlay2StopMojo internalStop = new InternalPlay2StopMojo ( ) ; \ninternalStop . project = project ; \ntry { \ninternalStop . execute ( ) ; \n} \ncatch ( MojoExecutionException e ) { \n} \ncatch ( MojoFailureException e ) { \n} \n} \nthrow new MojoExecutionException ( String . format ( \"Failed to start Play! server in %d ms\" , Integer . valueOf ( startTimeout ) ) ) ; \n} \n} \nBuildException runnerException = runner . getException ( ) ; \nif ( runnerException != null ) { \nthrow new MojoExecutionException ( \"Play! server start exception\" , runnerException ) ; \n} \ntry { \nURLConnection conn = connectUrl . openConnection ( ) ; \nif ( startTimeout > 0 ) { \nint connectTimeOut = Long . valueOf ( Math . min ( endTimeMillis - System . currentTimeMillis ( ) , Integer . valueOf ( Integer . MAX_VALUE ) . longValue ( ) ) ) . intValue ( ) ; \nif ( connectTimeOut > 0 ) { \nconn . setConnectTimeout ( connectTimeOut ) ; \n} \n} \nconnectUrl . openConnection ( ) . getContent ( ) ; \nstarted = true ; \n} \ncatch ( Exception e ) { \n} \nif ( ! started ) { \nlong sleepTime = verifyWaitDelay ; \nif ( startTimeout > 0 ) { \nsleepTime = Math . min ( sleepTime , endTimeMillis - System . currentTimeMillis ( ) ) ; \n} \nif ( sleepTime > 0 ) { \ntry { \nThread . sleep ( sleepTime ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new MojoExecutionException ( \"?\" , e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"6599": "public class DirectoryChooserFragment { \nprivate void refreshButtonState ( ) { \nfinal Activity activity = getActivity ( ) ; \nif ( activity != null ) { \nif ( mSelectedDir != null ) { \nmBtnConfirm . setEnabled ( isValidFile ( mSelectedDir ) ) ; \ngetActivity ( ) . invalidateOptionsMenu ( ) ; \n} \n} \n} \n} \n"}
{"6620": "public class ElementType { \npublic void setAttribute ( AttributesImpl atts , String name , String type , String value ) { \nif ( name . equals ( \"xmlns\" ) ) { \nreturn ; \n} \nelse if ( name . startsWith ( \"xmlns:\" ) ) { \nreturn ; \n} \n; \nString namespace = namespace ( name , true ) ; \nString localName = localName ( name ) ; \nint i = atts . getIndex ( name ) ; \nif ( i == - 1 ) { \nname = name . intern ( ) ; \nif ( type == null ) type = \"CDATA\" ; \nif ( ! type . equals ( \"CDATA\" ) ) value = normalize ( value ) ; \natts . addAttribute ( namespace , localName , name , type , value ) ; \n} \nelse { \nif ( type == null ) type = atts . getType ( i ) ; \nif ( ! type . equals ( \"CDATA\" ) ) value = normalize ( value ) ; \natts . setAttribute ( i , namespace , localName , name , type , value ) ; \n} \n} \n} \n"}
{"6631": "public class FilenameUtils { \npublic static String separatorsToUnix ( String path ) { \nif ( path == null ) { \nreturn path ; \n} \nelse if ( path . indexOf ( WINDOWS_SEPARATOR ) == - 1 ) { \nreturn path ; \n} \nreturn path . replace ( WINDOWS_SEPARATOR , UNIX_SEPARATOR ) ; \n} \n} \n"}
{"6633": "public class CropImageView { \nprivate void ensureVisible ( HighlightView hv ) { \nRect r = hv . mDrawRect ; \nint panDeltaX1 = Math . max ( 0 , mLeft - r . left ) ; \nint panDeltaX2 = Math . min ( 0 , mRight - r . right ) ; \nint panDeltaY1 = Math . max ( 0 , mTop - r . top ) ; \nint panDeltaY2 = Math . min ( 0 , mBottom - r . bottom ) ; \nint panDeltaX = panDeltaX1 != 0 ? panDeltaX1 : panDeltaX2 ; \nint panDeltaY = panDeltaY1 != 0 ? panDeltaY1 : panDeltaY2 ; \nif ( panDeltaX != 0 ) { \npanBy ( panDeltaX , panDeltaY ) ; \n} \nelse if ( panDeltaY != 0 ) { \npanBy ( panDeltaX , panDeltaY ) ; \n} \n} \n} \n"}
{"6653": "public class FontManager { \nprivate static Map < String , String > getAssetFonts ( Context context ) { \nsynchronized ( ASSET_FONTS_BY_NAME ) { \nif ( ASSET_FONTS_BY_NAME . isEmpty ( ) ) { \nAssetManager assets = context . getResources ( ) . getAssets ( ) ; \nCollection < String > fontFiles = AssetIndex . getAssetIndex ( context ) ; \nif ( fontFiles == null ) { \nfontFiles = listFontFiles ( context . getResources ( ) ) ; \n} \nelse if ( fontFiles . isEmpty ( ) ) { \nfontFiles = listFontFiles ( context . getResources ( ) ) ; \n} \nfor ( String filePath : fontFiles ) { \nif ( filePath . toLowerCase ( Locale . getDefault ( ) ) . endsWith ( \"ttf\" ) ) { \nString fontName = TTFAnalyzer . getFontName ( assets , filePath ) ; \nif ( fontName == null ) { \nfontName = getFileName ( filePath ) ; \n} \nASSET_FONTS_BY_NAME . put ( fontName , filePath ) ; \n} \n} \n} \nreturn ASSET_FONTS_BY_NAME ; \n} \n} \n} \n"}
{"6658": "public class Parser { \n@ Override public void adup ( char [ ] buff , int offset , int length ) throws SAXException { \nif ( theNewElement != null ) { \nif ( theAttributeName != null ) { \ntheNewElement . setAttribute ( theAttributeName , null , theAttributeName ) ; \ntheAttributeName = null ; \n} \n} \n} \n} \n"}
{"6660": "public class Parser { \nprivate int lookupEntity ( char [ ] buff , int offset , int length ) { \nint result = 0 ; \nif ( length < 1 ) return result ; \nif ( buff [ offset ] == '#' ) { \nif ( length > 1 ) { \nif ( buff [ offset + 1 ] == 'x' || buff [ offset + 1 ] == 'X' ) { \ntry { \nreturn Integer . parseInt ( new String ( buff , offset + 2 , length - 2 ) , 16 ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn 0 ; \n} \n} \n} \ntry { \nreturn Integer . parseInt ( new String ( buff , offset + 1 , length - 1 ) , 10 ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn 0 ; \n} \n} \nreturn theSchema . getEntity ( new String ( buff , offset , length ) ) ; \n} \n} \n"}
{"6663": "public class Parser { \nprivate void restartablyPop ( ) throws SAXException { \nElement popped = theStack ; \npop ( ) ; \nif ( restartElements ) { \nif ( ( popped . flags ( ) & Schema . F_RESTART ) != 0 ) { \npopped . anonymize ( ) ; \npopped . setNext ( theSaved ) ; \ntheSaved = popped ; \n} \n} \n} \n} \n"}
{"6666": "public class Parser { \nprivate static String trimquotes ( String in ) { \nif ( in == null ) return in ; \nint length = in . length ( ) ; \nif ( length == 0 ) return in ; \nchar s = in . charAt ( 0 ) ; \nchar e = in . charAt ( length - 1 ) ; \nif ( s == e ) { \nif ( s == '\\'' || s == '\"' ) { \nin = in . substring ( 1 , in . length ( ) - 1 ) ; \n} \n} \nreturn in ; \n} \n} \n"}
{"6667": "public class Parser { \nprivate static String [ ] split ( String val ) throws IllegalArgumentException { \nval = val . trim ( ) ; \nif ( val . length ( ) == 0 ) { \nreturn new String [ 0 ] ; \n} \nelse { \nArrayList < String > l = new ArrayList < String > ( ) ; \nint s = 0 ; \nint e = 0 ; \nboolean sq = false ; \nboolean dq = false ; \nchar lastc = 0 ; \nint len = val . length ( ) ; \nfor ( e = 0 ; \ne < len ; \ne ++ ) { \nchar c = val . charAt ( e ) ; \nif ( ! dq && c == '\\'' && lastc != '\\\\' ) { \nsq = ! sq ; \nif ( s < 0 ) s = e ; \n} \nelse if ( ! sq && c == '\\\"' && lastc != '\\\\' ) { \ndq = ! dq ; \nif ( s < 0 ) s = e ; \n} \nelse if ( ! sq ) { \nif ( ! dq ) { \nif ( Character . isWhitespace ( c ) ) { \nif ( s >= 0 ) l . add ( val . substring ( s , e ) ) ; \ns = - 1 ; \n} \nelse if ( s < 0 ) { \nif ( c != ' ' ) { \ns = e ; \n} \n} \n} \n} \nlastc = c ; \n} \nl . add ( val . substring ( s , e ) ) ; \nreturn ( String [ ] ) l . toArray ( new String [ 0 ] ) ; \n} \n} \n} \n"}
{"6668": "public class Parser { \nprivate void rectify ( Element e ) throws SAXException { \nElement sp ; \nwhile ( true ) { \nfor ( sp = theStack ; \nsp != null ; \nsp = sp . next ( ) ) { \nif ( sp . canContain ( e ) ) break ; \n} \nif ( sp != null ) break ; \nElementType parentType = e . parent ( ) ; \nif ( parentType == null ) break ; \nElement parent = new Element ( parentType , defaultAttributes ) ; \nparent . setNext ( e ) ; \ne = parent ; \n} \nif ( sp == null ) return ; \nwhile ( theStack != sp ) { \nif ( theStack == null || theStack . next ( ) == null ) break ; \nelse if ( theStack . next ( ) . next ( ) == null ) break ; \nrestartablyPop ( ) ; \n} \nwhile ( e != null ) { \nElement nexte = e . next ( ) ; \nif ( ! e . name ( ) . equals ( \"<pcdata>\" ) ) push ( e ) ; \ne = nexte ; \nrestart ( e ) ; \n} \ntheNewElement = null ; \n} \n} \n"}
{"6669": "public class Parser { \nprivate String makeName ( char [ ] buff , int offset , int length ) { \nStringBuffer dst = new StringBuffer ( length + 2 ) ; \nboolean seenColon = false ; \nboolean start = true ; \nfor ( ; \nlength -- > 0 ; \noffset ++ ) { \nchar ch = buff [ offset ] ; \nif ( Character . isLetter ( ch ) || ch == '_' ) { \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( Character . isDigit ( ch ) || ch == '-' || ch == '.' ) { \nif ( start ) dst . append ( '_' ) ; \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( ch == ':' ) { \nif ( ! seenColon ) { \nseenColon = true ; \nif ( start ) dst . append ( '_' ) ; \nstart = true ; \ndst . append ( translateColons ? '_' : ch ) ; \n} \n} \n} \nint dstLength = dst . length ( ) ; \nif ( dstLength == 0 ) dst . append ( '_' ) ; \nelse if ( dst . charAt ( dstLength - 1 ) == ':' ) dst . append ( '_' ) ; \nreturn dst . toString ( ) . intern ( ) ; \n} \n} \n"}
{"6672": "public class RTManager { \n@ Subscribe ( sticky = true , threadMode = ThreadMode . MAIN ) public void onEventMainThread ( MediaEvent event ) { \nRTEditText editor = mEditors . get ( mActiveEditor ) ; \nRTMedia media = event . getMedia ( ) ; \nif ( editor != null ) { \nif ( media instanceof RTImage ) { \ninsertImage ( editor , ( RTImage ) media ) ; \nEventBus . getDefault ( ) . removeStickyEvent ( event ) ; \nmActiveEditor = Integer . MAX_VALUE ; \n} \n} \n} \n} \n"}
{"6673": "public class RTManager { \n@ Subscribe ( threadMode = ThreadMode . MAIN ) public void onEventMainThread ( LinkEvent event ) { \nfinal String fragmentTag = event . getFragmentTag ( ) ; \nmRTApi . removeFragment ( fragmentTag ) ; \nif ( ! event . wasCancelled ( ) ) { \nif ( ID_01_LINK_FRAGMENT . equals ( fragmentTag ) ) { \nRTEditText editor = getActiveEditor ( ) ; \nif ( editor != null ) { \nLink link = event . getLink ( ) ; \nString url = null ; \nif ( link != null ) { \nif ( link . isValid ( ) ) { \nSelection selection = mLinkSelection != null && mLinkSelection . end ( ) <= editor . length ( ) ? mLinkSelection : new Selection ( editor ) ; \nString linkText = link . getLinkText ( ) ; \nEditable str = editor . getText ( ) ; \nstr . replace ( selection . start ( ) , selection . end ( ) , linkText ) ; \neditor . setSelection ( selection . start ( ) , selection . start ( ) + linkText . length ( ) ) ; \nurl = link . getUrl ( ) ; \n} \n} \neditor . applyEffect ( Effects . LINK , url ) ; \n} \n} \n} \n} \n} \n"}
{"6688": "public class HTMLWriter { \nprivate void writeName ( String uri , String localName , String qName , boolean isElement ) throws SAXException { \nString prefix = doPrefix ( uri , qName , isElement ) ; \nif ( prefix != null ) { \nif ( ! \"\" . equals ( prefix ) ) { \nwrite ( prefix ) ; \nwrite ( ':' ) ; \n} \n} \nif ( localName != null && ! \"\" . equals ( localName ) ) { \nwrite ( localName ) ; \n} \nelse { \nint i = qName . indexOf ( ':' ) ; \nwrite ( qName . substring ( i + 1 , qName . length ( ) ) ) ; \n} \n} \n} \n"}
{"6690": "public class AwsKinesisUtils { \nprivate static void waitStreamActivation ( AmazonKinesis consumer , String streamName , long streamCreationTimeoutMillis ) { \nDescribeStreamRequest describeStreamRequest = new DescribeStreamRequest ( ) . withStreamName ( streamName ) . withLimit ( 1 ) ; \nDescribeStreamResult describeStreamResult = null ; \nString streamStatus = null ; \nlong endTime = System . currentTimeMillis ( ) + streamCreationTimeoutMillis ; \ndo { \ntry { \ndescribeStreamResult = consumer . describeStream ( describeStreamRequest ) ; \nstreamStatus = describeStreamResult . getStreamDescription ( ) . getStreamStatus ( ) ; \nif ( ACTIVE_STREAM_STATUS . equals ( streamStatus ) ) { \nbreak ; \n} \nThread . sleep ( 100 ) ; \n} \ncatch ( ResourceNotFoundException | LimitExceededException ignored ) { \n} \ncatch ( InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \nthrow new AwsKinesisException ( \"Thread interrupted while waiting for stream activation\" , args -> args . add ( \"streamName\" , streamName ) , e ) ; \n} \n} \nwhile ( System . currentTimeMillis ( ) < endTime ) ; \nif ( describeStreamResult == null || streamStatus == null ) { \nthrow new AwsKinesisException ( \"Stream never went active\" , args -> args . add ( \"streamName\" , streamName ) . add ( \"streamCreationTimeoutMillis\" , streamCreationTimeoutMillis ) ) ; \n} \nelse if ( ! streamStatus . equals ( ACTIVE_STREAM_STATUS ) ) { \nthrow new AwsKinesisException ( \"Stream never went active\" , args -> args . add ( \"streamName\" , streamName ) . add ( \"streamCreationTimeoutMillis\" , streamCreationTimeoutMillis ) ) ; \n} \n} \n} \n"}
{"6699": "public class StringUtils { \nprivate static String replace ( final String inString , final String oldPattern , final String newPattern ) { \nif ( ! hasLength ( inString ) || ! hasLength ( oldPattern ) ) { \nreturn inString ; \n} \nelse if ( newPattern == null ) { \nreturn inString ; \n} \nfinal StringBuffer sbuf = new StringBuffer ( ) ; \nint pos = 0 ; \nint index = inString . indexOf ( oldPattern ) ; \nfinal int patLen = oldPattern . length ( ) ; \nwhile ( index >= 0 ) { \nsbuf . append ( inString . substring ( pos , index ) ) ; \nsbuf . append ( newPattern ) ; \npos = index + patLen ; \nindex = inString . indexOf ( oldPattern , pos ) ; \n} \nsbuf . append ( inString . substring ( pos ) ) ; \nreturn sbuf . toString ( ) ; \n} \n} \n"}
{"6700": "public class StringUtils { \nprivate static String deleteAny ( final String inString , final String charsToDelete ) { \nif ( ! hasLength ( inString ) ) { \nreturn inString ; \n} \nelse if ( ! hasLength ( charsToDelete ) ) { \nreturn inString ; \n} \nfinal StringBuffer out = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < inString . length ( ) ; \ni ++ ) { \nfinal char c = inString . charAt ( i ) ; \nif ( charsToDelete . indexOf ( c ) == - 1 ) { \nout . append ( c ) ; \n} \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"6713": "public class WildcardExpanderModelTransformer { \nprivate void processResource ( final Group group , final Resource resource ) { \nfinal UriLocator uriLocator = locatorFactory . getInstance ( resource . getUri ( ) ) ; \nif ( uriLocator instanceof WildcardUriLocatorSupport ) { \nfinal WildcardStreamLocator wildcardStreamLocator = ( ( WildcardUriLocatorSupport ) uriLocator ) . getWildcardStreamLocator ( ) ; \nif ( wildcardStreamLocator . hasWildcard ( resource . getUri ( ) ) ) { \nif ( wildcardStreamLocator instanceof WildcardExpanderHandlerAware ) { \nfinal WildcardExpanderHandlerAware expandedHandler = ( WildcardExpanderHandlerAware ) wildcardStreamLocator ; \nLOG . debug ( \"Expanding resource: {}\" , resource . getUri ( ) ) ; \nfinal String baseNameFolder = computeBaseNameFolder ( resource , uriLocator , expandedHandler ) ; \nLOG . debug ( \"baseNameFolder: {}\" , baseNameFolder ) ; \nexpandedHandler . setWildcardExpanderHandler ( createExpanderHandler ( group , resource , baseNameFolder ) ) ; \ntry { \nuriLocator . locate ( resource . getUri ( ) ) ; \n} \ncatch ( final IOException e ) { \nLOG . debug ( \"[FAIL] problem while trying to expand wildcard for the following resource uri: {}\" , resource . getUri ( ) ) ; \n} \nfinally { \nexpandedHandler . setWildcardExpanderHandler ( null ) ; \n} \n} \n} \n} \n} \n} \n"}
{"6714": "public class WildcardExpanderModelTransformer { \npublic Function < Collection < File > , Void > createExpanderHandler ( final Group group , final Resource resource , final String baseNameFolder ) { \nLOG . debug ( \"createExpanderHandler using baseNameFolder: {}\\n for resource {}\" , baseNameFolder , resource ) ; \nreturn new Function < Collection < File > , Void > ( ) { \npublic Void apply ( final Collection < File > files ) { \nif ( baseNameFolder == null ) { \nLOG . warn ( \"The resource {} is probably invalid, removing it from the group.\" , resource ) ; \ngroup . replace ( resource , new ArrayList < Resource > ( ) ) ; \n} \nelse { \nfinal List < Resource > expandedResources = new ArrayList < Resource > ( ) ; \nLOG . debug ( \"baseNameFolder: {}\" , baseNameFolder ) ; \nfor ( final File file : files ) { \nfinal String resourcePath = getFullPathNoEndSeparator ( resource ) ; \nLOG . debug ( \"\\tresourcePath: {}\" , resourcePath ) ; \nLOG . debug ( \"\\tfile path: {}\" , file . getPath ( ) ) ; \nfinal String computedResourceUri = resourcePath + StringUtils . removeStart ( file . getPath ( ) , baseNameFolder ) . replace ( '\\\\' , '/' ) ; \nfinal Resource expandedResource = Resource . create ( computedResourceUri , resource . getType ( ) ) ; \nLOG . debug ( \"\\texpanded resource: {}\" , expandedResource ) ; \nexpandedResources . add ( expandedResource ) ; \n} \nLOG . debug ( \"\\treplace resource {}\" , resource ) ; \ngroup . replace ( resource , expandedResources ) ; \n} \nreturn null ; \n} \nprivate String getFullPathNoEndSeparator ( final Resource resource1 ) { \nfinal String result = FilenameUtils . getFullPathNoEndSeparator ( resource1 . getUri ( ) ) ; \nif ( result != null && 1 == result . length ( ) ) { \nif ( 0 == FilenameUtils . indexOfLastSeparator ( result ) ) { \nreturn \"\" ; \n} \n} \nreturn result ; \n} \n} \n; \n} \n} \n"}
{"6747": "public class ResourceBundleProcessor { \npublic void serveProcessedBundle ( ) throws IOException { \nfinal WroConfiguration configuration = context . getConfig ( ) ; \nfinal HttpServletRequest request = context . getRequest ( ) ; \nfinal HttpServletResponse response = context . getResponse ( ) ; \nOutputStream os = null ; \ntry { \nfinal CacheKey cacheKey = getSafeCacheKey ( request ) ; \ninitAggregatedFolderPath ( request , cacheKey . getType ( ) ) ; \nfinal CacheValue cacheValue = cacheStrategy . get ( cacheKey ) ; \nfinal String ifNoneMatch = request . getHeader ( HttpHeader . IF_NONE_MATCH . toString ( ) ) ; \nfinal String etagValue = String . format ( \"\\\"%s\\\"\" , cacheValue . getHash ( ) ) ; \nif ( etagValue != null ) { \nif ( etagValue . equals ( ifNoneMatch ) ) { \nLOG . debug ( \"ETag hash detected: {}. Sending {} status code\" , etagValue , HttpServletResponse . SC_NOT_MODIFIED ) ; \nresponse . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; \nreturn ; \n} \n} \nresponse . setContentType ( cacheKey . getType ( ) . getContentType ( ) + \"; charset=\" + configuration . getEncoding ( ) ) ; \nresponse . setHeader ( HttpHeader . ETAG . toString ( ) , etagValue ) ; \nos = response . getOutputStream ( ) ; \nif ( cacheValue . getRawContent ( ) != null ) { \nif ( isGzipAllowed ( ) ) { \nresponse . setContentLength ( cacheValue . getGzippedContent ( ) . length ) ; \nresponse . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , \"gzip\" ) ; \nresponse . setHeader ( \"Vary\" , \"Accept-Encoding\" ) ; \nIOUtils . write ( cacheValue . getGzippedContent ( ) , os ) ; \n} \nelse { \nresponse . setContentLength ( cacheValue . getRawContent ( ) . getBytes ( configuration . getEncoding ( ) ) . length ) ; \nIOUtils . write ( cacheValue . getRawContent ( ) , os , configuration . getEncoding ( ) ) ; \n} \n} \n} \nfinally { \nif ( os != null ) { \nIOUtils . closeQuietly ( os ) ; \n} \n} \n} \n} \n"}
{"6748": "public class ResourceBundleProcessor { \nprivate void initAggregatedFolderPath ( final HttpServletRequest request , final ResourceType type ) { \nif ( ResourceType . CSS == type ) { \nif ( context . getAggregatedFolderPath ( ) == null ) { \nfinal String requestUri = request . getRequestURI ( ) ; \nfinal String cssFolder = StringUtils . removeEnd ( requestUri , FilenameUtils . getName ( requestUri ) ) ; \nfinal String aggregatedFolder = StringUtils . removeStart ( cssFolder , request . getContextPath ( ) ) ; \nLOG . debug ( \"set aggregatedFolderPath: {}\" , aggregatedFolder ) ; \nContext . get ( ) . setAggregatedFolderPath ( aggregatedFolder ) ; \n} \n} \n} \n} \n"}
{"6784": "public class RubySassEngine { \npublic void addRequire ( final String require ) { \nif ( require != null ) { \nif ( require . trim ( ) . length ( ) > 0 ) { \nrequires . add ( require . trim ( ) ) ; \n} \n} \n} \n} \n"}
{"6819": "public class ElkTimer { \npublic void log ( Logger logger , LogLevel priority ) { \nif ( LoggerWrap . isEnabledFor ( logger , priority ) ) { \nString timerLabel ; \nif ( threadId != 0 ) { \ntimerLabel = name + \" (thread \" + threadId + \")\" ; \n} \nelse if ( threadCount > 1 ) { \ntimerLabel = name + \" (over \" + threadCount + \" threads)\" ; \n} \nelse { \ntimerLabel = name ; \n} \nif ( todoFlags == RECORD_NONE ) { \nLoggerWrap . log ( logger , priority , \"Timer \" + timerLabel + \" recorded \" + measurements + \" run(s), no times taken\" ) ; \n} \nelse { \nString labels = \"\" ; \nString values = \"\" ; \nString separator ; \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"CPU\" ; \nvalues += totalCpuTime / 1000000 ; \nseparator = \"/\" ; \n} \nelse { \nseparator = \"\" ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += separator + \"Wall\" ; \nvalues += separator + totalWallTime / 1000000 ; \n} \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 ) { \nif ( threadId != 0 ) { \nlabels += \"/CPU avg\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / measurements / 1000000 ; \n} \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall avg\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / measurements / 1000000 ; \n} \nif ( threadCount > 1 ) { \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 ) { \nif ( threadId != 0 ) { \nlabels += \"/CPU per thread\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / threadCount / 1000000 ; \n} \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall per thread\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / threadCount / 1000000 ; \n} \n} \nLoggerWrap . log ( logger , priority , \"Time for \" + timerLabel + \" for \" + measurements + \" run(s) \" + labels + \" (ms): \" + values ) ; \n} \nif ( isRunning ) { \nlogger . warn ( \"Timer \" + timerLabel + \" logged while it was still running\" ) ; \n} \n} \n} \n} \n"}
{"6826": "public class ClassExpressionSaturationFactory { \nprivate void updateFinishedCounters ( ThisStatistics localStatistics ) throws InterruptedException { \nint snapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nfor ( ; \n; \n) { \nint snapshotCountContextsSaturatedLower = countContextsSaturatedLower_ . get ( ) ; \nsaturationState_ . setContextsSaturated ( snapshotCountContextsSaturatedLower ) ; \nif ( saturationState_ . getContextSetSaturatedCount ( ) < snapshotCountContextsSaturatedLower ) { \nreturn ; \n} \nint updatedSnapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nif ( updatedSnapshotJobsProcessed == snapshotJobsProcessed ) { \nbreak ; \n} \nsnapshotJobsProcessed = updatedSnapshotJobsProcessed ; \n} \nfor ( ; \n; \n) { \nint snapshotJobsFinished = countJobsFinishedUpper_ . get ( ) ; \nif ( snapshotJobsFinished >= snapshotJobsProcessed ) { \nbreak ; \n} \nif ( ! countJobsFinishedUpper_ . compareAndSet ( snapshotJobsFinished , snapshotJobsFinished + 1 ) ) { \ncontinue ; \n} \nJ nextJob = jobsInProgress_ . poll ( ) ; \nIndexedContextRoot root = nextJob . getInput ( ) ; \nContext rootSaturation = saturationState_ . getContext ( root ) ; \nif ( rootSaturation . isInitialized ( ) ) { \nif ( ! rootSaturation . isSaturated ( ) ) { \nLOGGER_ . error ( \"{}: context for a finished job not saturated!\" , rootSaturation ) ; \n} \n} \nnextJob . setOutput ( rootSaturation ) ; \nLOGGER_ . trace ( \"{}: saturation finished\" , root ) ; \nlocalStatistics . jobsProcessedNo ++ ; \nlistener_ . notifyFinished ( nextJob ) ; \n} \n} \n} \n"}
{"6829": "public class ObjectPropertyTaxonomyComputationFactory { \nprivate void instertIntoTaxonomy ( final IndexedObjectProperty property ) { \nfinal Map < IndexedObjectProperty , ElkObjectProperty > equivalent = collectEquivalent ( property ) ; \nif ( equivalent == null ) { \nreturn ; \n} \nfinal Map < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > subEquivalent = new ArrayHashMap < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > ( ) ; \nfinal Set < IndexedObjectProperty > indirect = new ArrayHashSet < IndexedObjectProperty > ( ) ; \nfor ( final IndexedObjectProperty subProperty : property . getSaturated ( ) . getSubProperties ( ) ) { \nif ( equivalent . containsKey ( subProperty ) ) { \ncontinue ; \n} \nfinal Map < IndexedObjectProperty , ElkObjectProperty > subEq = collectEquivalent ( subProperty ) ; \nsubEquivalent . put ( subProperty , subEq . values ( ) ) ; \nfor ( final IndexedObjectProperty subSubProperty : subProperty . getSaturated ( ) . getSubProperties ( ) ) { \nif ( ! subEq . containsKey ( subSubProperty ) ) { \nindirect . add ( subSubProperty ) ; \n} \n} \n} \nif ( subEquivalent . isEmpty ( ) ) { \nif ( indexedBottomProperty_ == null || ! equivalent . containsKey ( indexedBottomProperty_ ) ) { \noutputProcessor_ . visit ( new TransitiveReductionOutputEquivalentDirectImpl < ElkObjectProperty > ( equivalent . values ( ) , defaultDirectSubproperties_ ) ) ; \nreturn ; \n} \n} \nfinal Collection < Collection < ? extends ElkObjectProperty > > direct = Operations . map ( subEquivalent . entrySet ( ) , new Operations . Transformation < Map . Entry < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > , Collection < ? extends ElkObjectProperty > > ( ) { \n@ Override public Collection < ? extends ElkObjectProperty > transform ( final Entry < IndexedObjectProperty , Collection < ? extends ElkObjectProperty > > element ) { \nif ( indirect . contains ( element . getKey ( ) ) ) { \nreturn null ; \n} \nelse { \nreturn element . getValue ( ) ; \n} \n} \n} \n) ; \noutputProcessor_ . visit ( new TransitiveReductionOutputEquivalentDirectImpl < ElkObjectProperty > ( equivalent . values ( ) , direct ) ) ; \n} \n} \n"}
{"6846": "public class CachedIndexedComplexClassExpressionImpl { \npublic final void checkOccurrenceNumbers ( ) { \nif ( LOGGER_ . isTraceEnabled ( ) ) LOGGER_ . trace ( toString ( ) + \" occurences: \" + printOccurrenceNumbers ( ) ) ; \nif ( positiveOccurrenceNo < 0 ) throw new ElkUnexpectedIndexingException ( toString ( ) + \" has a negative occurrence: \" + printOccurrenceNumbers ( ) ) ; \nelse if ( negativeOccurrenceNo < 0 ) throw new ElkUnexpectedIndexingException ( toString ( ) + \" has a negative occurrence: \" + printOccurrenceNumbers ( ) ) ; \n} \n} \n"}
{"6854": "public class OreTaxonomyPrinter { \nprotected static void printDeclarations ( Taxonomy < ElkClass > classTaxonomy , ElkObject . Factory objectFactory , Appendable writer ) throws IOException { \nList < ElkClass > classes = new ArrayList < ElkClass > ( classTaxonomy . getNodes ( ) . size ( ) * 2 ) ; \nfor ( TaxonomyNode < ElkClass > classNode : classTaxonomy . getNodes ( ) ) { \nfor ( ElkClass clazz : classNode ) { \nif ( ! clazz . getIri ( ) . equals ( PredefinedElkIris . OWL_THING ) ) { \nif ( ! clazz . getIri ( ) . equals ( PredefinedElkIris . OWL_NOTHING ) ) { \nclasses . add ( clazz ) ; \n} \n} \n} \n} \nCollections . sort ( classes , CLASS_COMPARATOR ) ; \nfor ( ElkClass clazz : classes ) { \nElkDeclarationAxiom decl = objectFactory . getDeclarationAxiom ( clazz ) ; \nOwlFunctionalStylePrinter . append ( writer , decl , true ) ; \nwriter . append ( '\\n' ) ; \n} \n} \n} \n"}
{"6861": "public class TaxonomyPrinter { \nprotected static < T extends ElkEntity > void processTaxomomy ( final Taxonomy < T > taxonomy , final Appendable writer ) throws IOException { \nfinal ElkObject . Factory factory = new ElkObjectEntityRecyclingFactory ( ) ; \nfinal List < T > members = new ArrayList < T > ( taxonomy . getNodes ( ) . size ( ) * 2 ) ; \nfor ( final TaxonomyNode < T > node : taxonomy . getNodes ( ) ) { \nfor ( final T member : node ) { \nif ( ! member . getIri ( ) . equals ( taxonomy . getTopNode ( ) . getCanonicalMember ( ) . getIri ( ) ) ) { \nif ( ! member . getIri ( ) . equals ( taxonomy . getBottomNode ( ) . getCanonicalMember ( ) . getIri ( ) ) ) { \nmembers . add ( member ) ; \n} \n} \n} \n} \nCollections . sort ( members , taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nprintDeclarations ( members , factory , writer ) ; \nfinal TreeSet < T > canonicalMembers = new TreeSet < T > ( taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nfor ( final TaxonomyNode < T > node : taxonomy . getNodes ( ) ) { \ncanonicalMembers . add ( node . getCanonicalMember ( ) ) ; \n} \nfor ( final T canonicalMember : canonicalMembers ) { \nfinal TaxonomyNode < T > node = taxonomy . getNode ( canonicalMember ) ; \nfinal ArrayList < T > orderedEquivalentMembers = new ArrayList < T > ( node . size ( ) ) ; \nfor ( final T member : node ) { \norderedEquivalentMembers . add ( member ) ; \n} \nCollections . sort ( orderedEquivalentMembers , taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nfinal TreeSet < T > orderedSuperMembers = new TreeSet < T > ( taxonomy . getKeyProvider ( ) . getComparator ( ) ) ; \nfor ( final TaxonomyNode < T > superNode : node . getDirectSuperNodes ( ) ) { \norderedSuperMembers . add ( superNode . getCanonicalMember ( ) ) ; \n} \nprintMemberAxioms ( canonicalMember , orderedEquivalentMembers , orderedSuperMembers , taxonomy , factory , writer ) ; \n} \n} \n} \n"}
{"6862": "public class ConcurrentComputationWithInputs { \npublic synchronized boolean submit ( I input ) throws InterruptedException { \nif ( termination ) return false ; \nelse if ( isInterrupted ( ) ) return false ; \nbuffer_ . put ( input ) ; \nreturn true ; \n} \n} \n"}
{"6864": "public class ClassExpressionQueryState { \nprivate QueryState markNotComputed ( final IndexedClassExpression queryClass ) { \nfinal QueryState state = indexed_ . get ( queryClass ) ; \nif ( state == null ) { \nreturn null ; \n} \nelse if ( ! state . isComputed ) { \nreturn null ; \n} \nstate . isComputed = false ; \nif ( state . node != null ) { \nremoveAllRelated ( queryClass , state . node ) ; \nstate . node = null ; \n} \nreturn state ; \n} \n} \n"}
{"6866": "public class AbstractMatch { \nprotected static void checkChainMatch ( final ElkSubObjectPropertyExpression fullChain , final int startPos ) { \nfullChain . accept ( new ElkSubObjectPropertyExpressionVisitor < Void > ( ) { \nvoid fail ( ) { \nthrow new IllegalArgumentException ( fullChain + \", \" + startPos ) ; \n} \nVoid defaultVisit ( ElkObjectPropertyExpression expression ) { \nif ( startPos != 0 ) { \nfail ( ) ; \n} \nreturn null ; \n} \n@ Override public Void visit ( ElkObjectPropertyChain expression ) { \nif ( startPos < 0 ) fail ( ) ; \nelse if ( startPos >= expression . getObjectPropertyExpressions ( ) . size ( ) ) fail ( ) ; \nreturn null ; \n} \n@ Override public Void visit ( ElkObjectInverseOf expression ) { \nreturn defaultVisit ( expression ) ; \n} \n@ Override public Void visit ( ElkObjectProperty expression ) { \nreturn defaultVisit ( expression ) ; \n} \n} \n) ; \n} \n} \n"}
{"6869": "public class ArraySlicedSet { \npublic boolean add ( int s , E e ) { \nif ( e == null ) throw new NullPointerException ( ) ; \nint mask = ( 1 << s ) ; \nint oldMask = addMask ( logs , data , masks , e , mask ) ; \nint newMask = oldMask | mask ; \nif ( newMask == oldMask ) return false ; \nelse if ( oldMask == 0 ) { \nif ( ++ occupied == LinearProbing . getUpperSize ( data . length ) ) enlarge ( ) ; \n} \nsizes [ s ] ++ ; \nreturn true ; \n} \n} \n"}
{"6870": "public class ArraySlicedSet { \npublic boolean remove ( int s , Object o ) { \nif ( o == null ) throw new NullPointerException ( ) ; \nint mask = 1 << s ; \nint oldMask = removeMask ( logs , data , masks , o , mask ) ; \nint newMask = oldMask & ~ mask ; \nif ( newMask == oldMask ) return false ; \nif ( newMask == 0 ) { \nif ( -- occupied == LinearProbing . getLowerSize ( data . length ) ) shrink ( ) ; \n} \nsizes [ s ] -- ; \nreturn true ; \n} \n} \n"}
{"6918": "public class Xform { \n@ SuppressWarnings ( \"unchecked\" ) private static < H > H _fold ( Iterable source , Operation [ ] ops , int opIdx , H ident , Fn2 reducer ) { \nObject ret = ident ; \nsourceLoop : for ( Object o : source ) { \nfor ( int j = opIdx ; \nj < ops . length ; \nj ++ ) { \nOperation op = ops [ j ] ; \nif ( op . filter != null ) { \nif ( ! op . filter . apply ( o ) ) { \ncontinue sourceLoop ; \n} \n} \nif ( op . map != null ) { \no = op . map . apply ( o ) ; \nif ( o == TERMINATE ) { \nreturn ( H ) ret ; \n} \n} \nelse if ( op . flatMap != null ) { \nret = _fold ( op . flatMap . apply ( o ) , ops , j + 1 , ( H ) ret , reducer ) ; \ncontinue sourceLoop ; \n} \n} \nret = reducer . apply ( ret , o ) ; \n} \nreturn ( H ) ret ; \n} \n} \n"}
{"6929": "public class StaticImports { \n@ SafeVarargs public static < T > ImSet < T > set ( T ... items ) { \nif ( items == null ) { \nreturn PersistentHashSet . empty ( ) ; \n} \nelse if ( items . length < 1 ) { \nreturn PersistentHashSet . empty ( ) ; \n} \nreturn PersistentHashSet . of ( Arrays . asList ( items ) ) ; \n} \n} \n"}
{"6930": "public class StaticImports { \n@ SafeVarargs static public < T > ImList < T > vec ( T ... items ) { \nif ( items == null ) { \nreturn PersistentVector . empty ( ) ; \n} \nelse if ( items . length < 1 ) { \nreturn PersistentVector . empty ( ) ; \n} \nreturn mutableVec ( items ) . immutable ( ) ; \n} \n} \n"}
{"6938": "public class SleeTransactionImpl { \nprivate void suspendIfAssoaciatedWithThread ( ) throws SystemException { \nfinal SleeTransaction currentThreadTransaction = transactionManager . getSleeTransaction ( ) ; \nif ( currentThreadTransaction != null ) { \nif ( currentThreadTransaction . equals ( this ) ) { \ntransactionManager . getRealTransactionManager ( ) . suspend ( ) ; \n} \n} \n} \n} \n"}
{"6939": "public class SleeTransactionImpl { \nprivate void beforeAsyncOperation ( ) throws IllegalStateException , SecurityException { \ntry { \nint status = transaction . getStatus ( ) ; \nif ( asyncOperationInitiated . getAndSet ( true ) ) { \nthrow new IllegalStateException ( \"There is no active tx, tx is in state: \" + status ) ; \n} \nelse if ( status != Status . STATUS_ACTIVE && status != Status . STATUS_MARKED_ROLLBACK ) { \nthrow new IllegalStateException ( \"There is no active tx, tx is in state: \" + status ) ; \n} \nsuspendIfAssoaciatedWithThread ( ) ; \n} \ncatch ( SystemException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"6951": "public class ServiceManagementImpl { \npublic boolean isRAEntityLinkNameReferenced ( String raLinkName ) { \nif ( raLinkName == null ) { \nthrow new NullPointerException ( \"null ra link name\" ) ; \n} \nboolean b = false ; \ntry { \nb = transactionManager . requireTransaction ( ) ; \nfor ( ServiceID serviceID : componentRepositoryImpl . getServiceIDs ( ) ) { \nServiceComponent serviceComponent = componentRepositoryImpl . getComponentByID ( serviceID ) ; \nif ( serviceComponent . getServiceState ( ) != ServiceState . INACTIVE ) { \nif ( serviceComponent . getResourceAdaptorEntityLinks ( componentRepositoryImpl ) . contains ( raLinkName ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \nfinally { \ntry { \ntransactionManager . requireTransactionEnd ( b , false ) ; \n} \ncatch ( Throwable ex ) { \nthrow new SLEEException ( ex . getMessage ( ) , ex ) ; \n} \n} \n} \n} \n"}
{"6964": "public class NextSbbEntityFinder { \npublic Result next ( ActivityContext ac , EventContext sleeEvent , Set < SbbEntityID > sbbEntitiesThatHandledCurrentEvent , SleeContainer sleeContainer ) { \nSbbEntityID sbbEntityId = null ; \nSbbEntity sbbEntity = null ; \nEventEntryDescriptor mEventEntry = null ; \nfor ( Iterator < SbbEntityID > iter = ac . getSortedSbbAttachmentSet ( sbbEntitiesThatHandledCurrentEvent ) . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nsbbEntityId = iter . next ( ) ; \nsbbEntity = sleeContainer . getSbbEntityFactory ( ) . getSbbEntity ( sbbEntityId , true ) ; \nif ( sbbEntity == null ) { \ncontinue ; \n} \nif ( eventRouterConfiguration . isConfirmSbbEntityAttachement ( ) ) { \nif ( ! sbbEntity . isAttached ( ac . getActivityContextHandle ( ) ) ) { \ncontinue ; \n} \n} \nif ( sleeEvent . getService ( ) != null ) { \nif ( ! sleeEvent . getService ( ) . equals ( sbbEntityId . getServiceID ( ) ) ) { \nif ( ! sleeEvent . isActivityEndEvent ( ) ) { \ncontinue ; \n} \nelse { \nreturn new Result ( sbbEntity , false ) ; \n} \n} \n} \nmEventEntry = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getEventEntries ( ) . get ( sleeEvent . getEventTypeId ( ) ) ; \nif ( mEventEntry != null && mEventEntry . isReceived ( ) ) { \nreturn new Result ( sbbEntity , true ) ; \n} \nelse { \nif ( ! sleeEvent . isActivityEndEvent ( ) ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Event is not received by sbb descriptor of entity \" + sbbEntityId + \", will not deliver event to sbb entity ...\" ) ; \n} \ncontinue ; \n} \nelse { \nreturn new Result ( sbbEntity , false ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6985": "public class UsageMBeanImpl { \npublic void sendUsageNotification ( long value , long seqno , String usageParameterSetName , String usageParameterName , boolean isCounter ) { \nUsageNotificationManagerMBeanImpl notificationManager = parent . getUsageNotificationManagerMBean ( notificationSource ) ; \nif ( notificationManager == null ) { \nUsageNotification notification = createUsageNotification ( value , seqno , usageParameterSetName , usageParameterName , isCounter ) ; \nfor ( ListenerFilterHandbackTriplet triplet : listeners . values ( ) ) { \nif ( triplet . notificationFilter == null ) { \ntriplet . notificationListener . handleNotification ( notification , triplet . handbackObject ) ; \n} \nelse if ( triplet . notificationFilter . isNotificationEnabled ( notification ) ) { \ntriplet . notificationListener . handleNotification ( notification , triplet . handbackObject ) ; \n} \n} \n} \nelse if ( notificationManager . getNotificationsEnabled ( usageParameterName ) ) { \nUsageNotification notification = createUsageNotification ( value , seqno , usageParameterSetName , usageParameterName , isCounter ) ; \nfor ( ListenerFilterHandbackTriplet triplet : listeners . values ( ) ) { \nif ( triplet . notificationFilter == null || triplet . notificationFilter . isNotificationEnabled ( notification ) ) { \ntriplet . notificationListener . handleNotification ( notification , triplet . handbackObject ) ; \n} \n} \n} \n} \n} \n"}
{"7002": "public class ResourceAdaptorEntityImpl { \npublic void sleeStopping ( ) throws InvalidStateException , TransactionRequiredLocalException { \nif ( state != null ) { \nif ( state . isActive ( ) ) { \ntry { \nobject . raStopping ( ) ; \n} \ncatch ( Throwable t ) { \nlogger . error ( \"Got exception from RA object\" , t ) ; \n} \nscheduleAllActivitiesEnd ( ) ; \n} \n} \n} \n} \n"}
{"7010": "public class ResourceAdaptorEntityImpl { \npublic void activityEnded ( final ActivityHandle handle , int activityFlags ) { \nlogger . trace ( \"activityEnded( handle = \" + handle + \" )\" ) ; \nActivityHandle ah = null ; \nif ( handle instanceof ActivityHandleReference ) { \nah = resourceManagement . getHandleReferenceFactory ( ) . removeActivityHandleReference ( ( ActivityHandleReference ) handle ) ; \n} \nelse { \nah = handle ; \n} \nif ( ah != null ) { \nif ( ActivityFlags . hasRequestEndedCallback ( activityFlags ) ) { \nobject . activityEnded ( ah ) ; \n} \n} \nif ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) { \nsynchronized ( this ) { \nif ( ! hasActivities ( ) ) { \nif ( timerTask != null ) { \ntimerTask . cancel ( ) ; \n} \nallActivitiesEnded ( ) ; \n} \n} \n} \n} \n} \n"}
{"7018": "public class ProfileSpecificationComponentImpl { \nprivate void buildProfileAttributeMap ( ) throws DeploymentException { \nHashMap < String , ProfileAttribute > map = new HashMap < String , ProfileAttribute > ( ) ; \nClass < ? > cmpInterface = getProfileCmpInterfaceClass ( ) ; \nString attributeGetterMethodPrefix = \"get\" ; \nfor ( Method method : cmpInterface . getMethods ( ) ) { \nif ( ! method . getDeclaringClass ( ) . equals ( Object . class ) ) { \nif ( method . getName ( ) . startsWith ( attributeGetterMethodPrefix ) ) { \nString attributeName = method . getName ( ) . substring ( attributeGetterMethodPrefix . length ( ) ) ; \nswitch ( attributeName . length ( ) ) { \ncase 0 : throw new DeploymentException ( \"the profile cmp interface class has an invalid attribute getter method name > \" + method . getName ( ) ) ; \ncase 1 : attributeName = attributeName . toLowerCase ( ) ; \nbreak ; \ndefault : attributeName = attributeName . substring ( 0 , 1 ) . toLowerCase ( ) + attributeName . substring ( 1 ) ; \nbreak ; \n} \nProfileAttributeImpl profileAttribute = null ; \ntry { \nprofileAttribute = new ProfileAttributeImpl ( attributeName , method . getReturnType ( ) ) ; \n} \ncatch ( Throwable e ) { \nthrow new DeploymentException ( \"Invalid profile cmp interface attribute getter method definition ( name = \" + attributeName + \" , type = \" + method . getReturnType ( ) + \" )\" , e ) ; \n} \nif ( isSlee11 ( ) ) { \nfor ( ProfileCMPFieldDescriptor cmpField : getDescriptor ( ) . getProfileCMPInterface ( ) . getCmpFields ( ) ) { \nif ( cmpField . getCmpFieldName ( ) . equals ( attributeName ) ) { \nprofileAttribute . setUnique ( cmpField . isUnique ( ) ) ; \n} \n} \n} \nelse { \nfor ( ProfileIndexDescriptor profileIndex : getDescriptor ( ) . getIndexedAttributes ( ) ) { \nif ( profileIndex . getName ( ) . equals ( attributeName ) ) { \nprofileAttribute . setIndex ( true ) ; \nprofileAttribute . setUnique ( profileIndex . getUnique ( ) ) ; \n} \n} \n} \nmap . put ( attributeName , profileAttribute ) ; \n} \n} \n} \nprofileAttributeMap = Collections . unmodifiableMap ( map ) ; \n} \n} \n"}
{"7025": "public class SbbAbstractMethodHandler { \npublic static void fireEvent ( SbbEntity sbbEntity , EventTypeID eventTypeID , Object eventObject , ActivityContextInterface aci , Address address , ServiceID serviceID ) { \nif ( sleeContainer . getCongestionControl ( ) . refuseFireEvent ( ) ) { \nthrow new SLEEException ( \"congestion control refused event\" ) ; \n} \nif ( sbbEntity == null || sbbEntity . getSbbObject ( ) == null ) throw new IllegalStateException ( \"SbbObject not assigned!\" ) ; \nelse if ( sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) throw new IllegalStateException ( \"SbbObject not assigned!\" ) ; \nif ( eventObject == null ) throw new NullPointerException ( \"JAIN SLEE (TM) specs - Section 8.4.1: The event ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException.\" ) ; \nif ( aci == null ) throw new NullPointerException ( \"JAIN SLEE (TM) specs - Section 8.4.1: The activity ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException.\" ) ; \nfinal SleeTransactionManager txManager = sleeContainer . getTransactionManager ( ) ; \ntxManager . mandateTransaction ( ) ; \nActivityContext ac = ( ( org . mobicents . slee . container . activity . ActivityContextInterface ) aci ) . getActivityContext ( ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"invoke(): firing event on \" + ac ) ; \n} \nif ( ac . isEnding ( ) ) { \nthrow new IllegalStateException ( \"activity context \" + ac . getActivityContextHandle ( ) + \" is ending\" ) ; \n} \nfinal EventRoutingTransactionData transactionData = txManager . getTransactionContext ( ) . getEventRoutingTransactionData ( ) ; \nif ( transactionData != null ) { \nfinal EventContext eventBeingDelivered = transactionData . getEventBeingDelivered ( ) ; \nif ( eventBeingDelivered != null ) { \nif ( eventBeingDelivered . getEvent ( ) == eventObject ) { \nac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , eventBeingDelivered ) ; \nreturn ; \n} \n} \n} \nac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , null , null , null ) ; \n} \n} \n"}
{"7052": "public class SbbObjectPoolManagementImpl { \npublic void createObjectPool ( final ServiceID serviceID , final SbbComponent sbbComponent , final SleeTransactionManager sleeTransactionManager ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Creating Pool for  \" + serviceID + \" and \" + sbbComponent ) ; \n} \ncreateObjectPool ( serviceID , sbbComponent ) ; \nif ( sleeTransactionManager != null ) { \nif ( sleeTransactionManager . getTransactionContext ( ) != null ) { \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Due to tx rollback, removing pool for \" + serviceID + \" and \" + sbbComponent ) ; \n} \ntry { \nremoveObjectPool ( serviceID , sbbComponent . getSbbID ( ) ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( \"Failed to remove \" + serviceID + \" and \" + sbbComponent + \" object pool\" , e ) ; \n} \n} \n} \n; \nsleeTransactionManager . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( action ) ; \n} \n} \n} \n} \n"}
{"7054": "public class SleeEndpointImpl { \nActivityContextHandle _startActivity ( ActivityHandle handle , int activityFlags , final SleeTransaction barrierTx ) { \nActivityContext ac = null ; \nif ( raEntity . getHandleReferenceFactory ( ) != null && ! ActivityFlags . hasSleeMayMarshal ( activityFlags ) ) { \nfinal ActivityHandleReference reference = raEntity . getHandleReferenceFactory ( ) . createActivityHandleReference ( handle ) ; \ntry { \nac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , reference ) , activityFlags ) ; \n} \ncatch ( ActivityAlreadyExistsException e ) { \nthrow e ; \n} \ncatch ( RuntimeException e ) { \nraEntity . getHandleReferenceFactory ( ) . removeActivityHandleReference ( reference ) ; \nthrow e ; \n} \n} \nelse { \nac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) , activityFlags ) ; \n} \nif ( barrierTx != null ) { \nif ( ac != null ) { \nfinal ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; \naeqm . createBarrier ( barrierTx ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \naeqm . removeBarrier ( barrierTx ) ; \n} \n} \n; \nfinal TransactionContext tc = barrierTx . getTransactionContext ( ) ; \ntc . getAfterCommitActions ( ) . add ( action ) ; \ntc . getAfterRollbackActions ( ) . add ( action ) ; \n} \n} \nreturn ac . getActivityContextHandle ( ) ; \n} \n} \n"}
{"7056": "public class SleeEndpointImpl { \nprivate void checkFireEventPreconditions ( ActivityHandle handle , FireableEventType eventType , Object event ) throws NullPointerException , IllegalEventException , IllegalStateException { \nif ( event == null ) throw new NullPointerException ( \"event is null\" ) ; \nif ( handle == null ) throw new NullPointerException ( \"handle is null\" ) ; \nif ( eventType == null ) { \nthrow new NullPointerException ( \"eventType is null\" ) ; \n} \nfinal EventTypeComponent eventTypeComponent = componentRepository . getComponentByID ( eventType . getEventType ( ) ) ; \nif ( eventTypeComponent == null ) { \nthrow new IllegalEventException ( \"event type not installed (more on SLEE 1.1 specs 15.14.8)\" ) ; \n} \nif ( ! eventTypeComponent . getEventTypeClass ( ) . isAssignableFrom ( event . getClass ( ) ) ) { \nthrow new IllegalEventException ( \"the class of the event object fired is not assignable to the event class of the event type (more on SLEE 1.1 specs 15.14.8) \" ) ; \n} \nif ( eventType . getClass ( ) != FireableEventTypeImpl . class ) { \nthrow new IllegalEventException ( \"unknown implementation of FireableEventType\" ) ; \n} \nif ( raEntity . getAllowedEventTypes ( ) != null ) { \nif ( ! raEntity . getAllowedEventTypes ( ) . contains ( eventType . getEventType ( ) ) ) { \nthrow new IllegalEventException ( \"Resource Adaptor configured to not ignore ra type event checking and the event \" + eventType . getEventType ( ) + \" does not belongs to any of the ra types implemented by the resource adaptor\" ) ; \n} \n} \n} \n} \n"}
{"7062": "public class DeployableUnitInstallPanel { \nprivate String extractMessage ( String result ) { \nString startPreTag = \"<pre>\" ; \nString endPreTag = \"</pre>\" ; \nresult = result . trim ( ) ; \nif ( result . startsWith ( startPreTag ) ) { \nif ( result . endsWith ( endPreTag ) ) { \nresult = result . substring ( startPreTag . length ( ) , result . length ( ) - endPreTag . length ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7069": "public class ProfileCallRecorderTransactionData { \n@ SuppressWarnings ( \"unchecked\" ) public static void addProfileCall ( ProfileObjectImpl po ) throws SLEEException { \nSleeTransactionManager sleeTransactionManager = sleeContainer . getTransactionManager ( ) ; \ntry { \nif ( sleeTransactionManager . getTransaction ( ) == null ) { \nreturn ; \n} \n} \ncatch ( SystemException se ) { \nthrow new SLEEException ( \"Unable to verify SLEE Transaction.\" , se ) ; \n} \nString key = makeKey ( po ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Recording call to profile. Key[\" + key + \"]\" ) ; \n} \nfinal TransactionContext txContext = sleeTransactionManager . getTransactionContext ( ) ; \nProfileCallRecorderTransactionData data = ( ProfileCallRecorderTransactionData ) txContext . getData ( ) . get ( TRANSACTION_CONTEXT_KEY ) ; \nif ( data == null ) { \ndata = new ProfileCallRecorderTransactionData ( ) ; \ntxContext . getData ( ) . put ( TRANSACTION_CONTEXT_KEY , data ) ; \n} \nif ( ! po . isProfileReentrant ( ) ) { \nif ( data . invokedProfiles . contains ( key ) ) { \nif ( data . invokedProfiles . getLast ( ) . compareTo ( key ) != 0 ) { \nthrow new SLEEException ( \"Detected loopback call. Call sequence: \" + data . invokedProfiles ) ; \n} \n} \ndata . invokedProfiles . add ( key ) ; \ndata . invokedProfileTablesNames . add ( po . getProfileTable ( ) . getProfileTableName ( ) ) ; \n} \n} \n} \n"}
{"7074": "public class ConcreteActivityContextInterfaceGenerator { \nprivate void generateConcreteMethods ( Map interfaceMethods ) { \nif ( interfaceMethods == null ) return ; \nIterator it = interfaceMethods . values ( ) . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nCtMethod interfaceMethod = ( CtMethod ) it . next ( ) ; \nif ( interfaceMethod != null ) { \nif ( interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( javax . slee . ActivityContextInterface . class . getName ( ) ) || interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( ActivityContextInterfaceExt . class . getName ( ) ) ) continue ; \n} \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( interfaceMethod , concreteActivityContextInterface , null ) ; \nString fieldName = interfaceMethod . getName ( ) . substring ( 3 ) ; \nfieldName = fieldName . substring ( 0 , 1 ) . toLowerCase ( ) + fieldName . substring ( 1 ) ; \nString concreteMethodBody = null ; \nif ( interfaceMethod . getName ( ) . startsWith ( \"get\" ) ) { \nconcreteMethodBody = \"{ return ($r)getFieldValue(\\\"\" + fieldName + \"\\\",\" + concreteMethod . getReturnType ( ) . getName ( ) + \".class); }\" ; \n} \nelse if ( interfaceMethod . getName ( ) . startsWith ( \"set\" ) ) { \nconcreteMethodBody = \"{ setFieldValue(\\\"\" + fieldName + \"\\\",$1); }\" ; \n} \nelse { \nthrow new SLEEException ( \"unexpected method name <\" + interfaceMethod . getName ( ) + \"> to implement in sbb aci interface\" ) ; \n} \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + interfaceMethod . getName ( ) + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nconcreteActivityContextInterface . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception cce ) { \nthrow new SLEEException ( \"Cannot compile method \" + interfaceMethod . getName ( ) , cce ) ; \n} \n} \n} \n} \n"}
{"7078": "public class ActivityContextImpl { \npublic boolean removeNameBinding ( String aciName ) { \nboolean removed = cacheData . nameUnbound ( aciName ) ; \nif ( removed ) { \nif ( acReferencesHandler != null ) { \nacReferencesHandler . nameReferenceRemoved ( ) ; \n} \n} \nreturn removed ; \n} \n} \n"}
{"7082": "public class ActivityContextImpl { \npublic void detachSbbEntity ( SbbEntityID sbbEntityId ) throws javax . slee . TransactionRequiredLocalException { \nboolean detached = cacheData . detachSbbEntity ( sbbEntityId ) ; \nif ( detached && acReferencesHandler != null ) { \nif ( ! isEnding ( ) ) { \nacReferencesHandler . sbbeReferenceRemoved ( ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Detached sbb entity \" + sbbEntityId + \" from AC with handle \" + getActivityContextHandle ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"7085": "public class DeployableUnit { \npublic void addComponent ( DeployableComponent dc ) { \nif ( logger . isTraceEnabled ( ) ) logger . trace ( \"Adding Component \" + dc . getComponentKey ( ) ) ; \ncomponents . add ( dc ) ; \ncomponentIDs . add ( dc . getComponentKey ( ) ) ; \ndependencies . addAll ( dc . getDependencies ( ) ) ; \ninstallActions . addAll ( dc . getInstallActions ( ) ) ; \nCollection < ManagementAction > postInstallActionsStrings = postInstallActions . remove ( dc . getComponentKey ( ) ) ; \nif ( postInstallActionsStrings != null ) { \nif ( ! postInstallActionsStrings . isEmpty ( ) ) { \ninstallActions . addAll ( postInstallActionsStrings ) ; \n} \n} \nCollection < ManagementAction > preUninstallActionsStrings = preUninstallActions . remove ( dc . getComponentKey ( ) ) ; \nif ( preUninstallActionsStrings != null ) uninstallActions . addAll ( preUninstallActionsStrings ) ; \nuninstallActions . addAll ( dc . getUninstallActions ( ) ) ; \n} \n} \n"}
{"7110": "public class SbbAbstractClassDecorator { \npublic boolean decorateAbstractSbb ( ) throws DeploymentException { \nClassPool pool = component . getClassPool ( ) ; \nString sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; \ntry { \nsbbAbstractClass = pool . get ( sbbAbstractClassName ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find Abstract Sbb Class: \" + sbbAbstractClassName , nfe ) ; \n} \nconcreteMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nint mods = methods [ i ] . getModifiers ( ) ; \nif ( ! Modifier . isAbstract ( mods ) ) { \nif ( ! Modifier . isNative ( mods ) ) { \nconcreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; \n} \n} \n} \ndecorateENCBindCalls ( ) ; \ndecorateNewThreadCalls ( ) ; \nif ( isAbstractSbbClassDecorated ) { \ntry { \nString deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nsbbAbstractClass . writeFile ( deployDir ) ; \nsbbAbstractClass . detach ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Modified Abstract Class \" + sbbAbstractClass . getName ( ) + \" generated in the following path \" + deployDir ) ; \n} \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nfinally { \nsbbAbstractClass . defrost ( ) ; \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"7117": "public class ProfileObjectImpl { \npublic void unsetProfileContext ( ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"[unsetProfileContext] \" + this ) ; \n} \nif ( state == ProfileObjectState . POOLED ) { \nif ( profileConcreteClassInfo . isInvokeUnsetProfileContext ( ) ) { \nfinal ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; \ntry { \nfinal ClassLoader cl = profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; \nif ( System . getSecurityManager ( ) != null ) { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \nreturn null ; \n} \n} \n) ; \n} \nelse { \nThread . currentThread ( ) . setContextClassLoader ( cl ) ; \n} \nif ( isSlee11 ) { \ntry { \nprofileConcrete . unsetProfileContext ( ) ; \n} \ncatch ( RuntimeException e ) { \nruntimeExceptionOnProfileInvocation ( e ) ; \n} \n} \nprofileContext . setProfileObject ( null ) ; \nstate = ProfileObjectState . DOES_NOT_EXIST ; \n} \nfinally { \nif ( System . getSecurityManager ( ) != null ) { \nAccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { \npublic Object run ( ) { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \nreturn null ; \n} \n} \n) ; \n} \nelse { \nThread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7119": "public class ProfileObjectImpl { \npublic void fireAddOrUpdatedEventIfNeeded ( ) { \nif ( state == ProfileObjectState . READY ) { \nif ( profileEntity . isDirty ( ) ) { \nif ( profileTable . doesFireEvents ( ) && profileEntity . getProfileName ( ) != null ) { \nif ( profileTable . getSleeContainer ( ) . getSleeState ( ) == SleeState . RUNNING ) { \nActivityContext ac = profileTable . getActivityContext ( ) ; \nAbstractProfileEvent event = null ; \nif ( profileEntity . isCreate ( ) ) { \nif ( persisted ) { \nevent = new ProfileAddedEventImpl ( profileEntity , profileTable . getProfileManagement ( ) ) ; \npersisted = false ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"firing profile added event for profile named \" + profileEntity ) ; \n} \n} \nelse { \nreturn ; \n} \n} \nelse { \nevent = new ProfileUpdatedEventImpl ( profileEntitySnapshot , profileEntity , profileTable . getProfileManagement ( ) ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"firing profile updated event for profile named \" + profileEntity ) ; \n} \n} \nac . fireEvent ( event . getEventTypeID ( ) , event , event . getProfileAddress ( ) , null , null , null , null ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7121": "public class ClassGeneratorUtils { \npublic static CtClass createClass ( String className , String [ ] interfaces ) throws Exception { \nif ( className == null ) { \nthrow new NullPointerException ( \"Class name cannot be null\" ) ; \n} \nCtClass clazz = classPool . makeClass ( className ) ; \nif ( interfaces != null ) { \nif ( interfaces . length > 0 ) { \nclazz . setInterfaces ( classPool . get ( interfaces ) ) ; \n} \n} \nreturn clazz ; \n} \n} \n"}
{"7122": "public class ClassGeneratorUtils { \npublic static void createInheritanceLink ( CtClass concreteClass , String superClassName ) { \nif ( superClassName != null ) { \nif ( superClassName . length ( ) >= 0 ) { \ntry { \nconcreteClass . setSuperclass ( classPool . get ( superClassName ) ) ; \n} \ncatch ( CannotCompileException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( NotFoundException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n} \n} \n"}
{"7129": "public class SleeEndpointStartActivityNotTransactedExecutor { \nvoid execute ( final ActivityHandle handle , final int activityFlags , boolean suspendActivity ) throws SLEEException { \nfinal SleeTransaction tx = super . suspendTransaction ( ) ; \nActivityContextHandle ach = null ; \ntry { \nach = sleeEndpoint . _startActivity ( handle , activityFlags , suspendActivity ? tx : null ) ; \n} \nfinally { \nif ( tx != null ) { \nsuper . resumeTransaction ( tx ) ; \nif ( ach != null ) { \nif ( ActivityFlags . hasRequestSleeActivityGCCallback ( activityFlags ) ) { \nacFactory . getActivityContext ( ach ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7130": "public class ClassUtils { \npublic static Class checkInterfaces ( Class classOrInterfaceWithInterfaces , String interfaceSearched ) { \nClass returnValue = null ; \nif ( classOrInterfaceWithInterfaces . getName ( ) . compareTo ( interfaceSearched ) == 0 ) { \nreturn classOrInterfaceWithInterfaces ; \n} \nfor ( Class iface : classOrInterfaceWithInterfaces . getInterfaces ( ) ) { \nif ( iface . getName ( ) . compareTo ( interfaceSearched ) == 0 ) { \nreturnValue = iface ; \n} \nelse { \nreturnValue = checkInterfaces ( iface , interfaceSearched ) ; \n} \nif ( returnValue != null ) break ; \n} \nif ( ! classOrInterfaceWithInterfaces . isInterface ( ) ) { \nif ( returnValue == null ) { \nClass superClass = classOrInterfaceWithInterfaces . getSuperclass ( ) ; \nif ( superClass != null ) { \nreturnValue = checkInterfaces ( superClass , interfaceSearched ) ; \n} \n} \n} \nreturn returnValue ; \n} \n} \n"}
{"7133": "public class TraceMBeanImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { \nif ( tracerName . compareTo ( \"\" ) == 0 ) { \nreturn ; \n} \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nint fqdnPartIndex = 0 ; \nString lastToken = null ; \nwhile ( stringTokenizer . hasMoreTokens ( ) ) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) { \nlastToken = token ; \n} \nif ( lastToken . compareTo ( token ) == 0 ) { \nif ( token . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \nif ( token . compareTo ( \".\" ) != 0 ) { \nfor ( int charIndex = 0 ; \ncharIndex < token . length ( ) ; \ncharIndex ++ ) { \nCharacter c = token . charAt ( charIndex ) ; \nif ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { \n} \nelse { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \" Token[\" + token + \"], name for source: \" + notificationSource + \", is illegal, contains illegal character: \" + charIndex ) ; \n} \n} \nfqdnPartIndex ++ ; \n} \nlastToken = token ; \n} \nif ( lastToken . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \n} \n"}
{"7152": "public class TracerImpl { \nvoid syncLevelWithLog4j ( ) { \nLevel log4jLevel = parent == null ? logger . getEffectiveLevel ( ) : logger . getLevel ( ) ; \nif ( level == null ) { \nassignLog4JLevel ( log4jLevel ) ; \n} \nelse { \nif ( tracerToLog4JLevel ( level ) != log4jLevel ) { \nassignLog4JLevel ( log4jLevel ) ; \n} \n} \nif ( parent == null ) { \nif ( level == null ) { \nlogger . setLevel ( Level . INFO ) ; \nlevel = TraceLevel . INFO ; \n} \n} \nresetCacheFlags ( false ) ; \n} \n} \n"}
{"7156": "public class TracerImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws NullPointerException , InvalidArgumentException { \nif ( tracerName . equals ( \"\" ) ) { \nreturn ; \n} \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nString lastToken = null ; \nwhile ( stringTokenizer . hasMoreTokens ( ) ) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) { \nlastToken = token ; \n} \nif ( lastToken . equals ( token ) ) { \nif ( token . equals ( \".\" ) ) { \nthrow new InvalidArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \nlastToken = token ; \n} \nif ( lastToken . equals ( \".\" ) ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \n} \n"}
{"7170": "public class SleeContainer { \nprivate void validateStateTransition ( SleeState oldState , SleeState newState ) throws InvalidStateException { \nif ( oldState == SleeState . STOPPED ) { \nif ( newState == SleeState . STARTING ) { \nreturn ; \n} \n} \nelse if ( oldState == SleeState . STARTING ) { \nif ( newState == SleeState . RUNNING ) { \nreturn ; \n} \nelse if ( newState == SleeState . STOPPING ) { \nreturn ; \n} \n} \nelse if ( oldState == SleeState . RUNNING ) { \nif ( newState == SleeState . STOPPING ) { \nreturn ; \n} \n} \nelse if ( oldState == SleeState . STOPPING ) { \nif ( newState == SleeState . STOPPED ) { \nreturn ; \n} \n} \nthrow new InvalidStateException ( \"illegal slee state transition: \" + oldState + \" -> \" + newState ) ; \n} \n} \n"}
{"7178": "public class RegionRequest { \npublic Rectangle resolve ( Dimension imageDims ) throws ResolvingException { \nif ( square ) { \nif ( imageDims . width > imageDims . height ) { \nreturn new Rectangle ( ( imageDims . width - imageDims . height ) / 2 , 0 , imageDims . height , imageDims . height ) ; \n} \nelse if ( imageDims . height > imageDims . width ) { \nreturn new Rectangle ( 0 , ( imageDims . height - imageDims . width ) / 2 , imageDims . width , imageDims . width ) ; \n} \n} \nif ( absoluteBox == null ) { \nif ( relativeBox == null ) { \nreturn new Rectangle ( 0 , 0 , imageDims . width , imageDims . height ) ; \n} \n} \nRectangle rect ; \nif ( isRelative ( ) ) { \nrect = new Rectangle ( ( int ) Math . round ( relativeBox . x . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . y . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) , ( int ) Math . round ( relativeBox . w . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . h . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) ) ; \n} \nelse { \nrect = absoluteBox ; \n} \nif ( rect . x >= imageDims . width ) { \nthrow new ResolvingException ( \"X and Y must be smaller than the native width/height\" ) ; \n} \nelse if ( rect . y >= imageDims . height ) { \nthrow new ResolvingException ( \"X and Y must be smaller than the native width/height\" ) ; \n} \nif ( rect . x + rect . width > imageDims . width ) { \nrect . width = imageDims . width - rect . x ; \n} \nif ( rect . y + rect . height > imageDims . height ) { \nrect . height = imageDims . height - rect . y ; \n} \nreturn rect ; \n} \n} \n"}
{"7200": "public class ExceptionCollector { \nfinal void addException ( SQLException exception ) { \nif ( ! ( exception instanceof SQLTimeoutException ) ) { \nif ( ! ( exception instanceof SQLTransactionRollbackException ) ) { \ngetOrInit ( ) . offer ( exception ) ; \n} \n} \n} \n} \n"}
{"7211": "public class Reporter { \npublic static void setSystemInfo ( String key , String value ) { \nif ( systemInfoKeyMap . isEmpty ( ) ) { \nsystemInfoKeyMap . put ( key , false ) ; \n} \nelse if ( ! systemInfoKeyMap . containsKey ( key ) ) { \nsystemInfoKeyMap . put ( key , false ) ; \n} \nif ( systemInfoKeyMap . get ( key ) ) { \nreturn ; \n} \ngetExtentReport ( ) . setSystemInfo ( key , value ) ; \nsystemInfoKeyMap . put ( key , true ) ; \n} \n} \n"}
{"7238": "public class LevelDBKeyValueStore { \n@ Override public Map < byte [ ] , byte [ ] > loadAllByKeys ( Collection < byte [ ] > keys ) { \nif ( keys == null ) { \nreturn Collections . EMPTY_MAP ; \n} \nelse if ( keys . size ( ) == 0 ) { \nreturn Collections . EMPTY_MAP ; \n} \nMap < byte [ ] , byte [ ] > results = new LinkedHashMap < > ( keys . size ( ) ) ; \nDBIterator iterator = null ; \ntry { \niterator = database . iterator ( ) ; \niterator . seek ( keys . iterator ( ) . next ( ) ) ; \nwhile ( iterator . hasNext ( ) ) { \nfinal Map . Entry < byte [ ] , byte [ ] > next = iterator . next ( ) ; \nresults . put ( next . getKey ( ) , next . getValue ( ) ) ; \n} \n} \nfinally { \ntry { \nif ( iterator != null ) { \niterator . close ( ) ; \n} \n} \ncatch ( IOException e ) { \nExceptions . handle ( e ) ; \n} \n} \nreturn results ; \n} \n} \n"}
{"7264": "public class MessageUtils { \npublic static String generateLabelValue ( final String fieldName ) { \nfinal StringBuilder buffer = new StringBuilder ( fieldName . length ( ) * 2 ) ; \nclass GenerationCommand { \nboolean capNextChar = false ; \nboolean lastCharWasUpperCase = false ; \nboolean lastCharWasNumber = false ; \nboolean lastCharWasSpecial = false ; \nboolean shouldContinue = true ; \nchar [ ] chars = fieldName . toCharArray ( ) ; \nvoid processFieldName ( ) { \nfor ( int index = 0 ; \nindex < chars . length ; \nindex ++ ) { \nchar cchar = chars [ index ] ; \nshouldContinue = true ; \nprocessCharWasNumber ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessCharWasUpperCase ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessSpecialChars ( buffer , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \ncchar = processCapitalizeCommand ( cchar ) ; \ncchar = processFirstCharacterCheck ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nbuffer . append ( cchar ) ; \n} \n} \nprivate void processCharWasNumber ( StringBuilder buffer , int index , char cchar ) { \nif ( lastCharWasSpecial ) { \nreturn ; \n} \nif ( Character . isDigit ( cchar ) ) { \nif ( index != 0 ) { \nif ( ! lastCharWasNumber ) { \nbuffer . append ( ' ' ) ; \n} \n} \nlastCharWasNumber = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasNumber = false ; \n} \n} \nprivate char processFirstCharacterCheck ( final StringBuilder buffer , int index , char cchar ) { \nif ( index == 0 ) { \ncchar = Character . toUpperCase ( cchar ) ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nreturn cchar ; \n} \nprivate char processCapitalizeCommand ( char cchar ) { \nif ( capNextChar ) { \ncapNextChar = false ; \ncchar = Character . toUpperCase ( cchar ) ; \n} \nreturn cchar ; \n} \nprivate void processSpecialChars ( final StringBuilder buffer , char cchar ) { \nlastCharWasSpecial = false ; \nif ( cchar == '.' ) { \nbuffer . append ( ' ' ) ; \ncapNextChar = true ; \nlastCharWasSpecial = false ; \nthis . shouldContinue = false ; \n} \nelse if ( cchar == '_' ) { \nbuffer . append ( ' ' ) ; \ncapNextChar = true ; \nlastCharWasSpecial = false ; \nthis . shouldContinue = false ; \n} \n} \nprivate void processCharWasUpperCase ( final StringBuilder buffer , int index , char cchar ) { \nif ( Character . isUpperCase ( cchar ) ) { \nif ( index != 0 ) { \nif ( ! lastCharWasUpperCase ) { \nbuffer . append ( ' ' ) ; \n} \n} \nlastCharWasUpperCase = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasUpperCase = false ; \n} \n} \n} \nGenerationCommand gc = new GenerationCommand ( ) ; \ngc . processFieldName ( ) ; \nreturn buffer . toString ( ) . replace ( \"  \" , \" \" ) ; \n} \n} \n"}
{"7282": "public class Str { \npublic static String num ( Number count ) { \nif ( count == null ) { \nreturn \"\" ; \n} \nif ( count instanceof Double || count instanceof BigDecimal ) { \nString s = count . toString ( ) ; \nif ( idx ( s , 1 ) == '.' && s . length ( ) > 7 ) { \ns = slc ( s , 0 , 5 ) ; \nreturn s ; \n} \nelse { \nreturn s ; \n} \n} \nelse if ( count instanceof Integer || count instanceof Long || count instanceof Short ) { \nString s = count . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nCharBuf buf = CharBuf . create ( s . length ( ) ) ; \nint index = 0 ; \nfor ( char c : s . toCharArray ( ) ) { \nindex ++ ; \nbuf . add ( c ) ; \nif ( index % 3 == 0 ) { \nbuf . add ( ',' ) ; \n} \n} \nif ( buf . lastChar ( ) == ',' ) { \nbuf . removeLastChar ( ) ; \n} \ns = buf . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nreturn s ; \n} \nelse if ( count instanceof BigInteger ) { \nString s = count . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nCharBuf buf = CharBuf . create ( s . length ( ) ) ; \nint index = 0 ; \nfor ( char c : s . toCharArray ( ) ) { \nindex ++ ; \nbuf . add ( c ) ; \nif ( index % 3 == 0 ) { \nbuf . add ( ',' ) ; \n} \n} \nif ( buf . lastChar ( ) == ',' ) { \nbuf . removeLastChar ( ) ; \n} \ns = buf . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nreturn s ; \n} \nreturn count . toString ( ) ; \n} \n} \n"}
{"7283": "public class Sort { \npublic static Sort sorts ( Sort ... sorts ) { \nif ( sorts == null ) { \nreturn null ; \n} \nelse if ( sorts . length == 0 ) { \nreturn null ; \n} \nSort main = sorts [ 0 ] ; \nfor ( int index = 1 ; \nindex < sorts . length ; \nindex ++ ) { \nmain . then ( sorts [ index ] ) ; \n} \nreturn main ; \n} \n} \n"}
{"7293": "public class SortingInternal { \npublic static void sort ( List list , String sortBy , Map < String , FieldAccess > fields , boolean ascending , boolean nullsFirst ) { \ntry { \nif ( list == null ) { \nreturn ; \n} \nelse if ( list . size ( ) == 0 ) { \nreturn ; \n} \nObject o = list . get ( 0 ) ; \nif ( sortBy . equals ( \"this\" ) ) { \nCollections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nCollections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \ncatch ( Exception ex ) { \nExceptions . handle ( ex , \"list\" , list , \"\\nsortBy\" , sortBy , \"fields\" , fields , \"ascending\" , ascending , \"nullFirst\" , nullsFirst ) ; \n} \n} \n} \n"}
{"7299": "public class Fields { \npublic static boolean classHasStringField ( Class < ? > clz , String name ) { \nList < Field > fields = Reflection . getAllFields ( clz ) ; \nfor ( Field field : fields ) { \nif ( field . getType ( ) . equals ( Typ . string ) && field . getName ( ) . equals ( name ) && ! Modifier . isStatic ( field . getModifiers ( ) ) ) { \nif ( field . getDeclaringClass ( ) == clz ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"7300": "public class Fields { \npublic static boolean classHasField ( Class < ? > clz , String name ) { \nList < Field > fields = Reflection . getAllFields ( clz ) ; \nfor ( Field field : fields ) { \nif ( field . getName ( ) . equals ( name ) && ! Modifier . isStatic ( field . getModifiers ( ) ) ) { \nif ( field . getDeclaringClass ( ) == clz ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"7301": "public class Fields { \npublic static String getFirstComparableOrPrimitiveFromClass ( Class < ? > clz ) { \nList < Field > fields = Reflection . getAllFields ( clz ) ; \nfor ( Field field : fields ) { \nif ( field . getType ( ) . isPrimitive ( ) ) { \nreturn field . getName ( ) ; \n} \nelse if ( Typ . isComparable ( field . getType ( ) ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) { \nreturn field . getName ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7306": "public class Sorting { \npublic static void sort ( List list , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( list == null ) { \nreturn ; \n} \nelse if ( list . size ( ) == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nCollections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nIterator iterator = list . iterator ( ) ; \nObject object = iterator . next ( ) ; \nMap < String , FieldAccess > fields = null ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \n} \nelse { \nwhile ( iterator . hasNext ( ) ) { \nobject = iterator . next ( ) ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nCollections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \n} \n} \n"}
{"7310": "public class Sorting { \npublic static < T > void sort ( T [ ] array , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( array == null ) { \nreturn ; \n} \nelse if ( array . length == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nArrays . sort ( array , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nObject object = array [ 0 ] ; \nMap < String , FieldAccess > fields = null ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \n} \nelse { \nfor ( int index = 1 ; \nindex < array . length ; \nindex ++ ) { \nobject = array [ index ] ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nArrays . sort ( array , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \n} \n} \n"}
{"7325": "public class FilterDefault { \nprivate ResultSet mainQueryPlan ( Criteria [ ] expressions ) { \nResultSetInternal results = new ResultSetImpl ( this . fields ) ; \nif ( expressions == null ) { \nresults . addResults ( searchableCollection . all ( ) ) ; \n} \nelse if ( expressions . length == 0 ) { \nresults . addResults ( searchableCollection . all ( ) ) ; \n} \nGroup group = expressions . length == 1 && expressions [ 0 ] instanceof Group ? ( Group ) expressions [ 0 ] : ObjectFilter . and ( expressions ) ; \ndoFilterGroup ( group , results ) ; \nreturn results ; \n} \n} \n"}
{"7330": "public class BatchFileWriter { \npublic void nextBufferToWrite ( final ByteBuffer bufferOut ) throws InterruptedException { \ndirty = true ; \nfinal int size = bufferOut . limit ( ) ; \nwrite ( bufferOut ) ; \nif ( ! error . get ( ) ) { \ntotalBytesTransferred += size ; \nbytesTransferred += size ; \nbytesSinceLastFlush += size ; \nbuffersSent ++ ; \n} \nif ( this . bytesTransferred >= FILE_SIZE_BYTES ) { \ntry { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \ncleanupOutputStream ( ) ; \ne . printStackTrace ( System . err ) ; \n} \nfinally { \noutputStream = null ; \n} \n} \nelse if ( fileTimeOut . get ( ) ) { \ntry { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \ncleanupOutputStream ( ) ; \ne . printStackTrace ( System . err ) ; \n} \nfinally { \noutputStream = null ; \n} \n} \n} \n} \n"}
{"7332": "public class BatchFileWriter { \nprivate void initOutputStream ( ) { \nlong time = this . time . get ( ) ; \nif ( error . get ( ) ) { \ncleanupOutputStream ( ) ; \nerror . set ( false ) ; \ntime = System . nanoTime ( ) / 1_000_000 ; \n} \nelse if ( this . totalBytesTransferred == 0 ) { \ncleanupOutputStream ( ) ; \nerror . set ( false ) ; \ntime = System . nanoTime ( ) / 1_000_000 ; \n} \nif ( outputStream != null ) { \nreturn ; \n} \nfileName = LogFilesConfig . getLogFileName ( FORMAT_PATTERN , outputDirPath ( ) , numFiles , time , SERVER_NAME ) ; \ntry { \nfileTimeOut . set ( false ) ; \noutputStream = streamCreator ( ) ; \nfileStartTime . set ( time ) ; \nbytesTransferred = 0 ; \nbytesSinceLastFlush = 0 ; \n} \ncatch ( Exception ex ) { \ncleanupOutputStream ( ) ; \nerror . set ( true ) ; \nExceptions . handle ( ex ) ; \n} \nfinally { \nnumFiles ++ ; \n} \n} \n} \n"}
{"7362": "public class JsonSlurper { \npublic Object parseText ( String text ) { \nif ( text == null ) { \nthrow new IllegalArgumentException ( \"The JSON input text should neither be null nor empty.\" ) ; \n} \nelse if ( text . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"The JSON input text should neither be null nor empty.\" ) ; \n} \nreturn JsonFactory . create ( ) . fromJson ( text ) ; \n} \n} \n"}
{"7367": "public class CouchDbUtil { \npublic static List < String > listResources ( String path ) { \ntry { \nClass < CouchDbUtil > clazz = CouchDbUtil . class ; \nURL dirURL = clazz . getClassLoader ( ) . getResource ( path ) ; \nif ( dirURL != null ) { \nif ( dirURL . getProtocol ( ) . equals ( \"file\" ) ) { \nreturn Arrays . asList ( new File ( dirURL . toURI ( ) ) . list ( ) ) ; \n} \n} \nif ( dirURL != null ) { \nif ( dirURL . getProtocol ( ) . equals ( \"jar\" ) ) { \nString jarPath = dirURL . getPath ( ) . substring ( 5 , dirURL . getPath ( ) . indexOf ( \"!\" ) ) ; \nJarFile jar = new JarFile ( URLDecoder . decode ( jarPath , \"UTF-8\" ) ) ; \nEnumeration < JarEntry > entries = jar . entries ( ) ; \nSet < String > result = new HashSet < String > ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nString name = entries . nextElement ( ) . getName ( ) ; \nif ( name . startsWith ( SPRING_BOOT_DIR ) ) { \nname = name . substring ( SPRING_BOOT_DIR . length ( ) ) ; \n} \nif ( name . startsWith ( path ) ) { \nString entry = name . substring ( path . length ( ) ) ; \nint checkSubdir = entry . indexOf ( \"/\" ) ; \nif ( checkSubdir >= 0 ) { \nentry = entry . substring ( 0 , checkSubdir ) ; \n} \nif ( entry . length ( ) > 0 ) { \nresult . add ( entry ) ; \n} \n} \n} \nclose ( jar ) ; \nreturn new ArrayList < String > ( result ) ; \n} \n} \nreturn null ; \n} \ncatch ( Exception e ) { \nthrow new CouchDbException ( e ) ; \n} \n} \n} \n"}
{"7387": "public class CouchDbClientBase { \nvoid validate ( HttpResponse response ) throws IOException { \nfinal int code = response . getStatusLine ( ) . getStatusCode ( ) ; \nif ( code == 200 || code == 201 ) { \nreturn ; \n} \nelse if ( code == 202 ) { \nreturn ; \n} \nString reason = response . getStatusLine ( ) . getReasonPhrase ( ) ; \nswitch ( code ) { \ncase HttpStatus . SC_NOT_FOUND : { \nthrow new NoDocumentException ( reason ) ; \n} \ncase HttpStatus . SC_CONFLICT : { \nthrow new DocumentConflictException ( reason ) ; \n} \ndefault : { \nthrow new CouchDbException ( reason += EntityUtils . toString ( response . getEntity ( ) ) ) ; \n} \n} \n} \n} \n"}
{"7408": "public class DataAccessImpl { \n@ Override public Observable < Observable < Row > > findAllDataFromBucket ( long timestamp , int pageSize , int maxConcurrency ) { \nPreparedStatement ts = getTempStatement ( MetricType . UNDEFINED , TempStatement . SCAN_WITH_TOKEN_RANGES , timestamp ) ; \nif ( ts == null ) { \nreturn Observable . empty ( ) ; \n} \nelse if ( prepMap . floorKey ( timestamp ) == 0L ) { \nreturn Observable . empty ( ) ; \n} \nreturn Observable . from ( getTokenRanges ( ) ) . map ( tr -> rxSession . executeAndFetch ( ts . bind ( ) . setToken ( 0 , tr . getStart ( ) ) . setToken ( 1 , tr . getEnd ( ) ) . setFetchSize ( pageSize ) ) ) ; \n} \n} \n"}
{"7447": "public class UploadManager { \nprivate void sign ( RequestHandler requestHandler ) throws QSException { \nif ( callBack != null ) { \nString signed = callBack . onSignature ( requestHandler . getStringToSignature ( ) ) ; \nif ( ! QSStringUtil . isEmpty ( signed ) ) requestHandler . setSignature ( callBack . onAccessKey ( ) , signed ) ; \nString correctTime = callBack . onCorrectTime ( requestHandler . getStringToSignature ( ) ) ; \nif ( correctTime != null ) { \nif ( correctTime . trim ( ) . length ( ) > 0 ) requestHandler . getBuilder ( ) . setHeader ( QSConstant . HEADER_PARAM_KEY_DATE , correctTime ) ; \n} \n} \n} \n} \n"}
{"7449": "public class UploadManager { \nprivate void completeMultiUpload ( String objectKey , String fileName , String eTag , String uploadID , long length ) throws QSException { \nCompleteMultipartUploadInput completeMultipartUploadInput = new CompleteMultipartUploadInput ( uploadID , partCounts , 0 ) ; \ncompleteMultipartUploadInput . setContentLength ( length ) ; \nif ( ! QSStringUtil . isEmpty ( fileName ) ) { \ntry { \nString keyName = QSStringUtil . percentEncode ( fileName , \"UTF-8\" ) ; \ncompleteMultipartUploadInput . setContentDisposition ( String . format ( \"attachment; filename=\\\"%s\\\"; filename*=utf-8''%s\" , keyName , keyName ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \ne . printStackTrace ( ) ; \n} \n} \nif ( ! QSStringUtil . isEmpty ( eTag ) ) { \ncompleteMultipartUploadInput . setETag ( eTag ) ; \n} \nRequestHandler requestHandler = bucket . completeMultipartUploadRequest ( objectKey , completeMultipartUploadInput ) ; \nsign ( requestHandler ) ; \nBucket . CompleteMultipartUploadOutput send = ( Bucket . CompleteMultipartUploadOutput ) requestHandler . send ( ) ; \nif ( send . getStatueCode ( ) == 200 ) { \nuploadModel . setUploadComplete ( true ) ; \nsetData ( objectKey , recorder ) ; \n} \nelse if ( send . getStatueCode ( ) == 201 ) { \nuploadModel . setUploadComplete ( true ) ; \nsetData ( objectKey , recorder ) ; \n} \nif ( callBack != null ) callBack . onAPIResponse ( objectKey , send ) ; \n} \n} \n"}
{"7460": "public class SSPApi { \nprivate synchronized SSPToken getAuthenticationToken ( boolean forceUpdate ) throws MalformedURLException , RestClientException { \nif ( authenticationToken != null && ! authenticationToken . hasExpired ( ) ) { \nif ( ! forceUpdate ) { \nreturn authenticationToken ; \n} \n} \nString authString = getClientId ( ) + \":\" + getClientSecret ( ) ; \nString authentication = new Base64 ( ) . encodeToString ( authString . getBytes ( ) ) ; \nHttpHeaders headers = new HttpHeaders ( ) ; \nheaders . add ( AUTHORIZATION , BASIC + \" \" + authentication ) ; \nMultiValueMap < String , String > form = new LinkedMultiValueMap < > ( ) ; \nform . add ( GRANT_TYPE , CLIENT_CREDENTIALS ) ; \nHttpEntity < MultiValueMap < String , String > > request = new HttpEntity < > ( form , headers ) ; \nURL authURL = getAuthenticationURL ( ) ; \nauthenticationToken = restTemplate . postForObject ( authURL . toExternalForm ( ) , request , SSPToken . class ) ; \nreturn authenticationToken ; \n} \n} \n"}
{"7468": "public class SSPTaskNotificationService { \nprivate URL normalizeLink ( String link ) { \ntry { \nif ( StringUtils . isEmpty ( link ) ) { \nreturn null ; \n} \nif ( link . startsWith ( \"/\" ) ) { \nreturn sspApi . getSSPUrl ( link , true ) ; \n} \nif ( link . startsWith ( \"http://\" ) ) { \nreturn new URL ( link ) ; \n} \nelse if ( link . startsWith ( \"https://\" ) ) { \nreturn new URL ( link ) ; \n} \nreturn new URL ( \"http://\" + link ) ; \n} \ncatch ( MalformedURLException e ) { \nlog . warn ( \"Bad URL from SSP Entry: \" + link , e ) ; \nreturn null ; \n} \n} \n} \n"}
{"7494": "public class Intersection2D_F64 { \npublic static boolean containTriangle ( Point2D_F64 a , Point2D_F64 b , Point2D_F64 c , Point2D_F64 pt ) { \nboolean ret = false ; \nif ( ( a . y > pt . y ) != ( b . y > pt . y ) ) { \nif ( pt . x < ( b . x - a . x ) * ( pt . y - a . y ) / ( b . y - a . y ) + a . x ) ret = true ; \n} \nif ( ( b . y > pt . y ) != ( c . y > pt . y ) ) { \nif ( pt . x < ( c . x - b . x ) * ( pt . y - b . y ) / ( c . y - b . y ) + b . x ) ret = ! ret ; \n} \nif ( ( c . y > pt . y ) != ( a . y > pt . y ) ) { \nif ( pt . x < ( a . x - c . x ) * ( pt . y - c . y ) / ( a . y - c . y ) + c . x ) ret = ! ret ; \n} \nreturn ret ; \n} \n} \n"}
{"7496": "public class Intersection2D_F64 { \npublic static Point2D_F64 intersection ( LineSegment2D_F64 l_0 , LineSegment2D_F64 l_1 , Point2D_F64 ret ) { \ndouble a0 = l_0 . b . x - l_0 . a . x ; \ndouble b0 = l_0 . b . y - l_0 . a . y ; \ndouble a1 = l_1 . b . x - l_1 . a . x ; \ndouble b1 = l_1 . b . y - l_1 . a . y ; \ndouble top = b0 * ( l_1 . a . x - l_0 . a . x ) + a0 * ( l_0 . a . y - l_1 . a . y ) ; \ndouble bottom = a0 * b1 - b0 * a1 ; \nif ( bottom == 0 ) return null ; \ndouble t_1 = top / bottom ; \nif ( t_1 < 0 ) return null ; \nelse if ( t_1 > 1 ) return null ; \ntop = b1 * ( l_0 . a . x - l_1 . a . x ) + a1 * ( l_1 . a . y - l_0 . a . y ) ; \nbottom = a1 * b0 - b1 * a0 ; \ndouble t_0 = top / bottom ; \nif ( t_0 < 0 ) return null ; \nelse if ( t_0 > 1 ) return null ; \nif ( ret == null ) { \nret = new Point2D_F64 ( ) ; \n} \nret . set ( l_1 . a . x + a1 * t_1 , l_1 . a . y + b1 * t_1 ) ; \nreturn ret ; \n} \n} \n"}
{"7498": "public class Intersection2D_F64 { \npublic static double intersection ( LineParametric2D_F64 target , LineSegment2D_F64 l ) { \ndouble a1 = l . b . x - l . a . x ; \ndouble b1 = l . b . y - l . a . y ; \ndouble top = target . slope . y * ( l . a . x - target . p . x ) + target . slope . x * ( target . p . y - l . a . y ) ; \ndouble bottom = target . slope . x * b1 - target . slope . y * a1 ; \nif ( bottom == 0 ) return Double . NaN ; \ndouble t_1 = top / bottom ; \nif ( t_1 < 0 ) return Double . NaN ; \nelse if ( t_1 > 1 ) return Double . NaN ; \ntop = b1 * ( target . p . x - l . a . x ) + a1 * ( l . a . y - target . p . y ) ; \nbottom = a1 * target . slope . y - b1 * target . slope . x ; \nreturn top / bottom ; \n} \n} \n"}
{"7529": "public class Intersection3D_F64 { \nprivate static boolean containedPlane ( Point3D_F64 T_v0 , Point3D_F64 output , Vector3D_F64 u , Vector3D_F64 v , Vector3D_F64 w0 ) { \ndouble uu , uv , vv , wu , wv , D ; \nuu = u . dot ( u ) ; \nuv = u . dot ( v ) ; \nvv = v . dot ( v ) ; \nw0 . minus ( output , T_v0 ) ; \nwu = w0 . dot ( u ) ; \nwv = w0 . dot ( v ) ; \nD = uv * uv - uu * vv ; \ndouble s , t ; \ns = ( uv * wv - vv * wu ) / D ; \nif ( s < 0.0 ) return false ; \nelse if ( s > 1.0 ) return false ; \nt = ( uv * wu - uu * wv ) / D ; \nreturn ! ( t < 0.0 ) && ! ( ( s + t ) > 1.0 ) ; \n} \n} \n"}
{"7591": "public class Distance2D_F64 { \npublic static double distanceSq ( LineSegment2D_F64 segmentA , LineSegment2D_F64 segmentB ) { \ndouble slopeAX = segmentA . slopeX ( ) ; \ndouble slopeAY = segmentA . slopeY ( ) ; \ndouble slopeBX = segmentB . slopeX ( ) ; \ndouble slopeBY = segmentB . slopeY ( ) ; \ndouble ta = slopeBX * ( segmentA . a . y - segmentB . a . y ) - slopeBY * ( segmentA . a . x - segmentB . a . x ) ; \ndouble bottom = slopeBY * slopeAX - slopeAY * slopeBX ; \nif ( bottom != 0 ) { \nta /= bottom ; \nif ( ta >= 0 ) { \nif ( ta <= 1.0 ) { \ndouble tb = slopeAX * ( segmentB . a . y - segmentA . a . y ) - slopeAY * ( segmentB . a . x - segmentA . a . x ) ; \ntb /= slopeAY * slopeBX - slopeBY * slopeAX ; \nif ( tb >= 0 ) { \nif ( tb <= 1.0 ) return 0 ; \n} \n} \n} \n} \ndouble closest = Double . MAX_VALUE ; \nclosest = Math . min ( closest , distanceSq ( segmentA , segmentB . a ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentA , segmentB . b ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentB , segmentA . a ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentB , segmentA . b ) ) ; \nreturn closest ; \n} \n} \n"}
{"7617": "public class UtilPoint2D_F64 { \npublic static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { \nif ( covariance . getNumCols ( ) != 2 ) { \nif ( covariance instanceof ReshapeMatrix ) { \n( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Must be a 2x2 matrix\" ) ; \n} \n} \nelse if ( covariance . getNumRows ( ) != 2 ) { \nif ( covariance instanceof ReshapeMatrix ) { \n( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Must be a 2x2 matrix\" ) ; \n} \n} \nmean ( points , mean ) ; \ndouble xx = 0 , xy = 0 , yy = 0 ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni ++ ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - mean . x ; \ndouble dy = p . y - mean . y ; \nxx += dx * dx ; \nxy += dx * dy ; \nyy += dy * dy ; \n} \nxx /= points . size ( ) ; \nxy /= points . size ( ) ; \nyy /= points . size ( ) ; \ncovariance . unsafe_set ( 0 , 0 , xx ) ; \ncovariance . unsafe_set ( 0 , 1 , xy ) ; \ncovariance . unsafe_set ( 1 , 0 , xy ) ; \ncovariance . unsafe_set ( 1 , 1 , yy ) ; \n} \n} \n"}
{"7632": "public class InstallFeatureUtil { \nprivate Set < String > getConfigDropinsFeatures ( Set < String > origResult , File serverDirectory , String folderName ) { \nSet < String > result = origResult ; \nFile configDropinsFolder ; \ntry { \nconfigDropinsFolder = new File ( new File ( serverDirectory , \"configDropins\" ) , folderName ) . getCanonicalFile ( ) ; \n} \ncatch ( IOException e ) { \nwarn ( \"The \" + serverDirectory + \"/configDropins/\" + folderName + \" directory cannot be accessed. Skipping its server features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nFile [ ] configDropinsXmls = configDropinsFolder . listFiles ( new FilenameFilter ( ) { \n@ Override public boolean accept ( File dir , String name ) { \nreturn name . endsWith ( \".xml\" ) ; \n} \n} \n) ; \nif ( configDropinsXmls == null ) { \nreturn result ; \n} \nelse if ( configDropinsXmls . length == 0 ) { \nreturn result ; \n} \nComparator < File > comparator = new Comparator < File > ( ) { \n@ Override public int compare ( File left , File right ) { \nreturn left . getAbsolutePath ( ) . toLowerCase ( ) . compareTo ( right . getAbsolutePath ( ) . toLowerCase ( ) ) ; \n} \n} \n; \nCollections . sort ( Arrays . asList ( configDropinsXmls ) , comparator ) ; \nfor ( File xml : configDropinsXmls ) { \nSet < String > features = getServerXmlFeatures ( result , xml , null ) ; \nif ( features != null ) { \nresult = features ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7634": "public class InstallFeatureUtil { \nprivate Set < String > parseIncludeNode ( Set < String > origResult , File serverFile , Element node , List < File > updatedParsedXmls ) { \nSet < String > result = origResult ; \nString includeFileName = node . getAttribute ( \"location\" ) ; \nif ( includeFileName == null ) { \nreturn result ; \n} \nelse if ( includeFileName . trim ( ) . isEmpty ( ) ) { \nreturn result ; \n} \nFile includeFile = null ; \nif ( isURL ( includeFileName ) ) { \ntry { \nFile tempFile = File . createTempFile ( \"serverFromURL\" , \".xml\" ) ; \nFileUtils . copyURLToFile ( new URL ( includeFileName ) , tempFile , COPY_FILE_TIMEOUT_MILLIS , COPY_FILE_TIMEOUT_MILLIS ) ; \nincludeFile = tempFile ; \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" includes a URL \" + includeFileName + \" that cannot be accessed. Skipping the included features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \n} \nelse { \nincludeFile = new File ( includeFileName ) ; \n} \ntry { \nif ( ! includeFile . isAbsolute ( ) ) { \nincludeFile = new File ( serverFile . getParentFile ( ) . getAbsolutePath ( ) , includeFileName ) . getCanonicalFile ( ) ; \n} \nelse { \nincludeFile = includeFile . getCanonicalFile ( ) ; \n} \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" includes a file \" + includeFileName + \" that cannot be accessed. Skipping the included features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nif ( ! updatedParsedXmls . contains ( includeFile ) ) { \nString onConflict = node . getAttribute ( \"onConflict\" ) ; \nSet < String > features = getServerXmlFeatures ( null , includeFile , updatedParsedXmls ) ; \nresult = handleOnConflict ( result , onConflict , features ) ; \n} \nreturn result ; \n} \n} \n"}
{"7645": "public class InstallFeatureUtil { \nprivate static int compare ( String version1 , String version2 ) { \nif ( version1 == null && version2 == null ) { \nreturn 0 ; \n} \nelse if ( version1 == null && version2 != null ) { \nreturn - 1 ; \n} \nelse if ( version1 != null ) { \nif ( version2 == null ) { \nreturn 1 ; \n} \n} \nString [ ] components1 = version1 . split ( \"\\\\.\" ) ; \nString [ ] components2 = version2 . split ( \"\\\\.\" ) ; \nfor ( int i = 0 ; \ni < components1 . length && i < components2 . length ; \ni ++ ) { \nint comparison ; \ntry { \ncomparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; \n} \ncatch ( NumberFormatException e ) { \ncomparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; \n} \nif ( comparison != 0 ) { \nreturn comparison ; \n} \n} \nreturn components1 . length - components2 . length ; \n} \n} \n"}
{"7647": "public class SpringBootUtil { \npublic static boolean isSpringBootUberJar ( File artifact ) { \nif ( artifact == null || ! artifact . exists ( ) ) { \nreturn false ; \n} \nelse if ( ! artifact . isFile ( ) ) { \nreturn false ; \n} \ntry ( JarFile jarFile = new JarFile ( artifact ) ) { \nManifest manifest = jarFile . getManifest ( ) ; \nif ( manifest != null ) { \nAttributes attributes = manifest . getMainAttributes ( ) ; \nif ( attributes . getValue ( BOOT_VERSION_ATTRIBUTE ) != null && attributes . getValue ( BOOT_START_CLASS_ATTRIBUTE ) != null ) { \nreturn true ; \n} \nelse { \nEnumeration < JarEntry > entries = jarFile . entries ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nJarEntry entry = entries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nif ( ! entryName . startsWith ( \"org\" ) ) { \nif ( entryName . matches ( BOOT_JAR_EXPRESSION ) || entryName . matches ( BOOT_WAR_EXPRESSION ) ) { \nreturn true ; \n} \n} \n} \n} \n} \n} \ncatch ( IOException e ) { \n} \nreturn false ; \n} \n} \n"}
{"7664": "public class StdRandom { \npublic static int discrete ( double [ ] a ) { \nif ( a == null ) throw new NullPointerException ( \"argument array is null\" ) ; \ndouble EPSILON = 1E-14 ; \ndouble sum = 0.0 ; \nfor ( int i = 0 ; \ni < a . length ; \ni ++ ) { \nif ( ! ( a [ i ] >= 0.0 ) ) throw new IllegalArgumentException ( \"array entry \" + i + \" must be nonnegative: \" + a [ i ] ) ; \nsum = sum + a [ i ] ; \n} \nif ( sum > 1.0 + EPSILON ) throw new IllegalArgumentException ( \"sum of array entries does not approximately equal 1.0: \" + sum ) ; \nelse if ( sum < 1.0 - EPSILON ) throw new IllegalArgumentException ( \"sum of array entries does not approximately equal 1.0: \" + sum ) ; \nwhile ( true ) { \ndouble r = uniform ( ) ; \nsum = 0.0 ; \nfor ( int i = 0 ; \ni < a . length ; \ni ++ ) { \nsum = sum + a [ i ] ; \nif ( sum > r ) return i ; \n} \n} \n} \n} \n"}
{"7671": "public class TokenBasedAuthResponseFilter { \n@ Override public void filter ( ContainerRequestContext requestContext , ContainerResponseContext responseContext ) throws IOException { \nString authToken = extractAuthTokenFromCookieList ( requestContext . getHeaders ( ) . getFirst ( \"Cookie\" ) ) ; \nif ( authToken != null ) { \nif ( authToken . length ( ) != 0 ) { \ntry { \nBasicToken token = new BasicToken ( authToken ) ; \nif ( token . isExpired ( ) ) { \nLOGGER . debug ( \"ExpireDate : \" + token . getExpirationDate ( ) . toString ( ) ) ; \nLOGGER . debug ( \"Now: \" + DateTime . now ( ) . toDate ( ) . toString ( ) ) ; \nresponseContext . getHeaders ( ) . putSingle ( \"Set-Cookie\" , getTokenSentence ( null ) ) ; \nresponseContext . setStatusInfo ( Response . Status . UNAUTHORIZED ) ; \nresponseContext . setEntity ( \"Token expired. Please login again.\" ) ; \nLOGGER . info ( \"Token expired. Please login again.\" ) ; \n} \nelse { \ntoken . setExpiration ( token . getMaxAge ( ) ) ; \nif ( ! logoutPath . equals ( requestContext . getUriInfo ( ) . getPath ( ) ) ) { \nString cookie = getTokenSentence ( token ) ; \nresponseContext . getHeaders ( ) . putSingle ( \"Set-Cookie\" , cookie ) ; \n} \n} \n} \ncatch ( Exception e ) { \nLOGGER . error ( \"Token re-creation failed\" , e . getMessage ( ) ) ; \nresponseContext . setStatusInfo ( Response . Status . UNAUTHORIZED ) ; \n} \n} \n} \n} \n} \n"}
{"7672": "public class TokenBasedAuthResponseFilter { \nprivate String extractAuthTokenFromCookieList ( String cookieList ) { \nif ( cookieList == null ) { \nreturn null ; \n} \nelse if ( cookieList . length ( ) == 0 ) { \nreturn null ; \n} \nString [ ] cookies = cookieList . split ( \";\" ) ; \nfor ( String cookie : cookies ) { \nif ( cookie . trim ( ) . startsWith ( tokenKey ) ) { \nreturn cookie . trim ( ) . substring ( tokenKey . length ( ) + 1 ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7685": "public class RobeExceptionMapper { \n@ Override public Response toResponse ( Exception e ) { \nString id = System . nanoTime ( ) + \"\" ; \nLOGGER . error ( id , e ) ; \nif ( e instanceof RobeRuntimeException ) { \nreturn ( ( RobeRuntimeException ) e ) . getResponse ( id ) ; \n} \nelse if ( e instanceof ConstraintViolationException ) { \nConstraintViolationException exception = ( ConstraintViolationException ) e ; \nRobeMessage [ ] errors = new RobeMessage [ exception . getConstraintViolations ( ) . size ( ) ] ; \nint i = 0 ; \nfor ( ConstraintViolation error : exception . getConstraintViolations ( ) ) { \nerrors [ i ++ ] = new RobeMessage . Builder ( ) . message ( error . getMessage ( ) ) . status ( 422 ) . id ( id ) . build ( ) ; \n} \nreturn Response . status ( 422 ) . entity ( errors ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse if ( e instanceof WebApplicationException ) { \nWebApplicationException we = ( WebApplicationException ) e ; \nRobeMessage error = new RobeMessage . Builder ( ) . id ( id ) . message ( we . getMessage ( ) ) . status ( we . getResponse ( ) . getStatus ( ) ) . build ( ) ; \nreturn Response . fromResponse ( we . getResponse ( ) ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse { \nif ( e . getClass ( ) . getName ( ) . equals ( \"org.hibernate.exception.ConstraintViolationException\" ) ) { \nif ( e . getCause ( ) != null ) { \nif ( e . getCause ( ) . getMessage ( ) != null ) { \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getCause ( ) . getMessage ( ) . split ( \"for\" ) [ 0 ] ) . status ( Response . Status . CONFLICT . getStatusCode ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . CONFLICT ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \n} \n} \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getMessage ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . INTERNAL_SERVER_ERROR ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \n} \n} \n"}
{"7689": "public class MailSender { \npublic void sendMessage ( MailItem item ) throws MessagingException { \ncheckNotNull ( item . getReceivers ( ) ) ; \ncheckNotNull ( item . getReceivers ( ) . get ( 0 ) ) ; \ncheckNotNull ( item . getTitle ( ) ) ; \ncheckNotNull ( item . getBody ( ) ) ; \nMessage msg = new MimeMessage ( session ) ; \nif ( item . getSender ( ) == null ) { \nitem . setSender ( configuration . getProperties ( ) . get ( configuration . getUsernameKey ( ) ) . toString ( ) ) ; \n} \nelse if ( item . getSender ( ) . length ( ) == 0 ) { \nitem . setSender ( configuration . getProperties ( ) . get ( configuration . getUsernameKey ( ) ) . toString ( ) ) ; \n} \nInternetAddress from = new InternetAddress ( item . getSender ( ) ) ; \nmsg . setFrom ( from ) ; \nInternetAddress [ ] to = new InternetAddress [ item . getReceivers ( ) . size ( ) ] ; \nfor ( int i = 0 ; \ni < item . getReceivers ( ) . size ( ) ; \ni ++ ) { \nto [ i ] = new InternetAddress ( item . getReceivers ( ) . get ( i ) ) ; \n} \nmsg . setRecipients ( Message . RecipientType . TO , to ) ; \nmsg . setSubject ( item . getTitle ( ) ) ; \nMimeBodyPart body = new MimeBodyPart ( ) ; \nbody . setContent ( item . getBody ( ) , \"text/html; charset=UTF-8\" ) ; \nMultipart content = new MimeMultipart ( ) ; \ncontent . addBodyPart ( body ) ; \nif ( item . getAttachments ( ) != null ) { \nif ( item . getAttachments ( ) . size ( ) > 0 ) { \nfor ( DataSource attachment : item . getAttachments ( ) ) { \nBodyPart itemBodyPart = new MimeBodyPart ( ) ; \nitemBodyPart . setDataHandler ( new DataHandler ( attachment ) ) ; \nitemBodyPart . setFileName ( attachment . getName ( ) ) ; \ncontent . addBodyPart ( itemBodyPart ) ; \n} \n} \n} \nmsg . setContent ( content ) ; \nmsg . saveChanges ( ) ; \nTransport . send ( msg ) ; \nfor ( Map . Entry < String , String [ ] > entry : item . getHeaders ( ) . entrySet ( ) ) { \nString [ ] value = msg . getHeader ( entry . getKey ( ) ) ; \nif ( value != null ) { \nentry . setValue ( value ) ; \n} \n} \n} \n} \n"}
{"7697": "public class Transaction { \nprivate void success ( ) { \norg . hibernate . Transaction txn = session . getTransaction ( ) ; \nif ( txn != null ) { \nif ( txn . getStatus ( ) . equals ( TransactionStatus . ACTIVE ) ) { \ntxn . commit ( ) ; \n} \n} \n} \n} \n"}
{"7698": "public class Transaction { \nprivate void error ( ) { \norg . hibernate . Transaction txn = session . getTransaction ( ) ; \nif ( txn != null ) { \nif ( txn . getStatus ( ) . equals ( TransactionStatus . ACTIVE ) ) { \ntxn . rollback ( ) ; \n} \n} \n} \n} \n"}
{"7719": "public class CharStreams { \npublic static boolean equal ( Reader in1 , Reader in2 ) throws IOException { \nif ( in1 == in2 ) { \nreturn true ; \n} \nif ( in1 == null ) { \nreturn false ; \n} \nelse if ( in2 == null ) { \nreturn false ; \n} \nin1 = buffer ( in1 ) ; \nin2 = buffer ( in2 ) ; \nint c1 = in1 . read ( ) ; \nint c2 = in2 . read ( ) ; \nwhile ( c1 != - 1 && c2 != - 1 && c1 == c2 ) { \nc1 = in1 . read ( ) ; \nc2 = in2 . read ( ) ; \n} \nreturn in1 . read ( ) == - 1 && in2 . read ( ) == - 1 ; \n} \n} \n"}
{"7721": "public class XFiles { \npublic static void touch ( File ... files ) throws IOException { \nlong now = System . currentTimeMillis ( ) ; \nfor ( File f : files ) { \nif ( ! f . createNewFile ( ) ) { \nif ( ! f . setLastModified ( now ) ) { \nthrow new IOException ( \"Failed to touch \" + f ) ; \n} \n} \n} \n} \n} \n"}
{"7726": "public class Passwords { \npublic static boolean verify ( String password , byte [ ] hash ) { \nbyte [ ] h = Arrays . copyOf ( hash , HASH_LENGTH + SALT_LENGTH + 3 ) ; \nint n = 1 << ( h [ HASH_LENGTH + SALT_LENGTH ] & 0xFF ) ; \nint r = h [ HASH_LENGTH + SALT_LENGTH + 1 ] & 0xFF ; \nint p = h [ HASH_LENGTH + SALT_LENGTH + 2 ] & 0xFF ; \nif ( n > N || n < N_MIN || r > R || r < R_MIN || p > P ) { \nn = N ; \nr = R ; \np = P ; \n} \nelse if ( p < P_MIN ) { \nn = N ; \nr = R ; \np = P ; \n} \nbyte [ ] salt = new byte [ SALT_LENGTH ] ; \nSystem . arraycopy ( h , HASH_LENGTH , salt , 0 , SALT_LENGTH ) ; \nbyte [ ] expected = hash ( password , salt , r , n , p ) ; \nint result = 0 ; \nfor ( int i = 0 ; \ni < h . length ; \ni ++ ) { \nresult |= h [ i ] ^ expected [ i ] ; \n} \nreturn result == 0 ; \n} \n} \n"}
{"7744": "public class LongtermForecastHelper { \npublic MeteoExtrasLongTermForecast createSimpleLongTermForecast ( ) throws MeteoException { \nList < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; \nZonedDateTime dt = getNow ( ) ; \nfor ( int i = 0 ; \ni <= 6 ; \ni ++ ) { \nZonedDateTime dti = dt . plusDays ( i ) ; \nif ( getIndexer ( ) . hasForecastsForDay ( dti ) ) { \nMeteoExtrasForecastDay mefd = createSimpleForcastForDay ( dti ) ; \nif ( mefd != null ) { \nif ( mefd . getForecasts ( ) . size ( ) > 0 ) { \nforecastDays . add ( mefd ) ; \n} \n} \n} \n} \nreturn new MeteoExtrasLongTermForecast ( forecastDays ) ; \n} \n} \n"}
{"7748": "public class WindSymbolHelper { \npublic static Optional < String > createWindSymbolName ( PointForecast pointForecast ) { \nif ( pointForecast == null || pointForecast . getWindDirection ( ) == null ) { \nreturn Optional . empty ( ) ; \n} \nelse if ( pointForecast . getWindSpeed ( ) == null ) { \nreturn Optional . empty ( ) ; \n} \nreturn Optional . of ( pointForecast . getWindDirection ( ) . getName ( ) . toLowerCase ( ) + idFormat . format ( pointForecast . getWindSpeed ( ) . getBeaufort ( ) ) ) ; \n} \n} \n"}
{"7749": "public class WindSymbolHelper { \npublic static Optional < BeaufortLevel > findBeaufortLevel ( PointForecast pointForecast ) { \nif ( pointForecast == null ) { \nreturn Optional . empty ( ) ; \n} \nelse if ( pointForecast . getWindSpeed ( ) == null ) { \nreturn Optional . empty ( ) ; \n} \nreturn Optional . ofNullable ( findUnitById ( pointForecast . getWindSpeed ( ) . getBeaufort ( ) ) ) ; \n} \n} \n"}
{"7753": "public class MeteoForecastIndexer { \nOptional < PeriodForecast > getBestFitPeriodForecast ( ZonedDateTime from , ZonedDateTime to ) { \nif ( from == null ) { \nreturn Optional . empty ( ) ; \n} \nelse if ( to == null ) { \nreturn Optional . empty ( ) ; \n} \nZonedDateTime requestFrom = toZeroMSN ( from ) ; \nZonedDateTime requestTo = toZeroMSN ( to ) ; \nList < PeriodForecast > forecastsList = dayIndex . get ( new DayIndexKey ( requestFrom ) ) ; \nif ( forecastsList == null ) { \nreturn Optional . empty ( ) ; \n} \nPeriodForecast chosenForecast = null ; \nlong score = 0 ; \nlong tmpScore = 0 ; \nfor ( PeriodForecast forecast : forecastsList ) { \nZonedDateTime actualFrom = cloneZonedDateTime ( forecast . getFrom ( ) ) ; \nZonedDateTime actualTo = cloneZonedDateTime ( forecast . getTo ( ) ) ; \nif ( requestFrom . equals ( actualFrom ) && requestTo . equals ( actualTo ) ) { \nreturn Optional . of ( forecast ) ; \n} \nelse if ( ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualFrom ) ) || ( requestFrom . isAfter ( actualTo ) && requestTo . isAfter ( actualTo ) ) || actualTo . isEqual ( actualFrom ) ) { \ncontinue ; \n} \nelse if ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualTo ) ) { \ntmpScore = hoursBetween ( requestTo , actualFrom ) ; \n} \nelse if ( ( actualFrom . isBefore ( requestFrom ) || actualFrom . isEqual ( requestFrom ) ) && actualTo . isBefore ( requestTo ) ) { \ntmpScore = hoursBetween ( actualTo , requestFrom ) ; \n} \nelse if ( actualFrom . isAfter ( requestFrom ) && ( actualTo . isBefore ( requestTo ) || actualTo . isEqual ( requestTo ) ) ) { \ntmpScore = hoursBetween ( actualTo , actualFrom ) ; \n} \nelse if ( actualFrom . isBefore ( requestFrom ) && actualTo . isAfter ( requestTo ) ) { \ntmpScore = hoursBetween ( requestTo , requestFrom ) ; \n} \nelse { \nDateTimeFormatter formatter = DateTimeFormatter . ofPattern ( \"yyyy-MM-dd:HH:mm\" ) ; \nlog . warn ( \"Unhandled forecast Requested period:\" + requestFrom . format ( formatter ) + \"--\" + requestTo . format ( formatter ) + \", Actual period: \" + actualFrom . format ( formatter ) + \"--\" + actualTo . format ( formatter ) ) ; \n} \ntmpScore = Math . abs ( tmpScore ) ; \nif ( score == 0 && tmpScore > 0 ) { \nscore = tmpScore ; \nchosenForecast = forecast ; \n} \nelse if ( tmpScore > score ) { \nscore = tmpScore ; \nchosenForecast = forecast ; \n} \n} \nreturn Optional . ofNullable ( chosenForecast ) ; \n} \n} \n"}
{"7770": "public class Name { \npublic String getIndex ( final int index ) { \nif ( index < 0 ) { \nthrow new IllegalArgumentException ( \"Index out of bounds\" ) ; \n} \nelse if ( index >= components . size ( ) ) { \nthrow new IllegalArgumentException ( \"Index out of bounds\" ) ; \n} \nreturn components . get ( index ) ; \n} \n} \n"}
{"7771": "public class Name { \npublic Name getPrefix ( final int upperIndex ) { \nif ( upperIndex < 0 ) { \nthrow new IllegalArgumentException ( \"Index out of bounds\" ) ; \n} \nelse if ( upperIndex > components . size ( ) ) { \nthrow new IllegalArgumentException ( \"Index out of bounds\" ) ; \n} \nreturn new Name ( components . subList ( 0 , upperIndex ) ) ; \n} \n} \n"}
{"7774": "public class Runtime { \nprivate boolean cfindloop ( Dfa d , Dfa s , int [ ] coldp ) { \nint begin ; \nint end ; \nint cold ; \nint open ; \nint close ; \nint estart ; \nint estop ; \nboolean shorter = 0 != ( g . tree . flags & Subre . SHORTER ) ; \nboolean hitend [ ] = new boolean [ 1 ] ; \nboolean lookingAt = 0 != ( eflags & Flags . REG_LOOKING_AT ) ; \nassert d != null && s != null ; \nclose = 0 ; \ndo { \nint [ ] cold0 = new int [ 1 ] ; \nif ( lookingAt ) { \nclose = d . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = 0 ; \n} \nelse { \nclose = s . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = cold0 [ 0 ] ; \n} \nif ( close == - 1 ) { \nbreak ; \n} \nassert cold != - 1 ; \nopen = cold ; \ncold = - 1 ; \nfor ( begin = open ; \nbegin <= close ; \nbegin ++ ) { \nif ( begin > 0 ) { \nif ( lookingAt ) { \nreturn false ; \n} \n} \nestart = begin ; \nestop = data . length ( ) ; \nfor ( ; \n; \n) { \nif ( shorter ) { \nend = d . shortest ( begin , estart , estop , null , hitend ) ; \n} \nelse { \nend = d . longest ( begin , estop , hitend ) ; \n} \nif ( hitend [ 0 ] ) { \nif ( cold == - 1 ) { \ncold = begin ; \n} \n} \nif ( end == - 1 ) { \nbreak ; \n} \nfor ( int x = 0 ; \nx < match . size ( ) ; \nx ++ ) { \nmatch . set ( x , null ) ; \n} \nint maxsubno = getMaxSubno ( g . tree , 0 ) ; \nmem = new int [ maxsubno + 1 ] ; \nboolean matched = cdissect ( g . tree , begin , end ) ; \nif ( matched ) { \nmatch . set ( 0 , new RegMatch ( begin , end ) ) ; \ncoldp [ 0 ] = cold ; \nreturn true ; \n} \nif ( shorter ? end == estop : end == begin ) { \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \nif ( shorter ) { \nestart = end + 1 ; \n} \nelse { \nestop = end - 1 ; \n} \n} \n} \n} \nwhile ( close < data . length ( ) ) ; \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \n} \n"}
{"7776": "public class Runtime { \nprivate boolean crevdissect ( RuntimeSubexpression t , int begin , int end ) { \nDfa d ; \nDfa d2 ; \nint mid ; \nassert t . op == '.' ; \nassert t . left != null && t . left . machine . states . length > 0 ; \nassert t . right != null && t . right . machine . states . length > 0 ; \nassert 0 != ( t . left . flags & Subre . SHORTER ) ; \nd = new Dfa ( this , t . left . machine ) ; \nd2 = new Dfa ( this , t . right . machine ) ; \nif ( mem [ t . retry ] == 0 ) { \nmid = d . shortest ( begin , begin , end , null , null ) ; \nif ( mid == - 1 ) { \nreturn false ; \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \n} \nelse { \nmid = begin + ( mem [ t . retry ] - 1 ) ; \n} \nfor ( ; \n; \n) { \nboolean cdmatch = cdissect ( t . left , begin , mid ) ; \nif ( cdmatch && d2 . longest ( mid , end , null ) == end ) { \nif ( cdissect ( t . right , mid , end ) ) { \nbreak ; \n} \n} \nif ( mid == end ) { \nreturn false ; \n} \nmid = d . shortest ( begin , mid + 1 , end , null , null ) ; \nif ( mid == - 1 ) { \nreturn false ; \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \nzapmem ( t . left ) ; \nzapmem ( t . right ) ; \n} \nreturn true ; \n} \n} \n"}
{"7781": "public class Compiler { \nprivate long nfanode ( Subre t ) throws RegexException { \nlong ret ; \nassert t . begin != null ; \nif ( LOG . isDebugEnabled ( ) ) { \nif ( IS_DEBUG ) { \nLOG . debug ( String . format ( \"========= TREE NODE %s ==========\" , t . shortId ( ) ) ) ; \n} \n} \nNfa newNfa = new Nfa ( nfa ) ; \nnewNfa . dupnfa ( t . begin , t . end , newNfa . init , newNfa . finalState ) ; \nnewNfa . specialcolors ( ) ; \nret = newNfa . optimize ( ) ; \nt . cnfa = newNfa . compact ( ) ; \nreturn ret ; \n} \n} \n"}
{"7783": "public class Compiler { \nprivate void deltraverse ( Nfa nfa , State leftend , State s ) { \nArc a ; \nState to ; \nif ( s . nouts == 0 ) { \nreturn ; \n} \nif ( s . tmp != null ) { \nreturn ; \n} \ns . tmp = s ; \nwhile ( ( a = s . outs ) != null ) { \nto = a . to ; \ndeltraverse ( nfa , leftend , to ) ; \nassert to . nouts == 0 || to . tmp != null ; \nnfa . freearc ( a ) ; \nif ( to . nins == 0 ) { \nif ( to . tmp == null ) { \nassert to . nouts == 0 ; \nnfa . freestate ( to ) ; \n} \n} \n} \nassert s . no != State . FREESTATE ; \nassert s == leftend || s . nins != 0 ; \nassert s . nouts == 0 ; \ns . tmp = null ; \n} \n} \n"}
{"7786": "public class Compiler { \nprivate int scannum ( ) throws RegexException { \nint n = 0 ; \nwhile ( see ( DIGIT ) && n < DUPMAX ) { \nn = n * 10 + nextvalue ; \nlex . next ( ) ; \n} \nif ( see ( DIGIT ) ) { \nthrow new RegexException ( \"Unvalid reference number.\" ) ; \n} \nelse if ( n > DUPMAX ) { \nthrow new RegexException ( \"Unvalid reference number.\" ) ; \n} \nreturn n ; \n} \n} \n"}
{"7791": "public class Compiler { \nprivate void dovec ( UnicodeSet set , State lp , State rp ) throws RegexException { \nint rangeCount = set . getRangeCount ( ) ; \nfor ( int rx = 0 ; \nrx < rangeCount ; \nrx ++ ) { \nint rangeStart = set . getRangeStart ( rx ) ; \nint rangeEnd = set . getRangeEnd ( rx ) ; \nif ( LOG . isDebugEnabled ( ) ) { \nif ( IS_DEBUG ) { \nLOG . debug ( String . format ( \"%s %d %4x %4x\" , set , rx , rangeStart , rangeEnd ) ) ; \n} \n} \nif ( rangeStart == rangeEnd ) { \nnfa . newarc ( PLAIN , cm . subcolor ( rangeStart ) , lp , rp ) ; \n} \ncm . subrange ( rangeStart , rangeEnd , lp , rp ) ; \n} \n} \n} \n"}
{"7800": "public class Lex { \nvoid prefixes ( ) throws RegexException { \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nreturn ; \n} \nif ( have ( 4 ) ) { \nif ( next3 ( '*' , '*' , '*' ) ) { \nswitch ( charAtNowPlus ( 3 ) ) { \ncase '?' : throw new RegexException ( \"REG_BADPAT\" ) ; \ncase '=' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \nv . now += 4 ; \nreturn ; \ncase ':' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_ADVANCED ; \nv . now += 4 ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADRPT\" ) ; \n} \n} \n} \nif ( ( v . cflags & Flags . REG_ADVANCED ) != Flags . REG_ADVANCED ) { \nreturn ; \n} \nif ( have ( 3 ) && next2 ( '(' , '?' ) ) { \nif ( iscalpha ( charAtNowPlus ( 2 ) ) ) { \nv . note ( Flags . REG_UNONPOSIX ) ; \nv . now += 2 ; \nfor ( ; \n! ateos ( ) && iscalpha ( charAtNow ( ) ) ; \nv . now ++ ) { \nswitch ( charAtNow ( ) ) { \ncase 'b' : v . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'c' : v . cflags &= ~ Flags . REG_ICASE ; \nbreak ; \ncase 'e' : v . cflags |= Flags . REG_EXTENDED ; \nv . cflags &= ~ ( Flags . REG_ADVF | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'i' : v . cflags |= Flags . REG_ICASE ; \nbreak ; \ncase 'm' : case 'n' : v . cflags |= Flags . REG_NEWLINE ; \nbreak ; \ncase 'p' : v . cflags |= Flags . REG_NLSTOP ; \nv . cflags &= ~ Flags . REG_NLANCH ; \nbreak ; \ncase 'q' : v . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ Flags . REG_ADVANCED ; \nbreak ; \ncase 's' : v . cflags &= ~ Flags . REG_NEWLINE ; \nbreak ; \ncase 't' : v . cflags &= ~ Flags . REG_EXPANDED ; \nbreak ; \ncase 'w' : v . cflags &= ~ Flags . REG_NLSTOP ; \nv . cflags |= Flags . REG_NLANCH ; \nbreak ; \ncase 'x' : v . cflags |= Flags . REG_EXPANDED ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADOPT\" ) ; \n} \n} \nif ( ! next1 ( ')' ) ) { \nthrow new RegexException ( \"REG_BADOPT\" ) ; \n} \nv . now ++ ; \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nv . cflags &= ~ ( Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \n} \n} \n} \n} \n} \n"}
{"7804": "public class Dfa { \nint lastcold ( ) { \nint nopr = 0 ; \nfor ( StateSet ss : stateSets . values ( ) ) { \nif ( ss . noprogress ) { \nif ( nopr < ss . getLastSeen ( ) ) { \nnopr = ss . getLastSeen ( ) ; \n} \n} \n} \nreturn nopr ; \n} \n} \n"}
{"7807": "public class CnfaBuilder { \nvoid carcsort ( int first , int last ) { \nint p ; \nint q ; \nlong tmp ; \nif ( last - first <= 1 ) { \nreturn ; \n} \nfor ( p = first ; \np <= last ; \np ++ ) { \nfor ( q = p ; \nq <= last ; \nq ++ ) { \nshort pco = Cnfa . carcColor ( arcs [ p ] ) ; \nshort qco = Cnfa . carcColor ( arcs [ q ] ) ; \nint pto = Cnfa . carcTarget ( arcs [ p ] ) ; \nint qto = Cnfa . carcTarget ( arcs [ q ] ) ; \nif ( pco > qco ) { \nassert p != q ; \ntmp = arcs [ p ] ; \narcs [ p ] = arcs [ q ] ; \narcs [ q ] = tmp ; \n} \nelse if ( pco == qco && pto > qto ) { \nassert p != q ; \ntmp = arcs [ p ] ; \narcs [ p ] = arcs [ q ] ; \narcs [ q ] = tmp ; \n} \n} \n} \n} \n} \n"}
{"7808": "public class Subre { \nString dumpst ( boolean nfapresent ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( String . format ( \"%s. `%c'\" , shortId ( ) , op ) ) ; \nif ( 0 != ( flags & LONGER ) ) { \nsb . append ( \" longest\" ) ; \n} \nif ( 0 != ( flags & SHORTER ) ) { \nsb . append ( \" shortest\" ) ; \n} \nif ( 0 != ( flags & MIXED ) ) { \nsb . append ( \" hasmixed\" ) ; \n} \nif ( 0 != ( flags & CAP ) ) { \nsb . append ( \" hascapture\" ) ; \n} \nif ( 0 != ( flags & BACKR ) ) { \nsb . append ( \" hasbackref\" ) ; \n} \nif ( 0 == ( flags & INUSE ) ) { \nsb . append ( \" UNUSED\" ) ; \n} \nif ( subno != 0 ) { \nsb . append ( String . format ( \" (#%d)\" , subno ) ) ; \n} \nif ( min != 1 ) { \nsb . append ( String . format ( \" {%d,\" , min ) ) ; \nif ( max != Compiler . INFINITY ) { \nsb . append ( String . format ( \"%d\" , max ) ) ; \n} \nsb . append ( \"}\" ) ; \n} \nelse if ( max != 1 ) { \nsb . append ( String . format ( \" {%d,\" , min ) ) ; \nif ( max != Compiler . INFINITY ) { \nsb . append ( String . format ( \"%d\" , max ) ) ; \n} \nsb . append ( \"}\" ) ; \n} \nif ( nfapresent ) { \nsb . append ( String . format ( \" %d-%d\" , begin . no , end . no ) ) ; \n} \nif ( left != null ) { \nsb . append ( String . format ( \" L:%s\" , left . toString ( ) ) ) ; \n} \nif ( right != null ) { \nsb . append ( String . format ( \" R:%s\" , right . toString ( ) ) ) ; \n} \nsb . append ( \"\\n\" ) ; \nif ( left != null ) { \nleft . dumpst ( nfapresent ) ; \n} \nif ( right != null ) { \nright . dumpst ( nfapresent ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"7819": "public class Nfa { \nvoid dumpnfa ( ) { \nif ( ! LOG . isDebugEnabled ( ) ) { \nreturn ; \n} \nelse if ( ! IS_DEBUG ) { \nreturn ; \n} \nLOG . debug ( \"dump nfa\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( String . format ( \"pre %d, post %d init %d final %d\" , pre . no , post . no , init . no , finalState . no ) ) ; \nif ( bos [ 0 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", bos [%d]\" , bos [ 0 ] ) ) ; \n} \nif ( bos [ 1 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", bol [%d]\" , bos [ 1 ] ) ) ; \n} \nif ( eos [ 0 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", eos [%d]\" , eos [ 0 ] ) ) ; \n} \nif ( eos [ 1 ] != Constants . COLORLESS ) { \nsb . append ( String . format ( \", eol [%d]\" , eos [ 1 ] ) ) ; \n} \nLOG . debug ( sb . toString ( ) ) ; \nfor ( State s = states ; \ns != null ; \ns = s . next ) { \ndumpstate ( s ) ; \n} \nif ( parent == null ) { \ncm . dumpcolors ( ) ; \n} \n} \n} \n"}
{"7820": "public class Nfa { \nvoid dumpstate ( State s ) { \nArc a ; \nif ( ! LOG . isDebugEnabled ( ) ) { \nreturn ; \n} \nelse if ( ! IS_DEBUG ) { \nreturn ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( String . format ( \"State %d%s%c\" , s . no , ( s . tmp != null ) ? \"T\" : \"\" , ( s . flag != 0 ) ? ( char ) s . flag : '.' ) ) ; \nif ( s . prev != null ) { \nif ( s . prev . next != s ) { \nsb . append ( String . format ( \"\\tstate chain bad\" ) ) ; \n} \n} \nif ( s . nouts == 0 ) { \nsb . append ( \"\\tno out arcs\" ) ; \n} \nelse { \ndumparcs ( s , sb ) ; \n} \nLOG . debug ( sb . toString ( ) ) ; \nfor ( a = s . ins ; \na != null ; \na = a . inchain ) { \nif ( a . to != s ) { \nLOG . debug ( String . format ( \"\\tlink from %d to %d on %d's in-chain\" , a . from . no , a . to . no , s . no ) ) ; \n} \n} \n} \n} \n"}
{"7827": "public class Nfa { \nvoid cleanup ( ) { \nState s ; \nState nexts ; \nint n ; \nmarkreachable ( pre , null , pre ) ; \nmarkcanreach ( post , pre , post ) ; \nfor ( s = states ; \ns != null ; \ns = nexts ) { \nnexts = s . next ; \nif ( s . tmp != post ) { \nif ( 0 == s . flag ) { \ndropstate ( s ) ; \n} \n} \n} \nassert post . nins == 0 || post . tmp == post ; \ncleartraverse ( pre ) ; \nassert post . nins == 0 || post . tmp == null ; \nn = 0 ; \nfor ( s = states ; \ns != null ; \ns = s . next ) { \ns . no = n ++ ; \n} \nnstates = n ; \n} \n} \n"}
{"7830": "public class Nfa { \nvoid fixempties ( ) { \nState s ; \nState nexts ; \nArc a ; \nArc nexta ; \nboolean progress ; \ndo { \nprogress = false ; \nfor ( s = states ; \ns != null ; \ns = nexts ) { \nnexts = s . next ; \nfor ( a = s . outs ; \na != null ; \na = nexta ) { \nnexta = a . outchain ; \nif ( a . type == Compiler . EMPTY ) { \nif ( unempty ( a ) ) { \nprogress = true ; \n} \n} \nassert nexta == null || s . no != State . FREESTATE ; \n} \n} \nif ( progress ) { \ndumpnfa ( ) ; \n} \n} \nwhile ( progress ) ; \n} \n} \n"}
{"7863": "public class JspServletWrapper { \npublic java . util . List < String > getDependants ( ) { \ntry { \nObject target ; \nif ( isTagFile ) { \nif ( reload ) { \ntagHandlerClass = ctxt . load ( ) ; \n} \ntarget = tagHandlerClass . newInstance ( ) ; \n} \nelse { \ntarget = getServlet ( ) ; \n} \nif ( target != null ) { \nif ( target instanceof JspSourceDependent ) { \nreturn ( ( JspSourceDependent ) target ) . getDependants ( ) ; \n} \n} \n} \ncatch ( Throwable ex ) { \n} \nreturn null ; \n} \n} \n"}
{"7865": "public class BasicAuthentication { \npublic static String [ ] parseAuthorization ( final HttpServletRequest request ) { \nfinal String auth = request . getHeader ( \"Authorization\" ) ; \nlogger . debug ( \"Auth header: {}\" , auth ) ; \nif ( auth == null ) { \nreturn null ; \n} \nelse if ( auth . isEmpty ( ) ) { \nreturn null ; \n} \nfinal String [ ] toks = auth . split ( \"\\\\s\" ) ; \nif ( toks . length < 2 ) { \nreturn null ; \n} \nif ( ! \"Basic\" . equalsIgnoreCase ( toks [ 0 ] ) ) { \nreturn null ; \n} \nfinal byte [ ] authData = Base64 . getDecoder ( ) . decode ( toks [ 1 ] ) ; \nfinal String authStr = StandardCharsets . ISO_8859_1 . decode ( ByteBuffer . wrap ( authData ) ) . toString ( ) ; \nlogger . debug ( \"Auth String: {}\" , authStr ) ; \nfinal String [ ] authToks = authStr . split ( \":\" , 2 ) ; \nlogger . debug ( \"Auth tokens: {}\" , new Object [ ] { \nauthToks } \n) ; \nif ( authToks . length != 2 ) { \nreturn null ; \n} \nreturn authToks ; \n} \n} \n"}
{"7878": "public class OsgiSitemapGenerator { \nprivate Optional < Instant > calcLastMod ( ) { \nInstant globalLastMod = null ; \nfor ( final ChannelInformation ci : this . channelService . list ( ) ) { \nfinal Optional < Instant > lastMod = ofNullable ( ci . getState ( ) . getModificationTimestamp ( ) ) ; \nif ( globalLastMod == null ) { \nglobalLastMod = lastMod . get ( ) ; \n} \nelse if ( lastMod . get ( ) . isAfter ( globalLastMod ) ) { \nglobalLastMod = lastMod . get ( ) ; \n} \n} \nreturn Optional . ofNullable ( globalLastMod ) ; \n} \n} \n"}
{"7879": "public class JSPContextFinder { \nArrayList basicFindClassLoaders ( ) { \nClass [ ] stack = contextFinder . getClassContext ( ) ; \nArrayList result = new ArrayList ( 1 ) ; \nClassLoader previousLoader = null ; \nfor ( int i = 1 ; \ni < stack . length ; \ni ++ ) { \nClassLoader tmp = stack [ i ] . getClassLoader ( ) ; \nif ( checkClass ( stack [ i ] ) && tmp != null ) { \nif ( tmp != this ) { \nif ( checkClassLoader ( tmp ) ) { \nif ( previousLoader != tmp ) { \nresult . add ( tmp ) ; \npreviousLoader = tmp ; \n} \n} \nif ( Activator . getBundle ( stack [ i ] ) != null ) break ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"7880": "public class JSPContextFinder { \nprivate boolean checkClassLoader ( ClassLoader classloader ) { \nif ( classloader == null ) return false ; \nelse if ( classloader == getParent ( ) ) return false ; \nfor ( ClassLoader parent = classloader . getParent ( ) ; \nparent != null ; \nparent = parent . getParent ( ) ) if ( parent == this ) return false ; \nreturn true ; \n} \n} \n"}
{"7881": "public class JSPContextFinder { \nprivate boolean startLoading ( String name ) { \nSet classesAndResources = ( Set ) cycleDetector . get ( ) ; \nif ( classesAndResources != null ) { \nif ( classesAndResources . contains ( name ) ) return false ; \n} \nif ( classesAndResources == null ) { \nclassesAndResources = new HashSet ( 3 ) ; \ncycleDetector . set ( classesAndResources ) ; \n} \nclassesAndResources . add ( name ) ; \nreturn true ; \n} \n} \n"}
{"7887": "public class ImplicitTagLibraryInfo { \nprivate void parseImplicitTld ( JspCompilationContext ctxt , String path ) throws JasperException { \nInputStream is = null ; \nTreeNode tld = null ; \ntry { \nURL uri = ctxt . getResource ( path ) ; \nif ( uri == null ) { \nreturn ; \n} \nis = uri . openStream ( ) ; \ntld = new ParserUtils ( ) . parseXMLDocument ( IMPLICIT_TLD , is , ctxt . getOptions ( ) . isValidationEnabled ( ) ) ; \n} \ncatch ( Exception ex ) { \nthrow new JasperException ( ex ) ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Throwable t ) { \n} \n} \n} \nthis . jspversion = tld . findAttribute ( \"version\" ) ; \nIterator list = tld . findChildren ( ) ; \nwhile ( list . hasNext ( ) ) { \nTreeNode element = ( TreeNode ) list . next ( ) ; \nString tname = element . getName ( ) ; \nif ( \"tlibversion\" . equals ( tname ) || \"tlib-version\" . equals ( tname ) ) { \nthis . tlibversion = element . getBody ( ) ; \n} \nelse if ( \"jspversion\" . equals ( tname ) || \"jsp-version\" . equals ( tname ) ) { \nthis . jspversion = element . getBody ( ) ; \n} \nelse if ( ! \"shortname\" . equals ( tname ) ) { \nif ( ! \"short-name\" . equals ( tname ) ) { \nerr . jspError ( \"jsp.error.implicitTld.additionalElements\" , path , tname ) ; \n} \n} \n} \nDouble jspVersionDouble = Double . valueOf ( this . jspversion ) ; \nif ( Double . compare ( jspVersionDouble , Constants . JSP_VERSION_2_0 ) < 0 ) { \nerr . jspError ( \"jsp.error.implicitTld.jspVersion\" , path , this . jspversion ) ; \n} \n} \n} \n"}
{"7890": "public class ChannelController { \nprivate static void validateChannelName ( final String name , final ValidationContext ctx ) { \nif ( name == null ) { \nreturn ; \n} \nelse if ( name . isEmpty ( ) ) { \nreturn ; \n} \nfinal Matcher m = ChannelService . NAME_PATTERN . matcher ( name ) ; \nif ( ! m . matches ( ) ) { \nctx . error ( \"names\" , String . format ( \"The channel name '%s' must match the pattern '%s'\" , name , ChannelService . NAME_PATTERN . pattern ( ) ) ) ; \n} \n} \n} \n"}
{"7891": "public class SeekableXZInputStream { \npublic void seekToBlock ( int blockNumber ) throws IOException { \nif ( in == null ) throw new XZIOException ( \"Stream closed\" ) ; \nif ( blockNumber < 0 ) throw new XZIOException ( \"Invalid XZ Block number: \" + blockNumber ) ; \nelse if ( blockNumber >= blockCount ) throw new XZIOException ( \"Invalid XZ Block number: \" + blockNumber ) ; \nseekPos = getBlockPos ( blockNumber ) ; \nseekNeeded = true ; \n} \n} \n"}
{"7892": "public class SeekableXZInputStream { \nprivate void locateBlockByPos ( BlockInfo info , long pos ) { \nif ( pos < 0 ) throw new IndexOutOfBoundsException ( \"Invalid uncompressed position: \" + pos ) ; \nelse if ( pos >= uncompressedSize ) throw new IndexOutOfBoundsException ( \"Invalid uncompressed position: \" + pos ) ; \nIndexDecoder index ; \nfor ( int i = 0 ; \n; \n++ i ) { \nindex = streams . get ( i ) ; \nif ( index . hasUncompressedOffset ( pos ) ) break ; \n} \nindex . locateBlock ( info , pos ) ; \nassert ( info . compressedOffset & 3 ) == 0 ; \nassert info . uncompressedSize > 0 ; \nassert pos >= info . uncompressedOffset ; \nassert pos < info . uncompressedOffset + info . uncompressedSize ; \n} \n} \n"}
{"7893": "public class UnzipServlet { \nprotected static List < MavenVersionedArtifact > getMavenArtifacts ( final String channelId , final Supplier < Collection < ArtifactInformation > > artifactsSupplier , final String groupId , final String artifactId , final boolean snapshot , final Predicate < ComparableVersion > versionFilter ) { \nfinal List < MavenVersionedArtifact > arts = new ArrayList < > ( ) ; \nfor ( final ArtifactInformation ai : artifactsSupplier . get ( ) ) { \nif ( ! isZip ( ai ) ) { \ncontinue ; \n} \nfinal String mvnGroupId = ai . getMetaData ( ) . get ( MK_GROUP_ID ) ; \nfinal String mvnArtifactId = ai . getMetaData ( ) . get ( MK_ARTIFACT_ID ) ; \nfinal String classifier = ai . getMetaData ( ) . get ( MK_CLASSIFIER ) ; \nfinal String mvnVersion = ai . getMetaData ( ) . get ( MK_VERSION ) ; \nfinal String mvnSnapshotVersion = ai . getMetaData ( ) . get ( MK_SNAPSHOT_VERSION ) ; \nif ( mvnGroupId == null || mvnArtifactId == null ) { \ncontinue ; \n} \nelse if ( mvnVersion == null ) { \ncontinue ; \n} \nif ( classifier != null ) { \nif ( ! classifier . isEmpty ( ) ) { \ncontinue ; \n} \n} \nif ( ! mvnGroupId . equals ( groupId ) ) { \ncontinue ; \n} \nelse if ( ! mvnArtifactId . equals ( artifactId ) ) { \ncontinue ; \n} \nif ( ! snapshot ) { \nif ( mvnSnapshotVersion != null || mvnVersion . endsWith ( \"-SNAPSHOT\" ) ) { \ncontinue ; \n} \n} \nfinal ComparableVersion v = parseVersion ( mvnVersion ) ; \nfinal ComparableVersion sv = parseVersion ( mvnSnapshotVersion ) ; \nif ( v == null ) { \ncontinue ; \n} \nif ( versionFilter == null ) { \narts . add ( new MavenVersionedArtifact ( sv != null ? sv : v , channelId , ai ) ) ; \n} \nelse if ( versionFilter . test ( v ) ) { \narts . add ( new MavenVersionedArtifact ( sv != null ? sv : v , channelId , ai ) ) ; \n} \nelse if ( sv != null ) { \nif ( versionFilter . test ( sv ) ) { \narts . add ( new MavenVersionedArtifact ( sv , channelId , ai ) ) ; \n} \n} \n} \nreturn arts ; \n} \n} \n"}
{"7895": "public class LZMAEncoderNormal { \nprivate void calc1BytePrices ( int pos , int posState , int avail , int anyRepPrice ) { \nboolean nextIsByte = false ; \nint curByte = lz . getByte ( 0 ) ; \nint matchByte = lz . getByte ( opts [ optCur ] . reps [ 0 ] + 1 ) ; \nint literalPrice = opts [ optCur ] . price + literalEncoder . getPrice ( curByte , matchByte , lz . getByte ( 1 ) , pos , opts [ optCur ] . state ) ; \nif ( literalPrice < opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( literalPrice , optCur , - 1 ) ; \nnextIsByte = true ; \n} \nif ( matchByte == curByte ) { \nif ( opts [ optCur + 1 ] . optPrev == optCur || opts [ optCur + 1 ] . backPrev != 0 ) { \nint shortRepPrice = getShortRepPrice ( anyRepPrice , opts [ optCur ] . state , posState ) ; \nif ( shortRepPrice <= opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( shortRepPrice , optCur , 0 ) ; \nnextIsByte = true ; \n} \n} \n} \nif ( ! nextIsByte && matchByte != curByte ) { \nif ( avail > MATCH_LEN_MIN ) { \nint lenLimit = Math . min ( niceLen , avail - 1 ) ; \nint len = lz . getMatchLen ( 1 , opts [ optCur ] . reps [ 0 ] , lenLimit ) ; \nif ( len >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + 1 ) & posMask ; \nint price = literalPrice + getLongRepAndLenPrice ( 0 , len , nextState , nextPosState ) ; \nint i = optCur + 1 + len ; \nwhile ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set2 ( price , optCur , 0 ) ; \n} \n} \n} \n} \n} \n"}
{"7908": "public class JspRuntimeContext { \nprivate void initClassPath ( ) { \nStringBuilder cpath = new StringBuilder ( ) ; \nString sep = System . getProperty ( \"path.separator\" ) ; \ncpath . append ( options . getScratchDir ( ) + sep ) ; \nString cp = ( String ) context . getAttribute ( Constants . SERVLET_CLASSPATH ) ; \nif ( cp == null ) { \ncp = options . getClassPath ( ) ; \n} \nelse if ( cp . equals ( \"\" ) ) { \ncp = options . getClassPath ( ) ; \n} \nif ( cp != null ) { \nclasspath = cpath . toString ( ) + cp ; \n} \nif ( classpath != null ) { \ntry { \nclasspath = URLDecoder . decode ( classpath , \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nif ( log . isLoggable ( Level . FINE ) ) log . log ( Level . FINE , \"Exception decoding classpath : \" + classpath , e ) ; \n} \n} \n} \n} \n"}
{"7921": "public class Parser { \nprivate boolean parseJspAttributeAndBody ( Node parent , String tag , String bodyType ) throws JasperException { \nboolean result = false ; \nif ( reader . matchesOptionalSpacesFollowedBy ( \"<jsp:attribute\" ) ) { \nparseNamedAttributes ( parent ) ; \nresult = true ; \n} \nif ( reader . matchesOptionalSpacesFollowedBy ( \"<jsp:body\" ) ) { \nparseJspBody ( parent , bodyType ) ; \nreader . skipSpaces ( ) ; \nif ( ! reader . matchesETag ( tag ) ) { \nerr . jspError ( reader . mark ( ) , \"jsp.error.unterminated\" , \"&lt;\" + tag ) ; \n} \nresult = true ; \n} \nelse if ( result ) { \nif ( ! reader . matchesETag ( tag ) ) { \nerr . jspError ( reader . mark ( ) , \"jsp.error.jspbody.required\" , \"&lt;\" + tag ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7927": "public class MavenCoordinates { \npublic MavenCoordinates toBase ( ) { \nif ( this . classifier == null ) { \nif ( this . extension == null ) { \nreturn this ; \n} \n} \nreturn new MavenCoordinates ( this . groupId , this . artifactId , this . version ) ; \n} \n} \n"}
{"7947": "public class LZMAEncoder { \npublic boolean encodeForLZMA2 ( ) { \ntry { \nif ( ! lz . isStarted ( ) ) { \nif ( ! encodeInit ( ) ) return false ; \n} \nwhile ( uncompressedSize <= LZMA2_UNCOMPRESSED_LIMIT && rc . getPendingSize ( ) <= LZMA2_COMPRESSED_LIMIT ) if ( ! encodeSymbol ( ) ) return false ; \n} \ncatch ( IOException e ) { \nthrow new Error ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"7951": "public class LZMAOutputStream { \npublic void finish ( ) throws IOException { \nif ( ! finished ) { \nif ( exception != null ) throw exception ; \ntry { \nif ( expectedUncompressedSize != - 1 ) { \nif ( expectedUncompressedSize != currentUncompressedSize ) throw new XZIOException ( \"Expected uncompressed size (\" + expectedUncompressedSize + \") doesn't equal \" + \"the number of bytes written to the stream (\" + currentUncompressedSize + \")\" ) ; \n} \nlz . setFinishing ( ) ; \nlzma . encodeForLZMA1 ( ) ; \nif ( useEndMarker ) lzma . encodeLZMA1EndMarker ( ) ; \nrc . finish ( ) ; \n} \ncatch ( IOException e ) { \nexception = e ; \nthrow e ; \n} \nfinished = true ; \nlzma . putArraysToCache ( arrayCache ) ; \nlzma = null ; \nlz = null ; \n} \n} \n} \n"}
{"7952": "public class PageContextImpl { \npublic Exception getException ( ) { \nThrowable t = JspRuntimeLibrary . getThrowable ( request ) ; \nif ( t != null ) { \nif ( ! ( t instanceof Exception ) ) { \nt = new JspException ( t ) ; \n} \n} \nreturn ( Exception ) t ; \n} \n} \n"}
{"7961": "public class JspC { \npublic void scanFiles ( File base ) throws JasperException { \nStack < String > dirs = new Stack < String > ( ) ; \ndirs . push ( base . toString ( ) ) ; \nif ( extensions == null ) { \nextensions = new ArrayList < String > ( ) ; \nextensions . add ( \"jsp\" ) ; \nextensions . add ( \"jspx\" ) ; \n} \nwhile ( ! dirs . isEmpty ( ) ) { \nString s = dirs . pop ( ) ; \nFile f = new File ( s ) ; \nif ( f . exists ( ) ) { \nif ( f . isDirectory ( ) ) { \nString [ ] files = f . list ( ) ; \nString ext ; \nfor ( int i = 0 ; \n( files != null ) && i < files . length ; \ni ++ ) { \nFile f2 = new File ( s , files [ i ] ) ; \nif ( f2 . isDirectory ( ) ) { \ndirs . push ( f2 . getPath ( ) ) ; \n} \nelse { \nString path = f2 . getPath ( ) ; \nString uri = path . substring ( uriRoot . length ( ) ) ; \next = files [ i ] . substring ( files [ i ] . lastIndexOf ( '.' ) + 1 ) ; \nif ( extensions . contains ( ext ) ) { \npages . add ( path ) ; \n} \nelse if ( jspConfig . isJspPage ( uri ) ) { \npages . add ( path ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"7962": "public class JspC { \nprivate void locateUriRoot ( File f ) { \nString tUriBase = uriBase ; \nif ( tUriBase == null ) { \ntUriBase = \"/\" ; \n} \ntry { \nif ( f . exists ( ) ) { \nf = new File ( f . getCanonicalPath ( ) ) ; \nwhile ( f != null ) { \nFile g = new File ( f , \"WEB-INF\" ) ; \nif ( g . exists ( ) ) { \nif ( g . isDirectory ( ) ) { \nuriRoot = f . getCanonicalPath ( ) ; \nuriBase = tUriBase ; \nif ( log . isLoggable ( Level . INFO ) ) { \nlog . info ( Localizer . getMessage ( \"jspc.implicit.uriRoot\" , uriRoot ) ) ; \n} \nbreak ; \n} \n} \nif ( f . exists ( ) ) { \nif ( f . isDirectory ( ) ) { \ntUriBase = \"/\" + f . getName ( ) + \"/\" + tUriBase ; \n} \n} \nString fParent = f . getParent ( ) ; \nif ( fParent == null ) { \nbreak ; \n} \nelse { \nf = new File ( fParent ) ; \n} \n} \nif ( uriRoot != null ) { \nFile froot = new File ( uriRoot ) ; \nuriRoot = froot . getCanonicalPath ( ) ; \n} \n} \n} \ncatch ( IOException ioe ) { \n} \n} \n} \n"}
{"7968": "public class JspReader { \nMark skipUntilIgnoreEsc ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nint prev = 'x' ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , prev = ch , ch = nextChar ( ) ) { \nif ( ch == '\\\\' && prev == '\\\\' ) { \nch = 0 ; \n} \nelse if ( ch == limit . charAt ( 0 ) ) { \nif ( prev != '\\\\' ) { \nfor ( int i = 1 ; \ni < limlen ; \ni ++ ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse continue skip ; \n} \nreturn ret ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"7970": "public class JspReader { \nString parseToken ( boolean quoted ) throws JasperException { \nStringBuilder stringBuffer = new StringBuilder ( ) ; \nskipSpaces ( ) ; \nstringBuffer . setLength ( 0 ) ; \nif ( ! hasMoreInput ( ) ) { \nreturn \"\" ; \n} \nint ch = peekChar ( ) ; \nif ( quoted ) { \nif ( ch == '\"' || ch == '\\'' ) { \nchar endQuote = ch == '\"' ? '\"' : '\\'' ; \nch = nextChar ( ) ; \nfor ( ch = nextChar ( ) ; \nch != - 1 && ch != endQuote ; \nch = nextChar ( ) ) { \nif ( ch == '\\\\' ) ch = nextChar ( ) ; \nstringBuffer . append ( ( char ) ch ) ; \n} \nif ( ch == - 1 ) { \nerr . jspError ( mark ( ) , \"jsp.error.quotes.unterminated\" ) ; \n} \n} \nelse { \nerr . jspError ( mark ( ) , \"jsp.error.attr.quoted\" ) ; \n} \n} \nelse { \nif ( ! isDelimiter ( ) ) { \ndo { \nch = nextChar ( ) ; \nif ( ch == '\\\\' ) { \nif ( peekChar ( ) == '\"' || peekChar ( ) == '\\'' || peekChar ( ) == '>' ) ch = nextChar ( ) ; \nelse if ( peekChar ( ) == '%' ) ch = nextChar ( ) ; \n} \nstringBuffer . append ( ( char ) ch ) ; \n} \nwhile ( ! isDelimiter ( ) ) ; \n} \n} \nreturn stringBuffer . toString ( ) ; \n} \n} \n"}
{"7971": "public class JspReader { \nprivate boolean popFile ( ) throws JasperException { \nif ( current == null ) { \nreturn false ; \n} \nelse if ( currFileId < 0 ) { \nreturn false ; \n} \nString fName = getFile ( currFileId ) ; \ncurrFileId = unregisterSourceFile ( fName ) ; \nif ( currFileId < - 1 ) { \nerr . jspError ( \"jsp.error.file.not.registered\" , fName ) ; \n} \nMark previous = current . popStream ( ) ; \nif ( previous != null ) { \nmaster = current . baseDir ; \ncurrent = previous ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"7986": "public class AetherImporter { \npublic static AetherResult asResult ( final Collection < ArtifactResult > results , final ImportConfiguration cfg , final Optional < DependencyResult > dependencyResult ) { \nfinal AetherResult result = new AetherResult ( ) ; \nfinal Set < String > requested = new HashSet < > ( cfg . getCoordinates ( ) . size ( ) ) ; \nfor ( final MavenCoordinates mc : cfg . getCoordinates ( ) ) { \nrequested . add ( mc . toString ( ) ) ; \n} \nfinal Map < String , Boolean > optionalDeps = new HashMap < > ( ) ; \nfillOptionalDependenciesMap ( dependencyResult , optionalDeps ) ; \nfor ( final ArtifactResult ar : results ) { \nfinal AetherResult . Entry entry = new AetherResult . Entry ( ) ; \nfinal MavenCoordinates coordinates = MavenCoordinates . fromResult ( ar ) ; \nfinal String key = coordinates . toBase ( ) . toString ( ) ; \nentry . setCoordinates ( coordinates ) ; \nentry . setResolved ( ar . isResolved ( ) ) ; \nentry . setRequested ( requested . contains ( key ) ) ; \nentry . setOptional ( optionalDeps . getOrDefault ( key , Boolean . FALSE ) ) ; \nif ( ar . getExceptions ( ) != null ) { \nif ( ! ar . getExceptions ( ) . isEmpty ( ) ) { \nfinal StringBuilder sb = new StringBuilder ( ar . getExceptions ( ) . get ( 0 ) . getMessage ( ) ) ; \nif ( ar . getExceptions ( ) . size ( ) > 1 ) { \nsb . append ( \" ...\" ) ; \n} \nentry . setError ( sb . toString ( ) ) ; \n} \n} \nresult . getArtifacts ( ) . add ( entry ) ; \n} \nCollections . sort ( result . getArtifacts ( ) , Comparator . comparing ( AetherResult . Entry :: getCoordinates ) ) ; \nresult . setRepositoryUrl ( cfg . getRepositoryUrl ( ) ) ; \nreturn result ; \n} \n} \n"}
{"7996": "public class JspCServletContext { \npublic Set < String > getResourcePaths ( String path ) { \nSet < String > thePaths = new HashSet < String > ( ) ; \nif ( ! path . endsWith ( \"/\" ) ) path += \"/\" ; \nString basePath = getRealPath ( path ) ; \nif ( basePath == null ) return ( thePaths ) ; \nFile theBaseDir = new File ( basePath ) ; \nif ( ! theBaseDir . exists ( ) ) return ( thePaths ) ; \nelse if ( ! theBaseDir . isDirectory ( ) ) return ( thePaths ) ; \nString theFiles [ ] = theBaseDir . list ( ) ; \nfor ( int i = 0 ; \ni < theFiles . length ; \ni ++ ) { \nFile testFile = new File ( basePath + File . separator + theFiles [ i ] ) ; \nif ( testFile . isFile ( ) ) thePaths . add ( path + theFiles [ i ] ) ; \nelse if ( testFile . isDirectory ( ) ) thePaths . add ( path + theFiles [ i ] + \"/\" ) ; \n} \nreturn ( thePaths ) ; \n} \n} \n"}
{"8004": "public class LZEncoder { \nprivate void processPendingBytes ( ) { \nif ( pendingSize > 0 ) { \nif ( readPos < readLimit ) { \nreadPos -= pendingSize ; \nint oldPendingSize = pendingSize ; \npendingSize = 0 ; \nskip ( oldPendingSize ) ; \nassert pendingSize < oldPendingSize ; \n} \n} \n} \n} \n"}
{"8008": "public class LZEncoder { \nint movePos ( int requiredForFlushing , int requiredForFinishing ) { \nassert requiredForFlushing >= requiredForFinishing ; \n++ readPos ; \nint avail = writePos - readPos ; \nif ( avail < requiredForFlushing ) { \nif ( avail < requiredForFinishing ) { \n++ pendingSize ; \navail = 0 ; \n} \nelse if ( ! finishing ) { \n++ pendingSize ; \navail = 0 ; \n} \n} \nreturn avail ; \n} \n} \n"}
{"8011": "public class JspWriterImpl { \npublic final void clear ( ) throws IOException { \nif ( bufferSize == 0 ) { \nif ( out != null ) throw new IllegalStateException ( getLocalizeMessage ( \"jsp.error.ise_on_clear\" ) ) ; \n} \nif ( flushed ) throw new IOException ( getLocalizeMessage ( \"jsp.error.attempt_to_clear_flushed_buffer\" ) ) ; \nensureOpen ( ) ; \nif ( buf != null ) buf . pos = buf . offset ; \n} \n} \n"}
{"8013": "public class JspWriterImpl { \npublic void close ( ) throws IOException { \nif ( response == null ) return ; \nelse if ( closed ) return ; \nflush ( ) ; \nif ( out != null ) out . close ( ) ; \nout = null ; \nbyteOut = null ; \nclosed = true ; \n} \n} \n"}
{"8014": "public class JspWriterImpl { \npublic void write ( boolean bytesOK , byte buf [ ] , String str ) throws IOException { \nensureOpen ( ) ; \nif ( bufferSize == 0 ) { \nif ( bytesOK ) { \ninitByteOut ( ) ; \nif ( implementsByteWriter ) { \nwrite ( buf , 0 , buf . length ) ; \nreturn ; \n} \n} \n} \nwrite ( str ) ; \n} \n} \n"}
{"8017": "public class Aggregator { \npublic List < String > makeKey ( final Map < MetaKey , String > metaData , final boolean requireAll ) { \nfinal List < String > result = new ArrayList < > ( this . fields . size ( ) ) ; \nfor ( final MetaKey field : this . fields ) { \nfinal String value = metaData . get ( field ) ; \nif ( requireAll ) { \nif ( value == null ) { \nreturn null ; \n} \n} \nresult . add ( value ) ; \n} \nreturn result ; \n} \n} \n"}
{"8018": "public class Compiler { \nprivate void generateClass ( ) throws FileNotFoundException , JasperException , Exception { \nlong t1 = 0 ; \nif ( log . isLoggable ( Level . FINE ) ) { \nt1 = System . currentTimeMillis ( ) ; \n} \nString javaFileName = ctxt . getServletJavaFileName ( ) ; \nsetJavaCompilerOptions ( ) ; \nJavacErrorDetail [ ] javacErrors = javaCompiler . compile ( ctxt . getFullClassName ( ) , pageNodes ) ; \nif ( javacErrors != null ) { \njavaCompiler . doJavaFile ( true ) ; \nlog . severe ( \"Error compiling file: \" + javaFileName ) ; \nerrDispatcher . javacError ( javacErrors ) ; \n} \nif ( log . isLoggable ( Level . FINE ) ) { \nlong t2 = System . currentTimeMillis ( ) ; \nlog . fine ( \"Compiled \" + javaFileName + \" \" + ( t2 - t1 ) + \"ms\" ) ; \n} \njavaCompiler . doJavaFile ( ctxt . keepGenerated ( ) ) ; \nif ( ! ctxt . isPrototypeMode ( ) ) { \nif ( ! options . isSmapSuppressed ( ) ) { \nsmapUtil . installSmap ( ) ; \n} \n} \nif ( jsw != null ) { \nif ( jsw . getServletClassLastModifiedTime ( ) <= 0 ) { \njsw . setServletClassLastModifiedTime ( javaCompiler . getClassLastModified ( ) ) ; \n} \n} \nif ( options . getSaveBytecode ( ) ) { \njavaCompiler . saveClassFile ( ctxt . getFullClassName ( ) , ctxt . getClassFileName ( ) ) ; \n} \nctxt . getRuntimeContext ( ) . adjustBytecodeTime ( ctxt . getFullClassName ( ) , jspModTime ) ; \n} \n} \n"}
{"8022": "public class Compiler { \nprivate boolean systemJarInWebinf ( String path ) { \nif ( path . indexOf ( \"/WEB-INF/\" ) < 0 ) { \nreturn false ; \n} \nBoolean useMyFaces = ( Boolean ) ctxt . getServletContext ( ) . getAttribute ( \"com.sun.faces.useMyFaces\" ) ; \nif ( useMyFaces == null ) { \nfor ( String jar : systemJsfJars ) { \nif ( path . indexOf ( jar ) > 0 ) { \nreturn true ; \n} \n} \n} \nelse if ( ! useMyFaces ) { \nfor ( String jar : systemJsfJars ) { \nif ( path . indexOf ( jar ) > 0 ) { \nreturn true ; \n} \n} \n} \nfor ( String jar : systemJars ) { \nif ( path . indexOf ( jar ) > 0 ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8026": "public class Generator { \nprivate void generateXmlProlog ( Node . Nodes page ) { \nString omitXmlDecl = pageInfo . getOmitXmlDecl ( ) ; \nif ( omitXmlDecl != null && ! JspUtil . booleanValue ( omitXmlDecl ) ) { \nString cType = pageInfo . getContentType ( ) ; \nString charSet = cType . substring ( cType . indexOf ( \"charset=\" ) + 8 ) ; \nout . printil ( \"out.write(\\\"<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"\" + charSet + \"\\\\\\\"?>\\\\n\\\");\" ) ; \n} \nelse if ( omitXmlDecl == null && page . getRoot ( ) . isXmlSyntax ( ) && ! pageInfo . hasJspRoot ( ) && ! ctxt . isTagFile ( ) ) { \nString cType = pageInfo . getContentType ( ) ; \nString charSet = cType . substring ( cType . indexOf ( \"charset=\" ) + 8 ) ; \nout . printil ( \"out.write(\\\"<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"\" + charSet + \"\\\\\\\"?>\\\\n\\\");\" ) ; \n} \nString doctypeName = pageInfo . getDoctypeName ( ) ; \nif ( doctypeName != null ) { \nString doctypePublic = pageInfo . getDoctypePublic ( ) ; \nString doctypeSystem = pageInfo . getDoctypeSystem ( ) ; \nout . printin ( \"out.write(\\\"<!DOCTYPE \" ) ; \nout . print ( doctypeName ) ; \nif ( doctypePublic == null ) { \nout . print ( \" SYSTEM \\\\\\\"\" ) ; \n} \nelse { \nout . print ( \" PUBLIC \\\\\\\"\" ) ; \nout . print ( doctypePublic ) ; \nout . print ( \"\\\\\\\" \\\\\\\"\" ) ; \n} \nout . print ( doctypeSystem ) ; \nout . println ( \"\\\\\\\">\\\\n\\\");\" ) ; \n} \n} \n} \n"}
{"8031": "public class TransferServiceImpl { \nprivate Map < MetaKey , String > readProperties ( final InputStream stream ) throws IOException { \ntry { \nfinal Document doc = this . xmlToolsFactory . newDocumentBuilder ( ) . parse ( new FilterInputStream ( stream ) { \n@ Override public void close ( ) { \n} \n} \n) ; \nfinal Element root = doc . getDocumentElement ( ) ; \nif ( ! \"properties\" . equals ( root . getNodeName ( ) ) ) { \nthrow new IllegalStateException ( String . format ( \"Root element must be of type '%s'\" , \"properties\" ) ) ; \n} \nfinal Map < MetaKey , String > result = new HashMap < > ( ) ; \nfor ( final Element ele : XmlHelper . iterElement ( root , \"property\" ) ) { \nfinal String namespace = ele . getAttribute ( \"namespace\" ) ; \nfinal String key = ele . getAttribute ( \"key\" ) ; \nfinal String value = ele . getTextContent ( ) ; \nif ( namespace . isEmpty ( ) ) { \ncontinue ; \n} \nelse if ( key . isEmpty ( ) ) { \ncontinue ; \n} \nresult . put ( new MetaKey ( namespace , key ) , value ) ; \n} \nreturn result ; \n} \ncatch ( final Exception e ) { \nthrow new IOException ( \"Failed to read properties\" , e ) ; \n} \n} \n} \n"}
{"8033": "public class Validator { \nprivate static void validateXmlView ( PageData xmlView , Compiler compiler ) throws JasperException { \nStringBuilder errMsg = null ; \nErrorDispatcher errDisp = compiler . getErrorDispatcher ( ) ; \nfor ( Iterator < TagLibraryInfo > iter = compiler . getPageInfo ( ) . getTaglibs ( ) . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nTagLibraryInfo o = iter . next ( ) ; \nif ( ! ( o instanceof TagLibraryInfoImpl ) ) continue ; \nTagLibraryInfoImpl tli = ( TagLibraryInfoImpl ) o ; \nValidationMessage [ ] errors = tli . validate ( xmlView ) ; \nif ( errors != null ) { \nif ( errors . length != 0 ) { \nif ( errMsg == null ) { \nerrMsg = new StringBuilder ( ) ; \n} \nerrMsg . append ( \"<h3>\" ) ; \nerrMsg . append ( Localizer . getMessage ( \"jsp.error.tlv.invalid.page\" , tli . getShortName ( ) ) ) ; \nerrMsg . append ( \"</h3>\" ) ; \nfor ( int i = 0 ; \ni < errors . length ; \ni ++ ) { \nif ( errors [ i ] != null ) { \nerrMsg . append ( \"<p>\" ) ; \nerrMsg . append ( errors [ i ] . getId ( ) ) ; \nerrMsg . append ( \": \" ) ; \nerrMsg . append ( errors [ i ] . getMessage ( ) ) ; \nerrMsg . append ( \"</p>\" ) ; \n} \n} \n} \n} \n} \nif ( errMsg != null ) { \nerrDisp . jspError ( errMsg . toString ( ) ) ; \n} \n} \n} \n"}
{"8036": "public class JspConfig { \nprivate JspPropertyGroup selectProperty ( JspPropertyGroup prev , JspPropertyGroup curr ) { \nif ( prev == null ) { \nreturn curr ; \n} \nif ( prev . getExtension ( ) == null ) { \nreturn prev ; \n} \nif ( curr . getExtension ( ) == null ) { \nreturn curr ; \n} \nString prevPath = prev . getPath ( ) ; \nString currPath = curr . getPath ( ) ; \nif ( prevPath == null ) { \nif ( currPath == null ) { \nreturn prev ; \n} \n} \nif ( prevPath == null ) { \nif ( currPath != null ) { \nreturn curr ; \n} \n} \nif ( prevPath != null ) { \nif ( currPath == null ) { \nreturn prev ; \n} \n} \nif ( prevPath . length ( ) >= currPath . length ( ) ) { \nreturn prev ; \n} \nreturn curr ; \n} \n} \n"}
{"8037": "public class JspConfig { \npublic boolean isJspPage ( String uri ) throws JasperException { \ninit ( ) ; \nif ( jspProperties == null ) { \nreturn false ; \n} \nString uriPath = null ; \nint index = uri . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) { \nuriPath = uri . substring ( 0 , index + 1 ) ; \n} \nString uriExtension = null ; \nindex = uri . lastIndexOf ( '.' ) ; \nif ( index >= 0 ) { \nuriExtension = uri . substring ( index + 1 ) ; \n} \nfor ( JspPropertyGroup jpg : jspProperties ) { \nJspProperty jp = jpg . getJspProperty ( ) ; \nString extension = jpg . getExtension ( ) ; \nString path = jpg . getPath ( ) ; \nif ( extension == null ) { \nif ( uri . equals ( path ) ) { \nreturn true ; \n} \n} \nelse { \nif ( path == null || path . equals ( uriPath ) ) { \nif ( extension . equals ( \"*\" ) || extension . equals ( uriExtension ) ) { \nreturn true ; \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8038": "public class ServletWriter { \npublic void printComment ( Mark start , Mark stop , char [ ] chars ) { \nif ( start != null ) { \nif ( stop != null ) { \nprintln ( \"// from=\" + start ) ; \nprintln ( \"//   to=\" + stop ) ; \n} \n} \nif ( chars != null ) for ( int i = 0 ; \ni < chars . length ; \n) { \nprintin ( ) ; \nprint ( \"// \" ) ; \nwhile ( chars [ i ] != '\\n' && i < chars . length ) writer . print ( chars [ i ++ ] ) ; \n} \n} \n} \n"}
{"8043": "public class JspUtil { \npublic static void checkScope ( String scope , Node n , ErrorDispatcher err ) throws JasperException { \nif ( scope != null && ! scope . equals ( \"page\" ) && ! scope . equals ( \"request\" ) && ! scope . equals ( \"session\" ) ) { \nif ( ! scope . equals ( \"application\" ) ) { \nerr . jspError ( n , \"jsp.error.invalid.scope\" , scope ) ; \n} \n} \n} \n} \n"}
{"8054": "public class Functions { \npublic static SortedSet < String > metadata ( final Map < MetaKey , String > metadata , String namespace , String key ) { \nfinal SortedSet < String > result = new TreeSet < > ( ) ; \nif ( namespace . isEmpty ( ) ) { \nnamespace = null ; \n} \nif ( key . isEmpty ( ) ) { \nkey = null ; \n} \nfor ( final Map . Entry < MetaKey , String > entry : metadata . entrySet ( ) ) { \nif ( namespace != null ) { \nif ( ! namespace . equals ( entry . getKey ( ) . getNamespace ( ) ) ) { \ncontinue ; \n} \n} \nif ( key != null ) { \nif ( ! key . equals ( entry . getKey ( ) . getKey ( ) ) ) { \ncontinue ; \n} \n} \nresult . add ( entry . getValue ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"8055": "public class DatabaseUserService { \n@ Override public void run ( ) throws Exception { \nthis . storageManager . modifyRun ( MODEL_KEY , UserWriteModel . class , users -> { \nfinal Date timeout = new Date ( System . currentTimeMillis ( ) - getTimeout ( ) ) ; \nfinal Collection < UserEntity > updates = new LinkedList < > ( ) ; \nfinal Collection < String > removals = new LinkedList < > ( ) ; \nfor ( final UserEntity user : users . asCollection ( ) ) { \nif ( user . getEmailTokenDate ( ) == null ) { \ncontinue ; \n} \nelse if ( user . getEmailTokenDate ( ) . after ( timeout ) ) { \ncontinue ; \n} \nif ( user . isEmailVerified ( ) ) { \nuser . setEmailToken ( null ) ; \nuser . setEmailTokenDate ( null ) ; \nuser . setEmailTokenSalt ( null ) ; \nupdates . add ( user ) ; \n} \nelse { \nremovals . add ( user . getId ( ) ) ; \n} \n} \nupdates . forEach ( users :: putUser ) ; \nremovals . forEach ( users :: removeUser ) ; \n} \n) ; \n} \n} \n"}
{"8057": "public class MetadataCache { \npublic boolean put ( Locator locator , String key , String value ) throws CacheException { \nif ( value == null ) return false ; \nTimer . Context cachePutTimerContext = MetadataCache . cachePutTimer . time ( ) ; \nboolean dbWrite = false ; \ntry { \nCacheKey cacheKey = new CacheKey ( locator , key ) ; \nString oldValue = cache . getIfPresent ( cacheKey ) ; \ncache . put ( cacheKey , value ) ; \nif ( oldValue == null ) { \ndbWrite = true ; \n} \nelse if ( ! oldValue . equals ( value ) ) { \ndbWrite = true ; \n} \nif ( dbWrite ) { \nupdatedMetricMeter . mark ( ) ; \nif ( ! batchedWrites ) { \ndatabasePut ( locator , key , value ) ; \n} \nelse { \ndatabaseLazyWrite ( locator , key ) ; \n} \n} \nreturn dbWrite ; \n} \nfinally { \ncachePutTimerContext . stop ( ) ; \n} \n} \n} \n"}
{"8058": "public class MetadataCache { \nprivate String databaseLoad ( Locator locator , String key ) throws CacheException { \ntry { \nCacheKey cacheKey = new CacheKey ( locator , key ) ; \nMap < String , String > metadata = io . getAllValues ( locator ) ; \nif ( metadata == null ) { \ncache . put ( cacheKey , NULL ) ; \nreturn NULL ; \n} \nelse if ( metadata . isEmpty ( ) ) { \ncache . put ( cacheKey , NULL ) ; \nreturn NULL ; \n} \nint metadataRowSize = 0 ; \nfor ( Map . Entry < String , String > meta : metadata . entrySet ( ) ) { \nmetadataRowSize += meta . getKey ( ) . getBytes ( ) . length + locator . toString ( ) . getBytes ( ) . length ; \nif ( meta . getValue ( ) != null ) metadataRowSize += meta . getValue ( ) . getBytes ( ) . length ; \nif ( meta . getKey ( ) . equals ( key ) ) continue ; \nCacheKey metaKey = new CacheKey ( locator , meta . getKey ( ) ) ; \ncache . put ( metaKey , meta . getValue ( ) ) ; \n} \ntotalMetadataSize . update ( metadataRowSize ) ; \nString value = metadata . get ( key ) ; \nif ( value == null ) { \ncache . put ( cacheKey , NULL ) ; \nvalue = NULL ; \n} \nreturn value ; \n} \ncatch ( IOException ex ) { \nthrow new CacheException ( ex ) ; \n} \n} \n} \n"}
{"8090": "public class MetricIndexData { \nprivate Set < String > getCompleteMetricNames ( Map < String , MetricIndexDocCount > metricIndexMap ) { \nSet < String > completeMetricNames = new HashSet < String > ( ) ; \nfor ( Map . Entry < String , MetricIndexDocCount > entry : metricIndexMap . entrySet ( ) ) { \nMetricIndexDocCount metricIndexDocCount = entry . getValue ( ) ; \nif ( metricIndexDocCount != null ) { \nif ( metricIndexDocCount . actualDocCount > 0 ) { \nif ( metricIndexDocCount . actualDocCount > metricIndexDocCount . childrenTotalDocCount ) { \ncompleteMetricNames . add ( entry . getKey ( ) ) ; \n} \n} \n} \n} \nreturn Collections . unmodifiableSet ( completeMetricNames ) ; \n} \n} \n"}
{"8091": "public class Token { \npublic static List < Token > getTokens ( Locator locator ) { \nif ( StringUtils . isEmpty ( locator . getMetricName ( ) ) ) return new ArrayList < > ( ) ; \nelse if ( StringUtils . isEmpty ( locator . getTenantId ( ) ) ) return new ArrayList < > ( ) ; \nString [ ] tokens = locator . getMetricName ( ) . split ( Locator . METRIC_TOKEN_SEPARATOR_REGEX ) ; \nreturn IntStream . range ( 0 , tokens . length ) . mapToObj ( index -> new Token ( locator , tokens , index ) ) . collect ( toList ( ) ) ; \n} \n} \n"}
{"8163": "public class NumberUtils { \npublic static boolean isNumeric ( String value , Locale locale ) { \nif ( value == null ) return false ; \nint start = 0 ; \nfinal DecimalFormatSymbols symbols = ( locale != null ) ? DecimalFormatSymbols . getInstance ( locale ) : DecimalFormatSymbols . getInstance ( ) ; \nif ( value . startsWith ( \"+\" ) ) start ++ ; \nelse if ( value . startsWith ( \"-\" ) ) start ++ ; \nboolean fraction = false ; \nfor ( int i = start ; \ni < value . length ( ) ; \ni ++ ) { \nfinal char c = value . charAt ( i ) ; \nif ( c == symbols . getDecimalSeparator ( ) ) { \nif ( ! fraction ) { \nfraction = true ; \ncontinue ; \n} \n} \nif ( c == symbols . getGroupingSeparator ( ) ) { \nif ( ! fraction ) { \ncontinue ; \n} \n} \nif ( ! Character . isDigit ( c ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"8181": "public class LocaleUtils { \npublic static String getCountryISO2 ( String country ) { \ncountry = StringUtils . trimToNull ( country ) ; \nif ( country == null ) return null ; \nif ( country . length ( ) == 2 ) return country ; \nString [ ] iso2Codes = Locale . getISOCountries ( ) ; \nif ( country . length ( ) == 3 ) { \nString iso2Code = LocaleUtils . getCountryISO2FromISO3 ( country ) ; \nif ( iso2Code != null ) return iso2Code ; \n} \nfor ( String iso2Code : iso2Codes ) { \nLocale countryLocale = new Locale ( iso2Code , iso2Code ) ; \nfor ( Locale translationLocale : LocaleUtils . availableLocaleList ( ) ) { \nString name = StringUtils . trimToNull ( countryLocale . getDisplayCountry ( translationLocale ) ) ; \nif ( name != null ) { \nif ( name . equalsIgnoreCase ( country ) ) return iso2Code ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8182": "public class LocaleUtils { \npublic static String getCountryISO2FromISO3 ( String iso3Code ) { \niso3Code = StringUtils . trimToNull ( iso3Code ) ; \nif ( iso3Code == null ) return null ; \nif ( iso3Code . length ( ) == 3 ) { \nfor ( String iso2Code : Locale . getISOCountries ( ) ) { \nLocale countryLocale = new Locale ( iso2Code , iso2Code ) ; \nString countryISO3 = StringUtils . trimToNull ( countryLocale . getISO3Country ( ) ) ; \nif ( countryISO3 != null ) { \nif ( countryISO3 . equalsIgnoreCase ( iso3Code ) ) { \nreturn iso2Code ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8183": "public class LocaleUtils { \npublic static String getCountryISO3 ( String country ) { \ncountry = StringUtils . trimToNull ( country ) ; \nif ( country == null ) return null ; \nif ( country . length ( ) == 3 ) return country ; \nString [ ] iso2Codes = Locale . getISOCountries ( ) ; \nif ( country . length ( ) == 2 ) { \nString iso3code = LocaleUtils . getCountryISO3FromISO2 ( country ) ; \nif ( iso3code != null ) return iso3code ; \n} \nfor ( String iso2Code : iso2Codes ) { \nLocale countryLocale = new Locale ( iso2Code , iso2Code ) ; \nString iso3Code = StringUtils . trimToNull ( countryLocale . getISO3Country ( ) ) ; \nif ( iso3Code == null ) continue ; \nfor ( Locale translationLocale : LocaleUtils . availableLocaleList ( ) ) { \nString name = StringUtils . trimToNull ( countryLocale . getDisplayCountry ( translationLocale ) ) ; \nif ( name != null ) { \nif ( name . equalsIgnoreCase ( country ) ) return iso3Code ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8186": "public class LocaleUtils { \npublic static String translateCountryName ( String country , Locale language ) { \ncountry = StringUtils . trimToNull ( country ) ; \nif ( country == null ) return null ; \nfor ( String iso2Code : Locale . getISOCountries ( ) ) { \nLocale countryLocale = new Locale ( iso2Code , iso2Code ) ; \nfor ( Locale translationLocale : LocaleUtils . availableLocaleList ( ) ) { \nString name = StringUtils . trimToNull ( countryLocale . getDisplayCountry ( translationLocale ) ) ; \nif ( name != null ) { \nif ( name . equalsIgnoreCase ( country ) ) { \nname = StringUtils . trimToNull ( countryLocale . getDisplayCountry ( language ) ) ; \nif ( name != null ) return name ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8204": "public class XmlValidationHandler { \n@ Override public boolean handleEvent ( ValidationEvent event ) { \nif ( event == null ) throw new IllegalArgumentException ( \"No validation event was provided!\" ) ; \nint line = - 1 ; \nint col = - 1 ; \nif ( event . getLocator ( ) != null ) { \nline = event . getLocator ( ) . getLineNumber ( ) ; \ncol = event . getLocator ( ) . getColumnNumber ( ) ; \n} \nif ( ValidationEvent . FATAL_ERROR == event . getSeverity ( ) ) { \nLOGGER . warn ( \"fatal validation error\" ) ; \nif ( line > - 1 ) { \nif ( col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \n} \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \nreturn false ; \n} \nif ( ValidationEvent . WARNING == event . getSeverity ( ) ) { \nLOGGER . warn ( \"validation warning\" ) ; \nif ( line > - 1 ) { \nif ( col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \n} \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \nelse { \nLOGGER . warn ( \"validation error\" ) ; \nif ( line > - 1 ) { \nif ( col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \n} \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"8354": "public class XmlValidationModeDetector { \nprivate String consumeCommentTokens ( String line ) { \nif ( line . indexOf ( START_COMMENT ) == - 1 ) { \nif ( line . indexOf ( END_COMMENT ) == - 1 ) { \nreturn line ; \n} \n} \nwhile ( ( line = consume ( line ) ) != null ) { \nif ( ! this . inComment ) { \nif ( ! line . trim ( ) . startsWith ( START_COMMENT ) ) { \nreturn line ; \n} \n} \n} \nreturn line ; \n} \n} \n"}
{"8370": "public class MethodInvoker { \npublic void prepare ( ) throws ClassNotFoundException , NoSuchMethodException { \nif ( this . staticMethod != null ) { \nint lastDotIndex = this . staticMethod . lastIndexOf ( '.' ) ; \nif ( lastDotIndex == - 1 ) { \nthrow new IllegalArgumentException ( \"staticMethod must be a fully qualified class plus method name: \" + \"e.g. 'example.MyExampleClass.myExampleMethod'\" ) ; \n} \nelse if ( lastDotIndex == this . staticMethod . length ( ) ) { \nthrow new IllegalArgumentException ( \"staticMethod must be a fully qualified class plus method name: \" + \"e.g. 'example.MyExampleClass.myExampleMethod'\" ) ; \n} \nString className = this . staticMethod . substring ( 0 , lastDotIndex ) ; \nString methodName = this . staticMethod . substring ( lastDotIndex + 1 ) ; \nthis . targetClass = resolveClassName ( className ) ; \nthis . targetMethod = methodName ; \n} \nClass < ? > targetClass = getTargetClass ( ) ; \nString targetMethod = getTargetMethod ( ) ; \nif ( targetClass == null ) { \nthrow new IllegalArgumentException ( \"Either 'targetClass' or 'targetObject' is required\" ) ; \n} \nif ( targetMethod == null ) { \nthrow new IllegalArgumentException ( \"Property 'targetMethod' is required\" ) ; \n} \nObject [ ] arguments = getArguments ( ) ; \nClass < ? > [ ] argTypes = new Class < ? > [ arguments . length ] ; \nfor ( int i = 0 ; \ni < arguments . length ; \n++ i ) { \nargTypes [ i ] = ( arguments [ i ] != null ? arguments [ i ] . getClass ( ) : Object . class ) ; \n} \ntry { \nthis . methodObject = targetClass . getMethod ( targetMethod , argTypes ) ; \n} \ncatch ( NoSuchMethodException ex ) { \nthis . methodObject = findMatchingMethod ( ) ; \nif ( this . methodObject == null ) { \nthrow ex ; \n} \n} \n} \n} \n"}
{"8375": "public class DomUtils { \npublic static Element getChildElementByTagName ( Element ele , String childEleName ) { \nAssert . notNull ( ele , \"Element must not be null\" ) ; \nAssert . notNull ( childEleName , \"Element name must not be null\" ) ; \nNodeList nl = ele . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nl . getLength ( ) ; \ni ++ ) { \nNode node = nl . item ( i ) ; \nif ( node instanceof Element ) { \nif ( nodeNameMatch ( node , childEleName ) ) { \nreturn ( Element ) node ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8395": "public class ServerMethods { \npublic String [ ] get_keyword_names ( ) { \ntry { \nString [ ] names = servlet . getLibrary ( ) . getKeywordNames ( ) ; \nif ( names == null ) throw new RuntimeException ( \"No keywords found in the test library\" ) ; \nelse if ( names . length == 0 ) throw new RuntimeException ( \"No keywords found in the test library\" ) ; \nString [ ] newNames = Arrays . copyOf ( names , names . length + 1 ) ; \nnewNames [ names . length ] = \"stop_remote_server\" ; \nreturn newNames ; \n} \ncatch ( Throwable e ) { \nlog . warn ( \"\" , e ) ; \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"8409": "public class FloatingActionButton { \nprotected static int getShadowRadius ( Drawable shadow , Drawable circle ) { \nint radius = 0 ; \nif ( shadow != null ) { \nif ( circle != null ) { \nRect rect = new Rect ( ) ; \nradius = ( circle . getIntrinsicWidth ( ) + ( shadow . getPadding ( rect ) ? rect . left + rect . right : 0 ) ) / 2 ; \n} \n} \nreturn Math . max ( 1 , radius ) ; \n} \n} \n"}
{"8415": "public class MdPageGeneratorMojo { \nprivate String getTitle ( List < String > raw ) { \nif ( raw == null ) { \nreturn defaultTitle ; \n} \nString previousLine = \"\" ; \nfor ( String line : raw ) { \nline = line . trim ( ) ; \nif ( line . startsWith ( \"#\" ) ) { \nline = line . replace ( \"#\" , \"\" ) ; \nreturn line ; \n} \nif ( line . startsWith ( \"=\" ) && StringUtils . countMatches ( line , \"=\" ) == previousLine . length ( ) && line . matches ( \"^=+$\" ) ) { \nreturn previousLine ; \n} \nelse if ( line . startsWith ( \"-\" ) && StringUtils . countMatches ( line , \"-\" ) == previousLine . length ( ) && line . matches ( \"^-+$\" ) ) { \nreturn previousLine ; \n} \npreviousLine = line ; \n} \nreturn defaultTitle ; \n} \n} \n"}
{"8417": "public class MdPageGeneratorMojo { \nprivate String replaceVariables ( String initialContent , Map < String , String > variables ) { \nString newContent = initialContent ; \nif ( applyFiltering ) { \nif ( newContent != null ) { \nnewContent = newContent . replaceAll ( \"\\\\{\\\\w*=.*}\" , \"\" ) ; \nif ( variables != null ) { \nnewContent = substituteVariables ( newContent , \"\\\\$\\\\{(.+?)\\\\}\" , variables ) ; \n} \n} \n} \nreturn newContent ; \n} \n} \n"}
{"8420": "public class BaseClient { \nprotected String checkPath ( String path ) { \nif ( path . toLowerCase ( ) . contains ( \"statements\" ) ) { \nif ( path . toLowerCase ( ) . contains ( \"more\" ) ) { \nint pathLength = this . _host . getPath ( ) . length ( ) ; \nreturn path . substring ( pathLength , path . length ( ) ) ; \n} \n} \nreturn path ; \n} \n} \n"}
{"8421": "public class CrossfadeDrawerLayout { \nprivate View wrapSliderContent ( View child , int index ) { \nif ( index == 1 ) { \nif ( child . getId ( ) != - 1 ) { \nmLargeView = ( ViewGroup ) child ; \nmContainer = new ScrimInsetsRelativeLayout ( getContext ( ) ) ; \nmContainer . setGravity ( Gravity . START ) ; \nmContainer . setLayoutParams ( child . getLayoutParams ( ) ) ; \nmContainer . addView ( mLargeView , ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; \nmSmallView = new LinearLayout ( getContext ( ) ) ; \nmContainer . addView ( mSmallView , ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ; \nmLargeView . setAlpha ( 0 ) ; \nmLargeView . setVisibility ( View . GONE ) ; \nmContainer . setFitsSystemWindows ( true ) ; \nmSmallView . setFitsSystemWindows ( true ) ; \nreturn mContainer ; \n} \n} \nreturn child ; \n} \n} \n"}
{"8427": "public class UseActivityInterceptor { \n@ SuppressWarnings ( \"unchecked\" ) private void launchActivity ( ) { \nif ( activity != null ) { \nif ( ActivityRunMode . SPECIFICATION . equals ( activityRunMode ) ) return ; \n} \nString targetPackage = instrumentation . getTargetContext ( ) . getPackageName ( ) ; \nIntent intent = getLaunchIntent ( targetPackage , activityClass , bundleCreator ) ; \nactivity = instrumentation . startActivitySync ( intent ) ; \ninstrumentation . waitForIdleSync ( ) ; \n} \n} \n"}
{"8452": "public class GMOperation { \npublic GMOperation source ( final File file , @ CheckForNull final Integer width , @ CheckForNull final Integer height ) throws IOException { \nif ( file != null ) { \nif ( ! file . exists ( ) ) { \nthrow new IOException ( \"Source file '\" + file + \"' does not exist\" ) ; \n} \n} \nif ( ( width != null ) && ( height != null ) && ( width > 0 ) ) { \nif ( height > 0 ) { \nsize ( width , height ) ; \n} \n} \nreturn addImage ( file ) ; \n} \n} \n"}
{"8469": "public class JNE { \nstatic private File getOrCreateTempDirectory ( boolean deleteOnExit ) throws ExtractException { \nif ( TEMP_DIRECTORY != null ) { \nif ( TEMP_DIRECTORY . exists ( ) ) { \nreturn TEMP_DIRECTORY ; \n} \n} \ntry { \nPath baseDir = Paths . get ( System . getProperty ( \"java.io.tmpdir\" ) ) ; \nPath tempDirectory = baseDir . resolve ( \"jne.\" + UUID . randomUUID ( ) . toString ( ) ) ; \nFiles . createDirectories ( tempDirectory ) ; \nFile tempDirectoryAsFile = tempDirectory . toFile ( ) ; \nif ( deleteOnExit ) { \ntempDirectoryAsFile . deleteOnExit ( ) ; \n} \nTEMP_DIRECTORY = tempDirectoryAsFile ; \nreturn TEMP_DIRECTORY ; \n} \ncatch ( IOException e ) { \nthrow new ExtractException ( \"Unable to create temporary dir\" , e ) ; \n} \n} \n} \n"}
{"8485": "public class StenoSerializationHelper { \npublic static void serializeThrowable ( final IThrowableProxy throwableProxy , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper ) throws IOException { \njsonGenerator . writeStringField ( \"type\" , throwableProxy . getClassName ( ) ) ; \njsonGenerator . writeStringField ( \"message\" , throwableProxy . getMessage ( ) ) ; \njsonGenerator . writeArrayFieldStart ( \"backtrace\" ) ; \nfor ( final StackTraceElementProxy ste : throwableProxy . getStackTraceElementProxyArray ( ) ) { \njsonGenerator . writeString ( ste . toString ( ) ) ; \n} \njsonGenerator . writeEndArray ( ) ; \njsonGenerator . writeObjectFieldStart ( \"data\" ) ; \nif ( throwableProxy instanceof ThrowableProxy ) { \nfinal JsonNode jsonNode = objectMapper . valueToTree ( ( ( ThrowableProxy ) throwableProxy ) . getThrowable ( ) ) ; \nfor ( final Iterator < Map . Entry < String , JsonNode > > iterator = jsonNode . fields ( ) ; \niterator . hasNext ( ) ; \n) { \nfinal Map . Entry < String , JsonNode > field = iterator . next ( ) ; \njsonGenerator . writeFieldName ( field . getKey ( ) ) ; \nobjectMapper . writeValue ( jsonGenerator , field . getValue ( ) ) ; \n} \n} \nif ( throwableProxy . getSuppressed ( ) != null ) { \nif ( throwableProxy . getSuppressed ( ) . length > 0 ) { \njsonGenerator . writeArrayFieldStart ( \"suppressed\" ) ; \nfor ( final IThrowableProxy suppressed : throwableProxy . getSuppressed ( ) ) { \njsonGenerator . writeStartObject ( ) ; \nserializeThrowable ( suppressed , jsonGenerator , objectMapper ) ; \njsonGenerator . writeEndObject ( ) ; \n} \njsonGenerator . writeEndArray ( ) ; \n} \n} \nif ( throwableProxy . getCause ( ) != null ) { \njsonGenerator . writeObjectFieldStart ( \"cause\" ) ; \nserializeThrowable ( throwableProxy . getCause ( ) , jsonGenerator , objectMapper ) ; \njsonGenerator . writeEndObject ( ) ; \n} \njsonGenerator . writeEndObject ( ) ; \n} \n} \n"}
{"8491": "public class SaveAttrsUtility { \npublic static String parseSaveAttr ( final Cell cell , final Map < String , String > saveCommentsMap ) { \nif ( cell != null ) { \nString key = cell . getSheet ( ) . getSheetName ( ) + \"!\" + CellUtility . getCellIndexNumberKey ( cell . getColumnIndex ( ) , cell . getRowIndex ( ) ) ; \nString saveAttr = null ; \nif ( saveCommentsMap != null ) { \nsaveAttr = ParserUtility . getStringBetweenBracket ( saveCommentsMap . get ( key ) ) ; \n} \nif ( saveAttr == null ) { \nif ( cell . getCellTypeEnum ( ) == CellType . STRING ) { \nsaveAttr = SaveAttrsUtility . parseSaveAttrString ( cell . getStringCellValue ( ) ) ; \n} \n} \nif ( saveAttr != null ) { \nif ( ! saveAttr . isEmpty ( ) ) { \nreturn TieConstants . CELL_ADDR_PRE_FIX + cell . getColumnIndex ( ) + \"=\" + saveAttr + \",\" ; \n} \n} \n} \nreturn \"\" ; \n} \n} \n"}
{"8494": "public class SaveAttrsUtility { \npublic static String parseSaveAttrString ( final String strValue ) { \nif ( strValue != null ) { \nint first = strValue . indexOf ( TieConstants . METHOD_PREFIX ) ; \nint last = strValue . lastIndexOf ( TieConstants . METHOD_PREFIX ) ; \nint end = strValue . lastIndexOf ( TieConstants . METHOD_END ) ; \nif ( ( first >= 0 ) && ( first == last ) ) { \nif ( end > 1 ) { \nreturn strValue . substring ( first + 2 , end ) ; \n} \n} \n} \nreturn \"\" ; \n} \n} \n"}
{"8495": "public class SaveAttrsUtility { \npublic static String getSaveAttrListFromRow ( final Row row ) { \nif ( row != null ) { \nCell cell = row . getCell ( TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN ) ; \nif ( cell != null ) { \nString str = cell . getStringCellValue ( ) ; \nif ( str != null ) { \nif ( ! str . isEmpty ( ) ) { \nreturn str ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8496": "public class SaveAttrsUtility { \npublic static String getSaveAttrFromList ( final int columnIndex , final String saveAttrs ) { \nif ( saveAttrs != null ) { \nif ( ! saveAttrs . isEmpty ( ) ) { \nString str = TieConstants . CELL_ADDR_PRE_FIX + columnIndex + \"=\" ; \nint istart = saveAttrs . indexOf ( str ) ; \nif ( istart >= 0 ) { \nint iend = saveAttrs . indexOf ( ',' , istart ) ; \nif ( iend > istart ) { \nreturn saveAttrs . substring ( istart + str . length ( ) , iend ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8498": "public class SaveAttrsUtility { \npublic static void setSaveAttrsForSheet ( final Sheet sheet , final int minRowNum , final int maxRowNum , final Map < String , String > saveCommentsMap ) { \nfor ( Row row : sheet ) { \nint rowIndex = row . getRowNum ( ) ; \nif ( rowIndex >= minRowNum ) { \nif ( rowIndex <= maxRowNum ) { \nsetSaveAttrsForRow ( row , saveCommentsMap ) ; \n} \n} \n} \n} \n} \n"}
{"8504": "public class TieWebSheetBean { \npublic XSSFEvaluationWorkbook getWbWrapper ( ) { \nif ( this . wbWrapper == null ) { \nif ( this . getWb ( ) != null ) { \nthis . wbWrapper = XSSFEvaluationWorkbook . create ( ( XSSFWorkbook ) this . getWb ( ) ) ; \n} \n} \nreturn wbWrapper ; \n} \n} \n"}
{"8505": "public class TieWebSheetBean { \npublic FormulaEvaluator getFormulaEvaluator ( ) { \nif ( this . formulaEvaluator == null ) { \nif ( this . getWb ( ) != null ) { \nthis . formulaEvaluator = this . getWb ( ) . getCreationHelper ( ) . createFormulaEvaluator ( ) ; \n} \n} \nreturn formulaEvaluator ; \n} \n} \n"}
{"8506": "public class TieWebSheetBean { \npublic void reCalcMaxColCounts ( ) { \nif ( this . getSheetConfigMap ( ) == null ) { \nthis . maxColCounts = 0 ; \nreturn ; \n} \nelse if ( this . getSheetConfigMap ( ) . isEmpty ( ) ) { \nthis . maxColCounts = 0 ; \nreturn ; \n} \nint maxColumns = 0 ; \nfor ( SheetConfiguration sheetConfig : this . getSheetConfigMap ( ) . values ( ) ) { \nint counts = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) - sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) + 1 ; \nif ( maxColumns < counts ) { \nmaxColumns = counts ; \n} \n} \nthis . maxColCounts = maxColumns ; \n} \n} \n"}
{"8509": "public class TieWebSheetBean { \npublic int loadWorkSheetByTabName ( final String tabName ) { \ntry { \nint sheetId = this . getHelper ( ) . getWebSheetLoader ( ) . findTabIndexWithName ( tabName ) ; \nif ( getSheetConfigMap ( ) != null ) { \nif ( sheetId < getSheetConfigMap ( ) . size ( ) ) { \nthis . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( tabName ) ; \nsetActiveTabIndex ( sheetId ) ; \n} \n} \nreturn 1 ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"loadWorkSheetByTabName failed. error = \" + ex . getMessage ( ) , ex ) ; \n} \nreturn - 1 ; \n} \n} \n"}
{"8518": "public class TieWebSheetBeanHelper { \npublic final CellHelper getCellHelper ( ) { \nif ( this . cellHelper == null ) { \nif ( this . parent != null ) { \nthis . cellHelper = new CellHelper ( parent ) ; \n} \n} \nreturn cellHelper ; \n} \n} \n"}
{"8519": "public class TieWebSheetBeanHelper { \npublic final PicturesHelper getPicHelper ( ) { \nif ( this . picHelper == null ) { \nif ( this . parent != null ) { \nthis . picHelper = new PicturesHelper ( parent ) ; \n} \n} \nreturn picHelper ; \n} \n} \n"}
{"8520": "public class TieWebSheetBeanHelper { \npublic final ValidationHandler getValidationHandler ( ) { \nif ( this . validationHandler == null ) { \nif ( this . parent != null ) { \nthis . validationHandler = new ValidationHandler ( parent ) ; \n} \n} \nreturn validationHandler ; \n} \n} \n"}
{"8521": "public class TieWebSheetBeanHelper { \npublic final ChartHelper getChartHelper ( ) { \nif ( this . chartHelper == null ) { \nif ( this . parent != null ) { \nthis . chartHelper = new ChartHelper ( parent ) ; \n} \n} \nreturn chartHelper ; \n} \n} \n"}
{"8523": "public class ShiftFormulaUtility { \nprivate static Ptg [ ] convertPtg ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg ) { \nbyte originalOperandClass = - 1 ; \nif ( ! ( ( Ptg ) ptg ) . isBaseToken ( ) ) { \noriginalOperandClass = ( ( Ptg ) ptg ) . getPtgClass ( ) ; \n} \nint currentRow ; \ncurrentRow = getFirstSupportedRowNumFromPtg ( ptg ) ; \nif ( currentRow >= 0 ) { \nif ( shiftFormulaRef . getWatchList ( ) . contains ( currentRow ) ) { \nreturn convertPtgForWatchList ( ptgs , position , shiftFormulaRef , ptg , originalOperandClass , currentRow ) ; \n} \n} \nif ( ptg instanceof AttrPtg ) { \nif ( shiftFormulaRef . getFormulaChanged ( ) > 1 ) { \nAttrPtg newPtg = ( AttrPtg ) ptg ; \nif ( newPtg . isSum ( ) ) { \nFuncVarPtg fptg = FuncVarPtg . create ( \"sum\" , shiftFormulaRef . getFormulaChanged ( ) ) ; \nreturn singlePtg ( fptg , fptg . getPtgClass ( ) , shiftFormulaRef . getFormulaChanged ( ) ) ; \n} \n} \n} \nreturn singlePtg ( ptg , originalOperandClass , shiftFormulaRef . getFormulaChanged ( ) ) ; \n} \n} \n"}
{"8524": "public class ShiftFormulaUtility { \nprivate static Ptg [ ] convertPtgForWatchList ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg , final byte originalOperandClass , final int currentRow ) { \nList < SerialRow > rowlist = getRowsList ( currentRow , shiftFormulaRef . getCurrentRowsMappingList ( ) ) ; \nif ( rowlist == null ) { \nreturn singlePtg ( ptg , originalOperandClass , - 1 ) ; \n} \nelse if ( rowlist . isEmpty ( ) ) { \nreturn singlePtg ( ptg , originalOperandClass , - 1 ) ; \n} \nshiftFormulaRef . setFormulaChanged ( 1 ) ; \nif ( ( rowlist . size ( ) == 1 ) || ( ( position + 1 ) >= ptgs . length ) ) { \nreturn singlePtg ( fixupRefRelativeRowOneToOne ( ptg , rowlist . get ( 0 ) . getRow ( ) ) , originalOperandClass , - 1 ) ; \n} \nelse if ( ! ( ptgs [ position + 1 ] instanceof ParenthesisPtg ) ) { \nreturn singlePtg ( fixupRefRelativeRowOneToOne ( ptg , rowlist . get ( 0 ) . getRow ( ) ) , originalOperandClass , - 1 ) ; \n} \nshiftFormulaRef . setFormulaChanged ( rowlist . size ( ) ) ; \nreturn fixupRefRelativeRowOneToMany ( ptg , originalOperandClass , rowlist , ptgs , position ) ; \n} \n} \n"}
{"8525": "public class ShiftFormulaUtility { \nprivate static Ptg [ ] singlePtg ( final Object ptg , final byte originalOperandClass , final int formulaChanged ) { \nPtg [ ] newPtg = new Ptg [ 1 ] ; \nif ( originalOperandClass != ( - 1 ) ) { \n( ( Ptg ) ptg ) . setClass ( originalOperandClass ) ; \n} \nObject ptgAfter = ptg ; \nif ( ptg instanceof FuncVarPtg ) { \nFuncVarPtg fptg = ( FuncVarPtg ) ptg ; \nif ( formulaChanged > 0 ) { \nif ( fptg . getNumberOfOperands ( ) != formulaChanged ) { \nptgAfter = FuncVarPtg . create ( ( ( FuncVarPtg ) ptg ) . getName ( ) , formulaChanged ) ; \n} \n} \n} \nnewPtg [ 0 ] = ( Ptg ) ptgAfter ; \nreturn newPtg ; \n} \n} \n"}
{"8529": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForRefPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg , final boolean includeParenthesis ) { \nRefPtgBase refPtg = ( RefPtgBase ) ptg ; \nint unitSize = 1 ; \nif ( includeParenthesis ) { \nunitSize = 2 ; \n} \nfor ( int i = 0 ; \ni < rowList . size ( ) ; \ni ++ ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nif ( refPtg instanceof Ref3DPxg ) { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( row . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nRefPtgBase refPtgBase = refPtg ; \nnewPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \nif ( unitSize == 2 ) { \nif ( i < ( rowList . size ( ) - 1 ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \n} \n} \n} \n"}
{"8552": "public class ChartHelper { \npublic final void setSeriesStyle ( final JFreeChart chart , final int seriesIndex , final String style ) { \nif ( chart != null ) { \nif ( style != null ) { \nBasicStroke stroke = ChartUtility . toStroke ( style ) ; \nPlot plot = chart . getPlot ( ) ; \nif ( plot instanceof CategoryPlot ) { \nCategoryPlot categoryPlot = chart . getCategoryPlot ( ) ; \nCategoryItemRenderer cir = categoryPlot . getRenderer ( ) ; \ntry { \ncir . setSeriesStroke ( seriesIndex , stroke ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \nelse if ( plot instanceof XYPlot ) { \nXYPlot xyPlot = chart . getXYPlot ( ) ; \nXYItemRenderer xyir = xyPlot . getRenderer ( ) ; \ntry { \nxyir . setSeriesStroke ( seriesIndex , stroke ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \nelse { \nLOG . log ( Level . FINE , \"setSeriesColor() unsupported plot: {}\" , plot . toString ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"8555": "public class ChartHelper { \nprivate void initXSSFChartsMap ( final XSSFWorkbook wb , final ChartsData chartsData ) { \ninitAnchorsMap ( wb , chartsData ) ; \nMap < String , ClientAnchor > anchorMap = chartsData . getChartAnchorsMap ( ) ; \nMap < String , BufferedImage > chartMap = chartsData . getChartsMap ( ) ; \nMap < String , ChartData > chartDataMap = chartsData . getChartDataMap ( ) ; \nchartMap . clear ( ) ; \nchartDataMap . clear ( ) ; \nfor ( int i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni ++ ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nList < XSSFChart > charts = drawing . getCharts ( ) ; \nif ( charts != null ) { \nif ( ! charts . isEmpty ( ) ) { \nfor ( XSSFChart chart : charts ) { \ngenerateSingleXSSFChart ( chart , getChartIdFromParent ( chart , sheet . getSheetName ( ) ) , sheet , anchorMap , chartMap , chartDataMap ) ; \n} \n} \n} \n} \n} \n} \n"}
{"8563": "public class ConfigurationUtility { \npublic static void buildCellFormulaForShiftedRows ( final Sheet sheet , final XSSFEvaluationWorkbook wbWrapper , final ShiftFormulaRef shiftFormulaRef , final Cell cell , final String originFormula ) { \nif ( shiftFormulaRef . getWatchList ( ) != null ) { \nif ( ! shiftFormulaRef . getWatchList ( ) . isEmpty ( ) ) { \nPtg [ ] ptgs = FormulaParser . parse ( originFormula , wbWrapper , FormulaType . CELL , sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ) ; \nPtg [ ] convertedFormulaPtg = ShiftFormulaUtility . convertSharedFormulas ( ptgs , shiftFormulaRef ) ; \nif ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) { \ncell . setCellFormula ( FormulaRenderer . toFormulaString ( wbWrapper , convertedFormulaPtg ) ) ; \n} \n} \n} \n} \n} \n"}
{"8564": "public class ConfigurationUtility { \npublic static List < RowsMapping > gatherRowsMappingByFullName ( final ConfigBuildRef configBuildRef , final String fullName ) { \nList < RowsMapping > list = new ArrayList < > ( ) ; \nMap < String , ConfigRangeAttrs > shiftMap = configBuildRef . getShiftMap ( ) ; \nfor ( Map . Entry < String , ConfigRangeAttrs > entry : shiftMap . entrySet ( ) ) { \nString fname = entry . getKey ( ) ; \nif ( fname . startsWith ( fullName + \":\" ) ) { \nConfigRangeAttrs attrs = entry . getValue ( ) ; \nlist . add ( attrs . getUnitRowsMapping ( ) ) ; \n} \nelse if ( fname . equals ( fullName ) ) { \nConfigRangeAttrs attrs = entry . getValue ( ) ; \nlist . add ( attrs . getUnitRowsMapping ( ) ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"8569": "public class ConfigurationUtility { \npublic static int getOriginalRowNumInHiddenColumn ( final Row row ) { \nif ( row != null ) { \nCell cell = row . getCell ( TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nString rowNum = cell . getStringCellValue ( ) ; \ntry { \nif ( ( rowNum != null ) && ( ! rowNum . isEmpty ( ) ) ) { \nif ( WebSheetUtility . isNumeric ( rowNum ) ) { \nreturn Integer . parseInt ( rowNum ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"getOriginalRowNumInHiddenColumn rowNum = \" + rowNum + \" error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8575": "public class ConfigurationUtility { \npublic static boolean isStaticRow ( final ConfigRange sourceConfigRange , final int rowIndex ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( int i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nif ( rowIndex >= command . getConfigRange ( ) . getFirstRowAddr ( ) . getRow ( ) ) { \nif ( rowIndex < ( command . getConfigRange ( ) . getLastRowPlusAddr ( ) . getRow ( ) ) ) { \nreturn false ; \n} \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8576": "public class ConfigurationUtility { \npublic static boolean isStaticRowRef ( final ConfigRange sourceConfigRange , final Row row ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( int i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nint rowIndex = row . getRowNum ( ) ; \nif ( rowIndex >= command . getTopRow ( ) ) { \nif ( rowIndex < ( command . getTopRow ( ) + command . getFinalLength ( ) ) ) { \nreturn false ; \n} \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8580": "public class ConfigurationUtility { \nprivate static void addSkipCellToListInTheRegion ( final List < String > skipCellList , final CellRangeAddress caddress ) { \nfor ( int col = caddress . getFirstColumn ( ) ; \ncol <= caddress . getLastColumn ( ) ; \ncol ++ ) { \nfor ( int row = caddress . getFirstRow ( ) ; \nrow <= caddress . getLastRow ( ) ; \nrow ++ ) { \nif ( col == caddress . getFirstColumn ( ) ) { \nif ( row == caddress . getFirstRow ( ) ) { \ncontinue ; \n} \n} \nskipCellList . add ( CellUtility . getCellIndexNumberKey ( col , row ) ) ; \n} \n} \n} \n} \n"}
{"8581": "public class ConfigurationUtility { \npublic static void buildSheetCommentFromAlias ( Sheet sheet , List < TieCommandAlias > tieCommandAliasList ) { \nif ( tieCommandAliasList == null ) { \nreturn ; \n} \nelse if ( tieCommandAliasList . isEmpty ( ) ) { \nreturn ; \n} \nfor ( Row row : sheet ) { \nfor ( Cell cell : row ) { \nbuildCellCommentFromalias ( tieCommandAliasList , cell ) ; \n} \n} \n} \n} \n"}
{"8582": "public class ConfigurationUtility { \nprivate static void buildCellCommentFromalias ( List < TieCommandAlias > tieCommandAliasList , Cell cell ) { \nString value = CellUtility . getCellValueWithoutFormat ( cell ) ; \nif ( value != null ) { \nif ( ! value . isEmpty ( ) ) { \nfor ( TieCommandAlias alias : tieCommandAliasList ) { \nMatcher matcher = alias . getPattern ( ) . matcher ( value ) ; \nif ( matcher . find ( ) ) { \nCellUtility . createOrInsertComment ( cell , alias . getCommand ( ) ) ; \nif ( alias . isRemove ( ) ) { \nCellUtility . setCellValue ( cell , ParserUtility . removeCharsFromString ( value , matcher . start ( ) , matcher . end ( ) ) ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"8584": "public class ConfigurationHandler { \nprivate SheetConfiguration getSheetConfiguration ( final Sheet sheet , final String formName , final int sheetRightCol ) { \nSheetConfiguration sheetConfig = new SheetConfiguration ( ) ; \nsheetConfig . setFormName ( formName ) ; \nsheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; \nint leftCol = sheet . getLeftCol ( ) ; \nint lastRow = sheet . getLastRowNum ( ) ; \nint firstRow = sheet . getFirstRowNum ( ) ; \nint rightCol = 0 ; \nint maxRow = 0 ; \nfor ( Row row : sheet ) { \nif ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) { \nbreak ; \n} \nmaxRow = row . getRowNum ( ) ; \nint firstCellNum = row . getFirstCellNum ( ) ; \nif ( firstCellNum >= 0 ) { \nif ( firstCellNum < leftCol ) { \nleftCol = firstCellNum ; \n} \n} \nif ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { \nint verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; \nif ( verifiedcol > rightCol ) { \nrightCol = verifiedcol ; \n} \n} \n} \nif ( maxRow < lastRow ) { \nlastRow = maxRow ; \n} \nString tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + \"0 : \" + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + \"0\" ; \nsheetConfig . setFormHeaderRange ( tempStr ) ; \nsheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; \ntempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( firstRow + 1 ) + \" : \" + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( lastRow + 1 ) ; \nsheetConfig . setFormBodyRange ( tempStr ) ; \nsheetConfig . setBodyCellRange ( new CellRange ( tempStr ) ) ; \nsheetConfig . setFormBodyType ( org . tiefaces . common . TieConstants . FORM_TYPE_FREE ) ; \nsheetConfig . setCellFormAttributes ( new HashMap < String , List < CellFormAttributes > > ( ) ) ; \nint sheetIndex = parent . getWb ( ) . getSheetIndex ( sheet ) ; \nif ( parent . getWb ( ) . isSheetHidden ( sheetIndex ) ) { \nsheetConfig . setHidden ( true ) ; \n} \nelse if ( parent . getWb ( ) . isSheetVeryHidden ( sheetIndex ) ) { \nsheetConfig . setHidden ( true ) ; \n} \nreturn sheetConfig ; \n} \n} \n"}
{"8586": "public class ConfigurationHandler { \nprivate int verifyLastCell ( final Row row , final int stoppoint , final int sheetRightCol ) { \nint lastCol = sheetRightCol ; \nint col ; \nfor ( col = lastCol ; \ncol >= stoppoint ; \ncol -- ) { \nCell cell = row . getCell ( col ) ; \nif ( cell != null ) { \nif ( cell . getCellTypeEnum ( ) != CellType . BLANK ) { \nbreak ; \n} \n} \n} \nreturn col ; \n} \n} \n"}
{"8587": "public class ConfigurationHandler { \npublic final void buildSheet ( final Sheet sheet , final Map < String , SheetConfiguration > sheetConfigMap , final CellAttributesMap cellAttributesMap ) { \nif ( sheet . getLastRowNum ( ) <= 0 ) { \nif ( sheet . getRow ( 0 ) == null ) { \nreturn ; \n} \n} \ncheckAndRepairLastRow ( sheet ) ; \nint sheetRightCol = WebSheetUtility . getSheetRightCol ( sheet ) ; \nList < ConfigCommand > commandList = buildCommandListFromSheetComment ( ( XSSFSheet ) sheet , sheetRightCol , cellAttributesMap ) ; \nboolean hasEachCommand = hasEachCommandInTheList ( commandList ) ; \nList < String > formList = new ArrayList < > ( ) ; \nbuildSheetConfigMapFromFormCommand ( sheet , sheetConfigMap , commandList , formList , sheetRightCol ) ; \nmatchParentCommand ( commandList ) ; \nmatchSheetConfigForm ( sheetConfigMap , commandList , formList ) ; \ninitTemplateForCommand ( sheet , sheetConfigMap , formList , hasEachCommand ) ; \n} \n} \n"}
{"8588": "public class ConfigurationHandler { \nprivate final void checkAndRepairLastRow ( final Sheet sheet ) { \nRow lastrow = sheet . getRow ( sheet . getLastRowNum ( ) ) ; \nif ( lastrow != null ) { \nfor ( Cell cell : lastrow ) { \nif ( cell . getCellTypeEnum ( ) != CellType . _NONE ) { \nif ( cell . getCellTypeEnum ( ) != CellType . BLANK ) { \nreturn ; \n} \n} \n} \nsheet . removeRow ( lastrow ) ; \n} \n} \n} \n"}
{"8590": "public class ConfigurationHandler { \nprivate void setParentForChildCommand ( final List < ConfigCommand > commandList , final int i , final ConfigCommand child ) { \nint matchIndex = - 1 ; \nConfigRange matchRange = null ; \nfor ( int j = 0 ; \nj < commandList . size ( ) ; \nj ++ ) { \nif ( j != i ) { \nCommand commandParent = commandList . get ( j ) ; \nif ( ! commandParent . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) && WebSheetUtility . insideRange ( child . getConfigRange ( ) , commandParent . getConfigRange ( ) ) ) { \nif ( ( matchRange == null ) || ( WebSheetUtility . insideRange ( commandParent . getConfigRange ( ) , matchRange ) ) ) { \nmatchRange = commandParent . getConfigRange ( ) ; \nmatchIndex = j ; \n} \n} \n} \n} \nif ( matchIndex >= 0 ) { \ncommandList . get ( matchIndex ) . getConfigRange ( ) . addCommand ( child ) ; \nchild . setParentFound ( true ) ; \n} \n} \n} \n"}
{"8600": "public class ConfigurationHandler { \nprivate SheetConfiguration getSheetConfigurationFromConfigCommand ( final Sheet sheet , final FormCommand fcommand , final int sheetRightCol ) { \nSheetConfiguration sheetConfig = new SheetConfiguration ( ) ; \nsheetConfig . setFormName ( fcommand . getName ( ) ) ; \nsheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; \nint leftCol = fcommand . getLeftCol ( ) ; \nint lastRow = fcommand . getLastRow ( ) ; \nint rightCol = 0 ; \nint maxRow = 0 ; \nfor ( Row row : sheet ) { \nif ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) { \nbreak ; \n} \nmaxRow = row . getRowNum ( ) ; \nif ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { \nint verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; \nif ( verifiedcol > rightCol ) { \nrightCol = verifiedcol ; \n} \n} \n} \nif ( maxRow < lastRow ) { \nlastRow = maxRow ; \n} \nsetHeaderOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; \nsetBodyOfSheetConfiguration ( fcommand , sheetConfig , leftCol , lastRow , rightCol ) ; \nsetFooterOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; \nString hidden = fcommand . getHidden ( ) ; \nif ( hidden != null ) { \nif ( Boolean . parseBoolean ( hidden ) ) { \nsheetConfig . setHidden ( true ) ; \n} \n} \nString fixedWidthStyle = fcommand . getFixedWidthStyle ( ) ; \nif ( fixedWidthStyle != null ) { \nif ( Boolean . parseBoolean ( fixedWidthStyle ) ) { \nsheetConfig . setFixedWidthStyle ( true ) ; \n} \n} \nsheetConfig . setFormCommand ( fcommand ) ; \nreturn sheetConfig ; \n} \n} \n"}
{"8612": "public class CommandUtility { \npublic static boolean isRowAllowAdd ( final Row row , final SheetConfiguration sheetConfig ) { \nString fullName = ConfigurationUtility . getFullNameFromRow ( row ) ; \nif ( fullName != null ) { \nConfigRangeAttrs attrs = sheetConfig . getShiftMap ( ) . get ( fullName ) ; \nif ( ( attrs != null ) && ( attrs . isAllowAdd ( ) ) ) { \nif ( row . getRowNum ( ) == attrs . getFirstRowRef ( ) . getRowIndex ( ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8613": "public class CommandUtility { \npublic static void insertEachTemplate ( final ConfigRange sourceConfigRange , final ConfigBuildRef configBuildRef , final int index , final int insertPosition , final RowsMapping unitRowsMapping ) { \nint srcStartRow = sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; \nint srcEndRow = sourceConfigRange . getLastRowPlusAddr ( ) . getRow ( ) - 1 ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nWorkbook wb = sheet . getWorkbook ( ) ; \nString copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; \nif ( copyName . length ( ) > TieConstants . EXCEL_SHEET_NAME_LIMIT ) { \ncopyName = copyName . substring ( 0 , TieConstants . EXCEL_SHEET_NAME_LIMIT ) ; \n} \nSheet srcSheet = wb . getSheet ( copyName ) ; \nif ( index > 0 ) { \nCellUtility . copyRows ( srcSheet , sheet , srcStartRow , srcEndRow , insertPosition , false , true ) ; \n} \nfor ( int rowIndex = srcStartRow ; \nrowIndex <= srcEndRow ; \nrowIndex ++ ) { \nif ( configBuildRef . getWatchList ( ) . contains ( rowIndex ) ) { \nif ( ConfigurationUtility . isStaticRow ( sourceConfigRange , rowIndex ) ) { \nunitRowsMapping . addRow ( rowIndex , sheet . getRow ( insertPosition + rowIndex - srcStartRow ) ) ; \n} \n} \n} \n} \n} \n"}
{"8615": "public class CommandUtility { \nprivate static void evaluateUserFormula ( final Cell cell , final String strValue ) { \nString formulaStr = strValue . substring ( 2 , strValue . length ( ) - 1 ) ; \nif ( formulaStr != null ) { \nif ( ! formulaStr . isEmpty ( ) ) { \ncell . setCellFormula ( formulaStr ) ; \n} \n} \n} \n} \n"}
{"8619": "public class CommandUtility { \npublic static void removeRowsInSheet ( final Sheet sheet , final int rowIndexStart , final int rowIndexEnd , final Map < Cell , String > cachedMap ) { \nfor ( int irow = rowIndexStart ; \nirow <= rowIndexEnd ; \nirow ++ ) { \nremoveCachedCellForRow ( sheet , irow , cachedMap ) ; \n} \nint irows = rowIndexEnd - rowIndexStart + 1 ; \nif ( irows < 1 ) { \nreturn ; \n} \nelse if ( rowIndexStart < 0 ) { \nreturn ; \n} \nint lastRowNum = sheet . getLastRowNum ( ) ; \nif ( rowIndexEnd < lastRowNum ) { \nsheet . shiftRows ( rowIndexEnd + 1 , lastRowNum , - irows ) ; \n} \nif ( rowIndexEnd == lastRowNum ) { \nfor ( int i = rowIndexEnd ; \ni >= rowIndexStart ; \ni -- ) { \nremoveSingleRowInSheet ( sheet , rowIndexStart ) ; \n} \n} \n} \n} \n"}
{"8622": "public class CommandUtility { \npublic static void removeRowsInBody ( final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows , final int rowIndexStart , final int rowIndexEnd ) { \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nif ( rowIndexEnd < rowIndexStart ) { \nreturn ; \n} \nelse if ( rowIndexStart < top ) { \nreturn ; \n} \nint irows = rowIndexEnd - rowIndexStart + 1 ; \nfor ( int rowIndex = rowIndexEnd ; \nrowIndex >= rowIndexStart ; \nrowIndex -- ) { \nbodyRows . remove ( rowIndex - top ) ; \n} \nfor ( int irow = rowIndexStart - top ; \nirow < bodyRows . size ( ) ; \nirow ++ ) { \nFacesRow facesrow = bodyRows . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) - irows ) ; \n} \n} \n} \n"}
{"8625": "public class CellMap { \nprivate String assembleNewValue ( final Object value , final FacesCell facesCell ) { \nString newValue ; \nif ( value instanceof java . util . Date ) { \nString datePattern = facesCell . getDatePattern ( ) ; \nif ( datePattern == null ) { \ndatePattern = parent . getDefaultDatePattern ( ) ; \n} \nelse if ( datePattern . isEmpty ( ) ) { \ndatePattern = parent . getDefaultDatePattern ( ) ; \n} \nFormat formatter = new SimpleDateFormat ( datePattern ) ; \nnewValue = formatter . format ( value ) ; \n} \nelse { \nnewValue = ( String ) value ; \n} \nif ( \"textarea\" . equalsIgnoreCase ( facesCell . getInputType ( ) ) ) { \nif ( newValue != null ) { \nnewValue = newValue . replace ( \"\\r\\n\" , \"\\n\" ) ; \n} \n} \nreturn newValue ; \n} \n} \n"}
{"8635": "public class CellUtility { \npublic static void copyRows ( final Sheet srcSheet , final Sheet destSheet , final int srcRowStart , final int srcRowEnd , final int destRow , final boolean checkLock , final boolean setHiddenColumn ) { \nint length = srcRowEnd - srcRowStart + 1 ; \nif ( length <= 0 ) { \nreturn ; \n} \ndestSheet . shiftRows ( destRow , destSheet . getLastRowNum ( ) , length , true , false ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \ncopySingleRow ( srcSheet , destSheet , srcRowStart + i , destRow + i , checkLock , setHiddenColumn ) ; \n} \nfor ( int i = 0 ; \ni < srcSheet . getNumMergedRegions ( ) ; \ni ++ ) { \nCellRangeAddress cellRangeAddress = srcSheet . getMergedRegion ( i ) ; \nif ( cellRangeAddress . getFirstRow ( ) >= srcRowStart ) { \nif ( cellRangeAddress . getLastRow ( ) <= srcRowEnd ) { \nint targetRowFrom = cellRangeAddress . getFirstRow ( ) - srcRowStart + destRow ; \nint targetRowTo = cellRangeAddress . getLastRow ( ) - srcRowStart + destRow ; \nCellRangeAddress newCellRangeAddress = new CellRangeAddress ( targetRowFrom , targetRowTo , cellRangeAddress . getFirstColumn ( ) , cellRangeAddress . getLastColumn ( ) ) ; \ndestSheet . addMergedRegion ( newCellRangeAddress ) ; \n} \n} \n} \n} \n} \n"}
{"8637": "public class CellUtility { \npublic static Cell copyCell ( final Sheet destSheet , final Row sourceRow , final Row newRow , final int cellIndex , final boolean checkLock ) { \nCell sourceCell = sourceRow . getCell ( cellIndex ) ; \nif ( sourceCell == null ) { \nreturn null ; \n} \nboolean refreshCell = false ; \nif ( sourceRow . equals ( newRow ) ) { \nif ( sourceCell . getColumnIndex ( ) == cellIndex ) { \nsourceRow . removeCell ( sourceCell ) ; \nrefreshCell = true ; \n} \n} \nCell newCell = newRow . createCell ( cellIndex ) ; \ntry { \nif ( ! refreshCell ) { \nif ( sourceCell . getCellComment ( ) != null ) { \ncloneComment ( sourceCell , newCell ) ; \n} \n} \ncopyCellSetStyle ( destSheet , sourceCell , newCell ) ; \ncopyCellSetValue ( sourceCell , newCell , checkLock ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"copy cell set error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \nreturn newCell ; \n} \n} \n"}
{"8644": "public class CellUtility { \nprivate static XSSFVMLDrawing getVmlDrawingFromCell ( final Cell cell ) { \nXSSFSheet sourceSheet = ( XSSFSheet ) cell . getSheet ( ) ; \nfor ( POIXMLDocumentPart sourcePart : sourceSheet . getRelations ( ) ) { \nif ( sourcePart != null ) { \nif ( sourcePart instanceof XSSFVMLDrawing ) { \nreturn ( XSSFVMLDrawing ) sourcePart ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8652": "public class CellUtility { \npublic static Cell getPoiCellFromSheet ( final int rowIndex , final int colIndex , final Sheet sheet1 ) { \nif ( sheet1 != null ) { \nif ( sheet1 . getRow ( rowIndex ) != null ) { \nreturn sheet1 . getRow ( rowIndex ) . getCell ( colIndex ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8660": "public class RowsMapping { \npublic final void mergeMap ( final RowsMapping addMap ) { \nMap < Integer , List < SerialRow > > map = addMap . getRowsMap ( ) ; \nfor ( Map . Entry < Integer , List < SerialRow > > entry : map . entrySet ( ) ) { \nList < SerialRow > entryRowList = entry . getValue ( ) ; \nif ( entryRowList != null ) { \nif ( ! entryRowList . isEmpty ( ) ) { \nfor ( SerialRow row : entryRowList ) { \nthis . addRow ( entry . getKey ( ) , row . getRow ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"8664": "public class ChartUtility { \npublic static ChartData initChartDataFromXSSFChart ( final String chartId , final XSSFChart chart , final XSSFWorkbook wb ) { \nThemesTable themeTable = wb . getStylesSource ( ) . getTheme ( ) ; \nChartData chartData = new ChartData ( ) ; \nXSSFRichTextString chartTitle = chart . getTitle ( ) ; \nif ( chartTitle != null ) { \nchartData . setTitle ( chartTitle . toString ( ) ) ; \n} \nCTChart ctChart = chart . getCTChart ( ) ; \nChartType chartType = ChartUtility . getChartType ( ctChart ) ; \nif ( chartType == null ) { \nthrow new IllegalChartException ( \"Unknown chart type\" ) ; \n} \nchartData . setBgColor ( ColorUtility . getBgColor ( ctChart . getPlotArea ( ) , themeTable ) ) ; \nchartData . setId ( chartId ) ; \nchartData . setType ( chartType ) ; \nList < CTCatAx > ctCatAxList = ctChart . getPlotArea ( ) . getCatAxList ( ) ; \nif ( ctCatAxList != null ) { \nif ( ! ctCatAxList . isEmpty ( ) ) { \nchartData . setCatAx ( new ChartAxis ( ctCatAxList . get ( 0 ) ) ) ; \n} \n} \nList < CTValAx > ctValAxList = ctChart . getPlotArea ( ) . getValAxList ( ) ; \nif ( ctValAxList != null ) { \nif ( ! ctValAxList . isEmpty ( ) ) { \nchartData . setValAx ( new ChartAxis ( ctValAxList . get ( 0 ) ) ) ; \n} \n} \nChartObject ctObj = chartType . createChartObject ( ) ; \nif ( ctObj == null ) { \nthrow new IllegalChartException ( \"Cannot create chart object.\" ) ; \n} \nsetUpChartData ( chartData , ctChart , themeTable , ctObj ) ; \nreturn chartData ; \n} \n} \n"}
{"8665": "public class ChartUtility { \npublic static void setUpChartData ( final ChartData chartData , final CTChart ctChart , final ThemesTable themeTable , final ChartObject ctObj ) { \nObject chartObj = null ; \n@ SuppressWarnings ( \"rawtypes\" ) List plotCharts = ctObj . getChartListFromCtChart ( ctChart ) ; \nif ( plotCharts != null ) { \nif ( ! plotCharts . isEmpty ( ) ) { \nchartObj = plotCharts . get ( 0 ) ; \n} \n} \nif ( chartObj != null ) { \n@ SuppressWarnings ( \"rawtypes\" ) List bsers = ctObj . getSerListFromCtObjChart ( chartObj ) ; \nif ( ! AppUtils . emptyList ( bsers ) ) { \nchartData . buildCategoryList ( ctObj . getCtAxDataSourceFromSerList ( bsers ) ) ; \nchartData . buildSeriesList ( bsers , themeTable , ctObj ) ; \n} \n} \n} \n} \n"}
{"8668": "public class ChartUtility { \nprivate static String getAnchorAssociateChartId ( final CTTwoCellAnchor ctanchor ) { \nif ( ctanchor . getGraphicFrame ( ) == null ) { \nreturn null ; \n} \nNode parentNode = ctanchor . getGraphicFrame ( ) . getGraphic ( ) . getGraphicData ( ) . getDomNode ( ) ; \nNodeList childNodes = parentNode . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < childNodes . getLength ( ) ; \ni ++ ) { \nNode childNode = childNodes . item ( i ) ; \nif ( ( childNode != null ) && ( \"c:chart\" . equalsIgnoreCase ( childNode . getNodeName ( ) ) ) ) { \nif ( childNode . hasAttributes ( ) ) { \nString rId = getChartIdFromChildNodeAttributes ( childNode . getAttributes ( ) ) ; \nif ( rId != null ) { \nreturn rId ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8670": "public class EachCommand { \n@ SuppressWarnings ( \"rawtypes\" ) private int buildEachObjects ( String fullName , final ConfigBuildRef configBuildRef , final int atRow , final Map < String , Object > context , final List < RowsMapping > currentRowsMappingList , final Collection itemsCollection , final String objClassName ) { \nint index = 0 ; \nint insertPosition = atRow ; \nString thisObjClassName = objClassName ; \nfor ( Object obj : itemsCollection ) { \nif ( thisObjClassName == null ) { \nthisObjClassName = obj . getClass ( ) . getName ( ) ; \nconfigBuildRef . getCollectionObjNameMap ( ) . put ( this . var , thisObjClassName ) ; \n} \nRowsMapping unitRowsMapping = new RowsMapping ( ) ; \ncontext . put ( var , obj ) ; \nCommandUtility . insertEachTemplate ( this . getConfigRange ( ) , configBuildRef , index , insertPosition , unitRowsMapping ) ; \nConfigRange currentRange = ConfigurationUtility . buildCurrentRange ( this . getConfigRange ( ) , configBuildRef . getSheet ( ) , insertPosition ) ; \ncurrentRowsMappingList . add ( unitRowsMapping ) ; \nString unitFullName = fullName + \".\" + index ; \ncurrentRange . getAttrs ( ) . setAllowAdd ( false ) ; \nif ( this . allowAdd != null ) { \nif ( \"true\" . equalsIgnoreCase ( this . allowAdd . trim ( ) ) ) { \ncurrentRange . getAttrs ( ) . setAllowAdd ( true ) ; \nconfigBuildRef . setBodyAllowAdd ( true ) ; \n} \n} \nconfigBuildRef . putShiftAttrs ( unitFullName , currentRange . getAttrs ( ) , new RowsMapping ( unitRowsMapping ) ) ; \nint length = currentRange . buildAt ( unitFullName , configBuildRef , insertPosition , context , currentRowsMappingList ) ; \ncurrentRange . getAttrs ( ) . setFinalLength ( length ) ; \ninsertPosition += length ; \ncurrentRowsMappingList . remove ( unitRowsMapping ) ; \nindex ++ ; \ncontext . remove ( var ) ; \n} \nreturn insertPosition ; \n} \n} \n"}
{"8675": "public class CellHelper { \npublic final void restoreDataContext ( final String fullName ) { \nString [ ] parts = fullName . split ( \":\" ) ; \nif ( ! isNeedRestore ( fullName , parts ) ) { \nreturn ; \n} \nboolean stopSkip = false ; \nList < String > list = parent . getCurrent ( ) . getCurrentDataContextNameList ( ) ; \nint listSize = list . size ( ) ; \nfor ( int i = 0 ; \ni < parts . length ; \ni ++ ) { \nString part = parts [ i ] ; \nboolean skip = false ; \nif ( ! stopSkip ) { \nif ( i < listSize ) { \nString listPart = list . get ( i ) ; \nif ( part . equalsIgnoreCase ( listPart ) ) { \nskip = true ; \n} \n} \n} \nif ( ! skip ) { \nstopSkip = true ; \nstartRestoreDataContext ( part ) ; \n} \n} \nif ( stopSkip ) { \nparent . getCurrent ( ) . setCurrentDataContextName ( fullName ) ; \n} \nreturn ; \n} \n} \n"}
{"8677": "public class CellHelper { \nprivate boolean isNeedRestore ( final String fullName , final String [ ] parts ) { \nif ( fullName == null ) { \nreturn false ; \n} \nif ( parent . getCurrent ( ) . getCurrentDataContextName ( ) != null ) { \nif ( parent . getCurrent ( ) . getCurrentDataContextName ( ) . toLowerCase ( ) . startsWith ( fullName . toLowerCase ( ) ) ) { \nreturn false ; \n} \n} \nreturn ( ( parts != null ) && ( parts . length > 1 ) ) ; \n} \n} \n"}
{"8682": "public class ConfigRange { \nprivate void buildCellsForRow ( final Row row , final String fullName , final Map < String , Object > context , final ConfigBuildRef configBuildRef , ShiftFormulaRef shiftFormulaRef ) { \nif ( row == null ) { \nreturn ; \n} \nelse if ( ! ConfigurationUtility . isStaticRowRef ( this , row ) ) { \nreturn ; \n} \nfor ( Cell cell : row ) { \nbuildSingleCell ( cell , context , configBuildRef , shiftFormulaRef ) ; \n} \nConfigurationUtility . setFullNameInHiddenColumn ( row , fullName ) ; \n} \n} \n"}
{"8688": "public class ChartData { \nprivate List < XColor > getColorListFromDPTWithValueList ( final List < CTDPt > dptList , final List < ParsedCell > cells , final ThemesTable themeTable , final ChartObject ctObj ) { \nList < XColor > colors = new ArrayList < > ( ) ; \nif ( dptList != null ) { \nif ( cells != null ) { \nfor ( int index = 0 ; \nindex < cells . size ( ) ; \nindex ++ ) { \nCTDPt dpt = getDPtFromListWithIndex ( dptList , index ) ; \nCTShapeProperties ctSpPr = null ; \nif ( dpt != null ) { \nctSpPr = dpt . getSpPr ( ) ; \n} \ncolors . add ( ColorUtility . geColorFromSpPr ( index , ctSpPr , themeTable , ctObj . isLineColor ( ) ) ) ; \n} \n} \n} \nreturn colors ; \n} \n} \n"}
{"8697": "public class TieCommandAlias { \npublic Pattern getPattern ( ) { \nif ( this . pattern == null ) { \nif ( alias != null ) { \nthis . pattern = Pattern . compile ( \"\\\\s*\" + ParserUtility . wildcardToRegex ( alias ) ) ; \n} \n} \nreturn pattern ; \n} \n} \n"}
{"8700": "public class CellStyleUtility { \npublic static String getRowStyle ( final Workbook wb , final Cell poiCell , final String inputType , final float rowHeight , final int rowspan ) { \nCellStyle cellStyle = poiCell . getCellStyle ( ) ; \nif ( cellStyle != null ) { \nif ( rowspan == 1 ) { \nshort fontIdx = cellStyle . getFontIndex ( ) ; \nFont font = wb . getFontAt ( fontIdx ) ; \nfloat maxHeight = rowHeight ; \nif ( ! inputType . isEmpty ( ) ) { \nmaxHeight = Math . min ( font . getFontHeightInPoints ( ) + 8f , rowHeight ) ; \n} \nreturn \"height:\" + WebSheetUtility . pointsToPixels ( maxHeight ) + \"px;\" ; \n} \n} \nreturn \"\" ; \n} \n} \n"}
{"8709": "public class CellStyleUtility { \npublic static void setupCellStyle ( final Workbook wb , final FacesCell fcell , final Cell poiCell , final float rowHeight ) { \nCellStyle cellStyle = poiCell . getCellStyle ( ) ; \nif ( cellStyle != null ) { \nif ( ! cellStyle . getLocked ( ) ) { \nif ( fcell . getInputType ( ) . isEmpty ( ) ) { \nfcell . setInputType ( CellStyleUtility . getInputTypeFromCellType ( poiCell ) ) ; \n} \nif ( fcell . getControl ( ) . isEmpty ( ) ) { \nif ( ! fcell . getInputType ( ) . isEmpty ( ) ) { \nfcell . setControl ( \"text\" ) ; \n} \n} \nsetInputStyleBaseOnInputType ( fcell , poiCell ) ; \n} \n} \nString webStyle = getCellStyle ( wb , poiCell , fcell . getInputType ( ) ) + getCellFontStyle ( wb , poiCell ) + getRowStyle ( wb , poiCell , fcell . getInputType ( ) , rowHeight , fcell . getRowspan ( ) ) ; \nfcell . setStyle ( webStyle ) ; \nfcell . setColumnStyle ( getColumnStyle ( wb , fcell , poiCell , rowHeight ) ) ; \n} \n} \n"}
{"8719": "public class TieWebSheetView { \npublic String getTabStyle ( ) { \nString tabStyle = TieConstants . TAB_STYLE_VISIBLE ; \nint sheetId = webFormTabView . getActiveIndex ( ) ; \nif ( sheetId >= 0 ) { \nif ( sheetId < tabs . size ( ) ) { \ntabStyle = TieConstants . TAB_STYLE_INVISIBLE ; \n} \n} \nreturn tabStyle ; \n} \n} \n"}
{"8726": "public class FormCommand { \nprivate void addToWatchList ( final int addRow , final int lastStaticRow , final List < Integer > watchList ) { \nif ( addRow > lastStaticRow ) { \nif ( ! ( watchList . contains ( addRow ) ) ) { \nwatchList . add ( addRow ) ; \n} \n} \n} \n} \n"}
{"8728": "public class ParserUtility { \npublic static void parseWidgetAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { \nif ( newComment == null ) { \nreturn ; \n} \nelse if ( newComment . isEmpty ( ) ) { \nreturn ; \n} \nint widgetStart = newComment . indexOf ( TieConstants . METHOD_WIDGET_PREFIX ) ; \nint elStart = newComment . indexOf ( TieConstants . EL_START_BRACKET ) ; \nif ( widgetStart < 0 ) { \nreturn ; \n} \nelse if ( widgetStart >= elStart ) { \nreturn ; \n} \nString type = newComment . substring ( widgetStart + TieConstants . METHOD_WIDGET_PREFIX . length ( ) , elStart ) ; \nString values = getStringBetweenBracket ( newComment ) ; \nif ( values == null ) { \nreturn ; \n} \nString key = getAttributeKeyInMapByCell ( cell ) ; \ncellAttributesMap . getCellInputType ( ) . put ( key , type ) ; \nList < CellFormAttributes > inputs = cellAttributesMap . getCellInputAttributes ( ) . get ( key ) ; \nif ( inputs == null ) { \ninputs = new ArrayList < > ( ) ; \ncellAttributesMap . getCellInputAttributes ( ) . put ( key , inputs ) ; \n} \nparseInputAttributes ( inputs , values ) ; \nparseSpecialAttributes ( key , type , inputs , cellAttributesMap ) ; \n} \n} \n"}
{"8730": "public class ParserUtility { \npublic static void parseValidateAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { \nif ( newComment == null ) { \nreturn ; \n} \nelse if ( newComment . isEmpty ( ) ) { \nreturn ; \n} \nif ( ! newComment . startsWith ( TieConstants . METHOD_VALIDATE_PREFIX ) ) { \nreturn ; \n} \nString values = getStringBetweenBracket ( newComment ) ; \nif ( values == null ) { \nreturn ; \n} \nString key = getAttributeKeyInMapByCell ( cell ) ; \nList < CellFormAttributes > attrs = cellAttributesMap . getCellValidateAttributes ( ) . get ( key ) ; \nif ( attrs == null ) { \nattrs = new ArrayList < > ( ) ; \ncellAttributesMap . getCellValidateAttributes ( ) . put ( key , attrs ) ; \n} \nparseValidateAttributes ( attrs , values ) ; \n} \n} \n"}
{"8734": "public class ParserUtility { \npublic static void parseValidateAttributes ( final List < CellFormAttributes > clist , final String controlAttrs ) { \nif ( controlAttrs == null ) { \nreturn ; \n} \nString [ ] cattrs = controlAttrs . split ( TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; \nCellFormAttributes attr = new CellFormAttributes ( ) ; \nfor ( String cattr : cattrs ) { \nextractValidationAttributes ( attr , cattr ) ; \n} \nif ( attr . getValue ( ) != null ) { \nif ( ! attr . getValue ( ) . isEmpty ( ) ) { \nclist . add ( attr ) ; \n} \n} \n} \n} \n"}
{"8738": "public class ParserUtility { \nprivate static void processSelectItemAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { \nif ( sAttr . selectValues == null ) { \nsAttr . selectValues = sAttr . selectLabels ; \n} \nelse if ( sAttr . selectValues . length != sAttr . selectLabels . length ) { \nsAttr . selectValues = sAttr . selectLabels ; \n} \nMap < String , String > smap = cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( key ) ; \nif ( smap == null ) { \nsmap = new LinkedHashMap < > ( ) ; \n} \nsmap . clear ( ) ; \nif ( sAttr . defaultSelectLabel != null ) { \nsmap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; \n} \nfor ( int i = 0 ; \ni < sAttr . selectLabels . length ; \ni ++ ) { \nsmap . put ( sAttr . selectLabels [ i ] , sAttr . selectValues [ i ] ) ; \n} \ncellAttributesMap . getCellSelectItemsAttributes ( ) . put ( key , smap ) ; \n} \n} \n"}
{"8739": "public class ParserUtility { \nprivate static void gatherSpecialAttributes ( final String type , final SpecialAttributes sAttr , final CellFormAttributes attr ) { \nString attrKey = attr . getType ( ) ; \nif ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_LABELS ) ) { \nsAttr . selectLabels = attr . getValue ( ) . split ( \";\" ) ; \n} \nif ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_VALUES ) ) { \nsAttr . selectValues = attr . getValue ( ) . split ( \";\" ) ; \n} \nif ( attrKey . equalsIgnoreCase ( TieConstants . DEFAULT_SELECT_ITEM_LABEL ) ) { \nsAttr . defaultSelectLabel = attr . getValue ( ) ; \n} \nif ( attrKey . equalsIgnoreCase ( TieConstants . DEFAULT_SELECT_ITEM_VALUE ) ) { \nsAttr . defaultSelectValue = attr . getValue ( ) ; \n} \nif ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) ) { \nif ( attrKey . equalsIgnoreCase ( TieConstants . WIDGET_ATTR_PATTERN ) ) { \nsAttr . defaultDatePattern = attr . getValue ( ) ; \n} \n} \n} \n} \n"}
{"8740": "public class ParserUtility { \npublic static void parseCommentToMap ( final String cellKey , final String newComment , final Map < String , Map < String , String > > sheetCommentMap , final boolean normalComment ) { \nif ( newComment != null ) { \nif ( ! newComment . trim ( ) . isEmpty ( ) ) { \nString commentKey = TieConstants . NORMAL_COMMENT_KEY_IN_MAP ; \nif ( ! normalComment ) { \ncommentKey = newComment . substring ( 0 , newComment . indexOf ( TieConstants . EL_START_BRACKET ) ) ; \n} \nMap < String , String > map = sheetCommentMap . get ( commentKey ) ; \nif ( map == null ) { \nmap = new HashMap < > ( ) ; \n} \nmap . put ( cellKey , newComment ) ; \nsheetCommentMap . put ( commentKey , map ) ; \n} \n} \n} \n} \n"}
{"8741": "public class ParserUtility { \npublic static int findFirstNonCellNamePosition ( String input , int startPosition ) { \nchar c ; \nfor ( int i = startPosition ; \ni < input . length ( ) ; \ni ++ ) { \nc = input . charAt ( i ) ; \nif ( c != '$' ) { \nif ( ! Character . isLetterOrDigit ( c ) ) { \nreturn i ; \n} \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8750": "public class WebSheetUtility { \nprivate static boolean shouldContinue ( final char c , final ShouldContinueParameter para ) { \nif ( c == '.' && ! para . isDecimalHit ( ) ) { \npara . setDecimalHit ( true ) ; \nif ( para . isCommaHit ( ) ) { \nif ( para . getSinceLastComma ( ) != 3 ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nelse if ( c == ',' ) { \nif ( ! para . isDecimalHit ( ) ) { \nif ( para . isCommaHit ( ) ) { \nif ( para . getSinceLastComma ( ) != 3 ) { \nreturn false ; \n} \npara . setSinceLastComma ( 0 ) ; \n} \npara . setCommaHit ( true ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8758": "public class ValidationHandler { \nprivate void refreshAfterStatusChanged ( final boolean oldStatus , final boolean newStatus , final int formRow , final int formCol , final FacesCell cell , final boolean updateGui ) { \nif ( ! newStatus ) { \ncell . setErrormsg ( \"\" ) ; \n} \ncell . setInvalid ( newStatus ) ; \nif ( updateGui && ( oldStatus != newStatus ) ) { \nif ( parent . getWebFormClientId ( ) != null ) { \nRequestContext . getCurrentInstance ( ) . update ( parent . getWebFormClientId ( ) + \":\" + ( formRow ) + \":group\" + ( formCol ) ) ; \n} \n} \n} \n} \n"}
{"8759": "public class ValidationHandler { \npublic boolean validateWithRowColInCurrentPage ( final int row , final int col , boolean updateGui ) { \nboolean submitMode = parent . getSubmitMode ( ) ; \nboolean passEmptyCheck = ! submitMode ; \nint topRow = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nint leftCol = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \nboolean pass = true ; \nFacesRow fRow = CellUtility . getFacesRowFromBodyRow ( row , parent . getBodyRows ( ) , topRow ) ; \nif ( fRow == null ) { \nreturn pass ; \n} \nFacesCell cell = CellUtility . getFacesCellFromBodyRow ( row , col , parent . getBodyRows ( ) , topRow , leftCol ) ; \nif ( cell == null ) { \nreturn pass ; \n} \nCell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( row , col ) ; \nboolean oldStatus = cell . isInvalid ( ) ; \nString value = CellUtility . getCellValueWithoutFormat ( poiCell ) ; \nif ( value == null ) { \nvalue = \"\" ; \n} \nelse { \nvalue = value . trim ( ) ; \n} \nif ( passEmptyCheck ) { \nif ( value . isEmpty ( ) ) { \nrefreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; \nreturn pass ; \n} \n} \nif ( ( parent . isOnlyValidateInSubmitMode ( ) && submitMode ) || ! parent . isOnlyValidateInSubmitMode ( ) ) { \nif ( ! validateByTieWebSheetValidationBean ( poiCell , topRow , leftCol , cell , value , updateGui ) ) { \nreturn false ; \n} \n} \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; \nList < CellFormAttributes > cellAttributes = CellControlsUtility . findCellValidateAttributes ( parent . getCellAttributesMap ( ) . getCellValidateAttributes ( ) , fRow . getOriginRowIndex ( ) , poiCell ) ; \nif ( parent . isAdvancedContext ( ) && parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) != null ) { \nif ( ! checkErrorMessageFromObjectInContext ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , updateGui ) ) { \nreturn false ; \n} \n} \nif ( cellAttributes != null ) { \npass = validateAllRulesForSingleCell ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , cellAttributes , updateGui ) ; \n} \nif ( pass ) { \nrefreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; \n} \nreturn pass ; \n} \n} \n"}
{"8760": "public class ValidationHandler { \nprivate boolean validateByTieWebSheetValidationBean ( final Cell poiCell , final int topRow , final int leftCol , final FacesCell cell , final String value , boolean updateGui ) { \nif ( parent . getTieWebSheetValidationBean ( ) != null ) { \nString errormsg = null ; \nString fullName = ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) ; \nString saveAttr = SaveAttrsUtility . prepareContextAndAttrsForCell ( poiCell , fullName , parent . getCellHelper ( ) ) ; \nif ( saveAttr != null ) { \nint row = poiCell . getRowIndex ( ) ; \nint col = poiCell . getColumnIndex ( ) ; \nerrormsg = parent . getTieWebSheetValidationBean ( ) . validate ( parent . getSerialDataContext ( ) . getDataContext ( ) , saveAttr , ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) , poiCell . getSheet ( ) . getSheetName ( ) , row , col , value ) ; \nif ( errormsg != null ) { \nif ( ! errormsg . isEmpty ( ) ) { \ncell . setErrormsg ( errormsg ) ; \nrefreshAfterStatusChanged ( false , true , row - topRow , col - leftCol , cell , updateGui ) ; \nreturn false ; \n} \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8761": "public class ValidationHandler { \nprivate boolean checkErrorMessageFromObjectInContext ( final int formRow , final int formCol , final FacesCell cell , final Cell poiCell , final String value , final SheetConfiguration sheetConfig , boolean updateGui ) { \n@ SuppressWarnings ( \"unchecked\" ) HashMap < String , TieCell > tieCells = ( HashMap < String , TieCell > ) parent . getSerialDataContext ( ) . getDataContext ( ) . get ( \"tiecells\" ) ; \nif ( tieCells != null ) { \nTieCell tieCell = tieCells . get ( CellUtility . getSkeyFromPoiCell ( poiCell ) ) ; \nif ( tieCell != null ) { \nif ( tieCell . getContextObject ( ) != null ) { \nString errorMethod = tieCell . getMethodStr ( ) + parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) ; \nString errorMessage = CellControlsUtility . getObjectPropertyValue ( tieCell . getContextObject ( ) , errorMethod , true ) ; \nif ( errorMessage != null ) { \nif ( ! errorMessage . isEmpty ( ) ) { \ncell . setErrormsg ( errorMessage ) ; \nLOG . log ( Level . INFO , \"Validation failed for sheet {0} row {1} column {2} : {3}\" , new Object [ ] { \npoiCell . getSheet ( ) . getSheetName ( ) , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , errorMessage } \n) ; \nrefreshAfterStatusChanged ( false , true , formRow , formCol , cell , updateGui ) ; \nreturn false ; \n} \n} \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8767": "public class ValidationHandler { \nprivate boolean validateRow ( final int irow , final SheetConfiguration sheetConfig , boolean updateGui ) { \nboolean pass = true ; \nif ( sheetConfig == null ) { \nreturn pass ; \n} \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nList < FacesCell > cellRow = parent . getBodyRows ( ) . get ( irow - top ) . getCells ( ) ; \nfor ( int index = 0 ; \nindex < cellRow . size ( ) ; \nindex ++ ) { \nFacesCell fcell = cellRow . get ( index ) ; \nif ( fcell != null ) { \nif ( ! validateWithRowColInCurrentPage ( irow , fcell . getColumnIndex ( ) , updateGui ) ) { \npass = false ; \n} \n} \n} \nreturn pass ; \n} \n} \n"}
{"8770": "public class ValidationHandler { \npublic void setSubmitModeInView ( final Boolean fullflag ) { \nif ( FacesContext . getCurrentInstance ( ) != null ) { \nMap < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; \nif ( viewMap != null ) { \nBoolean flag = ( Boolean ) viewMap . get ( TieConstants . SUBMITMODE ) ; \nif ( flag == null ) { \nviewMap . put ( TieConstants . SUBMITMODE , fullflag ) ; \n} \nelse if ( ! flag . equals ( fullflag ) ) { \nviewMap . put ( TieConstants . SUBMITMODE , fullflag ) ; \n} \n} \n} \n} \n} \n"}
{"8771": "public class ValidationHandler { \npublic boolean preValidation ( ) { \nString currentTabName = parent . getCurrent ( ) . getCurrentTabName ( ) ; \nString tabName = null ; \nString firstInvalidTabName = null ; \nboolean reload = false ; \nfor ( Map . Entry < String , SheetConfiguration > entry : parent . getSheetConfigMap ( ) . entrySet ( ) ) { \ntabName = entry . getKey ( ) ; \nif ( reload ) { \nparent . getWebSheetLoader ( ) . prepareWorkShee ( tabName ) ; \nreload = true ; \n} \nelse if ( ! tabName . equals ( currentTabName ) ) { \nparent . getWebSheetLoader ( ) . prepareWorkShee ( tabName ) ; \nreload = true ; \n} \nif ( ! parent . getValidationHandler ( ) . validateCurrentPage ( ) ) { \nif ( firstInvalidTabName == null ) { \nfirstInvalidTabName = tabName ; \n} \n} \n} \nif ( firstInvalidTabName != null ) { \nif ( ! tabName . equals ( firstInvalidTabName ) ) { \nparent . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( firstInvalidTabName ) ; \n} \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"8778": "public class WebSheetLoader { \nprivate List < HeaderCell > loadHeaderRowWithConfigurationTab ( final SheetConfiguration sheetConfig , final RangeBuildRef rangeBuildRef , final int currentRow , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nSheet sheet1 = rangeBuildRef . getSheet ( ) ; \nint left = rangeBuildRef . getLeft ( ) ; \nint right = rangeBuildRef . getRight ( ) ; \ndouble totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; \nRow row = sheet1 . getRow ( currentRow ) ; \nList < HeaderCell > headercells = new ArrayList < > ( ) ; \nfor ( int cindex = left ; \ncindex <= right ; \ncindex ++ ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , currentRow ) ; \nif ( ! skippedRegionCells . contains ( cellindex ) ) { \nif ( ! sheet1 . isColumnHidden ( cindex ) ) { \nCell cell = null ; \nif ( row != null ) { \ncell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \n} \nint originRowIndex = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; \nif ( cell != null ) { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , originRowIndex , parent . getCellAttributesMap ( ) , null ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnStyle ( fcell . getColumnStyle ( ) + getColumnWidthStyle ( sheet1 , cellRangeMap , cellindex , cindex , totalWidth ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nheadercells . add ( new HeaderCell ( Integer . toString ( fcell . getRowspan ( ) ) , Integer . toString ( fcell . getColspan ( ) ) , fcell . getStyle ( ) , fcell . getColumnStyle ( ) , CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) , true , true ) ) ; \n} \n} \n} \n} \nfillToMaxColumns ( headercells ) ; \nreturn headercells ; \n} \n} \n"}
{"8787": "public class WebSheetLoader { \npublic final void loadWorkSheet ( final String tabName ) { \nprepareWorkShee ( tabName ) ; \nparent . getValidationHandler ( ) . validateCurrentPage ( ) ; \ncreateDynamicColumns ( tabName ) ; \nsetDataTablePage ( 0 ) ; \nparent . getCurrent ( ) . setCurrentDataContextName ( null ) ; \nsaveObjs ( ) ; \nif ( RequestContext . getCurrentInstance ( ) != null ) { \nif ( parent . getClientId ( ) != null ) { \nRequestContext . getCurrentInstance ( ) . update ( parent . getClientId ( ) + \":websheettab\" ) ; \n} \n} \n} \n} \n"}
{"8794": "public class WebSheetLoader { \npublic final void refreshCachedCell ( final String tblName , final int i , final int index , final Cell cell , final FacesCell fcell ) { \nif ( ( cell != null ) && ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) ) { \nif ( tblName != null ) { \ntry { \nprocessRefreshCell ( tblName , i , index , cell , fcell ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"refresh Cached Cell error : \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \n} \n} \n"}
{"8801": "public class Utils { \npublic static < T > Constructor < T > commonConstructor ( Class < T > type ) throws NoMethodForDependency { \nConstructor < ? > [ ] cs = type . getDeclaredConstructors ( ) ; \nif ( cs . length == 0 ) throw new NoMethodForDependency ( raw ( type ) ) ; \nConstructor < ? > mostParamsConstructor = null ; \nfor ( Constructor < ? > c : cs ) { \nif ( ! arrayContains ( c . getParameterTypes ( ) , type , ( a , b ) -> a == b ) ) { \nif ( mostParamsConstructor == null || ( moreVisible ( c , mostParamsConstructor ) == c && ( moreVisible ( mostParamsConstructor , c ) == c || c . getParameterCount ( ) > mostParamsConstructor . getParameterCount ( ) ) ) ) { \nmostParamsConstructor = c ; \n} \n} \n} \nif ( mostParamsConstructor == null ) throw new NoMethodForDependency ( raw ( type ) ) ; \n@ SuppressWarnings ( \"unchecked\" ) Constructor < T > c = ( Constructor < T > ) mostParamsConstructor ; \nreturn c ; \n} \n} \n"}
{"8816": "public class ImageRequest { \npublic void storeToDisk ( ) throws IOException { \nif ( manager . isPresentOnDisk ( url ) ) { \nreturn ; \n} \nif ( ! hasAllowedSize ( ) ) { \nIoUtils . consumeStream ( getRemoteInputStream ( ) , manager . getBuffersPool ( ) ) ; \nreturn ; \n} \nImageResult result = decodeStream ( getRemoteInputStream ( ) , true ) ; \nif ( result . getType ( ) == ImageSourceType . NETWORK ) { \nif ( result . getBitmap ( ) != null ) { \nwriteBitmapToDisk ( result . getBitmap ( ) ) ; \n} \n} \n} \n} \n"}
{"8820": "public class PoolableBufferedInputStream { \n@ Override public synchronized int available ( ) throws IOException { \nfinal InputStream localIn = in ; \nif ( buf == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \nelse if ( localIn == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \nreturn count - pos + localIn . available ( ) ; \n} \n} \n"}
{"8822": "public class PoolableBufferedInputStream { \n@ Override public synchronized int read ( ) throws IOException { \nbyte [ ] localBuf = buf ; \nfinal InputStream localIn = in ; \nif ( localBuf == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \nelse if ( localIn == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \nif ( pos >= count ) { \nif ( fillbuf ( localIn , localBuf ) == - 1 ) { \nreturn - 1 ; \n} \n} \nif ( localBuf != buf ) { \nlocalBuf = buf ; \nif ( localBuf == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \n} \nfinal int mask = 0xFF ; \nif ( count - pos > 0 ) { \nreturn localBuf [ pos ++ ] & mask ; \n} \nreturn - 1 ; \n} \n} \n"}
{"8830": "public class Part { \npublic static void sendParts ( final OutputStream out , final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( parts == null ) { \nthrow new IllegalArgumentException ( \"Parts may not be null\" ) ; \n} \nif ( partBoundary == null ) { \nthrow new IllegalArgumentException ( \"partBoundary may not be empty\" ) ; \n} \nelse if ( partBoundary . length == 0 ) { \nthrow new IllegalArgumentException ( \"partBoundary may not be empty\" ) ; \n} \nfor ( int i = 0 ; \ni < parts . length ; \ni ++ ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nparts [ i ] . send ( out ) ; \n} \nout . write ( EXTRA_BYTES ) ; \nout . write ( partBoundary ) ; \nout . write ( EXTRA_BYTES ) ; \nout . write ( CRLF_BYTES ) ; \n} \n} \n"}
{"8842": "public class BaseFileResponseCache { \nprotected CacheResponse get ( final CacheEntry requestInfo ) { \nif ( ! checkDiskCache ( ) ) { \nreturn null ; \n} \nfinal CacheEntry entry = newCacheEntry ( ) ; \nfinal DiskLruCache . Snapshot snapshot = readCacheInfo ( requestInfo , entry ) ; \nif ( snapshot == null ) { \nreturn null ; \n} \nif ( ! entry . matches ( requestInfo ) ) { \nsnapshot . close ( ) ; \nreturn null ; \n} \nelse if ( ! entry . canBeUsed ( ) ) { \nsnapshot . close ( ) ; \nreturn null ; \n} \nhitCount . incrementAndGet ( ) ; \nfinal InputStream body = newBodyInputStream ( snapshot ) ; \nreturn entry . newCacheResponse ( body ) ; \n} \n} \n"}
{"8853": "public class ViewImageConsumer { \npublic void notifyAboutViewChanges ( ) { \nfinal T view = this . view ; \nif ( view != null ) { \nif ( view instanceof ImagesLoadListenerProvider ) { \nthis . listener = ( ( ImagesLoadListenerProvider ) view ) . getImagesLoadListener ( ) ; \n} \n} \n} \n} \n"}
{"8866": "public class ImagesManager { \npublic void cancelImageLoading ( final View view ) { \ncheckThread ( ) ; \nfinal Object tag = view . getTag ( ) ; \nif ( tag != null ) { \nif ( tag instanceof ImageConsumer ) { \ncancelImageLoading ( ( ImageConsumer ) tag ) ; \n} \n} \n} \n} \n"}
{"8869": "public class ImagesManager { \nprivate void setLoadingImage ( final ImageConsumer consumer ) { \nif ( ! consumer . skipLoadingImage ( ) ) { \nDrawable d = getLoadingDrawable ( consumer ) ; \nif ( ! consumer . hasUndefinedSize ( ) ) { \nconsumer . setLoadingImage ( d ) ; \n} \nelse if ( d . getIntrinsicWidth ( ) != 0 && d . getIntrinsicHeight ( ) != 0 ) { \nconsumer . setLoadingImage ( d ) ; \n} \n} \n} \n} \n"}
{"8879": "public class JCublas2 { \nprivate static int checkResult ( int result ) { \nif ( exceptionsEnabled ) { \nif ( result != cublasStatus . CUBLAS_STATUS_SUCCESS ) { \nthrow new CudaException ( cublasStatus . stringFor ( result ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"8888": "public class MarkupConverter { \npublic static String removeKamolsMarkupFormating ( String tag ) { \nString result = \"\" ; \nif ( ! tag . contains ( \",\" ) ) return \"x\" ; \nint depth = 0 ; \nint commas = 0 ; \nfor ( char c : tag . toCharArray ( ) ) { \nif ( c == '[' ) depth ++ ; \nif ( c == ']' ) depth -- ; \nif ( depth == 1 ) { \nif ( c == ',' ) commas ++ ; \n} \nif ( commas == 2 ) result = result + c ; \n} \nresult = result . replaceAll ( \"_[A-Z0-9]*\" , \"_\" ) ; \nresult = result . replaceAll ( \"(\\\\[|\\\\]|\\\\,| )\" , \"\" ) ; \nreturn result ; \n} \n} \n"}
{"8924": "public class LogPersister { \nstatic public void setContext ( final Context context ) { \nif ( null == LogPersister . context ) { \nLogManager . getLogManager ( ) . getLogger ( \"\" ) . addHandler ( julHandler ) ; \njava . util . logging . Logger . getLogger ( \"\" ) . setLevel ( Level . ALL ) ; \nLogPersister . context = context ; \nif ( fileLoggerInstance == null ) { \nFileLogger . setContext ( context ) ; \nfileLoggerInstance = FileLogger . getInstance ( ) ; \n} \nelse if ( fileLoggerInstance instanceof FileLogger ) { \nFileLogger . setContext ( context ) ; \nfileLoggerInstance = FileLogger . getInstance ( ) ; \n} \nSharedPreferences prefs = LogPersister . context . getSharedPreferences ( SHARED_PREF_KEY , Context . MODE_PRIVATE ) ; \nif ( null != level ) { \nsetLevelSync ( level ) ; \n} \nelse { \nsetLevelSync ( Logger . LEVEL . fromString ( prefs . getString ( SHARED_PREF_KEY_level , getLevelDefault ( ) . toString ( ) ) ) ) ; \n} \nif ( null != logFileMaxSize ) { \nsetMaxLogStoreSize ( logFileMaxSize ) ; \n} \nelse { \nsetMaxLogStoreSize ( prefs . getInt ( SHARED_PREF_KEY_logFileMaxSize , DEFAULT_logFileMaxSize ) ) ; \n} \nif ( null != capture ) { \nsetCaptureSync ( capture ) ; \n} \nelse { \nsetCaptureSync ( prefs . getBoolean ( SHARED_PREF_KEY_logPersistence , DEFAULT_capture ) ) ; \n} \nuncaughtExceptionHandler = new UncaughtExceptionHandler ( ) ; \nThread . setDefaultUncaughtExceptionHandler ( uncaughtExceptionHandler ) ; \n} \n} \n} \n"}
{"8932": "public class BMSAnalytics { \nprivate static void setUserIdentity ( final String user , boolean isInitialCtx ) { \nif ( ! isInitialCtx ) { \nif ( ! BMSAnalytics . hasUserContext ) { \nlogger . error ( \"Cannot set user identity with anonymous user collection enabled.\" ) ; \nreturn ; \n} \n} \nJSONObject metadata = new JSONObject ( ) ; \nDEFAULT_USER_ID = user ; \nString hashedUserID = UUID . nameUUIDFromBytes ( user . getBytes ( ) ) . toString ( ) ; \ntry { \nif ( isInitialCtx ) { \nmetadata . put ( CATEGORY , INITIAL_CTX_CATEGORY ) ; \n} \nelse { \nmetadata . put ( CATEGORY , USER_SWITCH_CATEGORY ) ; \n} \nif ( BMSAnalytics . collectLocation ) { \nif ( locationService . getInitLocationRequests ( ) ) { \nmetadata . put ( LONGITUDE_KEY , locationService . getLongitude ( ) ) ; \nmetadata . put ( LATITUDE_KEY , locationService . getLatitude ( ) ) ; \n} \n} \nmetadata . put ( TIMESTAMP_KEY , ( new Date ( ) ) . getTime ( ) ) ; \nmetadata . put ( APP_SESSION_ID_KEY , MFPAnalyticsActivityLifecycleListener . getAppSessionID ( ) ) ; \nmetadata . put ( USER_ID_KEY , hashedUserID ) ; \n} \ncatch ( JSONException e ) { \nlogger . debug ( \"JSONException encountered logging change in user context: \" + e . getMessage ( ) ) ; \n} \nMFPInAppFeedBackListner . setUserIdentity ( user ) ; \nlog ( metadata ) ; \n} \n} \n"}
{"8934": "public class MFPAnalyticsLocationListener { \nprotected void startLocationUpdates ( ) { \nif ( ActivityCompat . checkSelfPermission ( Context , Manifest . permission . ACCESS_FINE_LOCATION ) != PackageManager . PERMISSION_GRANTED ) { \nif ( ActivityCompat . checkSelfPermission ( Context , Manifest . permission . ACCESS_COARSE_LOCATION ) != PackageManager . PERMISSION_GRANTED ) { \nreturn ; \n} \n} \nLocationServices . FusedLocationApi . requestLocationUpdates ( mGoogleApiClient , mLocationRequest , this ) ; \n} \n} \n"}
{"8941": "public class StatsToChart { \npublic Chart convert ( File file ) { \nif ( file == null ) return null ; \ntry { \nif ( file . isDirectory ( ) ) { \nSet < File > statsFiles = IO . listFileRecursive ( file , \"*.gfs\" ) ; \nif ( statsFiles == null ) return null ; \nelse if ( statsFiles . isEmpty ( ) ) return null ; \nfor ( File statFile : statsFiles ) { \nGfStatsReader reader = new GfStatsReader ( statFile . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \n} \nelse { \nGfStatsReader reader = new GfStatsReader ( file . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \nreturn visitor . getChart ( ) ; \n} \ncatch ( IOException e ) { \nthrow new RuntimeException ( \"File:\" + file + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8942": "public class GemFireJmxClient { \npublic static synchronized Pool getPoolForServer ( String serverName , JMX jmx ) throws InstanceNotFoundException { \nPool pool = PoolManager . find ( serverName ) ; \nif ( pool != null ) return pool ; \nPoolFactory poolFactory = PoolManager . createFactory ( ) ; \ntry { \nObjectName objectName = new ObjectName ( new StringBuilder ( \"GemFire:type=Member,member=\" ) . append ( serverName ) . toString ( ) ) ; \nString host = jmx . getAttribute ( objectName , \"Host\" ) ; \nif ( host == null ) throw new IllegalArgumentException ( \"host not found for serverName:\" + serverName + \" not found\" ) ; \nelse if ( host . length ( ) == 0 ) throw new IllegalArgumentException ( \"host not found for serverName:\" + serverName + \" not found\" ) ; \nhost = lookupNetworkHost ( host ) ; \nString findJmxPort = new StringBuilder ( \"GemFire:service=CacheServer,port=*,type=Member,member=\" ) . append ( serverName ) . toString ( ) ; \nSet < ObjectName > objectNames = jmx . searchObjectNames ( findJmxPort ) ; \nif ( objectNames == null ) throw new IllegalArgumentException ( \"Unable to to find port with server name:\" + serverName ) ; \nelse if ( objectNames . isEmpty ( ) ) throw new IllegalArgumentException ( \"Unable to to find port with server name:\" + serverName ) ; \nObjectName portObjectName = objectNames . iterator ( ) . next ( ) ; \nInteger port = jmx . getAttribute ( portObjectName , \"Port\" ) ; \nif ( port == null ) throw new IllegalArgumentException ( \"Unable to obtain port for objectName:\" + portObjectName + \" for server:\" + serverName ) ; \nSystem . out . println ( \"Found cache server host\" + host + \" port:\" + port ) ; \npoolFactory = poolFactory . addServer ( host , port . intValue ( ) ) ; \nreturn poolFactory . create ( serverName ) ; \n} \ncatch ( InstanceNotFoundException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( \"Unable to create pool for servername:\" + serverName + \" error:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8944": "public class GemFireJmxClient { \nprivate static boolean isExistingRegionOnServer ( String regionName , JMX jmx ) { \nString regionJmxPattern = String . format ( \"GemFire:service=Region,name=/%s,type=Distributed\" , regionName ) ; \nSet < ObjectName > regionObjNameSet = jmx . searchObjectNames ( regionJmxPattern ) ; \nif ( regionObjNameSet == null ) { \nregionJmxPattern = String . format ( \"GemFire:service=Region,name=\\\"/%s\\\",type=Distributed\" , regionName ) ; \nregionObjNameSet = jmx . searchObjectNames ( regionJmxPattern ) ; \n} \nelse if ( regionObjNameSet . isEmpty ( ) ) { \nregionJmxPattern = String . format ( \"GemFire:service=Region,name=\\\"/%s\\\",type=Distributed\" , regionName ) ; \nregionObjNameSet = jmx . searchObjectNames ( regionJmxPattern ) ; \n} \nreturn regionObjNameSet != null && ! regionObjNameSet . isEmpty ( ) ; \n} \n} \n"}
{"8945": "public class GemFireJmxClient { \npublic static MemberMXBean getMember ( String name , JMX jmx ) { \ntry { \nString pattern = \"GemFire:type=Member,member=\" + name ; \nSet < ObjectName > objectNames = jmx . searchObjectNames ( pattern ) ; \nif ( objectNames == null ) return null ; \nelse if ( objectNames . isEmpty ( ) ) return null ; \nObjectName serverName = new ObjectName ( pattern ) ; \nreturn jmx . newBean ( MemberMXBean . class , serverName ) ; \n} \ncatch ( MalformedObjectNameException e ) { \nthrow new RuntimeException ( \"Unable to get member \" + name + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8946": "public class GemFireJmxClient { \npublic static Collection < String > listHosts ( JMX jmx ) { \nSet < ObjectName > objectNames = jmx . searchObjectNames ( \"GemFire:type=Member,member=*\" ) ; \nif ( objectNames == null ) { \nreturn null ; \n} \nelse if ( objectNames . isEmpty ( ) ) { \nreturn null ; \n} \nHashSet < String > hostLists = new HashSet < String > ( objectNames . size ( ) ) ; \nMemberMXBean memberMXBean = null ; \nfor ( ObjectName objectName : objectNames ) { \nmemberMXBean = jmx . newBean ( MemberMXBean . class , objectName ) ; \nhostLists . add ( memberMXBean . getHost ( ) ) ; \n} \nreturn hostLists ; \n} \n} \n"}
{"8950": "public class GemFireIO { \n@ SuppressWarnings ( \"unchecked\" ) public static < T > void flatten ( Collection < Object > input , Collection < Object > flattenOutput ) throws Exception { \nif ( input == null || input . isEmpty ( ) ) return ; \nelse if ( flattenOutput == null ) return ; \nfor ( Object inputObj : input ) { \nif ( inputObj instanceof Exception ) throw ( Exception ) inputObj ; \nif ( inputObj == null ) continue ; \nif ( inputObj instanceof Collection ) flatten ( ( Collection < Object > ) inputObj , flattenOutput ) ; \nelse flattenOutput . add ( inputObj ) ; \n} \n} \n} \n"}
{"8951": "public class Querier { \n@ SuppressWarnings ( \"unchecked\" ) public static < ReturnType > Collection < ReturnType > query ( Query queryObj , RegionFunctionContext rfc , Object ... params ) throws FunctionDomainException , TypeMismatchException , NameResolutionException , QueryInvocationTargetException { \nSelectResults < ReturnType > selectResults ; \nif ( rfc == null || JvmRegionFunctionContext . class . isAssignableFrom ( rfc . getClass ( ) ) ) { \nif ( params == null || params . length == 0 ) { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( ) ; \n} \nelse { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( params ) ; \n} \nif ( selectResults == null ) return null ; \nelse if ( selectResults . isEmpty ( ) ) return null ; \nArrayList < ReturnType > results = new ArrayList < ReturnType > ( selectResults . size ( ) ) ; \nresults . addAll ( selectResults . asList ( ) ) ; \nreturn results ; \n} \nelse { \nif ( params == null || params . length == 0 ) { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc ) ; \n} \nelse { \nselectResults = ( SelectResults < ReturnType > ) queryObj . execute ( rfc , params ) ; \n} \nif ( selectResults == null ) return null ; \nelse if ( selectResults . isEmpty ( ) ) return null ; \nreturn selectResults ; \n} \n} \n} \n"}
{"8956": "public class ReadExportFunction { \n@ Override public void execute ( FunctionContext < Object > functionContext ) { \nResultSender < Object > sender = functionContext . getResultSender ( ) ; \nCache cache = CacheFactory . getAnyInstance ( ) ; \nLogger logWriter = LogManager . getLogger ( getClass ( ) ) ; \ntry { \nString [ ] args = ( String [ ] ) functionContext . getArguments ( ) ; \nif ( args == null ) throw new FunctionException ( \"Required array args: [region,extension]\" ) ; \nelse if ( args . length != 2 ) throw new FunctionException ( \"Required array args: [region,extension]\" ) ; \nString extensionArg = args [ 0 ] ; \nif ( extensionArg == null ) { \nthrow new IllegalArgumentException ( \"File extension required\" ) ; \n} \nelse if ( extensionArg . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"File extension required\" ) ; \n} \nExportFileType extension = ExportFileType . valueOf ( extensionArg ) ; \nString regionName = args [ 1 ] ; \nRegion < Object , Object > region = cache . getRegion ( regionName ) ; \nif ( region == null ) { \nsender . lastResult ( null ) ; \nreturn ; \n} \nFile file = new File ( new StringBuilder ( directoryPath ) . append ( \"/\" ) . append ( regionName ) . append ( \".\" ) . append ( extensionArg ) . toString ( ) ) ; \nString serverName = cache . getDistributedSystem ( ) . getDistributedMember ( ) . getName ( ) ; \nswitch ( extension ) { \ncase gfd : new GfdExportFunction ( ) . exportRegion ( region ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Unsupported extension file type:\" + extension ) ; \n} \nSerializable content = readContent ( file , extension , logWriter ) ; \nSerializable [ ] arrayResults = { \nserverName , content , file . getAbsolutePath ( ) } \n; \nsender . lastResult ( arrayResults ) ; \n} \ncatch ( Exception e ) { \nString stackTrace = Debugger . stackTrace ( e ) ; \nlogWriter . error ( stackTrace ) ; \nthrow new FunctionException ( stackTrace ) ; \n} \n} \n} \n"}
{"8957": "public class GemFireInspector { \npublic static Set < String > listHosts ( JMX jmx ) { \nSet < ObjectName > memberObjects = jmx . searchObjectNames ( \"GemFire:type=Member,member=*\" ) ; \nif ( memberObjects == null ) { \nreturn null ; \n} \nelse if ( memberObjects . isEmpty ( ) ) { \nreturn null ; \n} \nHashSet < String > hostList = new HashSet < String > ( memberObjects . size ( ) ) ; \nMemberMXBean bean = null ; \nfor ( ObjectName objectName : memberObjects ) { \nbean = jmx . newBean ( MemberMXBean . class , objectName ) ; \ntry { \nhostList . add ( bean . getHost ( ) ) ; \n} \ncatch ( UndeclaredThrowableException e ) { \n} \n} \nreturn hostList ; \n} \n} \n"}
{"8959": "public class StatsUtil { \npublic static String getAppName ( ResourceInst [ ] resources ) { \nif ( resources == null ) return null ; \nelse if ( resources . length == 0 ) return null ; \nResourceType rt = null ; \nfor ( ResourceInst resourceInst : resources ) { \nif ( resourceInst == null ) continue ; \nrt = resourceInst . getType ( ) ; \nif ( rt == null ) continue ; \nif ( ! \"CacheServerStats\" . equals ( rt . getName ( ) ) ) continue ; \nreturn resourceInst . getName ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"8961": "public class GeodeClient { \n@ SuppressWarnings ( \"unchecked\" ) public < K , V > Region < K , V > getRegion ( String regionName ) { \nif ( regionName == null ) return null ; \nelse if ( regionName . length ( ) == 0 ) return null ; \nRegion < K , V > region = ( Region < K , V > ) clientCache . getRegion ( regionName ) ; \nif ( region != null ) return ( Region < K , V > ) region ; \nregion = ( Region < K , V > ) this . createRegion ( regionName ) ; \nif ( cachingProxy ) { \nregion . registerInterestRegex ( \".*\" ) ; \n} \nreturn region ; \n} \n} \n"}
{"8962": "public class GeodeClient { \n@ SuppressWarnings ( \"unchecked\" ) public static < K , V > Region < K , V > getRegion ( ClientCache clientCache , String regionName ) { \nif ( regionName == null ) return null ; \nelse if ( regionName . length ( ) == 0 ) return null ; \nRegion < K , V > region = ( Region < K , V > ) clientCache . getRegion ( regionName ) ; \nif ( region != null ) return ( Region < K , V > ) region ; \nregion = ( Region < K , V > ) clientCache . createClientRegionFactory ( ClientRegionShortcut . PROXY ) . create ( regionName ) ; \nreturn region ; \n} \n} \n"}
{"8963": "public class RegionDiffDirector { \npublic void constructComparison ( Map < ? , BigInteger > sourceChecksumMap , Map < ? , BigInteger > targetMap ) { \nif ( sourceChecksumMap == null ) { \nif ( targetMap != null ) { \nif ( ! targetMap . isEmpty ( ) ) { \nthis . keysRemovedFromSource . addAll ( targetMap . keySet ( ) ) ; \n} \n} \nreturn ; \n} \nif ( targetMap == null ) { \nthis . keysMissingOnTarget . addAll ( sourceChecksumMap . keySet ( ) ) ; \nreturn ; \n} \nBigInteger targetBi = null ; \nBigInteger sourceBi = null ; \nfor ( Map . Entry < ? , BigInteger > entrySource : sourceChecksumMap . entrySet ( ) ) { \ntargetBi = targetMap . get ( entrySource . getKey ( ) ) ; \nsourceBi = sourceChecksumMap . get ( entrySource . getKey ( ) ) ; \nif ( targetBi == null ) { \nkeysMissingOnTarget . add ( entrySource . getKey ( ) ) ; \n} \nelse if ( ! targetBi . equals ( sourceBi ) ) { \nkeysDifferentOnTarget . add ( entrySource . getKey ( ) ) ; \n} \n} \nSet < ? > sourceKeySet = sourceChecksumMap . keySet ( ) ; \nfor ( Map . Entry < ? , ? > targetEntry : targetMap . entrySet ( ) ) { \nif ( ! sourceKeySet . contains ( targetEntry . getKey ( ) ) ) { \nkeysRemovedFromSource . add ( targetEntry . getKey ( ) ) ; \n} \n} \n} \n} \n"}
{"8966": "public class GfStatsReader { \npublic static void toCvsFiles ( File directory ) throws IOException { \nSet < File > statsFiles = IO . listFileRecursive ( directory , \"*.gfs\" ) ; \nif ( statsFiles == null ) return ; \nelse if ( statsFiles . isEmpty ( ) ) return ; \nfor ( File archiveFile : statsFiles ) { \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . dumpCsvFiles ( ) ; \n} \n} \n} \n"}
{"8968": "public class SingletonGemFireJmx { \npublic synchronized static JMX reconnect ( ) { \ntry { \nClientCache cache = null ; \ncache = ClientCacheFactory . getAnyInstance ( ) ; \nif ( cache != null ) { \nif ( ! cache . isClosed ( ) ) { \ncache . close ( ) ; \n} \n} \n} \ncatch ( Exception e ) { \nSystem . out . println ( \"Cache was closed\" ) ; \n} \nif ( jmx != null ) { \njmx . dispose ( ) ; \njmx = null ; \n} \nreturn getJmx ( ) ; \n} \n} \n"}
{"8969": "public class GemFireMgmt { \npublic static int stopMembersOnHost ( String hostName ) { \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp queryExp = null ; \nValueExp [ ] values = null ; \ntry { \nInetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; \nInetAddress address = null ; \nif ( addresses != null ) { \nvalues = new ValueExp [ addresses . length ] ; \nfor ( int i = 0 ; \ni < addresses . length ; \ni ++ ) { \naddress = addresses [ i ] ; \nvalues [ i ] = Query . value ( address . getHostAddress ( ) ) ; \n} \n} \n} \ncatch ( UnknownHostException e ) { \nDebugger . println ( e . getMessage ( ) ) ; \n} \nif ( values != null ) { \nqueryExp = Query . or ( Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( \"Host\" ) , values ) ) ; \n} \nelse { \nqueryExp = Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) ; \n} \nSet < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; \nif ( memberObjectNames == null ) return 0 ; \nelse if ( memberObjectNames . isEmpty ( ) ) return 0 ; \nint memberCount = memberObjectNames . size ( ) ; \nMemberMXBean member = null ; \nCollection < String > locators = new ArrayList < String > ( ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nmember = GemFireJmxClient . getMember ( objectName . getKeyProperty ( \"member\" ) , SingletonGemFireJmx . getJmx ( ) ) ; \nif ( member . isLocator ( ) ) { \nlocators . add ( member . getName ( ) ) ; \n} \nelse { \nshutDownMember ( member . getName ( ) ) ; \n} \n} \nfor ( String locatorName : locators ) { \nshutDownMember ( locatorName ) ; \n} \nreturn memberCount ; \n} \n} \n"}
{"8972": "public class GemFireMgmt { \npublic static void shutDownRedundancyZone ( String redundancyZone ) { \nif ( redundancyZone == null ) throw new IllegalArgumentException ( \"redundancyZone required\" ) ; \nelse if ( redundancyZone . length ( ) == 0 ) throw new IllegalArgumentException ( \"redundancyZone required\" ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp exp = Query . eq ( Query . attr ( \"RedundancyZone\" ) , Query . value ( redundancyZone ) ) ; \nCollection < ObjectName > memberObjectNames = SingletonGemFireJmx . getJmx ( ) . searchObjectNames ( objectNamePattern , exp ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nGemFireMgmt . shutDownMember ( objectName . getKeyProperty ( \"member\" ) ) ; \n} \n} \n} \n"}
{"8973": "public class GeodePagination { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) public < K , V > List < String > storePaginationMap ( String id , int pageSize , Region < String , Collection < K > > pageKeysRegion , List < Map . Entry < K , V > > results ) { \nif ( results == null ) return null ; \nelse if ( results . isEmpty ( ) ) return null ; \nList < Collection < K > > pagesCollection = toKeyPages ( ( List ) results , pageSize ) ; \nint pageIndex = 1 ; \nString key = null ; \nArrayList < String > keys = new ArrayList < String > ( pageSize ) ; \nfor ( Collection < K > page : pagesCollection ) { \nkey = toPageKey ( id , pageIndex ++ ) ; \npageKeysRegion . put ( key , page ) ; \nkeys . add ( key ) ; \n} \nkeys . trimToSize ( ) ; \nreturn keys ; \n} \n} \n"}
{"8974": "public class GeodePagination { \npublic < K , V > Map < K , V > readResultsByPage ( TextPageCriteria criteria , int pageNumber , Region < K , V > region , Region < String , Collection < ? > > pageRegion ) { \nif ( pageRegion == null ) return null ; \nCollection < ? > regionKeys = pageRegion . get ( criteria . toPageKey ( pageNumber ) ) ; \nif ( regionKeys == null ) return null ; \nelse if ( regionKeys . isEmpty ( ) ) return null ; \nreturn region . getAll ( regionKeys ) ; \n} \n} \n"}
{"8976": "public class GemFireNetworking { \npublic static boolean checkRemoteLocatorsAndLocatorsMatch ( String remoteLocators , String locators ) { \nif ( remoteLocators == null ) return false ; \nelse if ( remoteLocators . length ( ) == 0 ) return false ; \nif ( remoteLocators . equalsIgnoreCase ( locators ) ) return true ; \nString [ ] remoteLocatorsArray = remoteLocators . split ( \",\" ) ; \nif ( locators == null ) return false ; \nelse if ( locators . length ( ) == 0 ) return false ; \nString [ ] locatorsArray = locators . split ( \",\" ) ; \nString remoteLocatorHost , locatorHost ; \nint remoteLocatorPort , locatorPort ; \nfor ( String remoteLocator : remoteLocatorsArray ) { \nif ( remoteLocator == null ) continue ; \nelse if ( remoteLocator . length ( ) == 0 ) continue ; \nfor ( String locator : locatorsArray ) { \nif ( locator == null ) continue ; \nelse if ( locator . length ( ) == 0 ) continue ; \ntry { \nremoteLocatorHost = parseLocatorHost ( remoteLocator ) ; \nlocatorHost = parseLocatorHost ( locator ) ; \nremoteLocatorPort = parseLocatorPort ( remoteLocator ) ; \nlocatorPort = parseLocatorPort ( locator ) ; \nif ( Networking . hostEquals ( remoteLocatorHost , locatorHost ) && remoteLocatorPort == locatorPort ) { \nreturn true ; \n} \nelse { \n} \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \ncatch ( IllegalArgumentException e ) { \nthrow new IllegalArgumentException ( \"remoteLocator:\" + remoteLocator + \" locator:\" + locator + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8977": "public class GetEntriesChecksumFunction { \n@ Override public void execute ( FunctionContext < Object > functionContext ) { \ntry { \nString [ ] args = ( String [ ] ) functionContext . getArguments ( ) ; \nif ( args == null ) throw new IllegalArgumentException ( \"region argument required\" ) ; \nelse if ( args . length == 0 ) throw new IllegalArgumentException ( \"region argument required\" ) ; \nString regionName = args [ 0 ] ; \nif ( regionName == null ) throw new IllegalArgumentException ( \"region name argument required\" ) ; \nelse if ( regionName . length ( ) == 0 ) throw new IllegalArgumentException ( \"region name argument required\" ) ; \nRegion < Serializable , Object > region = CacheFactory . getAnyInstance ( ) . getRegion ( regionName ) ; \nif ( region == null ) throw new IllegalArgumentException ( \"region:\" + regionName + \" not found\" ) ; \nfunctionContext . getResultSender ( ) . lastResult ( buildCheckSumMap ( region ) ) ; \n} \ncatch ( Exception e ) { \nString stack = Debugger . stackTrace ( e ) ; \nLogManager . getLogger ( getClass ( ) ) . error ( stack ) ; \nthrow new FunctionException ( stack ) ; \n} \n} \n} \n"}
{"8978": "public class GetEntriesChecksumFunction { \nHashMap < Serializable , BigInteger > buildCheckSumMap ( Region < Serializable , Object > region ) { \nif ( region . getAttributes ( ) . getDataPolicy ( ) . withPartitioning ( ) ) { \nregion = PartitionRegionHelper . getLocalData ( region ) ; \n} \nSet < Serializable > keySet = region . keySet ( ) ; \nif ( keySet == null ) return null ; \nelse if ( keySet . isEmpty ( ) ) return null ; \nHashMap < Serializable , BigInteger > regionCheckSumMap = new HashMap < Serializable , BigInteger > ( keySet . size ( ) ) ; \nObject object = null ; \nObject tmp = null ; \nfor ( Map . Entry < Serializable , Object > entry : region . entrySet ( ) ) { \nobject = entry . getValue ( ) ; \nif ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) { \ntmp = ( ( PdxInstance ) object ) . getObject ( ) ; \nif ( Serializable . class . isAssignableFrom ( tmp . getClass ( ) ) ) { \nobject = tmp ; \n} \n} \nif ( ! ( PdxInstance . class . isAssignableFrom ( object . getClass ( ) ) ) ) { \nregionCheckSumMap . put ( entry . getKey ( ) , MD . checksum ( object ) ) ; \n} \nelse { \nregionCheckSumMap . put ( entry . getKey ( ) , BigInteger . valueOf ( object . hashCode ( ) ) ) ; \n} \n} \nreturn regionCheckSumMap ; \n} \n} \n"}
{"8984": "public class ShillelaghProcessor { \nprivate void checkForTableId ( TableObject tableObject , Element element ) { \nId idAnnotation = element . getAnnotation ( Id . class ) ; \nif ( idAnnotation != null ) { \nif ( element . asType ( ) . getKind ( ) != TypeKind . LONG ) { \nif ( ! ( \"java.lang.Long\" . equals ( element . asType ( ) . toString ( ) ) ) ) { \nlogger . e ( \"@Id must be on a long\" ) ; \n} \n} \nString columnName = Strings . isBlank ( idAnnotation . name ( ) ) ? element . getSimpleName ( ) . toString ( ) : idAnnotation . name ( ) ; \nfinal TableColumn idColumn = new TableColumn ( columnName , element . getSimpleName ( ) . toString ( ) , element . asType ( ) . toString ( ) , SqliteType . INTEGER ) ; \ntableObject . setIdColumn ( idColumn ) ; \n} \n} \n} \n"}
{"8985": "public class ShillelaghProcessor { \nprivate void checkForFields ( TableObject tableObject , Element columnElement ) { \nColumn columnAnnotation = columnElement . getAnnotation ( Column . class ) ; \nif ( columnAnnotation == null ) return ; \nfinal Element typeElement = typeUtils . asElement ( columnElement . asType ( ) ) ; \nfinal String type = typeElement == null ? columnElement . asType ( ) . toString ( ) : elementUtils . getBinaryName ( ( TypeElement ) typeElement ) . toString ( ) ; \nTableColumn tableColumn = new TableColumn ( columnElement , type , columnAnnotation . name ( ) ) ; \nif ( tableColumn . isBlob ( ) && ! tableColumn . isByteArray ( ) ) { \nString columnType = columnElement . asType ( ) . toString ( ) ; \nlogger . d ( \"Column Element Type: \" + columnType ) ; \nif ( ! checkForSuperType ( columnElement , Serializable . class ) && ! columnType . equals ( \"java.lang.Byte[]\" ) && ! columnType . startsWith ( \"java.util.Map\" ) ) { \nif ( ! columnType . startsWith ( \"java.util.List\" ) ) { \nlogger . e ( String . format ( \"%s in %s is not Serializable and will not be able to be converted to a byte array\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \n} \n} \n} \nelse if ( tableColumn . isOneToMany ( ) ) { \nTypeMirror typeMirror = ( ( DeclaredType ) columnElement . asType ( ) ) . getTypeArguments ( ) . get ( 0 ) ; \nif ( typeUtils . asElement ( typeMirror ) . getAnnotation ( Table . class ) == null ) { \nlogger . e ( \"One to many relationship in class %s where %s is not annotated with @Table\" , tableObject . getTableName ( ) , tableColumn . getColumnName ( ) ) ; \n} \noneToManyCache . put ( typeMirror . toString ( ) , tableObject ) ; \nTypeElement childColumnElement = elementUtils . getTypeElement ( typeMirror . toString ( ) ) ; \ntableColumn . setType ( getClassName ( childColumnElement , getPackageName ( childColumnElement ) ) ) ; \n} \nelse if ( tableColumn . getSqlType ( ) == SqliteType . UNKNOWN ) { \n@ SuppressWarnings ( \"ConstantConditions\" ) Table annotation = typeElement . getAnnotation ( Table . class ) ; \nif ( annotation == null ) { \nlogger . e ( String . format ( \"%s in %s needs to be marked as a blob or should be \" + \"annotated with @Table\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \n} \ntableColumn . setOneToOne ( true ) ; \n} \ntableObject . addColumn ( tableColumn ) ; \n} \n} \n"}
{"9017": "public class Buckets { \npublic void put ( final float r ) { \nif ( r < m_fMin ) return ; \nelse if ( r > m_fMax ) return ; \nfinal int i = ( int ) ( ( r - m_fMin ) / m_fWidth ) ; \n++ m_aCounters [ i ] ; \n} \n} \n"}
{"9024": "public class Matrix { \npublic RowVector getRow ( final int r ) throws MatrixException { \nif ( r < 0 ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nelse if ( r >= m_nRows ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nfinal RowVector rv = new RowVector ( m_nCols ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \n++ c ) { \nrv . m_aValues [ 0 ] [ c ] = m_aValues [ r ] [ c ] ; \n} \nreturn rv ; \n} \n} \n"}
{"9025": "public class Matrix { \npublic ColumnVector getColumn ( final int c ) throws MatrixException { \nif ( c < 0 ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nelse if ( c >= m_nCols ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nfinal ColumnVector cv = new ColumnVector ( m_nRows ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \ncv . m_aValues [ r ] [ 0 ] = m_aValues [ r ] [ c ] ; \n} \nreturn cv ; \n} \n} \n"}
{"9028": "public class Matrix { \npublic Matrix add ( final Matrix m ) throws MatrixException { \nif ( m_nRows != m . m_nRows ) { \nif ( m_nCols != m . m_nCols ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \n} \nfinal float sv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfor ( int c = 0 ; \nc < m_nCols ; \n++ c ) { \nsv [ r ] [ c ] = m_aValues [ r ] [ c ] + m . m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( sv ) ; \n} \n} \n"}
{"9029": "public class Matrix { \npublic Matrix subtract ( final Matrix m ) throws MatrixException { \nif ( m_nRows != m . m_nRows ) { \nif ( m_nCols != m . m_nCols ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \n} \nfinal float dv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfor ( int c = 0 ; \nc < m_nCols ; \n++ c ) { \ndv [ r ] [ c ] = m_aValues [ r ] [ c ] - m . m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( dv ) ; \n} \n} \n"}
{"9058": "public class ImprovedRegulaFalsiRootFinder { \n@ Override protected void computeNextPosition ( ) { \nm_fPrevXFalse = m_fXFalse ; \nm_fPrevFFalse = m_fFalse ; \nm_fXFalse = m_fXPos - m_fPos * ( m_fXNeg - m_fXPos ) / ( m_fNeg - m_fPos ) ; \nm_fFalse = m_aFunction . at ( m_fXFalse ) ; \nm_bDecreasePos = m_bDecreaseNeg = false ; \nif ( Float . isNaN ( m_fPrevFFalse ) ) { \nif ( m_fFalse < 0 ) m_bDecreasePos = true ; \nelse m_bDecreaseNeg = true ; \n} \nelse if ( m_fPrevFFalse * m_fFalse > 0 ) { \nif ( m_fFalse < 0 ) m_bDecreasePos = true ; \nelse m_bDecreaseNeg = true ; \n} \n} \n} \n"}
{"9068": "public class IEEE754 { \npublic static void validateFloatBiasedExponent ( final int biased ) throws IEEE754Exception { \nif ( biased < 0 ) { \nthrow new IEEE754Exception ( \"The biased exponent value should be \" + \"0 through \" + IEEE754Constants . FLOAT_EXPONENT_RESERVED + \".\" ) ; \n} \nelse if ( biased > IEEE754Constants . FLOAT_EXPONENT_RESERVED ) { \nthrow new IEEE754Exception ( \"The biased exponent value should be \" + \"0 through \" + IEEE754Constants . FLOAT_EXPONENT_RESERVED + \".\" ) ; \n} \n} \n} \n"}
{"9069": "public class IEEE754 { \npublic static void validateFloatUnbiasedExponent ( final int unbiased ) throws IEEE754Exception { \nif ( unbiased < - IEEE754Constants . FLOAT_EXPONENT_BIAS + 1 ) { \nthrow new IEEE754Exception ( \"The unbiased exponent value should be \" + - ( IEEE754Constants . FLOAT_EXPONENT_BIAS - 1 ) + \" through \" + IEEE754Constants . FLOAT_EXPONENT_BIAS + \".\" ) ; \n} \nelse if ( unbiased > IEEE754Constants . FLOAT_EXPONENT_BIAS ) { \nthrow new IEEE754Exception ( \"The unbiased exponent value should be \" + - ( IEEE754Constants . FLOAT_EXPONENT_BIAS - 1 ) + \" through \" + IEEE754Constants . FLOAT_EXPONENT_BIAS + \".\" ) ; \n} \n} \n} \n"}
{"9070": "public class IEEE754 { \npublic static void validateDoubleBiasedExponent ( final int biased ) throws IEEE754Exception { \nif ( biased < 0 ) { \nthrow new IEEE754Exception ( \"The biased exponent value should be \" + \"0 through \" + IEEE754Constants . DOUBLE_EXPONENT_RESERVED + \".\" ) ; \n} \nelse if ( biased > IEEE754Constants . DOUBLE_EXPONENT_RESERVED ) { \nthrow new IEEE754Exception ( \"The biased exponent value should be \" + \"0 through \" + IEEE754Constants . DOUBLE_EXPONENT_RESERVED + \".\" ) ; \n} \n} \n} \n"}
{"9071": "public class IEEE754 { \npublic static void validateDoubleUnbiasedExponent ( final int unbiased ) throws IEEE754Exception { \nif ( unbiased < - IEEE754Constants . DOUBLE_EXPONENT_BIAS + 1 ) { \nthrow new IEEE754Exception ( \"The unbiased exponent value should be \" + - ( IEEE754Constants . DOUBLE_EXPONENT_BIAS - 1 ) + \" through \" + IEEE754Constants . DOUBLE_EXPONENT_BIAS + \".\" ) ; \n} \nelse if ( unbiased > IEEE754Constants . DOUBLE_EXPONENT_BIAS ) { \nthrow new IEEE754Exception ( \"The unbiased exponent value should be \" + - ( IEEE754Constants . DOUBLE_EXPONENT_BIAS - 1 ) + \" through \" + IEEE754Constants . DOUBLE_EXPONENT_BIAS + \".\" ) ; \n} \n} \n} \n"}
{"9077": "public class PrimeFactors { \npublic static int [ ] factorsOf ( final int pn ) { \nint n = pn ; \nfinal boolean isPrime [ ] = primeSieve ( n ) ; \nfinal ICommonsList < Integer > v = new CommonsArrayList < > ( ) ; \nfor ( int factor = 2 ; \nn > 1 ; \n++ factor ) { \nif ( isPrime [ factor ] ) { \nif ( n % factor == 0 ) { \nv . add ( Integer . valueOf ( factor ) ) ; \ndo { \nn /= factor ; \n} \nwhile ( n % factor == 0 ) ; \n} \n} \n} \nfinal int factors [ ] = new int [ v . size ( ) ] ; \nfor ( int i = 0 ; \ni < v . size ( ) ; \n++ i ) { \nfactors [ i ] = v . get ( i ) . intValue ( ) ; \n} \nreturn factors ; \n} \n} \n"}
{"9084": "public class CdiFXMLLoaderFactory { \nstatic void initializeFXMLLoader ( final FXMLLoader fxmlLoader , final Class < ? > targetClass , final String location , final String resources , final String charset ) { \ncheckAndSetLocation ( fxmlLoader , targetClass , location ) ; \nif ( charset != null ) { \nif ( ! charset . equals ( CHARSET_UNSPECIFIED ) ) { \nfxmlLoader . setCharset ( Charset . forName ( charset ) ) ; \n} \n} \nif ( resources != null ) { \nif ( ! resources . equals ( RESOURCES_UNSPECIFIED ) ) { \nfxmlLoader . setResources ( ResourceBundle . getBundle ( resources ) ) ; \n} \n} \n} \n} \n"}
{"9093": "public class RSRServiceDiscoveryImpl { \npublic Collection < ServiceInstance < T > > queryForInstances ( String name ) throws Exception { \nList < ServiceInstance < T > > serviceInstances = new ArrayList < ServiceInstance < T > > ( ) ; \nIterator < Service > services = client . getServicesClient ( ) . list ( new MethodOptions ( 100 , null ) ) ; \nwhile ( services . hasNext ( ) ) { \nService service = services . next ( ) ; \nif ( service . getTags ( ) . contains ( typeTag ) ) { \nif ( service . getMetadata ( ) . get ( ServiceTracker . NAME ) . equals ( name ) ) { \nserviceInstances . add ( convert ( service ) ) ; \n} \n} \n} \nreturn serviceInstances ; \n} \n} \n"}
{"9095": "public class ABaseFieldClient { \nprotected String getMetaDataForDecimalAs ( String metaDataPrefixParam , double minParam , double maxParam , double stepFactorParam , String prefixParam ) { \nStringBuffer returnBuffer = new StringBuffer ( ) ; \nif ( metaDataPrefixParam != null ) { \nif ( ! metaDataPrefixParam . isEmpty ( ) ) { \nreturnBuffer . append ( metaDataPrefixParam ) ; \n} \n} \nreturnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . MIN ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; \nreturnBuffer . append ( minParam ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . MAX ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; \nreturnBuffer . append ( maxParam ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . STEP_FACTOR ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; \nreturnBuffer . append ( stepFactorParam ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . UNDERSCORE ) ; \nString prefix = ( prefixParam == null ) ? \"\" : prefixParam ; \nreturnBuffer . append ( FieldMetaData . Decimal . PREFIX ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_OPEN ) ; \nreturnBuffer . append ( prefix ) ; \nreturnBuffer . append ( FieldMetaData . Decimal . SQ_CLOSE ) ; \nreturn returnBuffer . toString ( ) ; \n} \n} \n"}
{"9098": "public class UserClient { \npublic byte [ ] getGravatarForEmail ( String emailAddressParam , int sizeParam ) { \ntry { \nJSONObject gravatarJSONObj = this . getJson ( WS . Path . User . Version1 . getGravatarByEmail ( emailAddressParam , sizeParam ) ) ; \nString base64Text = gravatarJSONObj . optString ( JSON_TAG_DATA , \"\" ) ; \nif ( base64Text == null ) { \nreturn null ; \n} \nelse if ( base64Text . isEmpty ( ) ) { \nreturn null ; \n} \nreturn UtilGlobal . decodeBase64 ( base64Text ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , jsonExcept , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \ncatch ( UnsupportedEncodingException unsEncExcept ) { \nthrow new FluidClientException ( unsEncExcept . getMessage ( ) , unsEncExcept , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \n} \n} \n"}
{"9099": "public class UserClient { \npublic byte [ ] getGravatarForUser ( User userParam , int sizeParam ) { \nif ( userParam == null ) { \nreturn null ; \n} \ntry { \nJSONObject gravatarJSONObj = this . postJson ( userParam , WS . Path . User . Version1 . getGravatarByUser ( sizeParam ) ) ; \nString base64Text = gravatarJSONObj . optString ( JSON_TAG_DATA , \"\" ) ; \nif ( base64Text == null ) { \nreturn null ; \n} \nelse if ( base64Text . isEmpty ( ) ) { \nreturn null ; \n} \nreturn UtilGlobal . decodeBase64 ( base64Text ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , jsonExcept , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9101": "public class Field { \n@ XmlTransient public String getElasticSearchFieldType ( ) { \nType fieldType = this . getTypeAsEnum ( ) ; \nif ( fieldType == null ) { \nreturn null ; \n} \nswitch ( fieldType ) { \ncase ParagraphText : return ElasticSearchType . TEXT ; \ncase Text : String metaData = this . getTypeMetaData ( ) ; \nif ( metaData == null ) { \nreturn ElasticSearchType . TEXT ; \n} \nelse if ( metaData . isEmpty ( ) ) { \nreturn ElasticSearchType . TEXT ; \n} \nif ( LATITUDE_AND_LONGITUDE . equals ( metaData ) ) { \nreturn ElasticSearchType . GEO_POINT ; \n} \nreturn ElasticSearchType . TEXT ; \ncase TrueFalse : return ElasticSearchType . BOOLEAN ; \ncase DateTime : return ElasticSearchType . DATE ; \ncase Decimal : return ElasticSearchType . DOUBLE ; \ncase MultipleChoice : return ElasticSearchType . KEYWORD ; \n} \nreturn null ; \n} \n} \n"}
{"9102": "public class FlowStepClient { \npublic FlowStep createFlowStep ( FlowStep flowStepParam ) { \nif ( flowStepParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStep ( this . putJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepCreate ( ) ) ) ; \n} \n} \n"}
{"9103": "public class FlowStepClient { \npublic FlowStep updateFlowStep ( FlowStep flowStepParam ) { \nif ( flowStepParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepUpdate ( ) ) ) ; \n} \n} \n"}
{"9105": "public class FlowStepClient { \npublic FlowStep getFlowStepByStep ( FlowStep flowStepParam ) { \nif ( this . serviceTicket != null ) { \nif ( flowStepParam != null ) { \nflowStepParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . getByStep ( ) ) ) ; \n} \n} \n"}
{"9106": "public class FlowStepClient { \npublic FlowStepListing getStepsByFlow ( Flow flowParam ) { \nif ( this . serviceTicket != null ) { \nif ( flowParam != null ) { \nflowParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStepListing ( this . postJson ( flowParam , WS . Path . FlowStep . Version1 . getAllStepsByFlow ( ) ) ) ; \n} \n} \n"}
{"9107": "public class FlowStepClient { \npublic FlowStep deleteFlowStep ( FlowStep flowStepParam ) { \nif ( flowStepParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepDelete ( ) ) ) ; \n} \n} \n"}
{"9108": "public class FlowStepClient { \npublic FlowStep forceDeleteFlowStep ( FlowStep flowStepParam ) { \nif ( flowStepParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStep ( this . postJson ( flowStepParam , WS . Path . FlowStep . Version1 . flowStepDelete ( true ) ) ) ; \n} \n} \n"}
{"9109": "public class ABaseESUtil { \nprotected final List < Form > populateTableFields ( boolean addAllTableRecordsForReturnParam , boolean includeFieldDataParam , List < Field > formFieldsParam ) { \nif ( formFieldsParam == null ) { \nreturn null ; \n} \nelse if ( formFieldsParam . isEmpty ( ) ) { \nreturn null ; \n} \nList < Form > allTableRecordsFromAllFields = addAllTableRecordsForReturnParam ? new ArrayList ( ) : null ; \nfor ( Field descendantField : formFieldsParam ) { \nif ( ! ( descendantField . getFieldValue ( ) instanceof TableField ) ) { \ncontinue ; \n} \nTableField tableField = ( TableField ) descendantField . getFieldValue ( ) ; \nList < Form > tableRecordWithIdOnly = tableField . getTableRecords ( ) ; \nif ( tableRecordWithIdOnly == null ) { \ncontinue ; \n} \nelse if ( tableRecordWithIdOnly . isEmpty ( ) ) { \ncontinue ; \n} \nList < Long > formIdsOnly = new ArrayList ( ) ; \nfor ( Form tableRecord : tableRecordWithIdOnly ) { \nformIdsOnly . add ( tableRecord . getId ( ) ) ; \n} \nList < Form > populatedTableRecords = this . getFormsByIds ( Index . TABLE_RECORD , formIdsOnly , includeFieldDataParam , DEFAULT_OFFSET , MAX_NUMBER_OF_TABLE_RECORDS ) ; \nif ( addAllTableRecordsForReturnParam ) { \nif ( populatedTableRecords != null ) { \nallTableRecordsFromAllFields . addAll ( populatedTableRecords ) ; \n} \n} \ntableField . setTableRecords ( populatedTableRecords ) ; \ndescendantField . setFieldValue ( tableField ) ; \n} \nreturn allTableRecordsFromAllFields ; \n} \n} \n"}
{"9111": "public class AGenericListMessageHandler { \n@ Override public void handleMessage ( Object objectToProcess ) { \nif ( objectToProcess instanceof Error ) { \nError fluidError = ( ( Error ) objectToProcess ) ; \nthis . errors . add ( fluidError ) ; \nif ( this . messageReceivedCallback != null ) { \nthis . messageReceivedCallback . errorMessageReceived ( fluidError ) ; \n} \nif ( this . completableFuture != null ) { \nthis . completableFuture . completeExceptionally ( new FluidClientException ( fluidError . getErrorMessage ( ) , fluidError . getErrorCode ( ) ) ) ; \n} \n} \nelse { \nJSONObject jsonObject = ( JSONObject ) objectToProcess ; \nif ( this . compressedResponse ) { \nCompressedResponse compressedResponse = new CompressedResponse ( jsonObject ) ; \nbyte [ ] compressedJsonList = UtilGlobal . decodeBase64 ( compressedResponse . getDataBase64 ( ) ) ; \nbyte [ ] uncompressedJson = null ; \ntry { \nuncompressedJson = this . uncompress ( compressedJsonList ) ; \n} \ncatch ( IOException eParam ) { \nthrow new FluidClientException ( \"I/O issue with uncompress. \" + eParam . getMessage ( ) , eParam , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \njsonObject = new JSONObject ( new String ( uncompressedJson ) ) ; \n} \nT messageForm = this . getNewInstanceBy ( jsonObject ) ; \nthis . returnValue . add ( messageForm ) ; \nif ( this . completableFuture != null ) { \nString echo = messageForm . getEcho ( ) ; \nif ( echo != null ) { \nif ( ! echo . trim ( ) . isEmpty ( ) ) { \nthis . expectedEchoMessagesBeforeComplete . remove ( echo ) ; \n} \n} \nif ( this . expectedEchoMessagesBeforeComplete . isEmpty ( ) ) { \nthis . completableFuture . complete ( this . returnValue ) ; \n} \n} \nif ( this . messageReceivedCallback != null ) { \nthis . messageReceivedCallback . messageReceived ( messageForm ) ; \n} \n} \n} \n} \n"}
{"9115": "public class FormContainerClient { \npublic TableRecord createTableRecord ( TableRecord tableRecordParam ) { \nif ( tableRecordParam != null ) { \nif ( this . serviceTicket != null ) { \ntableRecordParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new TableRecord ( this . putJson ( tableRecordParam , WS . Path . FormContainerTableRecord . Version1 . formContainerTableRecordCreate ( ) ) ) ; \n} \n} \n"}
{"9116": "public class FormContainerClient { \npublic Form deleteFormContainer ( Form formContainerParam ) { \nif ( formContainerParam != null ) { \nif ( this . serviceTicket != null ) { \nformContainerParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Form ( this . postJson ( formContainerParam , WS . Path . FormContainer . Version1 . formContainerDelete ( ) ) ) ; \n} \n} \n"}
{"9117": "public class FormContainerClient { \npublic List < FormFlowHistoricData > getFormFlowHistoricData ( Form formParam ) { \nif ( formParam != null ) { \nif ( this . serviceTicket != null ) { \nformParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FormFlowHistoricDataListing ( this . postJson ( formParam , WS . Path . FlowItemHistory . Version1 . getByFormContainer ( ) ) ) . getListing ( ) ; \n} \n} \n"}
{"9118": "public class FormContainerClient { \npublic List < FormHistoricData > getFormAndFieldHistoricData ( Form formParam , boolean includeCurrentParam ) { \nif ( formParam != null ) { \nif ( this . serviceTicket != null ) { \nformParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FormHistoricDataListing ( this . postJson ( formParam , WS . Path . FormHistory . Version1 . getByFormContainer ( includeCurrentParam ) ) ) . getListing ( ) ; \n} \n} \n"}
{"9119": "public class FormContainerClient { \npublic FormHistoricData getMostRecentFormAndFieldHistoricData ( Form formParam ) { \nif ( formParam != null ) { \nif ( this . serviceTicket != null ) { \nformParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FormHistoricData ( this . postJson ( formParam , WS . Path . FormHistory . Version1 . getByMostRecentByFormContainer ( ) ) ) ; \n} \n} \n"}
{"9122": "public class FormContainerClient { \npublic Form unLockFormContainer ( Form formParam , User userToUnLockAsParam , boolean unlockAsyncParam , boolean removeFromPersonalInventoryParam ) { \nif ( this . serviceTicket != null ) { \nif ( formParam != null ) { \nformParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nLong unLockAsUserId = ( userToUnLockAsParam == null ) ? null : userToUnLockAsParam . getId ( ) ; \ntry { \nreturn new Form ( this . postJson ( formParam , WS . Path . FormContainer . Version1 . unLockFormContainer ( unLockAsUserId , unlockAsyncParam , removeFromPersonalInventoryParam ) ) ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9123": "public class SQLFormUtil { \nprivate Form mapFormContainerTo ( Map < Long , String > definitionAndTitleParam , ResultSet resultSetParam ) throws SQLException { \nLong formId = resultSetParam . getLong ( SQLColumnIndex . _01_FORM_ID ) ; \nString formType = definitionAndTitleParam . get ( resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) ) ; \nString title = resultSetParam . getString ( SQLColumnIndex . _03_TITLE ) ; \nDate created = resultSetParam . getDate ( SQLColumnIndex . _04_CREATED ) ; \nDate lastUpdated = resultSetParam . getDate ( SQLColumnIndex . _05_LAST_UPDATED ) ; \nLong currentUserId = resultSetParam . getLong ( SQLColumnIndex . _06_CURRENT_USER_ID ) ; \nif ( formType == null ) { \nthrow new SQLException ( \"No mapping found for Form Type '\" + resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) + \"'.\" ) ; \n} \nForm toAdd = new Form ( formType ) ; \ntoAdd . setId ( formId ) ; \ntoAdd . setTitle ( title ) ; \nif ( created != null ) { \ntoAdd . setDateCreated ( new Date ( created . getTime ( ) ) ) ; \n} \nif ( lastUpdated != null ) { \ntoAdd . setDateLastUpdated ( new Date ( lastUpdated . getTime ( ) ) ) ; \n} \nif ( currentUserId != null ) { \nif ( currentUserId . longValue ( ) > 0 ) { \nUser currentUser = new User ( ) ; \ncurrentUser . setId ( currentUserId ) ; \ntoAdd . setCurrentUser ( currentUser ) ; \n} \n} \nreturn toAdd ; \n} \n} \n"}
{"9124": "public class Role { \n@ XmlTransient public static List < Role > convertToObjects ( String roleListingParam ) { \nif ( roleListingParam == null ) { \nreturn null ; \n} \nelse if ( roleListingParam . trim ( ) . isEmpty ( ) ) { \nreturn null ; \n} \nString [ ] listOfRoles = roleListingParam . split ( UtilGlobal . REG_EX_COMMA ) ; \nList < Role > returnVal = new ArrayList < > ( ) ; \nfor ( String roleName : listOfRoles ) { \nRole roleToAdd = new Role ( ) ; \nroleToAdd . setName ( roleName . trim ( ) ) ; \nreturnVal . add ( roleToAdd ) ; \n} \nreturn returnVal ; \n} \n} \n"}
{"9125": "public class FormDefinitionClient { \npublic Form createFormDefinition ( Form formDefinitionParam ) { \nif ( formDefinitionParam != null ) { \nif ( this . serviceTicket != null ) { \nformDefinitionParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Form ( this . putJson ( formDefinitionParam , WS . Path . FormDefinition . Version1 . formDefinitionCreate ( ) ) ) ; \n} \n} \n"}
{"9126": "public class FormDefinitionClient { \npublic Form updateFormDefinition ( Form formDefinitionParam ) { \nif ( formDefinitionParam != null ) { \nif ( this . serviceTicket != null ) { \nformDefinitionParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Form ( this . postJson ( formDefinitionParam , WS . Path . FormDefinition . Version1 . formDefinitionUpdate ( ) ) ) ; \n} \n} \n"}
{"9130": "public class FormDefinitionClient { \npublic Form deleteFormDefinition ( Form formDefinitionParam ) { \nif ( formDefinitionParam != null ) { \nif ( this . serviceTicket != null ) { \nformDefinitionParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Form ( this . postJson ( formDefinitionParam , WS . Path . FormDefinition . Version1 . formDefinitionDelete ( ) ) ) ; \n} \n} \n"}
{"9132": "public class CacheUtil { \nprivate MemcachedClient initXMemcachedClient ( ) { \nif ( this . memcachedClient != null ) { \nif ( ! this . memcachedClient . isShutdown ( ) ) { \nreturn this . memcachedClient ; \n} \n} \ntry { \nthis . memcachedClient = new XMemcachedClient ( this . cacheHost , this . cachePort ) ; \nreturn this . memcachedClient ; \n} \ncatch ( IOException e ) { \nthrow new FluidCacheException ( \"Unable to create MemCache client. \" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"9133": "public class CacheUtil { \npublic void shutdown ( ) { \nif ( this . memcachedClient != null ) { \nif ( ! this . memcachedClient . isShutdown ( ) ) { \ntry { \nthis . memcachedClient . shutdown ( ) ; \n} \ncatch ( IOException eParam ) { \nthrow new FluidCacheException ( \"Unable to create shutdown MemCache client. \" + eParam . getMessage ( ) , eParam ) ; \n} \n} \n} \n} \n} \n"}
{"9134": "public class ABaseUtil { \nprotected long toLongSafe ( String toParseParam ) { \nif ( toParseParam == null ) { \nreturn - 1 ; \n} \nelse if ( toParseParam . trim ( ) . isEmpty ( ) ) { \nreturn - 1 ; \n} \ntry { \nreturn Long . parseLong ( toParseParam . trim ( ) ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn - 1 ; \n} \n} \n} \n"}
{"9135": "public class DocumentToPDFConvert { \npublic File convertDocumentToPDF ( File inputDocumentParam ) { \nif ( inputDocumentParam == null ) { \nthrow new UtilException ( \"Input document to convert not provided or does not exist.\" , UtilException . ErrorCode . COMMAND ) ; \n} \nelse if ( ! inputDocumentParam . exists ( ) ) { \nthrow new UtilException ( \"Input document to convert not provided or does not exist.\" , UtilException . ErrorCode . COMMAND ) ; \n} \nif ( ! inputDocumentParam . isFile ( ) ) { \nthrow new UtilException ( \"Input document '' is not a file.\" , UtilException . ErrorCode . COMMAND ) ; \n} \nFile parentFolder = inputDocumentParam . getParentFile ( ) ; \nString inputFilenameWithoutExt = inputDocumentParam . getName ( ) ; \nint indexOfDot = - 1 ; \nif ( ( indexOfDot = inputFilenameWithoutExt . indexOf ( '.' ) ) > - 1 ) { \ninputFilenameWithoutExt = inputFilenameWithoutExt . substring ( 0 , indexOfDot ) ; \n} \nFile generatedPdfFileOut = new File ( parentFolder . getAbsolutePath ( ) . concat ( File . separator ) . concat ( inputFilenameWithoutExt ) . concat ( \".pdf\" ) ) ; \nString completeOutputPath = generatedPdfFileOut . getAbsolutePath ( ) ; \ntry { \nCommandUtil . CommandResult commandResult = this . commandUtil . executeCommand ( CommandUtil . FLUID_CLI , COMMAND_CONVERT_DOC_TO_PDF , \"-i\" , inputDocumentParam . getAbsolutePath ( ) , \"-o\" , completeOutputPath ) ; \nif ( commandResult . getExitCode ( ) != 0 ) { \nthrow new UtilException ( \"Unable to convert '\" + inputDocumentParam . getName ( ) + \"' to PDF. \" + commandResult . toString ( ) , UtilException . ErrorCode . COMMAND ) ; \n} \nFile returnVal = new File ( completeOutputPath ) ; \nif ( ! returnVal . exists ( ) ) { \nthrow new UtilException ( \"Command executed, but no output file. Expected PDF at '\" + completeOutputPath + \"'.\" , UtilException . ErrorCode . GENERAL ) ; \n} \nreturn returnVal ; \n} \ncatch ( IOException eParam ) { \nthrow new UtilException ( \"Problem executing command. \" + eParam . getMessage ( ) , eParam , UtilException . ErrorCode . GENERAL ) ; \n} \n} \n} \n"}
{"9136": "public class SQLUtilWebSocketRESTWrapper { \nprivate List < Field > getFieldValuesForFormFromCache ( Long formIdParam , List < FormFieldListing > listingReturnFieldValsPopulatedParam , Form [ ] formsToFetchForLocalCacheArrParam ) { \nif ( formIdParam == null ) { \nreturn null ; \n} \nelse if ( formIdParam . longValue ( ) < 1 ) { \nreturn null ; \n} \nif ( listingReturnFieldValsPopulatedParam == null ) { \nreturn null ; \n} \nelse if ( listingReturnFieldValsPopulatedParam . isEmpty ( ) ) { \nreturn null ; \n} \nif ( formsToFetchForLocalCacheArrParam == null ) { \nreturn null ; \n} \nelse if ( formsToFetchForLocalCacheArrParam . length == 0 ) { \nreturn null ; \n} \nfor ( Form formIter : formsToFetchForLocalCacheArrParam ) { \nif ( formIdParam . equals ( formIter . getId ( ) ) ) { \nString echoToUse = formIter . getEcho ( ) ; \nfor ( FormFieldListing fieldListing : listingReturnFieldValsPopulatedParam ) { \nif ( echoToUse . equals ( fieldListing . getEcho ( ) ) ) { \nreturn fieldListing . getListing ( ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"9137": "public class FlowStepRuleClient { \npublic FlowStepRule createFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStepRule ( this . putJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleEntryCreate ( ) ) ) ; \n} \n} \n"}
{"9138": "public class FlowStepRuleClient { \npublic FlowStepRule createFlowStepExitRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStepRule ( this . putJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleExitCreate ( ) ) ) ; \n} \n} \n"}
{"9139": "public class FlowStepRuleClient { \npublic FlowStepRule createFlowStepViewRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStepRule ( this . putJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleViewCreate ( ) ) ) ; \n} \n} \n"}
{"9140": "public class FlowStepRuleClient { \npublic FlowStepRule updateFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateEntry ( ) ) ) ; \n} \n} \n"}
{"9141": "public class FlowStepRuleClient { \npublic FlowStepRule updateFlowStepExitRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateExit ( ) ) ) ; \n} \n} \n"}
{"9142": "public class FlowStepRuleClient { \npublic FlowStepRule updateFlowStepViewRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleUpdateView ( ) ) ) ; \n} \n} \n"}
{"9143": "public class FlowStepRuleClient { \npublic FlowStepRule moveFlowStepEntryRuleUp ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryUp ( ) ) ) ; \n} \n} \n"}
{"9144": "public class FlowStepRuleClient { \npublic FlowStepRule moveFlowStepEntryRuleDown ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleMoveEntryDown ( ) ) ) ; \n} \n} \n"}
{"9145": "public class FlowStepRuleClient { \npublic FlowStepRule deleteFlowStepEntryRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStepRule ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteEntry ( ) ) ) ; \n} \n} \n"}
{"9146": "public class FlowStepRuleClient { \npublic FlowStep deleteFlowStepExitRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStep ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteExit ( ) ) ) ; \n} \n} \n"}
{"9147": "public class FlowStepRuleClient { \npublic FlowStep deleteFlowStepViewRule ( FlowStepRule flowStepRuleParam ) { \nif ( flowStepRuleParam != null ) { \nif ( this . serviceTicket != null ) { \nflowStepRuleParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new FlowStep ( this . postJson ( flowStepRuleParam , WS . Path . FlowStepRule . Version1 . flowStepRuleDeleteView ( ) ) ) ; \n} \n} \n"}
{"9152": "public class FormFieldClient { \npublic Field createFieldTextMasked ( Field formFieldParam , String maskValueParam ) { \nif ( formFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nformFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( maskValueParam == null ) { \nmaskValueParam = \"\" ; \n} \nelse if ( maskValueParam . trim ( ) . isEmpty ( ) ) { \nmaskValueParam = \"\" ; \n} \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nformFieldParam . setTypeMetaData ( FieldMetaData . Text . MASKED . concat ( maskValueParam ) ) ; \n} \nreturn new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9153": "public class FormFieldClient { \npublic Field createFieldTextBarcode ( Field formFieldParam , String barcodeTypeParam ) { \nif ( formFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nformFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( barcodeTypeParam == null ) { \nthrow new FluidClientException ( \"Barcode type cannot be empty.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nelse if ( barcodeTypeParam . trim ( ) . isEmpty ( ) ) { \nthrow new FluidClientException ( \"Barcode type cannot be empty.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nformFieldParam . setTypeMetaData ( FieldMetaData . Text . BARCODE . concat ( barcodeTypeParam ) ) ; \n} \nreturn new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9154": "public class FormFieldClient { \npublic Field createFieldDecimalSpinner ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam , String prefixParam ) { \nif ( formFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nformFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SPINNER , minParam , maxParam , stepFactorParam , prefixParam ) ) ; \n} \nreturn new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9155": "public class FormFieldClient { \npublic Field createFieldDecimalSlider ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam ) { \nif ( formFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nformFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SLIDER , minParam , maxParam , stepFactorParam , null ) ) ; \n} \nreturn new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9156": "public class FormFieldClient { \npublic Field createFieldTable ( Field formFieldParam , Form formDefinitionParam , boolean sumDecimalsParam ) { \nif ( formFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nformFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Table ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForTableField ( formDefinitionParam , sumDecimalsParam ) ) ; \n} \nreturn new Field ( this . putJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9157": "public class FormFieldClient { \npublic Field updateFieldTextMasked ( Field formFieldParam , String maskValueParam ) { \nif ( formFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nformFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( maskValueParam == null ) { \nthrow new FluidClientException ( \"Masked value cannot be empty.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nelse if ( maskValueParam . trim ( ) . isEmpty ( ) ) { \nthrow new FluidClientException ( \"Masked value cannot be empty.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nformFieldParam . setTypeMetaData ( FieldMetaData . Text . MASKED . concat ( maskValueParam ) ) ; \n} \nreturn new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9158": "public class FormFieldClient { \npublic Field updateFieldTextBarcode ( Field formFieldParam , String barcodeTypeParam ) { \nif ( formFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nformFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( barcodeTypeParam == null ) { \nthrow new FluidClientException ( \"Barcode type cannot be empty.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nelse if ( barcodeTypeParam . trim ( ) . isEmpty ( ) ) { \nthrow new FluidClientException ( \"Barcode type cannot be empty.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nformFieldParam . setTypeMetaData ( FieldMetaData . Text . BARCODE . concat ( barcodeTypeParam ) ) ; \n} \nreturn new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9159": "public class FormFieldClient { \npublic Field updateFieldDecimalSpinner ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam , String prefixParam ) { \nif ( formFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nformFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SPINNER , minParam , maxParam , stepFactorParam , prefixParam ) ) ; \n} \nreturn new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9160": "public class FormFieldClient { \npublic Field updateFieldDecimalSlider ( Field formFieldParam , double minParam , double maxParam , double stepFactorParam ) { \nif ( formFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nformFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForDecimalAs ( FieldMetaData . Decimal . SLIDER , minParam , maxParam , stepFactorParam , null ) ) ; \n} \nreturn new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9161": "public class FormFieldClient { \npublic Field updateFieldTable ( Field formFieldParam , Form formDefinitionParam , boolean sumDecimalsParam ) { \nif ( formFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nformFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( formFieldParam != null ) { \nformFieldParam . setTypeAsEnum ( Field . Type . Table ) ; \nformFieldParam . setTypeMetaData ( this . getMetaDataForTableField ( formDefinitionParam , sumDecimalsParam ) ) ; \n} \nreturn new Field ( this . postJson ( formFieldParam , WS . Path . FormField . Version1 . formFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9165": "public class FormFieldClient { \npublic Field deleteField ( Field fieldParam ) { \nif ( fieldParam != null ) { \nif ( this . serviceTicket != null ) { \nfieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Field ( this . postJson ( fieldParam , WS . Path . FormField . Version1 . formFieldDelete ( ) ) ) ; \n} \n} \n"}
{"9166": "public class FormFieldClient { \npublic Field forceDeleteField ( Field fieldParam ) { \nif ( fieldParam != null ) { \nif ( this . serviceTicket != null ) { \nfieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Field ( this . postJson ( fieldParam , WS . Path . FormField . Version1 . formFieldDelete ( true ) ) ) ; \n} \n} \n"}
{"9168": "public class UserFieldClient { \npublic Field updateFieldValue ( Field userFieldValueParam ) { \nif ( userFieldValueParam != null ) { \nif ( this . serviceTicket != null ) { \nuserFieldValueParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Field ( this . postJson ( userFieldValueParam , WS . Path . UserField . Version1 . userFieldUpdateValue ( ) ) ) ; \n} \n} \n"}
{"9170": "public class FlowClient { \npublic Flow createFlow ( Flow flowParam ) { \nif ( flowParam != null ) { \nif ( this . serviceTicket != null ) { \nflowParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Flow ( this . putJson ( flowParam , WS . Path . Flow . Version1 . flowCreate ( ) ) ) ; \n} \n} \n"}
{"9171": "public class FlowClient { \npublic Flow updateFlow ( Flow flowParam ) { \nif ( flowParam != null ) { \nif ( this . serviceTicket != null ) { \nflowParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowUpdate ( ) ) ) ; \n} \n} \n"}
{"9174": "public class FlowClient { \npublic Flow deleteFlow ( Flow flowParam ) { \nif ( flowParam != null ) { \nif ( this . serviceTicket != null ) { \nflowParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowDelete ( ) ) ) ; \n} \n} \n"}
{"9175": "public class FlowClient { \npublic Flow forceDeleteFlow ( Flow flowParam ) { \nif ( flowParam != null ) { \nif ( this . serviceTicket != null ) { \nflowParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Flow ( this . postJson ( flowParam , WS . Path . Flow . Version1 . flowDelete ( true ) ) ) ; \n} \n} \n"}
{"9176": "public class GlobalFieldClient { \npublic Field updateFieldValue ( Field globalFieldValueParam ) { \nif ( globalFieldValueParam != null ) { \nif ( this . serviceTicket != null ) { \nglobalFieldValueParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Field ( this . postJson ( globalFieldValueParam , Version1 . globalFieldUpdateValue ( ) ) ) ; \n} \n} \n"}
{"9184": "public class Auth0Client { \npublic AccessToken getAccessToken ( String clientIdParam , String clientSecretParam , String codeParam , String redirectUrlParam ) { \nif ( clientIdParam == null ) { \nthrow new FluidClientException ( \"Client Id must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nelse if ( clientIdParam . trim ( ) . isEmpty ( ) ) { \nthrow new FluidClientException ( \"Client Id must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nif ( clientSecretParam == null ) { \nthrow new FluidClientException ( \"Client Secret must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nelse if ( clientSecretParam . trim ( ) . isEmpty ( ) ) { \nthrow new FluidClientException ( \"Client Secret must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nif ( codeParam == null ) { \nthrow new FluidClientException ( \"Code must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nelse if ( codeParam . trim ( ) . isEmpty ( ) ) { \nthrow new FluidClientException ( \"Code must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nAccessTokenRequest tokenRequest = new AccessTokenRequest ( ) ; \ntokenRequest . setClientId ( clientIdParam ) ; \ntokenRequest . setClientSecret ( clientSecretParam ) ; \ntokenRequest . setGrantType ( AUTHORIZATION_CODE ) ; \ntokenRequest . setCode ( codeParam ) ; \ntokenRequest . setRedirectUri ( redirectUrlParam ) ; \nreturn new AccessToken ( this . postJson ( false , tokenRequest , WS . Path . Auth0 . Version1 . userToken ( ) ) ) ; \n} \n} \n"}
{"9185": "public class Auth0Client { \npublic NormalizedUserProfile getUserProfileInfo ( AccessToken accessTokenParam ) { \nif ( accessTokenParam == null ) { \nthrow new FluidClientException ( \"Code must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nelse if ( accessTokenParam . getAccessToken ( ) == null || accessTokenParam . getAccessToken ( ) . trim ( ) . isEmpty ( ) ) { \nthrow new FluidClientException ( \"Code must be provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \ntry { \nString accessToken = accessTokenParam . getAccessToken ( ) ; \nList < HeaderNameValue > headerListing = new ArrayList < HeaderNameValue > ( ) ; \nheaderListing . add ( new HeaderNameValue ( NormalizedUserProfile . HeaderMapping . AUTHORIZATION , \"Bearer \" + accessToken ) ) ; \nreturn new NormalizedUserProfile ( this . getJson ( true , WS . Path . Auth0 . Version1 . userInfo ( ) , headerListing ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new FluidClientException ( \"Unable to Encode (Not Supported). \" + e . getMessage ( ) , FluidClientException . ErrorCode . ILLEGAL_STATE_ERROR ) ; \n} \n} \n} \n"}
{"9187": "public class ABaseClientWS { \nprotected JSONObject executeForm ( HttpMethod httpMethodParam , List < HeaderNameValue > headerNameValuesParam , boolean checkConnectionValidParam , List < FormNameValue > formNameValuesParam , ContentType contentTypeParam , String postfixUrlParam ) { \nif ( formNameValuesParam == null ) { \nthrow new FluidClientException ( \"No 'Name and Value' body to post.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nelse if ( formNameValuesParam . isEmpty ( ) ) { \nthrow new FluidClientException ( \"No 'Name and Value' body to post.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nStringBuilder strBuilder = new StringBuilder ( ) ; \nfor ( FormNameValue nameValue : formNameValuesParam ) { \nif ( nameValue . getName ( ) == null ) { \ncontinue ; \n} \nelse if ( nameValue . getName ( ) . trim ( ) . isEmpty ( ) ) { \ncontinue ; \n} \nif ( nameValue . getValue ( ) == null ) { \ncontinue ; \n} \nstrBuilder . append ( nameValue . getName ( ) ) ; \nstrBuilder . append ( EQUALS ) ; \nstrBuilder . append ( nameValue . getValue ( ) ) ; \nstrBuilder . append ( AMP ) ; \n} \nString bodyJsonString = strBuilder . toString ( ) ; \nbodyJsonString = bodyJsonString . substring ( 0 , bodyJsonString . length ( ) - 1 ) ; \nreturn this . executeString ( httpMethodParam , headerNameValuesParam , checkConnectionValidParam , bodyJsonString , contentTypeParam , postfixUrlParam ) ; \n} \n} \n"}
{"9191": "public class ABaseClientWS { \nprivate String getPathToFluidSpecificTrustStore ( ) { \nString fluidSystemTrustStore = System . getProperty ( SYSTEM_PROP_FLUID_TRUST_STORE ) ; \nif ( fluidSystemTrustStore == null ) { \nreturn null ; \n} \nelse if ( fluidSystemTrustStore . trim ( ) . isEmpty ( ) ) { \nreturn null ; \n} \nFile certFile = new File ( fluidSystemTrustStore ) ; \nif ( certFile . exists ( ) ) { \nif ( certFile . isFile ( ) ) { \nreturn fluidSystemTrustStore ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9193": "public class FlowItemClient { \npublic FluidItemListing getFluidItemsForView ( JobView jobViewParam , int queryLimitParam , int offsetParam , String sortFieldParam , String sortOrderParam ) { \nif ( this . serviceTicket != null ) { \nif ( jobViewParam != null ) { \njobViewParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \ntry { \nreturn new FluidItemListing ( this . postJson ( jobViewParam , WS . Path . FlowItem . Version1 . getByJobView ( queryLimitParam , offsetParam , sortFieldParam , sortOrderParam ) ) ) ; \n} \ncatch ( JSONException jsonExcept ) { \nthrow new FluidClientException ( jsonExcept . getMessage ( ) , FluidClientException . ErrorCode . JSON_PARSING ) ; \n} \n} \n} \n"}
{"9200": "public class SQLUtilWebSocketExecuteNativeSQLClient { \npublic List < SQLResultSet > executeNativeSQLSynchronized ( NativeSQLQuery nativeSQLQueryParam ) { \nif ( nativeSQLQueryParam == null ) { \nreturn null ; \n} \nif ( nativeSQLQueryParam . getDatasourceName ( ) == null ) { \nthrow new FluidClientException ( \"No data-source name provided. Not allowed.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nelse if ( nativeSQLQueryParam . getDatasourceName ( ) . isEmpty ( ) ) { \nthrow new FluidClientException ( \"No data-source name provided. Not allowed.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nif ( nativeSQLQueryParam . getQuery ( ) == null || nativeSQLQueryParam . getQuery ( ) . isEmpty ( ) ) { \nif ( nativeSQLQueryParam . getStoredProcedure ( ) == null || nativeSQLQueryParam . getStoredProcedure ( ) . isEmpty ( ) ) { \nreturn null ; \n} \n} \nthis . setEchoIfNotSet ( nativeSQLQueryParam ) ; \nString uniqueReqId = this . initNewRequest ( ) ; \nthis . sendMessage ( nativeSQLQueryParam , uniqueReqId ) ; \ntry { \nList < SQLResultSet > returnValue = this . getHandler ( uniqueReqId ) . getCF ( ) . get ( this . getTimeoutInMillis ( ) , TimeUnit . MILLISECONDS ) ; \nif ( this . getHandler ( uniqueReqId ) . isConnectionClosed ( ) ) { \nthrow new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: \" + \"The connection was closed by the server prior to the response received.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \nreturn returnValue ; \n} \ncatch ( InterruptedException exceptParam ) { \nthrow new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: \" + exceptParam . getMessage ( ) , exceptParam , FluidClientException . ErrorCode . STATEMENT_EXECUTION_ERROR ) ; \n} \ncatch ( ExecutionException executeProblem ) { \nThrowable cause = executeProblem . getCause ( ) ; \nif ( cause instanceof FluidClientException ) { \nthrow ( FluidClientException ) cause ; \n} \nelse { \nthrow new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: \" + cause . getMessage ( ) , cause , FluidClientException . ErrorCode . STATEMENT_EXECUTION_ERROR ) ; \n} \n} \ncatch ( TimeoutException eParam ) { \nthrow new FluidClientException ( \"SQLUtil-WebSocket-ExecuteNativeSQL: Timeout while waiting for all return data. There were '\" + this . getHandler ( uniqueReqId ) . getReturnValue ( ) . size ( ) + \"' items after a Timeout of \" + ( TimeUnit . MILLISECONDS . toSeconds ( this . getTimeoutInMillis ( ) ) ) + \" seconds.\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \nfinally { \nthis . removeHandler ( uniqueReqId ) ; \n} \n} \n} \n"}
{"9201": "public class FluidLicenseClient { \npublic String requestLicense ( LicenseRequest licenseRequestParam ) { \nif ( licenseRequestParam != null ) { \nif ( this . serviceTicket != null ) { \nlicenseRequestParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn this . executeTxtReceiveTxt ( HttpMethod . POST , null , false , ( licenseRequestParam == null ) ? null : licenseRequestParam . toJsonObject ( ) . toString ( ) , ContentType . APPLICATION_JSON , Version1 . licenseRequest ( ) ) ; \n} \n} \n"}
{"9203": "public class RouteFieldClient { \npublic Field createFieldTextPlain ( Field routeFieldParam ) { \nif ( routeFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nrouteFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . Text . PLAIN ) ; \n} \nreturn new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9204": "public class RouteFieldClient { \npublic Field createFieldParagraphTextPlain ( Field routeFieldParam ) { \nif ( routeFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nrouteFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . PLAIN ) ; \n} \nreturn new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9205": "public class RouteFieldClient { \npublic Field createFieldParagraphTextHTML ( Field routeFieldParam ) { \nif ( routeFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nrouteFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . HTML ) ; \n} \nreturn new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9206": "public class RouteFieldClient { \npublic Field createFieldMultiChoiceSelectMany ( Field routeFieldParam , List < String > multiChoiceValuesParam ) { \nif ( routeFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nrouteFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( multiChoiceValuesParam == null ) { \nthrow new FluidClientException ( \"No Multi-choice values provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nelse if ( multiChoiceValuesParam . isEmpty ( ) ) { \nthrow new FluidClientException ( \"No Multi-choice values provided.\" , FluidClientException . ErrorCode . FIELD_VALIDATE ) ; \n} \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . MultipleChoice ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . MultiChoice . SELECT_MANY ) ; \nrouteFieldParam . setFieldValue ( new MultiChoice ( multiChoiceValuesParam ) ) ; \n} \nreturn new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9207": "public class RouteFieldClient { \npublic Field createFieldDateTimeDate ( Field routeFieldParam ) { \nif ( routeFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nrouteFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . DateTime ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE ) ; \n} \nreturn new Field ( this . putJson ( routeFieldParam , Version1 . routeFieldCreate ( ) ) ) ; \n} \n} \n"}
{"9208": "public class RouteFieldClient { \npublic Field updateFieldTextPlain ( Field routeFieldParam ) { \nif ( routeFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nrouteFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . Text ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . Text . PLAIN ) ; \n} \nreturn new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9209": "public class RouteFieldClient { \npublic Field updateFieldParagraphTextHTML ( Field routeFieldParam ) { \nif ( routeFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nrouteFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . ParagraphText ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . ParagraphText . HTML ) ; \n} \nreturn new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9210": "public class RouteFieldClient { \npublic Field updateFieldDateTimeDateAndTime ( Field routeFieldParam ) { \nif ( routeFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nrouteFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . DateTime ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . DateTime . DATE_AND_TIME ) ; \n} \nreturn new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9211": "public class RouteFieldClient { \npublic Field updateFieldDecimalPlain ( Field routeFieldParam ) { \nif ( routeFieldParam != null ) { \nif ( this . serviceTicket != null ) { \nrouteFieldParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nif ( routeFieldParam != null ) { \nrouteFieldParam . setTypeAsEnum ( Field . Type . Decimal ) ; \nrouteFieldParam . setTypeMetaData ( FieldMetaData . Decimal . PLAIN ) ; \n} \nreturn new Field ( this . postJson ( routeFieldParam , Version1 . routeFieldUpdate ( ) ) ) ; \n} \n} \n"}
{"9212": "public class RouteFieldClient { \npublic Field updateFieldValue ( Field routeFieldValueParam ) { \nif ( routeFieldValueParam != null ) { \nif ( this . serviceTicket != null ) { \nrouteFieldValueParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Field ( this . postJson ( routeFieldValueParam , Version1 . routeFieldUpdateValue ( ) ) ) ; \n} \n} \n"}
{"9213": "public class RouteFieldClient { \npublic Field createFieldValue ( Field routeFieldValueToCreateParam , FluidItem fluidItemParam ) { \nif ( routeFieldValueToCreateParam != null ) { \nif ( this . serviceTicket != null ) { \nrouteFieldValueToCreateParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nLong fluidItmId = ( fluidItemParam == null ) ? null : fluidItemParam . getId ( ) ; \nreturn new Field ( this . putJson ( routeFieldValueToCreateParam , Version1 . routeFieldCreateValue ( fluidItmId ) ) ) ; \n} \n} \n"}
{"9216": "public class AttachmentClient { \npublic Attachment createAttachment ( Attachment attachmentParam ) { \nif ( attachmentParam != null ) { \nif ( this . serviceTicket != null ) { \nattachmentParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Attachment ( this . putJson ( attachmentParam , WS . Path . Attachment . Version1 . attachmentCreate ( ) ) ) ; \n} \n} \n"}
{"9218": "public class AttachmentClient { \npublic Attachment deleteAttachment ( Attachment attachmentParam ) { \nif ( attachmentParam != null ) { \nif ( this . serviceTicket != null ) { \nattachmentParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Attachment ( this . postJson ( attachmentParam , WS . Path . Attachment . Version1 . attachmentDelete ( ) ) ) ; \n} \n} \n"}
{"9219": "public class AttachmentClient { \npublic Attachment forceDeleteAttachment ( Attachment attachmentParam ) { \nif ( attachmentParam != null ) { \nif ( this . serviceTicket != null ) { \nattachmentParam . setServiceTicket ( this . serviceTicket ) ; \n} \n} \nreturn new Attachment ( this . postJson ( attachmentParam , WS . Path . Attachment . Version1 . attachmentDelete ( true ) ) ) ; \n} \n} \n"}
{"9222": "public class XsdGroup { \nprivate void rule2 ( ) { \nif ( ! ( parent instanceof XsdSchema ) ) { \nif ( name != null ) { \nthrow new ParsingException ( XSD_TAG + \" element: The \" + NAME_TAG + \" should only be used when the parent of the \" + XSD_TAG + \" is the \" + XsdSchema . XSD_TAG + \" element.\" ) ; \n} \n} \n} \n} \n"}
{"9223": "public class XsdGroup { \nprivate void rule3 ( ) { \nif ( parent instanceof XsdSchema ) { \nif ( name == null ) { \nthrow new ParsingException ( XSD_TAG + \" element: The \" + NAME_TAG + \" should is required the parent of the \" + XSD_TAG + \" is the \" + XsdSchema . XSD_TAG + \" element.\" ) ; \n} \n} \n} \n} \n"}
{"9224": "public class XsdAttribute { \nprivate void rule3 ( ) { \nif ( attributesMap . containsKey ( REF_TAG ) ) { \nif ( simpleType != null || form != null || type != null ) { \nthrow new ParsingException ( XSD_TAG + \" element: If \" + REF_TAG + \" attribute is present, simpleType element, form attribute and type attribute cannot be present at the same time.\" ) ; \n} \n} \n} \n} \n"}
{"9226": "public class XsdElement { \nprivate void rule7 ( ) { \nif ( parent instanceof XsdSchema ) { \nif ( attributesMap . containsKey ( FORM_TAG ) ) { \nthrow new ParsingException ( XSD_TAG + \" element: The \" + FORM_TAG + \" attribute can only be present when the parent of the \" + xsdElementIsXsdSchema ) ; \n} \n} \n} \n} \n"}
{"9227": "public class XsdElement { \nprivate void rule3 ( ) { \nif ( parent instanceof XsdSchema ) { \nif ( attributesMap . containsKey ( REF_TAG ) ) { \nthrow new ParsingException ( XSD_TAG + \" element: The \" + REF_TAG + \" attribute cannot be present when the parent of the \" + xsdElementIsXsdSchema ) ; \n} \n} \n} \n} \n"}
{"9234": "public class HeaderGridView { \npublic boolean removeFooterView ( View v ) { \nif ( mFooterViewInfos . size ( ) > 0 ) { \nboolean result = false ; \nif ( mAdapter != null ) { \nif ( ( ( FooterViewGridAdapter ) mAdapter ) . removeFooter ( v ) ) { \nnotifiyChanged ( ) ; \nresult = true ; \n} \n} \nremoveFixedViewInfo ( v , mFooterViewInfos ) ; \nreturn result ; \n} \nreturn false ; \n} \n} \n"}
{"9259": "public class NestedRuntimeException { \npublic void printStackTrace ( final PrintStream stream ) { \nif ( nested == null ) { \nsuper . printStackTrace ( stream ) ; \n} \nelse if ( NestedThrowable . PARENT_TRACE_ENABLED ) { \nsuper . printStackTrace ( stream ) ; \n} \nNestedThrowable . Util . print ( nested , stream ) ; \n} \n} \n"}
{"9260": "public class NestedRuntimeException { \npublic void printStackTrace ( final PrintWriter writer ) { \nif ( nested == null ) { \nsuper . printStackTrace ( writer ) ; \n} \nelse if ( NestedThrowable . PARENT_TRACE_ENABLED ) { \nsuper . printStackTrace ( writer ) ; \n} \nNestedThrowable . Util . print ( nested , writer ) ; \n} \n} \n"}
{"9261": "public class MarshalledValueOutputStream { \nprotected Object replaceObject ( Object obj ) throws IOException { \nif ( obj instanceof Remote ) { \nif ( ! ( obj instanceof RemoteStub ) ) { \nRemote remote = ( Remote ) obj ; \ntry { \nobj = RemoteObject . toStub ( remote ) ; \n} \ncatch ( IOException ignore ) { \n} \n} \n} \nreturn obj ; \n} \n} \n"}
{"9262": "public class BasicTaskWrapper { \npublic void run ( ) { \nthis . runThread = Thread . currentThread ( ) ; \nlong runTime = getElapsedTime ( ) ; \nif ( startTimeout > 0l ) { \nif ( runTime >= startTimeout ) { \ntaskRejected ( new StartTimeoutException ( \"Start Timeout exceeded for task \" + taskString ) ) ; \nreturn ; \n} \n} \nboolean stopped = false ; \nsynchronized ( stateLock ) { \nif ( state == TASK_STOPPED ) { \nstopped = true ; \n} \nelse { \nstate = TASK_STARTED ; \ntaskStarted ( ) ; \nif ( waitType == Task . WAIT_FOR_START ) stateLock . notifyAll ( ) ; \n} \n} \nif ( stopped ) { \ntaskRejected ( new TaskStoppedException ( \"Task stopped for task \" + taskString ) ) ; \nreturn ; \n} \nThrowable throwable = null ; \ntry { \ntask . execute ( ) ; \n} \ncatch ( Throwable t ) { \nthrowable = t ; \n} \ntaskCompleted ( throwable ) ; \nsynchronized ( stateLock ) { \nstate = TASK_COMPLETED ; \nif ( waitType == Task . WAIT_FOR_COMPLETE ) stateLock . notifyAll ( ) ; \n} \n} \n} \n"}
{"9279": "public class Catalog { \nprotected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \nString catfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( catalogFiles . isEmpty ( ) ) { \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \n} \nwhile ( ! catalogFiles . isEmpty ( ) ) { \nString catfile = ( String ) catalogFiles . elementAt ( 0 ) ; \ntry { \ncatalogFiles . remove ( 0 ) ; \n} \ncatch ( ArrayIndexOutOfBoundsException e ) { \n} \nif ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) { \ntry { \nparseCatalogFile ( catfile ) ; \n} \ncatch ( CatalogException ce ) { \nSystem . out . println ( \"FIXME: \" + ce . toString ( ) ) ; \n} \n} \nelse { \ncatalogs . addElement ( catfile ) ; \n} \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \ncatfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \n} \ncatalogFiles . clear ( ) ; \n} \n} \n"}
{"9281": "public class Catalog { \npublic void unknownEntry ( Vector strings ) { \nif ( strings != null ) { \nif ( strings . size ( ) > 0 ) { \nString keyword = ( String ) strings . elementAt ( 0 ) ; \ncatalogManager . debug . message ( 2 , \"Unrecognized token parsing catalog\" , keyword ) ; \n} \n} \n} \n} \n"}
{"9282": "public class Catalog { \npublic void parseAllCatalogs ( ) throws MalformedURLException , IOException { \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \nc . parseCatalog ( catfile ) ; \ncatalogs . setElementAt ( c , catPos ) ; \nc . parseAllCatalogs ( ) ; \n} \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DELEGATE_PUBLIC || e . getEntryType ( ) == DELEGATE_SYSTEM ) { \nCatalog dcat = newCatalog ( ) ; \ndcat . parseCatalog ( e . getEntryArg ( 1 ) ) ; \n} \nelse if ( e . getEntryType ( ) == DELEGATE_URI ) { \nCatalog dcat = newCatalog ( ) ; \ndcat . parseCatalog ( e . getEntryArg ( 1 ) ) ; \n} \n} \n} \n} \n"}
{"9283": "public class Catalog { \npublic String resolveDoctype ( String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nString resolved = null ; \ncatalogManager . debug . message ( 3 , \"resolveDoctype(\" + entityName + \",\" + publicId + \",\" + systemId + \")\" ) ; \nsystemId = normalizeURI ( systemId ) ; \nif ( publicId != null ) { \nif ( publicId . startsWith ( \"urn:publicid:\" ) ) { \npublicId = PublicId . decodeURN ( publicId ) ; \n} \n} \nif ( systemId != null ) { \nif ( systemId . startsWith ( \"urn:publicid:\" ) ) { \nsystemId = PublicId . decodeURN ( systemId ) ; \nif ( publicId != null && ! publicId . equals ( systemId ) ) { \ncatalogManager . debug . message ( 1 , \"urn:publicid: system identifier differs from public identifier; using public identifier\" ) ; \nsystemId = null ; \n} \nelse { \npublicId = systemId ; \nsystemId = null ; \n} \n} \n} \nif ( systemId != null ) { \nresolved = resolveLocalSystem ( systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nif ( publicId != null ) { \nresolved = resolveLocalPublic ( DOCTYPE , entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nboolean over = default_override ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == OVERRIDE ) { \nover = e . getEntryArg ( 0 ) . equalsIgnoreCase ( \"YES\" ) ; \ncontinue ; \n} \nif ( e . getEntryType ( ) == DOCTYPE ) { \nif ( e . getEntryArg ( 0 ) . equals ( entityName ) ) { \nif ( over ) { \nreturn e . getEntryArg ( 1 ) ; \n} \nelse if ( systemId == null ) { \nreturn e . getEntryArg ( 1 ) ; \n} \n} \n} \n} \nreturn resolveSubordinateCatalogs ( DOCTYPE , entityName , publicId , systemId ) ; \n} \n} \n"}
{"9285": "public class Catalog { \npublic String resolveSystem ( String systemId ) throws MalformedURLException , IOException { \ncatalogManager . debug . message ( 3 , \"resolveSystem(\" + systemId + \")\" ) ; \nsystemId = normalizeURI ( systemId ) ; \nif ( systemId != null ) { \nif ( systemId . startsWith ( \"urn:publicid:\" ) ) { \nsystemId = PublicId . decodeURN ( systemId ) ; \nreturn resolvePublic ( systemId , null ) ; \n} \n} \nif ( systemId != null ) { \nString resolved = resolveLocalSystem ( systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nreturn resolveSubordinateCatalogs ( SYSTEM , null , null , systemId ) ; \n} \n} \n"}
{"9286": "public class Catalog { \nprotected String resolveLocalURI ( String uri ) throws MalformedURLException , IOException { \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == URI ) { \nif ( e . getEntryArg ( 0 ) . equals ( uri ) ) { \nreturn e . getEntryArg ( 1 ) ; \n} \n} \n} \nenumt = catalogEntries . elements ( ) ; \nString startString = null ; \nString prefix = null ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == REWRITE_URI ) { \nString p = e . getEntryArg ( 0 ) ; \nif ( p . length ( ) <= uri . length ( ) ) { \nif ( p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) { \nif ( startString == null ) { \nstartString = p ; \nprefix = e . getEntryArg ( 1 ) ; \n} \nelse if ( p . length ( ) > startString . length ( ) ) { \nstartString = p ; \nprefix = e . getEntryArg ( 1 ) ; \n} \n} \n} \n} \nif ( prefix != null ) { \nreturn prefix + uri . substring ( startString . length ( ) ) ; \n} \n} \nenumt = catalogEntries . elements ( ) ; \nVector delCats = new Vector ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DELEGATE_URI ) { \nString p = e . getEntryArg ( 0 ) ; \nif ( p . length ( ) <= uri . length ( ) ) { \nif ( p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) { \ndelCats . addElement ( e . getEntryArg ( 1 ) ) ; \n} \n} \n} \n} \nif ( delCats . size ( ) > 0 ) { \nEnumeration enumCats = delCats . elements ( ) ; \nif ( catalogManager . debug . getDebug ( ) > 1 ) { \ncatalogManager . debug . message ( 2 , \"Switching to delegated catalog(s):\" ) ; \nwhile ( enumCats . hasMoreElements ( ) ) { \nString delegatedCatalog = ( String ) enumCats . nextElement ( ) ; \ncatalogManager . debug . message ( 2 , \"\\t\" + delegatedCatalog ) ; \n} \n} \nCatalog dcat = newCatalog ( ) ; \nenumCats = delCats . elements ( ) ; \nwhile ( enumCats . hasMoreElements ( ) ) { \nString delegatedCatalog = ( String ) enumCats . nextElement ( ) ; \ndcat . parseCatalog ( delegatedCatalog ) ; \n} \nreturn dcat . resolveURI ( uri ) ; \n} \nreturn null ; \n} \n} \n"}
{"9311": "public class URLStreamHandlerFactory { \npublic URLStreamHandler createURLStreamHandler ( final String protocol ) { \nURLStreamHandler handler = ( URLStreamHandler ) handlerMap . get ( protocol ) ; \nif ( handler != null ) return handler ; \nString prevProtocol = ( String ) createURLStreamHandlerProtocol . get ( ) ; \nif ( prevProtocol != null ) { \nif ( prevProtocol . equals ( protocol ) ) return null ; \n} \ncreateURLStreamHandlerProtocol . set ( protocol ) ; \ncheckHandlerPkgs ( ) ; \nClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nfor ( int p = 0 ; \np < handlerPkgs . length ; \np ++ ) { \ntry { \nString classname = handlerPkgs [ p ] + \".\" + protocol + \".Handler\" ; \nClass < ? > type = null ; \ntry { \ntype = ctxLoader . loadClass ( classname ) ; \n} \ncatch ( ClassNotFoundException e ) { \ntype = Class . forName ( classname ) ; \n} \nif ( type != null ) { \nhandler = ( URLStreamHandler ) type . newInstance ( ) ; \nhandlerMap . put ( protocol , handler ) ; \nlog . trace ( \"Found protocol:\" + protocol + \" handler:\" + handler ) ; \n} \n} \ncatch ( Throwable ignore ) { \n} \n} \ncreateURLStreamHandlerProtocol . set ( null ) ; \nreturn handler ; \n} \n} \n"}
{"9312": "public class URLStreamHandlerFactory { \nprivate synchronized void checkHandlerPkgs ( ) { \nString handlerPkgsProp = System . getProperty ( \"java.protocol.handler.pkgs\" ) ; \nif ( handlerPkgsProp != null ) { \nif ( handlerPkgsProp . equals ( lastHandlerPkgs ) == false ) { \nStringTokenizer tokeninzer = new StringTokenizer ( handlerPkgsProp , \"|\" ) ; \nArrayList < String > tmp = new ArrayList < String > ( ) ; \nwhile ( tokeninzer . hasMoreTokens ( ) ) { \nString pkg = tokeninzer . nextToken ( ) . intern ( ) ; \nif ( tmp . contains ( pkg ) == false ) tmp . add ( pkg ) ; \n} \nif ( tmp . contains ( PACKAGE_PREFIX ) == false ) tmp . add ( PACKAGE_PREFIX ) ; \nhandlerPkgs = new String [ tmp . size ( ) ] ; \ntmp . toArray ( handlerPkgs ) ; \nlastHandlerPkgs = handlerPkgsProp ; \n} \n} \n} \n} \n"}
{"9319": "public class NonSerializableFactory { \npublic static synchronized void rebind ( Name name , Object target , boolean createSubcontexts ) throws NamingException { \nString key = name . toString ( ) ; \nInitialContext ctx = new InitialContext ( ) ; \nif ( createSubcontexts == true ) { \nif ( name . size ( ) > 1 ) { \nint size = name . size ( ) - 1 ; \nUtil . createSubcontext ( ctx , name . getPrefix ( size ) ) ; \n} \n} \nrebind ( ctx , key , target ) ; \n} \n} \n"}
{"9322": "public class Strings { \npublic static String [ ] split ( final String string , final String delim , final int limit ) { \nint count = count ( string , delim ) + 1 ; \nif ( limit > 0 ) { \nif ( count > limit ) { \ncount = limit ; \n} \n} \nString strings [ ] = new String [ count ] ; \nint begin = 0 ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nint end = string . indexOf ( delim , begin ) ; \nif ( end == - 1 ) end = string . length ( ) ; \nelse if ( i + 1 == count ) end = string . length ( ) ; \nif ( end == 0 ) strings [ i ] = EMPTY ; \nelse strings [ i ] = string . substring ( begin , end ) ; \nbegin = end + 1 ; \n} \nreturn strings ; \n} \n} \n"}
{"9334": "public class XmlHelper { \npublic static Iterator getChildrenByTagName ( Element element , String tagName ) { \nif ( element == null ) return null ; \nNodeList children = element . getChildNodes ( ) ; \nArrayList goodChildren = new ArrayList ( ) ; \nfor ( int i = 0 ; \ni < children . getLength ( ) ; \ni ++ ) { \nNode currentChild = children . item ( i ) ; \nif ( currentChild . getNodeType ( ) == Node . ELEMENT_NODE ) { \nif ( ( ( Element ) currentChild ) . getTagName ( ) . equals ( tagName ) ) { \ngoodChildren . add ( currentChild ) ; \n} \n} \n} \nreturn goodChildren . iterator ( ) ; \n} \n} \n"}
{"9344": "public class Resolver { \npublic String resolveSystem ( String systemId ) throws MalformedURLException , IOException { \nString resolved = super . resolveSystem ( systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == RESOLVER ) { \nresolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nelse if ( e . getEntryType ( ) == SYSTEMSUFFIX ) { \nString suffix = e . getEntryArg ( 0 ) ; \nString result = e . getEntryArg ( 1 ) ; \nif ( suffix . length ( ) <= systemId . length ( ) ) { \nif ( systemId . substring ( systemId . length ( ) - suffix . length ( ) ) . equals ( suffix ) ) { \nreturn result ; \n} \n} \n} \n} \nreturn resolveSubordinateCatalogs ( Catalog . SYSTEM , null , null , systemId ) ; \n} \n} \n"}
{"9353": "public class Resolver { \nprivate Vector resolveAllLocalSystem ( String systemId ) { \nVector map = new Vector ( ) ; \nString osname = System . getProperty ( \"os.name\" ) ; \nboolean windows = ( osname . indexOf ( \"Windows\" ) >= 0 ) ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == SYSTEM ) { \nif ( e . getEntryArg ( 0 ) . equals ( systemId ) || ( windows && e . getEntryArg ( 0 ) . equalsIgnoreCase ( systemId ) ) ) { \nmap . addElement ( e . getEntryArg ( 1 ) ) ; \n} \n} \n} \nif ( map . size ( ) == 0 ) { \nreturn null ; \n} \nelse { \nreturn map ; \n} \n} \n} \n"}
{"9356": "public class SAXCatalogReader { \npublic void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { \nif ( parserFactory == null ) { \nif ( parserClass == null ) { \ndebug . message ( 1 , \"Cannot read SAX catalog without a parser\" ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \n} \ndebug = catalog . getCatalogManager ( ) . debug ; \nEntityResolver bResolver = catalog . getCatalogManager ( ) . getBootstrapResolver ( ) ; \nthis . catalog = catalog ; \ntry { \nif ( parserFactory != null ) { \nSAXParser parser = parserFactory . newSAXParser ( ) ; \nSAXParserHandler spHandler = new SAXParserHandler ( ) ; \nspHandler . setContentHandler ( this ) ; \nif ( bResolver != null ) { \nspHandler . setEntityResolver ( bResolver ) ; \n} \nparser . parse ( new InputSource ( is ) , spHandler ) ; \n} \nelse { \nParser parser = ( Parser ) Class . forName ( parserClass ) . newInstance ( ) ; \nparser . setDocumentHandler ( this ) ; \nif ( bResolver != null ) { \nparser . setEntityResolver ( bResolver ) ; \n} \nparser . parse ( new InputSource ( is ) ) ; \n} \n} \ncatch ( ClassNotFoundException cnfe ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( IllegalAccessException iae ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( InstantiationException ie ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( ParserConfigurationException pce ) { \nthrow new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; \n} \ncatch ( SAXException se ) { \nException e = se . getException ( ) ; \nUnknownHostException uhe = new UnknownHostException ( ) ; \nFileNotFoundException fnfe = new FileNotFoundException ( ) ; \nif ( e != null ) { \nif ( e . getClass ( ) == uhe . getClass ( ) ) { \nthrow new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; \n} \nelse if ( e . getClass ( ) == fnfe . getClass ( ) ) { \nthrow new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; \n} \n} \nthrow new CatalogException ( se ) ; \n} \n} \n} \n"}
{"9360": "public class Node { \nvoid helpDelete ( Node < K , V > b , Node < K , V > f ) { \nif ( f == next ) { \nif ( this == b . next ) { \nif ( f == null || f . value != f ) appendMarker ( f ) ; \nelse b . casNext ( this , f . next ) ; \n} \n} \n} \n} \n"}
{"9361": "public class Node { \nV getValidValue ( ) { \nObject v = value ; \nif ( v == this ) return null ; \nelse if ( v == BASE_HEADER ) return null ; \nreturn ( V ) v ; \n} \n} \n"}
{"9388": "public class JBossEntityResolver { \nprotected InputSource resolveSystemIDasURL ( String systemId , boolean trace ) { \nif ( systemId == null ) return null ; \nif ( trace ) log . trace ( \"resolveSystemIDasURL, systemId=\" + systemId ) ; \nInputSource inputSource = null ; \ntry { \nif ( trace ) log . trace ( \"Trying to resolve systemId as a URL\" ) ; \nif ( isReplaceSystemProperties ( ) ) systemId = StringPropertyReplacer . replaceProperties ( systemId ) ; \nURL url = new URL ( systemId ) ; \nif ( warnOnNonFileURLs && url . getProtocol ( ) . equalsIgnoreCase ( \"file\" ) == false ) { \nif ( url . getProtocol ( ) . equalsIgnoreCase ( \"vfszip\" ) == false ) { \nlog . warn ( \"Trying to resolve systemId as a non-file URL: \" + systemId ) ; \n} \n} \nInputStream ins = url . openStream ( ) ; \nif ( ins != null ) { \ninputSource = new InputSource ( ins ) ; \ninputSource . setSystemId ( systemId ) ; \n} \nelse { \nlog . warn ( \"Cannot load systemId as URL: \" + systemId ) ; \n} \nif ( trace ) log . trace ( \"Resolved systemId as a URL\" ) ; \n} \ncatch ( MalformedURLException ignored ) { \nif ( trace ) log . trace ( \"SystemId is not a url: \" + systemId , ignored ) ; \n} \ncatch ( IOException e ) { \nif ( trace ) log . trace ( \"Failed to obtain URL.InputStream from systemId: \" + systemId , e ) ; \n} \nreturn inputSource ; \n} \n} \n"}
{"9421": "public class DOMUtils { \npublic static String getTextContent ( Node node , boolean replaceProps ) { \nboolean hasTextContent = false ; \nStringBuffer buffer = new StringBuffer ( ) ; \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nlist . getLength ( ) ; \ni ++ ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . TEXT_NODE ) { \nbuffer . append ( child . getNodeValue ( ) ) ; \nhasTextContent = true ; \n} \n} \nString text = ( hasTextContent ? buffer . toString ( ) : null ) ; \nif ( text != null ) { \nif ( replaceProps ) text = StringPropertyReplacer . replaceProperties ( text ) ; \n} \nreturn text ; \n} \n} \n"}
{"9429": "public class SystemPropertyClassValue { \npublic static Throwable setSystemPropertyClassValue ( String property , String className ) { \nif ( property == null ) throw new IllegalArgumentException ( \"Null or empty property\" ) ; \nelse if ( property . trim ( ) . length ( ) == 0 ) throw new IllegalArgumentException ( \"Null or empty property\" ) ; \nif ( className == null ) throw new IllegalArgumentException ( \"Null or empty class name\" ) ; \nelse if ( className . trim ( ) . length ( ) == 0 ) throw new IllegalArgumentException ( \"Null or empty class name\" ) ; \ntry { \nThread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; \n} \ncatch ( Throwable problem ) { \nreturn problem ; \n} \nSystem . setProperty ( property , className ) ; \nreturn null ; \n} \n} \n"}
{"9434": "public class Classes { \npublic static void forceLoad ( final Class type ) { \nif ( type == null ) throw new NullArgumentException ( \"type\" ) ; \nif ( type . isPrimitive ( ) ) return ; \nString packageName = Classes . getPackageName ( type ) ; \nif ( packageName . startsWith ( \"java.\" ) ) { \nreturn ; \n} \nelse if ( packageName . startsWith ( \"javax.\" ) ) { \nreturn ; \n} \ntry { \nMethod methods [ ] = type . getDeclaredMethods ( ) ; \nMethod method = null ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nint modifiers = methods [ i ] . getModifiers ( ) ; \nif ( Modifier . isStatic ( modifiers ) ) { \nmethod = methods [ i ] ; \nbreak ; \n} \n} \nif ( method != null ) { \nmethod . invoke ( null , ( Object [ ] ) null ) ; \n} \nelse { \ntype . newInstance ( ) ; \n} \n} \ncatch ( Exception ignore ) { \nThrowableHandler . add ( ignore ) ; \n} \n} \n} \n"}
{"9446": "public class WeakSet { \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nIterator iter = set . iterator ( ) ; \nObject UNKNOWN = new Object ( ) ; \nObject next = UNKNOWN ; \npublic boolean hasNext ( ) { \nif ( next != UNKNOWN ) { \nreturn true ; \n} \nwhile ( iter . hasNext ( ) ) { \nWeakObject weak = ( WeakObject ) iter . next ( ) ; \nObject obj = null ; \nif ( weak != null ) { \nif ( ( obj = weak . get ( ) ) == null ) { \ncontinue ; \n} \n} \nnext = obj ; \nreturn true ; \n} \nreturn false ; \n} \npublic Object next ( ) { \nif ( next == UNKNOWN ) { \nif ( ! hasNext ( ) ) { \nthrow new NoSuchElementException ( ) ; \n} \n} \nObject obj = next ; \nnext = UNKNOWN ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \n} \n} \n; \n} \n} \n"}
{"9451": "public class PropertyEditors { \npublic static final boolean isNull ( final String value , final boolean trim , final boolean empty ) { \nif ( disableIsNull ) return false ; \nif ( value == null ) return true ; \nString trimmed = trim ? value . trim ( ) : value ; \nif ( empty ) { \nif ( trimmed . length ( ) == 0 ) return true ; \n} \nreturn NULL . equalsIgnoreCase ( trimmed ) ; \n} \n} \n"}
{"9468": "public class CatalogManager { \npublic Vector getCatalogFiles ( ) { \nif ( catalogFiles == null ) { \ncatalogFiles = queryCatalogFiles ( ) ; \n} \nStringTokenizer files = new StringTokenizer ( catalogFiles , \";\" ) ; \nVector catalogs = new Vector ( ) ; \nwhile ( files . hasMoreTokens ( ) ) { \nString catalogFile = files . nextToken ( ) ; \nURL absURI = null ; \nif ( fromPropertiesFile ) { \nif ( ! relativeCatalogs ( ) ) { \ntry { \nabsURI = new URL ( propertyFileURI , catalogFile ) ; \ncatalogFile = absURI . toString ( ) ; \n} \ncatch ( MalformedURLException mue ) { \nabsURI = null ; \n} \n} \n} \ncatalogs . add ( catalogFile ) ; \n} \nreturn catalogs ; \n} \n} \n"}
{"9471": "public class BootstrapResolver { \npublic InputSource resolveEntity ( String publicId , String systemId ) { \nString resolved = null ; \nif ( systemId != null && systemMap . containsKey ( systemId ) ) { \nresolved = ( String ) systemMap . get ( systemId ) ; \n} \nelse if ( publicId != null ) { \nif ( publicMap . containsKey ( publicId ) ) { \nresolved = ( String ) publicMap . get ( publicId ) ; \n} \n} \nif ( resolved != null ) { \ntry { \nInputSource iSource = new InputSource ( resolved ) ; \niSource . setPublicId ( publicId ) ; \nURL url = new URL ( resolved ) ; \nInputStream iStream = url . openStream ( ) ; \niSource . setByteStream ( iStream ) ; \nreturn iSource ; \n} \ncatch ( Exception e ) { \nreturn null ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9472": "public class BootstrapResolver { \npublic Source resolve ( String href , String base ) throws TransformerException { \nString uri = href ; \nint hashPos = href . indexOf ( \"#\" ) ; \nif ( hashPos >= 0 ) { \nuri = href . substring ( 0 , hashPos ) ; \n} \nString result = null ; \nif ( href != null ) { \nif ( uriMap . containsKey ( href ) ) { \nresult = ( String ) uriMap . get ( href ) ; \n} \n} \nif ( result == null ) { \ntry { \nURL url = null ; \nif ( base == null ) { \nurl = new URL ( uri ) ; \nresult = url . toString ( ) ; \n} \nelse { \nURL baseURL = new URL ( base ) ; \nurl = ( href . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; \nresult = url . toString ( ) ; \n} \n} \ncatch ( java . net . MalformedURLException mue ) { \nString absBase = makeAbsolute ( base ) ; \nif ( ! absBase . equals ( base ) ) { \nreturn resolve ( href , absBase ) ; \n} \nelse { \nthrow new TransformerException ( \"Malformed URL \" + href + \"(base \" + base + \")\" , mue ) ; \n} \n} \n} \nSAXSource source = new SAXSource ( ) ; \nsource . setInputSource ( new InputSource ( result ) ) ; \nreturn source ; \n} \n} \n"}
{"9477": "public class Namespaces { \npublic static String getNamespaceURI ( Node node , String prefix ) { \nif ( node == null ) { \nreturn null ; \n} \nelse if ( node . getNodeType ( ) != Node . ELEMENT_NODE ) { \nreturn null ; \n} \nif ( prefix . equals ( \"\" ) ) { \nif ( ( ( Element ) node ) . hasAttribute ( \"xmlns\" ) ) { \nreturn ( ( Element ) node ) . getAttribute ( \"xmlns\" ) ; \n} \n} \nelse { \nString nsattr = \"xmlns:\" + prefix ; \nif ( ( ( Element ) node ) . hasAttribute ( nsattr ) ) { \nreturn ( ( Element ) node ) . getAttribute ( nsattr ) ; \n} \n} \nreturn getNamespaceURI ( node . getParentNode ( ) , prefix ) ; \n} \n} \n"}
{"9492": "public class CompoundIterator { \npublic boolean hasNext ( ) { \nfor ( ; \nindex < iters . length ; \nindex ++ ) { \nif ( iters [ index ] != null ) { \nif ( iters [ index ] . hasNext ( ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"9495": "public class StructsBatchCompiler { \nprotected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { \nif ( ! parentFolder . exists ( ) ) { \nreturn true ; \n} \nif ( filter == null ) filter = ACCEPT_ALL_FILTER ; \nlog . debug ( \"Cleaning folder \" + parentFolder . toString ( ) ) ; \nfinal File [ ] contents = parentFolder . listFiles ( filter ) ; \nfor ( int j = 0 ; \nj < contents . length ; \nj ++ ) { \nfinal File file = contents [ j ] ; \nif ( file . isDirectory ( ) ) { \nif ( ! cleanFolder ( file , filter , continueOnError , true ) ) { \nif ( ! continueOnError ) return false ; \n} \n} \nelse { \nif ( ! file . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + file . getAbsolutePath ( ) ) ; \nif ( ! continueOnError ) return false ; \n} \n} \n} \nif ( deleteParentFolder ) { \nif ( parentFolder . list ( ) . length == 0 ) { \nif ( ! parentFolder . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + parentFolder . getAbsolutePath ( ) ) ; \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"9507": "public class Chunk { \npublic int getSumDegree ( ) { \nif ( sumDegree < 0 ) { \nint sum = 0 ; \nfor ( Word word : words ) { \nif ( word != null ) { \nif ( word . getDegree ( ) > - 1 ) { \nsum += word . getDegree ( ) ; \n} \n} \n} \nsumDegree = sum ; \n} \nreturn sumDegree ; \n} \n} \n"}
{"9523": "public class JdbcFixture { \npublic String queryInWithSql ( String database , String sql ) { \nJdbcTemplate template = getDatabaseJdbcTemplate ( database ) ; \nif ( sql != null ) { \nif ( ! sql . trim ( ) . toUpperCase ( ) . startsWith ( JdbcFixture . SELECT_COMMAND_PREFIX ) ) { \nreturn Objects . toString ( template . update ( sql ) ) ; \n} \n} \nList < String > results = template . queryForList ( sql , String . class ) ; \nif ( results == null ) { \nreturn null ; \n} \nelse if ( results . isEmpty ( ) ) { \nreturn null ; \n} \nreturn results . get ( 0 ) ; \n} \n} \n"}
{"9555": "public class IntentionStacks { \nStack255 getEmptyIntentionStack ( ) { \nif ( ! stacks . isEmpty ( ) ) { \nif ( getActiveStack ( ) . isEmpty ( ) ) { \nreturn getActiveStack ( ) ; \n} \n} \nStack255 stack = new Stack255 ( ( byte ) 8 , ( byte ) 2 ) ; \nstacks . push ( stack ) ; \nreturn stack ; \n} \n} \n"}
{"9559": "public class PlanBindings { \nprivate final void setPlanVariables ( Agent agent , Plan planInstance , Set < Belief > results , int choice ) { \nif ( agent == null ) { \nreturn ; \n} \nelse if ( planInstance == null ) { \nreturn ; \n} \nBelief belief = getResultAtIndex ( results , choice ) ; \nif ( belief == null ) { \nreturn ; \n} \nObject [ ] tuple = belief . getTuple ( ) ; \nif ( tuple == null ) { \nreturn ; \n} \nint index = 0 ; \nHashMap < String , Object > vars = new HashMap < String , Object > ( ) ; \nfor ( Object o : belief . getTuple ( ) ) { \ntry { \nString fieldname = ABeliefStore . getFieldName ( agent . getId ( ) , belief . getBeliefset ( ) , index ) ; \nvars . put ( fieldname , o ) ; \n} \ncatch ( BeliefBaseException e ) { \nLog . error ( \"Agent \" + agent . getId ( ) + \" could not retrive belief set field: \" + e . getMessage ( ) ) ; \n} \nindex ++ ; \n} \nplanInstance . setPlanVariables ( vars ) ; \n} \n} \n"}
{"9565": "public class Plan { \npublic void step ( ) { \nif ( body == null || body . length == 0 || index < 0 ) { \nreturn ; \n} \nelse if ( index >= body . length ) { \nreturn ; \n} \nbody [ index ++ ] . step ( ) ; \n} \n} \n"}
{"9579": "public class AObject { \npublic static boolean isNameEqual ( AObject obj1 , AObject obj2 ) { \nif ( obj1 . name == null || obj2 . name == null || obj1 . name . length != obj2 . name . length ) { \nreturn false ; \n} \nelse if ( obj1 . name . length == 0 ) { \nreturn false ; \n} \nfor ( int i = 0 ; \ni < obj1 . name . length ; \ni ++ ) { \nif ( obj1 . name [ i ] != obj2 . name [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9581": "public class ArgumentsLoader { \npublic static void parse ( String [ ] args ) { \nfor ( int i = 0 ; \nargs != null && i < args . length ; \ni ++ ) { \nif ( \"--help\" . equals ( args [ i ] ) ) { \nabort ( null ) ; \n} \nif ( i + 1 < args . length ) { \nparseArgumentWithOption ( args [ i ] , args [ ++ i ] ) ; \n} \n} \nif ( config == null ) { \nabort ( \"Configuration file or string was not given\" ) ; \n} \nelse if ( config . getAgents ( ) == null ) { \nabort ( \"Configuration is missing agents specification\" ) ; \n} \nelse if ( config . getAgents ( ) . isEmpty ( ) ) { \nabort ( \"Configuration is missing agents specification\" ) ; \n} \n} \n} \n"}
{"9584": "public class AObjectCatalog { \npublic AObject get ( int index ) { \nif ( index >= 0 ) { \nif ( index < objects . length ) { \nreturn objects [ index ] ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9586": "public class AObjectCatalog { \npublic void push ( AObject obj ) { \nif ( obj == null ) { \nreturn ; \n} \nelse if ( obj . getId ( ) != GlobalConstant . NULLID ) { \nreturn ; \n} \nif ( nextid == objects . length ) { \ngrow ( ) ; \n} \nobj . setId ( nextid ) ; \nobjects [ nextid ++ ] = obj ; \n} \n} \n"}
{"9587": "public class Stack255 { \npublic Object get ( int idx ) { \nint index = idx & 0xff ; \nif ( isEmpty ( ) ) { \nreturn null ; \n} \nelse if ( index < 0 ) { \nreturn null ; \n} \nelse if ( index >= size ) { \nreturn null ; \n} \nreturn objects [ index ] ; \n} \n} \n"}
{"9590": "public class ABeliefStore { \npublic static String getType ( Object obj ) { \nif ( obj == null ) { \nreturn null ; \n} \nString type = null ; \nif ( obj instanceof String || obj instanceof Integer || obj instanceof Double ) { \ntype = obj . getClass ( ) . getName ( ) ; \n} \nelse if ( obj instanceof Boolean ) { \ntype = obj . getClass ( ) . getName ( ) ; \n} \nreturn type ; \n} \n} \n"}
{"9622": "public class PartialResponse { \npublic boolean isEndReached ( ) { \nif ( to == null ) { \nreturn true ; \n} \nelse if ( from == null ) { \nreturn true ; \n} \nif ( length == null ) { \nreturn false ; \n} \nreturn to == length - 1 ; \n} \n} \n"}
{"9629": "public class AbstractGenerator { \nprotected final GeneratedFile getTargetFile ( final String artifactName , final String filename , final String logInfo ) { \nfinal Folder folder = getGeneratorConfig ( ) . findTargetFolder ( artifactName ) ; \nfinal File dir = folder . getCanonicalDir ( ) ; \nfinal File file = new File ( dir , filename ) ; \nif ( ! dir . exists ( ) ) { \nif ( folder . isCreate ( ) ) { \ndir . mkdirs ( ) ; \n} \nelse { \nthrow new IllegalStateException ( \"Directory '\" + dir + \"' does not exist, but configuration does not allow creation: \" + \"<folder name=\\\"\" + folder . getName ( ) + \"\\\" create=\\\"false\\\" ... />\" ) ; \n} \n} \nif ( ! file . getParentFile ( ) . exists ( ) ) { \nfile . getParentFile ( ) . mkdirs ( ) ; \n} \nif ( file . exists ( ) ) { \nif ( ! folder . overrideAllowed ( file ) ) { \nreturn new GeneratedFile ( file , logInfo , true ) ; \n} \n} \nreturn new GeneratedFile ( file , logInfo ) ; \n} \n} \n"}
{"9631": "public class InstanceFieldsInitializationProcessor { \n@ Override public void postProcessInstance ( ManagedClassSPI managedClass , Object instance ) { \nConfig config = managedClass . getConfig ( ) ; \nif ( config == null ) { \nreturn ; \n} \nList < Config > fields = config . findChildren ( \"instance-field\" ) ; \nif ( ! fields . isEmpty ( ) ) { \nif ( ! InstanceType . POJO . equals ( managedClass . getInstanceType ( ) ) ) { \nthrow new BugError ( \"Cannot assign instance field on non %s type.\" , InstanceType . POJO ) ; \n} \n} \nfor ( Config field : fields ) { \nClasses . setFieldValue ( instance , field . getAttribute ( \"name\" ) , field . getAttribute ( \"value\" ) ) ; \n} \n} \n} \n"}
{"9637": "public class GeneratedFile { \npublic final void persist ( ) { \nif ( persisted ) { \nreturn ; \n} \ntry { \nif ( FileUtils . contentEquals ( tmpFile , file ) ) { \nLOG . debug ( \"Omitted: {} {}\" , getPath ( ) , logInfo ) ; \nif ( ! tmpFile . delete ( ) ) { \ntmpFile . deleteOnExit ( ) ; \n} \n} \nelse { \nif ( file . exists ( ) ) { \nif ( ! file . delete ( ) ) { \nthrow new IOException ( \"Wasn't able to delete file \" + file ) ; \n} \n} \nif ( ! tmpFile . renameTo ( file ) ) { \nthrow new IOException ( \"Wasn't able to rename temporary file \" + tmpFile + \" to \" + file ) ; \n} \nLOG . info ( \"Generated: {} {}\" , getPath ( ) , logInfo ) ; \n} \npersisted = true ; \n} \ncatch ( final IOException ex ) { \nthrow new RuntimeException ( \"Error comparing content: tmp=\" + tmpFile + \", target=\" + file + logInfo , ex ) ; \n} \n} \n} \n"}
{"9640": "public class AbstractEndpoint { \n@ SuppressWarnings ( \"LocalVariableHidesMemberVariable\" ) private void handleLinks ( HttpResponse response ) { \nMap < String , Map < URI , String > > links = new HashMap < > ( ) ; \nMap < String , String > linkTemplates = new HashMap < > ( ) ; \nhandleHeaderLinks ( response , links , linkTemplates ) ; \nHttpEntity entity = response . getEntity ( ) ; \nif ( entity != null ) { \nHeader contentType = entity . getContentType ( ) ; \nif ( contentType != null ) { \nif ( contentType . getValue ( ) . startsWith ( \"application/json\" ) ) { \ntry { \nhandleBodyLinks ( serializer . readTree ( entity . getContent ( ) ) , links , linkTemplates ) ; \n} \ncatch ( IOException ex ) { \nthrow new RuntimeException ( ) ; \n} \n} \n} \n} \nthis . links = unmodifiableMap ( links ) ; \nthis . linkTemplates = unmodifiableMap ( linkTemplates ) ; \n} \n} \n"}
{"9667": "public class AbstractEMFParser { \nprotected final void parseModel ( ) { \nif ( fileExtensions == null ) { \nthrow new IllegalStateException ( \"No file extensions for EMF model files set!\" ) ; \n} \nelse if ( fileExtensions . size ( ) == 0 ) { \nthrow new IllegalStateException ( \"No file extensions for EMF model files set!\" ) ; \n} \nresourceSet = new ResourceSetImpl ( ) ; \nerror = false ; \nparseDirs ( ) ; \nparseResources ( ) ; \n} \n} \n"}
{"9682": "public class ParameterizedTemplateParserConfig { \npublic final File getModelDir ( ) { \nif ( modelDir == null ) { \nif ( modelPath != null ) { \nmodelDir = Utils4J . getCanonicalFile ( new File ( modelPath ) ) ; \n} \n} \nreturn modelDir ; \n} \n} \n"}
{"9683": "public class ParameterizedTemplateParserConfig { \npublic final File getTemplateDir ( ) { \nif ( templateDir == null ) { \nif ( templatePath != null ) { \ntry { \ntemplateDir = new File ( templatePath ) . getCanonicalFile ( ) ; \n} \ncatch ( final IOException ex ) { \nthrow new RuntimeException ( \"Couldn't determine canonical template file: \" + templatePath , ex ) ; \n} \n} \n} \nreturn templateDir ; \n} \n} \n"}
{"9700": "public class FileSystemDirectoryHelper { \npublic String abs2rel ( final String basePath , final String absPath ) { \nif ( ! isAbsolutePath ( absPath ) ) { \nreturn absPath ; \n} \nif ( isWindowsDrive ( absPath ) && isWindowsDrive ( basePath ) ) { \nif ( absPath . charAt ( 0 ) != basePath . charAt ( 0 ) ) { \nreturn absPath ; \n} \n} \nStringBuilder result = new StringBuilder ( ) ; \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] absParts = getParts ( absPath ) ; \nint start = 0 ; \nfor ( int i = 0 ; \ni < Math . min ( baseParts . length , absParts . length ) ; \n++ i ) { \nif ( baseParts [ i ] . equals ( absParts [ i ] ) ) { \nstart = i + 1 ; \n} \n} \nfor ( int i = start ; \ni < baseParts . length ; \n++ i ) { \nif ( result . length ( ) > 0 ) { \nresult . append ( File . separator ) ; \n} \nresult . append ( \"..\" ) ; \n} \nfor ( int i = start ; \ni < absParts . length ; \n++ i ) { \nif ( result . length ( ) > 0 ) { \nresult . append ( File . separator ) ; \n} \nresult . append ( absParts [ i ] ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"9701": "public class FileSystemDirectoryHelper { \npublic File rel2abs ( final String basePath , final String relPath ) { \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] relParts = getParts ( relPath ) ; \nif ( isAbsolutePath ( relPath ) ) { \nreturn new File ( relPath ) ; \n} \nList < String > parts = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < baseParts . length ; \n++ i ) { \nif ( i > 0 ) { \nparts . add ( baseParts [ i ] ) ; \n} \nelse if ( ! isWindowsDrive ( basePath ) ) { \nparts . add ( baseParts [ i ] ) ; \n} \n} \nfor ( String part : relParts ) { \nif ( part . equals ( \"..\" ) && parts . size ( ) > 0 ) { \nparts . remove ( parts . size ( ) - 1 ) ; \n} \nelse if ( ! part . equals ( \".\" ) ) { \nif ( ! part . equals ( \"..\" ) ) { \nparts . add ( part ) ; \n} \n} \n} \nStringBuilder result = new StringBuilder ( ) ; \nif ( isWindowsDrive ( basePath ) ) { \nresult . append ( baseParts [ 0 ] ) ; \n} \nfor ( String part : parts ) { \nresult . append ( File . separator ) ; \nresult . append ( part ) ; \n} \nreturn new File ( result . toString ( ) ) ; \n} \n} \n"}
{"9708": "public class ParameterizedTemplateModels { \npublic final List < ParameterizedTemplateModel > findReferencesTo ( final File templateDir , final File templateFile ) { \nfinal List < ParameterizedTemplateModel > result = new ArrayList < ParameterizedTemplateModel > ( ) ; \nif ( paramTemplates != null ) { \nif ( Utils4J . fileInsideDirectory ( templateDir , templateFile ) ) { \nfor ( final ParameterizedTemplateModel paramTemplate : paramTemplates ) { \nif ( paramTemplate . hasReferenceTo ( templateDir , templateFile ) ) { \nresult . add ( paramTemplate ) ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"9719": "public class XtextParserConfig { \npublic final List < File > getModelDirs ( ) { \nif ( modelDirs == null ) { \nif ( modelPath != null ) { \nmodelDirs = paths ( ) . stream ( ) . filter ( XtextParserConfig :: isFile ) . map ( XtextParserConfig :: asFile ) . collect ( Collectors . toList ( ) ) ; \n} \n} \nreturn modelDirs ; \n} \n} \n"}
{"9720": "public class XtextParserConfig { \npublic final List < URI > getModelResources ( ) { \nif ( modelResources == null ) { \nif ( modelPath != null ) { \nmodelResources = new ArrayList < > ( ) ; \nmodelResources = paths ( ) . stream ( ) . filter ( XtextParserConfig :: isResource ) . map ( XtextParserConfig :: asResource ) . collect ( Collectors . toList ( ) ) ; \n} \n} \nreturn modelResources ; \n} \n} \n"}
{"9732": "public class BeanUtils { \npublic static < TAnnotation extends Annotation > List < PropertyDescriptor > getPropertiesWithAnnotation ( Class < ? > beanType , Class < TAnnotation > annotationType ) { \nLinkedList < PropertyDescriptor > result = new LinkedList < > ( ) ; \ngetProperties ( beanType ) . forEach ( property -> { \nif ( property . getReadMethod ( ) != null && property . getReadMethod ( ) . getAnnotation ( annotationType ) != null ) { \nresult . add ( property ) ; \n} \nelse if ( isFieldAnnotated ( beanType , property . getName ( ) , annotationType ) ) { \nresult . add ( property ) ; \n} \n} \n) ; \nreturn result ; \n} \n} \n"}
{"9760": "public class FileSelector { \npublic File getLastFile ( ) throws FileNotFoundException { \nFile [ ] files = directory . listFiles ( filter ) ; \nif ( files == null ) { \nthrow new FileNotFoundException ( ) ; \n} \nelse if ( files . length == 0 ) { \nthrow new FileNotFoundException ( ) ; \n} \nreturn files [ files . length - 1 ] ; \n} \n} \n"}
{"9778": "public class RecursiveFileSelector { \n@ Override public final File next ( ) { \nif ( files == null ) { \nif ( ! cacheNext ( ) ) { \nthrow new NoSuchElementException ( ) ; \n} \n} \nelse if ( fileIndex >= files . length ) { \nif ( ! cacheNext ( ) ) { \nthrow new NoSuchElementException ( ) ; \n} \n} \nreturn files [ fileIndex ++ ] ; \n} \n} \n"}
{"9788": "public class Summary { \npublic void setScore ( double v ) { \nif ( Summary_Type . featOkTst ) { \nif ( ( ( Summary_Type ) jcasType ) . casFeat_score == null ) jcasType . jcas . throwFeatMissing ( \"score\" , \"edu.cmu.lti.oaqa.type.answer.Summary\" ) ; \n} \njcasType . ll_cas . ll_setDoubleValue ( addr , ( ( Summary_Type ) jcasType ) . casFeatCode_score , v ) ; \n} \n} \n"}
{"9789": "public class Summary { \npublic StringList getVariants ( ) { \nif ( Summary_Type . featOkTst ) { \nif ( ( ( Summary_Type ) jcasType ) . casFeat_variants == null ) jcasType . jcas . throwFeatMissing ( \"variants\" , \"edu.cmu.lti.oaqa.type.answer.Summary\" ) ; \n} \nreturn ( StringList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Summary_Type ) jcasType ) . casFeatCode_variants ) ) ) ; \n} \n} \n"}
{"9790": "public class Summary { \npublic void setVariants ( StringList v ) { \nif ( Summary_Type . featOkTst ) { \nif ( ( ( Summary_Type ) jcasType ) . casFeat_variants == null ) jcasType . jcas . throwFeatMissing ( \"variants\" , \"edu.cmu.lti.oaqa.type.answer.Summary\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Summary_Type ) jcasType ) . casFeatCode_variants , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9791": "public class Question { \npublic String getQuestionType ( ) { \nif ( Question_Type . featOkTst ) { \nif ( ( ( Question_Type ) jcasType ) . casFeat_questionType == null ) jcasType . jcas . throwFeatMissing ( \"questionType\" , \"edu.cmu.lti.oaqa.type.input.Question\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Question_Type ) jcasType ) . casFeatCode_questionType ) ; \n} \n} \n"}
{"9792": "public class Question { \npublic void setQuestionType ( String v ) { \nif ( Question_Type . featOkTst ) { \nif ( ( ( Question_Type ) jcasType ) . casFeat_questionType == null ) jcasType . jcas . throwFeatMissing ( \"questionType\" , \"edu.cmu.lti.oaqa.type.input.Question\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Question_Type ) jcasType ) . casFeatCode_questionType , v ) ; \n} \n} \n"}
{"9793": "public class Focus { \npublic Token getToken ( ) { \nif ( Focus_Type . featOkTst ) { \nif ( ( ( Focus_Type ) jcasType ) . casFeat_token == null ) jcasType . jcas . throwFeatMissing ( \"token\" , \"edu.cmu.lti.oaqa.type.nlp.Focus\" ) ; \n} \nreturn ( Token ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Focus_Type ) jcasType ) . casFeatCode_token ) ) ) ; \n} \n} \n"}
{"9794": "public class Token { \npublic String getDepLabel ( ) { \nif ( Token_Type . featOkTst ) { \nif ( ( ( Token_Type ) jcasType ) . casFeat_depLabel == null ) jcasType . jcas . throwFeatMissing ( \"depLabel\" , \"edu.cmu.lti.oaqa.type.nlp.Token\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_depLabel ) ; \n} \n} \n"}
{"9795": "public class Token { \npublic void setDepLabel ( String v ) { \nif ( Token_Type . featOkTst ) { \nif ( ( ( Token_Type ) jcasType ) . casFeat_depLabel == null ) jcasType . jcas . throwFeatMissing ( \"depLabel\" , \"edu.cmu.lti.oaqa.type.nlp.Token\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_depLabel , v ) ; \n} \n} \n"}
{"9796": "public class Token { \npublic String getSemanticType ( ) { \nif ( Token_Type . featOkTst ) { \nif ( ( ( Token_Type ) jcasType ) . casFeat_semanticType == null ) jcasType . jcas . throwFeatMissing ( \"semanticType\" , \"edu.cmu.lti.oaqa.type.nlp.Token\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_semanticType ) ; \n} \n} \n"}
{"9797": "public class Token { \npublic void setSemanticType ( String v ) { \nif ( Token_Type . featOkTst ) { \nif ( ( ( Token_Type ) jcasType ) . casFeat_semanticType == null ) jcasType . jcas . throwFeatMissing ( \"semanticType\" , \"edu.cmu.lti.oaqa.type.nlp.Token\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_semanticType , v ) ; \n} \n} \n"}
{"9798": "public class Document { \npublic StringArray getSections ( ) { \nif ( Document_Type . featOkTst ) { \nif ( ( ( Document_Type ) jcasType ) . casFeat_sections == null ) jcasType . jcas . throwFeatMissing ( \"sections\" , \"edu.cmu.lti.oaqa.type.retrieval.Document\" ) ; \n} \nreturn ( StringArray ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) ) ) ; \n} \n} \n"}
{"9799": "public class Document { \npublic void setSections ( StringArray v ) { \nif ( Document_Type . featOkTst ) { \nif ( ( ( Document_Type ) jcasType ) . casFeat_sections == null ) jcasType . jcas . throwFeatMissing ( \"sections\" , \"edu.cmu.lti.oaqa.type.retrieval.Document\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9800": "public class Document { \npublic String getSections ( int i ) { \nif ( Document_Type . featOkTst ) { \nif ( ( ( Document_Type ) jcasType ) . casFeat_sections == null ) jcasType . jcas . throwFeatMissing ( \"sections\" , \"edu.cmu.lti.oaqa.type.retrieval.Document\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) , i ) ; \nreturn jcasType . ll_cas . ll_getStringArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) , i ) ; \n} \n} \n"}
{"9801": "public class Document { \npublic void setSections ( int i , String v ) { \nif ( Document_Type . featOkTst ) { \nif ( ( ( Document_Type ) jcasType ) . casFeat_sections == null ) jcasType . jcas . throwFeatMissing ( \"sections\" , \"edu.cmu.lti.oaqa.type.retrieval.Document\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) , i ) ; \njcasType . ll_cas . ll_setStringArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Document_Type ) jcasType ) . casFeatCode_sections ) , i , v ) ; \n} \n} \n"}
{"9802": "public class Concept { \npublic StringList getUris ( ) { \nif ( Concept_Type . featOkTst ) { \nif ( ( ( Concept_Type ) jcasType ) . casFeat_uris == null ) jcasType . jcas . throwFeatMissing ( \"uris\" , \"edu.cmu.lti.oaqa.type.kb.Concept\" ) ; \n} \nreturn ( StringList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_uris ) ) ) ; \n} \n} \n"}
{"9803": "public class Concept { \npublic void setUris ( StringList v ) { \nif ( Concept_Type . featOkTst ) { \nif ( ( ( Concept_Type ) jcasType ) . casFeat_uris == null ) jcasType . jcas . throwFeatMissing ( \"uris\" , \"edu.cmu.lti.oaqa.type.kb.Concept\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_uris , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9804": "public class Concept { \npublic FSList getTypes ( ) { \nif ( Concept_Type . featOkTst ) { \nif ( ( ( Concept_Type ) jcasType ) . casFeat_types == null ) jcasType . jcas . throwFeatMissing ( \"types\" , \"edu.cmu.lti.oaqa.type.kb.Concept\" ) ; \n} \nreturn ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_types ) ) ) ; \n} \n} \n"}
{"9805": "public class Concept { \npublic void setTypes ( FSList v ) { \nif ( Concept_Type . featOkTst ) { \nif ( ( ( Concept_Type ) jcasType ) . casFeat_types == null ) jcasType . jcas . throwFeatMissing ( \"types\" , \"edu.cmu.lti.oaqa.type.kb.Concept\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Concept_Type ) jcasType ) . casFeatCode_types , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9806": "public class AnswerType { \npublic Annotation getTargetType ( ) { \nif ( AnswerType_Type . featOkTst ) { \nif ( ( ( AnswerType_Type ) jcasType ) . casFeat_targetType == null ) jcasType . jcas . throwFeatMissing ( \"targetType\" , \"edu.cmu.lti.oaqa.type.answer.AnswerType\" ) ; \n} \nreturn ( Annotation ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( AnswerType_Type ) jcasType ) . casFeatCode_targetType ) ) ) ; \n} \n} \n"}
{"9807": "public class AnswerType { \npublic void setTargetType ( Annotation v ) { \nif ( AnswerType_Type . featOkTst ) { \nif ( ( ( AnswerType_Type ) jcasType ) . casFeat_targetType == null ) jcasType . jcas . throwFeatMissing ( \"targetType\" , \"edu.cmu.lti.oaqa.type.answer.AnswerType\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( AnswerType_Type ) jcasType ) . casFeatCode_targetType , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9808": "public class SearchResult { \npublic int getRank ( ) { \nif ( SearchResult_Type . featOkTst ) { \nif ( ( ( SearchResult_Type ) jcasType ) . casFeat_rank == null ) jcasType . jcas . throwFeatMissing ( \"rank\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \nreturn jcasType . ll_cas . ll_getIntValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_rank ) ; \n} \n} \n"}
{"9809": "public class SearchResult { \npublic void setRank ( int v ) { \nif ( SearchResult_Type . featOkTst ) { \nif ( ( ( SearchResult_Type ) jcasType ) . casFeat_rank == null ) jcasType . jcas . throwFeatMissing ( \"rank\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \njcasType . ll_cas . ll_setIntValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_rank , v ) ; \n} \n} \n"}
{"9810": "public class SearchResult { \npublic String getQueryString ( ) { \nif ( SearchResult_Type . featOkTst ) { \nif ( ( ( SearchResult_Type ) jcasType ) . casFeat_queryString == null ) jcasType . jcas . throwFeatMissing ( \"queryString\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_queryString ) ; \n} \n} \n"}
{"9811": "public class SearchResult { \npublic void setQueryString ( String v ) { \nif ( SearchResult_Type . featOkTst ) { \nif ( ( ( SearchResult_Type ) jcasType ) . casFeat_queryString == null ) jcasType . jcas . throwFeatMissing ( \"queryString\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_queryString , v ) ; \n} \n} \n"}
{"9812": "public class SearchResult { \npublic FSArray getCandidateAnswers ( ) { \nif ( SearchResult_Type . featOkTst ) { \nif ( ( ( SearchResult_Type ) jcasType ) . casFeat_candidateAnswers == null ) jcasType . jcas . throwFeatMissing ( \"candidateAnswers\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \nreturn ( FSArray ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) ) ) ; \n} \n} \n"}
{"9813": "public class SearchResult { \npublic void setCandidateAnswers ( FSArray v ) { \nif ( SearchResult_Type . featOkTst ) { \nif ( ( ( SearchResult_Type ) jcasType ) . casFeat_candidateAnswers == null ) jcasType . jcas . throwFeatMissing ( \"candidateAnswers\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9814": "public class SearchResult { \npublic CandidateAnswerVariant getCandidateAnswers ( int i ) { \nif ( SearchResult_Type . featOkTst ) { \nif ( ( ( SearchResult_Type ) jcasType ) . casFeat_candidateAnswers == null ) jcasType . jcas . throwFeatMissing ( \"candidateAnswers\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) , i ) ; \nreturn ( CandidateAnswerVariant ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) , i ) ) ) ; \n} \n} \n"}
{"9815": "public class SearchResult { \npublic void setCandidateAnswers ( int i , CandidateAnswerVariant v ) { \nif ( SearchResult_Type . featOkTst ) { \nif ( ( ( SearchResult_Type ) jcasType ) . casFeat_candidateAnswers == null ) jcasType . jcas . throwFeatMissing ( \"candidateAnswers\" , \"edu.cmu.lti.oaqa.type.retrieval.SearchResult\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) , i ) ; \njcasType . ll_cas . ll_setRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( SearchResult_Type ) jcasType ) . casFeatCode_candidateAnswers ) , i , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9816": "public class Search { \npublic String getQuery ( ) { \nif ( Search_Type . featOkTst ) { \nif ( ( ( Search_Type ) jcasType ) . casFeat_query == null ) jcasType . jcas . throwFeatMissing ( \"query\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_query ) ; \n} \n} \n"}
{"9817": "public class Search { \npublic void setQuery ( String v ) { \nif ( Search_Type . featOkTst ) { \nif ( ( ( Search_Type ) jcasType ) . casFeat_query == null ) jcasType . jcas . throwFeatMissing ( \"query\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_query , v ) ; \n} \n} \n"}
{"9818": "public class Search { \npublic FSArray getHitList ( ) { \nif ( Search_Type . featOkTst ) { \nif ( ( ( Search_Type ) jcasType ) . casFeat_hitList == null ) jcasType . jcas . throwFeatMissing ( \"hitList\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \nreturn ( FSArray ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) ) ) ; \n} \n} \n"}
{"9819": "public class Search { \npublic void setHitList ( FSArray v ) { \nif ( Search_Type . featOkTst ) { \nif ( ( ( Search_Type ) jcasType ) . casFeat_hitList == null ) jcasType . jcas . throwFeatMissing ( \"hitList\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9820": "public class Search { \npublic SearchResult getHitList ( int i ) { \nif ( Search_Type . featOkTst ) { \nif ( ( ( Search_Type ) jcasType ) . casFeat_hitList == null ) jcasType . jcas . throwFeatMissing ( \"hitList\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) , i ) ; \nreturn ( SearchResult ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) , i ) ) ) ; \n} \n} \n"}
{"9821": "public class Search { \npublic void setHitList ( int i , SearchResult v ) { \nif ( Search_Type . featOkTst ) { \nif ( ( ( Search_Type ) jcasType ) . casFeat_hitList == null ) jcasType . jcas . throwFeatMissing ( \"hitList\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . jcas . checkArrayBounds ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) , i ) ; \njcasType . ll_cas . ll_setRefArrayValue ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_hitList ) , i , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9822": "public class Search { \npublic AbstractQuery getAbstractQuery ( ) { \nif ( Search_Type . featOkTst ) { \nif ( ( ( Search_Type ) jcasType ) . casFeat_abstractQuery == null ) jcasType . jcas . throwFeatMissing ( \"abstractQuery\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \nreturn ( AbstractQuery ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_abstractQuery ) ) ) ; \n} \n} \n"}
{"9823": "public class Search { \npublic void setAbstractQuery ( AbstractQuery v ) { \nif ( Search_Type . featOkTst ) { \nif ( ( ( Search_Type ) jcasType ) . casFeat_abstractQuery == null ) jcasType . jcas . throwFeatMissing ( \"abstractQuery\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_abstractQuery , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9824": "public class Search { \npublic String getSearchId ( ) { \nif ( Search_Type . featOkTst ) { \nif ( ( ( Search_Type ) jcasType ) . casFeat_searchId == null ) jcasType . jcas . throwFeatMissing ( \"searchId\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_searchId ) ; \n} \n} \n"}
{"9825": "public class Search { \npublic void setSearchId ( String v ) { \nif ( Search_Type . featOkTst ) { \nif ( ( ( Search_Type ) jcasType ) . casFeat_searchId == null ) jcasType . jcas . throwFeatMissing ( \"searchId\" , \"edu.cmu.lti.oaqa.type.retrieval.Search\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Search_Type ) jcasType ) . casFeatCode_searchId , v ) ; \n} \n} \n"}
{"9826": "public class Passage { \npublic void setDocId ( String v ) { \nif ( Passage_Type . featOkTst ) { \nif ( ( ( Passage_Type ) jcasType ) . casFeat_docId == null ) jcasType . jcas . throwFeatMissing ( \"docId\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_docId , v ) ; \n} \n} \n"}
{"9827": "public class Passage { \npublic int getOffsetInBeginSection ( ) { \nif ( Passage_Type . featOkTst ) { \nif ( ( ( Passage_Type ) jcasType ) . casFeat_offsetInBeginSection == null ) jcasType . jcas . throwFeatMissing ( \"offsetInBeginSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \nreturn jcasType . ll_cas . ll_getIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInBeginSection ) ; \n} \n} \n"}
{"9828": "public class Passage { \npublic void setOffsetInBeginSection ( int v ) { \nif ( Passage_Type . featOkTst ) { \nif ( ( ( Passage_Type ) jcasType ) . casFeat_offsetInBeginSection == null ) jcasType . jcas . throwFeatMissing ( \"offsetInBeginSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInBeginSection , v ) ; \n} \n} \n"}
{"9829": "public class Passage { \npublic int getOffsetInEndSection ( ) { \nif ( Passage_Type . featOkTst ) { \nif ( ( ( Passage_Type ) jcasType ) . casFeat_offsetInEndSection == null ) jcasType . jcas . throwFeatMissing ( \"offsetInEndSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \nreturn jcasType . ll_cas . ll_getIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInEndSection ) ; \n} \n} \n"}
{"9830": "public class Passage { \npublic void setOffsetInEndSection ( int v ) { \nif ( Passage_Type . featOkTst ) { \nif ( ( ( Passage_Type ) jcasType ) . casFeat_offsetInEndSection == null ) jcasType . jcas . throwFeatMissing ( \"offsetInEndSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setIntValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_offsetInEndSection , v ) ; \n} \n} \n"}
{"9831": "public class Passage { \npublic String getBeginSection ( ) { \nif ( Passage_Type . featOkTst ) { \nif ( ( ( Passage_Type ) jcasType ) . casFeat_beginSection == null ) jcasType . jcas . throwFeatMissing ( \"beginSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_beginSection ) ; \n} \n} \n"}
{"9832": "public class Passage { \npublic void setBeginSection ( String v ) { \nif ( Passage_Type . featOkTst ) { \nif ( ( ( Passage_Type ) jcasType ) . casFeat_beginSection == null ) jcasType . jcas . throwFeatMissing ( \"beginSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_beginSection , v ) ; \n} \n} \n"}
{"9833": "public class Passage { \npublic String getEndSection ( ) { \nif ( Passage_Type . featOkTst ) { \nif ( ( ( Passage_Type ) jcasType ) . casFeat_endSection == null ) jcasType . jcas . throwFeatMissing ( \"endSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_endSection ) ; \n} \n} \n"}
{"9834": "public class Passage { \npublic void setEndSection ( String v ) { \nif ( Passage_Type . featOkTst ) { \nif ( ( ( Passage_Type ) jcasType ) . casFeat_endSection == null ) jcasType . jcas . throwFeatMissing ( \"endSection\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_endSection , v ) ; \n} \n} \n"}
{"9835": "public class Passage { \npublic String getAspects ( ) { \nif ( Passage_Type . featOkTst ) { \nif ( ( ( Passage_Type ) jcasType ) . casFeat_aspects == null ) jcasType . jcas . throwFeatMissing ( \"aspects\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_aspects ) ; \n} \n} \n"}
{"9836": "public class Passage { \npublic void setAspects ( String v ) { \nif ( Passage_Type . featOkTst ) { \nif ( ( ( Passage_Type ) jcasType ) . casFeat_aspects == null ) jcasType . jcas . throwFeatMissing ( \"aspects\" , \"edu.cmu.lti.oaqa.type.retrieval.Passage\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Passage_Type ) jcasType ) . casFeatCode_aspects , v ) ; \n} \n} \n"}
{"9837": "public class TripleSearchResult { \npublic Triple getTriple ( ) { \nif ( TripleSearchResult_Type . featOkTst ) { \nif ( ( ( TripleSearchResult_Type ) jcasType ) . casFeat_triple == null ) jcasType . jcas . throwFeatMissing ( \"triple\" , \"edu.cmu.lti.oaqa.type.retrieval.TripleSearchResult\" ) ; \n} \nreturn ( Triple ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( TripleSearchResult_Type ) jcasType ) . casFeatCode_triple ) ) ) ; \n} \n} \n"}
{"9838": "public class TripleSearchResult { \npublic void setTriple ( Triple v ) { \nif ( TripleSearchResult_Type . featOkTst ) { \nif ( ( ( TripleSearchResult_Type ) jcasType ) . casFeat_triple == null ) jcasType . jcas . throwFeatMissing ( \"triple\" , \"edu.cmu.lti.oaqa.type.retrieval.TripleSearchResult\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( TripleSearchResult_Type ) jcasType ) . casFeatCode_triple , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9839": "public class PassageFromRelation { \npublic Triple getSourceRelation ( ) { \nif ( PassageFromRelation_Type . featOkTst ) { \nif ( ( ( PassageFromRelation_Type ) jcasType ) . casFeat_sourceRelation == null ) jcasType . jcas . throwFeatMissing ( \"sourceRelation\" , \"edu.cmu.lti.oaqa.type.retrieval.PassageFromRelation\" ) ; \n} \nreturn ( Triple ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( PassageFromRelation_Type ) jcasType ) . casFeatCode_sourceRelation ) ) ) ; \n} \n} \n"}
{"9840": "public class PassageFromRelation { \npublic void setSourceRelation ( Triple v ) { \nif ( PassageFromRelation_Type . featOkTst ) { \nif ( ( ( PassageFromRelation_Type ) jcasType ) . casFeat_sourceRelation == null ) jcasType . jcas . throwFeatMissing ( \"sourceRelation\" , \"edu.cmu.lti.oaqa.type.retrieval.PassageFromRelation\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( PassageFromRelation_Type ) jcasType ) . casFeatCode_sourceRelation , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9841": "public class Triple { \npublic String getSubject ( ) { \nif ( Triple_Type . featOkTst ) { \nif ( ( ( Triple_Type ) jcasType ) . casFeat_subject == null ) jcasType . jcas . throwFeatMissing ( \"subject\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_subject ) ; \n} \n} \n"}
{"9842": "public class Triple { \npublic void setSubject ( String v ) { \nif ( Triple_Type . featOkTst ) { \nif ( ( ( Triple_Type ) jcasType ) . casFeat_subject == null ) jcasType . jcas . throwFeatMissing ( \"subject\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_subject , v ) ; \n} \n} \n"}
{"9843": "public class Triple { \npublic String getPredicate ( ) { \nif ( Triple_Type . featOkTst ) { \nif ( ( ( Triple_Type ) jcasType ) . casFeat_predicate == null ) jcasType . jcas . throwFeatMissing ( \"predicate\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_predicate ) ; \n} \n} \n"}
{"9844": "public class Triple { \npublic void setPredicate ( String v ) { \nif ( Triple_Type . featOkTst ) { \nif ( ( ( Triple_Type ) jcasType ) . casFeat_predicate == null ) jcasType . jcas . throwFeatMissing ( \"predicate\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_predicate , v ) ; \n} \n} \n"}
{"9845": "public class Triple { \npublic boolean getIsObjUri ( ) { \nif ( Triple_Type . featOkTst ) { \nif ( ( ( Triple_Type ) jcasType ) . casFeat_isObjUri == null ) jcasType . jcas . throwFeatMissing ( \"isObjUri\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \nreturn jcasType . ll_cas . ll_getBooleanValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_isObjUri ) ; \n} \n} \n"}
{"9846": "public class Triple { \npublic void setIsObjUri ( boolean v ) { \nif ( Triple_Type . featOkTst ) { \nif ( ( ( Triple_Type ) jcasType ) . casFeat_isObjUri == null ) jcasType . jcas . throwFeatMissing ( \"isObjUri\" , \"edu.cmu.lti.oaqa.type.kb.Triple\" ) ; \n} \njcasType . ll_cas . ll_setBooleanValue ( addr , ( ( Triple_Type ) jcasType ) . casFeatCode_isObjUri , v ) ; \n} \n} \n"}
{"9847": "public class ComplexQueryConcept { \npublic QueryOperator getOperator ( ) { \nif ( ComplexQueryConcept_Type . featOkTst ) { \nif ( ( ( ComplexQueryConcept_Type ) jcasType ) . casFeat_operator == null ) jcasType . jcas . throwFeatMissing ( \"operator\" , \"edu.cmu.lti.oaqa.type.retrieval.ComplexQueryConcept\" ) ; \n} \nreturn ( QueryOperator ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operator ) ) ) ; \n} \n} \n"}
{"9848": "public class ComplexQueryConcept { \npublic void setOperator ( QueryOperator v ) { \nif ( ComplexQueryConcept_Type . featOkTst ) { \nif ( ( ( ComplexQueryConcept_Type ) jcasType ) . casFeat_operator == null ) jcasType . jcas . throwFeatMissing ( \"operator\" , \"edu.cmu.lti.oaqa.type.retrieval.ComplexQueryConcept\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operator , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9849": "public class ComplexQueryConcept { \npublic FSList getOperatorArgs ( ) { \nif ( ComplexQueryConcept_Type . featOkTst ) { \nif ( ( ( ComplexQueryConcept_Type ) jcasType ) . casFeat_operatorArgs == null ) jcasType . jcas . throwFeatMissing ( \"operatorArgs\" , \"edu.cmu.lti.oaqa.type.retrieval.ComplexQueryConcept\" ) ; \n} \nreturn ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operatorArgs ) ) ) ; \n} \n} \n"}
{"9850": "public class ComplexQueryConcept { \npublic void setOperatorArgs ( FSList v ) { \nif ( ComplexQueryConcept_Type . featOkTst ) { \nif ( ( ( ComplexQueryConcept_Type ) jcasType ) . casFeat_operatorArgs == null ) jcasType . jcas . throwFeatMissing ( \"operatorArgs\" , \"edu.cmu.lti.oaqa.type.retrieval.ComplexQueryConcept\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( ComplexQueryConcept_Type ) jcasType ) . casFeatCode_operatorArgs , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9851": "public class ConceptMention { \npublic Concept getConcept ( ) { \nif ( ConceptMention_Type . featOkTst ) { \nif ( ( ( ConceptMention_Type ) jcasType ) . casFeat_concept == null ) jcasType . jcas . throwFeatMissing ( \"concept\" , \"edu.cmu.lti.oaqa.type.kb.ConceptMention\" ) ; \n} \nreturn ( Concept ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( ConceptMention_Type ) jcasType ) . casFeatCode_concept ) ) ) ; \n} \n} \n"}
{"9852": "public class ConceptMention { \npublic double getScore ( ) { \nif ( ConceptMention_Type . featOkTst ) { \nif ( ( ( ConceptMention_Type ) jcasType ) . casFeat_score == null ) jcasType . jcas . throwFeatMissing ( \"score\" , \"edu.cmu.lti.oaqa.type.kb.ConceptMention\" ) ; \n} \nreturn jcasType . ll_cas . ll_getDoubleValue ( addr , ( ( ConceptMention_Type ) jcasType ) . casFeatCode_score ) ; \n} \n} \n"}
{"9853": "public class CandidateAnswerOccurrence { \npublic String getText ( ) { \nif ( CandidateAnswerOccurrence_Type . featOkTst ) { \nif ( ( ( CandidateAnswerOccurrence_Type ) jcasType ) . casFeat_text == null ) jcasType . jcas . throwFeatMissing ( \"text\" , \"edu.cmu.lti.oaqa.type.answer.CandidateAnswerOccurrence\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( CandidateAnswerOccurrence_Type ) jcasType ) . casFeatCode_text ) ; \n} \n} \n"}
{"9854": "public class CandidateAnswerOccurrence { \npublic void setText ( String v ) { \nif ( CandidateAnswerOccurrence_Type . featOkTst ) { \nif ( ( ( CandidateAnswerOccurrence_Type ) jcasType ) . casFeat_text == null ) jcasType . jcas . throwFeatMissing ( \"text\" , \"edu.cmu.lti.oaqa.type.answer.CandidateAnswerOccurrence\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( CandidateAnswerOccurrence_Type ) jcasType ) . casFeatCode_text , v ) ; \n} \n} \n"}
{"9855": "public class ConceptType { \npublic String getId ( ) { \nif ( ConceptType_Type . featOkTst ) { \nif ( ( ( ConceptType_Type ) jcasType ) . casFeat_id == null ) jcasType . jcas . throwFeatMissing ( \"id\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_id ) ; \n} \n} \n"}
{"9856": "public class ConceptType { \npublic void setId ( String v ) { \nif ( ConceptType_Type . featOkTst ) { \nif ( ( ( ConceptType_Type ) jcasType ) . casFeat_id == null ) jcasType . jcas . throwFeatMissing ( \"id\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_id , v ) ; \n} \n} \n"}
{"9857": "public class ConceptType { \npublic String getName ( ) { \nif ( ConceptType_Type . featOkTst ) { \nif ( ( ( ConceptType_Type ) jcasType ) . casFeat_name == null ) jcasType . jcas . throwFeatMissing ( \"name\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_name ) ; \n} \n} \n"}
{"9858": "public class ConceptType { \npublic String getAbbreviation ( ) { \nif ( ConceptType_Type . featOkTst ) { \nif ( ( ( ConceptType_Type ) jcasType ) . casFeat_abbreviation == null ) jcasType . jcas . throwFeatMissing ( \"abbreviation\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_abbreviation ) ; \n} \n} \n"}
{"9859": "public class ConceptType { \npublic void setAbbreviation ( String v ) { \nif ( ConceptType_Type . featOkTst ) { \nif ( ( ( ConceptType_Type ) jcasType ) . casFeat_abbreviation == null ) jcasType . jcas . throwFeatMissing ( \"abbreviation\" , \"edu.cmu.lti.oaqa.type.kb.ConceptType\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( ConceptType_Type ) jcasType ) . casFeatCode_abbreviation , v ) ; \n} \n} \n"}
{"9860": "public class ConceptSearchResult { \npublic void setConcept ( Concept v ) { \nif ( ConceptSearchResult_Type . featOkTst ) { \nif ( ( ( ConceptSearchResult_Type ) jcasType ) . casFeat_concept == null ) jcasType . jcas . throwFeatMissing ( \"concept\" , \"edu.cmu.lti.oaqa.type.retrieval.ConceptSearchResult\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( ConceptSearchResult_Type ) jcasType ) . casFeatCode_concept , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9861": "public class Answer { \npublic FSList getVariants ( ) { \nif ( Answer_Type . featOkTst ) { \nif ( ( ( Answer_Type ) jcasType ) . casFeat_variants == null ) jcasType . jcas . throwFeatMissing ( \"variants\" , \"edu.cmu.lti.oaqa.type.answer.Answer\" ) ; \n} \nreturn ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( Answer_Type ) jcasType ) . casFeatCode_variants ) ) ) ; \n} \n} \n"}
{"9862": "public class Answer { \npublic void setVariants ( FSList v ) { \nif ( Answer_Type . featOkTst ) { \nif ( ( ( Answer_Type ) jcasType ) . casFeat_variants == null ) jcasType . jcas . throwFeatMissing ( \"variants\" , \"edu.cmu.lti.oaqa.type.answer.Answer\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( Answer_Type ) jcasType ) . casFeatCode_variants , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9863": "public class QueryConcept { \npublic StringList getNamedEntityTypes ( ) { \nif ( QueryConcept_Type . featOkTst ) { \nif ( ( ( QueryConcept_Type ) jcasType ) . casFeat_namedEntityTypes == null ) jcasType . jcas . throwFeatMissing ( \"namedEntityTypes\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryConcept\" ) ; \n} \nreturn ( StringList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_namedEntityTypes ) ) ) ; \n} \n} \n"}
{"9864": "public class QueryConcept { \npublic void setNamedEntityTypes ( StringList v ) { \nif ( QueryConcept_Type . featOkTst ) { \nif ( ( ( QueryConcept_Type ) jcasType ) . casFeat_namedEntityTypes == null ) jcasType . jcas . throwFeatMissing ( \"namedEntityTypes\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryConcept\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_namedEntityTypes , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9865": "public class QueryConcept { \npublic String getConceptType ( ) { \nif ( QueryConcept_Type . featOkTst ) { \nif ( ( ( QueryConcept_Type ) jcasType ) . casFeat_conceptType == null ) jcasType . jcas . throwFeatMissing ( \"conceptType\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryConcept\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_conceptType ) ; \n} \n} \n"}
{"9866": "public class QueryConcept { \npublic void setConceptType ( String v ) { \nif ( QueryConcept_Type . featOkTst ) { \nif ( ( ( QueryConcept_Type ) jcasType ) . casFeat_conceptType == null ) jcasType . jcas . throwFeatMissing ( \"conceptType\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryConcept\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( QueryConcept_Type ) jcasType ) . casFeatCode_conceptType , v ) ; \n} \n} \n"}
{"9867": "public class CandidateAnswerVariant { \npublic FSList getOccurrences ( ) { \nif ( CandidateAnswerVariant_Type . featOkTst ) { \nif ( ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeat_occurrences == null ) jcasType . jcas . throwFeatMissing ( \"occurrences\" , \"edu.cmu.lti.oaqa.type.answer.CandidateAnswerVariant\" ) ; \n} \nreturn ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeatCode_occurrences ) ) ) ; \n} \n} \n"}
{"9868": "public class CandidateAnswerVariant { \npublic void setOccurrences ( FSList v ) { \nif ( CandidateAnswerVariant_Type . featOkTst ) { \nif ( ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeat_occurrences == null ) jcasType . jcas . throwFeatMissing ( \"occurrences\" , \"edu.cmu.lti.oaqa.type.answer.CandidateAnswerVariant\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( CandidateAnswerVariant_Type ) jcasType ) . casFeatCode_occurrences , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9869": "public class AbstractQuery { \npublic FSList getConcepts ( ) { \nif ( AbstractQuery_Type . featOkTst ) { \nif ( ( ( AbstractQuery_Type ) jcasType ) . casFeat_concepts == null ) jcasType . jcas . throwFeatMissing ( \"concepts\" , \"edu.cmu.lti.oaqa.type.retrieval.AbstractQuery\" ) ; \n} \nreturn ( FSList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( AbstractQuery_Type ) jcasType ) . casFeatCode_concepts ) ) ) ; \n} \n} \n"}
{"9870": "public class AbstractQuery { \npublic void setConcepts ( FSList v ) { \nif ( AbstractQuery_Type . featOkTst ) { \nif ( ( ( AbstractQuery_Type ) jcasType ) . casFeat_concepts == null ) jcasType . jcas . throwFeatMissing ( \"concepts\" , \"edu.cmu.lti.oaqa.type.retrieval.AbstractQuery\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( AbstractQuery_Type ) jcasType ) . casFeatCode_concepts , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9871": "public class AtomicQueryConcept { \npublic String getOriginalText ( ) { \nif ( AtomicQueryConcept_Type . featOkTst ) { \nif ( ( ( AtomicQueryConcept_Type ) jcasType ) . casFeat_originalText == null ) jcasType . jcas . throwFeatMissing ( \"originalText\" , \"edu.cmu.lti.oaqa.type.retrieval.AtomicQueryConcept\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( AtomicQueryConcept_Type ) jcasType ) . casFeatCode_originalText ) ; \n} \n} \n"}
{"9872": "public class AtomicQueryConcept { \npublic void setOriginalText ( String v ) { \nif ( AtomicQueryConcept_Type . featOkTst ) { \nif ( ( ( AtomicQueryConcept_Type ) jcasType ) . casFeat_originalText == null ) jcasType . jcas . throwFeatMissing ( \"originalText\" , \"edu.cmu.lti.oaqa.type.retrieval.AtomicQueryConcept\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( AtomicQueryConcept_Type ) jcasType ) . casFeatCode_originalText , v ) ; \n} \n} \n"}
{"9873": "public class QueryOperator { \npublic StringList getArgs ( ) { \nif ( QueryOperator_Type . featOkTst ) { \nif ( ( ( QueryOperator_Type ) jcasType ) . casFeat_args == null ) jcasType . jcas . throwFeatMissing ( \"args\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryOperator\" ) ; \n} \nreturn ( StringList ) ( jcasType . ll_cas . ll_getFSForRef ( jcasType . ll_cas . ll_getRefValue ( addr , ( ( QueryOperator_Type ) jcasType ) . casFeatCode_args ) ) ) ; \n} \n} \n"}
{"9874": "public class QueryOperator { \npublic void setArgs ( StringList v ) { \nif ( QueryOperator_Type . featOkTst ) { \nif ( ( ( QueryOperator_Type ) jcasType ) . casFeat_args == null ) jcasType . jcas . throwFeatMissing ( \"args\" , \"edu.cmu.lti.oaqa.type.retrieval.QueryOperator\" ) ; \n} \njcasType . ll_cas . ll_setRefValue ( addr , ( ( QueryOperator_Type ) jcasType ) . casFeatCode_args , jcasType . ll_cas . ll_getFSRef ( v ) ) ; \n} \n} \n"}
{"9875": "public class SemanticRole { \npublic String getLabel ( ) { \nif ( SemanticRole_Type . featOkTst ) { \nif ( ( ( SemanticRole_Type ) jcasType ) . casFeat_label == null ) jcasType . jcas . throwFeatMissing ( \"label\" , \"edu.cmu.lti.oaqa.type.nlp.SemanticRole\" ) ; \n} \nreturn jcasType . ll_cas . ll_getStringValue ( addr , ( ( SemanticRole_Type ) jcasType ) . casFeatCode_label ) ; \n} \n} \n"}
{"9876": "public class SemanticRole { \npublic void setLabel ( String v ) { \nif ( SemanticRole_Type . featOkTst ) { \nif ( ( ( SemanticRole_Type ) jcasType ) . casFeat_label == null ) jcasType . jcas . throwFeatMissing ( \"label\" , \"edu.cmu.lti.oaqa.type.nlp.SemanticRole\" ) ; \n} \njcasType . ll_cas . ll_setStringValue ( addr , ( ( SemanticRole_Type ) jcasType ) . casFeatCode_label , v ) ; \n} \n} \n"}
{"9883": "public class AnnotationsParser { \nprivate boolean checkBracketsParenthesis ( ) { \nLOG . debug ( \"Check of brackets in the annotation section:\" ) ; \nif ( bracketCounterOpen == bracketCounterClose && parenthesisCounterOpen == parenthesisCounterClose ) { \nif ( curlyBracketCounterOpen == curlyBracketCounterClose ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9890": "public class StateMachineParser { \npublic boolean checkDetailsConnections ( String d ) { \nLOG . debug ( \"Validation of connection's details:\" ) ; \nString group = \"\\\\((\\\\D|\\\\d)((,|\\\\+)(\\\\D|\\\\d))+\\\\)\" ; \nString partOne = \"([1-9][0-9]*|\\\\D|\\\\?|\" + group + \")\" ; \nString partTwo = \"(R[1-9][0-9]*+|\\\\?)\" ; \nString element = partOne + \":\" + partTwo ; \nString patternConnection = element + \"-\" + element ; \nString hydrogenBondPartner = partOne + \":pair\" ; \nString hydrogenBondPattern = hydrogenBondPartner + \"-\" + hydrogenBondPartner ; \nPattern pConnection = Pattern . compile ( patternConnection , Pattern . CASE_INSENSITIVE ) ; \nMatcher mConnection = pConnection . matcher ( d ) ; \nPattern pHydrogen = Pattern . compile ( hydrogenBondPattern , Pattern . CASE_INSENSITIVE ) ; \nMatcher mHydrogen = pHydrogen . matcher ( d ) ; \nif ( mConnection . matches ( ) ) { \nLOG . debug ( \"Connection's details are valid:\" ) ; \nreturn true ; \n} \nelse if ( mHydrogen . matches ( ) ) { \nLOG . debug ( \"Connection's details are valid:\" ) ; \nreturn true ; \n} \nLOG . debug ( \"Connection's details are not valid: \" + d ) ; \nreturn false ; \n} \n} \n"}
{"9918": "public class ADiGraph { \nprivate void initPathsInternal ( ) { \nsynchronized ( LOCK ) { \nif ( _incomingPathsInternal == null ) { \nAMap < N , AList < AEdgePath < N , E > > > incomingPaths = AHashMap . empty ( ) ; \nincomingPaths = incomingPaths . withDefaultValue ( AList . nil ) ; \nAMap < N , AList < AEdgePath < N , E > > > outgoingPaths = AHashMap . empty ( ) ; \noutgoingPaths = outgoingPaths . withDefaultValue ( AList . nil ) ; \nAList < AEdgePath < N , E > > cycles = AList . nil ( ) ; \nfor ( N curNode : nodes ( ) ) { \nfinal Iterable < E > curIncoming = incomingEdges ( curNode ) ; \nList < AEdgePath < N , E > > unfinishedBusiness = new ArrayList < > ( ) ; \nfor ( E incomingEdge : curIncoming ) { \nunfinishedBusiness . add ( AEdgePath . create ( incomingEdge ) ) ; \n} \nAList < AEdgePath < N , E > > nonCycles = AList . nil ( ) ; \nwhile ( unfinishedBusiness . size ( ) > 0 ) { \nfinal List < AEdgePath < N , E > > curBusiness = unfinishedBusiness ; \nfor ( AEdgePath < N , E > p : unfinishedBusiness ) { \nif ( ! p . hasCycle ( ) ) nonCycles = nonCycles . cons ( p ) ; \nelse if ( p . isMinimalCycle ( ) ) nonCycles = nonCycles . cons ( p ) ; \nif ( p . isMinimalCycle ( ) ) cycles = cycles . cons ( p ) ; \n} \nunfinishedBusiness = new ArrayList < > ( ) ; \nfor ( AEdgePath < N , E > curPath : curBusiness ) { \nfinal Iterable < E > l = incomingEdges ( curPath . getFrom ( ) ) ; \nfor ( E newEdge : l ) { \nfinal AEdgePath < N , E > pathCandidate = curPath . prepend ( newEdge ) ; \nif ( ! pathCandidate . hasNonMinimalCycle ( ) ) { \nunfinishedBusiness . add ( pathCandidate ) ; \n} \n} \n} \n} \nincomingPaths = incomingPaths . updated ( curNode , nonCycles ) ; \nfor ( AEdgePath < N , E > p : nonCycles ) { \noutgoingPaths = outgoingPaths . updated ( p . getFrom ( ) , outgoingPaths . getRequired ( p . getFrom ( ) ) . cons ( p ) ) ; \n} \n} \n_incomingPathsInternal = incomingPaths ; \n_outgoingPathsInternal = outgoingPaths ; \n_cyclesInternal = cycles ; \n} \n} \n} \n} \n"}
{"9929": "public class ForkJoinPool { \nprivate boolean createWorker ( ) { \nForkJoinWorkerThreadFactory fac = factory ; \nThrowable ex = null ; \nForkJoinWorkerThread wt = null ; \ntry { \nif ( fac != null ) { \nif ( ( wt = fac . newThread ( this ) ) != null ) { \nwt . start ( ) ; \nreturn true ; \n} \n} \n} \ncatch ( Throwable rex ) { \nex = rex ; \n} \nderegisterWorker ( wt , ex ) ; \nreturn false ; \n} \n} \n"}
{"9931": "public class ForkJoinPool { \nfinal WorkQueue registerWorker ( ForkJoinWorkerThread wt ) { \nUncaughtExceptionHandler handler ; \nwt . setDaemon ( true ) ; \nif ( ( handler = ueh ) != null ) wt . setUncaughtExceptionHandler ( handler ) ; \nWorkQueue w = new WorkQueue ( this , wt ) ; \nint i = 0 ; \nint mode = config & MODE_MASK ; \nint rs = lockRunState ( ) ; \ntry { \nWorkQueue [ ] ws ; \nint n ; \nif ( ( ws = workQueues ) != null ) { \nif ( ( n = ws . length ) > 0 ) { \nint s = indexSeed += SEED_INCREMENT ; \nint m = n - 1 ; \ni = ( ( s << 1 ) | 1 ) & m ; \nif ( ws [ i ] != null ) { \nint probes = 0 ; \nint step = ( n <= 4 ) ? 2 : ( ( n >>> 1 ) & EVENMASK ) + 2 ; \nwhile ( ws [ i = ( i + step ) & m ] != null ) { \nif ( ++ probes >= n ) { \nworkQueues = ws = Arrays . copyOf ( ws , n <<= 1 ) ; \nm = n - 1 ; \nprobes = 0 ; \n} \n} \n} \nw . hint = s ; \nw . config = i | mode ; \nw . scanState = i ; \nws [ i ] = w ; \n} \n} \n} \nfinally { \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nwt . setName ( workerNamePrefix . concat ( Integer . toString ( i >>> 1 ) ) ) ; \nreturn w ; \n} \n} \n"}
{"9932": "public class ForkJoinPool { \nfinal void deregisterWorker ( ForkJoinWorkerThread wt , Throwable ex ) { \nWorkQueue w = null ; \nif ( wt != null ) { \nif ( ( w = wt . workQueue ) != null ) { \nWorkQueue [ ] ws ; \nint idx = w . config & SMASK ; \nint rs = lockRunState ( ) ; \nif ( ( ws = workQueues ) != null && ws . length > idx ) { \nif ( ws [ idx ] == w ) ws [ idx ] = null ; \n} \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \n} \nlong c ; \ndo { \n} \nwhile ( ! U . compareAndSwapLong ( this , CTL , c = ctl , ( ( AC_MASK & ( c - AC_UNIT ) ) | ( TC_MASK & ( c - TC_UNIT ) ) | ( SP_MASK & c ) ) ) ) ; \nif ( w != null ) { \nw . qlock = - 1 ; \nw . transferStealCount ( this ) ; \nw . cancelAll ( ) ; \n} \nfor ( ; \n; \n) { \nWorkQueue [ ] ws ; \nint m , sp ; \nif ( tryTerminate ( false , false ) || w == null || w . array == null || ( runState & STOP ) != 0 || ( ws = workQueues ) == null ) break ; \nelse if ( ( m = ws . length - 1 ) < 0 ) break ; \nif ( ( sp = ( int ) ( c = ctl ) ) != 0 ) { \nif ( tryRelease ( c , ws [ sp & m ] , AC_UNIT ) ) break ; \n} \nelse if ( ex != null && ( c & ADD_WORKER ) != 0L ) { \ntryAddWorker ( c ) ; \nbreak ; \n} \nelse break ; \n} \nif ( ex == null ) ForkJoinTask . helpExpungeStaleExceptions ( ) ; \nelse ForkJoinTask . rethrow ( ex ) ; \n} \n} \n"}
{"9933": "public class ForkJoinPool { \nfinal void signalWork ( WorkQueue [ ] ws , WorkQueue q ) { \nlong c ; \nint sp , i ; \nWorkQueue v ; \nThread p ; \nwhile ( ( c = ctl ) < 0L ) { \nif ( ( sp = ( int ) c ) == 0 ) { \nif ( ( c & ADD_WORKER ) != 0L ) tryAddWorker ( c ) ; \nbreak ; \n} \nif ( ws == null ) break ; \nif ( ws . length <= ( i = sp & SMASK ) ) break ; \nif ( ( v = ws [ i ] ) == null ) break ; \nint vs = ( sp + SS_SEQ ) & ~ INACTIVE ; \nint d = sp - v . scanState ; \nlong nc = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & v . stackPred ) ; \nif ( d == 0 ) { \nif ( U . compareAndSwapLong ( this , CTL , c , nc ) ) { \nv . scanState = vs ; \nif ( ( p = v . parker ) != null ) U . unpark ( p ) ; \nbreak ; \n} \n} \nif ( q != null ) { \nif ( q . base == q . top ) break ; \n} \n} \n} \n} \n"}
{"9935": "public class ForkJoinPool { \nprivate boolean awaitWork ( WorkQueue w , int r ) { \nif ( w == null ) return false ; \nelse if ( w . qlock < 0 ) return false ; \nfor ( int pred = w . stackPred , spins = SPINS , ss ; \n; \n) { \nif ( ( ss = w . scanState ) >= 0 ) break ; \nelse if ( spins > 0 ) { \nr ^= r << 6 ; \nr ^= r >>> 21 ; \nr ^= r << 7 ; \nif ( r >= 0 ) { \nif ( -- spins == 0 ) { \nWorkQueue v ; \nWorkQueue [ ] ws ; \nint s , j ; \nAtomicLong sc ; \nif ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null ) { \nif ( v . parker == null || v . scanState >= 0 ) spins = SPINS ; \n} \n} \n} \n} \nelse if ( w . qlock < 0 ) return false ; \nelse if ( ! Thread . interrupted ( ) ) { \nlong c , prevctl , parkTime , deadline ; \nint ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; \nif ( ac <= 0 && tryTerminate ( false , false ) ) return false ; \nelse if ( ( runState & STOP ) != 0 ) return false ; \nif ( ac <= 0 && ss == ( int ) c ) { \nprevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; \nint t = ( short ) ( c >>> TC_SHIFT ) ; \nif ( t > 2 ) { \nif ( U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \n} \nparkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; \ndeadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; \n} \nelse prevctl = parkTime = deadline = 0L ; \nThread wt = Thread . currentThread ( ) ; \nU . putObject ( wt , PARKBLOCKER , this ) ; \nw . parker = wt ; \nif ( w . scanState < 0 ) { \nif ( ctl == c ) U . park ( false , parkTime ) ; \n} \nU . putOrderedObject ( w , QPARKER , null ) ; \nU . putObject ( wt , PARKBLOCKER , null ) ; \nif ( w . scanState >= 0 ) break ; \nif ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L ) { \nif ( U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"9940": "public class ForkJoinPool { \nprivate static ForkJoinPool makeCommonPool ( ) { \nint parallelism = - 1 ; \nForkJoinWorkerThreadFactory factory = null ; \nUncaughtExceptionHandler handler = null ; \ntry { \nString pp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.parallelism\" ) ; \nString fp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.threadFactory\" ) ; \nString hp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.exceptionHandler\" ) ; \nString mp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.maximumSpares\" ) ; \nif ( pp != null ) parallelism = Integer . parseInt ( pp ) ; \nif ( fp != null ) factory = ( ( ForkJoinWorkerThreadFactory ) ClassLoader . getSystemClassLoader ( ) . loadClass ( fp ) . newInstance ( ) ) ; \nif ( hp != null ) handler = ( ( UncaughtExceptionHandler ) ClassLoader . getSystemClassLoader ( ) . loadClass ( hp ) . newInstance ( ) ) ; \nif ( mp != null ) commonMaxSpares = Integer . parseInt ( mp ) ; \n} \ncatch ( Exception ignore ) { \n} \nif ( factory == null ) { \nif ( System . getSecurityManager ( ) == null ) factory = defaultForkJoinWorkerThreadFactory ; \nelse factory = new InnocuousForkJoinWorkerThreadFactory ( ) ; \n} \nif ( parallelism < 0 ) { \nif ( ( parallelism = Runtime . getRuntime ( ) . availableProcessors ( ) - 1 ) <= 0 ) parallelism = 1 ; \n} \nif ( parallelism > MAX_CAP ) parallelism = MAX_CAP ; \nreturn new ForkJoinPool ( parallelism , factory , handler , LIFO_QUEUE , \"ForkJoinPool.commonPool-worker-\" ) ; \n} \n} \n"}
{"9941": "public class ForkJoinTask { \npublic final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nint s ; \nlong nanos = unit . toNanos ( timeout ) ; \nif ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; \nif ( ( s = status ) >= 0 ) { \nif ( nanos > 0L ) { \nlong d = System . nanoTime ( ) + nanos ; \nlong deadline = ( d == 0L ) ? 1L : d ; \nThread t = Thread . currentThread ( ) ; \nif ( t instanceof ForkJoinWorkerThread ) { \nForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; \ns = wt . pool . awaitJoin ( wt . workQueue , this , deadline ) ; \n} \nelse if ( ( s = ( ( this instanceof CountedCompleter ) ? ForkJoinPool . common . externalHelpComplete ( ( CountedCompleter < ? > ) this , 0 ) : ForkJoinPool . common . tryExternalUnpush ( this ) ? doExec ( ) : 0 ) ) >= 0 ) { \nlong ns , ms ; \nwhile ( ( s = status ) >= 0 && ( ns = deadline - System . nanoTime ( ) ) > 0L ) { \nif ( ( ms = TimeUnit . NANOSECONDS . toMillis ( ns ) ) > 0L ) { \nif ( U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { \nsynchronized ( this ) { \nif ( status >= 0 ) wait ( ms ) ; \nelse notifyAll ( ) ; \n} \n} \n} \n} \n} \n} \n} \nif ( s >= 0 ) s = status ; \nif ( ( s &= DONE_MASK ) != NORMAL ) { \nThrowable ex ; \nif ( s == CANCELLED ) throw new CancellationException ( ) ; \nif ( s != EXCEPTIONAL ) throw new TimeoutException ( ) ; \nif ( ( ex = getThrowableException ( ) ) != null ) throw new ExecutionException ( ex ) ; \n} \nreturn getRawResult ( ) ; \n} \n} \n"}
{"9957": "public class ValueTypeXmlAdapter { \n@ Override public String marshal ( BoundType v ) throws Exception { \nClass < ? extends Object > type = v . getClass ( ) ; \nif ( ! Types . isUserDefinedValueType ( type ) ) { \nthrow new IllegalArgumentException ( \"Type [\" + type + \"] must be an user-defined value type; \" + \"@XmlJavaTypeAdapter(ValueTypeXmlAdapter.class) \" + \"can be annotated to user-defined value type and field only\" ) ; \n} \nConverter converter = ConvertUtils . lookup ( type ) ; \nif ( converter != null ) { \nif ( converter instanceof AbstractConverter ) { \nString string = ( String ) ConvertUtils . convert ( v , String . class ) ; \nif ( string != null ) { \nreturn string ; \n} \n} \n} \nreturn v . toString ( ) ; \n} \n} \n"}
{"9961": "public class EMail { \npublic static Future < Boolean > send ( Email email ) { \ntry { \nemail = buildMessage ( email ) ; \nif ( GojaConfig . getProperty ( \"mail.smtp\" , StringPool . EMPTY ) . equals ( \"mock\" ) ) { \nif ( GojaConfig . getApplicationMode ( ) . isDev ( ) ) { \nMock . send ( email ) ; \nreturn new Future < Boolean > ( ) { \n@ Override public boolean cancel ( boolean mayInterruptIfRunning ) { \nreturn false ; \n} \n@ Override public boolean isCancelled ( ) { \nreturn false ; \n} \n@ Override public boolean isDone ( ) { \nreturn true ; \n} \n@ Override public Boolean get ( ) throws InterruptedException , ExecutionException { \nreturn true ; \n} \n@ Override public Boolean get ( long timeout , final TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nreturn true ; \n} \n} \n; \n} \n} \nemail . setMailSession ( getSession ( ) ) ; \nreturn sendMessage ( email ) ; \n} \ncatch ( EmailException ex ) { \nthrow new MailException ( \"Cannot send email\" , ex ) ; \n} \n} \n} \n"}
{"9963": "public class ApplicationRouter { \npublic void bind ( final RouteBinding handler ) { \nfinal Method method = handler . getMethod ( ) ; \nlogger . info ( \"Using appId: {} and default version: {}\" , appAcceptId , defaultVersion ) ; \nList < String > versions = handler . getVersions ( ) ; \nif ( versions == null ) { \nversions = Collections . singletonList ( defaultVersion ) ; \n} \nelse if ( versions . isEmpty ( ) ) { \nversions = Collections . singletonList ( defaultVersion ) ; \n} \nfor ( final String version : versions ) { \nfinal Set < Method > methods = new HashSet < > ( ) ; \nif ( method == Method . ANY ) { \nfor ( final Method m : Method . values ( ) ) { \nmethods . add ( m ) ; \n} \n} \nelse { \nmethods . add ( method ) ; \n} \nfor ( final Method m : methods ) { \nfinal BindingKey key = new BindingKey ( m , version ) ; \nList < PatternRouteBinding > b = routeBindings . get ( key ) ; \nif ( b == null ) { \nb = new ArrayList < > ( ) ; \nrouteBindings . put ( key , b ) ; \n} \nlogger . info ( \"ADD: {}, Pattern: {}, Route: {}\\n\" , key , handler . getPath ( ) , handler ) ; \naddPattern ( handler , b ) ; \n} \n} \n} \n} \n"}
{"9964": "public class ApplicationRouter { \npublic void bind ( final FilterBinding handler ) { \nfinal Method method = handler . getMethod ( ) ; \nfinal String path = handler . getPath ( ) ; \nlogger . info ( \"Using appId: {} and default version: {}\" , appAcceptId , defaultVersion ) ; \nList < String > versions = handler . getVersions ( ) ; \nif ( versions == null ) { \nversions = Collections . singletonList ( defaultVersion ) ; \n} \nelse if ( versions . isEmpty ( ) ) { \nversions = Collections . singletonList ( defaultVersion ) ; \n} \nfor ( final String version : versions ) { \nfinal Set < Method > methods = new HashSet < > ( ) ; \nif ( method == Method . ANY ) { \nfor ( final Method m : Method . values ( ) ) { \nmethods . add ( m ) ; \n} \n} \nelse { \nmethods . add ( method ) ; \n} \nfor ( final Method m : methods ) { \nfinal BindingKey key = new BindingKey ( m , version ) ; \nlogger . info ( \"ADD: {}, Pattern: {}, Filter: {}\\n\" , key , path , handler ) ; \nList < PatternFilterBinding > allFilterBindings = this . filterBindings . get ( key ) ; \nif ( allFilterBindings == null ) { \nallFilterBindings = new ArrayList < > ( ) ; \nthis . filterBindings . put ( key , allFilterBindings ) ; \n} \nboolean found = false ; \nfor ( final PatternFilterBinding binding : allFilterBindings ) { \nif ( binding . getPattern ( ) . pattern ( ) . equals ( handler . getPath ( ) ) ) { \nbinding . addFilter ( handler ) ; \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) { \nfinal PatternFilterBinding binding = new PatternFilterBinding ( handler . getPath ( ) , handler ) ; \nallFilterBindings . add ( binding ) ; \n} \n} \n} \n} \n} \n"}
{"9978": "public class FileRenamePolicyWrapper { \npublic String appendFileSeparator ( String path ) { \nif ( null == path ) { \nreturn File . separator ; \n} \nif ( ! path . startsWith ( StringPool . SLASH ) ) { \nif ( ! path . startsWith ( StringPool . BACK_SLASH ) ) { \npath = File . separator + path ; \n} \n} \nif ( ! path . endsWith ( StringPool . SLASH ) ) { \nif ( ! path . endsWith ( StringPool . BACK_SLASH ) ) { \npath = path + File . separator ; \n} \n} \nreturn path ; \n} \n} \n"}
{"9995": "public class Controller { \nprotected String parsePath ( String currentActionPath , String url ) { \nif ( url . startsWith ( SLASH ) ) { \nreturn url . split ( \"\\\\?\" ) [ 0 ] ; \n} \nelse if ( ! url . contains ( SLASH ) ) { \nreturn SLASH + currentActionPath . split ( SLASH ) [ 1 ] + SLASH + url . split ( \"\\\\?\" ) [ 0 ] ; \n} \nelse if ( url . contains ( \"http:\" ) ) { \nreturn null ; \n} \nelse if ( url . contains ( \"https:\" ) ) { \nreturn null ; \n} \nreturn currentActionPath + SLASH + url . split ( \"\\\\?\" ) [ 0 ] ; \n} \n} \n"}
{"10004": "public class LogUtil { \npublic static String encodeString ( String value ) { \nint estimatedSize = 0 ; \nfinal int len = value . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \n++ i ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' ) { \nestimatedSize += 3 ; \ncontinue ; \n} \nelse if ( ch == ',' ) { \nestimatedSize += 3 ; \ncontinue ; \n} \n++ estimatedSize ; \n} \nif ( value . length ( ) == estimatedSize ) { \nreturn value ; \n} \nfinal StringBuilder builder = new StringBuilder ( estimatedSize ) ; \nfor ( int i = 0 ; \ni < len ; \n++ i ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' ) { \nbuilder . append ( \"%20\" ) ; \ncontinue ; \n} \nif ( ch == ',' ) { \nbuilder . append ( \"%2c\" ) ; \ncontinue ; \n} \nbuilder . append ( ch ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"10018": "public class ZipKit { \npublic static void unzip ( File zipFile , File destDir , String ... patterns ) throws IOException { \nZipFile zip = new ZipFile ( zipFile ) ; \nEnumeration zipEntries = zip . entries ( ) ; \nwhile ( zipEntries . hasMoreElements ( ) ) { \nZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nif ( patterns != null ) { \nif ( patterns . length > 0 ) { \nif ( Wildcard . matchPathOne ( entryName , patterns ) == - 1 ) { \ncontinue ; \n} \n} \n} \nFile file = ( destDir != null ) ? new File ( destDir , entryName ) : new File ( entryName ) ; \nif ( entry . isDirectory ( ) ) { \nif ( ! file . mkdirs ( ) ) { \nif ( ! file . isDirectory ( ) ) { \nthrow new IOException ( \"Failed to create directory: \" + file ) ; \n} \n} \n} \nelse { \nFile parent = file . getParentFile ( ) ; \nif ( parent != null ) { \nif ( ! parent . exists ( ) ) { \nif ( ! parent . mkdirs ( ) ) { \nif ( ! file . isDirectory ( ) ) { \nthrow new IOException ( \"Failed to create directory: \" + parent ) ; \n} \n} \n} \n} \nInputStream in = zip . getInputStream ( entry ) ; \nOutputStream out = null ; \ntry { \nout = new FileOutputStream ( file ) ; \nStreamUtil . copy ( in , out ) ; \n} \nfinally { \nStreamUtil . close ( out ) ; \nStreamUtil . close ( in ) ; \n} \n} \n} \nclose ( zip ) ; \n} \n} \n"}
{"10025": "public class Validator { \npublic static boolean isBirthDay ( String value ) { \nString check = \"(\\\\d{4})(/|-|\\\\.)(\\\\d{1,2})(/|-|\\\\.)(\\\\d{1,2})$\" ; \nif ( match ( check , Pattern . CASE_INSENSITIVE , value ) ) { \nint year = Integer . parseInt ( value . substring ( 0 , 4 ) ) ; \nint month = Integer . parseInt ( value . substring ( 5 , 7 ) ) ; \nint day = Integer . parseInt ( value . substring ( 8 , 10 ) ) ; \nif ( month < 1 ) { \nreturn false ; \n} \nelse if ( month > 12 ) { \nreturn false ; \n} \nif ( day < 1 ) { \nreturn false ; \n} \nelse if ( day > 31 ) { \nreturn false ; \n} \nif ( month == 4 || month == 6 || month == 9 || month == 11 ) { \nif ( day == 31 ) { \nreturn false ; \n} \n} \nif ( month == 2 ) { \nboolean isleap = ( year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) ; \nif ( day > 29 ) { \nreturn false ; \n} \nelse if ( day == 29 && ! isleap ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"10047": "public class ClassKit { \npublic static boolean isAssignable ( Class < ? > lhsType , Class < ? > rhsType ) { \nPreconditions . checkNotNull ( lhsType , \"Left-hand side type must not be null\" ) ; \nPreconditions . checkNotNull ( rhsType , \"Right-hand side type must not be null\" ) ; \nif ( lhsType . isAssignableFrom ( rhsType ) ) { \nreturn true ; \n} \nif ( lhsType . isPrimitive ( ) ) { \nClass < ? > resolvedPrimitive = primitiveWrapperTypeMap . get ( rhsType ) ; \nif ( resolvedPrimitive != null ) { \nif ( lhsType . equals ( resolvedPrimitive ) ) { \nreturn true ; \n} \n} \n} \nelse { \nClass < ? > resolvedWrapper = primitiveTypeToWrapperMap . get ( rhsType ) ; \nif ( resolvedWrapper != null ) { \nif ( lhsType . isAssignableFrom ( resolvedWrapper ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10063": "public class Goja { \nprivate void initDataSource ( final Plugins plugins ) { \nfinal Map < String , Properties > dbConfig = GojaConfig . loadDBConfig ( GojaConfig . getConfigProps ( ) ) ; \nfor ( String db_config : dbConfig . keySet ( ) ) { \nfinal Properties db_props = dbConfig . get ( db_config ) ; \nif ( db_props != null ) { \nif ( ! db_props . isEmpty ( ) ) { \nDruidDbIntializer . init ( db_config , plugins , db_props ) ; \n} \n} \n} \nif ( GojaConfig . getPropertyToBoolean ( GojaPropConst . DB_SQLINXML , true ) ) { \nplugins . add ( new SqlInXmlPlugin ( ) ) ; \n} \n} \n} \n"}
{"10081": "public class ProtobufSerializerUtils { \npublic static final String getProtobufGetter ( ProtobufAttribute protobufAttribute , Field field ) { \nfinal String fieldName = field . getName ( ) ; \nfinal String upperClassName = field . getDeclaringClass ( ) . getCanonicalName ( ) ; \nMap < String , String > map = CLASS_TO_FIELD_GETTERS_MAP_CACHE . get ( upperClassName ) ; \nif ( map != null ) { \nif ( ! map . isEmpty ( ) ) { \nif ( map . containsKey ( fieldName ) ) { \nreturn map . get ( fieldName ) ; \n} \n} \n} \nelse { \nmap = new ConcurrentHashMap < > ( ) ; \n} \nfinal String upperCaseFirstFieldName = JStringUtils . upperCaseFirst ( field . getName ( ) ) ; \nString getter = \"get\" + upperCaseFirstFieldName ; \nif ( Collection . class . isAssignableFrom ( field . getType ( ) ) ) { \ngetter += \"List\" ; \n} \nif ( ! protobufAttribute . protobufGetter ( ) . isEmpty ( ) ) { \nreturn protobufAttribute . protobufGetter ( ) ; \n} \nmap . put ( fieldName , getter ) ; \nCLASS_TO_FIELD_GETTERS_MAP_CACHE . put ( upperClassName , map ) ; \nreturn getter ; \n} \n} \n"}
{"10082": "public class ProtobufSerializerUtils { \npublic static final String getPojoSetter ( ProtobufAttribute protobufAttribute , Field field ) { \nfinal String fieldName = field . getName ( ) ; \nfinal String upperClassName = field . getDeclaringClass ( ) . getCanonicalName ( ) ; \nMap < String , String > map = CLASS_TO_FIELD_SETTERS_MAP_CACHE . get ( upperClassName ) ; \nif ( map != null ) { \nif ( ! map . isEmpty ( ) ) { \nif ( map . containsKey ( fieldName ) ) { \nreturn map . get ( fieldName ) ; \n} \n} \n} \nelse { \nmap = new ConcurrentHashMap < > ( ) ; \n} \nfinal String upperCaseFirstFieldName = JStringUtils . upperCaseFirst ( field . getName ( ) ) ; \nString setter = \"set\" + upperCaseFirstFieldName ; \nif ( ! protobufAttribute . pojoSetter ( ) . isEmpty ( ) ) { \nreturn protobufAttribute . pojoSetter ( ) ; \n} \nmap . put ( fieldName , setter ) ; \nCLASS_TO_FIELD_SETTERS_MAP_CACHE . put ( upperClassName , map ) ; \nreturn setter ; \n} \n} \n"}
{"10089": "public class AttributeInjector { \nprotected void copyOutAttributes ( Object target , List < Attribute > jmxAttributeValues , Map < String , Method > attributeSetters , String identifierKey , Object identifier ) { \nfor ( Attribute oneAttribute : jmxAttributeValues ) { \nString attributeName = oneAttribute . getName ( ) ; \nMethod setter = attributeSetters . get ( attributeName ) ; \nObject value = oneAttribute . getValue ( ) ; \ntry { \nif ( setter . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( Integer . class ) ) { \nif ( value instanceof Long ) { \nvalue = ( ( Long ) value ) . intValue ( ) ; \n} \n} \nelse if ( setter . getParameterTypes ( ) [ 0 ] . isAssignableFrom ( int . class ) ) { \nif ( value instanceof Long ) { \nvalue = ( ( Long ) value ) . intValue ( ) ; \n} \n} \nsetter . invoke ( target , value ) ; \n} \ncatch ( InvocationTargetException invocationExc ) { \nthis . log . info ( \"invocation exception storing mbean results: {}={}; attributeName={}\" , identifierKey , identifier , attributeName , invocationExc ) ; \n} \ncatch ( IllegalAccessException illegalAccessExc ) { \nthis . log . info ( \"illegal access exception storing mbean results: {}={}; attributeName={}\" , identifierKey , identifier , attributeName , illegalAccessExc ) ; \n} \ncatch ( IllegalArgumentException illegalArgumentExc ) { \nthis . log . info ( \"illegal argument exception storing mbean results: {}={}; attributeName={}\" , identifierKey , identifier , attributeName , illegalArgumentExc ) ; \n} \n} \n} \n} \n"}
{"10096": "public class ClassLoaderUtils { \npublic static URL getResource ( String name , ClassLoader classLoader ) { \nValidate . notNull ( name , \"resourceName must be not null\" ) ; \nif ( name . startsWith ( \"/\" ) ) { \nname = name . substring ( 1 ) ; \n} \nif ( classLoader != null ) { \nURL url = classLoader . getResource ( name ) ; \nif ( url != null ) { \nreturn url ; \n} \n} \nClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nif ( loader != null ) { \nif ( loader != classLoader ) { \nURL url = loader . getResource ( name ) ; \nif ( url != null ) { \nreturn url ; \n} \n} \n} \nreturn ClassLoader . getSystemResource ( name ) ; \n} \n} \n"}
{"10101": "public class URI { \nprivate void initializePath ( String p_uriSpec ) throws MalformedURIException { \nif ( p_uriSpec == null ) { \nthrow new MalformedURIException ( \"Cannot initialize path from null string!\" ) ; \n} \nint index = 0 ; \nint start = 0 ; \nint end = p_uriSpec . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '?' ) { \nbreak ; \n} \nelse if ( testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) ) { \nthrow new MalformedURIException ( \"Path contains invalid escape sequence!\" ) ; \n} \nelse if ( ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Path contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) ) { \nif ( ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character: \" + testChar ) ; \n} \n} \nindex ++ ; \n} \nm_path = p_uriSpec . substring ( start , index ) ; \nif ( testChar == '?' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid escape sequence!\" ) ; \n} \nelse if ( ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) ) { \nif ( ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid character:\" + testChar ) ; \n} \n} \nindex ++ ; \n} \nm_queryString = p_uriSpec . substring ( start , index ) ; \n} \nif ( testChar == '#' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid escape sequence!\" ) ; \n} \nelse if ( ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) ) { \nif ( ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid character:\" + testChar ) ; \n} \n} \nindex ++ ; \n} \nm_fragment = p_uriSpec . substring ( start , index ) ; \n} \n} \n} \n"}
{"10103": "public class URI { \nprivate void setUserinfo ( String p_userinfo ) throws MalformedURIException { \nif ( p_userinfo == null ) { \nm_userinfo = null ; \n} \nelse { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Userinfo cannot be set when host is null!\" ) ; \n} \nint index = 0 ; \nint end = p_userinfo . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_userinfo . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid escape sequence!\" ) ; \n} \nelse if ( ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isUnreservedCharacter ( testChar ) ) { \nif ( USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid character:\" + testChar ) ; \n} \n} \nindex ++ ; \n} \n} \nm_userinfo = p_userinfo ; \n} \n} \n"}
{"10106": "public class URI { \nprivate void appendPath ( String p_addToPath ) throws MalformedURIException { \nif ( p_addToPath == null ) { \nreturn ; \n} \nelse if ( p_addToPath . length ( ) == 0 ) { \nreturn ; \n} \nif ( ! isURIString ( p_addToPath ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character!\" ) ; \n} \nif ( m_path == null || m_path . length ( ) == 0 ) { \nif ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = p_addToPath ; \n} \nelse { \nm_path = \"/\" + p_addToPath ; \n} \n} \nelse if ( m_path . endsWith ( \"/\" ) ) { \nif ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; \n} \nelse { \nm_path = m_path . concat ( p_addToPath ) ; \n} \n} \nelse { \nif ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = m_path . concat ( p_addToPath ) ; \n} \nelse { \nm_path = m_path . concat ( \"/\" + p_addToPath ) ; \n} \n} \n} \n} \n"}
{"10137": "public class ReflexUtil { \npublic static < T > void makeAccessible ( final Constructor < T > constructor ) { \nif ( ! Modifier . isPublic ( constructor . getModifiers ( ) ) ) { \nconstructor . setAccessible ( true ) ; \n} \nelse if ( ! Modifier . isPublic ( constructor . getDeclaringClass ( ) . getModifiers ( ) ) ) { \nconstructor . setAccessible ( true ) ; \n} \n} \n} \n"}
{"10142": "public class NamedParameterStatement { \nprivate static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { \nint length = sql . length ( ) ; \nStringBuffer parsedSql = new StringBuffer ( length ) ; \nboolean inSingleQuote = false ; \nboolean inDoubleQuote = false ; \nint index = 1 ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nchar c = sql . charAt ( i ) ; \nif ( inSingleQuote ) { \nif ( c == '\\'' ) { \ninSingleQuote = false ; \n} \n} \nelse if ( inDoubleQuote ) { \nif ( c == '\"' ) { \ninDoubleQuote = false ; \n} \n} \nelse { \nif ( c == '\\'' ) { \ninSingleQuote = true ; \n} \nelse if ( c == '\"' ) { \ninDoubleQuote = true ; \n} \nelse if ( c == ':' && i + 1 < length ) { \nif ( Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { \nint j = i + 2 ; \nwhile ( j < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) { \nj ++ ; \n} \nString name = sql . substring ( i + 1 , j ) ; \nc = '?' ; \ni += name . length ( ) ; \nList < Integer > indexList = nameIndexMap . get ( name ) ; \nif ( indexList == null ) { \nindexList = new LinkedList < Integer > ( ) ; \nnameIndexMap . put ( name , indexList ) ; \n} \nindexList . add ( index ) ; \nindex ++ ; \n} \n} \n} \nparsedSql . append ( c ) ; \n} \nreturn parsedSql . toString ( ) ; \n} \n} \n"}
{"10146": "public class FileExtensionFilter { \npublic boolean accept ( File pathname ) { \nString name = pathname . getName ( ) ; \nint iLastDot = name . lastIndexOf ( '.' ) ; \nString strExtension = \"\" ; \nif ( iLastDot != - 1 ) { \nif ( iLastDot != name . length ( ) - 1 ) strExtension = name . substring ( iLastDot + 1 ) ; \n} \nif ( m_rgstrIncludeExtensions != null ) { \nfor ( int i = 0 ; \ni < m_rgstrIncludeExtensions . length ; \ni ++ ) { \nif ( m_rgstrIncludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return true ; \n} \nreturn false ; \n} \nif ( m_rgstrExcludeExtensions != null ) { \nfor ( int i = 0 ; \ni < m_rgstrExcludeExtensions . length ; \ni ++ ) { \nif ( m_rgstrExcludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10153": "public class ClassUtil { \npublic static Field getDeclaredField ( Class < ? > clazz , String fieldName , boolean recursively ) { \ntry { \nreturn clazz . getDeclaredField ( fieldName ) ; \n} \ncatch ( NoSuchFieldException e ) { \nClass < ? > superClass = clazz . getSuperclass ( ) ; \nif ( superClass != null ) { \nif ( recursively ) { \nreturn getDeclaredField ( superClass , fieldName , true ) ; \n} \n} \n} \ncatch ( SecurityException e ) { \nlog . error ( \"{}\" , e . getMessage ( ) , e ) ; \n} \nreturn null ; \n} \n} \n"}
{"10154": "public class ClassUtil { \npublic static Method [ ] getDeclaredMethods ( Class < ? > clazz , boolean recursively ) { \nList < Method > methods = new LinkedList < Method > ( ) ; \nMethod [ ] declaredMethods = clazz . getDeclaredMethods ( ) ; \nCollections . addAll ( methods , declaredMethods ) ; \nClass < ? > superClass = clazz . getSuperclass ( ) ; \nif ( superClass != null ) { \nif ( recursively ) { \nMethod [ ] declaredMethodsOfSuper = getDeclaredMethods ( superClass , true ) ; \nif ( declaredMethodsOfSuper . length > 0 ) Collections . addAll ( methods , declaredMethodsOfSuper ) ; \n} \n} \nreturn methods . toArray ( new Method [ methods . size ( ) ] ) ; \n} \n} \n"}
{"10155": "public class ClassUtil { \npublic static Method getDeclaredMethod ( Class < ? > clazz , boolean recursively , String methodName , Class < ? > ... parameterTypes ) { \ntry { \nreturn clazz . getDeclaredMethod ( methodName , parameterTypes ) ; \n} \ncatch ( NoSuchMethodException e ) { \nClass < ? > superClass = clazz . getSuperclass ( ) ; \nif ( superClass != null ) { \nif ( recursively ) { \nreturn getDeclaredMethod ( superClass , true , methodName , parameterTypes ) ; \n} \n} \n} \ncatch ( SecurityException e ) { \nlog . error ( \"{}\" , e . getMessage ( ) , e ) ; \n} \nreturn null ; \n} \n} \n"}
{"10203": "public class FreeNonAnonymousVariablePredicate { \npublic boolean evaluate ( Term term ) { \nif ( term . isVar ( ) ) { \nif ( term instanceof Variable ) { \nVariable var = ( Variable ) term ; \nreturn ! var . isBound ( ) && ! var . isAnonymous ( ) ; \n} \n} \nreturn false ; \n} \n} \n"}
{"10205": "public class LexicographicalCollectionComparator { \npublic int compare ( Collection < T > c1 , Collection < T > c2 ) { \nIterator < T > i1 = c1 . iterator ( ) ; \nIterator < T > i2 = c2 . iterator ( ) ; \nwhile ( i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nT t1 = i1 . next ( ) ; \nT t2 = i2 . next ( ) ; \nint comp = comparator . compare ( t1 , t2 ) ; \nif ( comp < 0 ) { \nreturn - 1 ; \n} \nelse if ( comp > 0 ) { \nreturn 1 ; \n} \n} \nif ( ! i1 . hasNext ( ) ) { \nif ( i2 . hasNext ( ) ) { \nreturn - 1 ; \n} \n} \nif ( i1 . hasNext ( ) ) { \nif ( ! i2 . hasNext ( ) ) { \nreturn 1 ; \n} \n} \nreturn 0 ; \n} \n} \n"}
{"10217": "public class PropertyIntrospectorBase { \nprotected void setProperty ( Object callee , String property , Object value ) { \nif ( ! initialized ) { \ninitialize ( callee ) ; \n} \nMethod [ ] setterMethods = setters . get ( property ) ; \nif ( setterMethods == null ) { \nthrow new IllegalArgumentException ( \"No setter method for the property \" + property + \" exists.\" ) ; \n} \nelse if ( setterMethods . length == 0 ) { \nthrow new IllegalArgumentException ( \"No setter method for the property \" + property + \" exists.\" ) ; \n} \nMethod setterMethod = null ; \nClass valueType = ( value == null ) ? null : value . getClass ( ) ; \nif ( value == null ) { \nsetterMethod = setterMethods [ 0 ] ; \n} \nelse { \nfor ( Method method : setterMethods ) { \nClass argType = method . getParameterTypes ( ) [ 0 ] ; \nif ( argType . isAssignableFrom ( valueType ) ) { \nsetterMethod = method ; \nbreak ; \n} \nelse if ( argType . isPrimitive ( ) && ! valueType . isPrimitive ( ) && isAssignableFromPrimitive ( valueType , argType ) ) { \nsetterMethod = method ; \nbreak ; \n} \nelse if ( valueType . isPrimitive ( ) && ! argType . isPrimitive ( ) ) { \nif ( isAssignableFromPrimitive ( argType , valueType ) ) { \nsetterMethod = method ; \nbreak ; \n} \n} \n} \nif ( setterMethod == null ) { \nClass calleeType = ( callee == null ) ? null : callee . getClass ( ) ; \nthrow new IllegalArgumentException ( \"No setter method for property \" + property + \", of type, \" + calleeType + \" will accept the type of value specified, \" + valueType + \".\" ) ; \n} \n} \ntry { \nObject [ ] args = new Object [ ] { \nvalue } \n; \nsetterMethod . invoke ( callee , args ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalArgumentException ( \"The setter method for the property \" + property + \" threw an invocation target exception.\" , e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( \"The setter method for the property \" + property + \" cannot be accessed.\" , e ) ; \n} \n} \n} \n"}
{"10220": "public class PropertyIntrospectorBase { \nprivate void initialize ( Object callee ) { \nMap < String , List < Method > > settersTemp = new HashMap < String , List < Method > > ( ) ; \nMethod [ ] methods = callee . getClass ( ) . getMethods ( ) ; \nfor ( Method nextMethod : methods ) { \nString methodName = nextMethod . getName ( ) ; \nif ( methodName . startsWith ( \"get\" ) && ( methodName . length ( ) >= 4 ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 0 ) ) { \nString propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; \ngetters . put ( propertyName , nextMethod ) ; \n} \nelse if ( methodName . startsWith ( \"set\" ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) ) { \nif ( nextMethod . getParameterTypes ( ) . length == 1 ) { \nString propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; \nList < Method > setterMethodsForName = settersTemp . get ( propertyName ) ; \nif ( setterMethodsForName == null ) { \nsetterMethodsForName = new ArrayList < Method > ( ) ; \nsettersTemp . put ( propertyName , setterMethodsForName ) ; \n} \nsetterMethodsForName . add ( nextMethod ) ; \n} \n} \n} \nfor ( Map . Entry < String , List < Method > > entries : settersTemp . entrySet ( ) ) { \nString nextPropertyName = entries . getKey ( ) ; \nList < Method > nextMethodList = entries . getValue ( ) ; \nMethod [ ] methodArray = nextMethodList . toArray ( new Method [ nextMethodList . size ( ) ] ) ; \nsetters . put ( nextPropertyName , methodArray ) ; \n} \ninitialized = true ; \n} \n} \n"}
{"10248": "public class ReflectionUtils { \npublic static Set < Class > findMatchingSetters ( Class obClass , String propertyName ) { \nSet < Class > types = new HashSet < Class > ( ) ; \nString upperPropertyName = Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ; \nMethod [ ] methods = obClass . getMethods ( ) ; \nfor ( Method nextMethod : methods ) { \nString methodName = nextMethod . getName ( ) ; \nif ( methodName . equals ( \"set\" + upperPropertyName ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) ) { \nif ( nextMethod . getParameterTypes ( ) . length == 1 ) { \ntypes . add ( nextMethod . getParameterTypes ( ) [ 0 ] ) ; \n} \n} \n} \nreturn types ; \n} \n} \n"}
{"10255": "public class SchemaDefinitionImpl { \npublic void addSupportedTZ ( String tzName ) { \nif ( ! StringUtils . isBlank ( tzName ) ) { \nif ( ! tzNamesAliases . containsKey ( tzName . trim ( ) ) ) { \ntzNamesAliases . put ( tzName . trim ( ) , tzName . trim ( ) ) ; \nif ( LOG . isInfoEnabled ( ) ) { \nLOG . info ( \"Endpoint \" + this . getEndPointName ( ) + \" - add support of TZ: \" + tzName ) ; \n} \n} \n} \n} \n} \n"}
{"10273": "public class PagedList { \npublic List < E > get ( int index ) { \nint originalSize = original . size ( ) ; \nint size = ( originalSize / pageSize ) + ( ( ( originalSize % pageSize ) == 0 ) ? 0 : 1 ) ; \nif ( index == 0 ) { \nif ( originalSize == 0 ) { \nreturn new ArrayList < E > ( ) ; \n} \n} \nif ( index >= size ) { \nthrow new IndexOutOfBoundsException ( \"Index \" + index + \" is less than zero or more than the number of pages: \" + size ) ; \n} \nelse if ( index < 0 ) { \nthrow new IndexOutOfBoundsException ( \"Index \" + index + \" is less than zero or more than the number of pages: \" + size ) ; \n} \nList < E > result = original . subList ( pageSize * index , ( ( pageSize * ( index + 1 ) ) >= originalSize ) ? originalSize : ( pageSize * ( index + 1 ) ) ) ; \nreturn result ; \n} \n} \n"}
{"10277": "public class Surface { \nprotected Graphics2D createGraphics2D ( int width , int height , BufferedImage bi , Graphics g ) { \nGraphics2D g2 = null ; \nif ( bi != null ) { \ng2 = bi . createGraphics ( ) ; \n} \nelse { \ng2 = ( Graphics2D ) g ; \n} \ng2 . setBackground ( getBackground ( ) ) ; \ng2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , antiAlias ) ; \ng2 . setRenderingHint ( RenderingHints . KEY_RENDERING , rendering ) ; \nif ( clearSurface ) { \ng2 . clearRect ( 0 , 0 , width , height ) ; \nclearOnce = false ; \n} \nelse if ( clearOnce ) { \ng2 . clearRect ( 0 , 0 , width , height ) ; \nclearOnce = false ; \n} \nif ( texture != null ) { \ng2 . setComposite ( AlphaComposite . SrcOver ) ; \ng2 . setPaint ( texture ) ; \ng2 . fillRect ( 0 , 0 , width , height ) ; \n} \nif ( composite != null ) { \ng2 . setComposite ( composite ) ; \n} \nreturn g2 ; \n} \n} \n"}
{"10298": "public class TxSessionImpl { \npublic void bind ( ) { \nif ( txId == null ) { \ntxId = TxManager . createTxId ( ) ; \n} \nelse if ( ! txId . isValid ( ) ) { \ntxId = TxManager . createTxId ( ) ; \n} \nTxManager . assignTxIdToThread ( txId ) ; \nthreadSession . set ( this ) ; \n} \n} \n"}
{"10314": "public class SequentialCuckooFunction { \nprivate Entry < K > entryForKey ( K key ) { \nint keyHashCode = key . hashCode ( ) ; \nint hash1 = hash1 ( keyHashCode ) ; \nEntry < K > entry = hashTable [ indexFor ( hash1 ) ] ; \nif ( entry != null ) { \nif ( key . equals ( entry . key ) ) { \nreturn entry ; \n} \n} \nint hash2 = hash2 ( hash1 , keyHashCode ) ; \nentry = hashTable [ indexFor ( hash2 ) ] ; \nif ( entry != null ) { \nif ( key . equals ( entry . key ) ) { \nreturn entry ; \n} \n} \nreturn null ; \n} \n} \n"}
{"10315": "public class SequentialCuckooFunction { \nprivate Entry < K > cuckoo ( Entry < K > entry ) { \nEntry < K > currentEntry = entry ; \nint hash = entry . hash1 ; \nint index = indexFor ( hash ) ; \nEntry < K > nextEntry = hashTable [ index ] ; \nint previousFlag = 0 ; \nint [ ] previousIndex = new int [ 2 ] ; \nint [ ] previousSeq = new int [ 2 ] ; \nfor ( int i = 0 ; \ni < hashTableSize ; \ni ++ ) { \nif ( nextEntry == null ) { \nhashTable [ index ] = currentEntry ; \nreturn null ; \n} \nhashTable [ index ] = currentEntry ; \ncurrentEntry = nextEntry ; \nint firstPosition = indexFor ( currentEntry . hash1 ) ; \nhash = ( index == firstPosition ) ? currentEntry . hash2 : currentEntry . hash1 ; \nindex = indexFor ( hash ) ; \npreviousIndex [ previousFlag ] = index ; \npreviousSeq [ previousFlag ] = nextEntry . seq ; \npreviousFlag = ( previousFlag == 1 ) ? 0 : 1 ; \nnextEntry = hashTable [ index ] ; \nif ( ( nextEntry != null ) && ( index == previousIndex [ previousFlag ] ) ) { \nif ( nextEntry . seq == previousSeq [ previousFlag ] ) { \nbreak ; \n} \n} \n} \nreturn currentEntry ; \n} \n} \n"}
{"10339": "public class BoundedAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nQueue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; \nUnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; \nboolean beyondFringe = false ; \nminBeyondBound = Float . POSITIVE_INFINITY ; \nwhile ( ! queue . isEmpty ( ) ) { \nSearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; \nQueue < SearchNode < O , T > > successors = new LinkedList < SearchNode < O , T > > ( ) ; \nheadNode . expandSuccessors ( successors , reverseEnqueue ) ; \nfor ( SearchNode < O , T > successor : successors ) { \nfloat boundProperty = boundPropertyExtractor . getBoundProperty ( successor ) ; \nif ( boundProperty <= maxBound ) { \nqueue . offer ( successor ) ; \n} \nelse { \nbeyondFringe = true ; \nminBeyondBound = ( boundProperty < minBeyondBound ) ? boundProperty : minBeyondBound ; \n} \n} \nSearchNode < O , T > currentNode = peekAtHead ? queue . remove ( ) : headNode ; \nif ( currentNode . isExpanded ( ) ) { \nif ( goalPredicate . evaluate ( currentNode . getState ( ) ) ) { \nreturn currentNode ; \n} \n} \nif ( maxSteps > 0 ) { \nsearchSteps ++ ; \ninitSearch . setStepsTaken ( searchSteps ) ; \nif ( searchSteps >= maxSteps ) { \nif ( queue . isEmpty ( ) ) { \nreturn null ; \n} \nelse { \nthrow new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; \n} \n} \n} \n} \nif ( beyondFringe ) { \nthrow new MaxBoundException ( \"Max bound reached.\" , null ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"10348": "public class OpSymbol { \npublic void setArguments ( Term [ ] arguments ) { \nif ( ( arguments == null ) || ( arguments . length < 1 ) ) { \nthrow new IllegalArgumentException ( \"An operator has minimum 1 and maximum 2 arguments.\" ) ; \n} \nelse if ( arguments . length > 2 ) { \nthrow new IllegalArgumentException ( \"An operator has minimum 1 and maximum 2 arguments.\" ) ; \n} \nthis . arguments = arguments ; \nthis . arity = arguments . length ; \n} \n} \n"}
{"10363": "public class TimeRangeType { \npublic static Type createInstance ( String name , TimeOnly min , TimeOnly max ) { \nif ( ( min != null ) && ( max != null ) ) { \nif ( min . compareTo ( max ) > 0 ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \n} \nsynchronized ( INT_RANGE_TYPES ) { \nTimeRangeType newType = new TimeRangeType ( name , min , max ) ; \nTimeRangeType oldType = INT_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nINT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10392": "public class LoggingDiagnostic { \npublic static String currentConfiguration ( ) { \nStringBuffer rtn = new StringBuffer ( 1024 ) ; \nString loggingConfigClass = System . getProperty ( \"java.util.logging.config.class\" ) ; \nString loggingConfigFile = System . getProperty ( \"java.util.logging.config.file\" ) ; \nboolean configClassOK = false ; \nif ( loggingConfigClass == null ) { \nrtn . append ( \"No java.util.logging.config.class class is set.\\n\" ) ; \n} \nelse { \nrtn . append ( \"java.util.logging.config.class is set to '\" ) . append ( loggingConfigClass ) . append ( \"'\\n\" ) ; \ntry { \nClass c = Class . forName ( loggingConfigClass ) ; \nc . newInstance ( ) ; \nrtn . append ( \"This class was loaded and a new instance was sucessfully created.\\n\" ) ; \nconfigClassOK = true ; \n} \ncatch ( ClassNotFoundException e ) { \ne = null ; \nrtn . append ( loggingConfigClass ) . append ( \" could not be found.\" ) ; \n} \ncatch ( InstantiationException e ) { \ne = null ; \nrtn . append ( loggingConfigClass ) . append ( \" could not be instantiated.\" ) ; \n} \ncatch ( IllegalAccessException e ) { \ne = null ; \nrtn . append ( loggingConfigClass ) . append ( \" could not be accessed.\" ) ; \n} \n} \nif ( loggingConfigFile == null ) { \nrtn . append ( \"No java.util.logging.config.file file is set.\\n\" ) ; \n} \nelse { \nrtn . append ( \"java.util.logging.config.file is set to '\" ) . append ( loggingConfigFile ) . append ( \"'\\n\" ) ; \nFile loggingFile = new File ( loggingConfigFile ) ; \nrtn . append ( loggingFile . getAbsolutePath ( ) ) . append ( \"\\n\" ) ; \nif ( ! loggingFile . exists ( ) ) { \nrtn . append ( \"This file does NOT EXIST.\\n\" ) ; \n} \nelse if ( ! loggingFile . isFile ( ) ) { \nrtn . append ( \"This file does NOT EXIST.\\n\" ) ; \n} \nif ( loggingConfigClass != null ) { \nif ( configClassOK ) { \nrtn . append ( \"This file is ignored because java.util.logging.config.class is set.\\n\" ) ; \n} \n} \n} \nHandler [ ] handlers = Logger . getLogger ( \"\" ) . getHandlers ( ) ; \nlistHandlers ( handlers , rtn ) ; \nreturn rtn . toString ( ) ; \n} \n} \n"}
{"10405": "public class ErrorHandler { \npublic static void handleErrors ( Throwable exception , ActionErrors errors ) { \nlog . log ( Level . SEVERE , exception . getMessage ( ) , exception ) ; \nif ( exception . getCause ( ) == null ) { \nlog . fine ( \"Exception.getCause() is null\" ) ; \n} \nif ( exception instanceof WrappedStrutsServletException ) { \nif ( exception . getCause ( ) != null ) { \nexception = exception . getCause ( ) ; \nlog . fine ( \"Unwrapped WrappedStrutsServletException\" ) ; \n} \n} \nWriter stackTrace = new StringWriter ( ) ; \nexception . printStackTrace ( new PrintWriter ( new HTMLFilter ( stackTrace ) ) ) ; \nerrors . add ( \"exception\" , new ActionError ( \"error.general\" , stackTrace ) ) ; \nif ( exception instanceof UserReadableError ) { \nUserReadableError userError = ( UserReadableError ) exception ; \nif ( userError . isUserReadable ( ) ) { \nif ( userError . getUserMessageKey ( ) != null ) { \nerrors . add ( \"generalerror\" , new ActionError ( userError . getUserMessageKey ( ) , userError . getUserMessageKey ( ) ) ) ; \n} \nelse { \nerrors . add ( \"generalerror\" , new ActionError ( \"error.general\" , userError . getUserMessage ( ) ) ) ; \n} \nreturn ; \n} \n} \nerrors . add ( \"generalerror\" , new ActionError ( \"error.internalerror\" ) ) ; \n} \n} \n"}
{"10433": "public class BuiltInTransformVisitor { \nprotected void leaveFunctor ( Functor functor ) { \nint pos = traverser . getPosition ( ) ; \nif ( ! traverser . isInHead ( ) ) { \nif ( pos >= 0 ) { \nFunctor transformed = builtInTransform . apply ( functor ) ; \nif ( functor != transformed ) { \nBuiltInFunctor builtInFunctor = ( BuiltInFunctor ) transformed ; \nTerm parentTerm = traverser . getParentContext ( ) . getTerm ( ) ; \nif ( parentTerm instanceof Clause ) { \nClause parentClause = ( Clause ) parentTerm ; \nparentClause . getBody ( ) [ pos ] = builtInFunctor ; \n} \nelse if ( parentTerm instanceof Functor ) { \nFunctor parentFunctor = ( Functor ) parentTerm ; \nparentFunctor . getArguments ( ) [ pos ] = builtInFunctor ; \n} \n} \n} \n} \n} \n} \n"}
{"10493": "public class JsoupMicrodataDocument { \nprivate static void sanitizeRadioControls ( FormElement form ) { \nMap < String , Element > controlsByName = new HashMap < String , Element > ( ) ; \nfor ( Element control : form . elements ( ) ) { \nif ( \"radio\" . equals ( control . attr ( \"type\" ) ) ) { \nif ( control . hasAttr ( \"checked\" ) ) { \nString name = control . attr ( \"name\" ) ; \nif ( controlsByName . containsKey ( name ) ) { \ncontrolsByName . get ( name ) . attr ( \"checked\" , false ) ; \n} \ncontrolsByName . put ( name , control ) ; \n} \n} \n} \n} \n} \n"}
{"10498": "public class DateRangeType { \npublic static Type createInstance ( String name , DateOnly from , DateOnly to ) { \nif ( ( from != null ) && ( to != null ) ) { \nif ( from . compareTo ( to ) > 0 ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \n} \nsynchronized ( DATE_RANGE_TYPES ) { \nDateRangeType newType = new DateRangeType ( name , from , to ) ; \nDateRangeType oldType = DATE_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nDATE_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10501": "public class ResolutionInterpreter { \nprivate void evaluate ( Sentence < Clause > sentence ) throws SourceCodeException { \nClause clause = sentence . getT ( ) ; \nif ( clause . isQuery ( ) ) { \nengine . endScope ( ) ; \nengine . compile ( sentence ) ; \nevaluateQuery ( ) ; \n} \nelse { \nint name = clause . getHead ( ) . getName ( ) ; \nif ( currentPredicateName == null ) { \nengine . endScope ( ) ; \ncurrentPredicateName = name ; \n} \nelse if ( currentPredicateName != name ) { \nengine . endScope ( ) ; \ncurrentPredicateName = name ; \n} \naddProgramClause ( sentence ) ; \n} \n} \n} \n"}
{"10546": "public class WAMResolvingJavaMachine { \nprivate void trail ( int addr ) { \nif ( addr < hbp ) { \ndata . put ( trp , addr ) ; \ntrp ++ ; \n} \nelse if ( ( hp < addr ) && ( addr < bp ) ) { \ndata . put ( trp , addr ) ; \ntrp ++ ; \n} \n} \n} \n"}
{"10549": "public class WAMResolvingJavaMachine { \nprivate boolean unify ( int a1 , int a2 ) { \nuPush ( a1 ) ; \nuPush ( a2 ) ; \nboolean fail = false ; \nwhile ( ! uEmpty ( ) && ! fail ) { \nint d1 = deref ( uPop ( ) ) ; \nint t1 = derefTag ; \nint v1 = derefVal ; \nint d2 = deref ( uPop ( ) ) ; \nint t2 = derefTag ; \nint v2 = derefVal ; \nif ( d1 != d2 ) { \nif ( ( t1 == WAMInstruction . REF ) ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . REF ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . STR ) { \nint fn1 = data . get ( v1 ) ; \nint fn2 = data . get ( v2 ) ; \nbyte n1 = ( byte ) ( fn1 >>> 24 ) ; \nif ( fn1 == fn2 ) { \nfor ( int i = 1 ; \ni <= n1 ; \ni ++ ) { \nuPush ( v1 + i ) ; \nuPush ( v2 + i ) ; \n} \n} \nelse { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . CON ) { \nif ( t1 != WAMInstruction . CON ) { \nfail = true ; \n} \nelse if ( v1 != v2 ) { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . LIS ) { \nif ( t1 != WAMInstruction . LIS ) { \nfail = true ; \n} \nelse { \nuPush ( v1 ) ; \nuPush ( v2 ) ; \nuPush ( v1 + 1 ) ; \nuPush ( v2 + 1 ) ; \n} \n} \n} \n} \nreturn ! fail ; \n} \n} \n"}
{"10561": "public class LoggingToLog4JHandler { \nprivate String toLog4jMessage ( LogRecord record ) { \nString message = record . getMessage ( ) ; \nObject [ ] parameters = record . getParameters ( ) ; \nif ( parameters != null ) { \nif ( parameters . length != 0 ) { \nif ( ( message . indexOf ( \"{0}\" ) >= 0 ) || ( message . indexOf ( \"{1}\" ) >= 0 ) || ( message . indexOf ( \"{2}\" ) >= 0 ) ) { \nmessage = MessageFormat . format ( message , parameters ) ; \n} \nelse if ( message . indexOf ( \"{3}\" ) >= 0 ) { \nmessage = MessageFormat . format ( message , parameters ) ; \n} \n} \n} \nreturn message ; \n} \n} \n"}
{"10567": "public class WrapperQueue { \nprivate void signalOnSizeThresholdCrossing ( long oldSize , long newSize ) { \nif ( signalable != null ) { \nif ( ( oldSize >= lowWaterSizeThreshold ) && ( newSize < lowWaterSizeThreshold ) ) { \nsignalable . signalAll ( ) ; \n} \nelse if ( oldSize >= highWaterSizeThreshold ) { \nif ( newSize < highWaterSizeThreshold ) { \nsignalable . signal ( ) ; \n} \n} \n} \n} \n} \n"}
{"10588": "public class StartStopLifecycleBase { \npublic void terminated ( ) { \ntry { \nstateLock . writeLock ( ) . lock ( ) ; \nif ( state == State . Shutdown ) { \nstate = State . Terminated ; \nstateChange . signalAll ( ) ; \n} \nelse if ( state == State . Running ) { \nstate = State . Terminated ; \nstateChange . signalAll ( ) ; \n} \n} \nfinally { \nstateLock . writeLock ( ) . unlock ( ) ; \n} \n} \n} \n"}
{"10603": "public class BeanMemento { \nprivate void capture ( boolean ignoreNull ) { \nClass cls = ob . getClass ( ) ; \nMethod [ ] methods = cls . getMethods ( ) ; \nfor ( Method nextMethod : methods ) { \nString methodName = nextMethod . getName ( ) ; \nif ( methodName . startsWith ( \"get\" ) && ( methodName . length ( ) >= 4 ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) ) { \nif ( nextMethod . getParameterTypes ( ) . length == 0 ) { \nString propName = Character . toLowerCase ( methodName . charAt ( 3 ) ) + methodName . substring ( 4 ) ; \ntry { \nObject [ ] params = new Object [ ] { \n} \n; \nObject value = nextMethod . invoke ( ob , params ) ; \nif ( ! ignoreNull ) { \nvalues . put ( propName , value ) ; \n} \nelse if ( value != null ) { \nvalues . put ( propName , value ) ; \n} \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"10615": "public class OptimizeInstructions { \nprivate boolean isVoidVariable ( WAMInstruction instruction ) { \nSymbolKey symbolKey = instruction . getSymbolKeyReg1 ( ) ; \nif ( symbolKey != null ) { \nInteger count = ( Integer ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_VAR_OCCURRENCE_COUNT ) ; \nBoolean nonArgPositionOnly = ( Boolean ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_VAR_NON_ARG ) ; \nInteger allocation = ( Integer ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_ALLOCATION ) ; \nboolean singleton = ( count != null ) && count . equals ( 1 ) ; \nboolean nonArgPosition = ( nonArgPositionOnly != null ) && TRUE . equals ( nonArgPositionOnly ) ; \nboolean permanent = ( allocation != null ) && ( ( byte ) ( ( allocation & 0xff00 ) >> 8 ) == WAMInstruction . STACK_ADDR ) ; \nif ( singleton && nonArgPosition ) { \nif ( ! permanent ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10643": "public class PacketReader { \nprivate void parsePackets ( Thread thread ) { \ntry { \nwhile ( ! done ) { \nif ( reset ) { \nstartStream ( ) ; \nLOGGER . debug ( \"Started xmlstream...\" ) ; \nreset = false ; \ncontinue ; \n} \nElement doc = innerReader . parseDocument ( ) . getRootElement ( ) ; \nif ( doc == null ) { \nconnection . disconnect ( ) ; \nLOGGER . debug ( \"End of xmlstream.\" ) ; \ncontinue ; \n} \nPacket packet = null ; \nLOGGER . debug ( \"Processing packet \" + doc . asXML ( ) ) ; \npacket = parseFromPlugins ( doc , packet ) ; \nif ( packet == null ) { \npacket = parseFromCore ( doc ) ; \n} \nif ( packet != null ) { \nprocessPacket ( packet ) ; \n} \n} \n} \ncatch ( Exception e ) { \nif ( ! done ) { \nif ( ! connection . isSocketClosed ( ) ) { \nconnection . notifyConnectionError ( e ) ; \nif ( ! connection . isConnected ( ) ) { \nreleaseConnectionIDLock ( ) ; \n} \n} \n} \n} \n} \n} \n"}
{"10649": "public class InternalContent { \npublic void setProperty ( String key , Object value ) { \nif ( readOnly ) { \nreturn ; \n} \nif ( value == null ) { \nthrow new IllegalArgumentException ( \"value must not be null\" ) ; \n} \nObject o = content . get ( key ) ; \nif ( ! value . equals ( o ) ) { \nupdatedContent . put ( key , value ) ; \nupdated = true ; \n} \nelse if ( updatedContent . containsKey ( key ) ) { \nif ( ! value . equals ( updatedContent . get ( key ) ) ) { \nupdatedContent . put ( key , value ) ; \nupdated = true ; \n} \n} \n} \n} \n"}
{"10663": "public class TransactionalHashMap { \nprivate boolean validEntry ( final Entry < K , V > entry ) { \nif ( auto_commit ) return ( entry != null ) ; \nelse if ( entry == null ) return ( entry != null ) ; \nString id = getCurrentThreadId ( ) ; \nreturn ! ( ( entry . is ( Entry . DELETED , id ) ) || ( entry . is ( Entry . ADDED , null ) && entry . is ( Entry . NO_CHANGE , id ) ) ) ; \n} \n} \n"}
{"10670": "public class TransactionalHashMap { \nEntry < K , V > removeEntryForKey ( Object key ) throws ConcurrentModificationException { \nObject k = maskNull ( key ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nwhile ( e != null ) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) ) { \nif ( eq ( k , e . key ) ) { \nif ( e . is ( Entry . DELETED , null ) ) { \nif ( ! e . is ( Entry . DELETED , getCurrentThreadId ( ) ) ) throw new ConcurrentModificationException ( ) ; \n} \nif ( auto_commit ) { \nmodCount ++ ; \nsize -- ; \nif ( prev == e ) table [ i ] = next ; \nelse prev . next = next ; \nreturn e ; \n} \nelse e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \n} \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10671": "public class TransactionalHashMap { \n@ SuppressWarnings ( \"unchecked\" ) Entry < K , V > removeMapping ( Object o ) { \nif ( ! ( o instanceof Map . Entry ) ) return null ; \nMap . Entry < K , V > entry = ( Map . Entry < K , V > ) o ; \nObject k = maskNull ( entry . getKey ( ) ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nwhile ( e != null ) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) ) { \nif ( e . equals ( entry ) ) { \nif ( auto_commit ) { \nmodCount ++ ; \nsize -- ; \nif ( prev == e ) table [ i ] = next ; \nelse prev . next = next ; \n} \nelse e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \nreturn e ; \n} \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10683": "public class CommandHandler { \npublic void broadcastAvailablePlaylists ( Supplier < List < String > > availablePlaylist , Function < String , Playlist > playlistForNameFunction ) { \nif ( availablePlaylist == null ) return ; \nelse if ( playlistForNameFunction == null ) return ; \nthis . availablePlaylist = availablePlaylist ; \nthis . playlistForNameFunction = playlistForNameFunction ; \ncapabilities . setBroadcasting ( true ) ; \n} \n} \n"}
{"10691": "public class StorageClientUtils { \n@ SuppressWarnings ( \"unchecked\" ) public static < K , V > Map < K , V > getFilterMap ( Map < K , V > source , Map < K , V > modified , Set < K > include , Set < K > exclude , boolean includingRemoveProperties ) { \nif ( ( modified == null || modified . size ( ) == 0 ) && ( include == null ) ) { \nif ( exclude == null || exclude . size ( ) == 0 ) { \nif ( source instanceof ImmutableMap ) { \nreturn source ; \n} \nelse { \nreturn ImmutableMap . copyOf ( source ) ; \n} \n} \n} \nBuilder < K , V > filteredMap = new ImmutableMap . Builder < K , V > ( ) ; \nfor ( Entry < K , V > e : source . entrySet ( ) ) { \nK k = e . getKey ( ) ; \nif ( include == null ) { \nif ( exclude == null ) { \nif ( modified != null && modified . containsKey ( k ) ) { \nV o = modified . get ( k ) ; \nif ( o instanceof Map ) { \nfilteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) o , null , null , exclude , includingRemoveProperties ) ) ; \n} \nelse if ( includingRemoveProperties ) { \nfilteredMap . put ( k , o ) ; \n} \nelse if ( ! ( o instanceof RemoveProperty ) ) { \nfilteredMap . put ( k , o ) ; \n} \n} \nelse { \nObject o = e . getValue ( ) ; \nif ( o instanceof Map ) { \nfilteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) e . getValue ( ) , null , null , exclude , includingRemoveProperties ) ) ; \n} \nelse { \nfilteredMap . put ( k , e . getValue ( ) ) ; \n} \n} \n} \nelse if ( ! exclude . contains ( k ) ) { \nif ( modified != null && modified . containsKey ( k ) ) { \nV o = modified . get ( k ) ; \nif ( o instanceof Map ) { \nfilteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) o , null , null , exclude , includingRemoveProperties ) ) ; \n} \nelse if ( includingRemoveProperties ) { \nfilteredMap . put ( k , o ) ; \n} \nelse if ( ! ( o instanceof RemoveProperty ) ) { \nfilteredMap . put ( k , o ) ; \n} \n} \nelse { \nObject o = e . getValue ( ) ; \nif ( o instanceof Map ) { \nfilteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) e . getValue ( ) , null , null , exclude , includingRemoveProperties ) ) ; \n} \nelse { \nfilteredMap . put ( k , e . getValue ( ) ) ; \n} \n} \n} \n} \nelse if ( include . contains ( k ) ) { \nif ( exclude == null || ! exclude . contains ( k ) ) { \nif ( modified != null && modified . containsKey ( k ) ) { \nV o = modified . get ( k ) ; \nif ( o instanceof Map ) { \nfilteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) o , null , null , exclude , includingRemoveProperties ) ) ; \n} \nelse if ( includingRemoveProperties ) { \nfilteredMap . put ( k , o ) ; \n} \nelse if ( ! ( o instanceof RemoveProperty ) ) { \nfilteredMap . put ( k , o ) ; \n} \n} \nelse { \nObject o = e . getValue ( ) ; \nif ( o instanceof Map ) { \nfilteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) e . getValue ( ) , null , null , exclude , includingRemoveProperties ) ) ; \n} \nelse { \nfilteredMap . put ( k , e . getValue ( ) ) ; \n} \n} \n} \n} \n} \nif ( modified != null ) { \nfor ( Entry < K , V > e : modified . entrySet ( ) ) { \nK k = e . getKey ( ) ; \nif ( ! source . containsKey ( k ) ) { \nV v = e . getValue ( ) ; \nif ( ! ( v instanceof RemoveProperty ) ) { \nif ( v != null ) { \nfilteredMap . put ( k , v ) ; \n} \n} \n} \n} \n} \nreturn filteredMap . build ( ) ; \n} \n} \n"}
{"10696": "public class AbstractDao { \n@ Override public void updateOne ( E object , String ... properties ) { \nif ( object . getId ( ) == null ) { \nthrow new RuntimeException ( \"Not a Persisted entity\" ) ; \n} \nif ( properties == null ) { \nentityManager . merge ( object ) ; \nreturn ; \n} \nelse if ( properties . length == 0 ) { \nentityManager . merge ( object ) ; \nreturn ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"Update \" + clazz . getName ( ) + \" SET \" ) ; \nMap < String , Object > cache = new HashMap < String , Object > ( ) ; \nfor ( String prop : properties ) { \ntry { \nField field = object . getClass ( ) . getDeclaredField ( prop ) ; \nfield . setAccessible ( true ) ; \nObject value = field . get ( object ) ; \nif ( value instanceof Collection ) { \nthrow new RuntimeException ( \"Collection property is not suppotred.\" ) ; \n} \ncache . put ( prop , value ) ; \nif ( cache . size ( ) > 1 ) { \nsb . append ( \" ,\" ) ; \n} \nsb . append ( prop ) ; \nsb . append ( \" = :\" ) ; \nsb . append ( prop ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nif ( cache . size ( ) == 0 ) return ; \nsb . append ( \" WHERE id = \" + object . getId ( ) ) ; \nQuery query = entityManager . createQuery ( sb . toString ( ) ) ; \nfor ( Entry < String , Object > entry : cache . entrySet ( ) ) { \nquery . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nquery . executeUpdate ( ) ; \n} \n} \n"}
{"10705": "public class XMPPConnection { \nvoid startTLSReceived ( boolean required ) { \nif ( required ) { \nif ( config . getSecurityMode ( ) == ConnectionConfiguration . SecurityMode . disabled ) { \nnotifyConnectionError ( new IllegalStateException ( \"TLS required by server but not allowed by connection configuration\" ) ) ; \nreturn ; \n} \n} \nif ( config . getSecurityMode ( ) == ConnectionConfiguration . SecurityMode . disabled ) { \nreturn ; \n} \ntry { \nwriter . write ( \"<starttls xmlns=\\\"urn:ietf:params:xml:ns:xmpp-tls\\\"/>\" ) ; \nwriter . flush ( ) ; \n} \ncatch ( IOException e ) { \nnotifyConnectionError ( e ) ; \n} \n} \n} \n"}
{"10709": "public class XMPPConnection { \nsynchronized void notifyConnectionError ( Exception e ) { \nif ( packetReader == null || packetReader . done ) { \nif ( packetWriter == null || packetWriter . done ) return ; \n} \nif ( packetReader != null ) packetReader . done = true ; \nif ( packetWriter != null ) packetWriter . done = true ; \nshutdown ( new Presence ( Presence . Type . unavailable ) ) ; \nfor ( ConnectionListener listener : getConnectionListeners ( ) ) { \ntry { \nlistener . connectionClosedOnError ( e ) ; \n} \ncatch ( Exception e2 ) { \ne2 . printStackTrace ( ) ; \n} \n} \n} \n} \n"}
{"10726": "public class CachingManagerImpl { \nprotected void removeCached ( String keySpace , String columnFamily , String key ) throws StorageClientException { \nif ( sharedCache != null ) { \nfinal String cacheKey = getCacheKey ( keySpace , columnFamily , key ) ; \nputToCacheInternal ( cacheKey , new CacheHolder ( null , managerId ) , false ) ; \nLOGGER . debug ( \"Marked as deleted in Cache {} \" , cacheKey ) ; \nif ( client instanceof Disposer ) { \n( ( Disposer ) client ) . registerDisposable ( new Disposable ( ) { \n@ Override public void setDisposer ( Disposer disposer ) { \n} \n@ Override public void close ( ) { \nCacheHolder ch = sharedCache . get ( cacheKey ) ; \nif ( ch != null ) { \nif ( ch . wasLockedTo ( managerId ) ) { \nsharedCache . remove ( cacheKey ) ; \nLOGGER . debug ( \"Removed deleted marker from Cache {} \" , cacheKey ) ; \n} \n} \n} \n} \n) ; \n} \n} \nclient . remove ( keySpace , columnFamily , key ) ; \n} \n} \n"}
{"10727": "public class CachingManagerImpl { \nprotected void putCached ( String keySpace , String columnFamily , String key , Map < String , Object > encodedProperties , boolean probablyNew ) throws StorageClientException { \nString cacheKey = null ; \nif ( sharedCache != null ) { \ncacheKey = getCacheKey ( keySpace , columnFamily , key ) ; \n} \nif ( sharedCache != null ) { \nif ( ! probablyNew ) { \nCacheHolder ch = getFromCacheInternal ( cacheKey ) ; \nif ( ch != null ) { \nif ( ch . isLocked ( this . managerId ) ) { \nLOGGER . debug ( \"Is Locked {} \" , ch ) ; \nreturn ; \n} \n} \n} \n} \nLOGGER . debug ( \"Saving {} {} {} {} \" , new Object [ ] { \nkeySpace , columnFamily , key , encodedProperties } \n) ; \nclient . insert ( keySpace , columnFamily , key , encodedProperties , probablyNew ) ; \nif ( sharedCache != null ) { \nsharedCache . remove ( cacheKey ) ; \n} \n} \n} \n"}
{"10730": "public class CF_Locator { \nprivate void includeJar ( File file ) { \nif ( file . isDirectory ( ) ) { \nreturn ; \n} \nURL jarURL = null ; \nJarFile jar = null ; \ntry { \njarURL = new URL ( \"jar:\" + new URL ( \"file:/\" + file . getCanonicalPath ( ) ) . toExternalForm ( ) + \"!/\" ) ; \nJarURLConnection conn = ( JarURLConnection ) jarURL . openConnection ( ) ; \njar = conn . getJarFile ( ) ; \n} \ncatch ( MalformedURLException ignore ) { \nreturn ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \nif ( jar == null ) { \nreturn ; \n} \ntry { \nthis . locationMap . put ( jarURL . toURI ( ) , \"\" ) ; \n} \ncatch ( URISyntaxException ignore ) { \n} \nfor ( Enumeration < JarEntry > e = jar . entries ( ) ; \ne . hasMoreElements ( ) ; \n) { \nJarEntry entry = e . nextElement ( ) ; \nif ( this . pkgFilter != null ) { \nif ( entry . getName ( ) . startsWith ( this . pkgFilter ) ) { \ncontinue ; \n} \n} \nif ( entry . isDirectory ( ) ) { \nif ( entry . getName ( ) . toUpperCase ( Locale . ENGLISH ) . equals ( \"META-INF/\" ) ) { \ncontinue ; \n} \ntry { \nthis . locationMap . put ( new URI ( jarURL . toExternalForm ( ) + entry . getName ( ) ) , CF_Utils . getPkgName ( entry ) ) ; \n} \ncatch ( URISyntaxException ignore ) { \ncontinue ; \n} \n} \n} \n} \n} \n"}
{"10739": "public class EventPropertiesAssistant { \npublic void unregisterEventID ( String eventKey ) { \nproperties . remove ( eventKey + \"_DESCRIPTION\" ) ; \nproperties . remove ( eventKey ) ; \nFileOutputStream out = null ; \nBufferedReader reader = null ; \nBufferedWriter writer = null ; \ntry { \nout = new FileOutputStream ( eventPropertiesPath , true ) ; \nfinal File tempFile = new File ( eventPropertiesPath + \"temp.properties\" ) ; \nfinal BufferedReader readerFinal = new BufferedReader ( new FileReader ( eventPropertiesPath ) ) ; \nfinal BufferedWriter writerFinal = new BufferedWriter ( new FileWriter ( tempFile ) ) ; \ndoWithLock ( out . getChannel ( ) , lock -> { \nunlockedReloadFile ( ) ; \nif ( getEventID ( eventKey ) != null ) { \nreturn ; \n} \ntry { \nString currentLine = readerFinal . readLine ( ) ; \nwhile ( currentLine != null ) { \nString trimmedLine = currentLine . trim ( ) ; \nif ( trimmedLine . equals ( eventKey + \"_DESCRIPTION\" ) ) continue ; \nelse if ( trimmedLine . equals ( eventKey ) ) continue ; \nwriterFinal . write ( currentLine + System . getProperty ( \"line.separator\" ) ) ; \ncurrentLine = readerFinal . readLine ( ) ; \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n) ; \nreader = readerFinal ; \nwriter = writerFinal ; \ntempFile . renameTo ( new File ( eventPropertiesPath ) ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Unable find file\" , e ) ; \n} \nfinally { \ntry { \nif ( out != null ) { \nout . close ( ) ; \n} \nif ( writer != null ) { \nwriter . close ( ) ; \n} \nif ( reader != null ) { \nreader . close ( ) ; \n} \n} \ncatch ( IOException e ) { \nerror ( \"Unable to close lock\" , e ) ; \n} \n} \n} \n} \n"}
{"10742": "public class PlayerError { \npublic static Optional < PlayerError > createMusicPlayerError ( Identification source , String error ) { \nif ( error == null ) return Optional . empty ( ) ; \nelse if ( error . isEmpty ( ) ) return Optional . empty ( ) ; \ntry { \nPlayerError playerError = new PlayerError ( source ) ; \nplayerError . addResource ( new MusicErrorResource ( source , error ) ) ; \nreturn Optional . of ( playerError ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10743": "public class PlayerController { \npublic void startPlaying ( TrackInfo trackInfo ) { \nOptional < Identification > ownIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) ; \nOptional < Identification > playerIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( player ) ; \nif ( ! ownIdentification . isPresent ( ) ) { \nerror ( \"unable to obtain identification\" ) ; \nreturn ; \n} \nelse if ( ! playerIdentification . isPresent ( ) ) { \nerror ( \"unable to obtain identification\" ) ; \nreturn ; \n} \nStartMusicRequest . createStartMusicRequest ( ownIdentification . get ( ) , playerIdentification . get ( ) , trackInfo , player . isUsingJava ) . ifPresent ( event -> fire ( event , 5 ) ) ; \n} \n} \n"}
{"10744": "public class PlayerController { \npublic void stopPlaying ( ) { \nOptional < Identification > ownIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) ; \nOptional < Identification > playerIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( player ) ; \nif ( ! ownIdentification . isPresent ( ) ) { \nerror ( \"unable to obtain id\" ) ; \nreturn ; \n} \nelse if ( ! playerIdentification . isPresent ( ) ) { \nerror ( \"unable to obtain id\" ) ; \nreturn ; \n} \nStopMusic . createStopMusic ( ownIdentification . get ( ) , playerIdentification . get ( ) ) . ifPresent ( event -> fire ( event , 5 ) ) ; \n} \n} \n"}
{"10745": "public class PlayerController { \npublic void command ( String command , Playlist playlist , Progress progress , TrackInfo trackInfo , Volume volume ) { \nOptional < Identification > ownIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( this ) ; \nOptional < Identification > playerIdentification = IdentificationManagerM . getInstance ( ) . getIdentification ( player ) ; \nif ( ! ownIdentification . isPresent ( ) ) { \nerror ( \"unable to obtain id\" ) ; \nreturn ; \n} \nelse if ( ! playerIdentification . isPresent ( ) ) { \nerror ( \"unable to obtain id\" ) ; \nreturn ; \n} \nOptional < PlayerCommand > playerCommand = PlayerCommand . createPlayerCommand ( ownIdentification . get ( ) , playerIdentification . get ( ) , command , player . getCapabilities ( ) , getContext ( ) ) ; \nif ( playlist != null ) { \nplayerCommand . get ( ) . addResource ( new PlaylistResource ( ownIdentification . get ( ) , playlist ) ) ; \n} \nif ( progress != null ) { \nplayerCommand . get ( ) . addResource ( new ProgressResource ( ownIdentification . get ( ) , progress ) ) ; \n} \nif ( trackInfo != null ) { \nplayerCommand . get ( ) . addResource ( new TrackInfoResource ( ownIdentification . get ( ) , trackInfo ) ) ; \n} \nif ( volume != null ) { \nplayerCommand . get ( ) . addResource ( new VolumeResource ( ownIdentification . get ( ) , volume ) ) ; \n} \nfire ( playerCommand . get ( ) , 5 ) ; \n} \n} \n"}
{"10748": "public class UrlBuilder { \npublic UrlBuilder append ( boolean encode , String ... postFix ) { \nfor ( String part : postFix ) { \nif ( StringUtils . isNotBlank ( part ) ) { \nif ( url . charAt ( url . length ( ) - 1 ) != '/' ) { \nif ( ! part . startsWith ( \"/\" ) ) { \nurl . append ( '/' ) ; \n} \n} \nif ( encode ) { \ntry { \nurl . append ( URLEncoder . encode ( part , \"UTF-8\" ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \nelse { \nurl . append ( part ) ; \n} \n} \n} \nreturn this ; \n} \n} \n"}
{"10766": "public class JSONResult { \npublic String getString ( String defaultValue ) { \nif ( value instanceof String ) { \nreturn value . toString ( ) ; \n} \nelse if ( value instanceof Number ) { \nreturn value . toString ( ) ; \n} \nif ( value == null ) { \nreturn null ; \n} \nif ( value instanceof JSONArray ) { \nreturn ( ( JSONArray ) value ) . toJSONString ( ) ; \n} \nif ( value instanceof JSONObject ) { \nreturn ( ( JSONObject ) value ) . toJSONString ( ) ; \n} \nif ( value == null ) { \nreturn defaultValue ; \n} \nthrow createException ( \"Expected string:\" ) ; \n} \n} \n"}
{"10772": "public class CF { \npublic Set < Class < ? > > getSubclasses ( Class < ? > clazz ) { \nSet < Class < ? > > ret = new HashSet < Class < ? > > ( ) ; \nSet < Class < ? > > w = null ; \nif ( clazz != null ) { \nthis . clear ( ) ; \nMap < URI , String > locations = this . locator . getCfLocations ( ) ; \nfor ( Entry < URI , String > entry : locations . entrySet ( ) ) { \ntry { \nw = search ( clazz , entry . getKey ( ) , locations . get ( entry . getKey ( ) ) ) ; \nif ( w != null ) { \nif ( w . size ( ) > 0 ) { \nret . addAll ( w ) ; \n} \n} \n} \ncatch ( MalformedURLException ex ) { \n} \n} \n} \nreturn ret ; \n} \n} \n"}
{"10773": "public class CF { \npublic Set < Class < ? > > getSubclasses ( String fqcn ) { \nif ( fqcn == null ) { \nreturn new HashSet < Class < ? > > ( ) ; \n} \nelse if ( StringUtils . startsWith ( fqcn , \".\" ) ) { \nreturn new HashSet < Class < ? > > ( ) ; \n} \nelse if ( StringUtils . endsWith ( fqcn , \".\" ) ) { \nreturn new HashSet < Class < ? > > ( ) ; \n} \nClass < ? > clazz = null ; \ntry { \nclazz = Class . forName ( fqcn ) ; \n} \ncatch ( ClassNotFoundException ex ) { \nthis . clear ( ) ; \nthis . errors . add ( ex ) ; \nreturn new HashSet < Class < ? > > ( ) ; \n} \nreturn getSubclasses ( clazz ) ; \n} \n} \n"}
{"10774": "public class CF { \nprivate final Set < Class < ? > > search ( Class < ? > clazz , URI location , String packageName ) throws MalformedURLException { \nif ( clazz == null ) { \nreturn new HashSet < Class < ? > > ( ) ; \n} \nelse if ( location == null ) { \nreturn new HashSet < Class < ? > > ( ) ; \n} \nFile directory = new File ( location . toURL ( ) . getFile ( ) ) ; \nif ( directory . exists ( ) ) { \nreturn this . searchDirectory ( clazz , directory , location , packageName ) . keySet ( ) ; \n} \nelse { \nreturn this . searchJar ( clazz , location ) . keySet ( ) ; \n} \n} \n} \n"}
{"10775": "public class CF { \nprotected final Map < Class < ? > , URI > searchDirectory ( Class < ? > clazz , File directory , URI location , String packageName ) { \nMap < Class < ? > , URI > ret = new HashMap < > ( ) ; \nString [ ] files = directory . list ( ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni ++ ) { \nif ( files [ i ] . endsWith ( \".class\" ) ) { \nString classname = files [ i ] . substring ( 0 , files [ i ] . length ( ) - 6 ) ; \ntry { \nClass < ? > c = Class . forName ( packageName + \".\" + classname ) ; \nif ( clazz . isAssignableFrom ( c ) ) { \nif ( ! clazz . getName ( ) . equals ( packageName + \".\" + classname ) ) { \nret . put ( c , location ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nerrors . add ( ex ) ; \n} \n} \n} \nreturn ret ; \n} \n} \n"}
{"10776": "public class CF { \nprotected final Map < Class < ? > , URI > searchJar ( Class < ? > clazz , URI location ) { \nMap < Class < ? > , URI > ret = new HashMap < > ( ) ; \ntry { \nJarURLConnection conn = ( JarURLConnection ) location . toURL ( ) . openConnection ( ) ; \nJarFile jarFile = conn . getJarFile ( ) ; \nfor ( Enumeration < JarEntry > e = jarFile . entries ( ) ; \ne . hasMoreElements ( ) ; \n) { \nJarEntry entry = e . nextElement ( ) ; \nString entryname = entry . getName ( ) ; \nif ( this . processed . contains ( entryname ) ) { \ncontinue ; \n} \nthis . processed . add ( entryname ) ; \nif ( ! entry . isDirectory ( ) ) { \nif ( entryname . endsWith ( \".class\" ) ) { \nString classname = entryname . substring ( 0 , entryname . length ( ) - 6 ) ; \nif ( classname . startsWith ( \"/\" ) ) { \nclassname = classname . substring ( 1 ) ; \n} \nclassname = classname . replace ( '/' , '.' ) ; \nif ( ! StringUtils . startsWithAny ( classname , this . excludedNames ) ) { \ntry { \nClass < ? > c = Class . forName ( classname ) ; \nif ( clazz . isAssignableFrom ( c ) ) { \nif ( ! clazz . getName ( ) . equals ( classname ) ) { \nret . put ( c , location ) ; \n} \n} \n} \ncatch ( Exception exception ) { \nerrors . add ( exception ) ; \n} \ncatch ( Error error ) { \nerrors . add ( error ) ; \n} \n} \n} \n} \n} \n} \ncatch ( IOException ignore ) { \nerrors . add ( ignore ) ; \n} \nreturn ret ; \n} \n} \n"}
{"10779": "public class PacketCollector { \nprotected void processPacket ( Packet packet ) { \nif ( packet == null ) { \nreturn ; \n} \nif ( packetFilter == null ) { \nwhile ( ! resultQueue . offer ( packet ) ) { \nresultQueue . poll ( ) ; \n} \n} \nelse if ( packetFilter . accept ( packet ) ) { \nwhile ( ! resultQueue . offer ( packet ) ) { \nresultQueue . poll ( ) ; \n} \n} \n} \n} \n"}
{"10786": "public class RosterEntry { \npublic void setName ( String name ) { \nif ( name != null ) { \nif ( name . equals ( this . name ) ) { \nreturn ; \n} \n} \nthis . name = name ; \nRoster packet = new Roster ( ) ; \npacket . setType ( IQ . Type . set ) ; \npacket . addItem ( new JID ( user ) , name , ask , subscription , getGroupNames ( ) ) ; \nconnection . sendPacket ( packet ) ; \n} \n} \n"}
{"10791": "public class RSMUtils { \npublic static List < Identifiable > filterRSMResponse ( List < Identifiable > objects , RSM rsm ) throws IllegalArgumentException { \nString after = rsm . getAfter ( ) ; \nString before = rsm . getBefore ( ) ; \nint initialIndex = rsm . getIndex ( ) ; \nint lastIndex = objects . size ( ) ; \nif ( after != null ) { \nboolean afterItemFound = false ; \nboolean beforeItemFound = false ; \nint i = 0 ; \nfor ( Identifiable object : objects ) { \nif ( after != null ) { \nif ( after . equals ( object . getId ( ) ) ) { \ninitialIndex = i + 1 ; \nafterItemFound = true ; \n} \n} \nif ( before != null ) { \nif ( before . equals ( object . getId ( ) ) ) { \nlastIndex = i ; \nbeforeItemFound = true ; \n} \n} \ni ++ ; \n} \nif ( after != null ) { \nif ( ! afterItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \n} \nif ( before != null && ! before . isEmpty ( ) ) { \nif ( ! beforeItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \n} \n} \nelse if ( before != null && ! before . isEmpty ( ) ) { \nboolean afterItemFound = false ; \nboolean beforeItemFound = false ; \nint i = 0 ; \nfor ( Identifiable object : objects ) { \nif ( after != null && after . equals ( object . getId ( ) ) ) { \ninitialIndex = i + 1 ; \nafterItemFound = true ; \n} \nif ( before != null && before . equals ( object . getId ( ) ) ) { \nlastIndex = i ; \nbeforeItemFound = true ; \n} \ni ++ ; \n} \nif ( after != null && ! afterItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( before != null && ! before . isEmpty ( ) && ! beforeItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \n} \nif ( rsm . getMax ( ) != null ) { \nif ( before != null ) { \ninitialIndex = lastIndex - rsm . getMax ( ) ; \n} \nelse { \nlastIndex = initialIndex + rsm . getMax ( ) ; \n} \n} \nboolean outOfRange = initialIndex > lastIndex || initialIndex < 0 || lastIndex > objects . size ( ) ; \nList < Identifiable > filteredList = outOfRange ? new LinkedList < Identifiable > ( ) : objects . subList ( initialIndex , lastIndex ) ; \nrsm . setCount ( objects . size ( ) ) ; \nrsm . setIndex ( initialIndex ) ; \nif ( ! filteredList . isEmpty ( ) ) { \nrsm . setFirst ( filteredList . get ( 0 ) . getId ( ) ) ; \nrsm . setLast ( filteredList . get ( filteredList . size ( ) - 1 ) . getId ( ) ) ; \n} \nreturn filteredList ; \n} \n} \n"}
{"10793": "public class UserRoster { \npublic void reload ( ) { \nif ( ! connection . isAuthenticated ( ) ) { \nthrow new IllegalStateException ( \"Not logged in to server.\" ) ; \n} \nif ( connection . isAnonymous ( ) ) { \nthrow new IllegalStateException ( \"Anonymous users can't have a roster.\" ) ; \n} \nRoster packet = new Roster ( ) ; \nif ( rosterStore != null ) { \nif ( connection . isRosterVersioningSupported ( ) ) { \npacket . getElement ( ) . element ( \"query\" ) . addAttribute ( \"ver\" , rosterStore . getRosterVersion ( ) ) ; \nPacketFilter filter = new PacketIDFilter ( packet . getID ( ) ) ; \nconnection . addPacketListener ( new RosterResultListener ( ) , filter ) ; \n} \n} \nconnection . sendPacket ( packet ) ; \n} \n} \n"}
{"10804": "public class PropertiesAssistant { \npublic void initProperties ( ) { \npropertiesPath = getContext ( ) . getFiles ( ) . getPropertiesLocation ( ) + File . separator + getContext ( ) . getAddOns ( ) . getAddOn ( ) . getID ( ) + \".properties\" ; \nthis . propertiesFile = new File ( propertiesPath ) ; \nif ( ! this . propertiesFile . exists ( ) ) try { \nthis . propertiesFile . createNewFile ( ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Error while trying to create the new Properties file\" , e ) ; \n} \ntry { \nBufferedReader in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( this . propertiesFile ) , \"UTF8\" ) ) ; \ntry { \nproperties . load ( in ) ; \n} \ncatch ( IOException e ) { \nerror ( \"unable to load the InputStream for the PropertiesFile\" , e ) ; \n} \n} \ncatch ( FileNotFoundException | UnsupportedEncodingException e ) { \nerror ( \"Error while trying to read Properties-File\" , e ) ; \n} \nif ( defaultPropertiesPath != null ) { \nif ( new File ( defaultPropertiesPath ) . exists ( ) ) { \n@ SuppressWarnings ( \"unchecked\" ) Enumeration < String > keys = ( Enumeration < String > ) properties . propertyNames ( ) ; \nif ( ! keys . hasMoreElements ( ) ) { \ntry { \ncreateDefaultPropertyFile ( defaultPropertiesPath ) ; \n} \ncatch ( IOException e ) { \nerror ( \"Error while trying to copy the Default-Properties File\" , e ) ; \n} \nif ( new File ( defaultPropertiesPath ) . exists ( ) ) { \nif ( ! writeToPropertiesFile ( defaultPropertiesPath ) ) return ; \n} \nreloadProperties ( ) ; \n} \n} \n} \n} \n} \n"}
{"10835": "public class StopMusic { \npublic static Optional < StopMusic > createStopMusic ( Identification source , Identification target ) { \nif ( target == null ) return Optional . empty ( ) ; \nelse if ( target . equals ( source ) ) return Optional . empty ( ) ; \ntry { \nStopMusic stopRequest = new StopMusic ( source ) ; \nstopRequest . addResource ( new SelectorResource ( source , target ) ) ; \nreturn Optional . of ( stopRequest ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10844": "public class RequestUtils { \npublic static Object toValue ( String name , Object value ) { \nString [ ] parts = StringUtils . split ( name , \"@\" , 2 ) ; \nString fieldName = null ; \nString fieldType = \"String\" ; \nif ( parts . length == 2 ) { \nfieldType = parts [ 1 ] ; \nfieldName = parts [ 0 ] ; \n} \nelse if ( parts . length == 1 ) { \nfieldName = parts [ 0 ] ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Invalid property name\" ) ; \n} \ntry { \nint l = Array . getLength ( value ) ; \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nif ( ! fieldName . endsWith ( \"[]\" ) ) { \nif ( l == 1 ) { \nreturn rpt . newInstance ( Array . get ( value , 0 ) ) ; \n} \n} \nClass < ? > componentType = rpt . getComponentType ( ) ; \nObject [ ] a = ( Object [ ] ) Array . newInstance ( componentType , l ) ; \nfor ( int i = 0 ; \ni < l ; \ni ++ ) { \na [ i ] = rpt . newInstance ( Array . get ( value , i ) ) ; \n} \nreturn a ; \n} \ncatch ( IllegalArgumentException e ) { \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nreturn rpt . newInstance ( value ) ; \n} \n} \n} \n"}
{"10847": "public class TransactionalBidiTreeMap { \nprivate boolean validNode ( final Node < K , V > node , final String thread_id ) { \nif ( auto_commit ) return ( node != null ) ; \nelse if ( node == null ) return ( node != null ) ; \nreturn ! ( ( node . is ( Node . DELETED , thread_id ) ) || ( node . is ( Node . ADDED , null ) && node . is ( Node . NO_CHANGE , thread_id ) ) ) ; \n} \n} \n"}
{"10868": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackDelete ( final Node < K , V > deletedNode ) { \nfor ( int index = FIRST_INDEX ; \nindex < NUMBER_OF_INDICES ; \nindex ++ ) { \nif ( deletedNode . getLeft ( index ) != null ) { \nif ( deletedNode . getRight ( index ) != null ) { \nswapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; \n} \n} \nNode < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; \nif ( replacement != null ) { \nreplacement . setParent ( deletedNode . getParent ( index ) , index ) ; \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = replacement ; \n} \nelse if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( replacement , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( replacement , index ) ; \n} \ndeletedNode . setLeft ( null , index ) ; \ndeletedNode . setRight ( null , index ) ; \ndeletedNode . setParent ( null , index ) ; \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( replacement , index ) ; \n} \n} \nelse { \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = null ; \n} \nelse { \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( deletedNode , index ) ; \n} \nif ( deletedNode . getParent ( index ) != null ) { \nif ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( null , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( null , index ) ; \n} \ndeletedNode . setParent ( null , index ) ; \n} \n} \n} \n} \nshrink ( ) ; \n} \n} \n"}
{"10869": "public class TransactionalBidiTreeMap { \nprivate void checkNonNullComparable ( final Object o , final int index ) { \nif ( o == null ) { \nthrow new NullPointerException ( dataName [ index ] + \" cannot be null\" ) ; \n} \nif ( comparators [ index ] == null ) { \nif ( ! ( o instanceof Comparable ) ) { \nthrow new ClassCastException ( dataName [ index ] + \" must be Comparable\" ) ; \n} \n} \n} \n} \n"}
{"10887": "public class IPv4Scanner { \npublic static InetAddress subnetAddress0 ( InetAddress addr , int subnetBits ) { \nif ( subnetBits < 1 ) { \nthrow new FireRESTException ( \"Expected subnetBits 1..31\" ) ; \n} \nelse if ( 32 <= subnetBits ) { \nthrow new FireRESTException ( \"Expected subnetBits 1..31\" ) ; \n} \nlong mask = 1 ; \nfor ( int i = 0 ; \ni < 32 ; \ni ++ ) { \nmask <<= 1 ; \nmask |= i < subnetBits ? 1 : 0 ; \n} \nlong host0 = asLongAddress ( addr ) & mask ; \ntry { \nreturn asInetAddress ( host0 ) ; \n} \ncatch ( UnknownHostException e ) { \nthrow new FireRESTException ( e ) ; \n} \n} \n} \n"}
{"10890": "public class ExecS { \nprotected final void addAllApplications ( Set < Class < ? > > set ) { \nfor ( Class < ? > cls : set ) { \nif ( ! cls . isInterface ( ) ) { \nif ( ! Modifier . isAbstract ( cls . getModifiers ( ) ) ) { \nif ( ! this . classmap . containsValue ( cls ) ) { \nthis . classNames . add ( cls . getName ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"10895": "public class MuteEvent { \npublic static Optional < MuteEvent > createMuteEvent ( Identification source , Identification target ) { \nif ( target == null ) return Optional . empty ( ) ; \nelse if ( target . equals ( source ) ) return Optional . empty ( ) ; \ntry { \nMuteEvent muteRequest = new MuteEvent ( source ) ; \nmuteRequest . addResource ( new SelectorResource ( source , target ) ) ; \nreturn Optional . of ( muteRequest ) ; \n} \ncatch ( IllegalArgumentException e ) { \nreturn Optional . empty ( ) ; \n} \n} \n} \n"}
{"10912": "public class FireREST { \npublic BufferedImage errorImage ( String ... lines ) { \nif ( imageBuffer == null || imageBuffer . getWidth ( ) != imageWidth ) { \nimageBuffer = new BufferedImage ( imageWidth , imageHeight , BufferedImage . TYPE_INT_RGB ) ; \n} \nelse if ( imageBuffer . getHeight ( ) != imageHeight ) { \nimageBuffer = new BufferedImage ( imageWidth , imageHeight , BufferedImage . TYPE_INT_RGB ) ; \n} \nGraphics2D g = ( Graphics2D ) imageBuffer . getGraphics ( ) ; \ng . setBackground ( new Color ( 64 , 32 , 32 ) ) ; \ng . setColor ( new Color ( 255 , 64 , 64 ) ) ; \ng . clearRect ( 0 , 0 , imageWidth , imageHeight ) ; \nint maxLen = 0 ; \nfor ( String line : lines ) { \nif ( line != null ) { \nfor ( String innerLine : line . split ( \"\\n\" ) ) { \nmaxLen = Math . max ( innerLine . length ( ) , maxLen ) ; \n} \n} \n} \nint padding = 20 ; \nfloat sizeForWidth = 1.8f * ( imageWidth - padding - padding ) / maxLen ; \nfloat sizeForHeight = ( imageHeight - padding - padding ) / lines . length ; \nfloat lineHeight = Math . min ( 80 , Math . max ( 12 , Math . min ( sizeForWidth , sizeForHeight ) ) ) ; \nfloat fontSize = 0.8f * lineHeight ; \nFont font = g . getFont ( ) . deriveFont ( fontSize ) ; \ng . setFont ( font ) ; \nfloat y = fontSize + padding ; \nfor ( String line : lines ) { \nif ( line != null ) { \ng . drawString ( line , padding , y ) ; \ny += lineHeight ; \n} \n} \nreturn imageBuffer ; \n} \n} \n"}
{"10917": "public class WorkerThread { \n@ Override public synchronized void start ( ) { \nif ( ! running ) { \nif ( ! used ) { \nthis . running = true ; \nthis . used = true ; \nthis . setDaemon ( true ) ; \nsuper . start ( ) ; \n} \n} \n} \n} \n"}
{"10929": "public class ContentEventListener { \npublic void handleEvent ( Event event ) { \nString topic = event . getTopic ( ) ; \nLOGGER . debug ( \"Got Event {} {} \" , event , handlers ) ; \nCollection < IndexingHandler > contentIndexHandler = handlers . get ( topic ) ; \nif ( contentIndexHandler != null ) { \nif ( contentIndexHandler . size ( ) > 0 ) { \ntry { \nint ttl = Utils . toInt ( event . getProperty ( TopicIndexer . TTL ) , Integer . MAX_VALUE ) ; \nfor ( IndexingHandler indexingHandler : contentIndexHandler ) { \nif ( indexingHandler instanceof QoSIndexHandler ) { \nttl = Math . min ( ttl , Utils . defaultMax ( ( ( QoSIndexHandler ) indexingHandler ) . getTtl ( event ) ) ) ; \n} \n} \nQueueManager q = null ; \nif ( ttl < queues [ 0 ] . batchDelay ) { \nLOGGER . warn ( \"Unable to satisfy TTL of {} on event {}, posting to the highest priority queue. \" + \"If this message is logged a lot please adjust the queues or change the event ttl to something that can be satisfied. \" + \"Filling the highest priority queue is counter productive. \" , ttl , event ) ; \nqueues [ 0 ] . saveEvent ( event ) ; \n} \nelse { \nfor ( QueueManager qm : queues ) { \nif ( ttl < qm . batchDelay ) { \nq . saveEvent ( event ) ; \nq = null ; \nbreak ; \n} \nq = qm ; \n} \nif ( q != null ) { \nq . saveEvent ( event ) ; \n} \n} \n} \ncatch ( IOException e ) { \nLOGGER . warn ( e . getMessage ( ) , e ) ; \n} \n} \n} \n} \n} \n"}
{"10931": "public class Authorizable { \npublic void setProperty ( String name , Object value ) { \nif ( ! readOnly ) { \nif ( ! FILTER_PROPERTIES . contains ( name ) ) { \nObject cv = authorizableMap . get ( name ) ; \nif ( value == null ) { \nif ( cv != null ) { \nif ( ! ( cv instanceof RemoveProperty ) ) { \nmodifiedMap . put ( name , new RemoveProperty ( ) ) ; \n} \n} \n} \nelse if ( ! value . equals ( cv ) ) { \nmodifiedMap . put ( name , value ) ; \n} \nelse if ( modifiedMap . containsKey ( name ) ) { \nif ( ! value . equals ( modifiedMap . get ( name ) ) ) { \nmodifiedMap . put ( name , value ) ; \n} \n} \n} \n} \n} \n} \n"}
{"10932": "public class Authorizable { \npublic void removeProperty ( String key ) { \nif ( ! readOnly ) { \nif ( authorizableMap . containsKey ( key ) || modifiedMap . containsKey ( key ) ) { \nmodifiedMap . put ( key , new RemoveProperty ( ) ) ; \n} \n} \n} \n} \n"}
{"10933": "public class Authorizable { \npublic void addPrincipal ( String principal ) { \nif ( ! readOnly ) { \nif ( ! principals . contains ( principal ) ) { \nprincipals . add ( principal ) ; \nprincipalsModified = true ; \n} \n} \n} \n} \n"}
{"10934": "public class Authorizable { \npublic void removePrincipal ( String principal ) { \nif ( ! readOnly ) { \nif ( principals . contains ( principal ) ) { \nprincipals . remove ( principal ) ; \nprincipalsModified = true ; \n} \n} \n} \n} \n"}
{"10937": "public class PresenceNonConstant { \n@ Override public void eventFired ( EventModel event ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) ) { \nif ( event . containsDescriptor ( LeavingEvent . GENERAL_DESCRIPTOR ) ) { \npresent = false ; \nstrictPresent = false ; \n} \nelse if ( event . containsDescriptor ( LeavingEvent . STRICT_DESCRIPTOR ) ) { \nnonStrictAvailable ( ) . thenAccept ( available -> { \nif ( ! available ) present = false ; \nstrictPresent = false ; \n} \n) ; \n} \n} \nelse { \npresent = true ; \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) strictPresent = true ; \n} \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) lastSeen = LocalDateTime . now ( ) ; \n} \nelse if ( event . containsDescriptor ( PresenceEvent . ID ) ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) ) { \nif ( event . containsDescriptor ( LeavingEvent . GENERAL_DESCRIPTOR ) ) { \npresent = false ; \nstrictPresent = false ; \n} \nelse if ( event . containsDescriptor ( LeavingEvent . STRICT_DESCRIPTOR ) ) { \nnonStrictAvailable ( ) . thenAccept ( available -> { \nif ( ! available ) present = false ; \nstrictPresent = false ; \n} \n) ; \n} \n} \nelse { \npresent = true ; \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) strictPresent = true ; \n} \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) lastSeen = LocalDateTime . now ( ) ; \n} \n} \n} \n"}
{"10940": "public class AbstractHashedMap { \npublic boolean containsKey ( Object key ) { \nint hashCode = hash ( ( key == null ) ? NULL : key ) ; \nHashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; \nwhile ( entry != null ) { \nif ( entry . hashCode == hashCode ) { \nif ( isEqualKey ( key , entry . getKey ( ) ) ) { \nreturn true ; \n} \n} \nentry = entry . next ; \n} \nreturn false ; \n} \n} \n"}
{"10942": "public class AbstractHashedMap { \npublic V put ( K key , V value ) { \nint hashCode = hash ( ( key == null ) ? NULL : key ) ; \nint index = hashIndex ( hashCode , data . length ) ; \nHashEntry < K , V > entry = data [ index ] ; \nwhile ( entry != null ) { \nif ( entry . hashCode == hashCode ) { \nif ( isEqualKey ( key , entry . getKey ( ) ) ) { \nV oldValue = entry . getValue ( ) ; \nupdateEntry ( entry , value ) ; \nreturn oldValue ; \n} \n} \nentry = entry . next ; \n} \naddMapping ( index , hashCode , key , value ) ; \nreturn null ; \n} \n} \n"}
{"10950": "public class Types { \npublic static void loadFromStream ( String key , Map < String , Object > output , InputStream binaryStream , String type ) throws IOException { \nDataInputStream dis = new DataInputStream ( binaryStream ) ; \nString ckey = dis . readUTF ( ) ; \nif ( ! key . equals ( ckey ) ) { \nthrow new IOException ( \"Body Key does not match row key, unable to read\" ) ; \n} \nreadMapFromStream ( output , dis ) ; \nString cftype = null ; \ntry { \ncftype = dis . readUTF ( ) ; \n} \ncatch ( IOException e ) { \nLOGGER . debug ( \"No type specified\" ) ; \n} \nif ( cftype != null ) { \nif ( ! cftype . equals ( type ) ) { \nthrow new IOException ( \"Object is not of expected column family, unable to read expected [\" + type + \"] was [\" + cftype + \"]\" ) ; \n} \n} \nLOGGER . debug ( \"Finished Reading\" ) ; \ndis . close ( ) ; \nbinaryStream . close ( ) ; \n} \n} \n"}
