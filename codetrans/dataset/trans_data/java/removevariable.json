{"2753": "public class ContainerAnalysis { \nprotected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { \nfor ( int i = 0 ; \ni < methods . length ; \n++ i ) { \nif ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) continue ; \nOperationAnalysis oa = null ; \nfor ( int opIdx = 0 ; \noa == null && opIdx < operations . length ; \n++ opIdx ) if ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; \nif ( oa == null ) continue ; \nParameterAnalysis [ ] params = oa . getParameters ( ) ; \nStringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; \nif ( params . length == 0 ) b . append ( \"__\" ) ; \nfor ( int j = 0 ; \nj < params . length ; \n++ j ) { \nString s = params [ j ] . getTypeIDLName ( ) ; \nif ( s . startsWith ( \"::\" ) ) s = s . substring ( 2 ) ; \nif ( s . startsWith ( \"_\" ) ) { \ns = s . substring ( 1 ) ; \n} \nb . append ( '_' ) ; \nwhile ( ! \"\" . equals ( s ) ) { \nint idx = s . indexOf ( \"::\" ) ; \nb . append ( '_' ) ; \nif ( idx == - 1 ) { \nb . append ( s ) ; \ns = \"\" ; \n} \nelse { \nb . append ( s . substring ( 0 , idx ) ) ; \nif ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == '_' ) { \ns = s . substring ( idx + 3 ) ; \n} \nelse { \ns = s . substring ( idx + 2 ) ; \n} \n} \n} \n} \noa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2808": "public class ComponentDescription { \npublic void addMethodInterceptor ( MethodIdentifier method , InterceptorDescription description ) { \nList < InterceptorDescription > interceptors = methodInterceptors . get ( method ) ; \nif ( interceptors == null ) { \nmethodInterceptors . put ( method , interceptors = new ArrayList < InterceptorDescription > ( ) ) ; \n} \ninterceptors . add ( description ) ; \nthis . allInterceptors = null ; \n} \n} \n"}
{"2986": "public class OCommandExecutorSQLMoveVertex { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nODatabaseDocumentInternal db = getDatabase ( ) ; \ndb . begin ( ) ; \nif ( className == null && clusterName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \ntry { \nfinal Set < OIdentifiable > sourceRIDs = OSQLEngine . getInstance ( ) . parseRIDTarget ( db , source , context , iArgs ) ; \nfinal List < ODocument > result = new ArrayList < ODocument > ( sourceRIDs . size ( ) ) ; \nfor ( OIdentifiable from : sourceRIDs ) { \nfinal OVertex fromVertex = toVertex ( from ) ; \nif ( fromVertex == null ) continue ; \nfinal ORID oldVertex = fromVertex . getIdentity ( ) . copy ( ) ; \nfinal ORID newVertex = fromVertex . moveTo ( className , clusterName ) ; \nfinal ODocument newVertexDoc = newVertex . getRecord ( ) ; \nif ( fields != null ) { \nfor ( final OPair < String , Object > f : fields ) { \nif ( f . getValue ( ) instanceof OSQLFunctionRuntime ) f . setValue ( ( ( OSQLFunctionRuntime ) f . getValue ( ) ) . getValue ( newVertex . getRecord ( ) , null , context ) ) ; \n} \nOSQLHelper . bindParameters ( newVertexDoc , fields , new OCommandParameters ( iArgs ) , context ) ; \n} \nif ( merge != null ) newVertexDoc . merge ( merge , true , false ) ; \nnewVertexDoc . save ( ) ; \nresult . add ( new ODocument ( ) . setTrackingChanges ( false ) . field ( \"old\" , oldVertex , OType . LINK ) . field ( \"new\" , newVertex , OType . LINK ) ) ; \nif ( batch > 0 && result . size ( ) % batch == 0 ) { \ndb . commit ( ) ; \ndb . begin ( ) ; \n} \n} \ndb . commit ( ) ; \nreturn result ; \n} \nfinally { \n} \n} \n} \n"}
{"3186": "public class OSymmetricKey { \npublic static OSymmetricKey fromFile ( final String algorithm , final String path ) { \ntry { \njava . io . FileInputStream fis = null ; \ntry { \nfis = new java . io . FileInputStream ( OSystemVariableResolver . resolveSystemVariables ( path ) ) ; \nreturn fromStream ( algorithm , fis ) ; \n} \nfinally { \nif ( fis != null ) fis . close ( ) ; \n} \n} \ncatch ( Exception ex ) { \nthrow OException . wrapException ( new OSecurityException ( \"OSymmetricKey.fromFile() Exception: \" + ex . getMessage ( ) ) , ex ) ; \n} \n} \n} \n"}
{"3225": "public class OServerAdmin { \npublic synchronized OServerAdmin dropDatabase ( final String iDatabaseName , final String storageType ) throws IOException { \nODropDatabaseRequest request = new ODropDatabaseRequest ( iDatabaseName , storageType ) ; \nOURLConnection connection = OURLHelper . parse ( getURL ( ) ) ; \nOrientDBRemote remote = ( OrientDBRemote ) ODatabaseDocumentTxInternal . getOrCreateRemoteFactory ( connection . getPath ( ) ) ; \nremote . forceDatabaseClose ( iDatabaseName ) ; \nODatabaseRecordThreadLocal . instance ( ) . remove ( ) ; \nreturn this ; \n} \n} \n"}
{"3226": "public class OServerAdmin { \npublic synchronized OServerAdmin freezeDatabase ( final String storageType ) throws IOException { \nOFreezeDatabaseRequest request = new OFreezeDatabaseRequest ( storage . getName ( ) , storageType ) ; \nreturn this ; \n} \n} \n"}
{"3227": "public class OServerAdmin { \npublic synchronized OServerAdmin releaseDatabase ( final String storageType ) throws IOException { \nOReleaseDatabaseRequest request = new OReleaseDatabaseRequest ( storage . getName ( ) , storageType ) ; \nreturn this ; \n} \n} \n"}
{"3229": "public class OCommandExecutorSQLCreateIndex { \n@ SuppressWarnings ( \"rawtypes\" ) public Object execute ( final Map < Object , Object > iArgs ) { \nif ( indexName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal OIndex < ? > idx ; \nList < OCollate > collatesList = null ; \nif ( collates != null ) { \ncollatesList = new ArrayList < OCollate > ( ) ; \nfor ( String collate : collates ) { \nif ( collate != null ) { \nfinal OCollate col = OSQLEngine . getCollate ( collate ) ; \ncollatesList . add ( col ) ; \n} \nelse collatesList . add ( null ) ; \n} \n} \nif ( fields == null || fields . length == 0 ) { \nif ( keyTypes != null ) idx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new OSimpleKeyIndexDefinition ( keyTypes , collatesList ) , null , null , metadataDoc , engine ) ; \nelse if ( serializerKeyId != 0 ) { \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new ORuntimeKeyIndexDefinition ( serializerKeyId ) , null , null , metadataDoc , engine ) ; \n} \nelse { \nthrow new ODatabaseException ( \"Impossible to create an index without specify the key type or the associated property\" ) ; \n} \n} \nelse { \nif ( ( keyTypes == null || keyTypes . length == 0 ) && collates == null ) { \nidx = oClass . createIndex ( indexName , indexType . toString ( ) , null , metadataDoc , engine , fields ) ; \n} \nelse { \nfinal List < OType > fieldTypeList ; \nif ( keyTypes == null ) { \nfor ( final String fieldName : fields ) { \nif ( ! fieldName . equals ( \"@rid\" ) && ! oClass . existsProperty ( fieldName ) ) throw new OIndexException ( \"Index with name : '\" + indexName + \"' cannot be created on class : '\" + oClass . getName ( ) + \"' because field: '\" + fieldName + \"' is absent in class definition.\" ) ; \n} \nfieldTypeList = ( ( OClassImpl ) oClass ) . extractFieldTypes ( fields ) ; \n} \nelse fieldTypeList = Arrays . asList ( keyTypes ) ; \nfinal OIndexDefinition idxDef = OIndexDefinitionFactory . createIndexDefinition ( oClass , Arrays . asList ( fields ) , fieldTypeList , collatesList , indexType . toString ( ) , null ) ; \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . name ( ) , idxDef , oClass . getPolymorphicClusterIds ( ) , null , metadataDoc , engine ) ; \n} \n} \nif ( idx != null ) return idx . getSize ( ) ; \nreturn null ; \n} \n} \n"}
{"3551": "public class GeneratorConfig { \npublic String get ( Configs . Key key , String defaultVal ) { \nString val = config != null ? config . getConfig ( name , key . name ( ) ) : null ; \nif ( val == null ) { \nString fullKey = GENERATOR_PROP_PREFIX + \".\" + name + \".\" + key ; \nval = Configs . getSystemPropertyWithMavenPropertyAsFallback ( properties , fullKey ) ; \n} \nreturn val != null ? val : defaultVal ; \n} \n} \n"}
{"3559": "public class AbstractLiveEnricher { \nprotected String getExternalServiceURL ( String serviceName , String protocol ) { \nif ( ! isOnline ( ) ) { \ngetLog ( ) . info ( \"Not looking for service \" + serviceName + \" as we are in offline mode\" ) ; \nreturn null ; \n} \nelse { \ntry { \nKubernetesClient kubernetes = getKubernetes ( ) ; \nString ns = kubernetes . getNamespace ( ) ; \nif ( StringUtils . isBlank ( ns ) ) { \nns = getNamespace ( ) ; \n} \nService service = kubernetes . services ( ) . inNamespace ( ns ) . withName ( serviceName ) . get ( ) ; \nreturn service != null ? ServiceUrlUtil . getServiceURL ( kubernetes , serviceName , ns , protocol , true ) : null ; \n} \ncatch ( Throwable e ) { \nThrowable cause = e ; \nStack < Throwable > stack = unfoldExceptions ( e ) ; \nwhile ( ! stack . isEmpty ( ) ) { \nThrowable t = stack . pop ( ) ; \nif ( t instanceof ConnectException || \"No route to host\" . equals ( t . getMessage ( ) ) ) { \ngetLog ( ) . warn ( \"Cannot connect to Kubernetes to find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \nelse if ( t instanceof IllegalArgumentException || t . getMessage ( ) != null && t . getMessage ( ) . matches ( \"^No.*found.*$\" ) ) { \ngetLog ( ) . warn ( \"%s\" , cause . getMessage ( ) ) ; \nreturn null ; \n} \n; \n} \ngetLog ( ) . warn ( \"Cannot find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \n} \n} \n} \n"}
{"3939": "public class CudaMemoryManager { \n@ Override public Pointer allocate ( long bytes , MemoryKind kind , boolean initialize ) { \nif ( kind == MemoryKind . HOST ) { \nPointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocHost ( bytes , 0 ) ; \nif ( ptr == null ) throw new RuntimeException ( \"Failed to allocate \" + bytes + \" bytes from HOST memory\" ) ; \nif ( initialize ) Pointer . memset ( ptr , 0 , bytes ) ; \nreturn ptr ; \n} \nelse if ( kind == MemoryKind . DEVICE ) { \nPointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocDevice ( bytes , null , 0 ) ; \nif ( ptr == null ) throw new RuntimeException ( \"Failed to allocate \" + bytes + \" bytes from DEVICE [\" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) + \"] memory\" ) ; \nif ( initialize ) { \nCudaContext context = ( CudaContext ) AtomicAllocator . getInstance ( ) . getDeviceContext ( ) . getContext ( ) ; \nint i = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . memsetAsync ( ptr , 0 , bytes , 0 , context . getSpecialStream ( ) ) ; \nif ( i == 0 ) throw new ND4JIllegalStateException ( \"memset failed on device_\" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) ) ; \ncontext . getSpecialStream ( ) . synchronize ( ) ; \n} \nreturn ptr ; \n} \nelse throw new RuntimeException ( \"Unknown MemoryKind requested: \" + kind ) ; \n} \n} \n"}
{"3954": "public class AtomicState { \npublic void requestTick ( long time , TimeUnit timeUnit ) { \nboolean isWaiting = false ; \ntry { \nwhile ( isToeScheduled . get ( ) || isToeWaiting . get ( ) || getCurrentState ( ) == AccessState . TOE ) { \nif ( ! isWaiting ) { \nisWaiting = true ; \nwaitingTicks . incrementAndGet ( ) ; \n} \nThread . sleep ( 50 ) ; \n} \ncurrentState . set ( AccessState . TICK . ordinal ( ) ) ; \nwaitingTicks . decrementAndGet ( ) ; \ntickRequests . incrementAndGet ( ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"4352": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 ) { \nint stop = buf0 . limit ( ) ; \nint size = stop + 8 ; \nint savepos = buf0 . position ( ) ; \nassert savepos == 0 ; \nbyte [ ] bytes = new byte [ size ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . get ( bytes , 0 , stop ) ; \nbuf0 . position ( savepos ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \nbuf . position ( 0 ) ; \nbuf . limit ( size ) ; \nint i = 0 ; \ntry { \nfor ( i = 0 ; \nbuf . position ( ) < stop ; \ni ++ ) { \nsavepos = buf . position ( ) ; \nint iv = buf . getInt ( ) ; \nbuf . position ( savepos ) ; \nbuf . position ( savepos ) ; \nshort sv = buf . getShort ( ) ; \nbuf . position ( savepos ) ; \nbyte b = buf . get ( ) ; \nint ub = ( ( int ) b ) & 0x000000FF ; \nlong uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; \nint usv = ( ( int ) sv ) & 0xFFFF ; \nint ib = ( int ) b ; \nchar c = ( char ) ub ; \nString s = Character . toString ( c ) ; \nif ( c == '\\r' ) s = \"\\\\r\" ; \nelse if ( c == '\\n' ) s = \"\\\\n\" ; \nelse if ( c < ' ' || c >= 0x7f ) s = \"?\" ; \nSystem . err . printf ( \"[%03d] %02x %03d %4d '%s'\" , i , ub , ub , ib , s ) ; \nSystem . err . printf ( \"\\t%12d 0x%08x\" , iv , uiv ) ; \nSystem . err . printf ( \"\\t%5d\\t0x%04x\" , sv , usv ) ; \nSystem . err . println ( ) ; \nSystem . err . flush ( ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"failure:\" + e ) ; \n} \nfinally { \nSystem . err . flush ( ) ; \nSystem . err . flush ( ) ; \n} \n} \n} \n"}
{"4441": "public class Dap4ParserImpl { \nvoid passReserved ( XMLAttributeMap map , DapNode node ) throws ParseException { \ntry { \nfor ( Map . Entry < String , SaxEvent > entry : map . entrySet ( ) ) { \nSaxEvent event = entry . getValue ( ) ; \nString key = entry . getKey ( ) ; \nString value = event . value ; \nif ( isReserved ( key ) ) node . addXMLAttribute ( key , value ) ; \n} \n} \ncatch ( DapException de ) { \nthrow new ParseException ( de ) ; \n} \n} \n} \n"}
{"4785": "public class DSPPrinter { \nprotected void printCompoundInstance ( DataCursor datav ) throws DapException { \nDapStructure dstruct = ( DapStructure ) ( ( DapVariable ) datav . getTemplate ( ) ) . getBaseType ( ) ; \nswitch ( datav . getScheme ( ) ) { \ncase STRUCTURE : case RECORD : List < DapVariable > dfields = dstruct . getFields ( ) ; \nfor ( int f = 0 ; \nf < dfields . size ( ) ; \nf ++ ) { \nDapVariable field = dfields . get ( f ) ; \nList < Slice > fieldslices = this . ce . getConstrainedSlices ( field ) ; \nDataCursor fdata = datav . readField ( f ) ; \nprintVariable ( fdata , fieldslices ) ; \n} \nbreak ; \ncase SEQUENCE : long count = datav . getRecordCount ( ) ; \nfor ( long r = 0 ; \nr < count ; \nr ++ ) { \nDataCursor dr = datav . readRecord ( r ) ; \nprinter . marginPrint ( \"[\" ) ; \nprinter . eol ( ) ; \nprinter . indent ( ) ; \nprintCompoundInstance ( dr ) ; \nprinter . outdent ( ) ; \nprinter . marginPrint ( \"]\" ) ; \n} \nbreak ; \ndefault : throw new DapException ( \"Unexpected data cursor scheme:\" + datav . getScheme ( ) ) ; \n} \n} \n} \n"}
{"4934": "public class TextGetPutPane { \nvoid validate ( String urlString ) { \nif ( urlString == null ) return ; \nURI uri ; \ntry { \nuri = new URI ( urlString ) ; \n} \ncatch ( URISyntaxException e ) { \njavax . swing . JOptionPane . showMessageDialog ( null , \"URISyntaxException on URL (\" + urlString + \") \" + e . getMessage ( ) + \"\\n\" ) ; \nreturn ; \n} \nString contents = getText ( ) ; \ntry { \nCatalogBuilder catFactory = new CatalogBuilder ( ) ; \nboolean isValid = ! catFactory . hasFatalError ( ) ; \njavax . swing . JOptionPane . showMessageDialog ( this , \"Catalog Validation = \" + isValid + \"\\n\" + catFactory . getErrorMessage ( ) ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"5033": "public class Nc4Cursor { \nprotected Object readAtomicScalar ( VarNotes vi , TypeNotes ti ) throws DapException { \nNc4prototypes nc4 = ( ( Nc4DSP ) this . dsp ) . getJNI ( ) ; \nint ret ; \nDapType basetype = ti . getType ( ) ; \nObject result = null ; \nif ( basetype . isFixedSize ( ) ) { \nlong memsize = ( ( DapType ) ti . get ( ) ) . getSize ( ) ; \nNc4Pointer mem = Nc4Pointer . allocate ( memsize ) ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; \nsetMemory ( mem ) ; \nresult = getatomicdata ( ti . getType ( ) , 1 , mem . size , mem ) ; \n} \nelse if ( basetype . isStringType ( ) ) { \nString [ ] s = new String [ 1 ] ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var_string ( vi . gid , vi . id , s ) ) ; \nresult = s ; \n} \nelse if ( basetype . isOpaqueType ( ) ) { \nNc4Pointer mem = Nc4Pointer . allocate ( ti . getSize ( ) ) ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; \nsetMemory ( mem ) ; \nByteBuffer [ ] buf = new ByteBuffer [ 1 ] ; \nbuf [ 0 ] = mem . p . getByteBuffer ( 0 , ti . getSize ( ) ) ; \nresult = buf ; \n} \nelse throw new DapException ( \"Unexpected atomic type: \" + basetype ) ; \nreturn result ; \n} \n} \n"}
{"5117": "public class GradsDataDescriptorFile { \nprivate List < String > getFileNames ( ) throws IOException { \nif ( fileNames == null ) { \nfileNames = new ArrayList < > ( ) ; \ntimeStepsPerFile = tDim . getSize ( ) ; \nif ( ! isTemplate ( ) ) { \nfileNames . add ( getFullPath ( getDataFile ( ) ) ) ; \n} \nelse { \nList < String > fileSet = new ArrayList < > ( ) ; \nString template = getDataFile ( ) ; \nif ( GradsTimeDimension . hasTimeTemplate ( template ) ) { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TIME_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nelse { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nif ( templateType == ENS_TEMPLATE ) { \nfor ( int e = 0 ; \ne < eDim . getSize ( ) ; \ne ++ ) { \nfileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; \n} \n} \nelse if ( ( templateType == TIME_TEMPLATE ) || ( templateType == ENS_TIME_TEMPLATE ) ) { \nint numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; \nfor ( int t = 0 ; \nt < tDim . getSize ( ) ; \nt ++ ) { \nfor ( int e = 0 ; \ne < numens ; \ne ++ ) { \nString file = getFileName ( e , t ) ; \nif ( ! fileSet . contains ( file ) ) { \nfileSet . add ( file ) ; \n} \n} \n} \ntimeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; \n} \nfileNames . addAll ( fileSet ) ; \n} \nfor ( String file : fileNames ) { \nFile f = new File ( file ) ; \nif ( ! f . exists ( ) ) { \nlog . error ( \"File: \" + f + \" does not exist\" ) ; \nthrow new IOException ( \"File: \" + f + \" does not exist\" ) ; \n} \n} \n} \nreturn fileNames ; \n} \n} \n"}
{"5365": "public class NcmlCollectionReader { \nstatic public NcmlCollectionReader readNcML ( String ncmlString , Formatter errlog ) throws IOException { \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \nif ( debugURL ) System . out . println ( \" NetcdfDataset NcML String = <\" + ncmlString + \">\" ) ; \ndoc = builder . build ( new StringReader ( ncmlString ) ) ; \n} \ncatch ( JDOMException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \nif ( debugXML ) System . out . println ( \" SAXBuilder done\" ) ; \nreturn readXML ( doc , errlog , null ) ; \n} \n} \n"}
{"5438": "public class GribCdmIndex { \n@ Nullable public static GribCollectionImmutable openGribCollectionFromDataFile ( boolean isGrib1 , MFile mfile , CollectionUpdateType updateType , FeatureCollectionConfig config , Formatter errlog , org . slf4j . Logger logger ) throws IOException { \nMCollection dcm = new CollectionSingleFile ( mfile , logger ) ; \ndcm . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; \nif ( isGrib1 ) { \nGrib1CollectionBuilder builder = new Grib1CollectionBuilder ( dcm . getCollectionName ( ) , dcm , logger ) ; \n} \nelse { \nGrib2CollectionBuilder builder = new Grib2CollectionBuilder ( dcm . getCollectionName ( ) , dcm , logger ) ; \n} \nGribCollectionImmutable result = openCdmIndex ( dcm . getIndexFilename ( NCX_SUFFIX ) , config , true , logger ) ; \nif ( result != null ) return result ; \nif ( updateType == CollectionUpdateType . never ) return null ; \nif ( updateType == CollectionUpdateType . always ) return null ; \nreturn openGribCollectionFromDataFile ( isGrib1 , mfile , CollectionUpdateType . always , config , errlog , logger ) ; \n} \n} \n"}
{"5439": "public class RC { \nstatic boolean urlMatch ( URL pattern , URL url ) { \nif ( pattern == null ) return ( url == null ) ; \nif ( ! ( url . getHost ( ) . endsWith ( pattern . getHost ( ) ) ) ) return false ; \nif ( ! ( url . getPath ( ) . startsWith ( pattern . getPath ( ) ) ) ) return false ; \nif ( pattern . getPort ( ) > 0 && pattern . getPort ( ) != url . getPort ( ) ) return false ; \nreturn true ; \n} \n} \n"}
{"5443": "public class RC { \npublic boolean load ( String abspath ) { \nabspath = abspath . replace ( '\\\\' , '/' ) ; \nFile rcFile = new File ( abspath ) ; \nif ( ! rcFile . exists ( ) || ! rcFile . canRead ( ) ) { \nreturn false ; \n} \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \ntry ( BufferedReader rdr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( rcFile ) , CDM . UTF8 ) ) ) { \nfor ( int lineno = 1 ; \n; \nlineno ++ ) { \nURL url = null ; \nString line = rdr . readLine ( ) ; \nif ( line == null ) break ; \nline = line . trim ( ) ; \nif ( line . length ( ) == 0 ) continue ; \nif ( line . charAt ( 0 ) == '#' ) continue ; \nif ( line . charAt ( 0 ) == LTAG ) { \nint rindex = line . indexOf ( RTAG ) ; \nif ( rindex < 0 ) return false ; \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \nString surl = line . substring ( 1 , rindex ) ; \ntry { \nurl = new URL ( surl ) ; \n} \ncatch ( MalformedURLException mue ) { \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \n} \nline = line . substring ( rindex + 1 ) ; \nline = line . trim ( ) ; \n} \nString [ ] pieces = line . split ( \"\\\\s*=\\\\s*\" ) ; \nassert ( pieces . length == 1 || pieces . length == 2 ) ; \nString value = \"1\" ; \nif ( pieces . length == 2 ) value = pieces [ 1 ] . trim ( ) ; \nTriple triple = new Triple ( pieces [ 0 ] . trim ( ) , value , url ) ; \nList < Triple > list = triplestore . get ( triple . key ) ; \nif ( list == null ) list = new ArrayList < Triple > ( ) ; \ntriplestore . put ( triple . key , list ) ; \n} \n} \ncatch ( FileNotFoundException fe ) { \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \nreturn false ; \n} \ncatch ( IOException ioe ) { \nif ( showlog ) log . error ( \"File \" + abspath + \": IO exception: \" + ioe . getMessage ( ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"5485": "public class GempakFileReader { \npublic int getDataPointer ( int irow , int icol , String partName ) { \nint ipoint = - 1 ; \nif ( ( irow < 1 ) || ( irow > dmLabel . krow ) || ( icol < 1 ) || ( icol > dmLabel . kcol ) ) { \nSystem . out . println ( \"bad row or column number: \" + irow + \"/\" + icol ) ; \nreturn ipoint ; \n} \nint iprt = getPartNumber ( partName ) ; \nif ( iprt == 0 ) { \nSystem . out . println ( \"couldn't find part\" ) ; \nreturn ipoint ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( ( part . ktyprt != MDREAL ) && ( part . ktyprt != MDGRID ) && ( part . ktyprt != MDRPCK ) ) { \nSystem . out . println ( \"Not a valid type\" ) ; \nreturn ipoint ; \n} \nipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( icol - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nreturn ipoint ; \n} \n} \n"}
{"5520": "public class ToolsUI { \nprivate static void prepareGui ( ) { \nfinal String osName = System . getProperty ( \"os.name\" ) . toLowerCase ( ) ; \nfinal boolean isMacOs = osName . startsWith ( \"mac os x\" ) ; \nif ( isMacOs ) { \nSystem . setProperty ( \"apple.laf.useScreenMenuBar\" , \"true\" ) ; \nRuntime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { \n@ Override public void run ( ) { \ndoSavePrefsAndUI ( ) ; \n} \n} \n) ; \n} \nelse { \ntry { \nfor ( UIManager . LookAndFeelInfo info : UIManager . getInstalledLookAndFeels ( ) ) { \nif ( \"Nimbus\" . equals ( info . getName ( ) ) ) { \nUIManager . setLookAndFeel ( info . getClassName ( ) ) ; \nbreak ; \n} \n} \n} \ncatch ( Exception exc ) { \nlog . warn ( \"Unable to apply Nimbus look-and-feel due to {}\" , exc . toString ( ) ) ; \nif ( log . isTraceEnabled ( ) ) { \nexc . printStackTrace ( ) ; \n} \n} \n} \nBAMutil . setResourcePath ( \"/resources/nj22/ui/icons/\" ) ; \nSwingUtilities . invokeLater ( ( ) -> { \nfinal Toolkit tk = Toolkit . getDefaultToolkit ( ) ; \nfinal Font f = new Font ( \"SansSerif\" , Font . PLAIN , 12 ) ; \n} \n) ; \n} \n} \n"}
{"5712": "public class DapSerializer { \nprotected void writeStructure ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nwhile ( odom . hasNext ( ) ) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteStructure1 ( instance [ 0 ] , dst ) ; \n} \n} \n} \n"}
{"5714": "public class DapSerializer { \nprotected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( false ) while ( odom . hasNext ( ) ) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteSequence1 ( instance [ 0 ] , dst ) ; \n} \nelse { \nDataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; \nfor ( int i = 0 ; \ni < instances . length ; \ni ++ ) { \nwriteSequence1 ( instances [ i ] , dst ) ; \n} \n} \n} \n} \n"}
{"6312": "public class OfflineClient { \nprivate JSONObject listIndexesOfflineSync ( ) throws AlgoliaException { \ntry { \nfinal File appDir = getAppDir ( ) ; \nfinal File [ ] directories = appDir . listFiles ( new FileFilter ( ) { \n@ Override public boolean accept ( File pathname ) { \nreturn pathname . isDirectory ( ) ; \n} \n} \n) ; \nJSONObject response = new JSONObject ( ) ; \nJSONArray items = new JSONArray ( ) ; \nif ( directories != null ) { \nfor ( File directory : directories ) { \nfinal String name = directory . getName ( ) ; \nif ( hasOfflineData ( name ) ) { \nitems . put ( new JSONObject ( ) . put ( \"name\" , name ) ) ; \n} \n} \n} \nresponse . put ( \"items\" , items ) ; \nreturn response ; \n} \ncatch ( JSONException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"6397": "public class FieldEditorPropertyPage { \nprotected void applyFont ( ) { \nif ( fields != null ) { \nIterator < FieldEditor > e = fields . iterator ( ) ; \nwhile ( e . hasNext ( ) ) { \n} \n} \n} \n} \n"}
{"6460": "public class DroolsDebugTarget { \npublic DroolsLineBreakpoint getDroolsBreakpoint ( String source ) { \nif ( source == null ) { \nreturn null ; \n} \nIterator < IBreakpoint > iterator = getBreakpoints ( ) . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nIJavaBreakpoint element = ( IJavaBreakpoint ) iterator . next ( ) ; \nif ( element instanceof DroolsLineBreakpoint && ( ( DroolsLineBreakpoint ) element ) . getDialectName ( ) . equals ( \"mvel\" ) ) { \nDroolsLineBreakpoint l = ( DroolsLineBreakpoint ) element ; \ntry { \nString matchSource = l . getRuleName ( ) ; \nif ( source . equals ( matchSource ) || l . getFileRuleMappings ( ) . containsKey ( source ) ) { \nreturn l ; \n} \n} \ncatch ( CoreException e ) { \nlogError ( e ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6894": "public class SpringActionInputParameter { \n@ Override public boolean isHidden ( String property ) { \nInput inputAnnotation = methodParameter . getParameterAnnotation ( Input . class ) ; \nreturn inputAnnotation != null && arrayContains ( inputAnnotation . hidden ( ) , property ) ; \n} \n} \n"}
{"7293": "public class SortingInternal { \npublic static void sort ( List list , String sortBy , Map < String , FieldAccess > fields , boolean ascending , boolean nullsFirst ) { \ntry { \nif ( list == null || list . size ( ) == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nCollections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nCollections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \ncatch ( Exception ex ) { \nExceptions . handle ( ex , \"list\" , list , \"\\nsortBy\" , sortBy , \"fields\" , fields , \"ascending\" , ascending , \"nullFirst\" , nullsFirst ) ; \n} \n} \n} \n"}
{"7978": "public class ParserUtils { \nprotected TreeNode convert ( TreeNode parent , Node node ) { \nTreeNode treeNode = new TreeNode ( node . getNodeName ( ) , parent ) ; \nNamedNodeMap attributes = node . getAttributes ( ) ; \nif ( attributes != null ) { \nint n = attributes . getLength ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nNode attribute = attributes . item ( i ) ; \ntreeNode . addAttribute ( attribute . getNodeName ( ) , attribute . getNodeValue ( ) ) ; \n} \n} \nNodeList children = node . getChildNodes ( ) ; \nif ( children != null ) { \nint n = children . getLength ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nNode child = children . item ( i ) ; \nif ( child instanceof Comment ) continue ; \nif ( child instanceof Text ) { \nString body = ( ( Text ) child ) . getData ( ) ; \nif ( body != null ) { \nbody = body . trim ( ) ; \nif ( body . length ( ) > 0 ) treeNode . setBody ( body ) ; \n} \n} \nelse { \n} \n} \n} \nreturn ( treeNode ) ; \n} \n} \n"}
{"8037": "public class JspConfig { \npublic boolean isJspPage ( String uri ) throws JasperException { \ninit ( ) ; \nif ( jspProperties == null ) { \nreturn false ; \n} \nString uriPath = null ; \nint index = uri . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) { \nuriPath = uri . substring ( 0 , index + 1 ) ; \n} \nString uriExtension = null ; \nindex = uri . lastIndexOf ( '.' ) ; \nif ( index >= 0 ) { \nuriExtension = uri . substring ( index + 1 ) ; \n} \nfor ( JspPropertyGroup jpg : jspProperties ) { \nString extension = jpg . getExtension ( ) ; \nString path = jpg . getPath ( ) ; \nif ( extension == null ) { \nif ( uri . equals ( path ) ) { \nreturn true ; \n} \n} \nelse { \nif ( ( path == null || path . equals ( uriPath ) ) && ( extension . equals ( \"*\" ) || extension . equals ( uriExtension ) ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8384": "public class PhoneNumberAddress { \npublic static String calcMobileCity ( String mobileNumber ) throws MalformedURLException { \nString jsonString = null ; \nString urlString = \"http://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=\" + mobileNumber ; \nStringBuffer sb = new StringBuffer ( ) ; \nBufferedReader buffer ; \nURL url = new URL ( urlString ) ; \ntry { \nInputStream in = url . openStream ( ) ; \nbuffer = new BufferedReader ( new InputStreamReader ( in , \"gb2312\" ) ) ; \nString line = null ; \nwhile ( ( line = buffer . readLine ( ) ) != null ) { \nsb . append ( line ) ; \n} \nin . close ( ) ; \nbuffer . close ( ) ; \njsonString = sb . toString ( ) ; \nEntityHelper . print ( jsonString ) ; \njsonString = jsonString . replaceAll ( \"^[__]\\\\w{14}+[_ = ]+\" , \"[\" ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"9310": "public class URLStreamHandlerFactory { \n@ SuppressWarnings ( \"unused\" ) public static void preload ( ) { \nfor ( int i = 0 ; \ni < PROTOCOLS . length ; \ni ++ ) { \ntry { \nlog . trace ( \"Loaded protocol: \" + PROTOCOLS [ i ] ) ; \n} \ncatch ( Exception e ) { \nlog . warn ( \"Failed to load protocol: \" + PROTOCOLS [ i ] , e ) ; \n} \n} \n} \n} \n"}
{"9913": "public class MonomerNotationUnitRNA { \nprivate void setRNAContents ( String str ) throws NotationException { \nList < String > items = extractContents ( str ) ; \nfor ( String item : items ) { \nif ( item . length ( ) > 1 ) { \nif ( ! ( item . startsWith ( \"[\" ) && item . endsWith ( \"]\" ) ) ) { \nthrow new NotationException ( \"Monomers have to be in brackets \" + item ) ; \n} \n} \ncontents . add ( new MonomerNotationUnit ( item , type ) ) ; \n} \n} \n} \n"}
{"9935": "public class ForkJoinPool { \nprivate boolean awaitWork ( WorkQueue w , int r ) { \nif ( w == null || w . qlock < 0 ) return false ; \nfor ( int pred = w . stackPred , spins = SPINS , ss ; \n; \n) { \nif ( ( ss = w . scanState ) >= 0 ) break ; \nelse if ( spins > 0 ) { \nr ^= r << 6 ; \nr ^= r >>> 21 ; \nr ^= r << 7 ; \nif ( r >= 0 && -- spins == 0 ) { \nWorkQueue v ; \nWorkQueue [ ] ws ; \nint s , j ; \nif ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scanState >= 0 ) ) spins = SPINS ; \n} \n} \nelse if ( w . qlock < 0 ) return false ; \nelse if ( ! Thread . interrupted ( ) ) { \nlong c , prevctl , parkTime , deadline ; \nint ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; \nif ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) return false ; \nif ( ac <= 0 && ss == ( int ) c ) { \nprevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; \nint t = ( short ) ( c >>> TC_SHIFT ) ; \nif ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \nparkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; \ndeadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; \n} \nelse prevctl = parkTime = deadline = 0L ; \nThread wt = Thread . currentThread ( ) ; \nU . putObject ( wt , PARKBLOCKER , this ) ; \nw . parker = wt ; \nif ( w . scanState < 0 && ctl == c ) U . park ( false , parkTime ) ; \nU . putOrderedObject ( w , QPARKER , null ) ; \nU . putObject ( wt , PARKBLOCKER , null ) ; \nif ( w . scanState >= 0 ) break ; \nif ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10272": "public class RedirectAction { \npublic ActionForward executeWithErrorHandling ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response , ActionErrors errors ) { \nlog . fine ( \"public ActionForward performWithErrorHandling(ActionMapping mapping, ActionForm form,\" + \"HttpServletRequest request, HttpServletResponse response, \" + \"ActionErrors errors): called\" ) ; \nDynaBean dynaForm = ( DynaActionForm ) form ; \nString redirect = ( String ) dynaForm . get ( REDIRECT ) ; \nlog . fine ( \"redirect = \" + redirect ) ; \nreturn new ActionForward ( redirect , true ) ; \n} \n} \n"}
{"10462": "public class WAMResolvingMachine { \nprotected Term decodeHeap ( int start , Map < Integer , Variable > variableContext ) { \nTerm result = null ; \nbyte tag = getDerefTag ( ) ; \nint val = getDerefVal ( ) ; \nswitch ( tag ) { \ncase REF : { \nVariable var = variableContext . get ( val ) ; \nif ( var == null ) { \nvar = new Variable ( varNameId . decrementAndGet ( ) , null , false ) ; \nvariableContext . put ( val , var ) ; \n} \nresult = var ; \nbreak ; \n} \ncase STR : { \nint fn = getHeap ( val ) ; \nint f = fn & 0x00ffffff ; \nFunctorName functorName = getDeinternedFunctorName ( f ) ; \nint arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \nfor ( int i = 0 ; \ni < arity ; \ni ++ ) { \narguments [ i ] = decodeHeap ( val + 1 + i , variableContext ) ; \n} \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ncase WAMInstruction . CON : { \nint f = val & 0x3fffffff ; \nresult = new Functor ( f , null ) ; \nbreak ; \n} \ncase WAMInstruction . LIS : { \nFunctorName functorName = new FunctorName ( \"cons\" , 2 ) ; \nint f = internFunctorName ( functorName ) ; \nint arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \nfor ( int i = 0 ; \ni < arity ; \ni ++ ) { \narguments [ i ] = decodeHeap ( val + i , variableContext ) ; \n} \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ndefault : throw new IllegalStateException ( \"Encountered unknown tag type on the heap.\" ) ; \n} \nreturn result ; \n} \n} \n"}
{"10580": "public class BaseAction { \npublic ActionForward execute ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { \nlog . fine ( \"ActionForward perform(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse): called\" ) ; \nActionErrors errors = new ActionErrors ( ) ; \ntry { \nreturn executeWithErrorHandling ( mapping , form , request , response , errors ) ; \n} \ncatch ( Exception t ) { \nlog . log ( Level . WARNING , \"Caught a Throwable\" , t ) ; \nthrow new WrappedStrutsServletException ( t ) ; \n} \n} \n} \n"}
