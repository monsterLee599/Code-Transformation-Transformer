{"433": "public class ScheduledDisconnectStrategy { \nprivate void closeFreshSelectConnections ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { \nif ( null != lastSelectConnect ) { \nif ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { \nserviceOffConnections . add ( lastSelectConnect ) ; \n} \nelse { \nThread . sleep ( RETRY_DETECT_PERIOD ) ; \nif ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { \nserviceOffConnections . add ( lastSelectConnect ) ; \n} \nelse if ( logger . isInfoEnabled ( ) ) { \nlogger . info ( \"Address={} won't close at this schedule turn\" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; \n} \n} \n} \n} \n} \n"}
{"481": "public class Draft_6455 { \nprivate void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { \nint code = CloseFrame . NOCODE ; \nString reason = \"\" ; \nif ( frame instanceof CloseFrame ) { \nCloseFrame cf = ( CloseFrame ) frame ; \ncode = cf . getCloseCode ( ) ; \nreason = cf . getMessage ( ) ; \n} \nif ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) { \nwebSocketImpl . closeConnection ( code , reason , true ) ; \n} \nelse if ( getCloseHandshakeType ( ) == CloseHandshakeType . TWOWAY ) webSocketImpl . close ( code , reason , true ) ; \nelse webSocketImpl . flushAndClose ( code , reason , false ) ; \n} \n} \n"}
{"487": "public class WebSocketImpl { \npublic void decode ( ByteBuffer socketBuffer ) { \nassert ( socketBuffer . hasRemaining ( ) ) ; \nlog . trace ( \"process({}): ({})\" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? \"too big to display\" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; \nif ( readyState != ReadyState . NOT_YET_CONNECTED ) { \nif ( readyState == ReadyState . OPEN ) { \ndecodeFrames ( socketBuffer ) ; \n} \n} \nelse if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { \nassert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ; \nif ( socketBuffer . hasRemaining ( ) ) { \ndecodeFrames ( socketBuffer ) ; \n} \nelse if ( tmpHandshakeBytes . hasRemaining ( ) ) { \ndecodeFrames ( tmpHandshakeBytes ) ; \n} \n} \n} \n} \n"}
{"500": "public class AbstractWebSocket { \nprivate void executeConnectionLostDetection ( WebSocket webSocket , long minimumPongTime ) { \nif ( ! ( webSocket instanceof WebSocketImpl ) ) { \nreturn ; \n} \nWebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; \nif ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { \nlog . trace ( \"Closing connection due to no pong received: {}\" , webSocketImpl ) ; \nwebSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\" ) ; \n} \nelse if ( webSocketImpl . isOpen ( ) ) { \nwebSocketImpl . sendPing ( ) ; \n} \nelse { \nlog . trace ( \"Trying to ping a non open connection: {}\" , webSocketImpl ) ; \n} \n} \n} \n"}
{"659": "public class CodeEmitter { \npublic void cast_numeric ( Type from , Type to ) { \nif ( from != to ) { \nif ( from == Type . DOUBLE_TYPE ) { \nif ( to == Type . FLOAT_TYPE ) { \nmv . visitInsn ( Constants . D2F ) ; \n} \nelse if ( to == Type . LONG_TYPE ) { \nmv . visitInsn ( Constants . D2L ) ; \n} \nelse { \nmv . visitInsn ( Constants . D2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \n} \nelse if ( from == Type . FLOAT_TYPE ) { \nif ( to == Type . DOUBLE_TYPE ) { \nmv . visitInsn ( Constants . F2D ) ; \n} \nelse if ( to == Type . LONG_TYPE ) { \nmv . visitInsn ( Constants . F2L ) ; \n} \nelse { \nmv . visitInsn ( Constants . F2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \n} \nelse if ( from == Type . LONG_TYPE ) { \nif ( to == Type . DOUBLE_TYPE ) { \nmv . visitInsn ( Constants . L2D ) ; \n} \nelse if ( to == Type . FLOAT_TYPE ) { \nmv . visitInsn ( Constants . L2F ) ; \n} \nelse { \nmv . visitInsn ( Constants . L2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \n} \nelse if ( to == Type . BYTE_TYPE ) { \nmv . visitInsn ( Constants . I2B ) ; \n} \nelse if ( to == Type . CHAR_TYPE ) { \nmv . visitInsn ( Constants . I2C ) ; \n} \nelse if ( to == Type . DOUBLE_TYPE ) { \nmv . visitInsn ( Constants . I2D ) ; \n} \nelse if ( to == Type . FLOAT_TYPE ) { \nmv . visitInsn ( Constants . I2F ) ; \n} \nelse if ( to == Type . LONG_TYPE ) { \nmv . visitInsn ( Constants . I2L ) ; \n} \nelse if ( to == Type . SHORT_TYPE ) { \nmv . visitInsn ( Constants . I2S ) ; \n} \n} \n} \n} \n"}
{"830": "public class ActionMethodParser { \nprotected String [ ] readMethodActionPath ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) { \nString methodActionPath = annotationValues != null ? annotationValues . value ( ) : null ; \nif ( methodActionPath == null ) { \nmethodActionPath = methodName ; \n} \nelse if ( methodActionPath . equals ( Action . NONE ) ) { \nreturn ArraysUtil . array ( null , null ) ; \n} \nfor ( String path : actionConfig . getActionMethodNames ( ) ) { \nif ( methodActionPath . equals ( path ) ) { \nmethodActionPath = null ; \nbreak ; \n} \n} \nreturn ArraysUtil . array ( methodName , methodActionPath ) ; \n} \n} \n"}
{"935": "public class ResultMapper { \nprotected String resolveAlias ( final String value ) { \nfinal StringBuilder result = new StringBuilder ( value . length ( ) ) ; \nint i = 0 ; \nint len = value . length ( ) ; \nwhile ( i < len ) { \nint ndx = value . indexOf ( '<' , i ) ; \nif ( ndx == - 1 ) { \nif ( i == 0 ) { \nString alias = lookupAlias ( value ) ; \nreturn ( alias != null ? alias : value ) ; \n} \nelse { \nresult . append ( value . substring ( i ) ) ; \n} \nbreak ; \n} \nresult . append ( value . substring ( i , ndx ) ) ; \nndx ++ ; \nint ndx2 = value . indexOf ( '>' , ndx ) ; \nString aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; \nString alias = lookupAlias ( aliasName ) ; \nif ( alias != null ) { \nresult . append ( alias ) ; \n} \nelse if ( log . isWarnEnabled ( ) ) { \nlog . warn ( \"Alias not found: \" + aliasName ) ; \n} \ni = ndx2 + 1 ; \n} \ni = 0 ; \nlen = result . length ( ) ; \nwhile ( i < len ) { \nif ( result . charAt ( i ) != '/' ) { \nbreak ; \n} \ni ++ ; \n} \nif ( i > 1 ) { \nreturn result . substring ( i - 1 , len ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"943": "public class DbMetaUtil { \npublic static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { \nString columnName = null ; \nboolean isId = false ; \nClass < ? extends SqlType > sqlTypeClass = null ; \nDbId dbId = null ; \nif ( property . getFieldDescriptor ( ) != null ) { \ndbId = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbId . class ) ; \n} \nif ( dbId == null && property . getReadMethodDescriptor ( ) != null ) { \ndbId = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; \n} \nif ( dbId == null && property . getWriteMethodDescriptor ( ) != null ) { \ndbId = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; \n} \nif ( dbId != null ) { \ncolumnName = dbId . value ( ) . trim ( ) ; \nsqlTypeClass = dbId . sqlType ( ) ; \nisId = true ; \n} \nelse { \nDbColumn dbColumn = null ; \nif ( property . getFieldDescriptor ( ) != null ) { \ndbColumn = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbColumn . class ) ; \n} \nif ( dbColumn == null && property . getReadMethodDescriptor ( ) != null ) { \ndbColumn = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; \n} \nif ( dbColumn == null && property . getWriteMethodDescriptor ( ) != null ) { \ndbColumn = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; \n} \nif ( dbColumn != null ) { \ncolumnName = dbColumn . value ( ) . trim ( ) ; \nsqlTypeClass = dbColumn . sqlType ( ) ; \n} \nelse if ( isAnnotated ) { \nreturn null ; \n} \n} \nif ( StringUtil . isEmpty ( columnName ) ) { \ncolumnName = columnNamingStrategy . convertPropertyNameToColumnName ( property . getName ( ) ) ; \n} \nelse if ( ! columnNamingStrategy . isStrictAnnotationNames ( ) ) { \ncolumnName = columnNamingStrategy . applyToColumnName ( columnName ) ; \n} \nif ( sqlTypeClass == SqlType . class ) { \nsqlTypeClass = null ; \n} \nreturn new DbEntityColumnDescriptor ( dbEntityDescriptor , quoteIfRequired ( columnName , columnNamingStrategy . isAlwaysQuoteNames ( ) , columnNamingStrategy . getQuoteChar ( ) ) , property . getName ( ) , property . getType ( ) , isId , sqlTypeClass ) ; \n} \n} \n"}
{"1058": "public class BaseLoggableStatement { \npublic String getQueryString ( ) { \nif ( sqlTemplate == null ) { \nreturn toString ( ) ; \n} \nif ( parameterValues == null ) { \nreturn sqlTemplate ; \n} \nfinal StringBuilder sb = new StringBuilder ( ) ; \nint qMarkCount = 0 ; \nfinal StringTokenizer tok = new StringTokenizer ( sqlTemplate + ' ' , \"?\" ) ; \nwhile ( tok . hasMoreTokens ( ) ) { \nfinal String oneChunk = tok . nextToken ( ) ; \nsb . append ( oneChunk ) ; \ntry { \nObject value = null ; \nif ( parameterValues . size ( ) > 1 + qMarkCount ) { \nvalue = parameterValues . get ( 1 + qMarkCount ) ; \nqMarkCount ++ ; \n} \nelse if ( ! tok . hasMoreTokens ( ) ) { \nvalue = \"\" ; \n} \nif ( value == null ) { \nvalue = \"?\" ; \n} \nsb . append ( value ) ; \n} \ncatch ( Throwable th ) { \nsb . append ( \"--- Building query failed: \" ) . append ( th . toString ( ) ) ; \n} \n} \nreturn sb . toString ( ) . trim ( ) ; \n} \n} \n"}
{"1108": "public class StringUtil { \npublic static String findCommonPrefix ( final String ... strings ) { \nStringBuilder prefix = new StringBuilder ( ) ; \nint index = 0 ; \nchar c = 0 ; \nloop : while ( true ) { \nfor ( int i = 0 ; \ni < strings . length ; \ni ++ ) { \nString s = strings [ i ] ; \nif ( index == s . length ( ) ) { \nbreak loop ; \n} \nif ( i == 0 ) { \nc = s . charAt ( index ) ; \n} \nelse if ( s . charAt ( index ) != c ) { \nbreak loop ; \n} \n} \nindex ++ ; \nprefix . append ( c ) ; \n} \nreturn prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; \n} \n} \n"}
{"1126": "public class GzipResponseStream { \n@ Override public void close ( ) throws IOException { \nif ( closed ) { \nreturn ; \n} \nif ( gzipstream != null ) { \nflushToGZip ( ) ; \ngzipstream . close ( ) ; \ngzipstream = null ; \n} \nelse if ( bufferCount > 0 ) { \noutput . write ( buffer , 0 , bufferCount ) ; \nbufferCount = 0 ; \n} \noutput . close ( ) ; \nclosed = true ; \n} \n} \n"}
{"1228": "public class Label { \nfinal void put ( final ByteVector code , final int sourceInsnBytecodeOffset , final boolean wideReference ) { \nif ( ( flags & FLAG_RESOLVED ) == 0 ) { \nif ( wideReference ) { \naddForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_WIDE , code . length ) ; \ncode . putInt ( - 1 ) ; \n} \nelse { \naddForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_SHORT , code . length ) ; \ncode . putShort ( - 1 ) ; \n} \n} \nelse if ( wideReference ) { \ncode . putInt ( bytecodeOffset - sourceInsnBytecodeOffset ) ; \n} \nelse { \ncode . putShort ( bytecodeOffset - sourceInsnBytecodeOffset ) ; \n} \n} \n} \n"}
{"1329": "public class HttpBrowser { \nprotected HttpResponse _sendRequest ( final HttpRequest httpRequest , final HttpResponse previouseResponse ) { \nif ( ! keepAlive ) { \nhttpRequest . open ( httpConnectionProvider ) ; \n} \nelse if ( previouseResponse == null ) { \nhttpRequest . open ( httpConnectionProvider ) . connectionKeepAlive ( true ) ; \n} \nelse { \nhttpRequest . keepAlive ( previouseResponse , true ) ; \n} \nreturn httpRequest . send ( ) ; \n} \n} \n"}
{"1449": "public class JsonParser { \nprotected Number parseNumber ( ) { \nfinal int startIndex = ndx ; \nchar c = input [ ndx ] ; \nboolean isDouble = false ; \nboolean isExp = false ; \nif ( c == '-' ) { \nndx ++ ; \n} \nwhile ( true ) { \nif ( isEOF ( ) ) { \nbreak ; \n} \nc = input [ ndx ] ; \nif ( c >= '0' && c <= '9' ) { \nndx ++ ; \ncontinue ; \n} \nif ( c <= 32 ) { \nbreak ; \n} \nif ( c == ',' || c == '}' || c == ']' ) { \nbreak ; \n} \nif ( c == '.' ) { \nisDouble = true ; \n} \nelse if ( c == 'e' || c == 'E' ) { \nisExp = true ; \n} \nndx ++ ; \n} \nfinal String value = new String ( input , startIndex , ndx - startIndex ) ; \nif ( isDouble ) { \nreturn Double . valueOf ( value ) ; \n} \nlong longNumber ; \nif ( isExp ) { \nlongNumber = Double . valueOf ( value ) . longValue ( ) ; \n} \nelse if ( value . length ( ) >= 19 ) { \nBigInteger bigInteger = new BigInteger ( value ) ; \nif ( isGreaterThanLong ( bigInteger ) ) { \nreturn bigInteger ; \n} \nlongNumber = bigInteger . longValue ( ) ; \n} \nelse { \nlongNumber = Long . parseLong ( value ) ; \n} \nif ( ( longNumber >= Integer . MIN_VALUE ) && ( longNumber <= Integer . MAX_VALUE ) ) { \nreturn ( int ) longNumber ; \n} \nreturn longNumber ; \n} \n} \n"}
{"1678": "public class ExtendedURLClassLoader { \nprotected Loading resolveLoading ( final boolean parentFirstStrategy , final String className ) { \nboolean withParent = true ; \nboolean withLoader = true ; \nif ( parentFirstStrategy ) { \nif ( isMatchingRules ( className , loaderOnlyRules ) ) { \nwithParent = false ; \n} \nelse if ( isMatchingRules ( className , parentOnlyRules ) ) { \nwithLoader = false ; \n} \n} \nelse if ( isMatchingRules ( className , parentOnlyRules ) ) { \nwithLoader = false ; \n} \nelse if ( isMatchingRules ( className , loaderOnlyRules ) ) { \nwithParent = false ; \n} \nreturn new Loading ( withParent , withLoader ) ; \n} \n} \n"}
{"1697": "public class SocketHttpConnectionProvider { \nprotected SSLSocket createSSLSocket ( final String host , final int port , final int connectionTimeout , final boolean trustAll , final boolean verifyHttpsHost ) throws IOException { \nfinal SocketFactory socketFactory = getSocketFactory ( proxy , true , trustAll , connectionTimeout ) ; \nfinal Socket socket ; \nif ( connectionTimeout < 0 ) { \nsocket = socketFactory . createSocket ( host , port ) ; \n} \nelse { \nsocket = Sockets . connect ( host , port , connectionTimeout ) ; \n} \nSSLSocket sslSocket ; \nif ( socket instanceof SSLSocket ) { \nsslSocket = ( SSLSocket ) socket ; \n} \nelse if ( socketFactory instanceof SSLSocketFactory ) { \nsslSocket = ( SSLSocket ) ( ( SSLSocketFactory ) socketFactory ) . createSocket ( socket , host , port , true ) ; \n} \nelse { \nsslSocket = ( SSLSocket ) ( getDefaultSSLSocketFactory ( trustAll ) ) . createSocket ( socket , host , port , true ) ; \n} \nif ( secureEnabledProtocols != null ) { \nfinal String [ ] values = StringUtil . splitc ( secureEnabledProtocols , ',' ) ; \nStringUtil . trimAll ( values ) ; \nsslSocket . setEnabledProtocols ( values ) ; \n} \nif ( verifyHttpsHost ) { \nfinal SSLParameters sslParams = new SSLParameters ( ) ; \nsslParams . setEndpointIdentificationAlgorithm ( \"HTTPS\" ) ; \nsslSocket . setSSLParameters ( sslParams ) ; \n} \nreturn sslSocket ; \n} \n} \n"}
{"1771": "public class GzipFilter { \nprotected boolean isGzipEligible ( final HttpServletRequest request ) { \nif ( requestParameterName . length ( ) != 0 ) { \nString forceGzipString = request . getParameter ( requestParameterName ) ; \nif ( forceGzipString != null ) { \nreturn Converter . get ( ) . toBooleanValue ( forceGzipString , false ) ; \n} \n} \nString uri = request . getRequestURI ( ) ; \nif ( uri == null ) { \nreturn false ; \n} \nuri = uri . toLowerCase ( ) ; \nboolean result = false ; \nif ( matches == null ) { \nif ( extensions == null ) { \nreturn true ; \n} \nString extension = FileNameUtil . getExtension ( uri ) ; \nif ( extension . length ( ) > 0 ) { \nextension = extension . toLowerCase ( ) ; \nif ( StringUtil . equalsOne ( extension , extensions ) != - 1 ) { \nresult = true ; \n} \n} \n} \nelse if ( wildcards ) { \nresult = Wildcard . matchPathOne ( uri , matches ) != - 1 ; \n} \nelse { \nfor ( String match : matches ) { \nif ( uri . contains ( match ) ) { \nresult = true ; \nbreak ; \n} \n} \n} \nif ( ( result ) && ( excludes != null ) ) { \nif ( wildcards ) { \nif ( Wildcard . matchPathOne ( uri , excludes ) != - 1 ) { \nresult = false ; \n} \n} \nelse { \nfor ( String exclude : excludes ) { \nif ( uri . contains ( exclude ) ) { \nresult = false ; \nbreak ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"1776": "public class Vtor { \nprotected boolean matchProfiles ( final String [ ] checkProfiles ) { \nif ( ( checkProfiles != null ) && ( checkProfiles . length == 1 ) && checkProfiles [ 0 ] . equals ( ALL_PROFILES ) ) { \nreturn true ; \n} \nif ( enabledProfiles == null || enabledProfiles . isEmpty ( ) ) { \nif ( validateAllProfilesByDefault ) { \nreturn true ; \n} \nif ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) { \nreturn true ; \n} \nfor ( String profile : checkProfiles ) { \nif ( StringUtil . isEmpty ( profile ) ) { \nreturn true ; \n} \nif ( profile . equals ( DEFAULT_PROFILE ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nif ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) { \nreturn enabledProfiles . contains ( DEFAULT_PROFILE ) ; \n} \nboolean result = false ; \nfor ( String profile : checkProfiles ) { \nboolean b = true ; \nboolean must = false ; \nif ( StringUtil . isEmpty ( profile ) ) { \nprofile = DEFAULT_PROFILE ; \n} \nelse if ( profile . charAt ( 0 ) == '-' ) { \nprofile = profile . substring ( 1 ) ; \nb = false ; \n} \nelse if ( profile . charAt ( 0 ) == '+' ) { \nprofile = profile . substring ( 1 ) ; \nmust = true ; \n} \nif ( enabledProfiles . contains ( profile ) ) { \nif ( ! b ) { \nreturn false ; \n} \nresult = true ; \n} \nelse if ( must ) { \nreturn false ; \n} \n} \nreturn result ; \n} \n} \n"}
{"2257": "public class OmniturePollingConsumer { \npublic void getReport ( int reportId ) throws InterruptedException , ExecutionException , TimeoutException , IOException , StageException { \nint waitTime = 1000 ; \nResponse response = null ; \nwhile ( ! stop ) { \nfinal AsyncInvoker asyncInvoker = getResource . request ( ) . header ( WSSE_HEADER , OmnitureAuthUtil . getHeader ( username . get ( ) , sharedSecret . get ( ) ) ) . async ( ) ; \nLOG . debug ( \"Getting report using URL {} with report ID {}\" , getResource . getUri ( ) . toURL ( ) . toString ( ) , reportId ) ; \nfinal Future < Response > responseFuture = asyncInvoker . post ( Entity . json ( \"{ \\\"reportID\\\": \" + reportId + \" }\" ) ) ; \nresponse = responseFuture . get ( responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nString input = response . readEntity ( String . class ) ; \nObjectMapper mapper = new ObjectMapper ( ) ; \nJsonNode root = mapper . readTree ( input ) ; \nif ( ! root . has ( \"error\" ) ) { \nboolean accepted = entityQueue . offer ( input , responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; \nif ( ! accepted ) { \nLOG . warn ( \"Response buffer full, dropped record.\" ) ; \n} \nbreak ; \n} \nelse if ( root . get ( \"error\" ) . textValue ( ) . equals ( \"report_not_ready\" ) ) { \nwaitTime *= 2 ; \nLOG . info ( \"Report not available. Sleeping for {} seconds\" , waitTime / 1000 ) ; \nThread . sleep ( waitTime ) ; \n} \nelse { \nthrow new StageException ( Errors . OMNITURE_02 , root . get ( \"error\" ) . get ( \"error_description\" ) . asText ( ) ) ; \n} \n} \nresponse . close ( ) ; \n} \n} \n"}
{"2603": "public class JaxrsMethodParameterProcessor { \nprivate Class checkParamType ( Type genParamType , final Method method , final int paramPos , final ClassLoader classLoader ) { \nClass paramClazz = null ; \nif ( genParamType instanceof ParameterizedType ) { \nParameterizedType pType = ( ParameterizedType ) genParamType ; \nType [ ] actualTypeArgs = pType . getActualTypeArguments ( ) ; \nif ( actualTypeArgs . length == 1 ) { \ntry { \nparamClazz = classLoader . loadClass ( actualTypeArgs [ 0 ] . getTypeName ( ) ) ; \n} \ncatch ( Exception ee ) { \nJAXRS_LOGGER . classIntrospectionFailure ( ee . getClass ( ) . getName ( ) , ee . getMessage ( ) ) ; \n} \n} \n} \nelse { \nClass < ? > [ ] paramArr = method . getParameterTypes ( ) ; \nif ( paramArr [ paramPos ] . isArray ( ) ) { \nClass compClazz = paramArr [ paramPos ] . getComponentType ( ) ; \nif ( ! compClazz . isPrimitive ( ) ) { \nparamClazz = compClazz ; \n} \n} \nelse if ( ! paramArr [ paramPos ] . isPrimitive ( ) ) { \nparamClazz = paramArr [ paramPos ] ; \n} \n} \nreturn paramClazz ; \n} \n} \n"}
{"2703": "public class CNNameParser { \nprivate static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { \nint len = str . length ( ) ; \nVector components = new Vector ( 10 ) ; \nchar [ ] id = new char [ len ] ; \nchar [ ] kind = new char [ len ] ; \nint idCount , kindCount ; \nboolean idMode ; \nfor ( int i = 0 ; \ni < len ; \n) { \nidCount = kindCount = 0 ; \nidMode = true ; \nwhile ( i < len ) { \nif ( str . charAt ( i ) == compSeparator ) { \nbreak ; \n} \nelse if ( str . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; \n} \nelse if ( isMeta ( str . charAt ( i + 1 ) ) ) { \n++ i ; \nif ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; \n} \n} \nelse if ( idMode && str . charAt ( i ) == kindSeparator ) { \n++ i ; \nidMode = false ; \n} \nelse if ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \ncomponents . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; \nif ( i < len ) { \n++ i ; \n} \n} \nreturn components ; \n} \n} \n"}
{"2733": "public class PersistenceUnitServiceHandler { \nprivate static void addPuService ( final DeploymentPhaseContext phaseContext , final ArrayList < PersistenceUnitMetadataHolder > puList , final boolean startEarly , final Platform platform ) throws DeploymentUnitProcessingException { \nif ( puList . size ( ) > 0 ) { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nfinal EEModuleDescription eeModuleDescription = deploymentUnit . getAttachment ( org . jboss . as . ee . component . Attachments . EE_MODULE_DESCRIPTION ) ; \nfinal ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; \nfinal ModuleClassLoader classLoader = module . getClassLoader ( ) ; \nfor ( PersistenceUnitMetadataHolder holder : puList ) { \nsetAnnotationIndexes ( holder , deploymentUnit ) ; \nfor ( PersistenceUnitMetadata pu : holder . getPersistenceUnits ( ) ) { \nString jpaContainerManaged = pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_MANAGED ) ; \nboolean deployPU = ( jpaContainerManaged == null ? true : Boolean . parseBoolean ( jpaContainerManaged ) ) ; \nif ( deployPU ) { \nfinal PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = getPersistenceProviderDeploymentHolder ( deploymentUnit ) ; \nfinal PersistenceProvider provider = lookupProvider ( pu , persistenceProviderDeploymentHolder , deploymentUnit ) ; \nfinal PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor ( pu , persistenceProviderDeploymentHolder , deploymentUnit , provider , platform ) ; \nfinal boolean twoPhaseBootStrapCapable = ( adaptor instanceof TwoPhaseBootstrapCapable ) && Configuration . allowTwoPhaseBootstrap ( pu ) ; \nif ( startEarly ) { \nif ( twoPhaseBootStrapCapable ) { \ndeployPersistenceUnitPhaseOne ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , adaptor ) ; \n} \nelse if ( false == Configuration . needClassFileTransformer ( pu ) ) { \nROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is configured to not need class transformer to be set, no class rewriting will be allowed\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) ) ; \n} \nelse { \nfinal boolean allowCdiBeanManagerAccess = false ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \n} \nelse if ( twoPhaseBootStrapCapable ) { \ndeployPersistenceUnitPhaseTwo ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor ) ; \n} \nelse if ( false == Configuration . needClassFileTransformer ( pu ) ) { \nfinal boolean allowCdiBeanManagerAccess = true ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \n} \nelse { \nROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is not container managed (%s is set to false)\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) , Configuration . JPA_CONTAINER_MANAGED ) ; \n} \n} \n} \n} \n} \n} \n"}
{"2783": "public class DsXmlParser { \n@ Override protected Credential parseCredential ( XMLStreamReader reader ) throws XMLStreamException , ParserException , ValidateException { \nString userName = null ; \nString password = null ; \nString securityDomain = null ; \nboolean elytronEnabled = false ; \nString authenticationContext = null ; \nwhile ( reader . hasNext ( ) ) { \nswitch ( reader . nextTag ( ) ) { \ncase END_ELEMENT : { \nif ( DataSource . Tag . forName ( reader . getLocalName ( ) ) == DataSource . Tag . SECURITY || Recovery . Tag . forName ( reader . getLocalName ( ) ) == Recovery . Tag . RECOVER_CREDENTIAL ) { \nreturn new CredentialImpl ( userName , password , elytronEnabled ? authenticationContext : securityDomain , elytronEnabled , null ) ; \n} \nelse if ( Credential . Tag . forName ( reader . getLocalName ( ) ) == Credential . Tag . UNKNOWN ) { \nthrow new ParserException ( bundle . unexpectedEndTag ( reader . getLocalName ( ) ) ) ; \n} \nbreak ; \n} \ncase START_ELEMENT : { \nswitch ( Credential . Tag . forName ( reader . getLocalName ( ) ) ) { \ncase PASSWORD : { \npassword = elementAsString ( reader ) ; \nif ( propertyResolver != null && password != null ) { \nString resolvedPassword = propertyResolver . resolve ( password ) ; \nif ( resolvedPassword != null ) password = resolvedPassword ; \n} \nbreak ; \n} \ncase USER_NAME : { \nuserName = elementAsString ( reader ) ; \nbreak ; \n} \ncase SECURITY_DOMAIN : { \nsecurityDomain = elementAsString ( reader ) ; \nbreak ; \n} \ncase ELYTRON_ENABLED : { \nBoolean value = elementAsBoolean ( reader ) ; \nelytronEnabled = value == null ? true : value ; \nbreak ; \n} \ncase AUTHENTICATION_CONTEXT : { \nauthenticationContext = elementAsString ( reader ) ; \nbreak ; \n} \ndefault : throw new ParserException ( bundle . unexpectedElement ( reader . getLocalName ( ) ) ) ; \n} \nbreak ; \n} \n} \n} \nthrow new ParserException ( bundle . unexpectedEndOfDocument ( ) ) ; \n} \n} \n"}
{"2823": "public class ContextNames { \npublic static BindInfo bindInfoForEnvEntry ( String app , String module , String comp , boolean useCompNamespace , final String envEntryName ) { \nif ( envEntryName . startsWith ( \"java:\" ) ) { \nif ( useCompNamespace ) { \nreturn bindInfoFor ( app , module , comp , envEntryName ) ; \n} \nelse if ( envEntryName . startsWith ( \"java:comp\" ) ) { \nreturn bindInfoFor ( app , module , module , \"java:module\" + envEntryName . substring ( \"java:comp\" . length ( ) ) ) ; \n} \nelse { \nreturn bindInfoFor ( app , module , module , envEntryName ) ; \n} \n} \nelse if ( useCompNamespace ) { \nreturn bindInfoFor ( app , module , comp , \"java:comp/env/\" + envEntryName ) ; \n} \nelse { \nreturn bindInfoFor ( app , module , module , \"java:module/env/\" + envEntryName ) ; \n} \n} \n} \n"}
{"2924": "public class OSelectExecutionPlanner { \nprivate boolean handleClassWithIndexForSortOnly ( OSelectExecutionPlan plan , OIdentifier queryTarget , Set < String > filterClusters , QueryPlanningInfo info , OCommandContext ctx , boolean profilingEnabled ) { \nOSchema schema = getSchemaFromContext ( ctx ) ; \nOClass clazz = schema . getClass ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nclazz = schema . getView ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nthrow new OCommandExecutionException ( \"Class not found: \" + queryTarget ) ; \n} \n} \nfor ( OIndex idx : clazz . getIndexes ( ) . stream ( ) . filter ( i -> i . supportsOrderedIterations ( ) ) . filter ( i -> i . getDefinition ( ) != null ) . collect ( Collectors . toList ( ) ) ) { \nList < String > indexFields = idx . getDefinition ( ) . getFields ( ) ; \nif ( indexFields . size ( ) < info . orderBy . getItems ( ) . size ( ) ) { \ncontinue ; \n} \nboolean indexFound = true ; \nString orderType = null ; \nfor ( int i = 0 ; \ni < info . orderBy . getItems ( ) . size ( ) ; \ni ++ ) { \nOOrderByItem orderItem = info . orderBy . getItems ( ) . get ( i ) ; \nif ( orderItem . getCollate ( ) != null ) { \nreturn false ; \n} \nString indexField = indexFields . get ( i ) ; \nif ( i == 0 ) { \norderType = orderItem . getType ( ) ; \n} \nelse if ( orderType == null || ! orderType . equals ( orderItem . getType ( ) ) ) { \nindexFound = false ; \nbreak ; \n} \nif ( ! ( indexField . equals ( orderItem . getAlias ( ) ) || isInOriginalProjection ( indexField , orderItem . getAlias ( ) ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( indexFound && orderType != null ) { \nplan . chain ( new FetchFromIndexValuesStep ( idx , orderType . equals ( OOrderByItem . ASC ) , ctx , profilingEnabled ) ) ; \nint [ ] filterClusterIds = null ; \nif ( filterClusters != null ) { \nfilterClusterIds = filterClusters . stream ( ) . map ( name -> ctx . getDatabase ( ) . getClusterIdByName ( name ) ) . mapToInt ( i -> i ) . toArray ( ) ; \n} \nplan . chain ( new GetValueFromIndexEntryStep ( ctx , filterClusterIds , profilingEnabled ) ) ; \nif ( info . serverToClusters . size ( ) == 1 ) { \ninfo . orderApplied = true ; \n} \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2979": "public class ONative { \npublic int getOpenFilesLimit ( boolean verbose , int recommended , int defLimit ) { \nif ( Platform . isLinux ( ) ) { \nfinal OCLibrary . Rlimit rlimit = new OCLibrary . Rlimit ( ) ; \nfinal int result = C_LIBRARY . getrlimit ( OCLibrary . RLIMIT_NOFILE , rlimit ) ; \nif ( result == 0 && rlimit . rlim_cur > 0 ) { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Detected limit of amount of simultaneously open files is %d, \" + \" limit of open files for disk cache will be set to %d\" , rlimit . rlim_cur , rlimit . rlim_cur / 2 - 512 ) ; \n} \nif ( rlimit . rlim_cur < recommended ) { \nOLogManager . instance ( ) . warnNoDb ( this , \"Value of limit of simultaneously open files is too small, recommended value is %d\" , recommended ) ; \n} \nreturn ( int ) rlimit . rlim_cur / 2 - 512 ; \n} \nelse if ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Can not detect value of limit of open files.\" ) ; \n} \n} \nelse if ( Platform . isWindows ( ) ) { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Windows OS is detected, %d limit of open files will be set for the disk cache.\" , recommended ) ; \n} \nreturn recommended ; \n} \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Default limit of open files (%d) will be used.\" , defLimit ) ; \n} \nreturn defLimit ; \n} \n} \n"}
{"3035": "public class OCommandExecutorSQLCreateCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( clusterName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal int clusterId = database . getClusterIdByName ( clusterName ) ; \nif ( clusterId > - 1 ) throw new OCommandSQLParsingException ( \"Cluster '\" + clusterName + \"' already exists\" ) ; \nif ( blob ) { \nif ( requestedId == - 1 ) { \nreturn database . addBlobCluster ( clusterName ) ; \n} \nelse { \nthrow new OCommandExecutionException ( \"Request id not supported by blob cluster creation.\" ) ; \n} \n} \nelse if ( requestedId == - 1 ) { \nreturn database . addCluster ( clusterName ) ; \n} \nelse { \nreturn database . addCluster ( clusterName , requestedId , null ) ; \n} \n} \n} \n"}
{"3076": "public class ODirtyManager { \nprivate static Set < ORecord > mergeSet ( Set < ORecord > target , Set < ORecord > source ) { \nif ( source != null ) { \nif ( target == null ) { \nreturn source ; \n} \nelse if ( target . size ( ) > source . size ( ) ) { \ntarget . addAll ( source ) ; \nreturn target ; \n} \nelse { \nsource . addAll ( target ) ; \nreturn source ; \n} \n} \nelse { \nreturn target ; \n} \n} \n} \n"}
{"3149": "public class ODistributedResponseManagerImpl { \nprivate boolean computeQuorumResponse ( boolean reachedTimeout ) { \nif ( quorumResponse != null ) return true ; \nif ( groupResponsesByResult ) { \nfor ( List < ODistributedResponse > group : responseGroups ) { \nif ( group . size ( ) >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( ODistributedResponse r : group ) { \nif ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { \nfinal Object payload = r . getPayload ( ) ; \nif ( payload instanceof Throwable ) { \nif ( payload instanceof ODistributedRecordLockedException ) break ; \nif ( payload instanceof OConcurrentCreateException ) break ; \n} \nelse if ( ++ responsesForQuorum >= quorum ) { \nsetQuorumResponse ( r ) ; \nreturn true ; \n} \n} \n} \n} \n} \n} \nelse if ( receivedResponses >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { \nif ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && ++ responsesForQuorum >= quorum ) { \nODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; \nif ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3159": "public class OStringParser { \npublic static int indexOfOutsideStrings ( final String iText , final char iToFind , int iFrom , int iTo ) { \nif ( iTo == - 1 ) iTo = iText . length ( ) - 1 ; \nif ( iFrom == - 1 ) iFrom = iText . length ( ) - 1 ; \nchar c ; \nchar stringChar = ' ' ; \nboolean escape = false ; \nfinal StringBuilder buffer = new StringBuilder ( 1024 ) ; \nint i = iFrom ; \nwhile ( true ) { \nc = iText . charAt ( i ) ; \nif ( ! escape && c == '\\\\' && ( ( i + 1 ) < iText . length ( ) ) ) { \nif ( iText . charAt ( i + 1 ) == 'u' ) { \ni = readUnicode ( iText , i + 2 , buffer ) ; \n} \nelse escape = true ; \n} \nelse { \nif ( c == '\\'' || c == '\"' ) { \nif ( stringChar == ' ' ) { \nstringChar = c ; \n} \nelse if ( ! escape && c == stringChar ) stringChar = ' ' ; \n} \nif ( c == iToFind && stringChar == ' ' ) return i ; \nif ( escape ) escape = false ; \n} \nif ( iFrom < iTo ) { \nif ( ++ i > iTo ) break ; \n} \nelse if ( -- i < iFrom ) break ; \n} \nreturn - 1 ; \n} \n} \n"}
{"3207": "public class OrientVertex { \n@ Override public Iterable < Vertex > getVertices ( final Direction iDirection , final String ... iLabels ) { \nsetCurrentGraphInThreadLocal ( ) ; \nOrientBaseGraph . getEdgeClassNames ( getGraph ( ) , iLabels ) ; \nOrientBaseGraph . encodeClassNames ( iLabels ) ; \nfinal ODocument doc = getRecord ( ) ; \nfinal OMultiCollectionIterator < Vertex > iterable = new OMultiCollectionIterator < Vertex > ( ) ; \nfor ( OTriple < String , Direction , String > connectionField : getConnectionFields ( iDirection , iLabels ) ) { \nString fieldName = connectionField . getKey ( ) ; \nOPair < Direction , String > connection = connectionField . getValue ( ) ; \nfinal Object fieldValue = doc . rawField ( fieldName ) ; \nif ( fieldValue != null ) if ( fieldValue instanceof OIdentifiable ) { \naddSingleVertex ( doc , iterable , fieldName , connection , fieldValue , iLabels ) ; \n} \nelse if ( fieldValue instanceof Collection < ? > ) { \nCollection < ? > coll = ( Collection < ? > ) fieldValue ; \nif ( coll . size ( ) == 1 ) { \nif ( coll instanceof ORecordLazyMultiValue ) addSingleVertex ( doc , iterable , fieldName , connection , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) . next ( ) , iLabels ) ; \nelse if ( coll instanceof List < ? > ) addSingleVertex ( doc , iterable , fieldName , connection , ( ( List < ? > ) coll ) . get ( 0 ) , iLabels ) ; \nelse addSingleVertex ( doc , iterable , fieldName , connection , coll . iterator ( ) . next ( ) , iLabels ) ; \n} \nelse if ( coll instanceof ORecordLazyMultiValue ) iterable . add ( new OrientVertexIterator ( this , coll , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) , connection , iLabels , coll . size ( ) ) ) ; \nelse iterable . add ( new OrientVertexIterator ( this , coll , coll . iterator ( ) , connection , iLabels , - 1 ) ) ; \n} \nelse if ( fieldValue instanceof ORidBag ) { \niterable . add ( new OrientVertexIterator ( this , fieldValue , ( ( ORidBag ) fieldValue ) . rawIterator ( ) , connection , iLabels , - 1 ) ) ; \n} \n} \nreturn iterable ; \n} \n} \n"}
{"3229": "public class OCommandExecutorSQLCreateIndex { \n@ SuppressWarnings ( \"rawtypes\" ) public Object execute ( final Map < Object , Object > iArgs ) { \nif ( indexName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal OIndex < ? > idx ; \nList < OCollate > collatesList = null ; \nif ( collates != null ) { \ncollatesList = new ArrayList < OCollate > ( ) ; \nfor ( String collate : collates ) { \nif ( collate != null ) { \nfinal OCollate col = OSQLEngine . getCollate ( collate ) ; \ncollatesList . add ( col ) ; \n} \nelse collatesList . add ( null ) ; \n} \n} \nif ( fields == null || fields . length == 0 ) { \nOIndexFactory factory = OIndexes . getFactory ( indexType . toString ( ) , null ) ; \nif ( keyTypes != null ) idx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new OSimpleKeyIndexDefinition ( keyTypes , collatesList ) , null , null , metadataDoc , engine ) ; \nelse if ( serializerKeyId != 0 ) { \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new ORuntimeKeyIndexDefinition ( serializerKeyId ) , null , null , metadataDoc , engine ) ; \n} \nelse { \nthrow new ODatabaseException ( \"Impossible to create an index without specify the key type or the associated property\" ) ; \n} \n} \nelse if ( ( keyTypes == null || keyTypes . length == 0 ) && collates == null ) { \nidx = oClass . createIndex ( indexName , indexType . toString ( ) , null , metadataDoc , engine , fields ) ; \n} \nelse { \nfinal List < OType > fieldTypeList ; \nif ( keyTypes == null ) { \nfor ( final String fieldName : fields ) { \nif ( ! fieldName . equals ( \"@rid\" ) && ! oClass . existsProperty ( fieldName ) ) throw new OIndexException ( \"Index with name : '\" + indexName + \"' cannot be created on class : '\" + oClass . getName ( ) + \"' because field: '\" + fieldName + \"' is absent in class definition.\" ) ; \n} \nfieldTypeList = ( ( OClassImpl ) oClass ) . extractFieldTypes ( fields ) ; \n} \nelse fieldTypeList = Arrays . asList ( keyTypes ) ; \nfinal OIndexDefinition idxDef = OIndexDefinitionFactory . createIndexDefinition ( oClass , Arrays . asList ( fields ) , fieldTypeList , collatesList , indexType . toString ( ) , null ) ; \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . name ( ) , idxDef , oClass . getPolymorphicClusterIds ( ) , null , metadataDoc , engine ) ; \n} \nif ( idx != null ) return idx . getSize ( ) ; \nreturn null ; \n} \n} \n"}
{"3520": "public class ApplyService { \npublic void installTemplate ( Template entity , String sourceName ) { \nOpenShiftClient openShiftClient = getOpenShiftClient ( ) ; \nif ( openShiftClient == null ) { \nreturn ; \n} \nif ( ! isProcessTemplatesLocally ( ) ) { \nString namespace = getNamespace ( ) ; \nString id = getName ( entity ) ; \nObjects . requireNonNull ( id , \"No name for \" + entity + \" \" + sourceName ) ; \nTemplate old = openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . get ( ) ; \nif ( isRunning ( old ) ) { \nif ( UserConfigurationCompare . configEqual ( entity , old ) ) { \nlog . info ( \"Template has not changed so not doing anything\" ) ; \n} \nelse { \nboolean recreateMode = isRecreateMode ( ) ; \nrecreateMode = true ; \nif ( recreateMode ) { \nopenShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . delete ( ) ; \ndoCreateTemplate ( entity , namespace , sourceName ) ; \n} \nelse { \nlog . info ( \"Updating a Template from \" + sourceName ) ; \ntry { \nObject answer = openShiftClient . templates ( ) . inNamespace ( namespace ) . withName ( id ) . replace ( entity ) ; \nlog . info ( \"Updated Template: \" + answer ) ; \n} \ncatch ( Exception e ) { \nonApplyError ( \"Failed to update Template from \" + sourceName + \". \" + e + \". \" + entity , e ) ; \n} \n} \n} \n} \nelse if ( ! isAllowCreate ( ) ) { \nlog . warn ( \"Creation disabled so not creating a Template from \" + sourceName + \" namespace \" + namespace + \" name \" + getName ( entity ) ) ; \n} \nelse { \ndoCreateTemplate ( entity , namespace , sourceName ) ; \n} \n} \n} \n} \n"}
{"3649": "public class AudioUtil { \npublic static void toFloat ( AudioFormat format , ByteBuffer buf , FloatBuffer floatBuf ) { \nif ( ! format . isSigned ( ) ) throw new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \nif ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \nif ( format . isBigEndian ( ) ) { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \ntoFloat16BE ( buf , floatBuf ) ; \n} \nelse { \ntoFloat24BE ( buf , floatBuf ) ; \n} \n} \nelse if ( format . getSampleSizeInBits ( ) == 16 ) { \ntoFloat16LE ( buf , floatBuf ) ; \n} \nelse { \ntoFloat24LE ( buf , floatBuf ) ; \n} \n} \n} \n"}
{"3650": "public class AudioUtil { \npublic static void fromFloat ( FloatBuffer floatBuf , AudioFormat format , ByteBuffer buf ) { \nif ( ! format . isSigned ( ) ) throw new NotSupportedException ( \"Unsigned PCM is not supported ( yet? ).\" ) ; \nif ( format . getSampleSizeInBits ( ) != 16 && format . getSampleSizeInBits ( ) != 24 ) throw new NotSupportedException ( format . getSampleSizeInBits ( ) + \" bit PCM is not supported ( yet? ).\" ) ; \nif ( format . isBigEndian ( ) ) { \nif ( format . getSampleSizeInBits ( ) == 16 ) { \nfromFloat16BE ( buf , floatBuf ) ; \n} \nelse { \nfromFloat24BE ( buf , floatBuf ) ; \n} \n} \nelse if ( format . getSampleSizeInBits ( ) == 16 ) { \nfromFloat16LE ( buf , floatBuf ) ; \n} \nelse { \nfromFloat24LE ( buf , floatBuf ) ; \n} \n} \n} \n"}
{"3879": "public class DistributedAssignMessage { \n@ Override public void processMessage ( ) { \nif ( payload != null ) { \nif ( storage . arrayExists ( key ) && storage . getArray ( key ) . length ( ) == payload . length ( ) ) storage . getArray ( key ) . assign ( payload ) ; \nelse storage . setArray ( key , payload ) ; \n} \nelse if ( index >= 0 ) { \nif ( storage . getArray ( key ) == null ) throw new RuntimeException ( \"Init wasn't called before for key [\" + key + \"]\" ) ; \nstorage . getArray ( key ) . getRow ( index ) . assign ( value ) ; \n} \nelse storage . getArray ( key ) . assign ( value ) ; \n} \n} \n"}
{"3903": "public class BigDecimalMath { \nstatic public BigDecimal sin ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn sin ( x . negate ( ) ) . negate ( ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal res = mod2pi ( x ) ; \ndouble errpi = 0.5 * Math . abs ( x . ulp ( ) . doubleValue ( ) ) ; \nint val = 2 + err2prec ( FastMath . PI , errpi ) ; \nMathContext mc = new MathContext ( val ) ; \nBigDecimal p = pi ( mc ) ; \nmc = new MathContext ( x . precision ( ) ) ; \nif ( res . compareTo ( p ) > 0 ) { \nreturn sin ( subtractRound ( res , p ) ) . negate ( ) ; \n} \nelse if ( res . multiply ( new BigDecimal ( 2 ) ) . compareTo ( p ) > 0 ) { \nreturn sin ( subtractRound ( p , res ) ) ; \n} \nelse if ( res . multiply ( new BigDecimal ( 4 ) ) . compareTo ( p ) > 0 ) { \nreturn cos ( subtractRound ( p . divide ( new BigDecimal ( 2 ) ) , res ) ) ; \n} \nelse { \nBigDecimal resul = res ; \nBigDecimal xpowi = res ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = res . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( res . precision ( ) / Math . log10 ( 1.0 / res . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( res . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( res ) . multiply ( res ) . negate ( ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nmc = new MathContext ( res . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3905": "public class BigDecimalMath { \nstatic public BigDecimal cosh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn cos ( x . negate ( ) ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ONE ; \n} \nelse if ( x . doubleValue ( ) > 1.5 ) { \nreturn hypot ( 1 , sinh ( x ) ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = 0.5 * x . ulp ( ) . doubleValue ( ) * x . doubleValue ( ) ; \nint k = ( int ) ( Math . log ( xUlpDbl ) / Math . log ( x . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( resul . doubleValue ( ) , xUlpDbl ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n"}
{"3906": "public class BigDecimalMath { \nstatic public BigDecimal sinh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn sinh ( x . negate ( ) ) . negate ( ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse if ( x . doubleValue ( ) > 2.4 ) { \nBigDecimal two = new BigDecimal ( 2 ) ; \nBigDecimal xhalf = x . divide ( two ) ; \nBigDecimal resul = sinh ( xhalf ) . multiply ( cosh ( xhalf ) ) . multiply ( two ) ; \ndouble eps = Math . tanh ( x . doubleValue ( ) ) ; \nMathContext mc = new MathContext ( err2prec ( 0.5 * x . ulp ( ) . doubleValue ( ) / eps ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = xhighpr ; \nBigDecimal xpowi = xhighpr ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( x . precision ( ) / Math . log10 ( 1.0 / xhighpr . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( x . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( x . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n"}
{"3957": "public class AtomicState { \npublic AccessState getCurrentState ( ) { \nif ( AccessState . values ( ) [ currentState . get ( ) ] == AccessState . TOE ) { \nreturn AccessState . TOE ; \n} \nelse if ( tickRequests . get ( ) <= tackRequests . get ( ) ) { \ntickRequests . set ( 0 ) ; \ntackRequests . set ( 0 ) ; \nreturn AccessState . TACK ; \n} \nelse return AccessState . TICK ; \n} \n} \n"}
{"4188": "public class UnitName { \nprotected String makePlural ( final String name ) { \nString plural ; \nfinal int length = name . length ( ) ; \nfinal char lastChar = name . charAt ( length - 1 ) ; \nif ( lastChar != 'y' ) { \nplural = name + ( lastChar == 's' || lastChar == 'x' || lastChar == 'z' || name . endsWith ( \"ch\" ) ? \"es\" : \"s\" ) ; \n} \nelse if ( length == 1 ) { \nplural = name + \"s\" ; \n} \nelse { \nfinal char penultimateChar = name . charAt ( length - 2 ) ; \nplural = ( penultimateChar == 'a' || penultimateChar == 'e' || penultimateChar == 'i' || penultimateChar == 'o' || penultimateChar == 'u' ) ? name + \"s\" : name . substring ( 0 , length - 1 ) + \"ies\" ; \n} \nreturn plural ; \n} \n} \n"}
{"4205": "public class CatalogWatcher { \npublic void register ( Path dir ) throws IOException { \nif ( ! enable ) return ; \nWatchKey key = dir . register ( watcher , ENTRY_CREATE , ENTRY_DELETE , ENTRY_MODIFY ) ; \nif ( trace ) { \nPath prev = keys . get ( key ) ; \nif ( prev == null ) { \nSystem . out . format ( \"CatalogWatcher register: %s%n\" , dir ) ; \n} \nelse if ( ! dir . equals ( prev ) ) { \nSystem . out . format ( \"update: %s -> %s%n\" , prev , dir ) ; \n} \n} \nkeys . put ( key , dir ) ; \n} \n} \n"}
{"4525": "public class DODSNetcdfFile { \nNamePieces parseName ( String name ) { \nNamePieces pieces = new NamePieces ( ) ; \nint dotpos = name . lastIndexOf ( '.' ) ; \nint slashpos = name . lastIndexOf ( '/' ) ; \nif ( slashpos < 0 && dotpos < 0 ) { \npieces . name = name ; \n} \nelse if ( slashpos >= 0 && dotpos < 0 ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse if ( slashpos < 0 && dotpos >= 0 ) { \npieces . var = name . substring ( 0 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \nelse if ( slashpos > dotpos ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . var = name . substring ( slashpos + 1 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \nif ( pieces . prefix != null && pieces . prefix . length ( ) == 0 ) pieces . prefix = null ; \nif ( pieces . var != null && pieces . var . length ( ) == 0 ) pieces . var = null ; \nif ( pieces . name . length ( ) == 0 ) pieces . name = null ; \nreturn pieces ; \n} \n} \n"}
{"4701": "public class DConnect2 { \nprivate void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { \nInputStream is = null ; \ntry { \ntry ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { \nif ( acceptCompress ) method . setCompression ( \"deflate,gzip\" ) ; \nif ( allowSessions ) method . setUseSessions ( true ) ; \nint statusCode ; \nfor ( ; \n; \n) { \nstatusCode = method . execute ( ) ; \nif ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) break ; \nThread . sleep ( 5000 ) ; \nSystem . err . println ( \"Service Unavailable\" ) ; \n} \nif ( statusCode == HttpStatus . SC_NOT_FOUND ) { \nthrow new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + \": \" + urlString ) ; \n} \nif ( statusCode == HttpStatus . SC_UNAUTHORIZED || statusCode == HttpStatus . SC_FORBIDDEN ) { \nthrow new InvalidCredentialsException ( method . getStatusText ( ) ) ; \n} \nif ( statusCode != HttpStatus . SC_OK ) { \nthrow new DAP2Exception ( \"Method failed:\" + method . getStatusText ( ) + \" on URL= \" + urlString ) ; \n} \nis = method . getResponseAsStream ( ) ; \nHeader header = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( header != null && ( header . getValue ( ) . equals ( \"dods-error\" ) || header . getValue ( ) . equals ( \"dods_error\" ) ) ) { \nDAP2Exception ds = new DAP2Exception ( ) ; \nds . parse ( is ) ; \nthrow ds ; \n} \nver = new ServerVersion ( method ) ; \ncheckHeaders ( method ) ; \nHeader h = method . getResponseHeader ( \"content-encoding\" ) ; \nString encoding = ( h == null ) ? null : h . getValue ( ) ; \nif ( encoding != null && encoding . equals ( \"deflate\" ) ) { \nis = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"deflate %s%n\" , urlString ) ; \n} \nelse if ( encoding != null && encoding . equals ( \"gzip\" ) ) { \nis = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"gzip %s%n\" , urlString ) ; \n} \nelse if ( showCompress ) System . out . printf ( \"none %s%n\" , urlString ) ; \ncommand . process ( is ) ; \n} \n} \ncatch ( IOException | DAP2Exception e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nUtil . check ( e ) ; \nthrow new DAP2Exception ( e ) ; \n} \n} \n} \n"}
{"4988": "public class DerivedUnitImpl { \n@ Override protected Unit myMultiplyBy ( final Unit that ) throws MultiplyException { \nUnit result ; \nif ( dimension . getRank ( ) == 0 ) { \nresult = that ; \n} \nelse if ( ! ( that instanceof DerivedUnit ) ) { \nresult = that . multiplyBy ( this ) ; \n} \nelse { \nfinal UnitDimension thatDimension = ( ( DerivedUnit ) that ) . getDimension ( ) ; \nresult = thatDimension . getRank ( ) == 0 ? this : new DerivedUnitImpl ( dimension . multiplyBy ( thatDimension ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"4989": "public class DerivedUnitImpl { \n@ Override protected Unit myDivideBy ( final Unit that ) throws OperationException { \nUnit result ; \nif ( dimension . getRank ( ) == 0 ) { \nresult = that . raiseTo ( - 1 ) ; \n} \nelse if ( ! ( that instanceof DerivedUnit ) ) { \nresult = that . divideInto ( this ) ; \n} \nelse { \nfinal UnitDimension thatDimension = ( ( DerivedUnit ) that ) . getDimension ( ) ; \nresult = thatDimension . getRank ( ) == 0 ? this : new DerivedUnitImpl ( dimension . divideBy ( thatDimension ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"5000": "public class CFSimpleGeometryHelper { \npublic static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { \nif ( var == null ) return null ; \nString subStr = \"\" ; \nList < Dimension > dimList = var . getDimensions ( ) ; \nif ( dimList . size ( ) > 2 || dimList . size ( ) < 1 ) { \nreturn null ; \n} \nfor ( int i = 0 ; \ni < dimList . size ( ) ; \ni ++ ) { \nDimension dim = dimList . get ( i ) ; \nif ( dim == null ) continue ; \nif ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) { \nsubStr += id ; \n} \nelse if ( beginInd < 0 || endInd < 0 ) subStr += \":\" ; \nelse subStr += ( beginInd + \":\" + endInd ) ; \nif ( i < dimList . size ( ) - 1 ) { \nsubStr += \",\" ; \n} \n} \nreturn subStr ; \n} \n} \n"}
{"5011": "public class LatLonRect { \npublic void extend ( LatLonPoint p ) { \nif ( contains ( p ) ) return ; \ndouble lat = p . getLatitude ( ) ; \ndouble lon = p . getLongitude ( ) ; \nif ( lat > upperRight . getLatitude ( ) ) { \nupperRight . setLatitude ( lat ) ; \n} \nif ( lat < lowerLeft . getLatitude ( ) ) { \nlowerLeft . setLatitude ( lat ) ; \n} \nif ( allLongitude ) { \n} \nelse if ( crossDateline ) { \ndouble d1 = lon - upperRight . getLongitude ( ) ; \ndouble d2 = lowerLeft . getLongitude ( ) - lon ; \nif ( ( d1 > 0.0 ) && ( d2 > 0.0 ) ) { \nif ( d1 > d2 ) { \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \n} \nelse if ( lon > upperRight . getLongitude ( ) ) { \nif ( lon - upperRight . getLongitude ( ) > lowerLeft . getLongitude ( ) - lon + 360 ) { \ncrossDateline = true ; \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \nelse if ( lon < lowerLeft . getLongitude ( ) ) { \nif ( lowerLeft . getLongitude ( ) - lon > lon + 360.0 - upperRight . getLongitude ( ) ) { \ncrossDateline = true ; \nupperRight . setLongitude ( lon ) ; \n} \nelse { \nlowerLeft . setLongitude ( lon ) ; \n} \n} \nwidth = upperRight . getLongitude ( ) - lowerLeft . getLongitude ( ) ; \nlon0 = ( upperRight . getLongitude ( ) + lowerLeft . getLongitude ( ) ) / 2 ; \nif ( crossDateline ) { \nwidth += 360 ; \nlon0 -= 180 ; \n} \nthis . allLongitude = this . allLongitude || ( this . width >= 360.0 ) ; \n} \n} \n"}
{"5091": "public class GridVertCoord { \nprivate int coordIndex ( GridRecord record ) { \ndouble val = record . getLevel1 ( ) ; \ndouble val2 = record . getLevel2 ( ) ; \nif ( usesBounds && ( val > val2 ) ) { \nval = record . getLevel2 ( ) ; \nval2 = record . getLevel1 ( ) ; \n} \nfor ( int i = 0 ; \ni < levels . size ( ) ; \ni ++ ) { \nLevelCoord lc = ( LevelCoord ) levels . get ( i ) ; \nif ( usesBounds ) { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) && ucar . nc2 . util . Misc . nearlyEquals ( lc . value2 , val2 ) ) { \nreturn i ; \n} \n} \nelse if ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5117": "public class GradsDataDescriptorFile { \nprivate List < String > getFileNames ( ) throws IOException { \nif ( fileNames == null ) { \nfileNames = new ArrayList < > ( ) ; \ntimeStepsPerFile = tDim . getSize ( ) ; \nif ( ! isTemplate ( ) ) { \nfileNames . add ( getFullPath ( getDataFile ( ) ) ) ; \n} \nelse { \nlong start = System . currentTimeMillis ( ) ; \nList < String > fileSet = new ArrayList < > ( ) ; \nString template = getDataFile ( ) ; \nif ( GradsTimeDimension . hasTimeTemplate ( template ) ) { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TIME_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nelse if ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \nif ( templateType == ENS_TEMPLATE ) { \nfor ( int e = 0 ; \ne < eDim . getSize ( ) ; \ne ++ ) { \nfileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; \n} \n} \nelse if ( ( templateType == TIME_TEMPLATE ) || ( templateType == ENS_TIME_TEMPLATE ) ) { \nint numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; \nfor ( int t = 0 ; \nt < tDim . getSize ( ) ; \nt ++ ) { \nfor ( int e = 0 ; \ne < numens ; \ne ++ ) { \nString file = getFileName ( e , t ) ; \nif ( ! fileSet . contains ( file ) ) { \nfileSet . add ( file ) ; \n} \n} \n} \ntimeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; \n} \nfileNames . addAll ( fileSet ) ; \n} \nfor ( String file : fileNames ) { \nFile f = new File ( file ) ; \nif ( ! f . exists ( ) ) { \nlog . error ( \"File: \" + f + \" does not exist\" ) ; \nthrow new IOException ( \"File: \" + f + \" does not exist\" ) ; \n} \n} \n} \nreturn fileNames ; \n} \n} \n"}
{"5434": "public class GribCdmIndex { \npublic static boolean updateGribCollection ( FeatureCollectionConfig config , CollectionUpdateType updateType , Logger logger ) throws IOException { \nif ( logger == null ) logger = classLogger ; \nlong start = System . currentTimeMillis ( ) ; \nFormatter errlog = new Formatter ( ) ; \nCollectionSpecParser specp = config . getCollectionSpecParser ( errlog ) ; \nPath rootPath = Paths . get ( specp . getRootDir ( ) ) ; \nboolean isGrib1 = config . type == FeatureCollectionType . GRIB1 ; \nboolean changed ; \nif ( config . ptype == FeatureCollectionConfig . PartitionType . none || config . ptype == FeatureCollectionConfig . PartitionType . all ) { \ntry ( CollectionAbstract dcm = new CollectionPathMatcher ( config , specp , logger ) ) { \nchanged = updateGribCollection ( isGrib1 , dcm , updateType , FeatureCollectionConfig . PartitionType . none , logger , errlog ) ; \n} \n} \nelse if ( config . ptype == FeatureCollectionConfig . PartitionType . timePeriod ) { \ntry ( TimePartition tp = new TimePartition ( config , specp , logger ) ) { \nchanged = updateTimePartition ( isGrib1 , tp , updateType , logger ) ; \n} \n} \nelse if ( specp . wantSubdirs ( ) ) { \ntry ( DirectoryPartition dpart = new DirectoryPartition ( config , rootPath , true , new GribCdmIndex ( logger ) , NCX_SUFFIX , logger ) ) { \ndpart . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; \nchanged = updateDirectoryCollectionRecurse ( isGrib1 , dpart , config , updateType , logger ) ; \n} \n} \nelse { \nchanged = updateLeafCollection ( isGrib1 , config , updateType , true , logger , rootPath ) ; \n} \nlong took = System . currentTimeMillis ( ) - start ; \nlogger . info ( \"updateGribCollection {} changed {} took {} msecs\" , config . collectionName , changed , took ) ; \nreturn changed ; \n} \n} \n"}
{"5448": "public class GisFeatureRendererMulti { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nlong startTime = System . currentTimeMillis ( ) ; \nif ( featSetList == null ) { \ninitFeatSetList ( ) ; \nassert ! featSetList . isEmpty ( ) ; \n} \nFeatureSet fs = ( FeatureSet ) featSetList . get ( 0 ) ; \nif ( featSetList . size ( ) > 1 ) { \ndouble scale = 1.0 ; \ntry { \nAffineTransform world2device = g . getTransform ( ) ; \nAffineTransform world2normal = normal2device . createInverse ( ) ; \nworld2normal . concatenate ( world2device ) ; \nscale = Math . max ( Math . abs ( world2normal . getScaleX ( ) ) , Math . abs ( world2normal . getShearX ( ) ) ) ; \nif ( Debug . isSet ( \"GisFeature/showTransform\" ) ) { \nSystem . out . println ( \"GisFeature/showTransform: \" + world2normal + \"\\n scale = \" + scale ) ; \n} \n} \ncatch ( java . awt . geom . NoninvertibleTransformException e ) { \nSystem . out . println ( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device ) ; \n} \nif ( ! displayProject . isLatLon ( ) ) scale *= 111.0 ; \ndouble minD = Double . MAX_VALUE ; \nfor ( Object aFeatSetList : featSetList ) { \nFeatureSet tryfs = ( FeatureSet ) aFeatSetList ; \ndouble d = Math . abs ( scale * tryfs . minDist - pixelMatch ) ; \nif ( d < minD ) { \nminD = d ; \nfs = tryfs ; \n} \n} \nif ( Debug . isSet ( \"GisFeature/MapResolution\" ) ) { \nSystem . out . println ( \"GisFeature/MapResolution: scale = \" + scale + \" minDist = \" + fs . minDist ) ; \n} \n} \nif ( fs . featureList == null ) fs . createFeatures ( ) ; \nif ( ! displayProject . equals ( fs . project ) ) { \nfs . setProjection ( displayProject ) ; \n} \nelse if ( fs . newProjection && displayProject . isLatLon ( ) ) { \nfs . setProjection ( displayProject ) ; \n} \nfs . newProjection = false ; \nif ( Debug . isSet ( \"GisFeature/timing/getShapes\" ) ) { \nlong tookTime = System . currentTimeMillis ( ) - startTime ; \nSystem . out . println ( \"timing.getShapes: \" + tookTime * .001 + \" seconds\" ) ; \n} \nreturn fs . getShapes ( ) ; \n} \n} \n"}
{"5607": "public class GridCoordSys { \nvoid makeVerticalTransform ( GridDataset gds , Formatter parseInfo ) { \nif ( vt != null ) return ; \nif ( vCT == null ) return ; \nvt = vCT . makeVerticalTransform ( gds . getNetcdfDataset ( ) , timeDim ) ; \nif ( vt == null ) { \nif ( parseInfo != null ) parseInfo . format ( \"  - ERR can't make VerticalTransform = %s%n\" , vCT . getVerticalTransformType ( ) ) ; \n} \nelse if ( parseInfo != null ) parseInfo . format ( \"  - VerticalTransform = %s%n\" , vCT . getVerticalTransformType ( ) ) ; \n} \n} \n"}
{"5811": "public class GridDefRecord { \npublic static boolean compare ( GridDefRecord local , GridDefRecord other ) { \njava . util . Set < String > keys = local . getKeys ( ) ; \njava . util . Set < String > okeys = other . getKeys ( ) ; \nif ( keys . size ( ) != okeys . size ( ) ) return false ; \nfor ( String key : keys ) { \nif ( key . equals ( WIND_FLAG ) || key . equals ( RESOLUTION ) || key . equals ( VECTOR_COMPONENT_FLAG ) || key . equals ( GDS_KEY ) ) continue ; \nString val = local . getParam ( key ) ; \nString oval = other . getParam ( key ) ; \nif ( val . matches ( \"^[0-9]+\\\\.[0-9]*\" ) ) { \ndouble d = local . getDouble ( key ) ; \ndouble od = other . getDouble ( key ) ; \nif ( ! Misc . nearlyEquals ( d , od ) ) return false ; \n} \nelse if ( val . matches ( \"^[0-9]+\" ) ) { \nif ( ! val . equals ( oval ) ) return false ; \n} \nelse if ( ! val . equals ( oval ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"6204": "public class CallerData { \npublic static StackTraceElement [ ] extract ( Throwable t , String fqnOfInvokingClass , final int maxDepth , List < String > frameworkPackageList ) { \nif ( t == null ) { \nreturn null ; \n} \nStackTraceElement [ ] steArray = t . getStackTrace ( ) ; \nStackTraceElement [ ] callerDataArray ; \nint found = LINE_NA ; \nfor ( int i = 0 ; \ni < steArray . length ; \ni ++ ) { \nif ( isInFrameworkSpace ( steArray [ i ] . getClassName ( ) , fqnOfInvokingClass , frameworkPackageList ) ) { \nfound = i + 1 ; \n} \nelse if ( found != LINE_NA ) { \nbreak ; \n} \n} \nif ( found == LINE_NA ) { \nreturn EMPTY_CALLER_DATA_ARRAY ; \n} \nint availableDepth = steArray . length - found ; \nint desiredDepth = maxDepth < ( availableDepth ) ? maxDepth : availableDepth ; \ncallerDataArray = new StackTraceElement [ desiredDepth ] ; \nfor ( int i = 0 ; \ni < desiredDepth ; \ni ++ ) { \ncallerDataArray [ i ] = steArray [ found + i ] ; \n} \nreturn callerDataArray ; \n} \n} \n"}
{"6514": "public class DSLTree { \npublic void addChildToList ( Node n , String prefix , ArrayList < String > list ) { \nif ( n . getChildren ( ) . size ( ) > 0 ) { \nfor ( Node child : n . getChildren ( ) ) { \nif ( prefix != null && \"-\" . equals ( child . getToken ( ) ) ) { \nif ( ! list . contains ( prefix ) ) { \nlist . add ( prefix ) ; \n} \nreturn ; \n} \nString text = ( prefix == null ? \"\" : prefix + \" \" ) + child . getToken ( ) ; \naddChildToList ( child , text , list ) ; \n} \n} \nelse if ( ! list . contains ( prefix ) ) { \nlist . add ( prefix ) ; \n} \n} \n} \n"}
{"6830": "public class AbstractReasonerState { \npublic synchronized void ensureLoading ( ) throws ElkException { \nif ( ! isLoadingFinished ( ) ) { \nif ( isIncrementalMode ( ) ) { \nif ( ! stageManager . incrementalAdditionStage . isCompleted ( ) ) { \ncomplete ( stageManager . incrementalAdditionStage ) ; \n} \n} \nelse if ( ! stageManager . contextInitializationStage . isCompleted ( ) ) { \ncomplete ( stageManager . contextInitializationStage ) ; \n} \nLOGGER_ . trace ( \"Reset axiom loading\" ) ; \nstageManager . inputLoadingStage . invalidateRecursive ( ) ; \nstageManager . contextInitializationStage . invalidateRecursive ( ) ; \nstageManager . incrementalCompletionStage . invalidateRecursive ( ) ; \n} \ncomplete ( stageManager . inputLoadingStage ) ; \n} \n} \n"}
{"6903": "public class XhtmlWriter { \nprivate void appendForm ( Affordance affordance , ActionDescriptor actionDescriptor ) throws IOException { \nString formName = actionDescriptor . getActionName ( ) ; \nRequestMethod httpMethod = RequestMethod . valueOf ( actionDescriptor . getHttpMethod ( ) ) ; \nString actionUrl = affordance . expand ( ) . getHref ( ) ; \nbeginForm ( OptionalAttributes . attr ( \"action\" , actionUrl ) . and ( \"method\" , getHtmlConformingHttpMethod ( httpMethod ) ) . and ( \"name\" , formName ) ) ; \nwrite ( \"<h4>\" ) ; \nwrite ( \"Form \" + formName ) ; \nwrite ( \"</h4>\" ) ; \nwriteHiddenHttpMethodField ( httpMethod ) ; \nif ( actionDescriptor . hasRequestBody ( ) ) { \nActionInputParameter requestBody = actionDescriptor . getRequestBody ( ) ; \nClass < ? > parameterType = requestBody . getParameterType ( ) ; \nrecurseBeanProperties ( parameterType , actionDescriptor , requestBody , requestBody . getValue ( ) , \"\" ) ; \n} \nelse { \nCollection < String > requestParams = actionDescriptor . getRequestParamNames ( ) ; \nfor ( String requestParamName : requestParams ) { \nActionInputParameter actionInputParameter = actionDescriptor . getActionInputParameter ( requestParamName ) ; \nObject [ ] possibleValues = actionInputParameter . getPossibleValues ( actionDescriptor ) ; \nif ( possibleValues . length > 0 ) { \nif ( actionInputParameter . isArrayOrCollection ( ) ) { \nappendSelectMulti ( requestParamName , possibleValues , actionInputParameter ) ; \n} \nelse { \nappendSelectOne ( requestParamName , possibleValues , actionInputParameter ) ; \n} \n} \nelse if ( actionInputParameter . isArrayOrCollection ( ) ) { \nObject [ ] callValues = actionInputParameter . getValues ( ) ; \nint items = callValues . length ; \nfor ( int i = 0 ; \ni < items ; \ni ++ ) { \nObject value ; \nif ( i < callValues . length ) { \nvalue = callValues [ i ] ; \n} \nelse { \nvalue = null ; \n} \nappendInput ( requestParamName , actionInputParameter , value , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \nelse { \nString callValueFormatted = actionInputParameter . getValueFormatted ( ) ; \nappendInput ( requestParamName , actionInputParameter , callValueFormatted , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \n} \ninputButton ( Type . SUBMIT , capitalize ( httpMethod . name ( ) . toLowerCase ( ) ) ) ; \nendForm ( ) ; \n} \n} \n"}
{"6947": "public class UsageNotificationManagerMBeanImpl { \npublic boolean getNotificationsEnabled ( String paramName ) { \nBoolean areNotificationsEnabled = paramNames . get ( paramName ) ; \nif ( ! isSlee11 ) { \nif ( areNotificationsEnabled == null || areNotificationsEnabled . booleanValue ( ) ) { \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \nelse if ( areNotificationsEnabled != null && areNotificationsEnabled . booleanValue ( ) ) { \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"6952": "public class ServiceUsageMBeanImpl { \npublic synchronized String [ ] getUsageParameterSets ( SbbID sbbId ) throws NullPointerException , UnrecognizedSbbException , InvalidArgumentException , ManagementException { \nif ( sbbId == null ) throw new NullPointerException ( \"Sbb ID is null!\" ) ; \nSbbComponent sbbComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( sbbId ) ; \nif ( sbbComponent == null ) { \nthrow new UnrecognizedSbbException ( sbbId . toString ( ) ) ; \n} \nelse if ( sbbComponent . getUsageParametersInterface ( ) == null ) { \nthrow new InvalidArgumentException ( \"no usage parameter interface for \" + sbbId ) ; \n} \nServiceComponent serviceComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( getService ( ) ) ; \nif ( ! serviceComponent . getSbbIDs ( sleeContainer . getComponentRepository ( ) ) . contains ( sbbId ) ) { \nthrow new UnrecognizedSbbException ( sbbId . toString ( ) + \" is not part of \" + getService ( ) ) ; \n} \nSet < String > resultSet = new HashSet < String > ( ) ; \nfor ( UsageMBeanImpl usageMBeanImpl : usageMBeans . values ( ) ) { \nif ( ( ( SbbNotification ) usageMBeanImpl . getNotificationSource ( ) ) . getSbb ( ) . equals ( sbbId ) ) { \nString name = usageMBeanImpl . getUsageParameterSet ( ) ; \nif ( name != null ) { \nresultSet . add ( name ) ; \n} \n} \n} \nreturn resultSet . toArray ( new String [ resultSet . size ( ) ] ) ; \n} \n} \n"}
{"6964": "public class NextSbbEntityFinder { \npublic Result next ( ActivityContext ac , EventContext sleeEvent , Set < SbbEntityID > sbbEntitiesThatHandledCurrentEvent , SleeContainer sleeContainer ) { \nSbbEntityID sbbEntityId = null ; \nSbbEntity sbbEntity = null ; \nEventEntryDescriptor mEventEntry = null ; \nfor ( Iterator < SbbEntityID > iter = ac . getSortedSbbAttachmentSet ( sbbEntitiesThatHandledCurrentEvent ) . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nsbbEntityId = iter . next ( ) ; \nsbbEntity = sleeContainer . getSbbEntityFactory ( ) . getSbbEntity ( sbbEntityId , true ) ; \nif ( sbbEntity == null ) { \ncontinue ; \n} \nif ( eventRouterConfiguration . isConfirmSbbEntityAttachement ( ) && ! sbbEntity . isAttached ( ac . getActivityContextHandle ( ) ) ) { \ncontinue ; \n} \nif ( sleeEvent . getService ( ) != null && ! sleeEvent . getService ( ) . equals ( sbbEntityId . getServiceID ( ) ) ) { \nif ( ! sleeEvent . isActivityEndEvent ( ) ) { \ncontinue ; \n} \nelse { \nreturn new Result ( sbbEntity , false ) ; \n} \n} \nmEventEntry = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getEventEntries ( ) . get ( sleeEvent . getEventTypeId ( ) ) ; \nif ( mEventEntry != null && mEventEntry . isReceived ( ) ) { \nreturn new Result ( sbbEntity , true ) ; \n} \nelse if ( ! sleeEvent . isActivityEndEvent ( ) ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Event is not received by sbb descriptor of entity \" + sbbEntityId + \", will not deliver event to sbb entity ...\" ) ; \n} \ncontinue ; \n} \nelse { \nreturn new Result ( sbbEntity , false ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7094": "public class AbstractProfileMBeanImpl { \nprivate void writeMode ( ) throws SLEEException , ManagementException { \nif ( ! isProfileWriteable ( ) ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Changing state to read-write, for profile mbean with name \" + profileName + \", from table with name \" + this . profileTable . getProfileTableName ( ) ) ; \n} \nProfileObjectImpl profileObject = profileTable . getProfile ( profileName ) ; \nprofileObject . getProfileEntity ( ) . setReadOnly ( false ) ; \nstate = State . write ; \n} \nelse if ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Already in write state, for profile mbean with name \" + profileName + \", from table with name \" + this . profileTable . getProfileTableName ( ) ) ; \n} \n} \n} \n"}
{"7152": "public class TracerImpl { \nvoid syncLevelWithLog4j ( ) { \nLevel log4jLevel = parent == null ? logger . getEffectiveLevel ( ) : logger . getLevel ( ) ; \nif ( level == null ) { \nassignLog4JLevel ( log4jLevel ) ; \n} \nelse if ( tracerToLog4JLevel ( level ) != log4jLevel ) { \nassignLog4JLevel ( log4jLevel ) ; \n} \nif ( parent == null && level == null ) { \nlogger . setLevel ( Level . INFO ) ; \nlevel = TraceLevel . INFO ; \n} \nresetCacheFlags ( false ) ; \n} \n} \n"}
{"7154": "public class TracerImpl { \nvoid resetCacheFlags ( boolean resetChilds ) { \nif ( isTraceable ( TraceLevel . FINEST ) ) { \nfinestEnabled = true ; \nfinerEnabled = true ; \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nfinestEnabled = false ; \nif ( isTraceable ( TraceLevel . FINER ) ) { \nfinerEnabled = true ; \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nfinerEnabled = false ; \nif ( isTraceable ( TraceLevel . FINE ) ) { \nfineEnabled = true ; \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nfineEnabled = false ; \nif ( isTraceable ( TraceLevel . CONFIG ) ) { \nconfigEnabled = true ; \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse if ( isTraceable ( TraceLevel . INFO ) ) { \ninfoEnabled = true ; \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \ninfoEnabled = false ; \nif ( isTraceable ( TraceLevel . WARNING ) ) { \nwarningEnabled = true ; \nsevereEnabled = true ; \n} \nelse { \nwarningEnabled = false ; \nif ( isTraceable ( TraceLevel . SEVERE ) ) { \nsevereEnabled = true ; \n} \nelse { \nsevereEnabled = false ; \n} \n} \n} \n} \n} \n} \nif ( resetChilds ) { \nfor ( TracerImpl child : childs ) { \nif ( child . level == null ) { \nchild . resetCacheFlags ( true ) ; \n} \n} \n} \n} \n} \n"}
{"7218": "public class BoonExpressionContext { \nprivate Object doLookup ( String objectExpression , Object defaultValue , boolean searchChildren ) { \nif ( Str . isEmpty ( objectExpression ) ) { \nreturn defaultValue ; \n} \nchar firstChar = Str . idx ( objectExpression , 0 ) ; \nchar secondChar = Str . idx ( objectExpression , 1 ) ; \nchar lastChar = Str . idx ( objectExpression , - 1 ) ; \nboolean escape = false ; \nswitch ( firstChar ) { \ncase '$' : if ( lastChar == '}' ) { \nobjectExpression = slc ( objectExpression , 2 , - 1 ) ; \n} \nelse { \nobjectExpression = slc ( objectExpression , 1 ) ; \n} \nbreak ; \ncase '{' : if ( secondChar == '{' && lastChar == '}' ) { \nchar thirdChar = Str . idx ( objectExpression , 2 ) ; \nif ( thirdChar == '{' ) { \nescape = true ; \nobjectExpression = slc ( objectExpression , 3 , - 3 ) ; \n} \nelse { \nobjectExpression = slc ( objectExpression , 2 , - 2 ) ; \n} \n} \nelse if ( lastChar == '}' ) { \nreturn jsonParser . parse ( objectExpression ) ; \n} \nelse { \nescape = true ; \nobjectExpression = slc ( objectExpression , 1 ) ; \n} \nbreak ; \ncase '[' : return jsonParser . parse ( objectExpression ) ; \ncase '.' : if ( secondChar == '.' ) { \nString newExp = slc ( objectExpression , 2 ) ; \nreturn parent . doLookup ( newExp , newExp , false ) ; \n} \n} \nObject value ; \nlastChar = Str . idx ( objectExpression , - 1 ) ; \nif ( lastChar == ')' ) { \nvalue = handleFunction ( objectExpression , searchChildren ) ; \n} \nelse { \nvalue = findProperty ( objectExpression , searchChildren ) ; \nvalue = value == null ? defaultValue : value ; \n} \nif ( ! escape ) { \nreturn value ; \n} \nelse { \nreturn StandardFunctions . escapeXml ( value ) ; \n} \n} \n} \n"}
{"7479": "public class DistancePointTriangle3D_F64 { \npublic void closestPoint ( Point3D_F64 P , Point3D_F64 closestPt ) { \nGeometryMath_F64 . sub ( B , P , D ) ; \na = E0 . dot ( E0 ) ; \nb = E0 . dot ( E1 ) ; \nc = E1 . dot ( E1 ) ; \nd = E0 . dot ( D ) ; \ne = E1 . dot ( D ) ; \ndouble det = a * c - b * b ; \ns = b * e - c * d ; \nt = b * d - a * e ; \nif ( s + t <= det ) { \nif ( s < 0 ) { \nif ( t < 0 ) { \nregion4 ( ) ; \n} \nelse { \nregion3 ( ) ; \n} \n} \nelse if ( t < 0 ) { \nregion5 ( ) ; \n} \nelse { \nregion0 ( det ) ; \n} \n} \nelse if ( s < 0 ) { \nregion2 ( ) ; \n} \nelse if ( t < 0 ) { \nregion6 ( ) ; \n} \nelse { \nregion1 ( ) ; \n} \nclosestPt . x = B . x + s * E0 . x + t * E1 . x ; \nclosestPt . y = B . y + s * E0 . y + t * E1 . y ; \nclosestPt . z = B . z + s * E0 . z + t * E1 . z ; \n} \n} \n"}
{"7831": "public class Nfa { \nboolean unempty ( Arc a ) { \nState from = a . from ; \nState to = a . to ; \nboolean usefrom ; \nassert a . type == Compiler . EMPTY ; \nassert from != pre && to != post ; \nif ( from == to ) { \nfreearc ( a ) ; \nreturn true ; \n} \nusefrom = true ; \nif ( from . nouts > to . nins ) { \nusefrom = false ; \n} \nelse if ( from . nouts == to . nins ) { \nif ( from . nins > to . nouts ) { \nusefrom = false ; \n} \n} \nfreearc ( a ) ; \nif ( usefrom ) { \nif ( from . nouts == 0 ) { \nmoveins ( from , to ) ; \nfreestate ( from ) ; \n} \nelse { \ncopyins ( from , to ) ; \n} \n} \nelse if ( to . nins == 0 ) { \nmoveouts ( to , from ) ; \nfreestate ( to ) ; \n} \nelse { \ncopyouts ( to , from ) ; \n} \nreturn true ; \n} \n} \n"}
{"7970": "public class JspReader { \nString parseToken ( boolean quoted ) throws JasperException { \nStringBuilder stringBuffer = new StringBuilder ( ) ; \nskipSpaces ( ) ; \nstringBuffer . setLength ( 0 ) ; \nif ( ! hasMoreInput ( ) ) { \nreturn \"\" ; \n} \nint ch = peekChar ( ) ; \nif ( quoted ) { \nif ( ch == '\"' || ch == '\\'' ) { \nchar endQuote = ch == '\"' ? '\"' : '\\'' ; \nch = nextChar ( ) ; \nfor ( ch = nextChar ( ) ; \nch != - 1 && ch != endQuote ; \nch = nextChar ( ) ) { \nif ( ch == '\\\\' ) ch = nextChar ( ) ; \nstringBuffer . append ( ( char ) ch ) ; \n} \nif ( ch == - 1 ) { \nerr . jspError ( mark ( ) , \"jsp.error.quotes.unterminated\" ) ; \n} \n} \nelse { \nerr . jspError ( mark ( ) , \"jsp.error.attr.quoted\" ) ; \n} \n} \nelse if ( ! isDelimiter ( ) ) { \ndo { \nch = nextChar ( ) ; \nif ( ch == '\\\\' ) { \nif ( peekChar ( ) == '\"' || peekChar ( ) == '\\'' || peekChar ( ) == '>' || peekChar ( ) == '%' ) ch = nextChar ( ) ; \n} \nstringBuffer . append ( ( char ) ch ) ; \n} \nwhile ( ! isDelimiter ( ) ) ; \n} \nreturn stringBuffer . toString ( ) ; \n} \n} \n"}
{"8037": "public class JspConfig { \npublic boolean isJspPage ( String uri ) throws JasperException { \ninit ( ) ; \nif ( jspProperties == null ) { \nreturn false ; \n} \nString uriPath = null ; \nint index = uri . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) { \nuriPath = uri . substring ( 0 , index + 1 ) ; \n} \nString uriExtension = null ; \nindex = uri . lastIndexOf ( '.' ) ; \nif ( index >= 0 ) { \nuriExtension = uri . substring ( index + 1 ) ; \n} \nfor ( JspPropertyGroup jpg : jspProperties ) { \nJspProperty jp = jpg . getJspProperty ( ) ; \nString extension = jpg . getExtension ( ) ; \nString path = jpg . getPath ( ) ; \nif ( extension == null ) { \nif ( uri . equals ( path ) ) { \nreturn true ; \n} \n} \nelse if ( ( path == null || path . equals ( uriPath ) ) && ( extension . equals ( \"*\" ) || extension . equals ( uriExtension ) ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8528": "public class ShiftFormulaUtility { \nprotected static Object fixupRefRelativeRowOneToOne ( final Object ptg , final Row newRow ) { \nif ( ptg instanceof RefPtgBase ) { \nif ( ptg instanceof Ref3DPxg ) { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) ptg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( newRow . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( ref3dPxg . getPtgClass ( ) ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nreturn new3dpxg ; \n} \nelse { \nRefPtgBase refPtgBase = ( RefPtgBase ) ptg ; \nreturn new RefPtg ( newRow . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \n} \nelse if ( ptg instanceof Area3DPxg ) { \nArea3DPxg area3dPxg = ( Area3DPxg ) ptg ; \nArea3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; \nnew3dpxg . setClass ( area3dPxg . getPtgClass ( ) ) ; \nnew3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; \nnew3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; \nint shiftRow = newRow . getRowNum ( ) - area3dPxg . getFirstRow ( ) ; \nnew3dpxg . setFirstRow ( area3dPxg . getFirstRow ( ) + shiftRow ) ; \nnew3dpxg . setLastRow ( area3dPxg . getLastRow ( ) + shiftRow ) ; \nnew3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; \nnew3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; \nreturn new3dpxg ; \n} \nelse { \nAreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; \nint shiftRow = newRow . getRowNum ( ) - areaPtgBase . getFirstRow ( ) ; \nreturn new AreaPtg ( areaPtgBase . getFirstRow ( ) + shiftRow , areaPtgBase . getLastRow ( ) + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; \n} \n} \n} \n"}
{"8594": "public class ConfigurationHandler { \nprivate List < ConfigCommand > buildCommandList ( final Sheet sheet , final int sheetRightCol , final Cell cell , final List < ConfigCommand > cList , final CellAttributesMap cellAttributesMap ) { \nComment comment = cell . getCellComment ( ) ; \nString text = comment . getString ( ) . getString ( ) ; \nString [ ] commentLines = text . split ( \"\\\\n\" ) ; \nStringBuilder newComment = new StringBuilder ( ) ; \nboolean changed = false ; \nfor ( String commentLine : commentLines ) { \nString line = commentLine . trim ( ) ; \nif ( ParserUtility . isCommandString ( line ) ) { \nprocessCommandLine ( sheet , cell , line , cList , sheetRightCol ) ; \nchanged = true ; \n} \nelse if ( ParserUtility . isEmptyMethodString ( line ) || ParserUtility . isMethodString ( line ) ) { \nprocessMethodLine ( cell , line , cellAttributesMap ) ; \nchanged = true ; \n} \nelse if ( newComment . length ( ) > 0 ) { \nnewComment . append ( \"\\\\n\" + commentLine ) ; \n} \nelse { \nnewComment . append ( commentLine ) ; \n} \n} \nif ( ! changed ) { \nmoveCommentToMap ( cell , text , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; \n} \nelse if ( newComment . length ( ) > 0 ) { \nmoveCommentToMap ( cell , newComment . toString ( ) , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; \nCreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; \nRichTextString str = factory . createRichTextString ( newComment . toString ( ) ) ; \ncomment . setString ( str ) ; \n} \nelse { \ncell . removeCellComment ( ) ; \n} \nreturn cList ; \n} \n} \n"}
{"8710": "public class CellStyleUtility { \n@ SuppressWarnings ( \"deprecation\" ) private static String getInputTypeFromCellType ( final Cell cell ) { \nString inputType = TieConstants . CELL_INPUT_TYPE_TEXT ; \nif ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { \ninputType = TieConstants . CELL_INPUT_TYPE_DOUBLE ; \n} \nCellStyle style = cell . getCellStyle ( ) ; \nif ( style != null ) { \nint formatIndex = style . getDataFormat ( ) ; \nString formatString = style . getDataFormatString ( ) ; \nif ( DateUtil . isADateFormat ( formatIndex , formatString ) ) { \ninputType = TieConstants . CELL_INPUT_TYPE_DATE ; \n} \nelse if ( isAPercentageCell ( formatString ) ) { \ninputType = TieConstants . CELL_INPUT_TYPE_PERCENTAGE ; \n} \n} \nreturn inputType ; \n} \n} \n"}
{"8749": "public class WebSheetUtility { \npublic static boolean isNumeric ( final String str ) { \nString s = str ; \nif ( s . startsWith ( \"-\" ) ) { \ns = s . substring ( 1 ) ; \n} \nchar c ; \nint i ; \nint sLen = s . length ( ) ; \nShouldContinueParameter sPara = new ShouldContinueParameter ( false , false , 0 ) ; \nfor ( i = 0 ; \ni < sLen ; \ni ++ ) { \nc = s . charAt ( i ) ; \nif ( c < '0' || c > '9' ) { \nif ( ! shouldContinue ( c , sPara ) ) { \nreturn false ; \n} \n} \nelse if ( sPara . isCommaHit ( ) ) { \nsPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"8841": "public class BaseFileResponseCache { \nprivate synchronized File ensureWorkingDirectory ( ) throws IOException { \nFile directory = getWorkingDirectory ( ) ; \nif ( ! directory . exists ( ) ) { \nif ( ! directory . mkdirs ( ) ) { \nthrow new IOException ( \"Working directory \" + directory + \" cannot be created\" ) ; \n} \n} \nelse if ( ! directory . isDirectory ( ) ) { \nif ( ! directory . delete ( ) ) { \nthrow new IOException ( directory + \" is not a directory and cannot be deleted\" ) ; \n} \nif ( ! directory . mkdirs ( ) ) { \nthrow new IOException ( \"Working directory \" + directory + \" cannot be recreated\" ) ; \n} \n} \nreturn directory ; \n} \n} \n"}
{"9494": "public class StructsBatchCompiler { \nprivate void internalInstallJvmTypeProvider ( XtextResourceSet resourceSet , File tmpClassDirectory , boolean skipIndexLookup ) { \nIterable < String > classPathEntries = concat ( getClassPathEntries ( ) , getSourcePathDirectories ( ) , asList ( tmpClassDirectory . toString ( ) ) ) ; \nclassPathEntries = filter ( classPathEntries , new Predicate < String > ( ) { \npublic boolean apply ( String input ) { \nreturn ! Strings . isEmpty ( input . trim ( ) ) ; \n} \n} \n) ; \nFunction < String , URL > toUrl = new Function < String , URL > ( ) { \npublic URL apply ( String from ) { \ntry { \nreturn new File ( from ) . toURI ( ) . toURL ( ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n; \nIterable < URL > classPathUrls = Iterables . transform ( classPathEntries , toUrl ) ; \nlog . debug ( \"classpath used for Struct compilation : \" + classPathUrls ) ; \nClassLoader parentClassLoader ; \nif ( useCurrentClassLoaderAsParent ) { \nparentClassLoader = currentClassLoader ; \n} \nelse if ( isEmpty ( bootClassPath ) ) { \nparentClassLoader = ClassLoader . getSystemClassLoader ( ) . getParent ( ) ; \n} \nelse { \nIterable < URL > bootClassPathUrls = Iterables . transform ( getBootClassPathEntries ( ) , toUrl ) ; \nparentClassLoader = new BootClassLoader ( toArray ( bootClassPathUrls , URL . class ) ) ; \n} \nClassLoader urlClassLoader = new URLClassLoader ( toArray ( classPathUrls , URL . class ) , parentClassLoader ) ; \nnew ClasspathTypeProvider ( urlClassLoader , resourceSet , skipIndexLookup ? null : indexedJvmTypeAccess ) ; \nresourceSet . setClasspathURIContext ( urlClassLoader ) ; \nURLClassLoader urlClassLoaderForAnnotationProcessing = new URLClassLoader ( toArray ( classPathUrls , URL . class ) , currentClassLoader ) ; \nresourceSet . eAdapters ( ) . add ( new ProcessorClassloaderAdapter ( urlClassLoaderForAnnotationProcessing ) ) ; \n} \n} \n"}
{"9495": "public class StructsBatchCompiler { \nprotected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { \nif ( ! parentFolder . exists ( ) ) { \nreturn true ; \n} \nif ( filter == null ) filter = ACCEPT_ALL_FILTER ; \nlog . debug ( \"Cleaning folder \" + parentFolder . toString ( ) ) ; \nfinal File [ ] contents = parentFolder . listFiles ( filter ) ; \nfor ( int j = 0 ; \nj < contents . length ; \nj ++ ) { \nfinal File file = contents [ j ] ; \nif ( file . isDirectory ( ) ) { \nif ( ! cleanFolder ( file , filter , continueOnError , true ) && ! continueOnError ) return false ; \n} \nelse if ( ! file . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + file . getAbsolutePath ( ) ) ; \nif ( ! continueOnError ) return false ; \n} \n} \nif ( deleteParentFolder ) { \nif ( parentFolder . list ( ) . length == 0 && ! parentFolder . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + parentFolder . getAbsolutePath ( ) ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9761": "public class AbstractParser { \n@ SuppressWarnings ( \"unchecked\" ) protected final CONFIG_TYPE getConcreteConfig ( final ParserConfig config ) { \nfinal Config < ParserConfig > cfg = config . getConfig ( ) ; \nif ( cfg == null ) { \nthrow new IllegalStateException ( \"The configuration is expected to be of type '\" + concreteConfigClass . getName ( ) + \"', but was: null\" ) ; \n} \nelse if ( ! ( concreteConfigClass . isAssignableFrom ( cfg . getConfig ( ) . getClass ( ) ) ) ) { \nthrow new IllegalStateException ( \"The configuration is expected to be of type '\" + concreteConfigClass . getName ( ) + \"', but was: \" + cfg . getConfig ( ) . getClass ( ) . getName ( ) + \" - Did you add the configuration class to the JXB context?\" ) ; \n} \nreturn ( CONFIG_TYPE ) cfg . getConfig ( ) ; \n} \n} \n"}
{"9908": "public class ValidationMethod { \npublic static MonomerNotation decideWhichMonomerNotation ( String str , String type ) throws NotationException { \nMonomerNotation mon ; \nif ( str . startsWith ( \"(\" ) && str . endsWith ( \")\" ) ) { \nString str2 = str . substring ( 1 , str . length ( ) - 1 ) ; \nPattern patternAND = Pattern . compile ( \"\\\\+\" ) ; \nPattern patternOR = Pattern . compile ( \",\" ) ; \nif ( patternAND . matcher ( str ) . find ( ) ) { \nmon = new MonomerNotationGroupMixture ( str2 , type ) ; \n} \nelse if ( patternOR . matcher ( str ) . find ( ) ) { \nmon = new MonomerNotationGroupOr ( str2 , type ) ; \n} \nelse if ( str . contains ( \".\" ) ) { \nmon = new MonomerNotationList ( str2 , type ) ; \n} \nelse if ( type == \"RNA\" ) { \nmon = new MonomerNotationUnitRNA ( str2 , type ) ; \n} \nelse { \nif ( str2 . length ( ) > 1 ) { \nif ( ! ( str2 . startsWith ( \"[\" ) && str2 . endsWith ( \"]\" ) ) ) { \nthrow new NotationException ( \"Monomers have to be in brackets: \" + str ) ; \n} \n} \nmon = new MonomerNotationUnit ( str2 , type ) ; \n} \n} \nelse if ( type == \"RNA\" ) { \nmon = new MonomerNotationUnitRNA ( str , type ) ; \n} \nelse if ( type != \"BLOB\" ) { \nif ( str . length ( ) > 1 ) { \nif ( ! ( str . startsWith ( \"[\" ) && str . endsWith ( \"]\" ) ) ) { \nthrow new NotationException ( \"Monomers have to be in brackets: \" + str ) ; \n} \n} \nmon = new MonomerNotationUnit ( str , type ) ; \n} \nelse { \nmon = new MonomerNotationUnit ( str , type ) ; \n} \nreturn mon ; \n} \n} \n"}
{"10106": "public class URI { \nprivate void appendPath ( String p_addToPath ) throws MalformedURIException { \nif ( p_addToPath == null || p_addToPath . length ( ) == 0 ) { \nreturn ; \n} \nif ( ! isURIString ( p_addToPath ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character!\" ) ; \n} \nif ( m_path == null || m_path . length ( ) == 0 ) { \nif ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = p_addToPath ; \n} \nelse { \nm_path = \"/\" + p_addToPath ; \n} \n} \nelse if ( m_path . endsWith ( \"/\" ) ) { \nif ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; \n} \nelse { \nm_path = m_path . concat ( p_addToPath ) ; \n} \n} \nelse if ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = m_path . concat ( p_addToPath ) ; \n} \nelse { \nm_path = m_path . concat ( \"/\" + p_addToPath ) ; \n} \n} \n} \n"}
{"10142": "public class NamedParameterStatement { \nprivate static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { \nint length = sql . length ( ) ; \nStringBuffer parsedSql = new StringBuffer ( length ) ; \nboolean inSingleQuote = false ; \nboolean inDoubleQuote = false ; \nint index = 1 ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nchar c = sql . charAt ( i ) ; \nif ( inSingleQuote ) { \nif ( c == '\\'' ) { \ninSingleQuote = false ; \n} \n} \nelse if ( inDoubleQuote ) { \nif ( c == '\"' ) { \ninDoubleQuote = false ; \n} \n} \nelse if ( c == '\\'' ) { \ninSingleQuote = true ; \n} \nelse if ( c == '\"' ) { \ninDoubleQuote = true ; \n} \nelse if ( c == ':' && i + 1 < length && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { \nint j = i + 2 ; \nwhile ( j < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) { \nj ++ ; \n} \nString name = sql . substring ( i + 1 , j ) ; \nc = '?' ; \ni += name . length ( ) ; \nList < Integer > indexList = nameIndexMap . get ( name ) ; \nif ( indexList == null ) { \nindexList = new LinkedList < Integer > ( ) ; \nnameIndexMap . put ( name , indexList ) ; \n} \nindexList . add ( index ) ; \nindex ++ ; \n} \nparsedSql . append ( c ) ; \n} \nreturn parsedSql . toString ( ) ; \n} \n} \n"}
{"10162": "public class PasswordLoginModule { \n@ SuppressWarnings ( \"PMD.ConfusingTernary\" ) private void initAudit ( final CommonProperties commonProps ) { \ntry { \nfinal String auditClassName = commonProps . getAuditClassName ( ) ; \nif ( ! commonProps . isAuditEnabled ( ) ) { \nfinal String error = \"Auditing has been disabled in the JAAS configuration\" ; \nLOG . info ( error ) ; \n} \nelse if ( auditClassName == null ) { \nfinal String error = \"Auditing has been enabled in the JAAS configuration, but no audit class has been configured\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse if ( commonProps . isAuditSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton audit class instance of '\" + auditClassName + \"' from the audit factory\" ) ; \nthis . audit = AuditFactory . getSingleton ( auditClassName , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton audit class instance of '\" + auditClassName + \"' from the audit factory\" ) ; \nthis . audit = AuditFactory . getInstance ( auditClassName , commonProps ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The audit class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10163": "public class PasswordLoginModule { \n@ SuppressWarnings ( \"PMD.ConfusingTernary\" ) private void initMessageQueue ( final CommonProperties commonProps ) { \ntry { \nfinal String messageClassName = commonProps . getMessageQueueClassName ( ) ; \nif ( ! commonProps . isMessageQueueEnabled ( ) ) { \nfinal String error = \"Message queue has been disabled in the JAAS configuration\" ; \nLOG . info ( error ) ; \n} \nelse if ( messageClassName == null ) { \nfinal String error = \"Message queue has been enabled in the JAAS configuration, \" + \"but no message queue class has been configured\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse if ( commonProps . isMessageQueueSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton message class instance of '\" + messageClassName + \"' from the message factory\" ) ; \nthis . messageQ = MessageQFactory . getSingleton ( messageClassName , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton message class instance of '\" + messageClassName + \"' from the message factory\" ) ; \nthis . messageQ = MessageQFactory . getInstance ( messageClassName , commonProps ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The message class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10164": "public class PasswordLoginModule { \nprivate void initPwValidator ( final CommonProperties commonProps ) { \ntry { \nfinal String validatorClass = commonProps . getPasswordValidatorClassName ( ) ; \nif ( validatorClass == null ) { \nfinal String error = \"No password validator class has been configured in the JAAS configuration\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse if ( commonProps . isPasswordValidatorSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton validator class instance of '\" + validatorClass + \"' from the validator factory\" ) ; \nthis . pwValidator = PasswordValidatorFactory . getSingleton ( validatorClass , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton validator class instance of '\" + validatorClass + \"' from the validator factory\" ) ; \nthis . pwValidator = PasswordValidatorFactory . getInstance ( validatorClass , commonProps ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The validator class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10165": "public class PasswordLoginModule { \nprivate void initPwAuthenticator ( final CommonProperties commonProps ) { \ntry { \nfinal String authNticatorClass = commonProps . getPasswordAuthenticatorClassName ( ) ; \nif ( authNticatorClass == null ) { \nfinal String error = \"No password authenticator class has been configured in the JAAS configuration\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse if ( commonProps . isPasswordAuthenticatorSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton authenticator class instance of '\" + authNticatorClass + \"' from the authenticator factory\" ) ; \nthis . pwAuthenticator = PasswordAuthenticatorFactory . getSingleton ( authNticatorClass , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton authenticator class instance of '\" + authNticatorClass + \"' from the authenticator factory\" ) ; \nthis . pwAuthenticator = PasswordAuthenticatorFactory . getInstance ( authNticatorClass , commonProps ) ; \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The validator class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10591": "public class FibonacciHeap { \nprivate void updateMinimum ( Node node ) { \nif ( entryComparator != null ) { \nif ( entryComparator . compare ( node . element , minNode . element ) < 0 ) { \nminNode = node ; \n} \n} \nelse if ( ( ( Comparable ) node . element ) . compareTo ( minNode . element ) < 0 ) { \nminNode = node ; \n} \n} \n} \n"}
{"10619": "public class Functor { \npublic Iterator < Operator < Term > > getChildren ( boolean reverse ) { \nif ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) { \nreturn ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; \n} \nelse if ( arguments == null ) { \nreturn new LinkedList < Operator < Term > > ( ) . iterator ( ) ; \n} \nelse if ( ! reverse ) { \nreturn Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; \n} \nelse { \nList < Operator < Term > > argList = new LinkedList < Operator < Term > > ( ) ; \nfor ( int i = arity - 1 ; \ni >= 0 ; \ni -- ) { \nargList . add ( arguments [ i ] ) ; \n} \nreturn argList . iterator ( ) ; \n} \n} \n} \n"}
{"10651": "public class ModificationRequest { \npublic void processRequest ( HttpServletRequest request ) throws IOException , FileUploadException , StorageClientException , AccessDeniedException { \nboolean debug = LOGGER . isDebugEnabled ( ) ; \nif ( ServletFileUpload . isMultipartContent ( request ) ) { \nif ( debug ) { \nLOGGER . debug ( \"Multipart POST \" ) ; \n} \nfeedback . add ( \"Multipart Upload\" ) ; \nServletFileUpload upload = new ServletFileUpload ( ) ; \nFileItemIterator iterator = upload . getItemIterator ( request ) ; \nwhile ( iterator . hasNext ( ) ) { \nFileItemStream item = iterator . next ( ) ; \nif ( debug ) { \nLOGGER . debug ( \"Got Item {}\" , item ) ; \n} \nString name = item . getFieldName ( ) ; \nInputStream stream = item . openStream ( ) ; \nif ( item . isFormField ( ) ) { \nParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; \nString propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; \nRequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , Streams . asString ( stream ) ) ) ; \nfeedback . add ( pt . feedback ( propertyName ) ) ; \n} \nelse if ( streamProcessor != null ) { \nfeedback . addAll ( streamProcessor . processStream ( name , StorageClientUtils . getObjectName ( item . getName ( ) ) , item . getContentType ( ) , stream , this ) ) ; \n} \n} \nif ( debug ) { \nLOGGER . debug ( \"No More items \" ) ; \n} \n} \nelse { \nif ( debug ) { \nLOGGER . debug ( \"Trad Post \" ) ; \n} \n@ SuppressWarnings ( \"unchecked\" ) Map < String , String [ ] > parameters = request . getParameterMap ( ) ; \nif ( debug ) { \nLOGGER . debug ( \"Traditional POST {} \" , parameters ) ; \n} \nSet < Entry < String , String [ ] > > entries = parameters . entrySet ( ) ; \nfor ( Entry < String , String [ ] > param : entries ) { \nString name = ( String ) param . getKey ( ) ; \nParameterType pt = ParameterType . typeOfRequestParameter ( name ) ; \nString propertyName = RequestUtils . propertyName ( pt . getPropertyName ( name ) ) ; \nRequestUtils . accumulate ( stores . get ( pt ) , propertyName , RequestUtils . toValue ( name , param . getValue ( ) ) ) ; \nfeedback . add ( pt . feedback ( propertyName ) ) ; \n} \n} \n} \n} \n"}
{"10868": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackDelete ( final Node < K , V > deletedNode ) { \nfor ( int index = FIRST_INDEX ; \nindex < NUMBER_OF_INDICES ; \nindex ++ ) { \nif ( ( deletedNode . getLeft ( index ) != null ) && ( deletedNode . getRight ( index ) != null ) ) { \nswapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; \n} \nNode < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; \nif ( replacement != null ) { \nreplacement . setParent ( deletedNode . getParent ( index ) , index ) ; \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = replacement ; \n} \nelse if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( replacement , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( replacement , index ) ; \n} \ndeletedNode . setLeft ( null , index ) ; \ndeletedNode . setRight ( null , index ) ; \ndeletedNode . setParent ( null , index ) ; \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( replacement , index ) ; \n} \n} \nelse if ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = null ; \n} \nelse { \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( deletedNode , index ) ; \n} \nif ( deletedNode . getParent ( index ) != null ) { \nif ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( null , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( null , index ) ; \n} \ndeletedNode . setParent ( null , index ) ; \n} \n} \n} \nshrink ( ) ; \n} \n} \n"}
{"10870": "public class TransactionalBidiTreeMap { \nprivate void insertValue ( final Node < K , V > newNode , final String thread_id ) throws IllegalArgumentException { \nNode < K , V > node = rootNode [ VALUE ] ; \nwhile ( true ) { \nint cmp = compare ( Node . ADDED , newNode . getData ( VALUE ) , node . getStatus ( ) , node . getData ( VALUE ) , VALUE ) ; \nif ( cmp == 0 ) { \nif ( nextEqualValid ( getFloorEqualNode ( node , VALUE ) , VALUE , thread_id ) != null ) { \nString debug_message = \"Cannot store a duplicate value (\\\"\" + newNode . getData ( VALUE ) + \"\\\") in this Map. Value already exists for key \" + node . getKey ( ) ; \nlog . debug ( debug_message ) ; \nthrow new IllegalArgumentException ( debug_message ) ; \n} \nif ( node . is ( Node . ADDED , null ) ) throw new ConcurrentModificationException ( ) ; \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse if ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse if ( cmp < 0 ) { \nif ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setLeft ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse if ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \n} \n} \n"}
