{"236": "public class ResponsePrinter { \npublic static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { \nfinal StringBuilder builder = new StringBuilder ( ) ; \nif ( logDetail == ALL || logDetail == STATUS ) { \nbuilder . append ( responseOptions . statusLine ( ) ) ; \n} \nif ( logDetail == ALL || logDetail == HEADERS ) { \nfinal Headers headers = responseOptions . headers ( ) ; \nif ( headers . exist ( ) ) { \nappendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; \n} \n} \nelse if ( logDetail == COOKIES ) { \nfinal Cookies cookies = responseOptions . detailedCookies ( ) ; \nif ( cookies . exist ( ) ) { \nappendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; \n} \n} \nif ( logDetail == ALL || logDetail == BODY ) { \nString responseBodyToAppend ; \nif ( shouldPrettyPrint ) { \nresponseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; \n} \nelse { \nresponseBodyToAppend = responseBody . asString ( ) ; \n} \nif ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { \nbuilder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; \n} \nbuilder . append ( responseBodyToAppend ) ; \n} \nString response = builder . toString ( ) ; \nstream . print ( response + \"\\n\" ) ; \nreturn response ; \n} \n} \n"}
{"391": "public class Manager { \npublic static void main ( String [ ] args ) throws Exception { \nif ( args . length != 1 ) { \nSystem . err . print ( \"Usage: java -Dcom.sun.management.jmxremote \" + Manager . class . getName ( ) + \" [module class name]\" + \"\\n\" ) ; \nSystem . err . print ( \"Then run 'jconsole' to connect.\" + \"\\n\" ) ; \nSystem . exit ( 1 ) ; \n} \nModule module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; \nInjector injector = Guice . createInjector ( module ) ; \nmanage ( args [ 0 ] , injector ) ; \nSystem . out . print ( \"Press Ctrl+C to exit...\" + \"\\n\" ) ; \nThread . sleep ( Long . MAX_VALUE ) ; \n} \n} \n"}
{"1358": "public class SimpleLogger { \nprotected void print ( final Level level , final String message , final Throwable throwable ) { \nif ( ! isEnabled ( level ) ) { \nreturn ; \n} \nStringBuilder msg = new StringBuilder ( ) . append ( slf . getElapsedTime ( ) ) . append ( ' ' ) . append ( '[' ) . append ( level ) . append ( ']' ) . append ( ' ' ) . append ( getCallerClass ( ) ) . append ( ' ' ) . append ( '-' ) . append ( ' ' ) . append ( message ) ; \nSystem . out . print ( msg . toString ( ) + \"\\n\" ) ; \nif ( throwable != null ) { \nthrowable . printStackTrace ( System . out ) ; \n} \n} \n} \n"}
{"1409": "public class Cli { \npublic void printUsage ( final String commandName ) { \nfinal StringBuilder usage = new StringBuilder ( commandName ) ; \nfor ( final Option option : options ) { \nif ( option . shortName != null ) { \nusage . append ( \" [-\" ) . append ( option . shortName ) . append ( \"]\" ) ; \n} \nelse if ( option . longName != null ) { \nusage . append ( \" [--\" ) . append ( option . longName ) . append ( \"]\" ) ; \n} \n} \nfor ( final Param param : params ) { \nusage . append ( \" \" ) . append ( param . label ) ; \n} \nSystem . out . print ( usage + \"\\n\" ) ; \n} \n} \n"}
{"1694": "public class JoddJoy { \nprivate void printLogo ( ) { \nSystem . out . print ( Chalk256 . chalk ( ) . yellow ( ) . on ( Jodd . JODD ) + \"\\n\" ) ; \n} \n} \n"}
{"1816": "public class ClusteredServiceContainer { \npublic static void main ( final String [ ] args ) { \nloadPropertiesFiles ( args ) ; \ntry ( ClusteredServiceContainer container = launch ( ) ) { \ncontainer . context ( ) . shutdownSignalBarrier ( ) . await ( ) ; \nSystem . out . print ( \"Shutdown ClusteredServiceContainer...\" + \"\\n\" ) ; \n} \n} \n} \n"}
{"1818": "public class SamplesUtil { \n@ SuppressWarnings ( \"unused\" ) public static void printError ( final String channel , final int streamId , final int sessionId , final String message , final HeaderFlyweight cause ) { \nSystem . out . print ( message + \"\\n\" ) ; \n} \n} \n"}
{"1819": "public class SamplesUtil { \npublic static void printRate ( final double messagesPerSec , final double bytesPerSec , final long totalMessages , final long totalBytes ) { \nSystem . out . print ( String . format ( \"%.02g msgs/sec, %.02g payload bytes/sec, totals %d messages %d MB\" , messagesPerSec , bytesPerSec , totalMessages , totalBytes / ( 1024 * 1024 ) ) + \"\\n\" ) ; \n} \n} \n"}
{"1967": "public class MediaDriver { \npublic static void main ( final String [ ] args ) { \nloadPropertiesFiles ( args ) ; \nfinal ShutdownSignalBarrier barrier = new ShutdownSignalBarrier ( ) ; \nfinal MediaDriver . Context ctx = new MediaDriver . Context ( ) ; \nctx . terminationHook ( barrier :: signal ) ; \ntry ( MediaDriver ignore = MediaDriver . launch ( ctx ) ) { \nbarrier . await ( ) ; \nSystem . out . print ( \"Shutdown Driver...\" + \"\\n\" ) ; \n} \n} \n} \n"}
{"2373": "public class BootstrapClusterStreaming { \npublic static void main ( String [ ] args ) throws Exception { \nSparkStreamingBinding binding = null ; \ntry { \nbinding = SparkStreamingBindingFactory . build ( BootstrapCluster . getProperties ( ) ) ; \nbinding . init ( ) ; \nBootstrapCluster . createTransformers ( binding . getStreamingContext ( ) . sparkContext ( ) , binding . getSparkSession ( ) ) ; \nbinding . startContext ( ) ; \nbinding . awaitTermination ( ) ; \n} \ncatch ( Throwable error ) { \nString msg = \"Error trying to invoke BootstrapClusterStreaming.main: \" + error ; \nSystem . err . print ( new Date ( ) + \": \" + msg + \"\\n\" ) ; \nerror . printStackTrace ( System . err ) ; \nLOG . error ( msg , error ) ; \nthrow new IllegalStateException ( msg , error ) ; \n} \nfinally { \ntry { \nif ( binding != null ) { \nbinding . close ( ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . warn ( \"Error on binding close: \" + ex , ex ) ; \n} \n} \n} \n} \n"}
{"2794": "public class VaultSession { \nprivate void attributeCreatedDisplay ( String vaultBlock , String attributeName ) { \nSystem . out . print ( SecurityLogger . ROOT_LOGGER . vaultAttributeCreateDisplay ( vaultBlock , attributeName , securedAttributeConfigurationString ( vaultBlock , attributeName ) ) + \"\\n\" ) ; \n} \n} \n"}
{"2795": "public class VaultSession { \npublic void vaultConfigurationDisplay ( ) { \nfinal String configuration = vaultConfiguration ( ) ; \nSystem . out . print ( SecurityLogger . ROOT_LOGGER . vaultConfigurationTitle ( ) + \"\\n\" ) ; \nSystem . out . print ( \"********************************************\" + \"\\n\" ) ; \nSystem . out . print ( \"For standalone mode:\" + \"\\n\" ) ; \nSystem . out . print ( configuration + \"\\n\" ) ; \nSystem . out . print ( \"********************************************\" + \"\\n\" ) ; \nSystem . out . print ( \"For domain mode:\" + \"\\n\" ) ; \nSystem . out . print ( \"/host=the_host\" + configuration + \"\\n\" ) ; \nSystem . out . print ( \"********************************************\" + \"\\n\" ) ; \n} \n} \n"}
{"3244": "public class OServerNetworkListener { \nprivate void listen ( final String iHostName , final String iHostPortRange , final String iProtocolName , Class < ? extends ONetworkProtocol > protocolClass ) { \nfor ( int port : getPorts ( iHostPortRange ) ) { \ninboundAddr = new InetSocketAddress ( iHostName , port ) ; \ntry { \nserverSocket = socketFactory . createServerSocket ( port , 0 , InetAddress . getByName ( iHostName ) ) ; \nif ( serverSocket . isBound ( ) ) { \nOLogManager . instance ( ) . info ( this , \"Listening $ANSI{green \" + iProtocolName + \"} connections on $ANSI{green \" + inboundAddr . getAddress ( ) . getHostAddress ( ) + \":\" + inboundAddr . getPort ( ) + \"} (protocol v.\" + protocolVersion + \", socket=\" + socketFactory . getName ( ) + \")\" ) ; \nreturn ; \n} \n} \ncatch ( BindException be ) { \nOLogManager . instance ( ) . warn ( this , \"Port %s:%d busy, trying the next available...\" , iHostName , port ) ; \n} \ncatch ( SocketException se ) { \nOLogManager . instance ( ) . error ( this , \"Unable to create socket\" , se ) ; \nthrow new RuntimeException ( se ) ; \n} \ncatch ( IOException ioe ) { \nOLogManager . instance ( ) . error ( this , \"Unable to read data from an open socket\" , ioe ) ; \nSystem . err . print ( \"Unable to read data from an open socket.\" + \"\\n\" ) ; \nthrow new RuntimeException ( ioe ) ; \n} \n} \nOLogManager . instance ( ) . error ( this , \"Unable to listen for connections using the configured ports '%s' on host '%s'\" , null , iHostPortRange , iHostName ) ; \nthrow new OSystemException ( \"Unable to listen for connections using the configured ports '%s' on host '%s'\" ) ; \n} \n} \n"}
{"3734": "public class FSTBinaryOffheapMap { \npublic void resizeStore ( long required , long maxgrowbytes ) { \nif ( mappedFile == null ) throw new RuntimeException ( \"store is full. Required: \" + required ) ; \nif ( required <= memory . length ( ) ) return ; \nmutationCount ++ ; \nSystem . out . print ( \"resizing underlying \" + mappedFile + \" to \" + required + \" numElem:\" + numElem + \"\\n\" ) ; \nlong tim = System . currentTimeMillis ( ) ; \n( ( MMFBytez ) memory ) . freeAndClose ( ) ; \nmemory = null ; \ntry { \nFile mf = new File ( mappedFile ) ; \nFileOutputStream f = new FileOutputStream ( mf , true ) ; \nlong len = mf . length ( ) ; \nrequired = required + Math . min ( required , maxgrowbytes ) ; \nbyte [ ] toWrite = new byte [ 1000 ] ; \nlong max = ( required - len ) / 1000 ; \nfor ( long i = 0 ; \ni < max + 2 ; \ni ++ ) { \nf . write ( toWrite ) ; \n} \nf . flush ( ) ; \nf . close ( ) ; \nresetMem ( mappedFile , mf . length ( ) ) ; \nSystem . out . print ( \"resizing done in \" + ( System . currentTimeMillis ( ) - tim ) + \" numElemAfter:\" + numElem + \"\\n\" ) ; \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"3772": "public class ReflectionUtils { \npublic static void printThreadInfo ( PrintWriter stream , String title ) { \nfinal int STACK_DEPTH = 20 ; \nboolean contention = threadBean . isThreadContentionMonitoringEnabled ( ) ; \nlong [ ] threadIds = threadBean . getAllThreadIds ( ) ; \nstream . print ( \"Process Thread Dump: \" + title + \"\\n\" ) ; \nstream . print ( threadIds . length + \" active threads\" + \"\\n\" ) ; \nfor ( long tid : threadIds ) { \nThreadInfo info = threadBean . getThreadInfo ( tid , STACK_DEPTH ) ; \nif ( info == null ) { \nstream . print ( \"  Inactive\" + \"\\n\" ) ; \ncontinue ; \n} \nstream . print ( \"Thread \" + getTaskName ( info . getThreadId ( ) , info . getThreadName ( ) ) + \":\" + \"\\n\" ) ; \nThread . State state = info . getThreadState ( ) ; \nstream . print ( \"  State: \" + state + \"\\n\" ) ; \nstream . print ( \"  Blocked count: \" + info . getBlockedCount ( ) + \"\\n\" ) ; \nstream . print ( \"  Waited count: \" + info . getWaitedCount ( ) + \"\\n\" ) ; \nif ( contention ) { \nstream . print ( \"  Blocked time: \" + info . getBlockedTime ( ) + \"\\n\" ) ; \nstream . print ( \"  Waited time: \" + info . getWaitedTime ( ) + \"\\n\" ) ; \n} \nif ( state == Thread . State . WAITING ) { \nstream . print ( \"  Waiting on \" + info . getLockName ( ) + \"\\n\" ) ; \n} \nelse if ( state == Thread . State . BLOCKED ) { \nstream . print ( \"  Blocked on \" + info . getLockName ( ) + \"\\n\" ) ; \nstream . print ( \"  Blocked by \" + getTaskName ( info . getLockOwnerId ( ) , info . getLockOwnerName ( ) ) + \"\\n\" ) ; \n} \nstream . print ( \"  Stack:\" + \"\\n\" ) ; \nfor ( StackTraceElement frame : info . getStackTrace ( ) ) { \nstream . print ( \"    \" + frame . toString ( ) + \"\\n\" ) ; \n} \n} \nstream . flush ( ) ; \n} \n} \n"}
{"3862": "public class JCublasNDArrayFactory { \n@ Override public INDArray createFromNpyFile ( File file ) { \nbyte [ ] pathBytes = file . getAbsolutePath ( ) . getBytes ( Charset . forName ( \"UTF-8\" ) ) ; \nString otherBytes = new String ( pathBytes ) ; \nSystem . out . print ( otherBytes + \"\\n\" ) ; \nByteBuffer directBuffer = ByteBuffer . allocateDirect ( pathBytes . length ) . order ( ByteOrder . nativeOrder ( ) ) ; \ndirectBuffer . put ( pathBytes ) ; \ndirectBuffer . rewind ( ) ; \ndirectBuffer . position ( 0 ) ; \nPointer pointer = nativeOps . numpyFromFile ( new BytePointer ( directBuffer ) ) ; \nINDArray result = createFromNpyPointer ( pointer ) ; \nnativeOps . releaseNumpy ( pointer ) ; \nreturn result ; \n} \n} \n"}
{"4198": "public class CELexer { \npublic void yyerror ( String s ) { \nSystem . err . print ( \"CEParserImpl.yyerror: \" + s + \"; parse failed at char: \" + charno + \"; near: \" + \"\\n\" ) ; \nString context = getInput ( ) ; \nint show = ( context . length ( ) < CONTEXTLEN ? context . length ( ) : CONTEXTLEN ) ; \nSystem . err . print ( context . substring ( context . length ( ) - show ) + \"^\" + \"\\n\" ) ; \nnew Exception ( ) . printStackTrace ( System . err ) ; \n} \n} \n"}
{"4206": "public class CatalogWatcher { \npublic void processEvents ( ) { \nif ( ! enable ) return ; \nfor ( ; \n; \n) { \nWatchKey key ; \ntry { \nkey = watcher . take ( ) ; \n} \ncatch ( InterruptedException x ) { \nreturn ; \n} \nPath dir = keys . get ( key ) ; \nif ( dir == null ) { \nSystem . err . print ( \"WatchKey not recognized!!\" + \"\\n\" ) ; \ncontinue ; \n} \nfor ( WatchEvent < ? > event : key . pollEvents ( ) ) { \nWatchEvent . Kind kind = event . kind ( ) ; \nif ( kind == OVERFLOW ) { \ncontinue ; \n} \nWatchEvent < Path > ev = cast ( event ) ; \nPath name = ev . context ( ) ; \nPath child = dir . resolve ( name ) ; \nSystem . out . format ( \"%s: %s%n\" , event . kind ( ) . name ( ) , child ) ; \nif ( recursive && ( kind == ENTRY_CREATE ) ) { \ntry { \nif ( Files . isDirectory ( child , NOFOLLOW_LINKS ) ) { \nregisterAll ( child ) ; \n} \n} \ncatch ( IOException x ) { \n} \n} \n} \nboolean valid = key . reset ( ) ; \nif ( ! valid ) { \nkeys . remove ( key ) ; \nif ( keys . isEmpty ( ) ) { \nbreak ; \n} \n} \n} \n} \n} \n"}
{"4209": "public class FeatureDatasetFactoryManager { \nstatic public FeatureDataset wrap ( FeatureType wantFeatureType , NetcdfDataset ncd , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { \nif ( debug ) System . out . print ( \"wrap \" + ncd . getLocation ( ) + \" want = \" + wantFeatureType + \"\\n\" ) ; \nif ( ( wantFeatureType == null ) || ( wantFeatureType == FeatureType . ANY ) ) { \nreturn wrapUnknown ( ncd , task , errlog ) ; \n} \nObject analysis = null ; \nFeatureDatasetFactory useFactory = null ; \nfor ( Factory fac : factoryList ) { \nif ( ! featureTypeOk ( wantFeatureType , fac . featureType ) ) continue ; \nif ( debug ) System . out . print ( \" wrap try factory \" + fac . factory . getClass ( ) . getName ( ) + \"\\n\" ) ; \nanalysis = fac . factory . isMine ( wantFeatureType , ncd , errlog ) ; \nif ( analysis != null ) { \nuseFactory = fac . factory ; \nbreak ; \n} \n} \nif ( null == useFactory ) { \nerrlog . format ( \"**Failed to find FeatureDatasetFactory for= %s datatype=%s%n\" , ncd . getLocation ( ) , wantFeatureType ) ; \nreturn null ; \n} \nreturn useFactory . open ( wantFeatureType , ncd , analysis , task , errlog ) ; \n} \n} \n"}
{"4211": "public class FeatureDatasetFactoryManager { \nstatic public FeatureType findFeatureType ( NetcdfFile ncd ) { \nString cdm_datatype = ncd . findAttValueIgnoreCase ( null , CF . FEATURE_TYPE , null ) ; \nif ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , \"cdm_data_type\" , null ) ; \nif ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , \"cdm_datatype\" , null ) ; \nif ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , \"thredds_data_type\" , null ) ; \nif ( cdm_datatype != null ) { \nfor ( FeatureType ft : FeatureType . values ( ) ) if ( cdm_datatype . equalsIgnoreCase ( ft . name ( ) ) ) { \nif ( debug ) System . out . print ( \" wrapUnknown found cdm_datatype \" + cdm_datatype + \"\\n\" ) ; \nreturn ft ; \n} \n} \nCF . FeatureType cff = CF . FeatureType . getFeatureTypeFromGlobalAttribute ( ncd ) ; \nif ( cff != null ) return CF . FeatureType . convert ( cff ) ; \nreturn null ; \n} \n} \n"}
{"4235": "public class N3iosp { \nprivate ucar . ma2 . Array readRecordData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException { \nRange recordRange = section . getRange ( 0 ) ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nN3header . Vinfo vinfo = ( N3header . Vinfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( ( int ) ( vinfo . begin - header . recStart ) ) ; \n} \nif ( header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"Cant read records when recsize > \" + Integer . MAX_VALUE ) ; \nlong nrecs = section . computeSize ( ) ; \nif ( nrecs * header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"Too large read: nrecs * recsize= \" + ( nrecs * header . recsize ) + \"bytes exceeds \" + Integer . MAX_VALUE ) ; \nmembers . setStructureSize ( ( int ) header . recsize ) ; \nArrayStructureBB structureArray = new ArrayStructureBB ( members , new int [ ] { \nrecordRange . length ( ) } \n) ; \nbyte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; \nint count = 0 ; \nfor ( int recnum : recordRange ) { \nif ( debugRecord ) System . out . print ( \" read record \" + recnum + \"\\n\" ) ; \nraf . seek ( header . recStart + recnum * header . recsize ) ; \nif ( recnum != header . numrecs - 1 ) raf . readFully ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \nelse raf . read ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \ncount ++ ; \n} \nreturn structureArray ; \n} \n} \n"}
{"4254": "public class ThreddsDatasetChooser { \npublic static void main ( String args [ ] ) { \nboolean usePopup = false ; \nfor ( int i = 0 ; \ni < args . length ; \ni ++ ) { \nif ( args [ i ] . equals ( \"-usePopup\" ) ) usePopup = true ; \n} \ntry { \nstore = XMLStore . createFromFile ( \"ThreddsDatasetChooser\" , null ) ; \np = store . getPreferences ( ) ; \n} \ncatch ( IOException e ) { \nSystem . out . print ( \"XMLStore Creation failed \" + e + \"\\n\" ) ; \n} \nfinal JFrame frame = new JFrame ( \"Thredds Dataset Chooser\" ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \npublic void windowClosing ( WindowEvent e ) { \nchooser . save ( ) ; \nRectangle bounds = frame . getBounds ( ) ; \np . putBeanObject ( FRAME_SIZE , bounds ) ; \ntry { \nstore . save ( ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \n} \nSystem . exit ( 0 ) ; \n} \n} \n) ; \nchooser = new ThreddsDatasetChooser ( p , null , frame , true , usePopup , false ) ; \nchooser . setDoResolve ( true ) ; \nframe . getContentPane ( ) . add ( chooser ) ; \nRectangle bounds = ( Rectangle ) p . getBean ( FRAME_SIZE , new Rectangle ( 50 , 50 , 800 , 450 ) ) ; \nframe . setBounds ( bounds ) ; \nframe . pack ( ) ; \nframe . setBounds ( bounds ) ; \nframe . setVisible ( true ) ; \n} \n} \n"}
{"4258": "public class SerialWriter { \npublic void writeAtomicArray ( DapType daptype , Object values ) throws IOException { \nassert values != null && values . getClass ( ) . isArray ( ) ; \nByteBuffer buf = SerialWriter . encodeArray ( daptype , values , this . order ) ; \nbyte [ ] bytes = buf . array ( ) ; \nint len = buf . position ( ) ; \nwriteBytes ( bytes , len ) ; \nif ( DEBUG ) { \nSystem . err . printf ( \"%s: \" , daptype . getShortName ( ) ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nint x = ( int ) ( order == ByteOrder . BIG_ENDIAN ? bytes [ i ] : bytes [ ( len - 1 ) - i ] ) ; \nSystem . err . printf ( \"%02x\" , ( int ) ( x & 0xff ) ) ; \n} \nSystem . err . print ( \"\\n\" ) ; \n} \n} \n} \n"}
{"4259": "public class SerialWriter { \npublic void writeBytes ( byte [ ] bytes , int len ) throws IOException { \noutputBytes ( bytes , 0 , len ) ; \nif ( this . checksummode . enabled ( ChecksumMode . DAP ) ) { \nthis . checksum . update ( bytes , 0 , len ) ; \nif ( DUMPCSUM ) { \nSystem . err . print ( \"SSS \" ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nSystem . err . printf ( \"%02x\" , bytes [ i ] ) ; \n} \nSystem . err . print ( \"\\n\" ) ; \n} \n} \n} \n} \n"}
{"4260": "public class SerialWriter { \npublic void outputBytes ( byte [ ] bytes , int start , int count ) throws IOException { \nif ( DUMPDATA ) { \nSystem . err . printf ( \"output %d/%d:\" , start , count ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nSystem . err . printf ( \" %02x\" , bytes [ i ] ) ; \n} \nSystem . err . print ( \"\" + \"\\n\" ) ; \nSystem . err . flush ( ) ; \n} \noutput . write ( bytes , start , count ) ; \n} \n} \n"}
{"4268": "public class McIDASGridReader { \npublic static void main ( String [ ] args ) throws IOException { \nString file = \"GRID2001\" ; \nif ( args . length > 0 ) { \nfile = args [ 0 ] ; \n} \nMcIDASGridReader mg = new McIDASGridReader ( file ) ; \nGridIndex gridIndex = mg . getGridIndex ( ) ; \nList grids = gridIndex . getGridRecords ( ) ; \nSystem . out . print ( \"found \" + grids . size ( ) + \" grids\" + \"\\n\" ) ; \nint num = Math . min ( grids . size ( ) , 10 ) ; \nfor ( int i = 0 ; \ni < num ; \ni ++ ) { \nSystem . out . print ( grids . get ( i ) + \"\\n\" ) ; \n} \n} \n} \n"}
{"4281": "public class GempakGridReader { \npublic void printGrids ( ) { \nList < GridRecord > gridList = gridIndex . getGridRecords ( ) ; \nif ( gridList == null ) return ; \nSystem . out . print ( \"  NUM       TIME1              TIME2           LEVL1 LEVL2  VCORD PARM\" + \"\\n\" ) ; \nfor ( GridRecord aGridList : gridList ) { \nSystem . out . print ( aGridList + \"\\n\" ) ; \n} \n} \n} \n"}
{"4322": "public class SigmetIOServiceProvider { \npublic boolean isValidFile ( ucar . unidata . io . RandomAccessFile raf ) { \ntry { \nraf . order ( RandomAccessFile . LITTLE_ENDIAN ) ; \nraf . seek ( 0 ) ; \nshort [ ] data = new short [ 13 ] ; \nraf . readShort ( data , 0 , 13 ) ; \nreturn ( data [ 0 ] == ( short ) 27 && data [ 6 ] == ( short ) 26 && data [ 12 ] == ( short ) 15 ) ; \n} \ncatch ( IOException ioe ) { \nSystem . out . print ( \"In isValidFile(): \" + ioe . toString ( ) + \"\\n\" ) ; \nreturn false ; \n} \n} \n} \n"}
{"4323": "public class SigmetIOServiceProvider { \npublic java . util . Map < String , String > readStnNames ( ucar . unidata . io . RandomAccessFile raf ) { \njava . util . Map < String , String > hdrNames = new java . util . HashMap < String , String > ( ) ; \ntry { \nraf . seek ( 6288 ) ; \nString stnName = raf . readString ( 16 ) ; \nraf . seek ( 6306 ) ; \nString stnName_util = raf . readString ( 16 ) ; \nhdrNames . put ( \"StationName\" , stnName . trim ( ) ) ; \nhdrNames . put ( \"StationName_SetupUtility\" , stnName_util . trim ( ) ) ; \n} \ncatch ( Exception e ) { \nSystem . out . print ( e . toString ( ) + \"\\n\" ) ; \ne . printStackTrace ( ) ; \n} \nreturn hdrNames ; \n} \n} \n"}
{"4326": "public class SigmetIOServiceProvider { \npublic long readToByteChannel11 ( ucar . nc2 . Variable v2 , Section section , WritableByteChannel channel ) throws java . io . IOException , ucar . ma2 . InvalidRangeException { \nArray data = readData ( v2 , section ) ; \nfloat [ ] ftdata = new float [ ( int ) data . getSize ( ) ] ; \nbyte [ ] bytedata = new byte [ ( int ) data . getSize ( ) * 4 ] ; \nIndexIterator iter = data . getIndexIterator ( ) ; \nint i = 0 ; \nByteBuffer buffer = ByteBuffer . allocateDirect ( bytedata . length ) ; \nwhile ( iter . hasNext ( ) ) { \nftdata [ i ] = iter . getFloatNext ( ) ; \nbytedata [ i ] = new Float ( ftdata [ i ] ) . byteValue ( ) ; \nbuffer . put ( bytedata [ i ] ) ; \ni ++ ; \n} \nbuffer = ByteBuffer . wrap ( bytedata ) ; \nint count = channel . write ( buffer ) ; \nSystem . out . print ( \"COUNT=\" + count + \"\\n\" ) ; \nif ( buffer . hasRemaining ( ) ) { \nbuffer . compact ( ) ; \n} \nelse { \nbuffer . clear ( ) ; \n} \nreturn ( long ) count ; \n} \n} \n"}
{"4344": "public class Format { \nprivate static void show ( double d , int sigfig ) { \nSystem . out . print ( \"Format.d(\" + d + \",\" + sigfig + \") == \" + Format . d ( d , sigfig ) + \"\\n\" ) ; \n} \n} \n"}
{"4345": "public class Format { \nprivate static void show2 ( double d , int dec_places ) { \nSystem . out . print ( \"Format.dfrac(\" + d + \",\" + dec_places + \") == \" + Format . dfrac ( d , dec_places ) + \"\\n\" ) ; \n} \n} \n"}
{"4351": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 , boolean skipdmr ) { \nint savepos = buf0 . position ( ) ; \nint limit0 = buf0 . limit ( ) ; \nint skipcount = 0 ; \nif ( limit0 > MAXLIMIT ) limit0 = MAXLIMIT ; \nif ( limit0 >= buf0 . limit ( ) ) limit0 = buf0 . limit ( ) ; \nif ( skipdmr ) { \nByteOrder saveorder = buf0 . order ( ) ; \nbuf0 . order ( ByteOrder . BIG_ENDIAN ) ; \nskipcount = buf0 . getInt ( ) ; \nbuf0 . order ( saveorder ) ; \nskipcount &= 0xFFFFFF ; \nskipcount += 4 ; \n} \nbyte [ ] bytes = new byte [ ( limit0 + 8 ) - skipcount ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . position ( savepos + skipcount ) ; \nbuf0 . get ( bytes , 0 , limit0 - skipcount ) ; \nbuf0 . position ( savepos ) ; \nSystem . err . print ( \"order=\" + buf0 . order ( ) + \"\\n\" ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \ndumpbytes ( buf ) ; \n} \n} \n"}
{"4352": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 ) { \nint stop = buf0 . limit ( ) ; \nint size = stop + 8 ; \nint savepos = buf0 . position ( ) ; \nassert savepos == 0 ; \nbyte [ ] bytes = new byte [ size ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . get ( bytes , 0 , stop ) ; \nbuf0 . position ( savepos ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \nbuf . position ( 0 ) ; \nbuf . limit ( size ) ; \nint i = 0 ; \ntry { \nfor ( i = 0 ; \nbuf . position ( ) < stop ; \ni ++ ) { \nsavepos = buf . position ( ) ; \nint iv = buf . getInt ( ) ; \nbuf . position ( savepos ) ; \nlong lv = buf . getLong ( ) ; \nbuf . position ( savepos ) ; \nshort sv = buf . getShort ( ) ; \nbuf . position ( savepos ) ; \nbyte b = buf . get ( ) ; \nint ub = ( ( int ) b ) & 0x000000FF ; \nlong uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; \nint usv = ( ( int ) sv ) & 0xFFFF ; \nint ib = ( int ) b ; \nchar c = ( char ) ub ; \nString s = Character . toString ( c ) ; \nif ( c == '\\r' ) s = \"\\\\r\" ; \nelse if ( c == '\\n' ) s = \"\\\\n\" ; \nelse if ( c < ' ' || c >= 0x7f ) s = \"?\" ; \nSystem . err . printf ( \"[%03d] %02x %03d %4d '%s'\" , i , ub , ub , ib , s ) ; \nSystem . err . printf ( \"\\t%12d 0x%08x\" , iv , uiv ) ; \nSystem . err . printf ( \"\\t%5d\\t0x%04x\" , sv , usv ) ; \nSystem . err . print ( \"\\n\" ) ; \nSystem . err . flush ( ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . print ( \"failure:\" + e + \"\\n\" ) ; \n} \nfinally { \nSystem . err . flush ( ) ; \nSystem . err . flush ( ) ; \n} \n} \n} \n"}
{"4357": "public class DodsURLExtractor { \npublic ArrayList extract ( String url ) throws IOException { \nif ( debug ) System . out . print ( \" URLextract=\" + url + \"\\n\" ) ; \nbaseURL = new URL ( url ) ; \nInputStream in = baseURL . openStream ( ) ; \nInputStreamReader r = new InputStreamReader ( filterTag ( in ) , CDM . UTF8 ) ; \nHTMLEditorKit . ParserCallback callback = new CallerBacker ( ) ; \nurlList = new ArrayList ( ) ; \nwantURLS = true ; \nwantText = false ; \nparser . parse ( r , callback , false ) ; \nreturn urlList ; \n} \n} \n"}
{"4358": "public class DodsURLExtractor { \npublic String getTextContent ( String url ) throws IOException { \nif ( debug ) System . out . print ( \" URL.getTextContent=\" + url + \"\\n\" ) ; \nbaseURL = new URL ( url ) ; \nInputStream in = baseURL . openStream ( ) ; \nInputStreamReader r = new InputStreamReader ( filterTag ( in ) , CDM . UTF8 ) ; \nHTMLEditorKit . ParserCallback callback = new CallerBacker ( ) ; \ntextBuffer = new StringBuffer ( 3000 ) ; \nwantURLS = false ; \nwantText = true ; \nparser . parse ( r , callback , false ) ; \nreturn textBuffer . toString ( ) ; \n} \n} \n"}
{"4379": "public class GridHorizCoordSys { \nprivate void makeLC ( ) { \nproj = new LambertConformal ( gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LOV ) , gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) ) ; \nLatLonPointImpl startLL = new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ; \nProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( startLL ) ; \nstartx = start . getX ( ) ; \nstarty = start . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) { \nsetDxDy ( startx , starty , proj ) ; \n} \nif ( GridServiceProvider . debugProj ) { \nSystem . out . print ( \"GridHorizCoordSys.makeLC start at latlon \" + startLL + \"\\n\" ) ; \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . print ( \"GridHorizCoordSys.makeLC end at latlon \" + endLL + \"\\n\" ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . print ( \"   end at proj coord \" + endPP + \"\\n\" ) ; \ndouble endx = startx + getNx ( ) * getDxInKm ( ) ; \ndouble endy = starty + getNy ( ) * getDyInKm ( ) ; \nSystem . out . print ( \"   should be x=\" + endx + \" y=\" + endy + \"\\n\" ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"lambert_conformal_conic\" ) ) ; \nif ( gds . getDouble ( GridDefRecord . LATIN1 ) == gds . getDouble ( GridDefRecord . LATIN2 ) ) { \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; \n} \nelse { \ndouble [ ] data = new double [ ] { \ngds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) } \n; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Array . factory ( DataType . DOUBLE , new int [ ] { \n2 } \n, data ) ) ) ; \n} \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_CENTRAL_MERIDIAN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; \n} \n} \n"}
{"4380": "public class GridHorizCoordSys { \nprivate void makePS ( ) { \nString nproj = gds . getParam ( GridDefRecord . NPPROJ ) ; \ndouble latOrigin = ( nproj == null || nproj . equalsIgnoreCase ( \"true\" ) ) ? 90.0 : - 90.0 ; \ndouble scale ; \ndouble lad = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( lad ) ) { \nscale = .933 ; \n} \nelse { \nscale = ( 1.0 + Math . sin ( Math . toRadians ( Math . abs ( lad ) ) ) ) / 2 ; \n} \nproj = new Stereographic ( latOrigin , gds . getDouble ( GridDefRecord . LOV ) , scale ) ; \nProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ) ; \nstartx = start . getX ( ) ; \nstarty = start . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) setDxDy ( startx , starty , proj ) ; \nif ( GridServiceProvider . debugProj ) { \nSystem . out . printf ( \"starting proj coord %s lat/lon %s%n\" , start , proj . projToLatLon ( start ) ) ; \nSystem . out . print ( \"   should be LA1=\" + gds . getDouble ( GridDefRecord . LA1 ) + \" l)1=\" + gds . getDouble ( GridDefRecord . LO1 ) + \"\\n\" ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"polar_stereographic\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . STRAIGHT_VERTICAL_LONGITUDE_FROM_POLE , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . SCALE_FACTOR_AT_PROJECTION_ORIGIN , scale ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , latOrigin ) ) ; \n} \n} \n"}
{"4381": "public class GridHorizCoordSys { \nprivate void makeMercator ( ) { \ndouble Latin = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( Latin ) ) Latin = gds . getDouble ( GridDefRecord . LATIN ) ; \ndouble Lo1 = gds . getDouble ( GridDefRecord . LO1 ) ; \ndouble La1 = gds . getDouble ( GridDefRecord . LA1 ) ; \nproj = new Mercator ( Lo1 , Latin ) ; \nProjectionPoint startP = proj . latLonToProj ( new LatLonPointImpl ( La1 , Lo1 ) ) ; \nstartx = startP . getX ( ) ; \nstarty = startP . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) { \nsetDxDy ( startx , starty , proj ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"mercator\" ) ) ; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Latin ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lo1 ) ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \nif ( Lo2 < Lo1 ) Lo2 += 360 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . print ( \"GridHorizCoordSys.makeMercator: end at latlon= \" + endLL + \"\\n\" ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . print ( \"   start at proj coord \" + new ProjectionPointImpl ( startx , starty ) + \"\\n\" ) ; \nSystem . out . print ( \"   end at proj coord \" + endPP + \"\\n\" ) ; \ndouble endx = startx + ( getNx ( ) - 1 ) * getDxInKm ( ) ; \ndouble endy = starty + ( getNy ( ) - 1 ) * getDyInKm ( ) ; \nSystem . out . print ( \"   should be x=\" + endx + \" y=\" + endy + \"\\n\" ) ; \n} \n} \n} \n"}
{"4382": "public class GridHorizCoordSys { \nprivate void makeMSGgeostationary ( ) { \ndouble Lat0 = gds . getDouble ( GridDefRecord . LAP ) ; \ndouble Lon0 = gds . getDouble ( GridDefRecord . LOP ) ; \nint ny = gds . getInt ( GridDefRecord . NY ) ; \nint x_off = gds . getInt ( GridDefRecord . XP ) ; \nint y_off = gds . getInt ( GridDefRecord . YP ) ; \ndouble dx ; \ndouble dy = gds . getDouble ( GridDefRecord . DY ) ; \nif ( dy < 2100 ) { \ndx = 1207 ; \ndy = 1203 ; \n} \nelse { \ndx = 3622 ; \ndy = 3610 ; \n} \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( \"major_axis_earth\" ) ; \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \ndouble nr = gds . getDouble ( GridDefRecord . NR ) * 1e-6 ; \ndouble as = 2 * Math . asin ( 1.0 / nr ) ; \ndouble cfac = dx / as ; \ndouble lfac = dy / as ; \ndouble scale_factor = ( nr - 1 ) * major_axis / 1000 ; \ndouble scale_x = scale_factor ; \ndouble scale_y = - scale_factor ; \nstartx = scale_factor * ( 1 - x_off ) / cfac ; \nstarty = scale_factor * ( y_off - ny ) / lfac ; \nincrx = scale_factor / cfac ; \nincry = scale_factor / lfac ; \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"MSGnavigation\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lon0 ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , Lat0 ) ) ; \nattributes . add ( new Attribute ( \"height_from_earth_center\" , nr * major_axis ) ) ; \nattributes . add ( new Attribute ( \"scale_x\" , scale_x ) ) ; \nattributes . add ( new Attribute ( \"scale_y\" , scale_y ) ) ; \nproj = new MSGnavigation ( Lat0 , Lon0 , major_axis , minor_axis , nr * major_axis , scale_x , scale_y ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) + 360.0 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . print ( \"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL + \"\\n\" ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . print ( \"   end at proj coord \" + endPP + \"\\n\" ) ; \ndouble endx = 1 + getNx ( ) ; \ndouble endy = 1 + getNy ( ) ; \nSystem . out . print ( \"   should be x=\" + endx + \" y=\" + endy + \"\\n\" ) ; \n} \n} \n} \n"}
{"4384": "public class InvCatalogFactory10 { \nprotected InvDatasetImpl readDataset ( InvCatalogImpl catalog , InvDatasetImpl parent , Element dsElem , URI base ) { \nString name = dsElem . getAttributeValue ( \"name\" ) ; \nString alias = dsElem . getAttributeValue ( \"alias\" ) ; \nif ( alias != null ) { \nInvDatasetImpl ds = ( InvDatasetImpl ) catalog . findDatasetByID ( alias ) ; \nif ( ds == null ) { \nfactory . appendErr ( \" ** Parse error: dataset named \" + name + \" has illegal alias = \" + alias + \"\\n\" ) ; \nreturn null ; \n} \nreturn new InvDatasetImplProxy ( name , ds ) ; \n} \nInvDatasetImpl dataset = new InvDatasetImpl ( parent , name ) ; \nreadDatasetInfo ( catalog , dataset , dsElem , base ) ; \nif ( InvCatalogFactory . debugXML ) System . out . print ( \" Dataset added: \" + dataset . dump ( ) + \"\\n\" ) ; \nreturn dataset ; \n} \n} \n"}
{"4385": "public class InvCatalogFactory10 { \nprotected InvDatasetScan readDatasetScan ( InvCatalogImpl catalog , InvDatasetImpl parent , Element dsElem , URI base ) { \nInvDatasetScan datasetScan ; \nif ( dsElem . getAttributeValue ( \"dirLocation\" ) == null ) { \nif ( dsElem . getAttributeValue ( \"location\" ) == null ) { \nlogger . error ( \"readDatasetScan(): datasetScan has neither a \\\"location\\\" nor a \\\"dirLocation\\\" attribute.\" ) ; \ndatasetScan = null ; \n} \nelse { \nreturn readDatasetScanNew ( catalog , parent , dsElem , base ) ; \n} \n} \nelse { \nString name = dsElem . getAttributeValue ( \"name\" ) ; \nfactory . appendWarning ( \"**Warning: Dataset \" + name + \" using old form of DatasetScan (dirLocation instead of location)\\n\" ) ; \nString path = dsElem . getAttributeValue ( \"path\" ) ; \nString scanDir = expandAliasForPath ( dsElem . getAttributeValue ( \"dirLocation\" ) ) ; \nString filter = dsElem . getAttributeValue ( \"filter\" ) ; \nString addDatasetSizeString = dsElem . getAttributeValue ( \"addDatasetSize\" ) ; \nString addLatest = dsElem . getAttributeValue ( \"addLatest\" ) ; \nString sortOrderIncreasingString = dsElem . getAttributeValue ( \"sortOrderIncreasing\" ) ; \nboolean sortOrderIncreasing = false ; \nif ( sortOrderIncreasingString != null ) if ( sortOrderIncreasingString . equalsIgnoreCase ( \"true\" ) ) sortOrderIncreasing = true ; \nboolean addDatasetSize = true ; \nif ( addDatasetSizeString != null ) if ( addDatasetSizeString . equalsIgnoreCase ( \"false\" ) ) addDatasetSize = false ; \nif ( path != null ) { \nif ( path . charAt ( 0 ) == '/' ) path = path . substring ( 1 ) ; \nint last = path . length ( ) - 1 ; \nif ( path . charAt ( last ) == '/' ) path = path . substring ( 0 , last ) ; \n} \nif ( scanDir != null ) { \nint last = scanDir . length ( ) - 1 ; \nif ( scanDir . charAt ( last ) != '/' ) scanDir = scanDir + '/' ; \n} \nElement atcElem = dsElem . getChild ( \"addTimeCoverage\" , defNS ) ; \nString dsNameMatchPattern = null ; \nString startTimeSubstitutionPattern = null ; \nString duration = null ; \nif ( atcElem != null ) { \ndsNameMatchPattern = atcElem . getAttributeValue ( \"datasetNameMatchPattern\" ) ; \nstartTimeSubstitutionPattern = atcElem . getAttributeValue ( \"startTimeSubstitutionPattern\" ) ; \nduration = atcElem . getAttributeValue ( \"duration\" ) ; \n} \ntry { \ndatasetScan = new InvDatasetScan ( catalog , parent , name , path , scanDir , filter , addDatasetSize , addLatest , sortOrderIncreasing , dsNameMatchPattern , startTimeSubstitutionPattern , duration ) ; \nreadDatasetInfo ( catalog , datasetScan , dsElem , base ) ; \nif ( InvCatalogFactory . debugXML ) System . out . print ( \" Dataset added: \" + datasetScan . dump ( ) + \"\\n\" ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"Reading DatasetScan\" , e ) ; \ndatasetScan = null ; \n} \n} \nreturn datasetScan ; \n} \n} \n"}
{"4386": "public class InvCatalogFactory10 { \npublic Object readMetadataContentFromURL ( InvDataset dataset , java . net . URI uri ) throws java . io . IOException { \nElement elem = readContentFromURL ( uri ) ; \nObject contentObject = readMetadataContent ( dataset , elem ) ; \nif ( debugMetadataRead ) System . out . print ( \" convert to \" + contentObject . getClass ( ) . getName ( ) + \"\\n\" ) ; \nreturn contentObject ; \n} \n} \n"}
{"4424": "public class CoordSysBuilder { \n@ Override public void buildCoordinateSystems ( NetcdfDataset ncDataset ) { \nparseInfo . format ( \"Parsing with Convention = %s%n\" , conventionName ) ; \naddVariables ( ncDataset , ncDataset . getVariables ( ) , varList ) ; \nfindCoordinateAxes ( ncDataset ) ; \nfindCoordinateSystems ( ncDataset ) ; \nfindCoordinateTransforms ( ncDataset ) ; \nmakeCoordinateAxes ( ncDataset ) ; \nmakeCoordinateSystems ( ncDataset ) ; \nassignCoordinateSystemsExplicit ( ncDataset ) ; \nmakeCoordinateSystemsImplicit ( ncDataset ) ; \nif ( useMaximalCoordSys ) makeCoordinateSystemsMaximal ( ncDataset ) ; \nmakeCoordinateTransforms ( ncDataset ) ; \nassignCoordinateTransforms ( ncDataset ) ; \nif ( debug ) System . out . print ( \"parseInfo = \\n\" + parseInfo . toString ( ) + \"\\n\" ) ; \n} \n} \n"}
{"4433": "public class InvCatalogImpl { \nprivate boolean mark ( DatasetFilter filter , InvDatasetImpl ds ) { \nif ( ds instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) ds ; \nif ( ! catRef . isRead ( ) ) return false ; \n} \nboolean allMarked = true ; \nfor ( InvDataset nested : ds . getDatasets ( ) ) { \nallMarked &= mark ( filter , ( InvDatasetImpl ) nested ) ; \n} \nif ( ! allMarked ) return false ; \nif ( filter . accept ( ds ) >= 0 ) return false ; \nds . setMark ( true ) ; \nif ( debugFilter ) System . out . print ( \" mark \" + ds . getName ( ) + \"\\n\" ) ; \nreturn true ; \n} \n} \n"}
{"4434": "public class InvCatalogImpl { \nprivate void delete ( InvDatasetImpl ds ) { \nif ( ds instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) ds ; \nif ( ! catRef . isRead ( ) ) return ; \n} \nIterator iter = ds . getDatasets ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nInvDatasetImpl nested = ( InvDatasetImpl ) iter . next ( ) ; \nif ( nested . getMark ( ) ) { \niter . remove ( ) ; \nif ( debugFilter ) System . out . print ( \" remove \" + nested . getName ( ) + \"\\n\" ) ; \n} \nelse delete ( nested ) ; \n} \n} \n} \n"}
{"4473": "public class KMPMatch { \npublic int indexOf ( byte [ ] data , int start , int max ) { \nint j = 0 ; \nif ( data . length == 0 ) return - 1 ; \nif ( start + max > data . length ) System . out . print ( \"HEY KMPMatch\" + \"\\n\" ) ; \nfor ( int i = start ; \ni < start + max ; \ni ++ ) { \nwhile ( j > 0 && match [ j ] != data [ i ] ) j = failure [ j - 1 ] ; \nif ( match [ j ] == data [ i ] ) j ++ ; \nif ( j == match . length ) return i - match . length + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"4481": "public class RandomValue { \npublic int nextCount ( int max ) throws DapException { \nint min = 1 ; \nif ( max < min || min < 1 ) throw new DapException ( \"bad range\" ) ; \nint range = ( max + 1 ) - min ; \nint n = random . nextInt ( range ) ; \nn = n + min ; \nif ( DEBUG ) System . err . print ( \"RandomValue.nextCount: \" + n + \"\\n\" ) ; \nreturn n ; \n} \n} \n"}
{"4484": "public class NexradStationDB { \nprivate static void readStationTable ( ) throws IOException { \nstationTableHash = new HashMap < String , Station > ( ) ; \nClassLoader cl = Level2VolumeScan . class . getClassLoader ( ) ; \nInputStream is = cl . getResourceAsStream ( \"resources/nj22/tables/nexrad.tbl\" ) ; \nList < TableParser . Record > recs = TableParser . readTable ( is , \"3,15,46, 54,60d,67d,73d\" , 50000 ) ; \nfor ( TableParser . Record record : recs ) { \nStation s = new Station ( ) ; \ns . id = \"K\" + record . get ( 0 ) ; \ns . name = record . get ( 2 ) + \" \" + record . get ( 3 ) ; \ns . lat = ( Double ) record . get ( 4 ) * .01 ; \ns . lon = ( Double ) record . get ( 5 ) * .01 ; \ns . elev = ( Double ) record . get ( 6 ) ; \nstationTableHash . put ( s . id , s ) ; \nif ( showStations ) System . out . print ( \" station= \" + s + \"\\n\" ) ; \n} \n} \n} \n"}
{"4490": "public class ScaledPanel { \nprivate AffineTransform calcTransform ( Rectangle2D screen , Bounds world ) { \ndouble xs = screen . getWidth ( ) / ( world . getRight ( ) - world . getLeft ( ) ) ; \ndouble ys = screen . getHeight ( ) / ( world . getLower ( ) - world . getUpper ( ) ) ; \nAffineTransform cat = new AffineTransform ( ) ; \ncat . setToScale ( xs , ys ) ; \ncat . translate ( - world . getLeft ( ) , - world . getUpper ( ) ) ; \nif ( debugTransform ) { \nSystem . out . print ( \"TPanel calcTransform = \" + \"\\n\" ) ; \nSystem . out . print ( \"  screen = \" + screen + \"\\n\" ) ; \nSystem . out . print ( \"  world = \" + world + \"\\n\" ) ; \nSystem . out . print ( \"  transform = \" + cat . getScaleX ( ) + \" \" + cat . getShearX ( ) + \" \" + cat . getTranslateX ( ) + \"\\n\" ) ; \nSystem . out . print ( \"              \" + cat . getShearY ( ) + \" \" + cat . getScaleY ( ) + \" \" + cat . getTranslateY ( ) + \"\\n\" ) ; \nPoint2D src = new Point2D . Double ( world . getLeft ( ) , world . getUpper ( ) ) ; \nPoint2D dst = new Point2D . Double ( 0.0 , 0.0 ) ; \nSystem . out . print ( \"  upper left pt = \" + src + \"\\n\" ) ; \nSystem . out . print ( \"  transform = \" + cat . transform ( src , dst ) + \"\\n\" ) ; \nsrc = new Point2D . Double ( world . getRight ( ) , world . getLower ( ) ) ; \nSystem . out . print ( \"  lower right pt = \" + src + \"\\n\" ) ; \nSystem . out . print ( \"  transform = \" + cat . transform ( src , dst ) + \"\\n\" ) ; \n} \nreturn cat ; \n} \n} \n"}
{"4496": "public class CatGenConfigMetadataFactory { \nprivate Object readMetadataContentFromURL ( InvDataset dataset , String urlString ) throws java . net . MalformedURLException , java . io . IOException { \nDocument doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( true ) ; \ndoc = builder . build ( urlString ) ; \n} \ncatch ( JDOMException e ) { \nlog . error ( \"CatGenConfigMetadataFactory parsing error= \\n\" + e . getMessage ( ) ) ; \nthrow new java . io . IOException ( \"CatGenConfigMetadataFactory parsing error= \" + e . getMessage ( ) ) ; \n} \nif ( showParsedXML ) { \nXMLOutputter xmlOut = new XMLOutputter ( Format . getPrettyFormat ( ) ) ; \nSystem . out . print ( \"*** catalog/showParsedXML = \\n\" + xmlOut . outputString ( doc ) + \"\\n*******\" + \"\\n\" ) ; \n} \nreturn ( readMetadataContentJdom ( dataset , doc . getRootElement ( ) ) ) ; \n} \n} \n"}
{"4510": "public class Debug { \nstatic public boolean isSet ( String flagName ) { \nif ( store == null ) return false ; \nNamePart np = partit ( flagName ) ; \nif ( debug ) { \ntry { \nif ( ( np . storeName . length ( ) > 0 ) && ! store . nodeExists ( np . storeName ) ) System . out . print ( \"Debug.isSet create node = \" + flagName + \" \" + np + \"\\n\" ) ; \nelse if ( null == store . node ( np . storeName ) . get ( np . keyName , null ) ) System . out . print ( \"Debug.isSet create flag = \" + flagName + \" \" + np + \"\\n\" ) ; \n} \ncatch ( BackingStoreException e ) { \n} \n} \nboolean value = store . node ( np . storeName ) . getBoolean ( np . keyName , false ) ; \nstore . node ( np . storeName ) . putBoolean ( np . keyName , value ) ; \nreturn value ; \n} \n} \n"}
{"4511": "public class Debug { \nstatic public void constructMenu ( JMenu topMenu ) { \nif ( debug ) System . out . print ( \"Debug.constructMenu \" + \"\\n\" ) ; \nif ( topMenu . getItemCount ( ) > 0 ) topMenu . removeAll ( ) ; \ntry { \naddToMenu ( topMenu , store ) ; \n} \ncatch ( BackingStoreException e ) { \n} \ntopMenu . revalidate ( ) ; \n} \n} \n"}
{"4512": "public class Debug { \nstatic private void addToMenu ( JMenu menu , Preferences prefs ) throws BackingStoreException { \nif ( debug ) System . out . print ( \" addMenu \" + prefs . name ( ) + \"\\n\" ) ; \nString [ ] keys = prefs . keys ( ) ; \nfor ( String key : keys ) { \nboolean bval = prefs . getBoolean ( key , false ) ; \nString fullname = prefs . absolutePath ( ) + \"/\" + key ; \nmenu . add ( new DebugMenuItem ( fullname , key , bval ) ) ; \nif ( debug ) System . out . print ( \"   leaf= <\" + key + \"><\" + fullname + \">\" + \"\\n\" ) ; \n} \nString [ ] kidName = prefs . childrenNames ( ) ; \nfor ( String aKidName : kidName ) { \nPreferences pkid = prefs . node ( aKidName ) ; \nJMenu subMenu = new JMenu ( pkid . name ( ) ) ; \nmenu . add ( subMenu ) ; \naddToMenu ( subMenu , pkid ) ; \n} \n} \n} \n"}
{"4521": "public class Field { \nstatic private void showFormatInfo ( JFormattedTextField tf ) { \nJFormattedTextField . AbstractFormatter ff = tf . getFormatter ( ) ; \nSystem . out . print ( \"AbstractFormatter  \" + ff . getClass ( ) . getName ( ) + \"\\n\" ) ; \nif ( ff instanceof NumberFormatter ) { \nNumberFormatter nf = ( NumberFormatter ) ff ; \nFormat f = nf . getFormat ( ) ; \nSystem . out . print ( \" Format  = \" + f . getClass ( ) . getName ( ) + \"\\n\" ) ; \nif ( f instanceof NumberFormat ) { \nNumberFormat nfat = ( NumberFormat ) f ; \nSystem . out . print ( \" getMinimumIntegerDigits=\" + nfat . getMinimumIntegerDigits ( ) + \"\\n\" ) ; \nSystem . out . print ( \" getMaximumIntegerDigits=\" + nfat . getMaximumIntegerDigits ( ) + \"\\n\" ) ; \nSystem . out . print ( \" getMinimumFractionDigits=\" + nfat . getMinimumFractionDigits ( ) + \"\\n\" ) ; \nSystem . out . print ( \" getMaximumFractionDigits=\" + nfat . getMaximumFractionDigits ( ) + \"\\n\" ) ; \n} \nif ( f instanceof DecimalFormat ) { \nDecimalFormat df = ( DecimalFormat ) f ; \nSystem . out . print ( \" Pattern  = \" + df . toPattern ( ) + \"\\n\" ) ; \n} \n} \n} \n} \n"}
{"4527": "public class DODSNetcdfFile { \nDimension getNetcdfStrlenDim ( DODSVariable v ) { \nAttributeTable table = das . getAttributeTableN ( v . getFullName ( ) ) ; \nif ( table == null ) return null ; \nopendap . dap . Attribute dodsAtt = table . getAttribute ( \"DODS\" ) ; \nif ( dodsAtt == null ) return null ; \nAttributeTable dodsTable = dodsAtt . getContainerN ( ) ; \nif ( dodsTable == null ) return null ; \nopendap . dap . Attribute att = dodsTable . getAttribute ( \"strlen\" ) ; \nif ( att == null ) return null ; \nString strlen = att . getValueAtN ( 0 ) ; \nopendap . dap . Attribute att2 = dodsTable . getAttribute ( \"dimName\" ) ; \nString dimName = ( att2 == null ) ? null : att2 . getValueAtN ( 0 ) ; \nif ( debugCharArray ) System . out . print ( v . getFullName ( ) + \" has strlen= \" + strlen + \" dimName= \" + dimName + \"\\n\" ) ; \nint dimLength ; \ntry { \ndimLength = Integer . parseInt ( strlen ) ; \n} \ncatch ( NumberFormatException e ) { \nlogger . warn ( \"DODSNetcdfFile \" + location + \" var = \" + v . getFullName ( ) + \" error on strlen attribute = \" + strlen ) ; \nreturn null ; \n} \nif ( dimLength <= 0 ) return null ; \nreturn new Dimension ( dimName , dimLength , dimName != null ) ; \n} \n} \n"}
{"4531": "public class DODSNetcdfFile { \nDataDDS readDataDDSfromServer ( String CE ) throws IOException , opendap . dap . DAP2Exception { \nif ( debugServerCall ) System . out . print ( \"DODSNetcdfFile.readDataDDSfromServer = <\" + CE + \">\" + \"\\n\" ) ; \nlong start = 0 ; \nif ( debugTime ) start = System . currentTimeMillis ( ) ; \nif ( ! CE . startsWith ( \"?\" ) ) CE = \"?\" + CE ; \nDataDDS data ; \nsynchronized ( this ) { \ndata = dodsConnection . getData ( CE , null ) ; \n} \nif ( debugTime ) System . out . print ( \"DODSNetcdfFile.readDataDDSfromServer took = \" + ( System . currentTimeMillis ( ) - start ) / 1000.0 + \"\\n\" ) ; \nif ( debugDataResult ) { \nSystem . out . print ( \" dataDDS return:\" + \"\\n\" ) ; \ndata . print ( System . out ) ; \n} \nreturn data ; \n} \n} \n"}
{"4532": "public class Resource { \npublic static ImageIcon getIcon ( String fullIconName , boolean errMsg ) { \nImageIcon icon = null ; \njava . net . URL iconR = cl . getResource ( fullIconName ) ; \nif ( debugIcon ) { \nSystem . out . print ( \"classLoader \" + cl . getClassLoader ( ) + \"\\n\" ) ; \nSystem . out . print ( \"  Resource.getIcon on \" + fullIconName + \" = \" + iconR + \"\\n\" ) ; \n} \nif ( iconR != null ) icon = new ImageIcon ( iconR ) ; \nif ( ( icon == null ) && errMsg ) System . out . print ( \"  ERROR: Resource.getIcon failed on \" + fullIconName + \"\\n\" ) ; \nelse if ( debugIcon ) System . out . print ( \"  Resource.getIcon ok on \" + fullIconName + \"\\n\" ) ; \nreturn icon ; \n} \n} \n"}
{"4533": "public class Resource { \npublic static Image getImage ( String fullImageName ) { \nImage image = null ; \njava . net . URL url = cl . getResource ( fullImageName ) ; \nif ( url != null ) image = Toolkit . getDefaultToolkit ( ) . createImage ( url ) ; \nif ( image == null ) System . out . print ( \"  ERROR: Resource.getImageResource failed on \" + fullImageName + \"\\n\" ) ; \nreturn image ; \n} \n} \n"}
{"4534": "public class Resource { \npublic static Cursor makeCursor ( String name ) { \nImage image = getImage ( name ) ; \nif ( null == image ) return null ; \nCursor cursor ; \ntry { \nToolkit tk = Toolkit . getDefaultToolkit ( ) ; \nif ( debug ) { \nImageObserver obs = new ImageObserver ( ) { \npublic boolean imageUpdate ( Image image , int flags , int x , int y , int width , int height ) { \nreturn true ; \n} \n} \n; \nSystem . out . print ( \" bestCursorSize = \" + tk . getBestCursorSize ( image . getWidth ( obs ) , image . getHeight ( obs ) ) + \"\\n\" ) ; \nSystem . out . print ( \" getMaximumCursorColors = \" + tk . getMaximumCursorColors ( ) + \"\\n\" ) ; \n} \ncursor = tk . createCustomCursor ( image , new Point ( 17 , 17 ) , name ) ; \n} \ncatch ( IndexOutOfBoundsException e ) { \nSystem . out . print ( \"NavigatedPanel createCustomCursor failed \" + e + \"\\n\" ) ; \nreturn null ; \n} \nreturn cursor ; \n} \n} \n"}
{"4562": "public class DatasetFilter { \nprivate boolean match ( InvDataset dataset ) { \nif ( this . getParentDatasetSource ( ) . isCollection ( dataset ) && ! this . applyToCollectionDatasets ) return ( false ) ; \nif ( ( ! this . getParentDatasetSource ( ) . isCollection ( dataset ) ) && ! this . applyToAtomicDatasets ) return ( false ) ; \nif ( this . matchPatternTarget == null ) { \nif ( this . getParentDatasetSource ( ) . isCollection ( dataset ) ) { \nthis . setMatchPatternTarget ( \"name\" ) ; \n} \nelse { \nthis . setMatchPatternTarget ( \"urlPath\" ) ; \n} \n} \nif ( this . type == DatasetFilter . Type . REGULAR_EXPRESSION ) { \nboolean isMatch ; \nif ( this . getMatchPatternTarget ( ) . equals ( \"name\" ) ) { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( dataset . getName ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nelse if ( this . getMatchPatternTarget ( ) . equals ( \"urlPath\" ) ) { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( ( ( InvDatasetImpl ) dataset ) . getUrlPath ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nelse { \nisMatch = false ; \n} \nreturn ( isMatch ) ; \n} \nelse { \nSystem . err . print ( \"WARNING -- DatasetFilter.accept(): unsupported type\" + \" <\" + this . type . toString ( ) + \">.\" + \"\\n\" ) ; \nreturn ( false ) ; \n} \n} \n} \n"}
{"4565": "public class CEEvaluator { \npublic boolean evalClauses ( Object specialO ) throws NoSuchVariableException , DAP2ServerSideException , IOException { \nboolean result = true ; \nEnumeration ec = getClauses ( ) ; \nwhile ( ec . hasMoreElements ( ) && result == true ) { \nObject o = ec . nextElement ( ) ; \nif ( _Debug ) { \nSystem . out . print ( \"Evaluating clause: \" + ec . nextElement ( ) + \"\\n\" ) ; \n} \nresult = ( ( TopLevelClause ) o ) . evaluate ( ) ; \n} \nreturn ( result ) ; \n} \n} \n"}
{"4574": "public class LayoutM { \npublic void addLayoutComponent ( Component comp , Object constraint ) { \nif ( debug ) System . out . print ( name + \" addLayoutComponent= \" + comp . getClass ( ) . getName ( ) + \" \" + comp . hashCode ( ) + \" \" + constraint + \"\\n\" ) ; \nif ( ! ( constraint instanceof Constraint ) ) throw new IllegalArgumentException ( \"MySpringLayout must be Constraint\" ) ; \nconstraintMap . put ( comp , constraint ) ; \nglobalBounds = null ; \n} \n} \n"}
{"4575": "public class LayoutM { \npublic void invalidateLayout ( Container target ) { \nif ( debug ) System . out . print ( name + \" invalidateLayout \" + \"\\n\" ) ; \nglobalBounds = null ; \n} \n} \n"}
{"4576": "public class LayoutM { \npublic void removeLayoutComponent ( Component comp ) { \nif ( debug ) System . out . print ( \"removeLayoutComponent\" + \"\\n\" ) ; \nconstraintMap . remove ( comp ) ; \nglobalBounds = null ; \n} \n} \n"}
{"4577": "public class LayoutM { \npublic Dimension minimumLayoutSize ( Container parent ) { \nif ( debug ) System . out . print ( \"minimumLayoutSize\" + \"\\n\" ) ; \nif ( globalBounds == null ) layoutContainer ( parent ) ; \nreturn globalBounds . getSize ( ) ; \n} \n} \n"}
{"4578": "public class LayoutM { \npublic void layoutContainer ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nif ( debug ) System . out . print ( name + \" layoutContainer \" + \"\\n\" ) ; \nint n = target . getComponentCount ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nComponent comp = target . getComponent ( i ) ; \nif ( comp instanceof Container ) { \nContainer c = ( Container ) comp ; \nLayoutManager m = c . getLayout ( ) ; \nif ( m instanceof LayoutM ) m . layoutContainer ( c ) ; \n} \n} \nreset ( target ) ; \nglobalBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; \nwhile ( ! layoutPass ( target ) ) target . setPreferredSize ( globalBounds . getSize ( ) ) ; \n} \n} \n} \n"}
{"4589": "public class CFPointObWriter { \npublic static boolean rewritePointFeatureDataset ( String fileIn , String fileOut , boolean inMemory ) throws IOException { \nSystem . out . print ( \"Rewrite2 .nc files from \" + fileIn + \" to \" + fileOut + \" inMemory= \" + inMemory + \"\\n\" ) ; \nlong start = System . currentTimeMillis ( ) ; \nNetcdfFile ncfile = inMemory ? NetcdfFile . openInMemory ( fileIn ) : NetcdfFile . open ( fileIn ) ; \nNetcdfDataset ncd = new NetcdfDataset ( ncfile ) ; \nFormatter errlog = new Formatter ( ) ; \nFeatureDataset fd = FeatureDatasetFactoryManager . wrap ( FeatureType . ANY_POINT , ncd , null , errlog ) ; \nif ( fd == null ) return false ; \nif ( fd instanceof FeatureDatasetPoint ) { \nwritePointFeatureCollection ( ( FeatureDatasetPoint ) fd , fileOut ) ; \nfd . close ( ) ; \nlong took = System . currentTimeMillis ( ) - start ; \nSystem . out . print ( \" that took \" + ( took - start ) + \" msecs\" + \"\\n\" ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4634": "public class DodsV { \nvoid parseDAS ( DAS das ) throws IOException { \nEnumeration tableNames = das . getNames ( ) ; \nwhile ( tableNames . hasMoreElements ( ) ) { \nString tableName = ( String ) tableNames . nextElement ( ) ; \nAttributeTable attTable = das . getAttributeTableN ( tableName ) ; \nif ( tableName . equals ( \"NC_GLOBAL\" ) || tableName . equals ( \"HDF_GLOBAL\" ) ) { \naddAttributeTable ( this , attTable , tableName , true ) ; \n} \nelse if ( tableName . equals ( \"DODS_EXTRA\" ) || tableName . equals ( \"EXTRA_DIMENSION\" ) ) { \ncontinue ; \n} \nelse { \nDodsV dodsV = findDodsV ( tableName , false ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \ndodsV = findTableDotDelimited ( tableName ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \nif ( debugAttributes ) System . out . print ( \"DODSNetcdf getAttributes CANT find <\" + tableName + \"> add to globals\" + \"\\n\" ) ; \naddAttributeTable ( this , attTable , tableName , false ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4647": "public class Variable { \nprotected Array _read ( ) throws IOException { \nif ( cache . data != null ) { \nif ( debugCaching ) System . out . print ( \"got data from cache \" + getFullName ( ) + \"\\n\" ) ; \nreturn cache . data . copy ( ) ; \n} \nArray data = proxyReader . reallyRead ( this , null ) ; \nif ( isCaching ( ) ) { \nsetCachedData ( data ) ; \nif ( debugCaching ) System . out . print ( \"cache \" + getFullName ( ) + \"\\n\" ) ; \nreturn cache . data . copy ( ) ; \n} \nelse { \nreturn data ; \n} \n} \n} \n"}
{"4648": "public class Variable { \nprotected Array _read ( Section section ) throws IOException , InvalidRangeException { \nif ( ( null == section ) || section . computeSize ( ) == getSize ( ) ) return _read ( ) ; \nif ( isCaching ( ) ) { \nif ( cache . data == null ) { \nsetCachedData ( _read ( ) ) ; \nif ( debugCaching ) System . out . print ( \"cache \" + getFullName ( ) + \"\\n\" ) ; \n} \nif ( debugCaching ) System . out . print ( \"got data from cache \" + getFullName ( ) + \"\\n\" ) ; \nreturn cache . data . sectionNoReduce ( section . getRanges ( ) ) . copy ( ) ; \n} \nreturn proxyReader . reallyRead ( this , section , null ) ; \n} \n} \n"}
{"4664": "public class CDMDSP { \npublic void buildDMR ( ) throws DapException { \nif ( getDMR ( ) != null ) return ; \ntry { \nif ( DUMPCDL ) { \nSystem . out . print ( \"writecdl:\" + \"\\n\" ) ; \nthis . ncdfile . writeCDL ( System . out , false ) ; \nSystem . out . flush ( ) ; \n} \nString name = this . ncdfile . getLocation ( ) ; \nname = DapUtil . canonicalpath ( name ) ; \nint index = name . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) name = name . substring ( index + 1 , name . length ( ) ) ; \nsetDMR ( ( DapDataset ) dmrfactory . newDataset ( name ) . annotate ( NetcdfDataset . class , this . ncdfile ) ) ; \nrecordNode ( this . ncdfile . getRootGroup ( ) , getDMR ( ) ) ; \ngetDMR ( ) . setBase ( DapUtil . canonicalpath ( this . ncdfile . getLocation ( ) ) ) ; \nfillgroup ( getDMR ( ) , this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . sort ( ) ; \nprocessmappedvariables ( this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . finish ( ) ; \n} \ncatch ( DapException e ) { \nsetDMR ( null ) ; \nthrow new DapException ( e ) ; \n} \n} \n} \n"}
{"4672": "public class Navigation { \npublic AffineTransform getTransform ( ) { \nat . setTransform ( pix_per_world , 0.0 , 0.0 , - pix_per_world , pix_x0 , pix_y0 ) ; \nif ( debug ) { \nSystem . out . print ( \"Navigation getTransform = \" + pix_per_world + \" \" + pix_x0 + \" \" + pix_y0 + \"\\n\" ) ; \nSystem . out . print ( \"  transform = \" + at + \"\\n\" ) ; \n} \nreturn at ; \n} \n} \n"}
{"4677": "public class Navigation { \npublic void zoom ( double startx , double starty , double width , double height ) { \nif ( debugZoom ) System . out . print ( \"zoom \" + startx + \" \" + starty + \" \" + width + \" \" + height + \" \" + \"\\n\" ) ; \nif ( ( width < 5 ) || ( height < 5 ) ) return ; \nzoom . push ( ) ; \npix_x0 -= startx + width / 2 - pwidth / 2 ; \npix_y0 -= starty + height / 2 - pheight / 2 ; \nzoom ( pwidth / width ) ; \n} \n} \n"}
{"4678": "public class Navigation { \nprivate void recalcFromBoundingBox ( ) { \nif ( debugRecalc ) { \nSystem . out . print ( \"Navigation recalcFromBoundingBox= \" + bb + \"\\n\" ) ; \nSystem . out . print ( \"  \" + pwidth + \" \" + pheight + \"\\n\" ) ; \n} \ndouble pixx_per_wx = ( bb . getWidth ( ) == 0.0 ) ? 1 : pwidth / bb . getWidth ( ) ; \ndouble pixy_per_wy = ( bb . getHeight ( ) == 0.0 ) ? 1 : pheight / bb . getHeight ( ) ; \npix_per_world = Math . min ( pixx_per_wx , pixy_per_wy ) ; \ndouble wx0 = bb . getX ( ) + bb . getWidth ( ) / 2 ; \ndouble wy0 = bb . getY ( ) + bb . getHeight ( ) / 2 ; \npix_x0 = pwidth / 2 - pix_per_world * wx0 ; \npix_y0 = pheight / 2 + pix_per_world * wy0 ; \nif ( debugRecalc ) { \nSystem . out . print ( \"Navigation recalcFromBoundingBox done= \" + pix_per_world + \" \" + pix_x0 + \" \" + pix_y0 + \"\\n\" ) ; \nSystem . out . print ( \"  \" + pwidth + \" \" + pheight + \" \" + bb + \"\\n\" ) ; \n} \n} \n} \n"}
{"4693": "public class AccessLogParser { \npublic static void main ( String [ ] args ) throws IOException { \nAccessLogParser p = new AccessLogParser ( ) ; \nString line = \"24.18.236.132 - - [04/Feb/2011:17:49:03 -0700] \\\"GET /thredds/fileServer//nexrad/level3/N0R/YUX/20110205/Level3_YUX_N0R_20110205_0011.nids \\\" 200 10409 \\\"-\\\" \\\"-\\\" 17\" ; \nMatcher m = regPattern . matcher ( line ) ; \nSystem . out . printf ( \"%s %s%n\" , m . matches ( ) , m ) ; \nfor ( int i = 0 ; \ni < m . groupCount ( ) ; \ni ++ ) { \nSystem . out . print ( \" \" + i + \" \" + m . group ( i ) + \"\\n\" ) ; \n} \nLogReader . Log log = p . parseLog ( line ) ; \nSystem . out . printf ( \"%s%n\" , log ) ; \n} \n} \n"}
{"4701": "public class DConnect2 { \nprivate void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { \nInputStream is = null ; \ntry { \ntry ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { \nif ( acceptCompress ) method . setCompression ( \"deflate,gzip\" ) ; \nif ( allowSessions ) method . setUseSessions ( true ) ; \nint statusCode ; \nfor ( ; \n; \n) { \nstatusCode = method . execute ( ) ; \nif ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) break ; \nThread . sleep ( 5000 ) ; \nSystem . err . print ( \"Service Unavailable\" + \"\\n\" ) ; \n} \nif ( statusCode == HttpStatus . SC_NOT_FOUND ) { \nthrow new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + \": \" + urlString ) ; \n} \nif ( statusCode == HttpStatus . SC_UNAUTHORIZED || statusCode == HttpStatus . SC_FORBIDDEN ) { \nthrow new InvalidCredentialsException ( method . getStatusText ( ) ) ; \n} \nif ( statusCode != HttpStatus . SC_OK ) { \nthrow new DAP2Exception ( \"Method failed:\" + method . getStatusText ( ) + \" on URL= \" + urlString ) ; \n} \nis = method . getResponseAsStream ( ) ; \nHeader header = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( header != null && ( header . getValue ( ) . equals ( \"dods-error\" ) || header . getValue ( ) . equals ( \"dods_error\" ) ) ) { \nDAP2Exception ds = new DAP2Exception ( ) ; \nds . parse ( is ) ; \nthrow ds ; \n} \nver = new ServerVersion ( method ) ; \ncheckHeaders ( method ) ; \nHeader h = method . getResponseHeader ( \"content-encoding\" ) ; \nString encoding = ( h == null ) ? null : h . getValue ( ) ; \nif ( encoding != null && encoding . equals ( \"deflate\" ) ) { \nis = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"deflate %s%n\" , urlString ) ; \n} \nelse if ( encoding != null && encoding . equals ( \"gzip\" ) ) { \nis = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"gzip %s%n\" , urlString ) ; \n} \nelse { \nif ( showCompress ) System . out . printf ( \"none %s%n\" , urlString ) ; \n} \ncommand . process ( is ) ; \n} \n} \ncatch ( IOException | DAP2Exception e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nUtil . check ( e ) ; \nthrow new DAP2Exception ( e ) ; \n} \n} \n} \n"}
{"4732": "public class GridCoordSys { \nvoid addLevels ( List < GridRecord > records ) { \nfor ( GridRecord record : records ) { \nDouble d = new Double ( record . getLevel1 ( ) ) ; \nif ( ! levels . contains ( d ) ) { \nlevels . add ( d ) ; \n} \nif ( dontUseVertical && ( levels . size ( ) > 1 ) ) { \nif ( GridServiceProvider . debugVert ) { \nSystem . out . print ( \"GribCoordSys: unused level coordinate has > 1 levels = \" + verticalName + \" \" + record . getLevelType1 ( ) + \" \" + levels . size ( ) + \"\\n\" ) ; \n} \n} \n} \nCollections . sort ( levels ) ; \nif ( positive . equals ( \"down\" ) ) { \nCollections . reverse ( levels ) ; \n} \n} \n} \n"}
{"4740": "public class DiskCache2 { \npublic void showCache ( PrintStream pw ) { \npw . print ( \"Cache files\" + \"\\n\" ) ; \npw . print ( \"Size   LastModified       Filename\" + \"\\n\" ) ; \nFile dir = new File ( root ) ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files != null ) for ( File file : files ) { \nString org = null ; \ntry { \norg = URLDecoder . decode ( file . getName ( ) , \"UTF8\" ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \ne . printStackTrace ( ) ; \n} \npw . print ( \" \" + file . length ( ) + \" \" + new Date ( file . lastModified ( ) ) + \" \" + org + \"\\n\" ) ; \n} \n} \n} \n"}
{"4744": "public class Bearing { \npublic static void main ( String [ ] args ) { \nLatLonPointImpl pt1 = new LatLonPointImpl ( 40 , - 105 ) ; \nLatLonPointImpl pt2 = new LatLonPointImpl ( 37.4 , - 118.4 ) ; \nBearing b = calculateBearing ( pt1 , pt2 , null ) ; \nSystem . out . print ( \"Bearing from \" + pt1 + \" to \" + pt2 + \" = \\n\\t\" + b + \"\\n\" ) ; \nLatLonPointImpl pt3 = new LatLonPointImpl ( ) ; \npt3 = findPoint ( pt1 , b . getAngle ( ) , b . getDistance ( ) , pt3 ) ; \nSystem . out . print ( \"using first point, angle and distance, found second point at \" + pt3 + \"\\n\" ) ; \npt3 = findPoint ( pt2 , b . getBackAzimuth ( ) , b . getDistance ( ) , pt3 ) ; \nSystem . out . print ( \"using second point, backazimuth and distance, found first point at \" + pt3 + \"\\n\" ) ; \n} \n} \n"}
{"4760": "public class DbaseFile { \nprivate int loadHeader ( ) { \nif ( headerLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nBufferedInputStream bs = new BufferedInputStream ( s ) ; \nds = new DataInputStream ( bs ) ; \nHeader = new byte [ 32 ] ; \nds . readFully ( Header ) ; \nif ( Header [ 0 ] == '<' ) { \nclose ( ds ) ; \nreturn - 1 ; \n} \nfiletype = Header [ 0 ] ; \nnrecords = Swap . swapInt ( Header , 4 ) ; \nnbytesheader = Swap . swapShort ( Header , 8 ) ; \nnfields = ( nbytesheader / 32 ) - 1 ; \nif ( nfields < 1 ) { \nSystem . out . print ( \"nfields = \" + nfields + \"\\n\" ) ; \nSystem . out . print ( \"nbytesheader = \" + nbytesheader + \"\\n\" ) ; \nreturn - 1 ; \n} \nFieldDesc = new DbaseFieldDesc [ nfields ] ; \ndata = new DbaseData [ nfields ] ; \nfor ( int i = 0 ; \ni < nfields ; \ni ++ ) { \nFieldDesc [ i ] = new DbaseFieldDesc ( ds , filetype ) ; \ndata [ i ] = new DbaseData ( FieldDesc [ i ] , nrecords ) ; \n} \nds . readByte ( ) ; \nheaderLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"4768": "public class DbaseFile { \npublic static void main ( String [ ] args ) { \nif ( args . length < 1 ) { \nSystem . out . print ( \"filename or URL required\" + \"\\n\" ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( String s : args ) { \nSystem . out . print ( \"*** Dump of Dbase \" + s + \":\" + \"\\n\" ) ; \ntry { \nDbaseFile dbf = new DbaseFile ( s ) ; \nif ( dbf . loadHeader ( ) != 0 ) { \nSystem . out . print ( \"Error loading header\" + s + \"\\n\" ) ; \nSystem . exit ( - 1 ) ; \n} \nString [ ] fieldNames = dbf . getFieldNames ( ) ; \nSystem . out . print ( \"[\" ) ; \nint nf = dbf . getNumFields ( ) ; \nDbaseData [ ] dbd = new DbaseData [ nf ] ; \nfor ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \ndbd [ field ] = dbf . getField ( field ) ; \nswitch ( dbd [ field ] . getType ( ) ) { \ncase DbaseData . TYPE_BOOLEAN : System . out . print ( \"boolean \" ) ; \nbreak ; \ncase DbaseData . TYPE_CHAR : System . out . print ( \"String \" ) ; \nbreak ; \ncase DbaseData . TYPE_NUMERIC : System . out . print ( \"double \" ) ; \nbreak ; \n} \nSystem . out . print ( fieldNames [ field ] ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \n} \nSystem . out . print ( \"]\" + \"\\n\" ) ; \nif ( dbf . loadData ( ) != 0 ) { \nSystem . out . print ( \"Error loading data\" + s + \"\\n\" ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( int rec = 0 ; \nrec < dbf . getNumRecords ( ) ; \nrec ++ ) { \nfor ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \nSystem . out . print ( dbd [ field ] . getData ( rec ) ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \nelse System . out . print ( \"\\n\" ) ; \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4816": "public class DMRPrinter { \nvoid printDimrefs ( DapVariable var ) throws DapException { \nif ( var . getRank ( ) == 0 ) return ; \nList < DapDimension > dimset = this . ce . getConstrainedDimensions ( var ) ; \nif ( dimset == null ) throw new DapException ( \"Unknown variable: \" + var ) ; \nassert var . getRank ( ) == dimset . size ( ) ; \nfor ( int i = 0 ; \ni < var . getRank ( ) ; \ni ++ ) { \nDapDimension dim = dimset . get ( i ) ; \nprinter . marginPrint ( \"<Dim\" ) ; \nif ( dim . isShared ( ) ) { \nString fqn = dim . getFQN ( ) ; \nassert ( fqn != null ) : \"Illegal Dimension reference\" ; \nfqn = fqnXMLEscape ( fqn ) ; \nprintXMLAttribute ( \"name\" , fqn , XMLESCAPED ) ; \n} \nelse { \nlong size = dim . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , NILFLAGS ) ; \n} \nprinter . print ( \"/>\" + \"\\n\" ) ; \n} \n} \n} \n"}
{"4840": "public class StationRegionDateChooser { \nprotected void redraw ( ) { \nlong tstart = System . currentTimeMillis ( ) ; \njava . awt . Graphics2D gNP = np . getBufferedImageGraphics ( ) ; \nif ( gNP == null ) return ; \ngNP . setBackground ( np . getBackgroundColor ( ) ) ; \njava . awt . Rectangle r = gNP . getClipBounds ( ) ; \ngNP . clearRect ( r . x , r . y , r . width , r . height ) ; \nif ( regionSelect && geoSelectionMode ) { \nif ( geoSelection != null ) drawBB ( gNP , geoSelection , Color . cyan ) ; \nif ( geoBounds != null ) drawBB ( gNP , geoBounds , null ) ; \nif ( geoSelection != null ) { \nNavigation navigate = np . getNavigation ( ) ; \ndouble handleSize = RubberbandRectangleHandles . handleSizePixels / navigate . getPixPerWorld ( ) ; \nRectangle2D rect = new Rectangle2D . Double ( geoSelection . getX ( ) , geoSelection . getY ( ) , geoSelection . getWidth ( ) , geoSelection . getHeight ( ) ) ; \nRubberbandRectangleHandles . drawHandledRect ( gNP , rect , handleSize ) ; \nif ( debug ) System . out . print ( \"GeoRegionChooser.drawHandledRect=\" + handleSize + \" = \" + geoSelection + \"\\n\" ) ; \n} \n} \nfor ( int i = 0 ; \ni < renderers . size ( ) ; \ni ++ ) { \nucar . nc2 . ui . util . Renderer rend = ( Renderer ) renderers . get ( i ) ; \nrend . draw ( gNP , atI ) ; \n} \ngNP . dispose ( ) ; \nif ( debug ) { \nlong tend = System . currentTimeMillis ( ) ; \nSystem . out . print ( \"StationRegionDateChooser draw time = \" + ( tend - tstart ) / 1000.0 + \" secs\" + \"\\n\" ) ; \n} \nnp . repaint ( ) ; \n} \n} \n"}
{"4880": "public class DataDDS { \npublic final void externalize ( OutputStream os , boolean compress , boolean headers ) throws IOException { \nif ( headers ) { \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( os , Util . UTF8 ) ) ; \npw . print ( \"HTTP/1.0 200 OK\" + \"\\n\" ) ; \npw . print ( \"XDAP: \" + ServerVersion . DAP2_PROTOCOL_VERSION + \"\\n\" ) ; \npw . print ( \"XDODS-Server: DODS/\" + ServerVersion . DAP2_PROTOCOL_VERSION + \"\\n\" ) ; \npw . print ( \"Content-type: application/octet-stream\" + \"\\n\" ) ; \npw . print ( \"Content-Description: dods-data\" + \"\\n\" ) ; \nif ( compress ) { \npw . print ( \"Content-Encoding: deflate\" + \"\\n\" ) ; \n} \npw . print ( \"\\n\" ) ; \npw . flush ( ) ; \n} \nOutputStream bufferedOS ; \nif ( compress ) { \nbufferedOS = new BufferedOutputStream ( new DeflaterOutputStream ( os ) ) ; \n} \nelse { \nbufferedOS = new BufferedOutputStream ( os ) ; \n} \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( bufferedOS , Util . UTF8 ) ) ; \nprint ( pw ) ; \npw . flush ( ) ; \nbufferedOS . write ( \"\\nData:\\n\" . getBytes ( CDM . utf8Charset ) ) ; \nbufferedOS . flush ( ) ; \nDataOutputStream dataOS = new DataOutputStream ( bufferedOS ) ; \nfor ( Enumeration e = getVariables ( ) ; \ne . hasMoreElements ( ) ; \n) { \nClientIO bt = ( ClientIO ) e . nextElement ( ) ; \nbt . externalize ( dataOS ) ; \n} \ndataOS . close ( ) ; \n} \n} \n"}
{"4882": "public class ImageDatasetFactory { \npublic BufferedImage getNextImage ( boolean forward ) { \nif ( grid != null ) { \nif ( forward ) { \nthis . time ++ ; \nif ( this . time >= this . ntimes ) this . time = 0 ; \n} \nelse { \nthis . time -- ; \nif ( this . time < 0 ) this . time = this . ntimes - 1 ; \n} \nArray data ; \ntry { \ndata = grid . readDataSlice ( this . time , 0 , - 1 , - 1 ) ; \nreturn ImageArrayAdapter . makeGrayscaleImage ( data , grid ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \nif ( currentFile == null ) return null ; \nif ( currentDir == null ) { \ncurrentDirFileNo = 0 ; \ncurrentDir = currentFile . getParentFile ( ) ; \ncurrentDirFileList = new ArrayList < > ( ) ; \naddToList ( currentDir , currentDirFileList ) ; \nfor ( int i = 0 ; \ni < currentDirFileList . size ( ) ; \ni ++ ) { \nFile file = currentDirFileList . get ( i ) ; \nif ( file . equals ( currentFile ) ) currentDirFileNo = i ; \n} \n} \nif ( forward ) { \ncurrentDirFileNo ++ ; \nif ( currentDirFileNo >= currentDirFileList . size ( ) ) currentDirFileNo = 0 ; \n} \nelse { \ncurrentDirFileNo -- ; \nif ( currentDirFileNo < 0 ) currentDirFileNo = currentDirFileList . size ( ) - 1 ; \n} \nFile nextFile = currentDirFileList . get ( currentDirFileNo ) ; \ntry { \nSystem . out . print ( \"Open image \" + nextFile + \"\\n\" ) ; \nreturn javax . imageio . ImageIO . read ( nextFile ) ; \n} \ncatch ( IOException e ) { \nSystem . out . print ( \"Failed to open image \" + nextFile + \"\\n\" ) ; \nreturn getNextImage ( forward ) ; \n} \n} \n} \n"}
{"4885": "public class SpatialGrid { \npublic void setGrid ( Rectangle2D bbox , double width , double height ) { \noffsetX = bbox . getX ( ) ; \noffsetY = bbox . getY ( ) ; \ncountX = Math . min ( nx , ( int ) ( bbox . getWidth ( ) / ( scaleOverlap * width ) ) ) ; \ncountY = Math . min ( ny , ( int ) ( bbox . getHeight ( ) / ( scaleOverlap * height ) ) ) ; \ngridWidth = bbox . getWidth ( ) / countX ; \ngridHeight = bbox . getHeight ( ) / countY ; \nif ( debug ) System . out . print ( \"SpatialGrid size \" + gridWidth + \" \" + gridHeight + \" = \" + countX + \" by \" + countY + \" scaleOverlap= \" + scaleOverlap + \"\\n\" ) ; \n} \n} \n"}
{"4888": "public class SpatialGrid { \npublic boolean markIfClear ( Rectangle2D rect , Object o ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( debugMark ) System . out . print ( \"markIfClear \" + rect + \" \" + indexX + \" \" + indexY + \"\\n\" ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return false ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return false ; \nif ( null != findIntersection ( rect ) ) return false ; \ngwant . used = true ; \ngwant . objectBB = rect ; \ngwant . o = o ; \nreturn true ; \n} \n} \n"}
{"4891": "public class SpatialGrid { \npublic Object findClosest ( Point2D pt ) { \nObject o = null ; \nint indexX = ( int ) ( ( pt . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( pt . getY ( ) - offsetY ) / gridHeight ) ; \nif ( debugClosest ) System . out . print ( \"findClosest \" + pt + \" \" + indexX + \" \" + indexY + \"\\n\" ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return gwant . o ; \nfor ( int p = 1 ; \np < Math . max ( countX - 1 , countY - 1 ) ; \np ++ ) if ( null != ( o = findClosestAlongPerimeter ( pt , indexX , indexY , p ) ) ) return o ; \nreturn null ; \n} \n} \n"}
{"4965": "public class FileWriter2 { \npublic NetcdfFile write ( CancelTask cancel ) throws IOException { \ntry { \nif ( version . isExtendedModel ( ) ) addGroupExtended ( null , fileIn . getRootGroup ( ) ) ; \nelse addGroupClassic ( ) ; \nif ( cancel != null && cancel . isCancel ( ) ) return null ; \nwriter . create ( ) ; \nif ( cancel != null && cancel . isCancel ( ) ) return null ; \ndouble total = copyVarData ( varList , null , cancel ) ; \nif ( cancel != null && cancel . isCancel ( ) ) return null ; \nwriter . flush ( ) ; \nif ( debug ) System . out . print ( \"FileWriter done total bytes = \" + total + \"\\n\" ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \nwriter . abort ( ) ; \nthrow ioe ; \n} \nreturn writer . getNetcdfFile ( ) ; \n} \n} \n"}
{"5084": "public class GisFeatureRenderer { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nif ( shapeList != null ) return shapeList . iterator ( ) ; \nif ( Debug . isSet ( \"projection/LatLonShift\" ) ) System . out . print ( \"projection/LatLonShift GisFeatureRenderer.getShapes called\" + \"\\n\" ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nList featList = getFeatures ( ) ; \nshapeList = new ArrayList ( featList . size ( ) ) ; \nIterator iter = featList . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) iter . next ( ) ; \nShape shape ; \nif ( dataProject == null ) shape = feature . getShape ( ) ; \nelse if ( dataProject . isLatLon ( ) ) { \nshape = feature . getProjectedShape ( displayProject ) ; \n} \nelse if ( dataProject == displayProject ) { \nshape = feature . getShape ( ) ; \n} \nelse { \nshape = feature . getProjectedShape ( dataProject , displayProject ) ; \n} \nshapeList . add ( shape ) ; \n} \nreturn shapeList . iterator ( ) ; \n} \n} \n"}
{"5086": "public class BufrSplitter { \nprivate boolean readBuffer ( InputStream is , byte [ ] dest , int start , int want ) throws IOException { \nint done = 0 ; \nwhile ( done < want ) { \nint got = is . read ( dest , start + done , want - done ) ; \nif ( got < 0 ) return false ; \ndone += got ; \n} \nif ( showRead ) System . out . print ( \"Read buffer at \" + bytesRead + \" len=\" + done + \"\\n\" ) ; \nbytesRead += done ; \nreturn true ; \n} \n} \n"}
{"5098": "public class NavigatedPanel { \nvoid fireMapAreaEvent ( ) { \nif ( debugZoom ) System . out . print ( \"NP.fireMapAreaEvent \" + \"\\n\" ) ; \nif ( project . isLatLon ( ) ) { \nLatLonProjection llproj = ( LatLonProjection ) project ; \nProjectionRect box = getMapArea ( ) ; \ndouble center = llproj . getCenterLon ( ) ; \ndouble lonBeg = LatLonPointImpl . lonNormal ( box . getMinX ( ) , center ) ; \ndouble lonEnd = lonBeg + box . getMaxX ( ) - box . getMinX ( ) ; \nboolean showShift = Debug . isSet ( \"projection/LatLonShift\" ) || debugNewProjection ; \nif ( showShift ) System . out . print ( \"projection/LatLonShift: min,max = \" + box . getMinX ( ) + \" \" + box . getMaxX ( ) + \" beg,end= \" + lonBeg + \" \" + lonEnd + \" center = \" + center + \"\\n\" ) ; \nif ( ( lonBeg < center - 180 ) || ( lonEnd > center + 180 ) ) { \ndouble wx0 = box . getX ( ) + box . getWidth ( ) / 2 ; \nllproj . setCenterLon ( wx0 ) ; \ndouble newWx0 = llproj . getCenterLon ( ) ; \nsetWorldCenterX ( newWx0 ) ; \nif ( showShift ) System . out . print ( \"projection/LatLonShift: shift center to \" + wx0 + \"->\" + newWx0 + \"\\n\" ) ; \nlmProject . sendEvent ( new NewProjectionEvent ( this , llproj ) ) ; \nreturn ; \n} \n} \nlmMapArea . sendEvent ( new NewMapAreaEvent ( this , getMapArea ( ) ) ) ; \n} \n} \n"}
{"5099": "public class NavigatedPanel { \npublic void setMapArea ( ProjectionRect ma ) { \nif ( debugBB ) System . out . print ( \"NP.setMapArea \" + ma + \"\\n\" ) ; \nnavigate . setMapArea ( ma ) ; \n} \n} \n"}
{"5100": "public class NavigatedPanel { \npublic void setMapArea ( LatLonRect llbb ) { \nif ( debugBB ) System . out . print ( \"NP.setMapArea (ll) \" + llbb + \"\\n\" ) ; \nnavigate . setMapArea ( project . latLonToProjBB ( llbb ) ) ; \n} \n} \n"}
{"5102": "public class NavigatedPanel { \npublic void setProjectionImpl ( ProjectionImpl p ) { \nif ( geoSelection != null ) { \nLatLonRect geoLL = project . projToLatLonBB ( geoSelection ) ; \nsetGeoSelection ( p . latLonToProjBB ( geoLL ) ) ; \n} \nproject = p ; \nnavigate . setMapArea ( project . getDefaultMapArea ( ) ) ; \nif ( Debug . isSet ( \"projection/set\" ) || debugNewProjection ) System . out . print ( \"projection/set NP=\" + project + \"\\n\" ) ; \nif ( hasReference ) { \nrefWorld . setLocation ( project . latLonToProj ( refLatLon ) ) ; \n} \n} \n} \n"}
{"5104": "public class NavigatedPanel { \nprivate void redrawLater ( int delay ) { \nboolean already = ( redrawTimer != null ) && ( redrawTimer . isRunning ( ) ) ; \nif ( debugThread ) System . out . print ( \"redrawLater isRunning= \" + already + \"\\n\" ) ; \nif ( already ) return ; \nif ( redrawTimer == null ) { \nredrawTimer = new javax . swing . Timer ( 0 , new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent e ) { \ndrawG ( ) ; \nredrawTimer . stop ( ) ; \n} \n} \n) ; \n} \nredrawTimer . setDelay ( delay ) ; \nredrawTimer . start ( ) ; \n} \n} \n"}
{"5105": "public class NavigatedPanel { \nprivate void newScreenSize ( Rectangle b ) { \nboolean sameSize = ( b . width == myBounds . width ) && ( b . height == myBounds . height ) ; \nif ( debugBounds ) System . out . print ( \"NavigatedPanel newScreenSize old= \" + myBounds + \"\\n\" ) ; \nif ( sameSize && ( b . x == myBounds . x ) && ( b . y == myBounds . y ) ) return ; \nmyBounds . setBounds ( b ) ; \nif ( sameSize ) return ; \nif ( debugBounds ) System . out . print ( \"  newBounds = \" + b + \"\\n\" ) ; \nif ( ( b . width > 0 ) && ( b . height > 0 ) ) { \nbImage = new BufferedImage ( b . width , b . height , BufferedImage . TYPE_INT_RGB ) ; \n} \nelse { \nbImage = null ; \n} \nnavigate . setScreenSize ( b . width , b . height ) ; \n} \n} \n"}
{"5138": "public class DapController { \nprotected void doDMR ( DapRequest drq , DapContext cxt ) throws IOException { \nString realpath = getResourcePath ( drq , drq . getDatasetPath ( ) ) ; \nDSP dsp = DapCache . open ( realpath , cxt ) ; \nDapDataset dmr = dsp . getDMR ( ) ; \nByteOrder order = ( ByteOrder ) cxt . get ( Dap4Util . DAP4ENDIANTAG ) ; \nsetEndianness ( dmr , order ) ; \nCEConstraint ce = null ; \nString sce = drq . queryLookup ( DapProtocol . CONSTRAINTTAG ) ; \nce = CEConstraint . compile ( sce , dmr ) ; \nsetConstraint ( dmr , ce ) ; \nStringWriter sw = new StringWriter ( ) ; \nPrintWriter pw = new PrintWriter ( sw ) ; \nDMRPrinter dapprinter = new DMRPrinter ( dmr , ce , pw , drq . getFormat ( ) ) ; \nif ( cxt . get ( Dap4Util . DAP4TESTTAG ) != null ) dapprinter . testprint ( ) ; \nelse dapprinter . print ( ) ; \npw . close ( ) ; \nsw . close ( ) ; \nString sdmr = sw . toString ( ) ; \nif ( DEBUG ) System . err . print ( \"Sending: DMR:\\n\" + sdmr + \"\\n\" ) ; \naddCommonHeaders ( drq ) ; \nOutputStream out = drq . getOutputStream ( ) ; \nChunkWriter cw = new ChunkWriter ( out , RequestMode . DMR , order ) ; \ncw . cacheDMR ( sdmr ) ; \ncw . close ( ) ; \n} \n} \n"}
{"5167": "public class LuceneIndexer { \npublic static void main1 ( String [ ] args ) { \nif ( INDEX_DIR . exists ( ) ) { \nSystem . out . print ( \"Cannot save index to '\" + INDEX_DIR + \"' directory, please delete it first\" + \"\\n\" ) ; \nSystem . exit ( 1 ) ; \n} \nLuceneIndexer indexer = new LuceneIndexer ( ) ; \nDate start = new Date ( ) ; \ntry { \nIndexWriter writer = new IndexWriter ( INDEX_DIR , new StandardAnalyzer ( ) , true ) ; \nSystem . out . print ( \"Indexing to directory '\" + INDEX_DIR + \"'...\" + \"\\n\" ) ; \nindexer . indexDocs ( writer , DOC_DIR ) ; \nSystem . out . print ( \"Optimizing...\" + \"\\n\" ) ; \nwriter . optimize ( ) ; \nwriter . close ( ) ; \nDate end = new Date ( ) ; \nSystem . out . print ( end . getTime ( ) - start . getTime ( ) + \" total milliseconds\" + \"\\n\" ) ; \n} \ncatch ( IOException e ) { \nSystem . out . print ( \" caught a \" + e . getClass ( ) + \"\\n with message: \" + e . getMessage ( ) + \"\\n\" ) ; \n} \n} \n} \n"}
{"5192": "public class CatalogTreeView { \npublic void setCatalog ( Catalog catalog ) { \nif ( catalog == null ) return ; \nString catalogName = catalog . getBaseURI ( ) . toString ( ) ; \nthis . catalog = catalog ; \nsetCatalogURL ( catalogName ) ; \nmodel = new InvCatalogTreeModel ( catalog ) ; \ntree . setModel ( model ) ; \nif ( debugTree ) { \nSystem . out . print ( \"*** catalog/showJTree =\" + \"\\n\" ) ; \nshowNode ( tree . getModel ( ) , tree . getModel ( ) . getRoot ( ) ) ; \nSystem . out . print ( \"*** \" + \"\\n\" ) ; \n} \nint pos = catalogName . indexOf ( '#' ) ; \nif ( pos >= 0 ) { \nString id = catalogName . substring ( pos + 1 ) ; \nDataset dataset = catalog . findDatasetByID ( id ) ; \nif ( dataset != null ) { \nsetSelectedDataset ( dataset ) ; \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Selection\" , null , dataset ) ) ; \n} \n} \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Catalog\" , null , catalogName ) ) ; \n} \n} \n"}
{"5203": "public class JTreeTableSorted { \npublic void restoreState ( PreferencesExt store ) { \nif ( store == null ) return ; \nint ncols = table . getColumnCount ( ) ; \nint [ ] modelIndex = ( int [ ] ) store . getBean ( \"ColumnOrder\" , null ) ; \nif ( ( modelIndex != null ) && ( modelIndex . length == ncols ) ) { \nboolean [ ] visible = new boolean [ ncols ] ; \nfor ( int aModelIndex : modelIndex ) if ( aModelIndex < ncols ) visible [ aModelIndex ] = true ; \nfor ( int i = 0 ; \ni < ncols ; \ni ++ ) if ( ! visible [ i ] ) { \nacts [ i ] . hideColumn ( ) ; \nacts [ i ] . putValue ( BAMutil . STATE , new Boolean ( false ) ) ; \n} \nTableColumnModel tcm = table . getColumnModel ( ) ; \nint n = Math . min ( modelIndex . length , table . getColumnCount ( ) ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \ntc . setModelIndex ( modelIndex [ i ] ) ; \nString name = model . getColumnName ( modelIndex [ i ] ) ; \ntc . setHeaderValue ( name ) ; \ntc . setIdentifier ( name ) ; \nif ( useThreads && ( modelIndex [ i ] == threadCol ) ) { \nthreadHeaderRenderer = new ThreadHeaderRenderer ( threadCol ) ; \ntc . setHeaderRenderer ( threadHeaderRenderer ) ; \n} \nelse tc . setHeaderRenderer ( new SortedHeaderRenderer ( name , modelIndex [ i ] ) ) ; \n} \n} \nObject colWidths = store . getBean ( \"ColumnWidths\" , null ) ; \nif ( colWidths == null ) return ; \nint [ ] size = ( int [ ] ) colWidths ; \nsetColumnWidths ( size ) ; \nif ( debug ) { \nSystem . out . print ( \" read widths = \" + \"\\n\" ) ; \nfor ( int aSize : size ) System . out . print ( \" \" + aSize ) ; \nSystem . out . print ( \"\\n\" ) ; \n} \nboolean isThreadsOn = store . getBoolean ( \"isThreadsOn\" , false ) ; \nif ( useThreads ) { \nmodel . setThreadsOn ( isThreadsOn ) ; \nthreadHeaderRenderer . setOn ( isThreadsOn ) ; \n} \nint colNo = store . getInt ( \"SortOnCol\" , 0 ) ; \nboolean reverse = store . getBoolean ( \"SortReverse\" , false ) ; \nmodel . setSortCol ( colNo ) ; \nmodel . setReverse ( reverse ) ; \nsetSortCol ( colNo , reverse ) ; \nmodel . sort ( ) ; \ntable . fireDataChanged ( ) ; \n} \nprivate void setColumnWidths ( int [ ] sizes ) { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( int i = 0 ; \ni < table . getColumnCount ( ) ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nint maxw = ( ( sizes == null ) || ( i >= sizes . length ) ) ? 10 : sizes [ i ] ; \ntc . setPreferredWidth ( maxw ) ; \n} \n} \npublic void setColOn ( int colno , boolean state , int pos ) { \nacts [ colno ] . putValue ( BAMutil . STATE , new Boolean ( state ) ) ; \nif ( state ) acts [ colno ] . addAtPos ( pos ) ; \nelse acts [ colno ] . hideColumn ( ) ; \n} \n} \n"}
{"5221": "public class DIFWriter { \npublic void doOneDataset ( InvDataset ds ) { \nif ( debug ) System . out . print ( \"doDataset \" + ds . getName ( ) + \"\\n\" ) ; \nif ( isDatasetUseable ( ds , messBuffer ) ) { \nString id = StringUtil2 . replace ( ds . getID ( ) , \"/\" , \"-\" ) ; \nString fileOutName = fileDir + \"/\" + id + \".dif.xml\" ; \ntry { \nOutputStream out = new BufferedOutputStream ( new FileOutputStream ( fileOutName ) ) ; \nwriteOneEntry ( ds , out , messBuffer ) ; \nout . close ( ) ; \nmessBuffer . append ( \" OK on Write\\n\" ) ; \n} \ncatch ( IOException ioe ) { \nmessBuffer . append ( \"DIFWriter failed on write \" + ioe . getMessage ( ) + \"\\n\" ) ; \nlog . error ( \"DIFWriter failed on write \" + ioe . getMessage ( ) , ioe ) ; \n} \n} \n} \n} \n"}
{"5238": "public class ParsedSectionSpec { \nprivate static ParsedSectionSpec parseVariableSelector ( Object parent , String selector ) throws InvalidRangeException { \nString varNameEsc , indexSelect = null ; \nint pos1 = EscapeStrings . indexOf ( selector , '(' ) ; \nif ( pos1 < 0 ) { \nvarNameEsc = selector ; \n} \nelse { \nvarNameEsc = selector . substring ( 0 , pos1 ) ; \nint pos2 = selector . indexOf ( ')' , pos1 + 1 ) ; \nindexSelect = selector . substring ( pos1 , pos2 ) ; \n} \nif ( debugSelector ) System . out . print ( \" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\" + \"\\n\" ) ; \nVariable v = null ; \nif ( parent instanceof NetcdfFile ) { \nNetcdfFile ncfile = ( NetcdfFile ) parent ; \nv = ncfile . findVariable ( varNameEsc ) ; \n} \nelse if ( parent instanceof Structure ) { \nStructure s = ( Structure ) parent ; \nv = s . findVariable ( NetcdfFile . makeNameUnescaped ( varNameEsc ) ) ; \n} \nif ( v == null ) throw new IllegalArgumentException ( \" cant find variable: \" + varNameEsc + \" in selector=\" + selector ) ; \nif ( v . getDataType ( ) == DataType . SEQUENCE ) indexSelect = null ; \nSection section ; \nif ( indexSelect != null ) { \nsection = new Section ( indexSelect ) ; \nsection = Section . fill ( section , v . getShape ( ) ) ; \n} \nelse { \nsection = v . getShapeAsSection ( ) ; \n} \nreturn new ParsedSectionSpec ( v , section ) ; \n} \n} \n"}
{"5330": "public class BitCounterUncompressed { \nint countBits ( int startBit ) { \ncountBits = replicationCountSize ; \nthis . startBit = new int [ nrows ] ; \nfor ( int i = 0 ; \ni < nrows ; \ni ++ ) { \nthis . startBit [ i ] = startBit + countBits ; \nif ( debug ) System . out . print ( \" BitCounterUncompressed row \" + i + \" startBit=\" + this . startBit [ i ] + \"\\n\" ) ; \nfor ( DataDescriptor nd : parent . subKeys ) { \nBitCounterUncompressed [ ] bitCounter = ( subCounters == null ) ? null : subCounters . get ( nd ) ; \nif ( bitCounter == null ) countBits += nd . getBitWidth ( ) ; \nelse { \nif ( debug ) System . out . print ( \" ---------> nested \" + nd . getFxyName ( ) + \" starts at =\" + ( startBit + countBits ) + \"\\n\" ) ; \ncountBits += bitCounter [ i ] . countBits ( startBit + countBits ) ; \nif ( debug ) System . out . print ( \" <--------- nested \" + nd . getFxyName ( ) + \" ends at =\" + ( startBit + countBits ) + \"\\n\" ) ; \n} \n} \n} \nreturn countBits ; \n} \n} \n"}
{"5342": "public class OptSwitch { \npublic void SetHasValue ( int type ) { \nthis . type = type ; \nif ( debug ) { \nSystem . out . print ( \"sw = \" + ( char ) sw + \"; type = \" + type + \"; set = \" + set + \"; val = \" + val + \"\\n\" ) ; \n} \n} \n} \n"}
{"5344": "public class IO { \nstatic public long copyB ( InputStream in , OutputStream out , int bufferSize ) throws IOException { \nlong totalBytesRead = 0 ; \nint done = 0 , next = 1 ; \nbyte [ ] buffer = new byte [ bufferSize ] ; \nwhile ( true ) { \nint n = in . read ( buffer ) ; \nif ( n == - 1 ) break ; \nout . write ( buffer , 0 , n ) ; \ntotalBytesRead += n ; \nif ( showCopy ) { \ndone += n ; \nif ( done > 1000 * 1000 * next ) { \nSystem . out . print ( next + \" Mb\" + \"\\n\" ) ; \nnext ++ ; \n} \n} \n} \nout . flush ( ) ; \nreturn totalBytesRead ; \n} \n} \n"}
{"5360": "public class DTSServlet { \nprotected void printCatalog ( ReqState rs , PrintWriter os ) throws IOException { \nos . print ( \"Catalog not available for this server\" + \"\\n\" ) ; \nos . print ( \"Server version = \" + getServerVersion ( ) + \"\\n\" ) ; \n} \n} \n"}
{"5361": "public class DTSServlet { \nprotected void printStatus ( PrintWriter os ) { \nos . print ( \"<h2>Server version = \" + getServerVersion ( ) + \"</h2>\" + \"\\n\" ) ; \nos . print ( \"<h2>Number of Requests Received = \" + HitCounter + \"</h2>\" + \"\\n\" ) ; \nif ( track ) { \nint n = prArr . size ( ) ; \nint pending = 0 ; \nStringBuilder preqs = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nReqState rs = ( ReqState ) prArr . get ( i ) ; \nRequestDebug reqD = ( RequestDebug ) rs . getUserObject ( ) ; \nif ( ! reqD . done ) { \npreqs . append ( \"<pre>-----------------------\\n\" ) ; \npreqs . append ( \"Request[\" ) ; \npreqs . append ( reqD . reqno ) ; \npreqs . append ( \"](\" ) ; \npreqs . append ( reqD . threadDesc ) ; \npreqs . append ( \") is pending.\\n\" ) ; \npreqs . append ( rs . toString ( ) ) ; \npreqs . append ( \"</pre>\" ) ; \npending ++ ; \n} \n} \nos . print ( \"<h2>\" + pending + \" Pending Request(s)</h2>\" + \"\\n\" ) ; \nos . print ( preqs . toString ( ) + \"\\n\" ) ; \n} \n} \n} \n"}
{"5362": "public class DTSServlet { \nprivate void printBadURLPage ( PrintWriter pw ) { \npw . print ( \"<h3>Error in URL</h3>\" + \"\\n\" ) ; \npw . print ( \"The URL extension did not match any that are known by this\" + \"\\n\" ) ; \npw . print ( \"server. Below is a list of the five extensions that are be recognized by\" + \"\\n\" ) ; \npw . print ( \"all OPeNDAP servers. If you think that the server is broken (that the URL you\" + \"\\n\" ) ; \npw . print ( \"submitted should have worked), then please contact the\" + \"\\n\" ) ; \npw . print ( \"OPeNDAP user support coordinator at: \" + \"\\n\" ) ; \npw . print ( \"<a href=\\\"mailto:support@unidata.ucar.edu\\\">support@unidata.ucar.edu</a><p>\" + \"\\n\" ) ; \n} \n} \n"}
{"5365": "public class NcmlCollectionReader { \nstatic public NcmlCollectionReader readNcML ( String ncmlString , Formatter errlog ) throws IOException { \nStringReader reader = new StringReader ( ncmlString ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \nif ( debugURL ) System . out . print ( \" NetcdfDataset NcML String = <\" + ncmlString + \">\" + \"\\n\" ) ; \ndoc = builder . build ( new StringReader ( ncmlString ) ) ; \n} \ncatch ( JDOMException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \nif ( debugXML ) System . out . print ( \" SAXBuilder done\" + \"\\n\" ) ; \nreturn readXML ( doc , errlog , null ) ; \n} \n} \n"}
{"5366": "public class NcmlCollectionReader { \nstatic public NcmlCollectionReader open ( String ncmlLocation , Formatter errlog ) throws IOException { \nif ( ! ncmlLocation . startsWith ( \"http:\" ) && ! ncmlLocation . startsWith ( \"file:\" ) ) ncmlLocation = \"file:\" + ncmlLocation ; \nURL url = new URL ( ncmlLocation ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \nif ( debugURL ) System . out . print ( \" NetcdfDataset URL = <\" + url + \">\" + \"\\n\" ) ; \ndoc = builder . build ( url ) ; \n} \ncatch ( JDOMException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \nif ( debugXML ) System . out . print ( \" SAXBuilder done\" + \"\\n\" ) ; \nreturn readXML ( doc , errlog , ncmlLocation ) ; \n} \n} \n"}
{"5423": "public class DDS { \npublic void printDAS ( PrintWriter pw ) { \nDAS myDAS = null ; \ntry { \nmyDAS = this . getDAS ( ) ; \nmyDAS . print ( pw ) ; \n} \ncatch ( DASException dasE ) { \npw . print ( \"\\n\\nCould not get a DAS object to print!\\n\" + \"DDS.getDAS() threw an Exception. Message: \\n\" + dasE . getMessage ( ) + \"\\n\" ) ; \n} \n} \n} \n"}
{"5448": "public class GisFeatureRendererMulti { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nlong startTime = System . currentTimeMillis ( ) ; \nif ( featSetList == null ) { \ninitFeatSetList ( ) ; \nassert ! featSetList . isEmpty ( ) ; \n} \nFeatureSet fs = ( FeatureSet ) featSetList . get ( 0 ) ; \nif ( featSetList . size ( ) > 1 ) { \ndouble scale = 1.0 ; \ntry { \nAffineTransform world2device = g . getTransform ( ) ; \nAffineTransform world2normal = normal2device . createInverse ( ) ; \nworld2normal . concatenate ( world2device ) ; \nscale = Math . max ( Math . abs ( world2normal . getScaleX ( ) ) , Math . abs ( world2normal . getShearX ( ) ) ) ; \nif ( Debug . isSet ( \"GisFeature/showTransform\" ) ) { \nSystem . out . print ( \"GisFeature/showTransform: \" + world2normal + \"\\n scale = \" + scale + \"\\n\" ) ; \n} \n} \ncatch ( java . awt . geom . NoninvertibleTransformException e ) { \nSystem . out . print ( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device + \"\\n\" ) ; \n} \nif ( ! displayProject . isLatLon ( ) ) scale *= 111.0 ; \ndouble minD = Double . MAX_VALUE ; \nfor ( Object aFeatSetList : featSetList ) { \nFeatureSet tryfs = ( FeatureSet ) aFeatSetList ; \ndouble d = Math . abs ( scale * tryfs . minDist - pixelMatch ) ; \nif ( d < minD ) { \nminD = d ; \nfs = tryfs ; \n} \n} \nif ( Debug . isSet ( \"GisFeature/MapResolution\" ) ) { \nSystem . out . print ( \"GisFeature/MapResolution: scale = \" + scale + \" minDist = \" + fs . minDist + \"\\n\" ) ; \n} \n} \nif ( fs . featureList == null ) fs . createFeatures ( ) ; \nif ( ! displayProject . equals ( fs . project ) ) { \nfs . setProjection ( displayProject ) ; \n} \nelse { \nif ( fs . newProjection && displayProject . isLatLon ( ) ) { \nfs . setProjection ( displayProject ) ; \n} \n} \nfs . newProjection = false ; \nif ( Debug . isSet ( \"GisFeature/timing/getShapes\" ) ) { \nlong tookTime = System . currentTimeMillis ( ) - startTime ; \nSystem . out . print ( \"timing.getShapes: \" + tookTime * .001 + \" seconds\" + \"\\n\" ) ; \n} \nreturn fs . getShapes ( ) ; \n} \n} \n"}
{"5449": "public class GisFeatureRendererMulti { \nprivate ArrayList makeShapes ( Iterator featList ) { \nShape shape ; \nArrayList shapeList = new ArrayList ( ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nif ( Debug . isSet ( \"GisFeature/MapDraw\" ) ) { \nSystem . out . print ( \"GisFeature/MapDraw: makeShapes with \" + displayProject + \"\\n\" ) ; \n} \nwhile ( featList . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) featList . next ( ) ; \nif ( dataProject . isLatLon ( ) ) shape = feature . getProjectedShape ( displayProject ) ; \nelse if ( dataProject == displayProject ) shape = feature . getShape ( ) ; \nelse shape = feature . getProjectedShape ( dataProject , displayProject ) ; \nshapeList . add ( shape ) ; \n} \nreturn shapeList ; \n} \n} \n"}
{"5451": "public class StopButton { \npublic boolean startProgressMonitorTask ( ProgressMonitorTask pmt ) { \nif ( busy ) return false ; \nbusy = true ; \nthis . task = pmt ; \nisCancelled = false ; \ncount = 0 ; \nsetIcon ( icon [ 0 ] ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nif ( isCancelled && ! task . isCancel ( ) ) { \ntask . cancel ( ) ; \nif ( debug ) System . out . print ( \" task.cancel\" + \"\\n\" ) ; \nreturn ; \n} \nelse { \ncount ++ ; \nsetIcon ( icon [ count % 2 ] ) ; \nif ( debug ) System . out . print ( \" stop count=\" + count + \"\\n\" ) ; \n} \nif ( task . isDone ( ) ) { \nif ( myTimer != null ) myTimer . stop ( ) ; \nmyTimer = null ; \nif ( task . isError ( ) ) javax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \nbusy = false ; \n} \n} \n} \n; \nmyTimer = new javax . swing . Timer ( 1000 , watcher ) ; \nmyTimer . start ( ) ; \nThread taskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nreturn true ; \n} \n} \n"}
{"5476": "public class CEConstraint { \nstatic public CEConstraint compile ( String sce , DapDataset dmr ) throws DapException { \nif ( sce == null || sce . length ( ) == 0 ) return CEConstraint . getUniversal ( dmr ) ; \nCEParserImpl ceparser = new CEParserImpl ( dmr ) ; \nif ( PARSEDEBUG ) ceparser . setDebugLevel ( 1 ) ; \nif ( DEBUG ) { \nSystem . err . print ( \"Dap4Servlet: parsing constraint: |\" + sce + \"|\" + \"\\n\" ) ; \n} \nboolean ok ; \ntry { \nok = ceparser . parse ( sce ) ; \n} \ncatch ( ParseException pe ) { \nok = false ; \n} \nif ( ! ok ) throw new DapException ( \"Constraint parse failed: \" + sce ) ; \nCEAST root = ceparser . getCEAST ( ) ; \nCECompiler compiler = new CECompiler ( ) ; \nCEConstraint ce = compiler . compile ( dmr , root ) ; \nce . expand ( ) ; \nce . finish ( ) ; \nreturn ce ; \n} \n} \n"}
{"5484": "public class GempakFileReader { \npublic void printParts ( ) { \nif ( parts == null ) { \nreturn ; \n} \nfor ( int i = 0 ; \ni < parts . size ( ) ; \ni ++ ) { \nSystem . out . print ( \"\\nParts[\" + i + \"]:\" + \"\\n\" ) ; \nSystem . out . print ( parts . get ( i ) + \"\\n\" ) ; \n} \n} \n} \n"}
{"5485": "public class GempakFileReader { \npublic int getDataPointer ( int irow , int icol , String partName ) { \nint ipoint = - 1 ; \nif ( ( irow < 1 ) || ( irow > dmLabel . krow ) || ( icol < 1 ) || ( icol > dmLabel . kcol ) ) { \nSystem . out . print ( \"bad row or column number: \" + irow + \"/\" + icol + \"\\n\" ) ; \nreturn ipoint ; \n} \nint iprt = getPartNumber ( partName ) ; \nif ( iprt == 0 ) { \nSystem . out . print ( \"couldn't find part\" + \"\\n\" ) ; \nreturn ipoint ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( ( part . ktyprt != MDREAL ) && ( part . ktyprt != MDGRID ) && ( part . ktyprt != MDRPCK ) ) { \nSystem . out . print ( \"Not a valid type\" + \"\\n\" ) ; \nreturn ipoint ; \n} \nint ilenhd = part . klnhdr ; \nipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( icol - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nreturn ipoint ; \n} \n} \n"}
{"5491": "public class DDSXMLParser { \nprivate void parseBase ( Element e , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel ++ ; \nString type = e . getName ( ) ; \nif ( type . equals ( \"Attribute\" ) ) { \n} \nelse if ( type . equals ( \"Alias\" ) ) { \n} \nelse if ( type . equals ( \"dataBLOB\" ) ) { \norg . jdom2 . Attribute hrefAttr = e . getAttribute ( \"href\" ) ; \nString contentID = hrefAttr . getValue ( ) ; \nif ( _Debug ) System . out . print ( \"Found dataBLOB element. contentID=\\\"\" + contentID + \"\\\"\" + \"\\n\" ) ; \ndds . setBlobContentID ( contentID ) ; \n} \nelse { \nif ( _Debug ) System . out . print ( \"Parsing new BaseType element. Parse level: \" + parseLevel + \"\\n\" ) ; \nif ( _Debug ) showXMLElement ( e , indent ) ; \nBaseType bt = newBaseType ( e ) ; \nparentDC . addVariable ( bt ) ; \nif ( bt instanceof DConstructor ) { \nDConstructor myParentDC = parentDC ; \nparentDC = ( DConstructor ) bt ; \ntry { \nif ( bt instanceof DGrid ) { \nparseGrid ( e , indent ) ; \n} \nelse { \nfor ( Element child : e . getChildren ( ) ) { \nparseBase ( child , indent + \"    \" ) ; \n} \n} \n} \nfinally { \nparentDC = myParentDC ; \n} \n} \nelse if ( bt instanceof DArray ) { \nif ( _Debug ) System . out . print ( \"Parsing Array instance.  Array name: '\" + bt . getClearName ( ) + \"'\" + \"\\n\" ) ; \nparseArray ( e , ( DArray ) bt , indent ) ; \n} \n} \nparseLevel -- ; \n} \n} \n"}
{"5492": "public class DDSXMLParser { \nprivate void parseGrid ( Element gridElement , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel ++ ; \nDGrid myGrid = ( DGrid ) parentDC ; \nif ( _Debug ) { \nSystem . out . print ( \"Parsing Grid Element: \" + gridElement + \"\\n\" ) ; \nSystem . out . print ( \"Grid Elements: \" + \"\\n\" ) ; \nfor ( Element element : gridElement . getChildren ( ) ) System . out . print ( element + \"\\n\" ) ; \n} \nString eName = \"Array\" ; \nif ( _Debug ) { \nSystem . out . print ( \"Parsing Array element.\" + \"\\n\" ) ; \nSystem . out . print ( \"Asking for element: '\" + eName + \"' in namespace: '\" + opendapNameSpace + \"'\" + \"\\n\" ) ; \n} \nElement arrayElement = gridElement . getChild ( eName , opendapNameSpace ) ; \nif ( _Debug ) System . out . print ( \"Got Array element: \" + arrayElement + \"\\n\" ) ; \nDArray gridArray = ( DArray ) newBaseType ( arrayElement ) ; \nparseArray ( arrayElement , gridArray , indent + \"    \" ) ; \nmyGrid . addVariable ( gridArray , DGrid . ARRAY ) ; \neName = \"Map\" ; \nif ( _Debug ) { \nSystem . out . print ( \"Parsing Map elements.\" + \"\\n\" ) ; \nSystem . out . print ( \"Asking for element: '\" + eName + \"' in namespace: '\" + opendapNameSpace + \"'\" + \"\\n\" ) ; \n} \nList < Element > mapElements = gridElement . getChildren ( \"Map\" , opendapNameSpace ) ; \nif ( mapElements . size ( ) != gridArray . numDimensions ( ) ) throw new BadSemanticsException ( \"Error in Grid syntax: \" + \"The number of Map arrays must \" + \"equal the number of dimensions \" + \"of the data array.\" ) ; \nfor ( Element mapElement : mapElements ) { \nDArray thisMap = ( DArray ) newBaseType ( mapElement ) ; \nparseArray ( mapElement , thisMap , indent + \"    \" ) ; \nif ( thisMap . numDimensions ( ) != 1 ) throw new BadSemanticsException ( \"Error in Grid syntax: \" + \"Maps may have only one dimension.\" ) ; \nmyGrid . addVariable ( thisMap , DGrid . MAPS ) ; \n} \nparseLevel -- ; \n} \n} \n"}
{"5493": "public class DDSXMLParser { \nprivate void parseAliases ( Element e , String indent ) throws DASException { \nparseLevel ++ ; \nString subIndent = indent + \"    \" ; \nif ( _Debug ) System . out . print ( indent + \"Parsing Aliases: \" + \"\\n\" ) ; \nif ( _Debug ) System . out . print ( subIndent + \"currentBT: \" + currentBT . getTypeName ( ) + \" \" + currentBT . getClearName ( ) + \"\\n\" ) ; \nfor ( Element aliasElement : e . getChildren ( \"Alias\" , opendapNameSpace ) ) { \nString name = null ; \nAttribute nameAttr = aliasElement . getAttribute ( \"name\" ) ; \nname = nameAttr . getValue ( ) ; \nString attributeName = null ; \nAttribute attributeAttr = aliasElement . getAttribute ( \"Attribute\" ) ; \nattributeName = attributeAttr . getValue ( ) ; \nif ( _Debug ) { \nSystem . out . print ( subIndent + \"The name '\" + name + \"' is aliased to dds attribute: '\" + attributeName + \"'\" + \"\\n\" ) ; \n} \nif ( currentAT == null ) currentBT . addAttributeAlias ( name , attributeName ) ; \nelse currentAT . addAlias ( name , attributeName ) ; \n} \nparseLevel -- ; \n} \n} \n"}
{"5496": "public class ServerDDS { \npublic String getDatasetFilename ( ) { \nString s = getEncodedName ( ) ; \nSystem . out . print ( s + \"\\n\" ) ; \nreturn ( s ) ; \n} \n} \n"}
{"5501": "public class Tools { \npublic static void probeObject ( Object o ) { \nClass c = o . getClass ( ) ; \nClass interfaces [ ] = c . getInterfaces ( ) ; \nClass parent = c . getSuperclass ( ) ; \nMethod m [ ] = c . getMethods ( ) ; \nSystem . out . print ( \"********* OBJECT PROBE *********\" + \"\\n\" ) ; \nSystem . out . print ( \"Class Name:  \" + c . getName ( ) + \"\\n\" ) ; \nSystem . out . print ( \"Super Class: \" + parent . getName ( ) + \"\\n\" ) ; \nSystem . out . print ( \"Interfaces: \" + \"\\n\" ) ; \nfor ( int i = 0 ; \ni < interfaces . length ; \ni ++ ) { \nSystem . out . print ( \"    \" + interfaces [ i ] . getName ( ) + \"\\n\" ) ; \n} \nSystem . out . print ( \"Methods:\" + \"\\n\" ) ; \nfor ( int i = 0 ; \ni < m . length ; \ni ++ ) { \nClass params [ ] = m [ i ] . getParameterTypes ( ) ; \nClass excepts [ ] = m [ i ] . getExceptionTypes ( ) ; \nClass ret = m [ i ] . getReturnType ( ) ; \nSystem . out . print ( \"    \" + ret . getName ( ) + \"  \" + m [ i ] . getName ( ) + \"(\" ) ; \nfor ( int j = 0 ; \nj < params . length ; \nj ++ ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( params [ j ] . getName ( ) ) ; \n} \nSystem . out . print ( \")  throws \" ) ; \nfor ( int j = 0 ; \nj < excepts . length ; \nj ++ ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( excepts [ j ] . getName ( ) ) ; \n} \nSystem . out . print ( \"\" + \"\\n\" ) ; \n} \nSystem . out . print ( \"******************\" + \"\\n\" ) ; \n} \n} \n"}
{"5536": "public class BeanTable { \npublic List getSelectedBeans ( ) { \nArrayList < Object > list = new ArrayList < > ( ) ; \nint [ ] viewRowIndices = jtable . getSelectedRows ( ) ; \nfor ( int viewRowIndex : viewRowIndices ) { \nint modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndex ) ; \nlist . add ( beans . get ( modelRowIndex ) ) ; \nif ( debugSelected ) System . out . print ( \" bean selected= \" + modelRowIndex + \" \" + beans . get ( modelRowIndex ) + \"\\n\" ) ; \n} \nreturn list ; \n} \n} \n"}
{"5549": "public class SimpleUnit { \nstatic public SimpleUnit factory ( String name ) { \ntry { \nreturn factoryWithExceptions ( name ) ; \n} \ncatch ( Exception e ) { \nif ( debugParse ) System . out . print ( \"Parse \" + name + \" got Exception \" + e + \"\\n\" ) ; \nreturn null ; \n} \n} \n} \n"}
{"5563": "public class CatalogCrawler { \npublic int crawl ( InvCatalogImpl cat , CancelTask task , PrintWriter out , Object context ) { \nif ( out != null ) out . print ( \"***CATALOG \" + cat . getCreateFrom ( ) + \"\\n\" ) ; \ncountCatrefs = 0 ; \nfor ( InvDataset ds : cat . getDatasets ( ) ) { \nif ( type == Type . all ) crawlDataset ( ds , task , out , context , true ) ; \nelse crawlDirectDatasets ( ds , task , out , context , true ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nreturn 1 + countCatrefs ; \n} \n} \n"}
{"5564": "public class CatalogCrawler { \npublic void crawlDataset ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \nreturn ; \n} \nboolean isDataScan = ds . findProperty ( \"DatasetScan\" ) != null ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . print ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" + \"\\n\" ) ; \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nif ( ! isCatRef || isDataScan ) listen . getDataset ( ds , context ) ; \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( ! isDataScan ) { \nlisten . getDataset ( catref . getProxyDataset ( ) , context ) ; \n} \n} \nfor ( InvDataset dds : dlist ) { \ncrawlDataset ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nif ( isCatRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n"}
{"5565": "public class CatalogCrawler { \npublic void crawlDirectDatasets ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \nreturn ; \n} \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . print ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" + \"\\n\" ) ; \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nList < InvDataset > leaves = new ArrayList < InvDataset > ( ) ; \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasAccess ( ) ) leaves . add ( dds ) ; \n} \nif ( leaves . size ( ) > 0 ) { \nif ( type == Type . first_direct ) { \nInvDataset dds = leaves . get ( 0 ) ; \nlisten . getDataset ( dds , context ) ; \n} \nelse if ( type == Type . random_direct ) { \nlisten . getDataset ( chooseRandom ( leaves ) , context ) ; \n} \nelse if ( type == Type . random_direct_middle ) { \nlisten . getDataset ( chooseRandomNotFirstOrLast ( leaves ) , context ) ; \n} \nelse { \nfor ( InvDataset dds : leaves ) { \nlisten . getDataset ( dds , context ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \n} \n} \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasNestedDatasets ( ) ) crawlDirectDatasets ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nif ( ds instanceof InvCatalogRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n"}
{"5570": "public class RandomAccessFile { \npublic synchronized void close ( ) throws IOException { \nif ( cache != null ) { \nif ( cacheState > 0 ) { \nif ( cacheState == 1 ) { \ncacheState = 2 ; \nif ( cache . release ( this ) ) return ; \ncacheState = 0 ; \n} \nelse { \nreturn ; \n} \n} \n} \nif ( debugLeaks ) { \nopenFiles . remove ( location ) ; \nif ( showOpen ) System . out . print ( \"  close \" + location + \"\\n\" ) ; \n} \nif ( file == null ) return ; \nflush ( ) ; \nlong fileSize = file . length ( ) ; \nif ( ! readonly && ( minLength != 0 ) && ( minLength != fileSize ) ) { \nfile . setLength ( minLength ) ; \n} \nfile . close ( ) ; \nfile = null ; \n} \n} \n"}
{"5602": "public class FileCache { \n@ Override public void eject ( Object hashKey ) { \nif ( disabled . get ( ) ) return ; \nCacheElement wantCacheElem = cache . get ( hashKey ) ; \nif ( wantCacheElem == null ) return ; \nsynchronized ( wantCacheElem ) { \nfor ( CacheElement . CacheFile want : wantCacheElem . list ) { \nfiles . remove ( want . ncfile ) ; \ntry { \nwant . ncfile . setFileCache ( null ) ; \nwant . ncfile . close ( ) ; \nlog . debug ( \"close \" + want . ncfile . getLocation ( ) ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"close failed on \" + want . ncfile . getLocation ( ) , e ) ; \n} \nwant . ncfile = null ; \nif ( debugPrint ) System . out . print ( \"  FileCache \" + name + \" eject \" + hashKey + \"\\n\" ) ; \n} \nwantCacheElem . list . clear ( ) ; \n} \ncache . remove ( hashKey ) ; \n} \n} \n"}
{"5627": "public class GempakGridServiceProvider { \nprivate void initTables ( ) { \ntry { \nGempakGridParameterTable . addParameters ( \"resources/nj22/tables/gempak/wmogrib3.tbl\" ) ; \nGempakGridParameterTable . addParameters ( \"resources/nj22/tables/gempak/ncepgrib2.tbl\" ) ; \n} \ncatch ( Exception e ) { \nSystem . out . print ( \"unable to init tables\" + \"\\n\" ) ; \n} \n} \n} \n"}
{"5649": "public class MetadataManager { \nstatic synchronized public void closeAll ( ) { \nList < MetadataManager > closeDatabases = new ArrayList < > ( openDatabases ) ; \nfor ( MetadataManager mm : closeDatabases ) { \nif ( debug ) System . out . print ( \"  close database \" + mm . collectionName + \"\\n\" ) ; \nmm . close ( ) ; \n} \nopenDatabases = new ArrayList < > ( ) ; \nif ( myEnv != null ) { \ntry { \nmyEnv . close ( ) ; \nmyEnv = null ; \nlogger . info ( \"closed bdb caching\" ) ; \n} \ncatch ( DatabaseException dbe ) { \nlogger . error ( \"Error closing bdb: \" , dbe ) ; \n} \n} \n} \n} \n"}
{"5663": "public class EcmwfLocalConcepts { \nprivate void storeConcept ( String tableVersion , String parameterNumber , String key , String value ) { \nHashMap < String , HashMap < String , String > > tmpTable ; \nif ( localConcepts . containsKey ( tableVersion ) ) { \ntmpTable = localConcepts . get ( tableVersion ) ; \nif ( tmpTable . containsKey ( parameterNumber ) ) { \nHashMap < String , String > tmpParam = tmpTable . get ( parameterNumber ) ; \nif ( ! tmpParam . containsKey ( key ) ) { \ntmpParam . put ( key , value ) ; \n} \nelse { \nSystem . out . print ( \"already has key value pair: \" + key + \":\" + value + \"\\n\" ) ; \n} \n} \nelse { \nHashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; \ntmpParam . put ( key , value ) ; \ntmpTable . put ( parameterNumber , tmpParam ) ; \n} \n} \nelse { \ntmpTable = new HashMap < > ( ) ; \nHashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; \ntmpParam . put ( key , value ) ; \ntmpTable . put ( parameterNumber , tmpParam ) ; \n} \nlocalConcepts . put ( tableVersion , tmpTable ) ; \n} \n} \n"}
{"5664": "public class EcmwfLocalConcepts { \nprivate void writeGrib1Tables ( ) throws IOException { \nSimpleDateFormat dateFormat = new SimpleDateFormat ( \"yyyy-MM-dd'T'HH:mm:ssz\" ) ; \nCalendar cal = Calendar . getInstance ( ) ; \nString writeDate = dateFormat . format ( cal . getTime ( ) ) ; \nString grib1Info ; \nList < String > tableNums = new ArrayList < > ( ) ; \nHashMap < String , String > paramInfo ; \nPath dir = Paths . get ( ecmwfLocalConceptsLoc . replace ( \"sources/\" , \"resources/resources/grib1/\" ) ) ; \nfor ( String tableNum : localConcepts . keySet ( ) ) { \ntableNums . add ( tableNum ) ; \nString fileName = \"2.98.\" + tableNum + \".table\" ; \nSystem . out . print ( \"Writing: \" + fileName + \"\\n\" ) ; \nPath newFile = dir . resolve ( fileName ) ; \nFiles . deleteIfExists ( newFile ) ; \nFiles . createFile ( newFile ) ; \ntry ( BufferedWriter writer = Files . newBufferedWriter ( newFile , ENCODING ) ) { \nwriter . write ( \"# Generated by \" + this . getClass ( ) . getCanonicalName ( ) + \" on \" + writeDate ) ; \nwriter . newLine ( ) ; \nfor ( String paramNum : localConcepts . get ( tableNum ) . keySet ( ) ) { \nparamInfo = localConcepts . get ( tableNum ) . get ( paramNum ) ; \nString shortName = paramInfo . get ( SHORTNAME_ID ) ; \nString description = paramInfo . get ( DESCRIPTION_ID ) ; \nString units = paramInfo . get ( UNIT_ID ) ; \ngrib1Info = paramNum + \" \" + shortName + \" [\" + description + \"] (\" + units + \")\" ; \nwriter . write ( grib1Info ) ; \nwriter . newLine ( ) ; \n} \n} \n} \nwriteLookupTableFile ( tableNums , dir , writeDate ) ; \n} \n} \n"}
{"5665": "public class EcmwfLocalConcepts { \nprivate void writeLookupTableFile ( List < String > tableNums , Path dir , String writeDate ) throws IOException { \nSystem . out . print ( \"Writing: lookupTables.txt\" + \"\\n\" ) ; \nCollections . sort ( tableNums ) ; \nPath lookupTableReg = dir . resolve ( \"lookupTables.txt\" ) ; \nFiles . deleteIfExists ( lookupTableReg ) ; \nFiles . createFile ( lookupTableReg ) ; \ntry ( BufferedWriter writer = Files . newBufferedWriter ( lookupTableReg , ENCODING ) ) { \nwriter . write ( \"# Generated by \" + this . getClass ( ) . getCanonicalName ( ) + \" on \" + writeDate ) ; \nwriter . newLine ( ) ; \nfor ( String tn : tableNums ) { \nString tableName = \"2.98.\" + tn + \".table\" ; \nString reg = \"98:\\t-1:\\t\" + tn + \":\\t\" + tableName ; \nwriter . write ( reg ) ; \nwriter . newLine ( ) ; \n} \n} \n} \n} \n"}
{"5666": "public class EcmwfLocalConcepts { \nprivate void showLocalConcepts ( ) { \nfor ( String tableNum : localConcepts . keySet ( ) ) { \nfor ( String paramNum : localConcepts . get ( tableNum ) . keySet ( ) ) { \nfor ( String key : localConcepts . get ( tableNum ) . get ( paramNum ) . keySet ( ) ) { \nSystem . out . print ( key + \":\" + localConcepts . get ( tableNum ) . get ( paramNum ) . get ( key ) + \"\\n\" ) ; \n} \n} \n} \n} \n} \n"}
{"5667": "public class EcmwfLocalConcepts { \npublic static void main ( String [ ] args ) { \nEcmwfLocalConcepts ec = new EcmwfLocalConcepts ( ) ; \ntry { \nec . writeGrib1Tables ( ) ; \nSystem . out . print ( \"Finished!\" + \"\\n\" ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"5705": "public class XMLStore { \nstatic public XMLStore createFromFile ( String fileName , XMLStore storedDefaults ) throws java . io . IOException { \nFile prefsFile = new File ( fileName ) ; \nInputStream primIS = null , objIS = null ; \nif ( prefsFile . exists ( ) && prefsFile . length ( ) > 0 ) { \nprimIS = new BufferedInputStream ( new FileInputStream ( prefsFile ) ) ; \nobjIS = new BufferedInputStream ( new FileInputStream ( prefsFile ) ) ; \n} \nif ( debugWhichStore ) System . out . print ( \"XMLStore read from file \" + fileName + \"\\n\" ) ; \nXMLStore store = new XMLStore ( primIS , objIS , storedDefaults ) ; \nstore . prefsFile = prefsFile ; \nreturn store ; \n} \n} \n"}
{"5706": "public class XMLStore { \nstatic public XMLStore createFromInputStream ( InputStream is1 , InputStream is2 , XMLStore storedDefaults ) throws java . io . IOException { \nif ( debugWhichStore ) System . out . print ( \"XMLStore read from input stream \" + is1 + \"\\n\" ) ; \nreturn new XMLStore ( is1 , is2 , storedDefaults ) ; \n} \n} \n"}
{"5707": "public class XMLStore { \nstatic public XMLStore createFromResource ( String resourceName , XMLStore storedDefaults ) throws java . io . IOException { \nClass c = XMLStore . class ; \nInputStream primIS = c . getResourceAsStream ( resourceName ) ; \nInputStream objIS = c . getResourceAsStream ( resourceName ) ; \nif ( primIS == null ) { \nthrow new java . io . IOException ( \"XMLStore.createFromResource cant find <\" + resourceName + \">\" ) ; \n} \nif ( debugWhichStore ) System . out . print ( \"XMLStore read from resource \" + resourceName + \"\\n\" ) ; \nreturn new XMLStore ( primIS , objIS , storedDefaults ) ; \n} \n} \n"}
{"5708": "public class XMLStore { \nstatic public String makeStandardFilename ( String appName , String storeName ) { \nString userHome = null ; \ntry { \nuserHome = System . getProperty ( \"user.home\" ) ; \n} \ncatch ( Exception e ) { \nSystem . out . print ( \"XMLStore.makeStandardFilename: error System.getProperty(user.home) \" + e + \"\\n\" ) ; \n} \nif ( null == userHome ) userHome = \".\" ; \nString dirFilename = userHome + \"/\" + appName ; \nFile f = new File ( dirFilename ) ; \nif ( ! f . exists ( ) ) { \nboolean ok = f . mkdirs ( ) ; \nif ( ! ok ) System . out . print ( \"Error creating directories: \" + f . getAbsolutePath ( ) + \"\\n\" ) ; \n} \nreturn dirFilename + \"/\" + storeName ; \n} \n} \n"}
{"5710": "public class XMLStore { \npublic void save ( OutputStream out ) throws java . io . IOException { \noutputExceptionMessage = null ; \nOutputMunger bos = new OutputMunger ( out ) ; \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( bos , CDM . utf8Charset ) ) ; \nXMLEncoder beanEncoder = new XMLEncoder ( bos ) ; \nbeanEncoder . setExceptionListener ( new ExceptionListener ( ) { \npublic void exceptionThrown ( Exception exception ) { \nSystem . out . print ( \"XMLStore.save() got Exception: abort saving the preferences!\" + \"\\n\" ) ; \nexception . printStackTrace ( ) ; \noutputExceptionMessage = exception . getMessage ( ) ; \n} \n} \n) ; \npw . printf ( \"<?xml version='1.0' encoding='UTF-8'?>%n\" ) ; \npw . printf ( \"<preferences EXTERNAL_XML_VERSION='1.0'>%n\" ) ; \nif ( ! rootPrefs . isUserNode ( ) ) pw . printf ( \"  <root type='system'>%n\" ) ; \nelse pw . printf ( \"  <root type='user'>%n\" ) ; \nIndent indent = new Indent ( 2 ) ; \nindent . incr ( ) ; \nwriteXmlNode ( bos , pw , rootPrefs , beanEncoder , indent ) ; \nif ( outputExceptionMessage != null ) throw new IOException ( outputExceptionMessage ) ; \npw . printf ( \"  </root>%n\" ) ; \npw . printf ( \"</preferences>%n\" ) ; \npw . flush ( ) ; \n} \n} \n"}
{"5729": "public class StationRenderer { \npublic ucar . unidata . geoloc . Station pickClosest ( Point2D pickPt ) { \nif ( world2Normal == null || pickPt == null || stations . isEmpty ( ) ) return null ; \nworld2Normal . transform ( pickPt , ptN ) ; \nStationUI closest = ( StationUI ) stationGrid . findClosest ( ptN ) ; \nif ( debug ) System . out . print ( \"closest= \" + closest + \"\\n\" ) ; \nsetSelectedStation ( closest ) ; \nreturn getSelectedStation ( ) ; \n} \n} \n"}
{"5756": "public class JTableProjection { \npublic void setCurrentProjection ( ProjectionImpl proj ) { \nint row ; \nif ( 0 <= ( row = model . search ( proj ) ) ) { \nif ( debug ) System . out . print ( \" PTsetCurrentProjection found = \" + row + \"\\n\" ) ; \nselectedRow = row ; \nsetRowSelectionInterval ( row , row ) ; \n} \nelse { \nif ( debug ) System . out . print ( \" PTsetCurrentProjection not found = \" + row + \"\\n\" ) ; \nselectedRow = - 1 ; \nclearSelection ( ) ; \n} \n} \n} \n"}
{"5810": "public class GridDefRecord { \npublic final String getParam ( String key ) { \nString value = paramStr . get ( key ) ; \nif ( value == null ) { \nDouble result = paramDbl . get ( key ) ; \nif ( result != null ) { \nvalue = result . toString ( ) ; \n} \nelse { \nInteger intResult = paramInt . get ( key ) ; \nif ( intResult != null ) { \nvalue = intResult . toString ( ) ; \n} \n} \nif ( value != null ) { \nparamStr . put ( key , value ) ; \n} \n} \nif ( debug && value == null ) { \nSystem . out . print ( key + \" value not found\" + \"\\n\" ) ; \n} \nreturn value ; \n} \n} \n"}
{"5813": "public class MessageBroker { \nprivate int process ( Buffer b , InputStream is ) throws IOException { \nint start = 0 ; \nwhile ( start < b . have ) { \nint matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; \nif ( matchPos < 0 ) { \nif ( start == 0 ) return b . have - 3 ; \nelse return start ; \n} \nif ( matchPos + 6 >= b . have ) { \nreturn start ; \n} \nint b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; \nint b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; \nint b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; \nint messLen = b1 << 16 | b2 << 8 | b3 ; \nMessageTask task = new MessageTask ( messLen ) ; \ntask . header = extractHeader ( start , matchPos , b ) ; \nint last = matchPos + messLen ; \nif ( last > b . have ) { \ntask . have = b . have - matchPos ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \nif ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { \nSystem . out . print ( \"Failed to read remaining BUFR message\" + \"\\n\" ) ; \nbreak ; \n} \n} \nelse { \ntask . have = task . len ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \n} \nboolean ok = true ; \nfor ( int i = task . len - 4 ; \ni < task . len ; \ni ++ ) { \nint bb = task . mess [ i ] ; \nif ( bb != 55 ) { \nok = false ; \nbad_msgs ++ ; \n} \n} \ntry { \nif ( ok ) messQ . put ( task ) ; \ntotal_msgs ++ ; \n} \ncatch ( InterruptedException e ) { \nSystem . out . print ( \" interrupted queue put - assume process exit\" + \"\\n\" ) ; \nbreak ; \n} \nstart = matchPos + messLen + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5835": "public class Structure { \npublic ArrayStructure readStructure ( int start , int count ) throws IOException , ucar . ma2 . InvalidRangeException { \nif ( getRank ( ) != 1 ) throw new java . lang . UnsupportedOperationException ( \"not a vector structure\" ) ; \nint [ ] origin = new int [ ] { \nstart } \n; \nint [ ] shape = new int [ ] { \ncount } \n; \nif ( NetcdfFile . debugStructureIterator ) System . out . print ( \"readStructure \" + start + \" \" + count + \"\\n\" ) ; \nreturn ( ArrayStructure ) read ( origin , shape ) ; \n} \n} \n"}
{"6191": "public class StatusPrinter { \npublic static void printInCaseOfErrorsOrWarnings ( Context context , long threshold ) { \nif ( context == null ) { \nthrow new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \n} \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) { \nps . print ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" + \"\\n\" ) ; \n} \nelse { \nStatusUtil statusUtil = new StatusUtil ( context ) ; \nif ( statusUtil . getHighestLevel ( threshold ) >= ErrorStatus . WARN ) { \nprint ( sm , threshold ) ; \n} \n} \n} \n} \n"}
{"6192": "public class StatusPrinter { \npublic static void printIfErrorsOccured ( Context context ) { \nif ( context == null ) { \nthrow new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \n} \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) { \nps . print ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" + \"\\n\" ) ; \n} \nelse { \nStatusUtil statusUtil = new StatusUtil ( context ) ; \nif ( statusUtil . getHighestLevel ( 0 ) == ErrorStatus . ERROR ) { \nprint ( sm ) ; \n} \n} \n} \n} \n"}
{"6193": "public class StatusPrinter { \npublic static void print ( Context context , long threshold ) { \nif ( context == null ) { \nthrow new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \n} \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) { \nps . print ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" + \"\\n\" ) ; \n} \nelse { \nprint ( sm , threshold ) ; \n} \n} \n} \n"}
{"6438": "public class KieServiceDelegate { \nprotected String httpDelete ( String request ) throws IOException { \nString host = getKieRESTUrl ( ) ; \nURL url = new URL ( host + \"/\" + request ) ; \nActivator . print ( \"[DELETE] \" + url . toString ( ) + \"\\n\" ) ; \nHttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; \nconn . setRequestMethod ( \"DELETE\" ) ; \nconn . setRequestProperty ( \"Content\" , \"application/json\" ) ; \nsetHttpCredentials ( conn ) ; \nString response = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) . readLine ( ) ; \nActivator . print ( \"[DELETE] response: \" + response + \"\\n\" ) ; \nif ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_ACCEPTED ) { \nthrow new IOException ( \"HTTP DELETE failed : HTTP error code : \" + conn . getResponseCode ( ) ) ; \n} \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nif ( status != null && ! status . isEmpty ( ) ) { \nif ( ! \"APPROVED\" . equals ( status ) ) throw new IOException ( \"HTTP DELETE failed : Request status code : \" + status ) ; \n} \nString jobId = jo . get ( \"jobId\" ) . asString ( ) ; \nif ( jobId != null && ! jobId . isEmpty ( ) ) return jobId ; \nreturn response ; \n} \n} \n"}
{"6439": "public class KieServiceDelegate { \nprotected String httpPost ( String request , JsonObject body ) throws IOException , RuntimeException { \nString host = getKieRESTUrl ( ) ; \nURL url = new URL ( host + \"/\" + request ) ; \nActivator . print ( \"[POST] \" + url . toString ( ) + \" body: \" + body + \"\\n\" ) ; \nHttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; \nconn . setDoOutput ( body != null ) ; \nconn . setRequestMethod ( \"POST\" ) ; \nconn . setRequestProperty ( \"Content-Type\" , \"application/json\" ) ; \nsetHttpCredentials ( conn ) ; \nif ( body != null ) { \njava . io . OutputStream os = conn . getOutputStream ( ) ; \nWriter writer = new OutputStreamWriter ( os , \"UTF-8\" ) ; \nbody . writeTo ( writer ) ; \nwriter . close ( ) ; \nos . flush ( ) ; \n} \nString response = new BufferedReader ( new InputStreamReader ( ( conn . getInputStream ( ) ) ) ) . readLine ( ) ; \nActivator . print ( \"[POST] response: \" + response + \"\\n\" ) ; \nif ( conn . getResponseCode ( ) != HttpURLConnection . HTTP_ACCEPTED ) { \nthrow new IOException ( \"HTTP POST failed : HTTP error code : \" + conn . getResponseCode ( ) ) ; \n} \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nif ( status != null && ! status . isEmpty ( ) ) { \nif ( ! \"APPROVED\" . equals ( status ) ) throw new IOException ( \"HTTP POST failed : Request status code : \" + status ) ; \n} \nString jobId = jo . get ( \"jobId\" ) . asString ( ) ; \nif ( jobId != null && ! jobId . isEmpty ( ) ) return jobId ; \nreturn response ; \n} \n} \n"}
{"6440": "public class KieServiceDelegate { \npublic String getJobStatus ( final String jobId , final String title ) throws IOException , InterruptedException { \nfinal AtomicReference < String > ar = new AtomicReference < String > ( ) ; \nIWorkbench wb = PlatformUI . getWorkbench ( ) ; \nIProgressService ps = wb . getProgressService ( ) ; \ntry { \nps . busyCursorWhile ( new IRunnableWithProgress ( ) { \npublic void run ( IProgressMonitor pm ) throws InterruptedException { \npm . beginTask ( \"Waiting for Job \" + jobId + \":\\n\\n\" + title , STATUS_REQUEST_TIMEOUT ) ; \npm . subTask ( title ) ; \nlong startTime = System . currentTimeMillis ( ) ; \nlong stopTime = startTime ; \ndo { \ntry { \nThread . sleep ( STATUS_REQUEST_DELAY ) ; \nString response = httpGet ( \"jobs/\" + jobId ) ; \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nString result = jo . get ( \"result\" ) . asString ( ) ; \nif ( \"null\" . equals ( result ) ) { \nif ( ! \"SUCCESS\" . equals ( status ) ) result = null ; \n} \nif ( status != null && result != null ) ar . set ( status + \":\" + result ) ; \nstopTime = System . currentTimeMillis ( ) ; \npm . worked ( STATUS_REQUEST_DELAY ) ; \nActivator . print ( \"status=\" + status + \"\\n\" ) ; \nActivator . print ( \"result=\" + result + \"\\n\" ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nif ( pm . isCanceled ( ) ) throw new InterruptedException ( \"Operation canceled\" ) ; \n} \nwhile ( ar . get ( ) == null && stopTime - startTime < STATUS_REQUEST_TIMEOUT ) ; \npm . done ( ) ; \nActivator . print ( \"\\n----------------------------------\\n\" + \"Job \" + jobId + \"\\n\" + title + \"\\ncompleted in \" + ( stopTime - startTime ) / 1000.0 + \" sec\\n\" + \"Status: \" + ar . get ( ) + \"\\n----------------------------------\\n\" + \"\\n\" ) ; \n} \n} \n) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \nreturn ar . get ( ) ; \n} \n} \n"}
{"6455": "public class RowList { \npublic void dump ( ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \ni < numRows ; \n++ i ) { \nSystem . err . print ( i + \": \" + get ( i ) . getVertices ( ) + \"\\n\" ) ; \n} \n} \n} \n"}
{"6515": "public class DSLTree { \npublic void printTree ( ) { \nSystem . out . print ( \"ROOT\" + \"\\n\" ) ; \nfor ( Node n : rootCond . getChildren ( ) ) { \nprintNode ( n ) ; \n} \n} \n} \n"}
{"6516": "public class DSLTree { \nprotected void printNode ( Node n ) { \nprintTabs ( n . getDepth ( ) ) ; \nSystem . out . print ( \"- \\\"\" + n . getToken ( ) + \"\\\"\" + \"\\n\" ) ; \nfor ( Node c : n . getChildren ( ) ) { \nprintNode ( c ) ; \n} \n} \n} \n"}
{"6957": "public class AbstractOperation { \npublic void displayResult ( ) { \nif ( ! context . isQuiet ( ) ) { \nString resultText = prepareResultText ( ) ; \nPrintWriter out = context . getWriter ( ) ; \nout . print ( resultText + \"\\n\" ) ; \nout . flush ( ) ; \n} \n} \n} \n"}
{"7319": "public class CollectorManager { \nprivate boolean determineIfWeShouldExit ( ) { \nboolean shouldStop = stop . get ( ) ; \nif ( ! shouldStop ) { \nThread . interrupted ( ) ; \n} \nelse { \nSystem . out . print ( \"Exiting processing loop as requested\" + \"\\n\" ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"7322": "public class CollectorManager { \nprivate void startMonitor ( ) { \nfinal ScheduledExecutorService monitor = Executors . newScheduledThreadPool ( 2 , new ThreadFactory ( ) { \n@ Override public Thread newThread ( Runnable runnable ) { \nThread thread = new Thread ( runnable ) ; \nthread . setPriority ( Thread . NORM_PRIORITY + 1 ) ; \nreturn thread ; \n} \n} \n) ; \nmonitorFuture = monitor . scheduleAtFixedRate ( new Runnable ( ) { \n@ Override public void run ( ) { \nmonitor ( ) ; \n} \n} \n, MONITOR_INTERVAL_SECONDS , MONITOR_INTERVAL_SECONDS , TimeUnit . SECONDS ) ; \nRuntime . getRuntime ( ) . addShutdownHook ( new Thread ( new Runnable ( ) { \n@ Override public void run ( ) { \nSystem . err . print ( \"shutting down....\" + \"\\n\" ) ; \nmonitor ( ) ; \n} \n} \n) ) ; \n} \n} \n"}
{"7660": "public class MySystem { \npublic synchronized static void variable ( String name , Object value ) { \nif ( ! variable ) { \nreturn ; \n} \nSystem . out . print ( timeStamp ( ) + \"*=> \" + name + \" = '\" + ( value == null ? null : value . toString ( ) ) + \"'\" + \"\\n\" ) ; \n} \n} \n"}
{"7665": "public class StdRandom { \npublic static void main ( String [ ] args ) { \nint N = Integer . parseInt ( args [ 0 ] ) ; \nif ( args . length == 2 ) StdRandom . setSeed ( Long . parseLong ( args [ 1 ] ) ) ; \ndouble [ ] t = { \n.5 , .3 , .1 , .1 } \n; \nStdOut . print ( \"seed = \" + StdRandom . getSeed ( ) + \"\\n\" ) ; \nfor ( int i = 0 ; \ni < N ; \ni ++ ) { \nStdOut . printf ( \"%2d \" , uniform ( 100 ) ) ; \nStdOut . printf ( \"%8.5f \" , uniform ( 10.0 , 99.0 ) ) ; \nStdOut . printf ( \"%5b \" , bernoulli ( .5 ) ) ; \nStdOut . printf ( \"%7.5f \" , gaussian ( 9.0 , .2 ) ) ; \nStdOut . printf ( \"%2d \" , discrete ( t ) ) ; \nStdOut . print ( \"\\n\" ) ; \n} \nString [ ] a = \"A B C D E F G\" . split ( \" \" ) ; \nfor ( String s : a ) StdOut . print ( s + \" \" ) ; \nStdOut . print ( \"\\n\" ) ; \n} \n} \n"}
{"7756": "public class Application { \nprivate void updateDB ( ) throws SQLException , LiquibaseException { \nSystem . out . print ( \"About to perform DB update.\" + \"\\n\" ) ; \ntry ( BasicDataSource dataSource = new BasicDataSource ( ) ) { \ndataSource . setUrl ( fullConnectionString ) ; \ndataSource . setUsername ( username ) ; \ndataSource . setPassword ( password ) ; \ntry ( java . sql . Connection c = dataSource . getConnection ( ) ) { \nDatabase database = DatabaseFactory . getInstance ( ) . findCorrectDatabaseImplementation ( new JdbcConnection ( c ) ) ; \nLiquibase liquibase = null ; \nClassLoaderResourceAccessor accessor = new ClassLoaderResourceAccessor ( ) ; \ntry { \nif ( accessor . getResourcesAsStream ( \"changelog-master.xml\" ) != null ) { \nliquibase = new Liquibase ( \"changelog-master.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \n} \nelse if ( accessor . getResourcesAsStream ( \"changelog.xml\" ) != null ) { \nliquibase = new Liquibase ( \"changelog.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \n} \nelse { \nString errorMessage = \"No liquibase changelog-master.xml or changelog.xml could be located\" ; \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , errorMessage , this ) ; \nthrow new RuntimeException ( errorMessage ) ; \n} \n} \ncatch ( final IOException ioe ) { \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , ioe . getMessage ( ) , ioe ) ; \n} \nliquibase . getLog ( ) . setLogLevel ( logLevel ) ; \nliquibase . update ( new Contexts ( ) ) ; \nSystem . out . print ( \"DB update finished.\" + \"\\n\" ) ; \n} \n} \n} \n} \n"}
{"7845": "public class Main { \nprivate void printUsage ( final Options options , final String errorMessage ) { \nif ( errorMessage != null ) { \nSystem . out . print ( \"Error: \" + errorMessage + \"\\n\" ) ; \n} \nfinal HelpFormatter formatter = new HelpFormatter ( ) ; \nformatter . printHelp ( Main . class . getCanonicalName ( ) + \" <task> [options]\" , options ) ; \nSystem . out . print ( \"Tasks are: \" + gatherTaskNames ( taskFactory ) + \"\\n\" ) ; \nSystem . out . print ( \"Example: \" + Main . class . getCanonicalName ( ) + \" scan -f java:classpath::target/classes java:classpath::target/test-classes\" + \"\\n\" ) ; \n} \n} \n"}
{"7959": "public class JspC { \npublic static void main ( String arg [ ] ) { \nif ( arg . length == 0 ) { \nSystem . out . print ( Localizer . getMessage ( \"jspc.usage\" ) + \"\\n\" ) ; \n} \nelse { \nJspC jspc = new JspC ( ) ; \ntry { \njspc . setArgs ( arg ) ; \nif ( jspc . helpNeeded ) { \nSystem . out . print ( Localizer . getMessage ( \"jspc.usage\" ) + \"\\n\" ) ; \n} \nelse { \njspc . execute ( ) ; \n} \n} \ncatch ( JasperException je ) { \nSystem . err . print ( je + \"\\n\" ) ; \nif ( jspc . getDieLevel ( ) != NO_DIE_LEVEL ) { \nSystem . exit ( jspc . getDieLevel ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"7997": "public class JspCServletContext { \npublic void log ( String message , Throwable exception ) { \nmyLogWriter . print ( message + \"\\n\" ) ; \nexception . printStackTrace ( myLogWriter ) ; \n} \n} \n"}
{"8024": "public class Generator { \nprivate void generateDeclarations ( Node . Nodes page ) throws JasperException { \nclass DeclarationVisitor extends Node . Visitor { \nprivate boolean getServletInfoGenerated = false ; \npublic void visit ( Node . PageDirective n ) throws JasperException { \nif ( getServletInfoGenerated ) { \nreturn ; \n} \nString info = n . getAttributeValue ( \"info\" ) ; \nif ( info == null ) return ; \ngetServletInfoGenerated = true ; \nout . printil ( \"public String getServletInfo() {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return \" ) ; \nout . print ( quote ( info ) ) ; \nout . print ( \";\" + \"\\n\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . print ( \"\\n\" ) ; \n} \npublic void visit ( Node . Declaration n ) throws JasperException { \nn . setBeginJavaLine ( out . getJavaLine ( ) ) ; \nout . printMultiLn ( n . getText ( ) ) ; \nout . print ( \"\\n\" ) ; \nn . setEndJavaLine ( out . getJavaLine ( ) ) ; \n} \npublic void visit ( Node . CustomTag n ) throws JasperException { \nif ( n . useTagPlugin ( ) ) { \nif ( n . getAtSTag ( ) != null ) { \nn . getAtSTag ( ) . visit ( this ) ; \n} \nvisitBody ( n ) ; \nif ( n . getAtETag ( ) != null ) { \nn . getAtETag ( ) . visit ( this ) ; \n} \n} \nelse { \nvisitBody ( n ) ; \n} \n} \n} \nout . print ( \"\\n\" ) ; \npage . visit ( new DeclarationVisitor ( ) ) ; \n} \n} \n"}
{"8026": "public class Generator { \nprivate void generateXmlProlog ( Node . Nodes page ) { \nString omitXmlDecl = pageInfo . getOmitXmlDecl ( ) ; \nif ( ( omitXmlDecl != null && ! JspUtil . booleanValue ( omitXmlDecl ) ) || ( omitXmlDecl == null && page . getRoot ( ) . isXmlSyntax ( ) && ! pageInfo . hasJspRoot ( ) && ! ctxt . isTagFile ( ) ) ) { \nString cType = pageInfo . getContentType ( ) ; \nString charSet = cType . substring ( cType . indexOf ( \"charset=\" ) + 8 ) ; \nout . printil ( \"out.write(\\\"<?xml version=\\\\\\\"1.0\\\\\\\" encoding=\\\\\\\"\" + charSet + \"\\\\\\\"?>\\\\n\\\");\" ) ; \n} \nString doctypeName = pageInfo . getDoctypeName ( ) ; \nif ( doctypeName != null ) { \nString doctypePublic = pageInfo . getDoctypePublic ( ) ; \nString doctypeSystem = pageInfo . getDoctypeSystem ( ) ; \nout . printin ( \"out.write(\\\"<!DOCTYPE \" ) ; \nout . print ( doctypeName ) ; \nif ( doctypePublic == null ) { \nout . print ( \" SYSTEM \\\\\\\"\" ) ; \n} \nelse { \nout . print ( \" PUBLIC \\\\\\\"\" ) ; \nout . print ( doctypePublic ) ; \nout . print ( \"\\\\\\\" \\\\\\\"\" ) ; \n} \nout . print ( doctypeSystem ) ; \nout . print ( \"\\\\\\\">\\\\n\\\");\" + \"\\n\" ) ; \n} \n} \n} \n"}
{"8030": "public class Generator { \nprivate void generateTagHandlerAttributes ( TagInfo tagInfo ) throws JasperException { \nif ( tagInfo . hasDynamicAttributes ( ) ) { \nout . printil ( \"private java.util.HashMap _jspx_dynamic_attrs = new java.util.HashMap();\" ) ; \n} \nTagAttributeInfo [ ] attrInfos = tagInfo . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attrInfos . length ; \ni ++ ) { \nout . printin ( \"private \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \";\" + \"\\n\" ) ; \n} \nout . print ( \"\\n\" ) ; \nfor ( int i = 0 ; \ni < attrInfos . length ; \ni ++ ) { \nout . printin ( \"public \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( toGetterMethod ( attrInfos [ i ] . getName ( ) ) ) ; \nout . print ( \" {\" + \"\\n\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \";\" + \"\\n\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . print ( \"\\n\" ) ; \nout . printin ( \"public void \" ) ; \nout . print ( toSetterMethodName ( attrInfos [ i ] . getName ( ) ) ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"(javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( \"(\" ) ; \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \") {\" + \"\\n\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \" = \" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \";\" + \"\\n\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . print ( \"\\n\" ) ; \n} \n} \n} \n"}
{"8038": "public class ServletWriter { \npublic void printComment ( Mark start , Mark stop , char [ ] chars ) { \nif ( start != null && stop != null ) { \nprint ( \"// from=\" + start + \"\\n\" ) ; \nprint ( \"//   to=\" + stop + \"\\n\" ) ; \n} \nif ( chars != null ) for ( int i = 0 ; \ni < chars . length ; \n) { \nprintin ( ) ; \nprint ( \"// \" ) ; \nwhile ( chars [ i ] != '\\n' && i < chars . length ) writer . print ( chars [ i ++ ] ) ; \n} \n} \n} \n"}
{"8040": "public class ServletWriter { \npublic void printil ( String s ) { \njavaLine ++ ; \nwriter . print ( SPACES . substring ( 0 , indent ) ) ; \nwriter . print ( s + \"\\n\" ) ; \n} \n} \n"}
{"8367": "public class SingletonLoader { \npublic Object newInstance ( Class c ) throws InstantiationException , IllegalAccessException { \nObject ret = null ; \nMethod [ ] methods = c . getDeclaredMethods ( ) ; \nMethod m ; \nint modifiers ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nm = methods [ i ] ; \nmodifiers = m . getModifiers ( ) ; \nif ( ( modifiers & Modifier . STATIC ) != 0 ) { \nif ( ( modifiers & Modifier . PUBLIC ) != 0 ) { \nif ( m . getParameterTypes ( ) . length == 0 ) { \nif ( m . getReturnType ( ) == c ) { \nif ( m . getName ( ) . toLowerCase ( ) . indexOf ( \"instance\" ) != - 1 ) { \ntry { \nret = m . invoke ( null , dummyParameters ) ; \n} \ncatch ( IllegalArgumentException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IllegalAccessException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n} \n} \n} \n} \nif ( ret == null ) { \nConstructor [ ] constructors = c . getConstructors ( ) ; \nConstructor con = null ; \nfor ( int i = 0 ; \ni < constructors . length ; \ni ++ ) { \ncon = constructors [ i ] ; \nif ( con . getParameterTypes ( ) . length == 0 ) { \nmodifiers = con . getModifiers ( ) ; \ntry { \nif ( ( modifiers & Modifier . PUBLIC ) == 0 ) { \ncon . setAccessible ( true ) ; \n} \nret = c . newInstance ( ) ; \n} \ncatch ( SecurityException se ) { \n} \n} \n} \n} \nif ( ret == null ) { \nSystem . err . print ( \"Unable to instantiate: \" + c . getName ( ) + \": no singleton method, no public default constructor.\" + \"\\n\" ) ; \n} \nreturn ret ; \n} \n} \n"}
{"8380": "public class StringUtil { \npublic static final String setSize ( final String s , final int length ) { \nString result = s ; \nint oldlen = s . length ( ) ; \nif ( oldlen > length ) { \nSystem . err . print ( \"greenpeace.util.setSize(String s,int length): length (\" + length + \") is smaller than s.length(\" + oldlen + \") : \" + s + \"\\n\" ) ; \n} \nelse { \nint tofill = length - oldlen ; \nresult = StringUtil . appendSpaces ( s , tofill ) ; \n} \nreturn result ; \n} \n} \n"}
{"8388": "public class JarArchive { \nprivate ITreeNode parseTree ( ) { \nITreeNode root = new TreeNodeUniqueChildren ( ) ; \nITreeNode newnode , oldnode ; \nEnumeration entries = this . jar . entries ( ) ; \nString entry ; \nwhile ( entries . hasMoreElements ( ) ) { \nnewnode = root ; \noldnode = root ; \nentry = ( ( JarEntry ) entries . nextElement ( ) ) . getName ( ) ; \nSystem . out . print ( \"Entry: \" + entry + \"\\n\" ) ; \nStringTokenizer tokenizer = new StringTokenizer ( entry , \"/\" ) ; \nwhile ( tokenizer . hasMoreElements ( ) ) { \nString path = tokenizer . nextToken ( ) ; \nnewnode = new TreeNodeUniqueChildren ( path ) ; \noldnode . addChildNode ( newnode ) ; \noldnode = newnode ; \n} \n} \nreturn root ; \n} \n} \n"}
{"8398": "public class RemoteServer { \npublic static void main ( String [ ] args ) throws Exception { \nconfigureLogging ( ) ; \nCommandLineHelper helper = new CommandLineHelper ( args ) ; \nif ( helper . getHelpRequested ( ) ) { \nSystem . out . print ( helper . getUsage ( ) ) ; \nSystem . exit ( 0 ) ; \n} \nRemoteServer remoteServer = new RemoteServer ( ) ; \nString error = helper . getError ( ) ; \nif ( error == null ) { \ntry { \nfor ( String path : helper . getLibraryMap ( ) . keySet ( ) ) remoteServer . putLibrary ( path , helper . getLibraryMap ( ) . get ( path ) ) ; \n} \ncatch ( IllegalPathException e ) { \nerror = e . getMessage ( ) ; \n} \n} \nif ( error != null ) { \nSystem . out . print ( \"Error: \" + error + \"\\n\" ) ; \nSystem . out . print ( \"\\n\" ) ; \nSystem . out . print ( helper . getUsage ( ) + \"\\n\" ) ; \nSystem . exit ( 1 ) ; \n} \nremoteServer . setPort ( helper . getPort ( ) ) ; \nremoteServer . setAllowStop ( helper . getAllowStop ( ) ) ; \nremoteServer . setHost ( helper . getHost ( ) ) ; \nremoteServer . start ( ) ; \n} \n} \n"}
{"8455": "public class Args { \npublic static void usage ( PrintStream errStream , Object target ) { \nClass < ? > clazz ; \nif ( target instanceof Class ) { \nclazz = ( Class ) target ; \n} \nelse { \nclazz = target . getClass ( ) ; \n} \nerrStream . print ( \"Usage: \" + clazz . getName ( ) + \"\\n\" ) ; \nfor ( Class < ? > currentClazz = clazz ; \ncurrentClazz != null ; \ncurrentClazz = currentClazz . getSuperclass ( ) ) { \nfor ( Field field : currentClazz . getDeclaredFields ( ) ) { \nfieldUsage ( errStream , target , field ) ; \n} \n} \ntry { \nBeanInfo info = Introspector . getBeanInfo ( clazz ) ; \nfor ( PropertyDescriptor pd : info . getPropertyDescriptors ( ) ) { \npropertyUsage ( errStream , target , pd ) ; \n} \n} \ncatch ( IntrospectionException e ) { \n} \n} \n} \n"}
{"8884": "public class Wordform { \npublic void longDescription ( PrintStream out ) { \nout . print ( this . token + \":\" + \"\\n\" ) ; \nfor ( String s : this . attributes . keySet ( ) ) { \nout . print ( s + \"\\t\" + attributes . get ( s ) + \"\\n\" ) ; \n} \n} \n} \n"}
{"8939": "public class TimeStampSeries { \nvoid dump ( PrintWriter stream ) { \nstream . print ( \"[size=\" + count ) ; \nfor ( int i = 0 ; \ni < count ; \ni ++ ) { \nif ( i != 0 ) { \nstream . print ( \", \" ) ; \nstream . print ( timeStamps [ i ] - timeStamps [ i - 1 ] ) ; \n} \nelse { \nstream . print ( \" \" + timeStamps [ i ] ) ; \n} \n} \nstream . print ( \"]\" + \"\\n\" ) ; \n} \n} \n"}
{"8942": "public class GemFireJmxClient { \npublic static synchronized Pool getPoolForServer ( String serverName , JMX jmx ) throws InstanceNotFoundException { \nPool pool = PoolManager . find ( serverName ) ; \nif ( pool != null ) return pool ; \nPoolFactory poolFactory = PoolManager . createFactory ( ) ; \ntry { \nObjectName objectName = new ObjectName ( new StringBuilder ( \"GemFire:type=Member,member=\" ) . append ( serverName ) . toString ( ) ) ; \nString host = jmx . getAttribute ( objectName , \"Host\" ) ; \nif ( host == null || host . length ( ) == 0 ) throw new IllegalArgumentException ( \"host not found for serverName:\" + serverName + \" not found\" ) ; \nhost = lookupNetworkHost ( host ) ; \nString findJmxPort = new StringBuilder ( \"GemFire:service=CacheServer,port=*,type=Member,member=\" ) . append ( serverName ) . toString ( ) ; \nSet < ObjectName > objectNames = jmx . searchObjectNames ( findJmxPort ) ; \nif ( objectNames == null || objectNames . isEmpty ( ) ) throw new IllegalArgumentException ( \"Unable to to find port with server name:\" + serverName ) ; \nObjectName portObjectName = objectNames . iterator ( ) . next ( ) ; \nInteger port = jmx . getAttribute ( portObjectName , \"Port\" ) ; \nif ( port == null ) throw new IllegalArgumentException ( \"Unable to obtain port for objectName:\" + portObjectName + \" for server:\" + serverName ) ; \nSystem . out . print ( \"Found cache server host\" + host + \" port:\" + port + \"\\n\" ) ; \npoolFactory = poolFactory . addServer ( host , port . intValue ( ) ) ; \nreturn poolFactory . create ( serverName ) ; \n} \ncatch ( InstanceNotFoundException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( \"Unable to create pool for servername:\" + serverName + \" error:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8947": "public class GemFireJmxClient { \nstatic synchronized String lookupNetworkHost ( String host ) { \ntry { \nif ( _bundle == null ) { \nURL url = GemFireJmxClient . class . getResource ( hostPropFileName ) ; \nString filePath = null ; \nif ( url == null ) filePath = hostPropFileName ; \nelse filePath = url . toString ( ) ; \nSystem . out . print ( new StringBuilder ( \"Loading IP addresses from \" ) . append ( filePath ) . toString ( ) + \"\\n\" ) ; \n_bundle = ResourceBundle . getBundle ( \"host\" ) ; \n} \nSystem . out . print ( new StringBuilder ( \"Looking for host name \\\"\" ) . append ( host ) . append ( \"\\\" IP address in \" ) . append ( hostPropFileName ) . toString ( ) + \"\\n\" ) ; \nString newHost = _bundle . getString ( host ) ; \nSystem . out . print ( new StringBuilder ( host ) . append ( \"=\" ) . append ( newHost ) . toString ( ) + \"\\n\" ) ; \nreturn newHost ; \n} \ncatch ( RuntimeException e ) { \nSystem . out . print ( \"Using host:\" + host + \"\\n\" ) ; \nreturn host ; \n} \n} \n} \n"}
{"8960": "public class GeodeClient { \nprotected static void constructSecurity ( Properties props ) throws IOException { \nprops . setProperty ( \"security-client-auth-init\" , GeodeConfigAuthInitialize . class . getName ( ) + \".create\" ) ; \nFile sslFile = saveEnvFile ( GeodeConfigConstants . SSL_KEYSTORE_CLASSPATH_FILE_PROP ) ; \nSystem . out . print ( \"sslFile:\" + sslFile + \"\\n\" ) ; \nFile sslTrustStoreFile = saveEnvFile ( GeodeConfigConstants . SSL_TRUSTSTORE_CLASSPATH_FILE_PROP ) ; \nString sslTrustStoreFilePath = \"\" ; \nif ( sslTrustStoreFile != null ) sslTrustStoreFilePath = sslTrustStoreFile . getAbsolutePath ( ) ; \nprops . setProperty ( \"ssl-keystore\" , ( sslFile != null ) ? sslFile . getAbsolutePath ( ) : \"\" ) ; \nprops . setProperty ( \"ssl-keystore-password\" , Config . getPropertyEnv ( \"ssl-keystore-password\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-truststore\" , sslTrustStoreFilePath ) ; \nprops . setProperty ( \"ssl-protocols\" , Config . getPropertyEnv ( \"ssl-protocols\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-truststore-password\" , Config . getPropertyEnv ( \"ssl-truststore-password\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-keystore-type\" , Config . getPropertyEnv ( \"ssl-keystore-type\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-ciphers\" , Config . getPropertyEnv ( \"ssl-ciphers\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-require-authentication\" , Config . getPropertyEnv ( \"ssl-require-authentication\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-enabled-components\" , Config . getPropertyEnv ( \"ssl-enabled-components\" , \"\" ) ) ; \n} \n} \n"}
{"8967": "public class GfStatsReader { \npublic static void main ( String [ ] args ) { \nFile archiveFile , csvFile ; \nif ( args . length < 1 ) { \nSystem . err . print ( \"Usage: java \" + GfStatsReader . class . getName ( ) + \" archiveFile [csvFile [statName ]*]\" + \"\\n\" ) ; \nreturn ; \n} \ntry { \narchiveFile = Paths . get ( args [ 0 ] ) . toFile ( ) ; \nif ( archiveFile . isDirectory ( ) ) { \ntoCvsFiles ( archiveFile ) ; \nreturn ; \n} \nif ( args . length < 2 ) { \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . dumpCsvFiles ( ) ; \nreturn ; \n} \nString typeName = args [ 1 ] ; \ncsvFile = Paths . get ( args [ 2 ] ) . toFile ( ) ; \nGenericCsvStatsVisitor visitor = null ; \nif ( args . length > 3 ) { \nString [ ] stateNames = Arrays . copyOfRange ( args , 2 , args . length - 1 ) ; \nvisitor = new GenericCsvStatsVisitor ( csvFile , typeName , stateNames ) ; \n} \nelse visitor = new GenericCsvStatsVisitor ( csvFile , typeName ) ; \nSystem . out . print ( \"accepting\" + \"\\n\" ) ; \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"8968": "public class SingletonGemFireJmx { \npublic synchronized static JMX reconnect ( ) { \ntry { \nClientCache cache = null ; \ncache = ClientCacheFactory . getAnyInstance ( ) ; \nif ( cache != null && ! cache . isClosed ( ) ) { \ncache . close ( ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . out . print ( \"Cache was closed\" + \"\\n\" ) ; \n} \nif ( jmx != null ) { \njmx . dispose ( ) ; \njmx = null ; \n} \nreturn getJmx ( ) ; \n} \n} \n"}
{"8969": "public class GemFireMgmt { \npublic static int stopMembersOnHost ( String hostName ) { \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp queryExp = null ; \nValueExp [ ] values = null ; \ntry { \nInetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; \nInetAddress address = null ; \nif ( addresses != null ) { \nvalues = new ValueExp [ addresses . length ] ; \nfor ( int i = 0 ; \ni < addresses . length ; \ni ++ ) { \naddress = addresses [ i ] ; \nvalues [ i ] = Query . value ( address . getHostAddress ( ) ) ; \n} \n} \n} \ncatch ( UnknownHostException e ) { \nDebugger . print ( e . getMessage ( ) + \"\\n\" ) ; \n} \nif ( values != null ) { \nqueryExp = Query . or ( Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( \"Host\" ) , values ) ) ; \n} \nelse { \nqueryExp = Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) ; \n} \nSet < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; \nif ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) return 0 ; \nint memberCount = memberObjectNames . size ( ) ; \nMemberMXBean member = null ; \nCollection < String > locators = new ArrayList < String > ( ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nmember = GemFireJmxClient . getMember ( objectName . getKeyProperty ( \"member\" ) , SingletonGemFireJmx . getJmx ( ) ) ; \nif ( member . isLocator ( ) ) { \nlocators . add ( member . getName ( ) ) ; \n} \nelse { \nshutDownMember ( member . getName ( ) ) ; \n} \n} \nfor ( String locatorName : locators ) { \nshutDownMember ( locatorName ) ; \n} \nreturn memberCount ; \n} \n} \n"}
{"8970": "public class GemFireMgmt { \npublic static void shutDownMember ( String name ) { \ntry { \nObjectName serverName = new ObjectName ( \"GemFire:type=Member,member=\" + name ) ; \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nMemberMXBean bean = jmx . newBean ( MemberMXBean . class , serverName ) ; \nbean . shutDownMember ( ) ; \nSystem . out . print ( \"Waiting for member:\" + name + \"  to shutdown\" + \"\\n\" ) ; \nwhile ( GemFireJmxClient . checkMemberStatus ( name , SingletonGemFireJmx . getJmx ( ) ) ) { \nThread . sleep ( shutDownDelay ) ; \n} \n} \ncatch ( MalformedObjectNameException e ) { \nthrow new RuntimeException ( \"Unable to shutdown member \" + name + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \ncatch ( Exception e ) { \nSystem . out . print ( e . getMessage ( ) + \"\\n\" ) ; \n} \n} \n} \n"}
{"9014": "public class AbstractPiFormula { \nprotected void printPi ( final String piString ) { \nSystem . out . print ( \"\\npi = \" + piString . substring ( 0 , 2 ) ) ; \nint index = 2 ; \nint line = 0 ; \nint group = 0 ; \nfinal int length = piString . length ( ) ; \nwhile ( index + 5 < length ) { \nSystem . out . print ( piString . substring ( index , index + 5 ) + \" \" ) ; \nindex += 5 ; \nif ( ++ group == 10 ) { \nSystem . out . print ( \"\\n\" ) ; \nif ( ++ line == 10 ) { \nSystem . out . print ( \"\\n\" ) ; \nline = 0 ; \n} \nSystem . out . print ( \"       \" ) ; \ngroup = 0 ; \n} \n} \nif ( index < length ) { \nSystem . out . print ( piString . substring ( index ) + \"\\n\" ) ; \n} \n} \n} \n"}
{"9018": "public class Buckets { \npublic void print ( ) { \nint maxCount = 0 ; \nfor ( int i = 0 ; \ni < m_n ; \n++ i ) { \nmaxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; \n} \nfinal float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; \nfor ( int i = 0 ; \ni < m_n ; \n++ i ) { \nfinal int b = m_aCounters [ i ] ; \nm_aAlignRight . print ( i , 2 ) ; \nm_aAlignRight . print ( b , 7 ) ; \nSystem . out . print ( \": \" ) ; \nfinal int length = Math . round ( factor * b ) ; \nfor ( int j = 0 ; \nj < length ; \n++ j ) System . out . print ( \"*\" ) ; \nSystem . out . print ( \"\\n\" ) ; \n} \n} \n} \n"}
{"9032": "public class Matrix { \npublic void print ( final int width , @ Nonnull final PrintStream aPS ) { \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \n++ c ) { \nar . print ( m_aValues [ r ] [ c ] , width ) ; \n} \nar . print ( \"\\n\" ) ; \n} \n} \n} \n"}
{"9048": "public class LinearSystem { \npublic void printDecomposed ( final int width , @ Nonnull final PrintStream aPS ) throws MatrixException { \ndecompose ( ) ; \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \n++ c ) { \nar . print ( m_aLU . m_aValues [ pr ] [ c ] , width ) ; \n} \nar . print ( \"\\n\" ) ; \n} \n} \n} \n"}
{"9067": "public class IEEE754 { \npublic void print ( @ Nonnull final PrintStream aPW ) { \naPW . print ( \"------------------------------\" + \"\\n\" ) ; \nif ( isDouble ( ) ) aPW . print ( \"double value = \" + doubleValue ( ) + \"\\n\" ) ; \nelse aPW . print ( \"float value = \" + floatValue ( ) + \"\\n\" ) ; \naPW . print ( \"sign=\" + signBit ( ) ) ; \naPW . print ( \", exponent=\" + exponentBits ( ) + \" (biased=\" + biasedExponent ( ) ) ; \nif ( isZero ( ) ) aPW . print ( \", zero)\" + \"\\n\" ) ; \nelse if ( isExponentReserved ( ) ) aPW . print ( \", reserved)\" + \"\\n\" ) ; \nelse if ( isDenormalized ( ) ) aPW . print ( \", denormalized, use \" + unbiasedExponent ( ) + \")\" + \"\\n\" ) ; \nelse aPW . print ( \", normalized, unbiased=\" + unbiasedExponent ( ) + \")\" + \"\\n\" ) ; \naPW . print ( \"significand=\" + significandBits ( ) + \"\\n\" ) ; \n} \n} \n"}
{"9279": "public class Catalog { \nprotected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \nString catfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \nwhile ( ! catalogFiles . isEmpty ( ) ) { \nString catfile = ( String ) catalogFiles . elementAt ( 0 ) ; \ntry { \ncatalogFiles . remove ( 0 ) ; \n} \ncatch ( ArrayIndexOutOfBoundsException e ) { \n} \nif ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) { \ntry { \nparseCatalogFile ( catfile ) ; \n} \ncatch ( CatalogException ce ) { \nSystem . out . print ( \"FIXME: \" + ce . toString ( ) + \"\\n\" ) ; \n} \n} \nelse { \ncatalogs . addElement ( catfile ) ; \n} \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \ncatfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \n} \ncatalogFiles . clear ( ) ; \n} \n} \n"}
{"9294": "public class ThrowableHandler { \npublic static void add ( int type , Throwable t ) { \nif ( t == null ) return ; \ntry { \nfireOnThrowable ( type , t ) ; \n} \ncatch ( Throwable bad ) { \nSystem . err . print ( \"Unable to handle throwable: \" + t + \" because of:\" + \"\\n\" ) ; \nbad . printStackTrace ( ) ; \n} \n} \n} \n"}
{"9300": "public class CachedList { \nprivate void maintain ( ) { \nSoftObject obj ; \nint count = 0 ; \nwhile ( ( obj = ( SoftObject ) queue . poll ( ) ) != null ) { \ncount ++ ; \nlist . remove ( obj ) ; \n} \nif ( count != 0 ) { \nSystem . err . print ( \"vm reclaimed \" + count + \" objects\" + \"\\n\" ) ; \n} \n} \n} \n"}
{"9464": "public class CatalogManager { \nprivate synchronized void readProperties ( ) { \ntry { \npropertyFileURI = CatalogManager . class . getResource ( \"/\" + propertyFile ) ; \nInputStream in = CatalogManager . class . getResourceAsStream ( \"/\" + propertyFile ) ; \nif ( in == null ) { \nif ( ! ignoreMissingProperties ) { \nSystem . err . print ( \"Cannot find \" + propertyFile + \"\\n\" ) ; \nignoreMissingProperties = true ; \n} \nreturn ; \n} \nresources = new PropertyResourceBundle ( in ) ; \n} \ncatch ( MissingResourceException mre ) { \nif ( ! ignoreMissingProperties ) { \nSystem . err . print ( \"Cannot read \" + propertyFile + \"\\n\" ) ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( ! ignoreMissingProperties ) { \nSystem . err . print ( \"Failure trying to read \" + propertyFile + \"\\n\" ) ; \n} \n} \nif ( verbosity == null ) { \ntry { \nString verbStr = resources . getString ( \"verbosity\" ) ; \nint verb = Integer . parseInt ( verbStr . trim ( ) ) ; \ndebug . setDebug ( verb ) ; \nverbosity = new Integer ( verb ) ; \n} \ncatch ( Exception e ) { \n} \n} \n} \n} \n"}
{"9465": "public class CatalogManager { \nprivate int queryVerbosity ( ) { \nString verbStr = System . getProperty ( pVerbosity ) ; \nif ( verbStr == null ) { \nif ( resources == null ) readProperties ( ) ; \nif ( resources == null ) return defaultVerbosity ; \ntry { \nverbStr = resources . getString ( \"verbosity\" ) ; \n} \ncatch ( MissingResourceException e ) { \nreturn defaultVerbosity ; \n} \n} \ntry { \nint verb = Integer . parseInt ( verbStr . trim ( ) ) ; \nreturn verb ; \n} \ncatch ( Exception e ) { \nSystem . err . print ( \"Cannot parse verbosity: \\\"\" + verbStr + \"\\\"\" + \"\\n\" ) ; \nreturn defaultVerbosity ; \n} \n} \n} \n"}
{"9467": "public class CatalogManager { \nprivate String queryCatalogFiles ( ) { \nString catalogList = System . getProperty ( pFiles ) ; \nfromPropertiesFile = false ; \nif ( catalogList == null ) { \nif ( resources == null ) readProperties ( ) ; \nif ( resources != null ) { \ntry { \ncatalogList = resources . getString ( \"catalogs\" ) ; \nfromPropertiesFile = true ; \n} \ncatch ( MissingResourceException e ) { \nSystem . err . print ( propertyFile + \": catalogs not found.\" + \"\\n\" ) ; \ncatalogList = null ; \n} \n} \n} \nif ( catalogList == null ) { \ncatalogList = defaultCatalogFiles ; \n} \nreturn catalogList ; \n} \n} \n"}
{"9505": "public class Effect { \npublic static void main ( String [ ] args ) throws Exception { \nint n = 1 ; \nif ( args . length < 1 ) { \nusage ( ) ; \nreturn ; \n} \nProperties analyzers = new Properties ( ) ; \nanalyzers . load ( new FileInputStream ( new File ( \"analyzer.properties\" ) ) ) ; \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nString a = System . getProperty ( \"analyzer\" , \"mmseg4j\" ) ; \nAnalyzer analyzer = null ; \nString an = ( String ) analyzers . get ( a ) ; \nif ( an != null ) { \nanalyzer = ( Analyzer ) Class . forName ( an ) . newInstance ( ) ; \nmode = a ; \n} \nelse { \nusage ( ) ; \nreturn ; \n} \nif ( args . length > 1 ) { \ntry { \nn = Integer . parseInt ( args [ 1 ] ) ; \n} \ncatch ( NumberFormatException e ) { \n} \n} \nFile path = new File ( args [ 0 ] ) ; \nSystem . out . print ( \"analyzer=\" + analyzer . getClass ( ) . getName ( ) + \"\\n\" ) ; \nEffect ef = new Effect ( path , analyzer ) ; \nef . run ( mode , n ) ; \n} \n} \n"}
{"9506": "public class Performance { \npublic static void main ( String [ ] args ) throws IOException { \nif ( args . length < 1 ) { \nSystem . out . print ( \"Usage:\" + \"\\n\" ) ; \nSystem . out . print ( \"\\t-Dmode=simple, defalut is complex\" + \"\\n\" ) ; \nSystem . out . print ( \"\\tPerformance <txt path> - is a directory that contain *.txt\" + \"\\n\" ) ; \nreturn ; \n} \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nSeg seg = null ; \nDictionary dic = Dictionary . getInstance ( ) ; \nif ( \"simple\" . equals ( mode ) ) { \nseg = new SimpleSeg ( dic ) ; \n} \nelse { \nseg = new ComplexSeg ( dic ) ; \n} \nFile path = new File ( args [ 0 ] ) ; \nFile [ ] txts = path . listFiles ( new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . endsWith ( \".txt\" ) ; \n} \n} \n) ; \nlong time = 0 ; \nfor ( File txt : txts ) { \nMMSeg mmSeg = new MMSeg ( new InputStreamReader ( new FileInputStream ( txt ) ) , seg ) ; \nWord word = null ; \nOutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( new File ( txt . getAbsoluteFile ( ) + \".\" + mode + \".word\" ) ) ) ; \nBufferedWriter bw = new BufferedWriter ( osw ) ; \nlong start = System . currentTimeMillis ( ) ; \nwhile ( ( word = mmSeg . next ( ) ) != null ) { \nbw . append ( new String ( word . getString ( ) ) ) . append ( \"\\r\\n\" ) ; \n} \ntime += System . currentTimeMillis ( ) - start ; \nbw . close ( ) ; \n} \nSystem . out . print ( \"use \" + time + \"ms\" + \"\\n\" ) ; \n} \n} \n"}
{"9530": "public class CsvTableWriter { \npublic int dumpToCsv ( Context ctx , SQLiteDatabase db , String suffix ) throws FileNotFoundException { \nint numRowsWritten = 0 ; \nCursor c ; \nString filename = getCsvFilename ( db . getPath ( ) , db . getVersion ( ) , suffix ) ; \nc = db . query ( th . getTableName ( ) , null , null , null , null , null , null ) ; \nFileOutputStream fos ; \nfos = ctx . openFileOutput ( filename , 0 ) ; \nPrintWriter printWriter = new PrintWriter ( fos ) ; \nString headerRow = buildHeaderRow ( ) ; \nprintWriter . print ( headerRow + \"\\n\" ) ; \nfor ( boolean hasItem = c . moveToFirst ( ) ; \nhasItem ; \nhasItem = c . moveToNext ( ) ) { \nString csv = buildCsvRow ( c ) ; \nprintWriter . print ( csv + \"\\n\" ) ; \nnumRowsWritten ++ ; \n} \nprintWriter . flush ( ) ; \nprintWriter . close ( ) ; \nreturn numRowsWritten ; \n} \n} \n"}
{"9538": "public class DatabaseModel { \npublic void writeToIndex ( PrintWriter out ) { \nout . print ( StormEnvironment . BEGIN_DATABASE + \"\\n\" ) ; \nMap < String , String > dbMap = new HashMap < String , String > ( ) ; \ndbMap . put ( \"dbName\" , this . getDbName ( ) ) ; \ndbMap . put ( \"dbVersion\" , String . valueOf ( this . getDbVersion ( ) ) ) ; \ndbMap . put ( \"helperClass\" , this . getQualifiedClassName ( ) ) ; \nString dbInfo = CsvUtils . mapToCsv ( dbMap ) ; \nout . print ( dbInfo + \"\\n\" ) ; \nfor ( String th : this . tableHelpers ) { \nout . print ( th + \"\\n\" ) ; \n} \nout . print ( StormEnvironment . END_DATABASE + \"\\n\" ) ; \n} \n} \n"}
{"9545": "public class StormEnvironment { \nvoid writeIndex ( Filer filer ) { \nStandardLocation location = StandardLocation . SOURCE_OUTPUT ; \nFileObject indexFile ; \ntry { \nindexFile = filer . createResource ( location , \"com.turbomanage.storm\" , ENV_FILE ) ; \nOutputStream fos = indexFile . openOutputStream ( ) ; \nPrintWriter out = new PrintWriter ( fos ) ; \nout . print ( BEGIN_CONVERTERS + \"\\n\" ) ; \nfor ( ConverterModel converter : converters ) { \nconverter . writeToIndex ( out ) ; \n} \nout . print ( END_CONVERTERS + \"\\n\" ) ; \nfor ( DatabaseModel dbModel : dbModels . values ( ) ) { \ndbModel . writeToIndex ( out ) ; \n} \nout . close ( ) ; \n} \ncatch ( IOException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"9567": "public class Program { \nstatic void pauseForUserInput ( ) { \nSystem . out . print ( \"Press the Enter/Return key to continue..\" + \"\\n\" ) ; \nScanner in = new Scanner ( System . in ) ; \nin . nextLine ( ) ; \nin . close ( ) ; \n} \n} \n"}
{"9592": "public class ABeliefStore { \npublic static void main ( String [ ] args ) throws BeliefBaseException { \nBeliefBase bb = new ABeliefStore ( 100 , 4 ) ; \nbb . eval ( 0 , \"neighbour.age < 31\" ) ; \nConsole console = System . console ( ) ; \nif ( console == null ) { \nSystem . err . print ( \"No console.\" + \"\\n\" ) ; \nSystem . exit ( 1 ) ; \n} \nwhile ( true ) { \nPattern pattern = Pattern . compile ( console . readLine ( \"%nEnter your regex: \" ) ) ; \nMatcher matcher = pattern . matcher ( console . readLine ( \"Enter input string to search: \" ) ) ; \nboolean found = false ; \nwhile ( matcher . find ( ) ) { \nconsole . format ( \"I found the text\" + \" \\\"%s\\\" starting at \" + \"index %d and ending at index %d.%n\" , matcher . group ( ) , matcher . start ( ) , matcher . end ( ) ) ; \nfound = true ; \n} \nif ( ! found ) { \nconsole . format ( \"No match found.%n\" ) ; \n} \n} \n} \n} \n"}
{"9779": "public class Launcher { \nprivate static void configureApplication ( ) { \nFile file = new File ( \"chameria.props\" ) ; \nif ( file . exists ( ) ) { \nProperties props = new Properties ( ) ; \nInputStream is = null ; \ntry { \nis = new FileInputStream ( file ) ; \nprops . load ( is ) ; \nString n = props . getProperty ( \"application.name\" ) ; \nif ( n != null ) { \nQApplication . setApplicationName ( n ) ; \n} \nelse { \nQApplication . setApplicationName ( \"akquinet ChameRIA\" ) ; \n} \nn = props . getProperty ( \"application.version\" ) ; \nif ( n != null ) { \nQApplication . setApplicationVersion ( n ) ; \n} \nn = props . getProperty ( \"application.icon\" ) ; \nif ( n != null ) { \nQIcon icon = new QIcon ( n ) ; \nQApplication . setWindowIcon ( icon ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . print ( \"Cannot read the application configuration \" + e . getMessage ( ) + \"\\n\" ) ; \ne . printStackTrace ( ) ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \nQApplication . setOrganizationName ( \"akquinet A.G.\" ) ; \n} \n} \n"}
{"9780": "public class Launcher { \nprivate static void printWelcomeBanner ( ) { \nStringBuffer banner = new StringBuffer ( ) ; \nbanner . append ( \"\\n\" ) ; \nbanner . append ( \"\\t============================\\n\" ) ; \nbanner . append ( \"\\t|                          |\\n\" ) ; \nbanner . append ( \"\\t|   Welcome to ChameRIA    |\\n\" ) ; \nbanner . append ( \"\\t|                          |\\n\" ) ; \nbanner . append ( \"\\t============================\\n\" ) ; \nbanner . append ( \"\\n\" ) ; \nSystem . out . print ( banner + \"\\n\" ) ; \n} \n} \n"}
{"9781": "public class Launcher { \nprivate static void printStoppedBanner ( ) { \nSystem . out . print ( \"\\n\" + \"\\n\" ) ; \nSystem . out . print ( \"\\t=========================\" + \"\\n\" ) ; \nSystem . out . print ( \"\\t|   ChameRIA  stopped   |\" + \"\\n\" ) ; \nSystem . out . print ( \"\\t=========================\" + \"\\n\" ) ; \nSystem . out . print ( \"\\n\" + \"\\n\" ) ; \n} \n} \n"}
{"9783": "public class Launcher { \nprivate static void registerShutdownHook ( final ChameRIA chameleon ) { \nRuntime runtime = Runtime . getRuntime ( ) ; \nRunnable hook = new Runnable ( ) { \npublic void run ( ) { \ntry { \nif ( chameleon != null ) { \nchameleon . stop ( ) ; \nprintStoppedBanner ( ) ; \n} \n} \ncatch ( BundleException e ) { \nSystem . err . print ( \"Cannot stop Chameleon correctly : \" + e . getMessage ( ) + \"\\n\" ) ; \n} \ncatch ( InterruptedException e ) { \nSystem . err . print ( \"Unexpected Exception : \" + e . getMessage ( ) + \"\\n\" ) ; \n} \n} \n} \n; \nruntime . addShutdownHook ( new Thread ( hook ) ) ; \n} \n} \n"}
{"9887": "public class StartHELM2Parser { \npublic static void main ( String [ ] args ) throws ParseException , ExceptionState , IOException { \nOptions options = new Options ( ) ; \noptions . addOption ( \"inputHELM\" , true , \"HELM1 or HELM2 string in a file\" ) ; \noptions . addOption ( \"output\" , true , \"output can be in JSON- or HELM2-format\" ) ; \noptions . addOption ( \"translate\" , false , \"translate HELM1 to HELM2\" ) ; \nCommandLineParser parameter = new DefaultParser ( ) ; \ntry { \nCommandLine cmd = parameter . parse ( options , args ) ; \nString filename = cmd . getOptionValue ( \"inputHELM\" ) ; \nParserHELM2 parser = new ParserHELM2 ( ) ; \nFileReader in = new FileReader ( filename ) ; \nBufferedReader br = new BufferedReader ( in ) ; \nString line ; \nString helm ; \ntry { \nwhile ( ( line = br . readLine ( ) ) != null ) { \nhelm = line ; \nif ( cmd . hasOption ( \"translate\" ) ) { \nConverterHELM1ToHELM2 converter = new ConverterHELM1ToHELM2 ( ) ; \nhelm = converter . doConvert ( helm ) ; \nLOG . info ( \"HELM1 is translated to HELM2\" ) ; \n} \nparser . parse ( helm ) ; \nString output = \"\" ; \nif ( cmd . getOptionValue ( \"output\" ) . equals ( \"HELM2\" ) ) { \noutput = parser . getHELM2Notation ( ) . toHELM2 ( ) ; \n} \nelse if ( cmd . getOptionValue ( \"output\" ) . equals ( \"JSON\" ) ) { \noutput = parser . getJSON ( ) ; \n} \nSystem . out . print ( output + \"\\n\" ) ; \n} \n} \nfinally { \nbr . close ( ) ; \n} \n} \ncatch ( NullPointerException e ) { \nSystem . out . print ( \"Please call the program with the following arguments: \" + \"\\n\" + \"-inputHELM  <\" + options . getOption ( \"inputHELM\" ) . getDescription ( ) + \">\\n\" + \"-output <\" + options . getOption ( \"output\" ) . getDescription ( ) + \">\\n-translate(optional) <\" + options . getOption ( \"translate\" ) . getDescription ( ) + \">\" + \"\\n\" ) ; \n} \ncatch ( ParseException exp ) { \nSystem . out . print ( \"Unexpected exception: \" + exp . getMessage ( ) + \"\\n\" ) ; \n} \n} \n} \n"}
{"10034": "public class IO { \npublic static String readContentAsString ( File file , String encoding ) { \nInputStream is = null ; \ntry { \nis = new FileInputStream ( file ) ; \nStringWriter result = new StringWriter ( ) ; \nPrintWriter out = new PrintWriter ( result ) ; \nBufferedReader reader = new BufferedReader ( new InputStreamReader ( is , encoding ) ) ; \nString line = null ; \nwhile ( ( line = reader . readLine ( ) ) != null ) { \nout . print ( line + \"\\n\" ) ; \n} \nreturn result . toString ( ) ; \n} \ncatch ( IOException e ) { \nthrow new UnexpectedException ( e ) ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Exception e ) { \n} \n} \n} \n} \n} \n"}
{"10077": "public class ArgumentHandler { \npublic static < A > A readArguments ( Class < A > interfaceClass , String [ ] args ) { \nA result = null ; \ntry { \nfinal ArgumentHandler argumentHandler = new ArgumentHandler ( args ) ; \nresult = argumentHandler . getInstance ( interfaceClass ) ; \nargumentHandler . processArguments ( new ArgumentProcessor ( ) { \n@ Override public void process ( List < String > remaining ) throws InvalidArgumentsException { \nif ( remaining . size ( ) > 0 ) { \nthrow new InvalidArgumentsException ( \"The following arguments could not be understood: \" + remaining ) ; \n} \n} \n} \n) ; \n} \ncatch ( InvalidArgumentsException e ) { \nSystem . out . print ( e . getMessage ( ) + \"\\n\" ) ; \nshowUsage ( interfaceClass ) ; \nresult = null ; \n} \nif ( result instanceof ArgumentsWithHelp ) { \nif ( ( ( ArgumentsWithHelp ) result ) . getHelp ( ) ) { \nshowUsage ( interfaceClass ) ; \nresult = null ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10127": "public class ConsoleAuthProvider { \n@ Override public String getAuthorization ( String authorizationUrl ) throws CubeSensorsException { \nSystem . out . print ( \"authorizationUrl:\" + authorizationUrl + \"\\n\" ) ; \nSystem . out . print ( \"provide authorization code:\" ) ; \ntry ( Scanner in = new Scanner ( System . in ) ) { \nString authorization = in . nextLine ( ) ; \nreturn authorization ; \n} \n} \n} \n"}
{"10172": "public class BaseSourceFile { \npublic InputStream makeInStream ( ) { \nif ( m_InputStream != null ) return m_InputStream ; \ntry { \nreturn new FileInputStream ( m_inputFile ) ; \n} \ncatch ( FileNotFoundException ex ) { \nSystem . out . print ( \"Warning: scanned file does not exist: \" + m_inputFile . getPath ( ) + \"\\n\" ) ; \n} \nreturn null ; \n} \n} \n"}
{"10499": "public class ResolutionInterpreter { \nprivate void printIntroduction ( ) { \nSystem . out . print ( \"| LoJiX Prolog.\" + \"\\n\" ) ; \nSystem . out . print ( \"| Copyright The Sett Ltd.\" + \"\\n\" ) ; \nSystem . out . print ( \"| Licensed under the Apache License, Version 2.0.\" + \"\\n\" ) ; \nSystem . out . print ( \"| //www.apache.org/licenses/LICENSE-2.0\" + \"\\n\" ) ; \nSystem . out . print ( \"\\n\" ) ; \n} \n} \n"}
{"10502": "public class ResolutionInterpreter { \nprivate void evaluateQuery ( ) { \nIterator < Set < Variable > > i = engine . iterator ( ) ; \nif ( ! i . hasNext ( ) ) { \nSystem . out . print ( \"false. \" + \"\\n\" ) ; \nreturn ; \n} \nfor ( ; \ni . hasNext ( ) ; \n) { \nSet < Variable > solution = i . next ( ) ; \nif ( solution . isEmpty ( ) ) { \nSystem . out . print ( \"true\" ) ; \n} \nelse { \nfor ( Iterator < Variable > j = solution . iterator ( ) ; \nj . hasNext ( ) ; \n) { \nVariable nextVar = j . next ( ) ; \nString varName = engine . getVariableName ( nextVar . getName ( ) ) ; \nSystem . out . print ( varName + \" = \" + nextVar . getValue ( ) . toString ( engine , true , false ) ) ; \nif ( j . hasNext ( ) ) { \nSystem . out . print ( \"\\n\" ) ; \n} \n} \n} \nif ( ! i . hasNext ( ) ) { \nSystem . out . print ( \".\" + \"\\n\" ) ; \nbreak ; \n} \ntry { \nint key = consoleReader . readVirtualKey ( ) ; \nif ( key == SEMICOLON ) { \nSystem . out . print ( \" ;\" + \"\\n\" ) ; \n} \nelse { \nSystem . out . print ( \"\\n\" ) ; \nbreak ; \n} \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n} \n"}
{"10703": "public class ExecS_CliParser { \nstatic int doParse ( String [ ] args , ExecS_CliParser cli , String appName ) { \nException err = cli . parse ( args ) ; \nif ( err != null ) { \nSystem . err . print ( appName + \": error parsing command line -> \" + err . getMessage ( ) + \"\\n\" ) ; \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"10716": "public class NakamuraMain { \nprivate static void log ( PrintStream out , String prefix , String message , Throwable t ) { \nfinal StringBuilder linePrefixBuilder = new StringBuilder ( ) ; \nsynchronized ( fmt ) { \nlinePrefixBuilder . append ( fmt . format ( new Date ( ) ) ) ; \n} \nlinePrefixBuilder . append ( prefix ) ; \nlinePrefixBuilder . append ( \" [\" ) ; \nlinePrefixBuilder . append ( Thread . currentThread ( ) . getName ( ) ) ; \nlinePrefixBuilder . append ( \"] \" ) ; \nfinal String linePrefix = linePrefixBuilder . toString ( ) ; \nout . print ( linePrefix ) ; \nout . print ( message + \"\\n\" ) ; \nif ( t != null ) { \nt . printStackTrace ( new PrintStream ( out ) { \n@ Override public void println ( String x ) { \nsynchronized ( this ) { \nprint ( linePrefix ) ; \nsuper . print ( x + \"\\n\" ) ; \nflush ( ) ; \n} \n} \n} \n) ; \n} \n} \n} \n"}
{"10733": "public class ConsoleDebugger { \nprivate void createDebug ( ) { \nObservableReader debugReader = new ObservableReader ( reader ) ; \nreaderListener = new ReaderListener ( ) { \npublic void read ( String str ) { \nSystem . out . print ( dateFormatter . format ( new Date ( ) ) + \" RCV  (\" + connection . hashCode ( ) + \"): \" + str + \"\\n\" ) ; \n} \n} \n; \ndebugReader . addReaderListener ( readerListener ) ; \nObservableWriter debugWriter = new ObservableWriter ( writer ) ; \nwriterListener = new WriterListener ( ) { \npublic void write ( String str ) { \nSystem . out . print ( dateFormatter . format ( new Date ( ) ) + \" SENT (\" + connection . hashCode ( ) + \"): \" + str + \"\\n\" ) ; \n} \n} \n; \ndebugWriter . addWriterListener ( writerListener ) ; \nreader = debugReader ; \nwriter = debugWriter ; \nlistener = new PacketListener ( ) { \npublic void processPacket ( Packet packet ) { \nif ( printInterpreted ) { \nSystem . out . print ( dateFormatter . format ( new Date ( ) ) + \" RCV PKT (\" + connection . hashCode ( ) + \"): \" + packet . toXML ( ) + \"\\n\" ) ; \n} \n} \n} \n; \nconnListener = new ConnectionListener ( ) { \npublic void connectionClosed ( ) { \nSystem . out . print ( dateFormatter . format ( new Date ( ) ) + \" Connection closed (\" + connection . hashCode ( ) + \")\" + \"\\n\" ) ; \n} \npublic void connectionClosedOnError ( Exception e ) { \nSystem . out . print ( dateFormatter . format ( new Date ( ) ) + \" Connection closed due to an exception (\" + connection . hashCode ( ) + \")\" + \"\\n\" ) ; \ne . printStackTrace ( ) ; \n} \npublic void reconnectionFailed ( Exception e ) { \nSystem . out . print ( dateFormatter . format ( new Date ( ) ) + \" Reconnection failed due to an exception (\" + connection . hashCode ( ) + \")\" + \"\\n\" ) ; \ne . printStackTrace ( ) ; \n} \npublic void reconnectionSuccessful ( ) { \nSystem . out . print ( dateFormatter . format ( new Date ( ) ) + \" Connection reconnected (\" + connection . hashCode ( ) + \")\" + \"\\n\" ) ; \n} \npublic void reconnectingIn ( int seconds ) { \nSystem . out . print ( dateFormatter . format ( new Date ( ) ) + \" Connection (\" + connection . hashCode ( ) + \") will reconnect in \" + seconds + \"\\n\" ) ; \n} \n} \n; \n} \n} \n"}
{"10757": "public class LaunchNakamura { \nprivate void browserButtonActionPerformed ( java . awt . event . ActionEvent evt ) { \ntry { \nDesktop . getDesktop ( ) . browse ( new URL ( localhostURL ) . toURI ( ) ) ; \n} \ncatch ( IOException e ) { \nSystem . err . print ( \"IO Exception: \" + e . getMessage ( ) + \"\\n\" ) ; \n} \ncatch ( URISyntaxException e ) { \nSystem . err . print ( \"URISyntaxException: \" + e . getMessage ( ) + \"\\n\" ) ; \n} \n} \n} \n"}
{"10758": "public class LaunchNakamura { \nprotected ImageIcon createImageIcon ( String path , String description ) { \njava . net . URL imgURL = getClass ( ) . getResource ( path ) ; \nif ( imgURL != null ) { \nreturn new ImageIcon ( imgURL , description ) ; \n} \nelse { \nSystem . err . print ( \"Couldn't find file: \" + path + \"\\n\" ) ; \nreturn null ; \n} \n} \n} \n"}
{"10827": "public class Gen_RunScripts { \nprotected final int initOutputDir ( ) { \nString parent = System . getProperty ( \"user.dir\" ) ; \nString target = parent + File . separator + this . target ; \nFile targetDir = new File ( target ) ; \nFile parentDir = targetDir . getParentFile ( ) ; \nif ( targetDir . exists ( ) ) { \nif ( ! targetDir . isDirectory ( ) ) { \nSystem . err . print ( this . getAppName ( ) + \": target dir <\" + target + \"> exists but is not a directory, exiting\" + \"\\n\" ) ; \nreturn - 1 ; \n} \nif ( ! targetDir . canWrite ( ) ) { \nSystem . err . print ( this . getAppName ( ) + \": target dir <\" + target + \"> exists but but cannot write into it, exiting\" + \"\\n\" ) ; \nreturn - 1 ; \n} \n} \nelse { \nif ( ! parentDir . isDirectory ( ) ) { \nSystem . err . print ( this . getAppName ( ) + \": target dir parent <\" + parent + \"> exists but is not a directory, exiting\" + \"\\n\" ) ; \nreturn - 1 ; \n} \nif ( ! parentDir . canWrite ( ) ) { \nSystem . err . print ( this . getAppName ( ) + \": target dir parent <\" + parent + \"> exists but but cannot write into it, exiting\" + \"\\n\" ) ; \nreturn - 1 ; \n} \nif ( ! targetDir . mkdir ( ) ) { \nSystem . err . print ( this . getAppName ( ) + \": could not create target dir <\" + target + \">, exiting\" + \"\\n\" ) ; \nreturn - 1 ; \n} \n} \nthis . outputDir = target ; \nreturn 0 ; \n} \n} \n"}
{"10828": "public class Gen_RunScripts { \nprotected final Properties loadProperties ( String filename ) { \nProperties ret = new Properties ( ) ; \nURL url = null ; \nFile f = new File ( filename . toString ( ) ) ; \nif ( f . exists ( ) ) { \ntry { \nurl = f . toURI ( ) . toURL ( ) ; \n} \ncatch ( Exception ignore ) { \n} \n} \nelse { \nClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nurl = loader . getResource ( filename ) ; \nif ( url == null ) { \nloader = Gen_RunScripts . class . getClassLoader ( ) ; \nurl = loader . getResource ( filename ) ; \n} \n} \ntry { \nret . load ( url . openStream ( ) ) ; \n} \ncatch ( IOException e ) { \nSystem . err . print ( this . getAppName ( ) + \": cannot load property file <\" + filename + \">, IO exception\\n--><\" + e + \">\" + \"\\n\" ) ; \n} \ncatch ( Exception e ) { \nSystem . err . print ( this . getAppName ( ) + \": cannot load property file <\" + filename + \">, general exception\\n--><\" + e + \">\" + \"\\n\" ) ; \n} \nreturn ret ; \n} \n} \n"}
{"10891": "public class ExecS { \nprotected int executeApplication ( Object svc , String [ ] args , String orig ) { \nif ( svc != null && ( svc instanceof ExecS_Application ) ) { \nif ( svc instanceof Gen_RunScripts ) { \n( ( Gen_RunScripts ) svc ) . setClassMap ( this . classmap ) ; \n} \nif ( svc instanceof Gen_ExecJarScripts ) { \n( ( Gen_ExecJarScripts ) svc ) . setClassMap ( this . classmap ) ; \n} \nreturn ( ( ExecS_Application ) svc ) . executeApplication ( ArrayUtils . remove ( args , 0 ) ) ; \n} \nelse if ( svc == null ) { \nSystem . err . print ( \"could not create object for class or application name <\" + orig + \">\" + \"\\n\" ) ; \nreturn - 1 ; \n} \nelse if ( ! ( svc instanceof ExecS_Application ) ) { \nSystem . err . print ( \"given class or application name <\" + orig + \"> is not instance of \" + ExecS_Application . class . getName ( ) + \"\\n\" ) ; \nreturn - 2 ; \n} \nelse { \nSystem . err . print ( \"unexpected error processing for class or application name <\" + orig + \">\" + \"\\n\" ) ; \nreturn - 3 ; \n} \n} \n} \n"}
{"10892": "public class ExecS { \nprotected final void printList ( ) { \nST list = this . stg . getInstanceOf ( \"list\" ) ; \nlist . add ( \"appName\" , this . appName ) ; \nif ( this . classmap . size ( ) > 0 ) { \nList < Map < String , String > > l = new ArrayList < > ( ) ; \nfor ( String key : this . classmap . keySet ( ) ) { \nMap < String , String > m = new HashMap < > ( ) ; \nm . put ( \"key\" , key ) ; \nm . put ( \"val\" , this . classmap . get ( key ) . getName ( ) ) ; \nl . add ( m ) ; \n} \nlist . add ( \"classMap\" , l ) ; \n} \nlist . add ( \"className\" , this . classNames ) ; \nSystem . out . print ( list . render ( ) + \"\\n\" ) ; \n} \n} \n"}
{"10893": "public class ExecS { \nprotected final void printUsage ( ) { \nST usage = this . stg . getInstanceOf ( \"usage\" ) ; \nusage . add ( \"appName\" , this . appName ) ; \nusage . add ( \"packageFilter\" , this . packageFilter ) ; \nusage . add ( \"jarFilter\" , this . jarFilter ) ; \nusage . add ( \"excludedNames\" , new TreeSet < > ( Arrays . asList ( new CF ( ) . excludedNames ) ) ) ; \nSystem . out . print ( usage . render ( ) + \"\\n\" ) ; \n} \n} \n"}
{"10898": "public class Gen_ExecJarScripts { \npublic boolean writeFile ( File file , List < String > lines ) { \nif ( file . exists ( ) ) { \nfile . delete ( ) ; \n} \ntry { \nFileWriter out = new FileWriter ( file ) ; \nfor ( String s : lines ) { \nout . write ( s ) ; \nout . write ( System . getProperty ( \"line.separator\" ) ) ; \n} \nout . close ( ) ; \nfile . setExecutable ( true ) ; \n} \ncatch ( IOException ex ) { \nSystem . err . print ( this . getAppName ( ) + \": IO exception while writing to file - \" + file + \" with message: \" + ex . getMessage ( ) + \"\\n\" ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"10899": "public class Gen_ExecJarScripts { \nprotected boolean inExecJar ( ) { \nClass < Gen_ExecJarScripts > clazz = Gen_ExecJarScripts . class ; \nString className = clazz . getSimpleName ( ) + \".class\" ; \nString classPath = clazz . getResource ( className ) . toString ( ) ; \nif ( ! classPath . startsWith ( \"jar\" ) ) { \nSystem . err . print ( this . getAppName ( ) + \": not started in a jar, cannot proceed\" + \"\\n\" ) ; \nreturn false ; \n} \nString manifestPath = classPath . substring ( 0 , classPath . lastIndexOf ( \"!\" ) + 1 ) + \"/META-INF/MANIFEST.MF\" ; \nManifest manifest ; \ntry { \nmanifest = new Manifest ( new URL ( manifestPath ) . openStream ( ) ) ; \n} \ncatch ( IOException ex ) { \nSystem . err . print ( this . getAppName ( ) + \": exception while retrieving manifest: \" + ex . getMessage ( ) + \"\\n\" ) ; \nreturn false ; \n} \nAttributes attr = manifest . getMainAttributes ( ) ; \nif ( StringUtils . isBlank ( attr . getValue ( \"Main-Class\" ) ) ) { \nSystem . err . print ( this . getAppName ( ) + \": no main class in manifest, probably not an executable JAR, cannot continue\" + \"\\n\" ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
