{"391": "public class Manager { \npublic static void main ( String [ ] args ) throws Exception { \nif ( args . length != 1 ) { \nSystem . err . println ( \"Usage: java -Dcom.sun.management.jmxremote \" + Manager . class . getName ( ) + \" [module class name]\" ) ; \nSystem . err . println ( \"Then run 'jconsole' to connect.\" ) ; \nSystem . exit ( 1 ) ; \n} \nModule module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; \nInjector injector = Guice . createInjector ( module ) ; \nmanage ( args [ 0 ] , injector ) ; \n; \nThread . sleep ( Long . MAX_VALUE ) ; \n} \n} \n"}
{"1358": "public class SimpleLogger { \nprotected void print ( final Level level , final String message , final Throwable throwable ) { \nif ( ! isEnabled ( level ) ) { \nreturn ; \n} \nStringBuilder msg = new StringBuilder ( ) . append ( slf . getElapsedTime ( ) ) . append ( ' ' ) . append ( '[' ) . append ( level ) . append ( ']' ) . append ( ' ' ) . append ( getCallerClass ( ) ) . append ( ' ' ) . append ( '-' ) . append ( ' ' ) . append ( message ) ; \n; \nif ( throwable != null ) { \nthrowable . printStackTrace ( System . out ) ; \n} \n} \n} \n"}
{"1409": "public class Cli { \npublic void printUsage ( final String commandName ) { \nfinal StringBuilder usage = new StringBuilder ( commandName ) ; \nfor ( final Option option : options ) { \nif ( option . shortName != null ) { \nusage . append ( \" [-\" ) . append ( option . shortName ) . append ( \"]\" ) ; \n} \nelse if ( option . longName != null ) { \nusage . append ( \" [--\" ) . append ( option . longName ) . append ( \"]\" ) ; \n} \n} \nfor ( final Param param : params ) { \nusage . append ( \" \" ) . append ( param . label ) ; \n} \n; \n} \n} \n"}
{"1694": "public class JoddJoy { \nprivate void printLogo ( ) { \n; \n} \n} \n"}
{"1816": "public class ClusteredServiceContainer { \npublic static void main ( final String [ ] args ) { \nloadPropertiesFiles ( args ) ; \ntry ( ClusteredServiceContainer container = launch ( ) ) { \ncontainer . context ( ) . shutdownSignalBarrier ( ) . await ( ) ; \n; \n} \n} \n} \n"}
{"1818": "public class SamplesUtil { \n@ SuppressWarnings ( \"unused\" ) public static void printError ( final String channel , final int streamId , final int sessionId , final String message , final HeaderFlyweight cause ) { \n; \n} \n} \n"}
{"1819": "public class SamplesUtil { \npublic static void printRate ( final double messagesPerSec , final double bytesPerSec , final long totalMessages , final long totalBytes ) { \n; \n} \n} \n"}
{"1967": "public class MediaDriver { \npublic static void main ( final String [ ] args ) { \nloadPropertiesFiles ( args ) ; \nfinal ShutdownSignalBarrier barrier = new ShutdownSignalBarrier ( ) ; \nfinal MediaDriver . Context ctx = new MediaDriver . Context ( ) ; \nctx . terminationHook ( barrier :: signal ) ; \ntry ( MediaDriver ignore = MediaDriver . launch ( ctx ) ) { \nbarrier . await ( ) ; \n; \n} \n} \n} \n"}
{"2794": "public class VaultSession { \nprivate void attributeCreatedDisplay ( String vaultBlock , String attributeName ) { \n; \n} \n} \n"}
{"2795": "public class VaultSession { \npublic void vaultConfigurationDisplay ( ) { \nfinal String configuration = vaultConfiguration ( ) ; \n; \n; \n; \n; \n; \n; \n; \n; \n} \n} \n"}
{"3734": "public class FSTBinaryOffheapMap { \npublic void resizeStore ( long required , long maxgrowbytes ) { \nif ( mappedFile == null ) throw new RuntimeException ( \"store is full. Required: \" + required ) ; \nif ( required <= memory . length ( ) ) return ; \nmutationCount ++ ; \n; \nlong tim = System . currentTimeMillis ( ) ; \n( ( MMFBytez ) memory ) . freeAndClose ( ) ; \nmemory = null ; \ntry { \nFile mf = new File ( mappedFile ) ; \nFileOutputStream f = new FileOutputStream ( mf , true ) ; \nlong len = mf . length ( ) ; \nrequired = required + Math . min ( required , maxgrowbytes ) ; \nbyte [ ] toWrite = new byte [ 1000 ] ; \nlong max = ( required - len ) / 1000 ; \nfor ( long i = 0 ; \ni < max + 2 ; \ni ++ ) { \nf . write ( toWrite ) ; \n} \nf . flush ( ) ; \nf . close ( ) ; \nresetMem ( mappedFile , mf . length ( ) ) ; \n; \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"3862": "public class JCublasNDArrayFactory { \n@ Override public INDArray createFromNpyFile ( File file ) { \nbyte [ ] pathBytes = file . getAbsolutePath ( ) . getBytes ( Charset . forName ( \"UTF-8\" ) ) ; \nString otherBytes = new String ( pathBytes ) ; \n; \nByteBuffer directBuffer = ByteBuffer . allocateDirect ( pathBytes . length ) . order ( ByteOrder . nativeOrder ( ) ) ; \ndirectBuffer . put ( pathBytes ) ; \ndirectBuffer . rewind ( ) ; \ndirectBuffer . position ( 0 ) ; \nPointer pointer = nativeOps . numpyFromFile ( new BytePointer ( directBuffer ) ) ; \nINDArray result = createFromNpyPointer ( pointer ) ; \nnativeOps . releaseNumpy ( pointer ) ; \nreturn result ; \n} \n} \n"}
{"4209": "public class FeatureDatasetFactoryManager { \nstatic public FeatureDataset wrap ( FeatureType wantFeatureType , NetcdfDataset ncd , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { \nif ( debug ) ; \nif ( ( wantFeatureType == null ) || ( wantFeatureType == FeatureType . ANY ) ) { \nreturn wrapUnknown ( ncd , task , errlog ) ; \n} \nObject analysis = null ; \nFeatureDatasetFactory useFactory = null ; \nfor ( Factory fac : factoryList ) { \nif ( ! featureTypeOk ( wantFeatureType , fac . featureType ) ) continue ; \nif ( debug ) ; \nanalysis = fac . factory . isMine ( wantFeatureType , ncd , errlog ) ; \nif ( analysis != null ) { \nuseFactory = fac . factory ; \nbreak ; \n} \n} \nif ( null == useFactory ) { \nerrlog . format ( \"**Failed to find FeatureDatasetFactory for= %s datatype=%s%n\" , ncd . getLocation ( ) , wantFeatureType ) ; \nreturn null ; \n} \nreturn useFactory . open ( wantFeatureType , ncd , analysis , task , errlog ) ; \n} \n} \n"}
{"4211": "public class FeatureDatasetFactoryManager { \nstatic public FeatureType findFeatureType ( NetcdfFile ncd ) { \nString cdm_datatype = ncd . findAttValueIgnoreCase ( null , CF . FEATURE_TYPE , null ) ; \nif ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , \"cdm_data_type\" , null ) ; \nif ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , \"cdm_datatype\" , null ) ; \nif ( cdm_datatype == null ) cdm_datatype = ncd . findAttValueIgnoreCase ( null , \"thredds_data_type\" , null ) ; \nif ( cdm_datatype != null ) { \nfor ( FeatureType ft : FeatureType . values ( ) ) if ( cdm_datatype . equalsIgnoreCase ( ft . name ( ) ) ) { \nif ( debug ) ; \nreturn ft ; \n} \n} \nCF . FeatureType cff = CF . FeatureType . getFeatureTypeFromGlobalAttribute ( ncd ) ; \nif ( cff != null ) return CF . FeatureType . convert ( cff ) ; \nreturn null ; \n} \n} \n"}
{"4235": "public class N3iosp { \nprivate ucar . ma2 . Array readRecordData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException { \nRange recordRange = section . getRange ( 0 ) ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nN3header . Vinfo vinfo = ( N3header . Vinfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( ( int ) ( vinfo . begin - header . recStart ) ) ; \n} \nif ( header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"Cant read records when recsize > \" + Integer . MAX_VALUE ) ; \nlong nrecs = section . computeSize ( ) ; \nif ( nrecs * header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"Too large read: nrecs * recsize= \" + ( nrecs * header . recsize ) + \"bytes exceeds \" + Integer . MAX_VALUE ) ; \nmembers . setStructureSize ( ( int ) header . recsize ) ; \nArrayStructureBB structureArray = new ArrayStructureBB ( members , new int [ ] { \nrecordRange . length ( ) } \n) ; \nbyte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; \nint count = 0 ; \nfor ( int recnum : recordRange ) { \nif ( debugRecord ) ; \nraf . seek ( header . recStart + recnum * header . recsize ) ; \nif ( recnum != header . numrecs - 1 ) raf . readFully ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \nelse raf . read ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \ncount ++ ; \n} \nreturn structureArray ; \n} \n} \n"}
{"4254": "public class ThreddsDatasetChooser { \npublic static void main ( String args [ ] ) { \nboolean usePopup = false ; \nfor ( int i = 0 ; \ni < args . length ; \ni ++ ) { \nif ( args [ i ] . equals ( \"-usePopup\" ) ) usePopup = true ; \n} \ntry { \nstore = XMLStore . createFromFile ( \"ThreddsDatasetChooser\" , null ) ; \np = store . getPreferences ( ) ; \n} \ncatch ( IOException e ) { \n; \n} \nfinal JFrame frame = new JFrame ( \"Thredds Dataset Chooser\" ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \npublic void windowClosing ( WindowEvent e ) { \nchooser . save ( ) ; \nRectangle bounds = frame . getBounds ( ) ; \np . putBeanObject ( FRAME_SIZE , bounds ) ; \ntry { \nstore . save ( ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \n} \nSystem . exit ( 0 ) ; \n} \n} \n) ; \nchooser = new ThreddsDatasetChooser ( p , null , frame , true , usePopup , false ) ; \nchooser . setDoResolve ( true ) ; \nframe . getContentPane ( ) . add ( chooser ) ; \nRectangle bounds = ( Rectangle ) p . getBean ( FRAME_SIZE , new Rectangle ( 50 , 50 , 800 , 450 ) ) ; \nframe . setBounds ( bounds ) ; \nframe . pack ( ) ; \nframe . setBounds ( bounds ) ; \nframe . setVisible ( true ) ; \n} \n} \n"}
{"4268": "public class McIDASGridReader { \npublic static void main ( String [ ] args ) throws IOException { \nString file = \"GRID2001\" ; \nif ( args . length > 0 ) { \nfile = args [ 0 ] ; \n} \nMcIDASGridReader mg = new McIDASGridReader ( file ) ; \nGridIndex gridIndex = mg . getGridIndex ( ) ; \nList grids = gridIndex . getGridRecords ( ) ; \n; \nint num = Math . min ( grids . size ( ) , 10 ) ; \nfor ( int i = 0 ; \ni < num ; \ni ++ ) { \n; \n} \n} \n} \n"}
{"4281": "public class GempakGridReader { \npublic void printGrids ( ) { \nList < GridRecord > gridList = gridIndex . getGridRecords ( ) ; \nif ( gridList == null ) return ; \n; \nfor ( GridRecord aGridList : gridList ) { \n; \n} \n} \n} \n"}
{"4322": "public class SigmetIOServiceProvider { \npublic boolean isValidFile ( ucar . unidata . io . RandomAccessFile raf ) { \ntry { \nraf . order ( RandomAccessFile . LITTLE_ENDIAN ) ; \nraf . seek ( 0 ) ; \nshort [ ] data = new short [ 13 ] ; \nraf . readShort ( data , 0 , 13 ) ; \nreturn ( data [ 0 ] == ( short ) 27 && data [ 6 ] == ( short ) 26 && data [ 12 ] == ( short ) 15 ) ; \n} \ncatch ( IOException ioe ) { \n; \nreturn false ; \n} \n} \n} \n"}
{"4323": "public class SigmetIOServiceProvider { \npublic java . util . Map < String , String > readStnNames ( ucar . unidata . io . RandomAccessFile raf ) { \njava . util . Map < String , String > hdrNames = new java . util . HashMap < String , String > ( ) ; \ntry { \nraf . seek ( 6288 ) ; \nString stnName = raf . readString ( 16 ) ; \nraf . seek ( 6306 ) ; \nString stnName_util = raf . readString ( 16 ) ; \nhdrNames . put ( \"StationName\" , stnName . trim ( ) ) ; \nhdrNames . put ( \"StationName_SetupUtility\" , stnName_util . trim ( ) ) ; \n} \ncatch ( Exception e ) { \n; \ne . printStackTrace ( ) ; \n} \nreturn hdrNames ; \n} \n} \n"}
{"4326": "public class SigmetIOServiceProvider { \npublic long readToByteChannel11 ( ucar . nc2 . Variable v2 , Section section , WritableByteChannel channel ) throws java . io . IOException , ucar . ma2 . InvalidRangeException { \nArray data = readData ( v2 , section ) ; \nfloat [ ] ftdata = new float [ ( int ) data . getSize ( ) ] ; \nbyte [ ] bytedata = new byte [ ( int ) data . getSize ( ) * 4 ] ; \nIndexIterator iter = data . getIndexIterator ( ) ; \nint i = 0 ; \nByteBuffer buffer = ByteBuffer . allocateDirect ( bytedata . length ) ; \nwhile ( iter . hasNext ( ) ) { \nftdata [ i ] = iter . getFloatNext ( ) ; \nbytedata [ i ] = new Float ( ftdata [ i ] ) . byteValue ( ) ; \nbuffer . put ( bytedata [ i ] ) ; \ni ++ ; \n} \nbuffer = ByteBuffer . wrap ( bytedata ) ; \nint count = channel . write ( buffer ) ; \n; \nif ( buffer . hasRemaining ( ) ) { \nbuffer . compact ( ) ; \n} \nelse { \nbuffer . clear ( ) ; \n} \nreturn ( long ) count ; \n} \n} \n"}
{"4344": "public class Format { \nprivate static void show ( double d , int sigfig ) { \n; \n} \n} \n"}
{"4345": "public class Format { \nprivate static void show2 ( double d , int dec_places ) { \n; \n} \n} \n"}
{"4357": "public class DodsURLExtractor { \npublic ArrayList extract ( String url ) throws IOException { \nif ( debug ) ; \nbaseURL = new URL ( url ) ; \nInputStream in = baseURL . openStream ( ) ; \nInputStreamReader r = new InputStreamReader ( filterTag ( in ) , CDM . UTF8 ) ; \nHTMLEditorKit . ParserCallback callback = new CallerBacker ( ) ; \nurlList = new ArrayList ( ) ; \nwantURLS = true ; \nwantText = false ; \nparser . parse ( r , callback , false ) ; \nreturn urlList ; \n} \n} \n"}
{"4358": "public class DodsURLExtractor { \npublic String getTextContent ( String url ) throws IOException { \nif ( debug ) ; \nbaseURL = new URL ( url ) ; \nInputStream in = baseURL . openStream ( ) ; \nInputStreamReader r = new InputStreamReader ( filterTag ( in ) , CDM . UTF8 ) ; \nHTMLEditorKit . ParserCallback callback = new CallerBacker ( ) ; \ntextBuffer = new StringBuffer ( 3000 ) ; \nwantURLS = false ; \nwantText = true ; \nparser . parse ( r , callback , false ) ; \nreturn textBuffer . toString ( ) ; \n} \n} \n"}
{"4379": "public class GridHorizCoordSys { \nprivate void makeLC ( ) { \nproj = new LambertConformal ( gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LOV ) , gds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) ) ; \nLatLonPointImpl startLL = new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ; \nProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( startLL ) ; \nstartx = start . getX ( ) ; \nstarty = start . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) { \nsetDxDy ( startx , starty , proj ) ; \n} \nif ( GridServiceProvider . debugProj ) { \n; \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \n; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \n; \ndouble endx = startx + getNx ( ) * getDxInKm ( ) ; \ndouble endy = starty + getNy ( ) * getDyInKm ( ) ; \n; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"lambert_conformal_conic\" ) ) ; \nif ( gds . getDouble ( GridDefRecord . LATIN1 ) == gds . getDouble ( GridDefRecord . LATIN2 ) ) { \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; \n} \nelse { \ndouble [ ] data = new double [ ] { \ngds . getDouble ( GridDefRecord . LATIN1 ) , gds . getDouble ( GridDefRecord . LATIN2 ) } \n; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Array . factory ( DataType . DOUBLE , new int [ ] { \n2 } \n, data ) ) ) ; \n} \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_CENTRAL_MERIDIAN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LATIN1 ) ) ) ; \n} \n} \n"}
{"4380": "public class GridHorizCoordSys { \nprivate void makePS ( ) { \nString nproj = gds . getParam ( GridDefRecord . NPPROJ ) ; \ndouble latOrigin = ( nproj == null || nproj . equalsIgnoreCase ( \"true\" ) ) ? 90.0 : - 90.0 ; \ndouble scale ; \ndouble lad = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( lad ) ) { \nscale = .933 ; \n} \nelse { \nscale = ( 1.0 + Math . sin ( Math . toRadians ( Math . abs ( lad ) ) ) ) / 2 ; \n} \nproj = new Stereographic ( latOrigin , gds . getDouble ( GridDefRecord . LOV ) , scale ) ; \nProjectionPointImpl start = ( ProjectionPointImpl ) proj . latLonToProj ( new LatLonPointImpl ( gds . getDouble ( GridDefRecord . LA1 ) , gds . getDouble ( GridDefRecord . LO1 ) ) ) ; \nstartx = start . getX ( ) ; \nstarty = start . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) setDxDy ( startx , starty , proj ) ; \nif ( GridServiceProvider . debugProj ) { \nSystem . out . printf ( \"starting proj coord %s lat/lon %s%n\" , start , proj . projToLatLon ( start ) ) ; \n; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"polar_stereographic\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . STRAIGHT_VERTICAL_LONGITUDE_FROM_POLE , gds . getDouble ( GridDefRecord . LOV ) ) ) ; \nattributes . add ( new Attribute ( GridCF . SCALE_FACTOR_AT_PROJECTION_ORIGIN , scale ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , latOrigin ) ) ; \n} \n} \n"}
{"4381": "public class GridHorizCoordSys { \nprivate void makeMercator ( ) { \ndouble Latin = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( Latin ) ) Latin = gds . getDouble ( GridDefRecord . LATIN ) ; \ndouble Lo1 = gds . getDouble ( GridDefRecord . LO1 ) ; \ndouble La1 = gds . getDouble ( GridDefRecord . LA1 ) ; \nproj = new Mercator ( Lo1 , Latin ) ; \nProjectionPoint startP = proj . latLonToProj ( new LatLonPointImpl ( La1 , Lo1 ) ) ; \nstartx = startP . getX ( ) ; \nstarty = startP . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) { \nsetDxDy ( startx , starty , proj ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"mercator\" ) ) ; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Latin ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lo1 ) ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \nif ( Lo2 < Lo1 ) Lo2 += 360 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \n; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \n; \n; \ndouble endx = startx + ( getNx ( ) - 1 ) * getDxInKm ( ) ; \ndouble endy = starty + ( getNy ( ) - 1 ) * getDyInKm ( ) ; \n; \n} \n} \n} \n"}
{"4382": "public class GridHorizCoordSys { \nprivate void makeMSGgeostationary ( ) { \ndouble Lat0 = gds . getDouble ( GridDefRecord . LAP ) ; \ndouble Lon0 = gds . getDouble ( GridDefRecord . LOP ) ; \nint ny = gds . getInt ( GridDefRecord . NY ) ; \nint x_off = gds . getInt ( GridDefRecord . XP ) ; \nint y_off = gds . getInt ( GridDefRecord . YP ) ; \ndouble dx ; \ndouble dy = gds . getDouble ( GridDefRecord . DY ) ; \nif ( dy < 2100 ) { \ndx = 1207 ; \ndy = 1203 ; \n} \nelse { \ndx = 3622 ; \ndy = 3610 ; \n} \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( \"major_axis_earth\" ) ; \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \ndouble nr = gds . getDouble ( GridDefRecord . NR ) * 1e-6 ; \ndouble as = 2 * Math . asin ( 1.0 / nr ) ; \ndouble cfac = dx / as ; \ndouble lfac = dy / as ; \ndouble scale_factor = ( nr - 1 ) * major_axis / 1000 ; \ndouble scale_x = scale_factor ; \ndouble scale_y = - scale_factor ; \nstartx = scale_factor * ( 1 - x_off ) / cfac ; \nstarty = scale_factor * ( y_off - ny ) / lfac ; \nincrx = scale_factor / cfac ; \nincry = scale_factor / lfac ; \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"MSGnavigation\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lon0 ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , Lat0 ) ) ; \nattributes . add ( new Attribute ( \"height_from_earth_center\" , nr * major_axis ) ) ; \nattributes . add ( new Attribute ( \"scale_x\" , scale_x ) ) ; \nattributes . add ( new Attribute ( \"scale_y\" , scale_y ) ) ; \nproj = new MSGnavigation ( Lat0 , Lon0 , major_axis , minor_axis , nr * major_axis , scale_x , scale_y ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) + 360.0 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \n; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \n; \ndouble endx = 1 + getNx ( ) ; \ndouble endy = 1 + getNy ( ) ; \n; \n} \n} \n} \n"}
{"4384": "public class InvCatalogFactory10 { \nprotected InvDatasetImpl readDataset ( InvCatalogImpl catalog , InvDatasetImpl parent , Element dsElem , URI base ) { \nString name = dsElem . getAttributeValue ( \"name\" ) ; \nString alias = dsElem . getAttributeValue ( \"alias\" ) ; \nif ( alias != null ) { \nInvDatasetImpl ds = ( InvDatasetImpl ) catalog . findDatasetByID ( alias ) ; \nif ( ds == null ) { \nfactory . appendErr ( \" ** Parse error: dataset named \" + name + \" has illegal alias = \" + alias + \"\\n\" ) ; \nreturn null ; \n} \nreturn new InvDatasetImplProxy ( name , ds ) ; \n} \nInvDatasetImpl dataset = new InvDatasetImpl ( parent , name ) ; \nreadDatasetInfo ( catalog , dataset , dsElem , base ) ; \nif ( InvCatalogFactory . debugXML ) ; \nreturn dataset ; \n} \n} \n"}
{"4385": "public class InvCatalogFactory10 { \nprotected InvDatasetScan readDatasetScan ( InvCatalogImpl catalog , InvDatasetImpl parent , Element dsElem , URI base ) { \nInvDatasetScan datasetScan ; \nif ( dsElem . getAttributeValue ( \"dirLocation\" ) == null ) { \nif ( dsElem . getAttributeValue ( \"location\" ) == null ) { \nlogger . error ( \"readDatasetScan(): datasetScan has neither a \\\"location\\\" nor a \\\"dirLocation\\\" attribute.\" ) ; \ndatasetScan = null ; \n} \nelse { \nreturn readDatasetScanNew ( catalog , parent , dsElem , base ) ; \n} \n} \nelse { \nString name = dsElem . getAttributeValue ( \"name\" ) ; \nfactory . appendWarning ( \"**Warning: Dataset \" + name + \" using old form of DatasetScan (dirLocation instead of location)\\n\" ) ; \nString path = dsElem . getAttributeValue ( \"path\" ) ; \nString scanDir = expandAliasForPath ( dsElem . getAttributeValue ( \"dirLocation\" ) ) ; \nString filter = dsElem . getAttributeValue ( \"filter\" ) ; \nString addDatasetSizeString = dsElem . getAttributeValue ( \"addDatasetSize\" ) ; \nString addLatest = dsElem . getAttributeValue ( \"addLatest\" ) ; \nString sortOrderIncreasingString = dsElem . getAttributeValue ( \"sortOrderIncreasing\" ) ; \nboolean sortOrderIncreasing = false ; \nif ( sortOrderIncreasingString != null ) if ( sortOrderIncreasingString . equalsIgnoreCase ( \"true\" ) ) sortOrderIncreasing = true ; \nboolean addDatasetSize = true ; \nif ( addDatasetSizeString != null ) if ( addDatasetSizeString . equalsIgnoreCase ( \"false\" ) ) addDatasetSize = false ; \nif ( path != null ) { \nif ( path . charAt ( 0 ) == '/' ) path = path . substring ( 1 ) ; \nint last = path . length ( ) - 1 ; \nif ( path . charAt ( last ) == '/' ) path = path . substring ( 0 , last ) ; \n} \nif ( scanDir != null ) { \nint last = scanDir . length ( ) - 1 ; \nif ( scanDir . charAt ( last ) != '/' ) scanDir = scanDir + '/' ; \n} \nElement atcElem = dsElem . getChild ( \"addTimeCoverage\" , defNS ) ; \nString dsNameMatchPattern = null ; \nString startTimeSubstitutionPattern = null ; \nString duration = null ; \nif ( atcElem != null ) { \ndsNameMatchPattern = atcElem . getAttributeValue ( \"datasetNameMatchPattern\" ) ; \nstartTimeSubstitutionPattern = atcElem . getAttributeValue ( \"startTimeSubstitutionPattern\" ) ; \nduration = atcElem . getAttributeValue ( \"duration\" ) ; \n} \ntry { \ndatasetScan = new InvDatasetScan ( catalog , parent , name , path , scanDir , filter , addDatasetSize , addLatest , sortOrderIncreasing , dsNameMatchPattern , startTimeSubstitutionPattern , duration ) ; \nreadDatasetInfo ( catalog , datasetScan , dsElem , base ) ; \nif ( InvCatalogFactory . debugXML ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"Reading DatasetScan\" , e ) ; \ndatasetScan = null ; \n} \n} \nreturn datasetScan ; \n} \n} \n"}
{"4386": "public class InvCatalogFactory10 { \npublic Object readMetadataContentFromURL ( InvDataset dataset , java . net . URI uri ) throws java . io . IOException { \nElement elem = readContentFromURL ( uri ) ; \nObject contentObject = readMetadataContent ( dataset , elem ) ; \nif ( debugMetadataRead ) ; \nreturn contentObject ; \n} \n} \n"}
{"4424": "public class CoordSysBuilder { \n@ Override public void buildCoordinateSystems ( NetcdfDataset ncDataset ) { \nparseInfo . format ( \"Parsing with Convention = %s%n\" , conventionName ) ; \naddVariables ( ncDataset , ncDataset . getVariables ( ) , varList ) ; \nfindCoordinateAxes ( ncDataset ) ; \nfindCoordinateSystems ( ncDataset ) ; \nfindCoordinateTransforms ( ncDataset ) ; \nmakeCoordinateAxes ( ncDataset ) ; \nmakeCoordinateSystems ( ncDataset ) ; \nassignCoordinateSystemsExplicit ( ncDataset ) ; \nmakeCoordinateSystemsImplicit ( ncDataset ) ; \nif ( useMaximalCoordSys ) makeCoordinateSystemsMaximal ( ncDataset ) ; \nmakeCoordinateTransforms ( ncDataset ) ; \nassignCoordinateTransforms ( ncDataset ) ; \nif ( debug ) ; \n} \n} \n"}
{"4433": "public class InvCatalogImpl { \nprivate boolean mark ( DatasetFilter filter , InvDatasetImpl ds ) { \nif ( ds instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) ds ; \nif ( ! catRef . isRead ( ) ) return false ; \n} \nboolean allMarked = true ; \nfor ( InvDataset nested : ds . getDatasets ( ) ) { \nallMarked &= mark ( filter , ( InvDatasetImpl ) nested ) ; \n} \nif ( ! allMarked ) return false ; \nif ( filter . accept ( ds ) >= 0 ) return false ; \nds . setMark ( true ) ; \nif ( debugFilter ) ; \nreturn true ; \n} \n} \n"}
{"4434": "public class InvCatalogImpl { \nprivate void delete ( InvDatasetImpl ds ) { \nif ( ds instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) ds ; \nif ( ! catRef . isRead ( ) ) return ; \n} \nIterator iter = ds . getDatasets ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nInvDatasetImpl nested = ( InvDatasetImpl ) iter . next ( ) ; \nif ( nested . getMark ( ) ) { \niter . remove ( ) ; \nif ( debugFilter ) ; \n} \nelse delete ( nested ) ; \n} \n} \n} \n"}
{"4473": "public class KMPMatch { \npublic int indexOf ( byte [ ] data , int start , int max ) { \nint j = 0 ; \nif ( data . length == 0 ) return - 1 ; \nif ( start + max > data . length ) ; \nfor ( int i = start ; \ni < start + max ; \ni ++ ) { \nwhile ( j > 0 && match [ j ] != data [ i ] ) j = failure [ j - 1 ] ; \nif ( match [ j ] == data [ i ] ) j ++ ; \nif ( j == match . length ) return i - match . length + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"4484": "public class NexradStationDB { \nprivate static void readStationTable ( ) throws IOException { \nstationTableHash = new HashMap < String , Station > ( ) ; \nClassLoader cl = Level2VolumeScan . class . getClassLoader ( ) ; \nInputStream is = cl . getResourceAsStream ( \"resources/nj22/tables/nexrad.tbl\" ) ; \nList < TableParser . Record > recs = TableParser . readTable ( is , \"3,15,46, 54,60d,67d,73d\" , 50000 ) ; \nfor ( TableParser . Record record : recs ) { \nStation s = new Station ( ) ; \ns . id = \"K\" + record . get ( 0 ) ; \ns . name = record . get ( 2 ) + \" \" + record . get ( 3 ) ; \ns . lat = ( Double ) record . get ( 4 ) * .01 ; \ns . lon = ( Double ) record . get ( 5 ) * .01 ; \ns . elev = ( Double ) record . get ( 6 ) ; \nstationTableHash . put ( s . id , s ) ; \nif ( showStations ) ; \n} \n} \n} \n"}
{"4490": "public class ScaledPanel { \nprivate AffineTransform calcTransform ( Rectangle2D screen , Bounds world ) { \ndouble xs = screen . getWidth ( ) / ( world . getRight ( ) - world . getLeft ( ) ) ; \ndouble ys = screen . getHeight ( ) / ( world . getLower ( ) - world . getUpper ( ) ) ; \nAffineTransform cat = new AffineTransform ( ) ; \ncat . setToScale ( xs , ys ) ; \ncat . translate ( - world . getLeft ( ) , - world . getUpper ( ) ) ; \nif ( debugTransform ) { \n; \n; \n; \n; \n; \nPoint2D src = new Point2D . Double ( world . getLeft ( ) , world . getUpper ( ) ) ; \nPoint2D dst = new Point2D . Double ( 0.0 , 0.0 ) ; \n; \n; \nsrc = new Point2D . Double ( world . getRight ( ) , world . getLower ( ) ) ; \n; \n; \n} \nreturn cat ; \n} \n} \n"}
{"4496": "public class CatGenConfigMetadataFactory { \nprivate Object readMetadataContentFromURL ( InvDataset dataset , String urlString ) throws java . net . MalformedURLException , java . io . IOException { \nDocument doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( true ) ; \ndoc = builder . build ( urlString ) ; \n} \ncatch ( JDOMException e ) { \nlog . error ( \"CatGenConfigMetadataFactory parsing error= \\n\" + e . getMessage ( ) ) ; \nthrow new java . io . IOException ( \"CatGenConfigMetadataFactory parsing error= \" + e . getMessage ( ) ) ; \n} \nif ( showParsedXML ) { \nXMLOutputter xmlOut = new XMLOutputter ( Format . getPrettyFormat ( ) ) ; \n; \n} \nreturn ( readMetadataContentJdom ( dataset , doc . getRootElement ( ) ) ) ; \n} \n} \n"}
{"4510": "public class Debug { \nstatic public boolean isSet ( String flagName ) { \nif ( store == null ) return false ; \nNamePart np = partit ( flagName ) ; \nif ( debug ) { \ntry { \nif ( ( np . storeName . length ( ) > 0 ) && ! store . nodeExists ( np . storeName ) ) ; \nelse if ( null == store . node ( np . storeName ) . get ( np . keyName , null ) ) ; \n} \ncatch ( BackingStoreException e ) { \n} \n} \nboolean value = store . node ( np . storeName ) . getBoolean ( np . keyName , false ) ; \nstore . node ( np . storeName ) . putBoolean ( np . keyName , value ) ; \nreturn value ; \n} \n} \n"}
{"4511": "public class Debug { \nstatic public void constructMenu ( JMenu topMenu ) { \nif ( debug ) ; \nif ( topMenu . getItemCount ( ) > 0 ) topMenu . removeAll ( ) ; \ntry { \naddToMenu ( topMenu , store ) ; \n} \ncatch ( BackingStoreException e ) { \n} \ntopMenu . revalidate ( ) ; \n} \n} \n"}
{"4512": "public class Debug { \nstatic private void addToMenu ( JMenu menu , Preferences prefs ) throws BackingStoreException { \nif ( debug ) ; \nString [ ] keys = prefs . keys ( ) ; \nfor ( String key : keys ) { \nboolean bval = prefs . getBoolean ( key , false ) ; \nString fullname = prefs . absolutePath ( ) + \"/\" + key ; \nmenu . add ( new DebugMenuItem ( fullname , key , bval ) ) ; \nif ( debug ) ; \n} \nString [ ] kidName = prefs . childrenNames ( ) ; \nfor ( String aKidName : kidName ) { \nPreferences pkid = prefs . node ( aKidName ) ; \nJMenu subMenu = new JMenu ( pkid . name ( ) ) ; \nmenu . add ( subMenu ) ; \naddToMenu ( subMenu , pkid ) ; \n} \n} \n} \n"}
{"4521": "public class Field { \nstatic private void showFormatInfo ( JFormattedTextField tf ) { \nJFormattedTextField . AbstractFormatter ff = tf . getFormatter ( ) ; \n; \nif ( ff instanceof NumberFormatter ) { \nNumberFormatter nf = ( NumberFormatter ) ff ; \nFormat f = nf . getFormat ( ) ; \n; \nif ( f instanceof NumberFormat ) { \nNumberFormat nfat = ( NumberFormat ) f ; \n; \n; \n; \n; \n} \nif ( f instanceof DecimalFormat ) { \nDecimalFormat df = ( DecimalFormat ) f ; \n; \n} \n} \n} \n} \n"}
{"4527": "public class DODSNetcdfFile { \nDimension getNetcdfStrlenDim ( DODSVariable v ) { \nAttributeTable table = das . getAttributeTableN ( v . getFullName ( ) ) ; \nif ( table == null ) return null ; \nopendap . dap . Attribute dodsAtt = table . getAttribute ( \"DODS\" ) ; \nif ( dodsAtt == null ) return null ; \nAttributeTable dodsTable = dodsAtt . getContainerN ( ) ; \nif ( dodsTable == null ) return null ; \nopendap . dap . Attribute att = dodsTable . getAttribute ( \"strlen\" ) ; \nif ( att == null ) return null ; \nString strlen = att . getValueAtN ( 0 ) ; \nopendap . dap . Attribute att2 = dodsTable . getAttribute ( \"dimName\" ) ; \nString dimName = ( att2 == null ) ? null : att2 . getValueAtN ( 0 ) ; \nif ( debugCharArray ) ; \nint dimLength ; \ntry { \ndimLength = Integer . parseInt ( strlen ) ; \n} \ncatch ( NumberFormatException e ) { \nlogger . warn ( \"DODSNetcdfFile \" + location + \" var = \" + v . getFullName ( ) + \" error on strlen attribute = \" + strlen ) ; \nreturn null ; \n} \nif ( dimLength <= 0 ) return null ; \nreturn new Dimension ( dimName , dimLength , dimName != null ) ; \n} \n} \n"}
{"4531": "public class DODSNetcdfFile { \nDataDDS readDataDDSfromServer ( String CE ) throws IOException , opendap . dap . DAP2Exception { \nif ( debugServerCall ) ; \nlong start = 0 ; \nif ( debugTime ) start = System . currentTimeMillis ( ) ; \nif ( ! CE . startsWith ( \"?\" ) ) CE = \"?\" + CE ; \nDataDDS data ; \nsynchronized ( this ) { \ndata = dodsConnection . getData ( CE , null ) ; \n} \nif ( debugTime ) ; \nif ( debugDataResult ) { \n; \ndata . print ( System . out ) ; \n} \nreturn data ; \n} \n} \n"}
{"4532": "public class Resource { \npublic static ImageIcon getIcon ( String fullIconName , boolean errMsg ) { \nImageIcon icon = null ; \njava . net . URL iconR = cl . getResource ( fullIconName ) ; \nif ( debugIcon ) { \n; \n; \n} \nif ( iconR != null ) icon = new ImageIcon ( iconR ) ; \nif ( ( icon == null ) && errMsg ) ; \nelse if ( debugIcon ) ; \nreturn icon ; \n} \n} \n"}
{"4533": "public class Resource { \npublic static Image getImage ( String fullImageName ) { \nImage image = null ; \njava . net . URL url = cl . getResource ( fullImageName ) ; \nif ( url != null ) image = Toolkit . getDefaultToolkit ( ) . createImage ( url ) ; \nif ( image == null ) ; \nreturn image ; \n} \n} \n"}
{"4534": "public class Resource { \npublic static Cursor makeCursor ( String name ) { \nImage image = getImage ( name ) ; \nif ( null == image ) return null ; \nCursor cursor ; \ntry { \nToolkit tk = Toolkit . getDefaultToolkit ( ) ; \nif ( debug ) { \nImageObserver obs = new ImageObserver ( ) { \npublic boolean imageUpdate ( Image image , int flags , int x , int y , int width , int height ) { \nreturn true ; \n} \n} \n; \n; \n; \n} \ncursor = tk . createCustomCursor ( image , new Point ( 17 , 17 ) , name ) ; \n} \ncatch ( IndexOutOfBoundsException e ) { \n; \nreturn null ; \n} \nreturn cursor ; \n} \n} \n"}
{"4565": "public class CEEvaluator { \npublic boolean evalClauses ( Object specialO ) throws NoSuchVariableException , DAP2ServerSideException , IOException { \nboolean result = true ; \nEnumeration ec = getClauses ( ) ; \nwhile ( ec . hasMoreElements ( ) && result == true ) { \nObject o = ec . nextElement ( ) ; \nif ( _Debug ) { \n; \n} \nresult = ( ( TopLevelClause ) o ) . evaluate ( ) ; \n} \nreturn ( result ) ; \n} \n} \n"}
{"4574": "public class LayoutM { \npublic void addLayoutComponent ( Component comp , Object constraint ) { \nif ( debug ) ; \nif ( ! ( constraint instanceof Constraint ) ) throw new IllegalArgumentException ( \"MySpringLayout must be Constraint\" ) ; \nconstraintMap . put ( comp , constraint ) ; \nglobalBounds = null ; \n} \n} \n"}
{"4575": "public class LayoutM { \npublic void invalidateLayout ( Container target ) { \nif ( debug ) ; \nglobalBounds = null ; \n} \n} \n"}
{"4576": "public class LayoutM { \npublic void removeLayoutComponent ( Component comp ) { \nif ( debug ) ; \nconstraintMap . remove ( comp ) ; \nglobalBounds = null ; \n} \n} \n"}
{"4577": "public class LayoutM { \npublic Dimension minimumLayoutSize ( Container parent ) { \nif ( debug ) ; \nif ( globalBounds == null ) layoutContainer ( parent ) ; \nreturn globalBounds . getSize ( ) ; \n} \n} \n"}
{"4578": "public class LayoutM { \npublic void layoutContainer ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nif ( debug ) ; \nint n = target . getComponentCount ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nComponent comp = target . getComponent ( i ) ; \nif ( comp instanceof Container ) { \nContainer c = ( Container ) comp ; \nLayoutManager m = c . getLayout ( ) ; \nif ( m instanceof LayoutM ) m . layoutContainer ( c ) ; \n} \n} \nreset ( target ) ; \nglobalBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; \nwhile ( ! layoutPass ( target ) ) target . setPreferredSize ( globalBounds . getSize ( ) ) ; \n} \n} \n} \n"}
{"4589": "public class CFPointObWriter { \npublic static boolean rewritePointFeatureDataset ( String fileIn , String fileOut , boolean inMemory ) throws IOException { \n; \nlong start = System . currentTimeMillis ( ) ; \nNetcdfFile ncfile = inMemory ? NetcdfFile . openInMemory ( fileIn ) : NetcdfFile . open ( fileIn ) ; \nNetcdfDataset ncd = new NetcdfDataset ( ncfile ) ; \nFormatter errlog = new Formatter ( ) ; \nFeatureDataset fd = FeatureDatasetFactoryManager . wrap ( FeatureType . ANY_POINT , ncd , null , errlog ) ; \nif ( fd == null ) return false ; \nif ( fd instanceof FeatureDatasetPoint ) { \nwritePointFeatureCollection ( ( FeatureDatasetPoint ) fd , fileOut ) ; \nfd . close ( ) ; \nlong took = System . currentTimeMillis ( ) - start ; \n; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4634": "public class DodsV { \nvoid parseDAS ( DAS das ) throws IOException { \nEnumeration tableNames = das . getNames ( ) ; \nwhile ( tableNames . hasMoreElements ( ) ) { \nString tableName = ( String ) tableNames . nextElement ( ) ; \nAttributeTable attTable = das . getAttributeTableN ( tableName ) ; \nif ( tableName . equals ( \"NC_GLOBAL\" ) || tableName . equals ( \"HDF_GLOBAL\" ) ) { \naddAttributeTable ( this , attTable , tableName , true ) ; \n} \nelse if ( tableName . equals ( \"DODS_EXTRA\" ) || tableName . equals ( \"EXTRA_DIMENSION\" ) ) { \ncontinue ; \n} \nelse { \nDodsV dodsV = findDodsV ( tableName , false ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \ndodsV = findTableDotDelimited ( tableName ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \nif ( debugAttributes ) ; \naddAttributeTable ( this , attTable , tableName , false ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4647": "public class Variable { \nprotected Array _read ( ) throws IOException { \nif ( cache . data != null ) { \nif ( debugCaching ) ; \nreturn cache . data . copy ( ) ; \n} \nArray data = proxyReader . reallyRead ( this , null ) ; \nif ( isCaching ( ) ) { \nsetCachedData ( data ) ; \nif ( debugCaching ) ; \nreturn cache . data . copy ( ) ; \n} \nelse { \nreturn data ; \n} \n} \n} \n"}
{"4648": "public class Variable { \nprotected Array _read ( Section section ) throws IOException , InvalidRangeException { \nif ( ( null == section ) || section . computeSize ( ) == getSize ( ) ) return _read ( ) ; \nif ( isCaching ( ) ) { \nif ( cache . data == null ) { \nsetCachedData ( _read ( ) ) ; \nif ( debugCaching ) ; \n} \nif ( debugCaching ) ; \nreturn cache . data . sectionNoReduce ( section . getRanges ( ) ) . copy ( ) ; \n} \nreturn proxyReader . reallyRead ( this , section , null ) ; \n} \n} \n"}
{"4664": "public class CDMDSP { \npublic void buildDMR ( ) throws DapException { \nif ( getDMR ( ) != null ) return ; \ntry { \nif ( DUMPCDL ) { \n; \nthis . ncdfile . writeCDL ( System . out , false ) ; \nSystem . out . flush ( ) ; \n} \nString name = this . ncdfile . getLocation ( ) ; \nname = DapUtil . canonicalpath ( name ) ; \nint index = name . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) name = name . substring ( index + 1 , name . length ( ) ) ; \nsetDMR ( ( DapDataset ) dmrfactory . newDataset ( name ) . annotate ( NetcdfDataset . class , this . ncdfile ) ) ; \nrecordNode ( this . ncdfile . getRootGroup ( ) , getDMR ( ) ) ; \ngetDMR ( ) . setBase ( DapUtil . canonicalpath ( this . ncdfile . getLocation ( ) ) ) ; \nfillgroup ( getDMR ( ) , this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . sort ( ) ; \nprocessmappedvariables ( this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . finish ( ) ; \n} \ncatch ( DapException e ) { \nsetDMR ( null ) ; \nthrow new DapException ( e ) ; \n} \n} \n} \n"}
{"4672": "public class Navigation { \npublic AffineTransform getTransform ( ) { \nat . setTransform ( pix_per_world , 0.0 , 0.0 , - pix_per_world , pix_x0 , pix_y0 ) ; \nif ( debug ) { \n; \n; \n} \nreturn at ; \n} \n} \n"}
{"4677": "public class Navigation { \npublic void zoom ( double startx , double starty , double width , double height ) { \nif ( debugZoom ) ; \nif ( ( width < 5 ) || ( height < 5 ) ) return ; \nzoom . push ( ) ; \npix_x0 -= startx + width / 2 - pwidth / 2 ; \npix_y0 -= starty + height / 2 - pheight / 2 ; \nzoom ( pwidth / width ) ; \n} \n} \n"}
{"4678": "public class Navigation { \nprivate void recalcFromBoundingBox ( ) { \nif ( debugRecalc ) { \n; \n; \n} \ndouble pixx_per_wx = ( bb . getWidth ( ) == 0.0 ) ? 1 : pwidth / bb . getWidth ( ) ; \ndouble pixy_per_wy = ( bb . getHeight ( ) == 0.0 ) ? 1 : pheight / bb . getHeight ( ) ; \npix_per_world = Math . min ( pixx_per_wx , pixy_per_wy ) ; \ndouble wx0 = bb . getX ( ) + bb . getWidth ( ) / 2 ; \ndouble wy0 = bb . getY ( ) + bb . getHeight ( ) / 2 ; \npix_x0 = pwidth / 2 - pix_per_world * wx0 ; \npix_y0 = pheight / 2 + pix_per_world * wy0 ; \nif ( debugRecalc ) { \n; \n; \n} \n} \n} \n"}
{"4693": "public class AccessLogParser { \npublic static void main ( String [ ] args ) throws IOException { \nAccessLogParser p = new AccessLogParser ( ) ; \nString line = \"24.18.236.132 - - [04/Feb/2011:17:49:03 -0700] \\\"GET /thredds/fileServer//nexrad/level3/N0R/YUX/20110205/Level3_YUX_N0R_20110205_0011.nids \\\" 200 10409 \\\"-\\\" \\\"-\\\" 17\" ; \nMatcher m = regPattern . matcher ( line ) ; \nSystem . out . printf ( \"%s %s%n\" , m . matches ( ) , m ) ; \nfor ( int i = 0 ; \ni < m . groupCount ( ) ; \ni ++ ) { \n; \n} \nLogReader . Log log = p . parseLog ( line ) ; \nSystem . out . printf ( \"%s%n\" , log ) ; \n} \n} \n"}
{"4732": "public class GridCoordSys { \nvoid addLevels ( List < GridRecord > records ) { \nfor ( GridRecord record : records ) { \nDouble d = new Double ( record . getLevel1 ( ) ) ; \nif ( ! levels . contains ( d ) ) { \nlevels . add ( d ) ; \n} \nif ( dontUseVertical && ( levels . size ( ) > 1 ) ) { \nif ( GridServiceProvider . debugVert ) { \n; \n} \n} \n} \nCollections . sort ( levels ) ; \nif ( positive . equals ( \"down\" ) ) { \nCollections . reverse ( levels ) ; \n} \n} \n} \n"}
{"4744": "public class Bearing { \npublic static void main ( String [ ] args ) { \nLatLonPointImpl pt1 = new LatLonPointImpl ( 40 , - 105 ) ; \nLatLonPointImpl pt2 = new LatLonPointImpl ( 37.4 , - 118.4 ) ; \nBearing b = calculateBearing ( pt1 , pt2 , null ) ; \n; \nLatLonPointImpl pt3 = new LatLonPointImpl ( ) ; \npt3 = findPoint ( pt1 , b . getAngle ( ) , b . getDistance ( ) , pt3 ) ; \n; \npt3 = findPoint ( pt2 , b . getBackAzimuth ( ) , b . getDistance ( ) , pt3 ) ; \n; \n} \n} \n"}
{"4760": "public class DbaseFile { \nprivate int loadHeader ( ) { \nif ( headerLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nBufferedInputStream bs = new BufferedInputStream ( s ) ; \nds = new DataInputStream ( bs ) ; \nHeader = new byte [ 32 ] ; \nds . readFully ( Header ) ; \nif ( Header [ 0 ] == '<' ) { \nclose ( ds ) ; \nreturn - 1 ; \n} \nfiletype = Header [ 0 ] ; \nnrecords = Swap . swapInt ( Header , 4 ) ; \nnbytesheader = Swap . swapShort ( Header , 8 ) ; \nnfields = ( nbytesheader / 32 ) - 1 ; \nif ( nfields < 1 ) { \n; \n; \nreturn - 1 ; \n} \nFieldDesc = new DbaseFieldDesc [ nfields ] ; \ndata = new DbaseData [ nfields ] ; \nfor ( int i = 0 ; \ni < nfields ; \ni ++ ) { \nFieldDesc [ i ] = new DbaseFieldDesc ( ds , filetype ) ; \ndata [ i ] = new DbaseData ( FieldDesc [ i ] , nrecords ) ; \n} \nds . readByte ( ) ; \nheaderLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"4768": "public class DbaseFile { \npublic static void main ( String [ ] args ) { \nif ( args . length < 1 ) { \n; \nSystem . exit ( - 1 ) ; \n} \nfor ( String s : args ) { \n; \ntry { \nDbaseFile dbf = new DbaseFile ( s ) ; \nif ( dbf . loadHeader ( ) != 0 ) { \n; \nSystem . exit ( - 1 ) ; \n} \nString [ ] fieldNames = dbf . getFieldNames ( ) ; \n; \nint nf = dbf . getNumFields ( ) ; \nDbaseData [ ] dbd = new DbaseData [ nf ] ; \nfor ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \ndbd [ field ] = dbf . getField ( field ) ; \nswitch ( dbd [ field ] . getType ( ) ) { \ncase DbaseData . TYPE_BOOLEAN : ; \nbreak ; \ncase DbaseData . TYPE_CHAR : ; \nbreak ; \ncase DbaseData . TYPE_NUMERIC : ; \nbreak ; \n} \n; \nif ( field < nf - 1 ) ; \n} \n; \nif ( dbf . loadData ( ) != 0 ) { \n; \nSystem . exit ( - 1 ) ; \n} \nfor ( int rec = 0 ; \nrec < dbf . getNumRecords ( ) ; \nrec ++ ) { \nfor ( int field = 0 ; \nfield < nf ; \nfield ++ ) { \n; \nif ( field < nf - 1 ) ; \nelse ; \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4840": "public class StationRegionDateChooser { \nprotected void redraw ( ) { \nlong tstart = System . currentTimeMillis ( ) ; \njava . awt . Graphics2D gNP = np . getBufferedImageGraphics ( ) ; \nif ( gNP == null ) return ; \ngNP . setBackground ( np . getBackgroundColor ( ) ) ; \njava . awt . Rectangle r = gNP . getClipBounds ( ) ; \ngNP . clearRect ( r . x , r . y , r . width , r . height ) ; \nif ( regionSelect && geoSelectionMode ) { \nif ( geoSelection != null ) drawBB ( gNP , geoSelection , Color . cyan ) ; \nif ( geoBounds != null ) drawBB ( gNP , geoBounds , null ) ; \nif ( geoSelection != null ) { \nNavigation navigate = np . getNavigation ( ) ; \ndouble handleSize = RubberbandRectangleHandles . handleSizePixels / navigate . getPixPerWorld ( ) ; \nRectangle2D rect = new Rectangle2D . Double ( geoSelection . getX ( ) , geoSelection . getY ( ) , geoSelection . getWidth ( ) , geoSelection . getHeight ( ) ) ; \nRubberbandRectangleHandles . drawHandledRect ( gNP , rect , handleSize ) ; \nif ( debug ) ; \n} \n} \nfor ( int i = 0 ; \ni < renderers . size ( ) ; \ni ++ ) { \nucar . nc2 . ui . util . Renderer rend = ( Renderer ) renderers . get ( i ) ; \nrend . draw ( gNP , atI ) ; \n} \ngNP . dispose ( ) ; \nif ( debug ) { \nlong tend = System . currentTimeMillis ( ) ; \n; \n} \nnp . repaint ( ) ; \n} \n} \n"}
{"4882": "public class ImageDatasetFactory { \npublic BufferedImage getNextImage ( boolean forward ) { \nif ( grid != null ) { \nif ( forward ) { \nthis . time ++ ; \nif ( this . time >= this . ntimes ) this . time = 0 ; \n} \nelse { \nthis . time -- ; \nif ( this . time < 0 ) this . time = this . ntimes - 1 ; \n} \nArray data ; \ntry { \ndata = grid . readDataSlice ( this . time , 0 , - 1 , - 1 ) ; \nreturn ImageArrayAdapter . makeGrayscaleImage ( data , grid ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \nif ( currentFile == null ) return null ; \nif ( currentDir == null ) { \ncurrentDirFileNo = 0 ; \ncurrentDir = currentFile . getParentFile ( ) ; \ncurrentDirFileList = new ArrayList < > ( ) ; \naddToList ( currentDir , currentDirFileList ) ; \nfor ( int i = 0 ; \ni < currentDirFileList . size ( ) ; \ni ++ ) { \nFile file = currentDirFileList . get ( i ) ; \nif ( file . equals ( currentFile ) ) currentDirFileNo = i ; \n} \n} \nif ( forward ) { \ncurrentDirFileNo ++ ; \nif ( currentDirFileNo >= currentDirFileList . size ( ) ) currentDirFileNo = 0 ; \n} \nelse { \ncurrentDirFileNo -- ; \nif ( currentDirFileNo < 0 ) currentDirFileNo = currentDirFileList . size ( ) - 1 ; \n} \nFile nextFile = currentDirFileList . get ( currentDirFileNo ) ; \ntry { \n; \nreturn javax . imageio . ImageIO . read ( nextFile ) ; \n} \ncatch ( IOException e ) { \n; \nreturn getNextImage ( forward ) ; \n} \n} \n} \n"}
{"4885": "public class SpatialGrid { \npublic void setGrid ( Rectangle2D bbox , double width , double height ) { \noffsetX = bbox . getX ( ) ; \noffsetY = bbox . getY ( ) ; \ncountX = Math . min ( nx , ( int ) ( bbox . getWidth ( ) / ( scaleOverlap * width ) ) ) ; \ncountY = Math . min ( ny , ( int ) ( bbox . getHeight ( ) / ( scaleOverlap * height ) ) ) ; \ngridWidth = bbox . getWidth ( ) / countX ; \ngridHeight = bbox . getHeight ( ) / countY ; \nif ( debug ) ; \n} \n} \n"}
{"4888": "public class SpatialGrid { \npublic boolean markIfClear ( Rectangle2D rect , Object o ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( debugMark ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return false ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return false ; \nif ( null != findIntersection ( rect ) ) return false ; \ngwant . used = true ; \ngwant . objectBB = rect ; \ngwant . o = o ; \nreturn true ; \n} \n} \n"}
{"4891": "public class SpatialGrid { \npublic Object findClosest ( Point2D pt ) { \nObject o = null ; \nint indexX = ( int ) ( ( pt . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( pt . getY ( ) - offsetY ) / gridHeight ) ; \nif ( debugClosest ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return gwant . o ; \nfor ( int p = 1 ; \np < Math . max ( countX - 1 , countY - 1 ) ; \np ++ ) if ( null != ( o = findClosestAlongPerimeter ( pt , indexX , indexY , p ) ) ) return o ; \nreturn null ; \n} \n} \n"}
{"4965": "public class FileWriter2 { \npublic NetcdfFile write ( CancelTask cancel ) throws IOException { \ntry { \nif ( version . isExtendedModel ( ) ) addGroupExtended ( null , fileIn . getRootGroup ( ) ) ; \nelse addGroupClassic ( ) ; \nif ( cancel != null && cancel . isCancel ( ) ) return null ; \nwriter . create ( ) ; \nif ( cancel != null && cancel . isCancel ( ) ) return null ; \ndouble total = copyVarData ( varList , null , cancel ) ; \nif ( cancel != null && cancel . isCancel ( ) ) return null ; \nwriter . flush ( ) ; \nif ( debug ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \nwriter . abort ( ) ; \nthrow ioe ; \n} \nreturn writer . getNetcdfFile ( ) ; \n} \n} \n"}
{"5084": "public class GisFeatureRenderer { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nif ( shapeList != null ) return shapeList . iterator ( ) ; \nif ( Debug . isSet ( \"projection/LatLonShift\" ) ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nList featList = getFeatures ( ) ; \nshapeList = new ArrayList ( featList . size ( ) ) ; \nIterator iter = featList . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) iter . next ( ) ; \nShape shape ; \nif ( dataProject == null ) shape = feature . getShape ( ) ; \nelse if ( dataProject . isLatLon ( ) ) { \nshape = feature . getProjectedShape ( displayProject ) ; \n} \nelse if ( dataProject == displayProject ) { \nshape = feature . getShape ( ) ; \n} \nelse { \nshape = feature . getProjectedShape ( dataProject , displayProject ) ; \n} \nshapeList . add ( shape ) ; \n} \nreturn shapeList . iterator ( ) ; \n} \n} \n"}
{"5086": "public class BufrSplitter { \nprivate boolean readBuffer ( InputStream is , byte [ ] dest , int start , int want ) throws IOException { \nint done = 0 ; \nwhile ( done < want ) { \nint got = is . read ( dest , start + done , want - done ) ; \nif ( got < 0 ) return false ; \ndone += got ; \n} \nif ( showRead ) ; \nbytesRead += done ; \nreturn true ; \n} \n} \n"}
{"5098": "public class NavigatedPanel { \nvoid fireMapAreaEvent ( ) { \nif ( debugZoom ) ; \nif ( project . isLatLon ( ) ) { \nLatLonProjection llproj = ( LatLonProjection ) project ; \nProjectionRect box = getMapArea ( ) ; \ndouble center = llproj . getCenterLon ( ) ; \ndouble lonBeg = LatLonPointImpl . lonNormal ( box . getMinX ( ) , center ) ; \ndouble lonEnd = lonBeg + box . getMaxX ( ) - box . getMinX ( ) ; \nboolean showShift = Debug . isSet ( \"projection/LatLonShift\" ) || debugNewProjection ; \nif ( showShift ) ; \nif ( ( lonBeg < center - 180 ) || ( lonEnd > center + 180 ) ) { \ndouble wx0 = box . getX ( ) + box . getWidth ( ) / 2 ; \nllproj . setCenterLon ( wx0 ) ; \ndouble newWx0 = llproj . getCenterLon ( ) ; \nsetWorldCenterX ( newWx0 ) ; \nif ( showShift ) ; \nlmProject . sendEvent ( new NewProjectionEvent ( this , llproj ) ) ; \nreturn ; \n} \n} \nlmMapArea . sendEvent ( new NewMapAreaEvent ( this , getMapArea ( ) ) ) ; \n} \n} \n"}
{"5099": "public class NavigatedPanel { \npublic void setMapArea ( ProjectionRect ma ) { \nif ( debugBB ) ; \nnavigate . setMapArea ( ma ) ; \n} \n} \n"}
{"5100": "public class NavigatedPanel { \npublic void setMapArea ( LatLonRect llbb ) { \nif ( debugBB ) ; \nnavigate . setMapArea ( project . latLonToProjBB ( llbb ) ) ; \n} \n} \n"}
{"5102": "public class NavigatedPanel { \npublic void setProjectionImpl ( ProjectionImpl p ) { \nif ( geoSelection != null ) { \nLatLonRect geoLL = project . projToLatLonBB ( geoSelection ) ; \nsetGeoSelection ( p . latLonToProjBB ( geoLL ) ) ; \n} \nproject = p ; \nnavigate . setMapArea ( project . getDefaultMapArea ( ) ) ; \nif ( Debug . isSet ( \"projection/set\" ) || debugNewProjection ) ; \nif ( hasReference ) { \nrefWorld . setLocation ( project . latLonToProj ( refLatLon ) ) ; \n} \n} \n} \n"}
{"5104": "public class NavigatedPanel { \nprivate void redrawLater ( int delay ) { \nboolean already = ( redrawTimer != null ) && ( redrawTimer . isRunning ( ) ) ; \nif ( debugThread ) ; \nif ( already ) return ; \nif ( redrawTimer == null ) { \nredrawTimer = new javax . swing . Timer ( 0 , new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent e ) { \ndrawG ( ) ; \nredrawTimer . stop ( ) ; \n} \n} \n) ; \n} \nredrawTimer . setDelay ( delay ) ; \nredrawTimer . start ( ) ; \n} \n} \n"}
{"5105": "public class NavigatedPanel { \nprivate void newScreenSize ( Rectangle b ) { \nboolean sameSize = ( b . width == myBounds . width ) && ( b . height == myBounds . height ) ; \nif ( debugBounds ) ; \nif ( sameSize && ( b . x == myBounds . x ) && ( b . y == myBounds . y ) ) return ; \nmyBounds . setBounds ( b ) ; \nif ( sameSize ) return ; \nif ( debugBounds ) ; \nif ( ( b . width > 0 ) && ( b . height > 0 ) ) { \nbImage = new BufferedImage ( b . width , b . height , BufferedImage . TYPE_INT_RGB ) ; \n} \nelse { \nbImage = null ; \n} \nnavigate . setScreenSize ( b . width , b . height ) ; \n} \n} \n"}
{"5167": "public class LuceneIndexer { \npublic static void main1 ( String [ ] args ) { \nif ( INDEX_DIR . exists ( ) ) { \n; \nSystem . exit ( 1 ) ; \n} \nLuceneIndexer indexer = new LuceneIndexer ( ) ; \nDate start = new Date ( ) ; \ntry { \nIndexWriter writer = new IndexWriter ( INDEX_DIR , new StandardAnalyzer ( ) , true ) ; \n; \nindexer . indexDocs ( writer , DOC_DIR ) ; \n; \nwriter . optimize ( ) ; \nwriter . close ( ) ; \nDate end = new Date ( ) ; \n; \n} \ncatch ( IOException e ) { \n; \n} \n} \n} \n"}
{"5192": "public class CatalogTreeView { \npublic void setCatalog ( Catalog catalog ) { \nif ( catalog == null ) return ; \nString catalogName = catalog . getBaseURI ( ) . toString ( ) ; \nthis . catalog = catalog ; \nsetCatalogURL ( catalogName ) ; \nmodel = new InvCatalogTreeModel ( catalog ) ; \ntree . setModel ( model ) ; \nif ( debugTree ) { \n; \nshowNode ( tree . getModel ( ) , tree . getModel ( ) . getRoot ( ) ) ; \n; \n} \nint pos = catalogName . indexOf ( '#' ) ; \nif ( pos >= 0 ) { \nString id = catalogName . substring ( pos + 1 ) ; \nDataset dataset = catalog . findDatasetByID ( id ) ; \nif ( dataset != null ) { \nsetSelectedDataset ( dataset ) ; \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Selection\" , null , dataset ) ) ; \n} \n} \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Catalog\" , null , catalogName ) ) ; \n} \n} \n"}
{"5203": "public class JTreeTableSorted { \npublic void restoreState ( PreferencesExt store ) { \nif ( store == null ) return ; \nint ncols = table . getColumnCount ( ) ; \nint [ ] modelIndex = ( int [ ] ) store . getBean ( \"ColumnOrder\" , null ) ; \nif ( ( modelIndex != null ) && ( modelIndex . length == ncols ) ) { \nboolean [ ] visible = new boolean [ ncols ] ; \nfor ( int aModelIndex : modelIndex ) if ( aModelIndex < ncols ) visible [ aModelIndex ] = true ; \nfor ( int i = 0 ; \ni < ncols ; \ni ++ ) if ( ! visible [ i ] ) { \nacts [ i ] . hideColumn ( ) ; \nacts [ i ] . putValue ( BAMutil . STATE , new Boolean ( false ) ) ; \n} \nTableColumnModel tcm = table . getColumnModel ( ) ; \nint n = Math . min ( modelIndex . length , table . getColumnCount ( ) ) ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \ntc . setModelIndex ( modelIndex [ i ] ) ; \nString name = model . getColumnName ( modelIndex [ i ] ) ; \ntc . setHeaderValue ( name ) ; \ntc . setIdentifier ( name ) ; \nif ( useThreads && ( modelIndex [ i ] == threadCol ) ) { \nthreadHeaderRenderer = new ThreadHeaderRenderer ( threadCol ) ; \ntc . setHeaderRenderer ( threadHeaderRenderer ) ; \n} \nelse tc . setHeaderRenderer ( new SortedHeaderRenderer ( name , modelIndex [ i ] ) ) ; \n} \n} \nObject colWidths = store . getBean ( \"ColumnWidths\" , null ) ; \nif ( colWidths == null ) return ; \nint [ ] size = ( int [ ] ) colWidths ; \nsetColumnWidths ( size ) ; \nif ( debug ) { \n; \nfor ( int aSize : size ) ; \n; \n} \nboolean isThreadsOn = store . getBoolean ( \"isThreadsOn\" , false ) ; \nif ( useThreads ) { \nmodel . setThreadsOn ( isThreadsOn ) ; \nthreadHeaderRenderer . setOn ( isThreadsOn ) ; \n} \nint colNo = store . getInt ( \"SortOnCol\" , 0 ) ; \nboolean reverse = store . getBoolean ( \"SortReverse\" , false ) ; \nmodel . setSortCol ( colNo ) ; \nmodel . setReverse ( reverse ) ; \nsetSortCol ( colNo , reverse ) ; \nmodel . sort ( ) ; \ntable . fireDataChanged ( ) ; \n} \nprivate void setColumnWidths ( int [ ] sizes ) { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( int i = 0 ; \ni < table . getColumnCount ( ) ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nint maxw = ( ( sizes == null ) || ( i >= sizes . length ) ) ? 10 : sizes [ i ] ; \ntc . setPreferredWidth ( maxw ) ; \n} \n} \npublic void setColOn ( int colno , boolean state , int pos ) { \nacts [ colno ] . putValue ( BAMutil . STATE , new Boolean ( state ) ) ; \nif ( state ) acts [ colno ] . addAtPos ( pos ) ; \nelse acts [ colno ] . hideColumn ( ) ; \n} \n} \n"}
{"5221": "public class DIFWriter { \npublic void doOneDataset ( InvDataset ds ) { \nif ( debug ) ; \nif ( isDatasetUseable ( ds , messBuffer ) ) { \nString id = StringUtil2 . replace ( ds . getID ( ) , \"/\" , \"-\" ) ; \nString fileOutName = fileDir + \"/\" + id + \".dif.xml\" ; \ntry { \nOutputStream out = new BufferedOutputStream ( new FileOutputStream ( fileOutName ) ) ; \nwriteOneEntry ( ds , out , messBuffer ) ; \nout . close ( ) ; \nmessBuffer . append ( \" OK on Write\\n\" ) ; \n} \ncatch ( IOException ioe ) { \nmessBuffer . append ( \"DIFWriter failed on write \" + ioe . getMessage ( ) + \"\\n\" ) ; \nlog . error ( \"DIFWriter failed on write \" + ioe . getMessage ( ) , ioe ) ; \n} \n} \n} \n} \n"}
{"5238": "public class ParsedSectionSpec { \nprivate static ParsedSectionSpec parseVariableSelector ( Object parent , String selector ) throws InvalidRangeException { \nString varNameEsc , indexSelect = null ; \nint pos1 = EscapeStrings . indexOf ( selector , '(' ) ; \nif ( pos1 < 0 ) { \nvarNameEsc = selector ; \n} \nelse { \nvarNameEsc = selector . substring ( 0 , pos1 ) ; \nint pos2 = selector . indexOf ( ')' , pos1 + 1 ) ; \nindexSelect = selector . substring ( pos1 , pos2 ) ; \n} \nif ( debugSelector ) ; \nVariable v = null ; \nif ( parent instanceof NetcdfFile ) { \nNetcdfFile ncfile = ( NetcdfFile ) parent ; \nv = ncfile . findVariable ( varNameEsc ) ; \n} \nelse if ( parent instanceof Structure ) { \nStructure s = ( Structure ) parent ; \nv = s . findVariable ( NetcdfFile . makeNameUnescaped ( varNameEsc ) ) ; \n} \nif ( v == null ) throw new IllegalArgumentException ( \" cant find variable: \" + varNameEsc + \" in selector=\" + selector ) ; \nif ( v . getDataType ( ) == DataType . SEQUENCE ) indexSelect = null ; \nSection section ; \nif ( indexSelect != null ) { \nsection = new Section ( indexSelect ) ; \nsection = Section . fill ( section , v . getShape ( ) ) ; \n} \nelse { \nsection = v . getShapeAsSection ( ) ; \n} \nreturn new ParsedSectionSpec ( v , section ) ; \n} \n} \n"}
{"5330": "public class BitCounterUncompressed { \nint countBits ( int startBit ) { \ncountBits = replicationCountSize ; \nthis . startBit = new int [ nrows ] ; \nfor ( int i = 0 ; \ni < nrows ; \ni ++ ) { \nthis . startBit [ i ] = startBit + countBits ; \nif ( debug ) ; \nfor ( DataDescriptor nd : parent . subKeys ) { \nBitCounterUncompressed [ ] bitCounter = ( subCounters == null ) ? null : subCounters . get ( nd ) ; \nif ( bitCounter == null ) countBits += nd . getBitWidth ( ) ; \nelse { \nif ( debug ) ; \ncountBits += bitCounter [ i ] . countBits ( startBit + countBits ) ; \nif ( debug ) ; \n} \n} \n} \nreturn countBits ; \n} \n} \n"}
{"5342": "public class OptSwitch { \npublic void SetHasValue ( int type ) { \nthis . type = type ; \nif ( debug ) { \n; \n} \n} \n} \n"}
{"5344": "public class IO { \nstatic public long copyB ( InputStream in , OutputStream out , int bufferSize ) throws IOException { \nlong totalBytesRead = 0 ; \nint done = 0 , next = 1 ; \nbyte [ ] buffer = new byte [ bufferSize ] ; \nwhile ( true ) { \nint n = in . read ( buffer ) ; \nif ( n == - 1 ) break ; \nout . write ( buffer , 0 , n ) ; \ntotalBytesRead += n ; \nif ( showCopy ) { \ndone += n ; \nif ( done > 1000 * 1000 * next ) { \n; \nnext ++ ; \n} \n} \n} \nout . flush ( ) ; \nreturn totalBytesRead ; \n} \n} \n"}
{"5365": "public class NcmlCollectionReader { \nstatic public NcmlCollectionReader readNcML ( String ncmlString , Formatter errlog ) throws IOException { \nStringReader reader = new StringReader ( ncmlString ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \nif ( debugURL ) ; \ndoc = builder . build ( new StringReader ( ncmlString ) ) ; \n} \ncatch ( JDOMException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \nif ( debugXML ) ; \nreturn readXML ( doc , errlog , null ) ; \n} \n} \n"}
{"5366": "public class NcmlCollectionReader { \nstatic public NcmlCollectionReader open ( String ncmlLocation , Formatter errlog ) throws IOException { \nif ( ! ncmlLocation . startsWith ( \"http:\" ) && ! ncmlLocation . startsWith ( \"file:\" ) ) ncmlLocation = \"file:\" + ncmlLocation ; \nURL url = new URL ( ncmlLocation ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \nif ( debugURL ) ; \ndoc = builder . build ( url ) ; \n} \ncatch ( JDOMException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \nif ( debugXML ) ; \nreturn readXML ( doc , errlog , ncmlLocation ) ; \n} \n} \n"}
{"5448": "public class GisFeatureRendererMulti { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nlong startTime = System . currentTimeMillis ( ) ; \nif ( featSetList == null ) { \ninitFeatSetList ( ) ; \nassert ! featSetList . isEmpty ( ) ; \n} \nFeatureSet fs = ( FeatureSet ) featSetList . get ( 0 ) ; \nif ( featSetList . size ( ) > 1 ) { \ndouble scale = 1.0 ; \ntry { \nAffineTransform world2device = g . getTransform ( ) ; \nAffineTransform world2normal = normal2device . createInverse ( ) ; \nworld2normal . concatenate ( world2device ) ; \nscale = Math . max ( Math . abs ( world2normal . getScaleX ( ) ) , Math . abs ( world2normal . getShearX ( ) ) ) ; \nif ( Debug . isSet ( \"GisFeature/showTransform\" ) ) { \n; \n} \n} \ncatch ( java . awt . geom . NoninvertibleTransformException e ) { \n; \n} \nif ( ! displayProject . isLatLon ( ) ) scale *= 111.0 ; \ndouble minD = Double . MAX_VALUE ; \nfor ( Object aFeatSetList : featSetList ) { \nFeatureSet tryfs = ( FeatureSet ) aFeatSetList ; \ndouble d = Math . abs ( scale * tryfs . minDist - pixelMatch ) ; \nif ( d < minD ) { \nminD = d ; \nfs = tryfs ; \n} \n} \nif ( Debug . isSet ( \"GisFeature/MapResolution\" ) ) { \n; \n} \n} \nif ( fs . featureList == null ) fs . createFeatures ( ) ; \nif ( ! displayProject . equals ( fs . project ) ) { \nfs . setProjection ( displayProject ) ; \n} \nelse { \nif ( fs . newProjection && displayProject . isLatLon ( ) ) { \nfs . setProjection ( displayProject ) ; \n} \n} \nfs . newProjection = false ; \nif ( Debug . isSet ( \"GisFeature/timing/getShapes\" ) ) { \nlong tookTime = System . currentTimeMillis ( ) - startTime ; \n; \n} \nreturn fs . getShapes ( ) ; \n} \n} \n"}
{"5449": "public class GisFeatureRendererMulti { \nprivate ArrayList makeShapes ( Iterator featList ) { \nShape shape ; \nArrayList shapeList = new ArrayList ( ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nif ( Debug . isSet ( \"GisFeature/MapDraw\" ) ) { \n; \n} \nwhile ( featList . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) featList . next ( ) ; \nif ( dataProject . isLatLon ( ) ) shape = feature . getProjectedShape ( displayProject ) ; \nelse if ( dataProject == displayProject ) shape = feature . getShape ( ) ; \nelse shape = feature . getProjectedShape ( dataProject , displayProject ) ; \nshapeList . add ( shape ) ; \n} \nreturn shapeList ; \n} \n} \n"}
{"5451": "public class StopButton { \npublic boolean startProgressMonitorTask ( ProgressMonitorTask pmt ) { \nif ( busy ) return false ; \nbusy = true ; \nthis . task = pmt ; \nisCancelled = false ; \ncount = 0 ; \nsetIcon ( icon [ 0 ] ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nif ( isCancelled && ! task . isCancel ( ) ) { \ntask . cancel ( ) ; \nif ( debug ) ; \nreturn ; \n} \nelse { \ncount ++ ; \nsetIcon ( icon [ count % 2 ] ) ; \nif ( debug ) ; \n} \nif ( task . isDone ( ) ) { \nif ( myTimer != null ) myTimer . stop ( ) ; \nmyTimer = null ; \nif ( task . isError ( ) ) javax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \nbusy = false ; \n} \n} \n} \n; \nmyTimer = new javax . swing . Timer ( 1000 , watcher ) ; \nmyTimer . start ( ) ; \nThread taskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nreturn true ; \n} \n} \n"}
{"5484": "public class GempakFileReader { \npublic void printParts ( ) { \nif ( parts == null ) { \nreturn ; \n} \nfor ( int i = 0 ; \ni < parts . size ( ) ; \ni ++ ) { \n; \n; \n} \n} \n} \n"}
{"5485": "public class GempakFileReader { \npublic int getDataPointer ( int irow , int icol , String partName ) { \nint ipoint = - 1 ; \nif ( ( irow < 1 ) || ( irow > dmLabel . krow ) || ( icol < 1 ) || ( icol > dmLabel . kcol ) ) { \n; \nreturn ipoint ; \n} \nint iprt = getPartNumber ( partName ) ; \nif ( iprt == 0 ) { \n; \nreturn ipoint ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( ( part . ktyprt != MDREAL ) && ( part . ktyprt != MDGRID ) && ( part . ktyprt != MDRPCK ) ) { \n; \nreturn ipoint ; \n} \nint ilenhd = part . klnhdr ; \nipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( icol - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nreturn ipoint ; \n} \n} \n"}
{"5491": "public class DDSXMLParser { \nprivate void parseBase ( Element e , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel ++ ; \nString type = e . getName ( ) ; \nif ( type . equals ( \"Attribute\" ) ) { \n} \nelse if ( type . equals ( \"Alias\" ) ) { \n} \nelse if ( type . equals ( \"dataBLOB\" ) ) { \norg . jdom2 . Attribute hrefAttr = e . getAttribute ( \"href\" ) ; \nString contentID = hrefAttr . getValue ( ) ; \nif ( _Debug ) ; \ndds . setBlobContentID ( contentID ) ; \n} \nelse { \nif ( _Debug ) ; \nif ( _Debug ) showXMLElement ( e , indent ) ; \nBaseType bt = newBaseType ( e ) ; \nparentDC . addVariable ( bt ) ; \nif ( bt instanceof DConstructor ) { \nDConstructor myParentDC = parentDC ; \nparentDC = ( DConstructor ) bt ; \ntry { \nif ( bt instanceof DGrid ) { \nparseGrid ( e , indent ) ; \n} \nelse { \nfor ( Element child : e . getChildren ( ) ) { \nparseBase ( child , indent + \"    \" ) ; \n} \n} \n} \nfinally { \nparentDC = myParentDC ; \n} \n} \nelse if ( bt instanceof DArray ) { \nif ( _Debug ) ; \nparseArray ( e , ( DArray ) bt , indent ) ; \n} \n} \nparseLevel -- ; \n} \n} \n"}
{"5492": "public class DDSXMLParser { \nprivate void parseGrid ( Element gridElement , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel ++ ; \nDGrid myGrid = ( DGrid ) parentDC ; \nif ( _Debug ) { \n; \n; \nfor ( Element element : gridElement . getChildren ( ) ) ; \n} \nString eName = \"Array\" ; \nif ( _Debug ) { \n; \n; \n} \nElement arrayElement = gridElement . getChild ( eName , opendapNameSpace ) ; \nif ( _Debug ) ; \nDArray gridArray = ( DArray ) newBaseType ( arrayElement ) ; \nparseArray ( arrayElement , gridArray , indent + \"    \" ) ; \nmyGrid . addVariable ( gridArray , DGrid . ARRAY ) ; \neName = \"Map\" ; \nif ( _Debug ) { \n; \n; \n} \nList < Element > mapElements = gridElement . getChildren ( \"Map\" , opendapNameSpace ) ; \nif ( mapElements . size ( ) != gridArray . numDimensions ( ) ) throw new BadSemanticsException ( \"Error in Grid syntax: \" + \"The number of Map arrays must \" + \"equal the number of dimensions \" + \"of the data array.\" ) ; \nfor ( Element mapElement : mapElements ) { \nDArray thisMap = ( DArray ) newBaseType ( mapElement ) ; \nparseArray ( mapElement , thisMap , indent + \"    \" ) ; \nif ( thisMap . numDimensions ( ) != 1 ) throw new BadSemanticsException ( \"Error in Grid syntax: \" + \"Maps may have only one dimension.\" ) ; \nmyGrid . addVariable ( thisMap , DGrid . MAPS ) ; \n} \nparseLevel -- ; \n} \n} \n"}
{"5493": "public class DDSXMLParser { \nprivate void parseAliases ( Element e , String indent ) throws DASException { \nparseLevel ++ ; \nString subIndent = indent + \"    \" ; \nif ( _Debug ) ; \nif ( _Debug ) ; \nfor ( Element aliasElement : e . getChildren ( \"Alias\" , opendapNameSpace ) ) { \nString name = null ; \nAttribute nameAttr = aliasElement . getAttribute ( \"name\" ) ; \nname = nameAttr . getValue ( ) ; \nString attributeName = null ; \nAttribute attributeAttr = aliasElement . getAttribute ( \"Attribute\" ) ; \nattributeName = attributeAttr . getValue ( ) ; \nif ( _Debug ) { \n; \n} \nif ( currentAT == null ) currentBT . addAttributeAlias ( name , attributeName ) ; \nelse currentAT . addAlias ( name , attributeName ) ; \n} \nparseLevel -- ; \n} \n} \n"}
{"5496": "public class ServerDDS { \npublic String getDatasetFilename ( ) { \nString s = getEncodedName ( ) ; \n; \nreturn ( s ) ; \n} \n} \n"}
{"5501": "public class Tools { \npublic static void probeObject ( Object o ) { \nClass c = o . getClass ( ) ; \nClass interfaces [ ] = c . getInterfaces ( ) ; \nClass parent = c . getSuperclass ( ) ; \nMethod m [ ] = c . getMethods ( ) ; \n; \n; \n; \n; \nfor ( int i = 0 ; \ni < interfaces . length ; \ni ++ ) { \n; \n} \n; \nfor ( int i = 0 ; \ni < m . length ; \ni ++ ) { \nClass params [ ] = m [ i ] . getParameterTypes ( ) ; \nClass excepts [ ] = m [ i ] . getExceptionTypes ( ) ; \nClass ret = m [ i ] . getReturnType ( ) ; \n; \nfor ( int j = 0 ; \nj < params . length ; \nj ++ ) { \nif ( j > 0 ) ; \n; \n} \n; \nfor ( int j = 0 ; \nj < excepts . length ; \nj ++ ) { \nif ( j > 0 ) ; \n; \n} \n; \n} \n; \n} \n} \n"}
{"5536": "public class BeanTable { \npublic List getSelectedBeans ( ) { \nArrayList < Object > list = new ArrayList < > ( ) ; \nint [ ] viewRowIndices = jtable . getSelectedRows ( ) ; \nfor ( int viewRowIndex : viewRowIndices ) { \nint modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndex ) ; \nlist . add ( beans . get ( modelRowIndex ) ) ; \nif ( debugSelected ) ; \n} \nreturn list ; \n} \n} \n"}
{"5549": "public class SimpleUnit { \nstatic public SimpleUnit factory ( String name ) { \ntry { \nreturn factoryWithExceptions ( name ) ; \n} \ncatch ( Exception e ) { \nif ( debugParse ) ; \nreturn null ; \n} \n} \n} \n"}
{"5570": "public class RandomAccessFile { \npublic synchronized void close ( ) throws IOException { \nif ( cache != null ) { \nif ( cacheState > 0 ) { \nif ( cacheState == 1 ) { \ncacheState = 2 ; \nif ( cache . release ( this ) ) return ; \ncacheState = 0 ; \n} \nelse { \nreturn ; \n} \n} \n} \nif ( debugLeaks ) { \nopenFiles . remove ( location ) ; \nif ( showOpen ) ; \n} \nif ( file == null ) return ; \nflush ( ) ; \nlong fileSize = file . length ( ) ; \nif ( ! readonly && ( minLength != 0 ) && ( minLength != fileSize ) ) { \nfile . setLength ( minLength ) ; \n} \nfile . close ( ) ; \nfile = null ; \n} \n} \n"}
{"5602": "public class FileCache { \n@ Override public void eject ( Object hashKey ) { \nif ( disabled . get ( ) ) return ; \nCacheElement wantCacheElem = cache . get ( hashKey ) ; \nif ( wantCacheElem == null ) return ; \nsynchronized ( wantCacheElem ) { \nfor ( CacheElement . CacheFile want : wantCacheElem . list ) { \nfiles . remove ( want . ncfile ) ; \ntry { \nwant . ncfile . setFileCache ( null ) ; \nwant . ncfile . close ( ) ; \nlog . debug ( \"close \" + want . ncfile . getLocation ( ) ) ; \n} \ncatch ( IOException e ) { \nlog . error ( \"close failed on \" + want . ncfile . getLocation ( ) , e ) ; \n} \nwant . ncfile = null ; \nif ( debugPrint ) ; \n} \nwantCacheElem . list . clear ( ) ; \n} \ncache . remove ( hashKey ) ; \n} \n} \n"}
{"5627": "public class GempakGridServiceProvider { \nprivate void initTables ( ) { \ntry { \nGempakGridParameterTable . addParameters ( \"resources/nj22/tables/gempak/wmogrib3.tbl\" ) ; \nGempakGridParameterTable . addParameters ( \"resources/nj22/tables/gempak/ncepgrib2.tbl\" ) ; \n} \ncatch ( Exception e ) { \n; \n} \n} \n} \n"}
{"5649": "public class MetadataManager { \nstatic synchronized public void closeAll ( ) { \nList < MetadataManager > closeDatabases = new ArrayList < > ( openDatabases ) ; \nfor ( MetadataManager mm : closeDatabases ) { \nif ( debug ) ; \nmm . close ( ) ; \n} \nopenDatabases = new ArrayList < > ( ) ; \nif ( myEnv != null ) { \ntry { \nmyEnv . close ( ) ; \nmyEnv = null ; \nlogger . info ( \"closed bdb caching\" ) ; \n} \ncatch ( DatabaseException dbe ) { \nlogger . error ( \"Error closing bdb: \" , dbe ) ; \n} \n} \n} \n} \n"}
{"5663": "public class EcmwfLocalConcepts { \nprivate void storeConcept ( String tableVersion , String parameterNumber , String key , String value ) { \nHashMap < String , HashMap < String , String > > tmpTable ; \nif ( localConcepts . containsKey ( tableVersion ) ) { \ntmpTable = localConcepts . get ( tableVersion ) ; \nif ( tmpTable . containsKey ( parameterNumber ) ) { \nHashMap < String , String > tmpParam = tmpTable . get ( parameterNumber ) ; \nif ( ! tmpParam . containsKey ( key ) ) { \ntmpParam . put ( key , value ) ; \n} \nelse { \n; \n} \n} \nelse { \nHashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; \ntmpParam . put ( key , value ) ; \ntmpTable . put ( parameterNumber , tmpParam ) ; \n} \n} \nelse { \ntmpTable = new HashMap < > ( ) ; \nHashMap < String , String > tmpParam = new HashMap < > ( 4 ) ; \ntmpParam . put ( key , value ) ; \ntmpTable . put ( parameterNumber , tmpParam ) ; \n} \nlocalConcepts . put ( tableVersion , tmpTable ) ; \n} \n} \n"}
{"5664": "public class EcmwfLocalConcepts { \nprivate void writeGrib1Tables ( ) throws IOException { \nSimpleDateFormat dateFormat = new SimpleDateFormat ( \"yyyy-MM-dd'T'HH:mm:ssz\" ) ; \nCalendar cal = Calendar . getInstance ( ) ; \nString writeDate = dateFormat . format ( cal . getTime ( ) ) ; \nString grib1Info ; \nList < String > tableNums = new ArrayList < > ( ) ; \nHashMap < String , String > paramInfo ; \nPath dir = Paths . get ( ecmwfLocalConceptsLoc . replace ( \"sources/\" , \"resources/resources/grib1/\" ) ) ; \nfor ( String tableNum : localConcepts . keySet ( ) ) { \ntableNums . add ( tableNum ) ; \nString fileName = \"2.98.\" + tableNum + \".table\" ; \n; \nPath newFile = dir . resolve ( fileName ) ; \nFiles . deleteIfExists ( newFile ) ; \nFiles . createFile ( newFile ) ; \ntry ( BufferedWriter writer = Files . newBufferedWriter ( newFile , ENCODING ) ) { \nwriter . write ( \"# Generated by \" + this . getClass ( ) . getCanonicalName ( ) + \" on \" + writeDate ) ; \nwriter . newLine ( ) ; \nfor ( String paramNum : localConcepts . get ( tableNum ) . keySet ( ) ) { \nparamInfo = localConcepts . get ( tableNum ) . get ( paramNum ) ; \nString shortName = paramInfo . get ( SHORTNAME_ID ) ; \nString description = paramInfo . get ( DESCRIPTION_ID ) ; \nString units = paramInfo . get ( UNIT_ID ) ; \ngrib1Info = paramNum + \" \" + shortName + \" [\" + description + \"] (\" + units + \")\" ; \nwriter . write ( grib1Info ) ; \nwriter . newLine ( ) ; \n} \n} \n} \nwriteLookupTableFile ( tableNums , dir , writeDate ) ; \n} \n} \n"}
{"5665": "public class EcmwfLocalConcepts { \nprivate void writeLookupTableFile ( List < String > tableNums , Path dir , String writeDate ) throws IOException { \n; \nCollections . sort ( tableNums ) ; \nPath lookupTableReg = dir . resolve ( \"lookupTables.txt\" ) ; \nFiles . deleteIfExists ( lookupTableReg ) ; \nFiles . createFile ( lookupTableReg ) ; \ntry ( BufferedWriter writer = Files . newBufferedWriter ( lookupTableReg , ENCODING ) ) { \nwriter . write ( \"# Generated by \" + this . getClass ( ) . getCanonicalName ( ) + \" on \" + writeDate ) ; \nwriter . newLine ( ) ; \nfor ( String tn : tableNums ) { \nString tableName = \"2.98.\" + tn + \".table\" ; \nString reg = \"98:\\t-1:\\t\" + tn + \":\\t\" + tableName ; \nwriter . write ( reg ) ; \nwriter . newLine ( ) ; \n} \n} \n} \n} \n"}
{"5666": "public class EcmwfLocalConcepts { \nprivate void showLocalConcepts ( ) { \nfor ( String tableNum : localConcepts . keySet ( ) ) { \nfor ( String paramNum : localConcepts . get ( tableNum ) . keySet ( ) ) { \nfor ( String key : localConcepts . get ( tableNum ) . get ( paramNum ) . keySet ( ) ) { \n; \n} \n} \n} \n} \n} \n"}
{"5667": "public class EcmwfLocalConcepts { \npublic static void main ( String [ ] args ) { \nEcmwfLocalConcepts ec = new EcmwfLocalConcepts ( ) ; \ntry { \nec . writeGrib1Tables ( ) ; \n; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"5705": "public class XMLStore { \nstatic public XMLStore createFromFile ( String fileName , XMLStore storedDefaults ) throws java . io . IOException { \nFile prefsFile = new File ( fileName ) ; \nInputStream primIS = null , objIS = null ; \nif ( prefsFile . exists ( ) && prefsFile . length ( ) > 0 ) { \nprimIS = new BufferedInputStream ( new FileInputStream ( prefsFile ) ) ; \nobjIS = new BufferedInputStream ( new FileInputStream ( prefsFile ) ) ; \n} \nif ( debugWhichStore ) ; \nXMLStore store = new XMLStore ( primIS , objIS , storedDefaults ) ; \nstore . prefsFile = prefsFile ; \nreturn store ; \n} \n} \n"}
{"5706": "public class XMLStore { \nstatic public XMLStore createFromInputStream ( InputStream is1 , InputStream is2 , XMLStore storedDefaults ) throws java . io . IOException { \nif ( debugWhichStore ) ; \nreturn new XMLStore ( is1 , is2 , storedDefaults ) ; \n} \n} \n"}
{"5707": "public class XMLStore { \nstatic public XMLStore createFromResource ( String resourceName , XMLStore storedDefaults ) throws java . io . IOException { \nClass c = XMLStore . class ; \nInputStream primIS = c . getResourceAsStream ( resourceName ) ; \nInputStream objIS = c . getResourceAsStream ( resourceName ) ; \nif ( primIS == null ) { \nthrow new java . io . IOException ( \"XMLStore.createFromResource cant find <\" + resourceName + \">\" ) ; \n} \nif ( debugWhichStore ) ; \nreturn new XMLStore ( primIS , objIS , storedDefaults ) ; \n} \n} \n"}
{"5708": "public class XMLStore { \nstatic public String makeStandardFilename ( String appName , String storeName ) { \nString userHome = null ; \ntry { \nuserHome = System . getProperty ( \"user.home\" ) ; \n} \ncatch ( Exception e ) { \n; \n} \nif ( null == userHome ) userHome = \".\" ; \nString dirFilename = userHome + \"/\" + appName ; \nFile f = new File ( dirFilename ) ; \nif ( ! f . exists ( ) ) { \nboolean ok = f . mkdirs ( ) ; \nif ( ! ok ) ; \n} \nreturn dirFilename + \"/\" + storeName ; \n} \n} \n"}
{"5710": "public class XMLStore { \npublic void save ( OutputStream out ) throws java . io . IOException { \noutputExceptionMessage = null ; \nOutputMunger bos = new OutputMunger ( out ) ; \nPrintWriter pw = new PrintWriter ( new OutputStreamWriter ( bos , CDM . utf8Charset ) ) ; \nXMLEncoder beanEncoder = new XMLEncoder ( bos ) ; \nbeanEncoder . setExceptionListener ( new ExceptionListener ( ) { \npublic void exceptionThrown ( Exception exception ) { \n; \nexception . printStackTrace ( ) ; \noutputExceptionMessage = exception . getMessage ( ) ; \n} \n} \n) ; \npw . printf ( \"<?xml version='1.0' encoding='UTF-8'?>%n\" ) ; \npw . printf ( \"<preferences EXTERNAL_XML_VERSION='1.0'>%n\" ) ; \nif ( ! rootPrefs . isUserNode ( ) ) pw . printf ( \"  <root type='system'>%n\" ) ; \nelse pw . printf ( \"  <root type='user'>%n\" ) ; \nIndent indent = new Indent ( 2 ) ; \nindent . incr ( ) ; \nwriteXmlNode ( bos , pw , rootPrefs , beanEncoder , indent ) ; \nif ( outputExceptionMessage != null ) throw new IOException ( outputExceptionMessage ) ; \npw . printf ( \"  </root>%n\" ) ; \npw . printf ( \"</preferences>%n\" ) ; \npw . flush ( ) ; \n} \n} \n"}
{"5729": "public class StationRenderer { \npublic ucar . unidata . geoloc . Station pickClosest ( Point2D pickPt ) { \nif ( world2Normal == null || pickPt == null || stations . isEmpty ( ) ) return null ; \nworld2Normal . transform ( pickPt , ptN ) ; \nStationUI closest = ( StationUI ) stationGrid . findClosest ( ptN ) ; \nif ( debug ) ; \nsetSelectedStation ( closest ) ; \nreturn getSelectedStation ( ) ; \n} \n} \n"}
{"5756": "public class JTableProjection { \npublic void setCurrentProjection ( ProjectionImpl proj ) { \nint row ; \nif ( 0 <= ( row = model . search ( proj ) ) ) { \nif ( debug ) ; \nselectedRow = row ; \nsetRowSelectionInterval ( row , row ) ; \n} \nelse { \nif ( debug ) ; \nselectedRow = - 1 ; \nclearSelection ( ) ; \n} \n} \n} \n"}
{"5810": "public class GridDefRecord { \npublic final String getParam ( String key ) { \nString value = paramStr . get ( key ) ; \nif ( value == null ) { \nDouble result = paramDbl . get ( key ) ; \nif ( result != null ) { \nvalue = result . toString ( ) ; \n} \nelse { \nInteger intResult = paramInt . get ( key ) ; \nif ( intResult != null ) { \nvalue = intResult . toString ( ) ; \n} \n} \nif ( value != null ) { \nparamStr . put ( key , value ) ; \n} \n} \nif ( debug && value == null ) { \n; \n} \nreturn value ; \n} \n} \n"}
{"5813": "public class MessageBroker { \nprivate int process ( Buffer b , InputStream is ) throws IOException { \nint start = 0 ; \nwhile ( start < b . have ) { \nint matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; \nif ( matchPos < 0 ) { \nif ( start == 0 ) return b . have - 3 ; \nelse return start ; \n} \nif ( matchPos + 6 >= b . have ) { \nreturn start ; \n} \nint b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; \nint b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; \nint b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; \nint messLen = b1 << 16 | b2 << 8 | b3 ; \nMessageTask task = new MessageTask ( messLen ) ; \ntask . header = extractHeader ( start , matchPos , b ) ; \nint last = matchPos + messLen ; \nif ( last > b . have ) { \ntask . have = b . have - matchPos ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \nif ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { \n; \nbreak ; \n} \n} \nelse { \ntask . have = task . len ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \n} \nboolean ok = true ; \nfor ( int i = task . len - 4 ; \ni < task . len ; \ni ++ ) { \nint bb = task . mess [ i ] ; \nif ( bb != 55 ) { \nok = false ; \nbad_msgs ++ ; \n} \n} \ntry { \nif ( ok ) messQ . put ( task ) ; \ntotal_msgs ++ ; \n} \ncatch ( InterruptedException e ) { \n; \nbreak ; \n} \nstart = matchPos + messLen + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5835": "public class Structure { \npublic ArrayStructure readStructure ( int start , int count ) throws IOException , ucar . ma2 . InvalidRangeException { \nif ( getRank ( ) != 1 ) throw new java . lang . UnsupportedOperationException ( \"not a vector structure\" ) ; \nint [ ] origin = new int [ ] { \nstart } \n; \nint [ ] shape = new int [ ] { \ncount } \n; \nif ( NetcdfFile . debugStructureIterator ) ; \nreturn ( ArrayStructure ) read ( origin , shape ) ; \n} \n} \n"}
{"6515": "public class DSLTree { \npublic void printTree ( ) { \n; \nfor ( Node n : rootCond . getChildren ( ) ) { \nprintNode ( n ) ; \n} \n} \n} \n"}
{"6516": "public class DSLTree { \nprotected void printNode ( Node n ) { \nprintTabs ( n . getDepth ( ) ) ; \n; \nfor ( Node c : n . getChildren ( ) ) { \nprintNode ( c ) ; \n} \n} \n} \n"}
{"6517": "public class DSLTree { \nprotected void printTabs ( int count ) { \nfor ( int idx = 0 ; \nidx < count ; \nidx ++ ) { \n; \n} \n} \n} \n"}
{"7319": "public class CollectorManager { \nprivate boolean determineIfWeShouldExit ( ) { \nboolean shouldStop = stop . get ( ) ; \nif ( ! shouldStop ) { \nThread . interrupted ( ) ; \n} \nelse { \n; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"7660": "public class MySystem { \npublic synchronized static void variable ( String name , Object value ) { \nif ( ! variable ) { \nreturn ; \n} \n; \n} \n} \n"}
{"7756": "public class Application { \nprivate void updateDB ( ) throws SQLException , LiquibaseException { \n; \ntry ( BasicDataSource dataSource = new BasicDataSource ( ) ) { \ndataSource . setUrl ( fullConnectionString ) ; \ndataSource . setUsername ( username ) ; \ndataSource . setPassword ( password ) ; \ntry ( java . sql . Connection c = dataSource . getConnection ( ) ) { \nDatabase database = DatabaseFactory . getInstance ( ) . findCorrectDatabaseImplementation ( new JdbcConnection ( c ) ) ; \nLiquibase liquibase = null ; \nClassLoaderResourceAccessor accessor = new ClassLoaderResourceAccessor ( ) ; \ntry { \nif ( accessor . getResourcesAsStream ( \"changelog-master.xml\" ) != null ) { \nliquibase = new Liquibase ( \"changelog-master.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \n} \nelse if ( accessor . getResourcesAsStream ( \"changelog.xml\" ) != null ) { \nliquibase = new Liquibase ( \"changelog.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \n} \nelse { \nString errorMessage = \"No liquibase changelog-master.xml or changelog.xml could be located\" ; \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , errorMessage , this ) ; \nthrow new RuntimeException ( errorMessage ) ; \n} \n} \ncatch ( final IOException ioe ) { \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , ioe . getMessage ( ) , ioe ) ; \n} \nliquibase . getLog ( ) . setLogLevel ( logLevel ) ; \nliquibase . update ( new Contexts ( ) ) ; \n; \n} \n} \n} \n} \n"}
{"7845": "public class Main { \nprivate void printUsage ( final Options options , final String errorMessage ) { \nif ( errorMessage != null ) { \n; \n} \nfinal HelpFormatter formatter = new HelpFormatter ( ) ; \nformatter . printHelp ( Main . class . getCanonicalName ( ) + \" <task> [options]\" , options ) ; \n; \n; \n} \n} \n"}
{"7959": "public class JspC { \npublic static void main ( String arg [ ] ) { \nif ( arg . length == 0 ) { \n; \n} \nelse { \nJspC jspc = new JspC ( ) ; \ntry { \njspc . setArgs ( arg ) ; \nif ( jspc . helpNeeded ) { \n; \n} \nelse { \njspc . execute ( ) ; \n} \n} \ncatch ( JasperException je ) { \nSystem . err . println ( je ) ; \nif ( jspc . getDieLevel ( ) != NO_DIE_LEVEL ) { \nSystem . exit ( jspc . getDieLevel ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"8388": "public class JarArchive { \nprivate ITreeNode parseTree ( ) { \nITreeNode root = new TreeNodeUniqueChildren ( ) ; \nITreeNode newnode , oldnode ; \nEnumeration entries = this . jar . entries ( ) ; \nString entry ; \nwhile ( entries . hasMoreElements ( ) ) { \nnewnode = root ; \noldnode = root ; \nentry = ( ( JarEntry ) entries . nextElement ( ) ) . getName ( ) ; \n; \nStringTokenizer tokenizer = new StringTokenizer ( entry , \"/\" ) ; \nwhile ( tokenizer . hasMoreElements ( ) ) { \nString path = tokenizer . nextToken ( ) ; \nnewnode = new TreeNodeUniqueChildren ( path ) ; \noldnode . addChildNode ( newnode ) ; \noldnode = newnode ; \n} \n} \nreturn root ; \n} \n} \n"}
{"8398": "public class RemoteServer { \npublic static void main ( String [ ] args ) throws Exception { \nconfigureLogging ( ) ; \nCommandLineHelper helper = new CommandLineHelper ( args ) ; \nif ( helper . getHelpRequested ( ) ) { \n; \nSystem . exit ( 0 ) ; \n} \nRemoteServer remoteServer = new RemoteServer ( ) ; \nString error = helper . getError ( ) ; \nif ( error == null ) { \ntry { \nfor ( String path : helper . getLibraryMap ( ) . keySet ( ) ) remoteServer . putLibrary ( path , helper . getLibraryMap ( ) . get ( path ) ) ; \n} \ncatch ( IllegalPathException e ) { \nerror = e . getMessage ( ) ; \n} \n} \nif ( error != null ) { \n; \n; \n; \nSystem . exit ( 1 ) ; \n} \nremoteServer . setPort ( helper . getPort ( ) ) ; \nremoteServer . setAllowStop ( helper . getAllowStop ( ) ) ; \nremoteServer . setHost ( helper . getHost ( ) ) ; \nremoteServer . start ( ) ; \n} \n} \n"}
{"8942": "public class GemFireJmxClient { \npublic static synchronized Pool getPoolForServer ( String serverName , JMX jmx ) throws InstanceNotFoundException { \nPool pool = PoolManager . find ( serverName ) ; \nif ( pool != null ) return pool ; \nPoolFactory poolFactory = PoolManager . createFactory ( ) ; \ntry { \nObjectName objectName = new ObjectName ( new StringBuilder ( \"GemFire:type=Member,member=\" ) . append ( serverName ) . toString ( ) ) ; \nString host = jmx . getAttribute ( objectName , \"Host\" ) ; \nif ( host == null || host . length ( ) == 0 ) throw new IllegalArgumentException ( \"host not found for serverName:\" + serverName + \" not found\" ) ; \nhost = lookupNetworkHost ( host ) ; \nString findJmxPort = new StringBuilder ( \"GemFire:service=CacheServer,port=*,type=Member,member=\" ) . append ( serverName ) . toString ( ) ; \nSet < ObjectName > objectNames = jmx . searchObjectNames ( findJmxPort ) ; \nif ( objectNames == null || objectNames . isEmpty ( ) ) throw new IllegalArgumentException ( \"Unable to to find port with server name:\" + serverName ) ; \nObjectName portObjectName = objectNames . iterator ( ) . next ( ) ; \nInteger port = jmx . getAttribute ( portObjectName , \"Port\" ) ; \nif ( port == null ) throw new IllegalArgumentException ( \"Unable to obtain port for objectName:\" + portObjectName + \" for server:\" + serverName ) ; \n; \npoolFactory = poolFactory . addServer ( host , port . intValue ( ) ) ; \nreturn poolFactory . create ( serverName ) ; \n} \ncatch ( InstanceNotFoundException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( \"Unable to create pool for servername:\" + serverName + \" error:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n"}
{"8947": "public class GemFireJmxClient { \nstatic synchronized String lookupNetworkHost ( String host ) { \ntry { \nif ( _bundle == null ) { \nURL url = GemFireJmxClient . class . getResource ( hostPropFileName ) ; \nString filePath = null ; \nif ( url == null ) filePath = hostPropFileName ; \nelse filePath = url . toString ( ) ; \n; \n_bundle = ResourceBundle . getBundle ( \"host\" ) ; \n} \n; \nString newHost = _bundle . getString ( host ) ; \n; \nreturn newHost ; \n} \ncatch ( RuntimeException e ) { \n; \nreturn host ; \n} \n} \n} \n"}
{"8960": "public class GeodeClient { \nprotected static void constructSecurity ( Properties props ) throws IOException { \nprops . setProperty ( \"security-client-auth-init\" , GeodeConfigAuthInitialize . class . getName ( ) + \".create\" ) ; \nFile sslFile = saveEnvFile ( GeodeConfigConstants . SSL_KEYSTORE_CLASSPATH_FILE_PROP ) ; \n; \nFile sslTrustStoreFile = saveEnvFile ( GeodeConfigConstants . SSL_TRUSTSTORE_CLASSPATH_FILE_PROP ) ; \nString sslTrustStoreFilePath = \"\" ; \nif ( sslTrustStoreFile != null ) sslTrustStoreFilePath = sslTrustStoreFile . getAbsolutePath ( ) ; \nprops . setProperty ( \"ssl-keystore\" , ( sslFile != null ) ? sslFile . getAbsolutePath ( ) : \"\" ) ; \nprops . setProperty ( \"ssl-keystore-password\" , Config . getPropertyEnv ( \"ssl-keystore-password\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-truststore\" , sslTrustStoreFilePath ) ; \nprops . setProperty ( \"ssl-protocols\" , Config . getPropertyEnv ( \"ssl-protocols\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-truststore-password\" , Config . getPropertyEnv ( \"ssl-truststore-password\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-keystore-type\" , Config . getPropertyEnv ( \"ssl-keystore-type\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-ciphers\" , Config . getPropertyEnv ( \"ssl-ciphers\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-require-authentication\" , Config . getPropertyEnv ( \"ssl-require-authentication\" , \"\" ) ) ; \nprops . setProperty ( \"ssl-enabled-components\" , Config . getPropertyEnv ( \"ssl-enabled-components\" , \"\" ) ) ; \n} \n} \n"}
{"8967": "public class GfStatsReader { \npublic static void main ( String [ ] args ) { \nFile archiveFile , csvFile ; \nif ( args . length < 1 ) { \nSystem . err . println ( \"Usage: java \" + GfStatsReader . class . getName ( ) + \" archiveFile [csvFile [statName ]*]\" ) ; \nreturn ; \n} \ntry { \narchiveFile = Paths . get ( args [ 0 ] ) . toFile ( ) ; \nif ( archiveFile . isDirectory ( ) ) { \ntoCvsFiles ( archiveFile ) ; \nreturn ; \n} \nif ( args . length < 2 ) { \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . dumpCsvFiles ( ) ; \nreturn ; \n} \nString typeName = args [ 1 ] ; \ncsvFile = Paths . get ( args [ 2 ] ) . toFile ( ) ; \nGenericCsvStatsVisitor visitor = null ; \nif ( args . length > 3 ) { \nString [ ] stateNames = Arrays . copyOfRange ( args , 2 , args . length - 1 ) ; \nvisitor = new GenericCsvStatsVisitor ( csvFile , typeName , stateNames ) ; \n} \nelse visitor = new GenericCsvStatsVisitor ( csvFile , typeName ) ; \n; \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"8968": "public class SingletonGemFireJmx { \npublic synchronized static JMX reconnect ( ) { \ntry { \nClientCache cache = null ; \ncache = ClientCacheFactory . getAnyInstance ( ) ; \nif ( cache != null && ! cache . isClosed ( ) ) { \ncache . close ( ) ; \n} \n} \ncatch ( Exception e ) { \n; \n} \nif ( jmx != null ) { \njmx . dispose ( ) ; \njmx = null ; \n} \nreturn getJmx ( ) ; \n} \n} \n"}
{"8970": "public class GemFireMgmt { \npublic static void shutDownMember ( String name ) { \ntry { \nObjectName serverName = new ObjectName ( \"GemFire:type=Member,member=\" + name ) ; \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nMemberMXBean bean = jmx . newBean ( MemberMXBean . class , serverName ) ; \nbean . shutDownMember ( ) ; \n; \nwhile ( GemFireJmxClient . checkMemberStatus ( name , SingletonGemFireJmx . getJmx ( ) ) ) { \nThread . sleep ( shutDownDelay ) ; \n} \n} \ncatch ( MalformedObjectNameException e ) { \nthrow new RuntimeException ( \"Unable to shutdown member \" + name + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \ncatch ( Exception e ) { \n; \n} \n} \n} \n"}
{"9014": "public class AbstractPiFormula { \nprotected void printPi ( final String piString ) { \n; \nint index = 2 ; \nint line = 0 ; \nint group = 0 ; \nfinal int length = piString . length ( ) ; \nwhile ( index + 5 < length ) { \n; \nindex += 5 ; \nif ( ++ group == 10 ) { \n; \nif ( ++ line == 10 ) { \n; \nline = 0 ; \n} \n; \ngroup = 0 ; \n} \n} \nif ( index < length ) { \n; \n} \n} \n} \n"}
{"9018": "public class Buckets { \npublic void print ( ) { \nint maxCount = 0 ; \nfor ( int i = 0 ; \ni < m_n ; \n++ i ) { \nmaxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; \n} \nfinal float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; \nfor ( int i = 0 ; \ni < m_n ; \n++ i ) { \nfinal int b = m_aCounters [ i ] ; \nm_aAlignRight . print ( i , 2 ) ; \nm_aAlignRight . print ( b , 7 ) ; \n; \nfinal int length = Math . round ( factor * b ) ; \nfor ( int j = 0 ; \nj < length ; \n++ j ) ; \n; \n} \n} \n} \n"}
{"9279": "public class Catalog { \nprotected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \nString catfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \nwhile ( ! catalogFiles . isEmpty ( ) ) { \nString catfile = ( String ) catalogFiles . elementAt ( 0 ) ; \ntry { \ncatalogFiles . remove ( 0 ) ; \n} \ncatch ( ArrayIndexOutOfBoundsException e ) { \n} \nif ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) { \ntry { \nparseCatalogFile ( catfile ) ; \n} \ncatch ( CatalogException ce ) { \n; \n} \n} \nelse { \ncatalogs . addElement ( catfile ) ; \n} \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat ++ ) { \ncatfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \n} \ncatalogFiles . clear ( ) ; \n} \n} \n"}
{"9505": "public class Effect { \npublic static void main ( String [ ] args ) throws Exception { \nint n = 1 ; \nif ( args . length < 1 ) { \nusage ( ) ; \nreturn ; \n} \nProperties analyzers = new Properties ( ) ; \nanalyzers . load ( new FileInputStream ( new File ( \"analyzer.properties\" ) ) ) ; \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nString a = System . getProperty ( \"analyzer\" , \"mmseg4j\" ) ; \nAnalyzer analyzer = null ; \nString an = ( String ) analyzers . get ( a ) ; \nif ( an != null ) { \nanalyzer = ( Analyzer ) Class . forName ( an ) . newInstance ( ) ; \nmode = a ; \n} \nelse { \nusage ( ) ; \nreturn ; \n} \nif ( args . length > 1 ) { \ntry { \nn = Integer . parseInt ( args [ 1 ] ) ; \n} \ncatch ( NumberFormatException e ) { \n} \n} \nFile path = new File ( args [ 0 ] ) ; \n; \nEffect ef = new Effect ( path , analyzer ) ; \nef . run ( mode , n ) ; \n} \n} \n"}
{"9506": "public class Performance { \npublic static void main ( String [ ] args ) throws IOException { \nif ( args . length < 1 ) { \n; \n; \n; \nreturn ; \n} \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nSeg seg = null ; \nDictionary dic = Dictionary . getInstance ( ) ; \nif ( \"simple\" . equals ( mode ) ) { \nseg = new SimpleSeg ( dic ) ; \n} \nelse { \nseg = new ComplexSeg ( dic ) ; \n} \nFile path = new File ( args [ 0 ] ) ; \nFile [ ] txts = path . listFiles ( new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . endsWith ( \".txt\" ) ; \n} \n} \n) ; \nlong time = 0 ; \nfor ( File txt : txts ) { \nMMSeg mmSeg = new MMSeg ( new InputStreamReader ( new FileInputStream ( txt ) ) , seg ) ; \nWord word = null ; \nOutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( new File ( txt . getAbsoluteFile ( ) + \".\" + mode + \".word\" ) ) ) ; \nBufferedWriter bw = new BufferedWriter ( osw ) ; \nlong start = System . currentTimeMillis ( ) ; \nwhile ( ( word = mmSeg . next ( ) ) != null ) { \nbw . append ( new String ( word . getString ( ) ) ) . append ( \"\\r\\n\" ) ; \n} \ntime += System . currentTimeMillis ( ) - start ; \nbw . close ( ) ; \n} \n; \n} \n} \n"}
{"9567": "public class Program { \nstatic void pauseForUserInput ( ) { \n; \nScanner in = new Scanner ( System . in ) ; \nin . nextLine ( ) ; \nin . close ( ) ; \n} \n} \n"}
{"9780": "public class Launcher { \nprivate static void printWelcomeBanner ( ) { \nStringBuffer banner = new StringBuffer ( ) ; \nbanner . append ( \"\\n\" ) ; \nbanner . append ( \"\\t============================\\n\" ) ; \nbanner . append ( \"\\t|                          |\\n\" ) ; \nbanner . append ( \"\\t|   Welcome to ChameRIA    |\\n\" ) ; \nbanner . append ( \"\\t|                          |\\n\" ) ; \nbanner . append ( \"\\t============================\\n\" ) ; \nbanner . append ( \"\\n\" ) ; \n; \n} \n} \n"}
{"9781": "public class Launcher { \nprivate static void printStoppedBanner ( ) { \n; \n; \n; \n; \n; \n} \n} \n"}
{"9887": "public class StartHELM2Parser { \npublic static void main ( String [ ] args ) throws ParseException , ExceptionState , IOException { \nOptions options = new Options ( ) ; \noptions . addOption ( \"inputHELM\" , true , \"HELM1 or HELM2 string in a file\" ) ; \noptions . addOption ( \"output\" , true , \"output can be in JSON- or HELM2-format\" ) ; \noptions . addOption ( \"translate\" , false , \"translate HELM1 to HELM2\" ) ; \nCommandLineParser parameter = new DefaultParser ( ) ; \ntry { \nCommandLine cmd = parameter . parse ( options , args ) ; \nString filename = cmd . getOptionValue ( \"inputHELM\" ) ; \nParserHELM2 parser = new ParserHELM2 ( ) ; \nFileReader in = new FileReader ( filename ) ; \nBufferedReader br = new BufferedReader ( in ) ; \nString line ; \nString helm ; \ntry { \nwhile ( ( line = br . readLine ( ) ) != null ) { \nhelm = line ; \nif ( cmd . hasOption ( \"translate\" ) ) { \nConverterHELM1ToHELM2 converter = new ConverterHELM1ToHELM2 ( ) ; \nhelm = converter . doConvert ( helm ) ; \nLOG . info ( \"HELM1 is translated to HELM2\" ) ; \n} \nparser . parse ( helm ) ; \nString output = \"\" ; \nif ( cmd . getOptionValue ( \"output\" ) . equals ( \"HELM2\" ) ) { \noutput = parser . getHELM2Notation ( ) . toHELM2 ( ) ; \n} \nelse if ( cmd . getOptionValue ( \"output\" ) . equals ( \"JSON\" ) ) { \noutput = parser . getJSON ( ) ; \n} \n; \n} \n} \nfinally { \nbr . close ( ) ; \n} \n} \ncatch ( NullPointerException e ) { \n; \n} \ncatch ( ParseException exp ) { \n; \n} \n} \n} \n"}
{"10077": "public class ArgumentHandler { \npublic static < A > A readArguments ( Class < A > interfaceClass , String [ ] args ) { \nA result = null ; \ntry { \nfinal ArgumentHandler argumentHandler = new ArgumentHandler ( args ) ; \nresult = argumentHandler . getInstance ( interfaceClass ) ; \nargumentHandler . processArguments ( new ArgumentProcessor ( ) { \n@ Override public void process ( List < String > remaining ) throws InvalidArgumentsException { \nif ( remaining . size ( ) > 0 ) { \nthrow new InvalidArgumentsException ( \"The following arguments could not be understood: \" + remaining ) ; \n} \n} \n} \n) ; \n} \ncatch ( InvalidArgumentsException e ) { \n; \nshowUsage ( interfaceClass ) ; \nresult = null ; \n} \nif ( result instanceof ArgumentsWithHelp ) { \nif ( ( ( ArgumentsWithHelp ) result ) . getHelp ( ) ) { \nshowUsage ( interfaceClass ) ; \nresult = null ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10127": "public class ConsoleAuthProvider { \n@ Override public String getAuthorization ( String authorizationUrl ) throws CubeSensorsException { \n; \n; \ntry ( Scanner in = new Scanner ( System . in ) ) { \nString authorization = in . nextLine ( ) ; \nreturn authorization ; \n} \n} \n} \n"}
{"10158": "public class DebugOutputStream { \nprotected void dumpByte ( int b ) { \nif ( passThrough == true ) { \n; \n} \nif ( b < 0 ) { \nb += 128 ; \n} \nif ( b < 0x10 ) { \n; \n} \n; \n; \n} \n} \n"}
{"10172": "public class BaseSourceFile { \npublic InputStream makeInStream ( ) { \nif ( m_InputStream != null ) return m_InputStream ; \ntry { \nreturn new FileInputStream ( m_inputFile ) ; \n} \ncatch ( FileNotFoundException ex ) { \n; \n} \nreturn null ; \n} \n} \n"}
{"10499": "public class ResolutionInterpreter { \nprivate void printIntroduction ( ) { \n; \n; \n; \n; \n; \n} \n} \n"}
{"10502": "public class ResolutionInterpreter { \nprivate void evaluateQuery ( ) { \nIterator < Set < Variable > > i = engine . iterator ( ) ; \nif ( ! i . hasNext ( ) ) { \n; \nreturn ; \n} \nfor ( ; \ni . hasNext ( ) ; \n) { \nSet < Variable > solution = i . next ( ) ; \nif ( solution . isEmpty ( ) ) { \n; \n} \nelse { \nfor ( Iterator < Variable > j = solution . iterator ( ) ; \nj . hasNext ( ) ; \n) { \nVariable nextVar = j . next ( ) ; \nString varName = engine . getVariableName ( nextVar . getName ( ) ) ; \n; \nif ( j . hasNext ( ) ) { \n; \n} \n} \n} \nif ( ! i . hasNext ( ) ) { \n; \nbreak ; \n} \ntry { \nint key = consoleReader . readVirtualKey ( ) ; \nif ( key == SEMICOLON ) { \n; \n} \nelse { \n; \nbreak ; \n} \n} \ncatch ( IOException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n} \n"}
{"10733": "public class ConsoleDebugger { \nprivate void createDebug ( ) { \nObservableReader debugReader = new ObservableReader ( reader ) ; \nreaderListener = new ReaderListener ( ) { \npublic void read ( String str ) { \n; \n} \n} \n; \ndebugReader . addReaderListener ( readerListener ) ; \nObservableWriter debugWriter = new ObservableWriter ( writer ) ; \nwriterListener = new WriterListener ( ) { \npublic void write ( String str ) { \n; \n} \n} \n; \ndebugWriter . addWriterListener ( writerListener ) ; \nreader = debugReader ; \nwriter = debugWriter ; \nlistener = new PacketListener ( ) { \npublic void processPacket ( Packet packet ) { \nif ( printInterpreted ) { \n; \n} \n} \n} \n; \nconnListener = new ConnectionListener ( ) { \npublic void connectionClosed ( ) { \n; \n} \npublic void connectionClosedOnError ( Exception e ) { \n; \ne . printStackTrace ( ) ; \n} \npublic void reconnectionFailed ( Exception e ) { \n; \ne . printStackTrace ( ) ; \n} \npublic void reconnectionSuccessful ( ) { \n; \n} \npublic void reconnectingIn ( int seconds ) { \n; \n} \n} \n; \n} \n} \n"}
{"10892": "public class ExecS { \nprotected final void printList ( ) { \nST list = this . stg . getInstanceOf ( \"list\" ) ; \nlist . add ( \"appName\" , this . appName ) ; \nif ( this . classmap . size ( ) > 0 ) { \nList < Map < String , String > > l = new ArrayList < > ( ) ; \nfor ( String key : this . classmap . keySet ( ) ) { \nMap < String , String > m = new HashMap < > ( ) ; \nm . put ( \"key\" , key ) ; \nm . put ( \"val\" , this . classmap . get ( key ) . getName ( ) ) ; \nl . add ( m ) ; \n} \nlist . add ( \"classMap\" , l ) ; \n} \nlist . add ( \"className\" , this . classNames ) ; \n; \n} \n} \n"}
{"10893": "public class ExecS { \nprotected final void printUsage ( ) { \nST usage = this . stg . getInstanceOf ( \"usage\" ) ; \nusage . add ( \"appName\" , this . appName ) ; \nusage . add ( \"packageFilter\" , this . packageFilter ) ; \nusage . add ( \"jarFilter\" , this . jarFilter ) ; \nusage . add ( \"excludedNames\" , new TreeSet < > ( Arrays . asList ( new CF ( ) . excludedNames ) ) ) ; \n; \n} \n} \n"}
