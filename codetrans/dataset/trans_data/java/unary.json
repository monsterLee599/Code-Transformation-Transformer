{"38": "public class LinkedArrayList { \npublic void add ( Object o ) { \nif ( size == 0 ) { \nhead = new Object [ capacityHint + 1 ] ; \ntail = head ; \nhead [ 0 ] = o ; \nindexInTail = 1 ; \nsize = 1 ; \n} \nelse if ( indexInTail == capacityHint ) { \nObject [ ] t = new Object [ capacityHint + 1 ] ; \nt [ 0 ] = o ; \ntail [ capacityHint ] = t ; \ntail = t ; \nindexInTail = 1 ; \nsize = size + 1 ; \n} \nelse { \ntail [ indexInTail ] = o ; \nindexInTail = indexInTail + 1 ; \nsize = size + 1 ; \n} \n} \n} \n"}
{"44": "public class ExceptionHelper { \npublic static List < Throwable > flatten ( Throwable t ) { \nList < Throwable > list = new ArrayList < Throwable > ( ) ; \nArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; \ndeque . offer ( t ) ; \nwhile ( ! deque . isEmpty ( ) ) { \nThrowable e = deque . removeFirst ( ) ; \nif ( e instanceof CompositeException ) { \nCompositeException ce = ( CompositeException ) e ; \nList < Throwable > exceptions = ce . getExceptions ( ) ; \nfor ( int i = exceptions . size ( ) - 1 ; \ni >= 0 ; \ni = i - 1 ) { \ndeque . offerFirst ( exceptions . get ( i ) ) ; \n} \n} \nelse { \nlist . add ( e ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"50": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Subscriber < ? super U > subscriber ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nwhile ( a != null ) { \nfor ( int i = 0 ; \ni < c ; \ni = i + 1 ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , subscriber ) ) { \nreturn true ; \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"51": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Observer < ? super U > observer ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nwhile ( a != null ) { \nfor ( int i = 0 ; \ni < c ; \ni = i + 1 ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , observer ) ) { \nreturn true ; \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"65": "public class PublishSubject { \n@ SuppressWarnings ( \"unchecked\" ) void remove ( PublishDisposable < T > ps ) { \nfor ( ; \n; \n) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED || a == EMPTY ) { \nreturn ; \n} \nint n = a . length ; \nint j = - 1 ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nif ( a [ i ] == ps ) { \nj = i ; \nbreak ; \n} \n} \nif ( j < 0 ) { \nreturn ; \n} \nPublishDisposable < T > [ ] b ; \nif ( n == 1 ) { \nb = EMPTY ; \n} \nelse { \nb = new PublishDisposable [ n - 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , j ) ; \nSystem . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; \n} \nif ( subscribers . compareAndSet ( a , b ) ) { \nreturn ; \n} \n} \n} \n} \n"}
{"86": "public class SpringSecurityLdapTemplate { \npublic Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { \nObject [ ] encodedParams = new String [ params . length ] ; \nfor ( int i = 0 ; \ni < params . length ; \ni = i + 1 ) { \nencodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; \n} \nString formattedFilter = MessageFormat . format ( filter , encodedParams ) ; \nlogger . debug ( \"Using filter: \" + formattedFilter ) ; \nfinal HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; \nContextMapper roleMapper = new ContextMapper ( ) { \npublic Object mapFromContext ( Object ctx ) { \nDirContextAdapter adapter = ( DirContextAdapter ) ctx ; \nMap < String , List < String > > record = new HashMap < String , List < String > > ( ) ; \nif ( attributeNames == null || attributeNames . length == 0 ) { \ntry { \nfor ( NamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; \nae . hasMore ( ) ; \n) { \nAttribute attr = ( Attribute ) ae . next ( ) ; \nextractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; \n} \n} \ncatch ( NamingException x ) { \norg . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; \n} \n} \nelse { \nfor ( String attributeName : attributeNames ) { \nextractStringAttributeValues ( adapter , record , attributeName ) ; \n} \n} \nrecord . put ( DN_KEY , Arrays . asList ( getAdapterDN ( adapter ) ) ) ; \nset . add ( record ) ; \nreturn null ; \n} \n} \n; \nSearchControls ctls = new SearchControls ( ) ; \nctls . setSearchScope ( searchControls . getSearchScope ( ) ) ; \nctls . setReturningAttributes ( attributeNames != null && attributeNames . length > 0 ? attributeNames : null ) ; \nsearch ( base , formattedFilter , ctls , roleMapper ) ; \nreturn set ; \n} \n} \n"}
{"89": "public class BasicLookupStrategy { \nprivate void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { \nAssert . notNull ( acls , \"ACLs are required\" ) ; \nAssert . notEmpty ( findNow , \"Items to find now required\" ) ; \nString sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; \nSet < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { \npublic void setValues ( PreparedStatement ps ) throws SQLException { \nint i = 0 ; \nfor ( Long toFind : findNow ) { \ni = i + 1 ; \nps . setLong ( i , toFind ) ; \n} \n} \n} \n, new ProcessResultSet ( acls , sids ) ) ; \nif ( parentsToLookup . size ( ) > 0 ) { \nlookupPrimaryKeys ( acls , parentsToLookup , sids ) ; \n} \n} \n} \n"}
{"110": "public class AbstractRememberMeServices { \nprotected String encodeCookie ( String [ ] cookieTokens ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < cookieTokens . length ; \ni = i + 1 ) { \ntry { \nsb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nif ( i < cookieTokens . length - 1 ) { \nsb . append ( DELIMITER ) ; \n} \n} \nString value = sb . toString ( ) ; \nsb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; \nwhile ( sb . charAt ( sb . length ( ) - 1 ) == '=' ) { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"147": "public class UrlAuthorizationConfigurer { \nprivate static String [ ] hasAnyRole ( String ... roles ) { \nfor ( int i = 0 ; \ni < roles . length ; \ni = i + 1 ) { \nroles [ i ] = \"ROLE_\" + roles [ i ] ; \n} \nreturn roles ; \n} \n} \n"}
{"170": "public class AnnotationParameterNameDiscoverer { \nprivate < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { \nAnnotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; \nint parameterCount = parameterAnnotations . length ; \nString [ ] paramNames = new String [ parameterCount ] ; \nboolean found = false ; \nfor ( int i = 0 ; \ni < parameterCount ; \ni = i + 1 ) { \nAnnotation [ ] annotations = parameterAnnotations [ i ] ; \nString parameterName = findParameterName ( annotations ) ; \nif ( parameterName != null ) { \nfound = true ; \nparamNames [ i ] = parameterName ; \n} \n} \nreturn found ? paramNames : null ; \n} \n} \n"}
{"190": "public class StandardPasswordEncoder { \nprivate boolean matches ( byte [ ] expected , byte [ ] actual ) { \nif ( expected . length != actual . length ) { \nreturn false ; \n} \nint result = 0 ; \nfor ( int i = 0 ; \ni < expected . length ; \ni = i + 1 ) { \nresult |= expected [ i ] ^ actual [ i ] ; \n} \nreturn result == 0 ; \n} \n} \n"}
{"213": "public class JaasAuthenticationProvider { \nprivate void configureJaasUsingLoop ( ) throws IOException { \nString loginConfigUrl = convertLoginConfigToUrl ( ) ; \nboolean alreadySet = false ; \nint n = 1 ; \nfinal String prefix = \"login.config.url.\" ; \nString existing ; \nwhile ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { \nalreadySet = existing . equals ( loginConfigUrl ) ; \nif ( alreadySet ) { \nbreak ; \n} \nn = n + 1 ; \n} \nif ( ! alreadySet ) { \nString key = prefix + n ; \nlog . debug ( \"Setting security property [\" + key + \"] to: \" + loginConfigUrl ) ; \nSecurity . setProperty ( key , loginConfigUrl ) ; \n} \n} \n} \n"}
{"215": "public class FastHttpDateFormat { \nprivate static Long internalParseDate ( String value , DateFormat [ ] formats ) { \nDate date = null ; \nfor ( int i = 0 ; \n( date == null ) && ( i < formats . length ) ; \ni = i + 1 ) { \ntry { \ndate = formats [ i ] . parse ( value ) ; \n} \ncatch ( ParseException ignored ) { \n} \n} \nif ( date == null ) { \nreturn null ; \n} \nreturn new Long ( date . getTime ( ) ) ; \n} \n} \n"}
{"319": "public class SingleParameterInjector { \nstatic Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { \nif ( parameterInjectors == null ) { \nreturn NO_ARGUMENTS ; \n} \nint size = parameterInjectors . length ; \nObject [ ] parameters = new Object [ size ] ; \nfor ( int i = 0 ; \ni < size ; \ni = i + 1 ) { \nparameters [ i ] = parameterInjectors [ i ] . inject ( context ) ; \n} \nreturn parameters ; \n} \n} \n"}
{"326": "public class TypeLiteral { \nprivate List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { \nTypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; \nfor ( int t = 0 ; \nt < types . length ; \nt = t + 1 ) { \nresult [ t ] = resolve ( types [ t ] ) ; \n} \nreturn ImmutableList . copyOf ( result ) ; \n} \n} \n"}
{"352": "public class Message { \nprivate Object writeReplace ( ) throws ObjectStreamException { \nObject [ ] sourcesAsStrings = sources . toArray ( ) ; \nfor ( int i = 0 ; \ni < sourcesAsStrings . length ; \ni = i + 1 ) { \nsourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; \n} \nreturn new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; \n} \n} \n"}
{"356": "public class FactoryProvider2 { \nprivate boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { \nList < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; \nAnnotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; \nint p = 0 ; \nList < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; \nfor ( TypeLiteral < ? > param : params ) { \nKey < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p = p + 1 ] , errors ) ; \nconstructorKeys . add ( paramKey ) ; \n} \nfor ( Key < ? > key : paramList ) { \nif ( ! constructorKeys . remove ( key ) ) { \nreturn false ; \n} \n} \nfor ( Key < ? > key : constructorKeys ) { \nif ( key . getAnnotationType ( ) == Assisted . class ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"360": "public class FactoryProvider2 { \npublic Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { \ncheckState ( injector != null , \"Factories.create() factories cannot be used until they're initialized by Guice.\" ) ; \nfinal Key < ? > returnType = data . returnType ; \nfinal Key < ? > returnKey = Key . get ( returnType . getTypeLiteral ( ) , RETURN_ANNOTATION ) ; \nModule assistedModule = new AbstractModule ( ) { \n@ Override @ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) protected void configure ( ) { \nBinder binder = binder ( ) . withSource ( method ) ; \nint p = 0 ; \nif ( ! data . optimized ) { \nfor ( Key < ? > paramKey : data . paramTypes ) { \nbinder . bind ( ( Key ) paramKey ) . toProvider ( Providers . of ( args [ p = p + 1 ] ) ) ; \n} \n} \nelse { \nfor ( Key < ? > paramKey : data . paramTypes ) { \nbinder . bind ( ( Key ) paramKey ) . toProvider ( data . providers . get ( p = p + 1 ) ) ; \n} \n} \nConstructor constructor = data . constructor ; \nif ( constructor != null ) { \nbinder . bind ( returnKey ) . toConstructor ( constructor , ( TypeLiteral ) data . implementationType ) . in ( Scopes . NO_SCOPE ) ; \n} \n} \n} \n; \nInjector forCreate = injector . createChildInjector ( assistedModule ) ; \nBinding < ? > binding = forCreate . getBinding ( returnKey ) ; \nif ( data . optimized ) { \ndata . cachedBinding = binding ; \n} \nreturn binding ; \n} \n} \n"}
{"361": "public class FactoryProvider2 { \n@ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { \nif ( methodHandleByMethod . containsKey ( method ) ) { \nreturn methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; \n} \nif ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { \nif ( \"equals\" . equals ( method . getName ( ) ) ) { \nreturn proxy == args [ 0 ] ; \n} \nelse if ( \"hashCode\" . equals ( method . getName ( ) ) ) { \nreturn System . identityHashCode ( proxy ) ; \n} \nelse { \nreturn method . invoke ( this , args ) ; \n} \n} \nAssistData data = assistDataByMethod . get ( method ) ; \ncheckState ( data != null , \"No data for method: %s\" , method ) ; \nProvider < ? > provider ; \nif ( data . cachedBinding != null ) { \nprovider = data . cachedBinding . getProvider ( ) ; \n} \nelse { \nprovider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; \n} \ntry { \nint p = 0 ; \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . set ( args [ p = p + 1 ] ) ; \n} \nreturn provider . get ( ) ; \n} \ncatch ( ProvisionException e ) { \nif ( e . getErrorMessages ( ) . size ( ) == 1 ) { \nMessage onlyError = getOnlyElement ( e . getErrorMessages ( ) ) ; \nThrowable cause = onlyError . getCause ( ) ; \nif ( cause != null && canRethrow ( method , cause ) ) { \nthrow cause ; \n} \n} \nthrow e ; \n} \nfinally { \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . remove ( ) ; \n} \n} \n} \n} \n"}
{"362": "public class Errors { \n< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( format ( \"No implementation for %s was bound.\" , key ) ) ; \nList < String > possibleMatches = new ArrayList < > ( ) ; \nTypeLiteral < T > type = key . getTypeLiteral ( ) ; \nList < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; \nif ( ! sameTypes . isEmpty ( ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nint howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; \nfor ( int i = 0 ; \ni < howMany ; \ni = i + 1 ) { \nsb . append ( format ( \"%n    * %s\" , sameTypes . get ( i ) . getKey ( ) ) ) ; \n} \nint remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; \nif ( remaining > 0 ) { \nString plural = ( remaining == 1 ) ? \"\" : \"s\" ; \nsb . append ( format ( \"%n    %d more binding%s with other annotations.\" , remaining , plural ) ) ; \n} \n} \nelse { \nString want = type . toString ( ) ; \nMap < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; \nfor ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { \nString have = bindingKey . getTypeLiteral ( ) . toString ( ) ; \nif ( have . contains ( want ) || want . contains ( have ) ) { \nFormatter fmt = new Formatter ( ) ; \nMessages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; \nString match = String . format ( \"%s bound%s\" , convert ( bindingKey ) , fmt . toString ( ) ) ; \npossibleMatches . add ( match ) ; \nif ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) { \nbreak ; \n} \n} \n} \nif ( ( possibleMatches . size ( ) > 0 ) && ( possibleMatches . size ( ) <= MAX_RELATED_TYPES_REPORTED ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nfor ( String possibleMatch : possibleMatches ) { \nsb . append ( format ( \"%n    %s\" , possibleMatch ) ) ; \n} \n} \n} \nif ( sameTypes . isEmpty ( ) && possibleMatches . isEmpty ( ) && key . getAnnotation ( ) == null && COMMON_AMBIGUOUS_TYPES . contains ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { \nsb . append ( format ( \"%nThe key seems very generic, did you forget an annotation?\" ) ) ; \n} \nreturn addMessage ( sb . toString ( ) ) ; \n} \n} \n"}
{"365": "public class FilterChainInvocation { \nprivate Filter findNextFilter ( HttpServletRequest request ) { \nwhile ( index = index + 1 < filterDefinitions . length ) { \nFilter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; \nif ( filter != null ) { \nreturn filter ; \n} \n} \nreturn null ; \n} \n} \n"}
{"384": "public class Messages { \npublic static String formatMessages ( String heading , Collection < Message > errorMessages ) { \nFormatter fmt = new Formatter ( ) . format ( heading ) . format ( \":%n%n\" ) ; \nint index = 1 ; \nboolean displayCauses = getOnlyCause ( errorMessages ) == null ; \nMap < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; \nfor ( Message errorMessage : errorMessages ) { \nint thisIdx = index = index + 1 ; \nfmt . format ( \"%s) %s%n\" , thisIdx , errorMessage . getMessage ( ) ) ; \nList < Object > dependencies = errorMessage . getSources ( ) ; \nfor ( int i = dependencies . size ( ) - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nObject source = dependencies . get ( i ) ; \nformatSource ( fmt , source ) ; \n} \nThrowable cause = errorMessage . getCause ( ) ; \nif ( displayCauses && cause != null ) { \nEquivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; \nif ( ! causes . containsKey ( causeEquivalence ) ) { \ncauses . put ( causeEquivalence , thisIdx ) ; \nfmt . format ( \"Caused by: %s\" , Throwables . getStackTraceAsString ( cause ) ) ; \n} \nelse { \nint causeIdx = causes . get ( causeEquivalence ) ; \nfmt . format ( \"Caused by: %s (same stack trace as error #%s)\" , cause . getClass ( ) . getName ( ) , causeIdx ) ; \n} \n} \nfmt . format ( \"%n\" ) ; \n} \nif ( errorMessages . size ( ) == 1 ) { \nfmt . format ( \"1 error\" ) ; \n} \nelse { \nfmt . format ( \"%s errors\" , errorMessages . size ( ) ) ; \n} \nreturn fmt . toString ( ) ; \n} \n} \n"}
{"411": "public class DefaultConnectionManager { \nprivate void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { \nfinal int actualNum = pool . size ( ) ; \nfinal int expectNum = url . getConnNum ( ) ; \nif ( actualNum < expectNum ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"actual num {}, expect num {}, task name {}\" , actualNum , expectNum , taskName ) ; \n} \nif ( url . isConnWarmup ( ) ) { \nfor ( int i = actualNum ; \ni < expectNum ; \ni = i + 1 ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \n} \nelse { \nif ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { \nthrow new IllegalArgumentException ( \"sync create number when not warmup should be [0,\" + url . getConnNum ( ) + \"]\" ) ; \n} \nif ( syncCreateNumWhenNotWarmup > 0 ) { \nfor ( int i = 0 ; \ni < syncCreateNumWhenNotWarmup ; \ni = i + 1 ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \nif ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) { \nreturn ; \n} \n} \ninitializeExecutor ( ) ; \npool . markAsyncCreationStart ( ) ; \ntry { \nthis . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { \n@ Override public void run ( ) { \ntry { \nfor ( int i = pool . size ( ) ; \ni < url . getConnNum ( ) ; \ni = i + 1 ) { \nConnection conn = null ; \ntry { \nconn = create ( url ) ; \n} \ncatch ( RemotingException e ) { \nlogger . error ( \"Exception occurred in async create connection thread for {}, taskName {}\" , url . getUniqueKey ( ) , taskName , e ) ; \n} \npool . add ( conn ) ; \n} \n} \nfinally { \npool . markAsyncCreationDone ( ) ; \n} \n} \n} \n) ; \n} \ncatch ( RejectedExecutionException e ) { \npool . markAsyncCreationDone ( ) ; \nthrow e ; \n} \n} \n} \n} \n} \n"}
{"426": "public class ProtocolSwitch { \npublic static byte toByte ( BitSet bs ) { \nint value = 0 ; \nfor ( int i = 0 ; \ni < bs . length ( ) ; \ni = i + 1 ) { \nif ( bs . get ( i ) ) { \nvalue += 1 << i ; \n} \n} \nif ( bs . length ( ) > 7 ) { \nthrow new IllegalArgumentException ( \"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \n} \nreturn ( byte ) value ; \n} \n} \n"}
{"427": "public class ProtocolSwitch { \npublic static BitSet toBitSet ( int value ) { \nif ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { \nthrow new IllegalArgumentException ( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \n} \nBitSet bs = new BitSet ( ) ; \nint index = 0 ; \nwhile ( value != 0 ) { \nif ( value % 2 != 0 ) { \nbs . set ( index ) ; \n} \nindex = index + 1 ; \nvalue = ( byte ) ( value >> 1 ) ; \n} \nreturn bs ; \n} \n} \n"}
{"438": "public class RandomSelectStrategy { \nprivate Connection randomGet ( List < Connection > conns ) { \nif ( null == conns || conns . isEmpty ( ) ) { \nreturn null ; \n} \nint size = conns . size ( ) ; \nint tries = 0 ; \nConnection result = null ; \nwhile ( ( result == null || ! result . isFine ( ) ) && tries = tries + 1 < MAX_TIMES ) { \nresult = conns . get ( this . random . nextInt ( size ) ) ; \n} \nif ( result != null && ! result . isFine ( ) ) { \nresult = null ; \n} \nreturn result ; \n} \n} \n"}
{"561": "public class BuildDocHandlerFactory { \npublic static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { \nassert ( files . length == baseDirs . length ) ; \nFileRepository [ ] repositories = new FileRepository [ files . length ] ; \nList < JarFile > jarFiles = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni = i + 1 ) { \nFile file = files [ i ] ; \nString baseDir = baseDirs [ i ] ; \nif ( file . isDirectory ( ) ) { \nrepositories [ i ] = new FilesystemRepository ( file ) ; \n} \nelse { \nJarFile jarFile = new JarFile ( file ) ; \njarFiles . add ( jarFile ) ; \nrepositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; \n} \n} \nreturn new DocumentationHandler ( new AggregateFileRepository ( repositories ) , ( ) -> { \nfor ( JarFile jarFile : jarFiles ) { \njarFile . close ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"593": "public class ClassUtils { \npublic static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { \nif ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { \nreturn false ; \n} \nif ( classArray == null ) { \nclassArray = EMPTY_CLASS_ARRAY ; \n} \nif ( toClassArray == null ) { \ntoClassArray = EMPTY_CLASS_ARRAY ; \n} \nfor ( int i = 0 ; \ni < classArray . length ; \ni = i + 1 ) { \nif ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"649": "public class MemberUtils { \nprivate static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { \nfloat cost = 0.0f ; \nClass < ? > cls = srcClass ; \nif ( ! cls . isPrimitive ( ) ) { \ncost += 0.1f ; \ncls = ClassUtils . wrapperToPrimitive ( cls ) ; \n} \nfor ( int i = 0 ; \ncls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ; \ni = i + 1 ) { \nif ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { \ncost += 0.1f ; \nif ( i < ORDERED_PRIMITIVE_TYPES . length - 1 ) { \ncls = ORDERED_PRIMITIVE_TYPES [ i + 1 ] ; \n} \n} \n} \nreturn cost ; \n} \n} \n"}
{"650": "public class MemberUtils { \nprivate static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { \nfinal Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; \nfinal boolean isVarArgs = executable . isVarArgs ( ) ; \nfloat totalCost = 0.0f ; \nfinal long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; \nif ( srcArgs . length < normalArgsLen ) { \nreturn Float . MAX_VALUE ; \n} \nfor ( int i = 0 ; \ni < normalArgsLen ; \ni = i + 1 ) { \ntotalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; \n} \nif ( isVarArgs ) { \nfinal boolean noVarArgsPassed = srcArgs . length < destArgs . length ; \nfinal boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; \nfinal float varArgsCost = 0.001f ; \nfinal Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; \nif ( noVarArgsPassed ) { \ntotalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; \n} \nelse if ( explicitArrayForVarags ) { \nfinal Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; \ntotalCost += getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; \n} \nelse { \nfor ( int i = destArgs . length - 1 ; \ni < srcArgs . length ; \ni = i + 1 ) { \nfinal Class < ? > srcClass = srcArgs [ i ] ; \ntotalCost += getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; \n} \n} \n} \nreturn totalCost ; \n} \n} \n"}
{"651": "public class MemberUtils { \nprivate static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { \nif ( destClass . isPrimitive ( ) ) { \nreturn getPrimitivePromotionCost ( srcClass , destClass ) ; \n} \nfloat cost = 0.0f ; \nwhile ( srcClass != null && ! destClass . equals ( srcClass ) ) { \nif ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { \ncost += 0.25f ; \nbreak ; \n} \ncost = cost + 1 ; \nsrcClass = srcClass . getSuperclass ( ) ; \n} \nif ( srcClass == null ) { \ncost += 1.5f ; \n} \nreturn cost ; \n} \n} \n"}
{"674": "public class ReflectUtils { \npublic static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { \nMap map = new HashMap ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni = i + 1 ) { \nMethod method = methods [ i ] ; \nmap . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; \n} \nMethod [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; \nfor ( int i = 0 ; \ni < result . length ; \ni = i + 1 ) { \nresult [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; \nif ( result [ i ] == null ) { \n} \n} \nreturn result ; \n} \n} \n"}
{"700": "public class Handler { \nstatic int getExceptionTableLength ( final Handler firstHandler ) { \nint length = 0 ; \nHandler handler = firstHandler ; \nwhile ( handler != null ) { \nlength = length + 1 ; \nhandler = handler . nextHandler ; \n} \nreturn length ; \n} \n} \n"}
{"720": "public class RequestScope { \nprotected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { \nfinal boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( \"GET\" ) ; \nfinal Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nString [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; \nparamValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; \nif ( paramValues != null ) { \nif ( encode ) { \nfor ( int j = 0 ; \nj < paramValues . length ; \nj = j + 1 ) { \nfinal String p = paramValues [ j ] ; \nif ( p != null ) { \nfinal String encoding = madvocEncoding . getEncoding ( ) ; \nparamValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; \n} \n} \n} \nfinal Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n} \n) ; \n} \n} \n} \n"}
{"721": "public class RequestScope { \nprotected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { \nif ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { \nreturn ; \n} \nfinal MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; \nif ( ! multipartRequest . isMultipart ( ) ) { \nreturn ; \n} \nfinal Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nfinal FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; \nif ( ignoreInvalidUploadFiles ) { \nfor ( int j = 0 ; \nj < paramValues . length ; \nj = j + 1 ) { \nfinal FileUpload paramValue = paramValues [ j ] ; \nif ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { \nparamValues [ j ] = null ; \n} \n} \n} \nfinal Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"723": "public class ColumnNamingStrategy { \npublic String convertColumnNameToPropertyName ( final String columnName ) { \nStringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; \nint len = columnName . length ( ) ; \nif ( splitCamelCase ) { \nboolean toUpper = false ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nchar c = columnName . charAt ( i ) ; \nif ( c == separatorChar ) { \ntoUpper = true ; \ncontinue ; \n} \nif ( toUpper ) { \npropertyName . append ( Character . toUpperCase ( c ) ) ; \ntoUpper = false ; \n} \nelse { \npropertyName . append ( Character . toLowerCase ( c ) ) ; \n} \n} \nreturn propertyName . toString ( ) ; \n} \nreturn columnName ; \n} \n} \n"}
{"752": "public class Base64 { \npublic static byte [ ] decode ( final char [ ] arr ) { \nint length = arr . length ; \nif ( length == 0 ) { \nreturn new byte [ 0 ] ; \n} \nint sndx = 0 , endx = length - 1 ; \nint pad = arr [ endx ] == '=' ? ( arr [ endx - 1 ] == '=' ? 2 : 1 ) : 0 ; \nint cnt = endx - sndx + 1 ; \nint sepCnt = length > 76 ? ( arr [ 76 ] == '\\r' ? cnt / 78 : 0 ) << 1 : 0 ; \nint len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; \nbyte [ ] dest = new byte [ len ] ; \nint d = 0 ; \nfor ( int cc = 0 , eLen = ( len / 3 ) * 3 ; \nd < eLen ; \n) { \nint i = INV [ arr [ sndx = sndx + 1 ] ] << 18 | INV [ arr [ sndx = sndx + 1 ] ] << 12 | INV [ arr [ sndx = sndx + 1 ] ] << 6 | INV [ arr [ sndx = sndx + 1 ] ] ; \ndest [ d = d + 1 ] = ( byte ) ( i >> 16 ) ; \ndest [ d = d + 1 ] = ( byte ) ( i >> 8 ) ; \ndest [ d = d + 1 ] = ( byte ) i ; \nif ( sepCnt > 0 && cc = cc + 1 == 19 ) { \nsndx += 2 ; \ncc = 0 ; \n} \n} \nif ( d < len ) { \nint i = 0 ; \nfor ( int j = 0 ; \nsndx <= endx - pad ; \nj = j + 1 ) { \ni |= INV [ arr [ sndx = sndx + 1 ] ] << ( 18 - j * 6 ) ; \n} \nfor ( int r = 16 ; \nd < len ; \nr -= 8 ) { \ndest [ d = d + 1 ] = ( byte ) ( i >> r ) ; \n} \n} \nreturn dest ; \n} \n} \n"}
{"769": "public class PetiteBeans { \npublic void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( initMethodNames == null ) { \ninitMethodNames = StringPool . EMPTY_ARRAY ; \n} \nint total = initMethodNames . length ; \nInitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; \nint i ; \nfor ( i = 0 ; \ni < initMethodNames . length ; \ni = i + 1 ) { \nMethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Init method not found: \" + beanDefinition . type . getName ( ) + '#' + initMethodNames [ i ] ) ; \n} \ninitMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; \n} \nbeanDefinition . addInitMethodPoints ( initMethodPoints ) ; \n} \n} \n"}
{"770": "public class PetiteBeans { \npublic void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( destroyMethodNames == null ) { \ndestroyMethodNames = StringPool . EMPTY_ARRAY ; \n} \nint total = destroyMethodNames . length ; \nDestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; \nint i ; \nfor ( i = 0 ; \ni < destroyMethodNames . length ; \ni = i + 1 ) { \nMethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Destroy method not found: \" + beanDefinition . type . getName ( ) + '#' + destroyMethodNames [ i ] ) ; \n} \ndestroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; \n} \nbeanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; \n} \n} \n"}
{"781": "public class ProxettaAsmUtil { \npublic static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nmv . visitVarInsn ( ALOAD , 0 ) ; \nfor ( int i = 1 ; \ni <= methodInfo . getArgumentsCount ( ) ; \ni = i + 1 ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n} \n"}
{"782": "public class ProxettaAsmUtil { \npublic static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nfor ( int i = 0 ; \ni < methodInfo . getArgumentsCount ( ) ; \ni = i + 1 ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n} \n"}
{"783": "public class ProxettaAsmUtil { \npublic static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nfor ( int i = 1 ; \ni <= methodInfo . getArgumentsCount ( ) ; \ni = i + 1 ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n} \n"}
{"802": "public class ServletUtil { \npublic static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { \nif ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { \nint emptyCount = 0 ; \nint total = paramValues . length ; \nfor ( int i = 0 ; \ni < paramValues . length ; \ni = i + 1 ) { \nString paramValue = paramValues [ i ] ; \nif ( paramValue == null ) { \nemptyCount = emptyCount + 1 ; \ncontinue ; \n} \nif ( paramValue . length ( ) == 0 ) { \nemptyCount = emptyCount + 1 ; \nif ( treatEmptyParamsAsNull ) { \nparamValue = null ; \n} \n} \nparamValues [ i ] = paramValue ; \n} \nif ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { \nreturn null ; \n} \n} \nreturn paramValues ; \n} \n} \n"}
{"809": "public class BeanData { \npublic Object newBeanInstance ( ) { \nif ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { \nthrow new PetiteException ( \"No constructor (annotated, single or default) founded as injection point for: \" + beanDefinition . type . getName ( ) ) ; \n} \nint paramNo = beanDefinition . ctor . references . length ; \nObject [ ] args = new Object [ paramNo ] ; \nif ( beanDefinition . wiringMode != WiringMode . NONE ) { \nfor ( int i = 0 ; \ni < paramNo ; \ni = i + 1 ) { \nargs [ i ] = pc . getBean ( beanDefinition . ctor . references [ i ] ) ; \nif ( args [ i ] == null ) { \nif ( ( beanDefinition . wiringMode == WiringMode . STRICT ) ) { \nthrow new PetiteException ( \"Wiring constructor failed. References '\" + beanDefinition . ctor . references [ i ] + \"' not found for constructor: \" + beanDefinition . ctor . constructor ) ; \n} \n} \n} \n} \nfinal Object bean ; \ntry { \nbean = beanDefinition . ctor . constructor . newInstance ( args ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Failed to create new bean instance '\" + beanDefinition . type . getName ( ) + \"' using constructor: \" + beanDefinition . ctor . constructor , ex ) ; \n} \nreturn bean ; \n} \n} \n"}
{"817": "public class PropsData { \npublic String resolveMacros ( String value , final String ... profiles ) { \nStringTemplateParser stringTemplateParser = new StringTemplateParser ( ) ; \nstringTemplateParser . setResolveEscapes ( false ) ; \nif ( ! ignoreMissingMacros ) { \nstringTemplateParser . setReplaceMissingKey ( false ) ; \n} \nelse { \nstringTemplateParser . setReplaceMissingKey ( true ) ; \nstringTemplateParser . setMissingKeyReplacement ( StringPool . EMPTY ) ; \n} \nfinal Function < String , String > macroResolver = macroName -> { \nString [ ] lookupProfiles = profiles ; \nint leftIndex = macroName . indexOf ( '<' ) ; \nif ( leftIndex != - 1 ) { \nint rightIndex = macroName . indexOf ( '>' ) ; \nString profiles1 = macroName . substring ( leftIndex + 1 , rightIndex ) ; \nmacroName = macroName . substring ( 0 , leftIndex ) . concat ( macroName . substring ( rightIndex + 1 ) ) ; \nlookupProfiles = StringUtil . splitc ( profiles1 , ',' ) ; \nStringUtil . trimAll ( lookupProfiles ) ; \n} \nreturn lookupValue ( macroName , lookupProfiles ) ; \n} \n; \nint loopCount = 0 ; \nwhile ( loopCount = loopCount + 1 < MAX_INNER_MACROS ) { \nfinal String newValue = stringTemplateParser . parse ( value , macroResolver ) ; \nif ( newValue . equals ( value ) ) { \nbreak ; \n} \nif ( skipEmptyProps ) { \nif ( newValue . length ( ) == 0 ) { \nreturn null ; \n} \n} \nvalue = newValue ; \n} \nreturn value ; \n} \n} \n"}
{"819": "public class BCrypt { \nprivate static int streamtoword ( byte [ ] data , int [ ] offp ) { \nint i ; \nint word = 0 ; \nint off = offp [ 0 ] ; \nfor ( i = 0 ; \ni < 4 ; \ni = i + 1 ) { \nword = ( word << 8 ) | ( data [ off ] & 0xff ) ; \noff = ( off + 1 ) % data . length ; \n} \noffp [ 0 ] = off ; \nreturn word ; \n} \n} \n"}
{"821": "public class BCrypt { \npublic static boolean checkpw ( String plaintext , String hashed ) { \nbyte [ ] hashed_bytes ; \nbyte [ ] try_bytes ; \ntry { \nString try_pw = hashpw ( plaintext , hashed ) ; \nhashed_bytes = hashed . getBytes ( \"UTF-8\" ) ; \ntry_bytes = try_pw . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \nreturn false ; \n} \nif ( hashed_bytes . length != try_bytes . length ) { \nreturn false ; \n} \nbyte ret = 0 ; \nfor ( int i = 0 ; \ni < try_bytes . length ; \ni = i + 1 ) { \nret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; \n} \nreturn ret == 0 ; \n} \n} \n"}
{"822": "public class MultipartRequestInputStream { \npublic int copyAll ( final OutputStream out ) throws IOException { \nint count = 0 ; \nwhile ( true ) { \nbyte b = readByte ( ) ; \nif ( isBoundary ( b ) ) { \nbreak ; \n} \nout . write ( b ) ; \ncount = count + 1 ; \n} \nreturn count ; \n} \n} \n"}
{"823": "public class MultipartRequestInputStream { \npublic int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { \nint count = 0 ; \nwhile ( true ) { \nbyte b = readByte ( ) ; \nif ( isBoundary ( b ) ) { \nbreak ; \n} \nout . write ( b ) ; \ncount = count + 1 ; \nif ( count == maxBytes ) { \nreturn count ; \n} \n} \nreturn count ; \n} \n} \n"}
{"832": "public class ActionMethodParser { \npublic ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { \nif ( actionHandler != null ) { \nreturn new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; \n} \nfinal ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ; \nfinal Class [ ] paramTypes = actionClassMethod . getParameterTypes ( ) ; \nfinal MethodParam [ ] params = new MethodParam [ paramTypes . length ] ; \nfinal Annotation [ ] [ ] paramAnns = actionClassMethod . getParameterAnnotations ( ) ; \nString [ ] methodParamNames = null ; \nfor ( int ndx = 0 ; \nndx < paramTypes . length ; \nndx = ndx + 1 ) { \nClass paramType = paramTypes [ ndx ] ; \nif ( methodParamNames == null ) { \nmethodParamNames = actionMethodParamNameResolver . resolveParamNames ( actionClassMethod ) ; \n} \nfinal String paramName = methodParamNames [ ndx ] ; \nfinal Annotation [ ] parameterAnnotations = paramAnns [ ndx ] ; \nfinal ScopeData paramsScopeData = scopeDataInspector . inspectMethodParameterScopes ( paramName , paramType , parameterAnnotations ) ; \nMapperFunction mapperFunction = null ; \nfor ( final Annotation annotation : parameterAnnotations ) { \nif ( annotation instanceof Mapper ) { \nmapperFunction = MapperFunctionInstances . get ( ) . lookup ( ( ( Mapper ) annotation ) . value ( ) ) ; \nbreak ; \n} \n} \nparams [ ndx ] = new MethodParam ( paramTypes [ ndx ] , paramName , scopeDataInspector . detectAnnotationType ( parameterAnnotations ) , paramsScopeData , mapperFunction ) ; \n} \nreturn new ActionRuntime ( null , actionClass , actionClassMethod , filters , interceptors , actionDefinition , actionResult , defaultActionResult , async , auth , scopeData , params ) ; \n} \n} \n"}
{"845": "public class SymbolTable { \nprivate void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) { \nbyte [ ] inputBytes = classReader . b ; \nint currentAttributeOffset = classReader . getFirstAttributeOffset ( ) ; \nfor ( int i = classReader . readUnsignedShort ( currentAttributeOffset - 2 ) ; \ni > 0 ; \ni = i - 1 ) { \nString attributeName = classReader . readUTF8 ( currentAttributeOffset , charBuffer ) ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \nbootstrapMethodCount = classReader . readUnsignedShort ( currentAttributeOffset + 6 ) ; \nbreak ; \n} \ncurrentAttributeOffset += 6 + classReader . readInt ( currentAttributeOffset + 2 ) ; \n} \nif ( bootstrapMethodCount > 0 ) { \nint bootstrapMethodsOffset = currentAttributeOffset + 8 ; \nint bootstrapMethodsLength = classReader . readInt ( currentAttributeOffset + 2 ) - 2 ; \nbootstrapMethods = new ByteVector ( bootstrapMethodsLength ) ; \nbootstrapMethods . putByteArray ( inputBytes , bootstrapMethodsOffset , bootstrapMethodsLength ) ; \nint currentOffset = bootstrapMethodsOffset ; \nfor ( int i = 0 ; \ni < bootstrapMethodCount ; \ni = i + 1 ) { \nint offset = currentOffset - bootstrapMethodsOffset ; \nint bootstrapMethodRef = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nint numBootstrapArguments = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nint hashCode = classReader . readConst ( bootstrapMethodRef , charBuffer ) . hashCode ( ) ; \nwhile ( numBootstrapArguments = numBootstrapArguments - 1 > 0 ) { \nint bootstrapArgument = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nhashCode ^= classReader . readConst ( bootstrapArgument , charBuffer ) . hashCode ( ) ; \n} \nadd ( new Entry ( i , Symbol . BOOTSTRAP_METHOD_TAG , offset , hashCode & 0x7FFFFFFF ) ) ; \n} \n} \n} \n} \n"}
{"851": "public class SymbolTable { \nprivate Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { \nint hashCode = hash ( tag , owner , name , descriptor ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount = constantPoolCount + 1 , tag , owner , name , descriptor , 0 , hashCode ) ) ; \n} \n} \n"}
{"853": "public class SymbolTable { \nprivate Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . putByte ( tag ) . putInt ( value ) ; \nreturn put ( new Entry ( constantPoolCount = constantPoolCount + 1 , tag , value , hashCode ) ) ; \n} \n} \n"}
{"857": "public class SymbolTable { \nint addConstantNameAndType ( final String name , final String descriptor ) { \nfinal int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; \nint hashCode = hash ( tag , name , descriptor ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry . index ; \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount = constantPoolCount + 1 , tag , name , descriptor , hashCode ) ) . index ; \n} \n} \n"}
{"859": "public class SymbolTable { \nint addConstantUtf8 ( final String value ) { \nint hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { \nreturn entry . index ; \n} \nentry = entry . next ; \n} \nconstantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; \nreturn put ( new Entry ( constantPoolCount = constantPoolCount + 1 , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; \n} \n} \n"}
{"861": "public class SymbolTable { \nSymbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { \nfinal int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; \nint hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nif ( referenceKind <= Opcodes . H_PUTSTATIC ) { \nconstantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; \n} \nelse { \nconstantPool . put112 ( tag , referenceKind , addConstantMethodref ( owner , name , descriptor , isInterface ) . index ) ; \n} \nreturn put ( new Entry ( constantPoolCount = constantPoolCount + 1 , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; \n} \n} \n"}
{"865": "public class SymbolTable { \nprivate Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { \nint hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; \nreturn put ( new Entry ( constantPoolCount = constantPoolCount + 1 , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; \n} \n} \n"}
{"867": "public class SymbolTable { \nprivate Symbol addConstantUtf8Reference ( final int tag , final String value ) { \nint hashCode = hash ( tag , value ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nconstantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; \nreturn put ( new Entry ( constantPoolCount = constantPoolCount + 1 , tag , value , hashCode ) ) ; \n} \n} \n"}
{"871": "public class HttpMultiMap { \nprivate int hash ( final String name ) { \nint h = 0 ; \nfor ( int i = name . length ( ) - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nchar c = name . charAt ( i ) ; \nif ( ! caseSensitive ) { \nif ( c >= 'A' && c <= 'Z' ) { \nc += 32 ; \n} \n} \nh = 31 * h + c ; \n} \nif ( h > 0 ) { \nreturn h ; \n} \nif ( h == Integer . MIN_VALUE ) { \nreturn Integer . MAX_VALUE ; \n} \nreturn - h ; \n} \n} \n"}
{"872": "public class HttpMultiMap { \npublic HttpMultiMap < V > clear ( ) { \nfor ( int i = 0 ; \ni < entries . length ; \ni = i + 1 ) { \nentries [ i ] = null ; \n} \nhead . before = head . after = head ; \nreturn this ; \n} \n} \n"}
{"877": "public class FastCharBuffer { \n@ Override public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { \nfor ( int i = start ; \ni < end ; \ni = i + 1 ) { \nappend ( csq . charAt ( i ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"879": "public class ProxettaMethodBuilder { \n@ Override public void visitEnd ( ) { \ncreateFirstChainDelegate_Continue ( tmd ) ; \nfor ( int p = 0 ; \np < tmd . proxyData . length ; \np = p + 1 ) { \ntmd . selectCurrentProxy ( p ) ; \ncreateProxyMethod ( tmd ) ; \n} \n} \n} \n"}
{"886": "public class Fields { \npublic FieldDescriptor [ ] getAllFieldDescriptors ( ) { \nif ( allFields == null ) { \nFieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; \nint index = 0 ; \nfor ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { \nallFields [ index ] = fieldDescriptor ; \nindex = index + 1 ; \n} \nArrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; \nthis . allFields = allFields ; \n} \nreturn allFields ; \n} \n} \n"}
{"903": "public class ReceiveMailSession { \nReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { \nuseAndOpenFolderIfNotSet ( ) ; \nfinal Message [ ] messages ; \ntry { \nif ( filter == null ) { \nmessages = folder . getMessages ( ) ; \n} \nelse { \nmessages = folder . search ( filter . getSearchTerm ( ) ) ; \n} \nif ( messages . length == 0 ) { \nreturn ReceivedEmail . EMPTY_ARRAY ; \n} \nif ( envelope ) { \nfinal FetchProfile fetchProfile = new FetchProfile ( ) ; \nfetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; \nfetchProfile . add ( FetchProfile . Item . FLAGS ) ; \nfolder . fetch ( messages , fetchProfile ) ; \n} \nfinal ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; \nfor ( int i = 0 ; \ni < messages . length ; \ni = i + 1 ) { \nfinal Message msg = messages [ i ] ; \nemails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nemails [ i ] . flags ( flagsToSet ) ; \nmsg . setFlags ( flagsToSet , true ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { \nemails [ i ] . flags ( ) . remove ( flagsToUnset ) ; \nmsg . setFlags ( flagsToUnset , false ) ; \n} \nif ( EmailUtil . isEmptyFlags ( flagsToSet ) && ! emails [ i ] . isSeen ( ) ) { \nmsg . setFlag ( Flags . Flag . SEEN , false ) ; \n} \n} \nif ( processedMessageConsumer != null ) { \nprocessedMessageConsumer . accept ( messages ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nif ( flagsToSet . contains ( Flags . Flag . DELETED ) ) { \nfolder . expunge ( ) ; \n} \n} \nreturn emails ; \n} \ncatch ( final MessagingException msgexc ) { \nthrow new MailException ( \"Failed to fetch messages\" , msgexc ) ; \n} \n} \n} \n"}
{"933": "public class KeyValueJsonSerializer { \nprotected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { \nif ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { \nreturn count ; \n} \nif ( key != null ) { \ncurrentPath . push ( key . toString ( ) ) ; \n} \nelse { \ncurrentPath . push ( StringPool . NULL ) ; \n} \nboolean include = true ; \nif ( value != null ) { \ninclude = jsonContext . matchIgnoredPropertyTypes ( value . getClass ( ) , false , include ) ; \ninclude = jsonContext . matchPathToQueries ( include ) ; \n} \nif ( ! include ) { \ncurrentPath . pop ( ) ; \nreturn count ; \n} \nif ( key == null ) { \njsonContext . pushName ( null , count > 0 ) ; \n} \nelse { \njsonContext . pushName ( key . toString ( ) , count > 0 ) ; \n} \njsonContext . serialize ( value ) ; \nif ( jsonContext . isNamePopped ( ) ) { \ncount = count + 1 ; \n} \ncurrentPath . pop ( ) ; \nreturn count ; \n} \n} \n"}
{"935": "public class ResultMapper { \nprotected String resolveAlias ( final String value ) { \nfinal StringBuilder result = new StringBuilder ( value . length ( ) ) ; \nint i = 0 ; \nint len = value . length ( ) ; \nwhile ( i < len ) { \nint ndx = value . indexOf ( '<' , i ) ; \nif ( ndx == - 1 ) { \nif ( i == 0 ) { \nString alias = lookupAlias ( value ) ; \nreturn ( alias != null ? alias : value ) ; \n} \nelse { \nresult . append ( value . substring ( i ) ) ; \n} \nbreak ; \n} \nresult . append ( value . substring ( i , ndx ) ) ; \nndx = ndx + 1 ; \nint ndx2 = value . indexOf ( '>' , ndx ) ; \nString aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; \nString alias = lookupAlias ( aliasName ) ; \nif ( alias != null ) { \nresult . append ( alias ) ; \n} \nelse { \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( \"Alias not found: \" + aliasName ) ; \n} \n} \ni = ndx2 + 1 ; \n} \ni = 0 ; \nlen = result . length ( ) ; \nwhile ( i < len ) { \nif ( result . charAt ( i ) != '/' ) { \nbreak ; \n} \ni = i + 1 ; \n} \nif ( i > 1 ) { \nreturn result . substring ( i - 1 , len ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"936": "public class ResultMapper { \npublic ResultPath resolveResultPath ( String path , String value ) { \nboolean absolutePath = false ; \nif ( value != null ) { \nvalue = resolveAlias ( value ) ; \nif ( StringUtil . startsWithChar ( value , '/' ) ) { \nabsolutePath = true ; \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath = value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \npath = value ; \nvalue = null ; \n} \n} \nelse { \nint i = 0 ; \nwhile ( i < value . length ( ) ) { \nif ( value . charAt ( i ) != '#' ) { \nbreak ; \n} \nint dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; \nif ( dotNdx != - 1 ) { \npath = path . substring ( 0 , dotNdx ) ; \n} \ni = i + 1 ; \n} \nif ( i > 0 ) { \nvalue = value . substring ( i ) ; \nif ( StringUtil . startsWithChar ( value , '.' ) ) { \nvalue = value . substring ( 1 ) ; \n} \nelse { \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath += '.' + value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \nif ( value . length ( ) > 0 ) { \nif ( StringUtil . endsWithChar ( path , '/' ) ) { \npath += value ; \n} \nelse { \npath += '.' + value ; \n} \n} \nvalue = null ; \n} \n} \n} \n} \n} \nif ( ! absolutePath ) { \nif ( resultPathPrefix != null ) { \npath = resultPathPrefix + path ; \n} \n} \nreturn new ResultPath ( path , value ) ; \n} \n} \n"}
{"938": "public class MadvocUtil { \npublic static int lastIndexOfSlashDot ( final String str ) { \nint slashNdx = str . lastIndexOf ( '/' ) ; \nint dotNdx = StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; \nif ( dotNdx == - 1 ) { \nif ( slashNdx == - 1 ) { \nreturn - 1 ; \n} \nslashNdx = slashNdx + 1 ; \nif ( slashNdx < str . length ( ) - 1 ) { \ndotNdx = slashNdx ; \n} \nelse { \ndotNdx = - 1 ; \n} \n} \nreturn dotNdx ; \n} \n} \n"}
{"939": "public class MadvocUtil { \npublic static int lastIndexOfDotAfterSlash ( final String str ) { \nint slashNdx = str . lastIndexOf ( '/' ) ; \nslashNdx = slashNdx + 1 ; \nreturn StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; \n} \n} \n"}
{"941": "public class MadvocUtil { \npublic static String stripLastCamelWord ( String name ) { \nint ndx = name . length ( ) - 1 ; \nwhile ( ndx >= 0 ) { \nif ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { \nbreak ; \n} \nndx = ndx - 1 ; \n} \nif ( ndx >= 0 ) { \nname = name . substring ( 0 , ndx ) ; \n} \nreturn name ; \n} \n} \n"}
{"944": "public class Threefish { \npublic void init ( final long [ ] key , final long [ ] tweak ) { \nfinal int newNw = key . length ; \nif ( nw != newNw ) { \nnw = newNw ; \nswitch ( nw ) { \ncase WORDS_4 : pi = PI4 ; \nrpi = RPI4 ; \nr = R4 ; \nbreak ; \ncase WORDS_8 : pi = PI8 ; \nrpi = RPI8 ; \nr = R8 ; \nbreak ; \ncase WORDS_16 : pi = PI16 ; \nrpi = RPI16 ; \nr = R16 ; \nbreak ; \ndefault : throw new RuntimeException ( \"Invalid threefish key\" ) ; \n} \nthis . k = new long [ nw + 1 ] ; \nvd = new long [ nw ] ; \ned = new long [ nw ] ; \nfd = new long [ nw ] ; \nksd = new long [ nw ] ; \n} \nSystem . arraycopy ( key , 0 , this . k , 0 , key . length ) ; \nlong knw = EXTENDED_KEY_SCHEDULE_CONST ; \nfor ( int i = 0 ; \ni < nw ; \ni = i + 1 ) { \nknw ^= this . k [ i ] ; \n} \nthis . k [ nw ] = knw ; \nt [ 0 ] = tweak [ 0 ] ; \nt [ 1 ] = tweak [ 1 ] ; \nt [ 2 ] = t [ 0 ] ^ t [ 1 ] ; \n} \n} \n"}
{"947": "public class Threefish { \nprivate void keySchedule ( final int s ) { \nfor ( int i = 0 ; \ni < nw ; \ni = i + 1 ) { \nksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; \nif ( i == nw - 3 ) { \nksd [ i ] += t [ s % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 2 ) { \nksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 1 ) { \nksd [ i ] += s ; \n} \n} \n} \n} \n"}
{"950": "public class Threefish { \nprotected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { \nlong [ ] result = new long [ size >> 3 ] ; \nint i8 = offset ; \nfor ( int i = 0 ; \ni < result . length ; \ni = i + 1 ) { \nresult [ i ] = Bits . getLong ( ba , i8 ) ; \ni8 += 8 ; \n} \nreturn result ; \n} \n} \n"}
{"971": "public class ClassReader { \nprivate int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { \nint currentOffset = annotationOffset ; \nint numElementValuePairs = readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nif ( named ) { \nwhile ( numElementValuePairs = numElementValuePairs - 1 > 0 ) { \nString elementName = readUTF8 ( currentOffset , charBuffer ) ; \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; \n} \n} \nelse { \nwhile ( numElementValuePairs = numElementValuePairs - 1 > 0 ) { \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset , null , charBuffer ) ; \n} \n} \nif ( annotationVisitor != null ) { \nannotationVisitor . visitEnd ( ) ; \n} \nreturn currentOffset ; \n} \n} \n"}
{"972": "public class ClassReader { \nprivate int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { \nint currentOffset = verificationTypeInfoOffset ; \nint tag = b [ currentOffset = currentOffset + 1 ] & 0xFF ; \nswitch ( tag ) { \ncase Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; \nbreak ; \ncase Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; \nbreak ; \ncase Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; \nbreak ; \ncase Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; \nbreak ; \ncase Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; \nbreak ; \ncase Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; \nbreak ; \ncase Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; \nbreak ; \ncase Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; \ncurrentOffset += 2 ; \nbreak ; \ncase Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; \ncurrentOffset += 2 ; \nbreak ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \nreturn currentOffset ; \n} \n} \n"}
{"973": "public class ClassReader { \nprivate int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { \nchar [ ] charBuffer = new char [ maxStringLength ] ; \nint currentAttributeOffset = getFirstAttributeOffset ( ) ; \nint [ ] currentBootstrapMethodOffsets = null ; \nfor ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; \ni > 0 ; \ni = i - 1 ) { \nString attributeName = readUTF8 ( currentAttributeOffset , charBuffer ) ; \nint attributeLength = readInt ( currentAttributeOffset + 2 ) ; \ncurrentAttributeOffset += 6 ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \ncurrentBootstrapMethodOffsets = new int [ readUnsignedShort ( currentAttributeOffset ) ] ; \nint currentBootstrapMethodOffset = currentAttributeOffset + 2 ; \nfor ( int j = 0 ; \nj < currentBootstrapMethodOffsets . length ; \nj = j + 1 ) { \ncurrentBootstrapMethodOffsets [ j ] = currentBootstrapMethodOffset ; \ncurrentBootstrapMethodOffset += 4 + readUnsignedShort ( currentBootstrapMethodOffset + 2 ) * 2 ; \n} \nreturn currentBootstrapMethodOffsets ; \n} \ncurrentAttributeOffset += attributeLength ; \n} \nreturn null ; \n} \n} \n"}
{"974": "public class Ctors { \nprotected CtorDescriptor [ ] inspectConstructors ( ) { \nClass type = classDescriptor . getType ( ) ; \nConstructor [ ] ctors = type . getDeclaredConstructors ( ) ; \nCtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; \nfor ( int i = 0 ; \ni < ctors . length ; \ni = i + 1 ) { \nConstructor ctor = ctors [ i ] ; \nCtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; \nallCtors [ i ] = ctorDescriptor ; \nif ( ctorDescriptor . isDefault ( ) ) { \ndefaultCtor = ctorDescriptor ; \n} \n} \nreturn allCtors ; \n} \n} \n"}
{"975": "public class Ctors { \npublic CtorDescriptor getCtorDescriptor ( final Class ... args ) { \nctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { \nClass [ ] arg = ctorDescriptor . getParameters ( ) ; \nif ( arg . length != args . length ) { \ncontinue ; \n} \nfor ( int j = 0 ; \nj < arg . length ; \nj = j + 1 ) { \nif ( arg [ j ] != args [ j ] ) { \ncontinue ctors ; \n} \n} \nreturn ctorDescriptor ; \n} \nreturn null ; \n} \n} \n"}
{"978": "public class LongArrayConverter { \nprotected long [ ] convertArrayToArray ( final Object value ) { \nfinal Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; \nfinal long [ ] result ; \nif ( valueComponentType . isPrimitive ( ) ) { \nresult = convertPrimitiveArrayToArray ( value , valueComponentType ) ; \n} \nelse { \nfinal Object [ ] array = ( Object [ ] ) value ; \nresult = new long [ array . length ] ; \nfor ( int i = 0 ; \ni < array . length ; \ni = i + 1 ) { \nresult [ i ] = convertType ( array [ i ] ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"987": "public class FindFile { \nprotected void init ( ) { \nrules . detectMode ( ) ; \ntodoFiles = new LinkedList < > ( ) ; \ntodoFolders = new LinkedList < > ( ) ; \nif ( pathList == null ) { \npathList = new LinkedList < > ( ) ; \nreturn ; \n} \nif ( pathListOriginal == null ) { \npathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; \n} \nString [ ] files = new String [ pathList . size ( ) ] ; \nint index = 0 ; \nIterator < File > iterator = pathList . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nFile file = iterator . next ( ) ; \nif ( file . isFile ( ) ) { \nfiles [ index = index + 1 ] = file . getAbsolutePath ( ) ; \niterator . remove ( ) ; \n} \n} \nif ( index != 0 ) { \nFilesIterator filesIterator = new FilesIterator ( files ) ; \ntodoFiles . add ( filesIterator ) ; \n} \n} \n} \n"}
{"993": "public class Type { \npublic String getClassName ( ) { \nswitch ( sort ) { \ncase VOID : return \"void\" ; \ncase BOOLEAN : return \"boolean\" ; \ncase CHAR : return \"char\" ; \ncase BYTE : return \"byte\" ; \ncase SHORT : return \"short\" ; \ncase INT : return \"int\" ; \ncase FLOAT : return \"float\" ; \ncase LONG : return \"long\" ; \ncase DOUBLE : return \"double\" ; \ncase ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; \nfor ( int i = getDimensions ( ) ; \ni > 0 ; \ni = i - 1 ) { \nstringBuilder . append ( \"[]\" ) ; \n} \nreturn stringBuilder . toString ( ) ; \ncase OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( '/' , '.' ) ; \ndefault : throw new AssertionError ( ) ; \n} \n} \n} \n"}
{"999": "public class Type { \npublic static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { \nint argumentsSize = 1 ; \nint currentOffset = 1 ; \nint currentChar = methodDescriptor . charAt ( currentOffset ) ; \nwhile ( currentChar != ')' ) { \nif ( currentChar == 'J' || currentChar == 'D' ) { \ncurrentOffset = currentOffset + 1 ; \nargumentsSize += 2 ; \n} \nelse { \nwhile ( methodDescriptor . charAt ( currentOffset ) == '[' ) { \ncurrentOffset = currentOffset + 1 ; \n} \nif ( methodDescriptor . charAt ( currentOffset = currentOffset + 1 ) == 'L' ) { \ncurrentOffset = methodDescriptor . indexOf ( ';' , currentOffset ) + 1 ; \n} \nargumentsSize += 1 ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset ) ; \n} \ncurrentChar = methodDescriptor . charAt ( currentOffset + 1 ) ; \nif ( currentChar == 'V' ) { \nreturn argumentsSize << 2 ; \n} \nelse { \nint returnSize = ( currentChar == 'J' || currentChar == 'D' ) ? 2 : 1 ; \nreturn argumentsSize << 2 | returnSize ; \n} \n} \n} \n"}
{"1005": "public class JsonWriter { \npublic void writeString ( final String value ) { \npopName ( ) ; \nwrite ( StringPool . QUOTE ) ; \nint len = value . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nchar c = value . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : write ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : write ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '/' : if ( strictStringEncoding ) { \nwrite ( \"\\\\/\" ) ; \n} \nelse { \nwrite ( c ) ; \n} \nbreak ; \ncase '\\b' : write ( \"\\\\b\" ) ; \nbreak ; \ncase '\\f' : write ( \"\\\\f\" ) ; \nbreak ; \ncase '\\n' : write ( \"\\\\n\" ) ; \nbreak ; \ncase '\\r' : write ( \"\\\\r\" ) ; \nbreak ; \ncase '\\t' : write ( \"\\\\t\" ) ; \nbreak ; \ndefault : if ( Character . isISOControl ( c ) ) { \nunicode ( c ) ; \n} \nelse { \nwrite ( c ) ; \n} \n} \n} \nwrite ( StringPool . QUOTE ) ; \n} \n} \n"}
{"1006": "public class JsonWriter { \nprotected void unicode ( final char c ) { \nwrite ( \"\\\\u\" ) ; \nint n = c ; \nfor ( int i = 0 ; \ni < 4 ; \ni = i + 1 ) { \nint digit = ( n & 0xf000 ) >> 12 ; \nchar hex = CharUtil . int2hex ( digit ) ; \nwrite ( hex ) ; \nn <<= 4 ; \n} \n} \n} \n"}
{"1013": "public class ProxettaClassBuilder { \n@ Override public void visit ( final int version , int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { \nwd . init ( name , superName , this . suffix , this . reqProxyClassName ) ; \naccess &= ~ AsmUtil . ACC_ABSTRACT ; \nfinal int v = ProxettaAsmUtil . resolveJavaVersion ( version ) ; \nwd . dest . visit ( v , access , wd . thisReference , signature , wd . superName , null ) ; \nwd . proxyAspects = new ProxyAspectData [ aspects . length ] ; \nfor ( int i = 0 ; \ni < aspects . length ; \ni = i + 1 ) { \nwd . proxyAspects [ i ] = new ProxyAspectData ( wd , aspects [ i ] , i ) ; \n} \n} \n} \n"}
{"1030": "public class JtxTransactionManager { \npublic int totalThreadTransactionsWithStatus ( final JtxStatus status ) { \nArrayList < JtxTransaction > txlist = txStack . get ( ) ; \nif ( txlist == null ) { \nreturn 0 ; \n} \nint count = 0 ; \nfor ( JtxTransaction tx : txlist ) { \nif ( tx . getStatus ( ) == status ) { \ncount = count + 1 ; \n} \n} \nreturn count ; \n} \n} \n"}
{"1031": "public class JtxTransactionManager { \nprotected void associateTransaction ( final JtxTransaction tx ) { \ntotalTransactions = totalTransactions + 1 ; \nArrayList < JtxTransaction > txList = txStack . get ( ) ; \nif ( txList == null ) { \ntxList = new ArrayList < > ( ) ; \ntxStack . set ( txList ) ; \n} \ntxList . add ( tx ) ; \n} \n} \n"}
{"1036": "public class Format { \npublic static String alignLeftAndPad ( final String text , final int size ) { \nint textLength = text . length ( ) ; \nif ( textLength > size ) { \nreturn text . substring ( 0 , size ) ; \n} \nfinal StringBuilder sb = new StringBuilder ( size ) ; \nsb . append ( text ) ; \nwhile ( textLength = textLength + 1 < size ) { \nsb . append ( ' ' ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1037": "public class Format { \npublic static String toPrettyString ( final Object value ) { \nif ( value == null ) { \nreturn StringPool . NULL ; \n} \nfinal Class < ? > type = value . getClass ( ) ; \nif ( type . isArray ( ) ) { \nfinal Class componentType = type . getComponentType ( ) ; \nif ( componentType . isPrimitive ( ) ) { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nif ( componentType == int . class ) { \nsb . append ( ArraysUtil . toString ( ( int [ ] ) value ) ) ; \n} \nelse if ( componentType == long . class ) { \nsb . append ( ArraysUtil . toString ( ( long [ ] ) value ) ) ; \n} \nelse if ( componentType == double . class ) { \nsb . append ( ArraysUtil . toString ( ( double [ ] ) value ) ) ; \n} \nelse if ( componentType == float . class ) { \nsb . append ( ArraysUtil . toString ( ( float [ ] ) value ) ) ; \n} \nelse if ( componentType == boolean . class ) { \nsb . append ( ArraysUtil . toString ( ( boolean [ ] ) value ) ) ; \n} \nelse if ( componentType == short . class ) { \nsb . append ( ArraysUtil . toString ( ( short [ ] ) value ) ) ; \n} \nelse if ( componentType == byte . class ) { \nsb . append ( ArraysUtil . toString ( ( byte [ ] ) value ) ) ; \n} \nelse { \nthrow new IllegalArgumentException ( ) ; \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \nelse { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nfinal Object [ ] array = ( Object [ ] ) value ; \nfor ( int i = 0 ; \ni < array . length ; \ni = i + 1 ) { \nif ( i > 0 ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( array [ i ] ) ) ; \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \n} \nelse if ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '{' ) ; \nint i = 0 ; \nfor ( final Object o : iterable ) { \nif ( i > 0 ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( o ) ) ; \ni = i + 1 ; \n} \nsb . append ( '}' ) ; \nreturn sb . toString ( ) ; \n} \nreturn value . toString ( ) ; \n} \n} \n"}
{"1038": "public class Format { \npublic static String toCamelCase ( final String input , final boolean firstCharUppercase , final char separator ) { \nfinal int length = input . length ( ) ; \nfinal StringBuilder sb = new StringBuilder ( length ) ; \nboolean upperCase = firstCharUppercase ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nfinal char ch = input . charAt ( i ) ; \nif ( ch == separator ) { \nupperCase = true ; \n} \nelse if ( upperCase ) { \nsb . append ( Character . toUpperCase ( ch ) ) ; \nupperCase = false ; \n} \nelse { \nsb . append ( ch ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1041": "public class Format { \npublic static String escapeJava ( final String string ) { \nint strLen = string . length ( ) ; \nStringBuilder sb = new StringBuilder ( strLen ) ; \nfor ( int i = 0 ; \ni < strLen ; \ni = i + 1 ) { \nchar c = string . charAt ( i ) ; \nswitch ( c ) { \ncase '\\b' : sb . append ( \"\\\\b\" ) ; \nbreak ; \ncase '\\t' : sb . append ( \"\\\\t\" ) ; \nbreak ; \ncase '\\n' : sb . append ( \"\\\\n\" ) ; \nbreak ; \ncase '\\f' : sb . append ( \"\\\\f\" ) ; \nbreak ; \ncase '\\r' : sb . append ( \"\\\\r\" ) ; \nbreak ; \ncase '\\\"' : sb . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : sb . append ( \"\\\\\\\\\" ) ; \nbreak ; \ndefault : if ( ( c < 32 ) || ( c > 127 ) ) { \nString hex = Integer . toHexString ( c ) ; \nsb . append ( \"\\\\u\" ) ; \nfor ( int k = hex . length ( ) ; \nk < 4 ; \nk = k + 1 ) { \nsb . append ( '0' ) ; \n} \nsb . append ( hex ) ; \n} \nelse { \nsb . append ( c ) ; \n} \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1042": "public class Format { \npublic static String unescapeJava ( final String str ) { \nchar [ ] chars = str . toCharArray ( ) ; \nStringBuilder sb = new StringBuilder ( str . length ( ) ) ; \nfor ( int i = 0 ; \ni < chars . length ; \ni = i + 1 ) { \nchar c = chars [ i ] ; \nif ( c != '\\\\' ) { \nsb . append ( c ) ; \ncontinue ; \n} \ni = i + 1 ; \nc = chars [ i ] ; \nswitch ( c ) { \ncase 'b' : sb . append ( '\\b' ) ; \nbreak ; \ncase 't' : sb . append ( '\\t' ) ; \nbreak ; \ncase 'n' : sb . append ( '\\n' ) ; \nbreak ; \ncase 'f' : sb . append ( '\\f' ) ; \nbreak ; \ncase 'r' : sb . append ( '\\r' ) ; \nbreak ; \ncase '\"' : sb . append ( '\\\"' ) ; \nbreak ; \ncase '\\\\' : sb . append ( '\\\\' ) ; \nbreak ; \ncase 'u' : char hex = ( char ) Integer . parseInt ( new String ( chars , i + 1 , 4 ) , 16 ) ; \nsb . append ( hex ) ; \ni += 4 ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Invalid escaping character: \" + c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1048": "public class PetiteContainer { \npublic void setBeanProperty ( final String name , final Object value ) { \nObject bean = null ; \nint ndx = name . length ( ) ; \nwhile ( true ) { \nndx = name . lastIndexOf ( '.' , ndx ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nString beanName = name . substring ( 0 , ndx ) ; \nbean = getBean ( beanName ) ; \nif ( bean != null ) { \nbreak ; \n} \nndx = ndx - 1 ; \n} \nif ( bean == null ) { \nthrow new PetiteException ( \"Invalid bean property: \" + name ) ; \n} \ntry { \nBeanUtil . declared . setProperty ( bean , name . substring ( ndx + 1 ) , value ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Invalid bean property: \" + name , ex ) ; \n} \n} \n} \n"}
{"1058": "public class BaseLoggableStatement { \npublic String getQueryString ( ) { \nif ( sqlTemplate == null ) { \nreturn toString ( ) ; \n} \nif ( parameterValues == null ) { \nreturn sqlTemplate ; \n} \nfinal StringBuilder sb = new StringBuilder ( ) ; \nint qMarkCount = 0 ; \nfinal StringTokenizer tok = new StringTokenizer ( sqlTemplate + ' ' , \"?\" ) ; \nwhile ( tok . hasMoreTokens ( ) ) { \nfinal String oneChunk = tok . nextToken ( ) ; \nsb . append ( oneChunk ) ; \ntry { \nObject value = null ; \nif ( parameterValues . size ( ) > 1 + qMarkCount ) { \nvalue = parameterValues . get ( 1 + qMarkCount ) ; \nqMarkCount = qMarkCount + 1 ; \n} \nelse { \nif ( ! tok . hasMoreTokens ( ) ) { \nvalue = \"\" ; \n} \n} \nif ( value == null ) { \nvalue = \"?\" ; \n} \nsb . append ( value ) ; \n} \ncatch ( Throwable th ) { \nsb . append ( \"--- Building query failed: \" ) . append ( th . toString ( ) ) ; \n} \n} \nreturn sb . toString ( ) . trim ( ) ; \n} \n} \n"}
{"1061": "public class IteratorTag { \nprotected void iterateCollection ( final Collection collection , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nIterator iter = collection . iterator ( ) ; \nint i = 0 ; \nint to = calculateTo ( from , count , collection . size ( ) ) ; \nwhile ( i < to ) { \nObject item = iter . next ( ) ; \nif ( i >= from ) { \nif ( status != null ) { \niteratorStatus . next ( ! iter . hasNext ( ) ) ; \n} \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \n} \ni = i + 1 ; \n} \n} \n} \n"}
{"1062": "public class IteratorTag { \nprotected void iterateArray ( final Object [ ] array , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nint len = array . length ; \nint to = calculateTo ( from , count , len ) ; \nint last = to - 1 ; \nfor ( int i = from ; \ni < to ; \ni = i + 1 ) { \nObject item = array [ i ] ; \nif ( status != null ) { \niteratorStatus . next ( i == last ) ; \n} \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \n} \n} \n} \n"}
{"1064": "public class StringUtil { \npublic static String replaceChar ( final String s , final char sub , final char with ) { \nint startIndex = s . indexOf ( sub ) ; \nif ( startIndex == - 1 ) { \nreturn s ; \n} \nchar [ ] str = s . toCharArray ( ) ; \nfor ( int i = startIndex ; \ni < str . length ; \ni = i + 1 ) { \nif ( str [ i ] == sub ) { \nstr [ i ] = with ; \n} \n} \nreturn new String ( str ) ; \n} \n} \n"}
{"1065": "public class StringUtil { \npublic static String replaceChars ( final String s , final char [ ] sub , final char [ ] with ) { \nchar [ ] str = s . toCharArray ( ) ; \nfor ( int i = 0 ; \ni < str . length ; \ni = i + 1 ) { \nchar c = str [ i ] ; \nfor ( int j = 0 ; \nj < sub . length ; \nj = j + 1 ) { \nif ( c == sub [ j ] ) { \nstr [ i ] = with [ j ] ; \nbreak ; \n} \n} \n} \nreturn new String ( str ) ; \n} \n} \n"}
{"1071": "public class StringUtil { \npublic static String remove ( final String string , final char ch ) { \nint stringLen = string . length ( ) ; \nchar [ ] result = new char [ stringLen ] ; \nint offset = 0 ; \nfor ( int i = 0 ; \ni < stringLen ; \ni = i + 1 ) { \nchar c = string . charAt ( i ) ; \nif ( c == ch ) { \ncontinue ; \n} \nresult [ offset ] = c ; \noffset = offset + 1 ; \n} \nif ( offset == stringLen ) { \nreturn string ; \n} \nreturn new String ( result , 0 , offset ) ; \n} \n} \n"}
{"1076": "public class StringUtil { \npublic static String title ( final String string ) { \nchar [ ] chars = string . toCharArray ( ) ; \nboolean wasWhitespace = true ; \nfor ( int i = 0 ; \ni < chars . length ; \ni = i + 1 ) { \nchar c = chars [ i ] ; \nif ( CharUtil . isWhitespace ( c ) ) { \nwasWhitespace = true ; \n} \nelse { \nif ( wasWhitespace ) { \nchars [ i ] = Character . toUpperCase ( c ) ; \n} \nelse { \nchars [ i ] = Character . toLowerCase ( c ) ; \n} \nwasWhitespace = false ; \n} \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1077": "public class StringUtil { \npublic static String compressChars ( final String s , final char c ) { \nint len = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( len ) ; \nboolean wasChar = false ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nchar c1 = s . charAt ( i ) ; \nif ( c1 == c ) { \nif ( wasChar ) { \ncontinue ; \n} \nwasChar = true ; \n} \nelse { \nwasChar = false ; \n} \nsb . append ( c1 ) ; \n} \nif ( sb . length ( ) == len ) { \nreturn s ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1078": "public class StringUtil { \npublic static boolean startsWithIgnoreCase ( final String src , final String subS , final int startIndex ) { \nString sub = subS . toLowerCase ( ) ; \nint sublen = sub . length ( ) ; \nif ( startIndex + sublen > src . length ( ) ) { \nreturn false ; \n} \nint j = 0 ; \nint i = startIndex ; \nwhile ( j < sublen ) { \nchar source = Character . toLowerCase ( src . charAt ( i ) ) ; \nif ( sub . charAt ( j ) != source ) { \nreturn false ; \n} \nj = j + 1 ; \ni = i + 1 ; \n} \nreturn true ; \n} \n} \n"}
{"1080": "public class StringUtil { \npublic static int countIgnoreCase ( final String source , final String sub ) { \nint count = 0 ; \nint j = 0 ; \nint sublen = sub . length ( ) ; \nif ( sublen == 0 ) { \nreturn 0 ; \n} \nwhile ( true ) { \nint i = indexOfIgnoreCase ( source , sub , j ) ; \nif ( i == - 1 ) { \nbreak ; \n} \ncount = count + 1 ; \nj = i + sublen ; \n} \nreturn count ; \n} \n} \n"}
{"1081": "public class StringUtil { \npublic static boolean equalsIgnoreCase ( final String [ ] as , final String [ ] as1 ) { \nif ( as . length != as1 . length ) { \nreturn false ; \n} \nfor ( int i = 0 ; \ni < as . length ; \ni = i + 1 ) { \nif ( ! as [ i ] . equalsIgnoreCase ( as1 [ i ] ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1082": "public class StringUtil { \npublic static int indexOfWhitespace ( final String string , final int startindex , final int endindex ) { \nfor ( int i = startindex ; \ni < endindex ; \ni = i + 1 ) { \nif ( CharUtil . isWhitespace ( string . charAt ( i ) ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1085": "public class StringUtil { \npublic static String stripChar ( final String string , final char c ) { \nif ( string . length ( ) == 0 ) { \nreturn string ; \n} \nif ( string . length ( ) == 1 ) { \nif ( string . charAt ( 0 ) == c ) { \nreturn StringPool . EMPTY ; \n} \nreturn string ; \n} \nint left = 0 ; \nint right = string . length ( ) ; \nif ( string . charAt ( left ) == c ) { \nleft = left + 1 ; \n} \nif ( string . charAt ( right - 1 ) == c ) { \nright = right - 1 ; \n} \nreturn string . substring ( left , right ) ; \n} \n} \n"}
{"1088": "public class StringUtil { \npublic static void cropAll ( final String ... strings ) { \nfor ( int i = 0 ; \ni < strings . length ; \ni = i + 1 ) { \nString string = strings [ i ] ; \nif ( string != null ) { \nstring = crop ( strings [ i ] ) ; \n} \nstrings [ i ] = string ; \n} \n} \n} \n"}
{"1089": "public class StringUtil { \npublic static String trimLeft ( final String src ) { \nint len = src . length ( ) ; \nint st = 0 ; \nwhile ( ( st < len ) && ( CharUtil . isWhitespace ( src . charAt ( st ) ) ) ) { \nst = st + 1 ; \n} \nreturn st > 0 ? src . substring ( st ) : src ; \n} \n} \n"}
{"1090": "public class StringUtil { \npublic static String trimRight ( final String src ) { \nint len = src . length ( ) ; \nint count = len ; \nwhile ( ( len > 0 ) && ( CharUtil . isWhitespace ( src . charAt ( len - 1 ) ) ) ) { \nlen = len - 1 ; \n} \nreturn ( len < count ) ? src . substring ( 0 , len ) : src ; \n} \n} \n"}
{"1092": "public class StringUtil { \npublic static String join ( final Collection collection , final char separator ) { \nif ( collection == null ) { \nreturn null ; \n} \nif ( collection . size ( ) == 0 ) { \nreturn StringPool . EMPTY ; \n} \nfinal StringBuilder sb = new StringBuilder ( collection . size ( ) * 16 ) ; \nfinal Iterator it = collection . iterator ( ) ; \nfor ( int i = 0 ; \ni < collection . size ( ) ; \ni = i + 1 ) { \nif ( i > 0 ) { \nsb . append ( separator ) ; \n} \nsb . append ( it . next ( ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1093": "public class StringUtil { \npublic static String join ( final Object [ ] array , final String separator ) { \nif ( array == null ) { \nreturn null ; \n} \nif ( array . length == 0 ) { \nreturn StringPool . EMPTY ; \n} \nif ( array . length == 1 ) { \nreturn String . valueOf ( array [ 0 ] ) ; \n} \nfinal StringBuilder sb = new StringBuilder ( array . length * 16 ) ; \nfor ( int i = 0 ; \ni < array . length ; \ni = i + 1 ) { \nif ( i > 0 ) { \nsb . append ( separator ) ; \n} \nsb . append ( array [ i ] ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1105": "public class StringUtil { \npublic static String repeat ( final String source , int count ) { \nStringBand result = new StringBand ( count ) ; \nwhile ( count > 0 ) { \nresult . append ( source ) ; \ncount = count - 1 ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"1106": "public class StringUtil { \npublic static String reverse ( final String s ) { \nStringBuilder result = new StringBuilder ( s . length ( ) ) ; \nfor ( int i = s . length ( ) - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nresult . append ( s . charAt ( i ) ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"1107": "public class StringUtil { \npublic static String maxCommonPrefix ( final String one , final String two ) { \nfinal int minLength = Math . min ( one . length ( ) , two . length ( ) ) ; \nfinal StringBuilder sb = new StringBuilder ( minLength ) ; \nfor ( int pos = 0 ; \npos < minLength ; \npos = pos + 1 ) { \nfinal char currentChar = one . charAt ( pos ) ; \nif ( currentChar != two . charAt ( pos ) ) { \nbreak ; \n} \nsb . append ( currentChar ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1108": "public class StringUtil { \npublic static String findCommonPrefix ( final String ... strings ) { \nStringBuilder prefix = new StringBuilder ( ) ; \nint index = 0 ; \nchar c = 0 ; \nloop : while ( true ) { \nfor ( int i = 0 ; \ni < strings . length ; \ni = i + 1 ) { \nString s = strings [ i ] ; \nif ( index == s . length ( ) ) { \nbreak loop ; \n} \nif ( i == 0 ) { \nc = s . charAt ( index ) ; \n} \nelse { \nif ( s . charAt ( index ) != c ) { \nbreak loop ; \n} \n} \n} \nindex = index + 1 ; \nprefix . append ( c ) ; \n} \nreturn prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; \n} \n} \n"}
{"1109": "public class StringUtil { \npublic static String shorten ( String s , int length , final String suffix ) { \nlength -= suffix . length ( ) ; \nif ( s . length ( ) > length ) { \nfor ( int j = length ; \nj >= 0 ; \nj = j - 1 ) { \nif ( CharUtil . isWhitespace ( s . charAt ( j ) ) ) { \nlength = j ; \nbreak ; \n} \n} \nString temp = s . substring ( 0 , length ) ; \ns = temp . concat ( suffix ) ; \n} \nreturn s ; \n} \n} \n"}
{"1110": "public class StringUtil { \npublic static String toUpperCase ( final String s , Locale locale ) { \nif ( s == null ) { \nreturn null ; \n} \nStringBuilder sb = null ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni = i + 1 ) { \nchar c = s . charAt ( i ) ; \nif ( c > 127 ) { \nif ( locale == null ) { \nlocale = Locale . getDefault ( ) ; \n} \nreturn s . toUpperCase ( locale ) ; \n} \nif ( ( c >= 'a' ) && ( c <= 'z' ) ) { \nif ( sb == null ) { \nsb = new StringBuilder ( s ) ; \n} \nsb . setCharAt ( i , ( char ) ( c - 32 ) ) ; \n} \n} \nif ( sb == null ) { \nreturn s ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1112": "public class StringUtil { \npublic static String toHexString ( final byte [ ] bytes ) { \nchar [ ] chars = new char [ bytes . length * 2 ] ; \nint i = 0 ; \nfor ( byte b : bytes ) { \nchars [ i = i + 1 ] = CharUtil . int2hex ( ( b & 0xF0 ) >> 4 ) ; \nchars [ i = i + 1 ] = CharUtil . int2hex ( b & 0x0F ) ; \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1127": "public class GzipResponseStream { \n@ Override public void write ( final int b ) throws IOException { \nif ( closed ) { \nthrow new IOException ( \"Cannot write to a closed output stream\" ) ; \n} \nif ( bufferCount >= buffer . length ) { \nflushToGZip ( ) ; \n} \nbuffer [ bufferCount = bufferCount + 1 ] = ( byte ) b ; \n} \n} \n"}
{"1134": "public class InvokeReplacerMethodAdapter { \nprotected static String prependArgument ( final String desc , final String type ) { \nint ndx = desc . indexOf ( '(' ) ; \nndx = ndx + 1 ; \nreturn desc . substring ( 0 , ndx ) + type + desc . substring ( ndx ) ; \n} \n} \n"}
{"1136": "public class StripHtmlTagAdapter { \n@ Override public void text ( final CharSequence text ) { \nif ( ! strip ) { \nsuper . text ( text ) ; \nreturn ; \n} \nint textLength = text . length ( ) ; \nchar [ ] dest = new char [ textLength ] ; \nint ndx = 0 ; \nboolean regularChar = true ; \nfor ( int i = 0 ; \ni < textLength ; \ni = i + 1 ) { \nchar c = text . charAt ( i ) ; \nif ( CharUtil . isWhitespace ( c ) ) { \nif ( regularChar ) { \nregularChar = false ; \nc = ' ' ; \n} \nelse { \ncontinue ; \n} \n} \nelse { \nregularChar = true ; \n} \ndest [ ndx ] = c ; \nndx = ndx + 1 ; \n} \nif ( regularChar || ( ndx != 1 ) ) { \nsuper . text ( CharBuffer . wrap ( dest , 0 , ndx ) ) ; \nstrippedCharsCount += textLength - ndx ; \n} \nelse { \nstrippedCharsCount += textLength ; \n} \n} \n} \n"}
{"1143": "public class NodeSelector { \nprotected void walkDescendantsIteratively ( final LinkedList < Node > nodes , final CssSelector cssSelector , final List < Node > result ) { \nwhile ( ! nodes . isEmpty ( ) ) { \nNode node = nodes . removeFirst ( ) ; \nselectAndAdd ( node , cssSelector , result ) ; \nint childCount = node . getChildNodesCount ( ) ; \nfor ( int i = childCount - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nnodes . addFirst ( node . getChild ( i ) ) ; \n} \n} \n} \n} \n"}
{"1144": "public class NodeSelector { \nprotected void walk ( final Node rootNode , final CssSelector cssSelector , final List < Node > result ) { \nCssSelector previousCssSelector = cssSelector . getPrevCssSelector ( ) ; \nCombinator combinator = previousCssSelector != null ? previousCssSelector . getCombinator ( ) : Combinator . DESCENDANT ; \nswitch ( combinator ) { \ncase DESCENDANT : LinkedList < Node > nodes = new LinkedList < > ( ) ; \nint childCount = rootNode . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni = i + 1 ) { \nnodes . add ( rootNode . getChild ( i ) ) ; \n} \nwalkDescendantsIteratively ( nodes , cssSelector , result ) ; \nbreak ; \ncase CHILD : childCount = rootNode . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni = i + 1 ) { \nNode node = rootNode . getChild ( i ) ; \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase ADJACENT_SIBLING : Node node = rootNode . getNextSiblingElement ( ) ; \nif ( node != null ) { \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase GENERAL_SIBLING : node = rootNode ; \nwhile ( true ) { \nnode = node . getNextSiblingElement ( ) ; \nif ( node == null ) { \nbreak ; \n} \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \n} \n} \n} \n"}
{"1147": "public class CSSellyLexer { \nprivate static char [ ] zzUnpackCMap ( final String packed ) { \nchar [ ] map = new char [ 0x110000 ] ; \nint i = 0 ; \nint j = 0 ; \nwhile ( i < 128 ) { \nint count = packed . charAt ( i = i + 1 ) ; \nchar value = packed . charAt ( i = i + 1 ) ; \ndo map [ j = j + 1 ] = value ; \nwhile ( count = count - 1 > 0 ) ; \n} \nreturn map ; \n} \n} \n"}
{"1151": "public class DbPager { \nprotected String removeToFrom ( String sql ) { \nint from = 0 ; \nint fromCount = 1 ; \nint selectCount = 0 ; \nint lastNdx = 0 ; \nwhile ( true ) { \nint ndx = StringUtil . indexOfIgnoreCase ( sql , \"from\" , from ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nString left = sql . substring ( lastNdx , ndx ) ; \nselectCount += StringUtil . countIgnoreCase ( left , \"select\" ) ; \nif ( fromCount >= selectCount ) { \nsql = sql . substring ( ndx ) ; \nbreak ; \n} \nlastNdx = ndx ; \nfrom = ndx + 4 ; \nfromCount = fromCount + 1 ; \n} \nreturn sql ; \n} \n} \n"}
{"1153": "public class HtmlDecoder { \npublic static String decode ( final String html ) { \nint ndx = html . indexOf ( '&' ) ; \nif ( ndx == - 1 ) { \nreturn html ; \n} \nStringBuilder result = new StringBuilder ( html . length ( ) ) ; \nint lastIndex = 0 ; \nint len = html . length ( ) ; \nmainloop : while ( ndx != - 1 ) { \nresult . append ( html . substring ( lastIndex , ndx ) ) ; \nlastIndex = ndx ; \nwhile ( html . charAt ( lastIndex ) != ';' ) { \nlastIndex = lastIndex + 1 ; \nif ( lastIndex == len ) { \nlastIndex = ndx ; \nbreak mainloop ; \n} \n} \nif ( html . charAt ( ndx + 1 ) == '#' ) { \nchar c = html . charAt ( ndx + 2 ) ; \nint radix ; \nif ( ( c == 'x' ) || ( c == 'X' ) ) { \nradix = 16 ; \nndx += 3 ; \n} \nelse { \nradix = 10 ; \nndx += 2 ; \n} \nString number = html . substring ( ndx , lastIndex ) ; \nint i = Integer . parseInt ( number , radix ) ; \nresult . append ( ( char ) i ) ; \nlastIndex = lastIndex + 1 ; \n} \nelse { \nString encodeToken = html . substring ( ndx + 1 , lastIndex ) ; \nchar [ ] replacement = ENTITY_MAP . get ( encodeToken ) ; \nif ( replacement == null ) { \nresult . append ( '&' ) ; \nlastIndex = ndx + 1 ; \n} \nelse { \nresult . append ( replacement ) ; \nlastIndex = lastIndex + 1 ; \n} \n} \nndx = html . indexOf ( '&' , lastIndex ) ; \n} \nresult . append ( html . substring ( lastIndex ) ) ; \nreturn result . toString ( ) ; \n} \n} \n"}
{"1154": "public class HtmlDecoder { \npublic static String detectName ( final char [ ] input , int ndx ) { \nfinal Ptr ptr = new Ptr ( ) ; \nint firstIndex = 0 ; \nint lastIndex = ENTITY_NAMES . length - 1 ; \nint len = input . length ; \nchar [ ] lastName = null ; \nfinal BinarySearchBase binarySearch = new BinarySearchBase ( ) { \n@ Override protected int compare ( final int index ) { \nchar [ ] name = ENTITY_NAMES [ index ] ; \nif ( ptr . offset >= name . length ) { \nreturn - 1 ; \n} \nreturn name [ ptr . offset ] - ptr . c ; \n} \n} \n; \nwhile ( true ) { \nptr . c = input [ ndx ] ; \nif ( ! CharUtil . isAlphaOrDigit ( ptr . c ) ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nfirstIndex = binarySearch . findFirst ( firstIndex , lastIndex ) ; \nif ( firstIndex < 0 ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nchar [ ] element = ENTITY_NAMES [ firstIndex ] ; \nif ( element . length == ptr . offset + 1 ) { \nlastName = ENTITY_NAMES [ firstIndex ] ; \n} \nlastIndex = binarySearch . findLast ( firstIndex , lastIndex ) ; \nif ( firstIndex == lastIndex ) { \nfor ( int i = ptr . offset ; \ni < element . length ; \ni = i + 1 ) { \nif ( element [ i ] != input [ ndx ] ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nndx = ndx + 1 ; \n} \nreturn new String ( element ) ; \n} \nptr . offset = ptr . offset + 1 ; \nndx = ndx + 1 ; \nif ( ndx == len ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \n} \n} \n} \n"}
{"1157": "public class DbEntityDescriptor { \nprivate void resolveColumnsAndProperties ( final Class type ) { \nPropertyDescriptor [ ] allProperties = ClassIntrospector . get ( ) . lookup ( type ) . getAllPropertyDescriptors ( ) ; \nList < DbEntityColumnDescriptor > decList = new ArrayList < > ( allProperties . length ) ; \nint idcount = 0 ; \nHashSet < String > names = new HashSet < > ( allProperties . length ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \nDbEntityColumnDescriptor dec = DbMetaUtil . resolveColumnDescriptors ( this , propertyDescriptor , isAnnotated , columnNamingStrategy ) ; \nif ( dec != null ) { \nif ( ! names . add ( dec . getColumnName ( ) ) ) { \nthrow new DbOomException ( \"Duplicate column name: \" + dec . getColumnName ( ) ) ; \n} \ndecList . add ( dec ) ; \nif ( dec . isId ) { \nidcount = idcount + 1 ; \n} \n} \n} \nif ( decList . isEmpty ( ) ) { \nthrow new DbOomException ( \"No column mappings in entity: \" + type ) ; \n} \ncolumnDescriptors = decList . toArray ( new DbEntityColumnDescriptor [ 0 ] ) ; \nArrays . sort ( columnDescriptors ) ; \nif ( idcount > 0 ) { \nidColumnDescriptors = new DbEntityColumnDescriptor [ idcount ] ; \nidcount = 0 ; \nfor ( DbEntityColumnDescriptor dec : columnDescriptors ) { \nif ( dec . isId ) { \nidColumnDescriptors [ idcount = idcount + 1 ] = dec ; \n} \n} \n} \n} \n} \n"}
{"1165": "public class StringBand { \npublic StringBand append ( String s ) { \nif ( s == null ) { \ns = StringPool . NULL ; \n} \nif ( index >= array . length ) { \nexpandCapacity ( ) ; \n} \narray [ index = index + 1 ] = s ; \nlength += s . length ( ) ; \nreturn this ; \n} \n} \n"}
{"1166": "public class StringBand { \npublic void setIndex ( final int newIndex ) { \nif ( newIndex < 0 ) { \nthrow new ArrayIndexOutOfBoundsException ( newIndex ) ; \n} \nif ( newIndex > array . length ) { \nString [ ] newArray = new String [ newIndex ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , index ) ; \narray = newArray ; \n} \nif ( newIndex > index ) { \nfor ( int i = index ; \ni < newIndex ; \ni = i + 1 ) { \narray [ i ] = StringPool . EMPTY ; \n} \n} \nelse if ( newIndex < index ) { \nfor ( int i = newIndex ; \ni < index ; \ni = i + 1 ) { \narray [ i ] = null ; \n} \n} \nindex = newIndex ; \nlength = calculateLength ( ) ; \n} \n} \n"}
{"1168": "public class StringBand { \nprotected int calculateLength ( ) { \nint len = 0 ; \nfor ( int i = 0 ; \ni < index ; \ni = i + 1 ) { \nlen += array [ i ] . length ( ) ; \n} \nreturn len ; \n} \n} \n"}
{"1179": "public class FieldWriter { \nvoid putFieldInfo ( final ByteVector output ) { \nboolean useSyntheticAttribute = symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ; \nint mask = useSyntheticAttribute ? Opcodes . ACC_SYNTHETIC : 0 ; \noutput . putShort ( accessFlags & ~ mask ) . putShort ( nameIndex ) . putShort ( descriptorIndex ) ; \nint attributesCount = 0 ; \nif ( constantValueIndex != 0 ) { \nattributesCount = attributesCount + 1 ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { \nattributesCount = attributesCount + 1 ; \n} \nif ( signatureIndex != 0 ) { \nattributesCount = attributesCount + 1 ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \nattributesCount = attributesCount + 1 ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \nattributesCount = attributesCount + 1 ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \nattributesCount = attributesCount + 1 ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \nattributesCount = attributesCount + 1 ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \nattributesCount = attributesCount + 1 ; \n} \nif ( firstAttribute != null ) { \nattributesCount += firstAttribute . getAttributeCount ( ) ; \n} \noutput . putShort ( attributesCount ) ; \nif ( constantValueIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ) . putInt ( 2 ) . putShort ( constantValueIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ) . putInt ( 0 ) ; \n} \nif ( signatureIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ) . putInt ( 2 ) . putShort ( signatureIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ) . putInt ( 0 ) ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \nlastRuntimeVisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \nlastRuntimeInvisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \nlastRuntimeVisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \nlastRuntimeInvisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( firstAttribute != null ) { \nfirstAttribute . putAttributes ( symbolTable , output ) ; \n} \n} \n} \n"}
{"1193": "public class InExRules { \nprotected void addRule ( final D ruleDefinition , final boolean include ) { \nif ( rules == null ) { \nrules = new ArrayList < > ( ) ; \n} \nif ( include ) { \nincludesCount = includesCount + 1 ; \n} \nelse { \nexcludesCount = excludesCount + 1 ; \n} \nRule < R > newRule = new Rule < > ( makeRule ( ruleDefinition ) , include ) ; \nif ( rules . contains ( newRule ) ) { \nreturn ; \n} \nrules . add ( newRule ) ; \n} \n} \n"}
{"1214": "public class PropsParser { \nprotected void extractProfilesAndAdd ( final String key , final String value , final Operator operator ) { \nString fullKey = key ; \nint ndx = fullKey . indexOf ( PROFILE_LEFT ) ; \nif ( ndx == - 1 ) { \njustAdd ( fullKey , value , null , operator ) ; \nreturn ; \n} \nArrayList < String > keyProfiles = new ArrayList < > ( ) ; \nwhile ( true ) { \nndx = fullKey . indexOf ( PROFILE_LEFT ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nfinal int len = fullKey . length ( ) ; \nint ndx2 = fullKey . indexOf ( PROFILE_RIGHT , ndx + 1 ) ; \nif ( ndx2 == - 1 ) { \nndx2 = len ; \n} \nfinal String profile = fullKey . substring ( ndx + 1 , ndx2 ) ; \nkeyProfiles . add ( profile ) ; \nndx2 = ndx2 + 1 ; \nfinal String right = ( ndx2 == len ) ? StringPool . EMPTY : fullKey . substring ( ndx2 ) ; \nfullKey = fullKey . substring ( 0 , ndx ) + right ; \n} \nif ( fullKey . startsWith ( StringPool . DOT ) ) { \nfullKey = fullKey . substring ( 1 ) ; \n} \njustAdd ( fullKey , value , keyProfiles , operator ) ; \n} \n} \n"}
{"1218": "public class AsmUtil { \npublic static String typedescToSignature ( final String desc , final MutableInteger from ) { \nint fromIndex = from . get ( ) ; \nfrom . value = from . value + 1 ; \nswitch ( desc . charAt ( fromIndex ) ) { \ncase 'B' : return \"byte\" ; \ncase 'C' : return \"char\" ; \ncase 'D' : return \"double\" ; \ncase 'F' : return \"float\" ; \ncase 'I' : return \"int\" ; \ncase 'J' : return \"long\" ; \ncase 'S' : return \"short\" ; \ncase 'Z' : return \"boolean\" ; \ncase 'V' : return \"void\" ; \ncase 'L' : int index = desc . indexOf ( ';' , fromIndex ) ; \nif ( index < 0 ) { \nthrow new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \n} \nfrom . set ( index + 1 ) ; \nString str = desc . substring ( fromIndex + 1 , index ) ; \nreturn str . replace ( '/' , '.' ) ; \ncase 'T' : return desc . substring ( from . value ) ; \ncase '[' : StringBuilder brackets = new StringBuilder ( ) ; \nint n = fromIndex ; \nwhile ( desc . charAt ( n ) == '[' ) { \nbrackets . append ( \"[]\" ) ; \nn = n + 1 ; \n} \nfrom . value = n ; \nString type = typedescToSignature ( desc , from ) ; \nreturn type + brackets ; \ndefault : if ( from . value == 0 ) { \nthrow new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \n} \nreturn desc . substring ( from . value ) ; \n} \n} \n} \n"}
{"1226": "public class Label { \nfinal void addLineNumber ( final int lineNumber ) { \nif ( this . lineNumber == 0 ) { \nthis . lineNumber = ( short ) lineNumber ; \n} \nelse { \nif ( otherLineNumbers == null ) { \notherLineNumbers = new int [ LINE_NUMBERS_CAPACITY_INCREMENT ] ; \n} \nint otherLineNumberIndex = otherLineNumbers [ 0 ] = otherLineNumbers [ 0 ] + 1 ; \nif ( otherLineNumberIndex >= otherLineNumbers . length ) { \nint [ ] newLineNumbers = new int [ otherLineNumbers . length + LINE_NUMBERS_CAPACITY_INCREMENT ] ; \nSystem . arraycopy ( otherLineNumbers , 0 , newLineNumbers , 0 , otherLineNumbers . length ) ; \notherLineNumbers = newLineNumbers ; \n} \notherLineNumbers [ otherLineNumberIndex ] = lineNumber ; \n} \n} \n} \n"}
{"1227": "public class Label { \nfinal void accept ( final MethodVisitor methodVisitor , final boolean visitLineNumbers ) { \nmethodVisitor . visitLabel ( this ) ; \nif ( visitLineNumbers && lineNumber != 0 ) { \nmethodVisitor . visitLineNumber ( lineNumber & 0xFFFF , this ) ; \nif ( otherLineNumbers != null ) { \nfor ( int i = 1 ; \ni <= otherLineNumbers [ 0 ] ; \ni = i + 1 ) { \nmethodVisitor . visitLineNumber ( otherLineNumbers [ i ] , this ) ; \n} \n} \n} \n} \n} \n"}
{"1229": "public class Label { \nprivate void addForwardReference ( final int sourceInsnBytecodeOffset , final int referenceType , final int referenceHandle ) { \nif ( forwardReferences == null ) { \nforwardReferences = new int [ FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; \n} \nint lastElementIndex = forwardReferences [ 0 ] ; \nif ( lastElementIndex + 2 >= forwardReferences . length ) { \nint [ ] newValues = new int [ forwardReferences . length + FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; \nSystem . arraycopy ( forwardReferences , 0 , newValues , 0 , forwardReferences . length ) ; \nforwardReferences = newValues ; \n} \nforwardReferences [ lastElementIndex = lastElementIndex + 1 ] = sourceInsnBytecodeOffset ; \nforwardReferences [ lastElementIndex = lastElementIndex + 1 ] = referenceType | referenceHandle ; \nforwardReferences [ 0 ] = lastElementIndex ; \n} \n} \n"}
{"1230": "public class Label { \nfinal boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { \nthis . flags |= FLAG_RESOLVED ; \nthis . bytecodeOffset = bytecodeOffset ; \nif ( forwardReferences == null ) { \nreturn false ; \n} \nboolean hasAsmInstructions = false ; \nfor ( int i = forwardReferences [ 0 ] ; \ni > 0 ; \ni -= 2 ) { \nfinal int sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; \nfinal int reference = forwardReferences [ i ] ; \nfinal int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; \nint handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; \nif ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) { \nif ( relativeOffset < Short . MIN_VALUE || relativeOffset > Short . MAX_VALUE ) { \nint opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; \nif ( opcode < Opcodes . IFNULL ) { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; \n} \nelse { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; \n} \nhasAsmInstructions = true ; \n} \ncode [ handle = handle + 1 ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \nelse { \ncode [ handle = handle + 1 ] = ( byte ) ( relativeOffset >>> 24 ) ; \ncode [ handle = handle + 1 ] = ( byte ) ( relativeOffset >>> 16 ) ; \ncode [ handle = handle + 1 ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \n} \nreturn hasAsmInstructions ; \n} \n} \n"}
{"1233": "public class NaturalOrderComparator { \nprotected int [ ] compareDigits ( final String str1 , int ndx1 , final String str2 , int ndx2 ) { \nint zeroCount1 = 0 ; \nwhile ( charAt ( str1 , ndx1 ) == '0' ) { \nzeroCount1 = zeroCount1 + 1 ; \nndx1 = ndx1 + 1 ; \n} \nint len1 = 0 ; \nwhile ( true ) { \nfinal char char1 = charAt ( str1 , ndx1 ) ; \nfinal boolean isDigitChar1 = CharUtil . isDigit ( char1 ) ; \nif ( ! isDigitChar1 ) { \nbreak ; \n} \nlen1 = len1 + 1 ; \nndx1 = ndx1 + 1 ; \n} \nint zeroCount2 = 0 ; \nwhile ( charAt ( str2 , ndx2 ) == '0' ) { \nzeroCount2 = zeroCount2 + 1 ; \nndx2 = ndx2 + 1 ; \n} \nint len2 = 0 ; \nint ndx1_new = ndx1 - len1 ; \nint equalNumbers = 0 ; \nwhile ( true ) { \nfinal char char2 = charAt ( str2 , ndx2 ) ; \nfinal boolean isDigitChar2 = CharUtil . isDigit ( char2 ) ; \nif ( ! isDigitChar2 ) { \nbreak ; \n} \nif ( equalNumbers == 0 && ( ndx1_new < ndx1 ) ) { \nequalNumbers = charAt ( str1 , ndx1_new = ndx1_new + 1 ) - char2 ; \n} \nlen2 = len2 + 1 ; \nndx2 = ndx2 + 1 ; \n} \nif ( len1 != len2 ) { \nreturn new int [ ] { \nlen1 - len2 } \n; \n} \nif ( equalNumbers != 0 ) { \nreturn new int [ ] { \nequalNumbers } \n; \n} \nreturn new int [ ] { \n0 , zeroCount1 - zeroCount2 , ndx1 , ndx2 } \n; \n} \n} \n"}
{"1235": "public class ByteVector { \npublic ByteVector putByte ( final int byteValue ) { \nint currentLength = length ; \nif ( currentLength + 1 > data . length ) { \nenlarge ( 1 ) ; \n} \ndata [ currentLength = currentLength + 1 ] = ( byte ) byteValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1236": "public class ByteVector { \nfinal ByteVector put11 ( final int byteValue1 , final int byteValue2 ) { \nint currentLength = length ; \nif ( currentLength + 2 > data . length ) { \nenlarge ( 2 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) byteValue1 ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) byteValue2 ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1237": "public class ByteVector { \npublic ByteVector putShort ( final int shortValue ) { \nint currentLength = length ; \nif ( currentLength + 2 > data . length ) { \nenlarge ( 2 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1238": "public class ByteVector { \nfinal ByteVector put12 ( final int byteValue , final int shortValue ) { \nint currentLength = length ; \nif ( currentLength + 3 > data . length ) { \nenlarge ( 3 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) byteValue ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1239": "public class ByteVector { \nfinal ByteVector put112 ( final int byteValue1 , final int byteValue2 , final int shortValue ) { \nint currentLength = length ; \nif ( currentLength + 4 > data . length ) { \nenlarge ( 4 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) byteValue1 ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) byteValue2 ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1240": "public class ByteVector { \npublic ByteVector putInt ( final int intValue ) { \nint currentLength = length ; \nif ( currentLength + 4 > data . length ) { \nenlarge ( 4 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) intValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1241": "public class ByteVector { \nfinal ByteVector put122 ( final int byteValue , final int shortValue1 , final int shortValue2 ) { \nint currentLength = length ; \nif ( currentLength + 5 > data . length ) { \nenlarge ( 5 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) byteValue ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( shortValue1 >>> 8 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) shortValue1 ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( shortValue2 >>> 8 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) shortValue2 ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1242": "public class ByteVector { \npublic ByteVector putLong ( final long longValue ) { \nint currentLength = length ; \nif ( currentLength + 8 > data . length ) { \nenlarge ( 8 ) ; \n} \nbyte [ ] currentData = data ; \nint intValue = ( int ) ( longValue >>> 32 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) intValue ; \nintValue = ( int ) longValue ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength = currentLength + 1 ] = ( byte ) intValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1272": "public class ExceptionUtil { \npublic static StackTraceElement [ ] [ ] getStackTraceChain ( Throwable t , final String [ ] allow , final String [ ] deny ) { \nArrayList < StackTraceElement [ ] > result = new ArrayList < > ( ) ; \nwhile ( t != null ) { \nStackTraceElement [ ] stack = getStackTrace ( t , allow , deny ) ; \nresult . add ( stack ) ; \nt = t . getCause ( ) ; \n} \nStackTraceElement [ ] [ ] allStacks = new StackTraceElement [ result . size ( ) ] [ ] ; \nfor ( int i = 0 ; \ni < allStacks . length ; \ni = i + 1 ) { \nallStacks [ i ] = result . get ( i ) ; \n} \nreturn allStacks ; \n} \n} \n"}
{"1304": "public class URLCoder { \nprivate static String encodeUriComponent ( final String source , final String encoding , final URIPart uriPart ) { \nif ( source == null ) { \nreturn null ; \n} \nbyte [ ] bytes = encodeBytes ( StringUtil . getBytes ( source , encoding ) , uriPart ) ; \nchar [ ] chars = new char [ bytes . length ] ; \nfor ( int i = 0 ; \ni < bytes . length ; \ni = i + 1 ) { \nchars [ i ] = ( char ) bytes [ i ] ; \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1313": "public class Properties { \nprotected HashMap < String , PropertyDescriptor > inspectProperties ( ) { \nboolean scanAccessible = classDescriptor . isScanAccessible ( ) ; \nClass type = classDescriptor . getType ( ) ; \nHashMap < String , PropertyDescriptor > map = new HashMap < > ( ) ; \nMethod [ ] methods = scanAccessible ? ClassUtil . getAccessibleMethods ( type ) : ClassUtil . getSupportedMethods ( type ) ; \nfor ( int iteration = 0 ; \niteration < 2 ; \niteration = iteration + 1 ) { \nfor ( Method method : methods ) { \nif ( Modifier . isStatic ( method . getModifiers ( ) ) ) { \ncontinue ; \n} \nboolean add = false ; \nboolean issetter = false ; \nString propertyName ; \nif ( iteration == 0 ) { \npropertyName = ClassUtil . getBeanPropertyGetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = false ; \n} \n} \nelse { \npropertyName = ClassUtil . getBeanPropertySetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = true ; \n} \n} \nif ( add ) { \nMethodDescriptor methodDescriptor = classDescriptor . getMethodDescriptor ( method . getName ( ) , method . getParameterTypes ( ) , true ) ; \naddProperty ( map , propertyName , methodDescriptor , issetter ) ; \n} \n} \n} \nif ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { \nFieldDescriptor [ ] fieldDescriptors = classDescriptor . getAllFieldDescriptors ( ) ; \nString [ ] prefix = classDescriptor . getPropertyFieldPrefix ( ) ; \nfor ( FieldDescriptor fieldDescriptor : fieldDescriptors ) { \nField field = fieldDescriptor . getField ( ) ; \nif ( Modifier . isStatic ( field . getModifiers ( ) ) ) { \ncontinue ; \n} \nString name = field . getName ( ) ; \nif ( prefix != null ) { \nfor ( String p : prefix ) { \nif ( ! name . startsWith ( p ) ) { \ncontinue ; \n} \nname = name . substring ( p . length ( ) ) ; \nbreak ; \n} \n} \nif ( ! map . containsKey ( name ) ) { \nmap . put ( name , createPropertyDescriptor ( name , fieldDescriptor ) ) ; \n} \n} \n} \nreturn map ; \n} \n} \n"}
{"1314": "public class Properties { \npublic PropertyDescriptor [ ] getAllPropertyDescriptors ( ) { \nif ( allProperties == null ) { \nPropertyDescriptor [ ] allProperties = new PropertyDescriptor [ propertyDescriptors . size ( ) ] ; \nint index = 0 ; \nfor ( PropertyDescriptor propertyDescriptor : propertyDescriptors . values ( ) ) { \nallProperties [ index ] = propertyDescriptor ; \nindex = index + 1 ; \n} \nArrays . sort ( allProperties , new Comparator < PropertyDescriptor > ( ) { \n@ Override public int compare ( final PropertyDescriptor pd1 , final PropertyDescriptor pd2 ) { \nreturn pd1 . getName ( ) . compareTo ( pd2 . getName ( ) ) ; \n} \n} \n) ; \nthis . allProperties = allProperties ; \n} \nreturn allProperties ; \n} \n} \n"}
{"1320": "public class BlockCipher { \npublic byte [ ] encrypt ( final byte [ ] content ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nint length = content . length + 1 ; \nint blockCount = length / blockSizeInBytes ; \nint remaining = length ; \nint offset = 0 ; \nfor ( int i = 0 ; \ni < blockCount ; \ni = i + 1 ) { \nif ( remaining == blockSizeInBytes ) { \nbreak ; \n} \nbyte [ ] encrypted = encryptBlock ( content , offset ) ; \nfbb . append ( encrypted ) ; \noffset += blockSizeInBytes ; \nremaining -= blockSizeInBytes ; \n} \nif ( remaining != 0 ) { \nbyte [ ] block = new byte [ blockSizeInBytes ] ; \nSystem . arraycopy ( content , offset , block , 0 , remaining - 1 ) ; \nblock [ remaining - 1 ] = TERMINATOR ; \nbyte [ ] encrypted = encryptBlock ( block , 0 ) ; \nfbb . append ( encrypted ) ; \n} \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1321": "public class BlockCipher { \npublic byte [ ] decrypt ( final byte [ ] encryptedContent ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nint length = encryptedContent . length ; \nint blockCount = length / blockSizeInBytes ; \nint offset = 0 ; \nfor ( int i = 0 ; \ni < blockCount - 1 ; \ni = i + 1 ) { \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nfbb . append ( decrypted ) ; \noffset += blockSizeInBytes ; \n} \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nint ndx = blockSizeInBytes - 1 ; \nwhile ( ndx >= 0 ) { \nif ( decrypted [ ndx ] == TERMINATOR ) { \nbreak ; \n} \nndx = ndx - 1 ; \n} \nfbb . append ( decrypted , 0 , ndx ) ; \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1323": "public class MapToBean { \nprivate Object generifyList ( final List list , final Class componentType ) { \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni = i + 1 ) { \nObject element = list . get ( i ) ; \nif ( element != null ) { \nif ( element instanceof Map ) { \nObject bean = map2bean ( ( Map ) element , componentType ) ; \nlist . set ( i , bean ) ; \n} \nelse { \nObject value = convert ( element , componentType ) ; \nlist . set ( i , value ) ; \n} \n} \n} \nreturn list ; \n} \n} \n"}
{"1351": "public class DbQueryBase { \npublic ResultSet getGeneratedColumns ( ) { \ncheckInitialized ( ) ; \nif ( generatedColumns == null ) { \nthrow new DbSqlException ( this , \"No column is specified as auto-generated\" ) ; \n} \nfinal ResultSet rs ; \ntry { \nrs = statement . getGeneratedKeys ( ) ; \n} \ncatch ( SQLException sex ) { \nthrow new DbSqlException ( this , \"No generated keys\" , sex ) ; \n} \nsaveResultSet ( rs ) ; \ntotalOpenResultSetCount = totalOpenResultSetCount + 1 ; \nreturn rs ; \n} \n} \n"}
{"1369": "public class DefaultResultSetMapper { \nprotected String [ ] [ ] resolveMappedTypesTableNames ( final Class [ ] types ) { \nif ( cachedMappedNames == null ) { \nString [ ] [ ] names = new String [ types . length ] [ ] ; \nfor ( int i = 0 ; \ni < types . length ; \ni = i + 1 ) { \nClass type = types [ i ] ; \nif ( type != null ) { \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded != null ) { \nClass [ ] mappedTypes = ded . getMappedTypes ( ) ; \nif ( mappedTypes != null ) { \nnames [ i ] = createTypesTableNames ( mappedTypes ) ; \n} \n} \n} \n} \ncachedMappedNames = names ; \n} \nreturn cachedMappedNames ; \n} \n} \n"}
{"1370": "public class DefaultResultSetMapper { \nprotected String [ ] createTypesTableNames ( final Class [ ] types ) { \nString [ ] names = new String [ types . length ] ; \nfor ( int i = 0 ; \ni < types . length ; \ni = i + 1 ) { \nif ( types [ i ] == null ) { \nnames [ i ] = null ; \ncontinue ; \n} \nDbEntityDescriptor ded = dbEntityManager . lookupType ( types [ i ] ) ; \nif ( ded != null ) { \nString tableName = ded . getTableName ( ) ; \ntableName = tableName . toUpperCase ( ) ; \nnames [ i ] = tableName ; \n} \n} \nreturn names ; \n} \n} \n"}
{"1372": "public class DefaultResultSetMapper { \nprotected void cacheResultSetEntities ( final Object [ ] result ) { \nif ( entitiesCache == null ) { \nentitiesCache = new HashMap < > ( ) ; \n} \nfor ( int i = 0 ; \ni < result . length ; \ni = i + 1 ) { \nObject object = result [ i ] ; \nif ( object == null ) { \ncontinue ; \n} \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded == null ) { \ncontinue ; \n} \nObject key ; \nif ( ded . hasIdColumn ( ) ) { \nkey = ded . getKeyValue ( object ) ; \n} \nelse { \nkey = object ; \n} \nObject cachedObject = entitiesCache . get ( key ) ; \nif ( cachedObject == null ) { \nentitiesCache . put ( key , object ) ; \n} \nelse { \nresult [ i ] = cachedObject ; \n} \n} \n} \n} \n"}
{"1413": "public class LoopIterator { \npublic boolean next ( ) { \nif ( ! looping ) { \nreturn false ; \n} \nif ( last ) { \nreturn false ; \n} \nif ( count == 0 ) { \nvalue = start ; \nfirst = true ; \n} \nelse { \nvalue += step ; \nfirst = false ; \n} \ncount = count + 1 ; \nlast = isLastIteration ( value + step ) ; \nreturn true ; \n} \n} \n"}
{"1416": "public class Scanner { \npublic final boolean matchUpperCase ( final char [ ] uppercaseTarget ) { \nif ( ndx + uppercaseTarget . length > total ) { \nreturn false ; \n} \nint j = ndx ; \nfor ( int i = 0 ; \ni < uppercaseTarget . length ; \ni = i + 1 , j = j + 1 ) { \nfinal char c = CharUtil . toUpperAscii ( input [ j ] ) ; \nif ( c != uppercaseTarget [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1428": "public class TemplateParser { \npublic void parse ( final DbSqlBuilder sqlBuilder , final String template ) { \nint length = template . length ( ) ; \nint last = 0 ; \nwhile ( true ) { \nint mark = template . indexOf ( '$' , last ) ; \nif ( mark == - 1 ) { \nif ( last < length ) { \nsqlBuilder . appendRaw ( template . substring ( last ) ) ; \n} \nbreak ; \n} \nint escapesCount = countEscapes ( template , mark ) ; \nif ( escapesCount > 0 ) { \nboolean isEscaped = escapesCount % 2 != 0 ; \nint escapesToAdd = escapesCount >> 1 ; \nsqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + '$' ) ; \nif ( isEscaped ) { \nlast = mark + 1 ; \ncontinue ; \n} \n} \nelse { \nsqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; \n} \nint end ; \nif ( template . startsWith ( MACRO_TABLE , mark ) ) { \nmark += MACRO_TABLE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonTable ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_COLUMN , mark ) ) { \nmark += MACRO_COLUMN . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonColumn ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_MATCH , mark ) ) { \nmark += MACRO_MATCH . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonMatch ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_VALUE , mark ) ) { \nmark += MACRO_VALUE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonValue ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nmark = mark + 1 ; \nend = mark ; \nwhile ( end < length ) { \nif ( ! isReferenceChar ( template , end ) ) { \nbreak ; \n} \nend = end + 1 ; \n} \nonReference ( sqlBuilder , template . substring ( mark , end ) ) ; \nend = end - 1 ; \n} \nend = end + 1 ; \nlast = end ; \n} \n} \n} \n"}
{"1430": "public class TemplateParser { \nprotected int countEscapes ( final String template , int macroIndex ) { \nmacroIndex = macroIndex - 1 ; \nint escapeCount = 0 ; \nwhile ( macroIndex >= 0 ) { \nif ( template . charAt ( macroIndex ) != ESCAPE_CHARACTER ) { \nbreak ; \n} \nescapeCount = escapeCount + 1 ; \nmacroIndex = macroIndex - 1 ; \n} \nreturn escapeCount ; \n} \n} \n"}
{"1431": "public class HttpUtil { \npublic static String buildQuery ( final HttpMultiMap < ? > queryMap , final String encoding ) { \nif ( queryMap . isEmpty ( ) ) { \nreturn StringPool . EMPTY ; \n} \nint queryMapSize = queryMap . size ( ) ; \nStringBand query = new StringBand ( queryMapSize * 4 ) ; \nint count = 0 ; \nfor ( Map . Entry < String , ? > entry : queryMap ) { \nString key = entry . getKey ( ) ; \nkey = URLCoder . encodeQueryParam ( key , encoding ) ; \nObject value = entry . getValue ( ) ; \nif ( value == null ) { \nif ( count != 0 ) { \nquery . append ( '&' ) ; \n} \nquery . append ( key ) ; \ncount = count + 1 ; \n} \nelse { \nif ( count != 0 ) { \nquery . append ( '&' ) ; \n} \nquery . append ( key ) ; \ncount = count + 1 ; \nquery . append ( '=' ) ; \nString valueString = URLCoder . encodeQueryParam ( value . toString ( ) , encoding ) ; \nquery . append ( valueString ) ; \n} \n} \nreturn query . toString ( ) ; \n} \n} \n"}
{"1433": "public class HttpUtil { \npublic static String prepareHeaderParameterName ( final String headerName ) { \nif ( headerName . equals ( \"etag\" ) ) { \nreturn HttpBase . HEADER_ETAG ; \n} \nif ( headerName . equals ( \"www-authenticate\" ) ) { \nreturn \"WWW-Authenticate\" ; \n} \nchar [ ] name = headerName . toCharArray ( ) ; \nboolean capitalize = true ; \nfor ( int i = 0 ; \ni < name . length ; \ni = i + 1 ) { \nchar c = name [ i ] ; \nif ( c == '-' ) { \ncapitalize = true ; \ncontinue ; \n} \nif ( capitalize ) { \nname [ i ] = Character . toUpperCase ( c ) ; \ncapitalize = false ; \n} \nelse { \nname [ i ] = Character . toLowerCase ( c ) ; \n} \n} \nreturn new String ( name ) ; \n} \n} \n"}
{"1444": "public class JsonParser { \nprivate void skipObject ( ) { \nint bracketCount = 1 ; \nboolean insideString = false ; \nwhile ( ndx < total ) { \nfinal char c = input [ ndx ] ; \nif ( insideString ) { \nif ( c == '\\\"' && notPrecededByEvenNumberOfBackslashes ( ) ) { \ninsideString = false ; \n} \n} \nelse if ( c == '\\\"' ) { \ninsideString = true ; \n} \nelse if ( c == '{' ) { \nbracketCount = bracketCount + 1 ; \n} \nelse if ( c == '}' ) { \nbracketCount = bracketCount - 1 ; \nif ( bracketCount == 0 ) { \nndx = ndx + 1 ; \nreturn ; \n} \n} \nndx = ndx + 1 ; \n} \n} \n} \n"}
{"1446": "public class JsonParser { \nprotected String parseStringContent ( final char quote ) { \nfinal int startNdx = ndx ; \nwhile ( true ) { \nfinal char c = input [ ndx ] ; \nif ( c == quote ) { \nndx = ndx + 1 ; \nreturn new String ( input , startNdx , ndx - 1 - startNdx ) ; \n} \nif ( c == '\\\\' ) { \nbreak ; \n} \nndx = ndx + 1 ; \n} \ntextLen = ndx - startNdx ; \ngrowEmpty ( ) ; \nSystem . arraycopy ( input , startNdx , text , 0 , textLen ) ; \nwhile ( true ) { \nchar c = input [ ndx ] ; \nif ( c == quote ) { \nndx = ndx + 1 ; \nfinal String str = new String ( text , 0 , textLen ) ; \ntextLen = 0 ; \nreturn str ; \n} \nif ( c == '\\\\' ) { \nndx = ndx + 1 ; \nc = input [ ndx ] ; \nswitch ( c ) { \ncase '\\\"' : c = '\\\"' ; \nbreak ; \ncase '\\\\' : c = '\\\\' ; \nbreak ; \ncase '/' : c = '/' ; \nbreak ; \ncase 'b' : c = '\\b' ; \nbreak ; \ncase 'f' : c = '\\f' ; \nbreak ; \ncase 'n' : c = '\\n' ; \nbreak ; \ncase 'r' : c = '\\r' ; \nbreak ; \ncase 't' : c = '\\t' ; \nbreak ; \ncase 'u' : ndx = ndx + 1 ; \nc = parseUnicode ( ) ; \nbreak ; \ndefault : if ( looseMode ) { \nif ( c != '\\'' ) { \nc = '\\\\' ; \nndx = ndx - 1 ; \n} \n} \nelse { \nsyntaxError ( \"Invalid escape char: \" + c ) ; \n} \n} \n} \ntext [ textLen ] = c ; \ntextLen = textLen + 1 ; \ngrowAndCopy ( ) ; \nndx = ndx + 1 ; \n} \n} \n} \n"}
{"1447": "public class JsonParser { \nprotected char parseUnicode ( ) { \nint i0 = CharUtil . hex2int ( input [ ndx = ndx + 1 ] ) ; \nint i1 = CharUtil . hex2int ( input [ ndx = ndx + 1 ] ) ; \nint i2 = CharUtil . hex2int ( input [ ndx = ndx + 1 ] ) ; \nint i3 = CharUtil . hex2int ( input [ ndx ] ) ; \nreturn ( char ) ( ( i0 << 12 ) + ( i1 << 8 ) + ( i2 << 4 ) + i3 ) ; \n} \n} \n"}
{"1448": "public class JsonParser { \nprotected String parseUnquotedStringContent ( ) { \nfinal int startNdx = ndx ; \nwhile ( true ) { \nfinal char c = input [ ndx ] ; \nif ( c <= ' ' || CharUtil . equalsOne ( c , UNQUOTED_DELIMETERS ) ) { \nfinal int currentNdx = ndx ; \nskipWhiteSpaces ( ) ; \nreturn new String ( input , startNdx , currentNdx - startNdx ) ; \n} \nndx = ndx + 1 ; \n} \n} \n} \n"}
{"1449": "public class JsonParser { \nprotected Number parseNumber ( ) { \nfinal int startIndex = ndx ; \nchar c = input [ ndx ] ; \nboolean isDouble = false ; \nboolean isExp = false ; \nif ( c == '-' ) { \nndx = ndx + 1 ; \n} \nwhile ( true ) { \nif ( isEOF ( ) ) { \nbreak ; \n} \nc = input [ ndx ] ; \nif ( c >= '0' && c <= '9' ) { \nndx = ndx + 1 ; \ncontinue ; \n} \nif ( c <= 32 ) { \nbreak ; \n} \nif ( c == ',' || c == '}' || c == ']' ) { \nbreak ; \n} \nif ( c == '.' ) { \nisDouble = true ; \n} \nelse if ( c == 'e' || c == 'E' ) { \nisExp = true ; \n} \nndx = ndx + 1 ; \n} \nfinal String value = new String ( input , startIndex , ndx - startIndex ) ; \nif ( isDouble ) { \nreturn Double . valueOf ( value ) ; \n} \nlong longNumber ; \nif ( isExp ) { \nlongNumber = Double . valueOf ( value ) . longValue ( ) ; \n} \nelse { \nif ( value . length ( ) >= 19 ) { \nBigInteger bigInteger = new BigInteger ( value ) ; \nif ( isGreaterThanLong ( bigInteger ) ) { \nreturn bigInteger ; \n} \nlongNumber = bigInteger . longValue ( ) ; \n} \nelse { \nlongNumber = Long . parseLong ( value ) ; \n} \n} \nif ( ( longNumber >= Integer . MIN_VALUE ) && ( longNumber <= Integer . MAX_VALUE ) ) { \nreturn ( int ) longNumber ; \n} \nreturn longNumber ; \n} \n} \n"}
{"1450": "public class JsonParser { \nprotected Object parseArrayContent ( Class targetType , Class componentType ) { \nif ( targetType == Object . class ) { \ntargetType = List . class ; \n} \ntargetType = replaceWithMappedTypeForPath ( targetType ) ; \nif ( componentType == null && targetType != null && targetType . isArray ( ) ) { \ncomponentType = targetType . getComponentType ( ) ; \n} \npath . push ( VALUES ) ; \ncomponentType = replaceWithMappedTypeForPath ( componentType ) ; \nCollection < Object > target = newArrayInstance ( targetType ) ; \nboolean koma = false ; \nmainloop : while ( true ) { \nskipWhiteSpaces ( ) ; \nchar c = input [ ndx ] ; \nif ( c == ']' ) { \nif ( koma ) { \nsyntaxError ( \"Trailing comma\" ) ; \n} \nndx = ndx + 1 ; \npath . pop ( ) ; \nreturn target ; \n} \nObject value = parseValue ( componentType , null , null ) ; \ntarget . add ( value ) ; \nskipWhiteSpaces ( ) ; \nc = input [ ndx ] ; \nswitch ( c ) { \ncase ']' : ndx = ndx + 1 ; \nbreak mainloop ; \ncase ',' : ndx = ndx + 1 ; \nkoma = true ; \nbreak ; \ndefault : syntaxError ( \"Invalid char: expected ] or ,\" ) ; \n} \n} \npath . pop ( ) ; \nif ( targetType != null ) { \nreturn convertType ( target , targetType ) ; \n} \nreturn target ; \n} \n} \n"}
{"1456": "public class ReferencesResolver { \npublic BeanReferences [ ] readAllReferencesFromAnnotation ( final Executable methodOrCtor ) { \nPetiteInject petiteInject = methodOrCtor . getAnnotation ( PetiteInject . class ) ; \nfinal Parameter [ ] parameters = methodOrCtor . getParameters ( ) ; \nBeanReferences [ ] references ; \nfinal boolean hasAnnotationOnMethodOrCtor ; \nif ( petiteInject != null ) { \nreferences = convertAnnValueToReferences ( petiteInject . value ( ) ) ; \nhasAnnotationOnMethodOrCtor = true ; \n} \nelse { \nreferences = new BeanReferences [ parameters . length ] ; \nhasAnnotationOnMethodOrCtor = false ; \n} \nint parametersWithAnnotationCount = 0 ; \nfor ( int i = 0 ; \ni < parameters . length ; \ni = i + 1 ) { \nParameter parameter = parameters [ i ] ; \npetiteInject = parameter . getAnnotation ( PetiteInject . class ) ; \nif ( petiteInject == null ) { \ncontinue ; \n} \nString annotationValue = readAnnotationValue ( petiteInject ) ; \nif ( annotationValue != null ) { \nreferences [ i ] = BeanReferences . of ( annotationValue ) ; \n} \nparametersWithAnnotationCount = parametersWithAnnotationCount + 1 ; \n} \nif ( ! hasAnnotationOnMethodOrCtor ) { \nif ( parametersWithAnnotationCount == 0 ) { \nreturn null ; \n} \nif ( parametersWithAnnotationCount != parameters . length ) { \nthrow new PetiteException ( \"All arguments must be annotated with PetiteInject\" ) ; \n} \n} \nreferences = updateReferencesWithDefaultsIfNeeded ( methodOrCtor , references ) ; \nremoveAllDuplicateNames ( references ) ; \nreturn references ; \n} \n} \n"}
{"1457": "public class ReferencesResolver { \nprivate BeanReferences [ ] buildDefaultReferences ( final Executable methodOrCtor ) { \nfinal boolean useParamo = petiteConfig . getUseParamo ( ) ; \nfinal PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; \nMethodParameter [ ] methodParameters = null ; \nif ( useParamo ) { \nmethodParameters = Paramo . resolveParameters ( methodOrCtor ) ; \n} \nfinal Class [ ] paramTypes = methodOrCtor . getParameterTypes ( ) ; \nfinal BeanReferences [ ] references = new BeanReferences [ paramTypes . length ] ; \nfor ( int j = 0 ; \nj < paramTypes . length ; \nj = j + 1 ) { \nString [ ] ref = new String [ lookupReferences . length ] ; \nreferences [ j ] = BeanReferences . of ( ref ) ; \nfor ( int i = 0 ; \ni < ref . length ; \ni = i + 1 ) { \nswitch ( lookupReferences [ i ] ) { \ncase NAME : ref [ i ] = methodParameters != null ? methodParameters [ j ] . getName ( ) : null ; \nbreak ; \ncase TYPE_SHORT_NAME : ref [ i ] = StringUtil . uncapitalize ( paramTypes [ j ] . getSimpleName ( ) ) ; \nbreak ; \ncase TYPE_FULL_NAME : ref [ i ] = paramTypes [ j ] . getName ( ) ; \nbreak ; \n} \n} \n} \nreturn references ; \n} \n} \n"}
{"1458": "public class ReferencesResolver { \npublic BeanReferences buildDefaultReference ( final PropertyDescriptor propertyDescriptor ) { \nfinal PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; \nfinal String [ ] references = new String [ lookupReferences . length ] ; \nfor ( int i = 0 ; \ni < references . length ; \ni = i + 1 ) { \nswitch ( lookupReferences [ i ] ) { \ncase NAME : references [ i ] = propertyDescriptor . getName ( ) ; \nbreak ; \ncase TYPE_SHORT_NAME : references [ i ] = StringUtil . uncapitalize ( propertyDescriptor . getType ( ) . getSimpleName ( ) ) ; \nbreak ; \ncase TYPE_FULL_NAME : references [ i ] = propertyDescriptor . getType ( ) . getName ( ) ; \nbreak ; \n} \n} \nreturn BeanReferences . of ( references ) ; \n} \n} \n"}
{"1459": "public class ReferencesResolver { \nprivate void removeAllDuplicateNames ( final BeanReferences [ ] allBeanReferences ) { \nfor ( int i = 0 ; \ni < allBeanReferences . length ; \ni = i + 1 ) { \nBeanReferences references = allBeanReferences [ i ] ; \nallBeanReferences [ i ] = references . removeDuplicateNames ( ) ; \n} \n} \n} \n"}
{"1460": "public class ReferencesResolver { \nprivate BeanReferences [ ] convertRefToReferences ( final String [ ] references ) { \nif ( references == null ) { \nreturn null ; \n} \nBeanReferences [ ] ref = new BeanReferences [ references . length ] ; \nfor ( int i = 0 ; \ni < references . length ; \ni = i + 1 ) { \nref [ i ] = BeanReferences . of ( references [ i ] ) ; \n} \nreturn ref ; \n} \n} \n"}
{"1461": "public class ReferencesResolver { \nprivate BeanReferences [ ] convertAnnValueToReferences ( String value ) { \nif ( value == null ) { \nreturn null ; \n} \nvalue = value . trim ( ) ; \nif ( value . length ( ) == 0 ) { \nreturn null ; \n} \nString [ ] refNames = Converter . get ( ) . toStringArray ( value ) ; \nBeanReferences [ ] references = new BeanReferences [ refNames . length ] ; \nfor ( int i = 0 ; \ni < refNames . length ; \ni = i + 1 ) { \nreferences [ i ] = BeanReferences . of ( refNames [ i ] . trim ( ) ) ; \n} \nreturn references ; \n} \n} \n"}
{"1466": "public class ClassUtil { \npublic static boolean compareParameters ( final Class [ ] first , final Class [ ] second ) { \nif ( first . length != second . length ) { \nreturn false ; \n} \nfor ( int i = 0 ; \ni < first . length ; \ni = i + 1 ) { \nif ( first [ i ] != second [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1469": "public class ClassUtil { \npublic static Class [ ] getSuperclasses ( final Class type ) { \nint i = 0 ; \nfor ( Class x = type . getSuperclass ( ) ; \nx != null ; \nx = x . getSuperclass ( ) ) { \ni = i + 1 ; \n} \nClass [ ] result = new Class [ i ] ; \ni = 0 ; \nfor ( Class x = type . getSuperclass ( ) ; \nx != null ; \nx = x . getSuperclass ( ) ) { \nresult [ i ] = x ; \ni = i + 1 ; \n} \nreturn result ; \n} \n} \n"}
{"1490": "public class DbListIterator { \n@ Override public T next ( ) { \nif ( hasNext == null ) { \nhasNext = Boolean . valueOf ( moveToNext ( ) ) ; \n} \nif ( hasNext == false ) { \nthrow new NoSuchElementException ( ) ; \n} \nif ( ! entityAwareMode ) { \nhasNext = null ; \nreturn newElement ; \n} \ncount = count + 1 ; \nT result = previousElement ; \npreviousElement = newElement ; \nhasNext = null ; \nreturn result ; \n} \n} \n"}
{"1497": "public class ArraysUtil { \npublic static int indexOf ( char [ ] array , char value ) { \nfor ( int i = 0 ; \ni < array . length ; \ni = i + 1 ) { \nif ( array [ i ] == value ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1498": "public class ArraysUtil { \npublic static int indexOf ( Object [ ] array , Object value ) { \nfor ( int i = 0 ; \ni < array . length ; \ni = i + 1 ) { \nif ( array [ i ] . equals ( value ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1503": "public class MethodWriter { \nprivate void computeMaxStackAndLocal ( ) { \nHandler handler = firstHandler ; \nwhile ( handler != null ) { \nLabel handlerBlock = handler . handlerPc ; \nLabel handlerRangeBlock = handler . startPc ; \nLabel handlerRangeEnd = handler . endPc ; \nwhile ( handlerRangeBlock != handlerRangeEnd ) { \nif ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) { \nhandlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; \n} \nelse { \nhandlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; \n} \nhandlerRangeBlock = handlerRangeBlock . nextBasicBlock ; \n} \nhandler = handler . nextHandler ; \n} \nif ( hasSubroutines ) { \nshort numSubroutines = 1 ; \nfirstBasicBlock . markSubroutine ( numSubroutines ) ; \nfor ( short currentSubroutine = 1 ; \ncurrentSubroutine <= numSubroutines ; \ncurrentSubroutine = currentSubroutine + 1 ) { \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 && basicBlock . subroutineId == currentSubroutine ) { \nLabel jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; \nif ( jsrTarget . subroutineId == 0 ) { \njsrTarget . markSubroutine ( numSubroutines = numSubroutines + 1 ) ; \n} \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \nLabel subroutine = basicBlock . outgoingEdges . nextEdge . successor ; \nsubroutine . addSubroutineRetSuccessors ( basicBlock ) ; \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel listOfBlocksToProcess = firstBasicBlock ; \nlistOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; \nint maxStackSize = maxStack ; \nwhile ( listOfBlocksToProcess != Label . EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; \nint inputStackTop = basicBlock . inputStackSize ; \nint maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; \nif ( maxBlockStackSize > maxStackSize ) { \nmaxStackSize = maxBlockStackSize ; \n} \nEdge outgoingEdge = basicBlock . outgoingEdges ; \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \noutgoingEdge = outgoingEdge . nextEdge ; \n} \nwhile ( outgoingEdge != null ) { \nLabel successorBlock = outgoingEdge . successor ; \nif ( successorBlock . nextListElement == null ) { \nsuccessorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; \nsuccessorBlock . nextListElement = listOfBlocksToProcess ; \nlistOfBlocksToProcess = successorBlock ; \n} \noutgoingEdge = outgoingEdge . nextEdge ; \n} \n} \nthis . maxStack = maxStackSize ; \n} \n} \n"}
{"1518": "public class HtmlStaplerBundlesManager { \npublic synchronized String registerBundle ( final String contextPath , final String actionPath , final String tempBundleId , final String bundleContentType , final List < String > sources ) { \nif ( tempBundleId == null || sources . isEmpty ( ) ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , StringPool . EMPTY ) ; \n} \nreturn null ; \n} \nString [ ] sourcesArray = sources . toArray ( new String [ 0 ] ) ; \nfor ( int i = 0 , sourcesArrayLength = sourcesArray . length ; \ni < sourcesArrayLength ; \ni = i + 1 ) { \nsourcesArray [ i ] = sourcesArray [ i ] . trim ( ) . toLowerCase ( ) ; \n} \nif ( sortResources ) { \nArrays . sort ( sourcesArray ) ; \n} \nStringBand sb = new StringBand ( sourcesArray . length ) ; \nfor ( String src : sourcesArray ) { \nsb . append ( src ) ; \n} \nString sourcesString = sb . toString ( ) ; \nString bundleId = createDigest ( sourcesString ) ; \nbundleId += '.' + bundleContentType ; \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , bundleId ) ; \nmirrors . put ( tempBundleId , bundleId ) ; \n} \ntry { \ncreateBundle ( contextPath , actionPath , bundleId , sources ) ; \n} \ncatch ( IOException ioex ) { \nthrow new HtmlStaplerException ( \"Can't create bundle\" , ioex ) ; \n} \nreturn bundleId ; \n} \n} \n"}
{"1521": "public class HtmlStaplerBundlesManager { \npublic synchronized void reset ( ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . clear ( ) ; \nmirrors . clear ( ) ; \n} \nfinal FindFile ff = new FindFile ( ) ; \nff . includeDirs ( false ) ; \nff . searchPath ( new File ( bundleFolder , staplerPath ) ) ; \nFile f ; \nint count = 0 ; \nwhile ( ( f = ff . nextFile ( ) ) != null ) { \nf . delete ( ) ; \ncount = count + 1 ; \n} \nif ( log . isInfoEnabled ( ) ) { \nlog . info ( \"reset: \" + count + \" bundle files deleted.\" ) ; \n} \n} \n} \n"}
{"1545": "public class AnnotationTxAdviceManager { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public void registerAnnotations ( final Class < ? extends Annotation > [ ] annotations ) { \nthis . annotations = annotations ; \nthis . annotationParsers = new AnnotationParser [ annotations . length ] ; \nfor ( int i = 0 ; \ni < annotations . length ; \ni = i + 1 ) { \nannotationParsers [ i ] = TransactionAnnotationValues . parserFor ( annotations [ i ] ) ; \n} \n} \n} \n"}
{"1547": "public class CssSelector { \n@ Override public boolean accept ( final Node node ) { \nif ( ! matchElement ( node ) ) { \nreturn false ; \n} \nint totalSelectors = selectorsCount ( ) ; \nfor ( int i = 0 ; \ni < totalSelectors ; \ni = i + 1 ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase ATTRIBUTE : if ( ! ( ( AttributeSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1549": "public class CssSelector { \npublic boolean accept ( final List < Node > currentResults , final Node node , final int index ) { \nint totalSelectors = selectorsCount ( ) ; \nfor ( int i = 0 ; \ni < totalSelectors ; \ni = i + 1 ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( currentResults , node , index ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( currentResults , node , index ) ) { \nreturn false ; \n} \nbreak ; \ndefault : } \n} \nreturn true ; \n} \n} \n"}
{"1552": "public class Node { \nprotected < T extends Node > T cloneTo ( final T dest ) { \ndest . parentNode = parentNode ; \nif ( attributes != null ) { \ndest . attributes = new ArrayList < > ( attributes . size ( ) ) ; \nfor ( int i = 0 , attributesSize = attributes . size ( ) ; \ni < attributesSize ; \ni = i + 1 ) { \nAttribute attr = attributes . get ( i ) ; \ndest . attributes . add ( attr . clone ( ) ) ; \n} \n} \nif ( childNodes != null ) { \ndest . childNodes = new ArrayList < > ( childNodes . size ( ) ) ; \nfor ( int i = 0 , childNodesSize = childNodes . size ( ) ; \ni < childNodesSize ; \ni = i + 1 ) { \nNode child = childNodes . get ( i ) ; \nNode childClone = child . clone ( ) ; \nchildClone . parentNode = dest ; \ndest . childNodes . add ( childClone ) ; \n} \n} \nreturn dest ; \n} \n} \n"}
{"1560": "public class Node { \npublic void removeAllChilds ( ) { \nList < Node > removedNodes = childNodes ; \nchildNodes = null ; \nchildElementNodes = null ; \nchildElementNodesCount = 0 ; \nif ( removedNodes != null ) { \nfor ( int i = 0 , removedNodesSize = removedNodes . size ( ) ; \ni < removedNodesSize ; \ni = i + 1 ) { \nNode removedNode = removedNodes . get ( i ) ; \nremovedNode . detachFromParent ( ) ; \n} \n} \n} \n} \n"}
{"1563": "public class Node { \npublic boolean check ( ) { \nif ( childNodes == null ) { \nreturn true ; \n} \nint siblingElementIndex = 0 ; \nfor ( int i = 0 , childNodesSize = childNodes . size ( ) ; \ni < childNodesSize ; \ni = i + 1 ) { \nNode childNode = childNodes . get ( i ) ; \nif ( childNode . siblingIndex != i ) { \nreturn false ; \n} \nif ( childNode . getNodeType ( ) == NodeType . ELEMENT ) { \nif ( childNode . siblingElementIndex != siblingElementIndex ) { \nreturn false ; \n} \nsiblingElementIndex = siblingElementIndex + 1 ; \n} \n} \nif ( childElementNodesCount != siblingElementIndex ) { \nreturn false ; \n} \nif ( childElementNodes != null ) { \nif ( childElementNodes . length != childElementNodesCount ) { \nreturn false ; \n} \nint childCount = getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni = i + 1 ) { \nNode child = getChild ( i ) ; \nif ( child . siblingElementIndex >= 0 ) { \nif ( childElementNodes [ child . siblingElementIndex ] != child ) { \nreturn false ; \n} \n} \n} \n} \nif ( siblingNameIndex != - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \nfor ( int i = 0 , siblingsSize = siblings . size ( ) ; \ni < siblingsSize ; \ni = i + 1 ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nif ( sibling . siblingNameIndex != index = index + 1 ) { \nreturn false ; \n} \n} \n} \n} \nfor ( Node childNode : childNodes ) { \nif ( ! childNode . check ( ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1564": "public class Node { \nprotected void initChildElementNodes ( ) { \nif ( childElementNodes == null ) { \nchildElementNodes = new Element [ childElementNodesCount ] ; \nint childCount = getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni = i + 1 ) { \nNode child = getChild ( i ) ; \nif ( child . siblingElementIndex >= 0 ) { \nchildElementNodes [ child . siblingElementIndex ] = ( Element ) child ; \n} \n} \n} \n} \n} \n"}
{"1565": "public class Node { \nprotected void initSiblingNames ( ) { \nif ( siblingNameIndex == - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \nfor ( int i = 0 , siblingsSize = siblings . size ( ) ; \ni < siblingsSize ; \ni = i + 1 ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nsibling . siblingNameIndex = index = index + 1 ; \n} \n} \n} \n} \n} \n"}
{"1567": "public class Node { \nprotected void changeOwnerDocument ( final Node node , final Document ownerDocument ) { \nnode . ownerDocument = ownerDocument ; \nint childCount = node . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni = i + 1 ) { \nNode child = node . getChild ( i ) ; \nchangeOwnerDocument ( child , ownerDocument ) ; \n} \n} \n} \n"}
{"1568": "public class Node { \npublic Node getPreviousSiblingName ( ) { \nif ( nodeName == null ) { \nreturn null ; \n} \ninitSiblingNames ( ) ; \nint index = siblingNameIndex - 1 ; \nfor ( int i = siblingIndex ; \ni >= 0 ; \ni = i - 1 ) { \nNode sibling = parentNode . childNodes . get ( i ) ; \nif ( ( index == sibling . siblingNameIndex ) && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nreturn sibling ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1572": "public class Node { \nprotected void visitChildren ( final NodeVisitor nodeVisitor ) { \nif ( childNodes != null ) { \nfor ( int i = 0 , childNodesSize = childNodes . size ( ) ; \ni < childNodesSize ; \ni = i + 1 ) { \nNode childNode = childNodes . get ( i ) ; \nchildNode . visit ( nodeVisitor ) ; \n} \n} \n} \n} \n"}
{"1578": "public class RootPackages { \npublic void addRootPackage ( final String rootPackage , String mapping ) { \nif ( packages == null ) { \npackages = new String [ 0 ] ; \n} \nif ( mappings == null ) { \nmappings = new String [ 0 ] ; \n} \nif ( mapping . length ( ) > 0 ) { \nif ( ! mapping . startsWith ( StringPool . SLASH ) ) { \nmapping = StringPool . SLASH + mapping ; \n} \nif ( mapping . endsWith ( StringPool . SLASH ) ) { \nmapping = StringUtil . substring ( mapping , 0 , - 1 ) ; \n} \n} \nfor ( int i = 0 ; \ni < packages . length ; \ni = i + 1 ) { \nif ( packages [ i ] . equals ( rootPackage ) ) { \nif ( mappings [ i ] . equals ( mapping ) ) { \nreturn ; \n} \nthrow new MadvocException ( \"Different mappings for the same root package: \" + rootPackage ) ; \n} \n} \npackages = ArraysUtil . append ( packages , rootPackage ) ; \nmappings = ArraysUtil . append ( mappings , mapping ) ; \n} \n} \n"}
{"1580": "public class RootPackages { \npublic String findRootPackageForActionPath ( final String actionPath ) { \nif ( mappings == null ) { \nreturn null ; \n} \nint ndx = - 1 ; \nint delta = Integer . MAX_VALUE ; \nfor ( int i = 0 ; \ni < mappings . length ; \ni = i + 1 ) { \nString mapping = mappings [ i ] ; \nboolean found = false ; \nif ( actionPath . equals ( mapping ) ) { \nfound = true ; \n} \nelse { \nmapping += StringPool . SLASH ; \nif ( actionPath . startsWith ( mapping ) ) { \nfound = true ; \n} \n} \nif ( found ) { \nint distance = actionPath . length ( ) - mapping . length ( ) ; \nif ( distance < delta ) { \nndx = i ; \ndelta = distance ; \n} \n} \n} \nif ( ndx == - 1 ) { \nreturn null ; \n} \nreturn packages [ ndx ] ; \n} \n} \n"}
{"1582": "public class BeanReferences { \npublic BeanReferences removeDuplicateNames ( ) { \nif ( names . length < 2 ) { \nreturn this ; \n} \nint nullCount = 0 ; \nfor ( int i = 1 ; \ni < names . length ; \ni = i + 1 ) { \nString thisRef = names [ i ] ; \nif ( thisRef == null ) { \nnullCount = nullCount + 1 ; \ncontinue ; \n} \nfor ( int j = 0 ; \nj < i ; \nj = j + 1 ) { \nif ( names [ j ] == null ) { \ncontinue ; \n} \nif ( thisRef . equals ( names [ j ] ) ) { \nnames [ i ] = null ; \nbreak ; \n} \n} \n} \nif ( nullCount == 0 ) { \nreturn this ; \n} \nString [ ] newRefs = new String [ names . length - nullCount ] ; \nint ndx = 0 ; \nfor ( String name : names ) { \nif ( name == null ) { \ncontinue ; \n} \nnewRefs [ ndx ] = name ; \nndx = ndx + 1 ; \n} \nreturn new BeanReferences ( newRefs ) ; \n} \n} \n"}
{"1587": "public class Targets { \npublic Object [ ] extractParametersValues ( ) { \nfinal Object [ ] values = new Object [ targets . length - 1 ] ; \nfor ( int i = 1 ; \ni < targets . length ; \ni = i + 1 ) { \nvalues [ i - 1 ] = targets [ i ] . value ( ) ; \n} \nreturn values ; \n} \n} \n"}
{"1588": "public class Targets { \nprotected Target [ ] makeTargets ( final Target actionTarget , final MethodParam [ ] methodParams ) { \nif ( methodParams == null ) { \nreturn new Target [ ] { \nactionTarget } \n; \n} \nfinal Target [ ] target = new Target [ methodParams . length + 1 ] ; \ntarget [ 0 ] = actionTarget ; \nfinal Object action = actionTarget . value ( ) ; \nfor ( int i = 0 ; \ni < methodParams . length ; \ni = i + 1 ) { \nfinal MethodParam methodParam = methodParams [ i ] ; \nfinal Class paramType = methodParam . type ( ) ; \nfinal Target paramTarget ; \nif ( methodParam . annotationType ( ) == null ) { \nfinal ScopeData newScopeData = methodParam . scopeData ( ) . inspector ( ) . inspectClassScopesWithCache ( paramType ) ; \nparamTarget = Target . ofValue ( createActionMethodArgument ( paramType , action ) , newScopeData ) ; \n} \nelse if ( methodParam . annotationType ( ) == Out . class ) { \nparamTarget = Target . ofMethodParam ( methodParam , createActionMethodArgument ( paramType , action ) ) ; \n} \nelse { \nparamTarget = Target . ofMethodParam ( methodParam , type -> createActionMethodArgument ( type , action ) ) ; \n} \ntarget [ i + 1 ] = paramTarget ; \n} \nreturn target ; \n} \n} \n"}
{"1597": "public class FormProcessorVisitor { \nprotected String valueToString ( final String name , final Object valueObject ) { \nif ( ! valueObject . getClass ( ) . isArray ( ) ) { \nreturn valueObject . toString ( ) ; \n} \nString [ ] array = ( String [ ] ) valueObject ; \nif ( valueNameIndexes == null ) { \nvalueNameIndexes = new HashMap < > ( ) ; \n} \nMutableInteger index = valueNameIndexes . get ( name ) ; \nif ( index == null ) { \nindex = new MutableInteger ( 0 ) ; \nvalueNameIndexes . put ( name , index ) ; \n} \nif ( index . value >= array . length ) { \nreturn null ; \n} \nString result = array [ index . value ] ; \nindex . value = index . value + 1 ; \nreturn result ; \n} \n} \n"}
{"1601": "public class Socks4ProxySocketFactory { \nprivate Socket createSocks4ProxySocket ( final String host , final int port ) { \nSocket socket = null ; \nfinal String proxyHost = proxy . getProxyAddress ( ) ; \nfinal int proxyPort = proxy . getProxyPort ( ) ; \nfinal String user = proxy . getProxyUsername ( ) ; \ntry { \nsocket = Sockets . connect ( proxyHost , proxyPort , connectionTimeout ) ; \nfinal InputStream in = socket . getInputStream ( ) ; \nfinal OutputStream out = socket . getOutputStream ( ) ; \nsocket . setTcpNoDelay ( true ) ; \nbyte [ ] buf = new byte [ 1024 ] ; \nint index = 0 ; \nbuf [ index = index + 1 ] = 4 ; \nbuf [ index = index + 1 ] = 1 ; \nbuf [ index = index + 1 ] = ( byte ) ( port >>> 8 ) ; \nbuf [ index = index + 1 ] = ( byte ) ( port & 0xff ) ; \nInetAddress addr = InetAddress . getByName ( host ) ; \nbyte [ ] byteAddress = addr . getAddress ( ) ; \nfor ( byte byteAddres : byteAddress ) { \nbuf [ index = index + 1 ] = byteAddres ; \n} \nif ( user != null ) { \nSystem . arraycopy ( user . getBytes ( ) , 0 , buf , index , user . length ( ) ) ; \nindex += user . length ( ) ; \n} \nbuf [ index = index + 1 ] = 0 ; \nout . write ( buf , 0 , index ) ; \nint len = 6 ; \nint s = 0 ; \nwhile ( s < len ) { \nint i = in . read ( buf , s , len - s ) ; \nif ( i <= 0 ) { \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"stream is closed\" ) ; \n} \ns += i ; \n} \nif ( buf [ 0 ] != 0 ) { \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned VN \" + buf [ 0 ] ) ; \n} \nif ( buf [ 1 ] != 90 ) { \ntry { \nsocket . close ( ) ; \n} \ncatch ( Exception ignore ) { \n} \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned CD \" + buf [ 1 ] ) ; \n} \nbyte [ ] temp = new byte [ 2 ] ; \nin . read ( temp , 0 , 2 ) ; \nreturn socket ; \n} \ncatch ( RuntimeException rtex ) { \ncloseSocket ( socket ) ; \nthrow rtex ; \n} \ncatch ( Exception ex ) { \ncloseSocket ( socket ) ; \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , ex . toString ( ) , ex ) ; \n} \n} \n} \n"}
{"1604": "public class CharSequenceUtil { \npublic static boolean equalsOne ( final char c , final CharSequence match ) { \nfor ( int i = 0 ; \ni < match . length ( ) ; \ni = i + 1 ) { \nchar aMatch = match . charAt ( i ) ; \nif ( c == aMatch ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"1605": "public class CharSequenceUtil { \npublic static int findFirstEqual ( final CharSequence source , final int index , final CharSequence match ) { \nfor ( int i = index ; \ni < source . length ( ) ; \ni = i + 1 ) { \nif ( equalsOne ( source . charAt ( i ) , match ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1606": "public class CharSequenceUtil { \npublic static int findFirstEqual ( final char [ ] source , final int index , final char match ) { \nfor ( int i = index ; \ni < source . length ; \ni = i + 1 ) { \nif ( source [ i ] == match ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1613": "public class Frame { \nprivate static int getAbstractTypeFromDescriptor ( final SymbolTable symbolTable , final String buffer , final int offset ) { \nString internalName ; \nswitch ( buffer . charAt ( offset ) ) { \ncase 'V' : return 0 ; \ncase 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : return INTEGER ; \ncase 'F' : return FLOAT ; \ncase 'J' : return LONG ; \ncase 'D' : return DOUBLE ; \ncase 'L' : internalName = buffer . substring ( offset + 1 , buffer . length ( ) - 1 ) ; \nreturn REFERENCE_KIND | symbolTable . addType ( internalName ) ; \ncase '[' : int elementDescriptorOffset = offset + 1 ; \nwhile ( buffer . charAt ( elementDescriptorOffset ) == '[' ) { \nelementDescriptorOffset = elementDescriptorOffset + 1 ; \n} \nint typeValue ; \nswitch ( buffer . charAt ( elementDescriptorOffset ) ) { \ncase 'Z' : typeValue = BOOLEAN ; \nbreak ; \ncase 'C' : typeValue = CHAR ; \nbreak ; \ncase 'B' : typeValue = BYTE ; \nbreak ; \ncase 'S' : typeValue = SHORT ; \nbreak ; \ncase 'I' : typeValue = INTEGER ; \nbreak ; \ncase 'F' : typeValue = FLOAT ; \nbreak ; \ncase 'J' : typeValue = LONG ; \nbreak ; \ncase 'D' : typeValue = DOUBLE ; \nbreak ; \ncase 'L' : internalName = buffer . substring ( elementDescriptorOffset + 1 , buffer . length ( ) - 1 ) ; \ntypeValue = REFERENCE_KIND | symbolTable . addType ( internalName ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \nreturn ( ( elementDescriptorOffset - offset ) << DIM_SHIFT ) | typeValue ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \n} \n} \n"}
{"1614": "public class Frame { \nfinal void setInputFrameFromApiFormat ( final SymbolTable symbolTable , final int numLocal , final Object [ ] local , final int numStack , final Object [ ] stack ) { \nint inputLocalIndex = 0 ; \nfor ( int i = 0 ; \ni < numLocal ; \ni = i + 1 ) { \ninputLocals [ inputLocalIndex = inputLocalIndex + 1 ] = getAbstractTypeFromApiFormat ( symbolTable , local [ i ] ) ; \nif ( local [ i ] == Opcodes . LONG || local [ i ] == Opcodes . DOUBLE ) { \ninputLocals [ inputLocalIndex = inputLocalIndex + 1 ] = TOP ; \n} \n} \nwhile ( inputLocalIndex < inputLocals . length ) { \ninputLocals [ inputLocalIndex = inputLocalIndex + 1 ] = TOP ; \n} \nint numStackTop = 0 ; \nfor ( int i = 0 ; \ni < numStack ; \ni = i + 1 ) { \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \nnumStackTop = numStackTop + 1 ; \n} \n} \ninputStack = new int [ numStack + numStackTop ] ; \nint inputStackIndex = 0 ; \nfor ( int i = 0 ; \ni < numStack ; \ni = i + 1 ) { \ninputStack [ inputStackIndex = inputStackIndex + 1 ] = getAbstractTypeFromApiFormat ( symbolTable , stack [ i ] ) ; \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \ninputStack [ inputStackIndex = inputStackIndex + 1 ] = TOP ; \n} \n} \noutputStackTop = 0 ; \ninitializationCount = 0 ; \n} \n} \n"}
{"1617": "public class Frame { \nprivate void push ( final int abstractType ) { \nif ( outputStack == null ) { \noutputStack = new int [ 10 ] ; \n} \nint outputStackLength = outputStack . length ; \nif ( outputStackTop >= outputStackLength ) { \nint [ ] newOutputStack = new int [ Math . max ( outputStackTop + 1 , 2 * outputStackLength ) ] ; \nSystem . arraycopy ( outputStack , 0 , newOutputStack , 0 , outputStackLength ) ; \noutputStack = newOutputStack ; \n} \noutputStack [ outputStackTop = outputStackTop + 1 ] = abstractType ; \nshort outputStackSize = ( short ) ( outputStackStart + outputStackTop ) ; \nif ( outputStackSize > owner . outputStackMax ) { \nowner . outputStackMax = outputStackSize ; \n} \n} \n} \n"}
{"1621": "public class Frame { \nprivate void addInitializedType ( final int abstractType ) { \nif ( initializations == null ) { \ninitializations = new int [ 2 ] ; \n} \nint initializationsLength = initializations . length ; \nif ( initializationCount >= initializationsLength ) { \nint [ ] newInitializations = new int [ Math . max ( initializationCount + 1 , 2 * initializationsLength ) ] ; \nSystem . arraycopy ( initializations , 0 , newInitializations , 0 , initializationsLength ) ; \ninitializations = newInitializations ; \n} \ninitializations [ initializationCount = initializationCount + 1 ] = abstractType ; \n} \n} \n"}
{"1622": "public class Frame { \nprivate int getInitializedType ( final SymbolTable symbolTable , final int abstractType ) { \nif ( abstractType == UNINITIALIZED_THIS || ( abstractType & ( DIM_MASK | KIND_MASK ) ) == UNINITIALIZED_KIND ) { \nfor ( int i = 0 ; \ni < initializationCount ; \ni = i + 1 ) { \nint initializedType = initializations [ i ] ; \nint dim = initializedType & DIM_MASK ; \nint kind = initializedType & KIND_MASK ; \nint value = initializedType & VALUE_MASK ; \nif ( kind == LOCAL_KIND ) { \ninitializedType = dim + inputLocals [ value ] ; \n} \nelse if ( kind == STACK_KIND ) { \ninitializedType = dim + inputStack [ inputStack . length - value ] ; \n} \nif ( abstractType == initializedType ) { \nif ( abstractType == UNINITIALIZED_THIS ) { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; \n} \nelse { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; \n} \n} \n} \n} \nreturn abstractType ; \n} \n} \n"}
{"1623": "public class Frame { \nstatic void putAbstractType ( final SymbolTable symbolTable , final int abstractType , final ByteVector output ) { \nint arrayDimensions = ( abstractType & Frame . DIM_MASK ) >> DIM_SHIFT ; \nif ( arrayDimensions == 0 ) { \nint typeValue = abstractType & VALUE_MASK ; \nswitch ( abstractType & KIND_MASK ) { \ncase CONSTANT_KIND : output . putByte ( typeValue ) ; \nbreak ; \ncase REFERENCE_KIND : output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( symbolTable . getType ( typeValue ) . value ) . index ) ; \nbreak ; \ncase UNINITIALIZED_KIND : output . putByte ( ITEM_UNINITIALIZED ) . putShort ( ( int ) symbolTable . getType ( typeValue ) . data ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \nelse { \nStringBuilder typeDescriptor = new StringBuilder ( ) ; \nwhile ( arrayDimensions = arrayDimensions - 1 > 0 ) { \ntypeDescriptor . append ( '[' ) ; \n} \nif ( ( abstractType & KIND_MASK ) == REFERENCE_KIND ) { \ntypeDescriptor . append ( 'L' ) . append ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) . append ( ';' ) ; \n} \nelse { \nswitch ( abstractType & VALUE_MASK ) { \ncase Frame . ITEM_ASM_BOOLEAN : typeDescriptor . append ( 'Z' ) ; \nbreak ; \ncase Frame . ITEM_ASM_BYTE : typeDescriptor . append ( 'B' ) ; \nbreak ; \ncase Frame . ITEM_ASM_CHAR : typeDescriptor . append ( 'C' ) ; \nbreak ; \ncase Frame . ITEM_ASM_SHORT : typeDescriptor . append ( 'S' ) ; \nbreak ; \ncase Frame . ITEM_INTEGER : typeDescriptor . append ( 'I' ) ; \nbreak ; \ncase Frame . ITEM_FLOAT : typeDescriptor . append ( 'F' ) ; \nbreak ; \ncase Frame . ITEM_LONG : typeDescriptor . append ( 'J' ) ; \nbreak ; \ncase Frame . ITEM_DOUBLE : typeDescriptor . append ( 'D' ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \noutput . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( typeDescriptor . toString ( ) ) . index ) ; \n} \n} \n} \n"}
{"1624": "public class TimedCache { \n@ Override protected int pruneCache ( ) { \nint count = 0 ; \nIterator < CacheObject < K , V > > values = cacheMap . values ( ) . iterator ( ) ; \nwhile ( values . hasNext ( ) ) { \nCacheObject co = values . next ( ) ; \nif ( co . isExpired ( ) ) { \nvalues . remove ( ) ; \ncount = count + 1 ; \n} \n} \nreturn count ; \n} \n} \n"}
{"1635": "public class ActionRequest { \nprotected ActionWrapper [ ] createExecutionArray ( ) { \nint totalInterceptors = ( this . actionRuntime . getInterceptors ( ) != null ? this . actionRuntime . getInterceptors ( ) . length : 0 ) ; \nint totalFilters = ( this . actionRuntime . getFilters ( ) != null ? this . actionRuntime . getFilters ( ) . length : 0 ) ; \nActionWrapper [ ] executionArray = new ActionWrapper [ totalFilters + 1 + totalInterceptors + 1 ] ; \nint index = 0 ; \nif ( totalFilters > 0 ) { \nSystem . arraycopy ( actionRuntime . getFilters ( ) , 0 , executionArray , index , totalFilters ) ; \nindex += totalFilters ; \n} \nexecutionArray [ index = index + 1 ] = actionRequest -> { \nObject actionResult = actionRequest . invoke ( ) ; \nActionRequest . this . madvocController . render ( ActionRequest . this , actionResult ) ; \nreturn actionResult ; \n} \n; \nif ( totalInterceptors > 0 ) { \nSystem . arraycopy ( actionRuntime . getInterceptors ( ) , 0 , executionArray , index , totalInterceptors ) ; \nindex += totalInterceptors ; \n} \nexecutionArray [ index ] = actionRequest -> { \nactionResult = invokeActionMethod ( ) ; \nreturn actionResult ; \n} \n; \nreturn executionArray ; \n} \n} \n"}
{"1641": "public class CharUtil { \npublic static byte [ ] toRawByteArray ( final char [ ] carr ) { \nbyte [ ] barr = new byte [ carr . length << 1 ] ; \nfor ( int i = 0 , bpos = 0 ; \ni < carr . length ; \ni = i + 1 ) { \nchar c = carr [ i ] ; \nbarr [ bpos = bpos + 1 ] = ( byte ) ( ( c & 0xFF00 ) >> 8 ) ; \nbarr [ bpos = bpos + 1 ] = ( byte ) ( c & 0x00FF ) ; \n} \nreturn barr ; \n} \n} \n"}
{"1642": "public class CharUtil { \npublic static int findFirstDiff ( final char [ ] source , final int index , final char [ ] match ) { \nfor ( int i = index ; \ni < source . length ; \ni = i + 1 ) { \nif ( ! equalsOne ( source [ i ] , match ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1660": "public class Props { \npublic String [ ] getAllProfiles ( ) { \nString [ ] profiles = new String [ data . profileProperties . size ( ) ] ; \nint index = 0 ; \nfor ( String profileName : data . profileProperties . keySet ( ) ) { \nprofiles [ index ] = profileName ; \nindex = index + 1 ; \n} \nreturn profiles ; \n} \n} \n"}
{"1676": "public class RestActionNamingStrategy { \nprotected String resolveHttpMethodFromMethodName ( final String methodName ) { \nint i = 0 ; \nwhile ( i < methodName . length ( ) ) { \nif ( CharUtil . isUppercaseAlpha ( methodName . charAt ( i ) ) ) { \nbreak ; \n} \ni = i + 1 ; \n} \nfinal String name = methodName . substring ( 0 , i ) . toUpperCase ( ) ; \nfor ( final HttpMethod httpMethod : HttpMethod . values ( ) ) { \nif ( httpMethod . equalsName ( name ) ) { \nreturn httpMethod . name ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1677": "public class Wildcard { \nprivate static boolean match ( final CharSequence string , final CharSequence pattern , int sNdx , int pNdx ) { \nint pLen = pattern . length ( ) ; \nif ( pLen == 1 ) { \nif ( pattern . charAt ( 0 ) == '*' ) { \nreturn true ; \n} \n} \nint sLen = string . length ( ) ; \nboolean nextIsNotWildcard = false ; \nwhile ( true ) { \nif ( ( sNdx >= sLen ) ) { \nwhile ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '*' ) ) { \npNdx = pNdx + 1 ; \n} \nreturn pNdx >= pLen ; \n} \nif ( pNdx >= pLen ) { \nreturn false ; \n} \nchar p = pattern . charAt ( pNdx ) ; \nif ( ! nextIsNotWildcard ) { \nif ( p == '\\\\' ) { \npNdx = pNdx + 1 ; \nnextIsNotWildcard = true ; \ncontinue ; \n} \nif ( p == '?' ) { \nsNdx = sNdx + 1 ; \npNdx = pNdx + 1 ; \ncontinue ; \n} \nif ( p == '*' ) { \nchar pNext = 0 ; \nif ( pNdx + 1 < pLen ) { \npNext = pattern . charAt ( pNdx + 1 ) ; \n} \nif ( pNext == '*' ) { \npNdx = pNdx + 1 ; \ncontinue ; \n} \nint i ; \npNdx = pNdx + 1 ; \nfor ( i = string . length ( ) ; \ni >= sNdx ; \ni = i - 1 ) { \nif ( match ( string , pattern , i , pNdx ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \nelse { \nnextIsNotWildcard = false ; \n} \nif ( p != string . charAt ( sNdx ) ) { \nreturn false ; \n} \nsNdx = sNdx + 1 ; \npNdx = pNdx + 1 ; \n} \n} \n} \n"}
{"1700": "public class RandomString { \npublic String random ( int count , final char [ ] chars ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nfinal char [ ] result = new char [ count ] ; \nwhile ( count = count - 1 > 0 ) { \nresult [ count ] = chars [ rnd . nextInt ( chars . length ) ] ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1701": "public class RandomString { \npublic String random ( int count , final char start , final char end ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nfinal char [ ] result = new char [ count ] ; \nfinal int len = end - start + 1 ; \nwhile ( count = count - 1 > 0 ) { \nresult [ count ] = ( char ) ( rnd . nextInt ( len ) + start ) ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1702": "public class RandomString { \npublic String randomRanges ( int count , final char ... ranges ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nint i = 0 ; \nint len = 0 ; \nfinal int [ ] lens = new int [ ranges . length ] ; \nwhile ( i < ranges . length ) { \nint gap = ranges [ i + 1 ] - ranges [ i ] + 1 ; \nlen += gap ; \nlens [ i ] = len ; \ni += 2 ; \n} \nfinal char [ ] result = new char [ count ] ; \nwhile ( count = count - 1 > 0 ) { \nchar c = 0 ; \nint r = rnd . nextInt ( len ) ; \nfor ( i = 0 ; \ni < ranges . length ; \ni += 2 ) { \nif ( r < lens [ i ] ) { \nr += ranges [ i ] ; \nif ( i != 0 ) { \nr -= lens [ i - 2 ] ; \n} \nc = ( char ) r ; \nbreak ; \n} \n} \nresult [ count ] = c ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1712": "public class NetUtil { \npublic static boolean validateAgaintIPAdressV4Format ( final String input ) { \nif ( input == null ) { \nreturn false ; \n} \nint hitDots = 0 ; \nchar [ ] data = input . toCharArray ( ) ; \nfor ( int i = 0 ; \ni < data . length ; \ni = i + 1 ) { \nchar c = data [ i ] ; \nint b = 0 ; \ndo { \nif ( c < '0' || c > '9' ) { \nreturn false ; \n} \nb = ( b * 10 + c ) - 48 ; \nif ( i = i + 1 >= data . length ) { \nbreak ; \n} \nc = data [ i ] ; \n} \nwhile ( c != '.' ) ; \nif ( b > 255 ) { \nreturn false ; \n} \nhitDots = hitDots + 1 ; \n} \nreturn hitDots == 4 ; \n} \n} \n"}
{"1736": "public class DbOomQuery { \npublic void populateGeneratedKeys ( final Object entity ) { \nfinal String [ ] generatedColumns = getGeneratedColumnNames ( ) ; \nif ( generatedColumns == null ) { \nreturn ; \n} \nDbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( entity . getClass ( ) ) ; \nClass [ ] keyTypes = new Class [ generatedColumns . length ] ; \nString [ ] properties = new String [ generatedColumns . length ] ; \nfor ( int i = 0 ; \ni < generatedColumns . length ; \ni = i + 1 ) { \nString column = generatedColumns [ i ] ; \nDbEntityColumnDescriptor decd = ded . findByColumnName ( column ) ; \nif ( decd != null ) { \nkeyTypes [ i ] = decd . getPropertyType ( ) ; \nproperties [ i ] = decd . getPropertyName ( ) ; \n} \n} \nfinal Object keyValues = findGeneratedColumns ( keyTypes ) ; \nif ( ! keyValues . getClass ( ) . isArray ( ) ) { \nBeanUtil . declared . setProperty ( entity , properties [ 0 ] , keyValues ) ; \n} \nelse { \nfor ( int i = 0 ; \ni < properties . length ; \ni = i + 1 ) { \nBeanUtil . declared . setProperty ( entity , properties [ i ] , ( ( Object [ ] ) keyValues ) [ i ] ) ; \n} \n} \n} \n} \n"}
{"1740": "public class DbQuery { \npublic Q setObjects ( final Object ... objects ) { \nint index = 1 ; \nfor ( final Object object : objects ) { \nsetObject ( index = index + 1 , object ) ; \n} \nreturn _this ( ) ; \n} \n} \n"}
{"1746": "public class SqlChunk { \nprotected void appendMissingSpace ( final StringBuilder out ) { \nint len = out . length ( ) ; \nif ( len == 0 ) { \nreturn ; \n} \nlen = len - 1 ; \nif ( ! CharUtil . isWhitespace ( out . charAt ( len ) ) ) { \nout . append ( ' ' ) ; \n} \n} \n} \n"}
{"1751": "public class ActionMethodParamNameResolver { \npublic String [ ] resolveParamNames ( final Method actionClassMethod ) { \nMethodParameter [ ] methodParameters = Paramo . resolveParameters ( actionClassMethod ) ; \nString [ ] names = new String [ methodParameters . length ] ; \nfor ( int i = 0 ; \ni < methodParameters . length ; \ni = i + 1 ) { \nnames [ i ] = methodParameters [ i ] . getName ( ) ; \n} \nreturn names ; \n} \n} \n"}
{"1765": "public class EmailFilter { \npublic EmailFilter and ( final EmailFilter ... emailFilters ) { \nfinal SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; \nfor ( int i = 0 ; \ni < emailFilters . length ; \ni = i + 1 ) { \nsearchTerms [ i ] = emailFilters [ i ] . searchTerm ; \n} \nconcat ( new AndTerm ( searchTerms ) ) ; \nreturn this ; \n} \n} \n"}
{"1766": "public class EmailFilter { \npublic EmailFilter or ( final EmailFilter ... emailFilters ) { \nfinal SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; \nfor ( int i = 0 ; \ni < emailFilters . length ; \ni = i + 1 ) { \nsearchTerms [ i ] = emailFilters [ i ] . searchTerm ; \n} \nconcat ( new OrTerm ( searchTerms ) ) ; \nreturn this ; \n} \n} \n"}
{"1769": "public class Base32 { \npublic static String encode ( final byte [ ] bytes ) { \nStringBuilder base32 = new StringBuilder ( ( bytes . length * 8 + 4 ) / 5 ) ; \nint currByte , digit , i = 0 ; \nwhile ( i < bytes . length ) { \ncurrByte = bytes [ i = i + 1 ] & 255 ; \nbase32 . append ( CHARS [ currByte >> 3 ] ) ; \ndigit = ( currByte & 7 ) << 2 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i = i + 1 ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 6 ) ] ) ; \nbase32 . append ( CHARS [ ( currByte >> 1 ) & 31 ] ) ; \ndigit = ( currByte & 1 ) << 4 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i = i + 1 ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 4 ) ] ) ; \ndigit = ( currByte & 15 ) << 1 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i = i + 1 ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 7 ) ] ) ; \nbase32 . append ( CHARS [ ( currByte >> 2 ) & 31 ] ) ; \ndigit = ( currByte & 3 ) << 3 ; \nif ( i >= bytes . length ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i = i + 1 ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 5 ) ] ) ; \nbase32 . append ( CHARS [ currByte & 31 ] ) ; \n} \nreturn base32 . toString ( ) ; \n} \n} \n"}
{"1770": "public class ByteArrayConverter { \nprotected byte [ ] convertValueToArray ( final Object value ) { \nif ( value instanceof Blob ) { \nfinal Blob blob = ( Blob ) value ; \ntry { \nfinal long length = blob . length ( ) ; \nif ( length > Integer . MAX_VALUE ) { \nthrow new TypeConversionException ( \"Blob is too big.\" ) ; \n} \nreturn blob . getBytes ( 1 , ( int ) length ) ; \n} \ncatch ( SQLException sex ) { \nthrow new TypeConversionException ( value , sex ) ; \n} \n} \nif ( value instanceof File ) { \ntry { \nreturn FileUtil . readBytes ( ( File ) value ) ; \n} \ncatch ( IOException ioex ) { \nthrow new TypeConversionException ( value , ioex ) ; \n} \n} \nif ( value instanceof Collection ) { \nfinal Collection collection = ( Collection ) value ; \nfinal byte [ ] target = new byte [ collection . size ( ) ] ; \nint i = 0 ; \nfor ( final Object element : collection ) { \ntarget [ i ] = convertType ( element ) ; \ni = i + 1 ; \n} \nreturn target ; \n} \nif ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal ArrayList < Byte > byteArrayList = new ArrayList < > ( ) ; \nfor ( final Object element : iterable ) { \nfinal byte convertedValue = convertType ( element ) ; \nbyteArrayList . add ( Byte . valueOf ( convertedValue ) ) ; \n} \nfinal byte [ ] array = new byte [ byteArrayList . size ( ) ] ; \nfor ( int i = 0 ; \ni < byteArrayList . size ( ) ; \ni = i + 1 ) { \nfinal Byte b = byteArrayList . get ( i ) ; \narray [ i ] = b . byteValue ( ) ; \n} \nreturn array ; \n} \nif ( value instanceof CharSequence ) { \nfinal String [ ] strings = StringUtil . splitc ( value . toString ( ) , ArrayConverter . NUMBER_DELIMITERS ) ; \nreturn convertArrayToArray ( strings ) ; \n} \nreturn convertToSingleElementArray ( value ) ; \n} \n} \n"}
{"1781": "public class JulianDate { \nprivate void set ( final int i , double f ) { \ninteger = i ; \nint fi = ( int ) f ; \nf -= fi ; \ninteger += fi ; \nif ( f < 0 ) { \nf += 1 ; \ninteger = integer - 1 ; \n} \nthis . fraction = f ; \n} \n} \n"}
{"1787": "public class PBKDF2Hash { \nprivate static byte [ ] fromHex ( final String hex ) { \nfinal byte [ ] binary = new byte [ hex . length ( ) / 2 ] ; \nfor ( int i = 0 ; \ni < binary . length ; \ni = i + 1 ) { \nbinary [ i ] = ( byte ) Integer . parseInt ( hex . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; \n} \nreturn binary ; \n} \n} \n"}
{"1792": "public class SignatureReader { \nprivate static int parseType ( final String signature , final int startOffset , final SignatureVisitor signatureVisitor ) { \nint offset = startOffset ; \nchar currentChar = signature . charAt ( offset = offset + 1 ) ; \nswitch ( currentChar ) { \ncase 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : case 'F' : case 'J' : case 'D' : case 'V' : signatureVisitor . visitBaseType ( currentChar ) ; \nreturn offset ; \ncase '[' : return parseType ( signature , offset , signatureVisitor . visitArrayType ( ) ) ; \ncase 'T' : int endOffset = signature . indexOf ( ';' , offset ) ; \nsignatureVisitor . visitTypeVariable ( signature . substring ( offset , endOffset ) ) ; \nreturn endOffset + 1 ; \ncase 'L' : int start = offset ; \nboolean visited = false ; \nboolean inner = false ; \nwhile ( true ) { \ncurrentChar = signature . charAt ( offset = offset + 1 ) ; \nif ( currentChar == '.' || currentChar == ';' ) { \nif ( ! visited ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( inner ) { \nsignatureVisitor . visitInnerClassType ( name ) ; \n} \nelse { \nsignatureVisitor . visitClassType ( name ) ; \n} \n} \nif ( currentChar == ';' ) { \nsignatureVisitor . visitEnd ( ) ; \nbreak ; \n} \nstart = offset ; \nvisited = false ; \ninner = true ; \n} \nelse if ( currentChar == '<' ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( inner ) { \nsignatureVisitor . visitInnerClassType ( name ) ; \n} \nelse { \nsignatureVisitor . visitClassType ( name ) ; \n} \nvisited = true ; \nwhile ( ( currentChar = signature . charAt ( offset ) ) != '>' ) { \nswitch ( currentChar ) { \ncase '*' : offset = offset + 1 ; \nsignatureVisitor . visitTypeArgument ( ) ; \nbreak ; \ncase '+' : case '-' : offset = parseType ( signature , offset + 1 , signatureVisitor . visitTypeArgument ( currentChar ) ) ; \nbreak ; \ndefault : offset = parseType ( signature , offset , signatureVisitor . visitTypeArgument ( '=' ) ) ; \nbreak ; \n} \n} \n} \n} \nreturn offset ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \n} \n} \n"}
{"1802": "public class CsvUtil { \npublic static String toCsvString ( final Object ... elements ) { \nStringBuilder line = new StringBuilder ( ) ; \nint last = elements . length - 1 ; \nfor ( int i = 0 ; \ni < elements . length ; \ni = i + 1 ) { \nif ( elements [ i ] == null ) { \nif ( i != last ) { \nline . append ( FIELD_SEPARATOR ) ; \n} \ncontinue ; \n} \nString field = elements [ i ] . toString ( ) ; \nint ndx = field . indexOf ( FIELD_SEPARATOR ) ; \nif ( ndx == - 1 ) { \nndx = field . indexOf ( FIELD_QUOTE ) ; \n} \nif ( ndx == - 1 ) { \nif ( field . startsWith ( StringPool . SPACE ) || field . endsWith ( StringPool . SPACE ) ) { \nndx = 1 ; \n} \n} \nif ( ndx == - 1 ) { \nndx = StringUtil . indexOfChars ( field , SPECIAL_CHARS ) ; \n} \nif ( ndx != - 1 ) { \nline . append ( FIELD_QUOTE ) ; \n} \nfield = StringUtil . replace ( field , StringPool . QUOTE , DOUBLE_QUOTE ) ; \nline . append ( field ) ; \nif ( ndx != - 1 ) { \nline . append ( FIELD_QUOTE ) ; \n} \nif ( i != last ) { \nline . append ( FIELD_SEPARATOR ) ; \n} \n} \nreturn line . toString ( ) ; \n} \n} \n"}
{"1803": "public class CsvUtil { \npublic static String [ ] toStringArray ( final String line ) { \nList < String > row = new ArrayList < > ( ) ; \nboolean inQuotedField = false ; \nint fieldStart = 0 ; \nfinal int len = line . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nchar c = line . charAt ( i ) ; \nif ( c == FIELD_SEPARATOR ) { \nif ( ! inQuotedField ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 1 ; \n} \n} \nelse if ( c == FIELD_QUOTE ) { \nif ( inQuotedField ) { \nif ( i + 1 == len || line . charAt ( i + 1 ) == FIELD_SEPARATOR ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 2 ; \ni = i + 1 ; \ninQuotedField = false ; \n} \n} \nelse if ( fieldStart == i ) { \ninQuotedField = true ; \nfieldStart = fieldStart + 1 ; \n} \n} \n} \nif ( len > 0 && fieldStart <= len ) { \naddField ( row , line , fieldStart , len , inQuotedField ) ; \n} \nreturn row . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"1810": "public class Cookie { \nprivate void setName ( final String name ) { \nif ( name . contains ( \";\" ) || name . contains ( \",\" ) || name . startsWith ( \"$\" ) ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \nfor ( int n = 0 ; \nn < name . length ( ) ; \nn = n + 1 ) { \nchar c = name . charAt ( n ) ; \nif ( c <= 0x20 || c >= 0x7f ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \n} \nthis . name = name ; \n} \n} \n"}
{"1860": "public class ClusterControl { \npublic static AtomicCounter findControlToggle ( final CountersReader counters ) { \nfinal AtomicBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = counters . maxCounterId ( ) ; \ni < size ; \ni = i + 1 ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED && buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == CONTROL_TOGGLE_TYPE_ID ) { \nreturn new AtomicCounter ( counters . valuesBuffer ( ) , i , null ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1897": "public class ClusterMember { \npublic static String encodeAsString ( final ClusterMember [ ] clusterMembers ) { \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( int i = 0 , length = clusterMembers . length ; \ni < length ; \ni = i + 1 ) { \nfinal ClusterMember member = clusterMembers [ i ] ; \nbuilder . append ( member . id ( ) ) . append ( ',' ) . append ( member . endpointsDetail ( ) ) ; \nif ( ( length - 1 ) != i ) { \nbuilder . append ( '|' ) ; \n} \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"1900": "public class ClusterMember { \npublic static boolean hasActiveQuorum ( final ClusterMember [ ] clusterMembers , final long nowMs , final long timeoutMs ) { \nint threshold = quorumThreshold ( clusterMembers . length ) ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( member . isLeader ( ) || nowMs <= ( member . timeOfLastAppendPositionMs ( ) + timeoutMs ) ) { \nif ( threshold = threshold - 1 <= 0 ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"1901": "public class ClusterMember { \npublic static long quorumPosition ( final ClusterMember [ ] members , final long [ ] rankedPositions ) { \nfinal int length = rankedPositions . length ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nrankedPositions [ i ] = 0 ; \n} \nfor ( final ClusterMember member : members ) { \nlong newPosition = member . logPosition ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nfinal long rankedPosition = rankedPositions [ i ] ; \nif ( newPosition > rankedPosition ) { \nrankedPositions [ i ] = newPosition ; \nnewPosition = rankedPosition ; \n} \n} \n} \nreturn rankedPositions [ length - 1 ] ; \n} \n} \n"}
{"1905": "public class ClusterMember { \npublic static boolean hasMajorityVote ( final ClusterMember [ ] clusterMembers , final long candidateTermId ) { \nint votes = 0 ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( Boolean . TRUE . equals ( member . vote ) && member . candidateTermId == candidateTermId ) { \nvotes = votes + 1 ; \n} \n} \nreturn votes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; \n} \n} \n"}
{"1910": "public class ClusterMember { \npublic static boolean isQuorumCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { \nint possibleVotes = 0 ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( NULL_POSITION == member . logPosition || compareLog ( candidate , member ) < 0 ) { \ncontinue ; \n} \npossibleVotes = possibleVotes + 1 ; \n} \nreturn possibleVotes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; \n} \n} \n"}
{"1912": "public class ClusterMember { \npublic static int findMemberIndex ( final ClusterMember [ ] clusterMembers , final int memberId ) { \nfinal int length = clusterMembers . length ; \nint index = ArrayUtil . UNKNOWN_INDEX ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nif ( clusterMembers [ i ] . id ( ) == memberId ) { \nindex = i ; \n} \n} \nreturn index ; \n} \n} \n"}
{"1926": "public class RecordingPos { \npublic static int findCounterIdByRecording ( final CountersReader countersReader , final long recordingId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = countersReader . maxCounterId ( ) ; \ni < size ; \ni = i + 1 ) { \nif ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1927": "public class RecordingPos { \npublic static int findCounterIdBySession ( final CountersReader countersReader , final int sessionId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = countersReader . maxCounterId ( ) ; \ni < size ; \ni = i + 1 ) { \nif ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SESSION_ID_OFFSET ) == sessionId ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1932": "public class RecordingLog { \npublic Entry findLastTerm ( ) { \nfor ( int i = entries . size ( ) - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( ENTRY_TYPE_TERM == entry . type ) { \nreturn entry ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1938": "public class RecordingLog { \npublic void tombstoneEntry ( final long leadershipTermId , final int entryIndex ) { \nint index = - 1 ; \nfor ( int i = 0 , size = entries . size ( ) ; \ni < size ; \ni = i + 1 ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( entry . leadershipTermId == leadershipTermId && entry . entryIndex == entryIndex ) { \nindex = entry . entryIndex ; \nif ( ENTRY_TYPE_TERM == entry . type ) { \nindexByLeadershipTermIdMap . remove ( leadershipTermId ) ; \n} \nbreak ; \n} \n} \nif ( - 1 == index ) { \nthrow new ClusterException ( \"unknown entry index: \" + entryIndex ) ; \n} \nbuffer . putInt ( 0 , NULL_VALUE , LITTLE_ENDIAN ) ; \nbyteBuffer . limit ( SIZE_OF_INT ) . position ( 0 ) ; \nfinal long filePosition = ( index * ( long ) ENTRY_LENGTH ) + ENTRY_TYPE_OFFSET ; \ntry { \nif ( SIZE_OF_INT != fileChannel . write ( byteBuffer , filePosition ) ) { \nthrow new ClusterException ( \"failed to write field atomically\" ) ; \n} \n} \ncatch ( final Exception ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \n} \n} \n"}
{"1957": "public class RecoveryState { \npublic static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final long leadershipTermId , final long logPosition , final long timestamp , final boolean hasReplay , final long ... snapshotRecordingIds ) { \ntempBuffer . putLong ( LEADERSHIP_TERM_ID_OFFSET , leadershipTermId ) ; \ntempBuffer . putLong ( LOG_POSITION_OFFSET , logPosition ) ; \ntempBuffer . putLong ( TIMESTAMP_OFFSET , timestamp ) ; \ntempBuffer . putInt ( REPLAY_FLAG_OFFSET , hasReplay ? 1 : 0 ) ; \nfinal int serviceCount = snapshotRecordingIds . length ; \ntempBuffer . putInt ( SERVICE_COUNT_OFFSET , serviceCount ) ; \nfinal int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceCount * SIZE_OF_LONG ) ; \nif ( keyLength > MAX_KEY_LENGTH ) { \nthrow new ClusterException ( keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH ) ; \n} \nfor ( int i = 0 ; \ni < serviceCount ; \ni = i + 1 ) { \ntempBuffer . putLong ( SNAPSHOT_RECORDING_IDS_OFFSET + ( i * SIZE_OF_LONG ) , snapshotRecordingIds [ i ] ) ; \n} \nfinal int labelOffset = BitUtil . align ( keyLength , SIZE_OF_INT ) ; \nint labelLength = 0 ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; \nlabelLength += tempBuffer . putLongAscii ( keyLength + labelLength , leadershipTermId ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" logPosition=\" ) ; \nlabelLength += tempBuffer . putLongAscii ( labelOffset + labelLength , logPosition ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" hasReplay=\" + hasReplay ) ; \nreturn aeron . addCounter ( RECOVERY_STATE_TYPE_ID , tempBuffer , 0 , keyLength , tempBuffer , labelOffset , labelLength ) ; \n} \n} \n"}
{"1958": "public class RecoveryState { \npublic static int findCounterId ( final CountersReader counters ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = counters . maxCounterId ( ) ; \ni < size ; \ni = i + 1 ) { \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1961": "public class HeaderFlyweight { \npublic static char [ ] flagsToChars ( final short flags ) { \nfinal char [ ] chars = new char [ ] { \n'0' , '0' , '0' , '0' , '0' , '0' , '0' , '0' } \n; \nfinal int length = chars . length ; \nshort mask = ( short ) ( 1 << ( length - 1 ) ) ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nif ( ( flags & mask ) == mask ) { \nchars [ i ] = '1' ; \n} \nmask >>= 1 ; \n} \nreturn chars ; \n} \n} \n"}
{"1971": "public class ServiceHeartbeat { \npublic static int findCounterId ( final CountersReader counters , final int serviceId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = counters . maxCounterId ( ) ; \ni < size ; \ni = i + 1 ) { \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == SERVICE_HEARTBEAT_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET ) == serviceId ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1977": "public class CapacityByteArrayOutputStream { \npublic void setByte ( long index , byte value ) { \ncheckArgument ( index < bytesUsed , \"Index: \" + index + \" is >= the current size of: \" + bytesUsed ) ; \nlong seen = 0 ; \nfor ( int i = 0 ; \ni < slabs . size ( ) ; \ni = i + 1 ) { \nByteBuffer slab = slabs . get ( i ) ; \nif ( index < seen + slab . limit ( ) ) { \nslab . put ( ( int ) ( index - seen ) , value ) ; \nbreak ; \n} \nseen += slab . limit ( ) ; \n} \n} \n} \n"}
{"1978": "public class ColumnIndexBuilder { \npublic void add ( Statistics < ? > stats ) { \nif ( stats . hasNonNullValue ( ) ) { \nnullPages . add ( false ) ; \nObject min = stats . genericGetMin ( ) ; \nObject max = stats . genericGetMax ( ) ; \naddMinMax ( min , max ) ; \npageIndexes . add ( nextPageIndex ) ; \nminMaxSize += sizeOf ( min ) ; \nminMaxSize += sizeOf ( max ) ; \n} \nelse { \nnullPages . add ( true ) ; \n} \nnullCounts . add ( stats . getNumNulls ( ) ) ; \nnextPageIndex = nextPageIndex + 1 ; \n} \n} \n"}
{"1982": "public class GlobParser { \nprivate static String annotateMessage ( String message , int pos ) { \nStringBuilder sb = new StringBuilder ( message ) ; \nsb . append ( '\\n' ) ; \nfor ( int i = 0 ; \ni < pos ; \ni = i + 1 ) { \nsb . append ( '-' ) ; \n} \nsb . append ( '^' ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2015": "public class ColumnWriterBase { \n@ Override public void writeNull ( int repetitionLevel , int definitionLevel ) { \nif ( DEBUG ) log ( null , repetitionLevel , definitionLevel ) ; \nrepetitionLevel ( repetitionLevel ) ; \ndefinitionLevel ( definitionLevel ) ; \nstatistics . incrementNumNulls ( ) ; \nvalueCount = valueCount + 1 ; \n} \n} \n"}
{"2017": "public class DeltaBinaryPackingValuesReader { \n@ Override public void initFromPage ( int valueCount , ByteBufferInputStream stream ) throws IOException { \nthis . in = stream ; \nlong startPos = in . position ( ) ; \nthis . config = DeltaBinaryPackingConfig . readConfig ( in ) ; \nthis . totalValueCount = BytesUtils . readUnsignedVarInt ( in ) ; \nallocateValuesBuffer ( ) ; \nbitWidths = new int [ config . miniBlockNumInABlock ] ; \nvaluesBuffer [ valuesBuffered = valuesBuffered + 1 ] = BytesUtils . readZigZagVarLong ( in ) ; \nwhile ( valuesBuffered < totalValueCount ) { \nloadNewBlockToBuffer ( ) ; \n} \nupdateNextOffset ( ( int ) ( in . position ( ) - startPos ) ) ; \n} \n} \n"}
{"2020": "public class DeltaBinaryPackingValuesWriterForInteger { \nprivate void calculateBitWidthsForDeltaBlockBuffer ( int miniBlocksToFlush ) { \nfor ( int miniBlockIndex = 0 ; \nminiBlockIndex < miniBlocksToFlush ; \nminiBlockIndex = miniBlockIndex + 1 ) { \nint mask = 0 ; \nint miniStart = miniBlockIndex * config . miniBlockSizeInValues ; \nint miniEnd = Math . min ( ( miniBlockIndex + 1 ) * config . miniBlockSizeInValues , deltaValuesToFlush ) ; \nfor ( int i = miniStart ; \ni < miniEnd ; \ni = i + 1 ) { \nmask |= deltaBlockBuffer [ i ] ; \n} \nbitWidths [ miniBlockIndex ] = 32 - Integer . numberOfLeadingZeros ( mask ) ; \n} \n} \n} \n"}
{"2039": "public class ProtocolEventsAmender { \nprivate void checkSet ( Iterator < TProtocol > eventIter , ThriftField setFieldDefinition ) throws TException { \nTSet thriftSet = acceptProtocol ( eventIter . next ( ) ) . readSetBegin ( ) ; \nThriftField elementFieldDefinition = ( ( ThriftType . SetType ) setFieldDefinition . getType ( ) ) . getValues ( ) ; \nint setSize = thriftSet . size ; \nfor ( int i = 0 ; \ni < setSize ; \ni = i + 1 ) { \ncheckField ( thriftSet . elemType , eventIter , elementFieldDefinition ) ; \n} \nacceptProtocol ( eventIter . next ( ) ) . readSetEnd ( ) ; \n} \n} \n"}
{"2050": "public class FilteredRecordReader { \nprivate void skipToMatch ( ) { \nwhile ( recordsRead < recordCount && ! recordFilter . isMatch ( ) ) { \nState currentState = getState ( 0 ) ; \ndo { \nColumnReader columnReader = currentState . column ; \nif ( columnReader . getCurrentDefinitionLevel ( ) >= currentState . maxDefinitionLevel ) { \ncolumnReader . skip ( ) ; \n} \ncolumnReader . consume ( ) ; \nint nextR = currentState . maxRepetitionLevel == 0 ? 0 : columnReader . getCurrentRepetitionLevel ( ) ; \ncurrentState = currentState . getNextState ( nextR ) ; \n} \nwhile ( currentState != null ) ; \nrecordsRead = recordsRead + 1 ; \n} \n} \n} \n"}
{"2057": "public class PathGlobPattern { \npublic void set ( String glob ) { \nStringBuilder regex = new StringBuilder ( ) ; \nint setOpen = 0 ; \nint curlyOpen = 0 ; \nint len = glob . length ( ) ; \nhasWildcard = false ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nchar c = glob . charAt ( i ) ; \nswitch ( c ) { \ncase BACKSLASH : if ( i = i + 1 >= len ) { \nerror ( \"Missing escaped character\" , glob , i ) ; \n} \nregex . append ( c ) . append ( glob . charAt ( i ) ) ; \ncontinue ; \ncase '.' : case '$' : case '(' : case ')' : case '|' : case '+' : regex . append ( BACKSLASH ) ; \nbreak ; \ncase '*' : if ( i + 1 < len && glob . charAt ( i + 1 ) == '*' ) { \nregex . append ( '.' ) ; \ni = i + 1 ; \nbreak ; \n} \nregex . append ( \"[^\" + PATH_SEPARATOR + \"]\" ) ; \nhasWildcard = true ; \nbreak ; \ncase '?' : regex . append ( '.' ) ; \nhasWildcard = true ; \ncontinue ; \ncase '{' : regex . append ( \"(?:\" ) ; \ncurlyOpen = curlyOpen + 1 ; \nhasWildcard = true ; \ncontinue ; \ncase ',' : regex . append ( curlyOpen > 0 ? '|' : c ) ; \ncontinue ; \ncase '}' : if ( curlyOpen > 0 ) { \ncurlyOpen = curlyOpen - 1 ; \nregex . append ( \")\" ) ; \ncontinue ; \n} \nbreak ; \ncase '[' : if ( setOpen > 0 ) { \nerror ( \"Unclosed character class\" , glob , i ) ; \n} \nsetOpen = setOpen + 1 ; \nhasWildcard = true ; \nbreak ; \ncase '^' : if ( setOpen == 0 ) { \nregex . append ( BACKSLASH ) ; \n} \nbreak ; \ncase '!' : regex . append ( setOpen > 0 && '[' == glob . charAt ( i - 1 ) ? '^' : '!' ) ; \ncontinue ; \ncase ']' : setOpen = 0 ; \nbreak ; \ndefault : } \nregex . append ( c ) ; \n} \nif ( setOpen > 0 ) { \nerror ( \"Unclosed character class\" , glob , len ) ; \n} \nif ( curlyOpen > 0 ) { \nerror ( \"Unclosed group\" , glob , len ) ; \n} \ncompiled = Pattern . compile ( regex . toString ( ) ) ; \n} \n} \n"}
{"2078": "public class ByteBasedBitPackingEncoder { \npublic void writeInt ( int value ) throws IOException { \ninput [ inputSize ] = value ; \ninputSize = inputSize + 1 ; \nif ( inputSize == VALUES_WRITTEN_AT_A_TIME ) { \npack ( ) ; \nif ( packedPosition == slabSize ) { \nslabs . add ( BytesInput . from ( packed ) ) ; \ntotalFullSlabSize += slabSize ; \nif ( slabSize < bitWidth * MAX_SLAB_SIZE_MULT ) { \nslabSize *= 2 ; \n} \ninitPackedSlab ( ) ; \n} \n} \n} \n} \n"}
{"2128": "public class HttpClientSource { \nString parseHeadersOnly ( BatchMaker batchMaker ) throws StageException { \nHttpSourceOffset sourceOffset = new HttpSourceOffset ( getResolvedUrl ( ) , currentParameterHash , System . currentTimeMillis ( ) , getCurrentPage ( ) ) ; \nRecord record = getContext ( ) . createRecord ( sourceOffset + \"::0\" ) ; \naddResponseHeaders ( record . getHeader ( ) ) ; \nrecord . set ( Field . create ( new HashMap ( ) ) ) ; \nbatchMaker . addRecord ( record ) ; \nrecordCount = recordCount + 1 ; \nincrementSourceOffset ( sourceOffset , 1 ) ; \nlastRequestCompletedTime = System . currentTimeMillis ( ) ; \nreturn sourceOffset . toString ( ) ; \n} \n} \n"}
{"2130": "public class HttpClientSource { \nprivate int parsePaginatedResult ( BatchMaker batchMaker , String sourceOffset , Record record ) throws StageException { \nint numSubRecords = 0 ; \nif ( ! record . has ( conf . pagination . resultFieldPath ) ) { \nfinal StageException stageException = new StageException ( Errors . HTTP_12 , conf . pagination . resultFieldPath ) ; \nLOG . error ( stageException . getMessage ( ) ) ; \nthrow stageException ; \n} \nField resultField = record . get ( conf . pagination . resultFieldPath ) ; \nif ( resultField . getType ( ) != Field . Type . LIST ) { \nfinal StageException stageException = new StageException ( Errors . HTTP_08 , resultField . getType ( ) ) ; \nLOG . error ( stageException . getMessage ( ) ) ; \nthrow stageException ; \n} \nList < Field > results = resultField . getValueAsList ( ) ; \nint subRecordIdx = 0 ; \nfor ( Field result : results ) { \nRecord r = getContext ( ) . createRecord ( sourceOffset + \"::\" + subRecordIdx = subRecordIdx + 1 ) ; \nif ( conf . pagination . keepAllFields ) { \nr . set ( record . get ( ) . clone ( ) ) ; \nr . set ( conf . pagination . resultFieldPath , result ) ; \n} \nelse { \nr . set ( result ) ; \n} \naddResponseHeaders ( r . getHeader ( ) ) ; \nbatchMaker . addRecord ( r ) ; \nnumSubRecords = numSubRecords + 1 ; \n} \nif ( conf . pagination . mode != PaginationMode . LINK_FIELD ) { \nhaveMorePages = numSubRecords > 0 ; \n} \nreturn numSubRecords ; \n} \n} \n"}
{"2142": "public class MultiLineLiveFileReader { \nint findNextMainLine ( LiveFileChunk chunk , int startIdx ) { \nList < FileLine > lines = chunk . getLines ( ) ; \nint found = - 1 ; \nfor ( int i = startIdx ; \nfound == - 1 && i < lines . size ( ) ; \ni = i + 1 ) { \nif ( pattern . matcher ( lines . get ( i ) . getText ( ) . trim ( ) ) . matches ( ) ) { \nfound = i ; \n} \n} \nreturn found ; \n} \n} \n"}
{"2143": "public class MultiLineLiveFileReader { \nLiveFileChunk resolveChunk ( LiveFileChunk chunk ) { \nList < FileLine > completeLines = new ArrayList < > ( ) ; \nList < FileLine > chunkLines = chunk . getLines ( ) ; \nif ( incompleteMultiLine . length ( ) == 0 ) { \nincompleteMultiLineOffset = chunk . getOffset ( ) ; \nincompleteMultiLineTruncated = chunk . isTruncated ( ) ; \n} \nincompleteMultiLineTruncated |= chunk . isTruncated ( ) ; \nint pos = 0 ; \nint idx = findNextMainLine ( chunk , pos ) ; \nwhile ( idx > - 1 ) { \nfor ( int i = pos ; \ni < idx ; \ni = i + 1 ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( incompleteMultiLine . length ( ) != 0 ) { \ncompleteLines . add ( new FileLine ( incompleteMultiLineOffset , incompleteMultiLine . toString ( ) ) ) ; \nincompleteMultiLineOffset += incompleteMultiLine . length ( ) ; \nincompleteMultiLine . setLength ( 0 ) ; \nincompleteMultiLineTruncated = false ; \n} \nincompleteMultiLine . append ( chunkLines . get ( idx ) . getText ( ) ) ; \npos = idx + 1 ; \nidx = findNextMainLine ( chunk , pos ) ; \n} \nfor ( int i = pos ; \ni < chunkLines . size ( ) ; \ni = i + 1 ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( completeLines . isEmpty ( ) ) { \nchunk = null ; \n} \nelse { \nchunk = new LiveFileChunk ( chunk . getTag ( ) , chunk . getFile ( ) , chunk . getCharset ( ) , completeLines , incompleteMultiLineTruncated ) ; \n} \nreturn chunk ; \n} \n} \n"}
{"2145": "public class FieldRenamerProcessor { \nprivate static String escapeQuotedSubstring ( String input ) { \nString [ ] parts = input . split ( \"'\" ) ; \nStringBuilder output = new StringBuilder ( input . length ( ) * 2 ) ; \nfor ( int i = 0 ; \ni < parts . length ; \ni = i + 1 ) { \nif ( ( i % 2 ) == 1 ) { \noutput . append ( \"'\" ) . append ( parts [ i ] . replace ( \"|\" , \"\\\\|\" ) ) . append ( \"'\" ) ; \n} \nelse { \noutput . append ( parts [ i ] ) ; \n} \n} \nreturn output . toString ( ) ; \n} \n} \n"}
{"2175": "public class Utils { \npublic static String format ( String template , Object ... args ) { \nString [ ] templateArr = TEMPLATES . get ( template ) ; \nif ( templateArr == null ) { \ntemplateArr = prepareTemplate ( template ) ; \nTEMPLATES . put ( template , templateArr ) ; \n} \nStringBuilder sb = new StringBuilder ( template . length ( ) * 2 ) ; \nfor ( int i = 0 ; \ni < templateArr . length ; \ni = i + 1 ) { \nsb . append ( templateArr [ i ] ) ; \nif ( args != null && ( i < templateArr . length - 1 ) ) { \nsb . append ( ( i < args . length ) ? args [ i ] : TOKEN ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2216": "public class JdbcMultiRowRecordWriter { \nprivate void processQueue ( LinkedList < Record > queue , List < OnRecordErrorException > errorRecords , Connection connection , int maxRowsPerBatch , int opCode ) throws StageException { \nif ( queue . isEmpty ( ) ) { \nreturn ; \n} \nint rowCount = 0 ; \nfinal Record first = queue . getFirst ( ) ; \nSortedMap < String , String > columnsToParameters = recordReader . getColumnsToParameters ( first , opCode , getColumnsToParameters ( ) , opCode == OperationType . UPDATE_CODE ? getColumnsToFieldNoPK ( ) : getColumnsToFields ( ) ) ; \nif ( columnsToParameters . isEmpty ( ) ) { \nif ( LOG . isWarnEnabled ( ) ) { \nLOG . warn ( \"No parameters found for record with ID {}; skipping\" , first . getHeader ( ) . getSourceId ( ) ) ; \n} \nreturn ; \n} \nString query = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , Math . min ( maxRowsPerBatch , queue . size ( ) ) ) ; \nLinkedList < Record > removed = new LinkedList < > ( ) ; \ntry ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { \nint paramIdx = 1 ; \nwhile ( ! queue . isEmpty ( ) ) { \nRecord r = queue . removeFirst ( ) ; \nif ( opCode != DELETE_CODE ) { \nparamIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; \n} \nif ( opCode != OperationType . INSERT_CODE ) { \nparamIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; \n} \nremoved . add ( r ) ; \nrowCount = rowCount + 1 ; \nif ( rowCount == maxRowsPerBatch ) { \nprocessBatch ( removed , errorRecords , statement , connection ) ; \nrowCount = 0 ; \nparamIdx = 1 ; \nremoved . clear ( ) ; \n} \n} \n} \ncatch ( SQLException e ) { \nhandleSqlException ( e , removed , errorRecords ) ; \n} \nif ( ! removed . isEmpty ( ) ) { \nquery = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , removed . size ( ) ) ; \ntry ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { \nint paramIdx = 1 ; \nfor ( Record r : removed ) { \nif ( opCode != DELETE_CODE ) { \nparamIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; \n} \nif ( opCode != OperationType . INSERT_CODE ) { \nparamIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; \n} \n} \nprocessBatch ( removed , errorRecords , statement , connection ) ; \n} \ncatch ( SQLException e ) { \nhandleSqlException ( e , removed , errorRecords ) ; \n} \n} \n} \n} \n"}
{"2284": "public class BigQueryDelegate { \npublic LinkedHashMap < String , Field > fieldsToMap ( List < com . google . cloud . bigquery . Field > schema , List < FieldValue > values ) { \ncheckState ( schema . size ( ) == values . size ( ) , \"Schema '{}' and Values '{}' sizes do not match.\" , schema . size ( ) , values . size ( ) ) ; \nLinkedHashMap < String , Field > root = new LinkedHashMap < > ( ) ; \nfor ( int i = 0 ; \ni < values . size ( ) ; \ni = i + 1 ) { \nFieldValue value = values . get ( i ) ; \ncom . google . cloud . bigquery . Field field = schema . get ( i ) ; \nif ( value . getAttribute ( ) . equals ( FieldValue . Attribute . PRIMITIVE ) ) { \nroot . put ( field . getName ( ) , fromPrimitiveField ( field , value ) ) ; \n} \nelse if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . RECORD ) ) { \nroot . put ( field . getName ( ) , Field . create ( fieldsToMap ( field . getSubFields ( ) , value . getRecordValue ( ) ) ) ) ; \n} \nelse if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . REPEATED ) ) { \nroot . put ( field . getName ( ) , Field . create ( fromRepeatedField ( field , value . getRepeatedValue ( ) ) ) ) ; \n} \n} \nreturn root ; \n} \n} \n"}
{"2287": "public class KineticaTableUtils { \nprivate Class < ? > getColumnType ( JSONObject field ) throws GPUdbException { \nClass < ? > columnType = null ; \nif ( field . get ( \"type\" ) instanceof JSONArray ) { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \nfor ( int j = 0 ; \nj < columnTypes . length ( ) ; \nj = j + 1 ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ! ct . equals ( \"null\" ) ) { \ncolumnType = getClassForType ( ct ) ; \nbreak ; \n} \n} \n} \nelse { \ncolumnType = getClassForType ( field . getString ( \"type\" ) ) ; \n} \nif ( columnType == null ) { \nthrow new GPUdbException ( \"Error getting column type for field: \" + field . toString ( ) ) ; \n} \nreturn columnType ; \n} \n} \n"}
{"2288": "public class KineticaTableUtils { \nprivate boolean typeIsNullable ( JSONObject field ) throws GPUdbException { \nif ( field . get ( \"type\" ) instanceof JSONArray ) { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \nfor ( int j = 0 ; \nj < columnTypes . length ( ) ; \nj = j + 1 ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ct . equals ( \"null\" ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"2292": "public class AerospikeBeanConfig { \npublic void init ( Target . Context context , List < Target . ConfigIssue > issues ) { \nList < Host > hosts = getAerospikeHosts ( issues , connectionString , Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , context ) ; \nClientPolicy cp = new ClientPolicy ( ) ; \ntry { \nclient = new AerospikeClient ( cp , hosts . toArray ( new Host [ hosts . size ( ) ] ) ) ; \nint retries = 0 ; \nwhile ( ! client . isConnected ( ) && retries <= maxRetries ) { \nif ( retries > maxRetries ) { \nissues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; \nreturn ; \n} \nretries = retries + 1 ; \ntry { \nThread . sleep ( 100 ) ; \n} \ncatch ( InterruptedException ignored ) { \n} \n} \n} \ncatch ( AerospikeException ex ) { \nissues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; \n} \n} \n} \n"}
{"2308": "public class LoginManager { \npublic void release ( ) { \nsynchronized ( LoginManager . class ) { \nif ( refCount == 0 ) throw new IllegalStateException ( \"release called on LoginManager with refCount == 0\" ) ; \nelse if ( refCount == 1 ) { \nCACHED_INSTANCES . remove ( loginType ) ; \nlogin . shutdown ( ) ; \n} \nrefCount = refCount - 1 ; \n} \n} \n} \n"}
{"2312": "public class ProductionPipelineRunner { \npublic int produceEmptyBatchesForIdleRunners ( long idleTime ) throws PipelineException , StageException { \nLOG . debug ( \"Checking if any active runner is idle\" ) ; \nint counter = 0 ; \ntry { \ndestroyLock . lock ( ) ; \nwhile ( running && counter < pipes . size ( ) ) { \ncounter = counter + 1 ; \nPipeRunner runner = null ; \ntry { \nrunner = runnerPool . getIdleRunner ( idleTime ) ; \nif ( runner == null ) { \nreturn counter ; \n} \nLOG . debug ( \"Generating empty batch for runner: {}\" , runner . getRunnerId ( ) ) ; \npipeContext . getRuntimeStats ( ) . incIdleBatchCount ( ) ; \nFullPipeBatch pipeBatch = new FullPipeBatch ( null , null , 0 , false ) ; \npipeBatch . setIdleBatch ( true ) ; \npipeBatch . skipStage ( originPipe ) ; \nexecuteRunner ( runner , System . currentTimeMillis ( ) , pipeBatch , null , null , new HashMap < > ( ) , new HashMap < > ( ) ) ; \n} \nfinally { \nif ( runner != null ) { \nrunnerPool . returnRunner ( runner ) ; \n} \n} \n} \n} \nfinally { \ndestroyLock . unlock ( ) ; \n} \nreturn counter ; \n} \n} \n"}
{"2318": "public class LogCharDataParser { \nint readLine ( StringBuilder sb ) throws IOException { \nint c = reader . read ( ) ; \nint count = ( c == - 1 ) ? - 1 : 0 ; \nwhile ( c > - 1 && ! isOverMaxObjectLen ( count ) && ! checkEolAndAdjust ( c ) ) { \ncount = count + 1 ; \nsb . append ( ( char ) c ) ; \nc = reader . read ( ) ; \n} \nif ( isOverMaxObjectLen ( count ) ) { \nsb . setLength ( sb . length ( ) - 1 ) ; \nwhile ( c > - 1 && c != '\\n' && c != '\\r' ) { \ncount = count + 1 ; \nc = reader . read ( ) ; \n} \ncheckEolAndAdjust ( c ) ; \n} \nreturn count ; \n} \n} \n"}
{"2336": "public class Pattern { \nstatic private boolean isSlashEscapedChar ( String s , int pos ) { \nint numSlashes = 0 ; \nwhile ( pos > 0 && ( s . charAt ( pos - 1 ) == '\\\\' ) ) { \npos = pos - 1 ; \nnumSlashes = numSlashes + 1 ; \n} \nreturn numSlashes % 2 != 0 ; \n} \n} \n"}
{"2338": "public class Pattern { \nstatic private int countOpenParens ( String s , int pos ) { \njava . util . regex . Pattern p = java . util . regex . Pattern . compile ( \"\\\\(\" ) ; \njava . util . regex . Matcher m = p . matcher ( s . subSequence ( 0 , pos ) ) ; \nint numParens = 0 ; \nwhile ( m . find ( ) ) { \nif ( isInsideCharClass ( s , m . start ( ) ) ) { \ncontinue ; \n} \nif ( isEscapedChar ( s , m . start ( ) ) ) continue ; \nif ( ! isNoncapturingParen ( s , m . start ( ) ) ) { \nnumParens = numParens + 1 ; \n} \n} \nreturn numParens ; \n} \n} \n"}
{"2349": "public class CollectdParser { \nprivate int parseValues ( int startOffset , ByteBuf buf ) throws OnRecordErrorException { \nint offset = startOffset ; \nint numValues = buf . getUnsignedShort ( offset ) ; \noffset += 2 ; \nList < Byte > types = new ArrayList < > ( numValues ) ; \nwhile ( numValues = numValues - 1 > 0 ) { \ntypes . add ( buf . getByte ( offset ) ) ; \noffset += 1 ; \n} \nfor ( int i = 0 ; \ni < types . size ( ) ; \ni = i + 1 ) { \nByte type = types . get ( i ) ; \nString label = getValueLabel ( i , type ) ; \nswitch ( type ) { \ncase COUNTER : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase GAUGE : fields . put ( label , Field . create ( buf . order ( ByteOrder . LITTLE_ENDIAN ) . getDouble ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase DERIVE : fields . put ( label , Field . create ( buf . getLong ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase ABSOLUTE : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ndefault : throw new OnRecordErrorException ( Errors . COLLECTD_01 , type ) ; \n} \n} \nreturn offset ; \n} \n} \n"}
{"2354": "public class JdbcBaseRecordWriter { \nint setPrimaryKeys ( int index , final Record record , PreparedStatement statement , int opCode ) throws OnRecordErrorException { \nfor ( String key : getPrimaryKeyColumns ( ) ) { \nField field = record . get ( recordReader . getFieldPath ( key , getColumnsToFields ( ) , opCode ) ) ; \nif ( field == null ) { \nLOG . error ( \"Primary key {} is missing in record\" , key ) ; \nthrow new OnRecordErrorException ( record , JdbcErrors . JDBC_19 , key ) ; \n} \nObject value = field . getValue ( ) ; \ntry { \nstatement . setObject ( index , value , getColumnType ( key ) ) ; \n} \ncatch ( SQLException ex ) { \nLOG . error ( \"SQLException thrown: {}\" , ex . getMessage ( ) ) ; \nthrow new OnRecordErrorException ( record , JdbcErrors . JDBC_19 , key , ex ) ; \n} \nindex = index + 1 ; \n} \nreturn index ; \n} \n} \n"}
{"2368": "public class MetricEnabledWrapperStream { \nstatic String convertBytesToDisplayFormat ( double bytes ) { \nint unitIdx = 0 ; \ndouble unitChangedBytes = bytes ; \nwhile ( unitIdx < UNITS . length - 1 && Math . floor ( unitChangedBytes / 1024 ) > 0 ) { \nunitChangedBytes = unitChangedBytes / 1024 ; \nunitIdx = unitIdx + 1 ; \n} \nreturn df . format ( unitChangedBytes ) + \" \" + UNITS [ unitIdx ] ; \n} \n} \n"}
{"2392": "public class WholeFileTransformerProcessor { \nprivate void writeParquet ( String sourceFileName , DataFileStream < GenericRecord > fileReader , Path tempParquetFile ) throws StageException { \nlong recordCount = 0 ; \nGenericRecord avroRecord ; \nSchema schema = fileReader . getSchema ( ) ; \nLOG . debug ( \"Start reading input file : {}\" , sourceFileName ) ; \ntry { \nConfiguration jobConfiguration = new Configuration ( ) ; \nString compressionCodecName = compressionElEval . eval ( variables , jobConfig . avroParquetConfig . compressionCodec , String . class ) ; \njobConfiguration . set ( AvroParquetConstants . COMPRESSION_CODEC_NAME , compressionCodecName ) ; \njobConfiguration . setInt ( AvroParquetConstants . ROW_GROUP_SIZE , jobConfig . avroParquetConfig . rowGroupSize ) ; \njobConfiguration . setInt ( AvroParquetConstants . PAGE_SIZE , jobConfig . avroParquetConfig . pageSize ) ; \njobConfiguration . setInt ( AvroParquetConstants . DICTIONARY_PAGE_SIZE , jobConfig . avroParquetConfig . dictionaryPageSize ) ; \njobConfiguration . setInt ( AvroParquetConstants . MAX_PADDING_SIZE , jobConfig . avroParquetConfig . maxPaddingSize ) ; \nParquetWriter . Builder builder = AvroToParquetConverterUtil . initializeWriter ( new org . apache . hadoop . fs . Path ( tempParquetFile . toString ( ) ) , schema , jobConfiguration ) ; \nparquetWriter = builder . build ( ) ; \nwhile ( fileReader . hasNext ( ) ) { \navroRecord = fileReader . next ( ) ; \nparquetWriter . write ( avroRecord ) ; \nrecordCount = recordCount + 1 ; \n} \nparquetWriter . close ( ) ; \n} \ncatch ( IOException ex ) { \nthrow new TransformerStageCheckedException ( Errors . CONVERT_08 , sourceFileName , recordCount , ex ) ; \n} \nLOG . debug ( \"Finished writing {} records to {}\" , recordCount , tempParquetFile . getFileName ( ) ) ; \n} \n} \n"}
{"2443": "public class HTTPSession { \nprivate int findHeaderEnd ( final byte [ ] buf , int rlen ) { \nint splitbyte = 0 ; \nwhile ( splitbyte + 1 < rlen ) { \nif ( buf [ splitbyte ] == '\\r' && buf [ splitbyte + 1 ] == '\\n' && splitbyte + 3 < rlen && buf [ splitbyte + 2 ] == '\\r' && buf [ splitbyte + 3 ] == '\\n' ) { \nreturn splitbyte + 4 ; \n} \nif ( buf [ splitbyte ] == '\\n' && buf [ splitbyte + 1 ] == '\\n' ) { \nreturn splitbyte + 2 ; \n} \nsplitbyte = splitbyte + 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"2465": "public class MethodInfoHelper { \npublic static String [ ] getCanonicalParameterTypes ( Method viewMethod ) { \nClass < ? > [ ] parameterTypes = viewMethod . getParameterTypes ( ) ; \nif ( parameterTypes == null ) { \nreturn NO_STRINGS ; \n} \nString [ ] canonicalNames = new String [ parameterTypes . length ] ; \nfor ( int i = 0 ; \ni < parameterTypes . length ; \ni = i + 1 ) { \ncanonicalNames [ i ] = parameterTypes [ i ] . getCanonicalName ( ) ; \n} \nreturn canonicalNames ; \n} \n} \n"}
{"2485": "public class TransactionSubsystem10Parser { \nstatic void parseCoreEnvironmentElement ( final XMLExtendedStreamReader reader , final ModelNode operation ) throws XMLStreamException { \nfinal int count = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nrequireNoNamespaceAttribute ( reader , i ) ; \nfinal String value = reader . getAttributeValue ( i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nswitch ( attribute ) { \ncase NODE_IDENTIFIER : TransactionSubsystemRootResourceDefinition . NODE_IDENTIFIER . parseAndSetParameter ( value , operation , reader ) ; \nbreak ; \ncase PATH : case RELATIVE_TO : throw TransactionLogger . ROOT_LOGGER . unsupportedAttribute ( attribute . getLocalName ( ) , reader . getLocation ( ) ) ; \ndefault : throw unexpectedAttribute ( reader , i ) ; \n} \n} \nfinal EnumSet < Element > required = EnumSet . of ( Element . PROCESS_ID ) ; \nfinal EnumSet < Element > encountered = EnumSet . noneOf ( Element . class ) ; \nwhile ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { \nfinal Element element = Element . forName ( reader . getLocalName ( ) ) ; \nrequired . remove ( element ) ; \nswitch ( element ) { \ncase PROCESS_ID : { \nif ( ! encountered . add ( element ) ) { \nthrow duplicateNamedElement ( reader , reader . getLocalName ( ) ) ; \n} \nparseProcessIdEnvironmentElement ( reader , operation ) ; \nbreak ; \n} \ndefault : throw unexpectedElement ( reader ) ; \n} \n} \nif ( ! required . isEmpty ( ) ) { \nthrow missingRequiredElement ( reader , required ) ; \n} \n} \n} \n"}
{"2510": "public class Injection { \nprotected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Method > hits = null ; \nMethod [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni = i + 1 ) { \nfinal Method method = methods [ i ] ; \nif ( methodName . equals ( method . getName ( ) ) && method . getParameterTypes ( ) . length == 1 ) { \nif ( propertyType == null || argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; \nSecurityActions . setAccessible ( method ) ; \nhits . add ( method ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new MethodSorter ( ) ) ; \nif ( propertyType != null ) { \nfor ( Method m : hits ) { \nif ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) return m ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2511": "public class Injection { \nprotected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Field > hits = null ; \nField [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; \nfor ( int i = 0 ; \ni < fields . length ; \ni = i + 1 ) { \nfinal Field field = fields [ i ] ; \nif ( fieldName . equals ( field . getName ( ) ) ) { \nif ( fieldType == null || argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; \nSecurityActions . setAccessible ( field ) ; \nhits . add ( field ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new FieldSorter ( ) ) ; \nif ( fieldType != null ) { \nfor ( Field f : hits ) { \nif ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) return f ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2513": "public class AuditNotificationReceiver { \nprivate static String deriveUsefulInfo ( HttpServletRequest httpRequest ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"[\" ) . append ( httpRequest . getContextPath ( ) ) ; \nsb . append ( \":cookies=\" ) . append ( Arrays . toString ( httpRequest . getCookies ( ) ) ) . append ( \":headers=\" ) ; \nEnumeration < ? > en = httpRequest . getHeaderNames ( ) ; \nwhile ( en . hasMoreElements ( ) ) { \nString headerName = ( String ) en . nextElement ( ) ; \nsb . append ( headerName ) . append ( \"=\" ) ; \nif ( ! headerName . contains ( \"authorization\" ) ) { \nsb . append ( httpRequest . getHeader ( headerName ) ) . append ( \",\" ) ; \n} \n} \nsb . append ( \"]\" ) ; \nsb . append ( \"[parameters=\" ) ; \nEnumeration < ? > enparam = httpRequest . getParameterNames ( ) ; \nwhile ( enparam . hasMoreElements ( ) ) { \nString paramName = ( String ) enparam . nextElement ( ) ; \nString [ ] paramValues = httpRequest . getParameterValues ( paramName ) ; \nint len = paramValues != null ? paramValues . length : 0 ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nsb . append ( paramValues [ i ] ) . append ( \"::\" ) ; \n} \nsb . append ( \",\" ) ; \n} \nsb . append ( \"][attributes=\" ) ; \nEnumeration < ? > enu = httpRequest . getAttributeNames ( ) ; \nwhile ( enu . hasMoreElements ( ) ) { \nString attrName = ( String ) enu . nextElement ( ) ; \nsb . append ( attrName ) . append ( \"=\" ) ; \nsb . append ( httpRequest . getAttribute ( attrName ) ) . append ( \",\" ) ; \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2519": "public class StubStrategy { \npublic void writeParams ( OutputStream out , Object [ ] params ) { \nint len = params . length ; \nif ( len != paramWriters . length ) { \nthrow IIOPLogger . ROOT_LOGGER . errorMashalingParams ( ) ; \n} \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nObject param = params [ i ] ; \nif ( param instanceof PortableRemoteObject ) { \ntry { \nparam = PortableRemoteObject . toStub ( ( Remote ) param ) ; \n} \ncatch ( NoSuchObjectException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nparamWriters [ i ] . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( param ) ) ; \n} \n} \n} \n"}
{"2528": "public class AbstractInvocationHandler { \nprivate boolean matches ( final Method seiMethod , final Method viewMethod ) { \nif ( ! seiMethod . getName ( ) . equals ( viewMethod . getName ( ) ) ) return false ; \nfinal Class < ? > [ ] sourceParams = seiMethod . getParameterTypes ( ) ; \nfinal Class < ? > [ ] targetParams = viewMethod . getParameterTypes ( ) ; \nif ( sourceParams . length != targetParams . length ) return false ; \nfor ( int i = 0 ; \ni < sourceParams . length ; \ni = i + 1 ) { \nif ( ! sourceParams [ i ] . equals ( targetParams [ i ] ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"2550": "public class CommonIronJacamarParser { \nprivate String parseConnectionAttributes_5_0 ( final XMLExtendedStreamReader reader , final ModelNode connectionDefinitionNode ) throws XMLStreamException { \nString poolName = null ; \nString jndiName = null ; \nint attributeSize = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < attributeSize ; \ni = i + 1 ) { \nConnectionDefinition . Attribute attribute = ConnectionDefinition . Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nString value = reader . getAttributeValue ( i ) ; \nswitch ( attribute ) { \ncase ENABLED : { \nENABLED . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CONNECTABLE : { \nCONNECTABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase TRACKING : { \nTRACKING . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase JNDI_NAME : { \njndiName = value ; \nJNDINAME . parseAndSetParameter ( jndiName , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase POOL_NAME : { \npoolName = value ; \nbreak ; \n} \ncase USE_JAVA_CONTEXT : { \nUSE_JAVA_CONTEXT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase USE_CCM : { \nUSE_CCM . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase SHARABLE : { \nSHARABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT : { \nENLISTMENT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CLASS_NAME : { \nCLASS_NAME . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase MCP : { \nMCP . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT_TRACE : ENLISTMENT_TRACE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \ndefault : throw ParseUtils . unexpectedAttribute ( reader , i ) ; \n} \n} \nif ( poolName == null || poolName . trim ( ) . equals ( \"\" ) ) { \nif ( jndiName != null && jndiName . trim ( ) . length ( ) != 0 ) { \nif ( jndiName . contains ( \"/\" ) ) { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \"/\" ) + 1 ) ; \n} \nelse { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \":\" ) + 1 ) ; \n} \n} \nelse { \nthrow ParseUtils . missingRequired ( reader , EnumSet . of ( ConnectionDefinition . Attribute . JNDI_NAME ) ) ; \n} \n} \nreturn poolName ; \n} \n} \n"}
{"2616": "public class SkeletonStrategy { \npublic Object [ ] readParams ( InputStream in ) { \nint len = paramReaders . length ; \nObject [ ] params = new Object [ len ] ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nparams [ i ] = paramReaders [ i ] . read ( in ) ; \n} \nreturn params ; \n} \n} \n"}
{"2618": "public class SkeletonStrategy { \npublic void writeException ( OutputStream out , Throwable e ) { \nint len = excepWriters . length ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nif ( excepWriters [ i ] . getExceptionClass ( ) . isInstance ( e ) ) { \nexcepWriters [ i ] . write ( out , e ) ; \nreturn ; \n} \n} \nthrow new UnknownException ( e ) ; \n} \n} \n"}
{"2619": "public class DefaultBeanInfo { \nprotected < U > U lookup ( Lookup < U > lookup , int start , int depth ) { \nint size ; \nsynchronized ( indexes ) { \nsize = indexes . size ( ) ; \nfor ( int i = start ; \ni < depth && i < size ; \ni = i + 1 ) { \nU result = lookup . lookup ( indexes . get ( i ) ) ; \nif ( result != null ) return result ; \n} \n} \nif ( currentClass == null ) return null ; \nsynchronized ( indexes ) { \nClassReflectionIndex cri = index . getClassIndex ( currentClass ) ; \nindexes . add ( cri ) ; \ncurrentClass = currentClass . getSuperclass ( ) ; \n} \nreturn lookup ( lookup , size , depth ) ; \n} \n} \n"}
{"2620": "public class SFSBCallStack { \npublic static void beginSfsbCreation ( ) { \nSFSBCallStackThreadData data = CURRENT . get ( ) ; \nint no = data . creationBeanNestingLevel ; \nif ( no == 0 ) { \ndata . creationTimeXPCRegistration = new HashMap < String , ExtendedEntityManager > ( ) ; \ndata . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( data . creationTimeInjectedXPCs , null ) ; \n} \nelse { \nSFSBInjectedXPCs parent = data . creationTimeInjectedXPCs ; \ndata . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( parent , parent . getTopLevel ( ) ) ; \n} \ndata . creationBeanNestingLevel = data . creationBeanNestingLevel + 1 ; \n} \n} \n"}
{"2621": "public class SFSBCallStack { \npublic static void endSfsbCreation ( ) { \nSFSBCallStackThreadData data = CURRENT . get ( ) ; \nint no = data . creationBeanNestingLevel ; \nno = no - 1 ; \ndata . creationBeanNestingLevel = no ; \nif ( no == 0 ) { \ndata . creationTimeXPCRegistration = null ; \ndata . creationTimeInjectedXPCs = null ; \n} \nelse { \ndata . creationTimeInjectedXPCs = data . creationTimeInjectedXPCs . getParent ( ) ; \n} \n} \n} \n"}
{"2627": "public class JSFComponentProcessor { \nprivate void processXmlManagedBeans ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder className = null ; \nint indent = 0 ; \nboolean managedBean = false ; \nboolean managedBeanClass = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent = indent + 1 ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN ) ) { \nmanagedBean = true ; \n} \n} \nelse if ( indent == 3 && managedBean ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN_CLASS ) ) { \nmanagedBeanClass = true ; \nclassName = new StringBuilder ( ) ; \n} \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent = indent - 1 ; \nmanagedBeanClass = false ; \nif ( indent == 1 ) { \nmanagedBean = false ; \n} \nif ( className != null ) { \nmanagedBeanClasses . add ( className . toString ( ) . trim ( ) ) ; \nclassName = null ; \n} \n} \nelse if ( managedBeanClass && event == XMLStreamConstants . CHARACTERS ) { \nclassName . append ( parser . getText ( ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . managedBeansConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2628": "public class JSFComponentProcessor { \nprivate void processPhaseListeners ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder phaseListenerName = null ; \nint indent = 0 ; \nboolean lifecycle = false ; \nboolean phaseListener = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent = indent + 1 ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( LIFECYCLE ) ) { \nlifecycle = true ; \n} \n} \nelse if ( indent == 3 && lifecycle ) { \nif ( parser . getLocalName ( ) . equals ( PHASE_LISTENER ) ) { \nphaseListener = true ; \nphaseListenerName = new StringBuilder ( ) ; \n} \n} \n} \nelse if ( event == XMLStreamConstants . END_ELEMENT ) { \nindent = indent - 1 ; \nphaseListener = false ; \nif ( indent == 1 ) { \nlifecycle = false ; \n} \nif ( phaseListenerName != null ) { \nmanagedBeanClasses . add ( phaseListenerName . toString ( ) . trim ( ) ) ; \nphaseListenerName = null ; \n} \n} \nelse if ( phaseListener && event == XMLStreamConstants . CHARACTERS ) { \nphaseListenerName . append ( parser . getText ( ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . phaseListenersConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2629": "public class Util { \npublic static String getTypeIDLName ( Class cls ) throws RMIIIOPViolationException { \nif ( cls . isPrimitive ( ) ) return PrimitiveAnalysis . getPrimitiveAnalysis ( cls ) . getIDLName ( ) ; \nif ( cls . isArray ( ) ) { \nClass componentClass = cls ; \nint sequence = 0 ; \nwhile ( componentClass . isArray ( ) ) { \ncomponentClass = componentClass . getComponentType ( ) ; \nsequence = sequence + 1 ; \n} \nString idlName = getTypeIDLName ( componentClass ) ; \nint idx = idlName . lastIndexOf ( \"::\" ) ; \nString idlModule = idlName . substring ( 0 , idx + 2 ) ; \nString baseName = idlName . substring ( idx + 2 ) ; \nreturn \"::org::omg::boxedRMI\" + idlModule + \"seq\" + sequence + \"_\" + baseName ; \n} \nif ( cls == java . lang . String . class ) return \"::CORBA::WStringValue\" ; \nif ( cls == java . lang . Object . class ) return \"::java::lang::_Object\" ; \nif ( cls == java . lang . Class . class ) return \"::javax::rmi::CORBA::ClassDesc\" ; \nif ( cls == java . io . Serializable . class ) return \"::java::io::Serializable\" ; \nif ( cls == java . io . Externalizable . class ) return \"::java::io::Externalizable\" ; \nif ( cls == java . rmi . Remote . class ) return \"::java::rmi::Remote\" ; \nif ( cls == org . omg . CORBA . Object . class ) return \"::CORBA::Object\" ; \nif ( cls . isInterface ( ) && java . rmi . Remote . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \nif ( cls . isInterface ( ) && org . omg . CORBA . Object . class . isAssignableFrom ( cls ) && org . omg . CORBA . portable . IDLEntity . class . isAssignableFrom ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \nreturn ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; \n} \nif ( Throwable . class . isAssignableFrom ( cls ) ) { \nif ( Exception . class . isAssignableFrom ( cls ) && ! RuntimeException . class . isAssignableFrom ( cls ) ) { \nExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; \nreturn ea . getIDLModuleName ( ) + \"::\" + ea . getIDLName ( ) ; \n} \n} \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \nreturn va . getIDLModuleName ( ) + \"::\" + va . getIDLName ( ) ; \n} \n} \n"}
{"2631": "public class Util { \npublic static String javaToIDLName ( String name ) { \nif ( name == null || \"\" . equals ( name ) || name . indexOf ( '.' ) != - 1 ) throw IIOPLogger . ROOT_LOGGER . nameCannotBeNullEmptyOrQualified ( ) ; \nStringBuffer res = new StringBuffer ( name . length ( ) ) ; \nif ( name . charAt ( 0 ) == '_' ) res . append ( 'J' ) ; \nfor ( int i = 0 ; \ni < name . length ( ) ; \ni = i + 1 ) { \nchar c = name . charAt ( i ) ; \nif ( isLegalIDLIdentifierChar ( c ) ) res . append ( c ) ; \nelse res . append ( 'U' ) . append ( toHexString ( ( int ) c ) ) ; \n} \nString s = res . toString ( ) ; \nif ( isReservedIDLKeyword ( s ) ) return \"_\" + s ; \nelse return s ; \n} \n} \n"}
{"2632": "public class Util { \nprivate static boolean isReservedIDLKeyword ( String s ) { \nfor ( int i = 0 ; \ni < reservedIDLKeywords . length ; \ni = i + 1 ) if ( reservedIDLKeywords [ i ] . equals ( s ) ) return true ; \nreturn false ; \n} \n} \n"}
{"2634": "public class Util { \nprivate static String getSignature ( Method method ) { \nStringBuffer b = new StringBuffer ( \"(\" ) ; \nClass [ ] parameterTypes = method . getParameterTypes ( ) ; \nfor ( int i = 0 ; \ni < parameterTypes . length ; \ni = i + 1 ) b . append ( getSignature ( parameterTypes [ i ] ) ) ; \nb . append ( ')' ) . append ( getSignature ( method . getReturnType ( ) ) ) ; \nreturn b . toString ( ) ; \n} \n} \n"}
{"2645": "public class NamingEventCoordinator { \nvoid fireEvent ( final EventContext context , final Name name , final Binding existingBinding , final Binding newBinding , int type , final String changeInfo , final Integer ... scopes ) { \nfinal String target = name . toString ( ) ; \nfinal Set < Integer > scopeSet = new HashSet < Integer > ( Arrays . asList ( scopes ) ) ; \nfinal NamingEvent event = new NamingEvent ( context , type , newBinding , existingBinding , changeInfo ) ; \nfinal Set < ListenerHolder > holdersToFire = new HashSet < ListenerHolder > ( ) ; \nif ( scopeSet . contains ( EventContext . OBJECT_SCOPE ) ) { \nfinal TargetScope targetScope = new TargetScope ( target , EventContext . OBJECT_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \nif ( scopeSet . contains ( EventContext . ONELEVEL_SCOPE ) && ! name . isEmpty ( ) ) { \nfinal TargetScope targetScope = new TargetScope ( name . getPrefix ( name . size ( ) - 1 ) . toString ( ) , EventContext . ONELEVEL_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \nif ( scopeSet . contains ( EventContext . SUBTREE_SCOPE ) && ! name . isEmpty ( ) ) { \nfor ( int i = 1 ; \ni < name . size ( ) ; \ni = i + 1 ) { \nfinal Name parentName = name . getPrefix ( i ) ; \nfinal TargetScope targetScope = new TargetScope ( parentName . toString ( ) , EventContext . SUBTREE_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \n} \nexecutor . execute ( new FireEventTask ( holdersToFire , event ) ) ; \n} \n} \n"}
{"2685": "public class RmiIdlUtil { \npublic static boolean isAllFieldsPublic ( Class c ) { \ntry { \nfinal Field [ ] list = c . getFields ( ) ; \nfor ( int i = 0 ; \ni < list . length ; \ni = i + 1 ) if ( ! Modifier . isPublic ( list [ i ] . getModifiers ( ) ) ) return false ; \n} \ncatch ( Exception e ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"2703": "public class CNNameParser { \nprivate static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { \nint len = str . length ( ) ; \nVector components = new Vector ( 10 ) ; \nchar [ ] id = new char [ len ] ; \nchar [ ] kind = new char [ len ] ; \nint idCount , kindCount ; \nboolean idMode ; \nfor ( int i = 0 ; \ni < len ; \n) { \nidCount = kindCount = 0 ; \nidMode = true ; \nwhile ( i < len ) { \nif ( str . charAt ( i ) == compSeparator ) { \nbreak ; \n} \nelse if ( str . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; \n} \nelse if ( isMeta ( str . charAt ( i + 1 ) ) ) { \ni = i + 1 ; \nif ( idMode ) { \nid [ idCount = idCount + 1 ] = str . charAt ( i = i + 1 ) ; \n} \nelse { \nkind [ kindCount = kindCount + 1 ] = str . charAt ( i = i + 1 ) ; \n} \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; \n} \n} \nelse if ( idMode && str . charAt ( i ) == kindSeparator ) { \ni = i + 1 ; \nidMode = false ; \n} \nelse { \nif ( idMode ) { \nid [ idCount = idCount + 1 ] = str . charAt ( i = i + 1 ) ; \n} \nelse { \nkind [ kindCount = kindCount + 1 ] = str . charAt ( i = i + 1 ) ; \n} \n} \n} \ncomponents . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; \nif ( i < len ) { \ni = i + 1 ; \n} \n} \nreturn components ; \n} \n} \n"}
{"2704": "public class CNNameParser { \nprivate static NameComponent parseComponent ( String compStr ) throws InvalidNameException { \nNameComponent comp = new NameComponent ( ) ; \nint kindSep = - 1 ; \nint len = compStr . length ( ) ; \nint j = 0 ; \nchar [ ] newStr = new char [ len ] ; \nboolean escaped = false ; \nfor ( int i = 0 ; \ni < len && kindSep < 0 ; \ni = i + 1 ) { \nif ( escaped ) { \nnewStr [ j = j + 1 ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse if ( compStr . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \nelse if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \n} \nelse if ( compStr . charAt ( i ) == kindSeparator ) { \nkindSep = i ; \n} \nelse { \nnewStr [ j = j + 1 ] = compStr . charAt ( i ) ; \n} \n} \ncomp . id = new String ( newStr , 0 , j ) ; \nif ( kindSep < 0 ) { \ncomp . kind = \"\" ; \n} \nelse { \nj = 0 ; \nescaped = false ; \nfor ( int i = kindSep + 1 ; \ni < len ; \ni = i + 1 ) { \nif ( escaped ) { \nnewStr [ j = j + 1 ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse if ( compStr . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \nelse if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \n} \nelse { \nnewStr [ j = j + 1 ] = compStr . charAt ( i ) ; \n} \n} \ncomp . kind = new String ( newStr , 0 , j ) ; \n} \nreturn comp ; \n} \n} \n"}
{"2750": "public class ContainerAnalysis { \nprotected boolean hasNonAppExceptions ( Method m ) { \nClass [ ] ex = m . getExceptionTypes ( ) ; \nfor ( int i = 0 ; \ni < ex . length ; \ni = i + 1 ) if ( ! java . rmi . RemoteException . class . isAssignableFrom ( ex [ i ] ) ) return false ; \nreturn true ; \n} \n} \n"}
{"2753": "public class ContainerAnalysis { \nprotected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { \nfor ( int i = 0 ; \ni < methods . length ; \ni = i + 1 ) { \nif ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) continue ; \nOperationAnalysis oa = null ; \nString javaName = methods [ i ] . getName ( ) ; \nfor ( int opIdx = 0 ; \noa == null && opIdx < operations . length ; \nopIdx = opIdx + 1 ) if ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; \nif ( oa == null ) continue ; \nParameterAnalysis [ ] params = oa . getParameters ( ) ; \nStringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; \nif ( params . length == 0 ) b . append ( \"__\" ) ; \nfor ( int j = 0 ; \nj < params . length ; \nj = j + 1 ) { \nString s = params [ j ] . getTypeIDLName ( ) ; \nif ( s . startsWith ( \"::\" ) ) s = s . substring ( 2 ) ; \nif ( s . startsWith ( \"_\" ) ) { \ns = s . substring ( 1 ) ; \n} \nb . append ( '_' ) ; \nwhile ( ! \"\" . equals ( s ) ) { \nint idx = s . indexOf ( \"::\" ) ; \nb . append ( '_' ) ; \nif ( idx == - 1 ) { \nb . append ( s ) ; \ns = \"\" ; \n} \nelse { \nb . append ( s . substring ( 0 , idx ) ) ; \nif ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == '_' ) { \ns = s . substring ( idx + 3 ) ; \n} \nelse { \ns = s . substring ( idx + 2 ) ; \n} \n} \n} \n} \noa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2754": "public class ContainerAnalysis { \nprotected void fixupCaseNames ( ) throws RMIIIOPViolationException { \nArrayList entries = getContainedEntries ( ) ; \nboolean [ ] clash = new boolean [ entries . size ( ) ] ; \nString [ ] upperNames = new String [ entries . size ( ) ] ; \nfor ( int i = 0 ; \ni < entries . size ( ) ; \ni = i + 1 ) { \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nclash [ i ] = false ; \nupperNames [ i ] = aa . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ; \nfor ( int j = 0 ; \nj < i ; \nj = j + 1 ) { \nif ( upperNames [ i ] . equals ( upperNames [ j ] ) ) { \nclash [ i ] = true ; \nclash [ j ] = true ; \n} \n} \n} \nfor ( int i = 0 ; \ni < entries . size ( ) ; \ni = i + 1 ) { \nif ( ! clash [ i ] ) continue ; \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nboolean noUpper = true ; \nString name = aa . getIDLName ( ) ; \nStringBuffer b = new StringBuffer ( name ) ; \nb . append ( '_' ) ; \nfor ( int j = 0 ; \nj < name . length ( ) ; \nj = j + 1 ) { \nif ( ! Character . isUpperCase ( name . charAt ( j ) ) ) continue ; \nif ( noUpper ) noUpper = false ; \nelse b . append ( '_' ) ; \nb . append ( j ) ; \n} \naa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2755": "public class ContainerAnalysis { \nprotected String escapeIRName ( String name ) { \nStringBuffer b = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < name . length ( ) ; \ni = i + 1 ) { \nchar c = name . charAt ( i ) ; \nif ( c < 256 ) b . append ( c ) ; \nelse b . append ( \"\\\\U\" ) . append ( toHexString ( ( int ) c ) ) ; \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"2758": "public class XTSSubsystemParser { \nprivate void processAttributes ( final XMLExtendedStreamReader reader , AttributeProcessor < Integer , Attribute > attributeProcessorCallback ) throws XMLStreamException { \nfinal int count = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nParseUtils . requireNoNamespaceAttribute ( reader , i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nattributeProcessorCallback . process ( i , attribute ) ; \n} \n} \n} \n"}
{"2819": "public class PooledConnectionFactoryRemove { \nprotected void removeJNDIAliases ( OperationContext context , List < ModelNode > entries ) { \nif ( entries . size ( ) > 1 ) { \nfor ( int i = 1 ; \ni < entries . size ( ) ; \ni = i + 1 ) { \nContextNames . BindInfo aliasBindInfo = ContextNames . bindInfoFor ( entries . get ( i ) . asString ( ) ) ; \ncontext . removeService ( aliasBindInfo . getBinderServiceName ( ) ) ; \n} \n} \n} \n} \n"}
{"2826": "public class ValueDefImpl { \nprivate ValueMember [ ] getValueMembers ( ) { \nif ( valueMembers != null ) return valueMembers ; \nLocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; \nvalueMembers = new ValueMember [ c . length ] ; \nfor ( int i = 0 ; \ni < c . length ; \ni = i + 1 ) { \nValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; \nvalueMembers [ i ] = new ValueMember ( vmdi . name ( ) , vmdi . id ( ) , ( ( LocalContained ) vmdi . defined_in ) . id ( ) , vmdi . version ( ) , vmdi . type ( ) , vmdi . type_def ( ) , vmdi . access ( ) ) ; \n} \nreturn valueMembers ; \n} \n} \n"}
{"2827": "public class ValueDefImpl { \nprivate ValueMember [ ] getValueMembersForTypeCode ( ) { \nLocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; \nValueMember [ ] vms = new ValueMember [ c . length ] ; \nfor ( int i = 0 ; \ni < c . length ; \ni = i + 1 ) { \nValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; \nvms [ i ] = new ValueMember ( vmdi . name ( ) , null , null , null , vmdi . type ( ) , null , vmdi . access ( ) ) ; \n} \nreturn vms ; \n} \n} \n"}
{"2829": "public class AbstractFederationSubsystemReader { \nprotected ModelNode parseConfig ( XMLExtendedStreamReader reader , ModelElement xmlElement , String key , ModelNode lastNode , List < SimpleAttributeDefinition > attributes , List < ModelNode > addOperations ) throws XMLStreamException { \nif ( ! reader . getLocalName ( ) . equals ( xmlElement . getName ( ) ) ) { \nreturn null ; \n} \nModelNode modelNode = Util . getEmptyOperation ( ADD , null ) ; \nint attributeCount = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ni < attributeCount ; \ni = i + 1 ) { \nString attributeLocalName = reader . getAttributeLocalName ( i ) ; \nif ( ModelElement . forName ( attributeLocalName ) == null ) { \nthrow unexpectedAttribute ( reader , i ) ; \n} \n} \nfor ( SimpleAttributeDefinition simpleAttributeDefinition : attributes ) { \nString attributeValue = reader . getAttributeValue ( \"\" , simpleAttributeDefinition . getXmlName ( ) ) ; \nsimpleAttributeDefinition . parseAndSetParameter ( attributeValue , modelNode , reader ) ; \n} \nString name = xmlElement . getName ( ) ; \nif ( key != null ) { \nname = key ; \nif ( modelNode . hasDefined ( key ) ) { \nname = modelNode . get ( key ) . asString ( ) ; \n} \nelse { \nString attributeValue = reader . getAttributeValue ( \"\" , key ) ; \nif ( attributeValue != null ) { \nname = attributeValue ; \n} \n} \n} \nmodelNode . get ( ModelDescriptionConstants . OP_ADDR ) . set ( lastNode . clone ( ) . get ( OP_ADDR ) . add ( xmlElement . getName ( ) , name ) ) ; \naddOperations . add ( modelNode ) ; \nreturn modelNode ; \n} \n} \n"}
{"2849": "public class InterfaceRepository { \nprivate String [ ] addInterfaces ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { \nInterfaceAnalysis [ ] interfaces = ca . getInterfaces ( ) ; \nList base_interfaces = new ArrayList ( ) ; \nfor ( int i = 0 ; \ni < interfaces . length ; \ni = i + 1 ) { \nInterfaceDefImpl idi = addInterface ( interfaces [ i ] ) ; \nbase_interfaces . add ( idi . id ( ) ) ; \n} \nString [ ] strArr = new String [ base_interfaces . size ( ) ] ; \nreturn ( String [ ] ) base_interfaces . toArray ( strArr ) ; \n} \n} \n"}
{"2850": "public class InterfaceRepository { \nprivate String [ ] addAbstractBaseValuetypes ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { \nValueAnalysis [ ] abstractValuetypes = ca . getAbstractBaseValuetypes ( ) ; \nList abstract_base_valuetypes = new ArrayList ( ) ; \nfor ( int i = 0 ; \ni < abstractValuetypes . length ; \ni = i + 1 ) { \nValueDefImpl vdi = addValue ( abstractValuetypes [ i ] ) ; \nabstract_base_valuetypes . add ( vdi . id ( ) ) ; \n} \nString [ ] strArr = new String [ abstract_base_valuetypes . size ( ) ] ; \nreturn ( String [ ] ) abstract_base_valuetypes . toArray ( strArr ) ; \n} \n} \n"}
{"2853": "public class InterfaceRepository { \nprivate ValueDefImpl addValue ( ValueAnalysis va ) throws RMIIIOPViolationException , IRConstructionException { \nValueDefImpl vDef ; \nClass cls = va . getCls ( ) ; \nvDef = ( ValueDefImpl ) valueMap . get ( cls ) ; \nif ( vDef != null ) return vDef ; \nModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; \nString [ ] supported_interfaces = addInterfaces ( va ) ; \nString [ ] abstract_base_valuetypes = addAbstractBaseValuetypes ( va ) ; \nValueDefImpl superValue = null ; \nValueAnalysis superAnalysis = va . getSuperAnalysis ( ) ; \nif ( superAnalysis != null ) superValue = addValue ( superAnalysis ) ; \nString base = cls . getName ( ) ; \nbase = base . substring ( base . lastIndexOf ( '.' ) + 1 ) ; \nbase = Util . javaToIDLName ( base ) ; \nTypeCode baseTypeCode ; \nif ( superValue == null ) baseTypeCode = orb . get_primitive_tc ( TCKind . tk_null ) ; \nelse baseTypeCode = superValue . type ( ) ; \nvDef = new ValueDefImpl ( va . getRepositoryId ( ) , base , \"1.0\" , m , va . isAbstractValue ( ) , va . isCustom ( ) , supported_interfaces , abstract_base_valuetypes , baseTypeCode , impl ) ; \naddTypeCode ( cls , vDef . type ( ) ) ; \nm . add ( base , vDef ) ; \nvalueMap . put ( cls , vDef ) ; \naddConstants ( vDef , va ) ; \nValueMemberAnalysis [ ] vmas = va . getMembers ( ) ; \nfor ( int i = 0 ; \ni < vmas . length ; \ni = i + 1 ) { \nValueMemberDefImpl vmDef ; \nString vmid = va . getMemberRepositoryId ( vmas [ i ] . getJavaName ( ) ) ; \nString vmName = vmas [ i ] . getIDLName ( ) ; \nClass vmCls = vmas [ i ] . getCls ( ) ; \nTypeCode typeCode = getTypeCode ( vmCls ) ; \nboolean vmPublic = vmas [ i ] . isPublic ( ) ; \nvmDef = new ValueMemberDefImpl ( vmid , vmName , \"1.0\" , typeCode , vmPublic , vDef , impl ) ; \nvDef . add ( vmName , vmDef ) ; \n} \naddAttributes ( vDef , va ) ; \nreturn vDef ; \n} \n} \n"}
{"2867": "public class Configurator { \npublic static String [ ] getTypes ( ValueConfig [ ] values ) { \nif ( values == null || values . length == 0 ) return NO_PARAMS_TYPES ; \nString [ ] types = new String [ values . length ] ; \nfor ( int i = 0 ; \ni < types . length ; \ni = i + 1 ) types [ i ] = values [ i ] . getType ( ) ; \nreturn types ; \n} \n} \n"}
{"2869": "public class CNBindingEnumeration { \npublic java . lang . Object next ( ) throws NamingException { \nif ( more && counter >= _bindingList . value . length ) { \ngetMore ( ) ; \n} \nif ( more && counter < _bindingList . value . length ) { \norg . omg . CosNaming . Binding bndg = _bindingList . value [ counter ] ; \ncounter = counter + 1 ; \nreturn mapBinding ( bndg ) ; \n} \nelse { \nthrow new NoSuchElementException ( ) ; \n} \n} \n} \n"}
{"2890": "public class InterfaceAnalysis { \nprotected void calculateOperationAnalysisMap ( ) { \noperationAnalysisMap = new HashMap ( ) ; \nOperationAnalysis oa ; \nfor ( int i = 0 ; \ni < operations . length ; \ni = i + 1 ) { \noa = operations [ i ] ; \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n} \nfor ( int i = 0 ; \ni < attributes . length ; \ni = i + 1 ) { \nAttributeAnalysis attr = attributes [ i ] ; \noa = attr . getAccessorAnalysis ( ) ; \nif ( oa != null ) { \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \noa = attr . getMutatorAnalysis ( ) ; \nif ( oa != null ) operationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n} \n} \n} \n} \n"}
{"2911": "public class OWhereClause { \npublic long estimate ( OClass oClass , long threshold , OCommandContext ctx ) { \nlong count = oClass . count ( ) ; \nif ( count > 1 ) { \ncount = count / 2 ; \n} \nif ( count < threshold ) { \nreturn count ; \n} \nlong indexesCount = 0l ; \nList < OAndBlock > flattenedConditions = flatten ( ) ; \nSet < OIndex < ? > > indexes = oClass . getIndexes ( ) ; \nfor ( OAndBlock condition : flattenedConditions ) { \nList < OBinaryCondition > indexedFunctConditions = condition . getIndexedFunctionConditions ( oClass , ( ODatabaseDocumentInternal ) ctx . getDatabase ( ) ) ; \nlong conditionEstimation = Long . MAX_VALUE ; \nif ( indexedFunctConditions != null ) { \nfor ( OBinaryCondition cond : indexedFunctConditions ) { \nOFromClause from = new OFromClause ( - 1 ) ; \nOFromItem item = new OFromItem ( - 1 ) ; \nfrom . item = item ; \nfrom . item . setIdentifier ( new OIdentifier ( oClass . getName ( ) ) ) ; \nlong newCount = cond . estimateIndexed ( from , ctx ) ; \nif ( newCount < conditionEstimation ) { \nconditionEstimation = newCount ; \n} \n} \n} \nelse { \nMap < String , Object > conditions = getEqualityOperations ( condition , ctx ) ; \nfor ( OIndex index : indexes ) { \nif ( index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT . name ( ) ) || index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT_HASH_INDEX . name ( ) ) ) { \ncontinue ; \n} \nList < String > indexedFields = index . getDefinition ( ) . getFields ( ) ; \nint nMatchingKeys = 0 ; \nfor ( String indexedField : indexedFields ) { \nif ( conditions . containsKey ( indexedField ) ) { \nnMatchingKeys = nMatchingKeys + 1 ; \n} \nelse { \nbreak ; \n} \n} \nif ( nMatchingKeys > 0 ) { \nlong newCount = estimateFromIndex ( index , conditions , nMatchingKeys ) ; \nif ( newCount < conditionEstimation ) { \nconditionEstimation = newCount ; \n} \n} \n} \n} \nif ( conditionEstimation > count ) { \nreturn count ; \n} \nindexesCount += conditionEstimation ; \n} \nreturn Math . min ( indexesCount , count ) ; \n} \n} \n"}
{"2922": "public class OSelectExecutionPlanner { \nprivate static void extractSubQueries ( QueryPlanningInfo info ) { \nSubQueryCollector collector = new SubQueryCollector ( ) ; \nif ( info . perRecordLetClause != null ) { \ninfo . perRecordLetClause . extractSubQueries ( collector ) ; \n} \nint i = 0 ; \nint j = 0 ; \nfor ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { \nOIdentifier alias = entry . getKey ( ) ; \nOStatement query = entry . getValue ( ) ; \nif ( query . refersToParent ( ) ) { \naddRecordLevelLet ( info , alias , query , j = j + 1 ) ; \n} \nelse { \naddGlobalLet ( info , alias , query , i = i + 1 ) ; \n} \n} \ncollector . reset ( ) ; \nif ( info . whereClause != null ) { \ninfo . whereClause . extractSubQueries ( collector ) ; \n} \nif ( info . projection != null ) { \ninfo . projection . extractSubQueries ( collector ) ; \n} \nif ( info . orderBy != null ) { \ninfo . orderBy . extractSubQueries ( collector ) ; \n} \nif ( info . groupBy != null ) { \ninfo . groupBy . extractSubQueries ( collector ) ; \n} \nfor ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { \nOIdentifier alias = entry . getKey ( ) ; \nOStatement query = entry . getValue ( ) ; \nif ( query . refersToParent ( ) ) { \naddRecordLevelLet ( info , alias , query ) ; \n} \nelse { \naddGlobalLet ( info , alias , query ) ; \n} \n} \n} \n} \n"}
{"2924": "public class OSelectExecutionPlanner { \nprivate boolean handleClassWithIndexForSortOnly ( OSelectExecutionPlan plan , OIdentifier queryTarget , Set < String > filterClusters , QueryPlanningInfo info , OCommandContext ctx , boolean profilingEnabled ) { \nOSchema schema = getSchemaFromContext ( ctx ) ; \nOClass clazz = schema . getClass ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nclazz = schema . getView ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nthrow new OCommandExecutionException ( \"Class not found: \" + queryTarget ) ; \n} \n} \nfor ( OIndex idx : clazz . getIndexes ( ) . stream ( ) . filter ( i -> i . supportsOrderedIterations ( ) ) . filter ( i -> i . getDefinition ( ) != null ) . collect ( Collectors . toList ( ) ) ) { \nList < String > indexFields = idx . getDefinition ( ) . getFields ( ) ; \nif ( indexFields . size ( ) < info . orderBy . getItems ( ) . size ( ) ) { \ncontinue ; \n} \nboolean indexFound = true ; \nString orderType = null ; \nfor ( int i = 0 ; \ni < info . orderBy . getItems ( ) . size ( ) ; \ni = i + 1 ) { \nOOrderByItem orderItem = info . orderBy . getItems ( ) . get ( i ) ; \nif ( orderItem . getCollate ( ) != null ) { \nreturn false ; \n} \nString indexField = indexFields . get ( i ) ; \nif ( i == 0 ) { \norderType = orderItem . getType ( ) ; \n} \nelse { \nif ( orderType == null || ! orderType . equals ( orderItem . getType ( ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( ! ( indexField . equals ( orderItem . getAlias ( ) ) || isInOriginalProjection ( indexField , orderItem . getAlias ( ) ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( indexFound && orderType != null ) { \nplan . chain ( new FetchFromIndexValuesStep ( idx , orderType . equals ( OOrderByItem . ASC ) , ctx , profilingEnabled ) ) ; \nint [ ] filterClusterIds = null ; \nif ( filterClusters != null ) { \nfilterClusterIds = filterClusters . stream ( ) . map ( name -> ctx . getDatabase ( ) . getClusterIdByName ( name ) ) . mapToInt ( i -> i ) . toArray ( ) ; \n} \nplan . chain ( new GetValueFromIndexEntryStep ( ctx , filterClusterIds , profilingEnabled ) ) ; \nif ( info . serverToClusters . size ( ) == 1 ) { \ninfo . orderApplied = true ; \n} \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2934": "public class ODistributedOutput { \npublic static String getCompactServerStatus ( final ODistributedServerManager manager , final ODocument distribCfg ) { \nfinal StringBuilder buffer = new StringBuilder ( ) ; \nfinal Collection < ODocument > members = distribCfg . field ( \"members\" ) ; \nif ( members != null ) { \nbuffer . append ( members . size ( ) ) ; \nbuffer . append ( \":[\" ) ; \nint memberCount = 0 ; \nfor ( ODocument m : members ) { \nif ( m == null ) continue ; \nif ( memberCount = memberCount + 1 > 0 ) buffer . append ( \",\" ) ; \nfinal String serverName = m . field ( \"name\" ) ; \nbuffer . append ( serverName ) ; \nbuffer . append ( ( Object ) m . field ( \"status\" ) ) ; \nfinal Collection < String > databases = m . field ( \"databases\" ) ; \nif ( databases != null ) { \nbuffer . append ( \"{\" ) ; \nint dbCount = 0 ; \nfor ( String dbName : databases ) { \nfinal ODistributedConfiguration dbCfg = manager . getDatabaseConfiguration ( dbName , false ) ; \nif ( dbCfg == null ) continue ; \nif ( dbCount = dbCount + 1 > 0 ) buffer . append ( \",\" ) ; \nbuffer . append ( dbName ) ; \nbuffer . append ( \"=\" ) ; \nbuffer . append ( manager . getDatabaseStatus ( serverName , dbName ) ) ; \nbuffer . append ( \" (\" ) ; \nbuffer . append ( dbCfg . getServerRole ( serverName ) ) ; \nbuffer . append ( \")\" ) ; \n} \nbuffer . append ( \"}\" ) ; \n} \n} \nbuffer . append ( \"]\" ) ; \n} \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"2938": "public class OHazelcastPlugin { \n@ Override public String electNewLockManager ( ) { \nif ( hazelcastInstance == null ) throw new HazelcastInstanceNotActiveException ( ) ; \nfinal ILock lock = hazelcastInstance . getLock ( \"orientdb.lockManagerElection\" ) ; \nlock . lock ( ) ; \ntry { \nString lockManagerServer = getLockManagerRequester ( ) . getServer ( ) ; \nif ( lockManagerServer != null && getActiveServers ( ) . contains ( lockManagerServer ) ) return lockManagerServer ; \nfinal String originalLockManager = lockManagerServer ; \nODistributedServerLog . debug ( this , nodeName , originalLockManager , DIRECTION . OUT , \"lock '%s' is unreachable, electing a new lock...\" , originalLockManager ) ; \nint lockManagerServerId = - 1 ; \nif ( lockManagerServer != null && registeredNodeByName . containsKey ( lockManagerServer ) ) lockManagerServerId = registeredNodeByName . get ( lockManagerServer ) ; \nString newServer = null ; \nint currIndex = lockManagerServerId ; \nfor ( int i = 0 ; \ni < registeredNodeById . size ( ) ; \ni = i + 1 ) { \ncurrIndex = currIndex + 1 ; \nif ( currIndex >= registeredNodeById . size ( ) ) currIndex = 0 ; \nnewServer = registeredNodeById . get ( currIndex ) ; \nif ( newServer == null ) throw new OConfigurationException ( \"Found null server at index \" + currIndex + \" of server list \" + registeredNodeById ) ; \nif ( newServer . equalsIgnoreCase ( getLocalNodeName ( ) ) || activeNodes . containsKey ( newServer ) ) { \nODistributedServerLog . debug ( this , nodeName , newServer , DIRECTION . OUT , \"Trying to elected server '%s' as new lock (old=%s)...\" , newServer , originalLockManager ) ; \ntry { \ngetLockManagerRequester ( ) . setServer ( newServer ) ; \nconfigurationMap . put ( CONFIG_LOCKMANAGER , getLockManagerRequester ( ) . getServer ( ) ) ; \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Elected server '%s' as new lock (old=%s)\" , newServer , originalLockManager ) ; \nbreak ; \n} \ncatch ( Exception e ) { \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Error on electing server '%s' as new lock (error: %s)\" , newServer , e ) ; \n} \n} \n} \nreturn newServer ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"2940": "public class OMicroTransaction { \npublic void commit ( ) { \nif ( ! active ) throw error ( \"Inactive micro-transaction on commit\" ) ; \nif ( level < 1 ) throw error ( \"Unbalanced micro-transaction, level = \" + level ) ; \nlevel = level - 1 ; \nif ( level == 0 ) { \nactive = false ; \ndoCommit ( ) ; \n} \n} \n} \n"}
{"2941": "public class OMicroTransaction { \npublic void rollback ( ) { \nif ( ! active ) throw error ( \"Inactive micro-transaction on rollback\" ) ; \nif ( level < 1 ) throw error ( \"Unbalanced micro-transaction, level = \" + level ) ; \nlevel = level - 1 ; \nif ( level == 0 ) { \nactive = false ; \ndoRollback ( ) ; \n} \n} \n} \n"}
{"2970": "public class OEmbeddedRidBag { \npublic boolean swap ( int index , OIdentifiable newValue ) { \nEntriesIterator iter = ( EntriesIterator ) rawIterator ( ) ; \nint currIndex = 0 ; \nwhile ( iter . hasNext ( ) ) { \niter . next ( ) ; \nif ( index == currIndex ) { \niter . swapValueOnCurrent ( newValue ) ; \nreturn true ; \n} \ncurrIndex = currIndex + 1 ; \n} \nreturn false ; \n} \n} \n"}
{"2975": "public class OJSONReader { \npublic int nextChar ( ) throws IOException { \nif ( missedChar != null ) { \nc = missedChar . charValue ( ) ; \nmissedChar = null ; \n} \nelse { \nint read = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nc = ( char ) read ; \nif ( c == '\\\\' ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nchar c2 = ( char ) read ; \nif ( c2 == 'u' ) { \nfinal StringBuilder buff = new StringBuilder ( 8 ) ; \nfor ( int i = 0 ; \ni < 4 ; \ni = i + 1 ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nbuff . append ( ( char ) read ) ; \n} \ncursor += 6 ; \nreturn ( char ) Integer . parseInt ( buff . toString ( ) , 16 ) ; \n} \nelse { \nmissedChar = c2 ; \n} \n} \n} \ncursor = cursor + 1 ; \nif ( c == NEW_LINE ) { \nlineNumber = lineNumber + 1 ; \ncolumnNumber = 0 ; \n} \nelse columnNumber = columnNumber + 1 ; \nreturn ( char ) c ; \n} \n} \n"}
{"2977": "public class OCommandRequestAbstract { \n@ Override public OCommandRequestAbstract onAsyncReplicationError ( final OAsyncReplicationError iCallback ) { \nif ( iCallback != null ) { \nonAsyncReplicationError = new OAsyncReplicationError ( ) { \nint retry = 0 ; \n@ Override public ACTION onAsyncReplicationError ( Throwable iException , final int iRetry ) { \nswitch ( iCallback . onAsyncReplicationError ( iException , retry = retry + 1 ) ) { \ncase RETRY : execute ( ) ; \nbreak ; \ncase IGNORE : } \nreturn ACTION . IGNORE ; \n} \n} \n; \n} \nelse onAsyncReplicationError = null ; \nreturn this ; \n} \n} \n"}
{"2983": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeUntilReturn ( ) { \nif ( steps . size ( ) > 0 ) { \nlastStep = steps . get ( steps . size ( ) - 1 ) ; \n} \nfor ( int i = 0 ; \ni < steps . size ( ) - 1 ; \ni = i + 1 ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) { \nlastStep = returnStep ; \nreturn lastStep ; \n} \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nwhile ( lastResult . hasNext ( ) ) { \nwhile ( lastResult . hasNext ( ) ) { \nlastResult . next ( ) ; \n} \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \n} \nthis . lastStep = steps . get ( steps . size ( ) - 1 ) ; \nreturn lastStep ; \n} \n} \n"}
{"2984": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeFull ( ) { \nfor ( int i = 0 ; \ni < steps . size ( ) ; \ni = i + 1 ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) { \nreturn returnStep ; \n} \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nwhile ( lastResult . hasNext ( ) ) { \nwhile ( lastResult . hasNext ( ) ) { \nlastResult . next ( ) ; \n} \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2994": "public class OSQLFilterItemField { \npublic OCollate getCollate ( Object doc ) { \nif ( collate != null || operationsChain == null || ! isFieldChain ( ) ) { \nreturn collate ; \n} \nif ( ! ( doc instanceof OIdentifiable ) ) { \nreturn null ; \n} \nFieldChain chain = getFieldChain ( ) ; \nODocument lastDoc = ( ( OIdentifiable ) doc ) . getRecord ( ) ; \nfor ( int i = 0 ; \ni < chain . getItemCount ( ) - 1 ; \ni = i + 1 ) { \nif ( lastDoc == null ) { \nreturn null ; \n} \nObject nextDoc = lastDoc . field ( chain . getItemName ( i ) ) ; \nif ( nextDoc == null || ! ( nextDoc instanceof OIdentifiable ) ) { \nreturn null ; \n} \nlastDoc = ( ( OIdentifiable ) nextDoc ) . getRecord ( ) ; \n} \nif ( lastDoc == null ) { \nreturn null ; \n} \nOClass schemaClass = lastDoc . getSchemaClass ( ) ; \nif ( schemaClass == null ) { \nreturn null ; \n} \nOProperty property = schemaClass . getProperty ( chain . getItemName ( chain . getItemCount ( ) - 1 ) ) ; \nif ( property == null ) { \nreturn null ; \n} \nreturn property . getCollate ( ) ; \n} \n} \n"}
{"3005": "public class OAbstract2pcTask { \n@ Override public int [ ] getPartitionKey ( ) { \nif ( tasks . size ( ) == 1 ) return tasks . get ( 0 ) . getPartitionKey ( ) ; \nfinal int [ ] partitions = new int [ tasks . size ( ) ] ; \nfor ( int i = 0 ; \ni < tasks . size ( ) ; \ni = i + 1 ) { \nfinal OAbstractRecordReplicatedTask task = tasks . get ( i ) ; \npartitions [ i ] = task . getPartitionKey ( ) [ 0 ] ; \n} \nreturn partitions ; \n} \n} \n"}
{"3018": "public class OCommandExecutorSQLDelete { \npublic boolean result ( final Object iRecord ) { \nfinal ORecordAbstract record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; \nif ( record instanceof ODocument && compiledFilter != null && ! Boolean . TRUE . equals ( this . compiledFilter . evaluate ( record , ( ODocument ) record , getContext ( ) ) ) ) { \nreturn true ; \n} \ntry { \nif ( record . getIdentity ( ) . isValid ( ) ) { \nif ( returning . equalsIgnoreCase ( \"BEFORE\" ) ) allDeletedRecords . add ( record ) ; \nif ( ! unsafe && record instanceof ODocument ) { \nfinal OClass cls = ( ( ODocument ) record ) . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( cls . isSubClassOf ( \"V\" ) ) throw new OCommandExecutionException ( \"'DELETE' command cannot delete vertices. Use 'DELETE VERTEX' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \nelse if ( cls . isSubClassOf ( \"E\" ) ) throw new OCommandExecutionException ( \"'DELETE' command cannot delete edges. Use 'DELETE EDGE' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \nrecord . delete ( ) ; \nrecordCount = recordCount + 1 ; \nreturn true ; \n} \nreturn false ; \n} \nfinally { \nif ( lockStrategy . equalsIgnoreCase ( \"RECORD\" ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) ) . releaseWriteLock ( record . getIdentity ( ) ) ; \n} \n} \n} \n"}
{"3019": "public class OSQLPredicate { \npublic void bindParameters ( final Map < Object , Object > iArgs ) { \nif ( parameterItems == null || iArgs == null || iArgs . size ( ) == 0 ) return ; \nfor ( int i = 0 ; \ni < parameterItems . size ( ) ; \ni = i + 1 ) { \nOSQLFilterItemParameter value = parameterItems . get ( i ) ; \nif ( \"?\" . equals ( value . getName ( ) ) ) { \nvalue . setValue ( iArgs . get ( i ) ) ; \n} \nelse { \nvalue . setValue ( iArgs . get ( value . getName ( ) ) ) ; \n} \n} \n} \n} \n"}
{"3020": "public class FrequencySketch { \nprivate void reset ( ) { \nint count = 0 ; \nfor ( int i = 0 ; \ni < table . length ; \ni = i + 1 ) { \ncount += Long . bitCount ( table [ i ] & ONE_MASK ) ; \ntable [ i ] = ( table [ i ] >>> 1 ) & RESET_MASK ; \n} \nsize = ( size >>> 1 ) - ( count >>> 2 ) ; \n} \n} \n"}
{"3051": "public class OSessionStoragePerformanceStatistic { \npublic void completeComponentOperation ( ) { \nfinal Component currentComponent = componentsStack . peek ( ) ; \nif ( currentComponent == null ) return ; \ncurrentComponent . operationCount = currentComponent . operationCount - 1 ; \nif ( currentComponent . operationCount == 0 ) { \nfinal String componentName = currentComponent . name ; \nPerformanceCountersHolder cHolder = countersByComponent . computeIfAbsent ( componentName , k -> currentComponent . type . newCountersHolder ( ) ) ; \ncHolder . operationsCount = cHolder . operationsCount + 1 ; \ncomponentsStack . pop ( ) ; \nmakeSnapshotIfNeeded ( - 1 ) ; \n} \n} \n} \n"}
{"3057": "public class OSessionStoragePerformanceStatistic { \npublic void stopWriteCacheFlushTimer ( int pagesFlushed ) { \nif ( writCacheCountersHolder == null ) writCacheCountersHolder = new WritCacheCountersHolder ( ) ; \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nwritCacheCountersHolder . flushOperationsCount = writCacheCountersHolder . flushOperationsCount + 1 ; \nwritCacheCountersHolder . amountOfPagesFlushed += pagesFlushed ; \nwritCacheCountersHolder . flushOperationsTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3058": "public class OSessionStoragePerformanceStatistic { \npublic void stopFuzzyCheckpointTimer ( ) { \nif ( writCacheCountersHolder == null ) writCacheCountersHolder = new WritCacheCountersHolder ( ) ; \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nwritCacheCountersHolder . fuzzyCheckpointCount = writCacheCountersHolder . fuzzyCheckpointCount + 1 ; \nwritCacheCountersHolder . fuzzyCheckpointTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3059": "public class OSessionStoragePerformanceStatistic { \npublic void stopFullCheckpointTimer ( ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( storageCountersHolder == null ) storageCountersHolder = new StorageCountersHolder ( ) ; \nstorageCountersHolder . fullCheckpointOperationsCount = storageCountersHolder . fullCheckpointOperationsCount + 1 ; \nstorageCountersHolder . fullCheckpointOperationsTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3060": "public class OSessionStoragePerformanceStatistic { \npublic void stopCommitTimer ( ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nperformanceCountersHolder . commitTime += timeDiff ; \nperformanceCountersHolder . commitCount = performanceCountersHolder . commitCount + 1 ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3061": "public class OSessionStoragePerformanceStatistic { \npublic void stopWALRecordTimer ( boolean isStartRecord , boolean isStopRecord ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( walCountersHolder == null ) walCountersHolder = new WALCountersHolder ( ) ; \nwalCountersHolder . logRecordCount = walCountersHolder . logRecordCount + 1 ; \nwalCountersHolder . logRecordTime += timeDiff ; \nif ( isStartRecord ) { \nwalCountersHolder . startRecordCount = walCountersHolder . startRecordCount + 1 ; \nwalCountersHolder . startRecordTime += timeDiff ; \n} \nelse if ( isStopRecord ) { \nwalCountersHolder . stopRecordCount = walCountersHolder . stopRecordCount + 1 ; \nwalCountersHolder . stopRecordTime += timeDiff ; \n} \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3062": "public class OSessionStoragePerformanceStatistic { \npublic void stopWALFlushTimer ( ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( walCountersHolder == null ) walCountersHolder = new WALCountersHolder ( ) ; \nwalCountersHolder . flushCount = walCountersHolder . flushCount + 1 ; \nwalCountersHolder . flushTime += timeDiff ; \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3147": "public class ODistributedResponseManagerImpl { \nprotected List < ODistributedResponse > getConflictResponses ( ) { \nfinal List < ODistributedResponse > servers = new ArrayList < ODistributedResponse > ( ) ; \nint bestGroupSoFar = getBestResponsesGroup ( ) ; \nfor ( int i = 0 ; \ni < responseGroups . size ( ) ; \ni = i + 1 ) { \nif ( i != bestGroupSoFar ) { \nfor ( ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; \n} \n} \nreturn servers ; \n} \n} \n"}
{"3148": "public class ODistributedResponseManagerImpl { \nprotected int getBestResponsesGroup ( ) { \nint maxCoherentResponses = 0 ; \nint bestGroupSoFar = 0 ; \nfor ( int i = 0 ; \ni < responseGroups . size ( ) ; \ni = i + 1 ) { \nfinal int currentGroupSize = responseGroups . get ( i ) . size ( ) ; \nif ( currentGroupSize > maxCoherentResponses ) { \nmaxCoherentResponses = currentGroupSize ; \nbestGroupSoFar = i ; \n} \n} \nreturn bestGroupSoFar ; \n} \n} \n"}
{"3149": "public class ODistributedResponseManagerImpl { \nprivate boolean computeQuorumResponse ( boolean reachedTimeout ) { \nif ( quorumResponse != null ) return true ; \nif ( groupResponsesByResult ) { \nfor ( List < ODistributedResponse > group : responseGroups ) { \nif ( group . size ( ) >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( ODistributedResponse r : group ) { \nif ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { \nfinal Object payload = r . getPayload ( ) ; \nif ( payload instanceof Throwable ) { \nif ( payload instanceof ODistributedRecordLockedException ) break ; \nif ( payload instanceof OConcurrentCreateException ) break ; \n} \nelse if ( responsesForQuorum = responsesForQuorum + 1 >= quorum ) { \nsetQuorumResponse ( r ) ; \nreturn true ; \n} \n} \n} \n} \n} \n} \nelse { \nif ( receivedResponses >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { \nif ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && responsesForQuorum = responsesForQuorum + 1 >= quorum ) { \nODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; \nif ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; \nreturn true ; \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3158": "public class OOrderByOptimizer { \nboolean canBeUsedByOrderByAfterFilter ( OIndex < ? > index , List < String > equalsFilterFields , List < OPair < String , String > > orderedFields ) { \nif ( orderedFields . isEmpty ( ) ) return false ; \nif ( ! index . supportsOrderedIterations ( ) ) return false ; \nfinal OIndexDefinition definition = index . getDefinition ( ) ; \nfinal List < String > indexFields = definition . getFields ( ) ; \nint endIndex = Math . min ( indexFields . size ( ) , equalsFilterFields . size ( ) ) ; \nfinal String firstOrder = orderedFields . get ( 0 ) . getValue ( ) ; \nfor ( int i = 0 ; \ni < endIndex ; \ni = i + 1 ) { \nfinal String equalsFieldName = equalsFilterFields . get ( i ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! equalsFieldName . equals ( indexFieldName ) ) return false ; \n} \nendIndex = Math . min ( indexFields . size ( ) , orderedFields . size ( ) + equalsFilterFields . size ( ) ) ; \nif ( endIndex == equalsFilterFields . size ( ) ) { \nreturn false ; \n} \nfor ( int i = equalsFilterFields . size ( ) ; \ni < endIndex ; \ni = i + 1 ) { \nint fieldOrderInOrderByClause = i - equalsFilterFields . size ( ) ; \nfinal OPair < String , String > pair = orderedFields . get ( fieldOrderInOrderByClause ) ; \nif ( ! firstOrder . equals ( pair . getValue ( ) ) ) return false ; \nfinal String orderFieldName = pair . getKey ( ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! orderFieldName . equals ( indexFieldName ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3159": "public class OStringParser { \npublic static int indexOfOutsideStrings ( final String iText , final char iToFind , int iFrom , int iTo ) { \nif ( iTo == - 1 ) iTo = iText . length ( ) - 1 ; \nif ( iFrom == - 1 ) iFrom = iText . length ( ) - 1 ; \nchar c ; \nchar stringChar = ' ' ; \nboolean escape = false ; \nfinal StringBuilder buffer = new StringBuilder ( 1024 ) ; \nint i = iFrom ; \nwhile ( true ) { \nc = iText . charAt ( i ) ; \nif ( ! escape && c == '\\\\' && ( ( i + 1 ) < iText . length ( ) ) ) { \nif ( iText . charAt ( i + 1 ) == 'u' ) { \ni = readUnicode ( iText , i + 2 , buffer ) ; \n} \nelse escape = true ; \n} \nelse { \nif ( c == '\\'' || c == '\"' ) { \nif ( stringChar == ' ' ) { \nstringChar = c ; \n} \nelse { \nif ( ! escape && c == stringChar ) stringChar = ' ' ; \n} \n} \nif ( c == iToFind && stringChar == ' ' ) return i ; \nif ( escape ) escape = false ; \n} \nif ( iFrom < iTo ) { \nif ( i = i + 1 > iTo ) break ; \n} \nelse { \nif ( i = i - 1 < iFrom ) break ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3161": "public class OStringParser { \npublic static int jump ( final CharSequence iText , int iCurrentPosition , final int iMaxPosition , final String iJumpChars ) { \nif ( iCurrentPosition < 0 ) return - 1 ; \nfinal int size = iMaxPosition > - 1 ? Math . min ( iMaxPosition , iText . length ( ) ) : iText . length ( ) ; \nfinal int jumpCharSize = iJumpChars . length ( ) ; \nboolean found = true ; \nchar c ; \nfor ( ; \niCurrentPosition < size ; \niCurrentPosition = iCurrentPosition + 1 ) { \nfound = false ; \nc = iText . charAt ( iCurrentPosition ) ; \nfor ( int jumpIndex = 0 ; \njumpIndex < jumpCharSize ; \njumpIndex = jumpIndex + 1 ) { \nif ( iJumpChars . charAt ( jumpIndex ) == c ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) break ; \n} \nreturn iCurrentPosition >= size ? - 1 : iCurrentPosition ; \n} \n} \n"}
{"3197": "public class OIdentifiableIterator { \nprotected ORecord readCurrentRecord ( ORecord iRecord , final int iMovement ) { \nif ( limit > - 1 && browsedRecords >= limit ) return null ; \ndo { \nfinal boolean moveResult ; \nswitch ( iMovement ) { \ncase 1 : moveResult = nextPosition ( ) ; \nbreak ; \ncase - 1 : moveResult = prevPosition ( ) ; \nbreak ; \ncase 0 : moveResult = checkCurrentPosition ( ) ; \nbreak ; \ndefault : throw new IllegalStateException ( \"Invalid movement value : \" + iMovement ) ; \n} \nif ( ! moveResult ) return null ; \ntry { \nif ( iRecord != null ) { \nORecordInternal . setIdentity ( iRecord , new ORecordId ( current . getClusterId ( ) , current . getClusterPosition ( ) ) ) ; \niRecord = database . load ( iRecord , fetchPlan , false ) ; \n} \nelse iRecord = database . load ( current , fetchPlan , false ) ; \n} \ncatch ( ODatabaseException e ) { \nif ( Thread . interrupted ( ) || database . isClosed ( ) ) throw e ; \nif ( e . getCause ( ) instanceof OSecurityException ) throw e ; \nbrokenRIDs . add ( current . copy ( ) ) ; \nOLogManager . instance ( ) . error ( this , \"Error on fetching record during browsing. The record has been skipped\" , e ) ; \n} \nif ( iRecord != null ) { \nbrowsedRecords = browsedRecords + 1 ; \nreturn iRecord ; \n} \n} \nwhile ( iMovement != 0 ) ; \nreturn null ; \n} \n} \n"}
{"3204": "public class OrientSql { \nfinal public Token getNextToken ( ) { \nif ( token . next != null ) token = token . next ; \nelse token = token . next = token_source . getNextToken ( ) ; \njj_ntk = - 1 ; \njj_gen = jj_gen + 1 ; \nreturn token ; \n} \n} \n"}
{"3205": "public class OrientSql { \nfinal public Token getToken ( int index ) { \nToken t = token ; \nfor ( int i = 0 ; \ni < index ; \ni = i + 1 ) { \nif ( t . next != null ) t = t . next ; \nelse t = t . next = token_source . getNextToken ( ) ; \n} \nreturn t ; \n} \n} \n"}
{"3206": "public class OrientSql { \npublic ParseException generateParseException ( ) { \njj_expentries . clear ( ) ; \nboolean [ ] la1tokens = new boolean [ 279 ] ; \nif ( jj_kind >= 0 ) { \nla1tokens [ jj_kind ] = true ; \njj_kind = - 1 ; \n} \nfor ( int i = 0 ; \ni < 424 ; \ni = i + 1 ) { \nif ( jj_la1 [ i ] == jj_gen ) { \nfor ( int j = 0 ; \nj < 32 ; \nj = j + 1 ) { \nif ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ j ] = true ; \n} \nif ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 32 + j ] = true ; \n} \nif ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 64 + j ] = true ; \n} \nif ( ( jj_la1_3 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 96 + j ] = true ; \n} \nif ( ( jj_la1_4 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 128 + j ] = true ; \n} \nif ( ( jj_la1_5 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 160 + j ] = true ; \n} \nif ( ( jj_la1_6 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 192 + j ] = true ; \n} \nif ( ( jj_la1_7 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 224 + j ] = true ; \n} \nif ( ( jj_la1_8 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 256 + j ] = true ; \n} \n} \n} \n} \nfor ( int i = 0 ; \ni < 279 ; \ni = i + 1 ) { \nif ( la1tokens [ i ] ) { \njj_expentry = new int [ 1 ] ; \njj_expentry [ 0 ] = i ; \njj_expentries . add ( jj_expentry ) ; \n} \n} \njj_endpos = 0 ; \njj_rescan_token ( ) ; \njj_add_error_token ( 0 , 0 ) ; \nint [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; \nfor ( int i = 0 ; \ni < jj_expentries . size ( ) ; \ni = i + 1 ) { \nexptokseq [ i ] = jj_expentries . get ( i ) ; \n} \nreturn new ParseException ( token , exptokseq , tokenImage ) ; \n} \n} \n"}
{"3238": "public class JavaCharStream { \npublic void adjustBeginLineColumn ( int newLine , int newCol ) { \nint start = tokenBegin ; \nint len ; \nif ( bufpos >= tokenBegin ) { \nlen = bufpos - tokenBegin + inBuf + 1 ; \n} \nelse { \nlen = bufsize - tokenBegin + bufpos + 1 + inBuf ; \n} \nint i = 0 , j = 0 , k = 0 ; \nint nextColDiff = 0 , columnDiff = 0 ; \nwhile ( i < len && bufline [ j = start % bufsize ] == bufline [ k = start = start + 1 % bufsize ] ) { \nbufline [ j ] = newLine ; \nnextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; \nbufcolumn [ j ] = newCol + columnDiff ; \ncolumnDiff = nextColDiff ; \ni = i + 1 ; \n} \nif ( i < len ) { \nbufline [ j ] = newLine = newLine + 1 ; \nbufcolumn [ j ] = newCol + columnDiff ; \nwhile ( i = i + 1 < len ) { \nif ( bufline [ j = start % bufsize ] != bufline [ start = start + 1 % bufsize ] ) bufline [ j ] = newLine = newLine + 1 ; \nelse bufline [ j ] = newLine ; \n} \n} \nline = bufline [ j ] ; \ncolumn = bufcolumn [ j ] ; \n} \n} \n"}
{"3251": "public class OClosableLinkedContainer { \npublic void clear ( ) { \nlruLock . lock ( ) ; \ntry { \ndata . clear ( ) ; \nopenFiles . set ( 0 ) ; \nfor ( int n = 0 ; \nn < NUMBER_OF_READ_BUFFERS ; \nn = n + 1 ) { \nfinal AtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nfor ( int i = 0 ; \ni < READ_BUFFER_SIZE ; \ni = i + 1 ) { \nbuffer [ i ] . set ( null ) ; \n} \nreadBufferReadCount [ n ] = 0 ; \nreadBufferWriteCount [ n ] . set ( 0 ) ; \nreadBufferDrainAtWriteCount [ n ] . set ( 0 ) ; \n} \nstateBuffer . clear ( ) ; \nwhile ( lruList . poll ( ) != null ) ; \n} \nfinally { \nlruLock . unlock ( ) ; \n} \n} \n} \n"}
{"3253": "public class OClosableLinkedContainer { \nprivate void emptyReadBuffers ( ) { \nfor ( int n = 0 ; \nn < NUMBER_OF_READ_BUFFERS ; \nn = n + 1 ) { \nAtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nlong writeCount = readBufferDrainAtWriteCount [ n ] . get ( ) ; \nlong counter = readBufferReadCount [ n ] ; \nwhile ( true ) { \nfinal int bufferIndex = ( int ) ( counter & READ_BUFFER_INDEX_MASK ) ; \nfinal AtomicReference < OClosableEntry < K , V > > eref = buffer [ bufferIndex ] ; \nfinal OClosableEntry < K , V > entry = eref . get ( ) ; \nif ( entry == null ) break ; \napplyRead ( entry ) ; \ncounter = counter + 1 ; \neref . lazySet ( null ) ; \n} \nreadBufferReadCount [ n ] = counter ; \nreadBufferDrainAtWriteCount [ n ] . lazySet ( writeCount ) ; \n} \n} \n} \n"}
{"3276": "public class OGraphBatchInsertBasic { \npublic void end ( ) { \nfinal OClass vClass = db . getMetadata ( ) . getSchema ( ) . getClass ( vertexClass ) ; \ntry { \nrunningThreads = new AtomicInteger ( parallel ) ; \nfor ( int i = 0 ; \ni < parallel - 1 ; \ni = i + 1 ) { \nThread t = new BatchImporterJob ( i , vClass ) ; \nt . start ( ) ; \n} \nThread t = new BatchImporterJob ( parallel - 1 , vClass ) ; \nt . run ( ) ; \nif ( runningThreads . get ( ) > 0 ) { \nsynchronized ( runningThreads ) { \nwhile ( runningThreads . get ( ) > 0 ) { \ntry { \nrunningThreads . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \n} \n} \n} \n} \n} \nfinally { \ndb . activateOnCurrentThread ( ) ; \ndb . declareIntent ( null ) ; \ndb . close ( ) ; \nif ( walActive ) OGlobalConfiguration . USE_WAL . setValue ( true ) ; \n} \n} \n} \n"}
{"3279": "public class ORecordSerializerBinaryV0 { \nprivate List < RecordInfo > getPositionsFromEmbeddedCollection ( final BytesContainer bytes , int serializerVersion ) { \nList < RecordInfo > retList = new ArrayList < > ( ) ; \nint numberOfElements = OVarIntSerializer . readAsInteger ( bytes ) ; \nreadByte ( bytes ) ; \nfor ( int i = 0 ; \ni < numberOfElements ; \ni = i + 1 ) { \nOType dataType = readOType ( bytes , false ) ; \nint fieldStart = bytes . offset ; \nRecordInfo fieldInfo = new RecordInfo ( ) ; \nfieldInfo . fieldStartOffset = fieldStart ; \nfieldInfo . fieldType = dataType ; \ndeserializeValue ( bytes , dataType , null , true , - 1 , serializerVersion , true ) ; \nfieldInfo . fieldLength = bytes . offset - fieldStart ; \nretList . add ( fieldInfo ) ; \n} \nreturn retList ; \n} \n} \n"}
{"3285": "public class ODistributedWorker { \npublic void initDatabaseInstance ( ) { \nif ( database == null ) { \nfor ( int retry = 0 ; \nretry < 100 ; \nretry = retry + 1 ) { \ntry { \ndatabase = distributed . getDatabaseInstance ( ) ; \nbreak ; \n} \ncatch ( OStorageException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \ncatch ( OConfigurationException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \n} \nif ( database == null ) { \nODistributedServerLog . info ( this , manager . getLocalNodeName ( ) , null , DIRECTION . NONE , \"Database '%s' not present, shutting down database manager\" , databaseName ) ; \ndistributed . shutdown ( ) ; \nthrow new ODistributedException ( \"Cannot open database '\" + databaseName + \"'\" ) ; \n} \n} \nelse if ( database . isClosed ( ) ) { \ndatabase . activateOnCurrentThread ( ) ; \ndatabase . close ( ) ; \ndatabase = distributed . getDatabaseInstance ( ) ; \n} \n} \n} \n"}
{"3298": "public class OClassImpl { \nprotected void addPolymorphicClusterIds ( final OClassImpl iBaseClass ) { \nSet < Integer > clusters = new TreeSet < Integer > ( ) ; \nfor ( int clusterId : polymorphicClusterIds ) { \nclusters . add ( clusterId ) ; \n} \nfor ( int clusterId : iBaseClass . polymorphicClusterIds ) { \nif ( clusters . add ( clusterId ) ) { \ntry { \naddClusterIdToIndexes ( clusterId ) ; \n} \ncatch ( RuntimeException e ) { \nOLogManager . instance ( ) . warn ( this , \"Error adding clusterId '%d' to index of class '%s'\" , e , clusterId , getName ( ) ) ; \nclusters . remove ( clusterId ) ; \n} \n} \n} \npolymorphicClusterIds = new int [ clusters . size ( ) ] ; \nint i = 0 ; \nfor ( Integer cluster : clusters ) { \npolymorphicClusterIds [ i ] = cluster ; \ni = i + 1 ; \n} \n} \n} \n"}
{"3307": "public class OCollections { \npublic static int indexOf ( final Object [ ] array , final Comparable object ) { \nfor ( int i = 0 ; \ni < array . length ; \ni = i + 1 ) { \nif ( object . compareTo ( array [ i ] ) == 0 ) return i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"3308": "public class OCollections { \npublic static int indexOf ( final int [ ] array , final int object ) { \nfor ( int i = 0 ; \ni < array . length ; \ni = i + 1 ) { \nif ( array [ i ] == object ) return i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"3310": "public class OCommandExecutorSQLSelect { \n@ Override protected boolean handleResult ( final OIdentifiable iRecord , final OCommandContext iContext ) { \nlastRecord = iRecord ; \nif ( ( orderedFields . isEmpty ( ) || fullySortedByIndex || isRidOnlySort ( ) ) && skip > 0 && this . unwindFields == null && this . expandTarget == null ) { \nlastRecord = null ; \nskip = skip - 1 ; \nreturn true ; \n} \nif ( ! addResult ( lastRecord , iContext ) ) { \nreturn false ; \n} \nreturn continueSearching ( ) ; \n} \n} \n"}
{"3333": "public class OrientBlob { \nprivate int getRelativeIndex ( long pos ) { \nint currentSize = 0 ; \ncurrentChunkIndex = 0 ; \nwhile ( pos >= ( currentSize += binaryDataChunks . get ( currentChunkIndex ) . length ) ) currentChunkIndex = currentChunkIndex + 1 ; \ncurrentChunk = binaryDataChunks . get ( currentChunkIndex ) ; \ncurrentSize -= currentChunk . length ; \nint relativePosition = ( int ) ( pos - currentSize ) ; \nreturn relativePosition - 1 ; \n} \n} \n"}
{"3336": "public class OBaseParser { \nprotected int parserNextChars ( final boolean iUpperCase , final boolean iMandatory , final String ... iCandidateWords ) { \nparserPreviousPos = parserCurrentPos ; \nparserSkipWhiteSpaces ( ) ; \nparserEscapeSequenceCount = 0 ; \nparserLastWord . setLength ( 0 ) ; \nfinal String [ ] processedWords = Arrays . copyOf ( iCandidateWords , iCandidateWords . length ) ; \nfinal String text2Use = iUpperCase ? parserTextUpperCase : parserText ; \nfinal int max = text2Use . length ( ) ; \nparserCurrentPos = parserCurrentPos + parserTextUpperCase . length ( ) - parserText . length ( ) ; \nfor ( int i = 0 ; \nparserCurrentPos <= max ; \ni = i + 1 ) { \nfinal char ch = parserCurrentPos < max ? text2Use . charAt ( parserCurrentPos ) : '\\n' ; \nfinal boolean separator = ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t' || ch == '(' ; \nif ( ! separator ) parserLastWord . append ( ch ) ; \nint candidatesWordsCount = 0 ; \nint candidatesWordsPos = - 1 ; \nfor ( int c = 0 ; \nc < processedWords . length ; \nc = c + 1 ) { \nfinal String w = processedWords [ c ] ; \nif ( w != null ) { \nfinal int wordSize = w . length ( ) ; \nif ( ( separator && wordSize > i ) || ( ! separator && ( i > wordSize - 1 || w . charAt ( i ) != ch ) ) ) processedWords [ c ] = null ; \nelse { \ncandidatesWordsCount = candidatesWordsCount + 1 ; \nif ( candidatesWordsCount == 1 ) candidatesWordsPos = c ; \n} \n} \n} \nif ( candidatesWordsCount == 1 ) { \nfinal String w = processedWords [ candidatesWordsPos ] ; \nif ( w . length ( ) == i + ( separator ? 0 : 1 ) && ! Character . isLetter ( ch ) ) return candidatesWordsPos ; \n} \nif ( candidatesWordsCount == 0 || separator ) break ; \nparserCurrentPos = parserCurrentPos + 1 ; \n} \nif ( iMandatory ) throwSyntaxErrorException ( \"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\" + Arrays . toString ( iCandidateWords ) + \"'\" ) ; \nreturn - 1 ; \n} \n} \n"}
{"3338": "public class OBaseParser { \nprivate boolean parserCheckSeparator ( final char c , final String iSeparatorChars ) { \nfor ( int sepIndex = 0 ; \nsepIndex < iSeparatorChars . length ( ) ; \nsepIndex = sepIndex + 1 ) { \nif ( iSeparatorChars . charAt ( sepIndex ) == c ) { \nparserLastSeparator = c ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3347": "public class FastBufferedInputStream { \npublic int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { \nByteArrays . ensureOffsetLength ( array , off , len ) ; \nif ( len == 0 ) return 0 ; \nif ( noMoreCharacters ( ) ) return - 1 ; \nint i , k = 0 , remaining = len , read = 0 ; \nfor ( ; \n; \n) { \nfor ( i = 0 ; \ni < avail && i < remaining && ( k = buffer [ pos + i ] ) != '\\n' && k != '\\r' ; \ni = i + 1 ) ; \nSystem . arraycopy ( buffer , pos , array , off + read , i ) ; \npos += i ; \navail -= i ; \nread += i ; \nremaining -= i ; \nif ( remaining == 0 ) { \nreadBytes += read ; \nreturn read ; \n} \nif ( avail > 0 ) { \nif ( k == '\\n' ) { \npos = pos + 1 ; \navail = avail - 1 ; \nif ( terminators . contains ( LineTerminator . LF ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \nelse { \narray [ off + read = read + 1 ] = '\\n' ; \nremaining = remaining - 1 ; \n} \n} \nelse if ( k == '\\r' ) { \npos = pos + 1 ; \navail = avail - 1 ; \nif ( terminators . contains ( LineTerminator . CR_LF ) ) { \nif ( avail > 0 ) { \nif ( buffer [ pos ] == '\\n' ) { \npos = pos + 1 ; \navail = avail - 1 ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \nelse { \nif ( noMoreCharacters ( ) ) { \nif ( ! terminators . contains ( LineTerminator . CR ) ) { \narray [ off + read = read + 1 ] = '\\r' ; \nremaining = remaining - 1 ; \nreadBytes += read ; \n} \nelse readBytes += read + 1 ; \nreturn read ; \n} \nif ( buffer [ 0 ] == '\\n' ) { \npos = pos + 1 ; \navail = avail - 1 ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \n} \nif ( terminators . contains ( LineTerminator . CR ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \narray [ off + read = read + 1 ] = '\\r' ; \nremaining = remaining - 1 ; \n} \n} \nelse if ( noMoreCharacters ( ) ) { \nreadBytes += read ; \nreturn read ; \n} \n} \n} \n} \n"}
{"3349": "public class FastBufferedInputStream { \n@ Override public long skip ( final long n ) throws IOException { \nif ( n <= avail ) { \nfinal int m = ( int ) n ; \npos += m ; \navail -= m ; \nreadBytes += n ; \nreturn n ; \n} \nlong toSkip = n - avail , result = 0 ; \navail = 0 ; \nwhile ( toSkip != 0 && ( result = is == System . in ? skipByReading ( toSkip ) : is . skip ( toSkip ) ) < toSkip ) { \nif ( result == 0 ) { \nif ( is . read ( ) == - 1 ) break ; \ntoSkip = toSkip - 1 ; \n} \nelse toSkip -= result ; \n} \nfinal long t = n - ( toSkip - result ) ; \nreadBytes += t ; \nreturn t ; \n} \n} \n"}
{"3351": "public class Arrays { \npublic static void mergeSort ( final int from , final int to , final IntComparator c , final Swapper swapper ) { \nfinal int length = to - from ; \nif ( length < MERGESORT_NO_REC ) { \nfor ( int i = from ; \ni < to ; \ni = i + 1 ) { \nfor ( int j = i ; \nj > from && ( c . compare ( j - 1 , j ) > 0 ) ; \nj = j - 1 ) { \nswapper . swap ( j , j - 1 ) ; \n} \n} \nreturn ; \n} \nint mid = ( from + to ) >>> 1 ; \nmergeSort ( from , mid , c , swapper ) ; \nmergeSort ( mid , to , c , swapper ) ; \nif ( c . compare ( mid - 1 , mid ) <= 0 ) return ; \ninPlaceMerge ( from , mid , to , c , swapper ) ; \n} \n} \n"}
{"3352": "public class Arrays { \nprotected static void swap ( final Swapper swapper , int a , int b , final int n ) { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 , a = a + 1 , b = b + 1 ) swapper . swap ( a , b ) ; \n} \n} \n"}
{"3363": "public class HollowFilesystemBlobStorageCleaner { \n@ Override public void cleanSnapshots ( ) { \nFile [ ] files = getFilesByType ( HollowProducer . Blob . Type . SNAPSHOT . prefix ) ; \nif ( files == null || files . length <= numOfSnapshotsToKeep ) { \nreturn ; \n} \nsortByLastModified ( files ) ; \nfor ( int i = numOfSnapshotsToKeep ; \ni < files . length ; \ni = i + 1 ) { \nFile file = files [ i ] ; \nboolean deleted = file . delete ( ) ; \nif ( ! deleted ) { \nlog . warning ( \"Could not delete snapshot \" + file . getPath ( ) ) ; \n} \n} \n} \n} \n"}
{"3368": "public class AbstractProducerMetricsListener { \n@ Override public void onCycleComplete ( com . netflix . hollow . api . producer . Status status , HollowProducer . ReadState readState , long version , Duration elapsed ) { \nboolean isCycleSuccess ; \nlong cycleEndTimeNano = System . nanoTime ( ) ; \nif ( status . getType ( ) == com . netflix . hollow . api . producer . Status . StatusType . SUCCESS ) { \nisCycleSuccess = true ; \nconsecutiveFailures = 0l ; \nlastCycleSuccessTimeNanoOptional = OptionalLong . of ( cycleEndTimeNano ) ; \n} \nelse { \nisCycleSuccess = false ; \nconsecutiveFailures = consecutiveFailures + 1 ; \n} \ncycleMetricsBuilder . setConsecutiveFailures ( consecutiveFailures ) . setCycleDurationMillis ( elapsed . toMillis ( ) ) . setIsCycleSuccess ( isCycleSuccess ) ; \nlastCycleSuccessTimeNanoOptional . ifPresent ( cycleMetricsBuilder :: setLastCycleSuccessTimeNano ) ; \ncycleMetricsReporting ( cycleMetricsBuilder . build ( ) ) ; \n} \n} \n"}
{"3369": "public class HollowBlobHeaderReader { \nprivate Map < String , String > readHeaderTags ( DataInputStream dis ) throws IOException { \nint numHeaderTags = dis . readShort ( ) ; \nMap < String , String > headerTags = new HashMap < String , String > ( ) ; \nfor ( int i = 0 ; \ni < numHeaderTags ; \ni = i + 1 ) { \nheaderTags . put ( dis . readUTF ( ) , dis . readUTF ( ) ) ; \n} \nreturn headerTags ; \n} \n} \n"}
{"3371": "public class ThreadSafeBitSet { \npublic void clearAll ( ) { \nThreadSafeBitSetSegments segments = this . segments . get ( ) ; \nfor ( int i = 0 ; \ni < segments . numSegments ( ) ; \ni = i + 1 ) { \nAtomicLongArray segment = segments . getSegment ( i ) ; \nfor ( int j = 0 ; \nj < segment . length ( ) ; \nj = j + 1 ) { \nsegment . set ( j , 0L ) ; \n} \n} \n} \n} \n"}
{"3372": "public class SnapshotPopulatedOrdinalsReader { \npublic static void readOrdinals ( DataInputStream dis , HollowTypeStateListener [ ] listeners ) throws IOException { \nint numLongs = dis . readInt ( ) ; \nint currentOrdinal = 0 ; \nfor ( int i = 0 ; \ni < numLongs ; \ni = i + 1 ) { \nlong l = dis . readLong ( ) ; \nnotifyPopulatedOrdinals ( l , currentOrdinal , listeners ) ; \ncurrentOrdinal += 64 ; \n} \n} \n} \n"}
{"3375": "public class SegmentedByteArray { \npublic void copy ( ByteData src , long srcPos , long destPos , long length ) { \nfor ( long i = 0 ; \ni < length ; \ni = i + 1 ) { \nset ( destPos = destPos + 1 , src . get ( srcPos = srcPos + 1 ) ) ; \n} \n} \n} \n"}
{"3377": "public class SegmentedByteArray { \npublic boolean rangeEquals ( long rangeStart , SegmentedByteArray compareTo , long cmpStart , int length ) { \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) if ( get ( rangeStart + i ) != compareTo . get ( cmpStart + i ) ) return false ; \nreturn true ; \n} \n} \n"}
{"3378": "public class SegmentedByteArray { \npublic void orderedCopy ( SegmentedByteArray src , long srcPos , long destPos , long length ) { \nint segmentLength = 1 << log2OfSegmentSize ; \nint currentSegment = ( int ) ( destPos >>> log2OfSegmentSize ) ; \nint segmentStartPos = ( int ) ( destPos & bitmask ) ; \nint remainingBytesInSegment = segmentLength - segmentStartPos ; \nwhile ( length > 0 ) { \nint bytesToCopyFromSegment = ( int ) Math . min ( remainingBytesInSegment , length ) ; \nensureCapacity ( currentSegment ) ; \nint copiedBytes = src . orderedCopy ( srcPos , segments [ currentSegment ] , segmentStartPos , bytesToCopyFromSegment ) ; \nsrcPos += copiedBytes ; \nlength -= copiedBytes ; \nsegmentStartPos = 0 ; \nremainingBytesInSegment = segmentLength ; \ncurrentSegment = currentSegment + 1 ; \n} \n} \n} \n"}
{"3380": "public class SegmentedByteArray { \npublic void readFrom ( InputStream is , long length ) throws IOException { \nint segmentSize = 1 << log2OfSegmentSize ; \nint segment = 0 ; \nbyte scratch [ ] = new byte [ segmentSize ] ; \nwhile ( length > 0 ) { \nensureCapacity ( segment ) ; \nlong bytesToCopy = Math . min ( segmentSize , length ) ; \nlong bytesCopied = 0 ; \nwhile ( bytesCopied < bytesToCopy ) { \nbytesCopied += is . read ( scratch , ( int ) bytesCopied , ( int ) ( bytesToCopy - bytesCopied ) ) ; \n} \norderedCopy ( scratch , 0 , segments [ segment = segment + 1 ] , 0 , ( int ) bytesCopied ) ; \nlength -= bytesCopied ; \n} \n} \n} \n"}
{"3384": "public class HollowHashIndexBuilder { \nprivate long calculateDedupedSizesAndTotalNumberOfSelectBuckets ( MultiLinkedElementArray elementArray , GrowingSegmentedLongArray matchIndexHashAndSizeArray ) { \nlong totalBuckets = 0 ; \nlong maxSize = 0 ; \nint [ ] selectArray = new int [ 8 ] ; \nfor ( int i = 0 ; \ni < elementArray . numLists ( ) ; \ni = i + 1 ) { \nint listSize = elementArray . listSize ( i ) ; \nint setSize = 0 ; \nint predictedBuckets = HashCodes . hashTableSize ( listSize ) ; \nint hashMask = predictedBuckets - 1 ; \nif ( predictedBuckets > selectArray . length ) selectArray = new int [ predictedBuckets ] ; \nfor ( int j = 0 ; \nj < predictedBuckets ; \nj = j + 1 ) selectArray [ j ] = - 1 ; \nHollowOrdinalIterator iter = elementArray . iterator ( i ) ; \nint selectOrdinal = iter . next ( ) ; \nwhile ( selectOrdinal != HollowOrdinalIterator . NO_MORE_ORDINALS ) { \nint hash = HashCodes . hashInt ( selectOrdinal ) ; \nint bucket = hash & hashMask ; \nwhile ( true ) { \nif ( selectArray [ bucket ] == selectOrdinal ) break ; \nif ( selectArray [ bucket ] == - 1 ) { \nselectArray [ bucket ] = selectOrdinal ; \nsetSize = setSize + 1 ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashMask ; \n} \nselectOrdinal = iter . next ( ) ; \n} \nlong matchIndexHashAndSize = matchIndexHashAndSizeArray . get ( i ) ; \nmatchIndexHashAndSize |= ( long ) setSize << 32 ; \nmatchIndexHashAndSizeArray . set ( i , matchIndexHashAndSize ) ; \ntotalBuckets += HashCodes . hashTableSize ( setSize ) ; \nif ( setSize > maxSize ) maxSize = setSize ; \n} \nreturn totalBuckets | ( long ) bitsRequiredToRepresentValue ( maxSize ) << 56 ; \n} \n} \n"}
{"3388": "public class HollowPrimaryKeyValueDeriver { \npublic boolean keyMatches ( int ordinal , Object ... keys ) { \nif ( keys . length != fieldPathIndexes . length ) return false ; \nfor ( int i = 0 ; \ni < keys . length ; \ni = i + 1 ) { \nif ( ! keyMatches ( keys [ i ] , ordinal , i ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3389": "public class HollowPrimaryKeyValueDeriver { \npublic Object [ ] getRecordKey ( int ordinal ) { \nObject [ ] results = new Object [ fieldPathIndexes . length ] ; \nfor ( int i = 0 ; \ni < fieldPathIndexes . length ; \ni = i + 1 ) { \nresults [ i ] = readValue ( ordinal , i ) ; \n} \nreturn results ; \n} \n} \n"}
{"3404": "public class HollowSpecificDiff { \npublic void setElementKeyPaths ( String ... paths ) { \nresetResults ( ) ; \nelementKeyPaths = new BitSet ( elementPaths . length ) ; \nfor ( int i = 0 ; \ni < paths . length ; \ni = i + 1 ) { \nint elementPathIdx = getElementPathIdx ( paths [ i ] ) ; \nif ( elementPathIdx == - 1 ) throw new IllegalArgumentException ( \"Key path must have been specified as an element match path.  Offending path: \" + paths [ i ] ) ; \nelementKeyPaths . set ( elementPathIdx ) ; \n} \nelementNonKeyPaths = new BitSet ( elementPaths . length ) ; \nelementNonKeyPaths . set ( 0 , elementPaths . length ) ; \nelementNonKeyPaths . andNot ( elementKeyPaths ) ; \n} \n} \n"}
{"3405": "public class HollowSpecificDiff { \npublic void calculate ( ) { \nresetResults ( ) ; \nSimultaneousExecutor executor = new SimultaneousExecutor ( getClass ( ) , \"calculate\" ) ; \nfinal int numThreads = executor . getCorePoolSize ( ) ; \nfor ( int i = 0 ; \ni < numThreads ; \ni = i + 1 ) { \nfinal int threadNumber = i ; \nexecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \nHollowIndexerValueTraverser fromTraverser = new HollowIndexerValueTraverser ( from , type , elementPaths ) ; \nHollowIndexerValueTraverser toTraverser = new HollowIndexerValueTraverser ( to , type , elementPaths ) ; \nint hashedResults [ ] = new int [ 16 ] ; \nfor ( int i = threadNumber ; \ni < matcher . getMatchedOrdinals ( ) . size ( ) ; \ni += numThreads ) { \nlong ordinalPair = matcher . getMatchedOrdinals ( ) . get ( i ) ; \nint fromOrdinal = ( int ) ( ordinalPair >>> 32 ) ; \nint toOrdinal = ( int ) ordinalPair ; \nfromTraverser . traverse ( fromOrdinal ) ; \ntoTraverser . traverse ( toOrdinal ) ; \nif ( fromTraverser . getNumMatches ( ) * 2 > hashedResults . length ) hashedResults = new int [ hashTableSize ( fromTraverser . getNumMatches ( ) ) ] ; \npopulateHashTable ( fromTraverser , hashedResults ) ; \ncountMatches ( fromTraverser , toTraverser , hashedResults ) ; \n} \nfor ( int i = threadNumber ; \ni < matcher . getExtraInFrom ( ) . size ( ) ; \ni += numThreads ) { \nfromTraverser . traverse ( matcher . getExtraInFrom ( ) . get ( i ) ) ; \ntotalUnmatchedFromElements . addAndGet ( fromTraverser . getNumMatches ( ) ) ; \n} \nfor ( int i = threadNumber ; \ni < matcher . getExtraInTo ( ) . size ( ) ; \ni += numThreads ) { \ntoTraverser . traverse ( matcher . getExtraInTo ( ) . get ( i ) ) ; \ntotalUnmatchedToElements . addAndGet ( toTraverser . getNumMatches ( ) ) ; \n} \n} \n} \n) ; \n} \ntry { \nexecutor . awaitSuccessfulCompletion ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( ex ) ; \n} \n} \n} \n"}
{"3412": "public class HollowObjectWriteRecord { \npublic void writeDataTo ( ByteDataBuffer buf ) { \nfor ( int i = 0 ; \ni < fieldData . length ; \ni = i + 1 ) { \nwriteField ( buf , i ) ; \n} \n} \n} \n"}
{"3415": "public class FreeOrdinalTracker { \npublic void returnOrdinalToPool ( int ordinal ) { \nif ( size == freeOrdinals . length ) { \nfreeOrdinals = Arrays . copyOf ( freeOrdinals , freeOrdinals . length * 3 / 2 ) ; \n} \nfreeOrdinals [ size ] = ordinal ; \nsize = size + 1 ; \n} \n} \n"}
{"3416": "public class FreeOrdinalTracker { \npublic void sort ( ) { \nArrays . sort ( freeOrdinals , 0 , size ) ; \nint midpoint = size / 2 ; \nfor ( int i = 0 ; \ni < midpoint ; \ni = i + 1 ) { \nint temp = freeOrdinals [ i ] ; \nfreeOrdinals [ i ] = freeOrdinals [ size - i - 1 ] ; \nfreeOrdinals [ size - i - 1 ] = temp ; \n} \n} \n} \n"}
{"3417": "public class SetMapKeyHasher { \npublic static int hash ( Object key [ ] , FieldType fieldType [ ] ) { \nint hash = 0 ; \nfor ( int i = 0 ; \ni < key . length ; \ni = i + 1 ) { \nhash *= 31 ; \nhash ^= hash ( key [ i ] , fieldType [ i ] ) ; \n} \nreturn hash ; \n} \n} \n"}
{"3419": "public class FixedLengthMultipleOccurrenceElementArray { \nprivate void resizeStorage ( ) { \nint currentElementsPerNode = maxElementsPerNode ; \nint newElementsPerNode = ( int ) ( currentElementsPerNode * RESIZE_MULTIPLE ) ; \nif ( newElementsPerNode <= currentElementsPerNode ) { \nthrow new IllegalStateException ( \"cannot resize fixed length array from \" + currentElementsPerNode + \" to \" + newElementsPerNode ) ; \n} \nFixedLengthElementArray newStorage = new FixedLengthElementArray ( memoryRecycler , numNodes * bitsPerElement * newElementsPerNode ) ; \nLongStream . range ( 0 , numNodes ) . forEach ( nodeIndex -> { \nlong currentBucketStart = nodeIndex * currentElementsPerNode * bitsPerElement ; \nlong newBucketStart = nodeIndex * newElementsPerNode * bitsPerElement ; \nfor ( int offset = 0 ; \noffset < currentElementsPerNode ; \noffset = offset + 1 ) { \nlong element = storage . getElementValue ( currentBucketStart + offset * bitsPerElement , bitsPerElement , elementMask ) ; \nif ( element == NO_ELEMENT ) { \nbreak ; \n} \nnewStorage . setElementValue ( newBucketStart + offset * bitsPerElement , bitsPerElement , element ) ; \n} \n} \n) ; \nstorage . destroy ( memoryRecycler ) ; \nstorage = newStorage ; \nmaxElementsPerNode = newElementsPerNode ; \n} \n} \n"}
{"3421": "public class ByteArrayOrdinalMap { \npublic void prepareForWrite ( ) { \nint maxOrdinal = 0 ; \nAtomicLongArray pao = pointersAndOrdinals ; \nfor ( int i = 0 ; \ni < pao . length ( ) ; \ni = i + 1 ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nint ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \nif ( ordinal > maxOrdinal ) { \nmaxOrdinal = ordinal ; \n} \n} \n} \nlong [ ] pbo = new long [ maxOrdinal + 1 ] ; \nArrays . fill ( pbo , - 1 ) ; \nfor ( int i = 0 ; \ni < pao . length ( ) ; \ni = i + 1 ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nint ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \npbo [ ordinal ] = key & POINTER_MASK ; \n} \n} \npointersByOrdinal = pbo ; \n} \n} \n"}
{"3422": "public class ByteArrayOrdinalMap { \nprivate boolean compare ( ByteDataBuffer serializedRepresentation , long key ) { \nlong position = key & POINTER_MASK ; \nint sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; \nif ( sizeOfData != serializedRepresentation . length ( ) ) { \nreturn false ; \n} \nposition += VarInt . sizeOfVInt ( sizeOfData ) ; \nfor ( int i = 0 ; \ni < sizeOfData ; \ni = i + 1 ) { \nif ( serializedRepresentation . get ( i ) != byteData . get ( position = position + 1 ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3425": "public class ByteArrayOrdinalMap { \nprivate AtomicLongArray emptyKeyArray ( int size ) { \nAtomicLongArray arr = new AtomicLongArray ( size ) ; \nfor ( int i = 0 ; \ni < arr . length ( ) ; \ni = i + 1 ) { \narr . lazySet ( i , EMPTY_BUCKET_VALUE ) ; \n} \nreturn arr ; \n} \n} \n"}
{"3426": "public class HollowIndexerValueTraverser { \npublic boolean isMatchEqual ( int matchIdx , HollowIndexerValueTraverser otherTraverser , int otherMatchIdx ) { \nfor ( int i = 0 ; \ni < getNumFieldPaths ( ) ; \ni = i + 1 ) { \nif ( ! HollowReadFieldUtils . fieldsAreEqual ( ( HollowObjectTypeDataAccess ) fieldTypeDataAccess [ i ] , fieldMatchLists [ i ] . get ( matchIdx ) , fieldSchemaPosition [ i ] , ( HollowObjectTypeDataAccess ) otherTraverser . fieldTypeDataAccess [ i ] , otherTraverser . fieldMatchLists [ i ] . get ( otherMatchIdx ) , otherTraverser . fieldSchemaPosition [ i ] ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3434": "public class HollowCodeGenerationUtils { \npublic static String normalizeFieldPathToParamName ( String fieldPath ) { \nString result = null ; \nif ( fieldPath . contains ( \".\" ) ) { \nString [ ] parts = fieldPath . split ( \"\\\\.\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( lowercase ( parts [ 0 ] ) ) ; \nfor ( int i = 1 ; \ni < parts . length ; \ni = i + 1 ) { \nsb . append ( uppercase ( parts [ i ] ) ) ; \n} \nresult = sb . toString ( ) ; \n} \nelse { \nresult = lowercase ( fieldPath ) ; \n} \nif ( result . endsWith ( \"!\" ) ) { \nreturn result . substring ( 0 , result . length ( ) - 1 ) ; \n} \nreturn result ; \n} \n} \n"}
{"3436": "public class HollowHashIndex { \npublic HollowHashIndexResult findMatches ( Object ... query ) { \nint hashCode = 0 ; \nfor ( int i = 0 ; \ni < query . length ; \ni = i + 1 ) { \nif ( query [ i ] == null ) throw new IllegalArgumentException ( \"querying by null unsupported; i=\" + i ) ; \nhashCode ^= HashCodes . hashInt ( keyHashCode ( query [ i ] , i ) ) ; \n} \nHollowHashIndexResult result ; \nHollowHashIndexState hashState ; \ndo { \nresult = null ; \nhashState = hashStateVolatile ; \nlong bucket = hashCode & hashState . getMatchHashMask ( ) ; \nlong hashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nboolean bucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \nwhile ( ! bucketIsEmpty ) { \nif ( matchIsEqual ( hashState . getMatchHashTable ( ) , hashBucketBit , query ) ) { \nint selectSize = ( int ) hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) , hashState . getBitsPerSelectTableSize ( ) ) ; \nlong selectBucketPointer = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) + hashState . getBitsPerSelectTableSize ( ) , hashState . getBitsPerSelectTablePointer ( ) ) ; \nresult = new HollowHashIndexResult ( hashState , selectBucketPointer , selectSize ) ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashState . getMatchHashMask ( ) ; \nhashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nbucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \n} \n} \nwhile ( hashState != hashStateVolatile ) ; \nreturn result ; \n} \n} \n"}
{"3443": "public class VarInt { \npublic static int writeVInt ( byte data [ ] , int pos , int value ) { \nif ( value > 0x0FFFFFFF || value < 0 ) data [ pos = pos + 1 ] = ( ( byte ) ( 0x80 | ( ( value >>> 28 ) ) ) ) ; \nif ( value > 0x1FFFFF || value < 0 ) data [ pos = pos + 1 ] = ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7F ) ) ) ; \nif ( value > 0x3FFF || value < 0 ) data [ pos = pos + 1 ] = ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7F ) ) ) ; \nif ( value > 0x7F || value < 0 ) data [ pos = pos + 1 ] = ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7F ) ) ) ; \ndata [ pos = pos + 1 ] = ( byte ) ( value & 0x7F ) ; \nreturn pos ; \n} \n} \n"}
{"3474": "public class DefaultServiceEnricher { \nprivate Service [ ] toArray ( List < Service > services ) { \nif ( services == null ) { \nreturn new Service [ 0 ] ; \n} \nif ( services instanceof ArrayList ) { \nreturn ( ( ArrayList < Service > ) services ) . toArray ( new Service [ services . size ( ) ] ) ; \n} \nelse { \nService [ ] ret = new Service [ services . size ( ) ] ; \nfor ( int i = 0 ; \ni < services . size ( ) ; \ni = i + 1 ) { \nret [ i ] = services . get ( i ) ; \n} \nreturn ret ; \n} \n} \n} \n"}
{"3490": "public class KubernetesHelper { \npublic static String validateKubernetesId ( String currentValue , String description ) throws IllegalArgumentException { \nif ( StringUtils . isBlank ( currentValue ) ) { \nthrow new IllegalArgumentException ( \"No \" + description + \" is specified!\" ) ; \n} \nint size = currentValue . length ( ) ; \nfor ( int i = 0 ; \ni < size ; \ni = i + 1 ) { \nchar ch = currentValue . charAt ( i ) ; \nif ( Character . isUpperCase ( ch ) ) { \nthrow new IllegalArgumentException ( \"Invalid upper case letter '\" + ch + \"' at index \" + i + \" for \" + description + \" value: \" + currentValue ) ; \n} \n} \nreturn currentValue ; \n} \n} \n"}
{"3508": "public class VersionUtil { \npublic static int compareVersions ( String v1 , String v2 ) { \nString [ ] components1 = split ( v1 ) ; \nString [ ] components2 = split ( v2 ) ; \nint diff ; \nint length = Math . min ( components1 . length , components2 . length ) ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nString s1 = components1 [ i ] ; \nString s2 = components2 [ i ] ; \nInteger i1 = tryParseInteger ( s1 ) ; \nInteger i2 = tryParseInteger ( s2 ) ; \nif ( i1 != null && i2 != null ) { \ndiff = i1 . compareTo ( i2 ) ; \n} \nelse { \ndiff = s1 . compareTo ( s2 ) ; \n} \nif ( diff != 0 ) { \nreturn diff ; \n} \n} \ndiff = Integer . compare ( components1 . length , components2 . length ) ; \nif ( diff == 0 ) { \nif ( v1 == v2 ) { \nreturn 0 ; \n} \n; \nreturn v1 != null ? v1 . compareTo ( v2 ) : - 1 ; \n} \nreturn diff ; \n} \n} \n"}
{"3519": "public class XmlUtils { \npublic static Element firstChild ( Element element , String name ) { \nNodeList nodes = element . getChildNodes ( ) ; \nif ( nodes != null ) { \nfor ( int i = 0 , size = nodes . getLength ( ) ; \ni < size ; \ni = i + 1 ) { \nNode item = nodes . item ( i ) ; \nif ( item instanceof Element ) { \nElement childElement = ( Element ) item ; \nif ( name . equals ( childElement . getTagName ( ) ) ) { \nreturn childElement ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"3531": "public class GoTimeUtil { \npublic static BigDecimal durationNs ( String durationP ) { \nif ( durationP == null ) { \nreturn null ; \n} \nString duration = durationP . trim ( ) ; \nif ( duration . length ( ) == 0 ) { \nreturn null ; \n} \nint unitPos = 1 ; \nwhile ( unitPos < duration . length ( ) && ( Character . isDigit ( duration . charAt ( unitPos ) ) || duration . charAt ( unitPos ) == '.' ) ) { \nunitPos = unitPos + 1 ; \n} \nif ( unitPos >= duration . length ( ) ) { \nthrow new IllegalArgumentException ( \"Time unit not found in string: \" + duration ) ; \n} \nString tail = duration . substring ( unitPos ) ; \nLong multiplier = null ; \nInteger unitEnd = null ; \nfor ( int i = 0 ; \ni < TIME_UNITS . length ; \ni = i + 1 ) { \nif ( tail . startsWith ( TIME_UNITS [ i ] ) ) { \nmultiplier = UNIT_MULTIPLIERS [ i ] ; \nunitEnd = unitPos + TIME_UNITS [ i ] . length ( ) ; \nbreak ; \n} \n} \nif ( multiplier == null ) { \nthrow new IllegalArgumentException ( \"Unknown time unit in string: \" + duration ) ; \n} \nBigDecimal value = new BigDecimal ( duration . substring ( 0 , unitPos ) ) ; \nvalue = value . multiply ( BigDecimal . valueOf ( multiplier ) ) ; \nString remaining = duration . substring ( unitEnd ) ; \nBigDecimal remainingValue = durationNs ( remaining ) ; \nif ( remainingValue != null ) { \nvalue = value . add ( remainingValue ) ; \n} \nreturn value ; \n} \n} \n"}
{"3576": "public class PaymentMethodNonce { \npublic static List < PaymentMethodNonce > parsePaymentMethodNonces ( String jsonBody ) throws JSONException { \nJSONArray paymentMethods = new JSONObject ( jsonBody ) . getJSONArray ( PAYMENT_METHOD_NONCE_COLLECTION_KEY ) ; \nif ( paymentMethods == null ) { \nreturn Collections . emptyList ( ) ; \n} \nList < PaymentMethodNonce > paymentMethodsNonces = new ArrayList < > ( ) ; \nJSONObject json ; \nPaymentMethodNonce paymentMethodNonce ; \nfor ( int i = 0 ; \ni < paymentMethods . length ( ) ; \ni = i + 1 ) { \njson = paymentMethods . getJSONObject ( i ) ; \npaymentMethodNonce = parsePaymentMethodNonces ( json , json . getString ( PAYMENT_METHOD_TYPE_KEY ) ) ; \nif ( paymentMethodNonce != null ) { \npaymentMethodsNonces . add ( paymentMethodNonce ) ; \n} \n} \nreturn paymentMethodsNonces ; \n} \n} \n"}
{"3598": "public class BaseResampler { \npublic static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { \ndouble sum = 0 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni = i + 1 ) { \nsum += taps [ i ] ; \n} \nint sumFix = 0 ; \nint precNum = 1 << precBits ; \nfor ( int i = 0 ; \ni < taps . length ; \ni = i + 1 ) { \ndouble d = ( taps [ i ] * precNum ) / sum + precNum ; \nint s = ( int ) d ; \ntaps [ i ] = d - s ; \nout [ i ] = ( short ) ( s - precNum ) ; \nsumFix += out [ i ] ; \n} \nlong tapsTaken = 0 ; \nwhile ( sumFix < precNum ) { \nint maxI = - 1 ; \nfor ( int i = 0 ; \ni < taps . length ; \ni = i + 1 ) { \nif ( ( tapsTaken & ( 1 << i ) ) == 0 && ( maxI == - 1 || taps [ i ] > taps [ maxI ] ) ) maxI = i ; \n} \nout [ maxI ] = out [ maxI ] + 1 ; \nsumFix = sumFix + 1 ; \ntapsTaken |= ( 1 << maxI ) ; \n} \nfor ( int i = 0 ; \ni < taps . length ; \ni = i + 1 ) { \ntaps [ i ] += out [ i ] ; \nif ( ( tapsTaken & ( 1 << i ) ) != 0 ) taps [ i ] -= 1 ; \n} \n} \n} \n"}
{"3599": "public class SegmentReader { \npublic final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { \nif ( done ) return State . STOP ; \nint skipOneMarker = curMarker >= 0x100 && curMarker <= 0x1ff ? 1 : 0 ; \nint written = out . position ( ) ; \ndo { \nwhile ( buf . hasRemaining ( ) ) { \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) { \nif ( skipOneMarker == 0 ) { \nreturn State . DONE ; \n} \nskipOneMarker = skipOneMarker - 1 ; \n} \nif ( ! out . hasRemaining ( ) ) return State . MORE_DATA ; \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; \n} \nbuf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; \npos += buf . remaining ( ) ; \n} \nwhile ( buf . hasRemaining ( ) ) ; \nwritten = out . position ( ) - written ; \nif ( written > 0 && curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \nfor ( ; \nbytesInMarker > 0 && out . hasRemaining ( ) ; \n) { \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) ; \nbytesInMarker = bytesInMarker - 1 ; \nif ( curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; \n} \nif ( bytesInMarker == 0 ) { \ndone = true ; \nreturn State . STOP ; \n} \nelse { \nreturn State . MORE_DATA ; \n} \n} \n} \n"}
{"3605": "public class QTTimeUtil { \npublic static long frameToTimevalue ( TrakBox trak , int frameNumber ) { \nTimeToSampleBox stts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( \"mdia.minf.stbl.stts\" ) ) ; \nTimeToSampleEntry [ ] timeToSamples = stts . getEntries ( ) ; \nlong pts = 0 ; \nint sttsInd = 0 , sttsSubInd = frameNumber ; \nwhile ( sttsSubInd >= timeToSamples [ sttsInd ] . getSampleCount ( ) ) { \nsttsSubInd -= timeToSamples [ sttsInd ] . getSampleCount ( ) ; \npts += timeToSamples [ sttsInd ] . getSampleCount ( ) * timeToSamples [ sttsInd ] . getSampleDuration ( ) ; \nsttsInd = sttsInd + 1 ; \n} \nreturn pts + timeToSamples [ sttsInd ] . getSampleDuration ( ) * sttsSubInd ; \n} \n} \n"}
{"3606": "public class QTTimeUtil { \npublic static int timevalueToFrame ( TrakBox trak , long tv ) { \nTimeToSampleEntry [ ] tts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( \"mdia.minf.stbl.stts\" ) ) . getEntries ( ) ; \nint frame = 0 ; \nfor ( int i = 0 ; \ntv > 0 && i < tts . length ; \ni = i + 1 ) { \nlong rem = tv / tts [ i ] . getSampleDuration ( ) ; \ntv -= tts [ i ] . getSampleCount ( ) * tts [ i ] . getSampleDuration ( ) ; \nframe += tv > 0 ? tts [ i ] . getSampleCount ( ) : rem ; \n} \nreturn frame ; \n} \n} \n"}
{"3620": "public class WavHeader { \npublic static WavHeader multiChannelWav ( WavHeader [ ] headers ) { \nWavHeader w = emptyWavHeader ( ) ; \nint totalSize = 0 ; \nfor ( int i = 0 ; \ni < headers . length ; \ni = i + 1 ) { \nWavHeader wavHeader = headers [ i ] ; \ntotalSize += wavHeader . dataSize ; \n} \nw . dataSize = totalSize ; \nFmtChunk fmt = headers [ 0 ] . fmt ; \nint bitsPerSample = fmt . bitsPerSample ; \nint bytesPerSample = bitsPerSample / 8 ; \nint sampleRate = ( int ) fmt . sampleRate ; \nw . fmt . bitsPerSample = ( short ) bitsPerSample ; \nw . fmt . blockAlign = ( short ) ( headers . length * bytesPerSample ) ; \nw . fmt . byteRate = headers . length * bytesPerSample * sampleRate ; \nw . fmt . numChannels = ( short ) headers . length ; \nw . fmt . sampleRate = sampleRate ; \nreturn w ; \n} \n} \n"}
{"3628": "public class SequenceEncoder { \npublic void encodeNativeFrame ( Picture pic ) throws IOException { \nif ( pic . getColor ( ) != ColorSpace . RGB ) throw new IllegalArgumentException ( \"The input images is expected in RGB color.\" ) ; \nColorSpace sinkColor = sink . getInputColor ( ) ; \nLoanerPicture toEncode ; \nif ( sinkColor != null ) { \ntoEncode = pixelStore . getPicture ( pic . getWidth ( ) , pic . getHeight ( ) , sinkColor ) ; \ntransform . transform ( pic , toEncode . getPicture ( ) ) ; \n} \nelse { \ntoEncode = new LoanerPicture ( pic , 0 ) ; \n} \nPacket pkt = Packet . createPacket ( null , timestamp , fps . getNum ( ) , fps . getDen ( ) , frameNo , FrameType . KEY , null ) ; \nsink . outputVideoFrame ( new VideoFrameWithPacket ( pkt , toEncode ) ) ; \nif ( sinkColor != null ) pixelStore . putBack ( toEncode ) ; \ntimestamp += fps . getDen ( ) ; \nframeNo = frameNo + 1 ; \n} \n} \n"}
{"3629": "public class EbmlUtil { \npublic static byte [ ] ebmlEncodeLen ( long value , int length ) { \nbyte [ ] b = new byte [ length ] ; \nfor ( int idx = 0 ; \nidx < length ; \nidx = idx + 1 ) { \nb [ length - idx - 1 ] = ( byte ) ( ( value >>> ( 8 * idx ) ) & 0xFFL ) ; \n} \nb [ 0 ] |= 0x80 >>> ( length - 1 ) ; \nreturn b ; \n} \n} \n"}
{"3630": "public class EbmlUtil { \npublic static int ebmlLength ( long v ) { \nif ( v == 0 ) return 1 ; \nint length = 8 ; \nwhile ( length > 0 && ( v & ebmlLengthMasks [ length ] ) == 0 ) length = length - 1 ; \nreturn length ; \n} \n} \n"}
{"3632": "public class FLVReader { \npublic boolean repositionFile ( ) throws IOException { \nint payloadSize = 0 ; \nfor ( int i = 0 ; \ni < REPOSITION_BUFFER_READS ; \ni = i + 1 ) { \nwhile ( readBuf . hasRemaining ( ) ) { \npayloadSize = ( ( payloadSize & 0xffff ) << 8 ) | ( readBuf . get ( ) & 0xff ) ; \nint pointerPos = readBuf . position ( ) + 7 + payloadSize ; \nif ( readBuf . position ( ) >= 8 && pointerPos < readBuf . limit ( ) - 4 && readBuf . getInt ( pointerPos ) - payloadSize == 11 ) { \nreadBuf . position ( readBuf . position ( ) - 8 ) ; \nreturn true ; \n} \n} \ninitialRead ( ch ) ; \nif ( ! readBuf . hasRemaining ( ) ) break ; \n} \nreturn false ; \n} \n} \n"}
{"3633": "public class MDecoder { \npublic int decodeBin ( int m ) { \nint bin ; \nint qIdx = ( range >> 6 ) & 0x3 ; \nint rLPS = MConst . rangeLPS [ qIdx ] [ cm [ 0 ] [ m ] ] ; \nrange -= rLPS ; \nint rs8 = range << 8 ; \nif ( code < rs8 ) { \nif ( cm [ 0 ] [ m ] < 62 ) cm [ 0 ] [ m ] = cm [ 0 ] [ m ] + 1 ; \nrenormalize ( ) ; \nbin = cm [ 1 ] [ m ] ; \n} \nelse { \nrange = rLPS ; \ncode -= rs8 ; \nrenormalize ( ) ; \nbin = 1 - cm [ 1 ] [ m ] ; \nif ( cm [ 0 ] [ m ] == 0 ) cm [ 1 ] [ m ] = 1 - cm [ 1 ] [ m ] ; \ncm [ 0 ] [ m ] = MConst . transitLPS [ cm [ 0 ] [ m ] ] ; \n} \nreturn bin ; \n} \n} \n"}
{"3634": "public class MDecoder { \npublic int decodeBinBypass ( ) { \ncode <<= 1 ; \nnBitsPending = nBitsPending - 1 ; \nif ( nBitsPending <= 0 ) readOneByte ( ) ; \nint tmp = code - ( range << 8 ) ; \nif ( tmp < 0 ) { \nreturn 0 ; \n} \nelse { \ncode = tmp ; \nreturn 1 ; \n} \n} \n} \n"}
{"3635": "public class MPEGUtil { \npublic static final ByteBuffer gotoMarker ( ByteBuffer buf , int n , int mmin , int mmax ) { \nif ( ! buf . hasRemaining ( ) ) return null ; \nint from = buf . position ( ) ; \nByteBuffer result = buf . slice ( ) ; \nresult . order ( ByteOrder . BIG_ENDIAN ) ; \nint val = 0xffffffff ; \nwhile ( buf . hasRemaining ( ) ) { \nval = ( val << 8 ) | ( buf . get ( ) & 0xff ) ; \nif ( val >= mmin && val <= mmax ) { \nif ( n == 0 ) { \nbuf . position ( buf . position ( ) - 4 ) ; \nresult . limit ( buf . position ( ) - from ) ; \nbreak ; \n} \nn = n - 1 ; \n} \n} \nreturn result ; \n} \n} \n"}
{"3646": "public class GainControl { \nprivate int getGainChangePointID ( int lngain ) { \nfor ( int i = 0 ; \ni < ID_GAIN ; \ni = i + 1 ) { \nif ( lngain == LN_GAIN [ i ] ) return i ; \n} \nreturn 0 ; \n} \n} \n"}
{"3651": "public class AudioUtil { \npublic static void interleave ( AudioFormat format , ByteBuffer [ ] ins , ByteBuffer outb ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * ins . length ; \nint max = 0 ; \nfor ( int i = 0 ; \ni < ins . length ; \ni = i + 1 ) if ( ins [ i ] . remaining ( ) > max ) max = ins [ i ] . remaining ( ) ; \nfor ( int frames = 0 ; \nframes < max && outb . remaining ( ) >= bytesPerFrame ; \nframes = frames + 1 ) { \nfor ( int j = 0 ; \nj < ins . length ; \nj = j + 1 ) { \nif ( ins [ j ] . remaining ( ) < bytesPerSample ) { \nfor ( int i = 0 ; \ni < bytesPerSample ; \ni = i + 1 ) outb . put ( ( byte ) 0 ) ; \n} \nelse { \nfor ( int i = 0 ; \ni < bytesPerSample ; \ni = i + 1 ) { \noutb . put ( ins [ j ] . get ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"3652": "public class AudioUtil { \npublic static void deinterleave ( AudioFormat format , ByteBuffer inb , ByteBuffer [ ] outs ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * outs . length ; \nwhile ( inb . remaining ( ) >= bytesPerFrame ) { \nfor ( int j = 0 ; \nj < outs . length ; \nj = j + 1 ) { \nfor ( int i = 0 ; \ni < bytesPerSample ; \ni = i + 1 ) { \nouts [ j ] . put ( inb . get ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"3654": "public class SliceGroupMapBuilder { \npublic static int [ ] buildBoxOutMap ( int picWidthInMbs , int picHeightInMbs , boolean changeDirection , int numberOfMbsInBox ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nfor ( int i = 0 ; \ni < picSizeInMbs ; \ni = i + 1 ) groups [ i ] = 1 ; \nint x = ( picWidthInMbs - changeDirectionInt ) / 2 ; \nint y = ( picHeightInMbs - changeDirectionInt ) / 2 ; \nint leftBound = x ; \nint topBound = y ; \nint rightBound = x ; \nint bottomBound = y ; \nint xDir = changeDirectionInt - 1 ; \nint yDir = changeDirectionInt ; \nboolean mapUnitVacant = false ; \nfor ( int k = 0 ; \nk < numberOfMbsInBox ; \nk += ( mapUnitVacant ? 1 : 0 ) ) { \nint mbAddr = y * picWidthInMbs + x ; \nmapUnitVacant = ( groups [ mbAddr ] == 1 ) ; \nif ( mapUnitVacant ) { \ngroups [ mbAddr ] = 0 ; \n} \nif ( xDir == - 1 && x == leftBound ) { \nleftBound = Max ( leftBound - 1 , 0 ) ; \nx = leftBound ; \nxDir = 0 ; \nyDir = 2 * changeDirectionInt - 1 ; \n} \nelse if ( xDir == 1 && x == rightBound ) { \nrightBound = Min ( rightBound + 1 , picWidthInMbs - 1 ) ; \nx = rightBound ; \nxDir = 0 ; \nyDir = 1 - 2 * changeDirectionInt ; \n} \nelse if ( yDir == - 1 && y == topBound ) { \ntopBound = Max ( topBound - 1 , 0 ) ; \ny = topBound ; \nxDir = 1 - 2 * changeDirectionInt ; \nyDir = 0 ; \n} \nelse if ( yDir == 1 && y == bottomBound ) { \nbottomBound = Min ( bottomBound + 1 , picHeightInMbs - 1 ) ; \ny = bottomBound ; \nxDir = 2 * changeDirectionInt - 1 ; \nyDir = 0 ; \n} \nelse { \nx += xDir ; \ny += yDir ; \n} \n} \nreturn groups ; \n} \n} \n"}
{"3655": "public class SliceGroupMapBuilder { \npublic static int [ ] buildWipeMap ( int picWidthInMbs , int picHeightInMbs , int sizeOfUpperLeftGroup , boolean changeDirection ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nint k = 0 ; \nfor ( int j = 0 ; \nj < picWidthInMbs ; \nj = j + 1 ) { \nfor ( int i = 0 ; \ni < picHeightInMbs ; \ni = i + 1 ) { \nint mbAddr = i * picWidthInMbs + j ; \nif ( k = k + 1 < sizeOfUpperLeftGroup ) { \ngroups [ mbAddr ] = changeDirectionInt ; \n} \nelse { \ngroups [ mbAddr ] = 1 - changeDirectionInt ; \n} \n} \n} \nreturn groups ; \n} \n} \n"}
{"3656": "public class MXFMetadata { \nprotected static UL [ ] readULBatch ( ByteBuffer _bb ) { \nint count = _bb . getInt ( ) ; \n_bb . getInt ( ) ; \nUL [ ] result = new UL [ count ] ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nresult [ i ] = UL . read ( _bb ) ; \n} \nreturn result ; \n} \n} \n"}
{"3657": "public class MXFMetadata { \nprotected static int [ ] readInt32Batch ( ByteBuffer _bb ) { \nint count = _bb . getInt ( ) ; \n_bb . getInt ( ) ; \nint [ ] result = new int [ count ] ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nresult [ i ] = _bb . getInt ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"3659": "public class H264Encoder { \npublic EncodedFrame encodeFrame ( Picture pic , ByteBuffer _out ) { \nif ( pic . getColor ( ) != ColorSpace . YUV420J ) throw new IllegalArgumentException ( \"Input picture color is not supported: \" + pic . getColor ( ) ) ; \nif ( frameNumber >= keyInterval ) { \nframeNumber = 0 ; \n} \nSliceType sliceType = frameNumber == 0 ? SliceType . I : SliceType . P ; \nboolean idr = frameNumber == 0 ; \nByteBuffer data = doEncodeFrame ( pic , _out , idr , frameNumber = frameNumber + 1 , sliceType ) ; \nreturn new EncodedFrame ( data , idr ) ; \n} \n} \n"}
{"3661": "public class H264Encoder { \npublic ByteBuffer encodePFrame ( Picture pic , ByteBuffer _out ) { \nframeNumber = frameNumber + 1 ; \nreturn doEncodeFrame ( pic , _out , true , frameNumber , SliceType . P ) ; \n} \n} \n"}
{"3662": "public class ContainerFormat { \npublic java . util . Collection < Codec . ID > getSupportedCodecs ( ) { \nfinal java . util . List < Codec . ID > retval = new java . util . LinkedList < Codec . ID > ( ) ; \nfinal java . util . Set < Codec . ID > uniqueSet = new java . util . HashSet < Codec . ID > ( ) ; \nint numCodecs = getNumSupportedCodecs ( ) ; \nfor ( int i = 0 ; \ni < numCodecs ; \ni = i + 1 ) { \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( id ) ) retval . add ( id ) ; \nuniqueSet . add ( id ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3663": "public class ContainerFormat { \npublic java . util . Collection < Long > getSupportedTags ( ) { \nfinal java . util . List < Long > retval = new java . util . LinkedList < Long > ( ) ; \nfinal java . util . Set < Long > uniqueSet = new java . util . HashSet < Long > ( ) ; \nint numCodecs = getNumSupportedCodecs ( ) ; \nfor ( int i = 0 ; \ni < numCodecs ; \ni = i + 1 ) { \nlong tag = getSupportedCodecTag ( i ) ; \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( tag ) ) retval . add ( tag ) ; \nuniqueSet . add ( tag ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3664": "public class JNIMemoryManager { \nfinal boolean addReference ( final JNIReference ref ) { \nboolean gotNonblockingLock = false ; \ngotNonblockingLock = mSpinLock . compareAndSet ( false , true ) ; \nif ( gotNonblockingLock ) { \nfinal int slot = mNextAvailableReferenceSlot = mNextAvailableReferenceSlot + 1 ; \nif ( slot < mMaxValidReference ) { \nmValidReferences [ slot ] = ref ; \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never be unlocked here\" ; \nreturn true ; \n} \nif ( ! mLock . tryLock ( ) ) { \ngotNonblockingLock = false ; \nmSpinLock . compareAndSet ( true , false ) ; \n} \n} \nif ( ! gotNonblockingLock ) { \nmLock . lock ( ) ; \nwhile ( ! mSpinLock . compareAndSet ( false , true ) ) ; \n} \ntry { \nint slot = mNextAvailableReferenceSlot = mNextAvailableReferenceSlot + 1 ; \nif ( slot >= mMaxValidReference ) { \nsweepAndCollect ( ) ; \nslot = mNextAvailableReferenceSlot = mNextAvailableReferenceSlot + 1 ; \n} \nmValidReferences [ slot ] = ref ; \n} \nfinally { \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never ever be unlocked here\" ; \nmLock . unlock ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"3666": "public class JNIMemoryManager { \nfinal public void flush ( ) { \nblockingLock ( ) ; \ntry { \nint numSurvivors = sweepAndCollect ( ) ; \nfor ( int i = 0 ; \ni < numSurvivors ; \ni = i + 1 ) { \nfinal JNIReference ref = mValidReferences [ i ] ; \nif ( ref != null ) ref . delete ( ) ; \n} \nsweepAndCollect ( ) ; \nmValidReferences = new JNIReference [ mMinimumReferencesToCache ] ; \nmNextAvailableReferenceSlot = 0 ; \nmMaxValidReference = mMinimumReferencesToCache ; \n} \nfinally { \nblockingUnlock ( ) ; \n} \n} \n} \n"}
{"3676": "public class DecodeAndPlayVideo { \nprivate static void playVideo ( String filename ) throws InterruptedException , IOException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint videoStreamId = - 1 ; \nlong streamStartTime = Global . NO_PTS ; \nDecoder videoDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni = i + 1 ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nstreamStartTime = stream . getStartTime ( ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { \nvideoStreamId = i ; \nvideoDecoder = decoder ; \nbreak ; \n} \n} \nif ( videoStreamId == - 1 ) throw new RuntimeException ( \"could not find video stream in container: \" + filename ) ; \nvideoDecoder . open ( null , null ) ; \nfinal MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; \nfinal MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; \nBufferedImage image = null ; \nfinal ImageFrame window = ImageFrame . make ( ) ; \nif ( window == null ) { \nthrow new RuntimeException ( \"Attempting this demo on a headless machine, and that will not work. Sad day for you.\" ) ; \n} \nlong systemStartTime = System . nanoTime ( ) ; \nfinal Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; \nfinal Rational streamTimebase = videoDecoder . getTimeBase ( ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == videoStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += videoDecoder . decode ( picture , packet , offset ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \nvideoDecoder . decode ( picture , null , 0 ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \n} \nwhile ( picture . isComplete ( ) ) ; \ndemuxer . close ( ) ; \nwindow . dispose ( ) ; \n} \n} \n"}
{"3679": "public class Configuration { \npublic static void printOption ( java . io . PrintStream stream , Configurable configObj , Property prop ) { \nif ( prop . getType ( ) != Property . Type . PROPERTY_FLAGS ) { \nstream . printf ( \"  %s; default= %s; type=%s;\\n\" , prop . getName ( ) , configObj . getPropertyAsString ( prop . getName ( ) ) , prop . getType ( ) ) ; \n} \nelse { \nstream . printf ( \"  %s; default= %d; valid values=(\" , prop . getName ( ) , configObj . getPropertyAsLong ( prop . getName ( ) ) ) ; \nint numSettings = prop . getNumFlagSettings ( ) ; \nlong value = configObj . getPropertyAsLong ( prop . getName ( ) ) ; \nfor ( int i = 0 ; \ni < numSettings ; \ni = i + 1 ) { \nProperty fprop = prop . getFlagConstant ( i ) ; \nlong flagMask = fprop . getDefault ( ) ; \nboolean isSet = ( value & flagMask ) > 0 ; \nstream . printf ( \"%s%s; \" , isSet ? \"+\" : \"-\" , fprop . getName ( ) ) ; \n} \nstream . printf ( \"); type=%s;\\n\" , prop . getType ( ) ) ; \n} \nstream . printf ( \"    help for %s: %s\\n\" , prop . getName ( ) , prop . getHelp ( ) == null ? \"no help available\" : prop . getHelp ( ) ) ; \n} \n} \n"}
{"3683": "public class Codec { \npublic java . util . Collection < Rational > getSupportedVideoFrameRates ( ) { \njava . util . List < Rational > retval = new java . util . LinkedList < Rational > ( ) ; \nint count = getNumSupportedVideoFrameRates ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nRational rate = getSupportedVideoFrameRate ( i ) ; \nif ( rate != null ) retval . add ( rate ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3684": "public class Codec { \npublic java . util . Collection < PixelFormat . Type > getSupportedVideoPixelFormats ( ) { \njava . util . List < PixelFormat . Type > retval = new java . util . LinkedList < PixelFormat . Type > ( ) ; \nint count = getNumSupportedVideoPixelFormats ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nPixelFormat . Type type = getSupportedVideoPixelFormat ( i ) ; \nif ( type != null && type != PixelFormat . Type . PIX_FMT_NONE ) retval . add ( type ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3685": "public class Codec { \npublic java . util . Collection < Integer > getSupportedAudioSampleRates ( ) { \njava . util . List < Integer > retval = new java . util . LinkedList < Integer > ( ) ; \nint count = getNumSupportedAudioSampleRates ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nint rate = getSupportedAudioSampleRate ( i ) ; \nif ( rate != 0 ) retval . add ( rate ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3686": "public class Codec { \npublic java . util . Collection < AudioFormat . Type > getSupportedAudioFormats ( ) { \njava . util . List < AudioFormat . Type > retval = new java . util . LinkedList < AudioFormat . Type > ( ) ; \nint count = getNumSupportedAudioFormats ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nAudioFormat . Type fmt = getSupportedAudioFormat ( i ) ; \nif ( fmt != null && fmt != AudioFormat . Type . SAMPLE_FMT_NONE ) retval . add ( fmt ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3687": "public class Codec { \npublic java . util . Collection < AudioChannel . Layout > getSupportedAudioChannelLayouts ( ) { \njava . util . List < AudioChannel . Layout > retval = new java . util . LinkedList < AudioChannel . Layout > ( ) ; \nint count = getNumSupportedAudioChannelLayouts ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nAudioChannel . Layout layout = getSupportedAudioChannelLayout ( i ) ; \nif ( layout != AudioChannel . Layout . CH_LAYOUT_UNKNOWN ) retval . add ( layout ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3692": "public class MuxerFormat { \npublic static java . util . Collection < MuxerFormat > getFormats ( ) { \njava . util . Collection < MuxerFormat > retval = new java . util . HashSet < MuxerFormat > ( ) ; \nint count = getNumFormats ( ) ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nMuxerFormat fmt = getFormat ( i ) ; \nif ( fmt != null ) retval . add ( fmt ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3706": "public class DecodeAndPlayAudio { \nprivate static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint audioStreamId = - 1 ; \nDecoder audioDecoder = null ; \nfor ( int i = 0 ; \ni < numStreams ; \ni = i + 1 ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { \naudioStreamId = i ; \naudioDecoder = decoder ; \nbreak ; \n} \n} \nif ( audioStreamId == - 1 ) throw new RuntimeException ( \"could not find audio stream in container: \" + filename ) ; \naudioDecoder . open ( null , null ) ; \nfinal MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; \nfinal MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; \nfinal AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; \nif ( audioFrame == null ) throw new LineUnavailableException ( ) ; \nByteBuffer rawAudio = null ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( demuxer . read ( packet ) >= 0 ) { \nif ( packet . getStreamIndex ( ) == audioStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += audioDecoder . decode ( samples , packet , offset ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \noffset += bytesRead ; \n} \nwhile ( offset < packet . getSize ( ) ) ; \n} \n} \ndo { \naudioDecoder . decode ( samples , null , 0 ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \n} \nwhile ( samples . isComplete ( ) ) ; \ndemuxer . close ( ) ; \naudioFrame . dispose ( ) ; \n} \n} \n"}
{"3712": "public class RecordAndEncodeVideo { \nprivate static void recordScreen ( String filename , String formatname , String codecname , int duration , int snapsPerSecond ) throws AWTException , InterruptedException , IOException { \nfinal Robot robot = new Robot ( ) ; \nfinal Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; \nfinal Rectangle screenbounds = new Rectangle ( toolkit . getScreenSize ( ) ) ; \nfinal Rational framerate = Rational . make ( 1 , snapsPerSecond ) ; \nfinal Muxer muxer = Muxer . make ( filename , null , formatname ) ; \nfinal MuxerFormat format = muxer . getFormat ( ) ; \nfinal Codec codec ; \nif ( codecname != null ) { \ncodec = Codec . findEncodingCodecByName ( codecname ) ; \n} \nelse { \ncodec = Codec . findEncodingCodec ( format . getDefaultVideoCodecId ( ) ) ; \n} \nEncoder encoder = Encoder . make ( codec ) ; \nencoder . setWidth ( screenbounds . width ) ; \nencoder . setHeight ( screenbounds . height ) ; \nfinal PixelFormat . Type pixelformat = PixelFormat . Type . PIX_FMT_YUV420P ; \nencoder . setPixelFormat ( pixelformat ) ; \nencoder . setTimeBase ( framerate ) ; \nif ( format . getFlag ( MuxerFormat . Flag . GLOBAL_HEADER ) ) encoder . setFlag ( Encoder . Flag . FLAG_GLOBAL_HEADER , true ) ; \nencoder . open ( null , null ) ; \nmuxer . addNewStream ( encoder ) ; \nmuxer . open ( null , null ) ; \nMediaPictureConverter converter = null ; \nfinal MediaPicture picture = MediaPicture . make ( encoder . getWidth ( ) , encoder . getHeight ( ) , pixelformat ) ; \npicture . setTimeBase ( framerate ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nfor ( int i = 0 ; \ni < duration / framerate . getDouble ( ) ; \ni = i + 1 ) { \nfinal BufferedImage screen = convertToType ( robot . createScreenCapture ( screenbounds ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nif ( converter == null ) converter = MediaPictureConverterFactory . createConverter ( screen , picture ) ; \nconverter . toPicture ( picture , screen , i ) ; \ndo { \nencoder . encode ( packet , picture ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nThread . sleep ( ( long ) ( 1000 * framerate . getDouble ( ) ) ) ; \n} \ndo { \nencoder . encode ( packet , null ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nmuxer . close ( ) ; \n} \n} \n"}
{"3717": "public class Base58 { \npublic static byte [ ] decode ( String input ) throws IllegalArgumentException { \nif ( input . startsWith ( \"base58:\" ) ) input = input . substring ( 7 ) ; \nif ( input . length ( ) == 0 ) return new byte [ 0 ] ; \nbyte [ ] input58 = new byte [ input . length ( ) ] ; \nfor ( int i = 0 ; \ni < input . length ( ) ; \ni = i + 1 ) { \nchar c = input . charAt ( i ) ; \nint digit = c < 128 ? INDEXES [ c ] : - 1 ; \nif ( digit < 0 ) { \nthrow new IllegalArgumentException ( \"Illegal character \" + c + \" at position \" + i ) ; \n} \ninput58 [ i ] = ( byte ) digit ; \n} \nint zeros = 0 ; \nwhile ( zeros < input58 . length && input58 [ zeros ] == 0 ) { \nzeros = zeros + 1 ; \n} \nbyte [ ] decoded = new byte [ input . length ( ) ] ; \nint outputStart = decoded . length ; \nfor ( int inputStart = zeros ; \ninputStart < input58 . length ; \n) { \ndecoded [ outputStart = outputStart - 1 ] = divmod ( input58 , inputStart , 58 , 256 ) ; \nif ( input58 [ inputStart ] == 0 ) { \ninputStart = inputStart + 1 ; \n} \n} \nwhile ( outputStart < decoded . length && decoded [ outputStart ] == 0 ) { \noutputStart = outputStart + 1 ; \n} \nreturn Arrays . copyOfRange ( decoded , outputStart - zeros , decoded . length ) ; \n} \n} \n"}
{"3718": "public class PrivateKeyAccount { \npublic static String generateSeed ( ) { \nbyte [ ] bytes = new byte [ 21 ] ; \nnew SecureRandom ( ) . nextBytes ( bytes ) ; \nbyte [ ] rhash = hash ( bytes , 0 , 20 , SHA256 ) ; \nbytes [ 20 ] = rhash [ 0 ] ; \nBigInteger rand = new BigInteger ( bytes ) ; \nBigInteger mask = new BigInteger ( new byte [ ] { \n0 , 0 , 7 , - 1 } \n) ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < 15 ; \ni = i + 1 ) { \nsb . append ( i > 0 ? ' ' : \"\" ) . append ( SEED_WORDS [ rand . and ( mask ) . intValue ( ) ] ) ; \nrand = rand . shiftRight ( 11 ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"3734": "public class FSTBinaryOffheapMap { \npublic void resizeStore ( long required , long maxgrowbytes ) { \nif ( mappedFile == null ) throw new RuntimeException ( \"store is full. Required: \" + required ) ; \nif ( required <= memory . length ( ) ) return ; \nmutationCount = mutationCount + 1 ; \nSystem . out . println ( \"resizing underlying \" + mappedFile + \" to \" + required + \" numElem:\" + numElem ) ; \nlong tim = System . currentTimeMillis ( ) ; \n( ( MMFBytez ) memory ) . freeAndClose ( ) ; \nmemory = null ; \ntry { \nFile mf = new File ( mappedFile ) ; \nFileOutputStream f = new FileOutputStream ( mf , true ) ; \nlong len = mf . length ( ) ; \nrequired = required + Math . min ( required , maxgrowbytes ) ; \nbyte [ ] toWrite = new byte [ 1000 ] ; \nlong max = ( required - len ) / 1000 ; \nfor ( long i = 0 ; \ni < max + 2 ; \ni = i + 1 ) { \nf . write ( toWrite ) ; \n} \nf . flush ( ) ; \nf . close ( ) ; \nresetMem ( mappedFile , mf . length ( ) ) ; \nSystem . out . println ( \"resizing done in \" + ( System . currentTimeMillis ( ) - tim ) + \" numElemAfter:\" + numElem ) ; \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"3735": "public class FSTBinaryOffheapMap { \npublic void removeBinary ( ByteSource key ) { \ncheckThread ( ) ; \nif ( key . length ( ) != keyLen ) throw new RuntimeException ( \"key must have length \" + keyLen ) ; \nmutationCount = mutationCount + 1 ; \nlong rem = index . get ( key ) ; \nif ( rem != 0 ) { \nindex . remove ( key ) ; \ndecElems ( ) ; \nremoveEntry ( rem ) ; \n} \n} \n} \n"}
{"3746": "public class FSTConfiguration { \npublic FSTConfiguration registerCrossPlatformClassMapping ( String [ ] [ ] keysAndVals ) { \nfor ( int i = 0 ; \ni < keysAndVals . length ; \ni = i + 1 ) { \nString [ ] keysAndVal = keysAndVals [ i ] ; \nregisterCrossPlatformClassMapping ( keysAndVal [ 0 ] , keysAndVal [ 1 ] ) ; \n} \nreturn this ; \n} \n} \n"}
{"3749": "public class MBOut { \nprotected void writeRawInt ( byte type , long data ) { \nint numBytes = MinBin . extractNumBytes ( type ) ; \nfor ( int i = 0 ; \ni < numBytes ; \ni = i + 1 ) { \nwriteOut ( ( byte ) ( data & 0xff ) ) ; \ndata = data >>> 8 ; \n} \n} \n} \n"}
{"3751": "public class MBOut { \npublic void writeArray ( Object primitiveArray , int start , int len ) { \nbyte type = MinBin . ARRAY_MASK ; \nClass < ? > componentType = primitiveArray . getClass ( ) . getComponentType ( ) ; \nif ( componentType == boolean . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == byte . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == short . class ) type |= MinBin . INT_16 ; \nelse if ( componentType == char . class ) type |= MinBin . INT_16 | MinBin . UNSIGN_MASK ; \nelse if ( componentType == int . class ) type |= MinBin . INT_32 ; \nelse if ( componentType == long . class ) type |= MinBin . INT_64 ; \nelse throw new RuntimeException ( \"unsupported type \" + componentType . getName ( ) ) ; \nwriteOut ( type ) ; \nwriteIntPacked ( len ) ; \nswitch ( type ) { \ncase MinBin . INT_8 | MinBin . ARRAY_MASK : { \nif ( componentType == boolean . class ) { \nboolean [ ] arr = ( boolean [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni = i + 1 ) { \nwriteRawInt ( type , arr [ i ] ? 1 : 0 ) ; \n} \n} \nelse { \nbyte [ ] arr = ( byte [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni = i + 1 ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \n} \nbreak ; \ncase MinBin . CHAR | MinBin . ARRAY_MASK : { \nchar [ ] charArr = ( char [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni = i + 1 ) { \nwriteRawInt ( type , charArr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_32 | MinBin . ARRAY_MASK : { \nint [ ] arr = ( int [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni = i + 1 ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_64 | MinBin . ARRAY_MASK : { \nlong [ ] arr = ( long [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni = i + 1 ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ndefault : { \nfor ( int i = start ; \ni < start + len ; \ni = i + 1 ) { \nif ( componentType == boolean . class ) writeRawInt ( type , Array . getBoolean ( primitiveArray , i ) ? 1 : 0 ) ; \nelse writeRawInt ( type , Array . getLong ( primitiveArray , i ) ) ; \n} \n} \n} \n} \n} \n"}
{"3757": "public class FSTObjectOutput { \nprotected void writeArray ( FSTClazzInfo . FSTFieldInfo referencee , Object array ) throws IOException { \nif ( array == null ) { \ngetCodec ( ) . writeClass ( Object . class ) ; \ngetCodec ( ) . writeFInt ( - 1 ) ; \nreturn ; \n} \nfinal int len = Array . getLength ( array ) ; \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \ngetCodec ( ) . writeClass ( array . getClass ( ) ) ; \ngetCodec ( ) . writeFInt ( len ) ; \nif ( ! componentType . isArray ( ) ) { \nif ( getCodec ( ) . isPrimitiveArray ( array , componentType ) ) { \ngetCodec ( ) . writePrimitiveArray ( array , 0 , len ) ; \n} \nelse { \nObject arr [ ] = ( Object [ ] ) array ; \nClass lastClz = null ; \nFSTClazzInfo lastInfo = null ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nObject toWrite = arr [ i ] ; \nif ( toWrite != null ) { \nlastInfo = writeObjectWithContext ( referencee , toWrite , lastClz == toWrite . getClass ( ) ? lastInfo : null ) ; \nlastClz = toWrite . getClass ( ) ; \n} \nelse writeObjectWithContext ( referencee , toWrite , null ) ; \n} \n} \n} \nelse { \nObject [ ] arr = ( Object [ ] ) array ; \nFSTClazzInfo . FSTFieldInfo ref1 = new FSTClazzInfo . FSTFieldInfo ( referencee . getPossibleClasses ( ) , null , conf . getCLInfoRegistry ( ) . isIgnoreAnnotations ( ) ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nObject subArr = arr [ i ] ; \nboolean needsWrite = true ; \nif ( getCodec ( ) . isTagMultiDimSubArrays ( ) ) { \nif ( subArr == null ) { \nneedsWrite = ! getCodec ( ) . writeTag ( NULL , null , 0 , null , this ) ; \n} \nelse { \nneedsWrite = ! getCodec ( ) . writeTag ( ARRAY , subArr , 0 , subArr , this ) ; \n} \n} \nif ( needsWrite ) { \nwriteArray ( ref1 , subArr ) ; \ngetCodec ( ) . writeArrayEnd ( ) ; \n} \n} \n} \n} \n} \n"}
{"3758": "public class StructString { \npublic void setString ( String s ) { \nif ( s == null ) { \nsetLen ( 0 ) ; \nreturn ; \n} \nif ( s . length ( ) > charsLen ( ) ) { \nthrow new RuntimeException ( \"String length exceeds buffer size. String len \" + s . length ( ) + \" charsLen:\" + charsLen ( ) ) ; \n} \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni = i + 1 ) { \nchars ( i , s . charAt ( i ) ) ; \n} \nlen = s . length ( ) ; \n} \n} \n"}
{"3761": "public class FSTStructChange { \npublic void snapshotChanges ( int originBase , Bytez origin ) { \nint sumLen = 0 ; \nfor ( int i = 0 ; \ni < curIndex ; \ni = i + 1 ) { \nsumLen += changeLength [ i ] ; \n} \nsnapshot = new byte [ sumLen ] ; \nint targetIdx = 0 ; \nfor ( int i = 0 ; \ni < curIndex ; \ni = i + 1 ) { \nint changeOffset = changeOffsets [ i ] ; \nint len = changeLength [ i ] ; \nfor ( int ii = 0 ; \nii < len ; \nii = ii + 1 ) { \nsnapshot [ targetIdx = targetIdx + 1 ] = origin . get ( changeOffset + ii ) ; \n} \n} \nrebase ( originBase ) ; \n} \n} \n"}
{"3765": "public class BinaryQueue { \npublic byte [ ] readByteArray ( int len ) { \nif ( available ( ) < len ) { \nthrow new RuntimeException ( \"not enough data available, check available() > len before calling\" ) ; \n} \nbyte b [ ] = new byte [ len ] ; \nint count = 0 ; \nwhile ( pollIndex != addIndex && count < len ) { \nb [ count = count + 1 ] = storage . get ( pollIndex = pollIndex + 1 ) ; \nif ( pollIndex >= storage . length ( ) ) { \npollIndex = 0 ; \n} \n} \nreturn b ; \n} \n} \n"}
{"3777": "public class BooleanIndexing { \npublic static boolean or ( IComplexNDArray n , Condition cond ) { \nboolean ret = false ; \nIComplexNDArray linear = n . linearView ( ) ; \nfor ( int i = 0 ; \ni < linear . length ( ) ; \ni = i + 1 ) { \nret = ret || cond . apply ( linear . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3779": "public class BooleanIndexing { \npublic static boolean [ ] and ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nlong tadLength = Shape . getTADLength ( n . shape ( ) , dimension ) ; \nfor ( int i = 0 ; \ni < arr . length ( ) ; \ni = i + 1 ) { \nif ( arr . getDouble ( i ) == tadLength ) result [ i ] = true ; \nelse result [ i ] = false ; \n} \nreturn result ; \n} \n} \n"}
{"3780": "public class BooleanIndexing { \npublic static boolean [ ] or ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nfor ( int i = 0 ; \ni < arr . length ( ) ; \ni = i + 1 ) { \nif ( arr . getDouble ( i ) > 0 ) result [ i ] = true ; \nelse result [ i ] = false ; \n} \nreturn result ; \n} \n} \n"}
{"3783": "public class FunctionProperties { \npublic int asFlatProperties ( FlatBufferBuilder bufferBuilder ) { \nint iname = bufferBuilder . createString ( name ) ; \nint ii = FlatProperties . createIVector ( bufferBuilder , Ints . toArray ( i ) ) ; \nint il = FlatProperties . createLVector ( bufferBuilder , Longs . toArray ( l ) ) ; \nint id = FlatProperties . createDVector ( bufferBuilder , Doubles . toArray ( d ) ) ; \nint arrays [ ] = new int [ a . size ( ) ] ; \nint cnt = 0 ; \nfor ( val array : a ) { \nint off = array . toFlatArray ( bufferBuilder ) ; \narrays [ cnt = cnt + 1 ] = off ; \n} \nint ia = FlatProperties . createAVector ( bufferBuilder , arrays ) ; \nreturn FlatProperties . createFlatProperties ( bufferBuilder , iname , ii , il , id , ia ) ; \n} \n} \n"}
{"3784": "public class FunctionProperties { \npublic static FunctionProperties fromFlatProperties ( FlatProperties properties ) { \nval props = new FunctionProperties ( ) ; \nfor ( int e = 0 ; \ne < properties . iLength ( ) ; \ne = e + 1 ) props . getI ( ) . add ( properties . i ( e ) ) ; \nfor ( int e = 0 ; \ne < properties . lLength ( ) ; \ne = e + 1 ) props . getL ( ) . add ( properties . l ( e ) ) ; \nfor ( int e = 0 ; \ne < properties . dLength ( ) ; \ne = e + 1 ) props . getD ( ) . add ( properties . d ( e ) ) ; \nfor ( int e = 0 ; \ne < properties . iLength ( ) ; \ne = e + 1 ) props . getA ( ) . add ( Nd4j . createFromFlatArray ( properties . a ( e ) ) ) ; \nreturn props ; \n} \n} \n"}
{"3785": "public class FunctionProperties { \npublic static int asFlatProperties ( FlatBufferBuilder bufferBuilder , Collection < FunctionProperties > properties ) { \nint props [ ] = new int [ properties . size ( ) ] ; \nint cnt = 0 ; \nfor ( val p : properties ) props [ cnt = cnt + 1 ] = p . asFlatProperties ( bufferBuilder ) ; \nreturn FlatNode . createPropertiesVector ( bufferBuilder , props ) ; \n} \n} \n"}
{"3788": "public class MathUtils { \npublic static List < Double > mergeCoords ( List < Double > x , List < Double > y ) { \nif ( x . size ( ) != y . size ( ) ) throw new IllegalArgumentException ( \"Sample sizes must be the same for each data applyTransformToDestination.\" ) ; \nList < Double > ret = new ArrayList < Double > ( ) ; \nfor ( int i = 0 ; \ni < x . size ( ) ; \ni = i + 1 ) { \nret . add ( x . get ( i ) ) ; \nret . add ( y . get ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3797": "public class BaseNDArrayFactory { \nprotected static void validateConcat ( int dimension , INDArray ... arrs ) { \nif ( arrs [ 0 ] . isScalar ( ) ) { \nfor ( int i = 1 ; \ni < arrs . length ; \ni = i + 1 ) if ( ! arrs [ i ] . isScalar ( ) ) throw new IllegalArgumentException ( \"All arrays must have same dimensions\" ) ; \n} \nelse { \nint dims = arrs [ 0 ] . shape ( ) . length ; \nlong [ ] shape = ArrayUtil . removeIndex ( arrs [ 0 ] . shape ( ) , dimension ) ; \nfor ( int i = 1 ; \ni < arrs . length ; \ni = i + 1 ) { \nassert Arrays . equals ( shape , ArrayUtil . removeIndex ( arrs [ i ] . shape ( ) , dimension ) ) ; \nassert arrs [ i ] . shape ( ) . length == dims ; \n} \n} \n} \n} \n"}
{"3799": "public class BaseNDArrayFactory { \n@ Override public INDArray linspace ( int lower , int upper , int num ) { \ndouble [ ] data = new double [ num ] ; \nfor ( int i = 0 ; \ni < num ; \ni = i + 1 ) { \ndouble t = ( double ) i / ( num - 1 ) ; \ndata [ i ] = lower * ( 1 - t ) + t * upper ; \n} \nINDArray ret = Nd4j . create ( data . length ) ; \nif ( ret . isScalar ( ) ) return ret ; \nfor ( int i = 0 ; \ni < ret . length ( ) ; \ni = i + 1 ) ret . putScalar ( i , data [ i ] ) ; \nreturn ret ; \n} \n} \n"}
{"3801": "public class BaseNDArrayFactory { \n@ Override public INDArray bilinearProducts ( INDArray curr , INDArray in ) { \nassert curr . shape ( ) . length == 3 ; \nif ( in . columns ( ) != 1 ) { \nthrow new AssertionError ( \"Expected a column vector\" ) ; \n} \nif ( in . rows ( ) != curr . size ( curr . shape ( ) . length - 1 ) ) { \nthrow new AssertionError ( \"Number of rows in the input does not match number of columns in tensor\" ) ; \n} \nif ( curr . size ( curr . shape ( ) . length - 2 ) != curr . size ( curr . shape ( ) . length - 1 ) ) { \nthrow new AssertionError ( \"Can only perform this operation on a SimpleTensor with square slices\" ) ; \n} \nINDArray ret = Nd4j . create ( curr . slices ( ) , 1 ) ; \nINDArray inT = in . transpose ( ) ; \nfor ( int i = 0 ; \ni < curr . slices ( ) ; \ni = i + 1 ) { \nINDArray slice = curr . slice ( i ) ; \nINDArray inTTimesSlice = inT . mmul ( slice ) ; \nret . putScalar ( i , Nd4j . getBlasWrapper ( ) . dot ( inTTimesSlice , in ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3813": "public class DataSet { \n@ Override public void binarize ( double cutoff ) { \nINDArray linear = getFeatureMatrix ( ) . linearView ( ) ; \nfor ( int i = 0 ; \ni < getFeatures ( ) . length ( ) ; \ni = i + 1 ) { \ndouble curr = linear . getDouble ( i ) ; \nif ( curr > cutoff ) getFeatures ( ) . putScalar ( i , 1 ) ; \nelse getFeatures ( ) . putScalar ( i , 0 ) ; \n} \n} \n} \n"}
{"3814": "public class DataSet { \n@ Override public DataSet sample ( int numSamples , org . nd4j . linalg . api . rng . Random rng , boolean withReplacement ) { \nINDArray examples = Nd4j . create ( numSamples , getFeatures ( ) . columns ( ) ) ; \nINDArray outcomes = Nd4j . create ( numSamples , numOutcomes ( ) ) ; \nSet < Integer > added = new HashSet < > ( ) ; \nfor ( int i = 0 ; \ni < numSamples ; \ni = i + 1 ) { \nint picked = rng . nextInt ( numExamples ( ) ) ; \nif ( ! withReplacement ) while ( added . contains ( picked ) ) picked = rng . nextInt ( numExamples ( ) ) ; \nexamples . putRow ( i , get ( picked ) . getFeatures ( ) ) ; \noutcomes . putRow ( i , get ( picked ) . getLabels ( ) ) ; \n} \nreturn new DataSet ( examples , outcomes ) ; \n} \n} \n"}
{"3818": "public class StringUtils { \npublic static String arrayToString ( String [ ] strs ) { \nif ( strs . length == 0 ) { \nreturn \"\" ; \n} \nStringBuilder sbuf = new StringBuilder ( ) ; \nsbuf . append ( strs [ 0 ] ) ; \nfor ( int idx = 1 ; \nidx < strs . length ; \nidx = idx + 1 ) { \nsbuf . append ( \",\" ) ; \nsbuf . append ( strs [ idx ] ) ; \n} \nreturn sbuf . toString ( ) ; \n} \n} \n"}
{"3819": "public class StringUtils { \npublic static String byteToHexString ( byte [ ] bytes , int start , int end ) { \nif ( bytes == null ) { \nthrow new IllegalArgumentException ( \"bytes == null\" ) ; \n} \nStringBuilder s = new StringBuilder ( ) ; \nfor ( int i = start ; \ni < end ; \ni = i + 1 ) { \ns . append ( format ( \"%02x\" , bytes [ i ] ) ) ; \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"3821": "public class StringUtils { \npublic static String [ ] split ( String str , char escapeChar , char separator ) { \nif ( str == null ) { \nreturn null ; \n} \nArrayList < String > strList = new ArrayList < String > ( ) ; \nStringBuilder split = new StringBuilder ( ) ; \nint index = 0 ; \nwhile ( ( index = findNext ( str , separator , escapeChar , index , split ) ) >= 0 ) { \nindex = index + 1 ; \nstrList . add ( split . toString ( ) ) ; \nsplit . setLength ( 0 ) ; \n} \nstrList . add ( split . toString ( ) ) ; \nint last = strList . size ( ) ; \nwhile ( last = last - 1 >= 0 && \"\" . equals ( strList . get ( last ) ) ) { \nstrList . remove ( last ) ; \n} \nreturn strList . toArray ( new String [ strList . size ( ) ] ) ; \n} \n} \n"}
{"3822": "public class StringUtils { \npublic static String [ ] split ( String str , char separator ) { \nif ( str . isEmpty ( ) ) { \nreturn new String [ ] { \n\"\" } \n; \n} \nArrayList < String > strList = new ArrayList < String > ( ) ; \nint startIndex = 0 ; \nint nextIndex = 0 ; \nwhile ( ( nextIndex = str . indexOf ( separator , startIndex ) ) != - 1 ) { \nstrList . add ( str . substring ( startIndex , nextIndex ) ) ; \nstartIndex = nextIndex + 1 ; \n} \nstrList . add ( str . substring ( startIndex ) ) ; \nint last = strList . size ( ) ; \nwhile ( last = last - 1 >= 0 && \"\" . equals ( strList . get ( last ) ) ) { \nstrList . remove ( last ) ; \n} \nreturn strList . toArray ( new String [ strList . size ( ) ] ) ; \n} \n} \n"}
{"3823": "public class StringUtils { \npublic static int findNext ( String str , char separator , char escapeChar , int start , StringBuilder split ) { \nint numPreEscapes = 0 ; \nfor ( int i = start ; \ni < str . length ( ) ; \ni = i + 1 ) { \nchar curChar = str . charAt ( i ) ; \nif ( numPreEscapes == 0 && curChar == separator ) { \nreturn i ; \n} \nelse { \nsplit . append ( curChar ) ; \nnumPreEscapes = ( curChar == escapeChar ) ? ( numPreEscapes = numPreEscapes + 1 ) % 2 : 0 ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3838": "public class Shape { \npublic static INDArrayIndex [ ] toIndexes ( int [ ] indices ) { \nINDArrayIndex [ ] ret = new INDArrayIndex [ indices . length ] ; \nfor ( int i = 0 ; \ni < ret . length ; \ni = i + 1 ) ret [ i ] = new NDArrayIndex ( indices [ i ] ) ; \nreturn ret ; \n} \n} \n"}
{"3841": "public class NioUtil { \npublic static void copyAtStride ( int n , BufferType bufferType , ByteBuffer from , int fromOffset , int fromStride , ByteBuffer to , int toOffset , int toStride ) { \nByteBuffer fromView = from ; \nByteBuffer toView = to ; \nfromView . order ( ByteOrder . nativeOrder ( ) ) ; \ntoView . order ( ByteOrder . nativeOrder ( ) ) ; \nswitch ( bufferType ) { \ncase INT : IntBuffer fromInt = fromView . asIntBuffer ( ) ; \nIntBuffer toInt = toView . asIntBuffer ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nint put = fromInt . get ( fromOffset + i * fromStride ) ; \ntoInt . put ( toOffset + i * toStride , put ) ; \n} \nbreak ; \ncase FLOAT : FloatBuffer fromFloat = fromView . asFloatBuffer ( ) ; \nFloatBuffer toFloat = toView . asFloatBuffer ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nfloat put = fromFloat . get ( fromOffset + i * fromStride ) ; \ntoFloat . put ( toOffset + i * toStride , put ) ; \n} \nbreak ; \ncase DOUBLE : DoubleBuffer fromDouble = fromView . asDoubleBuffer ( ) ; \nDoubleBuffer toDouble = toView . asDoubleBuffer ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \ntoDouble . put ( toOffset + i * toStride , fromDouble . get ( fromOffset + i * fromStride ) ) ; \n} \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Only floats and double supported\" ) ; \n} \n} \n} \n"}
{"3855": "public class MultipleEpochsIterator { \n@ Override public DataSet next ( ) { \nif ( ! iter . hasNext ( ) && passes < numPasses ) { \npasses = passes + 1 ; \nbatch = 0 ; \nlog . info ( \"Epoch \" + passes + \" batch \" + batch ) ; \niter . reset ( ) ; \n} \nbatch = batch + 1 ; \nDataSet next = iter . next ( ) ; \nif ( preProcessor != null ) preProcessor . preProcess ( next ) ; \nreturn next ; \n} \n} \n"}
{"3856": "public class CpuLapack { \n@ Override public void sgeqrf ( int M , int N , INDArray A , INDArray R , INDArray INFO ) { \nINDArray tau = Nd4j . create ( N ) ; \nint status = LAPACKE_sgeqrf ( getColumnOrder ( A ) , M , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) { \nthrow new BlasException ( \"Failed to execute sgeqrf\" , status ) ; \n} \nif ( R != null ) { \nR . assign ( A . get ( NDArrayIndex . interval ( 0 , A . columns ( ) ) , NDArrayIndex . all ( ) ) ) ; \nINDArrayIndex ix [ ] = new INDArrayIndex [ 2 ] ; \nfor ( int i = 1 ; \ni < Math . min ( A . rows ( ) , A . columns ( ) ) ; \ni = i + 1 ) { \nix [ 0 ] = NDArrayIndex . point ( i ) ; \nix [ 1 ] = NDArrayIndex . interval ( 0 , i ) ; \nR . put ( ix , 0 ) ; \n} \n} \nstatus = LAPACKE_sorgqr ( getColumnOrder ( A ) , M , N , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) { \nthrow new BlasException ( \"Failed to execute sorgqr\" , status ) ; \n} \n} \n} \n"}
{"3860": "public class AsynchronousFlowController { \nprotected void sweepTail ( ) { \nInteger deviceId = allocator . getDeviceId ( ) ; \nint cnt = 0 ; \nlong lastCommandId = deviceClocks . get ( deviceId ) . get ( ) ; \nfor ( int l = 0 ; \nl < configuration . getCommandLanesNumber ( ) ; \nl = l + 1 ) { \nQueue < cudaEvent_t > queue = eventsBarrier . get ( deviceId ) . get ( l ) ; \nif ( queue . size ( ) >= MAX_EXECUTION_QUEUE || laneClocks . get ( deviceId ) . get ( l ) . get ( ) < lastCommandId - MAX_EXECUTION_QUEUE ) { \ncudaEvent_t event = queue . poll ( ) ; \nif ( event != null && ! event . isDestroyed ( ) ) { \nevent . synchronize ( ) ; \nevent . destroy ( ) ; \ncnt = cnt + 1 ; \n} \n} \n} \ndeviceClocks . get ( deviceId ) . incrementAndGet ( ) ; \n} \n} \n"}
{"3888": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray expi ( IComplexNDArray toExp ) { \nIComplexNDArray flattened = toExp . ravel ( ) ; \nfor ( int i = 0 ; \ni < flattened . length ( ) ; \ni = i + 1 ) { \nIComplexNumber n = flattened . getComplex ( i ) ; \nflattened . put ( i , Nd4j . scalar ( ComplexUtil . exp ( n ) ) ) ; \n} \nreturn flattened . reshape ( toExp . shape ( ) ) ; \n} \n} \n"}
{"3889": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray center ( IComplexNDArray arr , long [ ] shape ) { \nif ( arr . length ( ) < ArrayUtil . prod ( shape ) ) return arr ; \nfor ( int i = 0 ; \ni < shape . length ; \ni = i + 1 ) if ( shape [ i ] < 1 ) shape [ i ] = 1 ; \nINDArray shapeMatrix = NDArrayUtil . toNDArray ( shape ) ; \nINDArray currShape = NDArrayUtil . toNDArray ( arr . shape ( ) ) ; \nINDArray startIndex = Transforms . floor ( currShape . sub ( shapeMatrix ) . divi ( Nd4j . scalar ( 2 ) ) ) ; \nINDArray endIndex = startIndex . add ( shapeMatrix ) ; \nINDArrayIndex [ ] indexes = Indices . createFromStartAndEnd ( startIndex , endIndex ) ; \nif ( shapeMatrix . length ( ) > 1 ) return arr . get ( indexes ) ; \nelse { \nIComplexNDArray ret = Nd4j . createComplex ( new int [ ] { \n( int ) shapeMatrix . getDouble ( 0 ) } \n) ; \nint start = ( int ) startIndex . getDouble ( 0 ) ; \nint end = ( int ) endIndex . getDouble ( 0 ) ; \nint count = 0 ; \nfor ( int i = start ; \ni < end ; \ni = i + 1 ) { \nret . putScalar ( count = count + 1 , arr . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \n} \n} \n"}
{"3890": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray truncate ( IComplexNDArray nd , int n , int dimension ) { \nif ( nd . isVector ( ) ) { \nIComplexNDArray truncated = Nd4j . createComplex ( new int [ ] { \n1 , n } \n) ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) truncated . putScalar ( i , nd . getComplex ( i ) ) ; \nreturn truncated ; \n} \nif ( nd . size ( dimension ) > n ) { \nlong [ ] shape = ArrayUtil . copy ( nd . shape ( ) ) ; \nshape [ dimension ] = n ; \nIComplexNDArray ret = Nd4j . createComplex ( shape ) ; \nIComplexNDArray ndLinear = nd . linearView ( ) ; \nIComplexNDArray retLinear = ret . linearView ( ) ; \nfor ( int i = 0 ; \ni < ret . length ( ) ; \ni = i + 1 ) retLinear . putScalar ( i , ndLinear . getComplex ( i ) ) ; \nreturn ret ; \n} \nreturn nd ; \n} \n} \n"}
{"3893": "public class DeviceLocalNDArray { \npublic void broadcast ( INDArray array ) { \nif ( array == null ) return ; \nNd4j . getExecutioner ( ) . commit ( ) ; \nint numDevices = Nd4j . getAffinityManager ( ) . getNumberOfDevices ( ) ; \nfor ( int i = 0 ; \ni < numDevices ; \ni = i + 1 ) { \nif ( Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) == i ) { \nset ( i , array ) ; \n} \nelse { \nset ( i , Nd4j . getAffinityManager ( ) . replicateToDevice ( i , array ) ) ; \n} \n} \n} \n} \n"}
{"3895": "public class BigDecimalMath { \nstatic public BigDecimal gamma ( MathContext mc ) { \nif ( mc . getPrecision ( ) < GAMMA . precision ( ) ) { \nreturn GAMMA . round ( mc ) ; \n} \nelse { \ndouble eps = prec2err ( 0.577 , mc . getPrecision ( ) ) ; \nMathContext mcloc = new MathContext ( 2 + mc . getPrecision ( ) ) ; \nBigDecimal resul = BigDecimal . ONE ; \nresul = resul . add ( log ( 2 , mcloc ) ) ; \nresul = resul . subtract ( log ( 3 , mcloc ) ) ; \nint kmax = ( int ) ( ( Math . log ( eps / 0.7 ) - 2. ) / 4. ) ; \nmcloc = new MathContext ( 1 + err2prec ( 1.2 , eps / kmax ) ) ; \nfor ( int n = 1 ; \n; \nn = n + 1 ) { \nBigDecimal c = zeta ( 2 * n + 1 , mcloc ) . subtract ( BigDecimal . ONE ) ; \nBigInteger fourn = BigInteger . valueOf ( 2 * n + 1 ) ; \nfourn = fourn . shiftLeft ( 2 * n ) ; \nc = divideRound ( c , fourn ) ; \nresul = resul . subtract ( c ) ; \nif ( c . doubleValue ( ) < 0.1 * eps ) { \nbreak ; \n} \n} \nreturn resul . round ( mc ) ; \n} \n} \n} \n"}
{"3899": "public class BigDecimalMath { \nstatic public BigDecimal exp ( BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nfinal BigDecimal invx = exp ( x . negate ( ) ) ; \nMathContext mc = new MathContext ( invx . precision ( ) ) ; \nreturn BigDecimal . ONE . divide ( invx , mc ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; \n} \nelse { \nfinal double xDbl = x . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nif ( Math . pow ( xDbl , TAYLOR_NTERM ) < TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl ) { \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; \nfor ( int i = 1 ; \ni <= TAYLOR_NTERM ; \ni = i + 1 ) { \nifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; \nxpowi = xpowi . multiply ( x ) ; \nfinal BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( c ) ; \nif ( Math . abs ( xpowi . doubleValue ( ) ) < i && Math . abs ( c . doubleValue ( ) ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nint exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; \nBigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; \nBigDecimal expxby10 = exp ( xby10 ) ; \nMathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; \nwhile ( exSc > 0 ) { \nint exsub = Math . min ( 8 , exSc ) ; \nexSc -= exsub ; \nMathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; \nint pex = 1 ; \nwhile ( exsub = exsub - 1 > 0 ) { \npex *= 10 ; \n} \nexpxby10 = expxby10 . pow ( pex , mctmp ) ; \n} \nreturn expxby10 . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3903": "public class BigDecimalMath { \nstatic public BigDecimal sin ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn sin ( x . negate ( ) ) . negate ( ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal res = mod2pi ( x ) ; \ndouble errpi = 0.5 * Math . abs ( x . ulp ( ) . doubleValue ( ) ) ; \nint val = 2 + err2prec ( FastMath . PI , errpi ) ; \nMathContext mc = new MathContext ( val ) ; \nBigDecimal p = pi ( mc ) ; \nmc = new MathContext ( x . precision ( ) ) ; \nif ( res . compareTo ( p ) > 0 ) { \nreturn sin ( subtractRound ( res , p ) ) . negate ( ) ; \n} \nelse if ( res . multiply ( new BigDecimal ( 2 ) ) . compareTo ( p ) > 0 ) { \nreturn sin ( subtractRound ( p , res ) ) ; \n} \nelse { \nif ( res . multiply ( new BigDecimal ( 4 ) ) . compareTo ( p ) > 0 ) { \nreturn cos ( subtractRound ( p . divide ( new BigDecimal ( 2 ) ) , res ) ) ; \n} \nelse { \nBigDecimal resul = res ; \nBigDecimal xpowi = res ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = res . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( res . precision ( ) / Math . log10 ( 1.0 / res . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( res . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni = i + 1 ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( res ) . multiply ( res ) . negate ( ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nmc = new MathContext ( res . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n} \n"}
{"3904": "public class BigDecimalMath { \nstatic public BigDecimal tan ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn tan ( x . negate ( ) ) . negate ( ) ; \n} \nelse { \nBigDecimal res = modpi ( x ) ; \nfinal double xDbl = res . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) / 2. ; \nfinal double eps = xUlpDbl / 2. / Math . pow ( Math . cos ( xDbl ) , 2. ) ; \nif ( xDbl > 0.8 ) { \nBigDecimal co = cot ( x ) ; \nMathContext mc = new MathContext ( err2prec ( 1. / co . doubleValue ( ) , eps ) ) ; \nreturn BigDecimal . ONE . divide ( co , mc ) ; \n} \nelse { \nfinal BigDecimal xhighpr = scalePrec ( res , 2 ) ; \nfinal BigDecimal xhighprSq = multiplyRound ( xhighpr , xhighpr ) ; \nBigDecimal result = xhighpr . plus ( ) ; \nBigDecimal xpowi = xhighpr ; \nBernoulli b = new Bernoulli ( ) ; \nBigInteger fourn = BigInteger . valueOf ( 4 ) ; \nBigInteger fac = BigInteger . valueOf ( 2 ) ; \nfor ( int i = 2 ; \n; \ni = i + 1 ) { \nRational f = b . at ( 2 * i ) . abs ( ) ; \nfourn = fourn . shiftLeft ( 2 ) ; \nfac = fac . multiply ( BigInteger . valueOf ( 2 * i ) ) . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nf = f . multiply ( fourn ) . multiply ( fourn . subtract ( BigInteger . ONE ) ) . divide ( fac ) ; \nxpowi = multiplyRound ( xpowi , xhighprSq ) ; \nBigDecimal c = multiplyRound ( xpowi , f ) ; \nresult = result . add ( c ) ; \nif ( Math . abs ( c . doubleValue ( ) ) < 0.1 * eps ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( result . doubleValue ( ) , eps ) ) ; \nreturn result . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3905": "public class BigDecimalMath { \nstatic public BigDecimal cosh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn cos ( x . negate ( ) ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ONE ; \n} \nelse { \nif ( x . doubleValue ( ) > 1.5 ) { \nreturn hypot ( 1 , sinh ( x ) ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = 0.5 * x . ulp ( ) . doubleValue ( ) * x . doubleValue ( ) ; \nint k = ( int ) ( Math . log ( xUlpDbl ) / Math . log ( x . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni = i + 1 ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( resul . doubleValue ( ) , xUlpDbl ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3906": "public class BigDecimalMath { \nstatic public BigDecimal sinh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn sinh ( x . negate ( ) ) . negate ( ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nif ( x . doubleValue ( ) > 2.4 ) { \nBigDecimal two = new BigDecimal ( 2 ) ; \nBigDecimal xhalf = x . divide ( two ) ; \nBigDecimal resul = sinh ( xhalf ) . multiply ( cosh ( xhalf ) ) . multiply ( two ) ; \ndouble eps = Math . tanh ( x . doubleValue ( ) ) ; \nMathContext mc = new MathContext ( err2prec ( 0.5 * x . ulp ( ) . doubleValue ( ) / eps ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = xhighpr ; \nBigDecimal xpowi = xhighpr ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( x . precision ( ) / Math . log10 ( 1.0 / xhighpr . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( x . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni = i + 1 ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( x . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3910": "public class BigDecimalMath { \nstatic public BigDecimal Gamma ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn divideRound ( Gamma ( x . add ( BigDecimal . ONE ) ) , x ) ; \n} \nelse if ( x . doubleValue ( ) > 1.5 ) { \nint n = ( int ) ( x . doubleValue ( ) - 0.5 ) ; \nBigDecimal xmin1 = x . subtract ( new BigDecimal ( n ) ) ; \nreturn multiplyRound ( Gamma ( xmin1 ) , pochhammer ( xmin1 , n ) ) ; \n} \nelse { \nBigDecimal z = x . subtract ( BigDecimal . ONE ) ; \nz = scalePrec ( z , 2 ) ; \nMathContext mcloc = new MathContext ( z . precision ( ) ) ; \ndouble eps = x . ulp ( ) . doubleValue ( ) / x . doubleValue ( ) ; \nBigDecimal resul = log ( scalePrec ( x , 2 ) ) . negate ( ) ; \nif ( x . compareTo ( BigDecimal . ONE ) != 0 ) { \nBigDecimal gammCompl = BigDecimal . ONE . subtract ( gamma ( mcloc ) ) ; \nresul = resul . add ( multiplyRound ( z , gammCompl ) ) ; \nfor ( int n = 2 ; \n; \nn = n + 1 ) { \nBigDecimal c = divideRound ( z . pow ( n , mcloc ) , n ) ; \nMathContext m = new MathContext ( err2prec ( n * z . ulp ( ) . doubleValue ( ) / 2. / z . doubleValue ( ) ) ) ; \nc = c . round ( m ) ; \nif ( eps / 100. / c . doubleValue ( ) < 0.01 ) { \nm = new MathContext ( err2prec ( eps / 100. / c . doubleValue ( ) ) ) ; \n} \nelse { \nm = new MathContext ( 2 ) ; \n} \nBigDecimal zetm1 = zeta ( n , m ) . subtract ( BigDecimal . ONE ) ; \nc = multiplyRound ( c , zetm1 ) ; \nif ( n % 2 == 0 ) { \nresul = resul . add ( c ) ; \n} \nelse { \nresul = resul . subtract ( c ) ; \n} \nif ( Math . abs ( c . doubleValue ( ) ) < eps ) { \nbreak ; \n} \n} \n} \ndouble psi = 0.5772156649 ; \ndouble zdbl = z . doubleValue ( ) ; \nfor ( int n = 1 ; \nn < 5 ; \nn = n + 1 ) { \npsi += zdbl / n / ( n + zdbl ) ; \n} \neps = psi * x . ulp ( ) . doubleValue ( ) / 2. ; \nmcloc = new MathContext ( err2prec ( eps ) ) ; \nreturn exp ( resul ) . round ( mcloc ) ; \n} \n} \n} \n"}
{"3911": "public class BigDecimalMath { \nstatic protected BigDecimal broadhurstBBP ( final int n , final int p , final int a [ ] , MathContext mc ) { \ndouble x = 0.0 ; \nfor ( int k = 1 ; \nk < 10 ; \nk = k + 1 ) { \nx += a [ ( k - 1 ) % 8 ] / Math . pow ( 2. , p * ( k + 1 ) / 2 ) / Math . pow ( ( double ) k , n ) ; \n} \ndouble eps = prec2err ( x , mc . getPrecision ( ) ) ; \nint kmax = ( int ) ( 6.6 * mc . getPrecision ( ) / p ) ; \neps /= kmax ; \nBigDecimal res = BigDecimal . ZERO ; \nfor ( int c = 0 ; \n; \nc = c + 1 ) { \nRational r = new Rational ( ) ; \nfor ( int k = 0 ; \nk < 8 ; \nk = k + 1 ) { \nRational tmp = new Rational ( BigInteger . valueOf ( a [ k ] ) , BigInteger . valueOf ( ( 1 + 8 * c + k ) ) . pow ( n ) ) ; \nint pk1h = p * ( 2 + 8 * c + k ) / 2 ; \ntmp = tmp . divide ( BigInteger . ONE . shiftLeft ( pk1h ) ) ; \nr = r . add ( tmp ) ; \n} \nif ( Math . abs ( r . doubleValue ( ) ) < eps ) { \nbreak ; \n} \nMathContext mcloc = new MathContext ( 1 + err2prec ( r . doubleValue ( ) , eps ) ) ; \nres = res . add ( r . BigDecimalValue ( mcloc ) ) ; \n} \nreturn res . round ( mc ) ; \n} \n} \n"}
{"3918": "public class SameDiff { \npublic void putShapeForVarName ( String varName , long [ ] shape ) { \nif ( shape == null ) { \nthrow new ND4JIllegalStateException ( \"Shape must not be null!\" ) ; \n} \nif ( variableNameToShape . containsKey ( varName ) ) { \nthrow new ND4JIllegalStateException ( \"Shape for \" + varName + \" already exists!\" ) ; \n} \nfor ( int i = 0 ; \ni < shape . length ; \ni = i + 1 ) { \nif ( shape [ i ] < 1 ) { \naddAsPlaceHolder ( varName ) ; \nplaceHolderOriginalShapes . put ( varName , shape ) ; \nreturn ; \n} \n} \nvariableNameToShape . put ( varName , shape ) ; \n} \n} \n"}
{"3922": "public class SameDiff { \npublic void addOutgoingFor ( String [ ] varNames , DifferentialFunction function ) { \nif ( function . getOwnName ( ) == null ) throw new ND4JIllegalStateException ( \"Instance id can not be null. Function not initialized properly\" ) ; \nif ( outgoingArgsReverse . containsKey ( function . getOwnName ( ) ) ) { \nthrow new ND4JIllegalStateException ( \"Outgoing arguments already declared for \" + function ) ; \n} \nif ( varNames == null ) throw new ND4JIllegalStateException ( \"Var names can not be null!\" ) ; \nfor ( int i = 0 ; \ni < varNames . length ; \ni = i + 1 ) { \nif ( varNames [ i ] == null ) throw new ND4JIllegalStateException ( \"Variable name elements can not be null!\" ) ; \n} \noutgoingArgsReverse . put ( function . getOwnName ( ) , varNames ) ; \noutgoingArgs . put ( varNames , function ) ; \nfor ( val resultName : varNames ) { \nList < DifferentialFunction > funcs = functionOutputFor . get ( resultName ) ; \nif ( funcs == null ) { \nfuncs = new ArrayList < > ( ) ; \nfunctionOutputFor . put ( resultName , funcs ) ; \n} \nfuncs . add ( function ) ; \n} \n} \n} \n"}
{"3925": "public class SameDiff { \npublic INDArray [ ] eval ( Map < String , INDArray > inputs ) { \nSameDiff execPipeline = dup ( ) ; \nList < DifferentialFunction > opExecAction = execPipeline . exec ( ) . getRight ( ) ; \nif ( opExecAction . isEmpty ( ) ) throw new IllegalStateException ( \"No ops found to execute.\" ) ; \nINDArray [ ] ret = new INDArray [ opExecAction . size ( ) ] ; \nfor ( int i = 0 ; \ni < ret . length ; \ni = i + 1 ) { \nval varName = opExecAction . get ( i ) . outputVariables ( ) [ 0 ] . getVarName ( ) ; \nret [ i ] = execPipeline . getArrForVarName ( varName ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3929": "public class SameDiff { \npublic void removeArgFromFunction ( String varName , DifferentialFunction function ) { \nval args = function . args ( ) ; \nfor ( int i = 0 ; \ni < args . length ; \ni = i + 1 ) { \nif ( args [ i ] . getVarName ( ) . equals ( varName ) ) { \nval reverseArgs = incomingArgsReverse . get ( function . getOwnName ( ) ) ; \nincomingArgs . remove ( reverseArgs ) ; \nincomingArgsReverse . remove ( function . getOwnName ( ) ) ; \nval newArgs = new ArrayList < String > ( args . length - 1 ) ; \nfor ( int arg = 0 ; \narg < args . length ; \narg = arg + 1 ) { \nif ( ! reverseArgs [ arg ] . equals ( varName ) ) { \nnewArgs . add ( reverseArgs [ arg ] ) ; \n} \n} \nval newArgsArr = newArgs . toArray ( new String [ newArgs . size ( ) ] ) ; \nincomingArgs . put ( newArgsArr , function ) ; \nincomingArgsReverse . put ( function . getOwnName ( ) , newArgsArr ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"3933": "public class SameDiff { \npublic List < DifferentialFunction > exec ( List < DifferentialFunction > ops ) { \nfor ( int i = 0 ; \ni < ops . size ( ) ; \ni = i + 1 ) { \nOp op = ( Op ) ops . get ( i ) ; \nNd4j . getExecutioner ( ) . exec ( op ) ; \n} \nreturn ops ; \n} \n} \n"}
{"3960": "public class BaseDataFetcher { \nprotected void initializeCurrFromList ( List < DataSet > examples ) { \nif ( examples . isEmpty ( ) ) log . warn ( \"Warning: empty dataset from the fetcher\" ) ; \nINDArray inputs = createInputMatrix ( examples . size ( ) ) ; \nINDArray labels = createOutputMatrix ( examples . size ( ) ) ; \nfor ( int i = 0 ; \ni < examples . size ( ) ; \ni = i + 1 ) { \ninputs . putRow ( i , examples . get ( i ) . getFeatureMatrix ( ) ) ; \nlabels . putRow ( i , examples . get ( i ) . getLabels ( ) ) ; \n} \ncurr = new DataSet ( inputs , labels ) ; \n} \n} \n"}
{"3961": "public class AtomicAllocator { \nprotected void initHostCollectors ( ) { \nfor ( int i = 0 ; \ni < configuration . getNumberOfGcThreads ( ) ; \ni = i + 1 ) { \nReferenceQueue < BaseDataBuffer > queue = new ReferenceQueue < > ( ) ; \nUnifiedGarbageCollectorThread uThread = new UnifiedGarbageCollectorThread ( i , queue ) ; \nNd4j . getAffinityManager ( ) . attachThreadToDevice ( uThread , getDeviceId ( ) ) ; \nqueueMap . put ( i , queue ) ; \nuThread . start ( ) ; \ncollectorsUnified . put ( i , uThread ) ; \n} \n} \n} \n"}
{"3966": "public class NDArrayIndex { \npublic static INDArrayIndex [ ] create ( INDArray index ) { \nif ( index . isMatrix ( ) ) { \nif ( index . rows ( ) > Integer . MAX_VALUE ) throw new ND4JArraySizeException ( ) ; \nNDArrayIndex [ ] ret = new NDArrayIndex [ ( int ) index . rows ( ) ] ; \nfor ( int i = 0 ; \ni < index . rows ( ) ; \ni = i + 1 ) { \nINDArray row = index . getRow ( i ) ; \nval nums = new long [ ( int ) index . getRow ( i ) . columns ( ) ] ; \nfor ( int j = 0 ; \nj < row . columns ( ) ; \nj = j + 1 ) { \nnums [ j ] = ( int ) row . getFloat ( j ) ; \n} \nNDArrayIndex idx = new NDArrayIndex ( nums ) ; \nret [ i ] = idx ; \n} \nreturn ret ; \n} \nelse if ( index . isVector ( ) ) { \nlong [ ] indices = NDArrayUtil . toLongs ( index ) ; \nreturn new NDArrayIndex [ ] { \nnew NDArrayIndex ( indices ) } \n; \n} \nthrow new IllegalArgumentException ( \"Passed in ndarray must be a matrix or a vector\" ) ; \n} \n} \n"}
{"3969": "public class DifferentialFunction { \npublic List < SDVariable > diff ( List < SDVariable > i_v1 ) { \nList < SDVariable > vals = doDiff ( i_v1 ) ; \nif ( vals == null ) { \nthrow new IllegalStateException ( \"Error executing diff operation: doDiff returned null for op: \" + this . opName ( ) ) ; \n} \nval outputVars = args ( ) ; \nfor ( int i = 0 ; \ni < vals . size ( ) ; \ni = i + 1 ) { \nSDVariable var = outputVars [ i ] ; \nSDVariable grad = var . getGradient ( ) ; \nif ( grad != null ) { \nSDVariable gradVar = f ( ) . add ( grad , vals . get ( i ) ) ; \ntry { \nvals . set ( i , gradVar ) ; \n} \ncatch ( UnsupportedOperationException e ) { \nthrow new UnsupportedOperationException ( \"Use a mutable list when returning values from \" + this . getClass ( ) . getSimpleName ( ) + \".doDiff (e.g. Arrays.asList instead of Collections.singletonList)\" , e ) ; \n} \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \n} \nelse { \nSDVariable gradVar = vals . get ( i ) ; \nsameDiff . updateVariableNameAndReference ( gradVar , var . getVarName ( ) + \"-grad\" ) ; \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \nsameDiff . setForwardVariableForVarName ( gradVar . getVarName ( ) , var ) ; \n} \n} \nreturn vals ; \n} \n} \n"}
{"3975": "public class BaseComplexNDArray { \nprotected void copyRealTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse for ( int i = 0 ; \ni < linear . length ( ) ; \ni = i + 1 ) { \narr . putScalar ( i , thisLinear . getReal ( i ) ) ; \n} \n} \n} \n"}
{"3976": "public class BaseComplexNDArray { \nprotected void copyImagTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse for ( int i = 0 ; \ni < linear . length ( ) ; \ni = i + 1 ) { \narr . putScalar ( i , thisLinear . getImag ( i ) ) ; \n} \n} \n} \n"}
{"3977": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray epsi ( Number other ) { \nIComplexNDArray linear = linearView ( ) ; \ndouble otherVal = other . doubleValue ( ) ; \nfor ( int i = 0 ; \ni < linearView ( ) . length ( ) ; \ni = i + 1 ) { \nIComplexNumber n = linear . getComplex ( i ) ; \ndouble real = n . realComponent ( ) . doubleValue ( ) ; \ndouble diff = Math . abs ( real - otherVal ) ; \nif ( diff <= Nd4j . EPS_THRESHOLD ) linear . putScalar ( i , Nd4j . createDouble ( 1 , 0 ) ) ; \nelse linear . putScalar ( i , Nd4j . createDouble ( 0 , 0 ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3978": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray assign ( IComplexNDArray arr ) { \nif ( ! arr . isScalar ( ) ) LinAlgExceptions . assertSameLength ( this , arr ) ; \nIComplexNDArray linear = linearView ( ) ; \nIComplexNDArray otherLinear = arr . linearView ( ) ; \nfor ( int i = 0 ; \ni < linear . length ( ) ; \ni = i + 1 ) { \nlinear . putScalar ( i , otherLinear . getComplex ( i ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3979": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray getRows ( int [ ] rindices ) { \nINDArray rows = Nd4j . create ( rindices . length , columns ( ) ) ; \nfor ( int i = 0 ; \ni < rindices . length ; \ni = i + 1 ) { \nrows . putRow ( i , getRow ( rindices [ i ] ) ) ; \n} \nreturn ( IComplexNDArray ) rows ; \n} \n} \n"}
{"3981": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray putColumn ( int column , INDArray toPut ) { \nassert toPut . isVector ( ) && toPut . length ( ) == rows ( ) : \"Illegal length for row \" + toPut . length ( ) + \" should have been \" + columns ( ) ; \nIComplexNDArray r = getColumn ( column ) ; \nif ( toPut instanceof IComplexNDArray ) { \nIComplexNDArray putComplex = ( IComplexNDArray ) toPut ; \nfor ( int i = 0 ; \ni < r . length ( ) ; \ni = i + 1 ) { \nIComplexNumber n = putComplex . getComplex ( i ) ; \nr . putScalar ( i , n ) ; \n} \n} \nelse { \nfor ( int i = 0 ; \ni < r . length ( ) ; \ni = i + 1 ) r . putScalar ( i , Nd4j . createDouble ( toPut . getDouble ( i ) , 0 ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3985": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray addi ( INDArray other , INDArray result ) { \nIComplexNDArray cOther = ( IComplexNDArray ) other ; \nIComplexNDArray cResult = ( IComplexNDArray ) result ; \nif ( cOther . isScalar ( ) ) { \nreturn cResult . addi ( cOther . getComplex ( 0 ) , result ) ; \n} \nif ( isScalar ( ) ) { \nreturn cOther . addi ( getComplex ( 0 ) , result ) ; \n} \nif ( result == this ) { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , cOther , cResult ) ; \n} \nelse if ( result == other ) { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \nelse { \nINDArray resultLinear = result . linearView ( ) ; \nINDArray otherLinear = other . linearView ( ) ; \nINDArray linear = linearView ( ) ; \nfor ( int i = 0 ; \ni < resultLinear . length ( ) ; \ni = i + 1 ) { \nresultLinear . putScalar ( i , otherLinear . getDouble ( i ) + linear . getDouble ( i ) ) ; \n} \n} \nreturn ( IComplexNDArray ) result ; \n} \n} \n"}
{"3986": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray assign ( Number value ) { \nIComplexNDArray one = linearView ( ) ; \nfor ( int i = 0 ; \ni < one . length ( ) ; \ni = i + 1 ) one . putScalar ( i , Nd4j . createDouble ( value . doubleValue ( ) , 0 ) ) ; \nreturn this ; \n} \n} \n"}
{"3987": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray ravel ( ) { \nif ( length ( ) >= Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"length() can not be >= Integer.MAX_VALUE\" ) ; \nIComplexNDArray ret = Nd4j . createComplex ( ( int ) length ( ) , ordering ( ) ) ; \nIComplexNDArray linear = linearView ( ) ; \nfor ( int i = 0 ; \ni < length ( ) ; \ni = i + 1 ) { \nret . putScalar ( i , linear . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3993": "public class DistributedSgDotMessage { \n@ Override public void processMessage ( ) { \nSkipGramRequestMessage sgrm = new SkipGramRequestMessage ( w1 , w2 , rowsB , codes , negSamples , alpha , 119 ) ; \nif ( negSamples > 0 ) { \nint negatives [ ] = Arrays . copyOfRange ( rowsB , codes . length , rowsB . length ) ; \nsgrm . setNegatives ( negatives ) ; \n} \nsgrm . setTaskId ( this . taskId ) ; \nsgrm . setOriginatorId ( this . getOriginatorId ( ) ) ; \nSkipGramTrainer sgt = ( SkipGramTrainer ) trainer ; \nsgt . pickTraining ( sgrm ) ; \nint resultLength = codes . length + ( negSamples > 0 ? ( negSamples + 1 ) : 0 ) ; \nINDArray result = Nd4j . createUninitialized ( resultLength , 1 ) ; \nint e = 0 ; \nfor ( ; \ne < codes . length ; \ne = e + 1 ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1 ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nfor ( ; \ne < resultLength ; \ne = e + 1 ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1_NEGATIVE ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nif ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . AVERAGING ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) 1 , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . putMessage ( dot ) ; \n} \nelse if ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . SHARDED ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) voidConfiguration . getNumberOfShards ( ) , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . sendMessage ( dot ) ; \n} \n} \n} \n"}
{"4021": "public class GenericTypeReflector { \npublic static boolean isSuperType ( Type superType , Type subType ) { \nif ( superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType ) { \nClass < ? > superClass = erase ( superType ) ; \nType mappedSubType = getExactSuperType ( capture ( subType ) , superClass ) ; \nif ( mappedSubType == null ) { \nreturn false ; \n} \nelse if ( superType instanceof Class < ? > ) { \nreturn true ; \n} \nelse if ( mappedSubType instanceof Class < ? > ) { \nreturn true ; \n} \nelse if ( mappedSubType instanceof GenericArrayType ) { \nType superComponentType = getArrayComponentType ( superType ) ; \nassert superComponentType != null ; \nType mappedSubComponentType = getArrayComponentType ( mappedSubType ) ; \nassert mappedSubComponentType != null ; \nreturn isSuperType ( superComponentType , mappedSubComponentType ) ; \n} \nelse { \nassert mappedSubType instanceof ParameterizedType ; \nParameterizedType pMappedSubType = ( ParameterizedType ) mappedSubType ; \nassert pMappedSubType . getRawType ( ) == superClass ; \nParameterizedType pSuperType = ( ParameterizedType ) superType ; \nType [ ] superTypeArgs = pSuperType . getActualTypeArguments ( ) ; \nType [ ] subTypeArgs = pMappedSubType . getActualTypeArguments ( ) ; \nassert superTypeArgs . length == subTypeArgs . length ; \nfor ( int i = 0 ; \ni < superTypeArgs . length ; \ni = i + 1 ) { \nif ( ! contains ( superTypeArgs [ i ] , subTypeArgs [ i ] ) ) { \nreturn false ; \n} \n} \nreturn pSuperType . getOwnerType ( ) == null || isSuperType ( pSuperType . getOwnerType ( ) , pMappedSubType . getOwnerType ( ) ) ; \n} \n} \nelse if ( superType instanceof CaptureType ) { \nif ( superType . equals ( subType ) ) return true ; \nfor ( Type lowerBound : ( ( CaptureType ) superType ) . getLowerBounds ( ) ) { \nif ( isSuperType ( lowerBound , subType ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nelse if ( superType instanceof GenericArrayType ) { \nreturn isArraySupertype ( superType , subType ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented: \" + superType . getClass ( ) ) ; \n} \n} \n} \n"}
{"4022": "public class GenericTypeReflector { \nprivate static Type [ ] getExactDirectSuperTypes ( Type type ) { \nif ( type instanceof ParameterizedType || type instanceof Class ) { \nClass < ? > clazz ; \nif ( type instanceof ParameterizedType ) { \nclazz = ( Class < ? > ) ( ( ParameterizedType ) type ) . getRawType ( ) ; \n} \nelse { \nclazz = ( Class < ? > ) type ; \nif ( clazz . isArray ( ) ) return getArrayExactDirectSuperTypes ( clazz ) ; \n} \nType [ ] superInterfaces = clazz . getGenericInterfaces ( ) ; \nType superClass = clazz . getGenericSuperclass ( ) ; \nif ( superClass == null && superInterfaces . length == 0 && clazz . isInterface ( ) ) { \nreturn new Type [ ] { \nObject . class } \n; \n} \nType [ ] result ; \nint resultIndex ; \nif ( superClass == null ) { \nresult = new Type [ superInterfaces . length ] ; \nresultIndex = 0 ; \n} \nelse { \nresult = new Type [ superInterfaces . length + 1 ] ; \nresultIndex = 1 ; \nresult [ 0 ] = mapTypeParameters ( superClass , type ) ; \n} \nfor ( Type superInterface : superInterfaces ) { \nresult [ resultIndex = resultIndex + 1 ] = mapTypeParameters ( superInterface , type ) ; \n} \nreturn result ; \n} \nelse if ( type instanceof TypeVariable ) { \nTypeVariable < ? > tv = ( TypeVariable < ? > ) type ; \nreturn tv . getBounds ( ) ; \n} \nelse if ( type instanceof WildcardType ) { \nreturn ( ( WildcardType ) type ) . getUpperBounds ( ) ; \n} \nelse if ( type instanceof CaptureType ) { \nreturn ( ( CaptureType ) type ) . getUpperBounds ( ) ; \n} \nelse if ( type instanceof GenericArrayType ) { \nreturn getArrayExactDirectSuperTypes ( type ) ; \n} \nelse if ( type == null ) { \nthrow new NullPointerException ( ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented type: \" + type ) ; \n} \n} \n} \n"}
{"4040": "public class Path { \npublic int depth ( ) { \nint depth = 0 ; \nPath here = this ; \nwhile ( here != ROOT ) { \ndepth = depth + 1 ; \nhere = here . previous ; \n} \nreturn depth ; \n} \n} \n"}
{"4074": "public class Values { \npublic static void homogenizeIndexes ( final List < Value < ? > > list ) { \nif ( isIndexHomogeneous ( list ) ) return ; \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni = i + 1 ) { \nfinal Value < ? > value = list . get ( i ) ; \nif ( value . excludeFromIndexes ( ) ) list . set ( i , index ( value , true ) ) ; \n} \n} \n} \n"}
{"4079": "public class IfConditionGenerator { \npublic If < ? , ? > [ ] generateIfConditions ( Class < ? extends If < ? , ? > > [ ] ifClasses , Field field ) { \nif ( ifClasses . length == 0 ) return ALWAYS ; \nIf < ? , ? > [ ] result = new If < ? , ? > [ ifClasses . length ] ; \nfor ( int i = 0 ; \ni < ifClasses . length ; \ni = i + 1 ) { \nClass < ? extends If < ? , ? > > ifClass = ifClasses [ i ] ; \nresult [ i ] = this . createIf ( ifClass , field ) ; \nType valueType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 0 ] ) ; \nClass < ? > valueClass = GenericTypeReflector . erase ( valueType ) ; \nType pojoType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 1 ] ) ; \nClass < ? > pojoClass = GenericTypeReflector . erase ( pojoType ) ; \nif ( ! TypeUtils . isAssignableFrom ( valueClass , field . getType ( ) ) ) throw new IllegalStateException ( \"Cannot use If class \" + ifClass . getName ( ) + \" on \" + field + \" because you cannot assign \" + field . getType ( ) . getName ( ) + \" to \" + valueClass . getName ( ) ) ; \nif ( ! TypeUtils . isAssignableFrom ( pojoClass , field . getDeclaringClass ( ) ) ) throw new IllegalStateException ( \"Cannot use If class \" + ifClass . getName ( ) + \" on \" + field + \" because the containing class \" + field . getDeclaringClass ( ) . getName ( ) + \" is not compatible with \" + pojoClass . getName ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"4100": "public class OpenRtbUtils { \npublic static Iterable < Imp > impsWith ( BidRequest request , Predicate < Imp > impFilter ) { \ncheckNotNull ( impFilter ) ; \nList < Imp > imps = request . getImpList ( ) ; \nif ( imps . isEmpty ( ) || impFilter == IMP_ALL ) { \nreturn imps ; \n} \nelse if ( impFilter == IMP_NONE ) { \nreturn ImmutableList . of ( ) ; \n} \nboolean included = impFilter . test ( imps . get ( 0 ) ) ; \nint size = imps . size ( ) , i ; \nfor ( i = 1 ; \ni < size ; \ni = i + 1 ) { \nif ( impFilter . test ( imps . get ( i ) ) != included ) { \nbreak ; \n} \n} \nif ( i == size ) { \nreturn included ? imps : ImmutableList . < Imp > of ( ) ; \n} \nint headingSize = i ; \nreturn new FluentIterable < Imp > ( ) { \n@ Override public Iterator < Imp > iterator ( ) { \nIterator < Imp > unfiltered = imps . iterator ( ) ; \nreturn new AbstractIterator < Imp > ( ) { \nprivate int heading = 0 ; \n@ Override protected Imp computeNext ( ) { \nwhile ( unfiltered . hasNext ( ) ) { \nImp imp = unfiltered . next ( ) ; \nif ( ( heading = heading + 1 < headingSize ) ? included : impFilter . test ( imp ) ) { \nreturn imp ; \n} \n} \nreturn endOfData ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"4108": "public class ProtoUtils { \npublic static < M extends MessageLiteOrBuilder > List < M > filter ( List < M > objs , Predicate < M > filter ) { \ncheckNotNull ( filter ) ; \nfor ( int i = 0 ; \ni < objs . size ( ) ; \ni = i + 1 ) { \nif ( ! filter . test ( objs . get ( i ) ) ) { \nreturn filterFrom ( objs , filter , i ) ; \n} \n} \nreturn objs ; \n} \n} \n"}
{"4128": "public class MetadataTransfer { \npublic Metadata getMetaForOutlink ( String targetURL , String sourceURL , Metadata parentMD ) { \nMetadata md = _filter ( parentMD , mdToTransfer ) ; \nif ( trackPath ) { \nmd . addValue ( urlPathKeyName , sourceURL ) ; \n} \nif ( trackDepth ) { \nString existingDepth = md . getFirstValue ( depthKeyName ) ; \nint depth ; \ntry { \ndepth = Integer . parseInt ( existingDepth ) ; \n} \ncatch ( Exception e ) { \ndepth = 0 ; \n} \nmd . setValue ( depthKeyName , Integer . toString ( depth = depth + 1 ) ) ; \n} \nreturn md ; \n} \n} \n"}
{"4138": "public class CookieConverter { \npublic static List < Cookie > getCookies ( String [ ] cookiesStrings , URL targetURL ) { \nArrayList < Cookie > list = new ArrayList < Cookie > ( ) ; \nfor ( String cs : cookiesStrings ) { \nString name = null ; \nString value = null ; \nString expires = null ; \nString domain = null ; \nString path = null ; \nboolean secure = false ; \nString [ ] tokens = cs . split ( \";\" ) ; \nint equals = tokens [ 0 ] . indexOf ( \"=\" ) ; \nname = tokens [ 0 ] . substring ( 0 , equals ) ; \nvalue = tokens [ 0 ] . substring ( equals + 1 ) ; \nfor ( int i = 1 ; \ni < tokens . length ; \ni = i + 1 ) { \nString ti = tokens [ i ] . trim ( ) ; \nif ( ti . equalsIgnoreCase ( \"secure\" ) ) secure = true ; \nif ( ti . toLowerCase ( ) . startsWith ( \"path=\" ) ) { \npath = ti . substring ( 5 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"domain=\" ) ) { \ndomain = ti . substring ( 7 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"expires=\" ) ) { \nexpires = ti . substring ( 8 ) ; \n} \n} \nBasicClientCookie cookie = new BasicClientCookie ( name , value ) ; \nif ( domain != null ) { \ncookie . setDomain ( domain ) ; \nif ( ! checkDomainMatchToUrl ( domain , targetURL . getHost ( ) ) ) continue ; \n} \nif ( path != null ) { \ncookie . setPath ( path ) ; \nif ( ! path . equals ( \"\" ) && ! path . equals ( \"/\" ) && ! targetURL . getPath ( ) . startsWith ( path ) ) continue ; \n} \nif ( secure ) { \ncookie . setSecure ( secure ) ; \nif ( ! targetURL . getProtocol ( ) . equalsIgnoreCase ( \"https\" ) ) continue ; \n} \nif ( expires != null ) { \ntry { \nDate expirationDate = DATE_FORMAT . parse ( expires ) ; \ncookie . setExpiryDate ( expirationDate ) ; \nif ( cookie . isExpired ( new Date ( ) ) ) continue ; \ncookie . setExpiryDate ( expirationDate ) ; \n} \ncatch ( ParseException e ) { \n} \n} \nlist . add ( cookie ) ; \n} \nreturn list ; \n} \n} \n"}
{"4139": "public class CookieConverter { \npublic static boolean checkDomainMatchToUrl ( String cookieDomain , String urlHostName ) { \ntry { \nif ( cookieDomain . startsWith ( \".\" ) ) { \ncookieDomain = cookieDomain . substring ( 1 ) ; \n} \nString [ ] domainTokens = cookieDomain . split ( \"\\\\.\" ) ; \nString [ ] hostTokens = urlHostName . split ( \"\\\\.\" ) ; \nint tokenDif = hostTokens . length - domainTokens . length ; \nif ( tokenDif < 0 ) { \nreturn false ; \n} \nfor ( int i = domainTokens . length - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nif ( ! domainTokens [ i ] . equalsIgnoreCase ( hostTokens [ i + tokenDif ] ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \ncatch ( Exception e ) { \nreturn true ; \n} \n} \n} \n"}
{"4142": "public class RobotsTags { \npublic void extractMetaTags ( DocumentFragment doc ) throws XPathExpressionException { \nNodeList nodes = ( NodeList ) expression . evaluate ( doc , XPathConstants . NODESET ) ; \nif ( nodes == null ) return ; \nint numNodes = nodes . getLength ( ) ; \nfor ( int i = 0 ; \ni < numNodes ; \ni = i + 1 ) { \nNode n = ( Node ) nodes . item ( i ) ; \nboolean isRobots = false ; \nString content = null ; \nNamedNodeMap attrs = n . getAttributes ( ) ; \nfor ( int att = 0 ; \natt < attrs . getLength ( ) ; \natt = att + 1 ) { \nNode keyval = attrs . item ( att ) ; \nif ( \"name\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) && \"robots\" . equalsIgnoreCase ( keyval . getNodeValue ( ) ) ) { \nisRobots = true ; \ncontinue ; \n} \nif ( \"content\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) ) { \ncontent = keyval . getNodeValue ( ) ; \ncontinue ; \n} \n} \nif ( isRobots && content != null ) { \nString [ ] vals = content . split ( \" *, *\" ) ; \nparseValues ( vals ) ; \nreturn ; \n} \n} \n} \n} \n"}
{"4144": "public class Rules { \npublic boolean filter ( String url , Metadata metadata ) throws MalformedURLException { \nURL u = new URL ( url ) ; \nString hostname = u . getHost ( ) ; \nif ( checkScope ( hostNameRules . get ( hostname ) , u ) ) { \nreturn true ; \n} \nString [ ] domainParts = hostname . split ( \"\\\\.\" ) ; \nString domain = null ; \nfor ( int i = domainParts . length - 1 ; \ni >= 0 ; \ni = i - 1 ) { \ndomain = domainParts [ i ] + ( domain == null ? \"\" : \".\" + domain ) ; \nif ( checkScope ( domainRules . get ( domain ) , u ) ) { \nreturn true ; \n} \n} \nfor ( MDScope scope : metadataRules ) { \nString [ ] vals = metadata . getValues ( scope . getKey ( ) ) ; \nif ( vals == null ) { \ncontinue ; \n} \nfor ( String v : vals ) { \nif ( v . equalsIgnoreCase ( scope . getValue ( ) ) ) { \nFastURLFilter . LOG . debug ( \"Filtering {} matching metadata {}:{}\" , url , scope . getKey ( ) , scope . getValue ( ) ) ; \nif ( checkScope ( scope , u ) ) { \nreturn true ; \n} \n} \n} \n} \nif ( checkScope ( globalRules , u ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4176": "public class ArrayChar { \npublic void setString ( String val ) { \nint rank = getRank ( ) ; \nif ( rank != 1 ) throw new IllegalArgumentException ( \"ArayChar.setString rank must be 1\" ) ; \nint arrayLen = indexCalc . getShape ( 0 ) ; \nint strLen = Math . min ( val . length ( ) , arrayLen ) ; \nfor ( int k = 0 ; \nk < strLen ; \nk = k + 1 ) storage [ k ] = val . charAt ( k ) ; \nchar c = 0 ; \nfor ( int k = strLen ; \nk < arrayLen ; \nk = k + 1 ) storage [ k ] = c ; \n} \n} \n"}
{"4178": "public class ArrayChar { \npublic static ArrayChar makeFromString ( String s , int max ) { \nArrayChar result = new ArrayChar . D1 ( max ) ; \nfor ( int i = 0 ; \ni < max && i < s . length ( ) ; \ni = i + 1 ) result . setChar ( i , s . charAt ( i ) ) ; \nreturn result ; \n} \n} \n"}
{"4180": "public class ArrayChar { \npublic static ArrayChar makeFromStringArray ( ArrayObject values , int strlen ) { \ntry { \nSection section = new Section ( values . getShape ( ) ) ; \nsection . appendRange ( strlen ) ; \nint [ ] shape = section . getShape ( ) ; \nlong size = section . computeSize ( ) ; \nchar [ ] cdata = new char [ ( int ) size ] ; \nint start = 0 ; \nIndexIterator ii = values . getIndexIterator ( ) ; \nwhile ( ii . hasNext ( ) ) { \nString s = ( String ) ii . next ( ) ; \nfor ( int k = 0 ; \nk < s . length ( ) && k < strlen ; \nk = k + 1 ) cdata [ start + k ] = s . charAt ( k ) ; \nstart += strlen ; \n} \nArray carr = Array . factory ( DataType . CHAR , shape , cdata ) ; \nreturn ( ArrayChar ) carr ; \n} \ncatch ( InvalidRangeException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \n} \n"}
{"4185": "public class Grib1RecordScanner { \npublic static void main ( String [ ] args ) throws IOException { \nint count = 0 ; \nString file = ( args . length > 0 ) ? args [ 0 ] : \"Q:/cdmUnitTest/formats/grib1/ECMWF.hybrid.grib1\" ; \nRandomAccessFile raf = new RandomAccessFile ( file , \"r\" ) ; \nSystem . out . printf ( \"Read %s%n\" , raf . getLocation ( ) ) ; \nGrib1RecordScanner scan = new Grib1RecordScanner ( raf ) ; \nwhile ( scan . hasNext ( ) ) { \nscan . next ( ) ; \ncount = count + 1 ; \n} \nraf . close ( ) ; \nSystem . out . printf ( \"count=%d%n\" , count ) ; \n} \n} \n"}
{"4197": "public class GridUI { \npublic void addMapBean ( MapBean mb ) { \nmapBeanMenu . addAction ( mb . getActionDesc ( ) , mb . getIcon ( ) , mb . getAction ( ) ) ; \nif ( mapBeanCount == 0 ) { \nsetMapRenderer ( mb . getRenderer ( ) ) ; \n} \nmapBeanCount = mapBeanCount + 1 ; \nmb . addPropertyChangeListener ( new PropertyChangeListener ( ) { \npublic void propertyChange ( java . beans . PropertyChangeEvent e ) { \nif ( e . getPropertyName ( ) . equals ( \"Renderer\" ) ) { \nsetMapRenderer ( ( Renderer ) e . getNewValue ( ) ) ; \n} \n} \n} \n) ; \n} \n} \n"}
{"4227": "public class GradsAttribute { \npublic static GradsAttribute parseAttribute ( String attrSpec ) { \nString [ ] toks = attrSpec . split ( \"\\\\s+\" ) ; \nStringBuffer buf = new StringBuffer ( ) ; \nfor ( int i = 4 ; \ni < toks . length ; \ni = i + 1 ) { \nbuf . append ( toks [ i ] ) ; \nbuf . append ( \" \" ) ; \n} \nreturn new GradsAttribute ( toks [ 1 ] , toks [ 2 ] , toks [ 3 ] , buf . toString ( ) . trim ( ) ) ; \n} \n} \n"}
{"4232": "public class N3iosp { \npublic static String makeValidNetcdfObjectName ( String name ) { \nStringBuilder sb = new StringBuilder ( name ) ; \nwhile ( sb . length ( ) > 0 ) { \nint cp = sb . codePointAt ( 0 ) ; \nif ( cp <= 0x7f ) { \nif ( ! ( 'A' <= cp && cp <= 'Z' ) && ! ( 'a' <= cp && cp <= 'z' ) && ! ( '0' <= cp && cp <= '9' ) && cp != '_' ) { \nsb . deleteCharAt ( 0 ) ; \ncontinue ; \n} \n} \nbreak ; \n} \nfor ( int pos = 1 ; \npos < sb . length ( ) ; \npos = pos + 1 ) { \nint cp = sb . codePointAt ( pos ) ; \nif ( cp <= 0x7F ) { \nif ( cp < ' ' || cp > 0x7E || cp == '/' ) { \nsb . deleteCharAt ( pos ) ; \npos = pos - 1 ; \n} \n} \n} \nwhile ( sb . length ( ) > 0 ) { \nint cp = sb . codePointAt ( sb . length ( ) - 1 ) ; \nif ( cp <= 0x7f && Character . isWhitespace ( cp ) ) { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \nelse { \nbreak ; \n} \n} \nif ( sb . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( String . format ( \"Illegal NetCDF object name: '%s'\" , name ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"4235": "public class N3iosp { \nprivate ucar . ma2 . Array readRecordData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException { \nRange recordRange = section . getRange ( 0 ) ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nN3header . Vinfo vinfo = ( N3header . Vinfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( ( int ) ( vinfo . begin - header . recStart ) ) ; \n} \nif ( header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"Cant read records when recsize > \" + Integer . MAX_VALUE ) ; \nlong nrecs = section . computeSize ( ) ; \nif ( nrecs * header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( \"Too large read: nrecs * recsize= \" + ( nrecs * header . recsize ) + \"bytes exceeds \" + Integer . MAX_VALUE ) ; \nmembers . setStructureSize ( ( int ) header . recsize ) ; \nArrayStructureBB structureArray = new ArrayStructureBB ( members , new int [ ] { \nrecordRange . length ( ) } \n) ; \nbyte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; \nint count = 0 ; \nfor ( int recnum : recordRange ) { \nif ( debugRecord ) System . out . println ( \" read record \" + recnum ) ; \nraf . seek ( header . recStart + recnum * header . recsize ) ; \nif ( recnum != header . numrecs - 1 ) raf . readFully ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \nelse raf . read ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \ncount = count + 1 ; \n} \nreturn structureArray ; \n} \n} \n"}
{"4240": "public class GradsTimeDimension { \npublic static boolean hasTimeTemplate ( String template ) { \nfor ( int i = 0 ; \ni < timeTemplates . length ; \ni = i + 1 ) { \nif ( template . indexOf ( timeTemplates [ i ] ) >= 0 ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4254": "public class ThreddsDatasetChooser { \npublic static void main ( String args [ ] ) { \nboolean usePopup = false ; \nfor ( int i = 0 ; \ni < args . length ; \ni = i + 1 ) { \nif ( args [ i ] . equals ( \"-usePopup\" ) ) usePopup = true ; \n} \ntry { \nstore = XMLStore . createFromFile ( \"ThreddsDatasetChooser\" , null ) ; \np = store . getPreferences ( ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"XMLStore Creation failed \" + e ) ; \n} \nfinal JFrame frame = new JFrame ( \"Thredds Dataset Chooser\" ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \npublic void windowClosing ( WindowEvent e ) { \nchooser . save ( ) ; \nRectangle bounds = frame . getBounds ( ) ; \np . putBeanObject ( FRAME_SIZE , bounds ) ; \ntry { \nstore . save ( ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \n} \nSystem . exit ( 0 ) ; \n} \n} \n) ; \nchooser = new ThreddsDatasetChooser ( p , null , frame , true , usePopup , false ) ; \nchooser . setDoResolve ( true ) ; \nframe . getContentPane ( ) . add ( chooser ) ; \nRectangle bounds = ( Rectangle ) p . getBean ( FRAME_SIZE , new Rectangle ( 50 , 50 , 800 , 450 ) ) ; \nframe . setBounds ( bounds ) ; \nframe . pack ( ) ; \nframe . setBounds ( bounds ) ; \nframe . setVisible ( true ) ; \n} \n} \n"}
{"4258": "public class SerialWriter { \npublic void writeAtomicArray ( DapType daptype , Object values ) throws IOException { \nassert values != null && values . getClass ( ) . isArray ( ) ; \nByteBuffer buf = SerialWriter . encodeArray ( daptype , values , this . order ) ; \nbyte [ ] bytes = buf . array ( ) ; \nint len = buf . position ( ) ; \nwriteBytes ( bytes , len ) ; \nif ( DEBUG ) { \nSystem . err . printf ( \"%s: \" , daptype . getShortName ( ) ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nint x = ( int ) ( order == ByteOrder . BIG_ENDIAN ? bytes [ i ] : bytes [ ( len - 1 ) - i ] ) ; \nSystem . err . printf ( \"%02x\" , ( int ) ( x & 0xff ) ) ; \n} \nSystem . err . println ( ) ; \n} \n} \n} \n"}
{"4259": "public class SerialWriter { \npublic void writeBytes ( byte [ ] bytes , int len ) throws IOException { \noutputBytes ( bytes , 0 , len ) ; \nif ( this . checksummode . enabled ( ChecksumMode . DAP ) ) { \nthis . checksum . update ( bytes , 0 , len ) ; \nif ( DUMPCSUM ) { \nSystem . err . print ( \"SSS \" ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nSystem . err . printf ( \"%02x\" , bytes [ i ] ) ; \n} \nSystem . err . println ( ) ; \n} \n} \n} \n} \n"}
{"4260": "public class SerialWriter { \npublic void outputBytes ( byte [ ] bytes , int start , int count ) throws IOException { \nif ( DUMPDATA ) { \nSystem . err . printf ( \"output %d/%d:\" , start , count ) ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nSystem . err . printf ( \" %02x\" , bytes [ i ] ) ; \n} \nSystem . err . println ( \"\" ) ; \nSystem . err . flush ( ) ; \n} \noutput . write ( bytes , start , count ) ; \n} \n} \n"}
{"4267": "public class McIDASGridReader { \npublic float [ ] readGrid ( McIDASGridRecord gr ) throws IOException { \nfloat [ ] data ; \nint te = ( gr . getOffsetToHeader ( ) + 64 ) * 4 ; \nint rows = gr . getRows ( ) ; \nint cols = gr . getColumns ( ) ; \nrf . seek ( te ) ; \nfloat scale = ( float ) gr . getParamScale ( ) ; \ndata = new float [ rows * cols ] ; \nrf . order ( needToSwap ? RandomAccessFile . LITTLE_ENDIAN : RandomAccessFile . BIG_ENDIAN ) ; \nfor ( int nc = 0 ; \nnc < cols ; \nnc = nc + 1 ) { \nfor ( int nr = 0 ; \nnr < rows ; \nnr = nr + 1 ) { \nint temp = rf . readInt ( ) ; \ndata [ ( rows - nr - 1 ) * cols + nc ] = ( temp == McIDASUtil . MCMISSING ) ? Float . NaN : ( ( float ) temp ) / scale ; \n} \n} \nrf . order ( RandomAccessFile . BIG_ENDIAN ) ; \nreturn data ; \n} \n} \n"}
{"4268": "public class McIDASGridReader { \npublic static void main ( String [ ] args ) throws IOException { \nString file = \"GRID2001\" ; \nif ( args . length > 0 ) { \nfile = args [ 0 ] ; \n} \nMcIDASGridReader mg = new McIDASGridReader ( file ) ; \nGridIndex gridIndex = mg . getGridIndex ( ) ; \nList grids = gridIndex . getGridRecords ( ) ; \nSystem . out . println ( \"found \" + grids . size ( ) + \" grids\" ) ; \nint num = Math . min ( grids . size ( ) , 10 ) ; \nfor ( int i = 0 ; \ni < num ; \ni = i + 1 ) { \nSystem . out . println ( grids . get ( i ) ) ; \n} \n} \n} \n"}
{"4273": "public class LogReader { \npublic void scanLogFile ( File file , Closure closure , LogFilter logf , Stats stat ) throws IOException { \ntry ( InputStream ios = new FileInputStream ( file ) ) { \nSystem . out . printf ( \"-----Reading %s %n\" , file . getPath ( ) ) ; \nBufferedReader dataIS = new BufferedReader ( new InputStreamReader ( ios , CDM . utf8Charset ) , 40 * 1000 ) ; \nint total = 0 ; \nint count = 0 ; \nwhile ( ( maxLines < 0 ) || ( count < maxLines ) ) { \nLog log = parser . nextLog ( dataIS ) ; \nif ( log == null ) break ; \ntotal = total + 1 ; \nif ( ( logf != null ) && ! logf . pass ( log ) ) continue ; \nclosure . process ( log ) ; \ncount = count + 1 ; \n} \nif ( stat != null ) { \nstat . total += total ; \nstat . passed += count ; \n} \nSystem . out . printf ( \"----- %s total requests=%d passed=%d %n\" , file . getPath ( ) , total , count ) ; \n} \n} \n} \n"}
{"4277": "public class GempakGridReader { \nprivate synchronized float [ ] unpackData ( int iiword , int nword , int ipktyp , int kxky , int nbits , float ref , float scale , boolean miss , float difmin , int kx , int decimalScale ) throws IOException { \nif ( ipktyp == MDGGRB ) { \nif ( ! useDP ) { \nreturn unpackGrib1Data ( iiword , nword , kxky , nbits , ref , scale , miss , decimalScale ) ; \n} \nelse { \nif ( nword * 32 < kxky * nbits ) { \nnword = nword + 1 ; \n} \nint [ ] ksgrid = new int [ nword ] ; \nDM_RINT ( iiword , ksgrid ) ; \nreturn DP_UGRB ( ksgrid , kxky , nbits , ref , scale , miss , decimalScale ) ; \n} \n} \nelse if ( ipktyp == MDGNMC ) { \nreturn null ; \n} \nelse if ( ipktyp == MDGDIF ) { \nreturn null ; \n} \nreturn null ; \n} \n} \n"}
{"4278": "public class GempakGridReader { \nprivate synchronized float [ ] DP_UGRB ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalScale ) throws IOException { \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfloat [ ] grid = new float [ kxky ] ; \nif ( ( nbits <= 1 ) || ( nbits > 31 ) ) { \nreturn grid ; \n} \nif ( scale == 0. ) { \nreturn grid ; \n} \nint imax = ( int ) ( Math . pow ( 2 , nbits ) - 1 ) ; \nint iword = 0 ; \nint ibit = 1 ; \nfor ( int i = 0 ; \ni < kxky ; \ni = i + 1 ) { \nint jshft = nbits + ibit - 33 ; \nint idat = 0 ; \nidat = ( jshft < 0 ) ? idata [ iword ] >>> Math . abs ( jshft ) : idata [ iword ] << jshft ; \nidat = idat & imax ; \nif ( jshft > 0 ) { \njshft -= 32 ; \nint idat2 = 0 ; \nidat2 = idata [ iword + 1 ] >>> Math . abs ( jshft ) ; \nidat = idat | idat2 ; \n} \nif ( ( idat == imax ) && misflg ) { \ngrid [ i ] = RMISSD ; \n} \nelse { \ngrid [ i ] = ( qmin + idat * scale ) * scaleFactor ; \n} \nibit += nbits ; \nif ( ibit > 32 ) { \nibit -= 32 ; \niword = iword + 1 ; \n} \n} \nreturn grid ; \n} \n} \n"}
{"4279": "public class GempakGridReader { \nprivate float [ ] unpackGrib1Data ( int iiword , int nword , int kxky , int nbits , float ref , float scale , boolean miss , int decimalScale ) throws IOException { \nfloat [ ] values = new float [ kxky ] ; \nbitPos = 0 ; \nbitBuf = 0 ; \nnext = 0 ; \nch1 = 0 ; \nch2 = 0 ; \nch3 = 0 ; \nch4 = 0 ; \nrf . seek ( getOffset ( iiword ) ) ; \nint idat ; \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfor ( int i = 0 ; \ni < values . length ; \ni = i + 1 ) { \nidat = bits2UInt ( nbits ) ; \nif ( miss && ( idat == IMISSD ) ) { \nvalues [ i ] = IMISSD ; \n} \nelse { \nvalues [ i ] = ( ref + scale * idat ) * scaleFactor ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4282": "public class GempakGridReader { \nprivate void getNextByte ( ) throws IOException { \nif ( ! needToSwap ) { \nbitBuf = rf . read ( ) ; \n} \nelse { \nif ( next == 3 ) { \nbitBuf = ch3 ; \n} \nelse if ( next == 2 ) { \nbitBuf = ch2 ; \n} \nelse if ( next == 1 ) { \nbitBuf = ch1 ; \n} \nelse { \nch1 = rf . read ( ) ; \nch2 = rf . read ( ) ; \nch3 = rf . read ( ) ; \nch4 = rf . read ( ) ; \nbitBuf = ch4 ; \nnext = 4 ; \n} \nnext = next - 1 ; \n} \n} \n} \n"}
{"4291": "public class DownloadController { \nstatic protected String escapeString ( String s ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni = i + 1 ) { \nint c = s . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : buf . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : buf . append ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '\\n' : buf . append ( '\\n' ) ; \nbreak ; \ncase '\\r' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\t' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\f' : buf . append ( '\\f' ) ; \nbreak ; \ndefault : if ( c < ' ' ) buf . append ( String . format ( \"\\\\x%02x\" , ( c & 0xff ) ) ) ; \nelse buf . append ( ( char ) c ) ; \nbreak ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4292": "public class CDMUtil { \nstatic public List < Slice > createSlices ( List < Range > rangelist ) throws dap4 . core . util . DapException { \nList < Slice > slices = new ArrayList < Slice > ( rangelist . size ( ) ) ; \nfor ( int i = 0 ; \ni < rangelist . size ( ) ; \ni = i + 1 ) { \nRange r = rangelist . get ( i ) ; \nint stride = r . stride ( ) ; \nint first = r . first ( ) ; \nint n = r . length ( ) ; \nint stop = first + ( n * stride ) ; \nSlice cer = new Slice ( first , stop - 1 , stride ) ; \nslices . add ( cer ) ; \n} \nreturn slices ; \n} \n} \n"}
{"4295": "public class CDMUtil { \nstatic public int [ ] computeEffectiveShape ( List < DapDimension > dimset ) { \nif ( dimset == null || dimset . size ( ) == 0 ) return new int [ 0 ] ; \nint effectiverank = dimset . size ( ) ; \nint [ ] shape = new int [ effectiverank ] ; \nfor ( int i = 0 ; \ni < effectiverank ; \ni = i + 1 ) { \nshape [ i ] = ( int ) dimset . get ( i ) . getSize ( ) ; \n} \nreturn shape ; \n} \n} \n"}
{"4302": "public class ScaledUnit { \npublic float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { \nfinal float scale = ( float ) getScale ( ) ; \nfor ( int i = input . length ; \ni = i - 1 >= 0 ; \n) { \noutput [ i ] = input [ i ] * scale ; \n} \nif ( ! ( _unit instanceof DerivableUnit ) ) { \nthrow new ConversionException ( this , getDerivedUnit ( ) ) ; \n} \nreturn ( ( DerivableUnit ) getUnit ( ) ) . toDerivedUnit ( output , output ) ; \n} \n} \n"}
{"4313": "public class MFlowLayout { \npublic Dimension preferredLayoutSize ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nDimension dim = new Dimension ( 0 , 0 ) ; \nfor ( int i = 0 ; \ni < target . getComponentCount ( ) ; \ni = i + 1 ) { \nComponent m = target . getComponent ( i ) ; \nif ( m . isVisible ( ) ) { \nDimension d = m . getPreferredSize ( ) ; \nPoint p = m . getLocation ( ) ; \ndim . width = Math . max ( dim . width , p . x + d . width ) ; \ndim . height = Math . max ( dim . height , p . y + d . height ) ; \n} \n} \nInsets insets = target . getInsets ( ) ; \ndim . width += insets . left + insets . right + getHgap ( ) * 2 ; \ndim . height += insets . top + insets . bottom + getVgap ( ) * 2 ; \nreturn dim ; \n} \n} \n} \n"}
{"4314": "public class CatalogBuilderHelper { \nstatic CrawlableDataset verifyDescendantDataset ( CrawlableDataset ancestorCrDs , String path , CrawlableDatasetFilter filter ) { \nif ( ! ancestorCrDs . isCollection ( ) ) throw new IllegalArgumentException ( \"Ancestor dataset <\" + ancestorCrDs . getPath ( ) + \"> not a collection.\" ) ; \nif ( ! path . startsWith ( ancestorCrDs . getPath ( ) ) ) throw new IllegalArgumentException ( \"Dataset path <\" + path + \"> not descendant of given dataset <\" + ancestorCrDs . getPath ( ) + \">.\" ) ; \nif ( path . length ( ) == ancestorCrDs . getPath ( ) . length ( ) ) return ancestorCrDs ; \nString remainingPath = path . substring ( ancestorCrDs . getPath ( ) . length ( ) ) ; \nif ( remainingPath . startsWith ( \"/\" ) ) remainingPath = remainingPath . substring ( 1 ) ; \nString [ ] pathSegments = remainingPath . split ( \"/\" ) ; \nCrawlableDataset curCrDs = ancestorCrDs ; \nfor ( int i = 0 ; \ni < pathSegments . length ; \ni = i + 1 ) { \ncurCrDs = curCrDs . getDescendant ( pathSegments [ i ] ) ; \nif ( filter != null ) if ( ! filter . accept ( curCrDs ) ) return null ; \n} \nif ( ! curCrDs . exists ( ) ) return null ; \nreturn curCrDs ; \n} \n} \n"}
{"4321": "public class UnitDimension { \npublic QuantityDimension getQuantityDimension ( ) { \nFactor [ ] factors = getFactors ( ) ; \nfor ( int i = factors . length ; \ni = i - 1 >= 0 ; \n) { \nFactor factor = factors [ i ] ; \nfactors [ i ] = new Factor ( ( ( BaseUnit ) factor . getBase ( ) ) . getBaseQuantity ( ) , factor . getExponent ( ) ) ; \n} \nreturn new QuantityDimension ( factors ) ; \n} \n} \n"}
{"4326": "public class SigmetIOServiceProvider { \npublic long readToByteChannel11 ( ucar . nc2 . Variable v2 , Section section , WritableByteChannel channel ) throws java . io . IOException , ucar . ma2 . InvalidRangeException { \nArray data = readData ( v2 , section ) ; \nfloat [ ] ftdata = new float [ ( int ) data . getSize ( ) ] ; \nbyte [ ] bytedata = new byte [ ( int ) data . getSize ( ) * 4 ] ; \nIndexIterator iter = data . getIndexIterator ( ) ; \nint i = 0 ; \nByteBuffer buffer = ByteBuffer . allocateDirect ( bytedata . length ) ; \nwhile ( iter . hasNext ( ) ) { \nftdata [ i ] = iter . getFloatNext ( ) ; \nbytedata [ i ] = new Float ( ftdata [ i ] ) . byteValue ( ) ; \nbuffer . put ( bytedata [ i ] ) ; \ni = i + 1 ; \n} \nbuffer = ByteBuffer . wrap ( bytedata ) ; \nint count = channel . write ( buffer ) ; \nSystem . out . println ( \"COUNT=\" + count ) ; \nif ( buffer . hasRemaining ( ) ) { \nbuffer . compact ( ) ; \n} \nelse { \nbuffer . clear ( ) ; \n} \nreturn ( long ) count ; \n} \n} \n"}
{"4335": "public class GridServiceProvider { \nprivate void readXY ( Variable v2 , int ensIdx , int timeIdx , int levIdx , Range yRange , Range xRange , IndexIterator ii ) throws IOException , InvalidRangeException { \nGridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; \nGridHorizCoordSys hsys = pv . getHorizCoordSys ( ) ; \nint nx = hsys . getNx ( ) ; \nGridRecord record = pv . findRecord ( ensIdx , timeIdx , levIdx ) ; \nif ( record == null ) { \nAttribute att = v2 . findAttribute ( \"missing_value\" ) ; \nfloat missing_value = ( att == null ) ? - 9999.0f : att . getNumericValue ( ) . floatValue ( ) ; \nint xyCount = yRange . length ( ) * xRange . length ( ) ; \nfor ( int j = 0 ; \nj < xyCount ; \nj = j + 1 ) { \nii . setFloatNext ( missing_value ) ; \n} \nreturn ; \n} \nfloat [ ] data = _readData ( record ) ; \nif ( data == null ) { \n_readData ( record ) ; \nreturn ; \n} \nfor ( int y : yRange ) { \nfor ( int x : xRange ) { \nint index = y * nx + x ; \nii . setFloatNext ( data [ index ] ) ; \n} \n} \n} \n} \n"}
{"4338": "public class ArraySequenceNested { \npublic void finish ( ) { \nsequenceOffset = new int [ nelems ] ; \ntotal = 0 ; \nfor ( int i = 0 ; \ni < nelems ; \ni = i + 1 ) { \nsequenceOffset [ i ] = total ; \ntotal += sequenceLen [ i ] ; \n} \nsdata = new StructureData [ nelems ] ; \nfor ( int i = 0 ; \ni < nelems ; \ni = i + 1 ) sdata [ i ] = new StructureDataA ( this , sequenceOffset [ i ] ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nint [ ] mShape = m . getShape ( ) ; \nint [ ] shape = new int [ mShape . length + 1 ] ; \nshape [ 0 ] = total ; \nSystem . arraycopy ( mShape , 0 , shape , 1 , mShape . length ) ; \nArray data = Array . factory ( m . getDataType ( ) , shape ) ; \nm . setDataArray ( data ) ; \n} \n} \n} \n"}
{"4339": "public class Format { \npublic static void tab ( StringBuffer sbuff , int tabStop , boolean alwaysOne ) { \nint len = sbuff . length ( ) ; \nif ( tabStop > len ) { \nsbuff . setLength ( tabStop ) ; \nfor ( int i = len ; \ni < tabStop ; \ni = i + 1 ) { \nsbuff . setCharAt ( i , ' ' ) ; \n} \n} \nelse if ( alwaysOne ) { \nsbuff . setLength ( len + 1 ) ; \nsbuff . setCharAt ( len , ' ' ) ; \n} \n} \n} \n"}
{"4340": "public class Format { \npublic static String pad ( String s , int width , boolean rightJustify ) { \nif ( s . length ( ) >= width ) { \nreturn s ; \n} \nStringBuilder sbuff = new StringBuilder ( width ) ; \nint need = width - s . length ( ) ; \nsbuff . setLength ( need ) ; \nfor ( int i = 0 ; \ni < need ; \ni = i + 1 ) { \nsbuff . setCharAt ( i , ' ' ) ; \n} \nif ( rightJustify ) { \nsbuff . append ( s ) ; \n} \nelse { \nsbuff . insert ( 0 , s ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"4346": "public class GridDatasetInfo { \nprivate String getShapeString ( int [ ] shape ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < shape . length ; \ni = i + 1 ) { \nif ( i != 0 ) buf . append ( \" \" ) ; \nbuf . append ( shape [ i ] ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4352": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 ) { \nint stop = buf0 . limit ( ) ; \nint size = stop + 8 ; \nint savepos = buf0 . position ( ) ; \nassert savepos == 0 ; \nbyte [ ] bytes = new byte [ size ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . get ( bytes , 0 , stop ) ; \nbuf0 . position ( savepos ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \nbuf . position ( 0 ) ; \nbuf . limit ( size ) ; \nint i = 0 ; \ntry { \nfor ( i = 0 ; \nbuf . position ( ) < stop ; \ni = i + 1 ) { \nsavepos = buf . position ( ) ; \nint iv = buf . getInt ( ) ; \nbuf . position ( savepos ) ; \nlong lv = buf . getLong ( ) ; \nbuf . position ( savepos ) ; \nshort sv = buf . getShort ( ) ; \nbuf . position ( savepos ) ; \nbyte b = buf . get ( ) ; \nint ub = ( ( int ) b ) & 0x000000FF ; \nlong uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; \nint usv = ( ( int ) sv ) & 0xFFFF ; \nint ib = ( int ) b ; \nchar c = ( char ) ub ; \nString s = Character . toString ( c ) ; \nif ( c == '\\r' ) s = \"\\\\r\" ; \nelse if ( c == '\\n' ) s = \"\\\\n\" ; \nelse if ( c < ' ' || c >= 0x7f ) s = \"?\" ; \nSystem . err . printf ( \"[%03d] %02x %03d %4d '%s'\" , i , ub , ub , ib , s ) ; \nSystem . err . printf ( \"\\t%12d 0x%08x\" , iv , uiv ) ; \nSystem . err . printf ( \"\\t%5d\\t0x%04x\" , sv , usv ) ; \nSystem . err . println ( ) ; \nSystem . err . flush ( ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"failure:\" + e ) ; \n} \nfinally { \nSystem . err . flush ( ) ; \nSystem . err . flush ( ) ; \n} \n} \n} \n"}
{"4355": "public class NcStreamDataCol { \npublic Array decodeVlenData ( NcStreamProto . DataCol dproto ) throws IOException { \nDataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; \nByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; \nByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nbb . order ( bo ) ; \nArray alldata = Array . factory ( dataType , new int [ ] { \ndproto . getNelems ( ) } \n, bb ) ; \nIndexIterator all = alldata . getIndexIterator ( ) ; \nSection section = NcStream . decodeSection ( dproto . getSection ( ) ) ; \nArray [ ] data = new Array [ ( int ) section . computeSize ( ) ] ; \nint count = 0 ; \nfor ( int len : dproto . getVlensList ( ) ) { \nArray primdata = Array . factory ( dataType , new int [ ] { \nlen } \n) ; \nIndexIterator prim = primdata . getIndexIterator ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nprim . setObjectNext ( all . getObjectNext ( ) ) ; \n} \ndata [ count = count + 1 ] = primdata ; \n} \nreturn Array . makeVlenArray ( section . getShape ( ) , data ) ; \n} \n} \n"}
{"4356": "public class NcStreamDataCol { \nprivate Array decodeVlenData ( NcStreamProto . DataCol dproto , Section parentSection ) throws IOException { \nDataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; \nByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; \nByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nbb . order ( bo ) ; \nArray alldata = Array . factory ( dataType , new int [ ] { \ndproto . getNelems ( ) } \n, bb ) ; \nIndexIterator all = alldata . getIndexIterator ( ) ; \nint psize = ( int ) parentSection . computeSize ( ) ; \nSection section = NcStream . decodeSection ( dproto . getSection ( ) ) ; \nSection vsection = section . removeFirst ( parentSection ) ; \nint vsectionSize = ( int ) vsection . computeSize ( ) ; \nint countInner = 0 ; \nArray [ ] pdata = new Array [ psize ] ; \nfor ( int pCount = 0 ; \npCount < psize ; \npCount = pCount + 1 ) { \nArray [ ] vdata = new Array [ vsectionSize ] ; \nfor ( int vCount = 0 ; \nvCount < vsectionSize ; \nvCount = vCount + 1 ) { \nint vlen = dproto . getVlens ( countInner = countInner + 1 ) ; \nArray primdata = Array . factory ( dataType , new int [ ] { \nvlen } \n) ; \nIndexIterator prim = primdata . getIndexIterator ( ) ; \nfor ( int i = 0 ; \ni < vlen ; \ni = i + 1 ) { \nprim . setObjectNext ( all . getObjectNext ( ) ) ; \n} \nvdata [ vCount ] = primdata ; \n} \npdata [ pCount ] = Array . makeVlenArray ( vsection . getShape ( ) , vdata ) ; \n} \nreturn Array . makeVlenArray ( parentSection . getShape ( ) , pdata ) ; \n} \n} \n"}
{"4364": "public class CoordinateRuntime { \npublic List < Double > getOffsetsInTimeUnits ( ) { \ndouble start = firstDate . getMillis ( ) ; \nList < Double > result = new ArrayList < > ( runtimes . length ) ; \nfor ( int idx = 0 ; \nidx < runtimes . length ; \nidx = idx + 1 ) { \ndouble runtime = ( double ) getRuntime ( idx ) ; \ndouble msecs = ( runtime - start ) ; \nresult . add ( msecs / timeUnit . getValueInMillisecs ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"4375": "public class GridHorizCoordSys { \nprivate double [ ] addCoordAxis ( NetcdfFile ncfile , String name , int n , double start , double incr , String units , String desc , String standard_name , AxisType axis ) { \nVariable v = new Variable ( ncfile , g , null , name ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . setDimensions ( name ) ; \ndouble [ ] data = new double [ n ] ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \ndata [ i ] = start + incr * i ; \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nn } \n, data ) ; \nv . setCachedData ( dataArray , false ) ; \nv . addAttribute ( new Attribute ( \"units\" , units ) ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , desc ) ) ; \nv . addAttribute ( new Attribute ( \"standard_name\" , standard_name ) ) ; \nv . addAttribute ( new Attribute ( \"grid_spacing\" , incr + \" \" + units ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axis . toString ( ) ) ) ; \nncfile . addVariable ( g , v ) ; \nreturn data ; \n} \n} \n"}
{"4396": "public class AWIPSConvention { \nprivate Dimension makeZCoordAxis ( NetcdfDataset ds , List < String > values , String units ) throws IOException { \nint len = values . size ( ) ; \nString name = makeZCoordName ( units ) ; \nif ( len > 1 ) name = name + Integer . toString ( len ) ; \nelse name = name + values . get ( 0 ) ; \nStringUtil2 . replace ( name , ' ' , \"-\" ) ; \nDimension dim ; \nif ( null != ( dim = ds . getRootGroup ( ) . findDimension ( name ) ) ) { \nif ( dim . getLength ( ) == len ) { \nVariable coord = ds . getRootGroup ( ) . findVariable ( name ) ; \nArray coordData = coord . read ( ) ; \nArray newData = Array . makeArray ( coord . getDataType ( ) , values ) ; \nif ( MAMath . nearlyEquals ( coordData , newData ) ) { \nif ( debugBreakup ) parseInfo . format ( \"  use existing coord %s%n\" , dim ) ; \nreturn dim ; \n} \n} \n} \nString orgName = name ; \nint count = 1 ; \nwhile ( ds . getRootGroup ( ) . findDimension ( name ) != null ) { \nname = orgName + \"-\" + count ; \ncount = count + 1 ; \n} \ndim = new Dimension ( name , len ) ; \nds . addDimension ( null , dim ) ; \nif ( debugBreakup ) parseInfo . format ( \"  make Dimension = %s length = %d%n\" , name , len ) ; \nif ( debugBreakup ) { \nparseInfo . format ( \"  make ZCoordAxis = = %s length = %d%n\" , name , len ) ; \n} \nCoordinateAxis v = new CoordinateAxis1D ( ds , null , name , DataType . DOUBLE , name , makeUnitsName ( units ) , makeLongName ( name ) ) ; \nString positive = getZisPositive ( ds , v ) ; \nif ( null != positive ) v . addAttribute ( new Attribute ( _Coordinate . ZisPositive , positive ) ) ; \nv . setValues ( values ) ; \nds . addCoordinateAxis ( v ) ; \nparseInfo . format ( \"Created Z Coordinate Axis = \" ) ; \nv . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \nreturn dim ; \n} \n} \n"}
{"4412": "public class Index { \npublic long index ( ) { \nlong offset = 0 ; \nfor ( int i = 0 ; \ni < this . indices . length ; \ni = i + 1 ) { \noffset *= this . dimsizes [ i ] ; \noffset += this . indices [ i ] ; \n} \nreturn offset ; \n} \n} \n"}
{"4415": "public class EsriShapefile { \nprivate void discretize ( double [ ] d , int n ) { \nif ( coarseness == 0.0 ) return ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nd [ i ] = ( Math . rint ( resolution * d [ i ] ) / resolution ) ; \n} \n} \n} \n"}
{"4419": "public class LayoutSegmented { \nprivate int getMaxBytes ( long start ) { \nint segno = 0 ; \nwhile ( start >= segMax [ segno ] ) segno = segno + 1 ; \nreturn ( int ) ( segMax [ segno ] - start ) ; \n} \n} \n"}
{"4429": "public class CoordSysBuilder { \nprotected boolean isCoordinateAxisForVariable ( Variable axis , VariableEnhanced v ) { \nList < Dimension > varDims = v . getDimensionsAll ( ) ; \nList < Dimension > axisDims = axis . getDimensionsAll ( ) ; \nint checkDims = axisDims . size ( ) ; \nif ( axis . getDataType ( ) == DataType . CHAR ) checkDims = checkDims - 1 ; \nfor ( int i = 0 ; \ni < checkDims ; \ni = i + 1 ) { \nDimension axisDim = axisDims . get ( i ) ; \nif ( ! varDims . contains ( axisDim ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"4447": "public class DSPRegistry { \nsynchronized public void unregister ( Class < ? extends DSP > klass ) { \nfor ( int i = 0 ; \ni < registry . size ( ) ; \ni = i + 1 ) { \nif ( registry . get ( i ) . dspclass == klass ) { \nregistry . remove ( i ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4452": "public class DapDataset { \npublic void finish ( ) { \nif ( this . finished ) return ; \nif ( this . ce == null ) this . visiblenodes = nodelist ; \nelse { \nthis . visiblenodes = new ArrayList < DapNode > ( nodelist . size ( ) ) ; \nfor ( int i = 0 ; \ni < nodelist . size ( ) ; \ni = i + 1 ) { \nDapNode node = nodelist . get ( i ) ; \nif ( ce . references ( node ) ) visiblenodes . add ( node ) ; \n} \n} \nthis . topvariables = new ArrayList < DapVariable > ( ) ; \nthis . allvariables = new ArrayList < DapVariable > ( ) ; \nthis . allgroups = new ArrayList < DapGroup > ( ) ; \nthis . allenums = new ArrayList < DapEnumeration > ( ) ; \nthis . allcompounds = new ArrayList < DapStructure > ( ) ; \nthis . alldimensions = new ArrayList < DapDimension > ( ) ; \nfinishR ( this ) ; \n} \n} \n"}
{"4453": "public class DapDataset { \npublic void sort ( ) { \nList < DapNode > sorted = new ArrayList < DapNode > ( ) ; \nsortR ( this , sorted ) ; \nfor ( int i = 0 ; \ni < sorted . size ( ) ; \ni = i + 1 ) { \nsorted . get ( i ) . setIndex ( i ) ; \n} \nthis . nodelist = sorted ; \n} \n} \n"}
{"4468": "public class CoordinateAxis2D { \nprivate int findClosest ( ArrayDouble . D2 boundsForRun , double target ) { \ndouble minDiff = Double . MAX_VALUE ; \nint idxFound = - 1 ; \nint n = boundsForRun . getShape ( ) [ 0 ] ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \ndouble midpoint = ( boundsForRun . get ( i , 0 ) + boundsForRun . get ( i , 1 ) ) / 2.0 ; \ndouble diff = Math . abs ( midpoint - target ) ; \nif ( diff < minDiff ) { \nminDiff = diff ; \nidxFound = i ; \n} \n} \nreturn idxFound ; \n} \n} \n"}
{"4473": "public class KMPMatch { \npublic int indexOf ( byte [ ] data , int start , int max ) { \nint j = 0 ; \nif ( data . length == 0 ) return - 1 ; \nif ( start + max > data . length ) System . out . println ( \"HEY KMPMatch\" ) ; \nfor ( int i = start ; \ni < start + max ; \ni = i + 1 ) { \nwhile ( j > 0 && match [ j ] != data [ i ] ) j = failure [ j - 1 ] ; \nif ( match [ j ] == data [ i ] ) j = j + 1 ; \nif ( j == match . length ) return i - match . length + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"4489": "public class ColorScale { \npublic void setNumColors ( int n ) { \nif ( n != ncolors ) { \ncolors = new Color [ n ] ; \nint prevn = Math . min ( ncolors , n ) ; \nSystem . arraycopy ( useColors , 0 , colors , 0 , prevn ) ; \nfor ( int i = ncolors ; \ni < n ; \ni = i + 1 ) colors [ i ] = Color . white ; \nuseColors = colors ; \nncolors = n ; \nedge = new double [ ncolors ] ; \nhist = new int [ ncolors + 1 ] ; \n} \n} \n} \n"}
{"4495": "public class SmartArrayInt { \npublic int findIdx ( int want ) { \nif ( isConstant ) return ( want == start ) ? 0 : - 1 ; \nif ( isSequential ) return want - start ; \nif ( isSorted ) { \nreturn Arrays . binarySearch ( raw , want ) ; \n} \nfor ( int i = 0 ; \ni < raw . length ; \ni = i + 1 ) if ( raw [ i ] == want ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"4500": "public class CatGenConfigMetadataFactory { \nprivate CatalogGenConfig readCatGenConfigElement ( InvDataset parentDataset , Element catGenConfElement ) { \nString type = catGenConfElement . getAttributeValue ( \"type\" ) ; \nCatalogGenConfig catGenConf = new CatalogGenConfig ( parentDataset , type ) ; \njava . util . List list = catGenConfElement . getChildren ( \"datasetSource\" , catGenConfElement . getNamespace ( ) ) ; \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni = i + 1 ) { \nElement dsSourceElement = ( Element ) list . get ( i ) ; \ncatGenConf . setDatasetSource ( readDatasetSourceElement ( parentDataset , dsSourceElement ) ) ; \n} \nreturn ( catGenConf ) ; \n} \n} \n"}
{"4501": "public class CatGenConfigMetadataFactory { \nprivate DatasetSource readDatasetSourceElement ( InvDataset parentDataset , Element dsSourceElement ) { \nString name = dsSourceElement . getAttributeValue ( \"name\" ) ; \nString type = dsSourceElement . getAttributeValue ( \"type\" ) ; \nString structure = dsSourceElement . getAttributeValue ( \"structure\" ) ; \nString accessPoint = dsSourceElement . getAttributeValue ( \"accessPoint\" ) ; \nString createCatalogRefs = dsSourceElement . getAttributeValue ( \"createCatalogRefs\" ) ; \nElement resultServiceElement = dsSourceElement . getChild ( \"resultService\" , dsSourceElement . getNamespace ( ) ) ; \nResultService resultService = readResultServiceElement ( parentDataset , resultServiceElement ) ; \nDatasetSource dsSource = DatasetSource . newDatasetSource ( name , DatasetSourceType . getType ( type ) , DatasetSourceStructure . getStructure ( structure ) , accessPoint , resultService ) ; \nif ( createCatalogRefs != null ) { \ndsSource . setCreateCatalogRefs ( Boolean . valueOf ( createCatalogRefs ) . booleanValue ( ) ) ; \n} \njava . util . List list = dsSourceElement . getChildren ( \"datasetNamer\" , dsSourceElement . getNamespace ( ) ) ; \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni = i + 1 ) { \nElement dsNamerElement = ( Element ) list . get ( i ) ; \ndsSource . addDatasetNamer ( readDatasetNamerElement ( parentDataset , dsNamerElement ) ) ; \n} \nlist = dsSourceElement . getChildren ( \"datasetFilter\" , dsSourceElement . getNamespace ( ) ) ; \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni = i + 1 ) { \nElement dsFilterElement = ( Element ) list . get ( i ) ; \ndsSource . addDatasetFilter ( readDatasetFilterElement ( dsSource , dsFilterElement ) ) ; \n} \nreturn ( dsSource ) ; \n} \n} \n"}
{"4506": "public class CatGenConfigMetadataFactory { \nprivate org . jdom2 . Element createDatasetSourceElement ( DatasetSource dsSource ) { \nElement dssElem = new Element ( \"datasetSource\" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; \nif ( dsSource != null ) { \nif ( dsSource . getName ( ) != null ) { \ndssElem . setAttribute ( \"name\" , dsSource . getName ( ) ) ; \n} \nif ( dsSource . getType ( ) != null ) { \ndssElem . setAttribute ( \"type\" , dsSource . getType ( ) . toString ( ) ) ; \n} \nif ( dsSource . getStructure ( ) != null ) { \ndssElem . setAttribute ( \"structure\" , dsSource . getStructure ( ) . toString ( ) ) ; \n} \nif ( dsSource . getAccessPoint ( ) != null ) { \ndssElem . setAttribute ( \"accessPoint\" , dsSource . getAccessPoint ( ) ) ; \n} \ndssElem . setAttribute ( \"createCatalogRefs\" , Boolean . toString ( dsSource . isCreateCatalogRefs ( ) ) ) ; \nResultService rs = dsSource . getResultService ( ) ; \ndssElem . addContent ( createResultServiceElement ( rs ) ) ; \njava . util . List list = dsSource . getDatasetNamerList ( ) ; \nfor ( int j = 0 ; \nj < list . size ( ) ; \nj = j + 1 ) { \nDatasetNamer dsNamer = ( DatasetNamer ) list . get ( j ) ; \ndssElem . addContent ( createDatasetNamerElement ( dsNamer ) ) ; \n} \nlist = dsSource . getDatasetFilterList ( ) ; \nfor ( int j = 0 ; \nj < list . size ( ) ; \nj = j + 1 ) { \nDatasetFilter dsFilter = ( DatasetFilter ) list . get ( j ) ; \ndssElem . addContent ( createDatasetFilterElement ( dsFilter ) ) ; \n} \n} \nreturn ( dssElem ) ; \n} \n} \n"}
{"4513": "public class GempakParameterTable { \npublic void addParameters ( String tbl ) throws IOException { \ntry ( InputStream is = getInputStream ( tbl ) ) { \nif ( is == null ) { \nthrow new IOException ( \"Unable to open \" + tbl ) ; \n} \nString content = readContents ( is ) ; \nString [ ] lines = content . split ( \"\\n\" ) ; \nList < String [ ] > result = new ArrayList < > ( ) ; \nfor ( String line : lines ) { \nString tline = line . trim ( ) ; \nif ( tline . length ( ) == 0 ) { \ncontinue ; \n} \nif ( tline . startsWith ( \"!\" ) ) { \ncontinue ; \n} \nString [ ] words = new String [ indices . length ] ; \nfor ( int idx = 0 ; \nidx < indices . length ; \nidx = idx + 1 ) { \nif ( indices [ idx ] >= tline . length ( ) ) { \ncontinue ; \n} \nif ( indices [ idx ] + lengths [ idx ] > tline . length ( ) ) { \nwords [ idx ] = line . substring ( indices [ idx ] ) ; \n} \nelse { \nwords [ idx ] = line . substring ( indices [ idx ] , indices [ idx ] + lengths [ idx ] ) ; \n} \nwords [ idx ] = words [ idx ] . trim ( ) ; \n} \nresult . add ( words ) ; \n} \nfor ( String [ ] aResult : result ) { \nGempakParameter p = makeParameter ( aResult ) ; \nif ( p != null ) { \nif ( p . getName ( ) . contains ( \"(\" ) ) { \ntemplateParamMap . put ( p . getName ( ) , p ) ; \n} \nelse { \nparamMap . put ( p . getName ( ) , p ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4514": "public class GempakParameterTable { \nprivate GempakParameter makeParameter ( String [ ] words ) { \nint num = 0 ; \nString description ; \nif ( words [ 0 ] != null ) { \nnum = ( int ) Double . parseDouble ( words [ 0 ] ) ; \n} \nif ( ( words [ 3 ] == null ) || words [ 3 ] . equals ( \"\" ) ) { \nreturn null ; \n} \nString name = words [ 3 ] ; \nif ( name . contains ( \"-\" ) ) { \nint first = name . indexOf ( \"-\" ) ; \nint last = name . lastIndexOf ( \"-\" ) ; \nStringBuilder buf = new StringBuilder ( name . substring ( 0 , first ) ) ; \nbuf . append ( \"(\" ) ; \nfor ( int i = first ; \ni <= last ; \ni = i + 1 ) { \nbuf . append ( \"\\\\d\" ) ; \n} \nbuf . append ( \")\" ) ; \nbuf . append ( name . substring ( last + 1 ) ) ; \nname = buf . toString ( ) ; \n} \nif ( ( words [ 1 ] == null ) || words [ 1 ] . equals ( \"\" ) ) { \ndescription = words [ 3 ] ; \n} \nelse { \ndescription = words [ 1 ] ; \n} \nString unit = words [ 2 ] ; \nif ( unit != null ) { \nunit = unit . replaceAll ( \"\\\\*\\\\*\" , \"\" ) ; \nif ( unit . equals ( \"-\" ) ) { \nunit = \"\" ; \n} \n} \nint decimalScale ; \ntry { \ndecimalScale = Integer . parseInt ( words [ 4 ] . trim ( ) ) ; \n} \ncatch ( NumberFormatException ne ) { \ndecimalScale = 0 ; \n} \nreturn new GempakParameter ( num , name , description , unit , decimalScale ) ; \n} \n} \n"}
{"4541": "public class IospHelper { \nstatic public char [ ] convertByteToChar ( byte [ ] byteArray ) { \nint size = byteArray . length ; \nchar [ ] cbuff = new char [ size ] ; \nfor ( int i = 0 ; \ni < size ; \ni = i + 1 ) cbuff [ i ] = ( char ) DataType . unsignedByteToShort ( byteArray [ i ] ) ; \nreturn cbuff ; \n} \nstatic public byte [ ] convertCharToByte ( char [ ] from ) { \nbyte [ ] to = null ; \nif ( from != null ) { \nint size = from . length ; \nto = new byte [ size ] ; \nfor ( int i = 0 ; \ni < size ; \ni = i + 1 ) to [ i ] = ( byte ) from [ i ] ; \n} \nreturn to ; \n} \n} \n"}
{"4543": "public class IospHelper { \nstatic private ArrayStructure sectionArrayStructure ( ParsedSectionSpec child , ArrayStructure innerData , StructureMembers . Member m ) throws IOException , InvalidRangeException { \nStructureMembers membersw = new StructureMembers ( m . getStructureMembers ( ) ) ; \nArrayStructureW result = new ArrayStructureW ( membersw , child . section . getShape ( ) ) ; \nint count = 0 ; \nSection . Iterator iter = child . section . getIterator ( child . v . getShape ( ) ) ; \nwhile ( iter . hasNext ( ) ) { \nint recno = iter . next ( null ) ; \nStructureData sd = innerData . getStructureData ( recno ) ; \nresult . setStructureData ( sd , count = count + 1 ) ; \n} \nreturn result ; \n} \n} \n"}
{"4547": "public class CDMArrayStructure { \nstatic StructureMembers computemembers ( DapVariable var ) { \nDapStructure ds = ( DapStructure ) var . getBaseType ( ) ; \nStructureMembers sm = new StructureMembers ( ds . getShortName ( ) ) ; \nList < DapVariable > fields = ds . getFields ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni = i + 1 ) { \nDapVariable field = fields . get ( i ) ; \nDapType dt = field . getBaseType ( ) ; \nDataType cdmtype = CDMTypeFcns . daptype2cdmtype ( dt ) ; \nStructureMembers . Member m = sm . addMember ( field . getShortName ( ) , \"\" , null , cdmtype , CDMUtil . computeEffectiveShape ( field . getDimensions ( ) ) ) ; \nm . setDataParam ( i ) ; \nif ( dt . getTypeSort ( ) . isStructType ( ) ) { \nStructureMembers subsm = computemembers ( field ) ; \nm . setStructureMembers ( subsm ) ; \n} \n} \nreturn sm ; \n} \n} \n"}
{"4568": "public class HdfEos { \nprivate void setSharedDimensions ( Variable v , List < Element > values , List < Dimension > unknownDims , String location ) { \nif ( values . size ( ) == 0 ) { \nreturn ; \n} \nIterator < Element > iter = values . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nElement value = iter . next ( ) ; \nString dimName = value . getText ( ) . trim ( ) ; \nif ( dimName . equalsIgnoreCase ( \"scalar\" ) ) { \niter . remove ( ) ; \n} \n} \nList < Dimension > oldDims = v . getDimensions ( ) ; \nif ( oldDims . size ( ) != values . size ( ) ) { \nlog . error ( \"Different number of dimensions for {} {}\" , v , location ) ; \nreturn ; \n} \nList < Dimension > newDims = new ArrayList < > ( ) ; \nGroup group = v . getParentGroup ( ) ; \nfor ( int i = 0 ; \ni < values . size ( ) ; \ni = i + 1 ) { \nElement value = values . get ( i ) ; \nString dimName = value . getText ( ) . trim ( ) ; \ndimName = NetcdfFile . makeValidCdmObjectName ( dimName ) ; \nDimension dim = group . findDimension ( dimName ) ; \nDimension oldDim = oldDims . get ( i ) ; \nif ( dim == null ) { \ndim = checkUnknownDims ( dimName , unknownDims , oldDim , location ) ; \n} \nif ( dim == null ) { \nlog . error ( \"Unknown Dimension= {} for variable = {} {} \" , dimName , v . getFullName ( ) , location ) ; \nreturn ; \n} \nif ( dim . getLength ( ) != oldDim . getLength ( ) ) { \nlog . error ( \"Shared dimension ({}) has different length than data dimension ({}) shared={} org={} for {} {}\" , dim . getShortName ( ) , oldDim . getShortName ( ) , dim . getLength ( ) , oldDim . getLength ( ) , v , location ) ; \nreturn ; \n} \nnewDims . add ( dim ) ; \n} \nv . setDimensions ( newDims ) ; \nif ( showWork ) { \nlog . debug ( \" set shared dimensions for {}\" , v . getNameAndDimensions ( ) ) ; \n} \n} \n} \n"}
{"4578": "public class LayoutM { \npublic void layoutContainer ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nif ( debug ) System . out . println ( name + \" layoutContainer \" ) ; \nint n = target . getComponentCount ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nComponent comp = target . getComponent ( i ) ; \nif ( comp instanceof Container ) { \nContainer c = ( Container ) comp ; \nLayoutManager m = c . getLayout ( ) ; \nif ( m instanceof LayoutM ) m . layoutContainer ( c ) ; \n} \n} \nreset ( target ) ; \nglobalBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; \nwhile ( ! layoutPass ( target ) ) target . setPreferredSize ( globalBounds . getSize ( ) ) ; \n} \n} \n} \n"}
{"4581": "public class URLDumpPane { \nprivate void openURL ( String urlString , Command command ) { \ntry { \nURL u = new URL ( urlString ) ; \ncurrentConnection = ( HttpURLConnection ) u . openConnection ( ) ; \ncurrentConnection . setRequestMethod ( command . toString ( ) ) ; \ncurrentConnection . setAllowUserInteraction ( true ) ; \nclear ( ) ; \nappendLine ( command + \" request for \" + urlString ) ; \nMap < String , List < String > > reqs = currentConnection . getRequestProperties ( ) ; \nfor ( Map . Entry < String , List < String > > ent : reqs . entrySet ( ) ) { \nappend ( \" \" + ent . getKey ( ) + \": \" ) ; \nfor ( String v : ent . getValue ( ) ) append ( v + \" \" ) ; \nappendLine ( \"\" ) ; \n} \nappendLine ( \"\" ) ; \nappendLine ( \"getFollowRedirects=\" + HttpURLConnection . getFollowRedirects ( ) ) ; \nappendLine ( \"getInstanceFollowRedirects=\" + currentConnection . getInstanceFollowRedirects ( ) ) ; \nappendLine ( \"AllowUserInteraction=\" + currentConnection . getAllowUserInteraction ( ) ) ; \nappendLine ( \"\" ) ; \nint code = currentConnection . getResponseCode ( ) ; \nString response = currentConnection . getResponseMessage ( ) ; \nappendLine ( \" HTTP/1.x \" + code + \" \" + response ) ; \nappendLine ( \" content-length: \" + currentConnection . getContentLength ( ) ) ; \nappendLine ( \" content-encoding: \" + currentConnection . getContentEncoding ( ) ) ; \nappendLine ( \" content-type: \" + currentConnection . getContentType ( ) ) ; \nappendLine ( \"\\nHeaders: \" ) ; \nfor ( int j = 1 ; \ntrue ; \nj = j + 1 ) { \nString header = currentConnection . getHeaderField ( j ) ; \nString key = currentConnection . getHeaderFieldKey ( j ) ; \nif ( header == null || key == null ) break ; \nappendLine ( \" \" + key + \": \" + header ) ; \n} \nappendLine ( \"\" ) ; \nappendLine ( \"contents:\" ) ; \njava . io . InputStream is = currentConnection . getInputStream ( ) ; \nByteArrayOutputStream bout = new ByteArrayOutputStream ( 200000 ) ; \nIO . copy ( is , bout ) ; \nis . close ( ) ; \nappend ( new String ( bout . toByteArray ( ) , CDM . utf8Charset ) ) ; \nappendLine ( \"end contents\" ) ; \n} \ncatch ( MalformedURLException e ) { \nappend ( urlString + \" is not a parseable URL\" ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"4587": "public class CoordinateTime2DUnionizer { \nvoid setRuntimeCoords ( CoordinateRuntime runtimes ) { \nfor ( int idx = 0 ; \nidx < runtimes . getSize ( ) ; \nidx = idx + 1 ) { \nCalendarDate cd = runtimes . getRuntimeDate ( idx ) ; \nlong runtime = runtimes . getRuntime ( idx ) ; \nCoordinateTimeAbstract time = timeMap . get ( runtime ) ; \nif ( time == null ) { \ntime = isTimeInterval ? new CoordinateTimeIntv ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) : new CoordinateTime ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) ; \ntimeMap . put ( runtime , time ) ; \n} \n} \n} \n} \n"}
{"4588": "public class CFPointObWriter { \npublic static void writePointObsDataset ( PointObsDataset pobsDataset , String fileOut ) throws IOException { \nString altUnits = null ; \nDataIterator iterOne = pobsDataset . getDataIterator ( - 1 ) ; \nwhile ( iterOne . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iterOne . nextData ( ) ; \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \naltUnits = Double . isNaN ( loc . getAltitude ( ) ) ? null : \"meters\" ; \nbreak ; \n} \nList < VariableSimpleIF > vars = pobsDataset . getDataVariables ( ) ; \nList < PointObVar > nvars = new ArrayList < PointObVar > ( vars . size ( ) ) ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nint ndoubles = vars . size ( ) ; \ndouble [ ] dvals = new double [ ndoubles ] ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isString ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nString [ ] svals = new String [ vars . size ( ) - ndoubles ] ; \nFileOutputStream fos = new FileOutputStream ( fileOut ) ; \nDataOutputStream out = new DataOutputStream ( fos ) ; \nCFPointObWriter writer = new CFPointObWriter ( out , pobsDataset . getGlobalAttributes ( ) , altUnits , nvars , - 1 ) ; \nDataIterator iter = pobsDataset . getDataIterator ( 1000 * 1000 ) ; \nwhile ( iter . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iter . nextData ( ) ; \nStructureData sdata = pobsData . getData ( ) ; \nint dcount = 0 ; \nint scount = 0 ; \nfor ( PointObVar v : nvars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) { \nArray data = sdata . getArray ( v . getName ( ) ) ; \ndata . resetLocalIterator ( ) ; \nif ( data . hasNext ( ) ) dvals [ dcount = dcount + 1 ] = data . nextDouble ( ) ; \n} \nelse if ( v . getDataType ( ) . isString ( ) ) { \nArrayChar data = ( ArrayChar ) sdata . getArray ( v . getName ( ) ) ; \nsvals [ scount = scount + 1 ] = data . getString ( ) ; \n} \n} \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \nwriter . addPoint ( loc . getLatitude ( ) , loc . getLongitude ( ) , loc . getAltitude ( ) , pobsData . getObservationTimeAsDate ( ) , dvals , svals ) ; \n} \nwriter . finish ( ) ; \n} \n} \n"}
{"4601": "public class WRFEta { \nprivate ArrayDouble . D3 addStagger ( ArrayDouble . D3 array , int dimIndex ) { \nint [ ] shape = array . getShape ( ) ; \nint [ ] newShape = new int [ 3 ] ; \nSystem . arraycopy ( shape , 0 , newShape , 0 , 3 ) ; \nnewShape [ dimIndex ] = newShape [ dimIndex ] + 1 ; \nint ni = newShape [ 0 ] ; \nint nj = newShape [ 1 ] ; \nint nk = newShape [ 2 ] ; \nArrayDouble . D3 newArray = new ArrayDouble . D3 ( ni , nj , nk ) ; \nint n = shape [ dimIndex ] ; \ndouble [ ] d = new double [ n ] ; \nint [ ] eshape = new int [ 3 ] ; \nint [ ] neweshape = new int [ 3 ] ; \nfor ( int i = 0 ; \ni < 3 ; \ni = i + 1 ) { \neshape [ i ] = ( i == dimIndex ) ? n : 1 ; \nneweshape [ i ] = ( i == dimIndex ) ? n + 1 : 1 ; \n} \nint [ ] origin = new int [ 3 ] ; \ntry { \nfor ( int i = 0 ; \ni < ( ( dimIndex == 0 ) ? 1 : ni ) ; \ni = i + 1 ) { \nfor ( int j = 0 ; \nj < ( ( dimIndex == 1 ) ? 1 : nj ) ; \nj = j + 1 ) { \nfor ( int k = 0 ; \nk < ( ( dimIndex == 2 ) ? 1 : nk ) ; \nk = k + 1 ) { \norigin [ 0 ] = i ; \norigin [ 1 ] = j ; \norigin [ 2 ] = k ; \nIndexIterator it = array . section ( origin , eshape ) . getIndexIterator ( ) ; \nfor ( int l = 0 ; \nl < n ; \nl = l + 1 ) { \nd [ l ] = it . getDoubleNext ( ) ; \n} \ndouble [ ] d2 = extrapinterpolate ( d ) ; \nIndexIterator newit = newArray . section ( origin , neweshape ) . getIndexIterator ( ) ; \nfor ( int l = 0 ; \nl < n + 1 ; \nl = l + 1 ) { \nnewit . setDoubleNext ( d2 [ l ] ) ; \n} \n} \n} \n} \n} \ncatch ( InvalidRangeException e ) { \nreturn null ; \n} \nreturn newArray ; \n} \n} \n"}
{"4602": "public class WRFEta { \nprivate double [ ] extrapinterpolate ( double [ ] array ) { \nint n = array . length ; \ndouble [ ] d = new double [ n + 1 ] ; \nd [ 0 ] = 1.5 * array [ 0 ] - 0.5 * array [ 1 ] ; \nd [ n ] = 1.5 * array [ n - 1 ] - 0.5 * array [ n - 2 ] ; \nfor ( int i = 1 ; \ni < n ; \ni = i + 1 ) { \nd [ i ] = 0.5 * ( array [ i - 1 ] + array [ i ] ) ; \n} \nreturn d ; \n} \n} \n"}
{"4609": "public class GempakStationFileIOSP { \nprotected int getStnVarSize ( String name ) { \nint size = - 1 ; \nfor ( int i = 0 ; \ni < stnVarNames . length ; \ni = i + 1 ) { \nif ( name . equals ( stnVarNames [ i ] ) ) { \nsize = stnVarSizes [ i ] ; \nbreak ; \n} \n} \nreturn size ; \n} \n} \n"}
{"4612": "public class CeParser { \nprivate String yysyntax_error ( int yystate , int tok ) { \nif ( yyErrorVerbose ) { \nif ( tok != yyempty_ ) { \nStringBuffer res = new StringBuffer ( \"syntax error, unexpected \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ tok ] ) ) ; \nint yyn = yypact_ [ yystate ] ; \nif ( ! yy_pact_value_is_default_ ( yyn ) ) { \nint yyxbegin = yyn < 0 ? - yyn : 0 ; \nint yychecklim = yylast_ - yyn + 1 ; \nint yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_ ; \nint count = 0 ; \nfor ( int x = yyxbegin ; \nx < yyxend ; \nx = x + 1 ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) count = count + 1 ; \nif ( count < 5 ) { \ncount = 0 ; \nfor ( int x = yyxbegin ; \nx < yyxend ; \nx = x + 1 ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) { \nres . append ( count = count + 1 == 0 ? \", expecting \" : \" or \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ x ] ) ) ; \n} \n} \n} \nreturn res . toString ( ) ; \n} \n} \nreturn \"syntax error\" ; \n} \n} \n"}
{"4613": "public class CeParser { \nprivate void yy_reduce_print ( int yyrule , YYStack yystack ) { \nif ( yydebug == 0 ) return ; \nint yylno = yyrline_ [ yyrule ] ; \nint yynrhs = yyr2_ [ yyrule ] ; \nyycdebug ( \"Reducing stack by rule \" + ( yyrule - 1 ) + \" (line \" + yylno + \"), \" ) ; \nfor ( int yyi = 0 ; \nyyi < yynrhs ; \nyyi = yyi + 1 ) yy_symbol_print ( \"   $\" + ( yyi + 1 ) + \" =\" , yystos_ [ yystack . stateAt ( yynrhs - ( yyi + 1 ) ) ] , ( ( yystack . valueAt ( yynrhs - ( yyi + 1 ) ) ) ) ) ; \n} \n} \n"}
{"4623": "public class SimpleGeometryIndexFinder { \npublic int getBeginning ( int index ) { \nif ( index == ( pastIndex + 1 ) ) { \nreturn previousEnd + 1 ; \n} \nint newBeginning = 0 ; \nfor ( int i = 0 ; \ni < index ; \ni = i + 1 ) { \nnewBeginning += getNodeCount ( i ) ; \n} \npastIndex = index ; \npreviousBegin = newBeginning ; \nreturn newBeginning ; \n} \n} \n"}
{"4624": "public class SimpleGeometryIndexFinder { \npublic int getEnd ( int index ) { \nif ( index == ( pastIndex - 1 ) ) { \nreturn previousBegin - 1 ; \n} \nint new_end = 0 ; \nfor ( int i = 0 ; \ni < index + 1 ; \ni = i + 1 ) { \nnew_end += getNodeCount ( i ) ; \n} \npastIndex = index ; \npreviousEnd = new_end ; \nreturn new_end - 1 ; \n} \n} \n"}
{"4640": "public class Variable { \npublic int findDimensionIndex ( String name ) { \nfor ( int i = 0 ; \ni < dimensions . size ( ) ; \ni = i + 1 ) { \nDimension d = dimensions . get ( i ) ; \nif ( name . equals ( d . getShortName ( ) ) ) return i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"4653": "public class Variable { \npublic void resetShape ( ) { \nthis . shape = new int [ dimensions . size ( ) ] ; \nfor ( int i = 0 ; \ni < dimensions . size ( ) ; \ni = i + 1 ) { \nDimension dim = dimensions . get ( i ) ; \nshape [ i ] = dim . getLength ( ) ; \nif ( dim . isVariableLength ( ) ) { \nisVariableLength = true ; \n} \n} \nthis . shapeAsSection = null ; \n} \n} \n"}
{"4660": "public class FmrInv { \nvoid finish ( ) { \ngridList = new ArrayList < > ( uvHash . values ( ) ) ; \nCollections . sort ( gridList ) ; \nfor ( GridVariable grid : gridList ) { \ngrid . finish ( ) ; \n} \nint seqno = 0 ; \nfor ( TimeCoord tc : timeCoords ) tc . setId ( seqno = seqno + 1 ) ; \nHashMap < String , List < VertCoord > > map = new HashMap < > ( ) ; \nfor ( VertCoord vc : vertCoords ) { \nList < VertCoord > list = map . get ( vc . getName ( ) ) ; \nif ( list == null ) { \nlist = new ArrayList < > ( ) ; \nmap . put ( vc . getName ( ) , list ) ; \n} \nlist . add ( vc ) ; \n} \nfor ( List < VertCoord > list : map . values ( ) ) { \nif ( list . size ( ) > 0 ) { \nint count = 0 ; \nfor ( VertCoord vc : list ) { \nif ( count > 0 ) vc . setName ( vc . getName ( ) + count ) ; \ncount = count + 1 ; \n} \n} \n} \n} \n} \n"}
{"4665": "public class CDMDSP { \nprotected void buildseqtypes ( Variable cdmvar ) throws DapException { \nif ( CDMUtil . hasVLEN ( cdmvar ) ) { \nbuildseqtype ( cdmvar ) ; \n} \nif ( cdmvar . getDataType ( ) == DataType . STRUCTURE || cdmvar . getDataType ( ) == DataType . SEQUENCE ) { \nStructure struct = ( Structure ) cdmvar ; \nList < Variable > fields = struct . getVariables ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni = i + 1 ) { \nVariable field = fields . get ( i ) ; \nbuildseqtypes ( field ) ; \n} \n} \n} \n} \n"}
{"4668": "public class CDMDSP { \nstatic List < Dimension > getCoreDimset ( List < Dimension > dimset ) throws DapException { \nif ( dimset == null ) return null ; \nList < Dimension > core = new ArrayList < > ( ) ; \nint pos = - 1 ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < dimset . size ( ) ; \ni = i + 1 ) { \nif ( dimset . get ( i ) . isVariableLength ( ) ) { \npos = i ; \ncount = count + 1 ; \n} \nelse core . add ( dimset . get ( i ) ) ; \n} \nif ( ( pos != dimset . size ( ) - 1 ) || count > 1 ) throw new DapException ( \"Unsupported use of (*) Dimension\" ) ; \nreturn core ; \n} \n} \n"}
{"4669": "public class BufrDataProcess { \npublic int scanBufrFile ( String filename , Counter total ) throws Exception { \nint count = 0 ; \ntry ( RandomAccessFile raf = new RandomAccessFile ( filename , \"r\" ) ) { \nMessageScanner scan = new MessageScanner ( raf ) ; \nwhile ( scan . hasNext ( ) ) { \nMessage m = scan . next ( ) ; \nif ( m == null ) continue ; \ntry { \nif ( showMess ) out . format ( \"%sMessage %d header=%s%n\" , indent , count , m . getHeader ( ) ) ; \ncount = count + 1 ; \nCounter counter = new Counter ( ) ; \nprocessBufrMessageAsDataset ( scan , m , counter ) ; \nif ( showMess ) out . format ( \"%scount=%d miss=%d%n\" , indent , counter . nvals , counter . nmiss ) ; \ntotal . add ( counter ) ; \n} \ncatch ( Exception e ) { \nSystem . out . printf ( \"  BARF:%s on %s%n\" , e . getMessage ( ) , m . getHeader ( ) ) ; \nindent . setIndentLevel ( 0 ) ; \n} \n} \n} \nreturn count ; \n} \n} \n"}
{"4693": "public class AccessLogParser { \npublic static void main ( String [ ] args ) throws IOException { \nAccessLogParser p = new AccessLogParser ( ) ; \nString line = \"24.18.236.132 - - [04/Feb/2011:17:49:03 -0700] \\\"GET /thredds/fileServer//nexrad/level3/N0R/YUX/20110205/Level3_YUX_N0R_20110205_0011.nids \\\" 200 10409 \\\"-\\\" \\\"-\\\" 17\" ; \nMatcher m = regPattern . matcher ( line ) ; \nSystem . out . printf ( \"%s %s%n\" , m . matches ( ) , m ) ; \nfor ( int i = 0 ; \ni < m . groupCount ( ) ; \ni = i + 1 ) { \nSystem . out . println ( \" \" + i + \" \" + m . group ( i ) ) ; \n} \nLogReader . Log log = p . parseLog ( line ) ; \nSystem . out . printf ( \"%s%n\" , log ) ; \n} \n} \n"}
{"4712": "public class Parse { \nstatic public String cleanCharacterData ( String text ) { \nif ( text == null ) return null ; \nboolean bad = false ; \nfor ( int i = 0 , len = text . length ( ) ; \ni < len ; \ni = i + 1 ) { \nint ch = text . charAt ( i ) ; \nif ( ! org . jdom2 . Verifier . isXMLCharacter ( ch ) ) { \nbad = true ; \nbreak ; \n} \n} \nif ( ! bad ) return text ; \nStringBuilder sbuff = new StringBuilder ( text . length ( ) ) ; \nfor ( int i = 0 , len = text . length ( ) ; \ni < len ; \ni = i + 1 ) { \nint ch = text . charAt ( i ) ; \nif ( org . jdom2 . Verifier . isXMLCharacter ( ch ) ) sbuff . append ( ( char ) ch ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"4713": "public class Escape { \nprivate static String xunescapeString ( String in , char escape , boolean spaceplus ) { \ntry { \nif ( in == null ) return null ; \nbyte [ ] utf8 = in . getBytes ( utf8Charset ) ; \nbyte escape8 = ( byte ) escape ; \nbyte [ ] out = new byte [ utf8 . length ] ; \nint index8 = 0 ; \nfor ( int i = 0 ; \ni < utf8 . length ; \n) { \nbyte b = utf8 [ i = i + 1 ] ; \nif ( b == plus && spaceplus ) { \nout [ index8 = index8 + 1 ] = blank ; \n} \nelse if ( b == escape8 ) { \nif ( i + 2 <= utf8 . length ) { \nb = ( byte ) ( fromHex ( utf8 [ i ] ) << 4 | fromHex ( utf8 [ i + 1 ] ) ) ; \ni += 2 ; \n} \n} \nout [ index8 = index8 + 1 ] = b ; \n} \nreturn new String ( out , 0 , index8 , utf8Charset ) ; \n} \ncatch ( Exception e ) { \nreturn in ; \n} \n} \n} \n"}
{"4716": "public class Escape { \npublic static String backslashDecode ( String s ) { \nStringBuilder buf = new StringBuilder ( s ) ; \nint i = 0 ; \nwhile ( i < buf . length ( ) ) { \nif ( buf . charAt ( i ) == '\\\\' ) { \nbuf . deleteCharAt ( i ) ; \n} \ni = i + 1 ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4717": "public class Escape { \npublic static String backslashEncode ( String s ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni = i + 1 ) { \nint c = buf . charAt ( i ) ; \nif ( _MustBackslashEscape . indexOf ( c ) >= 0 ) buf . append ( _BACKSLASHEscape ) ; \nbuf . append ( ( char ) c ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4720": "public class Swap { \nstatic public int swapInt ( byte [ ] b , int offset ) { \nint accum = 0 ; \nfor ( int shiftBy = 0 , i = offset ; \nshiftBy < 32 ; \nshiftBy += 8 , i = i + 1 ) { \naccum |= ( b [ i ] & 0xff ) << shiftBy ; \n} \nreturn accum ; \n} \n} \n"}
{"4721": "public class Swap { \nstatic public double swapDouble ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nlong shiftedval ; \nfor ( int shiftBy = 0 , i = offset ; \nshiftBy < 64 ; \nshiftBy += 8 , i = i + 1 ) { \nshiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; \naccum |= shiftedval ; \n} \nreturn Double . longBitsToDouble ( accum ) ; \n} \n} \n"}
{"4724": "public class Swap { \nstatic public byte [ ] shortToBytes ( short v ) { \nbyte [ ] b = new byte [ 2 ] ; \nint allbits = 255 ; \nfor ( int i = 0 ; \ni < 2 ; \ni = i + 1 ) { \nb [ 1 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \n} \nreturn b ; \n} \n} \n"}
{"4725": "public class Swap { \nstatic public byte [ ] intToBytes ( int v ) { \nbyte [ ] b = new byte [ 4 ] ; \nint allbits = 255 ; \nfor ( int i = 0 ; \ni < 4 ; \ni = i + 1 ) { \nb [ 3 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \n} \nreturn b ; \n} \n} \n"}
{"4726": "public class Swap { \nstatic public byte [ ] longToBytes ( long v ) { \nbyte [ ] b = new byte [ 8 ] ; \nlong allbits = 255 ; \nfor ( int i = 0 ; \ni < 8 ; \ni = i + 1 ) { \nb [ 7 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \n} \nreturn b ; \n} \n} \n"}
{"4729": "public class OceanS { \nprivate Array makeC ( Array s , double a , double b ) { \nint nz = ( int ) s . getSize ( ) ; \nIndex sIndex = s . getIndex ( ) ; \nif ( a == 0 ) return s ; \nArrayDouble . D1 c = new ArrayDouble . D1 ( nz ) ; \ndouble fac1 = 1.0 - b ; \ndouble denom1 = 1.0 / Math . sinh ( a ) ; \ndouble denom2 = 1.0 / ( 2.0 * Math . tanh ( 0.5 * a ) ) ; \nfor ( int i = 0 ; \ni < nz ; \ni = i + 1 ) { \ndouble sz = s . getDouble ( sIndex . set ( i ) ) ; \ndouble term1 = fac1 * Math . sinh ( a * sz ) * denom1 ; \ndouble term2 = b * ( Math . tanh ( a * ( sz + 0.5 ) ) * denom2 - 0.5 ) ; \nc . set ( i , term1 + term2 ) ; \n} \nreturn c ; \n} \n} \n"}
{"4734": "public class GridCoordSys { \nvoid addToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( dontUseVertical ) { \nreturn ; \n} \nif ( g == null ) { \ng = ncfile . getRootGroup ( ) ; \n} \nString dims = \"time\" ; \nif ( ! dontUseVertical ) { \ndims = dims + \" \" + verticalName ; \n} \nif ( hcs . isLatLon ( ) ) { \ndims = dims + \" lat lon\" ; \n} \nelse { \ndims = dims + \" y x\" ; \n} \nint nlevs = levels . size ( ) ; \nVariable v = new Variable ( ncfile , g , null , verticalName ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , lookup . getLevelDescription ( record ) ) ) ; \nv . addAttribute ( new Attribute ( \"units\" , lookup . getLevelUnit ( record ) ) ) ; \nif ( positive != null ) { \nv . addAttribute ( new Attribute ( \"positive\" , positive ) ) ; \n} \nif ( units != null ) { \nAxisType axisType ; \nif ( SimpleUnit . isCompatible ( \"millibar\" , units ) ) { \naxisType = AxisType . Pressure ; \n} \nelse if ( SimpleUnit . isCompatible ( \"m\" , units ) ) { \naxisType = AxisType . Height ; \n} \nelse { \naxisType = AxisType . GeoZ ; \n} \nv . addAttribute ( new Attribute ( \"grid_level_type\" , Integer . toString ( record . getLevelType1 ( ) ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; \nif ( ! hcs . isLatLon ( ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . Transforms , hcs . getGridName ( ) ) ) ; \n} \n} \ndouble [ ] data = new double [ nlevs ] ; \nfor ( int i = 0 ; \ni < levels . size ( ) ; \ni = i + 1 ) { \nDouble d = ( Double ) levels . get ( i ) ; \ndata [ i ] = d . doubleValue ( ) ; \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nnlevs } \n, data ) ; \nv . setDimensions ( verticalName ) ; \nv . setCachedData ( dataArray , false ) ; \nncfile . addVariable ( g , v ) ; \nif ( record . getLevelType1 ( ) == 109 ) { \nfindCoordinateTransform ( g , \"Pressure\" , record . getLevelType1 ( ) ) ; \n} \n} \n} \n"}
{"4757": "public class DataDescriptor { \nstatic public void transferInfo ( List < DataDescriptor > fromList , List < DataDescriptor > toList ) { \nif ( fromList . size ( ) != toList . size ( ) ) throw new IllegalArgumentException ( \"list sizes dont match \" + fromList . size ( ) + \" != \" + toList . size ( ) ) ; \nfor ( int i = 0 ; \ni < fromList . size ( ) ; \ni = i + 1 ) { \nDataDescriptor from = fromList . get ( i ) ; \nDataDescriptor to = toList . get ( i ) ; \nto . refersTo = from . refersTo ; \nto . name = from . name ; \nif ( from . getSubKeys ( ) != null ) transferInfo ( from . getSubKeys ( ) , to . getSubKeys ( ) ) ; \n} \n} \n} \n"}
{"4760": "public class DbaseFile { \nprivate int loadHeader ( ) { \nif ( headerLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nBufferedInputStream bs = new BufferedInputStream ( s ) ; \nds = new DataInputStream ( bs ) ; \nHeader = new byte [ 32 ] ; \nds . readFully ( Header ) ; \nif ( Header [ 0 ] == '<' ) { \nclose ( ds ) ; \nreturn - 1 ; \n} \nfiletype = Header [ 0 ] ; \nnrecords = Swap . swapInt ( Header , 4 ) ; \nnbytesheader = Swap . swapShort ( Header , 8 ) ; \nnfields = ( nbytesheader / 32 ) - 1 ; \nif ( nfields < 1 ) { \nSystem . out . println ( \"nfields = \" + nfields ) ; \nSystem . out . println ( \"nbytesheader = \" + nbytesheader ) ; \nreturn - 1 ; \n} \nFieldDesc = new DbaseFieldDesc [ nfields ] ; \ndata = new DbaseData [ nfields ] ; \nfor ( int i = 0 ; \ni < nfields ; \ni = i + 1 ) { \nFieldDesc [ i ] = new DbaseFieldDesc ( ds , filetype ) ; \ndata [ i ] = new DbaseData ( FieldDesc [ i ] , nrecords ) ; \n} \nds . readByte ( ) ; \nheaderLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"4761": "public class DbaseFile { \nprivate int loadData ( ) { \nif ( ! headerLoaded ) return - 1 ; \nif ( dataLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nfor ( int i = 0 ; \ni < nrecords ; \ni = i + 1 ) { \nbyte recbyte = ds . readByte ( ) ; \nif ( recbyte == 0x20 ) { \nfor ( int j = 0 ; \nj < nfields ; \nj = j + 1 ) { \ndata [ j ] . readRowN ( ds , i ) ; \n} \n} \nelse { \nnrecords = nrecords - 1 ; \ni = i - 1 ; \n} \n} \ndataLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nfinally { \nclose ( s ) ; \n} \nreturn 0 ; \n} \n} \n"}
{"4762": "public class DbaseFile { \npublic DbaseData getField ( String Name ) { \nfor ( int i = 0 ; \ni < nfields ; \ni = i + 1 ) { \nif ( FieldDesc [ i ] . Name . equals ( Name ) ) return data [ i ] ; \n} \nreturn null ; \n} \n} \n"}
{"4763": "public class DbaseFile { \npublic double [ ] getDoublesByName ( String Name ) { \nDbaseData d ; \nif ( ( d = getField ( Name ) ) == null ) return null ; \nif ( d . getType ( ) == DbaseData . TYPE_CHAR ) { \nString [ ] s = d . getStrings ( ) ; \ndouble [ ] dd = new double [ s . length ] ; \nfor ( int i = 0 ; \ni < s . length ; \ni = i + 1 ) { \ndd [ i ] = Double . valueOf ( s [ i ] ) ; \n} \nreturn dd ; \n} \nif ( d . getType ( ) == DbaseData . TYPE_BOOLEAN ) { \nboolean [ ] b = d . getBooleans ( ) ; \ndouble [ ] dd = new double [ b . length ] ; \nfor ( int i = 0 ; \ni < b . length ; \ni = i + 1 ) { \nif ( b [ i ] ) { \ndd [ i ] = 1 ; \n} \nelse { \ndd [ i ] = 0 ; \n} \n} \nreturn dd ; \n} \nreturn d . getDoubles ( ) ; \n} \n} \n"}
{"4767": "public class DbaseFile { \npublic String [ ] getFieldNames ( ) { \nString [ ] s = new String [ nfields ] ; \nfor ( int i = 0 ; \ni < nfields ; \ni = i + 1 ) { \ns [ i ] = getFieldName ( i ) ; \n} \nreturn s ; \n} \n} \n"}
{"4768": "public class DbaseFile { \npublic static void main ( String [ ] args ) { \nif ( args . length < 1 ) { \nSystem . out . println ( \"filename or URL required\" ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( String s : args ) { \nSystem . out . println ( \"*** Dump of Dbase \" + s + \":\" ) ; \ntry { \nDbaseFile dbf = new DbaseFile ( s ) ; \nif ( dbf . loadHeader ( ) != 0 ) { \nSystem . out . println ( \"Error loading header\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nString [ ] fieldNames = dbf . getFieldNames ( ) ; \nSystem . out . print ( \"[\" ) ; \nint nf = dbf . getNumFields ( ) ; \nDbaseData [ ] dbd = new DbaseData [ nf ] ; \nfor ( int field = 0 ; \nfield < nf ; \nfield = field + 1 ) { \ndbd [ field ] = dbf . getField ( field ) ; \nswitch ( dbd [ field ] . getType ( ) ) { \ncase DbaseData . TYPE_BOOLEAN : System . out . print ( \"boolean \" ) ; \nbreak ; \ncase DbaseData . TYPE_CHAR : System . out . print ( \"String \" ) ; \nbreak ; \ncase DbaseData . TYPE_NUMERIC : System . out . print ( \"double \" ) ; \nbreak ; \n} \nSystem . out . print ( fieldNames [ field ] ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \n} \nSystem . out . println ( \"]\" ) ; \nif ( dbf . loadData ( ) != 0 ) { \nSystem . out . println ( \"Error loading data\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( int rec = 0 ; \nrec < dbf . getNumRecords ( ) ; \nrec = rec + 1 ) { \nfor ( int field = 0 ; \nfield < nf ; \nfield = field + 1 ) { \nSystem . out . print ( dbd [ field ] . getData ( rec ) ) ; \nif ( field < nf - 1 ) System . out . print ( \", \" ) ; \nelse System . out . println ( ) ; \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4777": "public class DapNode { \npublic String computefqn ( ) { \nList < DapNode > path = getPath ( ) ; \nStringBuilder fqn = new StringBuilder ( ) ; \nDapNode parent = path . get ( 0 ) ; \nfor ( int i = 1 ; \ni < path . size ( ) ; \ni = i + 1 ) { \nDapNode current = path . get ( i ) ; \nswitch ( parent . getSort ( ) ) { \ncase DATASET : case GROUP : case ENUMERATION : fqn . append ( '/' ) ; \nfqn . append ( Escape . backslashEscape ( current . getShortName ( ) , \"/.\" ) ) ; \nbreak ; \ncase STRUCTURE : case SEQUENCE : case ENUMCONST : case VARIABLE : fqn . append ( '.' ) ; \nfqn . append ( current . getEscapedShortName ( ) ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Illegal FQN parent\" ) ; \n} \nparent = current ; \n} \nreturn fqn . toString ( ) ; \n} \n} \n"}
{"4784": "public class DSPPrinter { \npublic DSPPrinter print ( ) throws DapException { \nDapDataset dmr = this . dsp . getDMR ( ) ; \nif ( this . ce == null ) this . ce = CEConstraint . getUniversal ( dmr ) ; \nthis . printer . setIndent ( 0 ) ; \nList < DapVariable > topvars = dmr . getTopVariables ( ) ; \nfor ( int i = 0 ; \ni < topvars . size ( ) ; \ni = i + 1 ) { \nDapVariable top = topvars . get ( i ) ; \nList < Slice > slices = this . ce . getConstrainedSlices ( top ) ; \nif ( this . ce . references ( top ) ) { \nDataCursor data = dsp . getVariableData ( top ) ; \nprintVariable ( data , slices ) ; \n} \n} \nprinter . eol ( ) ; \nreturn this ; \n} \n} \n"}
{"4785": "public class DSPPrinter { \nprotected void printCompoundInstance ( DataCursor datav ) throws DapException { \nDapStructure dstruct = ( DapStructure ) ( ( DapVariable ) datav . getTemplate ( ) ) . getBaseType ( ) ; \nswitch ( datav . getScheme ( ) ) { \ncase STRUCTURE : case RECORD : List < DapVariable > dfields = dstruct . getFields ( ) ; \nfor ( int f = 0 ; \nf < dfields . size ( ) ; \nf = f + 1 ) { \nDapVariable field = dfields . get ( f ) ; \nList < Slice > fieldslices = this . ce . getConstrainedSlices ( field ) ; \nDataCursor fdata = datav . readField ( f ) ; \nprintVariable ( fdata , fieldslices ) ; \n} \nbreak ; \ncase SEQUENCE : DapSequence dseq = ( DapSequence ) dstruct ; \nlong count = datav . getRecordCount ( ) ; \nfor ( long r = 0 ; \nr < count ; \nr = r + 1 ) { \nDataCursor dr = datav . readRecord ( r ) ; \nprinter . marginPrint ( \"[\" ) ; \nprinter . eol ( ) ; \nprinter . indent ( ) ; \nprintCompoundInstance ( dr ) ; \nprinter . outdent ( ) ; \nprinter . marginPrint ( \"]\" ) ; \n} \nbreak ; \ndefault : throw new DapException ( \"Unexpected data cursor scheme:\" + datav . getScheme ( ) ) ; \n} \n} \n} \n"}
{"4799": "public class CoordAxisHelper { \nprivate int findClosest ( double target ) { \ndouble minDiff = Double . MAX_VALUE ; \ndouble useValue = Double . MIN_VALUE ; \nint idxFound = - 1 ; \nfor ( int i = 0 ; \ni < axis . getNcoords ( ) ; \ni = i + 1 ) { \ndouble coord = axis . getCoordMidpoint ( i ) ; \ndouble diff = Math . abs ( coord - target ) ; \nif ( diff < minDiff || ( diff == minDiff && coord > useValue ) ) { \nminDiff = diff ; \nidxFound = i ; \nuseValue = coord ; \n} \n} \nreturn idxFound ; \n} \n} \n"}
{"4816": "public class DMRPrinter { \nvoid printDimrefs ( DapVariable var ) throws DapException { \nif ( var . getRank ( ) == 0 ) return ; \nList < DapDimension > dimset = this . ce . getConstrainedDimensions ( var ) ; \nif ( dimset == null ) throw new DapException ( \"Unknown variable: \" + var ) ; \nassert var . getRank ( ) == dimset . size ( ) ; \nfor ( int i = 0 ; \ni < var . getRank ( ) ; \ni = i + 1 ) { \nDapDimension dim = dimset . get ( i ) ; \nprinter . marginPrint ( \"<Dim\" ) ; \nif ( dim . isShared ( ) ) { \nString fqn = dim . getFQN ( ) ; \nassert ( fqn != null ) : \"Illegal Dimension reference\" ; \nfqn = fqnXMLEscape ( fqn ) ; \nprintXMLAttribute ( \"name\" , fqn , XMLESCAPED ) ; \n} \nelse { \nlong size = dim . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , NILFLAGS ) ; \n} \nprinter . println ( \"/>\" ) ; \n} \n} \n} \n"}
{"4818": "public class AreaReader { \nprivate void setAreaDirectoryAttributes ( Variable v ) { \nif ( ( dirBlock == null ) || ( ad == null ) ) { \nreturn ; \n} \nfor ( int i = 1 ; \ni < 14 ; \ni = i + 1 ) { \nif ( i == 7 ) { \ncontinue ; \n} \nv . addAttribute ( new Attribute ( getADDescription ( i ) , dirBlock [ i ] ) ) ; \n} \n} \n} \n"}
{"4831": "public class DSequence { \nprivate byte readMarker ( DataInputStream source ) throws IOException { \nbyte marker = source . readByte ( ) ; \nbyte unused ; \nfor ( int i = 0 ; \ni < 3 ; \ni = i + 1 ) unused = source . readByte ( ) ; \nreturn marker ; \n} \n} \n"}
{"4834": "public class MultipleAxisChart { \nprivate static TimeSeries createDataset ( String name , double base , RegularTimePeriod start , int count ) { \nTimeSeries series = new TimeSeries ( name , start . getClass ( ) ) ; \nRegularTimePeriod period = start ; \ndouble value = base ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nseries . add ( period , value ) ; \nperiod = period . next ( ) ; \nvalue = value * ( 1 + ( Math . random ( ) - 0.495 ) / 10.0 ) ; \n} \nreturn series ; \n} \n} \n"}
{"4836": "public class StructureDataA { \npublic String [ ] getJavaArrayString ( StructureMembers . Member m ) { \nif ( m . getDataType ( ) == DataType . STRING ) { \nArray data = getArray ( m ) ; \nint n = m . getSize ( ) ; \nString [ ] result = new String [ n ] ; \nfor ( int i = 0 ; \ni < result . length ; \ni = i + 1 ) result [ i ] = ( String ) data . getObject ( i ) ; \nreturn result ; \n} \nelse if ( m . getDataType ( ) == DataType . CHAR ) { \nArrayChar data = ( ArrayChar ) getArray ( m ) ; \nArrayChar . StringIterator iter = data . getStringIterator ( ) ; \nString [ ] result = new String [ iter . getNumElems ( ) ] ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) result [ count = count + 1 ] = iter . next ( ) ; \nreturn result ; \n} \nthrow new IllegalArgumentException ( \"getJavaArrayString: not String DataType :\" + m . getDataType ( ) ) ; \n} \n} \n"}
{"4837": "public class DoradeVOLD { \npublic DoradePARM [ ] getParamList ( ) { \nint paramCount = 0 ; \nfor ( int i = 0 ; \ni < nSensors ; \ni = i + 1 ) paramCount += myRADDs [ i ] . getNParams ( ) ; \nDoradePARM [ ] list = new DoradePARM [ paramCount ] ; \nint next = 0 ; \nfor ( int i = 0 ; \ni < nSensors ; \ni = i + 1 ) { \nint nParams = myRADDs [ i ] . getNParams ( ) ; \nSystem . arraycopy ( myRADDs [ i ] . getParamList ( ) , 0 , list , next , nParams ) ; \nnext += nParams ; \n} \nreturn list ; \n} \n} \n"}
{"4840": "public class StationRegionDateChooser { \nprotected void redraw ( ) { \nlong tstart = System . currentTimeMillis ( ) ; \njava . awt . Graphics2D gNP = np . getBufferedImageGraphics ( ) ; \nif ( gNP == null ) return ; \ngNP . setBackground ( np . getBackgroundColor ( ) ) ; \njava . awt . Rectangle r = gNP . getClipBounds ( ) ; \ngNP . clearRect ( r . x , r . y , r . width , r . height ) ; \nif ( regionSelect && geoSelectionMode ) { \nif ( geoSelection != null ) drawBB ( gNP , geoSelection , Color . cyan ) ; \nif ( geoBounds != null ) drawBB ( gNP , geoBounds , null ) ; \nif ( geoSelection != null ) { \nNavigation navigate = np . getNavigation ( ) ; \ndouble handleSize = RubberbandRectangleHandles . handleSizePixels / navigate . getPixPerWorld ( ) ; \nRectangle2D rect = new Rectangle2D . Double ( geoSelection . getX ( ) , geoSelection . getY ( ) , geoSelection . getWidth ( ) , geoSelection . getHeight ( ) ) ; \nRubberbandRectangleHandles . drawHandledRect ( gNP , rect , handleSize ) ; \nif ( debug ) System . out . println ( \"GeoRegionChooser.drawHandledRect=\" + handleSize + \" = \" + geoSelection ) ; \n} \n} \nfor ( int i = 0 ; \ni < renderers . size ( ) ; \ni = i + 1 ) { \nucar . nc2 . ui . util . Renderer rend = ( Renderer ) renderers . get ( i ) ; \nrend . draw ( gNP , atI ) ; \n} \ngNP . dispose ( ) ; \nif ( debug ) { \nlong tend = System . currentTimeMillis ( ) ; \nSystem . out . println ( \"StationRegionDateChooser draw time = \" + ( tend - tstart ) / 1000.0 + \" secs\" ) ; \n} \nnp . repaint ( ) ; \n} \n} \n"}
{"4853": "public class NcSDStructure { \npublic void serialize ( String dataset , DataOutputStream sink , CEEvaluator ce , Object specialO ) throws NoSuchVariableException , DAP2ServerSideException , IOException { \nif ( org == null ) { \nsuper . serialize ( dataset , sink , ce , specialO ) ; \nreturn ; \n} \njava . util . Enumeration vars = org . getVariables ( ) ; \nStructureMembers sm = sdata . getStructureMembers ( ) ; \nint count = 0 ; \nwhile ( vars . hasMoreElements ( ) ) { \nHasNetcdfVariable sm_org = ( HasNetcdfVariable ) vars . nextElement ( ) ; \nboolean isProjected = ( ( ServerMethods ) sm_org ) . isProject ( ) ; \nif ( isProjected ) { \nStructureMembers . Member m = sm . getMember ( count ) ; \nsm_org . serialize ( sink , sdata , m ) ; \n} \ncount = count + 1 ; \n} \n} \n} \n"}
{"4854": "public class DoradePARM { \npublic float [ ] getParamValues ( DoradeRDAT rdat , float [ ] workingArray ) throws DescriptorException { \nif ( ! paramName . equals ( rdat . getParamName ( ) ) ) throw new DescriptorException ( \"parameter name mismatch\" ) ; \nbyte [ ] paramData = rdat . getRawData ( ) ; \nint nCells = myRADD . getNCells ( ) ; \nfloat [ ] values ; \nif ( workingArray != null && workingArray . length == nCells ) { \nvalues = workingArray ; \n} \nelse { \nvalues = new float [ nCells ] ; \n} \nshort [ ] svalues = null ; \nif ( myRADD . getCompressionScheme ( ) == DoradeRADD . COMPRESSION_HRD ) { \nif ( binaryFormat != DoradePARM . FORMAT_16BIT_INT ) { \nthrow new DescriptorException ( \"Cannot unpack \" + \"compressed data with binary format \" + binaryFormat ) ; \n} \nsvalues = uncompressHRD ( paramData , nCells ) ; \n} \nfor ( int cell = 0 ; \ncell < nCells ; \ncell = cell + 1 ) { \nswitch ( binaryFormat ) { \ncase DoradePARM . FORMAT_8BIT_INT : byte bval = paramData [ cell ] ; \nvalues [ cell ] = ( bval == badDataFlag ) ? BAD_VALUE : ( bval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_INT : short sval = ( svalues != null ) ? svalues [ cell ] : grabShort ( paramData , 2 * cell ) ; \nvalues [ cell ] = ( sval == badDataFlag ) ? BAD_VALUE : ( sval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_INT : int ival = grabInt ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( ival == badDataFlag ) ? BAD_VALUE : ( ival - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_FLOAT : float fval = grabFloat ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( fval == badDataFlag ) ? BAD_VALUE : ( fval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_FLOAT : throw new DescriptorException ( \"can't unpack 16-bit \" + \"float data yet\" ) ; \ndefault : throw new DescriptorException ( \"bad binary format (\" + binaryFormat + \")\" ) ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4876": "public class GempakUtil { \npublic static int [ ] swp4 ( int [ ] values , int startIndex , int number ) { \nfor ( int i = startIndex ; \ni < startIndex + number ; \ni = i + 1 ) { \nvalues [ i ] = Integer . reverseBytes ( values [ i ] ) ; \n} \nreturn values ; \n} \n} \n"}
{"4882": "public class ImageDatasetFactory { \npublic BufferedImage getNextImage ( boolean forward ) { \nif ( grid != null ) { \nif ( forward ) { \nthis . time = this . time + 1 ; \nif ( this . time >= this . ntimes ) this . time = 0 ; \n} \nelse { \nthis . time = this . time - 1 ; \nif ( this . time < 0 ) this . time = this . ntimes - 1 ; \n} \nArray data ; \ntry { \ndata = grid . readDataSlice ( this . time , 0 , - 1 , - 1 ) ; \nreturn ImageArrayAdapter . makeGrayscaleImage ( data , grid ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \nif ( currentFile == null ) return null ; \nif ( currentDir == null ) { \ncurrentDirFileNo = 0 ; \ncurrentDir = currentFile . getParentFile ( ) ; \ncurrentDirFileList = new ArrayList < > ( ) ; \naddToList ( currentDir , currentDirFileList ) ; \nfor ( int i = 0 ; \ni < currentDirFileList . size ( ) ; \ni = i + 1 ) { \nFile file = currentDirFileList . get ( i ) ; \nif ( file . equals ( currentFile ) ) currentDirFileNo = i ; \n} \n} \nif ( forward ) { \ncurrentDirFileNo = currentDirFileNo + 1 ; \nif ( currentDirFileNo >= currentDirFileList . size ( ) ) currentDirFileNo = 0 ; \n} \nelse { \ncurrentDirFileNo = currentDirFileNo - 1 ; \nif ( currentDirFileNo < 0 ) currentDirFileNo = currentDirFileList . size ( ) - 1 ; \n} \nFile nextFile = currentDirFileList . get ( currentDirFileNo ) ; \ntry { \nSystem . out . println ( \"Open image \" + nextFile ) ; \nreturn javax . imageio . ImageIO . read ( nextFile ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"Failed to open image \" + nextFile ) ; \nreturn getNextImage ( forward ) ; \n} \n} \n} \n"}
{"4884": "public class FixedYearVariableMonthChronology { \nprivate static int sumArray ( int [ ] arr ) { \nif ( arr == null ) throw new NullPointerException ( \"null array\" ) ; \nif ( arr . length == 0 ) throw new IllegalArgumentException ( \"Zero-length array\" ) ; \nint sum = 0 ; \nfor ( int i = 0 ; \ni < arr . length ; \ni = i + 1 ) { \nif ( arr [ i ] <= 0 ) { \nthrow new IllegalArgumentException ( \"All array values must be > 0\" ) ; \n} \nsum += arr [ i ] ; \n} \nreturn sum ; \n} \n} \n"}
{"4887": "public class SpatialGrid { \npublic void clear ( ) { \nfor ( int y = 0 ; \ny < countY ; \ny = y + 1 ) for ( int x = 0 ; \nx < countX ; \nx = x + 1 ) gridArray [ y ] [ x ] . used = false ; \n} \n} \n"}
{"4889": "public class SpatialGrid { \npublic Object findIntersection ( Rectangle2D rect ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \nfor ( int y = Math . max ( 0 , indexY - 1 ) ; \ny <= Math . min ( countY - 1 , indexY + 1 ) ; \ny = y + 1 ) { \nfor ( int x = Math . max ( 0 , indexX - 1 ) ; \nx <= Math . min ( countX - 1 , indexX + 1 ) ; \nx = x + 1 ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) continue ; \nif ( intersectsOverlap ( rect , gtest . objectBB ) ) return gtest . o ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4890": "public class SpatialGrid { \npublic Object findIntersection ( Point2D p ) { \nint indexX = ( int ) ( ( p . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( p . getY ( ) - offsetY ) / gridHeight ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \nfor ( int y = Math . max ( 0 , indexY - 1 ) ; \ny <= Math . min ( countY - 1 , indexY + 1 ) ; \ny = y + 1 ) { \nfor ( int x = Math . max ( 0 , indexX - 1 ) ; \nx <= Math . min ( countX - 1 , indexX + 1 ) ; \nx = x + 1 ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) continue ; \nif ( gtest . objectBB . contains ( p . getX ( ) , p . getY ( ) ) ) return gtest . o ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4891": "public class SpatialGrid { \npublic Object findClosest ( Point2D pt ) { \nObject o = null ; \nint indexX = ( int ) ( ( pt . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( pt . getY ( ) - offsetY ) / gridHeight ) ; \nif ( debugClosest ) System . out . println ( \"findClosest \" + pt + \" \" + indexX + \" \" + indexY ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return gwant . o ; \nfor ( int p = 1 ; \np < Math . max ( countX - 1 , countY - 1 ) ; \np = p + 1 ) if ( null != ( o = findClosestAlongPerimeter ( pt , indexX , indexY , p ) ) ) return o ; \nreturn null ; \n} \n} \n"}
{"4895": "public class DatasetUrl { \nstatic private ServiceType searchPath ( String url ) { \nif ( false ) { \nif ( url == null || url . length ( ) == 0 ) return null ; \nurl = url . toLowerCase ( ) ; \nfor ( int i = 0 ; \ni < FRAGPROTOCOLS . length ; \ni = i + 1 ) { \nString p = FRAGPROTOCOLS [ i ] ; \nif ( url . indexOf ( \"/thredds/\" + p . toLowerCase ( ) + \"/\" ) >= 0 ) { \nreturn FRAGPROTOSVCTYPE [ i ] ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4903": "public class DapUtil { \nstatic public String locateRelative ( String relpath , String abspath , boolean wantdir ) { \nrelpath = relpath . trim ( ) . replace ( '\\\\' , '/' ) ; \nif ( relpath . charAt ( 0 ) == '/' ) relpath = relpath . substring ( 1 ) ; \nif ( relpath . endsWith ( \"/\" ) ) relpath = relpath . substring ( 0 , relpath . length ( ) - 1 ) ; \nString [ ] pieces = relpath . split ( \"[/]\" ) ; \nString partial = abspath ; \nfor ( int i = 0 ; \ni < pieces . length - 1 ; \ni = i + 1 ) { \nString nextdir = locateFile ( pieces [ i ] , abspath , true ) ; \nif ( nextdir == null ) return null ; \npartial = nextdir ; \n} \nString finalpath = locateFile ( pieces [ pieces . length - 1 ] , partial , wantdir ) ; \nreturn finalpath ; \n} \n} \n"}
{"4905": "public class DapUtil { \nstatic public List < DapVariable > getStructurePath ( DapVariable var ) { \nList < DapNode > path = var . getPath ( ) ; \nList < DapVariable > structpath = new ArrayList < DapVariable > ( ) ; \nfor ( int i = 0 ; \ni < path . size ( ) ; \ni = i + 1 ) { \nDapNode node = path . get ( i ) ; \nswitch ( node . getSort ( ) ) { \ncase DATASET : case GROUP : break ; \ncase VARIABLE : structpath . add ( ( DapVariable ) node ) ; \nbreak ; \ndefault : assert false : \"Internal error\" ; \n} \n} \nreturn structpath ; \n} \n} \n"}
{"4907": "public class DapUtil { \nstatic public String join ( String [ ] array , String sep , int from , int upto ) { \nif ( sep == null ) sep = \"\" ; \nif ( from < 0 || upto > array . length ) throw new IndexOutOfBoundsException ( ) ; \nif ( upto <= from ) return \"\" ; \nStringBuilder result = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( int i = from ; \ni < upto ; \ni = i + 1 , first = false ) { \nif ( ! first ) result . append ( sep ) ; \nresult . append ( array [ i ] ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"4914": "public class DapUtil { \nstatic public Index slicesToIndex ( List < Slice > slices ) throws DapException { \nlong [ ] positions = new long [ slices . size ( ) ] ; \nlong [ ] dimsizes = new long [ slices . size ( ) ] ; \nfor ( int i = 0 ; \ni < positions . length ; \ni = i + 1 ) { \nSlice s = slices . get ( i ) ; \nif ( s . getCount ( ) != 1 ) throw new DapException ( \"Attempt to convert non-singleton sliceset to index\" ) ; \npositions [ i ] = s . getFirst ( ) ; \ndimsizes [ i ] = s . getMax ( ) ; \n} \nreturn new Index ( positions , dimsizes ) ; \n} \n} \n"}
{"4936": "public class Index { \nstatic private long computeStrides ( int [ ] shape , int [ ] stride ) { \nlong product = 1 ; \nfor ( int ii = shape . length - 1 ; \nii >= 0 ; \nii = ii - 1 ) { \nfinal int thisDim = shape [ ii ] ; \nif ( thisDim < 0 ) continue ; \nstride [ ii ] = ( int ) product ; \nproduct *= thisDim ; \n} \nreturn product ; \n} \n} \n"}
{"4937": "public class Index { \nIndex section ( List < Range > ranges ) throws InvalidRangeException { \nif ( ranges . size ( ) != rank ) throw new InvalidRangeException ( \"Bad ranges [] length\" ) ; \nfor ( int ii = 0 ; \nii < rank ; \nii = ii + 1 ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) continue ; \nif ( r == Range . VLEN ) continue ; \nif ( ( r . first ( ) < 0 ) || ( r . first ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range starting value at index \" + ii + \" == \" + r . first ( ) ) ; \nif ( ( r . last ( ) < 0 ) || ( r . last ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range ending value at index \" + ii + \" == \" + r . last ( ) ) ; \n} \nint reducedRank = rank ; \nfor ( Range r : ranges ) { \nif ( ( r != null ) && ( r . length ( ) == 1 ) ) reducedRank = reducedRank - 1 ; \n} \nIndex newindex = Index . factory ( reducedRank ) ; \nnewindex . offset = offset ; \nint newDim = 0 ; \nfor ( int ii = 0 ; \nii < rank ; \nii = ii + 1 ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) { \nnewindex . shape [ newDim ] = shape [ ii ] ; \nnewindex . stride [ newDim ] = stride [ ii ] ; \nnewDim = newDim + 1 ; \n} \nelse if ( r . length ( ) != 1 ) { \nnewindex . shape [ newDim ] = r . length ( ) ; \nnewindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; \nnewindex . offset += stride [ ii ] * r . first ( ) ; \nnewDim = newDim + 1 ; \n} \nelse { \nnewindex . offset += stride [ ii ] * r . first ( ) ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator && ( newindex . size == size ) ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4938": "public class Index { \nIndex reduce ( ) { \nIndex c = this ; \nfor ( int ii = 0 ; \nii < rank ; \nii = ii + 1 ) if ( shape [ ii ] == 1 ) { \nIndex newc = c . reduce ( ii ) ; \nreturn newc . reduce ( ) ; \n} \nreturn c ; \n} \n} \n"}
{"4939": "public class Index { \nIndex reduce ( int dim ) { \nif ( ( dim < 0 ) || ( dim >= rank ) ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim ) ; \nif ( shape [ dim ] != 1 ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim + \" : length != 1\" ) ; \nIndex newindex = Index . factory ( rank - 1 ) ; \nnewindex . offset = offset ; \nint count = 0 ; \nfor ( int ii = 0 ; \nii < rank ; \nii = ii + 1 ) { \nif ( ii != dim ) { \nnewindex . shape [ count ] = shape [ ii ] ; \nnewindex . stride [ count ] = stride [ ii ] ; \ncount = count + 1 ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4941": "public class Index { \nIndex permute ( int [ ] dims ) { \nif ( dims . length != shape . length ) throw new IllegalArgumentException ( ) ; \nfor ( int dim : dims ) if ( ( dim < 0 ) || ( dim >= rank ) ) throw new IllegalArgumentException ( ) ; \nboolean isPermuted = false ; \nIndex newIndex = ( Index ) this . clone ( ) ; \nfor ( int i = 0 ; \ni < dims . length ; \ni = i + 1 ) { \nnewIndex . stride [ i ] = stride [ dims [ i ] ] ; \nnewIndex . shape [ i ] = shape [ dims [ i ] ] ; \nif ( i != dims [ i ] ) isPermuted = true ; \n} \nnewIndex . fastIterator = fastIterator && ! isPermuted ; \nnewIndex . precalc ( ) ; \nreturn newIndex ; \n} \n} \n"}
{"4943": "public class Index { \npublic int currentElement ( ) { \nint value = offset ; \nfor ( int ii = 0 ; \nii < rank ; \nii = ii + 1 ) { \nif ( shape [ ii ] < 0 ) break ; \nvalue += current [ ii ] * stride [ ii ] ; \n} \nreturn value ; \n} \n} \n"}
{"4951": "public class AbstractGempakStationFileReader { \nprivate List < GempakStation > getStationList ( ) { \nKey slat = findKey ( GempakStation . SLAT ) ; \nif ( slat == null ) { \nreturn null ; \n} \nList < int [ ] > toCheck ; \nif ( slat . type . equals ( ROW ) ) { \ntoCheck = headers . rowHeaders ; \n} \nelse { \ntoCheck = headers . colHeaders ; \n} \nList < GempakStation > fileStations = new ArrayList < > ( ) ; \nint i = 0 ; \nfor ( int [ ] header : toCheck ) { \nif ( header [ 0 ] != IMISSD ) { \nGempakStation station = makeStation ( header ) ; \nif ( station != null ) { \nstation . setIndex ( i + 1 ) ; \nfileStations . add ( station ) ; \n} \n} \ni = i + 1 ; \n} \nreturn fileStations ; \n} \n} \n"}
{"4972": "public class StructureDS { \nprotected ArrayStructure convert ( Array data , Section section ) throws IOException { \nArrayStructure orgAS = ( ArrayStructure ) data ; \nif ( ! convertNeeded ( orgAS . getStructureMembers ( ) ) ) { \nconvertMemberInfo ( orgAS . getStructureMembers ( ) ) ; \nreturn orgAS ; \n} \nArrayStructure newAS = ArrayStructureMA . factoryMA ( orgAS ) ; \nfor ( StructureMembers . Member m : newAS . getMembers ( ) ) { \nVariableEnhanced v2 = ( VariableEnhanced ) findVariable ( m . getName ( ) ) ; \nif ( ( v2 == null ) && ( orgVar != null ) ) v2 = findVariableFromOrgName ( m . getName ( ) ) ; \nif ( v2 == null ) continue ; \nif ( v2 instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v2 ; \nif ( vds . needConvert ( ) ) { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = vds . convert ( mdata , vds . getEnhanceMode ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \nelse if ( v2 instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v2 ; \nif ( innerStruct . convertNeeded ( null ) ) { \nif ( innerStruct . getDataType ( ) == DataType . SEQUENCE ) { \nArrayObject . D1 seqArray = ( ArrayObject . D1 ) newAS . extractMemberArray ( m ) ; \nArrayObject . D1 newSeq = ( ArrayObject . D1 ) Array . factory ( DataType . SEQUENCE , new int [ ] { \n( int ) seqArray . getSize ( ) } \n) ; \nm . setDataArray ( newSeq ) ; \nfor ( int i = 0 ; \ni < seqArray . getSize ( ) ; \ni = i + 1 ) { \nArraySequence innerSeq = ( ArraySequence ) seqArray . get ( i ) ; \nnewSeq . set ( i , new SequenceConverter ( innerStruct , innerSeq ) ) ; \n} \n} \nelse { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = innerStruct . convert ( mdata , null ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \nStructureMembers sm = newAS . getStructureMembers ( ) ; \nconvertMemberInfo ( sm ) ; \nfor ( Variable v : getVariables ( ) ) { \nif ( ! varHasData ( v , sm ) ) { \ntry { \nVariable completeVar = getParentGroup ( ) . findVariable ( v . getShortName ( ) ) ; \nArray mdata = completeVar . read ( section ) ; \nStructureMembers . Member m = sm . addMember ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) , v . getShape ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \ncatch ( InvalidRangeException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \nreturn newAS ; \n} \n} \n"}
{"4979": "public class GempakSoundingIOSP { \nprivate ArraySequence makeArraySequence ( Sequence seq , List < GempakParameter > params , float [ ] values ) { \nif ( values == null ) { \nreturn makeEmptySequence ( seq ) ; \n} \nint numLevels = values . length / params . size ( ) ; \nStructureMembers members = seq . makeStructureMembers ( ) ; \nint offset = ArrayStructureBB . setOffsets ( members ) ; \nint size = offset * numLevels ; \nbyte [ ] bytes = new byte [ size ] ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) ; \nArrayStructureBB abb = new ArrayStructureBB ( members , new int [ ] { \nnumLevels } \n, buf , 0 ) ; \nint var = 0 ; \nfor ( int i = 0 ; \ni < numLevels ; \ni = i + 1 ) { \nfor ( GempakParameter param : params ) { \nif ( members . findMember ( param . getName ( ) ) != null ) { \nbuf . putFloat ( values [ var ] ) ; \n} \nvar = var + 1 ; \n} \n} \nreturn new ArraySequence ( members , new SequenceIterator ( numLevels , abb ) , numLevels ) ; \n} \n} \n"}
{"4997": "public class DOM4Parser { \nList < Node > getSubnodes ( Node parent ) { \nList < Node > subs = new ArrayList < > ( ) ; \nNodeList nodes = parent . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nodes . getLength ( ) ; \ni = i + 1 ) { \nNode n = nodes . item ( i ) ; \nif ( n . getNodeType ( ) == Node . ELEMENT_NODE ) subs . add ( n ) ; \n} \nreturn subs ; \n} \n} \n"}
{"4999": "public class DOM4Parser { \nprotected void passReserved ( Node node , DapNode dap ) throws ParseException { \ntry { \nNamedNodeMap attrs = node . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attrs . getLength ( ) ; \ni = i + 1 ) { \nNode n = attrs . item ( i ) ; \nString key = n . getNodeName ( ) ; \nString value = n . getNodeValue ( ) ; \nif ( isReserved ( key ) ) dap . addXMLAttribute ( key , value ) ; \n} \n} \ncatch ( DapException de ) { \nthrow new ParseException ( de ) ; \n} \n} \n} \n"}
{"5000": "public class CFSimpleGeometryHelper { \npublic static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { \nif ( var == null ) return null ; \nString subStr = \"\" ; \nList < Dimension > dimList = var . getDimensions ( ) ; \nif ( dimList . size ( ) > 2 || dimList . size ( ) < 1 ) { \nreturn null ; \n} \nfor ( int i = 0 ; \ni < dimList . size ( ) ; \ni = i + 1 ) { \nDimension dim = dimList . get ( i ) ; \nif ( dim == null ) continue ; \nif ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) { \nsubStr += id ; \n} \nelse { \nif ( beginInd < 0 || endInd < 0 ) subStr += \":\" ; \nelse subStr += ( beginInd + \":\" + endInd ) ; \n} \nif ( i < dimList . size ( ) - 1 ) { \nsubStr += \",\" ; \n} \n} \nreturn subStr ; \n} \n} \n"}
{"5016": "public class MAMath { \npublic static boolean conformable ( int [ ] shapeA , int [ ] shapeB ) { \nif ( reducedRank ( shapeA ) != reducedRank ( shapeB ) ) return false ; \nint rankB = shapeB . length ; \nint dimB = 0 ; \nfor ( int aShapeA : shapeA ) { \nif ( aShapeA == 1 ) continue ; \nwhile ( dimB < rankB ) if ( shapeB [ dimB ] == 1 ) dimB = dimB + 1 ; \nelse break ; \nif ( aShapeA != shapeB [ dimB ] ) return false ; \ndimB = dimB + 1 ; \n} \nreturn true ; \n} \n} \n"}
{"5028": "public class EscapeStrings { \nstatic public String backslashEscape ( String x , String reservedChars ) { \nif ( x == null ) { \nreturn null ; \n} \nelse if ( reservedChars == null ) { \nreturn x ; \n} \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos = pos + 1 ) { \nchar c = x . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) >= 0 ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int pos = 0 ; \npos < sb . length ( ) ; \npos = pos + 1 ) { \nchar c = sb . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) < 0 ) { \ncontinue ; \n} \nsb . setCharAt ( pos , '\\\\' ) ; \npos = pos + 1 ; \nsb . insert ( pos , c ) ; \npos = pos + 1 ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5029": "public class EscapeStrings { \nstatic public String backslashUnescape ( String x ) { \nif ( ! x . contains ( \"\\\\\" ) ) return x ; \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos = pos + 1 ) { \nchar c = x . charAt ( pos ) ; \nif ( c == '\\\\' ) { \nc = x . charAt ( pos = pos + 1 ) ; \n} \nsb . append ( c ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5032": "public class EscapeStrings { \npublic static String backslashToDAP ( String bs ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint len = bs . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nchar c = bs . charAt ( i ) ; \nif ( i < ( len - 1 ) && c == '\\\\' ) { \nc = bs . charAt ( i = i + 1 ) ; \n} \nif ( _allowableInDAP . indexOf ( c ) < 0 ) { \nbuf . append ( _URIEscape ) ; \nString ashex = Integer . toHexString ( ( int ) c ) ; \nif ( ashex . length ( ) < 2 ) buf . append ( '0' ) ; \nbuf . append ( ashex ) ; \n} \nelse buf . append ( c ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5039": "public class D4DataCompiler { \nprotected D4Cursor compileStructure ( DapVariable var , DapStructure dapstruct , D4Cursor container ) throws DapException { \nint pos = getPos ( this . databuffer ) ; \nD4Cursor d4ds = new D4Cursor ( Scheme . STRUCTURE , ( D4DSP ) this . dsp , var , container ) . setOffset ( pos ) ; \nList < DapVariable > dfields = dapstruct . getFields ( ) ; \nfor ( int m = 0 ; \nm < dfields . size ( ) ; \nm = m + 1 ) { \nDapVariable dfield = dfields . get ( m ) ; \nD4Cursor dvfield = compileVar ( dfield , d4ds ) ; \nd4ds . addField ( m , dvfield ) ; \nassert dfield . getParent ( ) != null ; \n} \nreturn d4ds ; \n} \n} \n"}
{"5041": "public class D4DataCompiler { \npublic D4Cursor compileSequence ( DapVariable var , DapSequence dapseq , D4Cursor container ) throws DapException { \nint pos = getPos ( this . databuffer ) ; \nD4Cursor seq = new D4Cursor ( Scheme . SEQUENCE , this . dsp , var , container ) . setOffset ( pos ) ; \nList < DapVariable > dfields = dapseq . getFields ( ) ; \nlong nrecs = getCount ( this . databuffer ) ; \nfor ( int r = 0 ; \nr < nrecs ; \nr = r + 1 ) { \npos = getPos ( this . databuffer ) ; \nD4Cursor rec = ( D4Cursor ) new D4Cursor ( D4Cursor . Scheme . RECORD , this . dsp , var , container ) . setOffset ( pos ) . setRecordIndex ( r ) ; \nfor ( int m = 0 ; \nm < dfields . size ( ) ; \nm = m + 1 ) { \nDapVariable dfield = dfields . get ( m ) ; \nD4Cursor dvfield = compileVar ( dfield , rec ) ; \nrec . addField ( m , dvfield ) ; \nassert dfield . getParent ( ) != null ; \n} \nseq . addRecord ( rec ) ; \n} \nreturn seq ; \n} \n} \n"}
{"5046": "public class PrefPanel { \npublic Field addField ( Field fld ) { \naddField ( fld , cursorCol , cursorRow , null ) ; \ncursorRow = cursorRow + 1 ; \nreturn fld ; \n} \n} \n"}
{"5059": "public class DoradeRADD { \npublic float getCellSpacing ( ) throws DescriptorException { \nfloat [ ] cellRanges = myCELV . getCellRanges ( ) ; \nfloat cellSpacing = cellRanges [ 1 ] - cellRanges [ 0 ] ; \nfor ( int i = 2 ; \ni < cellRanges . length ; \ni = i + 1 ) { \nfloat space = cellRanges [ i ] - cellRanges [ i - 1 ] ; \nif ( ! Misc . nearlyEquals ( space , cellSpacing ) && ( Math . abs ( space / cellSpacing - 1.0 ) > 0.01 ) ) { \nthrow new DescriptorException ( \"variable cell spacing\" ) ; \n} \n} \nreturn cellSpacing ; \n} \n} \n"}
{"5061": "public class Dimension { \nprotected Factor [ ] mult ( final Dimension that ) { \nfinal Factor [ ] factors1 = _factors ; \nfinal Factor [ ] factors2 = that . _factors ; \nint i1 = 0 ; \nint i2 = 0 ; \nint k = 0 ; \nFactor [ ] newFactors = new Factor [ factors1 . length + factors2 . length ] ; \nfor ( ; \n; \n) { \nif ( i1 == factors1 . length ) { \nfinal int n = factors2 . length - i2 ; \nSystem . arraycopy ( factors2 , i2 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nif ( i2 == factors2 . length ) { \nfinal int n = factors1 . length - i1 ; \nSystem . arraycopy ( factors1 , i1 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nfinal Factor f1 = factors1 [ i1 ] ; \nfinal Factor f2 = factors2 [ i2 ] ; \nfinal int comp = f1 . getID ( ) . compareTo ( f2 . getID ( ) ) ; \nif ( comp < 0 ) { \nnewFactors [ k = k + 1 ] = f1 ; \ni1 = i1 + 1 ; \n} \nelse if ( comp == 0 ) { \nfinal int exponent = f1 . getExponent ( ) + f2 . getExponent ( ) ; \nif ( exponent != 0 ) { \nnewFactors [ k = k + 1 ] = new Factor ( f1 , exponent ) ; \n} \ni1 = i1 + 1 ; \ni2 = i2 + 1 ; \n} \nelse { \nnewFactors [ k = k + 1 ] = f2 ; \ni2 = i2 + 1 ; \n} \n} \nif ( k < newFactors . length ) { \nfinal Factor [ ] tmp = new Factor [ k ] ; \nSystem . arraycopy ( newFactors , 0 , tmp , 0 , k ) ; \nnewFactors = tmp ; \n} \nreturn newFactors ; \n} \n} \n"}
{"5062": "public class Dimension { \nprotected Factor [ ] pow ( final int power ) { \nFactor [ ] factors ; \nif ( power == 0 ) { \nfactors = new Factor [ 0 ] ; \n} \nelse { \nfactors = getFactors ( ) ; \nif ( power != 1 ) { \nfor ( int i = factors . length ; \ni = i - 1 >= 0 ; \n) { \nfactors [ i ] = factors [ i ] . pow ( power ) ; \n} \n} \n} \nreturn factors ; \n} \n} \n"}
{"5063": "public class Dimension { \npublic final boolean isReciprocalOf ( final Dimension that ) { \nfinal Factor [ ] theseFactors = _factors ; \nfinal Factor [ ] thoseFactors = that . _factors ; \nboolean isReciprocalOf ; \nif ( theseFactors . length != thoseFactors . length ) { \nisReciprocalOf = false ; \n} \nelse { \nint i ; \nfor ( i = theseFactors . length ; \ni = i - 1 >= 0 ; \n) { \nif ( ! theseFactors [ i ] . isReciprocalOf ( thoseFactors [ i ] ) ) { \nbreak ; \n} \n} \nisReciprocalOf = i < 0 ; \n} \nreturn isReciprocalOf ; \n} \n} \n"}
{"5064": "public class Dimension { \npublic final boolean isDimensionless ( ) { \nfor ( int i = _factors . length ; \ni = i - 1 >= 0 ; \n) { \nif ( ! _factors [ i ] . isDimensionless ( ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5068": "public class Grib1ParamTables { \npublic static void addParameterTable ( int center , int subcenter , int tableVersion , String tableFilename ) { \nGrib1ParamTableReader table = new Grib1ParamTableReader ( center , subcenter , tableVersion , tableFilename ) ; \nsynchronized ( lock ) { \nstandardLookup . tables . add ( standardTablesStart , table ) ; \nstandardTablesStart = standardTablesStart + 1 ; \n} \n} \n} \n"}
{"5070": "public class LogarithmicUnit { \npublic float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { \nfor ( int i = input . length ; \ni = i - 1 >= 0 ; \n) { \noutput [ i ] = ( float ) ( Math . exp ( input [ i ] * lnBase ) ) ; \n} \nreturn reference . toDerivedUnit ( output , output ) ; \n} \n} \n"}
{"5072": "public class Vis5DIosp { \nprivate Variable makeVerticalVariable ( int vert_sys , int n_levels , float [ ] vert_args ) throws IOException { \nString vert_unit = null ; \nString vert_type ; \nArrayFloat . D1 data = new ArrayFloat . D1 ( n_levels ) ; \nAxisType axisType = null ; \nswitch ( vert_sys ) { \ncase ( 0 ) : vert_unit = null ; \nvert_type = \"height\" ; \nbreak ; \ncase ( 1 ) : case ( 2 ) : vert_unit = \"km\" ; \nvert_type = \"altitude\" ; \naxisType = AxisType . Height ; \nbreak ; \ncase ( 3 ) : vert_unit = \"mbar\" ; \nvert_type = \"pressure\" ; \naxisType = AxisType . Pressure ; \nbreak ; \ndefault : throw new IOException ( \"vert_sys unknown\" ) ; \n} \nVariable vertVar = new Variable ( ncfile , null , null , vert_type ) ; \nvertVar . setDimensions ( LEVEL ) ; \nvertVar . setDataType ( DataType . FLOAT ) ; \nif ( vert_unit != null ) { \nvertVar . addAttribute ( new Attribute ( CDM . UNITS , vert_unit ) ) ; \n} \nif ( axisType != null ) { \nvertVar . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \n} \nswitch ( vert_sys ) { \ncase ( 0 ) : case ( 1 ) : for ( int i = 0 ; \ni < n_levels ; \ni = i + 1 ) { \ndata . set ( i , vert_args [ 0 ] + vert_args [ 1 ] * i ) ; \n} \nbreak ; \ncase ( 2 ) : for ( int i = 0 ; \ni < n_levels ; \ni = i + 1 ) { \ndata . set ( i , vert_args [ i ] ) ; \n} \nbreak ; \ncase ( 3 ) : try { \nVis5DVerticalSystem . Vis5DVerticalCoordinateSystem vert_cs = new Vis5DVerticalSystem . Vis5DVerticalCoordinateSystem ( ) ; \nfloat [ ] [ ] pressures = new float [ 1 ] [ n_levels ] ; \nSystem . arraycopy ( vert_args , 0 , pressures [ 0 ] , 0 , n_levels ) ; \nfor ( int i = 0 ; \ni < n_levels ; \ni = i + 1 ) { \npressures [ 0 ] [ i ] *= 1000 ; \n} \npressures = vert_cs . fromReference ( pressures ) ; \nfor ( int i = 0 ; \ni < n_levels ; \ni = i + 1 ) { \ndata . set ( i , pressures [ 0 ] [ i ] ) ; \n} \n} \ncatch ( VisADException ve ) { \nthrow new IOException ( \"unable to make vertical system\" ) ; \n} \nbreak ; \n} \nvertVar . setCachedData ( data , false ) ; \nreturn vertVar ; \n} \n} \n"}
{"5087": "public class HeaderInputStream { \nprivate void getMoreBytes ( ) throws IOException { \ncurrentOffset = 0 ; \nint bytesRead = 0 ; \nint lookingFor = 0 ; \nfor ( ; \nbytesRead < lineBuf . length ; \nbytesRead = bytesRead + 1 ) { \nint c = in . read ( ) ; \nif ( c == - 1 ) break ; \nlineBuf [ bytesRead ] = ( byte ) c ; \nif ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { \nlookingFor = lookingFor + 1 ; \nif ( lookingFor == endSequence . length ) { \nendFound = true ; \nbreak ; \n} \n} \nelse if ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) { \nlookingFor = 1 ; \n} \nelse { \nlookingFor = 0 ; \n} \n} \nbytesRemaining = bytesRead ; \n} \n} \n"}
{"5088": "public class HeaderInputStream { \npublic int read ( byte b [ ] , int off , int len ) throws IOException { \nif ( len <= 0 ) { \nreturn 0 ; \n} \nint c = read ( ) ; \nif ( c == - 1 ) return - 1 ; \nb [ off ] = ( byte ) c ; \nint i = 1 ; \ntry { \nfor ( ; \ni < len ; \ni = i + 1 ) { \nc = read ( ) ; \nif ( c == - 1 ) { \nbreak ; \n} \nb [ off + i ] = ( byte ) c ; \n} \n} \ncatch ( IOException e ) { \n} \nreturn i ; \n} \n} \n"}
{"5091": "public class GridVertCoord { \nprivate int coordIndex ( GridRecord record ) { \ndouble val = record . getLevel1 ( ) ; \ndouble val2 = record . getLevel2 ( ) ; \nif ( usesBounds && ( val > val2 ) ) { \nval = record . getLevel2 ( ) ; \nval2 = record . getLevel1 ( ) ; \n} \nfor ( int i = 0 ; \ni < levels . size ( ) ; \ni = i + 1 ) { \nLevelCoord lc = ( LevelCoord ) levels . get ( i ) ; \nif ( usesBounds ) { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) && ucar . nc2 . util . Misc . nearlyEquals ( lc . value2 , val2 ) ) { \nreturn i ; \n} \n} \nelse { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) ) { \nreturn i ; \n} \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5095": "public class NOWRadiosp { \npublic byte [ ] readOneRowData ( byte [ ] ddata , int rLen , int xt ) throws IOException , InvalidRangeException { \nint run ; \nbyte [ ] bdata = new byte [ xt ] ; \nint nbin = 0 ; \nint total = 0 ; \nfor ( run = 0 ; \nrun < rLen ; \nrun = run + 1 ) { \nint drun = DataType . unsignedByteToShort ( ddata [ run ] ) >> 4 ; \nbyte dcode1 = ( byte ) ( DataType . unsignedByteToShort ( ddata [ run ] ) & 0Xf ) ; \nfor ( int i = 0 ; \ni < drun ; \ni = i + 1 ) { \nbdata [ nbin = nbin + 1 ] = dcode1 ; \ntotal = total + 1 ; \n} \n} \nif ( total < xt ) { \nfor ( run = total ; \nrun < xt ; \nrun = run + 1 ) { \nbdata [ run ] = 0 ; \n} \n} \nreturn bdata ; \n} \n} \n"}
{"5096": "public class NcDDS { \nprivate void createFromDataset ( NetcdfDataset ncd ) { \nfor ( CoordinateAxis axis : ncd . getCoordinateAxes ( ) ) { \ncoordvars . put ( axis . getShortName ( ) , axis ) ; \n} \nddsvars = new ArrayList < > ( 50 ) ; \nfor ( Variable v : ncd . getVariables ( ) ) { \nif ( coordvars . containsKey ( v . getShortName ( ) ) ) continue ; \nddsvars . add ( v ) ; \nboolean isgridarray = ( v . getRank ( ) > 1 ) && ( v . getDataType ( ) != DataType . STRUCTURE ) && ( v . getParentStructure ( ) == null ) ; \nif ( ! isgridarray ) continue ; \nList < Dimension > dimset = v . getDimensions ( ) ; \nint rank = dimset . size ( ) ; \nfor ( int i = 0 ; \nisgridarray && i < rank ; \ni = i + 1 ) { \nDimension dim = dimset . get ( i ) ; \nif ( dim . getShortName ( ) == null ) isgridarray = false ; \nelse { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv == null ) isgridarray = false ; \n} \n} \nif ( isgridarray ) { \ngridarrays . put ( v . getFullName ( ) , v ) ; \nfor ( Dimension dim : dimset ) { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv != null ) used . put ( gv . getFullName ( ) , gv ) ; \n} \n} \n} \nfor ( Variable cv : ncd . getCoordinateAxes ( ) ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \nfor ( Variable cv : ddsvars ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \n} \n} \n"}
{"5106": "public class DatasetTreeView { \npublic void setSelected ( VariableIF v ) { \nif ( v == null ) { \nreturn ; \n} \nfinal List < VariableIF > vchain = new ArrayList < > ( ) ; \nvchain . add ( v ) ; \nVariableIF vp = v ; \nwhile ( vp . isMemberOfStructure ( ) ) { \nvp = vp . getParentStructure ( ) ; \nvchain . add ( 0 , vp ) ; \n} \nfinal List < Group > gchain = new ArrayList < > ( ) ; \nGroup gp = vp . getParentGroup ( ) ; \ngchain . add ( gp ) ; \nwhile ( gp . getParentGroup ( ) != null ) { \ngp = gp . getParentGroup ( ) ; \ngchain . add ( 0 , gp ) ; \n} \nfinal List < Object > pathList = new ArrayList < > ( ) ; \nGroupNode gnode = ( GroupNode ) model . getRoot ( ) ; \npathList . add ( gnode ) ; \nGroup parentGroup = gchain . get ( 0 ) ; \nfor ( int i = 1 ; \ni < gchain . size ( ) ; \ni = i + 1 ) { \nparentGroup = gchain . get ( i ) ; \ngnode = gnode . findNestedGroup ( parentGroup ) ; \nassert gnode != null ; \npathList . add ( gnode ) ; \n} \nvp = vchain . get ( 0 ) ; \nVariableNode vnode = gnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \nfor ( int i = 1 ; \ni < vchain . size ( ) ; \ni = i + 1 ) { \nvp = vchain . get ( i ) ; \nvnode = vnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \n} \nfinal Object [ ] paths = pathList . toArray ( ) ; \nfinal TreePath treePath = new TreePath ( paths ) ; \ntree . setSelectionPath ( treePath ) ; \ntree . scrollPathToVisible ( treePath ) ; \n} \n} \n"}
{"5113": "public class MultiOdometer { \n@ Override public boolean hasNext ( ) { \nif ( this . current >= odomset . size ( ) ) return false ; \nOdometer ocurrent = odomset . get ( this . current ) ; \nif ( ocurrent . hasNext ( ) ) return true ; \nthis . current = this . current + 1 ; \nreturn hasNext ( ) ; \n} \n} \n"}
{"5117": "public class GradsDataDescriptorFile { \nprivate List < String > getFileNames ( ) throws IOException { \nif ( fileNames == null ) { \nfileNames = new ArrayList < > ( ) ; \ntimeStepsPerFile = tDim . getSize ( ) ; \nif ( ! isTemplate ( ) ) { \nfileNames . add ( getFullPath ( getDataFile ( ) ) ) ; \n} \nelse { \nlong start = System . currentTimeMillis ( ) ; \nList < String > fileSet = new ArrayList < > ( ) ; \nString template = getDataFile ( ) ; \nif ( GradsTimeDimension . hasTimeTemplate ( template ) ) { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TIME_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nelse { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nif ( templateType == ENS_TEMPLATE ) { \nfor ( int e = 0 ; \ne < eDim . getSize ( ) ; \ne = e + 1 ) { \nfileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; \n} \n} \nelse if ( ( templateType == TIME_TEMPLATE ) || ( templateType == ENS_TIME_TEMPLATE ) ) { \nint numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; \nfor ( int t = 0 ; \nt < tDim . getSize ( ) ; \nt = t + 1 ) { \nfor ( int e = 0 ; \ne < numens ; \ne = e + 1 ) { \nString file = getFileName ( e , t ) ; \nif ( ! fileSet . contains ( file ) ) { \nfileSet . add ( file ) ; \n} \n} \n} \ntimeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; \n} \nfileNames . addAll ( fileSet ) ; \n} \nfor ( String file : fileNames ) { \nFile f = new File ( file ) ; \nif ( ! f . exists ( ) ) { \nlog . error ( \"File: \" + f + \" does not exist\" ) ; \nthrow new IOException ( \"File: \" + f + \" does not exist\" ) ; \n} \n} \n} \nreturn fileNames ; \n} \n} \n"}
{"5124": "public class Nidsheader { \nint pcode_12n13n14 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ , String structName , int code ) { \nint vlen = 0 ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nvlen = vlen + dlen [ i ] ; \n} \nArrayList dims = new ArrayList ( ) ; \nDimension sDim = new Dimension ( \"graphicSymbolSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , structName ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"special graphic symbol for code \" + code ) ) ; \nVariable i0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \ni0 . setDimensions ( ( String ) null ) ; \ni0 . setDataType ( DataType . FLOAT ) ; \ni0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( i0 ) ; \nVariable j0 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nj0 . setDimensions ( ( String ) null ) ; \nj0 . setDataType ( DataType . FLOAT ) ; \nj0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( j0 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , code , 0 ) ) ; \nreturn 1 ; \n} \n} \n"}
{"5129": "public class Nidsheader { \nint pcode_10n9 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ ) { \nArrayList dims = new ArrayList ( ) ; \nVariable v ; \nint vlen = 0 ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nvlen = vlen + dlen [ i ] ; \n} \nDimension sDim = new Dimension ( \"unlinkedVectorSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , \"unlinkedVectorStruct\" ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"Unlinked Vector Packet\" ) ) ; \nv = new Variable ( ncfile , null , null , \"iValue\" ) ; \nv . setDataType ( DataType . SHORT ) ; \nv . setDimensions ( ( String ) null ) ; \ndist . addMemberVariable ( v ) ; \nVariable ii0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \nii0 . setDimensions ( ( String ) null ) ; \nii0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii0 ) ; \nVariable ii1 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nii1 . setDimensions ( ( String ) null ) ; \nii1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii1 ) ; \nVariable jj0 = new Variable ( ncfile , null , dist , \"x_end\" ) ; \njj0 . setDimensions ( ( String ) null ) ; \njj0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj0 ) ; \nVariable jj1 = new Variable ( ncfile , null , dist , \"y_end\" ) ; \njj1 . setDimensions ( ( String ) null ) ; \njj1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj1 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , 10 , 0 ) ) ; \nreturn 1 ; \n} \n} \n"}
{"5130": "public class Nidsheader { \npublic int [ ] getLevels ( int nlevel , short [ ] th ) { \nint [ ] levels = new int [ nlevel ] ; \nint ival ; \nint isign ; \nfor ( int i = 0 ; \ni < nlevel ; \ni = i + 1 ) { \nival = convertShort2unsignedInt ( th [ i ] ) ; \nif ( ( ival & 0x00008000 ) == 0 ) { \nisign = - 1 ; \nif ( ( ival & 0x00000100 ) == 0 ) isign = 1 ; \nlevels [ i ] = isign * ( ival & 0x000000FF ) ; \n} \nelse { \nlevels [ i ] = - 9999 + ( ival & 0x000000FF ) ; \n} \n} \nreturn levels ; \n} \n} \n"}
{"5131": "public class Nidsheader { \npublic int [ ] getDualpolLevels ( short [ ] th ) { \nint inc = th . length ; \nint [ ] levels = new int [ inc ] ; \nfor ( int i = 0 ; \ni < inc ; \ni = i + 1 ) { \nlevels [ i ] = th [ i ] ; \n} \nreturn levels ; \n} \n} \n"}
{"5135": "public class Nidsheader { \nint getUInt ( byte [ ] b , int num ) { \nint base = 1 ; \nint i ; \nint word = 0 ; \nint bv [ ] = new int [ num ] ; \nfor ( i = 0 ; \ni < num ; \ni = i + 1 ) { \nbv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \n} \nfor ( i = num - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nword += base * bv [ i ] ; \nbase *= 256 ; \n} \nreturn word ; \n} \n} \n"}
{"5136": "public class Nidsheader { \nint getInt ( byte [ ] b , int num ) { \nint base = 1 ; \nint i ; \nint word = 0 ; \nint bv [ ] = new int [ num ] ; \nfor ( i = 0 ; \ni < num ; \ni = i + 1 ) { \nbv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \n} \nif ( bv [ 0 ] > 127 ) { \nbv [ 0 ] -= 128 ; \nbase = - 1 ; \n} \nfor ( i = num - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nword += base * bv [ i ] ; \nbase *= 256 ; \n} \nreturn word ; \n} \n} \n"}
{"5159": "public class Escape { \nstatic public String entityEscape ( String s , String wrt ) { \nif ( wrt == null ) wrt = ENTITYESCAPES ; \nStringBuilder escaped = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni = i + 1 ) { \nchar c = s . charAt ( i ) ; \nint index = wrt . indexOf ( c ) ; \nif ( index < 0 ) escaped . append ( c ) ; \nelse switch ( c ) { \ncase '&' : escaped . append ( '&' + ENTITY_AMP + ';' ) ; \nbreak ; \ncase '<' : escaped . append ( '&' + ENTITY_LT + ';' ) ; \nbreak ; \ncase '>' : escaped . append ( '&' + ENTITY_GT + ';' ) ; \nbreak ; \ncase '\"' : escaped . append ( '&' + ENTITY_QUOT + ';' ) ; \nbreak ; \ncase '\\'' : escaped . append ( '&' + ENTITY_APOS + ';' ) ; \nbreak ; \ncase '\\r' : case '\\t' : case '\\n' : escaped . append ( c ) ; \nbreak ; \ncase '\\0' : break ; \ndefault : if ( c >= ' ' ) escaped . append ( c ) ; \nbreak ; \n} \n} \nreturn escaped . toString ( ) ; \n} \n} \n"}
{"5160": "public class Escape { \nstatic public String backslashUnescape ( String s ) { \nStringBuilder clear = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \n) { \nchar c = s . charAt ( i = i + 1 ) ; \nif ( c == '\\\\' ) { \nc = s . charAt ( i = i + 1 ) ; \nswitch ( c ) { \ncase 'r' : c = '\\r' ; \nbreak ; \ncase 'n' : c = '\\n' ; \nbreak ; \ncase 't' : c = '\\t' ; \nbreak ; \ncase 'f' : c = '\\f' ; \nbreak ; \ndefault : break ; \n} \nclear . append ( c ) ; \n} \nelse clear . append ( c ) ; \n} \nreturn clear . toString ( ) ; \n} \n} \n"}
{"5161": "public class Escape { \nstatic public List < String > backslashsplit ( String s , char sep ) { \nList < String > path = new ArrayList < String > ( ) ; \nint len = s . length ( ) ; \nStringBuilder piece = new StringBuilder ( ) ; \nint i = 0 ; \nfor ( ; \ni <= len - 1 ; \ni = i + 1 ) { \nchar c = s . charAt ( i ) ; \nif ( c == '\\\\' && i < ( len - 1 ) ) { \npiece . append ( c ) ; \npiece . append ( s . charAt ( i = i + 1 ) ) ; \n} \nelse if ( c == sep ) { \npath . add ( piece . toString ( ) ) ; \npiece . setLength ( 0 ) ; \n} \nelse piece . append ( c ) ; \n} \npath . add ( piece . toString ( ) ) ; \nreturn path ; \n} \n} \n"}
{"5164": "public class DGrid { \npublic int projectedComponents ( boolean constrained ) { \nint comp ; \nif ( constrained ) { \ncomp = ( ( DArray ) arrayVar ) . isProject ( ) ? 1 : 0 ; \nEnumeration e = mapVars . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \nif ( ( ( DArray ) e . nextElement ( ) ) . isProject ( ) ) comp = comp + 1 ; \n} \n} \nelse { \ncomp = 1 + mapVars . size ( ) ; \n} \nreturn comp ; \n} \n} \n"}
{"5181": "public class ConfigCatalogInitialization { \nprivate void processDatasets ( long catId , ReadMode readMode , String dirPath , List < Dataset > datasets , Set < String > idMap ) throws IOException { \nif ( exceedLimit ) return ; \nfor ( Dataset ds : datasets ) { \nif ( datasetTracker . trackDataset ( catId , ds , callback ) ) countDatasets = countDatasets + 1 ; \nif ( maxDatasetsProcess > 0 && countDatasets > maxDatasetsProcess ) exceedLimit = true ; \nString id = ds . getID ( ) ; \nif ( id != null ) { \nif ( idMap . contains ( id ) ) { \nlogCatalogInit . error ( ERROR + \"Duplicate id on  '\" + ds . getName ( ) + \"' id= '\" + id + \"'\" ) ; \n} \nelse { \nidMap . add ( id ) ; \n} \n} \nif ( ( ds instanceof DatasetScan ) || ( ds instanceof FeatureCollectionRef ) ) continue ; \nif ( ds instanceof CatalogScan ) continue ; \nif ( ds instanceof CatalogRef ) { \nCatalogRef catref = ( CatalogRef ) ds ; \nString href = catref . getXlinkHref ( ) ; \nif ( ! href . startsWith ( \"http:\" ) ) { \nif ( href . startsWith ( \"./\" ) ) { \nhref = href . substring ( 2 ) ; \n} \nString path ; \nString contextPathPlus = this . contextPath + \"/\" ; \nif ( href . startsWith ( contextPathPlus ) ) { \npath = href . substring ( contextPathPlus . length ( ) ) ; \n} \nelse if ( href . startsWith ( \"/\" ) ) { \nlogCatalogInit . error ( ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" + \"Parent catalog info: Name=\\\"\" + catref . getParentCatalog ( ) . getName ( ) + \"\\\"; Base URI=\\\"\" + catref . getParentCatalog ( ) . getUriString ( ) + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\" ) ; \ncontinue ; \n} \nelse { \npath = dirPath + href ; \n} \nCatalogExt ext = catalogTracker . get ( path ) ; \nlong lastRead = ( ext == null ) ? 0 : ext . getLastRead ( ) ; \ncheckCatalogToRead ( readMode , path , false , lastRead ) ; \n} \n} \nelse { \nprocessDatasets ( catId , readMode , dirPath , ds . getDatasetsLocal ( ) , idMap ) ; \n} \n} \n} \n} \n"}
{"5194": "public class VlenIO { \npublic int writeVInt ( int i ) throws IOException { \nint count = 0 ; \nwhile ( ( i & ~ 0x7F ) != 0 ) { \nwriteByte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; \ni >>>= 7 ; \ncount = count + 1 ; \n} \nwriteByte ( ( byte ) i ) ; \nreturn count + 1 ; \n} \n} \n"}
{"5195": "public class VlenIO { \npublic int writeChars ( String s , int start , int length ) throws IOException { \nfinal int end = start + length ; \nint count = 0 ; \nfor ( int i = start ; \ni < end ; \ni = i + 1 ) { \nfinal int code = ( int ) s . charAt ( i ) ; \nif ( code >= 0x01 && code <= 0x7F ) { \nwriteByte ( ( byte ) code ) ; \ncount = count + 1 ; \n} \nelse if ( ( ( code >= 0x80 ) && ( code <= 0x7FF ) ) || code == 0 ) { \nwriteByte ( ( byte ) ( 0xC0 | ( code >> 6 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 2 ; \n} \nelse { \nwriteByte ( ( byte ) ( 0xE0 | ( code >>> 12 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( ( code >> 6 ) & 0x3F ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 3 ; \n} \n} \nreturn count ; \n} \n} \n"}
{"5196": "public class VlenIO { \npublic void readChars ( char [ ] buffer , int start , int length ) throws IOException { \nfinal int end = start + length ; \nfor ( int i = start ; \ni < end ; \ni = i + 1 ) { \nbyte b = readByte ( ) ; \nif ( ( b & 0x80 ) == 0 ) buffer [ i ] = ( char ) ( b & 0x7F ) ; \nelse if ( ( b & 0xE0 ) != 0xE0 ) { \nbuffer [ i ] = ( char ) ( ( ( b & 0x1F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \nelse buffer [ i ] = ( char ) ( ( ( b & 0x0F ) << 12 ) | ( ( readByte ( ) & 0x3F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \n} \n} \n"}
{"5203": "public class JTreeTableSorted { \npublic void restoreState ( PreferencesExt store ) { \nif ( store == null ) return ; \nint ncols = table . getColumnCount ( ) ; \nint [ ] modelIndex = ( int [ ] ) store . getBean ( \"ColumnOrder\" , null ) ; \nif ( ( modelIndex != null ) && ( modelIndex . length == ncols ) ) { \nboolean [ ] visible = new boolean [ ncols ] ; \nfor ( int aModelIndex : modelIndex ) if ( aModelIndex < ncols ) visible [ aModelIndex ] = true ; \nfor ( int i = 0 ; \ni < ncols ; \ni = i + 1 ) if ( ! visible [ i ] ) { \nacts [ i ] . hideColumn ( ) ; \nacts [ i ] . putValue ( BAMutil . STATE , new Boolean ( false ) ) ; \n} \nTableColumnModel tcm = table . getColumnModel ( ) ; \nint n = Math . min ( modelIndex . length , table . getColumnCount ( ) ) ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nTableColumn tc = tcm . getColumn ( i ) ; \ntc . setModelIndex ( modelIndex [ i ] ) ; \nString name = model . getColumnName ( modelIndex [ i ] ) ; \ntc . setHeaderValue ( name ) ; \ntc . setIdentifier ( name ) ; \nif ( useThreads && ( modelIndex [ i ] == threadCol ) ) { \nthreadHeaderRenderer = new ThreadHeaderRenderer ( threadCol ) ; \ntc . setHeaderRenderer ( threadHeaderRenderer ) ; \n} \nelse tc . setHeaderRenderer ( new SortedHeaderRenderer ( name , modelIndex [ i ] ) ) ; \n} \n} \nObject colWidths = store . getBean ( \"ColumnWidths\" , null ) ; \nif ( colWidths == null ) return ; \nint [ ] size = ( int [ ] ) colWidths ; \nsetColumnWidths ( size ) ; \nif ( debug ) { \nSystem . out . println ( \" read widths = \" ) ; \nfor ( int aSize : size ) System . out . print ( \" \" + aSize ) ; \nSystem . out . println ( ) ; \n} \nboolean isThreadsOn = store . getBoolean ( \"isThreadsOn\" , false ) ; \nif ( useThreads ) { \nmodel . setThreadsOn ( isThreadsOn ) ; \nthreadHeaderRenderer . setOn ( isThreadsOn ) ; \n} \nint colNo = store . getInt ( \"SortOnCol\" , 0 ) ; \nboolean reverse = store . getBoolean ( \"SortReverse\" , false ) ; \nmodel . setSortCol ( colNo ) ; \nmodel . setReverse ( reverse ) ; \nsetSortCol ( colNo , reverse ) ; \nmodel . sort ( ) ; \ntable . fireDataChanged ( ) ; \n} \nprivate void setColumnWidths ( int [ ] sizes ) { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( int i = 0 ; \ni < table . getColumnCount ( ) ; \ni = i + 1 ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nint maxw = ( ( sizes == null ) || ( i >= sizes . length ) ) ? 10 : sizes [ i ] ; \ntc . setPreferredWidth ( maxw ) ; \n} \n} \npublic void setColOn ( int colno , boolean state , int pos ) { \nacts [ colno ] . putValue ( BAMutil . STATE , new Boolean ( state ) ) ; \nif ( state ) acts [ colno ] . addAtPos ( pos ) ; \nelse acts [ colno ] . hideColumn ( ) ; \n} \n} \n"}
{"5205": "public class JTreeTableSorted { \npublic int [ ] getModelIndex ( ) { \nint [ ] modelIndex = new int [ model . getColumnCount ( ) ] ; \ntry { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( int i = 0 ; \ni < model . getColumnCount ( ) ; \ni = i + 1 ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nmodelIndex [ i ] = tc . getModelIndex ( ) ; \n} \n} \ncatch ( java . lang . ArrayIndexOutOfBoundsException e ) { \n} \nreturn modelIndex ; \n} \n} \n"}
{"5227": "public class GridVariable { \npublic void showMissing ( Formatter f ) { \nint count = 0 , total = 0 ; \nf . format ( \"  %s%n\" , name ) ; \nfor ( int j = 0 ; \nj < nlevels ; \nj = j + 1 ) { \nf . format ( \"   \" ) ; \nfor ( int i = 0 ; \ni < ntimes ; \ni = i + 1 ) { \nboolean missing = recordTracker [ i * nlevels + j ] == null ; \nf . format ( \"%s\" , missing ? \"-\" : \"X\" ) ; \nif ( missing ) count = count + 1 ; \ntotal = total + 1 ; \n} \nf . format ( \"%n\" ) ; \n} \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \n} \n} \n"}
{"5228": "public class GridVariable { \npublic int showMissingSummary ( Formatter f ) { \nint count = 0 ; \nint total = recordTracker . length ; \nfor ( int i = 0 ; \ni < total ; \ni = i + 1 ) { \nif ( recordTracker [ i ] == null ) count = count + 1 ; \n} \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \nreturn count ; \n} \n} \n"}
{"5233": "public class NCheader { \nstatic boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { \nif ( b1 == b2 ) return true ; \nif ( b1 == null || b2 == null ) return false ; \nif ( b1 . length < len || b2 . length < len ) return false ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nif ( b1 [ i ] != b2 [ i ] ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"5237": "public class GdsHorizCoordSys { \npublic void setGaussianLats ( int nparallels , float la1 , float la2 ) { \nlog . debug ( \"la1 {}, la2 {}\" , la1 , la2 ) ; \nif ( this . gaussLats != null ) throw new RuntimeException ( \"Cant modify GdsHorizCoordSys\" ) ; \nint nlats = ( 2 * nparallels ) ; \nGaussianLatitudes gaussLats = GaussianLatitudes . factory ( nlats ) ; \nint bestStartIndex = 0 , bestEndIndex = 0 ; \ndouble bestStartDiff = Double . MAX_VALUE ; \ndouble bestEndDiff = Double . MAX_VALUE ; \nfor ( int i = 0 ; \ni < nlats ; \ni = i + 1 ) { \ndouble diff = Math . abs ( gaussLats . latd [ i ] - la1 ) ; \nif ( diff < bestStartDiff ) { \nbestStartDiff = diff ; \nbestStartIndex = i ; \n} \ndiff = Math . abs ( gaussLats . latd [ i ] - la2 ) ; \nif ( diff < bestEndDiff ) { \nbestEndDiff = diff ; \nbestEndIndex = i ; \n} \n} \nlog . debug ( \"first pass: bestStartIndex {}, bestEndIndex {}\" , bestStartIndex , bestEndIndex ) ; \nif ( Math . abs ( bestEndIndex - bestStartIndex ) + 1 != nyRaw ) { \nlog . warn ( \"GRIB gaussian lats: NP != NY, use NY\" ) ; \nnlats = nyRaw ; \ngaussLats = GaussianLatitudes . factory ( nlats ) ; \nbestStartIndex = 0 ; \nbestEndIndex = nyRaw - 1 ; \n} \nboolean goesUp = bestEndIndex > bestStartIndex ; \nlog . debug ( \"bestStartIndex {}, bestEndIndex {}, goesUp {}\" , bestStartIndex , bestEndIndex , goesUp ) ; \nint useIndex = bestStartIndex ; \nfloat [ ] data = new float [ nyRaw ] ; \nfloat [ ] gaussw = new float [ nyRaw ] ; \nfor ( int i = 0 ; \ni < nyRaw ; \ni = i + 1 ) { \ndata [ i ] = ( float ) gaussLats . latd [ useIndex ] ; \ngaussw [ i ] = ( float ) gaussLats . gaussw [ useIndex ] ; \nlog . trace ( \"i {}, useIndex {}, data {}, gaussw {}\" , i , useIndex , data [ i ] , gaussw [ i ] ) ; \nif ( goesUp ) { \nuseIndex = useIndex + 1 ; \n} \nelse { \nuseIndex = useIndex - 1 ; \n} \n} \nthis . gaussLats = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, data ) ; \nthis . gaussw = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, gaussw ) ; \n} \n} \n"}
{"5240": "public class GeoGridCoordinate2D { \nprivate boolean box9 ( double wantLat , double wantLon , int [ ] rectIndex ) { \nint row = rectIndex [ 0 ] ; \nint minrow = Math . max ( row - 1 , 0 ) ; \nint maxrow = Math . min ( row + 1 , nrows ) ; \nint col = rectIndex [ 1 ] ; \nint mincol = Math . max ( col - 1 , 0 ) ; \nint maxcol = Math . min ( col + 1 , ncols ) ; \nif ( debug ) System . out . printf ( \"%n   box9:\" ) ; \nfor ( int i = minrow ; \ni <= maxrow ; \ni = i + 1 ) for ( int j = mincol ; \nj <= maxcol ; \nj = j + 1 ) { \nrectIndex [ 0 ] = i ; \nrectIndex [ 1 ] = j ; \nif ( contains ( wantLat , wantLon , rectIndex ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"5247": "public class ProgressMonitor { \npublic void start ( java . awt . Component top , String taskName , int progressMaxCount ) { \npm = new javax . swing . ProgressMonitor ( top , taskName , \"\" , 0 , progressMaxCount ) ; \npm . setMillisToDecideToPopup ( millisToDecideToPopup ) ; \npm . setMillisToPopup ( millisToPopup ) ; \ntaskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nsecs = secs + 1 ; \nif ( pm . isCanceled ( ) ) { \ntask . cancel ( ) ; \n} \nelse { \nString note = task . getNote ( ) ; \npm . setNote ( note == null ? secs + \" secs\" : note ) ; \nint progress = task . getProgress ( ) ; \npm . setProgress ( progress <= 0 ? secs : progress ) ; \n} \nif ( task . isDone ( ) ) { \ntimer . stop ( ) ; \npm . close ( ) ; \nif ( task . isError ( ) ) { \njavax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \n} \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \n} \n} \n} \n; \ntimer = new javax . swing . Timer ( 1000 , watcher ) ; \ntimer . start ( ) ; \n} \n} \n"}
{"5248": "public class HTTPUtil { \nstatic public URI parseToURI ( final String u ) throws URISyntaxException { \nStringBuilder buf = new StringBuilder ( ) ; \nint i = 0 ; \nwhile ( i < u . length ( ) ) { \nchar c = u . charAt ( i ) ; \nif ( c == '\\\\' ) { \nif ( i + 1 == u . length ( ) ) throw new URISyntaxException ( u , \"Trailing '\\' at end of url\" ) ; \nbuf . append ( \"%5c\" ) ; \ni = i + 1 ; \nc = u . charAt ( i ) ; \nbuf . append ( String . format ( \"%%%02x\" , ( int ) c ) ) ; \n} \nelse buf . append ( c ) ; \ni = i + 1 ; \n} \nreturn new URI ( buf . toString ( ) ) ; \n} \n} \n"}
{"5251": "public class HTTPUtil { \nstatic public String canonjoin ( String prefix , String suffix ) { \nif ( prefix == null ) prefix = \"\" ; \nif ( suffix == null ) suffix = \"\" ; \nprefix = HTTPUtil . canonicalpath ( prefix ) ; \nsuffix = HTTPUtil . canonicalpath ( suffix ) ; \nStringBuilder result = new StringBuilder ( ) ; \nresult . append ( prefix ) ; \nint prelen = prefix . length ( ) ; \nif ( prelen > 0 && result . charAt ( prelen - 1 ) != '/' ) { \nresult . append ( '/' ) ; \nprelen = prelen + 1 ; \n} \nif ( suffix . length ( ) > 0 && suffix . charAt ( 0 ) == '/' ) result . append ( suffix . substring ( 1 ) ) ; \nelse result . append ( suffix ) ; \nint len = result . length ( ) ; \nif ( len > 0 && result . charAt ( len - 1 ) == '/' ) { \nresult . deleteCharAt ( len - 1 ) ; \nlen = len - 1 ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"5269": "public class WFSGetFeatureWriter { \npublic void writeMembers ( ) { \nint index = 1 ; \nGMLFeatureWriter writer = new GMLFeatureWriter ( ) ; \nfor ( SimpleGeometry geometryItem : geometries ) { \ndouble [ ] lowerCorner = geometryItem . getBBLower ( ) ; \ndouble [ ] upperCorner = geometryItem . getBBUpper ( ) ; \nfileOutput += \"<wfs:member>\" + \"<\" + WFSController . TDSNAMESPACE + \":\" + ftName + \" gml:id=\\\"\" + ftName + \".\" + index + \"\\\">\" + \"<gml:boundedBy>\" + \"<gml:Envelope srsName=\" + \"\\\"urn:ogc:def:crs:EPSG::4326\\\"\" + \">\" + \"<gml:lowerCorner>\" + lowerCorner [ 0 ] + \" \" + lowerCorner [ 1 ] + \"</gml:lowerCorner>\" + \"<gml:upperCorner>\" + upperCorner [ 0 ] + \" \" + upperCorner [ 1 ] + \"</gml:upperCorner>\" + \"</gml:Envelope>\" + \"</gml:boundedBy>\" + \"<\" + WFSController . TDSNAMESPACE + \":geometryInformation>\" ; \nfileOutput += writer . writeFeature ( geometryItem ) ; \nfileOutput += \"</\" + WFSController . TDSNAMESPACE + \":geometryInformation>\" + \"</\" + WFSController . TDSNAMESPACE + \":\" + ftName + \">\" + \"</wfs:member>\" ; \nindex = index + 1 ; \n} \n} \n} \n"}
{"5272": "public class ChunkWriter { \npublic void writeDSR ( String dsr ) throws IOException { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to write DSR twice\" ) ; \nif ( dsr == null ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \nint len = dsr . length ( ) ; \nwhile ( len > 0 ) { \nchar c = dsr . charAt ( len - 1 ) ; \nif ( c != '\\r' && c != '\\n' ) break ; \nlen = len - 1 ; \n} \nif ( dsr . length ( ) == 0 ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \ndsr = dsr . substring ( 0 , len ) + DapUtil . CRLF ; \ndsr = XMLDOCUMENTHEADER + \"\\n\" + dsr ; \nbyte [ ] dsr8 = DapUtil . extract ( DapUtil . UTF8 . encode ( dsr ) ) ; \nsendDXR ( dsr8 ) ; \nstate = State . END ; \n} \n} \n"}
{"5283": "public class BooleanPrimitiveVector { \npublic PrimitiveVector subset ( int start , int stop , int stride ) { \nBooleanPrimitiveVector n = new BooleanPrimitiveVector ( getTemplate ( ) ) ; \nstride = Math . max ( stride , 1 ) ; \nstop = Math . max ( start , stop ) ; \nint length = 1 + ( stop - start ) / stride ; \nn . setLength ( length ) ; \nint count = 0 ; \nfor ( int i = start ; \ni <= stop ; \ni += stride ) { \nn . setValue ( count , vals [ i ] ) ; \ncount = count + 1 ; \n} \nreturn n ; \n} \n} \n"}
{"5285": "public class DatasetTrackerChronicle { \npublic static void cleanupBefore ( String pathname , long trackerNumber ) { \nfor ( long tnum = trackerNumber - 1 ; \ntnum > 0 ; \ntnum = tnum - 1 ) { \nFile oldDatabaseFile = new File ( pathname + datasetName + \".\" + tnum ) ; \nif ( ! oldDatabaseFile . exists ( ) ) break ; \nif ( oldDatabaseFile . delete ( ) ) { \ncatalogInitLog . info ( \"DatasetTrackerChronicle deleted {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \nelse { \ncatalogInitLog . error ( \"DatasetTrackerChronicle not able to delete {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \n"}
{"5288": "public class McIDASAreaProjection { \nprivate double [ ] makeDoubleArray ( int [ ] ints ) { \ndouble [ ] newArray = new double [ ints . length ] ; \nfor ( int i = 0 ; \ni < ints . length ; \ni = i + 1 ) { \nnewArray [ i ] = ints [ i ] ; \n} \nreturn newArray ; \n} \n} \n"}
{"5293": "public class GridIndexToNC { \nprivate void makeVerticalDimensions ( List < GridVertCoord > vertCoordList , NetcdfFile ncfile , Group group ) { \nGridVertCoord gvcs0 = null ; \nint maxLevels = 0 ; \nfor ( GridVertCoord gvcs : vertCoordList ) { \nif ( gvcs . getNLevels ( ) > maxLevels ) { \ngvcs0 = gvcs ; \nmaxLevels = gvcs . getNLevels ( ) ; \n} \n} \nint seqno = 1 ; \nfor ( GridVertCoord gvcs : vertCoordList ) { \nif ( gvcs != gvcs0 ) { \ngvcs . setSequence ( seqno = seqno + 1 ) ; \n} \ngvcs . addDimensionsToNetcdfFile ( ncfile , group ) ; \n} \n} \n} \n"}
{"5302": "public class InvDatasetImpl { \npublic boolean replaceDataset ( InvDatasetImpl remove , InvDatasetImpl add ) { \nfor ( int i = 0 ; \ni < datasets . size ( ) ; \ni = i + 1 ) { \nInvDataset dataset = datasets . get ( i ) ; \nif ( dataset . equals ( remove ) ) { \ndatasets . set ( i , add ) ; \nInvCatalogImpl cat = ( InvCatalogImpl ) getParentCatalog ( ) ; \nif ( cat != null ) { \ncat . removeDatasetByID ( remove ) ; \ncat . addDatasetByID ( add ) ; \n} \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5312": "public class WFSController { \nprivate WFSExceptionWriter getFeature ( PrintWriter out , HttpServletRequest hsreq , SimpleGeometryCSBuilder sgcs , String ftName , String fullFtName ) { \nList < SimpleGeometry > geometryList = new ArrayList < SimpleGeometry > ( ) ; \nGeometryType geoT = sgcs . getGeometryType ( ftName ) ; \nif ( geoT == null ) { \nreturn new WFSExceptionWriter ( \"Feature Type of \" + fullFtName + \" not found.\" , \"GetFeature\" , \"OperationProcessingFailed\" ) ; \n} \ntry { \nswitch ( geoT ) { \ncase POINT : Point pt = sgcs . getPoint ( ftName , 0 ) ; \nint j = 0 ; \nwhile ( pt != null ) { \ngeometryList . add ( pt ) ; \nj = j + 1 ; \npt = sgcs . getPoint ( ftName , j ) ; \n} \nbreak ; \ncase LINE : Line line = sgcs . getLine ( ftName , 0 ) ; \nint k = 0 ; \nwhile ( line != null ) { \ngeometryList . add ( line ) ; \nk = k + 1 ; \nline = sgcs . getLine ( ftName , k ) ; \n} \nbreak ; \ncase POLYGON : Polygon poly = sgcs . getPolygon ( ftName , 0 ) ; \nint i = 0 ; \nwhile ( poly != null ) { \ngeometryList . add ( poly ) ; \ni = i + 1 ; \npoly = sgcs . getPolygon ( ftName , i ) ; \n} \nbreak ; \n} \n} \ncatch ( ArrayIndexOutOfBoundsException aout ) { \n} \nWFSGetFeatureWriter gfdw = new WFSGetFeatureWriter ( out , WFSController . constructServerPath ( hsreq ) , WFSController . getXMLNamespaceXMLNSValue ( hsreq ) , geometryList , ftName ) ; \ngfdw . startXML ( ) ; \ngfdw . writeMembers ( ) ; \ngfdw . finishXML ( ) ; \nreturn null ; \n} \n} \n"}
{"5313": "public class WFSController { \nprivate WFSExceptionWriter checkParametersForError ( String request , String version , String service , String typeName ) { \nif ( service != null ) { \nif ( ! service . equalsIgnoreCase ( \"WFS\" ) ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. SERVICE parameter must be of value WFS.\" , \"service\" , \"InvalidParameterValue\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. SERVICE parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( request != null ) { \nif ( ! request . equalsIgnoreCase ( WFSRequestType . GetCapabilities . toString ( ) ) ) { \nif ( version != null ) { \nString [ ] versionParts = version . split ( \"\\\\.\" ) ; \nfor ( int ind = 0 ; \nind < versionParts . length ; \nind = ind + 1 ) { \ntry { \nInteger . valueOf ( versionParts [ ind ] ) ; \n} \ncatch ( NumberFormatException excep ) { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter consists of invalid characters.\" , \"version\" , \"InvalidParameterValue\" ) ; \n} \n} \nboolean validVersion = false ; \nif ( versionParts . length == 1 ) if ( versionParts [ 0 ] . equals ( \"2\" ) ) validVersion = true ; \nif ( versionParts . length >= 2 ) if ( versionParts [ 0 ] . equals ( \"2\" ) && versionParts [ 1 ] . equals ( \"0\" ) ) validVersion = true ; \nif ( ! validVersion ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. Version requested is not supported.\" , null , \"VersionNegotiationFailed\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( typeName == null ) { \nreturn new WFSExceptionWriter ( \"WFS server error. For the specifed request, parameter typename or typenames must be specified.\" , request , \"MissingParameterValue\" ) ; \n} \n} \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nif ( reqToProc == null ) return new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is not valid. Possible values: GetCapabilities, \" + \"DescribeFeatureType, GetFeature\" , \"request\" , \"InvalidParameterValue\" ) ; \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nreturn null ; \n} \n} \n"}
{"5330": "public class BitCounterUncompressed { \nint countBits ( int startBit ) { \ncountBits = replicationCountSize ; \nthis . startBit = new int [ nrows ] ; \nfor ( int i = 0 ; \ni < nrows ; \ni = i + 1 ) { \nthis . startBit [ i ] = startBit + countBits ; \nif ( debug ) System . out . println ( \" BitCounterUncompressed row \" + i + \" startBit=\" + this . startBit [ i ] ) ; \nfor ( DataDescriptor nd : parent . subKeys ) { \nBitCounterUncompressed [ ] bitCounter = ( subCounters == null ) ? null : subCounters . get ( nd ) ; \nif ( bitCounter == null ) countBits += nd . getBitWidth ( ) ; \nelse { \nif ( debug ) System . out . println ( \" ---------> nested \" + nd . getFxyName ( ) + \" starts at =\" + ( startBit + countBits ) ) ; \ncountBits += bitCounter [ i ] . countBits ( startBit + countBits ) ; \nif ( debug ) System . out . println ( \" <--------- nested \" + nd . getFxyName ( ) + \" ends at =\" + ( startBit + countBits ) ) ; \n} \n} \n} \nreturn countBits ; \n} \n} \n"}
{"5331": "public class TextHistoryPane { \npublic void appendLine ( String line ) { \nif ( count >= nlines ) { \ntry { \nint remove = Math . max ( removeIncr , count - nlines ) ; \nint offset = ta . getLineEndOffset ( remove ) ; \nta . replaceRange ( \"\" , 0 , offset ) ; \n} \ncatch ( Exception e ) { \nlog . error ( \"Problem in TextHistoryPane\" , e ) ; \n} \ncount = nlines - removeIncr ; \n} \nta . append ( line ) ; \nta . append ( \"\\n\" ) ; \ncount = count + 1 ; \nta . setCaretPosition ( ta . getText ( ) . length ( ) ) ; \n} \n} \n"}
{"5334": "public class VariableIndex { \n@ Nullable synchronized Record getRecordAt ( SubsetParams coords ) { \nint [ ] want = new int [ getRank ( ) ] ; \nint count = 0 ; \nint runIdx = - 1 ; \nfor ( Coordinate coord : getCoordinates ( ) ) { \nint idx = - 1 ; \nswitch ( coord . getType ( ) ) { \ncase runtime : CalendarDate runtimeCooord = coords . getRunTime ( ) ; \nidx = coord . getIndex ( runtimeCooord ) ; \nrunIdx = idx ; \nbreak ; \ncase timeIntv : double [ ] timeIntv = coords . getTimeOffsetIntv ( ) ; \nidx = coord . getIndex ( new TimeCoordIntvValue ( ( int ) timeIntv [ 0 ] , ( int ) timeIntv [ 1 ] ) ) ; \nbreak ; \ncase time : Double timeOffset = coords . getTimeOffset ( ) ; \nint coordInt = timeOffset . intValue ( ) ; \nidx = coord . getIndex ( coordInt ) ; \nbreak ; \ncase time2D : timeIntv = coords . getTimeOffsetIntv ( ) ; \nif ( timeIntv != null ) { \nTimeCoordIntvValue coordTinv = new TimeCoordIntvValue ( ( int ) timeIntv [ 0 ] , ( int ) timeIntv [ 1 ] ) ; \nidx = ( ( CoordinateTime2D ) coord ) . findTimeIndexFromVal ( runIdx , coordTinv ) ; \nbreak ; \n} \nDouble timeCoord = coords . getTimeOffset ( ) ; \nif ( timeCoord != null ) { \ncoordInt = timeCoord . intValue ( ) ; \nidx = ( ( CoordinateTime2D ) coord ) . findTimeIndexFromVal ( runIdx , coordInt ) ; \nbreak ; \n} \nCoordinateTime2D coord2D = ( CoordinateTime2D ) coord ; \nif ( coord2D . getNtimes ( ) == 1 ) { \nidx = 0 ; \nbreak ; \n} \nthrow new IllegalStateException ( \"time2D must have timeOffset ot timeOffsetIntv coordinare\" ) ; \ncase vert : double [ ] vertIntv = coords . getVertCoordIntv ( ) ; \nif ( vertIntv != null ) { \nVertCoordValue coordVert = new VertCoordValue ( vertIntv [ 0 ] , vertIntv [ 1 ] ) ; \nidx = coord . getIndex ( coordVert ) ; \nbreak ; \n} \nDouble vertCoord = coords . getVertCoord ( ) ; \nif ( vertCoord != null ) { \nVertCoordValue coordVert = new VertCoordValue ( vertCoord ) ; \nidx = coord . getIndex ( coordVert ) ; \n} \nbreak ; \ncase ens : Double ensVal = coords . getEnsCoord ( ) ; \nidx = ( ( CoordinateEns ) coord ) . getIndexByMember ( ensVal ) ; \nbreak ; \ndefault : logger . warn ( \"GribCollectionImmutable: missing CoordVal for {}%n\" , coord . getName ( ) ) ; \n} \nif ( idx < 0 ) { \nlogger . debug ( \"Cant find index for value in axis {} in variable {}\" , coord . getName ( ) , name ) ; \nreturn null ; \n} \nwant [ count = count + 1 ] = idx ; \n} \nreturn sa . getContent ( want ) ; \n} \n} \n"}
{"5336": "public class ComboBox { \npublic void addItem ( Object item ) { \nif ( item == null ) return ; \nfor ( int i = 0 ; \ni < getItemCount ( ) ; \ni = i + 1 ) { \nif ( item . equals ( getItemAt ( i ) ) ) { \nif ( i == 0 ) { \nsetSelectedIndex ( 0 ) ; \nreturn ; \n} \nremoveItemAt ( i ) ; \n} \n} \ninsertItemAt ( item , 0 ) ; \nsetSelectedIndex ( 0 ) ; \n} \n} \n"}
{"5339": "public class Odometer { \npublic int step ( int firstpos , int lastpos ) { \nfor ( int i = lastpos - 1 ; \ni >= firstpos ; \ni = i - 1 ) { \nif ( this . index . indices [ i ] > this . endpoint [ i ] ) this . index . indices [ i ] = this . slices . get ( i ) . getFirst ( ) ; \nelse { \nthis . index . indices [ i ] += this . slices . get ( i ) . getStride ( ) ; \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5344": "public class IO { \nstatic public long copyB ( InputStream in , OutputStream out , int bufferSize ) throws IOException { \nlong totalBytesRead = 0 ; \nint done = 0 , next = 1 ; \nbyte [ ] buffer = new byte [ bufferSize ] ; \nwhile ( true ) { \nint n = in . read ( buffer ) ; \nif ( n == - 1 ) break ; \nout . write ( buffer , 0 , n ) ; \ntotalBytesRead += n ; \nif ( showCopy ) { \ndone += n ; \nif ( done > 1000 * 1000 * next ) { \nSystem . out . println ( next + \" Mb\" ) ; \nnext = next + 1 ; \n} \n} \n} \nout . flush ( ) ; \nreturn totalBytesRead ; \n} \n} \n"}
{"5361": "public class DTSServlet { \nprotected void printStatus ( PrintWriter os ) { \nos . println ( \"<h2>Server version = \" + getServerVersion ( ) + \"</h2>\" ) ; \nos . println ( \"<h2>Number of Requests Received = \" + HitCounter + \"</h2>\" ) ; \nif ( track ) { \nint n = prArr . size ( ) ; \nint pending = 0 ; \nStringBuilder preqs = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nReqState rs = ( ReqState ) prArr . get ( i ) ; \nRequestDebug reqD = ( RequestDebug ) rs . getUserObject ( ) ; \nif ( ! reqD . done ) { \npreqs . append ( \"<pre>-----------------------\\n\" ) ; \npreqs . append ( \"Request[\" ) ; \npreqs . append ( reqD . reqno ) ; \npreqs . append ( \"](\" ) ; \npreqs . append ( reqD . threadDesc ) ; \npreqs . append ( \") is pending.\\n\" ) ; \npreqs . append ( rs . toString ( ) ) ; \npreqs . append ( \"</pre>\" ) ; \npending = pending + 1 ; \n} \n} \nos . println ( \"<h2>\" + pending + \" Pending Request(s)</h2>\" ) ; \nos . println ( preqs . toString ( ) ) ; \n} \n} \n} \n"}
{"5364": "public class NcStreamIosp { \nprivate Array readVlenData ( Variable v , Section section , DataStorage dataStorage ) throws IOException , InvalidRangeException { \nraf . seek ( dataStorage . filePos ) ; \nint nelems = readVInt ( raf ) ; \nArray [ ] result = new Array [ nelems ] ; \nfor ( int elem = 0 ; \nelem < nelems ; \nelem = elem + 1 ) { \nint dsize = readVInt ( raf ) ; \nbyte [ ] data = new byte [ dsize ] ; \nraf . readFully ( data ) ; \nArray dataArray = Array . factory ( v . getDataType ( ) , ( int [ ] ) null , ByteBuffer . wrap ( data ) ) ; \nresult [ elem ] = dataArray ; \n} \nreturn Array . makeVlenArray ( new int [ ] { \nnelems } \n, result ) ; \n} \n} \n"}
{"5367": "public class StringUtil2 { \nstatic public String allow ( String x , String allowChars , char replaceChar ) { \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos = pos + 1 ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int pos = 0 ; \npos < sb . length ( ) ; \npos = pos + 1 ) { \nchar c = sb . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) { \ncontinue ; \n} \nsb . setCharAt ( pos , replaceChar ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5368": "public class StringUtil2 { \npublic static String cleanup ( byte [ ] h ) { \nbyte [ ] bb = new byte [ h . length ] ; \nint count = 0 ; \nfor ( byte b : h ) { \nif ( b >= 32 && b < 127 ) bb [ count = count + 1 ] = b ; \n} \nreturn new String ( bb , 0 , count , CDM . utf8Charset ) ; \n} \n} \n"}
{"5369": "public class StringUtil2 { \nstatic public String filter ( String x , String okChars ) { \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos = pos + 1 ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) { \nreturn x ; \n} \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos = pos + 1 ) { \nchar c = x . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) { \nsb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5370": "public class StringUtil2 { \nstatic public String filter7bits ( String s ) { \nif ( s == null ) return null ; \nchar [ ] bo = new char [ s . length ( ) ] ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni = i + 1 ) { \nchar c = s . charAt ( i ) ; \nif ( ( c < 128 ) && ( c > 31 ) || ( ( c == '\\n' ) || ( c == '\\t' ) ) ) { \nbo [ count = count + 1 ] = c ; \n} \n} \nreturn new String ( bo , 0 , count ) ; \n} \n} \n"}
{"5371": "public class StringUtil2 { \nstatic public String makeValidCdmObjectName ( String name ) { \nname = name . trim ( ) ; \nboolean ok = true ; \nfor ( int i = 0 ; \ni < name . length ( ) ; \ni = i + 1 ) { \nint c = name . charAt ( i ) ; \nif ( c < 0x20 ) ok = false ; \nif ( c == '/' ) ok = false ; \nif ( c == ' ' ) ok = false ; \nif ( ! ok ) break ; \n} \nif ( ok ) return name ; \nStringBuilder sbuff = new StringBuilder ( name . length ( ) ) ; \nfor ( int i = 0 , len = name . length ( ) ; \ni < len ; \ni = i + 1 ) { \nint c = name . charAt ( i ) ; \nif ( ( c == '/' ) || ( c == ' ' ) ) sbuff . append ( '_' ) ; \nelse if ( c >= 0x20 ) sbuff . append ( ( char ) c ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"5372": "public class StringUtil2 { \nstatic public int match ( String s1 , String s2 ) { \nint i = 0 ; \nwhile ( ( i < s1 . length ( ) ) && ( i < s2 . length ( ) ) ) { \nif ( s1 . charAt ( i ) != s2 . charAt ( i ) ) { \nbreak ; \n} \ni = i + 1 ; \n} \nreturn i ; \n} \n} \n"}
{"5376": "public class StringUtil2 { \nstatic public String remove ( String s , int c ) { \nif ( 0 > s . indexOf ( c ) ) { \nreturn s ; \n} \nStringBuilder buff = new StringBuilder ( s ) ; \nint i = 0 ; \nwhile ( i < buff . length ( ) ) { \nif ( buff . charAt ( i ) == c ) { \nbuff . deleteCharAt ( i ) ; \n} \nelse { \ni = i + 1 ; \n} \n} \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5377": "public class StringUtil2 { \nstatic public String removeFromEnd ( String s , int c ) { \nif ( 0 > s . indexOf ( c ) ) return s ; \nint len = s . length ( ) ; \nwhile ( ( s . charAt ( len - 1 ) == c ) && ( len > 0 ) ) len = len - 1 ; \nif ( len == s . length ( ) ) return s ; \nreturn s . substring ( 0 , len ) ; \n} \n} \n"}
{"5378": "public class StringUtil2 { \nstatic public String collapseWhitespace ( String s ) { \nint len = s . length ( ) ; \nStringBuilder b = new StringBuilder ( len ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nchar c = s . charAt ( i ) ; \nif ( ! Character . isWhitespace ( c ) ) { \nb . append ( c ) ; \n} \nelse { \nb . append ( ' ' ) ; \nwhile ( ( i + 1 < len ) && Character . isWhitespace ( s . charAt ( i + 1 ) ) ) { \ni = i + 1 ; \n} \n} \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"5380": "public class StringUtil2 { \nstatic public String replace ( String x , char [ ] replaceChar , String [ ] replaceWith ) { \nboolean ok = true ; \nfor ( char aReplaceChar : replaceChar ) { \nint pos = x . indexOf ( aReplaceChar ) ; \nok = ( pos < 0 ) ; \nif ( ! ok ) break ; \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int i = 0 ; \ni < replaceChar . length ; \ni = i + 1 ) { \nint pos = x . indexOf ( replaceChar [ i ] ) ; \nif ( pos >= 0 ) { \nreplace ( sb , replaceChar [ i ] , replaceWith [ i ] ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5383": "public class StringUtil2 { \nstatic public String substitute ( String original , String [ ] match , String [ ] subst ) { \nboolean ok = true ; \nfor ( String aMatch : match ) { \nif ( original . contains ( aMatch ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) { \nreturn original ; \n} \nStringBuilder sb = new StringBuilder ( original ) ; \nfor ( int i = 0 ; \ni < match . length ; \ni = i + 1 ) { \nsubstitute ( sb , match [ i ] , subst [ i ] ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5384": "public class StringUtil2 { \nstatic public void remove ( StringBuilder sb , String out ) { \nint i = 0 ; \nwhile ( i < sb . length ( ) ) { \nint c = sb . charAt ( i ) ; \nboolean ok = true ; \nfor ( int j = 0 ; \nj < out . length ( ) ; \nj = j + 1 ) { \nif ( out . charAt ( j ) == c ) { \nsb . delete ( i , i + 1 ) ; \nok = false ; \nbreak ; \n} \n} \nif ( ok ) i = i + 1 ; \n} \n} \n} \n"}
{"5386": "public class StringUtil2 { \nstatic public void replace ( StringBuilder sb , String out , String in ) { \nfor ( int i = 0 ; \ni < sb . length ( ) ; \ni = i + 1 ) { \nint c = sb . charAt ( i ) ; \nfor ( int j = 0 ; \nj < out . length ( ) ; \nj = j + 1 ) { \nif ( out . charAt ( j ) == c ) sb . setCharAt ( i , in . charAt ( j ) ) ; \n} \n} \n} \n} \n"}
{"5388": "public class StringUtil2 { \nstatic public String trim ( String s , int bad ) { \nint len = s . length ( ) ; \nint st = 0 ; \nwhile ( ( st < len ) && ( s . charAt ( st ) == bad ) ) { \nst = st + 1 ; \n} \nwhile ( ( st < len ) && ( s . charAt ( len - 1 ) == bad ) ) { \nlen = len - 1 ; \n} \nreturn ( ( st > 0 ) || ( len < s . length ( ) ) ) ? s . substring ( st , len ) : s ; \n} \n} \n"}
{"5401": "public class CoordinateAxis1D { \npublic CoordinateAxis1D section ( Range r ) throws InvalidRangeException { \nSection section = new Section ( ) . appendRange ( r ) ; \nCoordinateAxis1D result = ( CoordinateAxis1D ) section ( section ) ; \nint len = r . length ( ) ; \nif ( isNumeric ( ) ) { \ndouble [ ] new_mids = new double [ len ] ; \nfor ( int idx = 0 ; \nidx < len ; \nidx = idx + 1 ) { \nint old_idx = r . element ( idx ) ; \nnew_mids [ idx ] = coords [ old_idx ] ; \n} \nresult . coords = new_mids ; \nif ( isInterval ) { \ndouble [ ] new_bound1 = new double [ len ] ; \ndouble [ ] new_bound2 = new double [ len ] ; \ndouble [ ] new_edge = new double [ len + 1 ] ; \nfor ( int idx = 0 ; \nidx < len ; \nidx = idx + 1 ) { \nint old_idx = r . element ( idx ) ; \nnew_bound1 [ idx ] = bound1 [ old_idx ] ; \nnew_bound2 [ idx ] = bound2 [ old_idx ] ; \nnew_edge [ idx ] = bound1 [ old_idx ] ; \nnew_edge [ idx + 1 ] = bound2 [ old_idx ] ; \n} \nresult . bound1 = new_bound1 ; \nresult . bound2 = new_bound2 ; \nresult . edge = new_edge ; \n} \nelse { \ndouble [ ] new_edge = new double [ len + 1 ] ; \nfor ( int idx = 0 ; \nidx < len ; \nidx = idx + 1 ) { \nint old_idx = r . element ( idx ) ; \nnew_edge [ idx ] = edge [ old_idx ] ; \nnew_edge [ idx + 1 ] = edge [ old_idx + 1 ] ; \n} \nresult . edge = new_edge ; \n} \n} \nif ( names != null ) { \nString [ ] new_names = new String [ len ] ; \nfor ( int idx = 0 ; \nidx < len ; \nidx = idx + 1 ) { \nint old_idx = r . element ( idx ) ; \nnew_names [ idx ] = names [ old_idx ] ; \n} \nresult . names = new_names ; \n} \nresult . wasCalcRegular = false ; \nresult . calcIsRegular ( ) ; \nreturn result ; \n} \n} \n"}
{"5406": "public class GradsUtil { \npublic static double [ ] getGaussianLatitudes ( String type , int start , int num ) throws IllegalArgumentException { \ndouble [ ] baseArray = null ; \nstart = start - 1 ; \nif ( type . equalsIgnoreCase ( GAUST62 ) ) { \nbaseArray = gltst62 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR15 ) ) { \nbaseArray = glts15 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR20 ) ) { \nbaseArray = glts20 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR30 ) ) { \nbaseArray = glts30 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR40 ) ) { \nbaseArray = glats ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Unsupported type: \" + type ) ; \n} \nif ( start + num > baseArray . length ) { \nthrow new IllegalArgumentException ( \"Maximum \" + baseArray . length + \" latitudes exceeded\" ) ; \n} \ndouble [ ] retVals = new double [ num ] ; \nfor ( int i = 0 ; \ni < num ; \ni = i + 1 ) { \nretVals [ i ] = baseArray [ start + i ] ; \n} \nreturn retVals ; \n} \n} \n"}
{"5407": "public class Swap { \nstatic public long swapLong ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nlong shiftedval ; \nfor ( int shiftBy = 0 , i = offset ; \nshiftBy < 64 ; \nshiftBy += 8 , i = i + 1 ) { \nshiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; \naccum |= shiftedval ; \n} \nreturn accum ; \n} \n} \n"}
{"5408": "public class Swap { \nstatic public float swapFloat ( byte [ ] b , int offset ) { \nint accum = 0 ; \nfor ( int shiftBy = 0 , i = offset ; \nshiftBy < 32 ; \nshiftBy += 8 , i = i + 1 ) accum |= ( b [ i ] & 0xff ) << shiftBy ; \nreturn Float . intBitsToFloat ( accum ) ; \n} \n} \n"}
{"5420": "public class Group { \npublic boolean removeDimension ( String dimName ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nfor ( int i = 0 ; \ni < dimensions . size ( ) ; \ni = i + 1 ) { \nDimension d = dimensions . get ( i ) ; \nif ( dimName . equals ( d . getShortName ( ) ) ) { \ndimensions . remove ( d ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5425": "public class GeotiffWriter { \npublic void writeGrid ( GridDataset dataset , GridDatatype grid , Array data , boolean greyScale ) throws IOException { \nGridCoordSystem gcs = grid . getCoordinateSystem ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) { \nthrow new IllegalArgumentException ( \"Must have 1D x and y axes for \" + grid . getFullName ( ) ) ; \n} \nCoordinateAxis1D xaxis = ( CoordinateAxis1D ) gcs . getXHorizAxis ( ) ; \nCoordinateAxis1D yaxis = ( CoordinateAxis1D ) gcs . getYHorizAxis ( ) ; \ndouble scaler = ( xaxis . getUnitsString ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge ( 0 ) * scaler ; \ndouble xInc = xaxis . getIncrement ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getIncrement ( ) ) * scaler ; \nif ( yaxis . getCoordValue ( 0 ) < yaxis . getCoordValue ( 1 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdge ( ( int ) yaxis . getSize ( ) ) * scaler ; \n} \nif ( ! xaxis . isRegular ( ) || ! yaxis . isRegular ( ) ) { \nthrow new IllegalArgumentException ( \"Must be evenly spaced grid = \" + grid . getFullName ( ) ) ; \n} \nif ( pageNumber > 1 ) { \ngeotiff . initTags ( ) ; \n} \nwriteGrid ( grid , data , greyScale , xStart , yStart , xInc , yInc , pageNumber ) ; \npageNumber = pageNumber + 1 ; \n} \n} \n"}
{"5429": "public class GeotiffWriter { \npublic void writeGrid ( GeoReferencedArray array , boolean greyScale ) throws IOException { \nCoverageCoordSys gcs = array . getCoordSysForData ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) throw new IllegalArgumentException ( \"Must have 1D x and y axes for \" + array . getCoverageName ( ) ) ; \nProjection proj = gcs . getProjection ( ) ; \nCoverageCoordAxis1D xaxis = ( CoverageCoordAxis1D ) gcs . getXAxis ( ) ; \nCoverageCoordAxis1D yaxis = ( CoverageCoordAxis1D ) gcs . getYAxis ( ) ; \ndouble scaler = ( xaxis . getUnits ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble xInc = xaxis . getResolution ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getResolution ( ) ) * scaler ; \nArray data = array . getData ( ) . reduce ( ) ; \nif ( yaxis . getCoordMidpoint ( 0 ) < yaxis . getCoordMidpoint ( 1 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdgeLast ( ) ; \n} \nif ( pageNumber > 1 ) { \ngeotiff . initTags ( ) ; \n} \nint nextStart = 0 ; \nMAMath . MinMax dataMinMax = MAMath . getMinMaxSkipMissingData ( data , array ) ; \nif ( greyScale ) { \nArrayByte result = replaceMissingValuesAndScale ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( byte [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nelse { \nArrayFloat result = replaceMissingValues ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( float [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nint height = data . getShape ( ) [ 0 ] ; \nint width = data . getShape ( ) [ 1 ] ; \nwriteMetadata ( greyScale , xStart , yStart , xInc , yInc , height , width , pageNumber , nextStart , dataMinMax , proj ) ; \npageNumber = pageNumber + 1 ; \n} \n} \n"}
{"5443": "public class RC { \npublic boolean load ( String abspath ) { \nabspath = abspath . replace ( '\\\\' , '/' ) ; \nFile rcFile = new File ( abspath ) ; \nif ( ! rcFile . exists ( ) || ! rcFile . canRead ( ) ) { \nreturn false ; \n} \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \ntry ( BufferedReader rdr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( rcFile ) , CDM . UTF8 ) ) ) { \nfor ( int lineno = 1 ; \n; \nlineno = lineno + 1 ) { \nURL url = null ; \nString line = rdr . readLine ( ) ; \nif ( line == null ) break ; \nline = line . trim ( ) ; \nif ( line . length ( ) == 0 ) continue ; \nif ( line . charAt ( 0 ) == '#' ) continue ; \nif ( line . charAt ( 0 ) == LTAG ) { \nint rindex = line . indexOf ( RTAG ) ; \nif ( rindex < 0 ) return false ; \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \nString surl = line . substring ( 1 , rindex ) ; \ntry { \nurl = new URL ( surl ) ; \n} \ncatch ( MalformedURLException mue ) { \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \n} \nline = line . substring ( rindex + 1 ) ; \nline = line . trim ( ) ; \n} \nString [ ] pieces = line . split ( \"\\\\s*=\\\\s*\" ) ; \nassert ( pieces . length == 1 || pieces . length == 2 ) ; \nString value = \"1\" ; \nif ( pieces . length == 2 ) value = pieces [ 1 ] . trim ( ) ; \nTriple triple = new Triple ( pieces [ 0 ] . trim ( ) , value , url ) ; \nList < Triple > list = triplestore . get ( triple . key ) ; \nif ( list == null ) list = new ArrayList < Triple > ( ) ; \nTriple prev = addtriple ( list , triple ) ; \ntriplestore . put ( triple . key , list ) ; \n} \n} \ncatch ( FileNotFoundException fe ) { \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \nreturn false ; \n} \ncatch ( IOException ioe ) { \nif ( showlog ) log . error ( \"File \" + abspath + \": IO exception: \" + ioe . getMessage ( ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"5451": "public class StopButton { \npublic boolean startProgressMonitorTask ( ProgressMonitorTask pmt ) { \nif ( busy ) return false ; \nbusy = true ; \nthis . task = pmt ; \nisCancelled = false ; \ncount = 0 ; \nsetIcon ( icon [ 0 ] ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nif ( isCancelled && ! task . isCancel ( ) ) { \ntask . cancel ( ) ; \nif ( debug ) System . out . println ( \" task.cancel\" ) ; \nreturn ; \n} \nelse { \ncount = count + 1 ; \nsetIcon ( icon [ count % 2 ] ) ; \nif ( debug ) System . out . println ( \" stop count=\" + count ) ; \n} \nif ( task . isDone ( ) ) { \nif ( myTimer != null ) myTimer . stop ( ) ; \nmyTimer = null ; \nif ( task . isError ( ) ) javax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \nbusy = false ; \n} \n} \n} \n; \nmyTimer = new javax . swing . Timer ( 1000 , watcher ) ; \nmyTimer . start ( ) ; \nThread taskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nreturn true ; \n} \n} \n"}
{"5465": "public class ArrayStructure { \npublic ArrayStructure getArrayStructure ( int recnum , StructureMembers . Member m ) { \nif ( ( m . getDataType ( ) != DataType . STRUCTURE ) && ( m . getDataType ( ) != DataType . SEQUENCE ) ) throw new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be Structure or Sequence\" ) ; \nif ( m . getDataType ( ) == DataType . SEQUENCE ) return getArraySequence ( recnum , m ) ; \nArrayStructure array = ( ArrayStructure ) m . getDataArray ( ) ; \nint count = m . getSize ( ) ; \nStructureData [ ] this_sdata = new StructureData [ count ] ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) this_sdata [ i ] = array . getStructureData ( recnum * count + i ) ; \nStructureMembers membersw = new StructureMembers ( array . getStructureMembers ( ) ) ; \nreturn new ArrayStructureW ( membersw , m . getShape ( ) , this_sdata ) ; \n} \n} \n"}
{"5470": "public class CEConstraint { \npublic String toConstraintString ( ) { \nStringBuilder buf = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( int i = 0 ; \ni < segments . size ( ) ; \ni = i + 1 ) { \nSegment seg = segments . get ( i ) ; \nif ( ! seg . var . isTopLevel ( ) ) continue ; \nif ( ! first ) buf . append ( \";\" ) ; \nfirst = false ; \ndumpvar ( seg , buf , true ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5473": "public class CEConstraint { \nprotected int expansionCount ( DapStructure struct ) { \nint count = 0 ; \nfor ( DapVariable field : struct . getFields ( ) ) { \nif ( findVariableIndex ( field ) >= 0 ) count = count + 1 ; \n} \nreturn count ; \n} \n} \n"}
{"5474": "public class CEConstraint { \nprotected void computeenums ( ) { \nfor ( int i = 0 ; \ni < variables . size ( ) ; \ni = i + 1 ) { \nDapVariable var = variables . get ( i ) ; \nif ( var . getSort ( ) != DapSort . VARIABLE ) continue ; \nDapType daptype = var . getBaseType ( ) ; \nif ( ! daptype . isEnumType ( ) ) continue ; \nif ( ! this . enums . contains ( ( DapEnumeration ) daptype ) ) this . enums . add ( ( DapEnumeration ) daptype ) ; \n} \n} \n} \n"}
{"5475": "public class CEConstraint { \nprotected void computegroups ( ) { \nfor ( int i = 0 ; \ni < variables . size ( ) ; \ni = i + 1 ) { \nDapVariable var = variables . get ( i ) ; \nList < DapGroup > path = var . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \nfor ( DapDimension dim : this . dimrefs ) { \nif ( ! dim . isShared ( ) ) continue ; \nList < DapGroup > path = dim . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \nfor ( DapEnumeration en : this . enums ) { \nList < DapGroup > path = en . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \n} \n} \n"}
{"5483": "public class GempakFileReader { \npublic float [ ] getFileHeader ( String name ) throws IOException { \nDMFileHeaderInfo fh = findFileHeader ( name ) ; \nif ( ( fh == null ) || ( fh . kfhtyp != MDREAL ) ) { \nreturn null ; \n} \nint knt = fileHeaderInfo . indexOf ( fh ) ; \nint iread = dmLabel . kpfile + 3 * dmLabel . kfhdrs ; \nfor ( int i = 0 ; \ni < knt ; \ni = i + 1 ) { \nDMFileHeaderInfo fhi = fileHeaderInfo . get ( i ) ; \niread = iread + fhi . kfhlen + 1 ; \n} \nint nword = DM_RINT ( iread ) ; \nif ( nword <= 0 ) { \nlogError ( \"Invalid header length for \" + name ) ; \nreturn null ; \n} \niread = iread + 1 ; \nfloat [ ] rheader = new float [ nword ] ; \nif ( name . equals ( \"NAVB\" ) && needToSwap ) { \nDM_RFLT ( iread , 1 , rheader , 0 ) ; \nneedToSwap = false ; \niread = iread + 1 ; \nDM_RFLT ( iread , 1 , rheader , 1 ) ; \nneedToSwap = true ; \niread = iread + 1 ; \nDM_RFLT ( iread , nword - 2 , rheader , 2 ) ; \n} \nelse { \nDM_RFLT ( iread , rheader ) ; \n} \nreturn rheader ; \n} \n} \n"}
{"5484": "public class GempakFileReader { \npublic void printParts ( ) { \nif ( parts == null ) { \nreturn ; \n} \nfor ( int i = 0 ; \ni < parts . size ( ) ; \ni = i + 1 ) { \nSystem . out . println ( \"\\nParts[\" + i + \"]:\" ) ; \nSystem . out . println ( parts . get ( i ) ) ; \n} \n} \n} \n"}
{"5488": "public class GempakFileReader { \npublic float [ ] DM_UNPK ( DMPart part , int [ ] ibitst ) { \nint nparms = part . kparms ; \nint nwordp = part . kwordp ; \nint npack = ( ibitst . length - 1 ) / nwordp + 1 ; \nif ( npack * nwordp != ibitst . length ) { \nreturn null ; \n} \nfloat [ ] data = new float [ nparms * npack ] ; \nPackingInfo pkinf = part . packInfo ; \nint ir = 0 ; \nint ii = 0 ; \nfor ( int pack = 0 ; \npack < npack ; \npack = pack + 1 ) { \nint [ ] jdata = new int [ nwordp ] ; \nSystem . arraycopy ( ibitst , ii , jdata , 0 , nwordp ) ; \nfor ( int idata = 0 ; \nidata < nparms ; \nidata = idata + 1 ) { \nint jbit = pkinf . nbitsc [ idata ] ; \nint jsbit = pkinf . isbitc [ idata ] ; \nint jshift = 1 - jsbit ; \nint jsword = pkinf . iswrdc [ idata ] ; \nint jword = jdata [ jsword ] ; \nint mask = mskpat >>> ( 32 - jbit ) ; \nint ifield = jword >>> Math . abs ( jshift ) ; \nifield = ifield & mask ; \nif ( ( jsbit + jbit - 1 ) > 32 ) { \njword = jdata [ jsword + 1 ] ; \njshift = jshift + 32 ; \nint iword = jword << jshift ; \niword = iword & mask ; \nifield = ifield | iword ; \n} \nif ( ifield == pkinf . imissc [ idata ] ) { \ndata [ ir + idata ] = RMISSD ; \n} \nelse { \ndata [ ir + idata ] = ( ifield + pkinf . koffst [ idata ] ) * ( float ) pkinf . scalec [ idata ] ; \n} \n} \nir += nparms ; \nii += nwordp ; \n} \nreturn data ; \n} \n} \n"}
{"5489": "public class GempakFileReader { \nprotected static String getBits ( int b ) { \nFormatter s = new Formatter ( ) ; \nfor ( int i = 31 ; \ni >= 0 ; \ni = i - 1 ) { \nif ( ( b & ( 1 << i ) ) != 0 ) { \ns . format ( \"1\" ) ; \n} \nelse { \ns . format ( \"0\" ) ; \n} \nif ( i % 8 == 0 ) { \ns . format ( \"|\" ) ; \n} \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"5491": "public class DDSXMLParser { \nprivate void parseBase ( Element e , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel = parseLevel + 1 ; \nString type = e . getName ( ) ; \nif ( type . equals ( \"Attribute\" ) ) { \n} \nelse if ( type . equals ( \"Alias\" ) ) { \n} \nelse if ( type . equals ( \"dataBLOB\" ) ) { \norg . jdom2 . Attribute hrefAttr = e . getAttribute ( \"href\" ) ; \nString contentID = hrefAttr . getValue ( ) ; \nif ( _Debug ) System . out . println ( \"Found dataBLOB element. contentID=\\\"\" + contentID + \"\\\"\" ) ; \ndds . setBlobContentID ( contentID ) ; \n} \nelse { \nif ( _Debug ) System . out . println ( \"Parsing new BaseType element. Parse level: \" + parseLevel ) ; \nif ( _Debug ) showXMLElement ( e , indent ) ; \nBaseType bt = newBaseType ( e ) ; \nparentDC . addVariable ( bt ) ; \nif ( bt instanceof DConstructor ) { \nDConstructor myParentDC = parentDC ; \nparentDC = ( DConstructor ) bt ; \ntry { \nif ( bt instanceof DGrid ) { \nparseGrid ( e , indent ) ; \n} \nelse { \nfor ( Element child : e . getChildren ( ) ) { \nparseBase ( child , indent + \"    \" ) ; \n} \n} \n} \nfinally { \nparentDC = myParentDC ; \n} \n} \nelse if ( bt instanceof DArray ) { \nif ( _Debug ) System . out . println ( \"Parsing Array instance.  Array name: '\" + bt . getClearName ( ) + \"'\" ) ; \nparseArray ( e , ( DArray ) bt , indent ) ; \n} \n} \nparseLevel = parseLevel - 1 ; \n} \n} \n"}
{"5492": "public class DDSXMLParser { \nprivate void parseGrid ( Element gridElement , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel = parseLevel + 1 ; \nDGrid myGrid = ( DGrid ) parentDC ; \nif ( _Debug ) { \nSystem . out . println ( \"Parsing Grid Element: \" + gridElement ) ; \nSystem . out . println ( \"Grid Elements: \" ) ; \nfor ( Element element : gridElement . getChildren ( ) ) System . out . println ( element ) ; \n} \nString eName = \"Array\" ; \nif ( _Debug ) { \nSystem . out . println ( \"Parsing Array element.\" ) ; \nSystem . out . println ( \"Asking for element: '\" + eName + \"' in namespace: '\" + opendapNameSpace + \"'\" ) ; \n} \nElement arrayElement = gridElement . getChild ( eName , opendapNameSpace ) ; \nif ( _Debug ) System . out . println ( \"Got Array element: \" + arrayElement ) ; \nDArray gridArray = ( DArray ) newBaseType ( arrayElement ) ; \nparseArray ( arrayElement , gridArray , indent + \"    \" ) ; \nmyGrid . addVariable ( gridArray , DGrid . ARRAY ) ; \neName = \"Map\" ; \nif ( _Debug ) { \nSystem . out . println ( \"Parsing Map elements.\" ) ; \nSystem . out . println ( \"Asking for element: '\" + eName + \"' in namespace: '\" + opendapNameSpace + \"'\" ) ; \n} \nList < Element > mapElements = gridElement . getChildren ( \"Map\" , opendapNameSpace ) ; \nif ( mapElements . size ( ) != gridArray . numDimensions ( ) ) throw new BadSemanticsException ( \"Error in Grid syntax: \" + \"The number of Map arrays must \" + \"equal the number of dimensions \" + \"of the data array.\" ) ; \nfor ( Element mapElement : mapElements ) { \nDArray thisMap = ( DArray ) newBaseType ( mapElement ) ; \nparseArray ( mapElement , thisMap , indent + \"    \" ) ; \nif ( thisMap . numDimensions ( ) != 1 ) throw new BadSemanticsException ( \"Error in Grid syntax: \" + \"Maps may have only one dimension.\" ) ; \nmyGrid . addVariable ( thisMap , DGrid . MAPS ) ; \n} \nparseLevel = parseLevel - 1 ; \n} \n} \n"}
{"5493": "public class DDSXMLParser { \nprivate void parseAliases ( Element e , String indent ) throws DASException { \nparseLevel = parseLevel + 1 ; \nString subIndent = indent + \"    \" ; \nif ( _Debug ) System . out . println ( indent + \"Parsing Aliases: \" ) ; \nif ( _Debug ) System . out . println ( subIndent + \"currentBT: \" + currentBT . getTypeName ( ) + \" \" + currentBT . getClearName ( ) ) ; \nfor ( Element aliasElement : e . getChildren ( \"Alias\" , opendapNameSpace ) ) { \nString name = null ; \nAttribute nameAttr = aliasElement . getAttribute ( \"name\" ) ; \nname = nameAttr . getValue ( ) ; \nString attributeName = null ; \nAttribute attributeAttr = aliasElement . getAttribute ( \"Attribute\" ) ; \nattributeName = attributeAttr . getValue ( ) ; \nif ( _Debug ) { \nSystem . out . println ( subIndent + \"The name '\" + name + \"' is aliased to dds attribute: '\" + attributeName + \"'\" ) ; \n} \nif ( currentAT == null ) currentBT . addAttributeAlias ( name , attributeName ) ; \nelse currentAT . addAlias ( name , attributeName ) ; \n} \nparseLevel = parseLevel - 1 ; \n} \n} \n"}
{"5495": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { \nList < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; \nIterator < DataDescriptor > dkIter = keys . iterator ( ) ; \nwhile ( dkIter . hasNext ( ) ) { \nDataDescriptor dk = dkIter . next ( ) ; \nif ( dk . f == 1 ) { \ndk . subKeys = new ArrayList < DataDescriptor > ( ) ; \ndk . replication = dk . y ; \nif ( dk . replication == 0 ) { \nroot . isVarLength = true ; \nDataDescriptor replication = dkIter . next ( ) ; \nif ( replication . y == 0 ) dk . replicationCountSize = 1 ; \nelse if ( replication . y == 1 ) dk . replicationCountSize = 8 ; \nelse if ( replication . y == 2 ) dk . replicationCountSize = 16 ; \nelse if ( replication . y == 11 ) dk . repetitionCountSize = 8 ; \nelse if ( replication . y == 12 ) dk . repetitionCountSize = 16 ; \nelse log . error ( \"Unknown replication type= \" + replication ) ; \n} \nfor ( int j = 0 ; \nj < dk . x && dkIter . hasNext ( ) ; \nj = j + 1 ) { \ndk . subKeys . add ( dkIter . next ( ) ) ; \n} \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \nelse if ( ( dk . f == 3 ) && ( dk . subKeys != null ) ) { \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \ntree . add ( dk ) ; \n} \nreturn tree ; \n} \n} \n"}
{"5501": "public class Tools { \npublic static void probeObject ( Object o ) { \nClass c = o . getClass ( ) ; \nClass interfaces [ ] = c . getInterfaces ( ) ; \nClass parent = c . getSuperclass ( ) ; \nMethod m [ ] = c . getMethods ( ) ; \nSystem . out . println ( \"********* OBJECT PROBE *********\" ) ; \nSystem . out . println ( \"Class Name:  \" + c . getName ( ) ) ; \nSystem . out . println ( \"Super Class: \" + parent . getName ( ) ) ; \nSystem . out . println ( \"Interfaces: \" ) ; \nfor ( int i = 0 ; \ni < interfaces . length ; \ni = i + 1 ) { \nSystem . out . println ( \"    \" + interfaces [ i ] . getName ( ) ) ; \n} \nSystem . out . println ( \"Methods:\" ) ; \nfor ( int i = 0 ; \ni < m . length ; \ni = i + 1 ) { \nClass params [ ] = m [ i ] . getParameterTypes ( ) ; \nClass excepts [ ] = m [ i ] . getExceptionTypes ( ) ; \nClass ret = m [ i ] . getReturnType ( ) ; \nSystem . out . print ( \"    \" + ret . getName ( ) + \"  \" + m [ i ] . getName ( ) + \"(\" ) ; \nfor ( int j = 0 ; \nj < params . length ; \nj = j + 1 ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( params [ j ] . getName ( ) ) ; \n} \nSystem . out . print ( \")  throws \" ) ; \nfor ( int j = 0 ; \nj < excepts . length ; \nj = j + 1 ) { \nif ( j > 0 ) System . out . print ( \", \" ) ; \nSystem . out . print ( excepts [ j ] . getName ( ) ) ; \n} \nSystem . out . println ( \"\" ) ; \n} \nSystem . out . println ( \"******************\" ) ; \n} \n} \n"}
{"5503": "public class CoordinateTimeAbstract { \npublic CoordinateTimeAbstract makeBestFromComplete ( ) { \nint [ ] best = new int [ time2runtime . length ] ; \nint last = - 1 ; \nint count = 0 ; \nfor ( int i = 0 ; \ni < time2runtime . length ; \ni = i + 1 ) { \nint time = time2runtime [ i ] ; \nif ( time >= last ) { \nlast = time ; \nbest [ i ] = time ; \ncount = count + 1 ; \n} \nelse { \nbest [ i ] = - 1 ; \n} \n} \nreturn makeBestFromComplete ( best , count ) ; \n} \n} \n"}
{"5505": "public class AccessLogTable { \nprivate void showTimeSeriesAll ( java . util . List < LogReader . Log > logs ) { \nTimeSeries bytesSentData = new TimeSeries ( \"Bytes Sent\" , Minute . class ) ; \nTimeSeries timeTookData = new TimeSeries ( \"Average Latency\" , Minute . class ) ; \nTimeSeries nreqData = new TimeSeries ( \"Number of Requests\" , Minute . class ) ; \nString intervalS = \"5 minute\" ; \nlong period = 1000 * 60 * 5 ; \ntry { \nTimeDuration tu = new TimeDuration ( intervalS ) ; \nperiod = ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ; \n} \ncatch ( Exception e ) { \nSystem . out . printf ( \"Illegal Time interval=%s %n\" , intervalS ) ; \n} \nlong current = 0 ; \nlong bytes = 0 ; \nlong timeTook = 0 ; \nlong total_count = 0 ; \nlong count = 0 ; \nfor ( LogReader . Log log : logs ) { \nlong msecs = log . date ; \nif ( msecs - current > period ) { \nif ( current > 0 ) { \ntotal_count += count ; \naddPoint ( bytesSentData , timeTookData , nreqData , new Date ( current ) , bytes , count , timeTook ) ; \n} \nbytes = 0 ; \ncount = 0 ; \ntimeTook = 0 ; \ncurrent = msecs ; \n} \nbytes += log . getBytes ( ) ; \ntimeTook += log . getMsecs ( ) ; \ncount = count + 1 ; \n} \nif ( count > 0 ) addPoint ( bytesSentData , timeTookData , nreqData , new Date ( current ) , bytes , count , timeTook ) ; \ntotal_count += count ; \nSystem . out . printf ( \"showTimeSeriesAll: total_count = %d logs = %d%n\" , total_count , logs . size ( ) ) ; \nMultipleAxisChart mc = new MultipleAxisChart ( \"Access Logs\" , intervalS + \" average\" , \"Mbytes Sent\" , bytesSentData ) ; \nmc . addSeries ( \"Number of Requests\" , nreqData ) ; \nmc . addSeries ( \"Average Latency (secs)\" , timeTookData ) ; \nmc . finish ( new java . awt . Dimension ( 1000 , 1000 ) ) ; \ntimeSeriesPanel . removeAll ( ) ; \ntimeSeriesPanel . add ( mc ) ; \n} \n} \n"}
{"5509": "public class Attribute { \nprotected void writeCDL ( Formatter f , boolean strict , String parentname ) { \nif ( strict && ( isString ( ) || this . getEnumType ( ) != null ) ) f . format ( \"string \" ) ; \nif ( strict && parentname != null ) f . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; \nf . format ( \":\" ) ; \nf . format ( \"%s\" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; \nif ( isString ( ) ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni = i + 1 ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nString val = getStringValue ( i ) ; \nif ( val != null ) f . format ( \"\\\"%s\\\"\" , encodeString ( val ) ) ; \n} \n} \nelse if ( getEnumType ( ) != null ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni = i + 1 ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nEnumTypedef en = getEnumType ( ) ; \nString econst = getStringValue ( i ) ; \nInteger ecint = en . lookupEnumInt ( econst ) ; \nif ( ecint == null ) throw new ForbiddenConversionException ( \"Illegal enum constant: \" + econst ) ; \nf . format ( \"\\\"%s\\\"\" , encodeString ( econst ) ) ; \n} \n} \nelse { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni = i + 1 ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nNumber number = getNumericValue ( i ) ; \nif ( dataType . isUnsigned ( ) ) { \nnumber = DataType . widenNumber ( number ) ; \n} \nf . format ( \"%s\" , number ) ; \nif ( dataType . isUnsigned ( ) ) { \nf . format ( \"U\" ) ; \n} \nif ( dataType == DataType . FLOAT ) f . format ( \"f\" ) ; \nelse if ( dataType == DataType . SHORT || dataType == DataType . USHORT ) { \nf . format ( \"S\" ) ; \n} \nelse if ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) { \nf . format ( \"B\" ) ; \n} \nelse if ( dataType == DataType . LONG || dataType == DataType . ULONG ) { \nf . format ( \"L\" ) ; \n} \n} \n} \n} \n} \n"}
{"5510": "public class Attribute { \nprivate void setStringValue ( String val ) { \nif ( val == null ) throw new IllegalArgumentException ( \"Attribute value cannot be null\" ) ; \nint len = val . length ( ) ; \nwhile ( ( len > 0 ) && ( val . charAt ( len - 1 ) == 0 ) ) len = len - 1 ; \nif ( len != val . length ( ) ) val = val . substring ( 0 , len ) ; \nthis . svalue = val ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \n} \n} \n"}
{"5511": "public class Attribute { \npublic void setValues ( List values ) { \nif ( values == null || values . size ( ) == 0 ) throw new IllegalArgumentException ( \"Cannot determine attribute's type\" ) ; \nint n = values . size ( ) ; \nClass c = values . get ( 0 ) . getClass ( ) ; \nObject pa ; \nif ( c == String . class ) { \nString [ ] va = new String [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) va [ i ] = ( String ) values . get ( i ) ; \n} \nelse if ( c == Integer . class ) { \nint [ ] va = new int [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) va [ i ] = ( Integer ) values . get ( i ) ; \n} \nelse if ( c == Double . class ) { \ndouble [ ] va = new double [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) va [ i ] = ( Double ) values . get ( i ) ; \n} \nelse if ( c == Float . class ) { \nfloat [ ] va = new float [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) va [ i ] = ( Float ) values . get ( i ) ; \n} \nelse if ( c == Short . class ) { \nshort [ ] va = new short [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) va [ i ] = ( Short ) values . get ( i ) ; \n} \nelse if ( c == Byte . class ) { \nbyte [ ] va = new byte [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) va [ i ] = ( Byte ) values . get ( i ) ; \n} \nelse if ( c == Long . class ) { \nlong [ ] va = new long [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) va [ i ] = ( Long ) values . get ( i ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Unknown type for Attribute = \" + c . getName ( ) ) ; \n} \nsetValues ( Array . factory ( this . dataType , new int [ ] { \nn } \n, pa ) ) ; \n} \n} \n"}
{"5513": "public class CollectionLevelScanner { \npublic void scan ( ) throws IOException { \nif ( state == 1 ) throw new IllegalStateException ( \"Scan already underway.\" ) ; \nif ( state >= 2 ) throw new IllegalStateException ( \"Scan has already been generated.\" ) ; \nstate = 1 ; \nif ( proxyDsHandlers == null ) proxyDsHandlers = Collections . EMPTY_MAP ; \ngenCatalog = createSkeletonCatalog ( currentLevel ) ; \nInvDatasetImpl topInvDs = ( InvDatasetImpl ) genCatalog . getDatasets ( ) . get ( 0 ) ; \nList crDsList = currentLevel . listDatasets ( this . filter ) ; \nif ( sorter != null ) sorter . sort ( crDsList ) ; \nfor ( int i = 0 ; \ni < crDsList . size ( ) ; \ni = i + 1 ) { \nCrawlableDataset curCrDs = ( CrawlableDataset ) crDsList . get ( i ) ; \nInvDatasetImpl curInvDs = ( InvDatasetImpl ) createInvDatasetFromCrawlableDataset ( curCrDs , topInvDs , null ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( curCrDs , curInvDs ) ; \nif ( curCrDs . isCollection ( ) ) catRefInfo . add ( dsInfo ) ; \nelse atomicDsInfo . add ( dsInfo ) ; \ntopInvDs . addDataset ( curInvDs ) ; \n} \n( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \nif ( atomicDsInfo . size ( ) > 0 ) { \nboolean anyProxiesAdded = false ; \nfor ( Iterator it = proxyDsHandlers . values ( ) . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nProxyDatasetHandler curProxy = ( ProxyDatasetHandler ) it . next ( ) ; \nInvService proxyService = curProxy . getProxyDatasetService ( currentLevel ) ; \nif ( proxyService != null ) { \nCrawlableDataset crDsToAdd = curProxy . createProxyDataset ( currentLevel ) ; \nInvDatasetImpl invDsToAdd = createInvDatasetFromCrawlableDataset ( crDsToAdd , topInvDs , proxyService ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( crDsToAdd , invDsToAdd ) ; \nproxyDsInfo . add ( dsInfo ) ; \nint index = curProxy . getProxyDatasetLocation ( currentLevel , topInvDs . getDatasets ( ) . size ( ) ) ; \ntopInvDs . addDataset ( index , ( InvDatasetImpl ) invDsToAdd ) ; \ngenCatalog . addService ( proxyService ) ; \nanyProxiesAdded = true ; \n} \n} \nif ( anyProxiesAdded ) ( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \n} \nthis . addTopLevelMetadata ( genCatalog , true ) ; \nstate = 2 ; \nreturn ; \n} \n} \n"}
{"5522": "public class CoordinateSystem { \nstatic public String makeName ( List < CoordinateAxis > axes ) { \nList < CoordinateAxis > axesSorted = new ArrayList < > ( axes ) ; \nCollections . sort ( axesSorted , new CoordinateAxis . AxisComparator ( ) ) ; \nStringBuilder buff = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < axesSorted . size ( ) ; \ni = i + 1 ) { \nCoordinateAxis axis = axesSorted . get ( i ) ; \nif ( i > 0 ) buff . append ( \" \" ) ; \nbuff . append ( axis . getFullNameEscaped ( ) ) ; \n} \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5537": "public class BeanTable { \npublic ArrayList < Object > getSelectedCells ( ) { \nArrayList < Object > list = new ArrayList < > ( ) ; \nint [ ] viewRowIndices = jtable . getSelectedRows ( ) ; \nint [ ] viewColumnIndices = jtable . getSelectedColumns ( ) ; \nfor ( int i = 0 ; \ni < viewRowIndices . length ; \ni = i + 1 ) for ( int j = 0 ; \ni < viewColumnIndices . length ; \nj = j + 1 ) { \nint modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndices [ i ] ) ; \nint modelColumnIndex = jtable . convertColumnIndexToModel ( viewColumnIndices [ j ] ) ; \nlist . add ( model . getValueAt ( modelRowIndex , modelColumnIndex ) ) ; \n} \nreturn list ; \n} \n} \n"}
{"5539": "public class BeanTable { \nprotected void restoreState ( ) { \nif ( store == null ) { \nreturn ; \n} \nArrayList propColObjs = ( ArrayList ) store . getBean ( \"propertyCol\" , new ArrayList ( ) ) ; \nHidableTableColumnModel tableColumnModel = ( HidableTableColumnModel ) jtable . getColumnModel ( ) ; \nint newViewIndex = 0 ; \nfor ( Object propColObj : propColObjs ) { \nPropertyCol propCol = ( PropertyCol ) propColObj ; \ntry { \nint currentViewIndex = tableColumnModel . getColumnIndex ( propCol . getName ( ) ) ; \nTableColumn column = tableColumnModel . getColumn ( currentViewIndex ) ; \ncolumn . setPreferredWidth ( propCol . getWidth ( ) ) ; \ntableColumnModel . moveColumn ( currentViewIndex , newViewIndex ) ; \nassert tableColumnModel . getColumn ( newViewIndex ) == column : \"tableColumn wasn't successfully moved.\" ; \ntableColumnModel . setColumnVisible ( column , propCol . isVisible ( ) ) ; \nif ( propCol . isVisible ( ) ) { \nnewViewIndex = newViewIndex + 1 ; \n} \n} \ncatch ( IllegalArgumentException e ) { \nlogger . debug ( String . format ( \"Column named \\\"%s\\\" was present in the preferences file but not the dataset.\" , propCol . getName ( ) ) , e ) ; \n} \n} \n} \n} \n"}
{"5564": "public class CatalogCrawler { \npublic void crawlDataset ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \nreturn ; \n} \nboolean isDataScan = ds . findProperty ( \"DatasetScan\" ) != null ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \ncountCatrefs = countCatrefs + 1 ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nif ( ! isCatRef || isDataScan ) listen . getDataset ( ds , context ) ; \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( ! isDataScan ) { \nlisten . getDataset ( catref . getProxyDataset ( ) , context ) ; \n} \n} \nfor ( InvDataset dds : dlist ) { \ncrawlDataset ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nif ( isCatRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n"}
{"5565": "public class CatalogCrawler { \npublic void crawlDirectDatasets ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \nreturn ; \n} \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \ncountCatrefs = countCatrefs + 1 ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nList < InvDataset > leaves = new ArrayList < InvDataset > ( ) ; \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasAccess ( ) ) leaves . add ( dds ) ; \n} \nif ( leaves . size ( ) > 0 ) { \nif ( type == Type . first_direct ) { \nInvDataset dds = leaves . get ( 0 ) ; \nlisten . getDataset ( dds , context ) ; \n} \nelse if ( type == Type . random_direct ) { \nlisten . getDataset ( chooseRandom ( leaves ) , context ) ; \n} \nelse if ( type == Type . random_direct_middle ) { \nlisten . getDataset ( chooseRandomNotFirstOrLast ( leaves ) , context ) ; \n} \nelse { \nfor ( InvDataset dds : leaves ) { \nlisten . getDataset ( dds , context ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \n} \n} \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasNestedDatasets ( ) ) crawlDirectDatasets ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nif ( ds instanceof InvCatalogRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n"}
{"5573": "public class RandomAccessFile { \npublic int read ( ) throws IOException { \nif ( filePosition < dataEnd ) { \nint pos = ( int ) ( filePosition - bufferStart ) ; \nfilePosition = filePosition + 1 ; \nreturn ( buffer [ pos ] & 0xff ) ; \n} \nelse if ( endOfFile ) { \nreturn - 1 ; \n} \nelse { \nseek ( filePosition ) ; \nreturn read ( ) ; \n} \n} \n} \n"}
{"5574": "public class RandomAccessFile { \npublic final void readShort ( short [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \npa [ start + i ] = readShort ( ) ; \n} \n} \n} \n"}
{"5576": "public class RandomAccessFile { \npublic final void readInt ( int [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \npa [ start + i ] = readInt ( ) ; \n} \n} \n} \n"}
{"5577": "public class RandomAccessFile { \npublic final void readLong ( long [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \npa [ start + i ] = readLong ( ) ; \n} \n} \n} \n"}
{"5578": "public class RandomAccessFile { \npublic final void readFloat ( float [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \npa [ start + i ] = Float . intBitsToFloat ( readInt ( ) ) ; \n} \n} \n} \n"}
{"5579": "public class RandomAccessFile { \npublic final void readDouble ( double [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \npa [ start + i ] = Double . longBitsToDouble ( readLong ( ) ) ; \n} \n} \n} \n"}
{"5581": "public class RandomAccessFile { \npublic String readStringMax ( int nbytes ) throws IOException { \nbyte [ ] b = new byte [ nbytes ] ; \nreadFully ( b ) ; \nint count ; \nfor ( count = 0 ; \ncount < nbytes ; \ncount = count + 1 ) if ( b [ count ] == 0 ) break ; \nreturn new String ( b , 0 , count , CDM . utf8Charset ) ; \n} \n} \n"}
{"5582": "public class RandomAccessFile { \npublic final void writeBoolean ( boolean [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nwriteBoolean ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5583": "public class RandomAccessFile { \npublic final void writeShort ( short [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nwriteShort ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5584": "public class RandomAccessFile { \npublic final void writeChar ( char [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nwriteChar ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5585": "public class RandomAccessFile { \npublic final void writeInt ( int [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nwriteInt ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5586": "public class RandomAccessFile { \npublic final void writeLong ( long [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nwriteLong ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5587": "public class RandomAccessFile { \npublic final void writeFloat ( float [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nwriteFloat ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5588": "public class RandomAccessFile { \npublic final void writeDouble ( double [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nwriteDouble ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5589": "public class RandomAccessFile { \npublic final void writeBytes ( String s ) throws IOException { \nint len = s . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nwrite ( ( byte ) s . charAt ( i ) ) ; \n} \n} \n} \n"}
{"5590": "public class RandomAccessFile { \npublic final void writeBytes ( char b [ ] , int off , int len ) throws IOException { \nfor ( int i = off ; \ni < len ; \ni = i + 1 ) { \nwrite ( ( byte ) b [ i ] ) ; \n} \n} \n} \n"}
{"5595": "public class DirectoryBuilder { \nprivate boolean isLeaf ( IndexReader indexReader ) throws IOException { \nif ( partitionStatus == PartitionStatus . unknown ) { \nint countDir = 0 , countFile = 0 , count = 0 ; \ntry ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( dir ) ) { \nIterator < Path > iterator = dirStream . iterator ( ) ; \nwhile ( iterator . hasNext ( ) && count = count + 1 < 100 ) { \nPath p = iterator . next ( ) ; \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( attr . isDirectory ( ) ) countDir = countDir + 1 ; \nelse countFile = countFile + 1 ; \n} \n} \npartitionStatus = ( countFile > countDir ) ? PartitionStatus . isLeaf : PartitionStatus . isDirectoryPartition ; \n} \nreturn partitionStatus == PartitionStatus . isLeaf ; \n} \n} \n"}
{"5597": "public class DirectoryBuilder { \nprivate void scanForChildren ( ) { \nif ( debug ) System . out . printf ( \"DirectoryBuilder.scanForChildren on %s \" , dir ) ; \nint count = 0 ; \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( dir ) ) { \nfor ( Path p : ds ) { \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( attr . isDirectory ( ) ) { \nchildren . add ( new DirectoryBuilder ( topCollectionName , p , attr , suffix ) ) ; \nif ( debug && ( count = count + 1 % 10 == 0 ) ) System . out . printf ( \"%d \" , count ) ; \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nif ( debug ) System . out . printf ( \"done=%d%n\" , count ) ; \nchildrenConstructed = true ; \n} \n} \n"}
{"5603": "public class FileCache { \n@ Override public boolean release ( FileCacheable ncfile ) throws IOException { \nif ( ncfile == null ) return false ; \nif ( disabled . get ( ) ) { \nncfile . setFileCache ( null ) ; \nncfile . close ( ) ; \nreturn false ; \n} \nCacheElement . CacheFile file = files . get ( ncfile ) ; \nif ( file != null ) { \nif ( ! file . isLocked . get ( ) ) { \ncacheLog . warn ( \"FileCache \" + name + \" release \" + ncfile . getLocation ( ) + \" not locked; hash= \" + ncfile . hashCode ( ) ) ; \n} \nfile . lastAccessed = System . currentTimeMillis ( ) ; \nfile . countAccessed = file . countAccessed + 1 ; \nfile . isLocked . set ( false ) ; \nfile . ncfile . release ( ) ; \nif ( cacheLog . isDebugEnabled ( ) ) cacheLog . debug ( \"FileCache \" + name + \" release \" + ncfile . getLocation ( ) + \"; hash= \" + ncfile . hashCode ( ) ) ; \nif ( debugPrint ) System . out . printf ( \"  FileCache %s release %s lock=%s count=%d%n\" , name , ncfile . getLocation ( ) , file . isLocked . get ( ) , countLocked ( ) ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"5616": "public class DirectoryCollection { \npublic void iterateOverMFileCollection ( Visitor visit ) throws IOException { \nif ( debug ) System . out . printf ( \" iterateOverMFileCollection %s \" , collectionDir ) ; \nint count = 0 ; \ntry ( DirectoryStream < Path > ds = Files . newDirectoryStream ( collectionDir , new MyStreamFilter ( ) ) ) { \nfor ( Path p : ds ) { \ntry { \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( ! attr . isDirectory ( ) ) visit . consume ( new MFileOS7 ( p ) ) ; \nif ( debug ) System . out . printf ( \"%d \" , count = count + 1 ) ; \n} \ncatch ( IOException ioe ) { \nlogger . error ( \"Failed to read attributes from file found in Files.newDirectoryStream \" , ioe ) ; \n} \n} \n} \nif ( debug ) System . out . printf ( \"%d%n\" , count ) ; \n} \n} \n"}
{"5658": "public class Grib2Pds { \nprotected CalendarDate calcTime ( int startIndex ) { \nint year = GribNumbers . int2 ( getOctet ( startIndex = startIndex + 1 ) , getOctet ( startIndex = startIndex + 1 ) ) ; \nint month = getOctet ( startIndex = startIndex + 1 ) ; \nint day = getOctet ( startIndex = startIndex + 1 ) ; \nint hour = getOctet ( startIndex = startIndex + 1 ) ; \nint minute = getOctet ( startIndex = startIndex + 1 ) ; \nint second = getOctet ( startIndex = startIndex + 1 ) ; \nif ( ( year == 0 ) && ( month == 0 ) && ( day == 0 ) && ( hour == 0 ) && ( minute == 0 ) && ( second == 0 ) ) return CalendarDate . UNKNOWN ; \nif ( hour > 23 ) { \nday += ( hour / 24 ) ; \nhour = hour % 24 ; \n} \nreturn CalendarDate . of ( null , year , month , day , hour , minute , second ) ; \n} \n} \n"}
{"5671": "public class DatasetSource { \nprivate void nameDatasets ( InvDatasetImpl datasetContainer ) { \nif ( this . getDatasetNamerList ( ) . isEmpty ( ) ) return ; \nif ( this . isFlatten ( ) ) { \nlogger . debug ( \"nameDatasets(): structure is FLAT calling nameDatasetList()\" ) ; \nthis . nameDatasetList ( datasetContainer ) ; \n} \nelse { \nlogger . debug ( \"nameDatasets(): structure is DIRECTORY_TREE calling\" + \" nameDatasetTree() on each dataset in dataset container\" ) ; \nInvDatasetImpl curDs = null ; \nfor ( int j = 0 ; \nj < datasetContainer . getDatasets ( ) . size ( ) ; \nj = j + 1 ) { \ncurDs = ( InvDatasetImpl ) datasetContainer . getDatasets ( ) . get ( j ) ; \nthis . nameDatasetTree ( curDs ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5672": "public class DatasetSource { \nprivate void nameDatasetList ( InvDatasetImpl dataset ) { \nInvDatasetImpl namedDs = new InvDatasetImpl ( dataset , \"nameDatastList() temp dataset\" , null , null , null ) ; \ndataset . addDataset ( namedDs ) ; \nDatasetNamer curNamer = null ; \nfor ( int i = 0 ; \ni < this . datasetNamerList . size ( ) ; \ni = i + 1 ) { \ncurNamer = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nlogger . debug ( \"nameDatasetList(): trying namer ({})\" , curNamer . getName ( ) ) ; \nInvDatasetImpl addLevelDs = null ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs = new InvDatasetImpl ( null , curNamer . getName ( ) , null , null , null ) ; \n} \nInvDatasetImpl curDs = null ; \njava . util . Iterator dsIter = dataset . getDatasets ( ) . iterator ( ) ; \nwhile ( dsIter . hasNext ( ) ) { \ncurDs = ( InvDatasetImpl ) dsIter . next ( ) ; \nlogger . debug ( \"nameDatasetList(): try namer on this ds ({}-{})\" , curDs . getName ( ) , curDs . getUrlPath ( ) ) ; \nif ( curNamer . nameDataset ( curDs ) ) { \nlogger . debug ( \"nameDatasetList(): ds named ({})\" , curDs . getName ( ) ) ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs . addDataset ( curDs ) ; \n} \nelse { \nnamedDs . addDataset ( curDs ) ; \n} \ndsIter . remove ( ) ; \n} \n} \nif ( curNamer . getAddLevel ( ) ) { \nif ( addLevelDs . hasNestedDatasets ( ) ) { \nnamedDs . addDataset ( addLevelDs ) ; \n} \n} \n} \nnamedDs . finish ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"nameDatasetList(): number of unnamed datasets is \" + dataset . getDatasets ( ) . size ( ) + \".\" ) ; \nlogger . debug ( \"nameDatasetList(): add named datasets back to container.\" ) ; \n} \nfor ( int i = 0 ; \ni < namedDs . getDatasets ( ) . size ( ) ; \ni = i + 1 ) { \ndataset . addDataset ( ( InvDatasetImpl ) namedDs . getDatasets ( ) . get ( i ) ) ; \n} \ndataset . removeDataset ( namedDs ) ; \nreturn ; \n} \n} \n"}
{"5673": "public class DatasetSource { \nprivate void nameDatasetTree ( InvDatasetImpl dataset ) { \nif ( dataset . getName ( ) . equals ( \"\" ) || ! dataset . hasAccess ( ) ) { \nlogger . debug ( \"nameDatasetTree(): naming dataset ({})...\" , dataset . getUrlPath ( ) ) ; \nDatasetNamer dsN = null ; \nfor ( int i = 0 ; \ni < this . datasetNamerList . size ( ) ; \ni = i + 1 ) { \ndsN = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nif ( dsN . nameDataset ( dataset ) ) { \nlogger . debug ( \"nameDatasetTree(): ... used namer ({})\" , dsN . getName ( ) ) ; \nbreak ; \n} \n} \n} \nInvDatasetImpl curDs = null ; \nfor ( int j = 0 ; \nj < dataset . getDatasets ( ) . size ( ) ; \nj = j + 1 ) { \ncurDs = ( InvDatasetImpl ) dataset . getDatasets ( ) . get ( j ) ; \nlogger . debug ( \"nameDatasetTree(): recurse to name child dataset ({})\" , curDs . getUrlPath ( ) ) ; \nthis . nameDatasetTree ( curDs ) ; \n} \nreturn ; \n} \n} \n"}
{"5683": "public class GempakSoundingFileReader { \nprivate List < String > SN_CKUA ( ) { \nList < String > types = new ArrayList < > ( ) ; \nboolean above = false ; \nboolean done = false ; \nString partToCheck ; \nwhile ( ! done ) { \nfor ( int group = 0 ; \ngroup < belowGroups . length ; \ngroup = group + 1 ) { \nif ( above ) { \npartToCheck = aboveGroups [ group ] ; \n} \nelse { \npartToCheck = belowGroups [ group ] ; \n} \nif ( checkForValidGroup ( partToCheck , parmLists [ group ] ) ) { \ntypes . add ( partToCheck ) ; \n} \n} \nif ( ! above ) { \nabove = true ; \n} \nelse { \ndone = true ; \n} \n} \nreturn types ; \n} \n} \n"}
{"5684": "public class GempakSoundingFileReader { \nprivate boolean checkForValidGroup ( String partToCheck , String [ ] params ) { \nDMPart part = getPart ( partToCheck ) ; \nif ( part == null ) { \nreturn false ; \n} \nint i = 0 ; \nfor ( DMParam parm : part . params ) { \nif ( ! ( parm . kprmnm . equals ( params [ i = i + 1 ] ) ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5699": "public class JTableSorted { \npublic int [ ] getModelIndex ( ) { \nint [ ] modelIndex = new int [ colName . length ] ; \nTableColumnModel tcm = jtable . getColumnModel ( ) ; \nfor ( int i = 0 ; \ni < colName . length ; \ni = i + 1 ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nmodelIndex [ i ] = tc . getModelIndex ( ) ; \n} \nreturn modelIndex ; \n} \n} \n"}
{"5701": "public class Util { \nstatic private void quickSort ( String a [ ] , int lo0 , int hi0 ) { \nint lo = lo0 ; \nint hi = hi0 ; \nString mid ; \nif ( hi0 > lo0 ) { \nmid = a [ ( lo0 + hi0 ) / 2 ] ; \nwhile ( lo <= hi ) { \nwhile ( ( lo < hi0 ) && ( a [ lo ] . compareTo ( mid ) < 0 ) ) lo = lo + 1 ; \nwhile ( ( hi > lo0 ) && ( a [ hi ] . compareTo ( mid ) > 0 ) ) hi = hi - 1 ; \nif ( lo <= hi ) { \nswap ( a , lo , hi ) ; \nlo = lo + 1 ; \nhi = hi - 1 ; \n} \n} \nif ( lo0 < hi ) quickSort ( a , lo0 , hi ) ; \nif ( lo < hi0 ) quickSort ( a , lo , hi0 ) ; \n} \n} \n} \n"}
{"5713": "public class DapSerializer { \nprotected void writeStructure1 ( DataCursor instance , SerialWriter dst ) throws IOException { \nassert instance . getScheme ( ) == DataCursor . Scheme . STRUCTURE ; \nDapVariable template = ( DapVariable ) instance . getTemplate ( ) ; \nassert ( this . ce . references ( template ) ) ; \nDapStructure ds = ( DapStructure ) template . getBaseType ( ) ; \nList < DapVariable > fields = ds . getFields ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni = i + 1 ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) continue ; \nDataCursor df = ( DataCursor ) instance . readField ( i ) ; \nwriteVariable ( df , dst ) ; \n} \n} \n} \n"}
{"5714": "public class DapSerializer { \nprotected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nDapSequence ds = ( DapSequence ) template . getBaseType ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( false ) while ( odom . hasNext ( ) ) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteSequence1 ( instance [ 0 ] , dst ) ; \n} \nelse { \nDataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; \nfor ( int i = 0 ; \ni < instances . length ; \ni = i + 1 ) { \nwriteSequence1 ( instances [ i ] , dst ) ; \n} \n} \n} \n} \n"}
{"5715": "public class DapSerializer { \nprotected void writeRecord ( DataCursor record , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) record . getTemplate ( ) ; \nDapSequence seq = ( DapSequence ) template . getBaseType ( ) ; \nList < DapVariable > fields = seq . getFields ( ) ; \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni = i + 1 ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) continue ; \nDataCursor df = ( DataCursor ) record . readField ( i ) ; \nwriteVariable ( df , dst ) ; \n} \n} \n} \n"}
{"5720": "public class Grib2DataReader { \nprivate float [ ] getData0 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nint nb = gdrs . numberOfBits ; \nint D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nint E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nBitReader reader = new BitReader ( raf , startPos + 5 ) ; \nif ( bitmap == null ) { \nfor ( int i = 0 ; \ni < totalNPoints ; \ni = i + 1 ) { \ndata [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \n} \n} \nelse { \nfor ( int i = 0 ; \ni < totalNPoints ; \ni = i + 1 ) { \nif ( GribNumbers . testBitIsSet ( bitmap [ i / 8 ] , i % 8 ) ) { \ndata [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \n} \nelse { \ndata [ i ] = staticMissingValue ; \n} \n} \n} \nreturn data ; \n} \n} \n"}
{"5721": "public class Grib2DataReader { \nprivate float [ ] getData41 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nint nb = gdrs . numberOfBits ; \nint D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nint E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nif ( nb == 0 ) { \nArrays . fill ( data , R ) ; \nreturn data ; \n} \nbyte [ ] buf = new byte [ dataLength - 5 ] ; \nraf . readFully ( buf ) ; \nInputStream in = new ByteArrayInputStream ( buf ) ; \nBufferedImage image = ImageIO . read ( in ) ; \nif ( nb != image . getColorModel ( ) . getPixelSize ( ) ) { \nlogger . debug ( \"PNG pixel size disagrees with grib number of bits: \" , image . getColorModel ( ) . getPixelSize ( ) , nb ) ; \n} \nDataBuffer db = image . getRaster ( ) . getDataBuffer ( ) ; \nif ( bitmap == null ) { \nfor ( int i = 0 ; \ni < dataNPoints ; \ni = i + 1 ) { \ndata [ i ] = ( R + db . getElem ( i ) * EE ) / DD ; \n} \n} \nelse { \nfor ( int bitPt = 0 , dataPt = 0 ; \nbitPt < totalNPoints ; \nbitPt = bitPt + 1 ) { \nif ( GribNumbers . testBitIsSet ( bitmap [ bitPt / 8 ] , bitPt % 8 ) ) { \ndata [ bitPt ] = ( R + db . getElem ( dataPt = dataPt + 1 ) * EE ) / DD ; \n} \nelse { \ndata [ bitPt ] = staticMissingValue ; \n} \n} \n} \nreturn data ; \n} \n} \n"}
{"5722": "public class CDMCursor { \n@ Override public Object read ( List < Slice > slices ) throws DapException { \nswitch ( this . scheme ) { \ncase ATOMIC : return readAtomic ( slices ) ; \ncase STRUCTURE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \nCDMCursor [ ] instances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase SEQUENCE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \ninstances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase STRUCTARRAY : Odometer odom = Odometer . factory ( slices ) ; \ninstances = new CDMCursor [ ( int ) odom . totalSize ( ) ] ; \nfor ( int i = 0 ; \nodom . hasNext ( ) ; \ni = i + 1 ) { \ninstances [ i ] = readStructure ( odom . next ( ) ) ; \n} \nreturn instances ; \ncase SEQARRAY : instances = readSequence ( slices ) ; \nreturn instances ; \ndefault : throw new DapException ( \"Attempt to slice a scalar object\" ) ; \n} \n} \n} \n"}
{"5726": "public class StationRenderer { \npublic void setStations ( java . util . List < ucar . unidata . geoloc . Station > stns ) { \nstations = new ArrayList < StationUI > ( stns . size ( ) ) ; \nstationHash . clear ( ) ; \nfor ( int i = 0 ; \ni < stns . size ( ) ; \ni = i + 1 ) { \nucar . unidata . geoloc . Station s = ( ucar . unidata . geoloc . Station ) stns . get ( i ) ; \nStationUI sui = new StationUI ( s ) ; \nstations . add ( sui ) ; \nstationHash . put ( s . getName ( ) , sui ) ; \n} \nposWasCalc = false ; \ncalcWorldPos ( ) ; \n} \n} \n"}
{"5737": "public class MAVector { \npublic double dot ( MAVector v ) { \nif ( nelems != v . getNelems ( ) ) throw new IllegalArgumentException ( \"MAVector.dot \" + nelems + \" != \" + v . getNelems ( ) ) ; \ndouble sum = 0.0 ; \nfor ( int k = 0 ; \nk < nelems ; \nk = k + 1 ) sum += getDouble ( k ) * v . getDouble ( k ) ; \nreturn sum ; \n} \n} \n"}
{"5738": "public class MAVector { \npublic double norm ( ) { \ndouble sum = 0.0 ; \nfor ( int k = 0 ; \nk < nelems ; \nk = k + 1 ) { \ndouble val = getDouble ( k ) ; \nsum += val * val ; \n} \nreturn Math . sqrt ( sum ) ; \n} \n} \n"}
{"5739": "public class MAVector { \npublic void normalize ( ) { \ndouble norm = norm ( ) ; \nif ( norm <= 0.0 ) return ; \nfor ( int k = 0 ; \nk < nelems ; \nk = k + 1 ) { \ndouble val = getDouble ( k ) ; \nsetDouble ( k , val / norm ) ; \n} \n} \n} \n"}
{"5760": "public class NetcdfFile { \nstatic public void registerIOProviderPreferred ( Class iospClass , Class target ) throws IllegalAccessException , InstantiationException { \niospDeRegister ( iospClass ) ; \nint pos = - 1 ; \nfor ( int i = 0 ; \ni < registeredProviders . size ( ) ; \ni = i + 1 ) { \nIOServiceProvider candidate = registeredProviders . get ( i ) ; \nif ( candidate . getClass ( ) == target ) { \nif ( pos < i ) pos = i ; \nbreak ; \n} \n} \nif ( pos < 0 ) pos = 0 ; \nIOServiceProvider spi = ( IOServiceProvider ) iospClass . newInstance ( ) ; \nregisteredProviders . add ( pos , spi ) ; \n} \n} \n"}
{"5762": "public class NetcdfFile { \nstatic public boolean iospDeRegister ( Class iospClass ) { \nfor ( int i = 0 ; \ni < registeredProviders . size ( ) ; \ni = i + 1 ) { \nIOServiceProvider spi = registeredProviders . get ( i ) ; \nif ( spi . getClass ( ) == iospClass ) { \nregisteredProviders . remove ( i ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5808": "public class StringValidateEncodeUtils { \n@ SuppressWarnings ( { \n\"UnnecessaryContinue\" } \n) public static boolean descendOnlyFilePath ( String path ) { \nString [ ] pathSegments = path . split ( \"/\" ) ; \nint i = 0 ; \nfor ( int indxOrigSegs = 0 ; \nindxOrigSegs < pathSegments . length ; \nindxOrigSegs = indxOrigSegs + 1 ) { \nString s = pathSegments [ indxOrigSegs ] ; \nif ( s . equals ( \".\" ) ) continue ; \nelse if ( s . equals ( \"..\" ) ) { \nif ( i == 0 ) return false ; \ni = i - 1 ; \n} \nelse { \ni = i + 1 ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5809": "public class StringValidateEncodeUtils { \npublic static String unicodeCodePoint2PercentHexString ( int codePoint , String charsetName ) { \nif ( ! Character . isDefined ( codePoint ) ) throw new IllegalArgumentException ( String . format ( \"Given code point [U+%1$04X - %1$d] not assigned to an abstract character.\" , codePoint ) ) ; \nif ( Character . getType ( codePoint ) == Character . SURROGATE ) throw new IllegalArgumentException ( String . format ( \"Given code point [U+%1$04X - %1$d] is an unencodable (by itself) surrogate character.\" , codePoint ) ) ; \nCharset charset = Charset . availableCharsets ( ) . get ( charsetName ) ; \nif ( charset == null ) throw new IllegalArgumentException ( String . format ( \"Unsupported charset [%s].\" , charsetName ) ) ; \nchar [ ] chars = Character . toChars ( codePoint ) ; \nByteBuffer byteBuffer = null ; \ntry { \nbyteBuffer = charset . newEncoder ( ) . encode ( CharBuffer . wrap ( chars ) ) ; \n} \ncatch ( CharacterCodingException e ) { \nString message = String . format ( \"Given code point [U+%1$04X - %1$d] cannot be encode in given charset [%2$s].\" , codePoint , charsetName ) ; \nthrow new IllegalArgumentException ( message , e ) ; \n} \nbyteBuffer . rewind ( ) ; \nStringBuilder encodedString = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < byteBuffer . limit ( ) ; \ni = i + 1 ) { \nString asHex = Integer . toHexString ( byteBuffer . get ( ) & 0xFF ) ; \nencodedString . append ( \"%\" ) . append ( asHex . length ( ) == 1 ? \"0\" : \"\" ) . append ( asHex ) ; \n} \nreturn encodedString . toString ( ) ; \n} \n} \n"}
{"5813": "public class MessageBroker { \nprivate int process ( Buffer b , InputStream is ) throws IOException { \nint start = 0 ; \nwhile ( start < b . have ) { \nint matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; \nif ( matchPos < 0 ) { \nif ( start == 0 ) return b . have - 3 ; \nelse return start ; \n} \nif ( matchPos + 6 >= b . have ) { \nreturn start ; \n} \nint b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; \nint b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; \nint b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; \nint messLen = b1 << 16 | b2 << 8 | b3 ; \nMessageTask task = new MessageTask ( messLen ) ; \ntask . header = extractHeader ( start , matchPos , b ) ; \nint last = matchPos + messLen ; \nif ( last > b . have ) { \ntask . have = b . have - matchPos ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \nif ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { \nSystem . out . println ( \"Failed to read remaining BUFR message\" ) ; \nbreak ; \n} \n} \nelse { \ntask . have = task . len ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \n} \nboolean ok = true ; \nfor ( int i = task . len - 4 ; \ni < task . len ; \ni = i + 1 ) { \nint bb = task . mess [ i ] ; \nif ( bb != 55 ) { \nok = false ; \nbad_msgs = bad_msgs + 1 ; \n} \n} \ntry { \nif ( ok ) messQ . put ( task ) ; \ntotal_msgs = total_msgs + 1 ; \n} \ncatch ( InterruptedException e ) { \nSystem . out . println ( \" interrupted queue put - assume process exit\" ) ; \nbreak ; \n} \nstart = matchPos + messLen + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5823": "public class DoradeSWIB { \npublic float [ ] getLatitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] lats = new float [ nRays ] ; \nfor ( int i = 0 ; \ni < nRays ; \ni = i + 1 ) lats [ i ] = myASIBs [ i ] . getLatitude ( ) ; \nreturn lats ; \n} \n} \n"}
{"5824": "public class DoradeSWIB { \npublic float [ ] getLongitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] lons = new float [ nRays ] ; \nfor ( int i = 0 ; \ni < nRays ; \ni = i + 1 ) lons [ i ] = myASIBs [ i ] . getLongitude ( ) ; \nreturn lons ; \n} \n} \n"}
{"5825": "public class DoradeSWIB { \npublic float [ ] getAltitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] alts = new float [ nRays ] ; \nfor ( int i = 0 ; \ni < nRays ; \ni = i + 1 ) alts [ i ] = myASIBs [ i ] . getAltitude ( ) ; \nreturn alts ; \n} \n} \n"}
{"5826": "public class DoradeSWIB { \npublic float [ ] getAzimuths ( ) { \nif ( azimuths == null ) { \nazimuths = new float [ nRays ] ; \nfor ( int r = 0 ; \nr < nRays ; \nr = r + 1 ) { \nazimuths [ r ] = myRYIBs [ r ] . getAzimuth ( ) ; \n} \n} \nreturn azimuths ; \n} \n} \n"}
{"5827": "public class DoradeSWIB { \npublic float [ ] getElevations ( ) { \nif ( elevations == null ) { \nelevations = new float [ nRays ] ; \nfor ( int r = 0 ; \nr < nRays ; \nr = r + 1 ) { \nelevations [ r ] = myRYIBs [ r ] . getElevation ( ) ; \n} \n} \nreturn elevations ; \n} \n} \n"}
{"5849": "public class TableAligner { \npublic static void installInAllColumns ( JTable table , int alignment ) { \nfor ( int colViewIndex = 0 ; \ncolViewIndex < table . getColumnCount ( ) ; \ncolViewIndex = colViewIndex + 1 ) { \ninstallInOneColumn ( table , colViewIndex , alignment ) ; \n} \n} \n} \n"}
{"5855": "public class CoreSocketFactory { \nprivate static List < String > listIpTypes ( String cloudSqlIpTypes ) { \nString [ ] rawTypes = cloudSqlIpTypes . split ( \",\" ) ; \nArrayList < String > result = new ArrayList < > ( rawTypes . length ) ; \nfor ( int i = 0 ; \ni < rawTypes . length ; \ni = i + 1 ) { \nif ( rawTypes [ i ] . trim ( ) . equalsIgnoreCase ( \"PUBLIC\" ) ) { \nresult . add ( i , \"PRIMARY\" ) ; \n} \nelse { \nresult . add ( i , rawTypes [ i ] . trim ( ) . toUpperCase ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"5858": "public class InMemoryJavaCompiler { \npublic Map < String , Class < ? > > compileAll ( ) throws Exception { \nif ( sourceCodes . size ( ) == 0 ) { \nthrow new CompilationException ( \"No source code to compile\" ) ; \n} \nCollection < SourceCode > compilationUnits = sourceCodes . values ( ) ; \nCompiledCode [ ] code ; \ncode = new CompiledCode [ compilationUnits . size ( ) ] ; \nIterator < SourceCode > iter = compilationUnits . iterator ( ) ; \nfor ( int i = 0 ; \ni < code . length ; \ni = i + 1 ) { \ncode [ i ] = new CompiledCode ( iter . next ( ) . getClassName ( ) ) ; \n} \nDiagnosticCollector < JavaFileObject > collector = new DiagnosticCollector < > ( ) ; \nExtendedStandardJavaFileManager fileManager = new ExtendedStandardJavaFileManager ( javac . getStandardFileManager ( null , null , null ) , classLoader ) ; \nJavaCompiler . CompilationTask task = javac . getTask ( null , fileManager , collector , options , null , compilationUnits ) ; \nboolean result = task . call ( ) ; \nif ( ! result || collector . getDiagnostics ( ) . size ( ) > 0 ) { \nStringBuffer exceptionMsg = new StringBuffer ( ) ; \nexceptionMsg . append ( \"Unable to compile the source\" ) ; \nboolean hasWarnings = false ; \nboolean hasErrors = false ; \nfor ( Diagnostic < ? extends JavaFileObject > d : collector . getDiagnostics ( ) ) { \nswitch ( d . getKind ( ) ) { \ncase NOTE : case MANDATORY_WARNING : case WARNING : hasWarnings = true ; \nbreak ; \ncase OTHER : case ERROR : default : hasErrors = true ; \nbreak ; \n} \nexceptionMsg . append ( \"\\n\" ) . append ( \"[kind=\" ) . append ( d . getKind ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"line=\" ) . append ( d . getLineNumber ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"message=\" ) . append ( d . getMessage ( Locale . US ) ) . append ( \"]\" ) ; \n} \nif ( hasWarnings && ! ignoreWarnings || hasErrors ) { \nthrow new CompilationException ( exceptionMsg . toString ( ) ) ; \n} \n} \nMap < String , Class < ? > > classes = new HashMap < String , Class < ? > > ( ) ; \nfor ( String className : sourceCodes . keySet ( ) ) { \nclasses . put ( className , classLoader . loadClass ( className ) ) ; \n} \nreturn classes ; \n} \n} \n"}
{"5883": "public class CoverageDataPng { \npublic int [ ] getPixelValues ( byte [ ] imageBytes ) { \nPngReaderInt reader = new PngReaderInt ( new ByteArrayInputStream ( imageBytes ) ) ; \nvalidateImageType ( reader ) ; \nint [ ] pixels = new int [ reader . imgInfo . cols * reader . imgInfo . rows ] ; \nint rowNumber = 0 ; \nwhile ( reader . hasMoreRows ( ) ) { \nImageLineInt row = reader . readRowInt ( ) ; \nint [ ] rowValues = row . getScanline ( ) ; \nSystem . arraycopy ( rowValues , 0 , pixels , rowNumber * reader . imgInfo . cols , rowValues . length ) ; \nrowNumber = rowNumber + 1 ; \n} \nreader . close ( ) ; \nreturn pixels ; \n} \n} \n"}
{"5900": "public class CoverageData { \nprivate CoverageDataTileMatrixResults getResultsZoomIn ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { \nCoverageDataTileMatrixResults results = null ; \nfor ( long zoomLevel = tileMatrix . getZoomLevel ( ) + 1 ; \nzoomLevel <= tileDao . getMaxZoom ( ) ; \nzoomLevel = zoomLevel + 1 ) { \nTileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; \nif ( zoomTileMatrix != null ) { \nresults = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; \nif ( results != null ) { \nbreak ; \n} \n} \n} \nreturn results ; \n} \n} \n"}
{"5901": "public class CoverageData { \nprivate CoverageDataTileMatrixResults getResultsZoomOut ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { \nCoverageDataTileMatrixResults results = null ; \nfor ( long zoomLevel = tileMatrix . getZoomLevel ( ) - 1 ; \nzoomLevel >= tileDao . getMinZoom ( ) ; \nzoomLevel = zoomLevel - 1 ) { \nTileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; \nif ( zoomTileMatrix != null ) { \nresults = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; \nif ( results != null ) { \nbreak ; \n} \n} \n} \nreturn results ; \n} \n} \n"}
{"5930": "public class TileGenerator { \npublic int getTileCount ( ) { \nif ( tileCount == null ) { \nlong count = 0 ; \nboolean degrees = projection . isUnit ( Units . DEGREES ) ; \nProjectionTransform transformToWebMercator = null ; \nif ( ! degrees ) { \ntransformToWebMercator = projection . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; \n} \nfor ( int zoom = minZoom ; \nzoom <= maxZoom ; \nzoom = zoom + 1 ) { \nBoundingBox expandedBoundingBox = getBoundingBox ( zoom ) ; \nTileGrid tileGrid = null ; \nif ( degrees ) { \ntileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( expandedBoundingBox , zoom ) ; \n} \nelse { \ntileGrid = TileBoundingBoxUtils . getTileGrid ( expandedBoundingBox . transform ( transformToWebMercator ) , zoom ) ; \n} \ncount += tileGrid . count ( ) ; \ntileGrids . put ( zoom , tileGrid ) ; \ntileBounds . put ( zoom , expandedBoundingBox ) ; \n} \ntileCount = ( int ) Math . min ( count , Integer . MAX_VALUE ) ; \n} \nreturn tileCount ; \n} \n} \n"}
{"5946": "public class CoverageDataTiff { \npublic float [ ] getPixelValues ( byte [ ] imageBytes ) { \nTIFFImage tiffImage = TiffReader . readTiff ( imageBytes ) ; \nFileDirectory directory = tiffImage . getFileDirectory ( ) ; \nvalidateImageType ( directory ) ; \nRasters rasters = directory . readRasters ( ) ; \nfloat [ ] pixels = new float [ rasters . getWidth ( ) * rasters . getHeight ( ) ] ; \nfor ( int y = 0 ; \ny < rasters . getHeight ( ) ; \ny = y + 1 ) { \nfor ( int x = 0 ; \nx < rasters . getWidth ( ) ; \nx = x + 1 ) { \nint index = rasters . getSampleIndex ( x , y ) ; \npixels [ index ] = rasters . getPixelSample ( 0 , x , y ) . floatValue ( ) ; \n} \n} \nreturn pixels ; \n} \n} \n"}
{"5989": "public class TileCreator { \npublic GeoPackageTile getTile ( BoundingBox requestBoundingBox ) { \nGeoPackageTile tile = null ; \nProjectionTransform transformRequestToTiles = requestProjection . getTransformation ( tilesProjection ) ; \nBoundingBox tilesBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; \nList < TileMatrix > tileMatrices = getTileMatrices ( tilesBoundingBox ) ; \nfor ( int i = 0 ; \ntile == null && i < tileMatrices . size ( ) ; \ni = i + 1 ) { \nTileMatrix tileMatrix = tileMatrices . get ( i ) ; \nTileCursor tileResults = retrieveTileResults ( tilesBoundingBox , tileMatrix ) ; \nif ( tileResults != null ) { \ntry { \nif ( tileResults . getCount ( ) > 0 ) { \nBoundingBox requestProjectedBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; \nint requestedTileWidth = width != null ? width : ( int ) tileMatrix . getTileWidth ( ) ; \nint requestedTileHeight = height != null ? height : ( int ) tileMatrix . getTileHeight ( ) ; \nint tileWidth = requestedTileWidth ; \nint tileHeight = requestedTileHeight ; \nif ( ! sameProjection ) { \ntileWidth = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLongitude ( ) - requestProjectedBoundingBox . getMinLongitude ( ) ) / tileMatrix . getPixelXSize ( ) ) ; \ntileHeight = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLatitude ( ) - requestProjectedBoundingBox . getMinLatitude ( ) ) / tileMatrix . getPixelYSize ( ) ) ; \n} \nBitmap tileBitmap = drawTile ( tileMatrix , tileResults , requestProjectedBoundingBox , tileWidth , tileHeight ) ; \nif ( tileBitmap != null ) { \nif ( ! sameProjection ) { \nBitmap reprojectTile = reprojectTile ( tileBitmap , requestedTileWidth , requestedTileHeight , requestBoundingBox , transformRequestToTiles , tilesBoundingBox ) ; \ntileBitmap . recycle ( ) ; \ntileBitmap = reprojectTile ; \n} \ntry { \nbyte [ ] tileData = BitmapConverter . toBytes ( tileBitmap , COMPRESS_FORMAT ) ; \ntileBitmap . recycle ( ) ; \ntile = new GeoPackageTile ( requestedTileWidth , requestedTileHeight , tileData ) ; \n} \ncatch ( IOException e ) { \nLog . e ( TileCreator . class . getSimpleName ( ) , \"Failed to create tile. min lat: \" + requestBoundingBox . getMinLatitude ( ) + \", max lat: \" + requestBoundingBox . getMaxLatitude ( ) + \", min lon: \" + requestBoundingBox . getMinLongitude ( ) + \", max lon: \" + requestBoundingBox . getMaxLongitude ( ) , e ) ; \n} \n} \n} \n} \nfinally { \ntileResults . close ( ) ; \n} \n} \n} \nreturn tile ; \n} \n} \n"}
{"5991": "public class TileCreator { \nprivate Bitmap reprojectTile ( Bitmap tile , int requestedTileWidth , int requestedTileHeight , BoundingBox requestBoundingBox , ProjectionTransform transformRequestToTiles , BoundingBox tilesBoundingBox ) { \nfinal double requestedWidthUnitsPerPixel = ( requestBoundingBox . getMaxLongitude ( ) - requestBoundingBox . getMinLongitude ( ) ) / requestedTileWidth ; \nfinal double requestedHeightUnitsPerPixel = ( requestBoundingBox . getMaxLatitude ( ) - requestBoundingBox . getMinLatitude ( ) ) / requestedTileHeight ; \nfinal double tilesDistanceWidth = tilesBoundingBox . getMaxLongitude ( ) - tilesBoundingBox . getMinLongitude ( ) ; \nfinal double tilesDistanceHeight = tilesBoundingBox . getMaxLatitude ( ) - tilesBoundingBox . getMinLatitude ( ) ; \nfinal int width = tile . getWidth ( ) ; \nfinal int height = tile . getHeight ( ) ; \nint [ ] pixels = new int [ width * height ] ; \ntile . getPixels ( pixels , 0 , width , 0 , 0 , width , height ) ; \nint [ ] projectedPixels = new int [ requestedTileWidth * requestedTileHeight ] ; \nfor ( int y = 0 ; \ny < requestedTileHeight ; \ny = y + 1 ) { \nfor ( int x = 0 ; \nx < requestedTileWidth ; \nx = x + 1 ) { \ndouble longitude = requestBoundingBox . getMinLongitude ( ) + ( x * requestedWidthUnitsPerPixel ) ; \ndouble latitude = requestBoundingBox . getMaxLatitude ( ) - ( y * requestedHeightUnitsPerPixel ) ; \nProjCoordinate fromCoord = new ProjCoordinate ( longitude , latitude ) ; \nProjCoordinate toCoord = transformRequestToTiles . transform ( fromCoord ) ; \ndouble projectedLongitude = toCoord . x ; \ndouble projectedLatitude = toCoord . y ; \nint xPixel = ( int ) Math . round ( ( ( projectedLongitude - tilesBoundingBox . getMinLongitude ( ) ) / tilesDistanceWidth ) * width ) ; \nint yPixel = ( int ) Math . round ( ( ( tilesBoundingBox . getMaxLatitude ( ) - projectedLatitude ) / tilesDistanceHeight ) * height ) ; \nxPixel = Math . max ( 0 , xPixel ) ; \nxPixel = Math . min ( width - 1 , xPixel ) ; \nyPixel = Math . max ( 0 , yPixel ) ; \nyPixel = Math . min ( height - 1 , yPixel ) ; \nint color = pixels [ ( yPixel * width ) + xPixel ] ; \nprojectedPixels [ ( y * requestedTileWidth ) + x ] = color ; \n} \n} \nBitmap projectedTileBitmap = Bitmap . createBitmap ( requestedTileWidth , requestedTileHeight , tile . getConfig ( ) ) ; \nprojectedTileBitmap . setPixels ( projectedPixels , 0 , requestedTileWidth , 0 , 0 , requestedTileWidth , requestedTileHeight ) ; \nreturn projectedTileBitmap ; \n} \n} \n"}
{"6017": "public class FeatureTileCanvas { \npublic Bitmap createBitmap ( ) { \nBitmap bitmap = null ; \nCanvas canvas = null ; \nfor ( int layer = 0 ; \nlayer < 4 ; \nlayer = layer + 1 ) { \nBitmap layerBitmap = layeredBitmap [ layer ] ; \nif ( layerBitmap != null ) { \nif ( bitmap == null ) { \nbitmap = layerBitmap ; \ncanvas = layeredCanvas [ layer ] ; \n} \nelse { \ncanvas . drawBitmap ( layerBitmap , new Matrix ( ) , null ) ; \nlayerBitmap . recycle ( ) ; \n} \nlayeredBitmap [ layer ] = null ; \nlayeredCanvas [ layer ] = null ; \n} \n} \nreturn bitmap ; \n} \n} \n"}
{"6018": "public class FeatureTileCanvas { \npublic void recycle ( ) { \nfor ( int layer = 0 ; \nlayer < 4 ; \nlayer = layer + 1 ) { \nBitmap bitmap = layeredBitmap [ layer ] ; \nif ( bitmap != null ) { \nbitmap . recycle ( ) ; \nlayeredBitmap [ layer ] = null ; \nlayeredCanvas [ layer ] = null ; \n} \n} \n} \n} \n"}
{"6066": "public class CoverageDataPngImage { \nprivate void readPixels ( ) { \nif ( reader != null ) { \npixels = new int [ reader . imgInfo . rows ] [ reader . imgInfo . cols ] ; \nint rowCount = 0 ; \nwhile ( reader . hasMoreRows ( ) ) { \nImageLineInt row = reader . readRowInt ( ) ; \nint [ ] columnValues = new int [ reader . imgInfo . cols ] ; \nSystem . arraycopy ( row . getScanline ( ) , 0 , columnValues , 0 , columnValues . length ) ; \npixels [ rowCount = rowCount + 1 ] = columnValues ; \n} \nreader . close ( ) ; \n} \n} \n} \n"}
{"6070": "public class DefaultFeatureTiles { \nprivate void addLineString ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , LineString lineString ) { \nList < Point > points = lineString . getPoints ( ) ; \nif ( points . size ( ) >= 2 ) { \npoints = simplifyPoints ( simplifyTolerance , points ) ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni = i + 1 ) { \nPoint point = points . get ( i ) ; \nPoint webMercatorPoint = transform . transform ( point ) ; \nfloat x = TileBoundingBoxUtils . getXPixel ( tileWidth , boundingBox , webMercatorPoint . getX ( ) ) ; \nfloat y = TileBoundingBoxUtils . getYPixel ( tileHeight , boundingBox , webMercatorPoint . getY ( ) ) ; \nif ( i == 0 ) { \npath . moveTo ( x , y ) ; \n} \nelse { \npath . lineTo ( x , y ) ; \n} \n} \n} \n} \n} \n"}
{"6071": "public class DefaultFeatureTiles { \nprivate void addPolygon ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , Polygon polygon ) { \nList < LineString > rings = polygon . getRings ( ) ; \nif ( ! rings . isEmpty ( ) ) { \nLineString polygonLineString = rings . get ( 0 ) ; \nList < Point > polygonPoints = polygonLineString . getPoints ( ) ; \nif ( polygonPoints . size ( ) >= 2 ) { \naddRing ( simplifyTolerance , boundingBox , transform , path , polygonPoints ) ; \nfor ( int i = 1 ; \ni < rings . size ( ) ; \ni = i + 1 ) { \nLineString holeLineString = rings . get ( i ) ; \nList < Point > holePoints = holeLineString . getPoints ( ) ; \nif ( holePoints . size ( ) >= 2 ) { \naddRing ( simplifyTolerance , boundingBox , transform , path , holePoints ) ; \n} \n} \n} \n} \n} \n} \n"}
{"6153": "public class ParallaxContainer { \nprivate void addParallaxView ( View view , int pageIndex ) { \nif ( view instanceof ViewGroup ) { \nViewGroup viewGroup = ( ViewGroup ) view ; \nfor ( int i = 0 , childCount = viewGroup . getChildCount ( ) ; \ni < childCount ; \ni = i + 1 ) { \naddParallaxView ( viewGroup . getChildAt ( i ) , pageIndex ) ; \n} \n} \nParallaxViewTag tag = ( ParallaxViewTag ) view . getTag ( R . id . parallax_view_tag ) ; \nif ( tag != null ) { \ntag . index = pageIndex ; \nparallaxViews . add ( view ) ; \n} \n} \n} \n"}
{"6183": "public class FilterAttachableImpl { \npublic FilterReply getFilterChainDecision ( E event ) { \nfinal Filter < E > [ ] filterArrray = filterList . asTypedArray ( ) ; \nfinal int len = filterArrray . length ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nfinal FilterReply r = filterArrray [ i ] . decide ( event ) ; \nif ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { \nreturn r ; \n} \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6204": "public class CallerData { \npublic static StackTraceElement [ ] extract ( Throwable t , String fqnOfInvokingClass , final int maxDepth , List < String > frameworkPackageList ) { \nif ( t == null ) { \nreturn null ; \n} \nStackTraceElement [ ] steArray = t . getStackTrace ( ) ; \nStackTraceElement [ ] callerDataArray ; \nint found = LINE_NA ; \nfor ( int i = 0 ; \ni < steArray . length ; \ni = i + 1 ) { \nif ( isInFrameworkSpace ( steArray [ i ] . getClassName ( ) , fqnOfInvokingClass , frameworkPackageList ) ) { \nfound = i + 1 ; \n} \nelse { \nif ( found != LINE_NA ) { \nbreak ; \n} \n} \n} \nif ( found == LINE_NA ) { \nreturn EMPTY_CALLER_DATA_ARRAY ; \n} \nint availableDepth = steArray . length - found ; \nint desiredDepth = maxDepth < ( availableDepth ) ? maxDepth : availableDepth ; \ncallerDataArray = new StackTraceElement [ desiredDepth ] ; \nfor ( int i = 0 ; \ni < desiredDepth ; \ni = i + 1 ) { \ncallerDataArray [ i ] = steArray [ found + i ] ; \n} \nreturn callerDataArray ; \n} \n} \n"}
{"6206": "public class BasicStatusManager { \npublic void add ( Status newStatus ) { \nfireStatusAddEvent ( newStatus ) ; \ncount = count + 1 ; \nif ( newStatus . getLevel ( ) > level ) { \nlevel = newStatus . getLevel ( ) ; \n} \nsynchronized ( statusListLock ) { \nif ( statusList . size ( ) < MAX_HEADER_COUNT ) { \nstatusList . add ( newStatus ) ; \n} \nelse { \ntailBuffer . add ( newStatus ) ; \n} \n} \n} \n} \n"}
{"6208": "public class Interpreter { \nList < Action > lookupImplicitAction ( ElementPath elementPath , Attributes attributes , InterpretationContext ec ) { \nint len = implicitActions . size ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nImplicitAction ia = ( ImplicitAction ) implicitActions . get ( i ) ; \nif ( ia . isApplicable ( elementPath , attributes , ec ) ) { \nList < Action > actionList = new ArrayList < Action > ( 1 ) ; \nactionList . add ( ia ) ; \nreturn actionList ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6216": "public class OutputStreamAppender { \npublic void start ( ) { \nint errors = 0 ; \nif ( this . encoder == null ) { \naddStatus ( new ErrorStatus ( \"No encoder set for the appender named \\\"\" + name + \"\\\".\" , this ) ) ; \nerrors = errors + 1 ; \n} \nif ( this . outputStream == null ) { \naddStatus ( new ErrorStatus ( \"No output stream set for the appender named \\\"\" + name + \"\\\".\" , this ) ) ; \nerrors = errors + 1 ; \n} \nif ( errors == 0 ) { \nsuper . start ( ) ; \n} \n} \n} \n"}
{"6231": "public class Logger { \nprivate synchronized void handleParentLevelChange ( int newParentLevelInt ) { \nif ( level == null ) { \neffectiveLevelInt = newParentLevelInt ; \nif ( childrenList != null ) { \nint len = childrenList . size ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nLogger child = ( Logger ) childrenList . get ( i ) ; \nchild . handleParentLevelChange ( newParentLevelInt ) ; \n} \n} \n} \n} \n} \n"}
{"6254": "public class SMTPAppenderBase { \nprotected void append ( E eventObject ) { \nif ( ! checkEntryConditions ( ) ) { \nreturn ; \n} \nString key = discriminator . getDiscriminatingValue ( eventObject ) ; \nlong now = System . currentTimeMillis ( ) ; \nfinal CyclicBuffer < E > cb = cbTracker . getOrCreate ( key , now ) ; \nsubAppend ( cb , eventObject ) ; \ntry { \nif ( eventEvaluator . evaluate ( eventObject ) ) { \nCyclicBuffer < E > cbClone = new CyclicBuffer < E > ( cb ) ; \ncb . clear ( ) ; \nif ( asynchronousSending ) { \nSenderRunnable senderRunnable = new SenderRunnable ( cbClone , eventObject ) ; \ncontext . getScheduledExecutorService ( ) . execute ( senderRunnable ) ; \n} \nelse { \nsendBuffer ( cbClone , eventObject ) ; \n} \n} \n} \ncatch ( EvaluationException ex ) { \nerrorCount = errorCount + 1 ; \nif ( errorCount < CoreConstants . MAX_ERROR_COUNT ) { \naddError ( \"SMTPAppender's EventEvaluator threw an Exception-\" , ex ) ; \n} \n} \nif ( eventMarksEndOfLife ( eventObject ) ) { \ncbTracker . endOfLife ( key ) ; \n} \ncbTracker . removeStaleComponents ( now ) ; \nif ( lastTrackerStatusPrint + delayBetweenStatusMessages < now ) { \naddInfo ( \"SMTPAppender [\" + name + \"] is tracking [\" + cbTracker . getComponentCount ( ) + \"] buffers\" ) ; \nlastTrackerStatusPrint = now ; \nif ( delayBetweenStatusMessages < MAX_DELAY_BETWEEN_STATUS_MESSAGES ) { \ndelayBetweenStatusMessages *= 4 ; \n} \n} \n} \n} \n"}
{"6269": "public class StatusUtil { \npublic long timeOfLastReset ( ) { \nList < Status > statusList = sm . getCopyOfStatusList ( ) ; \nif ( statusList == null ) return - 1 ; \nint len = statusList . size ( ) ; \nfor ( int i = len - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nStatus s = statusList . get ( i ) ; \nif ( CoreConstants . RESET_MSG_PREFIX . equals ( s . getMessage ( ) ) ) { \nreturn s . getDate ( ) ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"6270": "public class HTMLLayoutBase { \n@ Override public void start ( ) { \nint errorCount = 0 ; \ntry { \nParser < E > p = new Parser < E > ( pattern ) ; \np . setContext ( getContext ( ) ) ; \nNode t = p . parse ( ) ; \nthis . head = p . compile ( t , getEffectiveConverterMap ( ) ) ; \nConverterUtil . startConverters ( this . head ) ; \n} \ncatch ( ScanException ex ) { \naddError ( \"Incorrect pattern found\" , ex ) ; \nerrorCount = errorCount + 1 ; \n} \nif ( errorCount == 0 ) { \nsuper . started = true ; \n} \n} \n} \n"}
{"6281": "public class TurboFilterList { \npublic FilterReply getTurboFilterChainDecision ( final Marker marker , final Logger logger , final Level level , final String format , final Object [ ] params , final Throwable t ) { \nfinal int size = size ( ) ; \nif ( size == 1 ) { \ntry { \nTurboFilter tf = get ( 0 ) ; \nreturn tf . decide ( marker , logger , level , format , params , t ) ; \n} \ncatch ( IndexOutOfBoundsException iobe ) { \nreturn FilterReply . NEUTRAL ; \n} \n} \nObject [ ] tfa = toArray ( ) ; \nfinal int len = tfa . length ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nfinal TurboFilter tf = ( TurboFilter ) tfa [ i ] ; \nfinal FilterReply r = tf . decide ( marker , logger , level , format , params , t ) ; \nif ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { \nreturn r ; \n} \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6297": "public class ElementSelector { \npublic int getPrefixMatchLength ( ElementPath p ) { \nif ( p == null ) { \nreturn 0 ; \n} \nint lSize = this . partList . size ( ) ; \nint rSize = p . partList . size ( ) ; \nif ( ( lSize == 0 ) || ( rSize == 0 ) ) { \nreturn 0 ; \n} \nint minLen = ( lSize <= rSize ) ? lSize : rSize ; \nint match = 0 ; \nfor ( int i = 0 ; \ni < minLen ; \ni = i + 1 ) { \nString l = this . partList . get ( i ) ; \nString r = p . partList . get ( i ) ; \nif ( equalityCheck ( l , r ) ) { \nmatch = match + 1 ; \n} \nelse { \nbreak ; \n} \n} \nreturn match ; \n} \n} \n"}
{"6322": "public class VersionUtils { \npublic static int versionCompare ( String firstVersionString , String secondVersionString ) { \nString [ ] firstVersion = parseVersionString ( firstVersionString ) ; \nString [ ] secondVersion = parseVersionString ( secondVersionString ) ; \nint i = 0 ; \nwhile ( i < firstVersion . length && i < secondVersion . length && firstVersion [ i ] . equals ( secondVersion [ i ] ) ) { \ni = i + 1 ; \n} \nif ( i < firstVersion . length && i < secondVersion . length ) { \nint diff = Integer . valueOf ( firstVersion [ i ] ) . compareTo ( Integer . valueOf ( secondVersion [ i ] ) ) ; \nreturn Integer . signum ( diff ) ; \n} \nelse { \nreturn Integer . signum ( firstVersion . length - secondVersion . length ) ; \n} \n} \n} \n"}
{"6333": "public class JsonProtocol { \nprivate void writeJsonString ( byte [ ] b ) throws IOException { \ncontext . write ( ) ; \ntransport . write ( QUOTE ) ; \nint len = b . length ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nif ( ( b [ i ] & 0x00FF ) >= 0x30 ) { \nif ( b [ i ] == BACKSLASH [ 0 ] ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( BACKSLASH ) ; \n} \nelse { \ntransport . write ( b , i , 1 ) ; \n} \n} \nelse { \ntmpbuf [ 0 ] = JSON_CHAR_TABLE [ b [ i ] ] ; \nif ( tmpbuf [ 0 ] == 1 ) { \ntransport . write ( b , i , 1 ) ; \n} \nelse if ( tmpbuf [ 0 ] > 1 ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( tmpbuf , 0 , 1 ) ; \n} \nelse { \ntransport . write ( ESCSEQ ) ; \ntmpbuf [ 0 ] = hexChar ( ( byte ) ( b [ i ] >> 4 ) ) ; \ntmpbuf [ 1 ] = hexChar ( b [ i ] ) ; \ntransport . write ( tmpbuf , 0 , 2 ) ; \n} \n} \n} \ntransport . write ( QUOTE ) ; \n} \n} \n"}
{"6352": "public class KieNavigatorView { \nprotected void startThread ( ) { \nif ( animationActive ) return ; \nstopAnimation = false ; \nfinal Display display = treeViewer == null ? Display . getDefault ( ) : treeViewer . getControl ( ) . getDisplay ( ) ; \nfinal int SLEEP = 200 ; \nfinal Runnable [ ] animator = new Runnable [ 1 ] ; \nanimator [ 0 ] = new Runnable ( ) { \npublic void run ( ) { \nif ( ! stopAnimation ) { \ntry { \nint size = 0 ; \nString [ ] servers ; \nsynchronized ( starting ) { \nsize = starting . size ( ) ; \nservers = new String [ size ] ; \nstarting . toArray ( servers ) ; \n} \nfor ( int i = 0 ; \ni < size ; \ni = i + 1 ) { \nIServer server = ServerCore . findServer ( servers [ i ] ) ; \nif ( server != null ) { \ntreeViewer . update ( server , new String [ ] { \n\"ICON\" } \n) ; \n} \n} \n} \ncatch ( Exception e ) { \n} \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n} \n; \nDisplay . getDefault ( ) . asyncExec ( new Runnable ( ) { \npublic void run ( ) { \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n) ; \n} \n} \n"}
{"6358": "public class ConditionTerm { \npublic boolean matches ( ConditionTerm conditionTerm ) { \nint numberOfItemsToMatch = 0 ; \nboolean match = true ; \nEnumeration factors = getConditionFactors ( ) ; \nwhile ( match && factors . hasMoreElements ( ) ) { \nConditionFactor factor = ( ConditionFactor ) factors . nextElement ( ) ; \nif ( factor . not ( ) ) { \nmatch = ! conditionTerm . contains ( factor ) ; \n} \nelse { \nmatch = conditionTerm . contains ( factor ) ; \nnumberOfItemsToMatch = numberOfItemsToMatch + 1 ; \n} \n} \nmatch = match && numberOfItemsToMatch == conditionTerm . numberOfFactors ( ) ; \nreturn match ; \n} \n} \n"}
{"6370": "public class DebugUtil { \npublic static IJavaStackFrame getStackFrame ( IValue value ) throws CoreException { \nIStatusHandler handler = getStackFrameProvider ( ) ; \nif ( handler != null ) { \nIJavaStackFrame stackFrame = ( IJavaStackFrame ) handler . handleStatus ( fgNeedStackFrame , value ) ; \nif ( stackFrame != null ) { \nreturn stackFrame ; \n} \n} \nIDebugTarget target = value . getDebugTarget ( ) ; \nIJavaDebugTarget javaTarget = ( IJavaDebugTarget ) target . getAdapter ( IJavaDebugTarget . class ) ; \nif ( javaTarget != null ) { \nIThread [ ] threads = javaTarget . getThreads ( ) ; \nfor ( int i = 0 ; \ni < threads . length ; \ni = i + 1 ) { \nIThread thread = threads [ i ] ; \nif ( thread . isSuspended ( ) ) { \nreturn ( IJavaStackFrame ) thread . getTopStackFrame ( ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6373": "public class ElementEditor { \npublic static Node cloneNode ( Document document , Node node ) { \nNode nodeClone = null ; \nswitch ( node . getNodeType ( ) ) { \ncase Node . ELEMENT_NODE : { \nnodeClone = document . createElement ( ( ( Element ) node ) . getTagName ( ) ) ; \nNamedNodeMap namedNodeMap = node . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < namedNodeMap . getLength ( ) ; \ni = i + 1 ) { \nAttr attr = ( Attr ) namedNodeMap . item ( i ) ; \nAttr attrClone = document . createAttribute ( attr . getName ( ) ) ; \nattrClone . setValue ( attr . getValue ( ) ) ; \n( ( Element ) nodeClone ) . setAttributeNode ( attrClone ) ; \n} \n} \nbreak ; \ncase Node . TEXT_NODE : nodeClone = document . createTextNode ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . CDATA_SECTION_NODE : nodeClone = document . createCDATASection ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . ENTITY_REFERENCE_NODE : nodeClone = document . createEntityReference ( node . getNodeName ( ) ) ; \nbreak ; \ncase Node . PROCESSING_INSTRUCTION_NODE : nodeClone = document . createProcessingInstruction ( ( ( ProcessingInstruction ) node ) . getTarget ( ) , ( ( ProcessingInstruction ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . COMMENT_NODE : nodeClone = document . createComment ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . DOCUMENT_FRAGMENT_NODE : nodeClone = document . createDocumentFragment ( ) ; \nbreak ; \ncase Node . DOCUMENT_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . NOTATION_NODE : case Node . ATTRIBUTE_NODE : case Node . ENTITY_NODE : Assert . isTrue ( false , Policy . bind ( \"assert.notSupported\" ) ) ; \nbreak ; \ndefault : Assert . isTrue ( false , Policy . bind ( \"assert.unknownNodeType\" ) ) ; \n} \nreturn nodeClone ; \n} \n} \n"}
{"6382": "public class GraphicalVertex { \npublic static String dumpConstraints ( final Constraint [ ] constraints ) { \nif ( constraints == null ) { \nreturn null ; \n} \nfinal StringBuffer buffer = new StringBuffer ( ) ; \nfor ( int i = 0 , length = constraints . length ; \ni < length ; \ni = i + 1 ) { \nbuffer . append ( constraints [ i ] . toString ( ) + \"<br>\" ) ; \n} \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"6391": "public class DateTime { \npublic void setDateTime ( String date ) { \nString [ ] patterns = { \nRFC_1123_PATTERN , ISO_8601_UTC_PATTERN , ISO_8601_UTC_MILLIS_PATTERN , ISO_8601_PATTERN , ISO_8601_MILLIS_PATTERN , RFC_850_PATTERN , ASCTIME_PATTERN } \n; \nfor ( int i = 0 ; \ni < patterns . length ; \ni = i + 1 ) { \nif ( setDateTime ( date , patterns [ i ] ) ) break ; \n} \n} \n} \n"}
{"6396": "public class FieldEditorPropertyPage { \nprotected void adjustGridLayout ( ) { \nint numColumns = calcNumberOfColumns ( ) ; \n( ( GridLayout ) fieldEditorParent . getLayout ( ) ) . numColumns = numColumns ; \nif ( fields != null ) { \nfor ( int i = 0 ; \ni < fields . size ( ) ; \ni = i + 1 ) { \nFieldEditor fieldEditor = fields . get ( i ) ; \nfieldEditor . fillIntoGrid ( fieldEditorParent , numColumns ) ; \n} \n} \n} \n} \n"}
{"6400": "public class JsonPreferenceStore { \npublic void firePropertyChangeEvent ( Object source , String name , Object oldValue , Object newValue ) { \nPropertyChangeEvent event = new PropertyChangeEvent ( source , name , oldValue , newValue ) ; \nObject [ ] listeners = fListeners . getListeners ( ) ; \nfor ( int i = 0 ; \ni < listeners . length ; \ni = i + 1 ) ( ( IPropertyChangeListener ) listeners [ i ] ) . propertyChange ( event ) ; \n} \n} \n"}
{"6447": "public class ReteooLayoutFactory { \npublic static RowList calculateReteRows ( BaseVertex root ) { \nRowList rowList = new RowList ( ) ; \nrowList . add ( 0 , root ) ; \nint curRow = 0 ; \nfinal Set < BaseVertex > seenVertices = new HashSet < BaseVertex > ( ) ; \nseenVertices . add ( root ) ; \nwhile ( curRow < rowList . getDepth ( ) ) { \nfinal List < BaseVertex > rowVertices = rowList . get ( curRow ) . getVertices ( ) ; \nfor ( final Iterator < BaseVertex > rowNodeIter = rowVertices . iterator ( ) ; \nrowNodeIter . hasNext ( ) ; \n) { \nfinal BaseVertex rowNode = rowNodeIter . next ( ) ; \nfinal List < Connection > edges = rowNode . getSourceConnections ( ) ; \nfor ( final Iterator < Connection > edgeIter = edges . iterator ( ) ; \nedgeIter . hasNext ( ) ; \n) { \nfinal Connection edge = edgeIter . next ( ) ; \nfinal BaseVertex destNode = edge . getOpposite ( rowNode ) ; \nif ( ! seenVertices . contains ( destNode ) ) { \nrowList . add ( curRow + 1 , destNode ) ; \nseenVertices . add ( destNode ) ; \n} \n} \nseenVertices . add ( rowNode ) ; \n} \ncurRow = curRow + 1 ; \n} \nrowList . optimize ( ) ; \nreturn rowList ; \n} \n} \n"}
{"6452": "public class RowList { \npublic void add ( final int depth , final BaseVertex vertex ) { \nif ( this . rows . size ( ) < ( depth + 1 ) ) { \nfinal int addRows = depth - this . rows . size ( ) + 1 ; \nfor ( int i = 0 ; \ni < addRows ; \ni = i + 1 ) { \nthis . rows . add ( new Row ( ( depth - addRows ) + i ) ) ; \n} \n} \n( ( Row ) this . rows . get ( depth ) ) . add ( vertex ) ; \n} \n} \n"}
{"6453": "public class RowList { \npublic int getRow ( final BaseVertex vertex ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \ni < numRows ; \ni = i + 1 ) { \nif ( ( ( Row ) this . rows . get ( i ) ) . contains ( vertex ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"6455": "public class RowList { \npublic void dump ( ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \ni < numRows ; \ni = i + 1 ) { \nSystem . err . println ( i + \": \" + get ( i ) . getVertices ( ) ) ; \n} \n} \n} \n"}
{"6456": "public class RowList { \npublic void optimize ( ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \ni < numRows ; \ni = i + 1 ) { \nget ( i ) . optimize ( ) ; \n} \n} \n} \n"}
{"6486": "public class HexConverter { \npublic static String toHex ( byte [ ] arr ) { \nStringBuffer buf = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < arr . length ; \ni = i + 1 ) { \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 4 ) & 0x0f ) ) ; \nbuf . append ( Integer . toHexString ( arr [ i ] & 0x0f ) ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6487": "public class HexConverter { \npublic static String toHex ( int [ ] arr ) { \nStringBuffer buf = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < arr . length ; \ni = i + 1 ) { \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 28 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 24 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 20 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 16 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 12 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 8 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 4 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] ) & 0x0000000f ) ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6491": "public class CompletionUtil { \npublic static String stripLastWord ( String prefix ) { \nif ( \"\" . equals ( prefix ) ) { \nreturn prefix ; \n} \nif ( prefix . charAt ( prefix . length ( ) - 1 ) == ' ' ) { \nreturn \"\" ; \n} \nelse { \nchar [ ] c = prefix . toCharArray ( ) ; \nint start = 0 ; \nfor ( int i = c . length - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nif ( Character . isWhitespace ( c [ i ] ) || c [ i ] == '(' || c [ i ] == ':' || c [ i ] == ';' || c [ i ] == '=' || c [ i ] == '<' || c [ i ] == '>' || c [ i ] == '.' || c [ i ] == '{' || c [ i ] == '}' ) { \nstart = i + 1 ; \nbreak ; \n} \n} \nprefix = prefix . substring ( start , prefix . length ( ) ) ; \nreturn prefix ; \n} \n} \n} \n"}
{"6496": "public class Parser { \npublic void skipWhiteSpace ( ) { \nwhile ( pos < s . length ( ) && Character . isWhitespace ( s . charAt ( pos ) ) ) pos = pos + 1 ; \n} \n} \n"}
{"6511": "public class DSLTree { \npublic void addTokens ( String [ ] tokens , Node rootNode ) { \nNode thenode = rootNode ; \nfor ( int i = 0 ; \ni < tokens . length ; \ni = i + 1 ) { \nNode newnode = thenode . addToken ( tokens [ i ] ) ; \nthenode = newnode ; \n} \n} \n} \n"}
{"6517": "public class DSLTree { \nprotected void printTabs ( int count ) { \nfor ( int idx = 0 ; \nidx < count ; \nidx = idx + 1 ) { \nSystem . out . print ( tab ) ; \n} \n} \n} \n"}
{"6538": "public class EntityTag { \npublic static EntityTag generateEntityTag ( ) { \nString xx = basetime + \":\" + Integer . toHexString ( Thread . currentThread ( ) . hashCode ( ) ) ; \nbcnt = bcnt + 1 ; \nxx += \":\" + bcnt ; \nreturn new EntityTag ( xx ) ; \n} \n} \n"}
{"6545": "public class MultiValuePasswordCallback { \npublic void clearPassword ( ) { \nfor ( char pw [ ] : this . secrets ) { \nfor ( int i = 0 ; \ni < pw . length ; \ni = i + 1 ) { \npw [ i ] = 0 ; \n} \n} \nthis . secrets = new ArrayList < char [ ] > ( ) ; \n} \n} \n"}
{"6556": "public class OgnlRuntime { \npublic static final boolean isMoreSpecific ( Class [ ] classes1 , Class [ ] classes2 ) { \nfor ( int index = 0 , count = classes1 . length ; \nindex < count ; \nindex = index + 1 ) { \nClass c1 = classes1 [ index ] , c2 = classes2 [ index ] ; \nif ( c1 == c2 ) continue ; \nelse if ( c1 . isPrimitive ( ) ) return true ; \nelse if ( c1 . isAssignableFrom ( c2 ) ) return false ; \nelse if ( c2 . isAssignableFrom ( c1 ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"6557": "public class OgnlRuntime { \npublic static Method getAppropriateMethod ( OgnlContext context , Object source , Object target , String propertyName , String methodName , List methods , Object [ ] args , Object [ ] actualArgs ) { \nMethod result = null ; \nif ( methods != null ) { \nClass typeClass = target != null ? target . getClass ( ) : null ; \nif ( typeClass == null && source != null && Class . class . isInstance ( source ) ) { \ntypeClass = ( Class ) source ; \n} \nClass [ ] argClasses = getArgClasses ( args ) ; \nMatchingMethod mm = findBestMethod ( methods , typeClass , methodName , argClasses ) ; \nif ( mm != null ) { \nresult = mm . mMethod ; \nClass [ ] mParameterTypes = mm . mParameterTypes ; \nSystem . arraycopy ( args , 0 , actualArgs , 0 , args . length ) ; \nfor ( int j = 0 ; \nj < mParameterTypes . length ; \nj = j + 1 ) { \nClass type = mParameterTypes [ j ] ; \nif ( mm . report . conversionNeeded [ j ] || ( type . isPrimitive ( ) && ( actualArgs [ j ] == null ) ) ) { \nactualArgs [ j ] = getConvertedType ( context , source , result , propertyName , args [ j ] , type ) ; \n} \n} \n} \n} \nif ( result == null ) { \nresult = getConvertedMethodAndArgs ( context , target , propertyName , methods , args , actualArgs ) ; \n} \nreturn result ; \n} \n} \n"}
{"6559": "public class OgnlRuntime { \npublic static Map getPropertyDescriptors ( Class targetClass ) throws IntrospectionException , OgnlException { \nMap result ; \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { \nsynchronized ( _propertyDescriptorCache ) { \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { \nPropertyDescriptor [ ] pda = Introspector . getBeanInfo ( targetClass ) . getPropertyDescriptors ( ) ; \nresult = new HashMap ( 101 ) ; \nfor ( int i = 0 , icount = pda . length ; \ni < icount ; \ni = i + 1 ) { \nif ( pda [ i ] . getReadMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getReadMethod ( ) ) ) { \npda [ i ] . setReadMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getReadMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , true ) ) ; \n} \nif ( pda [ i ] . getWriteMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getWriteMethod ( ) ) ) { \npda [ i ] . setWriteMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getWriteMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , false ) ) ; \n} \nresult . put ( pda [ i ] . getName ( ) , pda [ i ] ) ; \n} \nfindObjectIndexedPropertyDescriptors ( targetClass , result ) ; \n_propertyDescriptorCache . put ( targetClass , result ) ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"6560": "public class OgnlRuntime { \npublic static PropertyDescriptor getPropertyDescriptorFromArray ( Class targetClass , String name ) throws IntrospectionException { \nPropertyDescriptor result = null ; \nPropertyDescriptor [ ] pda = getPropertyDescriptorsArray ( targetClass ) ; \nfor ( int i = 0 , icount = pda . length ; \n( result == null ) && ( i < icount ) ; \ni = i + 1 ) { \nif ( pda [ i ] . getName ( ) . compareTo ( name ) == 0 ) { \nresult = pda [ i ] ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6562": "public class JavaCharStream { \npublic char readChar ( ) throws java . io . IOException { \nif ( inBuf > 0 ) { \ninBuf = inBuf - 1 ; \nif ( bufpos = bufpos + 1 == bufsize ) bufpos = 0 ; \nreturn buffer [ bufpos ] ; \n} \nchar c ; \nif ( bufpos = bufpos + 1 == available ) AdjustBuffSize ( ) ; \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) == '\\\\' ) { \nUpdateLineColumn ( c ) ; \nint backSlashCnt = 1 ; \nfor ( ; \n; \n) { \nif ( bufpos = bufpos + 1 == available ) AdjustBuffSize ( ) ; \ntry { \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) != '\\\\' ) { \nUpdateLineColumn ( c ) ; \nif ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { \nif ( bufpos = bufpos - 1 < 0 ) bufpos = bufsize - 1 ; \nbreak ; \n} \nbackup ( backSlashCnt ) ; \nreturn '\\\\' ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( backSlashCnt > 1 ) backup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \nUpdateLineColumn ( c ) ; \nbackSlashCnt = backSlashCnt + 1 ; \n} \ntry { \nwhile ( ( c = ReadByte ( ) ) == 'u' ) column = column + 1 ; \nbuffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ReadByte ( ) ) << 8 | hexval ( ReadByte ( ) ) << 4 | hexval ( ReadByte ( ) ) ) ; \ncolumn += 4 ; \n} \ncatch ( java . io . IOException e ) { \nthrow new Error ( \"Invalid escape character at line \" + line + \" column \" + column + \".\" ) ; \n} \nif ( backSlashCnt == 1 ) return c ; \nelse { \nbackup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \n} \nelse { \nUpdateLineColumn ( c ) ; \nreturn c ; \n} \n} \n} \n"}
{"6579": "public class SimpleNode { \nprotected void flattenTree ( ) { \nboolean shouldFlatten = false ; \nint newSize = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \ni = i + 1 ) if ( _children [ i ] . getClass ( ) == getClass ( ) ) { \nshouldFlatten = true ; \nnewSize += _children [ i ] . jjtGetNumChildren ( ) ; \n} \nelse newSize = newSize + 1 ; \nif ( shouldFlatten ) { \nNode [ ] newChildren = new Node [ newSize ] ; \nint j = 0 ; \nfor ( int i = 0 ; \ni < _children . length ; \ni = i + 1 ) { \nNode c = _children [ i ] ; \nif ( c . getClass ( ) == getClass ( ) ) { \nfor ( int k = 0 ; \nk < c . jjtGetNumChildren ( ) ; \nk = k + 1 ) newChildren [ j = j + 1 ] = c . jjtGetChild ( k ) ; \n} \nelse newChildren [ j = j + 1 ] = c ; \n} \nif ( j != newSize ) throw new Error ( \"Assertion error: \" + j + \" != \" + newSize ) ; \n_children = newChildren ; \n} \n} \n} \n"}
{"6581": "public class OgnlParserTokenManager { \nprivate char escapeChar ( ) { \nint ofs = image . length ( ) - 1 ; \nswitch ( image . charAt ( ofs ) ) { \ncase 'n' : return '\\n' ; \ncase 'r' : return '\\r' ; \ncase 't' : return '\\t' ; \ncase 'b' : return '\\b' ; \ncase 'f' : return '\\f' ; \ncase '\\\\' : return '\\\\' ; \ncase '\\'' : return '\\'' ; \ncase '\\\"' : return '\\\"' ; \n} \nwhile ( image . charAt ( ofs = ofs - 1 ) != '\\\\' ) { \n} \nint value = 0 ; \nwhile ( ofs = ofs + 1 < image . length ( ) ) value = ( value << 3 ) | ( image . charAt ( ofs ) - '0' ) ; \nreturn ( char ) value ; \n} \n} \n"}
{"6590": "public class Reloader { \n@ Override public synchronized Object reload ( ) { \nObject result = null ; \ntry { \nboolean reloadRequired = buildLink . build ( ) ; \nif ( reloadRequired ) { \nint version = classLoaderVersion = classLoaderVersion + 1 ; \nString name = \"ReloadableClassLoader(v\" + version + \")\" ; \ncurrentApplicationClassLoader = new DelegatedResourcesClassLoader ( name , toUrls ( outputDirectories ) , baseLoader ) ; \nresult = currentApplicationClassLoader ; \n} \n} \ncatch ( MalformedURLException e ) { \nthrow new UnexpectedException ( \"Unexpected reloader exception\" , e ) ; \n} \ncatch ( Play2BuildFailure e ) { \nresult = new CompilationException ( e . getMessage ( ) , e . line ( ) , e . position ( ) , e . source ( ) != null ? e . source ( ) . getAbsolutePath ( ) : null , e . input ( ) ) ; \n} \ncatch ( Play2BuildError e ) { \nresult = new UnexpectedException ( e . getMessage ( ) , e . getCause ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"6598": "public class DirectoryChooserFragment { \nprivate void changeDirectory ( final File dir ) { \nif ( dir == null ) { \ndebug ( \"Could not change folder: dir was null\" ) ; \n} \nelse if ( ! dir . isDirectory ( ) ) { \ndebug ( \"Could not change folder: dir is no directory\" ) ; \n} \nelse { \nfinal File [ ] contents = dir . listFiles ( ) ; \nif ( contents != null ) { \nint numDirectories = 0 ; \nfor ( final File f : contents ) { \nif ( f . isDirectory ( ) ) { \nnumDirectories = numDirectories + 1 ; \n} \n} \nmFilesInDir = new File [ numDirectories ] ; \nmFilenames . clear ( ) ; \nfor ( int i = 0 , counter = 0 ; \ni < numDirectories ; \ncounter = counter + 1 ) { \nif ( contents [ counter ] . isDirectory ( ) ) { \nmFilesInDir [ i ] = contents [ counter ] ; \nmFilenames . add ( contents [ counter ] . getName ( ) ) ; \ni = i + 1 ; \n} \n} \nArrays . sort ( mFilesInDir ) ; \nCollections . sort ( mFilenames ) ; \nmSelectedDir = dir ; \nmTxtvSelectedFolder . setText ( dir . getAbsolutePath ( ) ) ; \nmListDirectoriesAdapter . notifyDataSetChanged ( ) ; \nmFileObserver = createFileObserver ( dir . getAbsolutePath ( ) ) ; \nmFileObserver . startWatching ( ) ; \ndebug ( \"Changed directory to %s\" , dir . getAbsolutePath ( ) ) ; \n} \nelse { \ndebug ( \"Could not change folder: contents of dir were null\" ) ; \n} \n} \nrefreshButtonState ( ) ; \n} \n} \n"}
{"6624": "public class ByteArrayOutputStream { \nprivate void needNewBuffer ( int newcount ) { \nif ( currentBufferIndex < buffers . size ( ) - 1 ) { \nfilledBufferSum += currentBuffer . length ; \ncurrentBufferIndex = currentBufferIndex + 1 ; \ncurrentBuffer = buffers . get ( currentBufferIndex ) ; \n} \nelse { \nint newBufferSize ; \nif ( currentBuffer == null ) { \nnewBufferSize = newcount ; \nfilledBufferSum = 0 ; \n} \nelse { \nnewBufferSize = Math . max ( currentBuffer . length << 1 , newcount - filledBufferSum ) ; \nfilledBufferSum += currentBuffer . length ; \n} \ncurrentBufferIndex = currentBufferIndex + 1 ; \ncurrentBuffer = new byte [ newBufferSize ] ; \nbuffers . add ( currentBuffer ) ; \n} \n} \n} \n"}
{"6626": "public class ByteArrayOutputStream { \n@ Override public synchronized void write ( int b ) { \nint inBufferPos = count - filledBufferSum ; \nif ( inBufferPos == currentBuffer . length ) { \nneedNewBuffer ( count + 1 ) ; \ninBufferPos = 0 ; \n} \ncurrentBuffer [ inBufferPos ] = ( byte ) b ; \ncount = count + 1 ; \n} \n} \n"}
{"6630": "public class HorizontalRTToolbar { \n@ Override public void setFontSize ( int size ) { \nif ( mFontSize != null ) { \nif ( size <= 0 ) { \nmFontSizeAdapter . updateSpinnerTitle ( \"\" ) ; \nmFontSizeAdapter . setSelectedItem ( 0 ) ; \nmFontSize . setSelection ( 0 ) ; \n} \nelse { \nsize = Helper . convertSpToPx ( size ) ; \nmFontSizeAdapter . updateSpinnerTitle ( Integer . toString ( size ) ) ; \nfor ( int pos = 0 ; \npos < mFontSizeAdapter . getCount ( ) ; \npos = pos + 1 ) { \nFontSizeSpinnerItem item = mFontSizeAdapter . getItem ( pos ) ; \nif ( size == item . getFontSize ( ) ) { \nmFontSizeAdapter . setSelectedItem ( pos ) ; \nmFontSize . setSelection ( pos ) ; \nbreak ; \n} \n} \n} \n} \n} \n} \n"}
{"6632": "public class CropImageView { \nprivate void recomputeFocus ( MotionEvent event ) { \nfor ( int i = 0 ; \ni < mHighlightViews . size ( ) ; \ni = i + 1 ) { \nHighlightView hv = mHighlightViews . get ( i ) ; \nhv . setFocus ( false ) ; \nhv . invalidate ( ) ; \n} \nfor ( int i = 0 ; \ni < mHighlightViews . size ( ) ; \ni = i + 1 ) { \nHighlightView hv = mHighlightViews . get ( i ) ; \nint edge = hv . getHit ( event . getX ( ) , event . getY ( ) ) ; \nif ( edge != HighlightView . GROW_NONE ) { \nif ( ! hv . hasFocus ( ) ) { \nhv . setFocus ( true ) ; \nhv . invalidate ( ) ; \n} \nbreak ; \n} \n} \ninvalidate ( ) ; \n} \n} \n"}
{"6636": "public class RegexValidator { \npublic String validate ( String value ) { \nif ( value == null ) { \nreturn null ; \n} \nfor ( int i = 0 ; \ni < patterns . length ; \ni = i + 1 ) { \nMatcher matcher = patterns [ i ] . matcher ( value ) ; \nif ( matcher . matches ( ) ) { \nint count = matcher . groupCount ( ) ; \nif ( count == 1 ) { \nreturn matcher . group ( 1 ) ; \n} \nStringBuffer buffer = new StringBuffer ( ) ; \nfor ( int j = 0 ; \nj < count ; \nj = j + 1 ) { \nString component = matcher . group ( j + 1 ) ; \nif ( component != null ) { \nbuffer . append ( component ) ; \n} \n} \nreturn buffer . toString ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6659": "public class Parser { \nprivate String expandEntities ( String src ) { \nint refStart = - 1 ; \nint len = src . length ( ) ; \nchar [ ] dst = new char [ len ] ; \nint dstlen = 0 ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nchar ch = src . charAt ( i ) ; \ndst [ dstlen = dstlen + 1 ] = ch ; \nif ( ch == '&' && refStart == - 1 ) { \nrefStart = dstlen ; \n} \nelse if ( refStart == - 1 ) { \n} \nelse if ( Character . isLetter ( ch ) || Character . isDigit ( ch ) || ch == '#' ) { \n} \nelse if ( ch == ';' ) { \nint ent = lookupEntity ( dst , refStart , dstlen - refStart - 1 ) ; \nif ( ent > 0xFFFF ) { \nent -= 0x10000 ; \ndst [ refStart - 1 ] = ( char ) ( ( ent >> 10 ) + 0xD800 ) ; \ndst [ refStart ] = ( char ) ( ( ent & 0x3FF ) + 0xDC00 ) ; \ndstlen = refStart + 1 ; \n} \nelse if ( ent != 0 ) { \ndst [ refStart - 1 ] = ( char ) ent ; \ndstlen = refStart ; \n} \nrefStart = - 1 ; \n} \nelse { \nrefStart = - 1 ; \n} \n} \nreturn new String ( dst , 0 , dstlen ) ; \n} \n} \n"}
{"6662": "public class Parser { \nprivate void pop ( ) throws SAXException { \nif ( theStack == null ) return ; \nString name = theStack . name ( ) ; \nString localName = theStack . localName ( ) ; \nString namespace = theStack . namespace ( ) ; \nString prefix = prefixOf ( name ) ; \nif ( ! namespaces ) namespace = localName = \"\" ; \ntheContentHandler . endElement ( namespace , localName , name ) ; \nif ( foreign ( prefix , namespace ) ) { \ntheContentHandler . endPrefixMapping ( prefix ) ; \n} \nAttributes atts = theStack . atts ( ) ; \nfor ( int i = atts . getLength ( ) - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nString attNamespace = atts . getURI ( i ) ; \nString attPrefix = prefixOf ( atts . getQName ( i ) ) ; \nif ( foreign ( attPrefix , attNamespace ) ) { \ntheContentHandler . endPrefixMapping ( attPrefix ) ; \n} \n} \ntheStack = theStack . next ( ) ; \n} \n} \n"}
{"6667": "public class Parser { \nprivate static String [ ] split ( String val ) throws IllegalArgumentException { \nval = val . trim ( ) ; \nif ( val . length ( ) == 0 ) { \nreturn new String [ 0 ] ; \n} \nelse { \nArrayList < String > l = new ArrayList < String > ( ) ; \nint s = 0 ; \nint e = 0 ; \nboolean sq = false ; \nboolean dq = false ; \nchar lastc = 0 ; \nint len = val . length ( ) ; \nfor ( e = 0 ; \ne < len ; \ne = e + 1 ) { \nchar c = val . charAt ( e ) ; \nif ( ! dq && c == '\\'' && lastc != '\\\\' ) { \nsq = ! sq ; \nif ( s < 0 ) s = e ; \n} \nelse if ( ! sq && c == '\\\"' && lastc != '\\\\' ) { \ndq = ! dq ; \nif ( s < 0 ) s = e ; \n} \nelse if ( ! sq && ! dq ) { \nif ( Character . isWhitespace ( c ) ) { \nif ( s >= 0 ) l . add ( val . substring ( s , e ) ) ; \ns = - 1 ; \n} \nelse if ( s < 0 && c != ' ' ) { \ns = e ; \n} \n} \nlastc = c ; \n} \nl . add ( val . substring ( s , e ) ) ; \nreturn ( String [ ] ) l . toArray ( new String [ 0 ] ) ; \n} \n} \n} \n"}
{"6669": "public class Parser { \nprivate String makeName ( char [ ] buff , int offset , int length ) { \nStringBuffer dst = new StringBuffer ( length + 2 ) ; \nboolean seenColon = false ; \nboolean start = true ; \nfor ( ; \nlength = length - 1 > 0 ; \noffset = offset + 1 ) { \nchar ch = buff [ offset ] ; \nif ( Character . isLetter ( ch ) || ch == '_' ) { \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( Character . isDigit ( ch ) || ch == '-' || ch == '.' ) { \nif ( start ) dst . append ( '_' ) ; \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( ch == ':' && ! seenColon ) { \nseenColon = true ; \nif ( start ) dst . append ( '_' ) ; \nstart = true ; \ndst . append ( translateColons ? '_' : ch ) ; \n} \n} \nint dstLength = dst . length ( ) ; \nif ( dstLength == 0 || dst . charAt ( dstLength - 1 ) == ':' ) dst . append ( '_' ) ; \nreturn dst . toString ( ) . intern ( ) ; \n} \n} \n"}
{"6685": "public class HTMLWriter { \nprivate boolean booleanAttribute ( String localName , String qName , String value ) { \nString name = localName ; \nif ( name == null ) { \nint i = qName . indexOf ( ':' ) ; \nif ( i != - 1 ) name = qName . substring ( i + 1 , qName . length ( ) ) ; \n} \nif ( ! name . equals ( value ) ) return false ; \nfor ( int j = 0 ; \nj < booleans . length ; \nj = j + 1 ) { \nif ( name . equals ( booleans [ j ] ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"6694": "public class AwsUtils { \npublic static < T > T performAmazonActionWithRetry ( String actionLabel , Supplier < T > action , int retryLimit , int durationInMillis ) { \nint retryCount = 0 ; \ndo { \ntry { \nreturn action . get ( ) ; \n} \ncatch ( LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e ) { \nint remainingRetries = retryLimit - retryCount ; \nLOG . debug ( \"Amazon exception caught\" , args -> args . add ( \"exception\" , e . getClass ( ) . getName ( ) ) . add ( \"action\" , actionLabel ) . add ( \"remainingRetryCount\" , remainingRetries ) ) ; \n} \nsleepUntilInterrupted ( actionLabel , durationInMillis ) ; \n} \nwhile ( retryCount = retryCount + 1 < retryLimit ) ; \nthrow new AwsException ( \"Limit exceeded, all retries failed\" , args -> args . add ( \"action\" , actionLabel ) . add ( \"retryLimit\" , retryLimit ) ) ; \n} \n} \n"}
{"6700": "public class StringUtils { \nprivate static String deleteAny ( final String inString , final String charsToDelete ) { \nif ( ! hasLength ( inString ) || ! hasLength ( charsToDelete ) ) { \nreturn inString ; \n} \nfinal StringBuffer out = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < inString . length ( ) ; \ni = i + 1 ) { \nfinal char c = inString . charAt ( i ) ; \nif ( charsToDelete . indexOf ( c ) == - 1 ) { \nout . append ( c ) ; \n} \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"6764": "public class AbstractConfigurableMultipleStrategy { \npublic static String createItemsAsString ( final String ... items ) { \nfinal StringBuffer sb = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < items . length ; \ni = i + 1 ) { \nsb . append ( items [ i ] ) ; \nif ( i < items . length - 1 ) { \nsb . append ( TOKEN_DELIMITER ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6787": "public class ProgressIndicator { \npublic synchronized void onProcessingResource ( final Resource resource ) { \ntotalResources = totalResources + 1 ; \nlog . debug ( \"processing resource: \" + resource . getUri ( ) ) ; \nif ( isLogRequired ( ) ) { \nlog . info ( \"Processed until now: \" + getTotalResources ( ) + \". Last processed: \" + resource . getUri ( ) ) ; \nupdateLastInvocation ( ) ; \n} \n} \n} \n"}
{"6814": "public class XmlModelFactory { \nprivate void processGroups ( final Document document ) { \nfinal NodeList groupNodeList = document . getElementsByTagName ( TAG_GROUP ) ; \nfor ( int i = 0 ; \ni < groupNodeList . getLength ( ) ; \ni = i + 1 ) { \nfinal Element groupElement = ( Element ) groupNodeList . item ( i ) ; \nfinal String name = groupElement . getAttribute ( ATTR_GROUP_NAME ) ; \nallGroupElements . put ( name , groupElement ) ; \n} \n} \n} \n"}
{"6816": "public class XmlModelFactory { \nprotected Group createGroup ( final Element element ) { \nfinal String name = element . getAttribute ( ATTR_GROUP_NAME ) ; \nfinal Group group = new Group ( name ) ; \nfinal List < Resource > resources = new ArrayList < Resource > ( ) ; \nfinal NodeList resourceNodeList = element . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < resourceNodeList . getLength ( ) ; \ni = i + 1 ) { \nfinal Node node = resourceNodeList . item ( i ) ; \nif ( node instanceof Element ) { \nfinal Element resourceElement = ( Element ) node ; \nparseResource ( resourceElement , resources ) ; \n} \n} \ngroup . setResources ( resources ) ; \nreturn group ; \n} \n} \n"}
{"6826": "public class ClassExpressionSaturationFactory { \nprivate void updateFinishedCounters ( ThisStatistics localStatistics ) throws InterruptedException { \nint snapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nfor ( ; \n; \n) { \nint snapshotCountContextsSaturatedLower = countContextsSaturatedLower_ . get ( ) ; \nsaturationState_ . setContextsSaturated ( snapshotCountContextsSaturatedLower ) ; \nif ( saturationState_ . getContextSetSaturatedCount ( ) < snapshotCountContextsSaturatedLower ) { \nreturn ; \n} \nint updatedSnapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nif ( updatedSnapshotJobsProcessed == snapshotJobsProcessed ) { \nbreak ; \n} \nsnapshotJobsProcessed = updatedSnapshotJobsProcessed ; \n} \nfor ( ; \n; \n) { \nint snapshotJobsFinished = countJobsFinishedUpper_ . get ( ) ; \nif ( snapshotJobsFinished >= snapshotJobsProcessed ) { \nbreak ; \n} \nif ( ! countJobsFinishedUpper_ . compareAndSet ( snapshotJobsFinished , snapshotJobsFinished + 1 ) ) { \ncontinue ; \n} \nJ nextJob = jobsInProgress_ . poll ( ) ; \nIndexedContextRoot root = nextJob . getInput ( ) ; \nContext rootSaturation = saturationState_ . getContext ( root ) ; \nif ( rootSaturation . isInitialized ( ) && ! rootSaturation . isSaturated ( ) ) { \nLOGGER_ . error ( \"{}: context for a finished job not saturated!\" , rootSaturation ) ; \n} \nnextJob . setOutput ( rootSaturation ) ; \nLOGGER_ . trace ( \"{}: saturation finished\" , root ) ; \nlocalStatistics . jobsProcessedNo = localStatistics . jobsProcessedNo + 1 ; \nlistener_ . notifyFinished ( nextJob ) ; \n} \n} \n} \n"}
{"6835": "public class ConsistencyCheckingState { \npublic Proof < ? extends EntailmentInference > getEvidence ( final boolean atMostOne ) { \nreturn new Proof < EntailmentInference > ( ) { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public Collection < OntologyInconsistencyEntailmentInference > getInferences ( final Object conclusion ) { \nif ( ! OntologyInconsistencyImpl . INSTANCE . equals ( conclusion ) ) { \nreturn Collections . emptyList ( ) ; \n} \nfinal Collection < ? extends IndexedIndividual > inconsistentIndividuals = getInconsistentIndividuals ( ) ; \nIterable < OntologyInconsistencyEntailmentInference > result = Operations . map ( inconsistentIndividuals , INDIVIDUAL_TO_ENTAILMENT_INFERENCE ) ; \nint size = inconsistentIndividuals . size ( ) ; \nif ( isTopObjectPropertyInBottom_ ) { \nresult = Operations . concat ( Operations . < OntologyInconsistencyEntailmentInference > singleton ( new TopObjectPropertyInBottomEntailsOntologyInconsistencyImpl ( conclusionFactory_ . getSubPropertyChain ( topProperty_ , bottomProperty_ ) ) ) , result ) ; \nsize = size + 1 ; \n} \nif ( isOwlThingInconsistent_ ) { \nresult = Operations . concat ( Operations . < OntologyInconsistencyEntailmentInference > singleton ( new OwlThingInconsistencyEntailsOntologyInconsistencyImpl ( conclusionFactory_ . getContradiction ( owlThing_ ) ) ) , result ) ; \nsize = size + 1 ; \n} \nif ( atMostOne ) { \nfinal Iterator < OntologyInconsistencyEntailmentInference > iter = result . iterator ( ) ; \nif ( ! iter . hasNext ( ) ) { \nreturn Collections . emptyList ( ) ; \n} \nreturn Collections . singleton ( iter . next ( ) ) ; \n} \nreturn Operations . getCollection ( result , size ) ; \n} \n} \n; \n} \n} \n"}
{"6843": "public class LinearProbing { \nstatic < E > int getMovedPosition ( E [ ] d , int del ) { \nint j = del ; \nfor ( ; \n; \n) { \nif ( j = j + 1 == d . length ) j = 0 ; \nE test = d [ j ] ; \nif ( test == null ) return j ; \nint k = getIndex ( test , d . length ) ; \nif ( ( del < j ) ? ( del < k ) && ( k <= j ) : ( del < k ) || ( k <= j ) ) continue ; \nreturn j ; \n} \n} \n} \n"}
{"6851": "public class ArrayHashMap { \nprivate void enlarge ( ) { \nint oldCapacity = keys . length ; \nif ( oldCapacity == LinearProbing . MAXIMUM_CAPACITY ) throw new IllegalArgumentException ( \"Map cannot grow beyond capacity: \" + LinearProbing . MAXIMUM_CAPACITY ) ; \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nint newCapacity = oldCapacity << 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \nfor ( int i = 0 ; \ni < oldCapacity ; \ni = i + 1 ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \n} \n} \n"}
{"6852": "public class ArrayHashMap { \nprivate void shrink ( ) { \nint oldCapacity = keys . length ; \nif ( oldCapacity <= LinearProbing . DEFAULT_INITIAL_CAPACITY ) return ; \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nint newCapacity = oldCapacity >> 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \nfor ( int i = 0 ; \ni < oldCapacity ; \ni = i + 1 ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \n} \n} \n"}
{"6856": "public class EntryCollection { \n@ Override public void clear ( ) { \nmodCount = modCount + 1 ; \nE [ ] tab = buckets ; \nfor ( int i = 0 ; \ni < tab . length ; \ni = i + 1 ) tab [ i ] = null ; \nsize = 0 ; \n} \n} \n"}
{"6867": "public class Operations { \npublic static < T > Set < T > filter ( final Set < ? extends T > input , final Condition < ? super T > condition , final int size ) { \nreturn new Set < T > ( ) { \n@ Override public int size ( ) { \nreturn size ; \n} \n@ Override public boolean isEmpty ( ) { \nreturn size == 0 ; \n} \n@ Override @ SuppressWarnings ( \"unchecked\" ) public boolean contains ( Object o ) { \nif ( ! input . contains ( o ) ) return false ; \nT elem = null ; \ntry { \nelem = ( T ) o ; \n} \ncatch ( ClassCastException cce ) { \nreturn false ; \n} \nreturn condition . holds ( elem ) ; \n} \n@ Override public Iterator < T > iterator ( ) { \nreturn filter ( input , condition ) . iterator ( ) ; \n} \n@ Override public Object [ ] toArray ( ) { \nObject [ ] result = new Object [ size ] ; \nint i = 0 ; \nfor ( Object o : filter ( input , condition ) ) { \nresult [ i = i + 1 ] = o ; \n} \nreturn result ; \n} \n@ Override public < S > S [ ] toArray ( S [ ] a ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean add ( T e ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean remove ( Object o ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean containsAll ( Collection < ? > c ) { \nfor ( Object o : c ) { \nif ( contains ( o ) ) return false ; \n} \nreturn true ; \n} \n@ Override public boolean addAll ( Collection < ? extends T > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean retainAll ( Collection < ? > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean removeAll ( Collection < ? > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public void clear ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \n} \n"}
{"6869": "public class ArraySlicedSet { \npublic boolean add ( int s , E e ) { \nif ( e == null ) throw new NullPointerException ( ) ; \nint mask = ( 1 << s ) ; \nint oldMask = addMask ( logs , data , masks , e , mask ) ; \nint newMask = oldMask | mask ; \nif ( newMask == oldMask ) return false ; \nelse if ( oldMask == 0 && occupied = occupied + 1 == LinearProbing . getUpperSize ( data . length ) ) enlarge ( ) ; \nsizes [ s ] = sizes [ s ] + 1 ; \nreturn true ; \n} \n} \n"}
{"6870": "public class ArraySlicedSet { \npublic boolean remove ( int s , Object o ) { \nif ( o == null ) throw new NullPointerException ( ) ; \nint mask = 1 << s ; \nint oldMask = removeMask ( logs , data , masks , o , mask ) ; \nint newMask = oldMask & ~ mask ; \nif ( newMask == oldMask ) return false ; \nif ( newMask == 0 && occupied = occupied - 1 == LinearProbing . getLowerSize ( data . length ) ) shrink ( ) ; \nsizes [ s ] = sizes [ s ] - 1 ; \nreturn true ; \n} \n} \n"}
{"6877": "public class StatisticsPrinter { \nstatic String getString ( char c , int n ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nsb . append ( c ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6903": "public class XhtmlWriter { \nprivate void appendForm ( Affordance affordance , ActionDescriptor actionDescriptor ) throws IOException { \nString formName = actionDescriptor . getActionName ( ) ; \nRequestMethod httpMethod = RequestMethod . valueOf ( actionDescriptor . getHttpMethod ( ) ) ; \nString actionUrl = affordance . expand ( ) . getHref ( ) ; \nbeginForm ( OptionalAttributes . attr ( \"action\" , actionUrl ) . and ( \"method\" , getHtmlConformingHttpMethod ( httpMethod ) ) . and ( \"name\" , formName ) ) ; \nwrite ( \"<h4>\" ) ; \nwrite ( \"Form \" + formName ) ; \nwrite ( \"</h4>\" ) ; \nwriteHiddenHttpMethodField ( httpMethod ) ; \nif ( actionDescriptor . hasRequestBody ( ) ) { \nActionInputParameter requestBody = actionDescriptor . getRequestBody ( ) ; \nClass < ? > parameterType = requestBody . getParameterType ( ) ; \nrecurseBeanProperties ( parameterType , actionDescriptor , requestBody , requestBody . getValue ( ) , \"\" ) ; \n} \nelse { \nCollection < String > requestParams = actionDescriptor . getRequestParamNames ( ) ; \nfor ( String requestParamName : requestParams ) { \nActionInputParameter actionInputParameter = actionDescriptor . getActionInputParameter ( requestParamName ) ; \nObject [ ] possibleValues = actionInputParameter . getPossibleValues ( actionDescriptor ) ; \nif ( possibleValues . length > 0 ) { \nif ( actionInputParameter . isArrayOrCollection ( ) ) { \nappendSelectMulti ( requestParamName , possibleValues , actionInputParameter ) ; \n} \nelse { \nappendSelectOne ( requestParamName , possibleValues , actionInputParameter ) ; \n} \n} \nelse { \nif ( actionInputParameter . isArrayOrCollection ( ) ) { \nObject [ ] callValues = actionInputParameter . getValues ( ) ; \nint items = callValues . length ; \nfor ( int i = 0 ; \ni < items ; \ni = i + 1 ) { \nObject value ; \nif ( i < callValues . length ) { \nvalue = callValues [ i ] ; \n} \nelse { \nvalue = null ; \n} \nappendInput ( requestParamName , actionInputParameter , value , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \nelse { \nString callValueFormatted = actionInputParameter . getValueFormatted ( ) ; \nappendInput ( requestParamName , actionInputParameter , callValueFormatted , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \n} \n} \ninputButton ( Type . SUBMIT , capitalize ( httpMethod . name ( ) . toLowerCase ( ) ) ) ; \nendForm ( ) ; \n} \n} \n"}
{"6911": "public class AbstractUberNode { \n@ Override public Iterator < UberNode > iterator ( ) { \nreturn new Iterator < UberNode > ( ) { \nint index = 0 ; \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( \"removing from uber node is not supported\" ) ; \n} \n@ Override public UberNode next ( ) { \nindex = findNextChildWithData ( ) ; \nreturn data . get ( index = index + 1 ) ; \n} \n@ Override public boolean hasNext ( ) { \nreturn findNextChildWithData ( ) != - 1 ; \n} \nprivate int findNextChildWithData ( ) { \nfor ( int i = index ; \ni < data . size ( ) ; \ni = i + 1 ) { \nif ( ! data . get ( i ) . getData ( ) . isEmpty ( ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n; \n} \n} \n"}
{"6918": "public class Xform { \n@ SuppressWarnings ( \"unchecked\" ) private static < H > H _fold ( Iterable source , Operation [ ] ops , int opIdx , H ident , Fn2 reducer ) { \nObject ret = ident ; \nsourceLoop : for ( Object o : source ) { \nfor ( int j = opIdx ; \nj < ops . length ; \nj = j + 1 ) { \nOperation op = ops [ j ] ; \nif ( ( op . filter != null ) && ! op . filter . apply ( o ) ) { \ncontinue sourceLoop ; \n} \nif ( op . map != null ) { \no = op . map . apply ( o ) ; \nif ( o == TERMINATE ) { \nreturn ( H ) ret ; \n} \n} \nelse if ( op . flatMap != null ) { \nret = _fold ( op . flatMap . apply ( o ) , ops , j + 1 , ( H ) ret , reducer ) ; \ncontinue sourceLoop ; \n} \n} \nret = reducer . apply ( ret , o ) ; \n} \nreturn ( H ) ret ; \n} \n} \n"}
{"6950": "public class ServiceManagementImpl { \npublic void uninstallService ( final ServiceComponent serviceComponent ) throws SystemException , UnrecognizedServiceException , InstanceNotFoundException , MBeanRegistrationException , NullPointerException , UnrecognizedResourceAdaptorEntityException , ManagementException , InvalidStateException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Uninstalling service with id \" + serviceComponent . getServiceID ( ) ) ; \n} \nif ( serviceComponent . getServiceState ( ) . isStopping ( ) ) { \nfor ( int i = 0 ; \ni < 15 ; \ni = i + 1 ) { \ntry { \nThread . sleep ( 1000 ) ; \nlogger . info ( \"Waiting for \" + serviceComponent . getServiceID ( ) + \" to stop, current state is \" + serviceComponent . getServiceState ( ) ) ; \nif ( serviceComponent . getServiceState ( ) . isInactive ( ) ) { \nbreak ; \n} \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \nif ( ! serviceComponent . getServiceState ( ) . isInactive ( ) ) { \nthrow new InvalidStateException ( serviceComponent . toString ( ) + \" is not inactive\" ) ; \n} \nfinal TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Closing Usage MBean of service \" + serviceComponent . getServiceID ( ) ) ; \n} \nServiceUsageMBean serviceUsageMBean = serviceComponent . getServiceUsageMBean ( ) ; \nif ( serviceUsageMBean != null ) { \nserviceUsageMBean . remove ( ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntry { \nsleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \nfinal TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; \nfor ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { \n{ \ntraceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntraceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \n} \nsleeContainer . getSbbManagement ( ) . serviceUninstall ( serviceComponent ) ; \n} \n} \n"}
{"6958": "public class AbstractOperation { \nprotected String unfoldArray ( String prefix , Object [ ] array , PropertyEditor editor ) { \nStringBuffer sb = new StringBuffer ( \"[\" ) ; \nfor ( int index = 0 ; \nindex < array . length ; \nindex = index + 1 ) { \nif ( editor != null ) { \neditor . setValue ( array [ index ] ) ; \nsb . append ( editor . getAsText ( ) ) ; \n} \nelse { \nsb . append ( array [ index ] . toString ( ) ) ; \n} \nif ( index < array . length - 1 ) { \nsb . append ( CID_SEPARATOR ) ; \n} \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"7028": "public class ClassUtils { \npublic static Map getAbstractMethodsFromClass ( CtClass sbbAbstractClass ) { \nHashMap abstractMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni = i + 1 ) { \nif ( Modifier . isAbstract ( methods [ i ] . getModifiers ( ) ) ) { \nabstractMethods . put ( methods [ i ] . getName ( ) , methods [ i ] ) ; \n} \n} \nreturn abstractMethods ; \n} \n} \n"}
{"7029": "public class ClassUtils { \npublic static Map getInterfaceMethodsFromInterface ( CtClass interfaceClass , Map exceptMethods ) { \nHashMap interfaceMethods = new HashMap ( ) ; \nCtMethod [ ] methods = interfaceClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni = i + 1 ) { \nif ( exceptMethods . get ( methods [ i ] . getName ( ) ) == null ) { \nConcreteClassGeneratorUtils . logger . trace ( methods [ i ] . getName ( ) ) ; \ninterfaceMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; \n} \n} \nMap temp = getSuperClassesAbstractMethodsFromInterface ( interfaceClass ) ; \nfor ( Iterator i = temp . keySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nString key = ( String ) i . next ( ) ; \nif ( ! exceptMethods . containsKey ( key ) ) { \ninterfaceMethods . put ( key , temp . get ( key ) ) ; \n} \n} \nreturn interfaceMethods ; \n} \n} \n"}
{"7037": "public class SLEESubDeployer { \npublic void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nURL url = deployableUnitURL ; \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method init called for \" + deployableUnitURL + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \nString fullPath = du . getFullPath ( ) ; \nString fileName = du . getFileName ( ) ; \ntry { \nDeployableUnitWrapper duWrapper = null ; \nif ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) { \nDeployableComponent dc = new DeployableComponent ( du , url , fileName , sleeContainerDeployer ) ; \nDeployableUnit deployerDU = deployableUnits . get ( duWrapper . getFileName ( ) ) ; \nfor ( DeployableComponent subDC : dc . getSubComponents ( ) ) { \ndeployerDU . addComponent ( subDC ) ; \n} \n} \nelse if ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nduJarFile = new JarFile ( fullPath ) ; \nJarEntry duXmlEntry = duJarFile . getJarEntry ( \"META-INF/deployable-unit.xml\" ) ; \nif ( duXmlEntry != null ) { \nDeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; \nDeployableUnitDescriptorFactory dudf = sleeContainerDeployer . getSleeContainer ( ) . getComponentManagement ( ) . getDeployableUnitManagement ( ) . getDeployableUnitDescriptorFactory ( ) ; \nDeployableUnitDescriptor duDesc = dudf . parse ( duJarFile . getInputStream ( duXmlEntry ) ) ; \nwhile ( deployableUnits . containsKey ( fileName ) ) { \nThread . sleep ( getWaitTimeBetweenOperations ( ) ) ; \n} \ndeployableUnits . put ( fileName , deployerDU ) ; \nfor ( String componentJarName : duDesc . getJarEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = componentJarName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = componentJarName . lastIndexOf ( '\\\\' ) ; \nbeginIndex = beginIndex + 1 ; \ncomponentJarName = componentJarName . substring ( beginIndex , componentJarName . length ( ) ) ; \ntoAccept . put ( componentJarName , du ) ; \n} \nfor ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = serviceXMLName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = serviceXMLName . lastIndexOf ( '\\\\' ) ; \nbeginIndex = beginIndex + 1 ; \nserviceXMLName = serviceXMLName . substring ( beginIndex , serviceXMLName . length ( ) ) ; \ntoAccept . put ( serviceXMLName , du ) ; \n} \n} \n} \nfinally { \nif ( duJarFile != null ) { \ntry { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"Deployment of \" + fileName + \" failed. \" , e ) ; \nreturn ; \n} \n} \n} \n"}
{"7105": "public class ConcreteSbbGenerator { \nprotected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { \nif ( mEventEntries == null ) return ; \nfor ( EventEntryDescriptor mEventEntry : mEventEntries ) { \nif ( mEventEntry . isFired ( ) ) { \nString methodName = \"fire\" + mEventEntry . getEventName ( ) ; \nCtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; \nif ( method == null ) { \nmethod = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; \n} \nif ( method != null ) { \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; \nString concreteMethodBody = \"{\" ; \nconcreteMethodBody += getEventTypeIDInstantionString ( mEventEntry ) ; \nconcreteMethodBody += SbbAbstractMethodHandler . class . getName ( ) + \".fireEvent(sbbEntity,eventTypeID\" ; \nfor ( int i = 0 ; \ni < method . getParameterTypes ( ) . length ; \ni = i + 1 ) { \nconcreteMethodBody += \",$\" + ( i + 1 ) ; \n} \nconcreteMethodBody += \");}\" ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nsbbConcreteClass . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception e ) { \nthrow new SLEEException ( \"Cannot compile method \" + method . getName ( ) , e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7110": "public class SbbAbstractClassDecorator { \npublic boolean decorateAbstractSbb ( ) throws DeploymentException { \nClassPool pool = component . getClassPool ( ) ; \nString sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; \ntry { \nsbbAbstractClass = pool . get ( sbbAbstractClassName ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find Abstract Sbb Class: \" + sbbAbstractClassName , nfe ) ; \n} \nconcreteMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni = i + 1 ) { \nint mods = methods [ i ] . getModifiers ( ) ; \nif ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) { \nconcreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; \n} \n} \ndecorateENCBindCalls ( ) ; \ndecorateNewThreadCalls ( ) ; \nif ( isAbstractSbbClassDecorated ) { \ntry { \nString deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nsbbAbstractClass . writeFile ( deployDir ) ; \nsbbAbstractClass . detach ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Modified Abstract Class \" + sbbAbstractClass . getName ( ) + \" generated in the following path \" + deployDir ) ; \n} \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nfinally { \nsbbAbstractClass . defrost ( ) ; \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"7131": "public class ClassUtils { \npublic static Map < String , Method > getAllInterfacesMethods ( Class xInterfaceClass , Set < String > ignore ) { \nHashMap < String , Method > abstractMethods = new HashMap < String , Method > ( ) ; \nMethod [ ] methods = null ; \nClass [ ] superInterfaces ; \nsuperInterfaces = xInterfaceClass . getInterfaces ( ) ; \nfor ( Class superInterface : superInterfaces ) { \nif ( ! ignore . contains ( superInterface . getName ( ) ) ) abstractMethods . putAll ( getAllInterfacesMethods ( superInterface , ignore ) ) ; \n} \nmethods = xInterfaceClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni = i + 1 ) { \nabstractMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; \n} \nreturn abstractMethods ; \n} \n} \n"}
{"7133": "public class TraceMBeanImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { \nif ( tracerName . compareTo ( \"\" ) == 0 ) { \nreturn ; \n} \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nint fqdnPartIndex = 0 ; \nString lastToken = null ; \nwhile ( stringTokenizer . hasMoreTokens ( ) ) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) { \nlastToken = token ; \n} \nif ( lastToken . compareTo ( token ) == 0 && token . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \nif ( token . compareTo ( \".\" ) != 0 ) { \nfor ( int charIndex = 0 ; \ncharIndex < token . length ( ) ; \ncharIndex = charIndex + 1 ) { \nCharacter c = token . charAt ( charIndex ) ; \nif ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { \n} \nelse { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \" Token[\" + token + \"], name for source: \" + notificationSource + \", is illegal, contains illegal character: \" + charIndex ) ; \n} \n} \nfqdnPartIndex = fqdnPartIndex + 1 ; \n} \nlastToken = token ; \n} \nif ( lastToken . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \n} \n"}
{"7188": "public class AndroidDeviceStore { \nprotected void initializeAdbConnection ( ) { \ntry { \nAndroidDebugBridge . init ( true ) ; \n} \ncatch ( IllegalStateException e ) { \nif ( ! shouldKeepAdbAlive ) { \nlogger . error ( \"The IllegalStateException is not a show \" + \"stopper. It has been handled. This is just debug spew. Please proceed.\" , e ) ; \nthrow new NestedException ( \"ADB init failed\" , e ) ; \n} \n} \nbridge = AndroidDebugBridge . getBridge ( ) ; \nif ( bridge == null ) { \nbridge = AndroidDebugBridge . createBridge ( AndroidSdk . adb ( ) . getAbsolutePath ( ) , false ) ; \n} \nlong timeout = System . currentTimeMillis ( ) + 60000 ; \nwhile ( ! bridge . hasInitialDeviceList ( ) && System . currentTimeMillis ( ) < timeout ) { \ntry { \nThread . sleep ( 50 ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nIDevice [ ] devices = bridge . getDevices ( ) ; \nlogger . info ( \"initialDeviceList size {}\" , devices . length ) ; \nfor ( int i = 0 ; \ni < devices . length ; \ni = i + 1 ) { \nlogger . info ( \"devices state: {},{} \" , devices [ i ] . getName ( ) , devices [ i ] . getState ( ) ) ; \nconnectedDevices . put ( devices [ i ] , new DefaultHardwareDevice ( devices [ i ] ) ) ; \n} \nbridge . addDeviceChangeListener ( new DeviceChangeListener ( connectedDevices ) ) ; \n} \n} \n"}
{"7195": "public class TextEditor { \npublic TextEditor detabify ( final int tabWidth ) { \nreplaceAll ( Pattern . compile ( \"(.*?)\\\\t\" ) , new Replacement ( ) { \npublic String replacement ( Matcher m ) { \nString lineSoFar = m . group ( 1 ) ; \nint width = lineSoFar . length ( ) ; \nStringBuilder replacement = new StringBuilder ( lineSoFar ) ; \ndo { \nreplacement . append ( ' ' ) ; \nwidth = width + 1 ; \n} \nwhile ( width % tabWidth != 0 ) ; \nreturn replacement . toString ( ) ; \n} \n} \n) ; \nreturn this ; \n} \n} \n"}
{"7196": "public class TextEditor { \npublic TextEditor indent ( int spaces ) { \nStringBuilder sb = new StringBuilder ( spaces ) ; \nfor ( int i = 0 ; \ni < spaces ; \ni = i + 1 ) { \nsb . append ( ' ' ) ; \n} \nreturn replaceAll ( \"^\" , sb . toString ( ) ) ; \n} \n} \n"}
{"7207": "public class MTGAPI { \nprivate static List < JsonObject > getJsonObject ( String path , Gson deserializer ) { \nString url = String . format ( \"%s/%s\" , ENDPOINT , path ) ; \nRequest request = new Request . Builder ( ) . url ( url ) . build ( ) ; \nResponse response ; \ntry { \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nArrayList < JsonObject > objectList = new ArrayList < > ( ) ; \nString linkHeader = response . headers ( ) . get ( \"Link\" ) ; \nif ( linkHeader == null || linkHeader . isEmpty ( ) || path . contains ( \"page=\" ) ) { \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nreturn objectList ; \n} \nelse { \nint numberOfPages = 0 ; \nString [ ] linkStrings = linkHeader . split ( DELIM_LINK ) ; \nList < String [ ] > paramList = new ArrayList < > ( ) ; \nfor ( String link : linkStrings ) { \nparamList . add ( link . split ( DELIM_LINK_PARAM ) ) ; \n} \nfor ( String [ ] params : paramList ) { \nif ( params [ 1 ] . contains ( \"last\" ) ) { \nMatcher matcher = Pattern . compile ( \"page=[0-9]+\" ) . matcher ( params [ 0 ] ) ; \nnumberOfPages = ( matcher . find ( ) ) ? Integer . parseInt ( matcher . group ( ) . substring ( 5 ) ) : 0 ; \n} \n} \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nif ( ! url . contains ( \"?\" ) ) { \nurl += \"?\" ; \n} \nfor ( int i = 1 ; \ni <= numberOfPages ; \ni = i + 1 ) { \nrequest = new Request . Builder ( ) . url ( url + \"&page=\" + i ) . build ( ) ; \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \n} \nreturn objectList ; \n} \n} \ncatch ( IOException e ) { \nthrow new HttpRequestFailedException ( e ) ; \n} \n} \n} \n"}
{"7242": "public class Dbl { \npublic static double varianceDouble ( double [ ] values , final int start , final int length ) { \ndouble mean = mean ( values , start , length ) ; \ndouble temp = 0 ; \nfor ( int index = start ; \nindex < length ; \nindex = index + 1 ) { \ndouble a = values [ index ] ; \ntemp += ( mean - a ) * ( mean - a ) ; \n} \nreturn temp / length ; \n} \n} \n"}
{"7264": "public class MessageUtils { \npublic static String generateLabelValue ( final String fieldName ) { \nfinal StringBuilder buffer = new StringBuilder ( fieldName . length ( ) * 2 ) ; \nclass GenerationCommand { \nboolean capNextChar = false ; \nboolean lastCharWasUpperCase = false ; \nboolean lastCharWasNumber = false ; \nboolean lastCharWasSpecial = false ; \nboolean shouldContinue = true ; \nchar [ ] chars = fieldName . toCharArray ( ) ; \nvoid processFieldName ( ) { \nfor ( int index = 0 ; \nindex < chars . length ; \nindex = index + 1 ) { \nchar cchar = chars [ index ] ; \nshouldContinue = true ; \nprocessCharWasNumber ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessCharWasUpperCase ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessSpecialChars ( buffer , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \ncchar = processCapitalizeCommand ( cchar ) ; \ncchar = processFirstCharacterCheck ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nbuffer . append ( cchar ) ; \n} \n} \nprivate void processCharWasNumber ( StringBuilder buffer , int index , char cchar ) { \nif ( lastCharWasSpecial ) { \nreturn ; \n} \nif ( Character . isDigit ( cchar ) ) { \nif ( index != 0 && ! lastCharWasNumber ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasNumber = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasNumber = false ; \n} \n} \nprivate char processFirstCharacterCheck ( final StringBuilder buffer , int index , char cchar ) { \nif ( index == 0 ) { \ncchar = Character . toUpperCase ( cchar ) ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nreturn cchar ; \n} \nprivate char processCapitalizeCommand ( char cchar ) { \nif ( capNextChar ) { \ncapNextChar = false ; \ncchar = Character . toUpperCase ( cchar ) ; \n} \nreturn cchar ; \n} \nprivate void processSpecialChars ( final StringBuilder buffer , char cchar ) { \nlastCharWasSpecial = false ; \nif ( cchar == '.' || cchar == '_' ) { \nbuffer . append ( ' ' ) ; \ncapNextChar = true ; \nlastCharWasSpecial = false ; \nthis . shouldContinue = false ; \n} \n} \nprivate void processCharWasUpperCase ( final StringBuilder buffer , int index , char cchar ) { \nif ( Character . isUpperCase ( cchar ) ) { \nif ( index != 0 && ! lastCharWasUpperCase ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasUpperCase = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasUpperCase = false ; \n} \n} \n} \nGenerationCommand gc = new GenerationCommand ( ) ; \ngc . processFieldName ( ) ; \nreturn buffer . toString ( ) . replace ( \"  \" , \" \" ) ; \n} \n} \n"}
{"7265": "public class CharBuf { \npublic CharSequence addHex ( final int decoded ) { \nint _location = location ; \nchar [ ] _buffer = buffer ; \nint _capacity = capacity ; \nif ( 2 + _location > _capacity ) { \n_buffer = Chr . grow ( _buffer ) ; \n_capacity = _buffer . length ; \n} \n_buffer [ _location ] = ( char ) encodeNibbleToHexAsciiCharByte ( ( decoded >> 4 ) & 0x0F ) ; \n_location = _location + 1 ; \n_buffer [ _location ] = ( char ) encodeNibbleToHexAsciiCharByte ( decoded & 0x0F ) ; \n; \n_location = _location + 1 ; \nlocation = _location ; \nbuffer = _buffer ; \ncapacity = _capacity ; \nreturn this ; \n} \n} \n"}
{"7278": "public class Str { \npublic static String [ ] fromCharArrayOfArrayToStringArray ( char [ ] [ ] split ) { \nString [ ] results = new String [ split . length ] ; \nchar [ ] array ; \nfor ( int index = 0 ; \nindex < split . length ; \nindex = index + 1 ) { \narray = split [ index ] ; \nresults [ index ] = array . length == 0 ? EMPTY_STRING : FastStringUtils . noCopyStringFromChars ( array ) ; \n} \nreturn results ; \n} \n} \n"}
{"7282": "public class Str { \npublic static String num ( Number count ) { \nif ( count == null ) { \nreturn \"\" ; \n} \nif ( count instanceof Double || count instanceof BigDecimal ) { \nString s = count . toString ( ) ; \nif ( idx ( s , 1 ) == '.' && s . length ( ) > 7 ) { \ns = slc ( s , 0 , 5 ) ; \nreturn s ; \n} \nelse { \nreturn s ; \n} \n} \nelse if ( count instanceof Integer || count instanceof Long || count instanceof Short || count instanceof BigInteger ) { \nString s = count . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nCharBuf buf = CharBuf . create ( s . length ( ) ) ; \nint index = 0 ; \nfor ( char c : s . toCharArray ( ) ) { \nindex = index + 1 ; \nbuf . add ( c ) ; \nif ( index % 3 == 0 ) { \nbuf . add ( ',' ) ; \n} \n} \nif ( buf . lastChar ( ) == ',' ) { \nbuf . removeLastChar ( ) ; \n} \ns = buf . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nreturn s ; \n} \nreturn count . toString ( ) ; \n} \n} \n"}
{"7283": "public class Sort { \npublic static Sort sorts ( Sort ... sorts ) { \nif ( sorts == null || sorts . length == 0 ) { \nreturn null ; \n} \nSort main = sorts [ 0 ] ; \nfor ( int index = 1 ; \nindex < sorts . length ; \nindex = index + 1 ) { \nmain . then ( sorts [ index ] ) ; \n} \nreturn main ; \n} \n} \n"}
{"7289": "public class Int { \npublic static boolean equalsOrDie ( int [ ] expected , int [ ] got ) { \nif ( expected . length != got . length ) { \ndie ( \"Lengths did not match, expected length\" , expected . length , \"but got\" , got . length ) ; \n} \nfor ( int index = 0 ; \nindex < expected . length ; \nindex = index + 1 ) { \nif ( expected [ index ] != got [ index ] ) { \ndie ( \"value at index did not match index\" , index , \"expected value\" , expected [ index ] , \"but got\" , got [ index ] ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7290": "public class Int { \npublic static int sum ( int [ ] values , int start , int length ) { \nlong sum = 0 ; \nfor ( int index = start ; \nindex < length ; \nindex = index + 1 ) { \nsum += values [ index ] ; \n} \nif ( sum < Integer . MIN_VALUE ) { \ndie ( \"overflow the sum is too small\" , sum ) ; \n} \nif ( sum > Integer . MAX_VALUE ) { \ndie ( \"overflow the sum is too big\" , sum ) ; \n} \nreturn ( int ) sum ; \n} \n} \n"}
{"7310": "public class Sorting { \npublic static < T > void sort ( T [ ] array , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( array == null || array . length == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nArrays . sort ( array , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nObject object = array [ 0 ] ; \nMap < String , FieldAccess > fields = null ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \n} \nelse { \nfor ( int index = 1 ; \nindex < array . length ; \nindex = index + 1 ) { \nobject = array [ index ] ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nArrays . sort ( array , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \n} \n} \n"}
{"7330": "public class BatchFileWriter { \npublic void nextBufferToWrite ( final ByteBuffer bufferOut ) throws InterruptedException { \ndirty = true ; \nfinal int size = bufferOut . limit ( ) ; \nwrite ( bufferOut ) ; \nif ( ! error . get ( ) ) { \ntotalBytesTransferred += size ; \nbytesTransferred += size ; \nbytesSinceLastFlush += size ; \nbuffersSent = buffersSent + 1 ; \n} \nif ( this . bytesTransferred >= FILE_SIZE_BYTES || fileTimeOut . get ( ) ) { \ntry { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \ncleanupOutputStream ( ) ; \ne . printStackTrace ( System . err ) ; \n} \nfinally { \noutputStream = null ; \n} \n} \n} \n} \n"}
{"7332": "public class BatchFileWriter { \nprivate void initOutputStream ( ) { \nlong time = this . time . get ( ) ; \nif ( error . get ( ) || this . totalBytesTransferred == 0 ) { \ncleanupOutputStream ( ) ; \nerror . set ( false ) ; \ntime = System . nanoTime ( ) / 1_000_000 ; \n} \nif ( outputStream != null ) { \nreturn ; \n} \nfileName = LogFilesConfig . getLogFileName ( FORMAT_PATTERN , outputDirPath ( ) , numFiles , time , SERVER_NAME ) ; \ntry { \nfileTimeOut . set ( false ) ; \noutputStream = streamCreator ( ) ; \nfileStartTime . set ( time ) ; \nbytesTransferred = 0 ; \nbytesSinceLastFlush = 0 ; \n} \ncatch ( Exception ex ) { \ncleanupOutputStream ( ) ; \nerror . set ( true ) ; \nExceptions . handle ( ex ) ; \n} \nfinally { \nnumFiles = numFiles + 1 ; \n} \n} \n} \n"}
{"7349": "public class BeanUtils { \npublic static Object getPropByPath ( Object item , String ... path ) { \nObject o = item ; \nfor ( int index = 0 ; \nindex < path . length ; \nindex = index + 1 ) { \nString propName = path [ index ] ; \nif ( o == null ) { \nreturn null ; \n} \nelse if ( o . getClass ( ) . isArray ( ) || o instanceof Collection ) { \no = getCollectionProp ( o , propName , index , path ) ; \nbreak ; \n} \nelse { \no = getProp ( o , propName ) ; \n} \n} \nreturn Conversions . unifyListOrArray ( o ) ; \n} \n} \n"}
{"7354": "public class BeanUtils { \nprivate static Object getCollectionProp ( Object o , String propName , int index , String [ ] path ) { \no = _getFieldValuesFromCollectionOrArray ( o , propName ) ; \nif ( index + 1 == path . length ) { \nreturn o ; \n} \nelse { \nindex = index + 1 ; \nreturn getCollectionProp ( o , path [ index ] , index , path ) ; \n} \n} \n} \n"}
{"7363": "public class EtcdClient { \nprivate void sendHttpRequest ( final Request request , final org . boon . core . Handler < Response > responseHandler ) { \nfinal HttpClientRequest httpClientRequest = httpClient . request ( request . getMethod ( ) , request . uri ( ) , handleResponse ( request , responseHandler ) ) ; \nfinal Runnable runnable = new Runnable ( ) { \n@ Override public void run ( ) { \nif ( ! request . getMethod ( ) . equals ( \"GET\" ) ) { \nhttpClientRequest . putHeader ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) . end ( request . paramBody ( ) ) ; \n} \nelse { \nhttpClientRequest . end ( ) ; \n} \n} \n} \n; \nif ( closed . get ( ) ) { \nthis . scheduledExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nconnect ( ) ; \nint retry = 0 ; \nwhile ( closed . get ( ) ) { \nSys . sleep ( 1000 ) ; \nif ( ! closed . get ( ) ) { \nbreak ; \n} \nretry = retry + 1 ; \nif ( retry > 10 ) { \nbreak ; \n} \nif ( retry % 3 == 0 ) { \nconnect ( ) ; \n} \n} \nif ( ! closed . get ( ) ) { \nrunnable . run ( ) ; \n} \nelse { \nresponseHandler . handle ( new Response ( \"TIMEOUT\" , - 1 , new Error ( - 1 , \"Timeout\" , \"Timeout\" , - 1L ) ) ) ; \n} \n} \n} \n, 10 , TimeUnit . MILLISECONDS ) ; \n} \nelse { \nrunnable . run ( ) ; \n} \n} \n} \n"}
{"7403": "public class TokenAuthenticator { \nprivate void onRequestFailure ( HttpServerExchange serverExchange , PooledConnection connection , IOException e , boolean retry ) { \nlog . debug ( \"Client request failure\" , e ) ; \nIoUtils . safeClose ( connection ) ; \nConnectionPool connectionPool = connectionPools . get ( serverExchange . getIoThread ( ) ) ; \nconnectionPool . release ( connection ) ; \nAuthContext context = serverExchange . getAttachment ( AUTH_CONTEXT_KEY ) ; \nif ( context . retries < MAX_RETRY && retry ) { \ncontext . retries = context . retries + 1 ; \nPooledConnectionWaiter waiter = createWaiter ( serverExchange ) ; \nif ( ! connectionPool . offer ( waiter ) ) { \nendExchange ( serverExchange , INTERNAL_SERVER_ERROR , TOO_MANY_PENDING_REQUESTS ) ; \n} \n} \nelse { \nendExchange ( serverExchange , INTERNAL_SERVER_ERROR , CLIENT_REQUEST_FAILURE ) ; \n} \n} \n} \n"}
{"7406": "public class BucketPoint { \npublic static < T extends BucketPoint > List < T > toList ( Map < Long , T > pointMap , Buckets buckets , BiFunction < Long , Long , T > emptyBucketFactory ) { \nList < T > result = new ArrayList < > ( buckets . getCount ( ) ) ; \nfor ( int index = 0 ; \nindex < buckets . getCount ( ) ; \nindex = index + 1 ) { \nlong from = buckets . getBucketStart ( index ) ; \nT bucketPoint = pointMap . get ( from ) ; \nif ( bucketPoint == null ) { \nlong to = from + buckets . getStep ( ) ; \nbucketPoint = emptyBucketFactory . apply ( from , to ) ; \n} \nresult . add ( bucketPoint ) ; \n} \nreturn result ; \n} \n} \n"}
{"7431": "public class FileSupplier { \npublic static Supplier < File > fromDirectory ( File dir , String prefix , String suffix ) { \nreturn new Supplier < File > ( ) { \nprivate int count ; \n@ Override public File get ( ) { \nreturn new File ( ensureDir ( dir ) , String . format ( \"%s%d%s\" , prefix , count = count + 1 , suffix ) ) ; \n} \n} \n; \n} \n} \n"}
{"7446": "public class Base64 { \nprivate static int removeWhiteSpace ( char [ ] data ) { \nif ( data == null ) { \nreturn 0 ; \n} \nint newSize = 0 ; \nint len = data . length ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nif ( ! isWhiteSpace ( data [ i ] ) ) { \ndata [ newSize = newSize + 1 ] = data [ i ] ; \n} \n} \nreturn newSize ; \n} \n} \n"}
{"7465": "public class SSPTaskNotificationService { \nprivate NotificationResponse mapToNotificationResponse ( PortletRequest request , ResponseEntity < String > response ) { \nConfiguration config = Configuration . builder ( ) . options ( Option . DEFAULT_PATH_LEAF_TO_NULL ) . build ( ) ; \nReadContext readContext = JsonPath . using ( config ) . parse ( response . getBody ( ) ) ; \nString success = readContext . read ( SUCCESS_QUERY ) ; \nif ( ! \"true\" . equalsIgnoreCase ( success ) ) { \nString error = readContext . read ( MESSAGE_QUERY ) ; \nreturn notificationError ( error ) ; \n} \nObject rows = readContext . read ( ROWS_QUERY ) ; \nif ( ! ( rows instanceof JSONArray ) ) { \nthrow new RuntimeException ( \"Expected 'rows' to be an array of tasks\" ) ; \n} \nString source = getNotificationSource ( request ) ; \nList < NotificationEntry > list = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < ( ( JSONArray ) rows ) . size ( ) ; \ni = i + 1 ) { \nNotificationEntry entry = mapNotificationEntry ( readContext , i , source ) ; \nif ( entry != null ) { \nattachActions ( request , entry ) ; \nlist . add ( entry ) ; \n} \n} \nNotificationResponse notification = new NotificationResponse ( ) ; \nif ( ! list . isEmpty ( ) ) { \nNotificationCategory category = getNotificationCategory ( request ) ; \ncategory . addEntries ( list ) ; \nnotification . setCategories ( Arrays . asList ( category ) ) ; \n} \nreturn notification ; \n} \n} \n"}
{"7486": "public class UtilPolygons2D_F64 { \npublic static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { \nrectangle . p0 . set ( polygon . get ( 0 ) ) ; \nrectangle . p1 . set ( polygon . get ( 0 ) ) ; \nfor ( int i = 0 ; \ni < polygon . size ( ) ; \ni = i + 1 ) { \nPoint2D_F64 p = polygon . get ( i ) ; \nif ( p . x < rectangle . p0 . x ) { \nrectangle . p0 . x = p . x ; \n} \nelse if ( p . x > rectangle . p1 . x ) { \nrectangle . p1 . x = p . x ; \n} \nif ( p . y < rectangle . p0 . y ) { \nrectangle . p0 . y = p . y ; \n} \nelse if ( p . y > rectangle . p1 . y ) { \nrectangle . p1 . y = p . y ; \n} \n} \n} \n} \n"}
{"7488": "public class UtilPolygons2D_F64 { \npublic static void vertexAverage ( Polygon2D_F64 input , Point2D_F64 average ) { \naverage . setIdx ( 0 , 0 ) ; \nfor ( int i = 0 ; \ni < input . size ( ) ; \ni = i + 1 ) { \nPoint2D_F64 v = input . vertexes . data [ i ] ; \naverage . x += v . x ; \naverage . y += v . y ; \n} \naverage . x /= input . size ( ) ; \naverage . y /= input . size ( ) ; \n} \n} \n"}
{"7489": "public class UtilPolygons2D_F64 { \npublic static void convexHull ( List < Point2D_F64 > points , Polygon2D_F64 hull ) { \nPoint2D_F64 [ ] array = new Point2D_F64 [ points . size ( ) ] ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni = i + 1 ) { \narray [ i ] = points . get ( i ) ; \n} \nAndrewMonotoneConvexHull_F64 andrew = new AndrewMonotoneConvexHull_F64 ( ) ; \nandrew . process ( array , array . length , hull ) ; \n} \n} \n"}
{"7490": "public class UtilPolygons2D_F64 { \npublic static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { \nfor ( int i = 0 ; \ni < polygon . vertexes . size ( ) ; \n) { \nint j = ( i + 1 ) % polygon . vertexes . size ( ) ; \nint k = ( i + 2 ) % polygon . vertexes . size ( ) ; \nPoint2D_F64 p0 = polygon . vertexes . get ( i ) ; \nPoint2D_F64 p1 = polygon . vertexes . get ( j ) ; \nPoint2D_F64 p2 = polygon . vertexes . get ( k ) ; \ndouble angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; \nif ( angle <= tol ) { \npolygon . vertexes . remove ( j ) ; \nif ( j < i ) i = polygon . vertexes . size ( ) - 1 ; \n} \nelse { \ni = i + 1 ; \n} \n} \n} \n} \n"}
{"7491": "public class UtilPolygons2D_F64 { \npublic static double averageOfClosestPointError ( Polygon2D_F64 model , Polygon2D_F64 target , int numberOfSamples ) { \nLineSegment2D_F64 line = new LineSegment2D_F64 ( ) ; \ndouble cornerLocationsB [ ] = new double [ target . size ( ) + 1 ] ; \ndouble totalLength = 0 ; \nfor ( int i = 0 ; \ni < target . size ( ) ; \ni = i + 1 ) { \nPoint2D_F64 b0 = target . get ( i % target . size ( ) ) ; \nPoint2D_F64 b1 = target . get ( ( i + 1 ) % target . size ( ) ) ; \ncornerLocationsB [ i ] = totalLength ; \ntotalLength += b0 . distance ( b1 ) ; \n} \ncornerLocationsB [ target . size ( ) ] = totalLength ; \nPoint2D_F64 pointOnB = new Point2D_F64 ( ) ; \ndouble error = 0 ; \nint cornerB = 0 ; \nfor ( int k = 0 ; \nk < numberOfSamples ; \nk = k + 1 ) { \ndouble location = totalLength * k / numberOfSamples ; \nwhile ( location > cornerLocationsB [ cornerB + 1 ] ) { \ncornerB = cornerB + 1 ; \n} \nPoint2D_F64 b0 = target . get ( cornerB ) ; \nPoint2D_F64 b1 = target . get ( ( cornerB + 1 ) % target . size ( ) ) ; \ndouble locationCornerB = cornerLocationsB [ cornerB ] ; \ndouble fraction = ( location - locationCornerB ) / ( cornerLocationsB [ cornerB + 1 ] - locationCornerB ) ; \npointOnB . x = ( b1 . x - b0 . x ) * fraction + b0 . x ; \npointOnB . y = ( b1 . y - b0 . y ) * fraction + b0 . y ; \ndouble best = Double . MAX_VALUE ; \nfor ( int i = 0 ; \ni < model . size ( ) + 1 ; \ni = i + 1 ) { \nline . a = model . get ( i % model . size ( ) ) ; \nline . b = model . get ( ( i + 1 ) % model . size ( ) ) ; \ndouble d = Distance2D_F64 . distance ( line , pointOnB ) ; \nif ( d < best ) { \nbest = d ; \n} \n} \nerror += best ; \n} \nreturn error / numberOfSamples ; \n} \n} \n"}
{"7515": "public class FitPlane3D_F64 { \npublic boolean svd ( List < Point3D_F64 > points , Point3D_F64 outputCenter , Vector3D_F64 outputNormal ) { \nfinal int N = points . size ( ) ; \noutputCenter . set ( 0 , 0 , 0 ) ; \nfor ( int i = 0 ; \ni < N ; \ni = i + 1 ) { \nPoint3D_F64 p = points . get ( i ) ; \noutputCenter . x += p . x ; \noutputCenter . y += p . y ; \noutputCenter . z += p . z ; \n} \noutputCenter . x /= N ; \noutputCenter . y /= N ; \noutputCenter . z /= N ; \nreturn solvePoint ( points , outputCenter , outputNormal ) ; \n} \n} \n"}
{"7516": "public class FitPlane3D_F64 { \npublic boolean solvePoint ( List < Point3D_F64 > points , Point3D_F64 pointOnPlane , Vector3D_F64 outputNormal ) { \nfinal int N = points . size ( ) ; \nA . reshape ( N , 3 ) ; \nint index = 0 ; \nfor ( int i = 0 ; \ni < N ; \ni = i + 1 ) { \nPoint3D_F64 p = points . get ( i ) ; \nA . data [ index = index + 1 ] = p . x - pointOnPlane . x ; \nA . data [ index = index + 1 ] = p . y - pointOnPlane . y ; \nA . data [ index = index + 1 ] = p . z - pointOnPlane . z ; \n} \nif ( ! solverNull . process ( A , 1 , nullspace ) ) return false ; \noutputNormal . x = ( double ) nullspace . unsafe_get ( 0 , 0 ) ; \noutputNormal . y = ( double ) nullspace . unsafe_get ( 1 , 0 ) ; \noutputNormal . z = ( double ) nullspace . unsafe_get ( 2 , 0 ) ; \nreturn true ; \n} \n} \n"}
{"7533": "public class AndrewMonotoneConvexHull_F64 { \npublic void process ( Point2D_F64 [ ] input , int length , Polygon2D_F64 hull ) { \nif ( length == 2 ) { \nhull . vertexes . resize ( length ) ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nhull . get ( i ) . set ( input [ i ] ) ; \n} \nreturn ; \n} \nsorter . sort ( input , length ) ; \nwork . reset ( ) ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( work . size ( ) >= 2 && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nint minSize = work . size + 2 ; \nfor ( int i = length - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( work . size ( ) >= minSize && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nhull . vertexes . resize ( work . size ) ; \nfor ( int i = 0 ; \ni < work . size ( ) ; \ni = i + 1 ) { \nhull . vertexes . data [ i ] . set ( work . get ( i ) ) ; \n} \n} \n} \n"}
{"7548": "public class SePointOps_F64 { \npublic static void transform ( Se2_F64 se , Point2D_F64 points [ ] , int length ) { \ndouble tranX = se . getX ( ) ; \ndouble tranY = se . getY ( ) ; \nfinal double c = se . getCosineYaw ( ) ; \nfinal double s = se . getSineYaw ( ) ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nPoint2D_F64 pt = points [ i ] ; \ndouble x = pt . x ; \ndouble y = pt . y ; \npt . x = tranX + x * c - y * s ; \npt . y = tranY + x * s + y * c ; \n} \n} \n} \n"}
{"7565": "public class GeoTuple_F64 { \npublic boolean isIdentical ( T t , double tol ) { \nif ( t . getDimension ( ) != getDimension ( ) ) return false ; \nint N = getDimension ( ) ; \nfor ( int i = 0 ; \ni < N ; \ni = i + 1 ) { \ndouble diff = Math . abs ( getIdx ( i ) - t . getIdx ( i ) ) ; \nif ( diff > tol ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"7566": "public class GeoTuple_F64 { \n@ Override public T copy ( ) { \nT ret = createNewInstance ( ) ; \nint N = getDimension ( ) ; \nfor ( int i = 0 ; \ni < N ; \ni = i + 1 ) { \nret . setIdx ( i , getIdx ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7567": "public class GeoTuple_F64 { \npublic double normSq ( ) { \ndouble total = 0 ; \nint N = getDimension ( ) ; \nfor ( int i = 0 ; \ni < N ; \ni = i + 1 ) { \ndouble a = getIdx ( i ) ; \ntotal += a * a ; \n} \nreturn total ; \n} \n} \n"}
{"7574": "public class UtilPoint4D_F64 { \npublic static List < Point4D_F64 > randomN ( Point3D_F64 center , double w , double stdev , int num , Random rand ) { \nList < Point4D_F64 > ret = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < num ; \ni = i + 1 ) { \nPoint4D_F64 p = new Point4D_F64 ( ) ; \np . x = center . x + rand . nextGaussian ( ) * stdev ; \np . y = center . y + rand . nextGaussian ( ) * stdev ; \np . z = center . z + rand . nextGaussian ( ) * stdev ; \np . w = w ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7595": "public class Distance2D_F64 { \npublic static double distanceSq ( Polygon2D_F64 poly , Point2D_F64 p , LineSegment2D_F64 storage ) { \nif ( storage == null ) storage = LineSegment2D_F64 . wrap ( null , null ) ; \ndouble minimum = Double . MAX_VALUE ; \nfor ( int i = 0 ; \ni < poly . size ( ) ; \ni = i + 1 ) { \nint j = ( i + 1 ) % poly . size ( ) ; \nstorage . a = poly . vertexes . data [ i ] ; \nstorage . b = poly . vertexes . data [ j ] ; \ndouble d = distanceSq ( storage , p ) ; \nif ( d < minimum ) minimum = d ; \n} \nreturn minimum ; \n} \n} \n"}
{"7602": "public class FitPolynomialSolverTall_F64 { \npublic boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { \nint N = length / 2 ; \nint numCoefs = output . size ( ) ; \nA . reshape ( N , numCoefs ) ; \nb . reshape ( N , 1 ) ; \nx . reshape ( numCoefs , 1 ) ; \nint end = offset + length ; \nfor ( int i = offset , idxA = 0 ; \ni < end ; \ni += 2 ) { \ndouble x = data [ i ] ; \ndouble y = data [ i + 1 ] ; \ndouble pow = 1.0 ; \nfor ( int j = 0 ; \nj < numCoefs ; \nj = j + 1 ) { \nA . data [ idxA = idxA + 1 ] = pow ; \npow *= x ; \n} \nb . data [ i / 2 ] = y ; \n} \nif ( ! solver . setA ( A ) ) return false ; \nsolver . solve ( b , x ) ; \nfor ( int i = 0 ; \ni < numCoefs ; \ni = i + 1 ) { \noutput . set ( i , x . data [ i ] ) ; \n} \nreturn true ; \n} \n} \n"}
{"7607": "public class UtilVector3D_F64 { \npublic static DMatrixRMaj createMatrix ( DMatrixRMaj R , Vector3D_F64 ... v ) { \nif ( R == null ) { \nR = new DMatrixRMaj ( 3 , v . length ) ; \n} \nfor ( int i = 0 ; \ni < v . length ; \ni = i + 1 ) { \nR . set ( 0 , i , v [ i ] . x ) ; \nR . set ( 1 , i , v [ i ] . y ) ; \nR . set ( 2 , i , v [ i ] . z ) ; \n} \nreturn R ; \n} \n} \n"}
{"7614": "public class Area2D_F64 { \npublic static double polygonSimple ( Polygon2D_F64 poly ) { \ndouble total = 0 ; \nPoint2D_F64 v0 = poly . get ( 0 ) ; \nPoint2D_F64 v1 = poly . get ( 1 ) ; \nfor ( int i = 2 ; \ni < poly . size ( ) ; \ni = i + 1 ) { \nPoint2D_F64 v2 = poly . get ( i ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nv0 = v1 ; \nv1 = v2 ; \n} \nPoint2D_F64 v2 = poly . get ( 0 ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nv0 = v1 ; \nv1 = v2 ; \nv2 = poly . get ( 1 ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nreturn Math . abs ( total / 2.0 ) ; \n} \n} \n"}
{"7615": "public class UtilPoint2D_F64 { \npublic static Point2D_F64 mean ( Point2D_F64 [ ] list , int offset , int length , Point2D_F64 mean ) { \nif ( mean == null ) mean = new Point2D_F64 ( ) ; \ndouble x = 0 ; \ndouble y = 0 ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nPoint2D_F64 p = list [ offset + i ] ; \nx += p . getX ( ) ; \ny += p . getY ( ) ; \n} \nx /= length ; \ny /= length ; \nmean . set ( x , y ) ; \nreturn mean ; \n} \n} \n"}
{"7616": "public class UtilPoint2D_F64 { \npublic static List < Point2D_F64 > orderCCW ( List < Point2D_F64 > points ) { \nPoint2D_F64 center = mean ( points , null ) ; \ndouble angles [ ] = new double [ points . size ( ) ] ; \nfor ( int i = 0 ; \ni < angles . length ; \ni = i + 1 ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - center . x ; \ndouble dy = p . y - center . y ; \nangles [ i ] = Math . atan2 ( dy , dx ) ; \n} \nint order [ ] = new int [ points . size ( ) ] ; \nQuickSort_F64 sorter = new QuickSort_F64 ( ) ; \nsorter . sort ( angles , 0 , points . size ( ) , order ) ; \nList < Point2D_F64 > out = new ArrayList < Point2D_F64 > ( points . size ( ) ) ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni = i + 1 ) { \nout . add ( points . get ( order [ i ] ) ) ; \n} \nreturn out ; \n} \n} \n"}
{"7617": "public class UtilPoint2D_F64 { \npublic static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { \nif ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) { \nif ( covariance instanceof ReshapeMatrix ) { \n( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Must be a 2x2 matrix\" ) ; \n} \n} \nmean ( points , mean ) ; \ndouble xx = 0 , xy = 0 , yy = 0 ; \nfor ( int i = 0 ; \ni < points . size ( ) ; \ni = i + 1 ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - mean . x ; \ndouble dy = p . y - mean . y ; \nxx += dx * dx ; \nxy += dx * dy ; \nyy += dy * dy ; \n} \nxx /= points . size ( ) ; \nxy /= points . size ( ) ; \nyy /= points . size ( ) ; \ncovariance . unsafe_set ( 0 , 0 , xx ) ; \ncovariance . unsafe_set ( 0 , 1 , xy ) ; \ncovariance . unsafe_set ( 1 , 0 , xy ) ; \ncovariance . unsafe_set ( 1 , 1 , yy ) ; \n} \n} \n"}
{"7618": "public class UtilPolygons2D_I32 { \npublic static boolean isConvex ( Polygon2D_I32 poly ) { \nfinal int N = poly . size ( ) ; \nint numPositive = 0 ; \nfor ( int i = 0 ; \ni < N ; \ni = i + 1 ) { \nint j = ( i + 1 ) % N ; \nint k = ( i + 2 ) % N ; \nPoint2D_I32 a = poly . vertexes . data [ i ] ; \nPoint2D_I32 b = poly . vertexes . data [ j ] ; \nPoint2D_I32 c = poly . vertexes . data [ k ] ; \nint dx0 = a . x - b . x ; \nint dy0 = a . y - b . y ; \nint dx1 = c . x - b . x ; \nint dy1 = c . y - b . y ; \nint z = dx0 * dy1 - dy0 * dx1 ; \nif ( z > 0 ) numPositive = numPositive + 1 ; \n} \nreturn ( numPositive == 0 || numPositive == N ) ; \n} \n} \n"}
{"7623": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > random ( PlaneNormal3D_F64 plane , double max , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \nVector3D_F64 axisX = new Vector3D_F64 ( ) ; \nVector3D_F64 axisY = new Vector3D_F64 ( ) ; \nUtilPlane3D_F64 . selectAxis2D ( plane . n , axisX , axisY ) ; \nfor ( int i = 0 ; \ni < num ; \ni = i + 1 ) { \ndouble x = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; \ndouble y = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = plane . p . x + axisX . x * x + axisY . x * y ; \np . y = plane . p . y + axisX . y * x + axisY . y * y ; \np . z = plane . p . z + axisX . z * x + axisY . z * y ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7624": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > random ( Point3D_F64 mean , double minX , double maxX , double minY , double maxY , double minZ , double maxZ , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < num ; \ni = i + 1 ) { \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = mean . x + rand . nextDouble ( ) * ( maxX - minX ) + minX ; \np . y = mean . y + rand . nextDouble ( ) * ( maxY - minY ) + minY ; \np . z = mean . z + rand . nextDouble ( ) * ( maxZ - minZ ) + minZ ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7625": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > randomN ( Point3D_F64 mean , double stdX , double stdY , double stdZ , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < num ; \ni = i + 1 ) { \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = mean . x + rand . nextGaussian ( ) * stdX ; \np . y = mean . y + rand . nextGaussian ( ) * stdY ; \np . z = mean . z + rand . nextGaussian ( ) * stdZ ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7627": "public class UtilPoint3D_F64 { \npublic static Point3D_F64 mean ( List < Point3D_F64 > points , int num , Point3D_F64 mean ) { \nif ( mean == null ) mean = new Point3D_F64 ( ) ; \ndouble x = 0 , y = 0 , z = 0 ; \nfor ( int i = 0 ; \ni < num ; \ni = i + 1 ) { \nPoint3D_F64 p = points . get ( i ) ; \nx += p . x ; \ny += p . y ; \nz += p . z ; \n} \nmean . x = x / num ; \nmean . y = y / num ; \nmean . z = z / num ; \nreturn mean ; \n} \n} \n"}
{"7633": "public class InstallFeatureUtil { \nprivate Set < String > getServerXmlFeatures ( Set < String > origResult , File serverFile , List < File > parsedXmls ) { \nSet < String > result = origResult ; \nList < File > updatedParsedXmls = parsedXmls != null ? parsedXmls : new ArrayList < File > ( ) ; \nFile canonicalServerFile ; \ntry { \ncanonicalServerFile = serverFile . getCanonicalFile ( ) ; \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be accessed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nupdatedParsedXmls . add ( canonicalServerFile ) ; \nif ( canonicalServerFile . exists ( ) ) { \ntry { \nDocument doc = new XmlDocument ( ) { \npublic Document getDocument ( File file ) throws IOException , ParserConfigurationException , SAXException { \ncreateDocument ( file ) ; \nreturn doc ; \n} \n} \n. getDocument ( canonicalServerFile ) ; \nElement root = doc . getDocumentElement ( ) ; \nNodeList nodes = root . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nodes . getLength ( ) ; \ni = i + 1 ) { \nif ( nodes . item ( i ) instanceof Element ) { \nElement child = ( Element ) nodes . item ( i ) ; \nif ( \"featureManager\" . equals ( child . getNodeName ( ) ) ) { \nif ( result == null ) { \nresult = new HashSet < String > ( ) ; \n} \nresult . addAll ( parseFeatureManagerNode ( child ) ) ; \n} \nelse if ( \"include\" . equals ( child . getNodeName ( ) ) ) { \nresult = parseIncludeNode ( result , canonicalServerFile , child , updatedParsedXmls ) ; \n} \n} \n} \n} \ncatch ( IOException | ParserConfigurationException | SAXException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be parsed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7635": "public class InstallFeatureUtil { \nprivate static Set < String > parseFeatureManagerNode ( Element node ) { \nSet < String > result = new HashSet < String > ( ) ; \nNodeList features = node . getElementsByTagName ( \"feature\" ) ; \nif ( features != null ) { \nfor ( int j = 0 ; \nj < features . getLength ( ) ; \nj = j + 1 ) { \nString content = features . item ( j ) . getTextContent ( ) ; \nif ( content != null ) { \nif ( content . contains ( \":\" ) ) { \nString [ ] split = content . split ( \":\" , 2 ) ; \nresult . add ( split [ 1 ] . trim ( ) . toLowerCase ( ) ) ; \n} \nelse { \nresult . add ( content . trim ( ) . toLowerCase ( ) ) ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"7645": "public class InstallFeatureUtil { \nprivate static int compare ( String version1 , String version2 ) { \nif ( version1 == null && version2 == null ) { \nreturn 0 ; \n} \nelse if ( version1 == null && version2 != null ) { \nreturn - 1 ; \n} \nelse if ( version1 != null && version2 == null ) { \nreturn 1 ; \n} \nString [ ] components1 = version1 . split ( \"\\\\.\" ) ; \nString [ ] components2 = version2 . split ( \"\\\\.\" ) ; \nfor ( int i = 0 ; \ni < components1 . length && i < components2 . length ; \ni = i + 1 ) { \nint comparison ; \ntry { \ncomparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; \n} \ncatch ( NumberFormatException e ) { \ncomparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; \n} \nif ( comparison != 0 ) { \nreturn comparison ; \n} \n} \nreturn components1 . length - components2 . length ; \n} \n} \n"}
{"7656": "public class Puzzle { \npublic int getDistanceToGoal ( ) { \nint distance = 0 ; \nfor ( int i = 0 ; \ni < cells . length ; \ni = i + 1 ) { \ndistance += getDistance ( i , cells [ i ] ) ; \n} \nreturn distance ; \n} \n} \n"}
{"7663": "public class StdRandom { \npublic static int poisson ( double lambda ) { \nif ( ! ( lambda > 0.0 ) ) throw new IllegalArgumentException ( \"Parameter lambda must be positive\" ) ; \nif ( Double . isInfinite ( lambda ) ) throw new IllegalArgumentException ( \"Parameter lambda must not be infinite\" ) ; \nint k = 0 ; \ndouble p = 1.0 ; \ndouble L = Math . exp ( - lambda ) ; \ndo { \nk = k + 1 ; \np *= uniform ( ) ; \n} \nwhile ( p >= L ) ; \nreturn k - 1 ; \n} \n} \n"}
{"7664": "public class StdRandom { \npublic static int discrete ( double [ ] a ) { \nif ( a == null ) throw new NullPointerException ( \"argument array is null\" ) ; \ndouble EPSILON = 1E-14 ; \ndouble sum = 0.0 ; \nfor ( int i = 0 ; \ni < a . length ; \ni = i + 1 ) { \nif ( ! ( a [ i ] >= 0.0 ) ) throw new IllegalArgumentException ( \"array entry \" + i + \" must be nonnegative: \" + a [ i ] ) ; \nsum = sum + a [ i ] ; \n} \nif ( sum > 1.0 + EPSILON || sum < 1.0 - EPSILON ) throw new IllegalArgumentException ( \"sum of array entries does not approximately equal 1.0: \" + sum ) ; \nwhile ( true ) { \ndouble r = uniform ( ) ; \nsum = 0.0 ; \nfor ( int i = 0 ; \ni < a . length ; \ni = i + 1 ) { \nsum = sum + a [ i ] ; \nif ( sum > r ) return i ; \n} \n} \n} \n} \n"}
{"7665": "public class StdRandom { \npublic static void main ( String [ ] args ) { \nint N = Integer . parseInt ( args [ 0 ] ) ; \nif ( args . length == 2 ) StdRandom . setSeed ( Long . parseLong ( args [ 1 ] ) ) ; \ndouble [ ] t = { \n.5 , .3 , .1 , .1 } \n; \nStdOut . println ( \"seed = \" + StdRandom . getSeed ( ) ) ; \nfor ( int i = 0 ; \ni < N ; \ni = i + 1 ) { \nStdOut . printf ( \"%2d \" , uniform ( 100 ) ) ; \nStdOut . printf ( \"%8.5f \" , uniform ( 10.0 , 99.0 ) ) ; \nStdOut . printf ( \"%5b \" , bernoulli ( .5 ) ) ; \nStdOut . printf ( \"%7.5f \" , gaussian ( 9.0 , .2 ) ) ; \nStdOut . printf ( \"%2d \" , discrete ( t ) ) ; \nStdOut . println ( ) ; \n} \nString [ ] a = \"A B C D E F G\" . split ( \" \" ) ; \nfor ( String s : a ) StdOut . print ( s + \" \" ) ; \nStdOut . println ( ) ; \n} \n} \n"}
{"7685": "public class RobeExceptionMapper { \n@ Override public Response toResponse ( Exception e ) { \nString id = System . nanoTime ( ) + \"\" ; \nLOGGER . error ( id , e ) ; \nif ( e instanceof RobeRuntimeException ) { \nreturn ( ( RobeRuntimeException ) e ) . getResponse ( id ) ; \n} \nelse if ( e instanceof ConstraintViolationException ) { \nConstraintViolationException exception = ( ConstraintViolationException ) e ; \nRobeMessage [ ] errors = new RobeMessage [ exception . getConstraintViolations ( ) . size ( ) ] ; \nint i = 0 ; \nfor ( ConstraintViolation error : exception . getConstraintViolations ( ) ) { \nerrors [ i = i + 1 ] = new RobeMessage . Builder ( ) . message ( error . getMessage ( ) ) . status ( 422 ) . id ( id ) . build ( ) ; \n} \nreturn Response . status ( 422 ) . entity ( errors ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse if ( e instanceof WebApplicationException ) { \nWebApplicationException we = ( WebApplicationException ) e ; \nRobeMessage error = new RobeMessage . Builder ( ) . id ( id ) . message ( we . getMessage ( ) ) . status ( we . getResponse ( ) . getStatus ( ) ) . build ( ) ; \nreturn Response . fromResponse ( we . getResponse ( ) ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse { \nif ( e . getClass ( ) . getName ( ) . equals ( \"org.hibernate.exception.ConstraintViolationException\" ) ) { \nif ( e . getCause ( ) != null && e . getCause ( ) . getMessage ( ) != null ) { \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getCause ( ) . getMessage ( ) . split ( \"for\" ) [ 0 ] ) . status ( Response . Status . CONFLICT . getStatusCode ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . CONFLICT ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \n} \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getMessage ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . INTERNAL_SERVER_ERROR ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \n} \n} \n"}
{"7689": "public class MailSender { \npublic void sendMessage ( MailItem item ) throws MessagingException { \ncheckNotNull ( item . getReceivers ( ) ) ; \ncheckNotNull ( item . getReceivers ( ) . get ( 0 ) ) ; \ncheckNotNull ( item . getTitle ( ) ) ; \ncheckNotNull ( item . getBody ( ) ) ; \nMessage msg = new MimeMessage ( session ) ; \nif ( item . getSender ( ) == null || item . getSender ( ) . length ( ) == 0 ) { \nitem . setSender ( configuration . getProperties ( ) . get ( configuration . getUsernameKey ( ) ) . toString ( ) ) ; \n} \nInternetAddress from = new InternetAddress ( item . getSender ( ) ) ; \nmsg . setFrom ( from ) ; \nInternetAddress [ ] to = new InternetAddress [ item . getReceivers ( ) . size ( ) ] ; \nfor ( int i = 0 ; \ni < item . getReceivers ( ) . size ( ) ; \ni = i + 1 ) { \nto [ i ] = new InternetAddress ( item . getReceivers ( ) . get ( i ) ) ; \n} \nmsg . setRecipients ( Message . RecipientType . TO , to ) ; \nmsg . setSubject ( item . getTitle ( ) ) ; \nMimeBodyPart body = new MimeBodyPart ( ) ; \nbody . setContent ( item . getBody ( ) , \"text/html; charset=UTF-8\" ) ; \nMultipart content = new MimeMultipart ( ) ; \ncontent . addBodyPart ( body ) ; \nif ( item . getAttachments ( ) != null && item . getAttachments ( ) . size ( ) > 0 ) { \nfor ( DataSource attachment : item . getAttachments ( ) ) { \nBodyPart itemBodyPart = new MimeBodyPart ( ) ; \nitemBodyPart . setDataHandler ( new DataHandler ( attachment ) ) ; \nitemBodyPart . setFileName ( attachment . getName ( ) ) ; \ncontent . addBodyPart ( itemBodyPart ) ; \n} \n} \nmsg . setContent ( content ) ; \nmsg . saveChanges ( ) ; \nTransport . send ( msg ) ; \nfor ( Map . Entry < String , String [ ] > entry : item . getHeaders ( ) . entrySet ( ) ) { \nString [ ] value = msg . getHeader ( entry . getKey ( ) ) ; \nif ( value != null ) { \nentry . setValue ( value ) ; \n} \n} \n} \n} \n"}
{"7700": "public class Query { \npublic static < E > Holder < E > configureFieldByName ( Criteria < E > criteria , String name ) { \nif ( Validations . isEmptyOrNull ( name ) ) return null ; \nString [ ] names = name . split ( \"\\\\.\" ) ; \nString currentName ; \nint step = 0 ; \nCriteriaParent < E > currentCriteria = criteria ; \nFieldMeta currentFieldMeta ; \nStringJoiner aliasJoiner = new StringJoiner ( \"$\" ) ; \ndo { \ncurrentName = names [ step ] ; \nif ( Validations . isEmptyOrNull ( currentName ) ) { \nthrow new RuntimeException ( currentName + \" defined name is wrong ! \" ) ; \n} \ncurrentFieldMeta = criteria . getMeta ( ) . getFieldMap ( ) . get ( currentName ) ; \nstep = step + 1 ; \naliasJoiner . add ( currentCriteria . getAlias ( ) ) ; \nif ( step >= names . length ) { \nbreak ; \n} \nif ( currentFieldMeta . getReference ( ) == null ) { \nthrow new RuntimeException ( \"\" + currentName + \" join field of \" + name + \"'s reference target information must defined ! \" ) ; \n} \nCriteriaJoin < E > criteriaJoin = currentCriteria . getJoin ( currentName ) ; \nif ( criteriaJoin == null ) { \ncurrentCriteria . createJoin ( currentName , currentFieldMeta . getReference ( ) . getTargetEntity ( ) , currentFieldMeta . getReference ( ) . getReferenceId ( ) ) ; \n} \ncurrentCriteria = criteriaJoin ; \n} \nwhile ( step >= names . length ) ; \nHolder < E > holder = new Holder < > ( ) ; \nholder . currentFieldName = currentName ; \nholder . currentCriteria = currentCriteria ; \nholder . currentFieldMeta = currentFieldMeta ; \nreturn holder ; \n} \n} \n"}
{"7723": "public class MD4 { \nprivate void addPadding ( ) { \nint len = BLOCK_LENGTH - bufferLen ; \nif ( len < 9 ) { \nlen += BLOCK_LENGTH ; \n} \nbyte [ ] buf = new byte [ len ] ; \nbuf [ 0 ] = ( byte ) 0x80 ; \nfor ( int i = 1 ; \ni < len - 8 ; \ni = i + 1 ) { \nbuf [ i ] = ( byte ) 0x00 ; \n} \ncounter = ( counter + ( long ) bufferLen ) * 8L ; \nLittleEndian . encode ( counter , buf , len - 8 ) ; \nupdate ( buf ) ; \n} \n} \n"}
{"7726": "public class Passwords { \npublic static boolean verify ( String password , byte [ ] hash ) { \nbyte [ ] h = Arrays . copyOf ( hash , HASH_LENGTH + SALT_LENGTH + 3 ) ; \nint n = 1 << ( h [ HASH_LENGTH + SALT_LENGTH ] & 0xFF ) ; \nint r = h [ HASH_LENGTH + SALT_LENGTH + 1 ] & 0xFF ; \nint p = h [ HASH_LENGTH + SALT_LENGTH + 2 ] & 0xFF ; \nif ( n > N || n < N_MIN || r > R || r < R_MIN || p > P || p < P_MIN ) { \nn = N ; \nr = R ; \np = P ; \n} \nbyte [ ] salt = new byte [ SALT_LENGTH ] ; \nSystem . arraycopy ( h , HASH_LENGTH , salt , 0 , SALT_LENGTH ) ; \nbyte [ ] expected = hash ( password , salt , r , n , p ) ; \nint result = 0 ; \nfor ( int i = 0 ; \ni < h . length ; \ni = i + 1 ) { \nresult |= h [ i ] ^ expected [ i ] ; \n} \nreturn result == 0 ; \n} \n} \n"}
{"7735": "public class Numbers { \npublic static long max ( long ... values ) { \nParameters . checkCondition ( values . length > 0 ) ; \nlong max = values [ 0 ] ; \nfor ( int i = 1 ; \ni < values . length ; \ni = i + 1 ) { \nmax = Math . max ( max , values [ i ] ) ; \n} \nreturn max ; \n} \n} \n"}
{"7736": "public class Numbers { \npublic static long min ( long ... values ) { \nParameters . checkCondition ( values . length > 0 ) ; \nlong min = values [ 0 ] ; \nfor ( int i = 1 ; \ni < values . length ; \ni = i + 1 ) { \nmin = Math . min ( min , values [ i ] ) ; \n} \nreturn min ; \n} \n} \n"}
{"7741": "public class LocationForecastHelper { \npublic List < MeteoExtrasForecast > findHourlyPointForecastsFromNow ( int hoursAhead ) { \nList < MeteoExtrasForecast > pointExtrasForecasts = new ArrayList < > ( ) ; \nZonedDateTime now = getNow ( ) ; \nfor ( int i = 0 ; \ni < hoursAhead ; \ni = i + 1 ) { \nZonedDateTime ahead = now . plusHours ( i ) ; \nOptional < PointForecast > pointForecast = getIndexer ( ) . getPointForecast ( ahead ) ; \npointForecast . ifPresent ( pof -> { \nOptional < PeriodForecast > periodForecast = getIndexer ( ) . getTightestFitPeriodForecast ( pof . getFrom ( ) ) ; \nperiodForecast . ifPresent ( pef -> pointExtrasForecasts . add ( new MeteoExtrasForecast ( pof , pef ) ) ) ; \n} \n) ; \n} \nreturn pointExtrasForecasts ; \n} \n} \n"}
{"7744": "public class LongtermForecastHelper { \npublic MeteoExtrasLongTermForecast createSimpleLongTermForecast ( ) throws MeteoException { \nList < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; \nZonedDateTime dt = getNow ( ) ; \nfor ( int i = 0 ; \ni <= 6 ; \ni = i + 1 ) { \nZonedDateTime dti = dt . plusDays ( i ) ; \nif ( getIndexer ( ) . hasForecastsForDay ( dti ) ) { \nMeteoExtrasForecastDay mefd = createSimpleForcastForDay ( dti ) ; \nif ( mefd != null && mefd . getForecasts ( ) . size ( ) > 0 ) { \nforecastDays . add ( mefd ) ; \n} \n} \n} \nreturn new MeteoExtrasLongTermForecast ( forecastDays ) ; \n} \n} \n"}
{"7745": "public class LongtermForecastHelper { \npublic MeteoExtrasLongTermForecast createLongTermForecast ( ) { \nList < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; \nZonedDateTime dt = toZeroHMSN ( getLocationForecast ( ) . getCreated ( ) . plusDays ( 1 ) ) ; \nfor ( int i = 0 ; \ni < series . getSeries ( ) . size ( ) ; \ni = i + 1 ) { \ncreateLongTermForecastDay ( dt . plusDays ( i ) , series . getSeries ( ) . get ( i ) ) . ifPresent ( forecastDays :: add ) ; \n} \nreturn new MeteoExtrasLongTermForecast ( forecastDays ) ; \n} \n} \n"}
{"7774": "public class Runtime { \nprivate boolean cfindloop ( Dfa d , Dfa s , int [ ] coldp ) { \nint begin ; \nint end ; \nint cold ; \nint open ; \nint close ; \nint estart ; \nint estop ; \nboolean shorter = 0 != ( g . tree . flags & Subre . SHORTER ) ; \nboolean hitend [ ] = new boolean [ 1 ] ; \nboolean lookingAt = 0 != ( eflags & Flags . REG_LOOKING_AT ) ; \nassert d != null && s != null ; \nclose = 0 ; \ndo { \nint [ ] cold0 = new int [ 1 ] ; \nif ( lookingAt ) { \nclose = d . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = 0 ; \n} \nelse { \nclose = s . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = cold0 [ 0 ] ; \n} \nif ( close == - 1 ) { \nbreak ; \n} \nassert cold != - 1 ; \nopen = cold ; \ncold = - 1 ; \nfor ( begin = open ; \nbegin <= close ; \nbegin = begin + 1 ) { \nif ( begin > 0 && lookingAt ) { \nreturn false ; \n} \nestart = begin ; \nestop = data . length ( ) ; \nfor ( ; \n; \n) { \nif ( shorter ) { \nend = d . shortest ( begin , estart , estop , null , hitend ) ; \n} \nelse { \nend = d . longest ( begin , estop , hitend ) ; \n} \nif ( hitend [ 0 ] && cold == - 1 ) { \ncold = begin ; \n} \nif ( end == - 1 ) { \nbreak ; \n} \nfor ( int x = 0 ; \nx < match . size ( ) ; \nx = x + 1 ) { \nmatch . set ( x , null ) ; \n} \nint maxsubno = getMaxSubno ( g . tree , 0 ) ; \nmem = new int [ maxsubno + 1 ] ; \nboolean matched = cdissect ( g . tree , begin , end ) ; \nif ( matched ) { \nmatch . set ( 0 , new RegMatch ( begin , end ) ) ; \ncoldp [ 0 ] = cold ; \nreturn true ; \n} \nif ( shorter ? end == estop : end == begin ) { \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \nif ( shorter ) { \nestart = end + 1 ; \n} \nelse { \nestop = end - 1 ; \n} \n} \n} \n} \nwhile ( close < data . length ( ) ) ; \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \n} \n"}
{"7777": "public class Runtime { \nprivate boolean cbrdissect ( RuntimeSubexpression t , int begin , int end ) { \nint i ; \nint n = t . number ; \nint len ; \nint paren ; \nint p ; \nint stop ; \nint min = t . min ; \nint max = t . max ; \nassert t . op == 'b' ; \nassert n >= 0 ; \nif ( match . get ( n ) == null ) { \nreturn false ; \n} \nparen = match . get ( n ) . start ; \nlen = match . get ( n ) . end - match . get ( n ) . start ; \nif ( 0 != mem [ t . retry ] ) { \nreturn false ; \n} \nmem [ t . retry ] = 1 ; \nif ( len == 0 ) { \nreturn begin == end ; \n} \nassert end >= begin ; \nif ( ( end - begin ) < len ) { \nreturn false ; \n} \nstop = end - len ; \ni = 0 ; \nfor ( p = begin ; \np <= stop && ( i < max || max == Compiler . INFINITY ) ; \np += len ) { \nif ( g . compare . compare ( data , paren , p , len ) != 0 ) { \nbreak ; \n} \ni = i + 1 ; \n} \nif ( p != end ) { \nreturn false ; \n} \nreturn min <= i && ( i <= max || max == Compiler . INFINITY ) ; \n} \n} \n"}
{"7791": "public class Compiler { \nprivate void dovec ( UnicodeSet set , State lp , State rp ) throws RegexException { \nint rangeCount = set . getRangeCount ( ) ; \nfor ( int rx = 0 ; \nrx < rangeCount ; \nrx = rx + 1 ) { \nint rangeStart = set . getRangeStart ( rx ) ; \nint rangeEnd = set . getRangeEnd ( rx ) ; \nif ( LOG . isDebugEnabled ( ) && IS_DEBUG ) { \nLOG . debug ( String . format ( \"%s %d %4x %4x\" , set , rx , rangeStart , rangeEnd ) ) ; \n} \nif ( rangeStart == rangeEnd ) { \nnfa . newarc ( PLAIN , cm . subcolor ( rangeStart ) , lp , rp ) ; \n} \ncm . subrange ( rangeStart , rangeEnd , lp , rp ) ; \n} \n} \n} \n"}
{"7794": "public class ColorMap { \nvoid subrange ( int from , int to , State lp , State rp ) throws RegexException { \nMap < Range < Integer > , Short > curColors = map . subRangeMap ( Range . closed ( from , to ) ) . asMapOfRanges ( ) ; \nList < Range < Integer > > ranges = Lists . newArrayList ( curColors . keySet ( ) ) ; \nfor ( Range < Integer > rangeToProcess : ranges ) { \nint start = rangeToProcess . lowerEndpoint ( ) ; \nif ( rangeToProcess . lowerBoundType ( ) == BoundType . OPEN ) { \nstart = start + 1 ; \n} \nint end = rangeToProcess . upperEndpoint ( ) ; \nif ( rangeToProcess . upperBoundType ( ) == BoundType . CLOSED ) { \nend = end + 1 ; \n} \nshort color = subcolor ( start , end - start ) ; \ncompiler . getNfa ( ) . newarc ( Compiler . PLAIN , color , lp , rp ) ; \n} \n} \n} \n"}
{"7795": "public class ColorMap { \nvoid okcolors ( Nfa nfa ) { \nColorDesc cd ; \nColorDesc scd ; \nArc a ; \nshort sco ; \nfor ( short co = 0 ; \nco < colorDescs . size ( ) ; \nco = co + 1 ) { \ncd = colorDescs . get ( co ) ; \nif ( cd == null ) { \ncontinue ; \n} \nsco = cd . sub ; \nif ( sco == Constants . NOSUB ) { \n} \nelse if ( sco == co ) { \n} \nelse if ( cd . getNChars ( ) == 0 ) { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nwhile ( ( a = cd . arcs ) != null ) { \nassert a . co == co ; \ncd . arcs = a . colorchain ; \na . setColor ( sco ) ; \na . colorchain = scd . arcs ; \nscd . arcs = a ; \n} \nfreecolor ( co ) ; \n} \nelse { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nfor ( a = cd . arcs ; \na != null ; \na = a . colorchain ) { \nassert a . co == co ; \nnfa . newarc ( a . type , sco , a . from , a . to ) ; \n} \n} \n} \n} \n} \n"}
{"7798": "public class ColorMap { \nvoid dumpcolors ( ) { \nfor ( int co = 0 ; \nco < colorDescs . size ( ) ; \nco = co + 1 ) { \nColorDesc cd = colorDescs . get ( co ) ; \nif ( cd != null ) { \ndumpcolor ( co , cd ) ; \n} \n} \n} \n} \n"}
{"7800": "public class Lex { \nvoid prefixes ( ) throws RegexException { \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nreturn ; \n} \nif ( have ( 4 ) && next3 ( '*' , '*' , '*' ) ) { \nswitch ( charAtNowPlus ( 3 ) ) { \ncase '?' : throw new RegexException ( \"REG_BADPAT\" ) ; \ncase '=' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \nv . now += 4 ; \nreturn ; \ncase ':' : v . note ( Flags . REG_UNONPOSIX ) ; \nv . cflags |= Flags . REG_ADVANCED ; \nv . now += 4 ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADRPT\" ) ; \n} \n} \nif ( ( v . cflags & Flags . REG_ADVANCED ) != Flags . REG_ADVANCED ) { \nreturn ; \n} \nif ( have ( 3 ) && next2 ( '(' , '?' ) && iscalpha ( charAtNowPlus ( 2 ) ) ) { \nv . note ( Flags . REG_UNONPOSIX ) ; \nv . now += 2 ; \nfor ( ; \n! ateos ( ) && iscalpha ( charAtNow ( ) ) ; \nv . now = v . now + 1 ) { \nswitch ( charAtNow ( ) ) { \ncase 'b' : v . cflags &= ~ ( Flags . REG_ADVANCED | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'c' : v . cflags &= ~ Flags . REG_ICASE ; \nbreak ; \ncase 'e' : v . cflags |= Flags . REG_EXTENDED ; \nv . cflags &= ~ ( Flags . REG_ADVF | Flags . REG_QUOTE ) ; \nbreak ; \ncase 'i' : v . cflags |= Flags . REG_ICASE ; \nbreak ; \ncase 'm' : case 'n' : v . cflags |= Flags . REG_NEWLINE ; \nbreak ; \ncase 'p' : v . cflags |= Flags . REG_NLSTOP ; \nv . cflags &= ~ Flags . REG_NLANCH ; \nbreak ; \ncase 'q' : v . cflags |= Flags . REG_QUOTE ; \nv . cflags &= ~ Flags . REG_ADVANCED ; \nbreak ; \ncase 's' : v . cflags &= ~ Flags . REG_NEWLINE ; \nbreak ; \ncase 't' : v . cflags &= ~ Flags . REG_EXPANDED ; \nbreak ; \ncase 'w' : v . cflags &= ~ Flags . REG_NLSTOP ; \nv . cflags |= Flags . REG_NLANCH ; \nbreak ; \ncase 'x' : v . cflags |= Flags . REG_EXPANDED ; \nbreak ; \ndefault : throw new RegexException ( \"REG_BADOPT\" ) ; \n} \n} \nif ( ! next1 ( ')' ) ) { \nthrow new RegexException ( \"REG_BADOPT\" ) ; \n} \nv . now = v . now + 1 ; \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nv . cflags &= ~ ( Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ; \n} \n} \n} \n} \n"}
{"7807": "public class CnfaBuilder { \nvoid carcsort ( int first , int last ) { \nint p ; \nint q ; \nlong tmp ; \nif ( last - first <= 1 ) { \nreturn ; \n} \nfor ( p = first ; \np <= last ; \np = p + 1 ) { \nfor ( q = p ; \nq <= last ; \nq = q + 1 ) { \nshort pco = Cnfa . carcColor ( arcs [ p ] ) ; \nshort qco = Cnfa . carcColor ( arcs [ q ] ) ; \nint pto = Cnfa . carcTarget ( arcs [ p ] ) ; \nint qto = Cnfa . carcTarget ( arcs [ q ] ) ; \nif ( pco > qco || ( pco == qco && pto > qto ) ) { \nassert p != q ; \ntmp = arcs [ p ] ; \narcs [ p ] = arcs [ q ] ; \narcs [ q ] = tmp ; \n} \n} \n} \n} \n} \n"}
{"7809": "public class Nfa { \nState newstate ( int flag ) { \nState newState = new State ( ) ; \nnewState . no = nstates = nstates + 1 ; \nif ( states == null ) { \nstates = newState ; \n} \nif ( slast != null ) { \nassert slast . next == null ; \nslast . next = newState ; \n} \nnewState . prev = slast ; \nslast = newState ; \nnewState . flag = flag ; \nreturn newState ; \n} \n} \n"}
{"7822": "public class Nfa { \nint dumprarcs ( Arc a , State s , int pos , StringBuilder sb ) { \nif ( a . outchain != null ) { \npos = dumprarcs ( a . outchain , s , pos , sb ) ; \n} \ndumparc ( a , s , sb ) ; \nif ( pos == 5 ) { \nsb . append ( \"\\n\" ) ; \npos = 1 ; \n} \nelse { \npos = pos + 1 ; \n} \nreturn pos ; \n} \n} \n"}
{"7827": "public class Nfa { \nvoid cleanup ( ) { \nState s ; \nState nexts ; \nint n ; \nmarkreachable ( pre , null , pre ) ; \nmarkcanreach ( post , pre , post ) ; \nfor ( s = states ; \ns != null ; \ns = nexts ) { \nnexts = s . next ; \nif ( s . tmp != post && 0 == s . flag ) { \ndropstate ( s ) ; \n} \n} \nassert post . nins == 0 || post . tmp == post ; \ncleartraverse ( pre ) ; \nassert post . nins == 0 || post . tmp == null ; \nn = 0 ; \nfor ( s = states ; \ns != null ; \ns = s . next ) { \ns . no = n = n + 1 ; \n} \nnstates = n ; \n} \n} \n"}
{"7879": "public class JSPContextFinder { \nArrayList basicFindClassLoaders ( ) { \nClass [ ] stack = contextFinder . getClassContext ( ) ; \nArrayList result = new ArrayList ( 1 ) ; \nClassLoader previousLoader = null ; \nfor ( int i = 1 ; \ni < stack . length ; \ni = i + 1 ) { \nClassLoader tmp = stack [ i ] . getClassLoader ( ) ; \nif ( checkClass ( stack [ i ] ) && tmp != null && tmp != this ) { \nif ( checkClassLoader ( tmp ) ) { \nif ( previousLoader != tmp ) { \nresult . add ( tmp ) ; \npreviousLoader = tmp ; \n} \n} \nif ( Activator . getBundle ( stack [ i ] ) != null ) break ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7892": "public class SeekableXZInputStream { \nprivate void locateBlockByPos ( BlockInfo info , long pos ) { \nif ( pos < 0 || pos >= uncompressedSize ) throw new IndexOutOfBoundsException ( \"Invalid uncompressed position: \" + pos ) ; \nIndexDecoder index ; \nfor ( int i = 0 ; \n; \ni = i + 1 ) { \nindex = streams . get ( i ) ; \nif ( index . hasUncompressedOffset ( pos ) ) break ; \n} \nindex . locateBlock ( info , pos ) ; \nassert ( info . compressedOffset & 3 ) == 0 ; \nassert info . uncompressedSize > 0 ; \nassert pos >= info . uncompressedOffset ; \nassert pos < info . uncompressedOffset + info . uncompressedSize ; \n} \n} \n"}
{"7894": "public class LZMAEncoderNormal { \nprivate void updateOptStateAndReps ( ) { \nint optPrev = opts [ optCur ] . optPrev ; \nassert optPrev < optCur ; \nif ( opts [ optCur ] . prev1IsLiteral ) { \noptPrev = optPrev - 1 ; \nif ( opts [ optCur ] . hasPrev2 ) { \nopts [ optCur ] . state . set ( opts [ opts [ optCur ] . optPrev2 ] . state ) ; \nif ( opts [ optCur ] . backPrev2 < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nopts [ optCur ] . state . updateLiteral ( ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nif ( optPrev == optCur - 1 ) { \nassert opts [ optCur ] . backPrev == 0 || opts [ optCur ] . backPrev == - 1 ; \nif ( opts [ optCur ] . backPrev == 0 ) opts [ optCur ] . state . updateShortRep ( ) ; \nelse opts [ optCur ] . state . updateLiteral ( ) ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 0 , REPS ) ; \n} \nelse { \nint back ; \nif ( opts [ optCur ] . prev1IsLiteral && opts [ optCur ] . hasPrev2 ) { \noptPrev = opts [ optCur ] . optPrev2 ; \nback = opts [ optCur ] . backPrev2 ; \nopts [ optCur ] . state . updateLongRep ( ) ; \n} \nelse { \nback = opts [ optCur ] . backPrev ; \nif ( back < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nif ( back < REPS ) { \nopts [ optCur ] . reps [ 0 ] = opts [ optPrev ] . reps [ back ] ; \nint rep ; \nfor ( rep = 1 ; \nrep <= back ; \nrep = rep + 1 ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep - 1 ] ; \nfor ( ; \nrep < REPS ; \nrep = rep + 1 ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep ] ; \n} \nelse { \nopts [ optCur ] . reps [ 0 ] = back - REPS ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 1 , REPS - 1 ) ; \n} \n} \n} \n} \n"}
{"7895": "public class LZMAEncoderNormal { \nprivate void calc1BytePrices ( int pos , int posState , int avail , int anyRepPrice ) { \nboolean nextIsByte = false ; \nint curByte = lz . getByte ( 0 ) ; \nint matchByte = lz . getByte ( opts [ optCur ] . reps [ 0 ] + 1 ) ; \nint literalPrice = opts [ optCur ] . price + literalEncoder . getPrice ( curByte , matchByte , lz . getByte ( 1 ) , pos , opts [ optCur ] . state ) ; \nif ( literalPrice < opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( literalPrice , optCur , - 1 ) ; \nnextIsByte = true ; \n} \nif ( matchByte == curByte && ( opts [ optCur + 1 ] . optPrev == optCur || opts [ optCur + 1 ] . backPrev != 0 ) ) { \nint shortRepPrice = getShortRepPrice ( anyRepPrice , opts [ optCur ] . state , posState ) ; \nif ( shortRepPrice <= opts [ optCur + 1 ] . price ) { \nopts [ optCur + 1 ] . set1 ( shortRepPrice , optCur , 0 ) ; \nnextIsByte = true ; \n} \n} \nif ( ! nextIsByte && matchByte != curByte && avail > MATCH_LEN_MIN ) { \nint lenLimit = Math . min ( niceLen , avail - 1 ) ; \nint len = lz . getMatchLen ( 1 , opts [ optCur ] . reps [ 0 ] , lenLimit ) ; \nif ( len >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + 1 ) & posMask ; \nint price = literalPrice + getLongRepAndLenPrice ( 0 , len , nextState , nextPosState ) ; \nint i = optCur + 1 + len ; \nwhile ( optEnd < i ) opts [ optEnd = optEnd + 1 ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set2 ( price , optCur , 0 ) ; \n} \n} \n} \n} \n"}
{"7896": "public class LZMAEncoderNormal { \nprivate int calcLongRepPrices ( int pos , int posState , int avail , int anyRepPrice ) { \nint startLen = MATCH_LEN_MIN ; \nint lenLimit = Math . min ( avail , niceLen ) ; \nfor ( int rep = 0 ; \nrep < REPS ; \nrep = rep + 1 ) { \nint len = lz . getMatchLen ( opts [ optCur ] . reps [ rep ] , lenLimit ) ; \nif ( len < MATCH_LEN_MIN ) continue ; \nwhile ( optEnd < optCur + len ) opts [ optEnd = optEnd + 1 ] . reset ( ) ; \nint longRepPrice = getLongRepPrice ( anyRepPrice , rep , opts [ optCur ] . state , posState ) ; \nfor ( int i = len ; \ni >= MATCH_LEN_MIN ; \ni = i - 1 ) { \nint price = longRepPrice + repLenEncoder . getPrice ( i , posState ) ; \nif ( price < opts [ optCur + i ] . price ) opts [ optCur + i ] . set1 ( price , optCur , rep ) ; \n} \nif ( rep == 0 ) startLen = len + 1 ; \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , opts [ optCur ] . reps [ rep ] , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nint price = longRepPrice + repLenEncoder . getPrice ( len , posState ) ; \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLongRep ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nprice += literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nwhile ( optEnd < i ) opts [ optEnd = optEnd + 1 ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , rep , len , 0 ) ; \n} \n} \nreturn startLen ; \n} \n} \n"}
{"7897": "public class LZMAEncoderNormal { \nprivate void calcNormalMatchPrices ( int pos , int posState , int avail , int anyMatchPrice , int startLen ) { \nif ( matches . len [ matches . count - 1 ] > avail ) { \nmatches . count = 0 ; \nwhile ( matches . len [ matches . count ] < avail ) matches . count = matches . count + 1 ; \nmatches . len [ matches . count = matches . count + 1 ] = avail ; \n} \nif ( matches . len [ matches . count - 1 ] < startLen ) return ; \nwhile ( optEnd < optCur + matches . len [ matches . count - 1 ] ) opts [ optEnd = optEnd + 1 ] . reset ( ) ; \nint normalMatchPrice = getNormalMatchPrice ( anyMatchPrice , opts [ optCur ] . state ) ; \nint match = 0 ; \nwhile ( startLen > matches . len [ match ] ) match = match + 1 ; \nfor ( int len = startLen ; \n; \nlen = len + 1 ) { \nint dist = matches . dist [ match ] ; \nint matchAndLenPrice = getMatchAndLenPrice ( normalMatchPrice , dist , len , posState ) ; \nif ( matchAndLenPrice < opts [ optCur + len ] . price ) opts [ optCur + len ] . set1 ( matchAndLenPrice , optCur , dist + REPS ) ; \nif ( len != matches . len [ match ] ) continue ; \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , dist , len2Limit ) ; \nif ( len2 >= MATCH_LEN_MIN ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateMatch ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nint price = matchAndLenPrice + literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nwhile ( optEnd < i ) opts [ optEnd = optEnd + 1 ] . reset ( ) ; \nif ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , dist + REPS , len , 0 ) ; \n} \nif ( match = match + 1 == matches . count ) break ; \n} \n} \n} \n"}
{"7919": "public class Parser { \nprivate String parseQuoted ( String tx ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint size = tx . length ( ) ; \nint i = 0 ; \nwhile ( i < size ) { \nchar ch = tx . charAt ( i ) ; \nif ( ch == '&' ) { \nif ( i + 5 < size && tx . charAt ( i + 1 ) == 'a' && tx . charAt ( i + 2 ) == 'p' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 's' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\\'' ) ; \ni += 6 ; \n} \nelse if ( i + 5 < size && tx . charAt ( i + 1 ) == 'q' && tx . charAt ( i + 2 ) == 'u' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 't' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\"' ) ; \ni += 6 ; \n} \nelse { \nbuf . append ( ch ) ; \ni = i + 1 ; \n} \n} \nelse if ( ch == '\\\\' && i + 1 < size ) { \nch = tx . charAt ( i + 1 ) ; \nif ( ch == '\\\\' || ch == '\\\"' || ch == '\\'' || ch == '>' ) { \nbuf . append ( ch ) ; \ni += 2 ; \n} \nelse { \nbuf . append ( '\\\\' ) ; \ni = i + 1 ; \n} \n} \nelse { \nbuf . append ( ch ) ; \ni = i + 1 ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"7941": "public class StorageManager { \npublic StorageRegistration registerModel ( final long lockPriority , final MetaKey key , final StorageModelProvider < ? , ? > storageProvider ) throws ModelInitializationException { \nthis . modelLock . writeLock ( ) . lock ( ) ; \ntry { \ntestClosed ( ) ; \nif ( this . modelKeyMap . containsKey ( key ) ) { \nthrow new IllegalArgumentException ( String . format ( \"A provider for '%s' is already registered\" , key ) ) ; \n} \ntry { \nstorageProvider . start ( this . context ) ; \n} \ncatch ( final Exception e ) { \nthrow new ModelInitializationException ( \"Failed to start model provider: \" + key , e ) ; \n} \nfinal long id = this . counter = this . counter + 1 ; \nfinal Entry entry = new Entry ( id , lockPriority , key , storageProvider ) ; \nthis . modelIdMap . put ( id , entry ) ; \nthis . modelKeyMap . put ( key , entry ) ; \nreturn new StorageRegistration ( ) { \n@ Override public void unregister ( ) { \nunregisterModel ( id ) ; \n} \n} \n; \n} \nfinally { \nthis . modelLock . writeLock ( ) . unlock ( ) ; \n} \n} \n} \n"}
{"7961": "public class JspC { \npublic void scanFiles ( File base ) throws JasperException { \nStack < String > dirs = new Stack < String > ( ) ; \ndirs . push ( base . toString ( ) ) ; \nif ( extensions == null ) { \nextensions = new ArrayList < String > ( ) ; \nextensions . add ( \"jsp\" ) ; \nextensions . add ( \"jspx\" ) ; \n} \nwhile ( ! dirs . isEmpty ( ) ) { \nString s = dirs . pop ( ) ; \nFile f = new File ( s ) ; \nif ( f . exists ( ) && f . isDirectory ( ) ) { \nString [ ] files = f . list ( ) ; \nString ext ; \nfor ( int i = 0 ; \n( files != null ) && i < files . length ; \ni = i + 1 ) { \nFile f2 = new File ( s , files [ i ] ) ; \nif ( f2 . isDirectory ( ) ) { \ndirs . push ( f2 . getPath ( ) ) ; \n} \nelse { \nString path = f2 . getPath ( ) ; \nString uri = path . substring ( uriRoot . length ( ) ) ; \next = files [ i ] . substring ( files [ i ] . lastIndexOf ( '.' ) + 1 ) ; \nif ( extensions . contains ( ext ) || jspConfig . isJspPage ( uri ) ) { \npages . add ( path ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"7964": "public class HC4 { \nprivate int movePos ( ) { \nint avail = movePos ( 4 , 4 ) ; \nif ( avail != 0 ) { \nif ( lzPos = lzPos + 1 == Integer . MAX_VALUE ) { \nint normalizationOffset = Integer . MAX_VALUE - cyclicSize ; \nhash . normalize ( normalizationOffset ) ; \nnormalize ( chain , cyclicSize , normalizationOffset ) ; \nlzPos -= normalizationOffset ; \n} \nif ( cyclicPos = cyclicPos + 1 == cyclicSize ) cyclicPos = 0 ; \n} \nreturn avail ; \n} \n} \n"}
{"7965": "public class JspReader { \nboolean matches ( String string ) throws JasperException { \nMark mark = mark ( ) ; \nint ch = 0 ; \nint i = 0 ; \ndo { \nch = nextChar ( ) ; \nif ( ( ( char ) ch ) != string . charAt ( i = i + 1 ) ) { \nreset ( mark ) ; \nreturn false ; \n} \n} \nwhile ( i < string . length ( ) ) ; \nreturn true ; \n} \n} \n"}
{"7967": "public class JspReader { \nMark skipUntil ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , ch = nextChar ( ) ) { \nif ( ch == limit . charAt ( 0 ) ) { \nMark restart = mark ( ) ; \nfor ( int i = 1 ; \ni < limlen ; \ni = i + 1 ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse { \nreset ( restart ) ; \ncontinue skip ; \n} \n} \nreturn ret ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7968": "public class JspReader { \nMark skipUntilIgnoreEsc ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nint prev = 'x' ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , prev = ch , ch = nextChar ( ) ) { \nif ( ch == '\\\\' && prev == '\\\\' ) { \nch = 0 ; \n} \nelse if ( ch == limit . charAt ( 0 ) && prev != '\\\\' ) { \nfor ( int i = 1 ; \ni < limlen ; \ni = i + 1 ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse continue skip ; \n} \nreturn ret ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7975": "public class ParserUtils { \npublic static void setSchemaResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \nschemaResourcePrefix = uencode ( prefix ) ; \nisSchemaResourcePrefixFileUrl = true ; \n} \nelse { \nschemaResourcePrefix = prefix ; \nisSchemaResourcePrefixFileUrl = false ; \n} \nfor ( int i = 0 ; \ni < CACHED_SCHEMA_RESOURCE_PATHS . length ; \ni = i + 1 ) { \nString path = DEFAULT_SCHEMA_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_SCHEMA_RESOURCE_PATHS [ i ] = schemaResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \n} \n} \n"}
{"7976": "public class ParserUtils { \npublic static void setDtdResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \ndtdResourcePrefix = uencode ( prefix ) ; \nisDtdResourcePrefixFileUrl = true ; \n} \nelse { \ndtdResourcePrefix = prefix ; \nisDtdResourcePrefixFileUrl = false ; \n} \nfor ( int i = 0 ; \ni < CACHED_DTD_RESOURCE_PATHS . length ; \ni = i + 1 ) { \nString path = DEFAULT_DTD_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_DTD_RESOURCE_PATHS [ i ] = dtdResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \n} \n} \n"}
{"7978": "public class ParserUtils { \nprotected TreeNode convert ( TreeNode parent , Node node ) { \nTreeNode treeNode = new TreeNode ( node . getNodeName ( ) , parent ) ; \nNamedNodeMap attributes = node . getAttributes ( ) ; \nif ( attributes != null ) { \nint n = attributes . getLength ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nNode attribute = attributes . item ( i ) ; \ntreeNode . addAttribute ( attribute . getNodeName ( ) , attribute . getNodeValue ( ) ) ; \n} \n} \nNodeList children = node . getChildNodes ( ) ; \nif ( children != null ) { \nint n = children . getLength ( ) ; \nfor ( int i = 0 ; \ni < n ; \ni = i + 1 ) { \nNode child = children . item ( i ) ; \nif ( child instanceof Comment ) continue ; \nif ( child instanceof Text ) { \nString body = ( ( Text ) child ) . getData ( ) ; \nif ( body != null ) { \nbody = body . trim ( ) ; \nif ( body . length ( ) > 0 ) treeNode . setBody ( body ) ; \n} \n} \nelse { \nTreeNode treeChild = convert ( treeNode , child ) ; \n} \n} \n} \nreturn ( treeNode ) ; \n} \n} \n"}
{"7991": "public class XMLEncodingDetector { \nprivate void scanXMLDecl ( ) throws IOException , JasperException { \nif ( skipString ( \"<?xml\" ) ) { \nfMarkupDepth = fMarkupDepth + 1 ; \nif ( XMLChar . isName ( peekChar ( ) ) ) { \nfStringBuffer . clear ( ) ; \nfStringBuffer . append ( \"xml\" ) ; \nwhile ( XMLChar . isName ( peekChar ( ) ) ) { \nfStringBuffer . append ( ( char ) scanChar ( ) ) ; \n} \nString target = fSymbolTable . addSymbol ( fStringBuffer . ch , fStringBuffer . offset , fStringBuffer . length ) ; \nscanPIData ( target , fString ) ; \n} \nelse { \nscanXMLDeclOrTextDecl ( false ) ; \n} \n} \n} \n} \n"}
{"7996": "public class JspCServletContext { \npublic Set < String > getResourcePaths ( String path ) { \nSet < String > thePaths = new HashSet < String > ( ) ; \nif ( ! path . endsWith ( \"/\" ) ) path += \"/\" ; \nString basePath = getRealPath ( path ) ; \nif ( basePath == null ) return ( thePaths ) ; \nFile theBaseDir = new File ( basePath ) ; \nif ( ! theBaseDir . exists ( ) || ! theBaseDir . isDirectory ( ) ) return ( thePaths ) ; \nString theFiles [ ] = theBaseDir . list ( ) ; \nfor ( int i = 0 ; \ni < theFiles . length ; \ni = i + 1 ) { \nFile testFile = new File ( basePath + File . separator + theFiles [ i ] ) ; \nif ( testFile . isFile ( ) ) thePaths . add ( path + theFiles [ i ] ) ; \nelse if ( testFile . isDirectory ( ) ) thePaths . add ( path + theFiles [ i ] + \"/\" ) ; \n} \nreturn ( thePaths ) ; \n} \n} \n"}
{"8005": "public class LZEncoder { \npublic int getMatchLen ( int dist , int lenLimit ) { \nint backPos = readPos - dist - 1 ; \nint len = 0 ; \nwhile ( len < lenLimit && buf [ readPos + len ] == buf [ backPos + len ] ) len = len + 1 ; \nreturn len ; \n} \n} \n"}
{"8006": "public class LZEncoder { \npublic int getMatchLen ( int forward , int dist , int lenLimit ) { \nint curPos = readPos + forward ; \nint backPos = curPos - dist - 1 ; \nint len = 0 ; \nwhile ( len < lenLimit && buf [ curPos + len ] == buf [ backPos + len ] ) len = len + 1 ; \nreturn len ; \n} \n} \n"}
{"8007": "public class LZEncoder { \npublic boolean verifyMatches ( Matches matches ) { \nint lenLimit = Math . min ( getAvail ( ) , matchLenMax ) ; \nfor ( int i = 0 ; \ni < matches . count ; \ni = i + 1 ) if ( getMatchLen ( matches . dist [ i ] , lenLimit ) != matches . len [ i ] ) return false ; \nreturn true ; \n} \n} \n"}
{"8008": "public class LZEncoder { \nint movePos ( int requiredForFlushing , int requiredForFinishing ) { \nassert requiredForFlushing >= requiredForFinishing ; \nreadPos = readPos + 1 ; \nint avail = writePos - readPos ; \nif ( avail < requiredForFlushing ) { \nif ( avail < requiredForFinishing || ! finishing ) { \npendingSize = pendingSize + 1 ; \navail = 0 ; \n} \n} \nreturn avail ; \n} \n} \n"}
{"8025": "public class Generator { \nprivate void compileTagHandlerPoolList ( Node . Nodes page ) throws JasperException { \nclass TagHandlerPoolVisitor extends Node . Visitor { \nprivate Set < String > names = new HashSet < String > ( ) ; \nTagHandlerPoolVisitor ( Set < String > v ) { \nnames = v ; \n} \npublic void visit ( Node . CustomTag n ) throws JasperException { \nif ( ! n . implementsSimpleTag ( ) ) { \nString name = createTagHandlerPoolName ( n . getPrefix ( ) , n . getLocalName ( ) , n . getAttributes ( ) , n . hasEmptyBody ( ) ) ; \nn . setTagHandlerPoolName ( name ) ; \nif ( ! names . contains ( name ) ) { \nnames . add ( name ) ; \n} \n} \nvisitBody ( n ) ; \n} \nprivate String createTagHandlerPoolName ( String prefix , String shortName , Attributes attrs , boolean hasEmptyBody ) { \nString poolName = null ; \npoolName = \"_jspx_tagPool_\" + prefix + \"_\" + shortName ; \nif ( attrs != null ) { \nString [ ] attrNames = new String [ attrs . getLength ( ) ] ; \nfor ( int i = 0 ; \ni < attrNames . length ; \ni = i + 1 ) { \nattrNames [ i ] = attrs . getQName ( i ) ; \n} \nArrays . sort ( attrNames , Collections . reverseOrder ( ) ) ; \nfor ( int i = 0 ; \ni < attrNames . length ; \ni = i + 1 ) { \npoolName = poolName + \"_\" + attrNames [ i ] ; \n} \n} \nif ( hasEmptyBody ) { \npoolName = poolName + \"_nobody\" ; \n} \nreturn JspUtil . makeXmlJavaIdentifier ( poolName ) ; \n} \n} \npage . visit ( new TagHandlerPoolVisitor ( tagHandlerPoolNames ) ) ; \n} \n} \n"}
{"8027": "public class Generator { \nprivate void genCommonPostamble ( ) { \nfor ( int i = 0 ; \ni < methodsBuffered . size ( ) ; \ni = i + 1 ) { \nGenBuffer methodBuffer = methodsBuffered . get ( i ) ; \nmethodBuffer . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( methodBuffer . toString ( ) ) ; \n} \nif ( fragmentHelperClass . isUsed ( ) ) { \nfragmentHelperClass . generatePostamble ( ) ; \nfragmentHelperClass . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( fragmentHelperClass . toString ( ) ) ; \n} \nif ( arrayBuffer != null ) { \nout . printMultiLn ( arrayBuffer . toString ( ) ) ; \n} \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \n} \n} \n"}
{"8030": "public class Generator { \nprivate void generateTagHandlerAttributes ( TagInfo tagInfo ) throws JasperException { \nif ( tagInfo . hasDynamicAttributes ( ) ) { \nout . printil ( \"private java.util.HashMap _jspx_dynamic_attrs = new java.util.HashMap();\" ) ; \n} \nTagAttributeInfo [ ] attrInfos = tagInfo . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attrInfos . length ; \ni = i + 1 ) { \nout . printin ( \"private \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \n} \nout . println ( ) ; \nfor ( int i = 0 ; \ni < attrInfos . length ; \ni = i + 1 ) { \nout . printin ( \"public \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( toGetterMethod ( attrInfos [ i ] . getName ( ) ) ) ; \nout . println ( \" {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \nout . printin ( \"public void \" ) ; \nout . print ( toSetterMethodName ( attrInfos [ i ] . getName ( ) ) ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"(javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( \"(\" ) ; \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \") {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \" = \" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \n} \n} \n} \n"}
{"8033": "public class Validator { \nprivate static void validateXmlView ( PageData xmlView , Compiler compiler ) throws JasperException { \nStringBuilder errMsg = null ; \nErrorDispatcher errDisp = compiler . getErrorDispatcher ( ) ; \nfor ( Iterator < TagLibraryInfo > iter = compiler . getPageInfo ( ) . getTaglibs ( ) . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nTagLibraryInfo o = iter . next ( ) ; \nif ( ! ( o instanceof TagLibraryInfoImpl ) ) continue ; \nTagLibraryInfoImpl tli = ( TagLibraryInfoImpl ) o ; \nValidationMessage [ ] errors = tli . validate ( xmlView ) ; \nif ( ( errors != null ) && ( errors . length != 0 ) ) { \nif ( errMsg == null ) { \nerrMsg = new StringBuilder ( ) ; \n} \nerrMsg . append ( \"<h3>\" ) ; \nerrMsg . append ( Localizer . getMessage ( \"jsp.error.tlv.invalid.page\" , tli . getShortName ( ) ) ) ; \nerrMsg . append ( \"</h3>\" ) ; \nfor ( int i = 0 ; \ni < errors . length ; \ni = i + 1 ) { \nif ( errors [ i ] != null ) { \nerrMsg . append ( \"<p>\" ) ; \nerrMsg . append ( errors [ i ] . getId ( ) ) ; \nerrMsg . append ( \": \" ) ; \nerrMsg . append ( errors [ i ] . getMessage ( ) ) ; \nerrMsg . append ( \"</p>\" ) ; \n} \n} \n} \n} \nif ( errMsg != null ) { \nerrDisp . jspError ( errMsg . toString ( ) ) ; \n} \n} \n} \n"}
{"8034": "public class TagHandlerPool { \npublic < T extends JspTag > JspTag get ( Class < T > handlerClass ) throws JspException { \nsynchronized ( this ) { \nif ( current >= 0 ) { \nreturn handlers [ current = current - 1 ] ; \n} \n} \nJspTag tagHandler = null ; \ntry { \nif ( resourceInjector != null ) { \ntagHandler = resourceInjector . createTagHandlerInstance ( handlerClass ) ; \n} \nelse { \ntagHandler = handlerClass . newInstance ( ) ; \n} \n} \ncatch ( Exception e ) { \nthrow new JspException ( e . getMessage ( ) , e ) ; \n} \nreturn tagHandler ; \n} \n} \n"}
{"8038": "public class ServletWriter { \npublic void printComment ( Mark start , Mark stop , char [ ] chars ) { \nif ( start != null && stop != null ) { \nprintln ( \"// from=\" + start ) ; \nprintln ( \"//   to=\" + stop ) ; \n} \nif ( chars != null ) for ( int i = 0 ; \ni < chars . length ; \n) { \nprintin ( ) ; \nprint ( \"// \" ) ; \nwhile ( chars [ i ] != '\\n' && i < chars . length ) writer . print ( chars [ i = i + 1 ] ) ; \n} \n} \n} \n"}
{"8040": "public class ServletWriter { \npublic void printil ( String s ) { \njavaLine = javaLine + 1 ; \nwriter . print ( SPACES . substring ( 0 , indent ) ) ; \nwriter . println ( s ) ; \n} \n} \n"}
{"8041": "public class ServletWriter { \npublic void printMultiLn ( String s ) { \nint index = 0 ; \nwhile ( ( index = s . indexOf ( '\\n' , index ) ) > - 1 ) { \njavaLine = javaLine + 1 ; \nindex = index + 1 ; \n} \nwriter . print ( s ) ; \n} \n} \n"}
{"8044": "public class JspUtil { \npublic static String escapeXml ( String s ) { \nif ( s == null ) return null ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni = i + 1 ) { \nchar c = s . charAt ( i ) ; \nif ( c == '<' ) { \nsb . append ( \"&lt;\" ) ; \n} \nelse if ( c == '>' ) { \nsb . append ( \"&gt;\" ) ; \n} \nelse if ( c == '\\'' ) { \nsb . append ( \"&apos;\" ) ; \n} \nelse if ( c == '&' ) { \nsb . append ( \"&amp;\" ) ; \n} \nelse if ( c == '\"' ) { \nsb . append ( \"&quot;\" ) ; \n} \nelse { \nsb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8047": "public class JspUtil { \npublic static final String makeJavaPackage ( String path ) { \nString classNameComponents [ ] = split ( path , \"/\" ) ; \nStringBuilder legalClassNames = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < classNameComponents . length ; \ni = i + 1 ) { \nlegalClassNames . append ( makeJavaIdentifier ( classNameComponents [ i ] ) ) ; \nif ( i < classNameComponents . length - 1 ) { \nlegalClassNames . append ( '.' ) ; \n} \n} \nreturn legalClassNames . toString ( ) ; \n} \n} \n"}
{"8048": "public class JspUtil { \nprivate static final String [ ] split ( String path , String pat ) { \nArrayList < String > comps = new ArrayList < String > ( ) ; \nint pos = path . indexOf ( pat ) ; \nint start = 0 ; \nwhile ( pos >= 0 ) { \nif ( pos > start ) { \nString comp = path . substring ( start , pos ) ; \ncomps . add ( comp ) ; \n} \nstart = pos + pat . length ( ) ; \npos = path . indexOf ( pat , start ) ; \n} \nif ( start < path . length ( ) ) { \ncomps . add ( path . substring ( start ) ) ; \n} \nString [ ] result = new String [ comps . size ( ) ] ; \nfor ( int i = 0 ; \ni < comps . size ( ) ; \ni = i + 1 ) { \nresult [ i ] = comps . get ( i ) ; \n} \nreturn result ; \n} \n} \n"}
{"8049": "public class JspUtil { \npublic static final String makeJavaIdentifier ( String identifier ) { \nStringBuilder modifiedIdentifier = new StringBuilder ( identifier . length ( ) ) ; \nif ( ! Character . isJavaIdentifierStart ( identifier . charAt ( 0 ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nfor ( int i = 0 ; \ni < identifier . length ( ) ; \ni = i + 1 ) { \nchar ch = identifier . charAt ( i ) ; \nif ( Character . isJavaIdentifierPart ( ch ) && ch != '_' ) { \nmodifiedIdentifier . append ( ch ) ; \n} \nelse if ( ch == '.' ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nelse { \nmodifiedIdentifier . append ( mangleChar ( ch ) ) ; \n} \n} \nif ( isJavaKeyword ( modifiedIdentifier . toString ( ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nreturn modifiedIdentifier . toString ( ) ; \n} \n} \n"}
{"8084": "public class OutputFormatter { \npublic static int [ ] computeMaximums ( String [ ] headers , OutputFormatter ... outputs ) { \nint [ ] max = new int [ headers . length ] ; \nfor ( int i = 0 ; \ni < headers . length ; \ni = i + 1 ) max [ i ] = headers [ i ] . length ( ) ; \nfor ( OutputFormatter output : outputs ) { \nmax [ 0 ] = Math . max ( output . host . length ( ) , max [ 0 ] ) ; \nfor ( int i = 1 ; \ni < headers . length ; \ni = i + 1 ) max [ i ] = Math . max ( output . results [ i - 1 ] . length ( ) , max [ i ] ) ; \n} \nreturn max ; \n} \n} \n"}
{"8085": "public class OutputFormatter { \npublic static String formatHeader ( int [ ] maximums , String [ ] headers ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < headers . length ; \ni = i + 1 ) sb = sb . append ( formatIn ( headers [ i ] , maximums [ i ] , false ) ) . append ( GAP ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8086": "public class OutputFormatter { \npublic static String [ ] format ( int [ ] maximums , OutputFormatter ... outputs ) { \nString [ ] formattedStrings = new String [ outputs . length ] ; \nint pos = 0 ; \nfor ( OutputFormatter output : outputs ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb = sb . append ( formatIn ( output . host , maximums [ 0 ] , false ) ) ; \nfor ( int i = 0 ; \ni < output . results . length ; \ni = i + 1 ) sb = sb . append ( GAP ) . append ( formatIn ( output . results [ i ] , maximums [ i + 1 ] , true ) ) ; \nformattedStrings [ pos = pos + 1 ] = sb . toString ( ) ; \n} \nreturn formattedStrings ; \n} \n} \n"}
{"8098": "public class CassandraModel { \npublic static Iterable < MetricColumnFamily > getMetricColumnFamilies ( ) { \nreturn new Iterable < MetricColumnFamily > ( ) { \n@ Override public Iterator < MetricColumnFamily > iterator ( ) { \nreturn new Iterator < MetricColumnFamily > ( ) { \nprivate int pos = 0 ; \n@ Override public boolean hasNext ( ) { \nreturn pos < METRIC_COLUMN_FAMILES . length ; \n} \n@ Override public MetricColumnFamily next ( ) { \nreturn METRIC_COLUMN_FAMILES [ pos = pos + 1 ] ; \n} \n@ Override public void remove ( ) { \nthrow new NoSuchMethodError ( \"Not implemented\" ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"8163": "public class NumberUtils { \npublic static boolean isNumeric ( String value , Locale locale ) { \nif ( value == null ) return false ; \nint start = 0 ; \nfinal DecimalFormatSymbols symbols = ( locale != null ) ? DecimalFormatSymbols . getInstance ( locale ) : DecimalFormatSymbols . getInstance ( ) ; \nif ( value . startsWith ( \"+\" ) || value . startsWith ( \"-\" ) ) start = start + 1 ; \nboolean fraction = false ; \nfor ( int i = start ; \ni < value . length ( ) ; \ni = i + 1 ) { \nfinal char c = value . charAt ( i ) ; \nif ( c == symbols . getDecimalSeparator ( ) && ! fraction ) { \nfraction = true ; \ncontinue ; \n} \nif ( c == symbols . getGroupingSeparator ( ) && ! fraction ) { \ncontinue ; \n} \nif ( ! Character . isDigit ( c ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"8205": "public class CsvRecord { \npublic void dump ( Writer writer , String lineSeparator ) throws IOException { \nfor ( int i = 0 ; \ni < this . getRecordLenth ( ) ; \ni = i + 1 ) { \nStringBuilder txt = new StringBuilder ( ) ; \ntry ( StringReader reader = new StringReader ( StringUtils . trimToEmpty ( this . get ( i ) ) ) ) { \nfor ( String line : IOUtils . readLines ( reader ) ) { \nif ( txt . length ( ) > 0 ) txt . append ( lineSeparator ) ; \ntxt . append ( line ) ; \n} \n} \nwriter . write ( i + \":\" + txt . toString ( ) ) ; \nwriter . write ( System . lineSeparator ( ) ) ; \n} \n} \n} \n"}
{"8207": "public class CsvRecord { \nprotected Iterable < String > print ( ) { \nfinal int length = this . getRecordLenth ( ) ; \nList < String > row = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nrow . add ( this . get ( i ) ) ; \n} \nreturn row ; \n} \n} \n"}
{"8349": "public class ObjectUtils { \npublic static boolean isCompatibleWithThrowsClause ( Throwable ex , Class < ? > [ ] declaredExceptions ) { \nif ( ! isCheckedException ( ex ) ) { \nreturn true ; \n} \nif ( declaredExceptions != null ) { \nint i = 0 ; \nwhile ( i < declaredExceptions . length ) { \nif ( declaredExceptions [ i ] . isAssignableFrom ( ex . getClass ( ) ) ) { \nreturn true ; \n} \ni = i + 1 ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8366": "public class CmdLineParser { \npublic final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { \nVector otherArgs = new Vector ( ) ; \nint position = 0 ; \nthis . values = new Hashtable ( 10 ) ; \nwhile ( position < argv . length ) { \nString curArg = argv [ position ] ; \nif ( curArg . startsWith ( \"-\" ) ) { \nif ( curArg . equals ( \"--\" ) ) { \nposition += 1 ; \nbreak ; \n} \nString valueArg = null ; \nif ( curArg . startsWith ( \"--\" ) ) { \nint equalsPos = curArg . indexOf ( \"=\" ) ; \nif ( equalsPos != - 1 ) { \nvalueArg = curArg . substring ( equalsPos + 1 ) ; \ncurArg = curArg . substring ( 0 , equalsPos ) ; \n} \n} \nelse if ( curArg . length ( ) > 2 ) { \nfor ( int i = 1 ; \ni < curArg . length ( ) ; \ni = i + 1 ) { \nOption opt = ( Option ) this . options . get ( \"-\" + curArg . charAt ( i ) ) ; \nif ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; \nif ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; \naddValue ( opt , opt . getValue ( null , locale ) ) ; \n} \nposition = position + 1 ; \ncontinue ; \n} \nOption opt = ( Option ) this . options . get ( curArg ) ; \nif ( opt == null ) { \nthrow new UnknownOptionException ( curArg ) ; \n} \nObject value = null ; \nif ( opt . wantsValue ( ) ) { \nif ( valueArg == null ) { \nposition += 1 ; \nif ( position < argv . length ) { \nvalueArg = argv [ position ] ; \n} \n} \nvalue = opt . getValue ( valueArg , locale ) ; \n} \nelse { \nvalue = opt . getValue ( null , locale ) ; \n} \naddValue ( opt , value ) ; \nposition += 1 ; \n} \nelse { \notherArgs . addElement ( curArg ) ; \nposition += 1 ; \n} \n} \nfor ( ; \nposition < argv . length ; \nposition = position + 1 ) { \notherArgs . addElement ( argv [ position ] ) ; \n} \nthis . remainingArgs = new String [ otherArgs . size ( ) ] ; \notherArgs . copyInto ( remainingArgs ) ; \n} \n} \n"}
{"8367": "public class SingletonLoader { \npublic Object newInstance ( Class c ) throws InstantiationException , IllegalAccessException { \nObject ret = null ; \nMethod [ ] methods = c . getDeclaredMethods ( ) ; \nMethod m ; \nint modifiers ; \nfor ( int i = 0 ; \ni < methods . length ; \ni = i + 1 ) { \nm = methods [ i ] ; \nmodifiers = m . getModifiers ( ) ; \nif ( ( modifiers & Modifier . STATIC ) != 0 ) { \nif ( ( modifiers & Modifier . PUBLIC ) != 0 ) { \nif ( m . getParameterTypes ( ) . length == 0 ) { \nif ( m . getReturnType ( ) == c ) { \nif ( m . getName ( ) . toLowerCase ( ) . indexOf ( \"instance\" ) != - 1 ) { \ntry { \nret = m . invoke ( null , dummyParameters ) ; \n} \ncatch ( IllegalArgumentException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IllegalAccessException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n} \n} \n} \n} \nif ( ret == null ) { \nConstructor [ ] constructors = c . getConstructors ( ) ; \nConstructor con = null ; \nfor ( int i = 0 ; \ni < constructors . length ; \ni = i + 1 ) { \ncon = constructors [ i ] ; \nif ( con . getParameterTypes ( ) . length == 0 ) { \nmodifiers = con . getModifiers ( ) ; \ntry { \nif ( ( modifiers & Modifier . PUBLIC ) == 0 ) { \ncon . setAccessible ( true ) ; \n} \nret = c . newInstance ( ) ; \n} \ncatch ( SecurityException se ) { \n} \n} \n} \n} \nif ( ret == null ) { \nSystem . err . println ( \"Unable to instantiate: \" + c . getName ( ) + \": no singleton method, no public default constructor.\" ) ; \n} \nreturn ret ; \n} \n} \n"}
{"8368": "public class ConcurrencyThrottleSupport { \nprotected void afterAccess ( ) { \nif ( this . concurrencyLimit >= 0 ) { \nsynchronized ( this . monitor ) { \nthis . concurrencyCount = this . concurrencyCount - 1 ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Returning from throttle at concurrency count \" + this . concurrencyCount ) ; \n} \nthis . monitor . notify ( ) ; \n} \n} \n} \n} \n"}
{"8370": "public class MethodInvoker { \npublic void prepare ( ) throws ClassNotFoundException , NoSuchMethodException { \nif ( this . staticMethod != null ) { \nint lastDotIndex = this . staticMethod . lastIndexOf ( '.' ) ; \nif ( lastDotIndex == - 1 || lastDotIndex == this . staticMethod . length ( ) ) { \nthrow new IllegalArgumentException ( \"staticMethod must be a fully qualified class plus method name: \" + \"e.g. 'example.MyExampleClass.myExampleMethod'\" ) ; \n} \nString className = this . staticMethod . substring ( 0 , lastDotIndex ) ; \nString methodName = this . staticMethod . substring ( lastDotIndex + 1 ) ; \nthis . targetClass = resolveClassName ( className ) ; \nthis . targetMethod = methodName ; \n} \nClass < ? > targetClass = getTargetClass ( ) ; \nString targetMethod = getTargetMethod ( ) ; \nif ( targetClass == null ) { \nthrow new IllegalArgumentException ( \"Either 'targetClass' or 'targetObject' is required\" ) ; \n} \nif ( targetMethod == null ) { \nthrow new IllegalArgumentException ( \"Property 'targetMethod' is required\" ) ; \n} \nObject [ ] arguments = getArguments ( ) ; \nClass < ? > [ ] argTypes = new Class < ? > [ arguments . length ] ; \nfor ( int i = 0 ; \ni < arguments . length ; \ni = i + 1 ) { \nargTypes [ i ] = ( arguments [ i ] != null ? arguments [ i ] . getClass ( ) : Object . class ) ; \n} \ntry { \nthis . methodObject = targetClass . getMethod ( targetMethod , argTypes ) ; \n} \ncatch ( NoSuchMethodException ex ) { \nthis . methodObject = findMatchingMethod ( ) ; \nif ( this . methodObject == null ) { \nthrow ex ; \n} \n} \n} \n} \n"}
{"8372": "public class ByteHelper { \nprivate static String toUnsignedString ( int i , int shift ) { \nchar [ ] buf = new char [ 32 ] ; \nint charPos = 32 ; \nint radix = 1 << shift ; \nint mask = radix - 1 ; \ndo { \nbuf [ charPos = charPos - 1 ] = digits [ i & mask ] ; \ni >>>= shift ; \n} \nwhile ( i != 0 ) ; \nreturn new String ( buf , charPos , ( 32 - charPos ) ) ; \n} \n} \n"}
{"8375": "public class DomUtils { \npublic static Element getChildElementByTagName ( Element ele , String childEleName ) { \nAssert . notNull ( ele , \"Element must not be null\" ) ; \nAssert . notNull ( childEleName , \"Element name must not be null\" ) ; \nNodeList nl = ele . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nl . getLength ( ) ; \ni = i + 1 ) { \nNode node = nl . item ( i ) ; \nif ( node instanceof Element && nodeNameMatch ( node , childEleName ) ) { \nreturn ( Element ) node ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8377": "public class DomUtils { \npublic static List < Element > getChildElements ( Element ele ) { \nAssert . notNull ( ele , \"Element must not be null\" ) ; \nNodeList nl = ele . getChildNodes ( ) ; \nList < Element > childEles = new ArrayList < Element > ( ) ; \nfor ( int i = 0 ; \ni < nl . getLength ( ) ; \ni = i + 1 ) { \nNode node = nl . item ( i ) ; \nif ( node instanceof Element ) { \nchildEles . add ( ( Element ) node ) ; \n} \n} \nreturn childEles ; \n} \n} \n"}
{"8390": "public class HorizontalPicker { \npublic void setValues ( CharSequence [ ] values ) { \nif ( this . values != values ) { \nthis . values = values ; \nif ( this . values != null ) { \nlayouts = new BoringLayout [ this . values . length ] ; \nfor ( int i = 0 ; \ni < layouts . length ; \ni = i + 1 ) { \nlayouts [ i ] = new BoringLayout ( this . values [ i ] , textPaint , itemWidth , Layout . Alignment . ALIGN_CENTER , 1f , 1f , boringMetrics , false , ellipsize , itemWidth ) ; \n} \n} \nelse { \nlayouts = new BoringLayout [ 0 ] ; \n} \nif ( getWidth ( ) > 0 ) { \nstartMarqueeIfNeeded ( ) ; \n} \nrequestLayout ( ) ; \ninvalidate ( ) ; \n} \n} \n} \n"}
{"8484": "public class StenoSerializationHelper { \npublic static void writeKeyValuePairs ( @ Nullable final List < String > keys , @ Nullable final List < Object > values , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper , final StenoEncoder encoder ) throws IOException { \nif ( keys != null ) { \nfinal int contextValuesLength = values == null ? 0 : values . size ( ) ; \nfor ( int i = 0 ; \ni < keys . size ( ) ; \ni = i + 1 ) { \nfinal String key = keys . get ( i ) ; \nif ( i >= contextValuesLength ) { \njsonGenerator . writeObjectField ( key , null ) ; \n} \nelse { \nfinal Object value = values . get ( i ) ; \nif ( isSimpleType ( value ) ) { \njsonGenerator . writeObjectField ( key , value ) ; \n} \nelse { \njsonGenerator . writeFieldName ( key ) ; \nobjectMapper . writeValue ( jsonGenerator , value ) ; \n} \n} \n} \n} \n} \n} \n"}
{"8487": "public class AbstractStenoCallerConverter { \nprotected StackTraceElement getCallerData ( final ILoggingEvent loggingEvent ) { \nfinal StackTraceElement [ ] callerData = loggingEvent . getCallerData ( ) ; \nif ( callerData != null ) { \nfor ( int i = 0 ; \ni < callerData . length ; \ni = i + 1 ) { \nfinal String callerClassName = callerData [ i ] . getClassName ( ) ; \nif ( ! callerClassName . startsWith ( STENO_CLASS_NAME_PREFIX ) ) { \nreturn callerData [ i ] ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8522": "public class ShiftFormulaUtility { \npublic static Ptg [ ] convertSharedFormulas ( final Ptg [ ] ptgs , final ShiftFormulaRef shiftFormulaRef ) { \nList < Ptg > newPtgList = new ArrayList < > ( ) ; \nObject ptg ; \nfor ( int k = 0 ; \nk < ptgs . length ; \nk = k + 1 ) { \nptg = ptgs [ k ] ; \nnewPtgList . addAll ( Arrays . asList ( convertPtg ( ptgs , k , shiftFormulaRef , ptg ) ) ) ; \n} \nreturn newPtgList . toArray ( new Ptg [ newPtgList . size ( ) ] ) ; \n} \n} \n"}
{"8529": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForRefPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg , final boolean includeParenthesis ) { \nRefPtgBase refPtg = ( RefPtgBase ) ptg ; \nint unitSize = 1 ; \nif ( includeParenthesis ) { \nunitSize = 2 ; \n} \nfor ( int i = 0 ; \ni < rowList . size ( ) ; \ni = i + 1 ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nif ( refPtg instanceof Ref3DPxg ) { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( row . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nRefPtgBase refPtgBase = refPtg ; \nnewPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \nif ( ( unitSize == 2 ) && ( i < ( rowList . size ( ) - 1 ) ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \n} \n} \n"}
{"8530": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForAreaPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg ) { \nAreaPtgBase areaPtg = ( AreaPtgBase ) ptg ; \nint originFirstRow = areaPtg . getFirstRow ( ) ; \nint originLastRow = areaPtg . getLastRow ( ) ; \nint unitSize = 2 ; \nfor ( int i = 0 ; \ni < rowList . size ( ) ; \ni = i + 1 ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nint shiftRow = row . getRowNum ( ) - originFirstRow ; \nif ( ptg instanceof Area3DPxg ) { \nArea3DPxg area3dPxg = ( Area3DPxg ) ptg ; \nArea3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; \nnew3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; \nnew3dpxg . setFirstRow ( originFirstRow + shiftRow ) ; \nnew3dpxg . setLastRow ( originLastRow + shiftRow ) ; \nnew3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; \nnew3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nAreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; \nnewPtg [ i * unitSize ] = new AreaPtg ( originFirstRow + shiftRow , originLastRow + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; \n} \nif ( i < ( rowList . size ( ) - 1 ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \n} \n} \n"}
{"8555": "public class ChartHelper { \nprivate void initXSSFChartsMap ( final XSSFWorkbook wb , final ChartsData chartsData ) { \ninitAnchorsMap ( wb , chartsData ) ; \nMap < String , ClientAnchor > anchorMap = chartsData . getChartAnchorsMap ( ) ; \nMap < String , BufferedImage > chartMap = chartsData . getChartsMap ( ) ; \nMap < String , ChartData > chartDataMap = chartsData . getChartDataMap ( ) ; \nchartMap . clear ( ) ; \nchartDataMap . clear ( ) ; \nfor ( int i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni = i + 1 ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nList < XSSFChart > charts = drawing . getCharts ( ) ; \nif ( ( charts != null ) && ( ! charts . isEmpty ( ) ) ) { \nfor ( XSSFChart chart : charts ) { \ngenerateSingleXSSFChart ( chart , getChartIdFromParent ( chart , sheet . getSheetName ( ) ) , sheet , anchorMap , chartMap , chartDataMap ) ; \n} \n} \n} \n} \n} \n"}
{"8566": "public class ConfigurationUtility { \npublic static void changeUpperLevelFinalLength ( final Map < String , ConfigRangeAttrs > shiftMap , final String addedFullName , final int increasedLength ) { \nString [ ] parts = addedFullName . split ( \":\" ) ; \nStringBuilder fname = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < ( parts . length - 1 ) ; \ni = i + 1 ) { \nif ( i == 0 ) { \nfname . append ( parts [ i ] ) ; \n} \nelse { \nfname . append ( \":\" ) . append ( parts [ i ] ) ; \n} \nString sname = fname . toString ( ) ; \nshiftMap . get ( sname ) . setFinalLength ( shiftMap . get ( sname ) . getFinalLength ( ) + increasedLength ) ; \n} \n} \n} \n"}
{"8567": "public class ConfigurationUtility { \npublic static void changeIndexNumberInHiddenColumn ( final ConfigBuildRef configBuildRef , final int startRowIndex , final String fullName , final Map < String , String > changeMap , final int steps ) { \nString searchName = fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nfor ( int i = startRowIndex ; \ni <= sheet . getLastRowNum ( ) ; \ni = i + 1 ) { \nRow row = sheet . getRow ( i ) ; \nString fname = getFullNameFromRow ( row ) ; \nif ( ( fname != null ) && ( fname . indexOf ( searchName ) >= 0 ) ) { \nint sindex = fname . indexOf ( searchName ) ; \nString snum = fname . substring ( sindex + searchName . length ( ) ) ; \nint sufindex = snum . indexOf ( ':' ) ; \nString suffix = \"\" ; \nif ( sufindex > 0 ) { \nsnum = snum . substring ( 0 , sufindex ) ; \nsuffix = \":\" ; \n} \nint increaseNum = Integer . parseInt ( snum ) + steps ; \nString realFullName = fname . substring ( sindex ) ; \nString changeName = fname . replace ( searchName + snum + suffix , searchName + increaseNum + suffix ) ; \nif ( changeMap . get ( realFullName ) == null ) { \nchangeMap . put ( realFullName , changeName . substring ( sindex ) ) ; \n} \nsetFullNameInHiddenColumn ( row , changeName ) ; \n} \nelse { \nreturn ; \n} \n} \n} \n} \n"}
{"8571": "public class ConfigurationUtility { \npublic static List < RowsMapping > findParentRowsMappingFromShiftMap ( final String [ ] parts , final Map < String , ConfigRangeAttrs > shiftMap ) { \nStringBuilder fullName = new StringBuilder ( ) ; \nList < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; \nfor ( int i = 1 ; \ni < parts . length - 1 ; \ni = i + 1 ) { \nString part = parts [ i ] ; \nif ( fullName . length ( ) == 0 ) { \nfullName . append ( part ) ; \n} \nelse { \nfullName . append ( \":\" + part ) ; \n} \nif ( fullName . length ( ) > 0 ) { \nConfigRangeAttrs rangeAttrs = shiftMap . get ( fullName . toString ( ) ) ; \nif ( rangeAttrs != null ) { \nrowsMappingList . add ( rangeAttrs . getUnitRowsMapping ( ) ) ; \n} \n} \n} \nreturn rowsMappingList ; \n} \n} \n"}
{"8573": "public class ConfigurationUtility { \n@ SuppressWarnings ( \"rawtypes\" ) public static Object findItemInCollection ( final Collection collection , final int index ) { \nif ( index >= 0 ) { \nif ( collection instanceof List ) { \nList list = ( List ) collection ; \nreturn list . get ( index ) ; \n} \nint i = 0 ; \nfor ( Object object : collection ) { \nif ( i == index ) { \nreturn object ; \n} \ni = i + 1 ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8575": "public class ConfigurationUtility { \npublic static boolean isStaticRow ( final ConfigRange sourceConfigRange , final int rowIndex ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( int i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni = i + 1 ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nif ( ( rowIndex >= command . getConfigRange ( ) . getFirstRowAddr ( ) . getRow ( ) ) && ( rowIndex < ( command . getConfigRange ( ) . getLastRowPlusAddr ( ) . getRow ( ) ) ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8576": "public class ConfigurationUtility { \npublic static boolean isStaticRowRef ( final ConfigRange sourceConfigRange , final Row row ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( int i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni = i + 1 ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nint rowIndex = row . getRowNum ( ) ; \nif ( ( rowIndex >= command . getTopRow ( ) ) && ( rowIndex < ( command . getTopRow ( ) + command . getFinalLength ( ) ) ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8578": "public class ConfigurationUtility { \npublic static Map < String , CellRangeAddress > indexMergedRegion ( final Sheet sheet1 ) { \nint numRegions = sheet1 . getNumMergedRegions ( ) ; \nMap < String , CellRangeAddress > cellRangeMap = new HashMap < > ( ) ; \nfor ( int i = 0 ; \ni < numRegions ; \ni = i + 1 ) { \nCellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; \nif ( caddress != null ) { \ncellRangeMap . put ( CellUtility . getCellIndexNumberKey ( caddress . getFirstColumn ( ) , caddress . getFirstRow ( ) ) , caddress ) ; \n} \n} \nreturn cellRangeMap ; \n} \n} \n"}
{"8579": "public class ConfigurationUtility { \npublic static List < String > skippedRegionCells ( final Sheet sheet1 ) { \nint numRegions = sheet1 . getNumMergedRegions ( ) ; \nList < String > skipCellList = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < numRegions ; \ni = i + 1 ) { \nCellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; \nif ( caddress != null ) { \naddSkipCellToListInTheRegion ( skipCellList , caddress ) ; \n} \n} \nreturn skipCellList ; \n} \n} \n"}
{"8580": "public class ConfigurationUtility { \nprivate static void addSkipCellToListInTheRegion ( final List < String > skipCellList , final CellRangeAddress caddress ) { \nfor ( int col = caddress . getFirstColumn ( ) ; \ncol <= caddress . getLastColumn ( ) ; \ncol = col + 1 ) { \nfor ( int row = caddress . getFirstRow ( ) ; \nrow <= caddress . getLastRow ( ) ; \nrow = row + 1 ) { \nif ( ( col == caddress . getFirstColumn ( ) ) && ( row == caddress . getFirstRow ( ) ) ) { \ncontinue ; \n} \nskipCellList . add ( CellUtility . getCellIndexNumberKey ( col , row ) ) ; \n} \n} \n} \n} \n"}
{"8583": "public class ConfigurationHandler { \npublic final Map < String , SheetConfiguration > buildConfiguration ( ) { \nMap < String , SheetConfiguration > sheetConfigMap = new LinkedHashMap < > ( ) ; \nList < String > sheetNames = new ArrayList < > ( ) ; \nString sname ; \nfor ( int i = 0 ; \ni < parent . getWb ( ) . getNumberOfSheets ( ) ; \ni = i + 1 ) { \nsname = parent . getWb ( ) . getSheetName ( i ) ; \nif ( ! sname . startsWith ( org . tiefaces . common . TieConstants . COPY_SHEET_PREFIX ) ) { \nsheetNames . add ( sname ) ; \n} \n} \nfor ( String sheetName : sheetNames ) { \nSheet sheet = parent . getWb ( ) . getSheet ( sheetName ) ; \nConfigurationUtility . buildSheetCommentFromAlias ( sheet , parent . getTieCommandAliasList ( ) ) ; \nbuildSheet ( sheet , sheetConfigMap , parent . getCellAttributesMap ( ) ) ; \n} \nreturn sheetConfigMap ; \n} \n} \n"}
{"8586": "public class ConfigurationHandler { \nprivate int verifyLastCell ( final Row row , final int stoppoint , final int sheetRightCol ) { \nint lastCol = sheetRightCol ; \nint col ; \nfor ( col = lastCol ; \ncol >= stoppoint ; \ncol = col - 1 ) { \nCell cell = row . getCell ( col ) ; \nif ( ( cell != null ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) { \nbreak ; \n} \n} \nreturn col ; \n} \n} \n"}
{"8590": "public class ConfigurationHandler { \nprivate void setParentForChildCommand ( final List < ConfigCommand > commandList , final int i , final ConfigCommand child ) { \nint matchIndex = - 1 ; \nConfigRange matchRange = null ; \nfor ( int j = 0 ; \nj < commandList . size ( ) ; \nj = j + 1 ) { \nif ( j != i ) { \nCommand commandParent = commandList . get ( j ) ; \nif ( ! commandParent . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) && WebSheetUtility . insideRange ( child . getConfigRange ( ) , commandParent . getConfigRange ( ) ) && ( ( matchRange == null ) || ( WebSheetUtility . insideRange ( commandParent . getConfigRange ( ) , matchRange ) ) ) ) { \nmatchRange = commandParent . getConfigRange ( ) ; \nmatchIndex = j ; \n} \n} \n} \nif ( matchIndex >= 0 ) { \ncommandList . get ( matchIndex ) . getConfigRange ( ) . addCommand ( child ) ; \nchild . setParentFound ( true ) ; \n} \n} \n} \n"}
{"8606": "public class CommandUtility { \nprivate static List < String > findRemoveFullNameList ( final Sheet sheet , final int startRow , final int endRow ) { \nList < String > list = new ArrayList < > ( ) ; \nfor ( int rowIndex = startRow ; \nrowIndex <= endRow ; \nrowIndex = rowIndex + 1 ) { \nString fullName = ConfigurationUtility . getFullNameFromRow ( sheet . getRow ( rowIndex ) ) ; \nif ( ! list . contains ( fullName ) ) { \nlist . add ( fullName ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"8611": "public class CommandUtility { \npublic static void indexCommandRange ( final ConfigRange sourceConfigRange , final Map < String , Command > indexMap ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( int i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni = i + 1 ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nindexMap . put ( command . getCommandName ( ) , command ) ; \ncommand . getConfigRange ( ) . indexCommandRange ( indexMap ) ; \n} \n} \n} \n} \n"}
{"8613": "public class CommandUtility { \npublic static void insertEachTemplate ( final ConfigRange sourceConfigRange , final ConfigBuildRef configBuildRef , final int index , final int insertPosition , final RowsMapping unitRowsMapping ) { \nint srcStartRow = sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; \nint srcEndRow = sourceConfigRange . getLastRowPlusAddr ( ) . getRow ( ) - 1 ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nWorkbook wb = sheet . getWorkbook ( ) ; \nString copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; \nif ( copyName . length ( ) > TieConstants . EXCEL_SHEET_NAME_LIMIT ) { \ncopyName = copyName . substring ( 0 , TieConstants . EXCEL_SHEET_NAME_LIMIT ) ; \n} \nSheet srcSheet = wb . getSheet ( copyName ) ; \nif ( index > 0 ) { \nCellUtility . copyRows ( srcSheet , sheet , srcStartRow , srcEndRow , insertPosition , false , true ) ; \n} \nfor ( int rowIndex = srcStartRow ; \nrowIndex <= srcEndRow ; \nrowIndex = rowIndex + 1 ) { \nif ( configBuildRef . getWatchList ( ) . contains ( rowIndex ) && ( ConfigurationUtility . isStaticRow ( sourceConfigRange , rowIndex ) ) ) { \nunitRowsMapping . addRow ( rowIndex , sheet . getRow ( insertPosition + rowIndex - srcStartRow ) ) ; \n} \n} \n} \n} \n"}
{"8619": "public class CommandUtility { \npublic static void removeRowsInSheet ( final Sheet sheet , final int rowIndexStart , final int rowIndexEnd , final Map < Cell , String > cachedMap ) { \nfor ( int irow = rowIndexStart ; \nirow <= rowIndexEnd ; \nirow = irow + 1 ) { \nremoveCachedCellForRow ( sheet , irow , cachedMap ) ; \n} \nint irows = rowIndexEnd - rowIndexStart + 1 ; \nif ( ( irows < 1 ) || ( rowIndexStart < 0 ) ) { \nreturn ; \n} \nint lastRowNum = sheet . getLastRowNum ( ) ; \nif ( rowIndexEnd < lastRowNum ) { \nsheet . shiftRows ( rowIndexEnd + 1 , lastRowNum , - irows ) ; \n} \nif ( rowIndexEnd == lastRowNum ) { \nfor ( int i = rowIndexEnd ; \ni >= rowIndexStart ; \ni = i - 1 ) { \nremoveSingleRowInSheet ( sheet , rowIndexStart ) ; \n} \n} \n} \n} \n"}
{"8622": "public class CommandUtility { \npublic static void removeRowsInBody ( final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows , final int rowIndexStart , final int rowIndexEnd ) { \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nif ( ( rowIndexEnd < rowIndexStart ) || ( rowIndexStart < top ) ) { \nreturn ; \n} \nint irows = rowIndexEnd - rowIndexStart + 1 ; \nfor ( int rowIndex = rowIndexEnd ; \nrowIndex >= rowIndexStart ; \nrowIndex = rowIndex - 1 ) { \nbodyRows . remove ( rowIndex - top ) ; \n} \nfor ( int irow = rowIndexStart - top ; \nirow < bodyRows . size ( ) ; \nirow = irow + 1 ) { \nFacesRow facesrow = bodyRows . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) - irows ) ; \n} \n} \n} \n"}
{"8635": "public class CellUtility { \npublic static void copyRows ( final Sheet srcSheet , final Sheet destSheet , final int srcRowStart , final int srcRowEnd , final int destRow , final boolean checkLock , final boolean setHiddenColumn ) { \nint length = srcRowEnd - srcRowStart + 1 ; \nif ( length <= 0 ) { \nreturn ; \n} \ndestSheet . shiftRows ( destRow , destSheet . getLastRowNum ( ) , length , true , false ) ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \ncopySingleRow ( srcSheet , destSheet , srcRowStart + i , destRow + i , checkLock , setHiddenColumn ) ; \n} \nfor ( int i = 0 ; \ni < srcSheet . getNumMergedRegions ( ) ; \ni = i + 1 ) { \nCellRangeAddress cellRangeAddress = srcSheet . getMergedRegion ( i ) ; \nif ( ( cellRangeAddress . getFirstRow ( ) >= srcRowStart ) && ( cellRangeAddress . getLastRow ( ) <= srcRowEnd ) ) { \nint targetRowFrom = cellRangeAddress . getFirstRow ( ) - srcRowStart + destRow ; \nint targetRowTo = cellRangeAddress . getLastRow ( ) - srcRowStart + destRow ; \nCellRangeAddress newCellRangeAddress = new CellRangeAddress ( targetRowFrom , targetRowTo , cellRangeAddress . getFirstColumn ( ) , cellRangeAddress . getLastColumn ( ) ) ; \ndestSheet . addMergedRegion ( newCellRangeAddress ) ; \n} \n} \n} \n} \n"}
{"8636": "public class CellUtility { \nprivate static void copySingleRow ( final Sheet srcSheet , final Sheet destSheet , final int sourceRowNum , final int destinationRowNum , final boolean checkLock , final boolean setHiddenColumn ) { \nRow newRow = destSheet . getRow ( destinationRowNum ) ; \nRow sourceRow = srcSheet . getRow ( sourceRowNum ) ; \nif ( newRow == null ) { \nnewRow = destSheet . createRow ( destinationRowNum ) ; \n} \nnewRow . setHeight ( sourceRow . getHeight ( ) ) ; \nfor ( int i = 0 ; \ni < sourceRow . getLastCellNum ( ) ; \ni = i + 1 ) { \ncopyCell ( destSheet , sourceRow , newRow , i , checkLock ) ; \n} \nif ( setHiddenColumn ) { \nConfigurationUtility . setOriginalRowNumInHiddenColumn ( newRow , sourceRow . getRowNum ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8655": "public class TieWebSheetBeanCurrent { \npublic final String getCurrentDataContextName ( ) { \nif ( currentDataContextName == null ) { \nStringBuilder sb = new StringBuilder ( ) ; \nList < String > list = this . getCurrentDataContextNameList ( ) ; \nfor ( int i = 0 ; \ni < list . size ( ) ; \ni = i + 1 ) { \nif ( i > 0 ) { \nsb . append ( \":\" + list . get ( i ) ) ; \n} \nelse { \nsb . append ( list . get ( i ) ) ; \n} \n} \nthis . setCurrentDataContextName ( sb . toString ( ) ) ; \n} \nreturn currentDataContextName ; \n} \n} \n"}
{"8666": "public class ChartUtility { \npublic static void initXSSFAnchorsMap ( final XSSFWorkbook wb , final ChartsData charsData ) { \nMap < String , ClientAnchor > anchortMap = charsData . getChartAnchorsMap ( ) ; \nMap < String , String > positionMap = charsData . getChartPositionMap ( ) ; \nanchortMap . clear ( ) ; \npositionMap . clear ( ) ; \nfor ( int i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni = i + 1 ) { \ninitXSSFAnchorsMapForSheet ( anchortMap , positionMap , wb . getSheetAt ( i ) ) ; \n} \n} \n} \n"}
{"8667": "public class ChartUtility { \nprivate static void initXSSFAnchorsMapForSheet ( final Map < String , ClientAnchor > anchortMap , final Map < String , String > positionMap , final XSSFSheet sheet ) { \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nCTDrawing ctDrawing = drawing . getCTDrawing ( ) ; \nif ( ctDrawing . sizeOfTwoCellAnchorArray ( ) <= 0 ) { \nreturn ; \n} \nList < CTTwoCellAnchor > alist = ctDrawing . getTwoCellAnchorList ( ) ; \nfor ( int j = 0 ; \nj < alist . size ( ) ; \nj = j + 1 ) { \nCTTwoCellAnchor ctanchor = alist . get ( j ) ; \nString singleChartId = getAnchorAssociateChartId ( ctanchor ) ; \nif ( singleChartId != null ) { \nString chartId = sheet . getSheetName ( ) + \"!\" + singleChartId ; \nint dx1 = ( int ) ctanchor . getFrom ( ) . getColOff ( ) ; \nint dy1 = ( int ) ctanchor . getFrom ( ) . getRowOff ( ) ; \nint dx2 = ( int ) ctanchor . getTo ( ) . getColOff ( ) ; \nint dy2 = ( int ) ctanchor . getTo ( ) . getRowOff ( ) ; \nint col1 = ctanchor . getFrom ( ) . getCol ( ) ; \nint row1 = ctanchor . getFrom ( ) . getRow ( ) ; \nint col2 = ctanchor . getTo ( ) . getCol ( ) ; \nint row2 = ctanchor . getTo ( ) . getRow ( ) ; \nanchortMap . put ( chartId , new XSSFClientAnchor ( dx1 , dy1 , dx2 , dy2 , col1 , row1 , col2 , row2 ) ) ; \npositionMap . put ( WebSheetUtility . getFullCellRefName ( sheet . getSheetName ( ) , row1 , col1 ) , chartId ) ; \n} \n} \n} \n} \n"}
{"8668": "public class ChartUtility { \nprivate static String getAnchorAssociateChartId ( final CTTwoCellAnchor ctanchor ) { \nif ( ctanchor . getGraphicFrame ( ) == null ) { \nreturn null ; \n} \nNode parentNode = ctanchor . getGraphicFrame ( ) . getGraphic ( ) . getGraphicData ( ) . getDomNode ( ) ; \nNodeList childNodes = parentNode . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < childNodes . getLength ( ) ; \ni = i + 1 ) { \nNode childNode = childNodes . item ( i ) ; \nif ( ( childNode != null ) && ( \"c:chart\" . equalsIgnoreCase ( childNode . getNodeName ( ) ) ) && ( childNode . hasAttributes ( ) ) ) { \nString rId = getChartIdFromChildNodeAttributes ( childNode . getAttributes ( ) ) ; \nif ( rId != null ) { \nreturn rId ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8669": "public class ChartUtility { \nprivate static String getChartIdFromChildNodeAttributes ( final NamedNodeMap attrs ) { \nfor ( int j = 0 ; \nj < attrs . getLength ( ) ; \nj = j + 1 ) { \nAttr attribute = ( Attr ) attrs . item ( j ) ; \nif ( \"r:id\" . equalsIgnoreCase ( attribute . getName ( ) ) ) { \nreturn attribute . getValue ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8670": "public class EachCommand { \n@ SuppressWarnings ( \"rawtypes\" ) private int buildEachObjects ( String fullName , final ConfigBuildRef configBuildRef , final int atRow , final Map < String , Object > context , final List < RowsMapping > currentRowsMappingList , final Collection itemsCollection , final String objClassName ) { \nint index = 0 ; \nint insertPosition = atRow ; \nString thisObjClassName = objClassName ; \nfor ( Object obj : itemsCollection ) { \nif ( thisObjClassName == null ) { \nthisObjClassName = obj . getClass ( ) . getName ( ) ; \nconfigBuildRef . getCollectionObjNameMap ( ) . put ( this . var , thisObjClassName ) ; \n} \nRowsMapping unitRowsMapping = new RowsMapping ( ) ; \ncontext . put ( var , obj ) ; \nCommandUtility . insertEachTemplate ( this . getConfigRange ( ) , configBuildRef , index , insertPosition , unitRowsMapping ) ; \nConfigRange currentRange = ConfigurationUtility . buildCurrentRange ( this . getConfigRange ( ) , configBuildRef . getSheet ( ) , insertPosition ) ; \ncurrentRowsMappingList . add ( unitRowsMapping ) ; \nString unitFullName = fullName + \".\" + index ; \ncurrentRange . getAttrs ( ) . setAllowAdd ( false ) ; \nif ( ( this . allowAdd != null ) && ( \"true\" . equalsIgnoreCase ( this . allowAdd . trim ( ) ) ) ) { \ncurrentRange . getAttrs ( ) . setAllowAdd ( true ) ; \nconfigBuildRef . setBodyAllowAdd ( true ) ; \n} \nconfigBuildRef . putShiftAttrs ( unitFullName , currentRange . getAttrs ( ) , new RowsMapping ( unitRowsMapping ) ) ; \nint length = currentRange . buildAt ( unitFullName , configBuildRef , insertPosition , context , currentRowsMappingList ) ; \ncurrentRange . getAttrs ( ) . setFinalLength ( length ) ; \ninsertPosition += length ; \ncurrentRowsMappingList . remove ( unitRowsMapping ) ; \nindex = index + 1 ; \ncontext . remove ( var ) ; \n} \nreturn insertPosition ; \n} \n} \n"}
{"8675": "public class CellHelper { \npublic final void restoreDataContext ( final String fullName ) { \nString [ ] parts = fullName . split ( \":\" ) ; \nif ( ! isNeedRestore ( fullName , parts ) ) { \nreturn ; \n} \nboolean stopSkip = false ; \nList < String > list = parent . getCurrent ( ) . getCurrentDataContextNameList ( ) ; \nint listSize = list . size ( ) ; \nfor ( int i = 0 ; \ni < parts . length ; \ni = i + 1 ) { \nString part = parts [ i ] ; \nboolean skip = false ; \nif ( ( ! stopSkip ) && ( i < listSize ) ) { \nString listPart = list . get ( i ) ; \nif ( part . equalsIgnoreCase ( listPart ) ) { \nskip = true ; \n} \n} \nif ( ! skip ) { \nstopSkip = true ; \nstartRestoreDataContext ( part ) ; \n} \n} \nif ( stopSkip ) { \nparent . getCurrent ( ) . setCurrentDataContextName ( fullName ) ; \n} \nreturn ; \n} \n} \n"}
{"8685": "public class ChartData { \npublic final void buildCategoryList ( final CTAxDataSource ctAxDs ) { \nList < ParsedCell > cells = new ArrayList < > ( ) ; \ntry { \nString fullRangeName = ctAxDs . getStrRef ( ) . getF ( ) ; \nString sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; \nCellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; \nfor ( int row = region . getFirstRow ( ) ; \nrow <= region . getLastRow ( ) ; \nrow = row + 1 ) { \nfor ( int col = region . getFirstColumn ( ) ; \ncol <= region . getLastColumn ( ) ; \ncol = col + 1 ) { \ncells . add ( new ParsedCell ( sheetName , row , col ) ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"failed in buildCategoryList\" , ex ) ; \n} \nthis . setCategoryList ( cells ) ; \n} \n} \n"}
{"8686": "public class ChartData { \n@ SuppressWarnings ( \"rawtypes\" ) public final void buildSeriesList ( final List bsers , final ThemesTable themeTable , final ChartObject ctObj ) { \nList < ChartSeries > lseriesList = new ArrayList < > ( ) ; \ntry { \nfor ( int index = 0 ; \nindex < bsers . size ( ) ; \nindex = index + 1 ) { \nObject ctObjSer = bsers . get ( index ) ; \nChartSeries ctSer = buildChartSeriesInList ( themeTable , ctObj , ctObjSer , index ) ; \nlseriesList . add ( ctSer ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"failed in buildSerialList\" , ex ) ; \n} \nthis . setSeriesList ( lseriesList ) ; \n} \n} \n"}
{"8687": "public class ChartData { \nprivate ChartSeries buildChartSeriesInList ( final ThemesTable themeTable , final ChartObject ctObj , final Object ctObjSer , final int index ) { \nChartSeries ctSer = new ChartSeries ( ) ; \nctSer . setSeriesLabel ( new ParsedCell ( ctObj . getSeriesLabelFromCTSer ( ctObjSer ) ) ) ; \nctSer . setSeriesColor ( ColorUtility . geColorFromSpPr ( index , ctObj . getShapePropertiesFromCTSer ( ctObjSer ) , themeTable , ctObj . isLineColor ( ) ) ) ; \nList < ParsedCell > cells = new ArrayList < > ( ) ; \nString fullRangeName = ( ctObj . getCTNumDataSourceFromCTSer ( ctObjSer ) ) . getNumRef ( ) . getF ( ) ; \nString sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; \nCellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; \nfor ( int row = region . getFirstRow ( ) ; \nrow <= region . getLastRow ( ) ; \nrow = row + 1 ) { \nfor ( int col = region . getFirstColumn ( ) ; \ncol <= region . getLastColumn ( ) ; \ncol = col + 1 ) { \ncells . add ( new ParsedCell ( sheetName , row , col ) ) ; \n} \n} \nctSer . setValueList ( cells ) ; \nctSer . setValueColorList ( getColorListFromDPTWithValueList ( ctObj . getDPtListFromCTSer ( ctObjSer ) , cells , themeTable , ctObj ) ) ; \nreturn ctSer ; \n} \n} \n"}
{"8688": "public class ChartData { \nprivate List < XColor > getColorListFromDPTWithValueList ( final List < CTDPt > dptList , final List < ParsedCell > cells , final ThemesTable themeTable , final ChartObject ctObj ) { \nList < XColor > colors = new ArrayList < > ( ) ; \nif ( ( dptList != null ) && ( cells != null ) ) { \nfor ( int index = 0 ; \nindex < cells . size ( ) ; \nindex = index + 1 ) { \nCTDPt dpt = getDPtFromListWithIndex ( dptList , index ) ; \nCTShapeProperties ctSpPr = null ; \nif ( dpt != null ) { \nctSpPr = dpt . getSpPr ( ) ; \n} \ncolors . add ( ColorUtility . geColorFromSpPr ( index , ctSpPr , themeTable , ctObj . isLineColor ( ) ) ) ; \n} \n} \nreturn colors ; \n} \n} \n"}
{"8692": "public class PicturesUtility { \nprivate static void getXSSFPictruesMap ( final XSSFWorkbook wb , final Map < String , Picture > picMap ) { \npicMap . clear ( ) ; \nList < XSSFPictureData > pictures = wb . getAllPictures ( ) ; \nif ( pictures . isEmpty ( ) ) { \nreturn ; \n} \nfor ( int i = 0 ; \ni < wb . getNumberOfSheets ( ) ; \ni = i + 1 ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nfor ( POIXMLDocumentPart dr : sheet . getRelations ( ) ) { \ntry { \nindexPictureInMap ( picMap , sheet , dr ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"Load Picture error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8696": "public class PicturesUtility { \npublic static AnchorSize getAnchorSize ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final ClientAnchor anchor ) { \nif ( ! ( sheet1 instanceof XSSFSheet ) ) { \nreturn null ; \n} \ndouble picWidth = 0.0 ; \ndouble picHeight = 0.0 ; \nint left = anchor . getDx1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint top = ( int ) ( ( double ) anchor . getDy1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \nint right = anchor . getDx2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint bottom = ( int ) ( ( double ) anchor . getDy2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \ndouble cellWidth = 0.0 ; \ndouble cellHeight = 0.0 ; \nif ( ( cell != null ) && ( fcell != null ) ) { \nfor ( int col = cell . getColumnIndex ( ) ; \ncol < cell . getColumnIndex ( ) + fcell . getColspan ( ) ; \ncol = col + 1 ) { \ncellWidth += sheet1 . getColumnWidthInPixels ( col ) ; \n} \ndouble lastCellWidth = sheet1 . getColumnWidthInPixels ( cell . getColumnIndex ( ) + fcell . getColspan ( ) - 1 ) ; \nfor ( int rowIndex = cell . getRowIndex ( ) ; \nrowIndex < cell . getRowIndex ( ) + fcell . getRowspan ( ) ; \nrowIndex = rowIndex + 1 ) { \ncellHeight += WebSheetUtility . pointsToPixels ( sheet1 . getRow ( rowIndex ) . getHeightInPoints ( ) ) ; \n} \ndouble lastCellHeight = WebSheetUtility . pointsToPixels ( sheet1 . getRow ( cell . getRowIndex ( ) + fcell . getRowspan ( ) - 1 ) . getHeightInPoints ( ) ) ; \npicWidth = cellWidth - lastCellWidth + right - left ; \npicHeight = cellHeight - lastCellHeight + bottom - top ; \n} \nelse { \nfor ( short col = anchor . getCol1 ( ) ; \ncol < anchor . getCol2 ( ) ; \ncol = col + 1 ) { \npicWidth += sheet1 . getColumnWidthInPixels ( col ) ; \n} \nfor ( int rowindex = anchor . getRow1 ( ) ; \nrowindex < anchor . getRow2 ( ) ; \nrowindex = rowindex + 1 ) { \nRow row = sheet1 . getRow ( rowindex ) ; \nif ( row != null ) { \npicHeight += WebSheetUtility . pointsToPixels ( row . getHeightInPoints ( ) ) ; \n} \n} \n} \nreturn new AnchorSize ( left , top , ( int ) picWidth , ( int ) picHeight , cellWidth , cellHeight ) ; \n} \n} \n"}
{"8708": "public class CellStyleUtility { \npublic static int calcTotalHeight ( final Sheet sheet1 , final int firstRow , final int lastRow , final int additionalHeight ) { \nint totalHeight = additionalHeight ; \nfor ( int i = firstRow ; \ni <= lastRow ; \ni = i + 1 ) { \ntotalHeight += sheet1 . getRow ( i ) . getHeight ( ) ; \n} \nreturn totalHeight ; \n} \n} \n"}
{"8716": "public class FacesUtility { \npublic static String strJoin ( final short [ ] aArr , final String sSep ) { \nStringBuilder sbStr = new StringBuilder ( ) ; \nfor ( int i = 0 , il = aArr . length ; \ni < il ; \ni = i + 1 ) { \nif ( i > 0 ) { \nsbStr . append ( sSep ) ; \n} \nsbStr . append ( aArr [ i ] ) ; \n} \nreturn sbStr . toString ( ) ; \n} \n} \n"}
{"8724": "public class FormCommand { \nprivate List < Integer > buildFormWatchList ( final XSSFEvaluationWorkbook wbWrapper , final Sheet sheet ) { \nList < Integer > watchList = new ArrayList < > ( ) ; \nConfigRange cRange = this . getConfigRange ( ) ; \nList < ConfigCommand > commandList = cRange . getCommandList ( ) ; \nif ( commandList . isEmpty ( ) ) { \nreturn watchList ; \n} \nint lastStaticRow = commandList . get ( 0 ) . getTopRow ( ) - 1 ; \nif ( lastStaticRow < 0 ) { \nlastStaticRow = this . getTopRow ( ) ; \n} \nint sheetIndex = sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ; \nfor ( int i = this . getTopRow ( ) ; \ni <= this . getLastRow ( ) ; \ni = i + 1 ) { \nRow row = sheet . getRow ( i ) ; \nfor ( Cell cell : row ) { \nif ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { \nbuildWatchListForCell ( wbWrapper , sheetIndex , cell , watchList , lastStaticRow ) ; \n} \n} \n} \nreturn watchList ; \n} \n} \n"}
{"8725": "public class FormCommand { \nprivate void buildWatchListForCell ( final XSSFEvaluationWorkbook wbWrapper , final int sheetIndex , final Cell cell , final List < Integer > watchList , final int lastStaticRow ) { \nString formula = cell . getCellFormula ( ) ; \nPtg [ ] ptgs = FormulaParser . parse ( formula , wbWrapper , FormulaType . CELL , sheetIndex ) ; \nfor ( int k = 0 ; \nk < ptgs . length ; \nk = k + 1 ) { \nObject ptg = ptgs [ k ] ; \nint areaInt = ShiftFormulaUtility . getFirstSupportedRowNumFromPtg ( ptg ) ; \nif ( areaInt >= 0 ) { \naddToWatchList ( areaInt , lastStaticRow , watchList ) ; \n} \n} \ncell . setCellType ( CellType . STRING ) ; \ncell . setCellValue ( TieConstants . USER_FORMULA_PREFIX + formula + TieConstants . USER_FORMULA_SUFFIX ) ; \n} \n} \n"}
{"8731": "public class ParserUtility { \nprivate static int findPairBracketPosition ( final String str , final int startPos ) { \nint bracketNum = 0 ; \nfor ( int i = startPos ; \ni < str . length ( ) ; \ni = i + 1 ) { \nchar current = str . charAt ( i ) ; \nif ( current == TieConstants . EL_START_BRACKET ) { \nbracketNum = bracketNum + 1 ; \n} \nelse if ( current == TieConstants . EL_END ) { \nbracketNum = bracketNum - 1 ; \nif ( bracketNum <= 0 ) { \nreturn i ; \n} \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8738": "public class ParserUtility { \nprivate static void processSelectItemAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { \nif ( ( sAttr . selectValues == null ) || ( sAttr . selectValues . length != sAttr . selectLabels . length ) ) { \nsAttr . selectValues = sAttr . selectLabels ; \n} \nMap < String , String > smap = cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( key ) ; \nif ( smap == null ) { \nsmap = new LinkedHashMap < > ( ) ; \n} \nsmap . clear ( ) ; \nif ( sAttr . defaultSelectLabel != null ) { \nsmap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; \n} \nfor ( int i = 0 ; \ni < sAttr . selectLabels . length ; \ni = i + 1 ) { \nsmap . put ( sAttr . selectLabels [ i ] , sAttr . selectValues [ i ] ) ; \n} \ncellAttributesMap . getCellSelectItemsAttributes ( ) . put ( key , smap ) ; \n} \n} \n"}
{"8741": "public class ParserUtility { \npublic static int findFirstNonCellNamePosition ( String input , int startPosition ) { \nchar c ; \nfor ( int i = startPosition ; \ni < input . length ( ) ; \ni = i + 1 ) { \nc = input . charAt ( i ) ; \nif ( c != '$' && ! Character . isLetterOrDigit ( c ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8744": "public class WebSheetUtility { \npublic static int convertColToInt ( final String col ) { \nString name = col . toUpperCase ( ) ; \nint number = 0 ; \nint pow = 1 ; \nfor ( int i = name . length ( ) - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nnumber += ( name . charAt ( i ) - 'A' + 1 ) * pow ; \npow *= TieConstants . EXCEL_LETTER_NUMBERS ; \n} \nreturn number - 1 ; \n} \n} \n"}
{"8749": "public class WebSheetUtility { \npublic static boolean isNumeric ( final String str ) { \nString s = str ; \nif ( s . startsWith ( \"-\" ) ) { \ns = s . substring ( 1 ) ; \n} \nchar c ; \nint i ; \nint sLen = s . length ( ) ; \nShouldContinueParameter sPara = new ShouldContinueParameter ( false , false , 0 ) ; \nfor ( i = 0 ; \ni < sLen ; \ni = i + 1 ) { \nc = s . charAt ( i ) ; \nif ( c < '0' || c > '9' ) { \nif ( ! shouldContinue ( c , sPara ) ) { \nreturn false ; \n} \n} \nelse { \nif ( sPara . isCommaHit ( ) ) { \nsPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8765": "public class ValidationHandler { \npublic final boolean validateCurrentPage ( ) { \nboolean allpass = true ; \nint top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nfor ( int irow = 0 ; \nirow < parent . getBodyRows ( ) . size ( ) ; \nirow = irow + 1 ) { \nif ( ! validateRowInCurrentPage ( irow + top , false ) ) { \nallpass = false ; \n} \n} \nreturn allpass ; \n} \n} \n"}
{"8767": "public class ValidationHandler { \nprivate boolean validateRow ( final int irow , final SheetConfiguration sheetConfig , boolean updateGui ) { \nboolean pass = true ; \nif ( sheetConfig == null ) { \nreturn pass ; \n} \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nList < FacesCell > cellRow = parent . getBodyRows ( ) . get ( irow - top ) . getCells ( ) ; \nfor ( int index = 0 ; \nindex < cellRow . size ( ) ; \nindex = index + 1 ) { \nFacesCell fcell = cellRow . get ( index ) ; \nif ( ( fcell != null ) && ( ! validateWithRowColInCurrentPage ( irow , fcell . getColumnIndex ( ) , updateGui ) ) ) { \npass = false ; \n} \n} \nreturn pass ; \n} \n} \n"}
{"8768": "public class ValidationHandler { \nprivate void refreshCachedCellsInCurrentPage ( final FacesContext facesContext , final String tblName ) { \nUIComponent s = facesContext . getViewRoot ( ) . findComponent ( tblName ) ; \nif ( s == null ) { \nreturn ; \n} \nDataTable webDataTable = ( DataTable ) s ; \nint first = webDataTable . getFirst ( ) ; \nint rowsToRender = webDataTable . getRowsToRender ( ) ; \nint rowCounts = webDataTable . getRowCount ( ) ; \nint top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nint left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \nfor ( int i = first ; \ni <= ( first + rowsToRender ) ; \ni = i + 1 ) { \nif ( i < rowCounts ) { \nrefreshCachedCellsInRow ( tblName , top , left , i ) ; \n} \n} \n} \n} \n"}
{"8769": "public class ValidationHandler { \nprivate void refreshCachedCellsInRow ( final String tblName , final int top , final int left , final int i ) { \nFacesRow dataRow = parent . getBodyRows ( ) . get ( i ) ; \nint isize = dataRow . getCells ( ) . size ( ) ; \nfor ( int index = 0 ; \nindex < isize ; \nindex = index + 1 ) { \nFacesCell fcell = dataRow . getCells ( ) . get ( index ) ; \nCell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( i + top , index + left ) ; \nif ( poiCell != null ) { \nparent . getHelper ( ) . getWebSheetLoader ( ) . refreshCachedCell ( tblName , i , index , poiCell , fcell ) ; \n} \n} \n} \n} \n"}
{"8773": "public class WebSheetLoader { \nprivate void loadHeaderRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nint top = sheetConfig . getHeaderCellRange ( ) . getTopRow ( ) ; \nint bottom = sheetConfig . getHeaderCellRange ( ) . getBottomRow ( ) ; \nint left = sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nint totalWidth = CellStyleUtility . calcTotalWidth ( sheet1 , left , right , WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) + parent . getAddRowColumnWidth ( ) ) ) ; \nRangeBuildRef rangeBuildRef = new RangeBuildRef ( left , right , totalWidth , sheet1 ) ; \nif ( sheetConfig . isFixedWidthStyle ( ) ) { \nparent . setTableWidthStyle ( \"table-layout: fixed; width:\" + WebSheetUtility . widthUnits2Pixel ( totalWidth ) + \"px;\" ) ; \n} \nparent . setLineNumberColumnWidthStyle ( getWidthStyle ( WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) ) , totalWidth ) ) ; \nparent . setAddRowColumnWidthStyle ( \"width:\" + parent . getAddRowColumnWidth ( ) + \"px;\" ) ; \nparent . getHeaderRows ( ) . clear ( ) ; \nif ( top < 0 ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , true ) ) ; \nparent . setShowLineNumber ( true ) ; \n} \nelse { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , false ) ) ; \nfor ( int i = top ; \ni <= bottom ; \ni = i + 1 ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithConfigurationTab ( sheetConfig , rangeBuildRef , i , cellRangeMap , skippedRegionCells ) ) ; \n} \nparent . setShowLineNumber ( false ) ; \n} \n} \n} \n"}
{"8774": "public class WebSheetLoader { \nprivate List < HeaderCell > loadHeaderRowWithoutConfigurationTab ( final RangeBuildRef rangeBuildRef , final boolean rendered ) { \nint firstCol = rangeBuildRef . getLeft ( ) ; \nint lastCol = rangeBuildRef . getRight ( ) ; \ndouble totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; \nSheet sheet1 = rangeBuildRef . getSheet ( ) ; \nList < HeaderCell > headercells = new ArrayList < > ( ) ; \nfor ( int i = firstCol ; \ni <= lastCol ; \ni = i + 1 ) { \nif ( ! sheet1 . isColumnHidden ( i ) ) { \nString style = getHeaderColumnStyle ( parent . getWb ( ) , null , sheet1 . getColumnWidth ( i ) , totalWidth ) ; \nheadercells . add ( new HeaderCell ( \"1\" , \"1\" , style , style , WebSheetUtility . getExcelColumnName ( i ) , rendered , true ) ) ; \n} \n} \nfillToMaxColumns ( headercells ) ; \nreturn headercells ; \n} \n} \n"}
{"8775": "public class WebSheetLoader { \nprivate void fillToMaxColumns ( final List < HeaderCell > headercells ) { \nif ( headercells . size ( ) < parent . getMaxColCounts ( ) ) { \nint fills = parent . getMaxColCounts ( ) - headercells . size ( ) ; \nfor ( int s = 0 ; \ns < fills ; \ns = s + 1 ) { \nheadercells . add ( new HeaderCell ( \"1\" , \"1\" , \"\" , \"\" , \"\" , false , false ) ) ; \n} \n} \n} \n} \n"}
{"8778": "public class WebSheetLoader { \nprivate List < HeaderCell > loadHeaderRowWithConfigurationTab ( final SheetConfiguration sheetConfig , final RangeBuildRef rangeBuildRef , final int currentRow , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nSheet sheet1 = rangeBuildRef . getSheet ( ) ; \nint left = rangeBuildRef . getLeft ( ) ; \nint right = rangeBuildRef . getRight ( ) ; \ndouble totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; \nRow row = sheet1 . getRow ( currentRow ) ; \nList < HeaderCell > headercells = new ArrayList < > ( ) ; \nfor ( int cindex = left ; \ncindex <= right ; \ncindex = cindex + 1 ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , currentRow ) ; \nif ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { \nCell cell = null ; \nif ( row != null ) { \ncell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \n} \nint originRowIndex = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; \nif ( cell != null ) { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , originRowIndex , parent . getCellAttributesMap ( ) , null ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnStyle ( fcell . getColumnStyle ( ) + getColumnWidthStyle ( sheet1 , cellRangeMap , cellindex , cindex , totalWidth ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nheadercells . add ( new HeaderCell ( Integer . toString ( fcell . getRowspan ( ) ) , Integer . toString ( fcell . getColspan ( ) ) , fcell . getStyle ( ) , fcell . getColumnStyle ( ) , CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) , true , true ) ) ; \n} \n} \n} \nfillToMaxColumns ( headercells ) ; \nreturn headercells ; \n} \n} \n"}
{"8783": "public class WebSheetLoader { \npublic void refreshData ( ) { \nif ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) { \nreturn ; \n} \nfor ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { \nfor ( int irow = sheetConfig . getFormCommand ( ) . getTopRow ( ) ; \nirow < sheetConfig . getFormCommand ( ) . getLastRow ( ) ; \nirow = irow + 1 ) { \nrefreshDataForRow ( parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) . getRow ( irow ) ) ; \n} \n} \nparent . getCellHelper ( ) . reCalc ( ) ; \n} \n} \n"}
{"8786": "public class WebSheetLoader { \npublic final int findTabIndexWithName ( final String tabname ) { \nfor ( int i = 0 ; \ni < parent . getTabs ( ) . size ( ) ; \ni = i + 1 ) { \nif ( parent . getTabs ( ) . get ( i ) . getTitle ( ) . equalsIgnoreCase ( tabname ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8792": "public class WebSheetLoader { \nprivate void loadBodyRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint bottom = CellUtility . getBodyBottomFromConfig ( sheetConfig ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nparent . getBodyRows ( ) . clear ( ) ; \nclearCache ( ) ; \nfor ( int i = top ; \ni <= bottom ; \ni = i + 1 ) { \nparent . getBodyRows ( ) . add ( assembleFacesBodyRow ( i , sheet1 , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \n} \nsheetConfig . setBodyPopulated ( true ) ; \nparent . getCurrent ( ) . setCurrentTopRow ( top ) ; \nparent . getCurrent ( ) . setCurrentLeftColumn ( left ) ; \n} \n} \n"}
{"8793": "public class WebSheetLoader { \nprivate FacesRow assembleFacesBodyRow ( final int rowIndex , final Sheet sheet1 , final int left , final int right , final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nFacesRow facesRow = new FacesRow ( rowIndex ) ; \nRow row = sheet1 . getRow ( rowIndex ) ; \nsetupRowInfo ( facesRow , sheet1 , row , rowIndex , CommandUtility . isRowAllowAdd ( row , sheetConfig ) ) ; \nString saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; \nList < FacesCell > bodycells = new ArrayList < > ( ) ; \nfor ( int cindex = left ; \ncindex <= right ; \ncindex = cindex + 1 ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , rowIndex ) ; \nif ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { \nCell cell = null ; \nif ( row != null ) { \ncell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \n} \nif ( cell != null ) { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , facesRow . getOriginRowIndex ( ) , parent . getCellAttributesMap ( ) , saveAttrList ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nbodycells . add ( fcell ) ; \naddCache ( cell ) ; \n} \nelse { \nbodycells . add ( null ) ; \n} \n} \nelse { \nbodycells . add ( null ) ; \n} \n} \nfacesRow . setCells ( bodycells ) ; \nreturn facesRow ; \n} \n} \n"}
{"8796": "public class WebSheetLoader { \nprivate void createDynamicColumns ( final String tabName ) { \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nparent . getColumns ( ) . clear ( ) ; \nfor ( int i = left ; \ni <= right ; \ni = i + 1 ) { \nparent . getColumns ( ) . add ( \"column\" + ( i - left ) ) ; \n} \n} \n} \n"}
{"8798": "public class WebSheetLoader { \nprivate void refreshBodyRowsInRange ( final int insertPosition , final int length , final Sheet sheet , final SheetConfiguration sheetConfig ) { \nMap < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet ) ; \nList < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet ) ; \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nfor ( int irow = insertPosition ; \nirow < ( insertPosition + length ) ; \nirow = irow + 1 ) { \nparent . getBodyRows ( ) . add ( irow - top , assembleFacesBodyRow ( irow , sheet , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \n} \nfor ( int irow = insertPosition + length - top ; \nirow < parent . getBodyRows ( ) . size ( ) ; \nirow = irow + 1 ) { \nFacesRow facesrow = parent . getBodyRows ( ) . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) + length ) ; \n} \n} \n} \n"}
{"8822": "public class PoolableBufferedInputStream { \n@ Override public synchronized int read ( ) throws IOException { \nbyte [ ] localBuf = buf ; \nfinal InputStream localIn = in ; \nif ( localBuf == null || localIn == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \nif ( pos >= count && fillbuf ( localIn , localBuf ) == - 1 ) { \nreturn - 1 ; \n} \nif ( localBuf != buf ) { \nlocalBuf = buf ; \nif ( localBuf == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \n} \nfinal int mask = 0xFF ; \nif ( count - pos > 0 ) { \nreturn localBuf [ pos = pos + 1 ] & mask ; \n} \nreturn - 1 ; \n} \n} \n"}
{"8830": "public class Part { \npublic static void sendParts ( final OutputStream out , final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( parts == null ) { \nthrow new IllegalArgumentException ( \"Parts may not be null\" ) ; \n} \nif ( partBoundary == null || partBoundary . length == 0 ) { \nthrow new IllegalArgumentException ( \"partBoundary may not be empty\" ) ; \n} \nfor ( int i = 0 ; \ni < parts . length ; \ni = i + 1 ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nparts [ i ] . send ( out ) ; \n} \nout . write ( EXTRA_BYTES ) ; \nout . write ( partBoundary ) ; \nout . write ( EXTRA_BYTES ) ; \nout . write ( CRLF_BYTES ) ; \n} \n} \n"}
{"8831": "public class Part { \npublic static long getLengthOfParts ( final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"getLengthOfParts(Parts[])\" ) ; \n} \nif ( parts == null ) { \nthrow new IllegalArgumentException ( \"Parts may not be null\" ) ; \n} \nlong total = 0 ; \nfor ( int i = 0 ; \ni < parts . length ; \ni = i + 1 ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nfinal long l = parts [ i ] . length ( ) ; \nif ( l < 0 ) { \nreturn - 1 ; \n} \ntotal += l ; \n} \ntotal += EXTRA_BYTES . length ; \ntotal += partBoundary . length ; \ntotal += EXTRA_BYTES . length ; \ntotal += CRLF_BYTES . length ; \nreturn total ; \n} \n} \n"}
{"8872": "public class BuffersPool { \npublic void release ( final byte [ ] buffer ) { \nif ( buffer == null ) { \nreturn ; \n} \nfinal int capacity = buffer . length ; \nif ( capacity == 0 ) { \nreturn ; \n} \nsynchronized ( lock ) { \nList < Object > bList = buffers . get ( capacity ) ; \nif ( bList == null ) { \nbList = new LinkedList < Object > ( ) ; \nbuffers . put ( capacity , bList ) ; \n} \nbList . add ( buffer ) ; \nusedBuffersCount = usedBuffersCount - 1 ; \n} \n} \n} \n"}
{"8888": "public class MarkupConverter { \npublic static String removeKamolsMarkupFormating ( String tag ) { \nString result = \"\" ; \nif ( ! tag . contains ( \",\" ) ) return \"x\" ; \nint depth = 0 ; \nint commas = 0 ; \nfor ( char c : tag . toCharArray ( ) ) { \nif ( c == '[' ) depth = depth + 1 ; \nif ( c == ']' ) depth = depth - 1 ; \nif ( depth == 1 && c == ',' ) commas = commas + 1 ; \nif ( commas == 2 ) result = result + c ; \n} \nresult = result . replaceAll ( \"_[A-Z0-9]*\" , \"_\" ) ; \nresult = result . replaceAll ( \"(\\\\[|\\\\]|\\\\,| )\" , \"\" ) ; \nreturn result ; \n} \n} \n"}
{"8891": "public class MetricDataRequest { \nprotected List < MetricData > process ( JsonNode node ) { \nJSONArray dataArray = node . getArray ( ) ; \nList < MetricData > list = new LinkedList < > ( ) ; \nfor ( int i = 0 ; \ni < dataArray . length ( ) ; \ni = i + 1 ) { \nJSONObject data = dataArray . getJSONObject ( i ) ; \nMetricData metricData = new MetricData ( data . getString ( \"frequency\" ) , data . getLong ( \"metricId\" ) , data . getString ( \"metricName\" ) , data . getString ( \"metricPath\" ) ) ; \nlist . add ( metricData ) ; \nJSONArray valueArray = data . getJSONArray ( \"metricValues\" ) ; \nfor ( int j = 0 ; \nj < valueArray . length ( ) ; \nj = j + 1 ) { \nJSONObject value = valueArray . getJSONObject ( j ) ; \nmetricData . metricValues . add ( new MetricValue ( value . getLong ( \"count\" ) , value . getLong ( \"value\" ) , value . getLong ( \"max\" ) , value . getLong ( \"min\" ) , value . getLong ( \"sum\" ) , value . getLong ( \"startTimeInMillis\" ) ) ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"8923": "public class SendAppFeedback { \nprotected static void sendLogsToServer ( boolean setSentTime ) { \nlong timeSent = new Date ( ) . getTime ( ) ; \nString appFeedBackSummary = Utility . convertFileToString ( \"AppFeedBackSummary.json\" ) ; \nif ( \"\" . equals ( appFeedBackSummary ) || \"{}\" . equals ( appFeedBackSummary ) ) { \nreturn ; \n} \nelse { \ntry { \nJSONObject appFeedBacksummaryJSON = new JSONObject ( appFeedBackSummary ) ; \nJSONArray savedArray = ( JSONArray ) appFeedBacksummaryJSON . get ( \"saved\" ) ; \nHashMap < String , String > timeSentMap = new HashMap < > ( ) ; \nfor ( int i = 0 ; \ni < savedArray . length ( ) ; \ni = i + 1 ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = Utility . addAndFetchSentTimeFromScreenFeedBackJson ( screenFeedBackJsonFile , timeSent , setSentTime ) ; \nif ( actualTimeSent != null ) { \ntimeSentMap . put ( instanceName , actualTimeSent ) ; \n} \n} \nfor ( int i = 0 ; \ni < savedArray . length ( ) ; \ni = i + 1 ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = timeSentMap . get ( instanceName ) ; \nString zipFile = Utility . storageDirectory + instanceName + \"_\" + actualTimeSent + \".zip\" ; \nList < String > fileList = new ArrayList < > ( ) ; \nfileList . add ( Utility . getImageFileName ( instanceName ) ) ; \nfileList . add ( screenFeedBackJsonFile ) ; \nUtility . createZipArchive ( fileList , zipFile ) ; \nLogPersister . sendInAppFeedBackFile ( zipFile , new FeedBackUploadResponseListener ( instanceName , zipFile , actualTimeSent ) ) ; \n} \n} \ncatch ( JSONException je ) { \n} \n} \n} \n} \n"}
{"8929": "public class LogPersister { \nprotected static JSONObject appendStackMetadata ( JSONObject additionalMetadata ) { \nJSONObject jsonMetadata ; \nif ( additionalMetadata != null ) { \njsonMetadata = additionalMetadata ; \n} \nelse { \njsonMetadata = new JSONObject ( ) ; \n} \ntry { \nStackTraceElement [ ] stackTraceElements = new Exception ( ) . getStackTrace ( ) ; \nint index = 0 ; \nwhile ( ! stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) ) { \nindex = index + 1 ; \n} \nwhile ( stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( JULHandler . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( java . util . logging . Logger . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( BMSAnalytics . class . getName ( ) ) ) { \nindex = index + 1 ; \n} \njsonMetadata . put ( \"$class\" , stackTraceElements [ index ] . getClassName ( ) ) ; \njsonMetadata . put ( \"$file\" , stackTraceElements [ index ] . getFileName ( ) ) ; \njsonMetadata . put ( \"$method\" , stackTraceElements [ index ] . getMethodName ( ) ) ; \njsonMetadata . put ( \"$line\" , stackTraceElements [ index ] . getLineNumber ( ) ) ; \njsonMetadata . put ( \"$src\" , \"java\" ) ; \n} \ncatch ( Exception e ) { \nLog . e ( LOG_TAG_NAME , \"Could not generate jsonMetadata object.\" , e ) ; \n} \nreturn jsonMetadata ; \n} \n} \n"}
{"8939": "public class TimeStampSeries { \nvoid dump ( PrintWriter stream ) { \nstream . print ( \"[size=\" + count ) ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nif ( i != 0 ) { \nstream . print ( \", \" ) ; \nstream . print ( timeStamps [ i ] - timeStamps [ i - 1 ] ) ; \n} \nelse { \nstream . print ( \" \" + timeStamps [ i ] ) ; \n} \n} \nstream . println ( \"]\" ) ; \n} \n} \n"}
{"8940": "public class TimeStampSeries { \ndouble [ ] getTimeValuesSinceIdx ( int idx ) { \nint resultSize = this . count - idx ; \ndouble [ ] result = new double [ resultSize ] ; \nfor ( int i = 0 ; \ni < resultSize ; \ni = i + 1 ) { \nresult [ i ] = getMilliTimeStamp ( idx + i ) ; \n} \nreturn result ; \n} \n} \n"}
{"8965": "public class GfStatsReader { \npublic void close ( ) throws IOException { \nif ( ! this . closed ) { \nthis . closed = true ; \nthis . is . close ( ) ; \nthis . dataIn . close ( ) ; \nthis . is = null ; \nthis . dataIn = null ; \nint typeCount = 0 ; \nif ( this . resourceTypeTable != null ) { \nfor ( int i = 0 ; \ni < this . resourceTypeTable . length ; \ni = i + 1 ) { \nif ( this . resourceTypeTable [ i ] != null ) { \nif ( this . resourceTypeTable [ i ] . close ( ) ) { \nthis . resourceTypeTable [ i ] = null ; \n} \nelse { \ntypeCount = typeCount + 1 ; \n} \n} \n} \nResourceType [ ] newTypeTable = new ResourceType [ typeCount ] ; \ntypeCount = 0 ; \nfor ( ResourceType aResourceTypeTable : this . resourceTypeTable ) { \nif ( aResourceTypeTable != null ) { \nnewTypeTable [ typeCount ] = aResourceTypeTable ; \ntypeCount = typeCount + 1 ; \n} \n} \nthis . resourceTypeTable = newTypeTable ; \n} \nif ( this . resourceInstTable != null ) { \nint instCount = 0 ; \nfor ( int i = 0 ; \ni < this . resourceInstTable . length ; \ni = i + 1 ) { \nif ( this . resourceInstTable [ i ] != null ) { \nif ( this . resourceInstTable [ i ] . close ( ) ) { \nthis . resourceInstTable [ i ] = null ; \n} \nelse { \ninstCount = instCount + 1 ; \n} \n} \n} \nResourceInst [ ] newInstTable = new ResourceInst [ instCount ] ; \ninstCount = 0 ; \nfor ( ResourceInst aResourceInstTable : this . resourceInstTable ) { \nif ( aResourceInstTable != null ) { \nnewInstTable [ instCount ] = aResourceInstTable ; \ninstCount = instCount + 1 ; \n} \n} \nthis . resourceInstTable = newInstTable ; \nthis . resourceInstSize = instCount ; \n} \nthis . timeSeries . shrink ( ) ; \nthis . filters = null ; \n} \n} \n} \n"}
{"8969": "public class GemFireMgmt { \npublic static int stopMembersOnHost ( String hostName ) { \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp queryExp = null ; \nValueExp [ ] values = null ; \ntry { \nInetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; \nInetAddress address = null ; \nif ( addresses != null ) { \nvalues = new ValueExp [ addresses . length ] ; \nfor ( int i = 0 ; \ni < addresses . length ; \ni = i + 1 ) { \naddress = addresses [ i ] ; \nvalues [ i ] = Query . value ( address . getHostAddress ( ) ) ; \n} \n} \n} \ncatch ( UnknownHostException e ) { \nDebugger . println ( e . getMessage ( ) ) ; \n} \nif ( values != null ) { \nqueryExp = Query . or ( Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( \"Host\" ) , values ) ) ; \n} \nelse { \nqueryExp = Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) ; \n} \nSet < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; \nif ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) return 0 ; \nint memberCount = memberObjectNames . size ( ) ; \nMemberMXBean member = null ; \nCollection < String > locators = new ArrayList < String > ( ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nmember = GemFireJmxClient . getMember ( objectName . getKeyProperty ( \"member\" ) , SingletonGemFireJmx . getJmx ( ) ) ; \nif ( member . isLocator ( ) ) { \nlocators . add ( member . getName ( ) ) ; \n} \nelse { \nshutDownMember ( member . getName ( ) ) ; \n} \n} \nfor ( String locatorName : locators ) { \nshutDownMember ( locatorName ) ; \n} \nreturn memberCount ; \n} \n} \n"}
{"8973": "public class GeodePagination { \n@ SuppressWarnings ( { \n\"unchecked\" , \"rawtypes\" } \n) public < K , V > List < String > storePaginationMap ( String id , int pageSize , Region < String , Collection < K > > pageKeysRegion , List < Map . Entry < K , V > > results ) { \nif ( results == null || results . isEmpty ( ) ) return null ; \nList < Collection < K > > pagesCollection = toKeyPages ( ( List ) results , pageSize ) ; \nint pageIndex = 1 ; \nString key = null ; \nArrayList < String > keys = new ArrayList < String > ( pageSize ) ; \nfor ( Collection < K > page : pagesCollection ) { \nkey = toPageKey ( id , pageIndex = pageIndex + 1 ) ; \npageKeysRegion . put ( key , page ) ; \nkeys . add ( key ) ; \n} \nkeys . trimToSize ( ) ; \nreturn keys ; \n} \n} \n"}
{"9005": "public class ColumnVector { \nprotected void set ( final float values [ ] ) { \nthis . m_nRows = values . length ; \nthis . m_nCols = 1 ; \nthis . m_aValues = new float [ m_nRows ] [ 1 ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nthis . m_aValues [ r ] [ 0 ] = values [ r ] ; \n} \n} \n} \n"}
{"9008": "public class BigFunctions { \nprivate static BigDecimal _expTaylor ( final BigDecimal x , final int scale ) { \nBigDecimal factorial = BigDecimal . ONE ; \nBigDecimal xPower = x ; \nBigDecimal sumPrev ; \nBigDecimal sum = x . add ( BigDecimal . ONE ) ; \nint i = 2 ; \ndo { \nxPower = xPower . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; \nfactorial = factorial . multiply ( BigDecimal . valueOf ( i ) ) ; \nfinal BigDecimal term = xPower . divide ( factorial , scale , RoundingMode . HALF_EVEN ) ; \nsumPrev = sum ; \nsum = sum . add ( term ) ; \ni = i + 1 ; \nThread . yield ( ) ; \n} \nwhile ( sum . compareTo ( sumPrev ) != 0 ) ; \nreturn sum ; \n} \n} \n"}
{"9014": "public class AbstractPiFormula { \nprotected void printPi ( final String piString ) { \nSystem . out . print ( \"\\npi = \" + piString . substring ( 0 , 2 ) ) ; \nint index = 2 ; \nint line = 0 ; \nint group = 0 ; \nfinal int length = piString . length ( ) ; \nwhile ( index + 5 < length ) { \nSystem . out . print ( piString . substring ( index , index + 5 ) + \" \" ) ; \nindex += 5 ; \nif ( group = group + 1 == 10 ) { \nSystem . out . println ( ) ; \nif ( line = line + 1 == 10 ) { \nSystem . out . println ( ) ; \nline = 0 ; \n} \nSystem . out . print ( \"       \" ) ; \ngroup = 0 ; \n} \n} \nif ( index < length ) { \nSystem . out . println ( piString . substring ( index ) ) ; \n} \n} \n} \n"}
{"9017": "public class Buckets { \npublic void put ( final float r ) { \nif ( ( r < m_fMin ) || ( r > m_fMax ) ) return ; \nfinal int i = ( int ) ( ( r - m_fMin ) / m_fWidth ) ; \nm_aCounters [ i ] = m_aCounters [ i ] + 1 ; \n} \n} \n"}
{"9018": "public class Buckets { \npublic void print ( ) { \nint maxCount = 0 ; \nfor ( int i = 0 ; \ni < m_n ; \ni = i + 1 ) { \nmaxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; \n} \nfinal float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; \nfor ( int i = 0 ; \ni < m_n ; \ni = i + 1 ) { \nfinal int b = m_aCounters [ i ] ; \nm_aAlignRight . print ( i , 2 ) ; \nm_aAlignRight . print ( b , 7 ) ; \nSystem . out . print ( \": \" ) ; \nfinal int length = Math . round ( factor * b ) ; \nfor ( int j = 0 ; \nj < length ; \nj = j + 1 ) System . out . print ( \"*\" ) ; \nSystem . out . println ( ) ; \n} \n} \n} \n"}
{"9024": "public class Matrix { \npublic RowVector getRow ( final int r ) throws MatrixException { \nif ( ( r < 0 ) || ( r >= m_nRows ) ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nfinal RowVector rv = new RowVector ( m_nCols ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \nc = c + 1 ) { \nrv . m_aValues [ 0 ] [ c ] = m_aValues [ r ] [ c ] ; \n} \nreturn rv ; \n} \n} \n"}
{"9025": "public class Matrix { \npublic ColumnVector getColumn ( final int c ) throws MatrixException { \nif ( ( c < 0 ) || ( c >= m_nCols ) ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nfinal ColumnVector cv = new ColumnVector ( m_nRows ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \ncv . m_aValues [ r ] [ 0 ] = m_aValues [ r ] [ c ] ; \n} \nreturn cv ; \n} \n} \n"}
{"9026": "public class Matrix { \nprotected void set ( final float values [ ] [ ] ) { \nm_nRows = values . length ; \nm_nCols = values [ 0 ] . length ; \nm_aValues = values ; \nfor ( int r = 1 ; \nr < m_nRows ; \nr = r + 1 ) { \nm_nCols = Math . min ( m_nCols , values [ r ] . length ) ; \n} \n} \n} \n"}
{"9027": "public class Matrix { \npublic Matrix transpose ( ) { \nfinal float tv [ ] [ ] = new float [ m_nCols ] [ m_nRows ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nfor ( int c = 0 ; \nc < m_nCols ; \nc = c + 1 ) { \ntv [ c ] [ r ] = m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( tv ) ; \n} \n} \n"}
{"9028": "public class Matrix { \npublic Matrix add ( final Matrix m ) throws MatrixException { \nif ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float sv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nfor ( int c = 0 ; \nc < m_nCols ; \nc = c + 1 ) { \nsv [ r ] [ c ] = m_aValues [ r ] [ c ] + m . m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( sv ) ; \n} \n} \n"}
{"9029": "public class Matrix { \npublic Matrix subtract ( final Matrix m ) throws MatrixException { \nif ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float dv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nfor ( int c = 0 ; \nc < m_nCols ; \nc = c + 1 ) { \ndv [ r ] [ c ] = m_aValues [ r ] [ c ] - m . m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( dv ) ; \n} \n} \n"}
{"9030": "public class Matrix { \npublic Matrix multiply ( final float k ) { \nfinal float pv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nfor ( int c = 0 ; \nc < m_nCols ; \nc = c + 1 ) { \npv [ r ] [ c ] = k * m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( pv ) ; \n} \n} \n"}
{"9031": "public class Matrix { \npublic Matrix multiply ( final Matrix m ) throws MatrixException { \nif ( m_nCols != m . m_nRows ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float pv [ ] [ ] = new float [ m_nRows ] [ m . m_nCols ] ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nfor ( int c = 0 ; \nc < m . m_nCols ; \nc = c + 1 ) { \nfloat dot = 0 ; \nfor ( int k = 0 ; \nk < m_nCols ; \nk = k + 1 ) { \ndot += m_aValues [ r ] [ k ] * m . m_aValues [ k ] [ c ] ; \n} \npv [ r ] [ c ] = dot ; \n} \n} \nreturn new Matrix ( pv ) ; \n} \n} \n"}
{"9032": "public class Matrix { \npublic void print ( final int width , @ Nonnull final PrintStream aPS ) { \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \nc = c + 1 ) { \nar . print ( m_aValues [ r ] [ c ] , width ) ; \n} \nar . println ( ) ; \n} \n} \n} \n"}
{"9044": "public class InvertibleMatrix { \npublic InvertibleMatrix inverse ( ) throws MatrixException { \nfinal InvertibleMatrix inverse = new InvertibleMatrix ( m_nRows ) ; \nfinal IdentityMatrix identity = new IdentityMatrix ( m_nRows ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \nc = c + 1 ) { \nfinal ColumnVector col = solve ( identity . getColumn ( c ) , true ) ; \ninverse . setColumn ( col , c ) ; \n} \nreturn inverse ; \n} \n} \n"}
{"9045": "public class InvertibleMatrix { \npublic float determinant ( ) throws MatrixException { \ndecompose ( ) ; \nfloat determinant = ( ( m_nExchangeCount & 1 ) == 0 ) ? 1 : - 1 ; \nfor ( int i = 0 ; \ni < m_nRows ; \ni = i + 1 ) { \nfinal int pi = m_aPermutation [ i ] ; \ndeterminant *= m_aLU . at ( pi , i ) ; \n} \nreturn determinant ; \n} \n} \n"}
{"9046": "public class InvertibleMatrix { \npublic float norm ( ) { \nfloat sum = 0 ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nfor ( int c = 0 ; \nc < m_nCols ; \nc = c + 1 ) { \nfinal float v = m_aValues [ r ] [ c ] ; \nsum += v * v ; \n} \n} \nreturn ( float ) Math . sqrt ( sum ) ; \n} \n} \n"}
{"9048": "public class LinearSystem { \npublic void printDecomposed ( final int width , @ Nonnull final PrintStream aPS ) throws MatrixException { \ndecompose ( ) ; \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nfinal int pr = m_aPermutation [ r ] ; \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( int c = 0 ; \nc < m_nCols ; \nc = c + 1 ) { \nar . print ( m_aLU . m_aValues [ pr ] [ c ] , width ) ; \n} \nar . println ( ) ; \n} \n} \n} \n"}
{"9049": "public class LinearSystem { \nprivate void _forwardElimination ( final float scales [ ] ) throws MatrixException { \nfor ( int rPivot = 0 ; \nrPivot < m_nRows - 1 ; \nrPivot = rPivot + 1 ) { \nfloat largestScaledElmt = 0 ; \nint rLargest = 0 ; \nfor ( int r = rPivot ; \nr < m_nRows ; \nr = r + 1 ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float absElmt = Math . abs ( m_aLU . at ( pr , rPivot ) ) ; \nfinal float scaledElmt = absElmt * scales [ pr ] ; \nif ( largestScaledElmt < scaledElmt ) { \nlargestScaledElmt = scaledElmt ; \nrLargest = r ; \n} \n} \nif ( largestScaledElmt == 0 ) { \nthrow new MatrixException ( MatrixException . SINGULAR ) ; \n} \nif ( rLargest != rPivot ) { \nfinal int temp = m_aPermutation [ rPivot ] ; \nm_aPermutation [ rPivot ] = m_aPermutation [ rLargest ] ; \nm_aPermutation [ rLargest ] = temp ; \nm_nExchangeCount = m_nExchangeCount + 1 ; \n} \nfinal int prPivot = m_aPermutation [ rPivot ] ; \nfinal float pivotElmt = m_aLU . at ( prPivot , rPivot ) ; \nfor ( int r = rPivot + 1 ; \nr < m_nRows ; \nr = r + 1 ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float multiple = m_aLU . at ( pr , rPivot ) / pivotElmt ; \nm_aLU . set ( pr , rPivot , multiple ) ; \nif ( multiple != 0 ) { \nfor ( int c = rPivot + 1 ; \nc < m_nCols ; \nc = c + 1 ) { \nfloat elmt = m_aLU . at ( pr , c ) ; \nelmt -= multiple * m_aLU . at ( prPivot , c ) ; \nm_aLU . set ( pr , c , elmt ) ; \n} \n} \n} \n} \n} \n} \n"}
{"9050": "public class LinearSystem { \nprivate ColumnVector _forwardSubstitution ( final ColumnVector b ) throws MatrixException { \nfinal ColumnVector y = new ColumnVector ( m_nRows ) ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nfinal int pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \nfor ( int c = 0 ; \nc < r ; \nc = c + 1 ) { \ndot += m_aLU . at ( pr , c ) * y . at ( c ) ; \n} \ny . set ( r , b . at ( pr ) - dot ) ; \n} \nreturn y ; \n} \n} \n"}
{"9051": "public class LinearSystem { \nprivate ColumnVector _backSubstitution ( final ColumnVector y ) throws MatrixException { \nfinal ColumnVector x = new ColumnVector ( m_nRows ) ; \nfor ( int r = m_nRows - 1 ; \nr >= 0 ; \nr = r - 1 ) { \nfinal int pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \nfor ( int c = r + 1 ; \nc < m_nRows ; \nc = c + 1 ) { \ndot += m_aLU . at ( pr , c ) * x . at ( c ) ; \n} \nx . set ( r , ( y . at ( r ) - dot ) / m_aLU . at ( pr , r ) ) ; \n} \nreturn x ; \n} \n} \n"}
{"9052": "public class LinearSystem { \nprivate void _improve ( final ColumnVector b , final ColumnVector x ) throws MatrixException { \nfloat largestX = 0 ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nfinal float absX = Math . abs ( x . m_aValues [ r ] [ 0 ] ) ; \nif ( largestX < absX ) largestX = absX ; \n} \nif ( largestX == 0 ) return ; \nfinal ColumnVector residuals = new ColumnVector ( m_nRows ) ; \nfor ( int iter = 0 ; \niter < MAX_ITER ; \niter = iter + 1 ) { \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \ndouble dot = 0 ; \nfor ( int c = 0 ; \nc < m_nRows ; \nc = c + 1 ) { \nfinal double elmt = at ( r , c ) ; \ndot += elmt * x . at ( c ) ; \n} \nfinal double value = b . at ( r ) - dot ; \nresiduals . set ( r , ( float ) value ) ; \n} \nfinal ColumnVector z = solve ( residuals , false ) ; \nfloat largestDiff = 0 ; \nfor ( int r = 0 ; \nr < m_nRows ; \nr = r + 1 ) { \nfinal float oldX = x . at ( r ) ; \nx . set ( r , oldX + z . at ( r ) ) ; \nfinal float diff = Math . abs ( x . at ( r ) - oldX ) ; \nif ( largestDiff < diff ) largestDiff = diff ; \n} \nif ( largestDiff < largestX * TOLERANCE ) return ; \n} \nthrow new MatrixException ( MatrixException . NO_CONVERGENCE ) ; \n} \n} \n"}
{"9053": "public class IdentityMatrix { \npublic static void convert ( final SquareMatrix sm ) { \nfor ( int r = 0 ; \nr < sm . m_nRows ; \nr = r + 1 ) { \nfor ( int c = 0 ; \nc < sm . m_nCols ; \nc = c + 1 ) { \nsm . m_aValues [ r ] [ c ] = ( r == c ) ? 1 : 0 ; \n} \n} \n} \n} \n"}
{"9054": "public class RandomExponential { \npublic float nextVonNeumann ( ) { \nint n ; \nint k = 0 ; \nfloat u1 ; \nfor ( ; \n; \n) { \nn = 1 ; \nu1 = GENERATOR . nextFloat ( ) ; \nfloat u = u1 ; \nfloat uPrev = Float . NaN ; \nfor ( ; \n; \n) { \nuPrev = u ; \nu = GENERATOR . nextFloat ( ) ; \nif ( u > uPrev ) { \nif ( ( n & 1 ) == 0 ) { \nreturn u1 + k ; \n} \nk = k + 1 ; \nbreak ; \n} \nn = n + 1 ; \n} \n} \n} \n} \n"}
{"9065": "public class IEEE754 { \nprivate static char [ ] _toCharBitArray ( final long pvalue , final int size ) { \nlong value = pvalue ; \nfinal char bits [ ] = new char [ size ] ; \nfor ( int i = size - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nbits [ i ] = ( value & 1 ) == 0 ? '0' : '1' ; \nvalue >>>= 1 ; \n} \nreturn bits ; \n} \n} \n"}
{"9073": "public class RandomNormal { \npublic float nextCentral ( ) { \nfloat sum = 0.0f ; \nfor ( int j = 0 ; \nj < 12 ; \nj = j + 1 ) sum += GENERATOR . nextFloat ( ) ; \nreturn m_fStddev * ( sum - 6 ) + m_fMean ; \n} \n} \n"}
{"9076": "public class PrimeFactors { \npublic static boolean [ ] primeSieve ( final int n ) { \nfinal int halfN = ( n + 1 ) >> 1 ; \nfinal boolean sieve [ ] = new boolean [ n + 1 ] ; \nfor ( int i = 2 ; \ni <= n ; \ni = i + 1 ) sieve [ i ] = true ; \nint prime = 2 ; \nwhile ( prime < halfN ) { \nfor ( int composite = prime << 1 ; \ncomposite <= n ; \ncomposite += prime ) sieve [ composite ] = false ; \nwhile ( ( prime = prime + 1 < halfN ) && ( ! sieve [ prime ] ) ) { \n} \n} \nreturn sieve ; \n} \n} \n"}
{"9077": "public class PrimeFactors { \npublic static int [ ] factorsOf ( final int pn ) { \nint n = pn ; \nfinal boolean isPrime [ ] = primeSieve ( n ) ; \nfinal ICommonsList < Integer > v = new CommonsArrayList < > ( ) ; \nfor ( int factor = 2 ; \nn > 1 ; \nfactor = factor + 1 ) { \nif ( isPrime [ factor ] && ( n % factor == 0 ) ) { \nv . add ( Integer . valueOf ( factor ) ) ; \ndo { \nn /= factor ; \n} \nwhile ( n % factor == 0 ) ; \n} \n} \nfinal int factors [ ] = new int [ v . size ( ) ] ; \nfor ( int i = 0 ; \ni < v . size ( ) ; \ni = i + 1 ) { \nfactors [ i ] = v . get ( i ) . intValue ( ) ; \n} \nreturn factors ; \n} \n} \n"}
{"9275": "public class Catalog { \nprotected void copyReaders ( Catalog newCatalog ) { \nVector mapArr = new Vector ( readerMap . size ( ) ) ; \nfor ( int count = 0 ; \ncount < readerMap . size ( ) ; \ncount = count + 1 ) { \nmapArr . add ( null ) ; \n} \nEnumeration enumt = readerMap . keys ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nString mimeType = ( String ) enumt . nextElement ( ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nmapArr . set ( pos . intValue ( ) , mimeType ) ; \n} \nfor ( int count = 0 ; \ncount < mapArr . size ( ) ; \ncount = count + 1 ) { \nString mimeType = ( String ) mapArr . get ( count ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nnewCatalog . addReader ( mimeType , ( CatalogReader ) readerArr . get ( pos . intValue ( ) ) ) ; \n} \n} \n} \n"}
{"9277": "public class Catalog { \npublic void loadSystemCatalogs ( ) throws MalformedURLException , IOException { \nVector catalogs = catalogManager . getCatalogFiles ( ) ; \nif ( catalogs != null ) { \nfor ( int count = 0 ; \ncount < catalogs . size ( ) ; \ncount = count + 1 ) { \ncatalogFiles . addElement ( catalogs . elementAt ( count ) ) ; \n} \n} \nif ( catalogFiles . size ( ) > 0 ) { \nString catfile = ( String ) catalogFiles . lastElement ( ) ; \ncatalogFiles . removeElement ( catfile ) ; \nparseCatalog ( catfile ) ; \n} \n} \n} \n"}
{"9278": "public class Catalog { \npublic synchronized void parseCatalog ( URL aUrl ) throws IOException { \ncatalogCwd = aUrl ; \nbase = aUrl ; \ndefault_override = catalogManager . getPreferPublic ( ) ; \ncatalogManager . debug . message ( 4 , \"Parse catalog: \" + aUrl . toString ( ) ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nfor ( int count = 0 ; \n! parsed && count < readerArr . size ( ) ; \ncount = count + 1 ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \ninStream = new DataInputStream ( aUrl . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { \nbreak ; \n} \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( parsed ) parsePendingCatalogs ( ) ; \n} \n} \n"}
{"9279": "public class Catalog { \nprotected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat = curCat + 1 ) { \nString catfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \nwhile ( ! catalogFiles . isEmpty ( ) ) { \nString catfile = ( String ) catalogFiles . elementAt ( 0 ) ; \ntry { \ncatalogFiles . remove ( 0 ) ; \n} \ncatch ( ArrayIndexOutOfBoundsException e ) { \n} \nif ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) { \ntry { \nparseCatalogFile ( catfile ) ; \n} \ncatch ( CatalogException ce ) { \nSystem . out . println ( \"FIXME: \" + ce . toString ( ) ) ; \n} \n} \nelse { \ncatalogs . addElement ( catfile ) ; \n} \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncurCat < catalogFiles . size ( ) ; \ncurCat = curCat + 1 ) { \ncatfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \n} \ncatalogFiles . clear ( ) ; \n} \n} \n"}
{"9280": "public class Catalog { \nprotected synchronized void parseCatalogFile ( String fileName ) throws MalformedURLException , IOException , CatalogException { \ntry { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogCwd = new URL ( \"file:\" + userdir + \"/basename\" ) ; \n} \ncatch ( MalformedURLException e ) { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogManager . debug . message ( 1 , \"Malformed URL on cwd\" , userdir ) ; \ncatalogCwd = null ; \n} \ntry { \nbase = new URL ( catalogCwd , fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e ) { \ntry { \nbase = new URL ( \"file:\" + fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e2 ) { \ncatalogManager . debug . message ( 1 , \"Malformed URL on catalog filename\" , fixSlashes ( fileName ) ) ; \nbase = null ; \n} \n} \ncatalogManager . debug . message ( 2 , \"Loading catalog\" , fileName ) ; \ncatalogManager . debug . message ( 4 , \"Default BASE\" , base . toString ( ) ) ; \nfileName = base . toString ( ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nboolean notFound = false ; \nfor ( int count = 0 ; \n! parsed && count < readerArr . size ( ) ; \ncount = count + 1 ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \nnotFound = false ; \ninStream = new DataInputStream ( base . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nnotFound = true ; \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { \nbreak ; \n} \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( ! parsed ) { \nif ( notFound ) { \ncatalogManager . debug . message ( 3 , \"Catalog does not exist\" , fileName ) ; \n} \nelse { \ncatalogManager . debug . message ( 1 , \"Failed to parse catalog\" , fileName ) ; \n} \n} \n} \n} \n"}
{"9282": "public class Catalog { \npublic void parseAllCatalogs ( ) throws MalformedURLException , IOException { \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos = catPos + 1 ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \nc . parseCatalog ( catfile ) ; \ncatalogs . setElementAt ( c , catPos ) ; \nc . parseAllCatalogs ( ) ; \n} \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DELEGATE_PUBLIC || e . getEntryType ( ) == DELEGATE_SYSTEM || e . getEntryType ( ) == DELEGATE_URI ) { \nCatalog dcat = newCatalog ( ) ; \ndcat . parseCatalog ( e . getEntryArg ( 1 ) ) ; \n} \n} \n} \n} \n"}
{"9287": "public class Catalog { \nprotected synchronized String resolveSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos = catPos + 1 ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == DOCUMENT ) { \nresolved = c . resolveDocument ( ) ; \n} \nelse if ( entityType == ENTITY ) { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == NOTATION ) { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == PUBLIC ) { \nresolved = c . resolvePublic ( publicId , systemId ) ; \n} \nelse if ( entityType == SYSTEM ) { \nresolved = c . resolveSystem ( systemId ) ; \n} \nelse if ( entityType == URI ) { \nresolved = c . resolveURI ( systemId ) ; \n} \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9289": "public class Catalog { \nprotected String normalizeURI ( String uriref ) { \nString newRef = \"\" ; \nbyte [ ] bytes ; \nif ( uriref == null ) { \nreturn null ; \n} \ntry { \nbytes = uriref . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \ncatalogManager . debug . message ( 1 , \"UTF-8 is an unsupported encoding!?\" ) ; \nreturn uriref ; \n} \nfor ( int count = 0 ; \ncount < bytes . length ; \ncount = count + 1 ) { \nint ch = bytes [ count ] & 0xFF ; \nif ( ( ch <= 0x20 ) || ( ch > 0x7F ) || ( ch == 0x22 ) || ( ch == 0x3C ) || ( ch == 0x3E ) || ( ch == 0x5C ) || ( ch == 0x5E ) || ( ch == 0x60 ) || ( ch == 0x7B ) || ( ch == 0x7C ) || ( ch == 0x7D ) || ( ch == 0x7F ) ) { \nnewRef += encodedByte ( ch ) ; \n} \nelse { \nnewRef += ( char ) bytes [ count ] ; \n} \n} \nreturn newRef ; \n} \n} \n"}
{"9291": "public class Catalog { \nprotected void addDelegate ( CatalogEntry entry ) { \nint pos = 0 ; \nString partial = entry . getEntryArg ( 0 ) ; \nEnumeration local = localDelegate . elements ( ) ; \nwhile ( local . hasMoreElements ( ) ) { \nCatalogEntry dpe = ( CatalogEntry ) local . nextElement ( ) ; \nString dp = dpe . getEntryArg ( 0 ) ; \nif ( dp . equals ( partial ) ) { \nreturn ; \n} \nif ( dp . length ( ) > partial . length ( ) ) { \npos = pos + 1 ; \n} \nif ( dp . length ( ) < partial . length ( ) ) { \nbreak ; \n} \n} \nif ( localDelegate . size ( ) == 0 ) { \nlocalDelegate . addElement ( entry ) ; \n} \nelse { \nlocalDelegate . insertElementAt ( entry , pos ) ; \n} \n} \n} \n"}
{"9293": "public class ThrowableHandler { \nprotected static void fireOnThrowable ( int type , Throwable t ) { \nObject [ ] list = listeners . toArray ( ) ; \nfor ( int i = 0 ; \ni < list . length ; \ni = i + 1 ) { \n( ( ThrowableListener ) list [ i ] ) . onThrowable ( type , t ) ; \n} \n} \n} \n"}
{"9300": "public class CachedList { \nprivate void maintain ( ) { \nSoftObject obj ; \nint count = 0 ; \nwhile ( ( obj = ( SoftObject ) queue . poll ( ) ) != null ) { \ncount = count + 1 ; \nlist . remove ( obj ) ; \n} \nif ( count != 0 ) { \nSystem . err . println ( \"vm reclaimed \" + count + \" objects\" ) ; \n} \n} \n} \n"}
{"9301": "public class CatalogEntry { \npublic static int addEntryType ( String name , int numArgs ) { \nentryTypes . put ( name , new Integer ( nextEntry ) ) ; \nentryArgs . add ( nextEntry , new Integer ( numArgs ) ) ; \nnextEntry = nextEntry + 1 ; \nreturn nextEntry - 1 ; \n} \n} \n"}
{"9307": "public class TimeoutPriorityQueueImpl { \nprivate TimeoutExtImpl removeNode ( int index ) { \nTimeoutExtImpl res = queue [ index ] ; \nif ( index == size ) { \nsize = size - 1 ; \nqueue [ index ] = null ; \nreturn res ; \n} \nswap ( index , size ) ; \nsize = size - 1 ; \nqueue [ res . index ] = null ; \nif ( normalizeUp ( index ) ) return res ; \nlong t = queue [ index ] . time ; \nint c = index << 1 ; \nwhile ( c <= size ) { \nTimeoutExtImpl l = queue [ c ] ; \nif ( c + 1 <= size ) { \nTimeoutExtImpl r = queue [ c + 1 ] ; \nif ( l . time <= r . time ) { \nif ( t <= l . time ) break ; \nswap ( index , c ) ; \nindex = c ; \n} \nelse { \nif ( t <= r . time ) break ; \nswap ( index , c + 1 ) ; \nindex = c + 1 ; \n} \n} \nelse { \nif ( t <= l . time ) break ; \nswap ( index , c ) ; \nindex = c ; \n} \nc = index << 1 ; \n} \nreturn res ; \n} \n} \n"}
{"9310": "public class URLStreamHandlerFactory { \n@ SuppressWarnings ( \"unused\" ) public static void preload ( ) { \nfor ( int i = 0 ; \ni < PROTOCOLS . length ; \ni = i + 1 ) { \ntry { \nURL url = new URL ( PROTOCOLS [ i ] , \"\" , - 1 , \"\" ) ; \nlog . trace ( \"Loaded protocol: \" + PROTOCOLS [ i ] ) ; \n} \ncatch ( Exception e ) { \nlog . warn ( \"Failed to load protocol: \" + PROTOCOLS [ i ] , e ) ; \n} \n} \n} \n} \n"}
{"9311": "public class URLStreamHandlerFactory { \npublic URLStreamHandler createURLStreamHandler ( final String protocol ) { \nURLStreamHandler handler = ( URLStreamHandler ) handlerMap . get ( protocol ) ; \nif ( handler != null ) return handler ; \nString prevProtocol = ( String ) createURLStreamHandlerProtocol . get ( ) ; \nif ( prevProtocol != null && prevProtocol . equals ( protocol ) ) return null ; \ncreateURLStreamHandlerProtocol . set ( protocol ) ; \ncheckHandlerPkgs ( ) ; \nClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nfor ( int p = 0 ; \np < handlerPkgs . length ; \np = p + 1 ) { \ntry { \nString classname = handlerPkgs [ p ] + \".\" + protocol + \".Handler\" ; \nClass < ? > type = null ; \ntry { \ntype = ctxLoader . loadClass ( classname ) ; \n} \ncatch ( ClassNotFoundException e ) { \ntype = Class . forName ( classname ) ; \n} \nif ( type != null ) { \nhandler = ( URLStreamHandler ) type . newInstance ( ) ; \nhandlerMap . put ( protocol , handler ) ; \nlog . trace ( \"Found protocol:\" + protocol + \" handler:\" + handler ) ; \n} \n} \ncatch ( Throwable ignore ) { \n} \n} \ncreateURLStreamHandlerProtocol . set ( null ) ; \nreturn handler ; \n} \n} \n"}
{"9322": "public class Strings { \npublic static String [ ] split ( final String string , final String delim , final int limit ) { \nint count = count ( string , delim ) + 1 ; \nif ( limit > 0 && count > limit ) { \ncount = limit ; \n} \nString strings [ ] = new String [ count ] ; \nint begin = 0 ; \nfor ( int i = 0 ; \ni < count ; \ni = i + 1 ) { \nint end = string . indexOf ( delim , begin ) ; \nif ( end == - 1 || i + 1 == count ) end = string . length ( ) ; \nif ( end == 0 ) strings [ i ] = EMPTY ; \nelse strings [ i ] = string . substring ( begin , end ) ; \nbegin = end + 1 ; \n} \nreturn strings ; \n} \n} \n"}
{"9323": "public class Strings { \npublic static String join ( final byte array [ ] ) { \nByte bytes [ ] = new Byte [ array . length ] ; \nfor ( int i = 0 ; \ni < bytes . length ; \ni = i + 1 ) { \nbytes [ i ] = new Byte ( array [ i ] ) ; \n} \nreturn join ( bytes , null ) ; \n} \n} \n"}
{"9334": "public class XmlHelper { \npublic static Iterator getChildrenByTagName ( Element element , String tagName ) { \nif ( element == null ) return null ; \nNodeList children = element . getChildNodes ( ) ; \nArrayList goodChildren = new ArrayList ( ) ; \nfor ( int i = 0 ; \ni < children . getLength ( ) ; \ni = i + 1 ) { \nNode currentChild = children . item ( i ) ; \nif ( currentChild . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) currentChild ) . getTagName ( ) . equals ( tagName ) ) { \ngoodChildren . add ( currentChild ) ; \n} \n} \nreturn goodChildren . iterator ( ) ; \n} \n} \n"}
{"9337": "public class XmlHelper { \npublic static String getElementContent ( Element element , String defaultStr ) throws Exception { \nif ( element == null ) return defaultStr ; \nNodeList children = element . getChildNodes ( ) ; \nString result = \"\" ; \nfor ( int i = 0 ; \ni < children . getLength ( ) ; \ni = i + 1 ) { \nif ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { \nresult += children . item ( i ) . getNodeValue ( ) ; \n} \nelse if ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { \n} \n} \nreturn result . trim ( ) ; \n} \n} \n"}
{"9349": "public class Resolver { \nprivate Vector appendVector ( Vector vec , Vector appvec ) { \nif ( appvec != null ) { \nfor ( int count = 0 ; \ncount < appvec . size ( ) ; \ncount = count + 1 ) { \nvec . addElement ( appvec . elementAt ( count ) ) ; \n} \n} \nreturn vec ; \n} \n} \n"}
{"9354": "public class Resolver { \nprivate synchronized Vector resolveAllSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nVector resolutions = new Vector ( ) ; \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos = catPos + 1 ) { \nResolver c = null ; \ntry { \nc = ( Resolver ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = ( Resolver ) newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == DOCUMENT ) { \nresolved = c . resolveDocument ( ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == ENTITY ) { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == NOTATION ) { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == PUBLIC ) { \nresolved = c . resolvePublic ( publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == SYSTEM ) { \nVector localResolutions = c . resolveAllSystem ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \nbreak ; \n} \nelse if ( entityType == SYSTEMREVERSE ) { \nVector localResolutions = c . resolveAllSystemReverse ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \n} \n} \nif ( resolutions != null ) { \nreturn resolutions ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"9370": "public class Objects { \npublic static Constructor getCompatibleConstructor ( final Class type , final Class valueType ) { \ntry { \nreturn type . getConstructor ( new Class [ ] { \nvalueType } \n) ; \n} \ncatch ( Exception ignore ) { \nClass [ ] types = type . getClasses ( ) ; \nfor ( int i = 0 ; \ni < types . length ; \ni = i + 1 ) { \ntry { \nreturn type . getConstructor ( new Class [ ] { \ntypes [ i ] } \n) ; \n} \ncatch ( Exception ignore2 ) { \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"9378": "public class PropertyMap { \nprivate void firePropertyAdded ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \nfor ( int i = 0 ; \ni < size ; \ni = i + 1 ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyAdded ( event ) ; \n} \n} \n} \n"}
{"9379": "public class PropertyMap { \nprivate void firePropertyRemoved ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \nfor ( int i = 0 ; \ni < size ; \ni = i + 1 ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyRemoved ( event ) ; \n} \n} \n} \n"}
{"9380": "public class PropertyMap { \nprivate void firePropertyChanged ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \nfor ( int i = 0 ; \ni < size ; \ni = i + 1 ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyChanged ( event ) ; \n} \n} \n} \n"}
{"9396": "public class StopWatch { \npublic long stop ( ) { \nlong lap = 0 ; \nif ( running ) { \ncount = count + 1 ; \nstop = System . currentTimeMillis ( ) ; \nlap = stop - start ; \ntotal += lap ; \nrunning = false ; \n} \nreturn lap ; \n} \n} \n"}
{"9399": "public class HashCode { \npublic static int generate ( final byte [ ] bytes ) { \nint hashcode = 0 ; \nfor ( int i = 0 ; \ni < bytes . length ; \ni = i + 1 ) { \nhashcode <<= 1 ; \nhashcode ^= bytes [ i ] ; \n} \nreturn hashcode ; \n} \n} \n"}
{"9400": "public class HashCode { \npublic static int generate ( final Object array [ ] , final boolean deep ) { \nint hashcode = 0 ; \nfor ( int i = 0 ; \ni < array . length ; \ni = i + 1 ) { \nif ( deep && ( array [ i ] instanceof Object [ ] ) ) { \nhashcode ^= generate ( ( Object [ ] ) array [ i ] , true ) ; \n} \nelse { \nhashcode ^= array [ i ] . hashCode ( ) ; \n} \n} \nreturn hashcode ; \n} \n} \n"}
{"9403": "public class TextCatalogReader { \nprotected String nextToken ( ) throws IOException { \nString token = \"\" ; \nint ch , nextch ; \nif ( ! tokenStack . empty ( ) ) { \nreturn ( String ) tokenStack . pop ( ) ; \n} \nwhile ( true ) { \nch = catfile . read ( ) ; \nwhile ( ch <= ' ' ) { \nch = catfile . read ( ) ; \nif ( ch < 0 ) { \nreturn null ; \n} \n} \nnextch = catfile . read ( ) ; \nif ( nextch < 0 ) { \nreturn null ; \n} \nif ( ch == '-' && nextch == '-' ) { \nch = ' ' ; \nnextch = nextChar ( ) ; \nwhile ( ch != '-' || nextch != '-' ) { \nch = nextch ; \nnextch = nextChar ( ) ; \n} \n} \nelse { \nstack [ top = top + 1 ] = nextch ; \nstack [ top = top + 1 ] = ch ; \nbreak ; \n} \n} \nch = nextChar ( ) ; \nif ( ch == '\"' || ch == '\\'' ) { \nint quote = ch ; \nwhile ( ( ch = nextChar ( ) ) != quote ) { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \n} \nreturn token ; \n} \nelse { \nwhile ( ch > ' ' ) { \nnextch = nextChar ( ) ; \nif ( ch == '-' && nextch == '-' ) { \nstack [ top = top + 1 ] = ch ; \nstack [ top = top + 1 ] = nextch ; \nreturn token ; \n} \nelse { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \nch = nextch ; \n} \n} \nreturn token ; \n} \n} \n} \n"}
{"9407": "public class Graph { \npublic boolean removeVertex ( Vertex < T > v ) { \nif ( ! verticies . containsValue ( v ) ) return false ; \nverticies . remove ( v . getName ( ) ) ; \nif ( v == rootVertex ) rootVertex = null ; \nfor ( int n = 0 ; \nn < v . getOutgoingEdgeCount ( ) ; \nn = n + 1 ) { \nEdge < T > e = v . getOutgoingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > to = e . getTo ( ) ; \nto . remove ( e ) ; \nedges . remove ( e ) ; \n} \nfor ( int n = 0 ; \nn < v . getIncomingEdgeCount ( ) ; \nn = n + 1 ) { \nEdge < T > e = v . getIncomingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > predecessor = e . getFrom ( ) ; \npredecessor . remove ( e ) ; \n} \nreturn true ; \n} \n} \n"}
{"9409": "public class Graph { \npublic void dfsSpanningTree ( Vertex < T > v , DFSVisitor < T > visitor ) { \nv . visit ( ) ; \nif ( visitor != null ) visitor . visit ( this , v ) ; \nfor ( int i = 0 ; \ni < v . getOutgoingEdgeCount ( ) ; \ni = i + 1 ) { \nEdge < T > e = v . getOutgoingEdge ( i ) ; \nif ( ! e . getTo ( ) . visited ( ) ) { \nif ( visitor != null ) visitor . visit ( this , v , e ) ; \ne . mark ( ) ; \ndfsSpanningTree ( e . getTo ( ) , visitor ) ; \n} \n} \n} \n} \n"}
{"9411": "public class Graph { \npublic Edge < T > [ ] findCycles ( ) { \nArrayList < Edge < T > > cycleEdges = new ArrayList < Edge < T > > ( ) ; \nfor ( int n = 0 ; \nn < verticies . size ( ) ; \nn = n + 1 ) { \nVertex < T > v = getVertex ( n ) ; \nv . setMarkState ( VISIT_COLOR_WHITE ) ; \n} \nfor ( int n = 0 ; \nn < verticies . size ( ) ; \nn = n + 1 ) { \nVertex < T > v = getVertex ( n ) ; \nvisit ( v , cycleEdges ) ; \n} \nEdge < T > [ ] cycles = new Edge [ cycleEdges . size ( ) ] ; \ncycleEdges . toArray ( cycles ) ; \nreturn cycles ; \n} \n} \n"}
{"9412": "public class DOMWriter { \npublic static String normalize ( String s , boolean canonical ) { \nStringBuffer str = new StringBuffer ( ) ; \nint len = ( s != null ) ? s . length ( ) : 0 ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nchar ch = s . charAt ( i ) ; \nswitch ( ch ) { \ncase '<' : { \nstr . append ( \"&lt;\" ) ; \nbreak ; \n} \ncase '>' : { \nstr . append ( \"&gt;\" ) ; \nbreak ; \n} \ncase '&' : { \nstr . append ( \"&amp;\" ) ; \nbreak ; \n} \ncase '\"' : { \nstr . append ( \"&quot;\" ) ; \nbreak ; \n} \ncase '\\'' : { \nstr . append ( \"&apos;\" ) ; \nbreak ; \n} \ncase '\\r' : case '\\n' : { \nif ( canonical ) { \nstr . append ( \"&#\" ) ; \nstr . append ( Integer . toString ( ch ) ) ; \nstr . append ( ';' ) ; \nbreak ; \n} \n} \ndefault : { \nstr . append ( ch ) ; \n} \n} \n} \nreturn ( str . toString ( ) ) ; \n} \n} \n"}
{"9418": "public class DOMUtils { \npublic static void copyAttributes ( Element destElement , Element srcElement ) { \nNamedNodeMap attribs = srcElement . getAttributes ( ) ; \nfor ( int i = 0 ; \ni < attribs . getLength ( ) ; \ni = i + 1 ) { \nAttr attr = ( Attr ) attribs . item ( i ) ; \nString uri = attr . getNamespaceURI ( ) ; \nString qname = attr . getName ( ) ; \nString value = attr . getNodeValue ( ) ; \nif ( uri == null && qname . startsWith ( \"xmlns\" ) ) { \nlog . trace ( \"Ignore attribute: [uri=\" + uri + \",qname=\" + qname + \",value=\" + value + \"]\" ) ; \n} \nelse { \ndestElement . setAttributeNS ( uri , qname , value ) ; \n} \n} \n} \n} \n"}
{"9419": "public class DOMUtils { \npublic static boolean hasChildElements ( Node node ) { \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nlist . getLength ( ) ; \ni = i + 1 ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . ELEMENT_NODE ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"9420": "public class DOMUtils { \npublic static Iterator getChildElements ( Node node ) { \nArrayList list = new ArrayList ( ) ; \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nlist . getLength ( ) ; \ni = i + 1 ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . ELEMENT_NODE ) list . add ( child ) ; \n} \nreturn list . iterator ( ) ; \n} \n} \n"}
{"9421": "public class DOMUtils { \npublic static String getTextContent ( Node node , boolean replaceProps ) { \nboolean hasTextContent = false ; \nStringBuffer buffer = new StringBuffer ( ) ; \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nlist . getLength ( ) ; \ni = i + 1 ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . TEXT_NODE ) { \nbuffer . append ( child . getNodeValue ( ) ) ; \nhasTextContent = true ; \n} \n} \nString text = ( hasTextContent ? buffer . toString ( ) : null ) ; \nif ( text != null && replaceProps ) text = StringPropertyReplacer . replaceProperties ( text ) ; \nreturn text ; \n} \n} \n"}
{"9430": "public class Classes { \npublic static void displayClassInfo ( Class clazz , StringBuffer results ) { \nClassLoader cl = clazz . getClassLoader ( ) ; \nresults . append ( \"\\n\" ) ; \nresults . append ( clazz . getName ( ) ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( clazz . hashCode ( ) ) ) ; \nresults . append ( \").ClassLoader=\" ) ; \nresults . append ( cl ) ; \nClassLoader parent = cl ; \nwhile ( parent != null ) { \nresults . append ( \"\\n..\" ) ; \nresults . append ( parent ) ; \nURL [ ] urls = getClassLoaderURLs ( parent ) ; \nint length = urls != null ? urls . length : 0 ; \nfor ( int u = 0 ; \nu < length ; \nu = u + 1 ) { \nresults . append ( \"\\n....\" ) ; \nresults . append ( urls [ u ] ) ; \n} \nif ( parent != null ) parent = parent . getParent ( ) ; \n} \nCodeSource clazzCS = clazz . getProtectionDomain ( ) . getCodeSource ( ) ; \nif ( clazzCS != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( clazzCS ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \nresults . append ( \"\\nImplemented Interfaces:\" ) ; \nClass [ ] ifaces = clazz . getInterfaces ( ) ; \nfor ( int i = 0 ; \ni < ifaces . length ; \ni = i + 1 ) { \nClass iface = ifaces [ i ] ; \nresults . append ( \"\\n++\" ) ; \nresults . append ( iface ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( iface . hashCode ( ) ) ) ; \nresults . append ( \")\" ) ; \nClassLoader loader = ifaces [ i ] . getClassLoader ( ) ; \nresults . append ( \"\\n++++ClassLoader: \" ) ; \nresults . append ( loader ) ; \nProtectionDomain pd = ifaces [ i ] . getProtectionDomain ( ) ; \nCodeSource cs = pd . getCodeSource ( ) ; \nif ( cs != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( cs ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \n} \n} \n} \n"}
{"9431": "public class Classes { \npublic static void describe ( StringBuffer buffer , Class clazz ) { \nif ( clazz == null ) buffer . append ( \"**null**\" ) ; \nelse { \nbuffer . append ( \"{class=\" ) . append ( clazz . getName ( ) ) ; \nClass [ ] intfs = clazz . getInterfaces ( ) ; \nif ( intfs . length > 0 ) { \nbuffer . append ( \" intfs=\" ) ; \nfor ( int i = 0 ; \ni < intfs . length ; \ni = i + 1 ) { \nbuffer . append ( intfs [ i ] . getName ( ) ) ; \nif ( i < intfs . length - 1 ) buffer . append ( \", \" ) ; \n} \n} \nbuffer . append ( \"}\" ) ; \n} \n} \n} \n"}
{"9434": "public class Classes { \npublic static void forceLoad ( final Class type ) { \nif ( type == null ) throw new NullArgumentException ( \"type\" ) ; \nif ( type . isPrimitive ( ) ) return ; \nString packageName = Classes . getPackageName ( type ) ; \nif ( packageName . startsWith ( \"java.\" ) || packageName . startsWith ( \"javax.\" ) ) { \nreturn ; \n} \ntry { \nMethod methods [ ] = type . getDeclaredMethods ( ) ; \nMethod method = null ; \nfor ( int i = 0 ; \ni < methods . length ; \ni = i + 1 ) { \nint modifiers = methods [ i ] . getModifiers ( ) ; \nif ( Modifier . isStatic ( modifiers ) ) { \nmethod = methods [ i ] ; \nbreak ; \n} \n} \nif ( method != null ) { \nmethod . invoke ( null , ( Object [ ] ) null ) ; \n} \nelse { \ntype . newInstance ( ) ; \n} \n} \ncatch ( Exception ignore ) { \nThrowableHandler . add ( ignore ) ; \n} \n} \n} \n"}
{"9436": "public class Classes { \npublic static void getAllInterfaces ( List allIfaces , Class c ) { \nwhile ( c != null ) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \nfor ( int n = 0 ; \nn < ifaces . length ; \nn = n + 1 ) { \nallIfaces . add ( ifaces [ n ] ) ; \n} \nc = c . getSuperclass ( ) ; \n} \n} \n} \n"}
{"9437": "public class Classes { \npublic static Class [ ] getAllUniqueInterfaces ( Class c ) { \nSet uniqueIfaces = new HashSet ( ) ; \nwhile ( c != null ) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \nfor ( int n = 0 ; \nn < ifaces . length ; \nn = n + 1 ) { \nuniqueIfaces . add ( ifaces [ n ] ) ; \n} \nc = c . getSuperclass ( ) ; \n} \nreturn ( Class [ ] ) uniqueIfaces . toArray ( new Class [ uniqueIfaces . size ( ) ] ) ; \n} \n} \n"}
{"9442": "public class Classes { \nprivate final static Class convertToJavaClass ( String name , ClassLoader cl ) throws ClassNotFoundException { \nint arraySize = 0 ; \nwhile ( name . endsWith ( \"[]\" ) ) { \nname = name . substring ( 0 , name . length ( ) - 2 ) ; \narraySize = arraySize + 1 ; \n} \nClass c = ( Class ) PRIMITIVE_NAME_TYPE_MAP . get ( name ) ; \nif ( c == null ) { \ntry { \nc = cl . loadClass ( name ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \nthrow new ClassNotFoundException ( \"Parameter class not found: \" + name ) ; \n} \n} \nif ( arraySize > 0 ) { \nint [ ] dims = new int [ arraySize ] ; \nfor ( int i = 0 ; \ni < arraySize ; \ni = i + 1 ) { \ndims [ i ] = 1 ; \n} \nc = Array . newInstance ( c , dims ) . getClass ( ) ; \n} \nreturn c ; \n} \n} \n"}
{"9448": "public class PropertyGroup { \n@ SuppressWarnings ( \"unchecked\" ) public Set entrySet ( ) { \nfinal Set superSet = super . entrySet ( true ) ; \nreturn new java . util . AbstractSet ( ) { \nprivate boolean isInGroup ( Map . Entry entry ) { \nString key = ( String ) entry . getKey ( ) ; \nreturn key . startsWith ( basename ) ; \n} \npublic int size ( ) { \nIterator iter = superSet . iterator ( ) ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \ncount = count + 1 ; \n} \n} \nreturn count ; \n} \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nprivate Iterator iter = superSet . iterator ( ) ; \nprivate Object next ; \npublic boolean hasNext ( ) { \nif ( next != null ) return true ; \nwhile ( next == null ) { \nif ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \nnext = entry ; \nreturn true ; \n} \n} \nelse { \nbreak ; \n} \n} \nreturn false ; \n} \npublic Object next ( ) { \nif ( next == null ) throw new java . util . NoSuchElementException ( ) ; \nObject obj = next ; \nnext = null ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"9462": "public class Util { \nprotected static void appendClassInfo ( StringBuffer buffer , Class clazz ) { \nbuffer . append ( \"[class=\" ) . append ( clazz . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( clazz . getClassLoader ( ) ) ; \nbuffer . append ( \" interfaces={\" ) ; \nClass [ ] interfaces = clazz . getInterfaces ( ) ; \nfor ( int i = 0 ; \ni < interfaces . length ; \ni = i + 1 ) { \nif ( i > 0 ) buffer . append ( \", \" ) ; \nbuffer . append ( \"interface=\" ) . append ( interfaces [ i ] . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( interfaces [ i ] . getClassLoader ( ) ) ; \n} \nbuffer . append ( \"}]\" ) ; \n} \n} \n"}
{"9482": "public class FilePropertyReader { \npublic Map readProperties ( ) throws PropertyException , IOException { \nProperties props = new Properties ( ) ; \nfor ( int i = 0 ; \ni < filenames . length ; \ni = i + 1 ) { \nloadProperties ( props , filenames [ i ] ) ; \n} \nreturn props ; \n} \n} \n"}
{"9491": "public class JarUtils { \nprivate static void jar ( File src , String prefix , JarInfo info ) throws IOException { \nJarOutputStream jout = info . out ; \nif ( src . isDirectory ( ) ) { \nprefix = prefix + src . getName ( ) + \"/\" ; \nZipEntry entry = new ZipEntry ( prefix ) ; \nentry . setTime ( src . lastModified ( ) ) ; \nentry . setMethod ( JarOutputStream . STORED ) ; \nentry . setSize ( 0L ) ; \nentry . setCrc ( 0L ) ; \njout . putNextEntry ( entry ) ; \njout . closeEntry ( ) ; \nFile [ ] files = src . listFiles ( info . filter ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni = i + 1 ) { \njar ( files [ i ] , prefix , info ) ; \n} \n} \nelse if ( src . isFile ( ) ) { \nbyte [ ] buffer = info . buffer ; \nZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; \nentry . setTime ( src . lastModified ( ) ) ; \njout . putNextEntry ( entry ) ; \nFileInputStream in = new FileInputStream ( src ) ; \nint len ; \nwhile ( ( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ) { \njout . write ( buffer , 0 , len ) ; \n} \nin . close ( ) ; \njout . closeEntry ( ) ; \n} \n} \n} \n"}
{"9492": "public class CompoundIterator { \npublic boolean hasNext ( ) { \nfor ( ; \nindex < iters . length ; \nindex = index + 1 ) { \nif ( iters [ index ] != null && iters [ index ] . hasNext ( ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9495": "public class StructsBatchCompiler { \nprotected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { \nif ( ! parentFolder . exists ( ) ) { \nreturn true ; \n} \nif ( filter == null ) filter = ACCEPT_ALL_FILTER ; \nlog . debug ( \"Cleaning folder \" + parentFolder . toString ( ) ) ; \nfinal File [ ] contents = parentFolder . listFiles ( filter ) ; \nfor ( int j = 0 ; \nj < contents . length ; \nj = j + 1 ) { \nfinal File file = contents [ j ] ; \nif ( file . isDirectory ( ) ) { \nif ( ! cleanFolder ( file , filter , continueOnError , true ) && ! continueOnError ) return false ; \n} \nelse { \nif ( ! file . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + file . getAbsolutePath ( ) ) ; \nif ( ! continueOnError ) return false ; \n} \n} \n} \nif ( deleteParentFolder ) { \nif ( parentFolder . list ( ) . length == 0 && ! parentFolder . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + parentFolder . getAbsolutePath ( ) ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9524": "public class UBValue { \npublic boolean [ ] asBoolArray ( ) { \nboolean [ ] retval ; \nUBArray array = asArray ( ) ; \nswitch ( array . getStrongType ( ) ) { \ncase Int8 : { \nbyte [ ] data = ( ( UBInt8Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni = i + 1 ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ncase Int16 : { \nshort [ ] data = ( ( UBInt16Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni = i + 1 ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ncase Int32 : { \nint [ ] data = ( ( UBInt32Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni = i + 1 ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ncase Int64 : { \nlong [ ] data = ( ( UBInt64Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni = i + 1 ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ncase Float32 : { \nfloat [ ] data = ( ( UBFloat32Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni = i + 1 ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ncase Float64 : { \ndouble [ ] data = ( ( UBFloat64Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ni < data . length ; \ni = i + 1 ) { \nretval [ i ] = data [ i ] > 0 ; \n} \nbreak ; \n} \ndefault : throw new RuntimeException ( \"not an int32[] type\" ) ; \n} \nreturn retval ; \n} \n} \n"}
{"9530": "public class CsvTableWriter { \npublic int dumpToCsv ( Context ctx , SQLiteDatabase db , String suffix ) throws FileNotFoundException { \nint numRowsWritten = 0 ; \nCursor c ; \nString filename = getCsvFilename ( db . getPath ( ) , db . getVersion ( ) , suffix ) ; \nc = db . query ( th . getTableName ( ) , null , null , null , null , null , null ) ; \nFileOutputStream fos ; \nfos = ctx . openFileOutput ( filename , 0 ) ; \nPrintWriter printWriter = new PrintWriter ( fos ) ; \nString headerRow = buildHeaderRow ( ) ; \nprintWriter . println ( headerRow ) ; \nfor ( boolean hasItem = c . moveToFirst ( ) ; \nhasItem ; \nhasItem = c . moveToNext ( ) ) { \nString csv = buildCsvRow ( c ) ; \nprintWriter . println ( csv ) ; \nnumRowsWritten = numRowsWritten + 1 ; \n} \nprintWriter . flush ( ) ; \nprintWriter . close ( ) ; \nreturn numRowsWritten ; \n} \n} \n"}
{"9556": "public class PlanBindings { \npublic void add ( Plan plan , Set < Belief > planBindings ) { \nif ( plan == null ) { \nreturn ; \n} \nif ( this . bindings . containsKey ( plan ) ) { \nSet < Belief > oldBindings = this . bindings . remove ( plan ) ; \nif ( oldBindings == null || oldBindings . isEmpty ( ) ) { \ncachedsize = cachedsize - 1 ; \n} \nelse { \ncachedsize -= oldBindings . size ( ) ; \n} \n} \nthis . bindings . put ( plan , planBindings ) ; \nif ( planBindings == null || planBindings . isEmpty ( ) ) { \ncachedsize = cachedsize + 1 ; \n} \nelse { \ncachedsize += planBindings . size ( ) ; \n} \n} \n} \n"}
{"9559": "public class PlanBindings { \nprivate final void setPlanVariables ( Agent agent , Plan planInstance , Set < Belief > results , int choice ) { \nif ( agent == null || planInstance == null ) { \nreturn ; \n} \nBelief belief = getResultAtIndex ( results , choice ) ; \nif ( belief == null ) { \nreturn ; \n} \nObject [ ] tuple = belief . getTuple ( ) ; \nif ( tuple == null ) { \nreturn ; \n} \nint index = 0 ; \nHashMap < String , Object > vars = new HashMap < String , Object > ( ) ; \nfor ( Object o : belief . getTuple ( ) ) { \ntry { \nString fieldname = ABeliefStore . getFieldName ( agent . getId ( ) , belief . getBeliefset ( ) , index ) ; \nvars . put ( fieldname , o ) ; \n} \ncatch ( BeliefBaseException e ) { \nLog . error ( \"Agent \" + agent . getId ( ) + \" could not retrive belief set field: \" + e . getMessage ( ) ) ; \n} \nindex = index + 1 ; \n} \nplanInstance . setPlanVariables ( vars ) ; \n} \n} \n"}
{"9560": "public class PlanBindings { \nprivate Belief getResultAtIndex ( Set < Belief > results , int index ) { \nBelief belief = null ; \nif ( ! ( results == null || index < 0 || index >= results . size ( ) ) ) { \nint idx = 0 ; \nfor ( Belief b : results ) { \nif ( idx == index ) { \nbelief = b ; \nbreak ; \n} \nidx = idx + 1 ; \n} \n} \nreturn belief ; \n} \n} \n"}
{"9565": "public class Plan { \npublic void step ( ) { \nif ( body == null || body . length == 0 || index < 0 || index >= body . length ) { \nreturn ; \n} \nbody [ index = index + 1 ] . step ( ) ; \n} \n} \n"}
{"9569": "public class Program { \nstatic void initIntentionSelectionThreads ( Config config ) { \nint ncores = config . getNumThreads ( ) ; \nMain . intentionSelectors = new IntentionSelector [ ncores ] ; \nfor ( int i = 0 ; \ni < Main . npools ; \ni = i + 1 ) { \nMain . intentionSelectors [ i ] = new IntentionSelector ( i , config . getRandomSeed ( ) ) ; \n} \n} \n} \n"}
{"9570": "public class Program { \nstatic void startIntentionSelectionThreads ( ) { \nfor ( int i = 0 ; \ni < Main . npools ; \ni = i + 1 ) { \nThread thread = new Thread ( Main . intentionSelectors [ i ] ) ; \nthread . setName ( \"jill-\" + i ) ; \nthread . start ( ) ; \n} \n} \n} \n"}
{"9571": "public class Program { \nstatic void shutdownIntentionSelectionThreads ( ) { \nfor ( int i = 0 ; \ni < Main . npools ; \ni = i + 1 ) { \nMain . intentionSelectors [ i ] . shutdown ( ) ; \n} \n} \n} \n"}
{"9575": "public class ProgramLoader { \nprivate static boolean processPlansForGoal ( GoalType gtype , String [ ] plans ) { \nfor ( int j = 0 ; \nj < plans . length ; \nj = j + 1 ) { \nClass < ? > pclass = loadClass ( plans [ j ] , Plan . class ) ; \nif ( pclass == null ) { \nreturn false ; \n} \nlogger . info ( \"Found Plan \" + pclass . getName ( ) + \" that handles Goal \" + gtype . getName ( ) ) ; \nPlanType ptype = new PlanType ( pclass . getName ( ) ) ; \nptype . setPlanClass ( pclass ) ; \nGlobalState . planTypes . push ( ptype ) ; \nptype . addParent ( ( byte ) gtype . getId ( ) ) ; \ngtype . addChild ( ( byte ) ptype . getId ( ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"9576": "public class ProgramLoader { \nprivate static void createAgentsInCatalog ( AObjectCatalog agents , AgentType atype , Class < ? > aclass , int num ) { \nint added = 0 ; \ntry { \nfor ( int i = 0 ; \ni < num ; \ni = i + 1 ) { \nAgent agent = ( Agent ) ( aclass . getConstructor ( String . class ) . newInstance ( \"a\" + Integer . toString ( i ) ) ) ; \nagent . setGoals ( atype . getGoals ( ) ) ; \nagents . push ( agent ) ; \nadded = added + 1 ; \n} \nlogger . info ( \"Finished loading {} agents\" , added ) ; \n} \ncatch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nlogger . error ( \"Could not create instance of class \" + aclass . getName ( ) ) ; \n} \n} \n} \n"}
{"9579": "public class AObject { \npublic static boolean isNameEqual ( AObject obj1 , AObject obj2 ) { \nif ( obj1 . name == null || obj2 . name == null || obj1 . name . length != obj2 . name . length || obj1 . name . length == 0 ) { \nreturn false ; \n} \nfor ( int i = 0 ; \ni < obj1 . name . length ; \ni = i + 1 ) { \nif ( obj1 . name [ i ] != obj2 . name [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9581": "public class ArgumentsLoader { \npublic static void parse ( String [ ] args ) { \nfor ( int i = 0 ; \nargs != null && i < args . length ; \ni = i + 1 ) { \nif ( \"--help\" . equals ( args [ i ] ) ) { \nabort ( null ) ; \n} \nif ( i + 1 < args . length ) { \nparseArgumentWithOption ( args [ i ] , args [ i = i + 1 ] ) ; \n} \n} \nif ( config == null ) { \nabort ( \"Configuration file or string was not given\" ) ; \n} \nelse if ( config . getAgents ( ) == null || config . getAgents ( ) . isEmpty ( ) ) { \nabort ( \"Configuration is missing agents specification\" ) ; \n} \n} \n} \n"}
{"9585": "public class AObjectCatalog { \npublic AObject find ( String name ) { \nfor ( int i = 0 ; \ni < nextid ; \ni = i + 1 ) { \nif ( objects [ i ] . getName ( ) . equals ( name ) ) { \nreturn objects [ i ] ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9586": "public class AObjectCatalog { \npublic void push ( AObject obj ) { \nif ( obj == null || obj . getId ( ) != GlobalConstant . NULLID ) { \nreturn ; \n} \nif ( nextid == objects . length ) { \ngrow ( ) ; \n} \nobj . setId ( nextid ) ; \nobjects [ nextid = nextid + 1 ] = obj ; \n} \n} \n"}
{"9588": "public class Stack255 { \npublic boolean push ( Object obj ) { \nif ( isFull ( ) ) { \nreturn false ; \n} \nif ( size == objects . length ) { \ngrow ( ) ; \n} \nobjects [ size = size + 1 ] = obj ; \nreturn true ; \n} \n} \n"}
{"9589": "public class Stack255 { \npublic Object pop ( ) { \nif ( isEmpty ( ) ) { \nreturn null ; \n} \nsize = size - 1 ; \nObject obj = objects [ size ] ; \nobjects [ size ] = null ; \nreturn obj ; \n} \n} \n"}
{"9602": "public class BeliefSet { \npublic BeliefSetField getFieldByName ( String name ) { \nBeliefSetField field = null ; \nfor ( int i = 0 ; \ni < fields . length ; \ni = i + 1 ) { \nif ( name . equals ( fields [ i ] . getName ( ) ) ) { \nfield = fields [ i ] ; \nbreak ; \n} \n} \nreturn field ; \n} \n} \n"}
{"9603": "public class Greeter { \nprivate void registerNeighbours ( Random rand , int count ) throws BeliefBaseException { \nint size = ( count < 0 ) ? 0 : count ; \nfor ( int i = 0 ; \ni < size ; \ni = i + 1 ) { \nboolean male = ( rand . nextDouble ( ) < 0.5 ) ? true : false ; \nthis . addBelief ( beliefset , buildName ( male ) , male ? \"male\" : \"female\" ) ; \n} \n} \n} \n"}
{"9608": "public class IntentionSelector { \nprivate boolean manageGoal ( int agentIndex , Agent agent , Stack255 agentExecutionStack , Goal node ) { \nGoalType gtype = ( GoalType ) GlobalState . goalTypes . find ( node . getClass ( ) . getName ( ) ) ; \nbyte [ ] ptypes = gtype . getChildren ( ) ; \nassert ( ptypes != null ) ; \nbindings . clear ( ) ; \nfor ( int p = 0 ; \np < ptypes . length ; \np = p + 1 ) { \nPlanType ptype = ( PlanType ) GlobalState . planTypes . get ( ptypes [ p ] ) ; \ntry { \nPlan planInstance = ( Plan ) ( ptype . getPlanClass ( ) . getConstructor ( Agent . class , Goal . class , String . class ) . newInstance ( GlobalState . agents . get ( agentIndex ) , node , \"p\" ) ) ; \nagent . clearLastResults ( ) ; \nif ( planInstance . context ( ) ) { \nSet < Belief > results = agent . getLastResults ( ) ; \nbindings . add ( planInstance , ( results == null ) ? null : new LinkedHashSet < Belief > ( results ) ) ; \n} \n} \ncatch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nlogger . error ( \"Could not create plan object of type \" + ptype . getClass ( ) . getName ( ) , e ) ; \n} \n} \nint numBindings = bindings . size ( ) ; \nif ( numBindings == 0 ) { \nlogger . debug ( Log . logPrefix ( agent . getId ( ) ) + \" has no applicable plans for goal \" + gtype + \" and will continue to wait indefinitely\" ) ; \nreturn false ; \n} \nagent . notifyAgentPrePlanSelection ( bindings ) ; \nPlan planInstance = bindings . selectPlan ( GlobalConstant . PLAN_SELECTION_POLICY ) ; \nsynchronized ( agentExecutionStack ) { \nlogger . debug ( Log . logPrefix ( agent . getId ( ) ) + \" choose an instance of plan \" + planInstance . getClass ( ) . getSimpleName ( ) + \" to handle goal \" + node . getClass ( ) . getSimpleName ( ) ) ; \nagentExecutionStack . push ( planInstance ) ; \n} \nreturn true ; \n} \n} \n"}
{"9614": "public class Main { \npublic static void finish ( ) { \nfor ( JillExtension extension : GlobalState . eventHandlers ) { \nextension . finish ( ) ; \n} \nProgram . shutdownIntentionSelectionThreads ( ) ; \nlong t0 = System . currentTimeMillis ( ) ; \nfor ( int i = 0 ; \ni < GlobalState . agents . size ( ) ; \ni = i + 1 ) { \nAgent agent = ( Agent ) GlobalState . agents . get ( i ) ; \nagent . finish ( ) ; \n} \nif ( writer != null ) { \nwriter . close ( ) ; \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Terminated \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \n} \n} \n"}
{"9615": "public class Main { \npublic static boolean arePoolsIdle ( ) { \nboolean idle = true ; \nfor ( int i = 0 ; \ni < npools ; \ni = i + 1 ) { \nidle &= ( intentionSelectors [ i ] == null ) || intentionSelectors [ i ] . isIdle ( ) ; \n} \nreturn idle ; \n} \n} \n"}
{"9627": "public class ContentType { \nprivate static Map < String , String > parseParameters ( String expression ) { \nMap < String , String > parameters = new HashMap < > ( ) ; \nint parametersSeparatorIndex = 0 ; \nfor ( ; \n; \n) { \nint valueSeparatorIndex = expression . indexOf ( '=' , parametersSeparatorIndex ) ; \nif ( valueSeparatorIndex == - 1 ) { \nbreak ; \n} \nString name = expression . substring ( parametersSeparatorIndex , valueSeparatorIndex ) . trim ( ) ; \nvalueSeparatorIndex = valueSeparatorIndex + 1 ; \nparametersSeparatorIndex = expression . indexOf ( ';' , valueSeparatorIndex ) ; \nif ( parametersSeparatorIndex == - 1 ) { \nparametersSeparatorIndex = expression . length ( ) ; \n} \nif ( valueSeparatorIndex == parametersSeparatorIndex ) { \nthrow new SyntaxException ( \"Invalid content type parameters |%s|. Value is empty.\" , expression ) ; \n} \nif ( parameters . put ( name , expression . substring ( valueSeparatorIndex , parametersSeparatorIndex ) . trim ( ) ) != null ) { \nthrow new SyntaxException ( \"Invalid content type parameters |%s|. Name override |%s|.\" , expression , name ) ; \n} \nparametersSeparatorIndex = parametersSeparatorIndex + 1 ; \n} \nif ( parameters . isEmpty ( ) ) { \nthrow new SyntaxException ( \"Invalid content type parameters |%s|. Missing name/value separator.\" , expression ) ; \n} \nreturn parameters ; \n} \n} \n"}
{"9666": "public class MultipartMixedArgumentsReader { \n@ Override public Object [ ] read ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException , IllegalArgumentException { \ntry { \nObject [ ] arguments = new Object [ formalParameters . length ] ; \nint argumentIndex = 0 ; \nServletFileUpload multipart = new ServletFileUpload ( ) ; \nFileItemIterator iterator = multipart . getItemIterator ( httpRequest ) ; \nFileItemStream fileItemStream = null ; \nwhile ( iterator . hasNext ( ) ) { \nfileItemStream = iterator . next ( ) ; \nString contentType = fileItemStream . getContentType ( ) ; \nType parameterType = formalParameters [ argumentIndex ] ; \nArgumentPartReader reader = argumentsReaderFactory . getArgumentPartReader ( contentType , parameterType ) ; \nboolean streamArgument = StreamFactory . isStream ( parameterType ) ; \nArgumentPartReader argumentPartReader = ( ArgumentPartReader ) reader ; \nInputStream inputStream = streamArgument ? new LazyFileItemStream ( fileItemStream ) : fileItemStream . openStream ( ) ; \narguments [ argumentIndex ] = argumentPartReader . read ( inputStream , parameterType ) ; \nargumentIndex = argumentIndex + 1 ; \nif ( streamArgument ) { \nthreadLocal . set ( inputStream ) ; \nbreak ; \n} \ninputStream . close ( ) ; \n} \nif ( argumentIndex != formalParameters . length ) { \nthrow new IllegalArgumentException ( \"Not all parameters processed due to stream argument that is not the last on arguments list.\" ) ; \n} \nreturn arguments ; \n} \ncatch ( FileUploadException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"9677": "public class StatementImpl { \npublic void setStringArray ( String parameterName , String ... values ) throws java . sql . SQLException { \nint arrayLen = this . getSql ( ) . getArrayLen ( parameterName ) ; \nAssertUtils . assertTrue ( values . length <= arrayLen ) ; \nfor ( int i = 0 ; \ni < arrayLen ; \ni = i + 1 ) { \nsetString2 ( Sql . toParamName ( parameterName , i ) , ( i < values . length ) ? values [ i ] : null ) ; \n} \n} \n} \n"}
{"9696": "public class EventStream { \nprotected void setRemoteHost ( String remoteHost ) { \nif ( string == null ) { \nstring = Strings . concat ( '#' , STREAM_ID = STREAM_ID + 1 , ':' , remoteHost ) ; \n} \n} \n} \n"}
{"9699": "public class FileSystemDirectoryHelper { \npublic File getCommonDir ( final File dir1 , final File dir2 ) throws IOException { \nList < File > parts1 = getParentDirs ( dir1 ) ; \nList < File > parts2 = getParentDirs ( dir2 ) ; \nFile matched = null ; \nfinal int maxCommonSize = Math . min ( parts1 . size ( ) , parts2 . size ( ) ) ; \nfor ( int i = 0 ; \ni < maxCommonSize ; \ni = i + 1 ) { \nif ( parts1 . get ( i ) . equals ( parts2 . get ( i ) ) ) { \nmatched = parts1 . get ( i ) ; \n} \nelse { \nbreak ; \n} \n} \nreturn matched ; \n} \n} \n"}
{"9700": "public class FileSystemDirectoryHelper { \npublic String abs2rel ( final String basePath , final String absPath ) { \nif ( ! isAbsolutePath ( absPath ) ) { \nreturn absPath ; \n} \nif ( isWindowsDrive ( absPath ) && isWindowsDrive ( basePath ) && absPath . charAt ( 0 ) != basePath . charAt ( 0 ) ) { \nreturn absPath ; \n} \nStringBuilder result = new StringBuilder ( ) ; \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] absParts = getParts ( absPath ) ; \nint start = 0 ; \nfor ( int i = 0 ; \ni < Math . min ( baseParts . length , absParts . length ) ; \ni = i + 1 ) { \nif ( baseParts [ i ] . equals ( absParts [ i ] ) ) { \nstart = i + 1 ; \n} \n} \nfor ( int i = start ; \ni < baseParts . length ; \ni = i + 1 ) { \nif ( result . length ( ) > 0 ) { \nresult . append ( File . separator ) ; \n} \nresult . append ( \"..\" ) ; \n} \nfor ( int i = start ; \ni < absParts . length ; \ni = i + 1 ) { \nif ( result . length ( ) > 0 ) { \nresult . append ( File . separator ) ; \n} \nresult . append ( absParts [ i ] ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"9701": "public class FileSystemDirectoryHelper { \npublic File rel2abs ( final String basePath , final String relPath ) { \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] relParts = getParts ( relPath ) ; \nif ( isAbsolutePath ( relPath ) ) { \nreturn new File ( relPath ) ; \n} \nList < String > parts = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < baseParts . length ; \ni = i + 1 ) { \nif ( i > 0 || ! isWindowsDrive ( basePath ) ) { \nparts . add ( baseParts [ i ] ) ; \n} \n} \nfor ( String part : relParts ) { \nif ( part . equals ( \"..\" ) && parts . size ( ) > 0 ) { \nparts . remove ( parts . size ( ) - 1 ) ; \n} \nelse if ( ! part . equals ( \".\" ) && ! part . equals ( \"..\" ) ) { \nparts . add ( part ) ; \n} \n} \nStringBuilder result = new StringBuilder ( ) ; \nif ( isWindowsDrive ( basePath ) ) { \nresult . append ( baseParts [ 0 ] ) ; \n} \nfor ( String part : parts ) { \nresult . append ( File . separator ) ; \nresult . append ( part ) ; \n} \nreturn new File ( result . toString ( ) ) ; \n} \n} \n"}
{"9762": "public class RequestPreprocessor { \nprivate static boolean startsWith ( String requestPath , String pathComponent ) { \nif ( requestPath . charAt ( 0 ) != '/' ) { \nreturn false ; \n} \nint i = 1 ; \nfor ( int j = 0 ; \ni < requestPath . length ( ) ; \ni = i + 1 , j = j + 1 ) { \nif ( requestPath . charAt ( i ) == '/' ) { \nreturn j == pathComponent . length ( ) ; \n} \nif ( j == pathComponent . length ( ) ) { \nreturn false ; \n} \nif ( Character . toLowerCase ( requestPath . charAt ( i ) ) != Character . toLowerCase ( pathComponent . charAt ( j ) ) ) { \nreturn false ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9778": "public class RecursiveFileSelector { \n@ Override public final File next ( ) { \nif ( files == null || fileIndex >= files . length ) { \nif ( ! cacheNext ( ) ) { \nthrow new NoSuchElementException ( ) ; \n} \n} \nreturn files [ fileIndex = fileIndex + 1 ] ; \n} \n} \n"}
{"9877": "public class BlockLocks { \npublic int nextClearBit ( int index ) { \nint i = index >> 6 ; \nif ( i >= wlen ) return - 1 ; \nint subIndex = index & 0x3f ; \nlong word = ~ bits . get ( i ) >> subIndex ; \nif ( word != 0 ) { \nreturn ( i << 6 ) + subIndex + Long . numberOfTrailingZeros ( word ) ; \n} \nwhile ( i = i + 1 < wlen ) { \nword = ~ bits . get ( i ) ; \nif ( word != 0 ) { \nreturn ( i << 6 ) + Long . numberOfTrailingZeros ( word ) ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"9882": "public class PolymerElements { \npublic String toHELM2 ( ) { \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < listMonomerNotations . size ( ) ; \ni = i + 1 ) { \nnotation . append ( listMonomerNotations . get ( i ) . toHELM2 ( ) + \".\" ) ; \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9898": "public class HELM2Notation { \npublic String polymerToHELM2 ( ) { \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < listOfPolymers . size ( ) ; \ni = i + 1 ) { \nif ( listOfPolymers . get ( i ) . isAnnotationHere ( ) ) { \nnotation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\\\"\" + listOfPolymers . get ( i ) . getAnnotation ( ) + \"\\\"|\" ) ; \n} \nelse { \nnotation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\" + \"|\" ) ; \n} \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9899": "public class HELM2Notation { \npublic String connectionToHELM2 ( ) { \nif ( listOfConnections . size ( ) == 0 ) { \nreturn \"\" ; \n} \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < listOfConnections . size ( ) ; \ni = i + 1 ) { \nnotation . append ( listOfConnections . get ( i ) . toHELM2 ( ) + \"|\" ) ; \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9900": "public class HELM2Notation { \npublic String groupingToHELM2 ( ) { \nif ( listOfGroupings . size ( ) == 0 ) { \nreturn \"\" ; \n} \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < listOfGroupings . size ( ) ; \ni = i + 1 ) { \nnotation . append ( listOfGroupings . get ( i ) . toHELM2 ( ) + \"|\" ) ; \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9901": "public class HELM2Notation { \npublic String annotationToHELM2 ( ) { \nif ( ! ( annotationSection . isEmpty ( ) ) ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < annotationSection . size ( ) ; \ni = i + 1 ) { \nsb . append ( annotationSection . get ( i ) . toHELM2 ( ) + \"|\" ) ; \n} \nsb . setLength ( sb . length ( ) - 1 ) ; \nreturn sb . toString ( ) ; \n} \nreturn \"\" ; \n} \n} \n"}
{"9905": "public class ConverterHELM1ToHELM2 { \npublic String doConvert ( String str ) { \nParserHELM2 parser = new ParserHELM2 ( ) ; \ntry { \nparser . parse ( str + \"V2.0\" ) ; \nreturn str + \"V2.0\" ; \n} \ncatch ( Exception e ) { \nString helm1 = str + \"f\" ; \nStringBuilder helm2 = new StringBuilder ( ) ; \nString [ ] sections = helm1 . split ( \"}\\\\$\" ) ; \nhelm2 . append ( sections [ 0 ] + \"}$\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 1 ; \ni < sections . length ; \ni = i + 1 ) { \nsb . append ( sections [ i ] + \"}$\" ) ; \n} \nhelm1 = \"$\" + sb . toString ( ) ; \nsections = helm1 . split ( \"\\\\$\" ) ; \nif ( sections . length >= 2 ) { \nif ( ! ( sections [ 1 ] . isEmpty ( ) ) ) { \nhelm2 . append ( sections [ 1 ] ) ; \n} \n} \nif ( sections . length >= 3 ) { \nif ( ! ( sections [ 2 ] . isEmpty ( ) ) ) { \nif ( ! ( sections [ 1 ] . isEmpty ( ) ) ) { \nhelm2 . append ( \"|\" + sections [ 2 ] ) ; \n} \nelse { \nhelm2 . append ( sections [ 2 ] ) ; \n} \n} \nhelm2 . append ( \"$\" ) ; \nhelm2 . append ( \"$\" ) ; \nif ( sections . length >= 4 ) { \nif ( ! ( sections [ 3 ] . isEmpty ( ) ) ) { \nhelm2 . append ( sections [ 3 ] ) ; \n} \n} \n} \nhelm2 . append ( \"$V2.0\" ) ; \nreturn helm2 . toString ( ) ; \n} \n} \n} \n"}
{"9912": "public class ParserHELM2 { \npublic void parse ( String test ) throws ExceptionState { \nparser = new StateMachineParser ( ) ; \ntest = test . trim ( ) ; \nif ( test . substring ( test . length ( ) - 4 ) . matches ( \"V2\\\\.0\" ) || test . substring ( test . length ( ) - 4 ) . matches ( \"v2\\\\.0\" ) ) { \nfor ( int i = 0 ; \ni < test . length ( ) - 4 ; \ni = i + 1 ) { \nparser . doAction ( test . charAt ( i ) ) ; \n} \nif ( ! ( parser . getState ( ) instanceof FinalState ) ) { \nLOG . error ( \"Invalid input: Final State was not reached:\" ) ; \nthrow new FinalStateException ( \"Invalid input: Final State was not reached\" ) ; \n} \n} \nelse { \nLOG . error ( \"Invalid input: HELM2 standard is missing:\" ) ; \nthrow new NotValidHELM2Exception ( \"Invalid input: HELM2 standard is missing\" ) ; \n} \n} \n} \n"}
{"9931": "public class ForkJoinPool { \nfinal WorkQueue registerWorker ( ForkJoinWorkerThread wt ) { \nUncaughtExceptionHandler handler ; \nwt . setDaemon ( true ) ; \nif ( ( handler = ueh ) != null ) wt . setUncaughtExceptionHandler ( handler ) ; \nWorkQueue w = new WorkQueue ( this , wt ) ; \nint i = 0 ; \nint mode = config & MODE_MASK ; \nint rs = lockRunState ( ) ; \ntry { \nWorkQueue [ ] ws ; \nint n ; \nif ( ( ws = workQueues ) != null && ( n = ws . length ) > 0 ) { \nint s = indexSeed += SEED_INCREMENT ; \nint m = n - 1 ; \ni = ( ( s << 1 ) | 1 ) & m ; \nif ( ws [ i ] != null ) { \nint probes = 0 ; \nint step = ( n <= 4 ) ? 2 : ( ( n >>> 1 ) & EVENMASK ) + 2 ; \nwhile ( ws [ i = ( i + step ) & m ] != null ) { \nif ( probes = probes + 1 >= n ) { \nworkQueues = ws = Arrays . copyOf ( ws , n <<= 1 ) ; \nm = n - 1 ; \nprobes = 0 ; \n} \n} \n} \nw . hint = s ; \nw . config = i | mode ; \nw . scanState = i ; \nws [ i ] = w ; \n} \n} \nfinally { \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nwt . setName ( workerNamePrefix . concat ( Integer . toString ( i >>> 1 ) ) ) ; \nreturn w ; \n} \n} \n"}
{"9935": "public class ForkJoinPool { \nprivate boolean awaitWork ( WorkQueue w , int r ) { \nif ( w == null || w . qlock < 0 ) return false ; \nfor ( int pred = w . stackPred , spins = SPINS , ss ; \n; \n) { \nif ( ( ss = w . scanState ) >= 0 ) break ; \nelse if ( spins > 0 ) { \nr ^= r << 6 ; \nr ^= r >>> 21 ; \nr ^= r << 7 ; \nif ( r >= 0 && spins = spins - 1 == 0 ) { \nWorkQueue v ; \nWorkQueue [ ] ws ; \nint s , j ; \nAtomicLong sc ; \nif ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scanState >= 0 ) ) spins = SPINS ; \n} \n} \nelse if ( w . qlock < 0 ) return false ; \nelse if ( ! Thread . interrupted ( ) ) { \nlong c , prevctl , parkTime , deadline ; \nint ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; \nif ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) return false ; \nif ( ac <= 0 && ss == ( int ) c ) { \nprevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; \nint t = ( short ) ( c >>> TC_SHIFT ) ; \nif ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \nparkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; \ndeadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; \n} \nelse prevctl = parkTime = deadline = 0L ; \nThread wt = Thread . currentThread ( ) ; \nU . putObject ( wt , PARKBLOCKER , this ) ; \nw . parker = wt ; \nif ( w . scanState < 0 && ctl == c ) U . park ( false , parkTime ) ; \nU . putOrderedObject ( w , QPARKER , null ) ; \nU . putObject ( wt , PARKBLOCKER , null ) ; \nif ( w . scanState >= 0 ) break ; \nif ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9943": "public class AThreadPoolImpl { \n@ Override public AThreadPoolStatistics getStatistics ( ) { \nfinal AWorkerThreadStatistics [ ] workerStats = new AWorkerThreadStatistics [ localQueues . length ] ; \nfor ( int i = 0 ; \ni < localQueues . length ; \ni = i + 1 ) { \nworkerStats [ i ] = localQueues [ i ] . thread . getStatistics ( ) ; \n} \nfinal ASharedQueueStatistics [ ] sharedQueueStats = new ASharedQueueStatistics [ sharedQueues . length ] ; \nfor ( int i = 0 ; \ni < sharedQueues . length ; \ni = i + 1 ) { \nsharedQueueStats [ i ] = new ASharedQueueStatistics ( sharedQueues [ i ] . approximateSize ( ) ) ; \n} \nreturn new AThreadPoolStatistics ( workerStats , sharedQueueStats ) ; \n} \n} \n"}
{"9982": "public class CharKit { \npublic static byte [ ] toSimpleByteArray ( char [ ] carr ) { \nbyte [ ] barr = new byte [ carr . length ] ; \nfor ( int i = 0 ; \ni < carr . length ; \ni = i + 1 ) { \nbarr [ i ] = ( byte ) carr [ i ] ; \n} \nreturn barr ; \n} \n} \n"}
{"9983": "public class CharKit { \npublic static byte [ ] toSimpleByteArray ( CharSequence charSequence ) { \nbyte [ ] barr = new byte [ charSequence . length ( ) ] ; \nfor ( int i = 0 ; \ni < barr . length ; \ni = i + 1 ) { \nbarr [ i ] = ( byte ) charSequence . charAt ( i ) ; \n} \nreturn barr ; \n} \n} \n"}
{"9984": "public class CharKit { \npublic static char [ ] toSimpleCharArray ( byte [ ] barr ) { \nchar [ ] carr = new char [ barr . length ] ; \nfor ( int i = 0 ; \ni < barr . length ; \ni = i + 1 ) { \ncarr [ i ] = ( char ) ( barr [ i ] & 0xFF ) ; \n} \nreturn carr ; \n} \n} \n"}
{"9985": "public class CharKit { \npublic static byte [ ] toAsciiByteArray ( CharSequence charSequence ) { \nbyte [ ] barr = new byte [ charSequence . length ( ) ] ; \nfor ( int i = 0 ; \ni < barr . length ; \ni = i + 1 ) { \nchar c = charSequence . charAt ( i ) ; \nbarr [ i ] = ( byte ) ( ( int ) ( c <= 0xFF ? c : 0x3F ) ) ; \n} \nreturn barr ; \n} \n} \n"}
{"10002": "public class RuntimeKit { \npublic static void compactMemory ( ) { \ntry { \nfinal byte [ ] [ ] unused = new byte [ 128 ] [ ] ; \nfor ( int i = unused . length ; \ni = i - 1 != 0 ; \n) { \nunused [ i ] = new byte [ 2000000000 ] ; \n} \n} \ncatch ( OutOfMemoryError ignore ) { \n} \nSystem . gc ( ) ; \n} \n} \n"}
{"10004": "public class LogUtil { \npublic static String encodeString ( String value ) { \nint estimatedSize = 0 ; \nfinal int len = value . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' || ch == ',' ) { \nestimatedSize += 3 ; \ncontinue ; \n} \nestimatedSize = estimatedSize + 1 ; \n} \nif ( value . length ( ) == estimatedSize ) { \nreturn value ; \n} \nfinal StringBuilder builder = new StringBuilder ( estimatedSize ) ; \nfor ( int i = 0 ; \ni < len ; \ni = i + 1 ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ch <= ' ' ) { \nbuilder . append ( \"%20\" ) ; \ncontinue ; \n} \nif ( ch == ',' ) { \nbuilder . append ( \"%2c\" ) ; \ncontinue ; \n} \nbuilder . append ( ch ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"10015": "public class Pipeline { \n@ SuppressWarnings ( \"unchecked\" ) public T apply ( T io ) { \nlogger . debug ( \"Pipeline began\" ) ; \ntry { \nfor ( int i = 0 ; \ni < stages . size ( ) ; \ni = i + 1 ) { \nObject stage = stages . get ( i ) ; \nString name = names . get ( stage ) ; \nlogger . debug ( \"Stage-\" + i + ( ( name != null && ! name . isEmpty ( ) ) ? \" [\" + name + \"] \" : \" \" ) + \"processing\" ) ; \nif ( stage instanceof Function ) { \nif ( ( io = ( ( Function < T , T > ) stage ) . apply ( io ) ) == null ) { \nreturn io ; \n} \n} \nelse if ( stage instanceof Predicate ) { \nif ( ! ( ( Predicate < T > ) stage ) . apply ( io ) ) { \nreturn io ; \n} \n} \n} \nreturn io ; \n} \nfinally { \nlogger . debug ( \"Pipeline ended\" ) ; \n} \n} \n} \n"}
{"10052": "public class URITemplate { \npublic Map < String , String > variables ( String uri ) { \nMap < String , String > variables = new HashMap < String , String > ( ) ; \nMatcher matcher = pattern . matcher ( uri ) ; \nif ( matcher . matches ( ) ) { \nfor ( int i = 0 ; \ni < matcher . groupCount ( ) ; \ni = i + 1 ) { \nvariables . put ( this . variables . get ( i ) , matcher . group ( i + 1 ) ) ; \n} \n} \nreturn variables ; \n} \n} \n"}
{"10101": "public class URI { \nprivate void initializePath ( String p_uriSpec ) throws MalformedURIException { \nif ( p_uriSpec == null ) { \nthrow new MalformedURIException ( \"Cannot initialize path from null string!\" ) ; \n} \nint index = 0 ; \nint start = 0 ; \nint end = p_uriSpec . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '?' || testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Path contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character: \" + testChar ) ; \n} \nindex = index + 1 ; \n} \nm_path = p_uriSpec . substring ( start , index ) ; \nif ( testChar == '?' ) { \nindex = index + 1 ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid character:\" + testChar ) ; \n} \nindex = index + 1 ; \n} \nm_queryString = p_uriSpec . substring ( start , index ) ; \n} \nif ( testChar == '#' ) { \nindex = index + 1 ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid character:\" + testChar ) ; \n} \nindex = index + 1 ; \n} \nm_fragment = p_uriSpec . substring ( start , index ) ; \n} \n} \n} \n"}
{"10103": "public class URI { \nprivate void setUserinfo ( String p_userinfo ) throws MalformedURIException { \nif ( p_userinfo == null ) { \nm_userinfo = null ; \n} \nelse { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Userinfo cannot be set when host is null!\" ) ; \n} \nint index = 0 ; \nint end = p_userinfo . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_userinfo . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid character:\" + testChar ) ; \n} \nindex = index + 1 ; \n} \n} \nm_userinfo = p_userinfo ; \n} \n} \n"}
{"10110": "public class PreparedStatementCreator { \nprotected static PreparedStatement createByIterator ( Connection conn , String sql , Iterator < ? > parameters ) throws SQLException { \nPreparedStatement ps = conn . prepareStatement ( sql ) ; \nif ( parameters != null ) { \nint index = 1 ; \nwhile ( parameters . hasNext ( ) ) { \nObject parameter = parameters . next ( ) ; \nif ( parameter == null ) { \nps . setObject ( index , null ) ; \n} \nelse { \nps . setObject ( index , parameter ) ; \n} \nindex = index + 1 ; \n} \n} \nreturn ps ; \n} \n} \n"}
{"10123": "public class FastBuffer { \n@ Override public Iterator < E > iterator ( ) { \nreturn new Iterator < E > ( ) { \nint iteratorIndex ; \nint iteratorBufferIndex ; \nint iteratorOffset ; \n@ Override public boolean hasNext ( ) { \nreturn iteratorIndex < size ; \n} \n@ Override public E next ( ) { \nif ( iteratorIndex >= size ) { \nthrow new NoSuchElementException ( ) ; \n} \nE [ ] buf = buffers [ iteratorBufferIndex ] ; \nE result = buf [ iteratorOffset ] ; \niteratorIndex = iteratorIndex + 1 ; \niteratorOffset = iteratorOffset + 1 ; \nif ( iteratorOffset >= buf . length ) { \niteratorOffset = 0 ; \niteratorBufferIndex = iteratorBufferIndex + 1 ; \n} \nreturn result ; \n} \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \n} \n"}
{"10139": "public class Util { \npublic static String replaceSlashWithHyphen ( String origin ) { \nchar [ ] resulltChars = origin . toCharArray ( ) ; \nfor ( int i = 0 ; \ni < resulltChars . length - 1 ; \ni = i + 1 ) { \nif ( resulltChars [ i ] == '/' ) { \nresulltChars [ i ] = '-' ; \n} \n} \nreturn new String ( resulltChars , 0 , resulltChars . length - 1 ) ; \n} \n} \n"}
{"10140": "public class Util { \npublic static String bytes2HexString ( byte [ ] bytes ) { \nStringBuffer resultBuffer = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < bytes . length ; \ni = i + 1 ) { \nresultBuffer . append ( byte2Hex ( bytes [ i ] ) ) ; \n} \nreturn resultBuffer . toString ( ) ; \n} \n} \n"}
{"10142": "public class NamedParameterStatement { \nprivate static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { \nint length = sql . length ( ) ; \nStringBuffer parsedSql = new StringBuffer ( length ) ; \nboolean inSingleQuote = false ; \nboolean inDoubleQuote = false ; \nint index = 1 ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nchar c = sql . charAt ( i ) ; \nif ( inSingleQuote ) { \nif ( c == '\\'' ) { \ninSingleQuote = false ; \n} \n} \nelse if ( inDoubleQuote ) { \nif ( c == '\"' ) { \ninDoubleQuote = false ; \n} \n} \nelse { \nif ( c == '\\'' ) { \ninSingleQuote = true ; \n} \nelse if ( c == '\"' ) { \ninDoubleQuote = true ; \n} \nelse if ( c == ':' && i + 1 < length && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { \nint j = i + 2 ; \nwhile ( j < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) { \nj = j + 1 ; \n} \nString name = sql . substring ( i + 1 , j ) ; \nc = '?' ; \ni += name . length ( ) ; \nList < Integer > indexList = nameIndexMap . get ( name ) ; \nif ( indexList == null ) { \nindexList = new LinkedList < Integer > ( ) ; \nnameIndexMap . put ( name , indexList ) ; \n} \nindexList . add ( index ) ; \nindex = index + 1 ; \n} \n} \nparsedSql . append ( c ) ; \n} \nreturn parsedSql . toString ( ) ; \n} \n} \n"}
{"10146": "public class FileExtensionFilter { \npublic boolean accept ( File pathname ) { \nString name = pathname . getName ( ) ; \nint iLastDot = name . lastIndexOf ( '.' ) ; \nString strExtension = \"\" ; \nif ( ( iLastDot != - 1 ) && ( iLastDot != name . length ( ) - 1 ) ) strExtension = name . substring ( iLastDot + 1 ) ; \nif ( m_rgstrIncludeExtensions != null ) { \nfor ( int i = 0 ; \ni < m_rgstrIncludeExtensions . length ; \ni = i + 1 ) { \nif ( m_rgstrIncludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return true ; \n} \nreturn false ; \n} \nif ( m_rgstrExcludeExtensions != null ) { \nfor ( int i = 0 ; \ni < m_rgstrExcludeExtensions . length ; \ni = i + 1 ) { \nif ( m_rgstrExcludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10148": "public class StateParser { \nprivate static Map < ExpectedLabels , Integer > mapLabels ( final List < String > labels ) { \nfinal Map < ExpectedLabels , Integer > map = new EnumMap < > ( ExpectedLabels . class ) ; \nfinal List < ExpectedLabels > unusedLabels = new ArrayList < > ( Arrays . asList ( ExpectedLabels . values ( ) ) ) ; \nfor ( int index = 0 ; \nindex < labels . size ( ) ; \nindex = index + 1 ) { \nfinal String next = labels . get ( index ) ; \nExpectedLabels labelValue ; \ntry { \nlabelValue = ExpectedLabels . valueOf ( next ) ; \nunusedLabels . remove ( labelValue ) ; \nif ( map . containsKey ( labelValue ) ) { \nLOGGER . warn ( \"Duplicate state label: {} ({})\" , next , labels ) ; \n} \nmap . put ( labelValue , index ) ; \n} \ncatch ( final IllegalArgumentException e ) { \nLOGGER . warn ( \"Unexpected state label: {}\" , next ) ; \n} \n} \nfor ( final ExpectedLabels label : unusedLabels ) { \nLOGGER . warn ( \"Unused label: {}\" , label ) ; \n} \nreturn map ; \n} \n} \n"}
{"10159": "public class StringUtils { \npublic static int indexOfIgnoreCase ( String s , String substr , int startIndex , int endIndex ) { \nif ( startIndex < 0 ) { \nstartIndex = 0 ; \n} \nint srclen = s . length ( ) ; \nif ( endIndex > srclen ) { \nendIndex = srclen ; \n} \nint sublen = substr . length ( ) ; \nif ( sublen == 0 ) { \nreturn startIndex > srclen ? srclen : startIndex ; \n} \nsubstr = substr . toLowerCase ( ) ; \nint total = endIndex - sublen + 1 ; \nchar c = substr . charAt ( 0 ) ; \nmainloop : for ( int i = startIndex ; \ni < total ; \ni = i + 1 ) { \nif ( Character . toLowerCase ( s . charAt ( i ) ) != c ) { \ncontinue ; \n} \nint j = 1 ; \nint k = i + 1 ; \nwhile ( j < sublen ) { \nchar source = Character . toLowerCase ( s . charAt ( k ) ) ; \nif ( substr . charAt ( j ) != source ) { \ncontinue mainloop ; \n} \nj = j + 1 ; \nk = k + 1 ; \n} \nreturn i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"10160": "public class StringUtils { \npublic static String removeChars ( String s , String chars ) { \nint i = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( i ) ; \nfor ( int j = 0 ; \nj < i ; \nj = j + 1 ) { \nchar c = s . charAt ( j ) ; \nif ( chars . indexOf ( c ) == - 1 ) { \nsb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"10169": "public class ArrayStack { \npublic void clear ( ) { \nint i = size ; \nObject [ ] els = elements ; \nwhile ( i = i - 1 > 0 ) { \nels [ i ] = null ; \n} \nthis . size = 0 ; \n} \n} \n"}
{"10170": "public class ArrayStack { \npublic T push ( T element ) { \nint i ; \nObject [ ] els ; \nif ( ( i = size = size + 1 ) >= ( els = elements ) . length ) { \nSystem . arraycopy ( els , 0 , els = elements = new Object [ i << 1 ] , 0 , i ) ; \n} \nels [ i ] = element ; \nreturn element ; \n} \n} \n"}
{"10171": "public class ArrayStack { \n@ SuppressWarnings ( \"unchecked\" ) public T pop ( ) throws EmptyStackException { \nint i ; \nif ( ( i = size = size - 1 ) >= 0 ) { \nT element = ( T ) elements [ i ] ; \nelements [ i ] = null ; \nreturn element ; \n} \nelse { \nsize = 0 ; \nthrow new EmptyStackException ( ) ; \n} \n} \n} \n"}
{"10173": "public class AppUtilities { \npublic static Properties parseArgs ( Properties properties , String [ ] args ) { \nif ( properties == null ) properties = new Properties ( ) ; \nif ( args == null ) return properties ; \nfor ( int i = 0 ; \ni < args . length ; \ni = i + 1 ) AppUtilities . addParam ( properties , args [ i ] , false ) ; \nreturn properties ; \n} \n} \n"}
{"10174": "public class WildcharPathUtils { \nprotected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { \nint patNdxStart = 0 ; \nint patNdxEnd = patterns . length - 1 ; \nint tokNdxStart = 0 ; \nint tokNdxEnd = tokens . length - 1 ; \nwhile ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { \nString patDir = patterns [ patNdxStart ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxStart ] , patDir ) ) { \nreturn false ; \n} \npatNdxStart = patNdxStart + 1 ; \ntokNdxStart = tokNdxStart + 1 ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni = i + 1 ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nif ( patNdxStart > patNdxEnd ) { \nreturn false ; \n} \nwhile ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { \nString patDir = patterns [ patNdxEnd ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxEnd ] , patDir ) ) { \nreturn false ; \n} \npatNdxEnd = patNdxEnd - 1 ; \ntokNdxEnd = tokNdxEnd - 1 ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni = i + 1 ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nwhile ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { \nint patIdxTmp = - 1 ; \nfor ( int i = patNdxStart + 1 ; \ni <= patNdxEnd ; \ni = i + 1 ) { \nif ( patterns [ i ] . equals ( PATH_MATCH ) ) { \npatIdxTmp = i ; \nbreak ; \n} \n} \nif ( patIdxTmp == patNdxStart + 1 ) { \npatNdxStart = patNdxStart + 1 ; \ncontinue ; \n} \nint patLength = ( patIdxTmp - patNdxStart - 1 ) ; \nint strLength = ( tokNdxEnd - tokNdxStart + 1 ) ; \nint ndx = - 1 ; \nstrLoop : for ( int i = 0 ; \ni <= strLength - patLength ; \ni = i + 1 ) { \nfor ( int j = 0 ; \nj < patLength ; \nj = j + 1 ) { \nString subPat = patterns [ patNdxStart + j + 1 ] ; \nString subStr = tokens [ tokNdxStart + i + j ] ; \nif ( ! WildcharUtils . match ( subStr , subPat ) ) { \ncontinue strLoop ; \n} \n} \nndx = tokNdxStart + i ; \nbreak ; \n} \nif ( ndx == - 1 ) { \nreturn false ; \n} \npatNdxStart = patIdxTmp ; \ntokNdxStart = ndx + patLength ; \n} \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni = i + 1 ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10182": "public class AreaGrid { \npublic int getColOfs ( int col ) throws ArrayIndexOutOfBoundsException { \nif ( col < width ) { \nint ofs = 0 ; \nfor ( int i = 0 ; \ni < col ; \ni = i + 1 ) ofs += cols [ i ] ; \nreturn ofs ; \n} \nelse if ( col == width ) return abspos . getWidth ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( col + \">\" + width ) ; \n} \n} \n"}
{"10183": "public class AreaGrid { \npublic int getRowOfs ( int row ) throws ArrayIndexOutOfBoundsException { \nif ( row < height ) { \nint ofs = 0 ; \nfor ( int i = 0 ; \ni < row ; \ni = i + 1 ) ofs += rows [ i ] ; \nreturn ofs ; \n} \nelse if ( row == height ) return abspos . getHeight ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( row + \">\" + height ) ; \n} \n} \n"}
{"10185": "public class AreaGrid { \nprivate void calculateColumns ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getX1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getX2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni = i + 1 ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt = cnt + 1 ; \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cnt = cnt + 1 ; \nwidth = cnt ; \nmaxindent = 0 ; \nminindent = - 1 ; \ncols = new int [ width ] ; \ncnt = 0 ; \nlast = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni = i + 1 ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \ncols [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt = cnt + 1 ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setX1 ( cnt ) ; \nmaxindent = cnt ; \nif ( minindent == - 1 ) minindent = maxindent ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setX2 ( cnt - 1 ) ; \nif ( pos . getX2 ( ) < pos . getX1 ( ) ) pos . setX2 ( pos . getX1 ( ) ) ; \n} \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cols [ cnt ] = abspos . getX2 ( ) - last ; \nif ( minindent == - 1 ) minindent = 0 ; \n} \n} \n"}
{"10186": "public class AreaGrid { \nprivate void calculateRows ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getY1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getY2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni = i + 1 ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt = cnt + 1 ; \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) cnt = cnt + 1 ; \nheight = cnt ; \nrows = new int [ height ] ; \ncnt = 0 ; \nlast = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \ni < points . length ; \ni = i + 1 ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nrows [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt = cnt + 1 ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setY1 ( cnt ) ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setY2 ( cnt - 1 ) ; \nif ( pos . getY2 ( ) < pos . getY1 ( ) ) pos . setY2 ( pos . getY1 ( ) ) ; \n} \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) rows [ cnt ] = abspos . getY2 ( ) - last ; \n} \n} \n"}
{"10189": "public class ByteCodeMonitor { \npublic void onCodeUpdate ( ByteBuffer codeBuffer , int start , int length , VariableAndFunctorInterner interner , WAMCodeView codeView ) { \nlog . fine ( \"public void onCodeUpdate(ByteBuffer codeBuffer, int start = \" + start + \", int length = \" + length + \", VariableAndFunctorInterner interner, WAMCodeView codeView): called\" ) ; \ncopyAndResizeCodeBuffer ( codeBuffer , start , length ) ; \nSizeableList < WAMInstruction > instructions = WAMInstruction . disassemble ( start , length , this . codeBuffer , interner , codeView ) ; \nMap . Entry < Integer , Integer > entry = addressToRow . floorEntry ( start ) ; \nint firstRow = ( entry == null ) ? 0 : ( entry . getValue ( ) + 1 ) ; \nint address = start ; \nint row = firstRow ; \nfor ( WAMInstruction instruction : instructions ) { \naddressToRow . put ( address , row ) ; \nrowToAddress . add ( row , address ) ; \nrow = row + 1 ; \naddress += instruction . sizeof ( ) ; \n} \nrenderInstructions ( instructions , firstRow , start ) ; \n} \n} \n"}
{"10191": "public class ByteCodeMonitor { \nprivate void renderInstructions ( Iterable < WAMInstruction > instructions , int row , int address ) { \nfor ( WAMInstruction instruction : instructions ) { \nWAMLabel label = instruction . getLabel ( ) ; \nlabeledTable . put ( ADDRESS , row , String . format ( \"%08X\" , address ) ) ; \nlabeledTable . put ( LABEL , row , ( label == null ) ? \"\" : ( label . toPrettyString ( ) + \":\" ) ) ; \nlabeledTable . put ( MNEMONIC , row , instruction . getMnemonic ( ) . getPretty ( ) ) ; \nint fieldMask = instruction . getMnemonic ( ) . getFieldMask ( ) ; \nString arg = \"\" ; \nfor ( int i = 2 ; \ni < 32 ; \ni = i * 2 ) { \nif ( ( fieldMask & i ) != 0 ) { \nif ( ! \"\" . equals ( arg ) ) { \narg += \", \" ; \n} \nswitch ( i ) { \ncase 2 : arg += Integer . toString ( instruction . getReg1 ( ) ) ; \nbreak ; \ncase 4 : arg += Integer . toString ( instruction . getReg2 ( ) ) ; \nbreak ; \ncase 8 : FunctorName fn = instruction . getFn ( ) ; \nif ( fn != null ) { \narg += fn . getName ( ) + \"/\" + fn . getArity ( ) ; \n} \nbreak ; \ncase 16 : WAMLabel target1 = instruction . getTarget1 ( ) ; \nif ( target1 != null ) { \narg += target1 . getName ( ) + \"/\" + target1 . getArity ( ) + \"_\" + target1 . getId ( ) ; \n} \nbreak ; \n} \n} \n} \nlabeledTable . put ( ARG_1 , row , arg ) ; \nrow = row + 1 ; \naddress += instruction . sizeof ( ) ; \n} \n} \n} \n"}
{"10207": "public class PageControlTag { \npublic int doStartTag ( ) throws JspException { \nlog . fine ( \"public int doStartTag(): called\" ) ; \nTagUtils tagUtils = TagUtils . getInstance ( ) ; \nPagedList list = ( PagedList ) tagUtils . lookup ( pageContext , name , property , scope ) ; \nlog . fine ( \"list = \" + list ) ; \nString url ; \ntry { \nurl = tagUtils . computeURL ( pageContext , null , null , null , action , null , null , null , false ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new JspException ( \"Got malformed URL exception: \" , e ) ; \n} \nrenderButton ( renderFirst , 0 , 0 , openDelimFirst , url , firstText , list . getCurrentPage ( ) != 0 ) ; \nrenderButton ( renderBack , list . getCurrentPage ( ) - 1 , ( ( list . getCurrentPage ( ) - 1 ) < list . getCurrentIndex ( ) ) ? ( list . getCurrentIndex ( ) - maxPages ) : list . getCurrentIndex ( ) , openDelimBack , url , backText , ( list . getCurrentPage ( ) - 1 ) >= 0 ) ; \nint from = list . getCurrentIndex ( ) ; \nint to = list . getCurrentIndex ( ) + maxPages ; \nfor ( int i = from ; \n( i < list . size ( ) ) && ( i < to ) ; \ni = i + 1 ) { \nrenderButton ( true , i , list . getCurrentIndex ( ) , ( i == list . getCurrentPage ( ) ) ? openDelimCurrent : openDelimNumber , url , \"\" + ( i + 1 ) , i != list . getCurrentPage ( ) ) ; \n} \nrenderButton ( ( list . getCurrentIndex ( ) + maxPages ) < list . size ( ) , list . getCurrentPage ( ) + maxPages , list . getCurrentPage ( ) + maxPages , openDelimMore , url , moreText , true ) ; \nrenderButton ( renderForward , list . getCurrentPage ( ) + 1 , ( ( list . getCurrentPage ( ) + 1 ) >= ( list . getCurrentIndex ( ) + maxPages ) ) ? ( list . getCurrentIndex ( ) + maxPages ) : list . getCurrentIndex ( ) , openDelimForward , url , forwardText , ( list . getCurrentPage ( ) + 1 ) < list . size ( ) ) ; \nrenderButton ( renderLast , list . size ( ) - 1 , ( list . size ( ) / maxPages ) * maxPages , openDelimLast , url , lastText , list . getCurrentPage ( ) != ( list . size ( ) - 1 ) ) ; \nreturn SKIP_BODY ; \n} \n} \n"}
{"10224": "public class PrologUnifier { \npublic boolean unifyInternal ( Term left , Term right , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( left == right ) { \nreturn true ; \n} \nif ( ! left . isVar ( ) && ! right . isVar ( ) && left . isConstant ( ) && right . isConstant ( ) && left . equals ( right ) ) { \nreturn true ; \n} \nelse if ( left . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) left , right , leftTrail , rightTrail ) ; \n} \nelse if ( right . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) right , left , rightTrail , leftTrail ) ; \n} \nelse if ( left . isFunctor ( ) && right . isFunctor ( ) ) { \nFunctor leftFunctor = ( Functor ) left ; \nFunctor rightFunctor = ( Functor ) right ; \nif ( ! left . equals ( right ) ) { \nreturn false ; \n} \nint arity = leftFunctor . getArity ( ) ; \nfor ( int i = 0 ; \ni < arity ; \ni = i + 1 ) { \nTerm leftArgument = leftFunctor . getArgument ( i ) ; \nTerm rightArgument = rightFunctor . getArgument ( i ) ; \nboolean result = unifyInternal ( leftArgument , rightArgument , leftTrail , rightTrail ) ; \nif ( ! result ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"10226": "public class InstructionCompiler { \nprivate void compileQuery ( Clause clause ) throws SourceCodeException { \nWAMCompiledQuery result ; \nMap < Byte , Integer > varNames = new TreeMap < Byte , Integer > ( ) ; \nseenRegisters = new TreeSet < Integer > ( ) ; \nlastAllocatedTempReg = findMaxArgumentsInClause ( clause ) ; \nnumPermanentVars = 0 ; \ncutLevelVarSlot = - 1 ; \nSizeableList < WAMInstruction > preFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSizeableList < WAMInstruction > postFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSet < Variable > freeVars = TermUtils . findFreeNonAnonymousVariables ( clause ) ; \nSet < Integer > freeVarNames = new TreeSet < Integer > ( ) ; \nfor ( Variable var : freeVars ) { \nfreeVarNames . add ( var . getName ( ) ) ; \n} \nallocatePermanentQueryRegisters ( clause , varNames ) ; \ngatherPositionAndOccurrenceInfo ( clause ) ; \nresult = new WAMCompiledQuery ( varNames , freeVarNames ) ; \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . AllocateN , REG_ADDR , ( byte ) ( numPermanentVars & 0xff ) ) ) ; \nif ( cutLevelVarSlot >= 0 ) { \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . GetLevel , STACK_ADDR , ( byte ) cutLevelVarSlot ) ) ; \n} \nresult . addInstructions ( preFixInstructions ) ; \nFunctor [ ] expressions = clause . getBody ( ) ; \nFunctorName fn = new FunctorName ( \"tq\" , 0 ) ; \nfor ( int i = 0 ; \ni < expressions . length ; \ni = i + 1 ) { \nFunctor expression = expressions [ i ] ; \nboolean isFirstBody = i == 0 ; \nBuiltIn builtIn ; \nif ( expression instanceof BuiltIn ) { \nbuiltIn = ( BuiltIn ) expression ; \n} \nelse { \nbuiltIn = this ; \n} \nSizeableLinkedList < WAMInstruction > instructions = builtIn . compileBodyArguments ( expression , false , fn , i ) ; \nresult . addInstructions ( expression , instructions ) ; \ninstructions = builtIn . compileBodyCall ( expression , isFirstBody , false , false , numPermanentVars ) ; \nresult . addInstructions ( expression , instructions ) ; \n} \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Suspend ) ) ; \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Deallocate ) ) ; \nresult . addInstructions ( postFixInstructions ) ; \nresult = optimizer . apply ( result ) ; \ndisplayCompiledQuery ( result ) ; \nobserver . onQueryCompilation ( result ) ; \n} \n} \n"}
{"10227": "public class InstructionCompiler { \nprivate int findMaxArgumentsInClause ( Clause clause ) { \nint result = 0 ; \nFunctor head = clause . getHead ( ) ; \nif ( head != null ) { \nresult = head . getArity ( ) ; \n} \nFunctor [ ] body = clause . getBody ( ) ; \nif ( body != null ) { \nfor ( int i = 0 ; \ni < body . length ; \ni = i + 1 ) { \nint arity = body [ i ] . getArity ( ) ; \nresult = ( arity > result ) ? arity : result ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10232": "public class ByteBufferUtils { \npublic static ByteBuffer putPaddedInt32AsString ( ByteBuffer buffer , int value , int length ) { \nint charsRequired = BitHackUtils . getCharacterCountInt32 ( value ) ; \nlength = ( charsRequired < length ) ? length : charsRequired ; \nint index = buffer . position ( ) + length - 1 ; \nint start = buffer . position ( ) ; \nbuffer . position ( buffer . position ( ) + length ) ; \nif ( value < 0 ) { \nbuffer . put ( MINUS_ASCII ) ; \nstart = start + 1 ; \n} \nelse { \nvalue = - value ; \n} \ndo { \nint remainder = value % 10 ; \nvalue = value / 10 ; \nbuffer . put ( index = index - 1 , ( ( byte ) ( ZERO_ASCII - remainder ) ) ) ; \n} \nwhile ( value != 0 ) ; \nwhile ( index >= start ) { \nbuffer . put ( index = index - 1 , ZERO_ASCII ) ; \n} \nreturn buffer ; \n} \n} \n"}
{"10233": "public class ByteBufferUtils { \npublic static String asString ( ByteBuffer buffer , int length ) { \nchar [ ] chars = new char [ length ] ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) { \nchars [ i ] = ( char ) buffer . get ( i ) ; \n} \nreturn String . valueOf ( chars ) ; \n} \n} \n"}
{"10245": "public class ReflectionUtils { \npublic static Object callMethod ( Object o , String method , Object [ ] params ) { \nClass cls = o . getClass ( ) ; \nClass [ ] paramClasses = new Class [ params . length ] ; \nfor ( int i = 0 ; \ni < params . length ; \ni = i + 1 ) { \nparamClasses [ i ] = params [ i ] . getClass ( ) ; \n} \ntry { \nMethod m = cls . getMethod ( method , paramClasses ) ; \nreturn m . invoke ( o , params ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"10264": "public class TraceIndenter { \npublic String generateTraceIndent ( int delta ) { \nif ( ! useIndent ) { \nreturn \"\" ; \n} \nelse { \nif ( delta >= 1 ) { \nindentStack . push ( delta ) ; \n} \nelse if ( delta < 0 ) { \nindentStack . pop ( ) ; \n} \nStringBuffer result = new StringBuffer ( ) ; \ntraceIndent += ( delta < 0 ) ? delta : 0 ; \nfor ( int i = 0 ; \ni < traceIndent ; \ni = i + 1 ) { \nresult . append ( \" \" ) ; \n} \ntraceIndent += ( delta > 0 ) ? delta : 0 ; \nreturn result . toString ( ) ; \n} \n} \n} \n"}
{"10265": "public class DefaultBuiltIn { \nprotected void allocateArgumentRegisters ( Functor expression ) { \nint reg = 0 ; \nfor ( ; \nreg < expression . getArity ( ) ; \nreg = reg + 1 ) { \nTerm term = expression . getArgument ( reg ) ; \nif ( term instanceof Functor ) { \nint allocation = ( reg & 0xff ) | ( REG_ADDR << 8 ) ; \nsymbolTable . put ( term . getSymbolKey ( ) , SymbolTableKeys . SYMKEY_ALLOCATION , allocation ) ; \n} \n} \n} \n} \n"}
{"10267": "public class ProtoDTLearningMethod { \nprivate OrdinalAttribute getMajorityClassification ( String property , Iterable < State > examples ) throws LearningFailureException { \nMap < OrdinalAttribute , Integer > countMap = null ; \nint biggestCount = 0 ; \nOrdinalAttribute biggestAttribute = null ; \nfor ( State example : examples ) { \nOrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; \nif ( countMap == null ) { \ncountMap = new HashMap < OrdinalAttribute , Integer > ( ) ; \n} \nint count ; \nif ( ! countMap . containsKey ( nextAttribute ) ) { \ncount = 1 ; \ncountMap . put ( nextAttribute , count ) ; \n} \nelse { \ncount = countMap . get ( nextAttribute ) ; \ncountMap . put ( nextAttribute , count = count + 1 ) ; \n} \nif ( count > biggestCount ) { \nbiggestCount = count ; \nbiggestAttribute = nextAttribute ; \n} \n} \nreturn biggestAttribute ; \n} \n} \n"}
{"10269": "public class ProtoDTLearningMethod { \nprivate String chooseBestPropertyToDecideOn ( String outputProperty , Iterable < State > examples , Iterable < String > inputProperties ) { \nint numOutputValues = examples . iterator ( ) . next ( ) . getComponentType ( ) . getPropertyType ( outputProperty ) . getNumPossibleValues ( ) ; \ndouble largestGain = 0.0d ; \nString largestGainProperty = null ; \nfor ( String inputProperty : inputProperties ) { \nint numInputValues = examples . iterator ( ) . next ( ) . getComponentType ( ) . getPropertyType ( inputProperty ) . getNumPossibleValues ( ) ; \nint [ ] outputCounts = new int [ numOutputValues ] ; \nint [ ] inputCounts = new int [ numInputValues ] ; \nint [ ] [ ] jointCounts = new int [ numInputValues ] [ numOutputValues ] ; \nfor ( State example : examples ) { \nOrdinalAttribute outputAttribute = ( OrdinalAttribute ) example . getProperty ( outputProperty ) ; \nOrdinalAttribute inputAttribute = ( OrdinalAttribute ) example . getProperty ( inputProperty ) ; \noutputCounts [ outputAttribute . ordinal ( ) ] = outputCounts [ outputAttribute . ordinal ( ) ] + 1 ; \ninputCounts [ inputAttribute . ordinal ( ) ] = inputCounts [ inputAttribute . ordinal ( ) ] + 1 ; \njointCounts [ inputAttribute . ordinal ( ) ] [ outputAttribute . ordinal ( ) ] = jointCounts [ inputAttribute . ordinal ( ) ] [ outputAttribute . ordinal ( ) ] + 1 ; \n} \ndouble [ ] pForG = InformationTheory . pForDistribution ( outputCounts ) ; \ndouble [ ] pForA = InformationTheory . pForDistribution ( inputCounts ) ; \ndouble [ ] [ ] pForGGivenA = InformationTheory . pForJointDistribution ( jointCounts ) ; \ndouble gain = InformationTheory . gain ( pForG , pForA , pForGGivenA ) ; \nif ( gain > largestGain ) { \nlargestGain = gain ; \nlargestGainProperty = inputProperty ; \n} \n} \nreturn largestGainProperty ; \n} \n} \n"}
{"10278": "public class Surface { \nprivate BufferedImage createBinaryImage ( int w , int h , int pixelBits ) { \nint bytesPerRow = w * pixelBits / 8 ; \nif ( ( w * pixelBits % 8 ) != 0 ) { \nbytesPerRow = bytesPerRow + 1 ; \n} \nbyte [ ] imageData = new byte [ h * bytesPerRow ] ; \nIndexColorModel cm = null ; \nswitch ( pixelBits ) { \ncase 1 : { \ncm = new IndexColorModel ( pixelBits , lut1Arr . length , lut1Arr , lut1Arr , lut1Arr ) ; \nbreak ; \n} \ncase 2 : { \ncm = new IndexColorModel ( pixelBits , lut2Arr . length , lut2Arr , lut2Arr , lut2Arr ) ; \nbreak ; \n} \ncase 4 : { \ncm = new IndexColorModel ( pixelBits , lut4Arr . length , lut4Arr , lut4Arr , lut4Arr ) ; \nbreak ; \n} \ndefault : { \nnew Exception ( \"Invalid # of bit per pixel\" ) . printStackTrace ( ) ; \n} \n} \nDataBuffer db = new DataBufferByte ( imageData , imageData . length ) ; \nWritableRaster r = Raster . createPackedRaster ( db , w , h , pixelBits , null ) ; \nreturn new BufferedImage ( cm , r , false , null ) ; \n} \n} \n"}
{"10282": "public class MaxStepsAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nQueue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; \nUnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; \nwhile ( ! queue . isEmpty ( ) ) { \nSearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; \nif ( ! headNode . isExpanded ( ) ) { \nheadNode . expandSuccessors ( queue , reverseEnqueue ) ; \n} \nSearchNode < O , T > currentNode = peekAtHead ? queue . peek ( ) : headNode ; \nif ( currentNode . isExpanded ( ) ) { \ncurrentNode = peekAtHead ? queue . remove ( ) : headNode ; \nif ( goalPredicate . evaluate ( currentNode . getState ( ) ) ) { \nreturn currentNode ; \n} \n} \nif ( maxSteps > 0 ) { \nsearchSteps = searchSteps + 1 ; \ninitSearch . setStepsTaken ( searchSteps ) ; \nif ( searchSteps >= maxSteps ) { \nif ( queue . isEmpty ( ) ) { \nreturn null ; \n} \nelse { \nthrow new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"10287": "public class PrologParser { \npublic Term listFunctor ( ) throws SourceCodeException { \nint nilId = interner . internFunctorName ( \"nil\" , 0 ) ; \nint consId = interner . internFunctorName ( \"cons\" , 2 ) ; \nToken leftDelim = consumeToken ( LSQPAREN ) ; \nTerm [ ] args = null ; \nToken nextToken = tokenSource . peek ( ) ; \nswitch ( nextToken . kind ) { \ncase LPAREN : case LSQPAREN : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case STRING_LITERAL : case VAR : case FUNCTOR : case ATOM : args = arglist ( ) ; \nbreak ; \ndefault : } \nTerm accumulator ; \nif ( tokenSource . peek ( ) . kind == CONS ) { \nif ( args == null ) { \nthrow new SourceCodeException ( \"Was expecting one of \" + BEGIN_TERM_TOKENS + \" but got \" + tokenImage [ nextToken . kind ] + \".\" , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; \n} \nconsumeToken ( CONS ) ; \naccumulator = term ( ) ; \n} \nelse { \naccumulator = new Nil ( nilId , null ) ; \n} \nToken rightDelim = consumeToken ( RSQPAREN ) ; \nif ( args != null ) { \nfor ( int i = args . length - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nTerm previousAccumulator = accumulator ; \naccumulator = new Cons ( consId , new Term [ ] { \nargs [ i ] , previousAccumulator } \n) ; \n} \n} \nSourceCodePosition position = new SourceCodePositionImpl ( leftDelim . beginLine , leftDelim . beginColumn , rightDelim . endLine , rightDelim . endColumn ) ; \naccumulator . setSourceCodePosition ( position ) ; \nreturn ( Functor ) accumulator ; \n} \n} \n"}
{"10303": "public class TimeUtils { \npublic static int ticksToYears ( long ticks ) { \nlong unitMillis = MILLIS_PER_YEAR / 2 ; \nlong i2 = ( ticks >> 1 ) + ( ( 1970L * MILLIS_PER_YEAR ) / 2 ) ; \nif ( i2 < 0 ) { \ni2 = i2 - unitMillis + 1 ; \n} \nint year = ( int ) ( i2 / unitMillis ) ; \nlong yearStart = millisToYearStart ( year ) ; \nlong diff = ticks - yearStart ; \nif ( diff < 0 ) { \nyear = year - 1 ; \n} \nelse if ( diff >= ( MILLIS_PER_DAY * 365L ) ) { \nlong oneYear ; \nif ( isLeapYear ( year ) ) { \noneYear = MILLIS_PER_DAY * 366L ; \n} \nelse { \noneYear = MILLIS_PER_DAY * 365L ; \n} \nyearStart += oneYear ; \nif ( yearStart <= ticks ) { \nyear = year + 1 ; \n} \n} \nreturn year ; \n} \n} \n"}
{"10310": "public class TimeUtils { \npublic static long millisToYearStart ( int year ) { \nint leapYears = year / 100 ; \nif ( year < 0 ) { \nleapYears = ( ( year + 3 ) >> 2 ) - leapYears + ( ( leapYears + 3 ) >> 2 ) - 1 ; \n} \nelse { \nleapYears = ( year >> 2 ) - leapYears + ( leapYears >> 2 ) ; \nif ( isLeapYear ( year ) ) { \nleapYears = leapYears - 1 ; \n} \n} \nreturn ( ( year * 365L ) + leapYears - DAYS_TO_1970 ) * MILLIS_PER_DAY ; \n} \n} \n"}
{"10313": "public class SequentialCuckooFunction { \nprivate Integer applyWithEntry ( K key , Entry < K > entry , boolean tryRehashing ) { \nEntry < K > uninsertedEntry = entry ; \nboolean createdNewEntry = false ; \nEntry < K > existingEntry = entryForKey ( key ) ; \nInteger result = null ; \nif ( existingEntry != null ) { \nresult = existingEntry . seq ; \n} \nelse { \nif ( uninsertedEntry == null ) { \nuninsertedEntry = new Entry < K > ( ) ; \nuninsertedEntry . key = key ; \nuninsertedEntry . seq = nextSequenceNumber ; \nnextSequenceNumber = nextSequenceNumber + 1 ; \ncount = count + 1 ; \ncreatedNewEntry = true ; \nresult = uninsertedEntry . seq ; \n} \nwhile ( true ) { \nint keyHashCode = uninsertedEntry . key . hashCode ( ) ; \nuninsertedEntry . hash1 = hash1 ( keyHashCode ) ; \nuninsertedEntry . hash2 = hash2 ( uninsertedEntry . hash1 , keyHashCode ) ; \nuninsertedEntry = cuckoo ( uninsertedEntry ) ; \nif ( uninsertedEntry == null ) { \nresult = createdNewEntry ? result : - 1 ; \nbreak ; \n} \nif ( tryRehashing ) { \nrehash ( ) ; \n} \nelse { \nresult = null ; \nbreak ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"10315": "public class SequentialCuckooFunction { \nprivate Entry < K > cuckoo ( Entry < K > entry ) { \nEntry < K > currentEntry = entry ; \nint hash = entry . hash1 ; \nint index = indexFor ( hash ) ; \nEntry < K > nextEntry = hashTable [ index ] ; \nint previousFlag = 0 ; \nint [ ] previousIndex = new int [ 2 ] ; \nint [ ] previousSeq = new int [ 2 ] ; \nfor ( int i = 0 ; \ni < hashTableSize ; \ni = i + 1 ) { \nif ( nextEntry == null ) { \nhashTable [ index ] = currentEntry ; \nreturn null ; \n} \nhashTable [ index ] = currentEntry ; \ncurrentEntry = nextEntry ; \nint firstPosition = indexFor ( currentEntry . hash1 ) ; \nhash = ( index == firstPosition ) ? currentEntry . hash2 : currentEntry . hash1 ; \nindex = indexFor ( hash ) ; \npreviousIndex [ previousFlag ] = index ; \npreviousSeq [ previousFlag ] = nextEntry . seq ; \npreviousFlag = ( previousFlag == 1 ) ? 0 : 1 ; \nnextEntry = hashTable [ index ] ; \nif ( ( nextEntry != null ) && ( index == previousIndex [ previousFlag ] ) && ( nextEntry . seq == previousSeq [ previousFlag ] ) ) { \nbreak ; \n} \n} \nreturn currentEntry ; \n} \n} \n"}
{"10324": "public class InformationTheory { \npublic static double [ ] pForDistribution ( int [ ] counts ) { \ndouble [ ] probabilities = new double [ counts . length ] ; \nint total = 0 ; \nfor ( int c : counts ) { \ntotal += c ; \n} \nfor ( int i = 0 ; \ni < probabilities . length ; \ni = i + 1 ) { \nif ( total > 0 ) { \nprobabilities [ i ] = ( ( double ) counts [ i ] ) / total ; \n} \nelse { \nprobabilities [ i ] = 0.0d ; \n} \n} \nreturn probabilities ; \n} \n} \n"}
{"10330": "public class DebugTag { \npublic String getCookies ( ) { \nMap info = new TreeMap ( ) ; \nHttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nCookie [ ] cookies = req . getCookies ( ) ; \nif ( cookies != null ) { \nfor ( int i = 0 ; \ni < cookies . length ; \ni = i + 1 ) { \nCookie cooky = cookies [ i ] ; \ninfo . put ( cooky . getName ( ) , cooky . getValue ( ) ) ; \n} \n} \nreturn toHTMLTable ( \"cookies\" , info ) ; \n} \n} \n"}
{"10331": "public class DebugTag { \npublic String getParameters ( ) { \nMap info = new TreeMap ( ) ; \nServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nEnumeration names = req . getParameterNames ( ) ; \nwhile ( names . hasMoreElements ( ) ) { \nString name = ( String ) names . nextElement ( ) ; \nString [ ] values = req . getParameterValues ( name ) ; \nStringBuffer sb = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ni < values . length ; \ni = i + 1 ) { \nif ( i != 0 ) { \nsb . append ( \" | \" ) ; \n} \nsb . append ( values [ i ] ) ; \n} \ninfo . put ( name , sb . toString ( ) ) ; \n} \nreturn toHTMLTable ( \"request parameters\" , info ) ; \n} \n} \n"}
{"10339": "public class BoundedAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nQueue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; \nUnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; \nboolean beyondFringe = false ; \nminBeyondBound = Float . POSITIVE_INFINITY ; \nwhile ( ! queue . isEmpty ( ) ) { \nSearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; \nQueue < SearchNode < O , T > > successors = new LinkedList < SearchNode < O , T > > ( ) ; \nheadNode . expandSuccessors ( successors , reverseEnqueue ) ; \nfor ( SearchNode < O , T > successor : successors ) { \nfloat boundProperty = boundPropertyExtractor . getBoundProperty ( successor ) ; \nif ( boundProperty <= maxBound ) { \nqueue . offer ( successor ) ; \n} \nelse { \nbeyondFringe = true ; \nminBeyondBound = ( boundProperty < minBeyondBound ) ? boundProperty : minBeyondBound ; \n} \n} \nSearchNode < O , T > currentNode = peekAtHead ? queue . remove ( ) : headNode ; \nif ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( currentNode . getState ( ) ) ) { \nreturn currentNode ; \n} \nif ( maxSteps > 0 ) { \nsearchSteps = searchSteps + 1 ; \ninitSearch . setStepsTaken ( searchSteps ) ; \nif ( searchSteps >= maxSteps ) { \nif ( queue . isEmpty ( ) ) { \nreturn null ; \n} \nelse { \nthrow new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; \n} \n} \n} \n} \nif ( beyondFringe ) { \nthrow new MaxBoundException ( \"Max bound reached.\" , null ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"10347": "public class AbstractHeap { \npublic < T > T [ ] toArray ( T [ ] a ) { \nint size = size ( ) ; \nif ( a . length < size ) { \na = ( T [ ] ) java . lang . reflect . Array . newInstance ( a . getClass ( ) . getComponentType ( ) , size ) ; \n} \nIterator < E > it = iterator ( ) ; \nObject [ ] result = a ; \nfor ( int i = 0 ; \ni < size ; \ni = i + 1 ) { \nresult [ i ] = it . next ( ) ; \n} \nif ( a . length > size ) { \na [ size ] = null ; \n} \nreturn a ; \n} \n} \n"}
{"10358": "public class AttributeGridImpl { \nprivate void setColumnAttribute ( AttributeSet attributes , int c ) { \nif ( c >= columnAttributes . size ( ) ) { \nfor ( int i = columnAttributes . size ( ) ; \ni <= c ; \ni = i + 1 ) { \ncolumnAttributes . add ( null ) ; \n} \n} \ncolumnAttributes . set ( c , attributes ) ; \n} \n} \n"}
{"10359": "public class AttributeGridImpl { \nprivate void setRowAttribute ( AttributeSet attributes , int r ) { \nif ( r >= rowAttributes . size ( ) ) { \nfor ( int i = rowAttributes . size ( ) ; \ni <= r ; \ni = i + 1 ) { \nrowAttributes . add ( null ) ; \n} \n} \nrowAttributes . set ( r , attributes ) ; \n} \n} \n"}
{"10377": "public class ByteBufferUtils { \npublic static int getIntFromBytes ( byte [ ] buf , int offset ) { \nint result = 0 ; \nresult += buf [ offset = offset + 1 ] & 0xFF ; \nresult += ( ( buf [ offset = offset + 1 ] & 0xFF ) << 8 ) ; \nresult += ( ( buf [ offset = offset + 1 ] & 0xFF ) << 16 ) ; \nresult += ( ( buf [ offset ] ) << 24 ) ; \nreturn result ; \n} \n} \n"}
{"10378": "public class ByteBufferUtils { \npublic static void writeIntToByteArray ( byte [ ] buf , int offset , int value ) { \nbuf [ offset = offset + 1 ] = ( byte ) ( value & 0x000000ff ) ; \nbuf [ offset = offset + 1 ] = ( byte ) ( ( value & 0x0000ff00 ) >> 8 ) ; \nbuf [ offset = offset + 1 ] = ( byte ) ( ( value & 0x00ff0000 ) >> 16 ) ; \nbuf [ offset ] = ( byte ) ( ( value & 0xff000000 ) >> 24 ) ; \n} \n} \n"}
{"10379": "public class ByteBufferUtils { \npublic static void write24BitIntToByteArray ( byte [ ] buf , int offset , int value ) { \nbuf [ offset = offset + 1 ] = ( byte ) ( value & 0x000000ff ) ; \nbuf [ offset = offset + 1 ] = ( byte ) ( ( value & 0x0000ff00 ) >> 8 ) ; \nbuf [ offset ] = ( byte ) ( ( value & 0x00ff0000 ) >> 16 ) ; \n} \n} \n"}
{"10380": "public class ByteBufferUtils { \npublic static int get24BitIntFromBytes ( byte [ ] buf , int offset ) { \nint i = 0 ; \noffset = offset + 1 ; \ni += buf [ offset = offset + 1 ] & 0xFF ; \ni += ( ( buf [ offset = offset + 1 ] & 0xFF ) << 8 ) ; \ni += ( ( buf [ offset ] & 0xFF ) << 16 ) ; \nreturn i ; \n} \n} \n"}
{"10381": "public class ByteBufferUtils { \npublic static short getShortFromBytes ( byte [ ] buf , int offset ) { \nshort result = 0 ; \nresult += buf [ offset = offset + 1 ] & 0xFF ; \nresult += ( ( buf [ offset ] ) << 8 ) ; \nreturn result ; \n} \n} \n"}
{"10382": "public class ByteBufferUtils { \npublic static void writeShortToByteArray ( byte [ ] buf , int offset , short value ) { \nbuf [ offset = offset + 1 ] = ( byte ) ( value & 0x000000ff ) ; \nbuf [ offset ] = ( byte ) ( ( value & 0x0000ff00 ) >> 8 ) ; \n} \n} \n"}
{"10389": "public class StringUtils { \npublic static String arrayToList ( String [ ] array , String delim ) { \nString result = \"\" ; \nfor ( int i = 0 ; \ni < array . length ; \ni = i + 1 ) { \nresult += array [ i ] + ( ( i == ( array . length - 1 ) ) ? \"\" : delim ) ; \n} \nreturn result ; \n} \n} \n"}
{"10390": "public class StringUtils { \npublic static String toCamelCase ( String name ) { \nString [ ] parts = name . split ( \"_\" ) ; \nString result = parts [ 0 ] ; \nfor ( int i = 1 ; \ni < parts . length ; \ni = i + 1 ) { \nif ( parts [ i ] . length ( ) > 0 ) { \nresult += upperFirstChar ( parts [ i ] ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10391": "public class StringUtils { \npublic static String convertCase ( String value , String separator , boolean firstLetterUpper , boolean firstLetterOfWordUpper ) { \nfinal StringBuffer result = new StringBuffer ( ) ; \nboolean firstWord = true ; \nboolean firstLetter = true ; \nboolean upper = false ; \nWordMachineState state = WordMachineState . Initial ; \nFunction2 < Character , Boolean , StringBuffer > writeChar = new Function2 < Character , Boolean , StringBuffer > ( ) { \npublic StringBuffer apply ( Character nextChar , Boolean upper ) { \nif ( upper ) result . append ( Character . toUpperCase ( nextChar ) ) ; \nelse result . append ( Character . toLowerCase ( nextChar ) ) ; \nreturn result ; \n} \n} \n; \nfor ( int i = 0 ; \ni < value . length ( ) ; \ni = i + 1 ) { \nchar nextChar = value . charAt ( i ) ; \nif ( Character . isUpperCase ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordCaps : state = WordMachineState . ContinueWordCaps ; \nupper = false ; \nbreak ; \ncase ContinueWordLower : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nresult . append ( separator ) ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse if ( Character . isLetterOrDigit ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordLower : case ContinueWordCaps : state = WordMachineState . ContinueWordLower ; \nupper = false ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse { \nswitch ( state ) { \ncase Initial : state = WordMachineState . Initial ; \nbreak ; \ncase StartWord : case ContinueWordCaps : case ContinueWordLower : state = WordMachineState . Initial ; \nbreak ; \n} \nupper = false ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"10396": "public class HierarchyAttribute { \npublic boolean isSubCategory ( HierarchyAttribute comp ) { \nif ( ! comp . attributeClass . attributeClassName . equals ( attributeClass . attributeClassName ) ) { \nreturn false ; \n} \nList < String > otherPath = comp . getPathValue ( ) ; \nList < String > path = getPathValue ( ) ; \nif ( otherPath . size ( ) <= path . size ( ) ) { \nreturn false ; \n} \nboolean subcat = true ; \nfor ( int i = 0 ; \ni < path . size ( ) ; \ni = i + 1 ) { \nif ( ! otherPath . get ( i ) . equals ( path . get ( i ) ) ) { \nsubcat = false ; \nbreak ; \n} \n} \nreturn subcat ; \n} \n} \n"}
{"10402": "public class ManhattanHeuristic { \npublic float computeH ( EightPuzzleState state , HeuristicSearchNode searchNode ) { \nHeuristicSearchNode parentNode = ( HeuristicSearchNode ) searchNode . getParent ( ) ; \nif ( parentNode == null ) { \nint h = 0 ; \nfor ( int j = 0 ; \nj < 3 ; \nj = j + 1 ) { \nfor ( int i = 0 ; \ni < 3 ; \ni = i + 1 ) { \nchar nextTile = state . getTileAt ( i , j ) ; \nint goalX = state . getGoalXForTile ( nextTile ) ; \nint goalY = state . getGoalYForTile ( nextTile ) ; \nint diffX = goalX - i ; \ndiffX = ( diffX < 0 ) ? - diffX : diffX ; \nint diffY = goalY - j ; \ndiffY = ( diffY < 0 ) ? - diffY : diffY ; \nh += diffX + diffY ; \n} \n} \nreturn ( float ) h ; \n} \nelse { \nEightPuzzleState parentState = ( EightPuzzleState ) parentNode . getState ( ) ; \nfloat h = parentNode . getH ( ) ; \nchar playedMove = ( ( String ) searchNode . getAppliedOp ( ) . getOp ( ) ) . charAt ( 0 ) ; \nint emptyX = parentState . getEmptyX ( ) ; \nint emptyY = parentState . getEmptyY ( ) ; \nchar movedTile = state . getTileAt ( emptyX , emptyY ) ; \nint oldX = 0 ; \nint oldY = 0 ; \nswitch ( playedMove ) { \ncase 'L' : { \noldX = emptyX - 1 ; \nbreak ; \n} \ncase 'R' : { \noldX = emptyX + 1 ; \nbreak ; \n} \ncase 'U' : { \noldY = emptyY - 1 ; \nbreak ; \n} \ncase 'D' : { \noldY = emptyY + 1 ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nint change = 0 ; \nswitch ( playedMove ) { \ncase 'L' : case 'R' : { \nint goalX = state . getGoalXForTile ( movedTile ) ; \nint newX = emptyX ; \nint oldDiffX = oldX - goalX ; \noldDiffX = ( oldDiffX < 0 ) ? - oldDiffX : oldDiffX ; \nint newDiffX = newX - goalX ; \nnewDiffX = ( newDiffX < 0 ) ? - newDiffX : newDiffX ; \nchange = newDiffX - oldDiffX ; \nbreak ; \n} \ncase 'U' : case 'D' : { \nint goalY = state . getGoalYForTile ( movedTile ) ; \nint newY = emptyY ; \nint oldDiffY = oldY - goalY ; \noldDiffY = ( oldDiffY < 0 ) ? - oldDiffY : oldDiffY ; \nint newDiffY = newY - goalY ; \nnewDiffY = ( newDiffY < 0 ) ? - newDiffY : newDiffY ; \nchange = newDiffY - oldDiffY ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nreturn ( change > 0 ) ? ( h + 1.0f ) : ( h - 1.0f ) ; \n} \n} \n} \n"}
{"10418": "public class BitHackUtils { \npublic static int getCharacterCountDecimal ( long integerValue , int scale ) { \nboolean isNeg = integerValue < 0 ; \nint totalDigits = BitHackUtils . getCharacterCountInt64 ( integerValue ) ; \nint totalLength = totalDigits ; \nif ( isNeg ) { \ntotalDigits = totalDigits - 1 ; \n} \nif ( scale > 0 ) { \ntotalLength = totalLength + 1 ; \nif ( scale >= totalDigits ) { \ntotalLength += ( scale - totalDigits ) + 1 ; \n} \n} \nelse { \ntotalLength -= scale ; \n} \nreturn totalLength ; \n} \n} \n"}
{"10425": "public class ContextualProperties { \nprotected Iterator getKeyIterator ( final String base , final String modifier , final String key ) { \nreturn new Iterator ( ) { \nprivate int i ; \npublic boolean hasNext ( ) { \nreturn ( useDefaults ? ( ( i < ORDER . length ) && ( ORDER [ i ] > ENVIRONMENT_DEFAULTS_CUTOFF ) ) : ( i < ORDER . length ) ) ; \n} \npublic Object next ( ) { \nif ( ! hasNext ( ) ) { \nreturn null ; \n} \nint o = ORDER [ i ] ; \nString result = ( ( ( o & E ) != 0 ) ? ( environment + \".\" ) : \"\" ) + ( ( ( o & B ) != 0 ) ? ( base + \".\" ) : \"\" ) + ( ( ( o & M ) != 0 ) ? ( modifier + \".\" ) : \"\" ) + key ; \ni = i + 1 ; \nreturn result ; \n} \npublic void remove ( ) { \nthrow new UnsupportedOperationException ( \"remove() is not supported on this key order iterator as \" + \"the ordering cannot be changed\" ) ; \n} \n} \n; \n} \n} \n"}
{"10438": "public class SilentFailSocketAppender { \npublic void append ( LoggingEvent event ) { \nif ( event == null ) { \nreturn ; \n} \nif ( address == null ) { \nerrorHandler . error ( \"No remote host is set for SocketAppender named \\\"\" + this . name + \"\\\".\" ) ; \nreturn ; \n} \nif ( oos != null ) { \ntry { \nif ( locationInfo ) { \nevent . getLocationInformation ( ) ; \n} \noos . writeObject ( event ) ; \noos . flush ( ) ; \nif ( counter = counter + 1 >= RESET_FREQUENCY ) { \ncounter = 0 ; \noos . reset ( ) ; \n} \n} \ncatch ( IOException e ) { \noos = null ; \nLogLog . warn ( \"Detected problem with connection: \" + e ) ; \nif ( reconnectionDelay > 0 ) { \nfireConnector ( ) ; \n} \n} \n} \n} \n} \n"}
{"10440": "public class WAMCompiledTermsPrintingVisitor { \nprotected void initializePrinters ( ) { \nint maxColumns = 0 ; \nprinters . add ( new SourceClausePrinter ( interner , symbolTable , traverser , maxColumns = maxColumns + 1 , printTable ) ) ; \nprinters . add ( new PositionPrinter ( interner , symbolTable , traverser , maxColumns = maxColumns + 1 , printTable ) ) ; \nprinters . add ( new UnoptimizedLabelPrinter ( interner , symbolTable , traverser , maxColumns = maxColumns + 1 , printTable ) ) ; \nprinters . add ( new UnoptimizedByteCodePrinter ( interner , symbolTable , traverser , maxColumns = maxColumns + 1 , printTable ) ) ; \nprinters . add ( new LabelPrinter ( interner , symbolTable , traverser , maxColumns = maxColumns + 1 , printTable ) ) ; \nprinters . add ( new ByteCodePrinter ( interner , symbolTable , traverser , maxColumns = maxColumns + 1 , printTable ) ) ; \n} \n} \n"}
{"10448": "public class NestedMediaQueries { \n@ Override public boolean enter ( RuleSetNode ruleSetNode ) { \nScopeNode scopeNode = NodeTreeUtils . getFirstChild ( ruleSetNode , ScopeNode . class ) ; \nSelectorGroupNode selectorGroupNode = NodeTreeUtils . getFirstChild ( ruleSetNode , SelectorGroupNode . class ) ; \nif ( selectorGroupNode == null ) { \nreturn true ; \n} \nList < SelectorNode > selectorNodes = NodeTreeUtils . getChildren ( selectorGroupNode , SelectorNode . class ) ; \nif ( selectorNodes . size ( ) < 0 ) { \nreturn true ; \n} \nList < MediaQueryNode > mediaQueryNodes = NodeTreeUtils . getAndRemoveChildren ( scopeNode , MediaQueryNode . class ) ; \nfor ( MediaQueryNode mediaQueryNode : mediaQueryNodes ) { \nScopeNode mediaScopeNode = NodeTreeUtils . getFirstChild ( mediaQueryNode , ScopeNode . class ) ; \nList < RuleSetNode > nestedRuleSets = NodeTreeUtils . getAndRemoveChildren ( mediaScopeNode , RuleSetNode . class ) ; \nif ( mediaScopeNode . getChildren ( ) . size ( ) > NodeTreeUtils . getChildren ( mediaScopeNode , WhiteSpaceCollectionNode . class ) . size ( ) ) { \nRuleSetNode newRuleSetNode = new RuleSetNode ( ) ; \nScopeNode newScopeNode = new ScopeNode ( ) ; \nnewRuleSetNode . addChild ( selectorGroupNode . clone ( ) ) ; \nnewRuleSetNode . addChild ( newScopeNode ) ; \nNodeTreeUtils . moveChildren ( mediaScopeNode , newScopeNode ) ; \nmediaScopeNode . clearChildren ( ) ; \nmediaScopeNode . addChild ( newRuleSetNode ) ; \n} \nfor ( RuleSetNode nestedRuleSet : nestedRuleSets ) { \nList < SelectorGroupNode > nestedSelectorGroupNodes = NodeTreeUtils . getChildren ( nestedRuleSet , SelectorGroupNode . class ) ; \nfor ( SelectorGroupNode nestedSelectorGroupNode : nestedSelectorGroupNodes ) { \nList < SelectorNode > nestedSelectorNodes = NodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SelectorNode . class ) ; \nNodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SpacingNode . class ) ; \nfor ( SelectorNode selectorNode : selectorNodes ) { \nfor ( SelectorNode nestedSelectorNode : nestedSelectorNodes ) { \nif ( nestedSelectorNode . getChildren ( ) . get ( 0 ) != null ) { \nif ( nestedSelectorNode . getChildren ( ) . get ( 0 ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) nestedSelectorNode . getChildren ( ) . get ( 0 ) ; \nselectorSegmentNode . setCombinator ( \" \" ) ; \n} \n} \nfor ( int j = selectorNode . getChildren ( ) . size ( ) - 1 ; \nj >= 0 ; \nj = j - 1 ) { \nif ( selectorNode . getChildren ( ) . get ( j ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) selectorNode . getChildren ( ) . get ( j ) . clone ( ) ; \nnestedSelectorNode . addChild ( 0 , selectorSegmentNode ) ; \n} \n} \nnestedSelectorGroupNode . addChild ( nestedSelectorNode ) ; \nnestedSelectorGroupNode . addChild ( new SpacingNode ( \" \" ) ) ; \n} \n} \n} \nmediaScopeNode . addChild ( nestedRuleSet ) ; \n} \nif ( ruleSetNode . getParent ( ) != null ) { \nruleSetNode . getParent ( ) . addChild ( new SpacingNode ( \"\\n\" ) ) ; \nruleSetNode . getParent ( ) . addChild ( mediaQueryNode ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10452": "public class BatchSynchQueueBase { \nprotected boolean insert ( E element , boolean unlockAndBlock ) { \nSynchRecordImpl < E > record = new SynchRecordImpl < E > ( element ) ; \nboolean result = buffer . offer ( record ) ; \nif ( result ) { \ncount = count + 1 ; \nnotEmpty . signal ( ) ; \nif ( unlockAndBlock ) { \nlock . unlock ( ) ; \nrecord . waitForConsumer ( ) ; \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"10457": "public class ScopeNode { \npublic ScopeNode callMixin ( String name , ArgumentsNode arguments ) { \nList < ExpressionGroupNode > argumentList = ( arguments != null ) ? NodeTreeUtils . getChildren ( arguments , ExpressionGroupNode . class ) : Collections . < ExpressionGroupNode > emptyList ( ) ; \nif ( argumentList . size ( ) > _parameterDefinitions . size ( ) ) { \nthrow new IllegalMixinArgumentException ( name , _parameterDefinitions . size ( ) ) ; \n} \nScopeNode mixinScope = clone ( ) ; \nNodeTreeUtils . filterLineBreaks ( mixinScope ) ; \nfor ( int i = 0 ; \ni < argumentList . size ( ) ; \ni = i + 1 ) { \nExpressionGroupNode argument = argumentList . get ( i ) ; \nVariableDefinitionNode parameter = mixinScope . _parameterDefinitions . get ( i ) ; \nparameter . clearChildren ( ) ; \nparameter . addChild ( argument ) ; \n} \ngetParent ( ) . setVisible ( false ) ; \nreturn mixinScope ; \n} \n} \n"}
{"10462": "public class WAMResolvingMachine { \nprotected Term decodeHeap ( int start , Map < Integer , Variable > variableContext ) { \nTerm result = null ; \nint addr = deref ( start ) ; \nbyte tag = getDerefTag ( ) ; \nint val = getDerefVal ( ) ; \nswitch ( tag ) { \ncase REF : { \nVariable var = variableContext . get ( val ) ; \nif ( var == null ) { \nvar = new Variable ( varNameId . decrementAndGet ( ) , null , false ) ; \nvariableContext . put ( val , var ) ; \n} \nresult = var ; \nbreak ; \n} \ncase STR : { \nint fn = getHeap ( val ) ; \nint f = fn & 0x00ffffff ; \nFunctorName functorName = getDeinternedFunctorName ( f ) ; \nint arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \nfor ( int i = 0 ; \ni < arity ; \ni = i + 1 ) { \narguments [ i ] = decodeHeap ( val + 1 + i , variableContext ) ; \n} \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ncase WAMInstruction . CON : { \nint f = val & 0x3fffffff ; \nresult = new Functor ( f , null ) ; \nbreak ; \n} \ncase WAMInstruction . LIS : { \nFunctorName functorName = new FunctorName ( \"cons\" , 2 ) ; \nint f = internFunctorName ( functorName ) ; \nint arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \nfor ( int i = 0 ; \ni < arity ; \ni = i + 1 ) { \narguments [ i ] = decodeHeap ( val + i , variableContext ) ; \n} \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ndefault : throw new IllegalStateException ( \"Encountered unknown tag type on the heap.\" ) ; \n} \nreturn result ; \n} \n} \n"}
{"10470": "public class LockFreeNQueue { \npublic E poll ( ) { \nint currentLevel = 0 ; \nwhile ( true ) { \nMarker < E > h = null ; \nNode < E > first = null ; \nNode < E > second = null ; \nfor ( ; \ncurrentLevel < n ; \ncurrentLevel = currentLevel + 1 ) { \nh = markers [ currentLevel ] ; \nfirst = h . getNext ( ) ; \nsecond = first . getNext ( ) ; \nif ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nbreak ; \n} \nelse if ( currentLevel == ( n - 1 ) ) { \nreturn null ; \n} \n} \nNode < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; \nif ( first == h . getNext ( ) ) { \nif ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nif ( first == null ) { \nreturn null ; \n} \nelse { \nmarkers [ currentLevel + 1 ] . casTail ( t , first ) ; \n} \n} \nelse if ( h . casNext ( first , second ) ) { \nDataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; \nE item = firstDataNode . getItem ( ) ; \nif ( item != null ) { \nfirstDataNode . setItem ( null ) ; \ncount . decrementAndGet ( ) ; \nreturn item ; \n} \n} \n} \n} \n} \n} \n"}
{"10515": "public class CircularArrayMap { \npublic void clearUpTo ( int key ) { \nif ( ( ( start <= key ) && ( key < ( end - 1 ) ) ) ) { \nint newStart ; \nfor ( newStart = start ; \n( newStart <= end ) && ( newStart <= key ) ; \nnewStart = newStart + 1 ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount = count - 1 ; \n} \n} \nfor ( ; \nnewStart <= end ; \nnewStart = newStart + 1 ) { \nif ( data [ offset ( newStart ) ] != null ) { \nbreak ; \n} \n} \nstart = newStart ; \n} \nelse { \nint newStart ; \nfor ( newStart = start ; \n( newStart <= end ) ; \nnewStart = newStart + 1 ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount = count - 1 ; \n} \n} \nstart = newStart ; \noffset = - start ; \n} \n} \n} \n"}
{"10530": "public class CommandLineParser { \nprivate Properties takeFreeArgsAsProperties ( Properties properties , int from ) { \nProperties result = new Properties ( ) ; \nfor ( int i = from ; \ntrue ; \ni = i + 1 ) { \nString nextFreeArg = properties . getProperty ( Integer . toString ( i ) ) ; \nif ( nextFreeArg == null ) { \nbreak ; \n} \nString [ ] nameValuePair = nextFreeArg . split ( \"=\" ) ; \nif ( nameValuePair . length == 2 ) { \nresult . setProperty ( nameValuePair [ 0 ] , nameValuePair [ 1 ] ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10533": "public class PTStemmer { \npublic Enumeration listOptions ( ) { \nVector < Option > result ; \nString desc ; \nSelectedTag tag ; \nint i ; \nresult = new Vector < Option > ( ) ; \ndesc = \"\" ; \nfor ( i = 0 ; \ni < TAGS_STEMMERS . length ; \ni = i + 1 ) { \ntag = new SelectedTag ( TAGS_STEMMERS [ i ] . getID ( ) , TAGS_STEMMERS ) ; \ndesc += \"\\t\" + tag . getSelectedTag ( ) . getIDStr ( ) + \" = \" + tag . getSelectedTag ( ) . getReadable ( ) + \"\\n\" ; \n} \nresult . addElement ( new Option ( \"\\tThe type of stemmer algorithm to use:\\n\" + desc + \"\\t(default: \" + new SelectedTag ( STEMMER_ORENGO , TAGS_STEMMERS ) + \")\" , \"S\" , 1 , \"-S \" + Tag . toOptionList ( TAGS_STEMMERS ) ) ) ; \nresult . addElement ( new Option ( \"\\tThe file with the named entities to ignore (optional).\\n\" + \"\\tFile format: simple text file with one entity per line.\\n\" + \"\\t(default: none)\\n\" , \"N\" , 1 , \"-N <file>\" ) ) ; \nresult . addElement ( new Option ( \"\\tThe file with the stopwords (optional).\\n\" + \"\\tFile format: simple text file with one stopword per line.\\n\" + \"\\t(default: none)\\n\" , \"W\" , 1 , \"-W <file>\" ) ) ; \nresult . addElement ( new Option ( \"\\tThe size of the cache. Disable with 0.\\n\" + \"\\t(default: 1000)\\n\" , \"C\" , 1 , \"-C <int>\" ) ) ; \nreturn result . elements ( ) ; \n} \n} \n"}
{"10546": "public class WAMResolvingJavaMachine { \nprivate void trail ( int addr ) { \nif ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) { \ndata . put ( trp , addr ) ; \ntrp = trp + 1 ; \n} \n} \n} \n"}
{"10547": "public class WAMResolvingJavaMachine { \nprivate void unwindTrail ( int a1 , int a2 ) { \nfor ( int addr = a1 ; \naddr < a2 ; \naddr = addr + 1 ) { \nint tmp = data . get ( addr ) ; \ndata . put ( tmp , refTo ( tmp ) ) ; \n} \n} \n} \n"}
{"10548": "public class WAMResolvingJavaMachine { \nprivate void tidyTrail ( ) { \nint i ; \nif ( bp == 0 ) { \ni = TRAIL_BASE ; \n} \nelse { \ni = data . get ( bp + data . get ( bp ) + 5 ) ; \n} \nwhile ( i < trp ) { \nint addr = data . get ( i ) ; \nif ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) { \ni = i + 1 ; \n} \nelse { \ndata . put ( i , data . get ( trp - 1 ) ) ; \ntrp = trp - 1 ; \n} \n} \n} \n} \n"}
{"10549": "public class WAMResolvingJavaMachine { \nprivate boolean unify ( int a1 , int a2 ) { \nuPush ( a1 ) ; \nuPush ( a2 ) ; \nboolean fail = false ; \nwhile ( ! uEmpty ( ) && ! fail ) { \nint d1 = deref ( uPop ( ) ) ; \nint t1 = derefTag ; \nint v1 = derefVal ; \nint d2 = deref ( uPop ( ) ) ; \nint t2 = derefTag ; \nint v2 = derefVal ; \nif ( d1 != d2 ) { \nif ( ( t1 == WAMInstruction . REF ) ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . REF ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . STR ) { \nint fn1 = data . get ( v1 ) ; \nint fn2 = data . get ( v2 ) ; \nbyte n1 = ( byte ) ( fn1 >>> 24 ) ; \nif ( fn1 == fn2 ) { \nfor ( int i = 1 ; \ni <= n1 ; \ni = i + 1 ) { \nuPush ( v1 + i ) ; \nuPush ( v2 + i ) ; \n} \n} \nelse { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . CON ) { \nif ( ( t1 != WAMInstruction . CON ) || ( v1 != v2 ) ) { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . LIS ) { \nif ( t1 != WAMInstruction . LIS ) { \nfail = true ; \n} \nelse { \nuPush ( v1 ) ; \nuPush ( v2 ) ; \nuPush ( v1 + 1 ) ; \nuPush ( v2 + 1 ) ; \n} \n} \n} \n} \nreturn ! fail ; \n} \n} \n"}
{"10553": "public class EightPuzzleState { \npublic static boolean isSolvable ( EightPuzzleState state ) { \nEightPuzzleState checkState ; \ntry { \ncheckState = ( EightPuzzleState ) state . clone ( ) ; \n} \ncatch ( CloneNotSupportedException e ) { \nthrow new IllegalStateException ( \"Puzzle state could not be cloned.\" , e ) ; \n} \nEightPuzzleState goalState = getGoalState ( ) ; \nint illegalSwaps = 0 ; \nfor ( int j = 0 ; \nj < 3 ; \nj = j + 1 ) { \nfor ( int i = 0 ; \ni < 3 ; \ni = i + 1 ) { \nchar t = goalState . getTileAt ( i , j ) ; \nillegalSwaps += checkState . swapTileToLocationCountingIllegal ( t , i , j ) ; \n} \n} \nreturn ( illegalSwaps % 2 ) == 0 ; \n} \n} \n"}
{"10556": "public class EightPuzzleState { \npublic String prettyPrint ( ) { \nString result = \"\" ; \nfor ( int j = 0 ; \nj < 3 ; \nj = j + 1 ) { \nresult += new String ( board [ j ] ) + \"\\n\" ; \n} \nresult = result . replace ( 'E' , ' ' ) ; \nreturn result ; \n} \n} \n"}
{"10557": "public class EightPuzzleState { \nprotected int swapTileToLocationCountingIllegal ( char t , int x , int y ) { \nint illegal = 0 ; \nint tileX = getXForTile ( t ) ; \nint tileY = getYForTile ( t ) ; \nwhile ( tileX != x ) { \nif ( ( tileX - x ) > 0 ) { \nif ( swapTiles ( tileX , tileY , tileX - 1 , tileY ) ) { \nillegal = illegal + 1 ; \n} \ntileX = tileX - 1 ; \n} \nelse { \nif ( swapTiles ( tileX , tileY , tileX + 1 , tileY ) ) { \nillegal = illegal + 1 ; \n} \ntileX = tileX + 1 ; \n} \n} \nwhile ( tileY != y ) { \nif ( swapTiles ( tileX , tileY , tileX , tileY - 1 ) ) { \nillegal = illegal + 1 ; \n} \ntileY = tileY - 1 ; \n} \nreturn illegal ; \n} \n} \n"}
{"10559": "public class EightPuzzleState { \nprivate static List < Character > stringToCharList ( String boardString ) { \nchar [ ] chars = new char [ 9 ] ; \nboardString . getChars ( 0 , 9 , chars , 0 ) ; \nList < Character > charList = new ArrayList < Character > ( ) ; \nfor ( int l = 0 ; \nl < 9 ; \nl = l + 1 ) { \ncharList . add ( chars [ l ] ) ; \n} \nreturn charList ; \n} \n} \n"}
{"10560": "public class EightPuzzleState { \nprivate static EightPuzzleState charListToState ( List < Character > charList ) { \nEightPuzzleState newState = new EightPuzzleState ( ) ; \nIterator < Character > k = charList . iterator ( ) ; \nfor ( int j = 0 ; \nj < 3 ; \nj = j + 1 ) { \nfor ( int i = 0 ; \ni < 3 ; \ni = i + 1 ) { \nchar nextChar = k . next ( ) ; \nif ( nextChar == 'E' ) { \nnewState . emptyX = i ; \nnewState . emptyY = j ; \n} \nnewState . board [ j ] [ i ] = nextChar ; \n} \n} \nreturn newState ; \n} \n} \n"}
{"10572": "public class Sizeof { \nprivate static void runGCTillStable ( ) { \nlong usedMem1 = usedMemory ( ) ; \nlong usedMem2 = Long . MAX_VALUE ; \nfor ( int i = 0 ; \n( usedMem1 < usedMem2 ) && ( i < 500 ) ; \ni = i + 1 ) { \nRUNTIME . runFinalization ( ) ; \nRUNTIME . gc ( ) ; \nThread . currentThread ( ) . yield ( ) ; \nusedMem2 = usedMem1 ; \nusedMem1 = usedMemory ( ) ; \n} \n} \n} \n"}
{"10589": "public class FibonacciHeap { \npublic boolean offer ( E o ) { \nNode newNode = new Node ( o ) ; \nif ( minNode != null ) { \nnewNode . next = minNode . next ; \nnewNode . prev = minNode ; \nminNode . next . prev = newNode ; \nminNode . next = newNode ; \nupdateMinimum ( newNode ) ; \n} \nelse { \nnewNode . next = newNode ; \nnewNode . prev = newNode ; \nminNode = newNode ; \n} \nsize = size + 1 ; \nreturn true ; \n} \n} \n"}
{"10619": "public class Functor { \npublic Iterator < Operator < Term > > getChildren ( boolean reverse ) { \nif ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) { \nreturn ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; \n} \nelse { \nif ( arguments == null ) { \nreturn new LinkedList < Operator < Term > > ( ) . iterator ( ) ; \n} \nelse if ( ! reverse ) { \nreturn Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; \n} \nelse { \nList < Operator < Term > > argList = new LinkedList < Operator < Term > > ( ) ; \nfor ( int i = arity - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nargList . add ( arguments [ i ] ) ; \n} \nreturn argList . iterator ( ) ; \n} \n} \n} \n} \n"}
{"10620": "public class Functor { \nprotected String toStringArguments ( ) { \nString result = \"\" ; \nif ( arity > 0 ) { \nresult += \"[ \" ; \nfor ( int i = 0 ; \ni < arity ; \ni = i + 1 ) { \nTerm nextArg = arguments [ i ] ; \nresult += ( ( nextArg != null ) ? nextArg . toString ( ) : \"<null>\" ) + ( ( i < ( arity - 1 ) ) ? \", \" : \" \" ) ; \n} \nresult += \" ]\" ; \n} \nreturn result ; \n} \n} \n"}
{"10632": "public class Type1UUID { \nprivate static long getUUIDTime ( ) { \nif ( _currentMillis != System . currentTimeMillis ( ) ) { \n_currentMillis = System . currentTimeMillis ( ) ; \n_counter = 0 ; \n} \nif ( _counter + 1 >= MILLI_MULT ) { \n_currentMillis = _currentMillis + 1 ; \n_counter = 0 ; \n} \nlong currentTime = ( _currentMillis + GREG_OFFSET ) * MILLI_MULT ; \nreturn currentTime + _counter = _counter + 1 ; \n} \n} \n"}
{"10650": "public class OrFilter { \npublic void addFilter ( PacketFilter filter ) { \nif ( filter == null ) { \nthrow new IllegalArgumentException ( \"Parameter cannot be null.\" ) ; \n} \nif ( size == filters . length ) { \nPacketFilter [ ] newFilters = new PacketFilter [ filters . length + 2 ] ; \nfor ( int i = 0 ; \ni < filters . length ; \ni = i + 1 ) { \nnewFilters [ i ] = filters [ i ] ; \n} \nfilters = newFilters ; \n} \nfilters [ size ] = filter ; \nsize = size + 1 ; \n} \n} \n"}
{"10661": "public class Files { \npublic static Boolean contentEquals ( Path file1 , Path file2 ) throws IOException { \nif ( ! java . nio . file . Files . isRegularFile ( file1 ) ) throw new IllegalArgumentException ( file1 + \"is not a regular file\" ) ; \nif ( ! java . nio . file . Files . isRegularFile ( file2 ) ) throw new IllegalArgumentException ( file2 + \"is not a regular file\" ) ; \nFileChannel channel1 = null ; \nFileChannel channel2 = null ; \nMappedByteBuffer buffer1 = null ; \nMappedByteBuffer buffer2 = null ; \ntry { \nlong size1 = java . nio . file . Files . size ( file1 ) ; \nlong size2 = java . nio . file . Files . size ( file2 ) ; \nif ( size1 != size2 ) return false ; \nlong position = 0 ; \nlong length = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \nchannel1 = FileChannel . open ( file1 ) ; \nchannel2 = FileChannel . open ( file2 ) ; \nwhile ( length > 0 ) { \nbuffer1 = channel1 . map ( MapMode . READ_ONLY , position , length ) ; \nbuffer2 = channel2 . map ( MapMode . READ_ONLY , position , length ) ; \nfor ( int i = 0 ; \ni < length ; \ni = i + 1 ) if ( buffer1 . get ( ) != buffer2 . get ( ) ) return false ; \nposition += length ; \nlength = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \ncleanDirectByteBuffer ( buffer1 ) ; \nbuffer1 = null ; \ncleanDirectByteBuffer ( buffer2 ) ; \nbuffer2 = null ; \n} \n} \nfinally { \ncleanDirectByteBuffer ( buffer1 ) ; \ncleanDirectByteBuffer ( buffer2 ) ; \nif ( channel1 != null ) try { \nchannel1 . close ( ) ; \n} \ncatch ( IOException e ) { \nif ( channel2 != null ) channel2 . close ( ) ; \nthrow e ; \n} \nif ( channel2 != null ) channel2 . close ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"10670": "public class TransactionalHashMap { \nEntry < K , V > removeEntryForKey ( Object key ) throws ConcurrentModificationException { \nObject k = maskNull ( key ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nwhile ( e != null ) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) && eq ( k , e . key ) ) { \nif ( e . is ( Entry . DELETED , null ) && ! e . is ( Entry . DELETED , getCurrentThreadId ( ) ) ) throw new ConcurrentModificationException ( ) ; \nif ( auto_commit ) { \nmodCount = modCount + 1 ; \nsize = size - 1 ; \nif ( prev == e ) table [ i ] = next ; \nelse prev . next = next ; \nreturn e ; \n} \nelse e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10671": "public class TransactionalHashMap { \n@ SuppressWarnings ( \"unchecked\" ) Entry < K , V > removeMapping ( Object o ) { \nif ( ! ( o instanceof Map . Entry ) ) return null ; \nMap . Entry < K , V > entry = ( Map . Entry < K , V > ) o ; \nObject k = maskNull ( entry . getKey ( ) ) ; \nint hash = hash ( k ) ; \nint i = indexFor ( hash , table . length ) ; \nEntry < K , V > prev = table [ i ] ; \nEntry < K , V > e = prev ; \nwhile ( e != null ) { \nEntry < K , V > next = e . next ; \nif ( e . hash == hash && validEntry ( e ) && e . equals ( entry ) ) { \nif ( auto_commit ) { \nmodCount = modCount + 1 ; \nsize = size - 1 ; \nif ( prev == e ) table [ i ] = next ; \nelse prev . next = next ; \n} \nelse e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; \nreturn e ; \n} \nprev = e ; \ne = next ; \n} \nreturn e ; \n} \n} \n"}
{"10672": "public class TransactionalHashMap { \nvoid addEntry ( int hash , K key , V value , int bucketIndex ) { \ntable [ bucketIndex ] = new Entry < K , V > ( hash , key , value , table [ bucketIndex ] ) ; \nif ( ! auto_commit ) table [ bucketIndex ] . setStatus ( Entry . ADDED , getCurrentThreadId ( ) ) ; \nif ( size = size + 1 >= threshold ) resize ( 2 * table . length ) ; \n} \n} \n"}
{"10719": "public class ObservableWriter { \nprivate void notifyListeners ( String str ) { \nWriterListener [ ] writerListeners = null ; \nsynchronized ( listeners ) { \nwriterListeners = new WriterListener [ listeners . size ( ) ] ; \nlisteners . toArray ( writerListeners ) ; \n} \nfor ( int i = 0 ; \ni < writerListeners . length ; \ni = i + 1 ) { \nwriterListeners [ i ] . write ( str ) ; \n} \n} \n} \n"}
{"10729": "public class CF_Locator { \nprotected final void include ( String name , File file ) { \nif ( ! file . exists ( ) ) { \nreturn ; \n} \nif ( ! file . isDirectory ( ) ) { \nif ( this . jarFilter . size ( ) > 0 ) { \nboolean ok = false ; \nfor ( String s : this . jarFilter ) { \nif ( file . getName ( ) . startsWith ( s ) ) { \nok = true ; \n} \n} \nif ( ok == false ) { \nreturn ; \n} \n} \nthis . includeJar ( file ) ; \nreturn ; \n} \nif ( name == null ) { \nname = \"\" ; \n} \nelse { \nname += \".\" ; \n} \nFile [ ] dirs = file . listFiles ( CF_Utils . DIRECTORIES_ONLY ) ; \nfor ( int i = 0 ; \ni < dirs . length ; \ni = i + 1 ) { \ntry { \nthis . locationMap . put ( new URI ( \"file://\" + dirs [ i ] . getCanonicalPath ( ) ) , name + dirs [ i ] . getName ( ) ) ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \ncatch ( URISyntaxException ignore ) { \nreturn ; \n} \nthis . include ( name + dirs [ i ] . getName ( ) , dirs [ i ] ) ; \n} \n} \n} \n"}
{"10775": "public class CF { \nprotected final Map < Class < ? > , URI > searchDirectory ( Class < ? > clazz , File directory , URI location , String packageName ) { \nMap < Class < ? > , URI > ret = new HashMap < > ( ) ; \nString [ ] files = directory . list ( ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni = i + 1 ) { \nif ( files [ i ] . endsWith ( \".class\" ) ) { \nString classname = files [ i ] . substring ( 0 , files [ i ] . length ( ) - 6 ) ; \ntry { \nClass < ? > c = Class . forName ( packageName + \".\" + classname ) ; \nif ( clazz . isAssignableFrom ( c ) && ! clazz . getName ( ) . equals ( packageName + \".\" + classname ) ) { \nret . put ( c , location ) ; \n} \n} \ncatch ( Exception ex ) { \nerrors . add ( ex ) ; \n} \n} \n} \nreturn ret ; \n} \n} \n"}
{"10791": "public class RSMUtils { \npublic static List < Identifiable > filterRSMResponse ( List < Identifiable > objects , RSM rsm ) throws IllegalArgumentException { \nString after = rsm . getAfter ( ) ; \nString before = rsm . getBefore ( ) ; \nint initialIndex = rsm . getIndex ( ) ; \nint lastIndex = objects . size ( ) ; \nif ( after != null || ( before != null && ! before . isEmpty ( ) ) ) { \nboolean afterItemFound = false ; \nboolean beforeItemFound = false ; \nint i = 0 ; \nfor ( Identifiable object : objects ) { \nif ( after != null && after . equals ( object . getId ( ) ) ) { \ninitialIndex = i + 1 ; \nafterItemFound = true ; \n} \nif ( before != null && before . equals ( object . getId ( ) ) ) { \nlastIndex = i ; \nbeforeItemFound = true ; \n} \ni = i + 1 ; \n} \nif ( after != null && ! afterItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( before != null && ! before . isEmpty ( ) && ! beforeItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \n} \nif ( rsm . getMax ( ) != null ) { \nif ( before != null ) { \ninitialIndex = lastIndex - rsm . getMax ( ) ; \n} \nelse { \nlastIndex = initialIndex + rsm . getMax ( ) ; \n} \n} \nboolean outOfRange = initialIndex > lastIndex || initialIndex < 0 || lastIndex > objects . size ( ) ; \nList < Identifiable > filteredList = outOfRange ? new LinkedList < Identifiable > ( ) : objects . subList ( initialIndex , lastIndex ) ; \nrsm . setCount ( objects . size ( ) ) ; \nrsm . setIndex ( initialIndex ) ; \nif ( ! filteredList . isEmpty ( ) ) { \nrsm . setFirst ( filteredList . get ( 0 ) . getId ( ) ) ; \nrsm . setLast ( filteredList . get ( filteredList . size ( ) - 1 ) . getId ( ) ) ; \n} \nreturn filteredList ; \n} \n} \n"}
{"10818": "public class AbstractReferenceMap { \nprotected void purge ( Reference ref ) { \nint hash = ref . hashCode ( ) ; \nint index = hashIndex ( hash , data . length ) ; \nHashEntry < K , V > previous = null ; \nHashEntry < K , V > entry = data [ index ] ; \nwhile ( entry != null ) { \nif ( ( ( ReferenceEntry < K , V > ) entry ) . purge ( ref ) ) { \nif ( previous == null ) { \ndata [ index ] = entry . next ; \n} \nelse { \nprevious . next = entry . next ; \n} \nthis . size = this . size - 1 ; \nreturn ; \n} \nprevious = entry ; \nentry = entry . next ; \n} \n} \n} \n"}
{"10844": "public class RequestUtils { \npublic static Object toValue ( String name , Object value ) { \nString [ ] parts = StringUtils . split ( name , \"@\" , 2 ) ; \nString fieldName = null ; \nString fieldType = \"String\" ; \nif ( parts . length == 2 ) { \nfieldType = parts [ 1 ] ; \nfieldName = parts [ 0 ] ; \n} \nelse if ( parts . length == 1 ) { \nfieldName = parts [ 0 ] ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Invalid property name\" ) ; \n} \ntry { \nint l = Array . getLength ( value ) ; \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nif ( ! fieldName . endsWith ( \"[]\" ) && l == 1 ) { \nreturn rpt . newInstance ( Array . get ( value , 0 ) ) ; \n} \nClass < ? > componentType = rpt . getComponentType ( ) ; \nObject [ ] a = ( Object [ ] ) Array . newInstance ( componentType , l ) ; \nfor ( int i = 0 ; \ni < l ; \ni = i + 1 ) { \na [ i ] = rpt . newInstance ( Array . get ( value , i ) ) ; \n} \nreturn a ; \n} \ncatch ( IllegalArgumentException e ) { \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nreturn rpt . newInstance ( value ) ; \n} \n} \n} \n"}
{"10868": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackDelete ( final Node < K , V > deletedNode ) { \nfor ( int index = FIRST_INDEX ; \nindex < NUMBER_OF_INDICES ; \nindex = index + 1 ) { \nif ( ( deletedNode . getLeft ( index ) != null ) && ( deletedNode . getRight ( index ) != null ) ) { \nswapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; \n} \nNode < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; \nif ( replacement != null ) { \nreplacement . setParent ( deletedNode . getParent ( index ) , index ) ; \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = replacement ; \n} \nelse if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( replacement , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( replacement , index ) ; \n} \ndeletedNode . setLeft ( null , index ) ; \ndeletedNode . setRight ( null , index ) ; \ndeletedNode . setParent ( null , index ) ; \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( replacement , index ) ; \n} \n} \nelse { \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = null ; \n} \nelse { \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( deletedNode , index ) ; \n} \nif ( deletedNode . getParent ( index ) != null ) { \nif ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( null , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( null , index ) ; \n} \ndeletedNode . setParent ( null , index ) ; \n} \n} \n} \n} \nshrink ( ) ; \n} \n} \n"}
{"10881": "public class Cache { \nprotected synchronized void cullCache ( ) { \nif ( maxCacheSize < 0 ) { \nreturn ; \n} \nif ( map . size ( ) > maxCacheSize ) { \ndeleteExpiredEntries ( ) ; \nint desiredSize = ( int ) ( maxCacheSize * .90 ) ; \nfor ( int i = map . size ( ) ; \ni > desiredSize ; \ni = i - 1 ) { \nif ( remove ( lastAccessedList . getLast ( ) . object , true ) == null ) { \nlog . warn ( \"Error attempting to cullCache with remove(\" + lastAccessedList . getLast ( ) . object . toString ( ) + \") - cacheObject not found in cache!\" ) ; \nlastAccessedList . getLast ( ) . remove ( ) ; \n} \n} \n} \n} \n} \n"}
{"10887": "public class IPv4Scanner { \npublic static InetAddress subnetAddress0 ( InetAddress addr , int subnetBits ) { \nif ( subnetBits < 1 || 32 <= subnetBits ) { \nthrow new FireRESTException ( \"Expected subnetBits 1..31\" ) ; \n} \nlong mask = 1 ; \nfor ( int i = 0 ; \ni < 32 ; \ni = i + 1 ) { \nmask <<= 1 ; \nmask |= i < subnetBits ? 1 : 0 ; \n} \nlong host0 = asLongAddress ( addr ) & mask ; \ntry { \nreturn asInetAddress ( host0 ) ; \n} \ncatch ( UnknownHostException e ) { \nthrow new FireRESTException ( e ) ; \n} \n} \n} \n"}
{"10924": "public class Playlist { \npublic HashMap < String , Object > export ( ) { \nHashMap < String , Object > data = new HashMap < > ( ) ; \nfor ( int i = 0 ; \ni < queue . size ( ) ; \ni = i + 1 ) { \ndata . put ( QUEUE_DESCRIPTOR + i , queue . get ( i ) . export ( ) ) ; \n} \nfor ( int i = 0 ; \ni < playbackModes . size ( ) ; \ni = i + 1 ) { \ndata . put ( PLAYBACK_MODE_DESCRIPTOR + i , playbackModes . get ( i ) . name ( ) ) ; \n} \ndata . put ( NAME_DESCRIPTOR , name ) ; \ndata . put ( POSITION_DESCRIPTOR , position ) ; \ndata . put ( DATA_DESCRIPTOR , this . data ) ; \nreturn data ; \n} \n} \n"}
{"10925": "public class StringUtils { \npublic static final String escapeForXML ( String string ) { \nif ( string == null ) { \nreturn null ; \n} \nchar ch ; \nint i = 0 ; \nint last = 0 ; \nchar [ ] input = string . toCharArray ( ) ; \nint len = input . length ; \nStringBuffer out = new StringBuffer ( ( int ) ( len * 1.3 ) ) ; \nfor ( ; \ni < len ; \ni = i + 1 ) { \nch = input [ i ] ; \nif ( ch > '>' ) { \ncontinue ; \n} \nelse if ( ch == '<' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( LT_ENCODE ) ; \n} \nelse if ( ch == '>' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( GT_ENCODE ) ; \n} \nelse if ( ch == '&' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nif ( ! ( len > i + 5 && input [ i + 1 ] == '#' && Character . isDigit ( input [ i + 2 ] ) && Character . isDigit ( input [ i + 3 ] ) && Character . isDigit ( input [ i + 4 ] ) && input [ i + 5 ] == ';' ) ) { \nlast = i + 1 ; \nout . append ( AMP_ENCODE ) ; \n} \n} \nelse if ( ch == '\"' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( QUOTE_ENCODE ) ; \n} \n} \nif ( last == 0 ) { \nreturn string ; \n} \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"10941": "public class AbstractHashedMap { \npublic boolean containsValue ( Object value ) { \nif ( value == null ) { \nfor ( int i = 0 , isize = data . length ; \ni < isize ; \ni = i + 1 ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( entry . getValue ( ) == null ) { \nreturn true ; \n} \nentry = entry . next ; \n} \n} \n} \nelse { \nfor ( int i = 0 , isize = data . length ; \ni < isize ; \ni = i + 1 ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( isEqualValue ( value , entry . getValue ( ) ) ) { \nreturn true ; \n} \nentry = entry . next ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10943": "public class AbstractHashedMap { \npublic void clear ( ) { \nmodCount = modCount + 1 ; \nHashEntry [ ] data = this . data ; \nfor ( int i = data . length - 1 ; \ni >= 0 ; \ni = i - 1 ) { \ndata [ i ] = null ; \n} \nsize = 0 ; \n} \n} \n"}
{"10947": "public class AbstractHashedMap { \nprotected void ensureCapacity ( int newCapacity ) { \nint oldCapacity = data . length ; \nif ( newCapacity <= oldCapacity ) { \nreturn ; \n} \nif ( size == 0 ) { \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = new HashEntry [ newCapacity ] ; \n} \nelse { \nHashEntry < K , V > oldEntries [ ] = data ; \nHashEntry < K , V > newEntries [ ] = new HashEntry [ newCapacity ] ; \nmodCount = modCount + 1 ; \nfor ( int i = oldCapacity - 1 ; \ni >= 0 ; \ni = i - 1 ) { \nHashEntry < K , V > entry = oldEntries [ i ] ; \nif ( entry != null ) { \noldEntries [ i ] = null ; \ndo { \nHashEntry < K , V > next = entry . next ; \nint index = hashIndex ( entry . hashCode , newCapacity ) ; \nentry . next = newEntries [ index ] ; \nnewEntries [ index ] = entry ; \nentry = next ; \n} \nwhile ( entry != null ) ; \n} \n} \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = newEntries ; \n} \n} \n} \n"}
