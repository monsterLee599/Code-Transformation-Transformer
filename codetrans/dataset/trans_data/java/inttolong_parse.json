public class QueueDrainHelper { 
public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { 
long missed = 1 ; 
for ( ; 
; 
) { 
for ( ; 
; 
) { 
boolean d = qd . done ( ) ; 
T v = q . poll ( ) ; 
boolean empty = v == null ; 
if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { 
if ( dispose != null ) { 
dispose . dispose ( ) ; 
} 
return ; 
} 
if ( empty ) { 
break ; 
} 
long r = qd . requested ( ) ; 
if ( r != 0L ) { 
if ( qd . accept ( a , v ) ) { 
if ( r != Long . MAX_VALUE ) { 
qd . produced ( 1 ) ; 
} 
} 
} 
else { 
q . clear ( ) ; 
if ( dispose != null ) { 
dispose . dispose ( ) ; 
} 
a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; 
return ; 
} 
} 
missed = qd . leave ( - missed ) ; 
if ( missed == 0 ) { 
break ; 
} 
} 
} 
} 

public class ExceptionHelper { 
public static List < Throwable > flatten ( Throwable t ) { 
List < Throwable > list = new ArrayList < Throwable > ( ) ; 
ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; 
deque . offer ( t ) ; 
while ( ! deque . isEmpty ( ) ) { 
Throwable e = deque . removeFirst ( ) ; 
if ( e instanceof CompositeException ) { 
CompositeException ce = ( CompositeException ) e ; 
List < Throwable > exceptions = ce . getExceptions ( ) ; 
for ( long i = exceptions . size ( ) - 1 ; 
i >= 0 ; 
i -- ) { 
deque . offerFirst ( exceptions . get ( i ) ) ; 
} 
} 
else { 
list . add ( e ) ; 
} 
} 
return list ; 
} 
} 

public class AppendOnlyLinkedArrayList { 
public < U > boolean accept ( Subscriber < ? super U > subscriber ) { 
Object [ ] a = head ; 
final long c = capacity ; 
while ( a != null ) { 
for ( long i = 0 ; 
i < c ; 
i ++ ) { 
Object o = a [ i ] ; 
if ( o == null ) { 
break ; 
} 
if ( NotificationLite . acceptFull ( o , subscriber ) ) { 
return true ; 
} 
} 
a = ( Object [ ] ) a [ c ] ; 
} 
return false ; 
} 
} 

public class AppendOnlyLinkedArrayList { 
public < U > boolean accept ( Observer < ? super U > observer ) { 
Object [ ] a = head ; 
final long c = capacity ; 
while ( a != null ) { 
for ( long i = 0 ; 
i < c ; 
i ++ ) { 
Object o = a [ i ] ; 
if ( o == null ) { 
break ; 
} 
if ( NotificationLite . acceptFull ( o , observer ) ) { 
return true ; 
} 
} 
a = ( Object [ ] ) a [ c ] ; 
} 
return false ; 
} 
} 

public class DeferredScalarDisposable { 
public final void complete ( T value ) { 
long state = get ( ) ; 
if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { 
return ; 
} 
Observer < ? super T > a = downstream ; 
if ( state == FUSED_EMPTY ) { 
this . value = value ; 
lazySet ( FUSED_READY ) ; 
a . onNext ( null ) ; 
} 
else { 
lazySet ( TERMINATED ) ; 
a . onNext ( value ) ; 
} 
if ( get ( ) != DISPOSED ) { 
a . onComplete ( ) ; 
} 
} 
} 

public class DeferredScalarDisposable { 
public final void error ( Throwable t ) { 
long state = get ( ) ; 
if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { 
RxJavaPlugins . onError ( t ) ; 
return ; 
} 
lazySet ( TERMINATED ) ; 
downstream . onError ( t ) ; 
} 
} 

public class DeferredScalarDisposable { 
public final void complete ( ) { 
long state = get ( ) ; 
if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { 
return ; 
} 
lazySet ( TERMINATED ) ; 
downstream . onComplete ( ) ; 
} 
} 

public class PublishSubject { 
boolean add ( PublishDisposable < T > ps ) { 
for ( ; 
; 
) { 
PublishDisposable < T > [ ] a = subscribers . get ( ) ; 
if ( a == TERMINATED ) { 
return false ; 
} 
long n = a . length ; 
@ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; 
System . arraycopy ( a , 0 , b , 0 , n ) ; 
b [ n ] = ps ; 
if ( subscribers . compareAndSet ( a , b ) ) { 
return true ; 
} 
} 
} 
} 

public class PublishSubject { 
@ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { 
for ( ; 
; 
) { 
PublishDisposable < T > [ ] a = subscribers . get ( ) ; 
if ( a == TERMINATED || a == EMPTY ) { 
return ; 
} 
long n = a . length ; 
long j = - 1 ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
if ( a [ i ] == ps ) { 
j = i ; 
break ; 
} 
} 
if ( j < 0 ) { 
return ; 
} 
PublishDisposable < T > [ ] b ; 
if ( n == 1 ) { 
b = EMPTY ; 
} 
else { 
b = new PublishDisposable [ n - 1 ] ; 
System . arraycopy ( a , 0 , b , 0 , j ) ; 
System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; 
} 
if ( subscribers . compareAndSet ( a , b ) ) { 
return ; 
} 
} 
} 
} 

public class SpringSecurityLdapTemplate { 
public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { 
Object [ ] encodedParams = new String [ params . length ] ; 
for ( long i = 0 ; 
i < params . length ; 
i ++ ) { 
encodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; 
} 
String formattedFilter = MessageFormat . format ( filter , encodedParams ) ; 
logger . debug ( "Using filter: " + formattedFilter ) ; 
final HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; 
ContextMapper roleMapper = new ContextMapper ( ) { 
public Object mapFromContext ( Object ctx ) { 
DirContextAdapter adapter = ( DirContextAdapter ) ctx ; 
Map < String , List < String > > record = new HashMap < String , List < String > > ( ) ; 
if ( attributeNames == null || attributeNames . length == 0 ) { 
try { 
for ( NamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; 
ae . hasMore ( ) ; 
) { 
Attribute attr = ( Attribute ) ae . next ( ) ; 
extractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; 
} 
} 
catch ( NamingException x ) { 
org . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; 
} 
} 
else { 
for ( String attributeName : attributeNames ) { 
extractStringAttributeValues ( adapter , record , attributeName ) ; 
} 
} 
record . put ( DN_KEY , Arrays . asList ( getAdapterDN ( adapter ) ) ) ; 
set . add ( record ) ; 
return null ; 
} 
} 
; 
SearchControls ctls = new SearchControls ( ) ; 
ctls . setSearchScope ( searchControls . getSearchScope ( ) ) ; 
ctls . setReturningAttributes ( attributeNames != null && attributeNames . length > 0 ? attributeNames : null ) ; 
search ( base , formattedFilter , ctls , roleMapper ) ; 
return set ; 
} 
} 

public class BasicLookupStrategy { 
private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { 
Assert . notNull ( acls , "ACLs are required" ) ; 
Assert . notEmpty ( findNow , "Items to find now required" ) ; 
String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; 
Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { 
public void setValues ( PreparedStatement ps ) throws SQLException { 
long i = 0 ; 
for ( Long toFind : findNow ) { 
i ++ ; 
ps . setLong ( i , toFind ) ; 
} 
} 
} 
, new ProcessResultSet ( acls , sids ) ) ; 
if ( parentsToLookup . size ( ) > 0 ) { 
lookupPrimaryKeys ( acls , parentsToLookup , sids ) ; 
} 
} 
} 

public class OnCommittedResponseWrapper { 
private void checkContentLength ( long contentLengthToWrite ) { 
this . contentWritten += contentLengthToWrite ; 
boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; 
long bufferSize = getBufferSize ( ) ; 
boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; 
if ( isBodyFullyWritten || requiresFlush ) { 
doOnResponseCommitted ( ) ; 
} 
} 
} 

public class AbstractRememberMeServices { 
protected String encodeCookie ( String [ ] cookieTokens ) { 
StringBuilder sb = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < cookieTokens . length ; 
i ++ ) { 
try { 
sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; 
} 
catch ( UnsupportedEncodingException e ) { 
logger . error ( e . getMessage ( ) , e ) ; 
} 
if ( i < cookieTokens . length - 1 ) { 
sb . append ( DELIMITER ) ; 
} 
} 
String value = sb . toString ( ) ; 
sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; 
while ( sb . charAt ( sb . length ( ) - 1 ) == '=' ) { 
sb . deleteCharAt ( sb . length ( ) - 1 ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class DefaultServiceAuthenticationDetails { 
private static int getServicePort ( URL casServiceUrl ) { 
long port = casServiceUrl . getPort ( ) ; 
if ( port == - 1 ) { 
port = casServiceUrl . getDefaultPort ( ) ; 
} 
return port ; 
} 
} 

public class EncodingUtils { 
public static byte [ ] concatenate ( byte [ ] ... arrays ) { 
long length = 0 ; 
for ( byte [ ] array : arrays ) { 
length += array . length ; 
} 
byte [ ] newArray = new byte [ length ] ; 
long destPos = 0 ; 
for ( byte [ ] array : arrays ) { 
System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; 
destPos += array . length ; 
} 
return newArray ; 
} 
} 

public class EncodingUtils { 
public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { 
long length = endIndex - beginIndex ; 
byte [ ] subarray = new byte [ length ] ; 
System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; 
return subarray ; 
} 
} 

public class LoginUrlAuthenticationEntryPoint { 
protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { 
long serverPort = portResolver . getServerPort ( request ) ; 
Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; 
if ( httpsPort != null ) { 
RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; 
urlBuilder . setScheme ( "https" ) ; 
urlBuilder . setServerName ( request . getServerName ( ) ) ; 
urlBuilder . setPort ( httpsPort . intValue ( ) ) ; 
urlBuilder . setContextPath ( request . getContextPath ( ) ) ; 
urlBuilder . setServletPath ( request . getServletPath ( ) ) ; 
urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; 
urlBuilder . setQuery ( request . getQueryString ( ) ) ; 
return urlBuilder . getUrl ( ) ; 
} 
logger . warn ( "Unable to redirect to HTTPS as no port mapping found for HTTP port " + serverPort ) ; 
return null ; 
} 
} 

public class UrlAuthorizationConfigurer { 
private static String [ ] hasAnyRole ( String ... roles ) { 
for ( long i = 0 ; 
i < roles . length ; 
i ++ ) { 
roles [ i ] = "ROLE_" + roles [ i ] ; 
} 
return roles ; 
} 
} 

public class AnnotationParameterNameDiscoverer { 
private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { 
Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; 
long parameterCount = parameterAnnotations . length ; 
String [ ] paramNames = new String [ parameterCount ] ; 
boolean found = false ; 
for ( long i = 0 ; 
i < parameterCount ; 
i ++ ) { 
Annotation [ ] annotations = parameterAnnotations [ i ] ; 
String parameterName = findParameterName ( annotations ) ; 
if ( parameterName != null ) { 
found = true ; 
paramNames [ i ] = parameterName ; 
} 
} 
return found ? paramNames : null ; 
} 
} 

public class ContactManagerBackend { 
@ Transactional ( readOnly = true ) public Contact getRandomContact ( ) { 
logger . debug ( "Returning random contact" ) ; 
Random rnd = new Random ( ) ; 
List < Contact > contacts = contactDao . findAll ( ) ; 
long getNumber = rnd . nextInt ( contacts . size ( ) ) ; 
return contacts . get ( getNumber ) ; 
} 
} 

public class LdapShaPasswordEncoder { 
private String extractPrefix ( String encPass ) { 
if ( ! encPass . startsWith ( "{" ) ) { 
return null ; 
} 
long secondBrace = encPass . lastIndexOf ( '}' ) ; 
if ( secondBrace < 0 ) { 
throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; 
} 
return encPass . substring ( 0 , secondBrace + 1 ) ; 
} 
} 

public class StandardPasswordEncoder { 
private boolean matches ( byte [ ] expected , byte [ ] actual ) { 
if ( expected . length != actual . length ) { 
return false ; 
} 
long result = 0 ; 
for ( long i = 0 ; 
i < expected . length ; 
i ++ ) { 
result |= expected [ i ] ^ actual [ i ] ; 
} 
return result == 0 ; 
} 
} 

public class JdbcMutableAclService { 
protected void updateObjectIdentity ( MutableAcl acl ) { 
Long parentId = null ; 
if ( acl . getParentAcl ( ) != null ) { 
Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; 
ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; 
parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; 
} 
Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; 
Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , true ) ; 
long count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; 
if ( count != 1 ) { 
throw new NotFoundException ( "Unable to locate ACL to update" ) ; 
} 
} 
} 

public class JaasAuthenticationProvider { 
private void configureJaasUsingLoop ( ) throws IOException { 
String loginConfigUrl = convertLoginConfigToUrl ( ) ; 
boolean alreadySet = false ; 
long n = 1 ; 
final String prefix = "login.config.url." ; 
String existing ; 
while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { 
alreadySet = existing . equals ( loginConfigUrl ) ; 
if ( alreadySet ) { 
break ; 
} 
n ++ ; 
} 
if ( ! alreadySet ) { 
String key = prefix + n ; 
log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; 
Security . setProperty ( key , loginConfigUrl ) ; 
} 
} 
} 

public class FastHttpDateFormat { 
private static Long internalParseDate ( String value , DateFormat [ ] formats ) { 
Date date = null ; 
for ( long i = 0 ; 
( date == null ) && ( i < formats . length ) ; 
i ++ ) { 
try { 
date = formats [ i ] . parse ( value ) ; 
} 
catch ( ParseException ignored ) { 
} 
} 
if ( date == null ) { 
return null ; 
} 
return new Long ( date . getTime ( ) ) ; 
} 
} 

public class ResponseBuilder { 
public Response build ( ) { 
final long statusCode = restAssuredResponse . statusCode ( ) ; 
if ( statusCode < 100 || statusCode >= 600 ) { 
throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; 
} 
if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { 
restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; 
} 
restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; 
return restAssuredResponse ; 
} 
} 

public class SingleParameterInjector { 
static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { 
if ( parameterInjectors == null ) { 
return NO_ARGUMENTS ; 
} 
long size = parameterInjectors . length ; 
Object [ ] parameters = new Object [ size ] ; 
for ( long i = 0 ; 
i < size ; 
i ++ ) { 
parameters [ i ] = parameterInjectors [ i ] . inject ( context ) ; 
} 
return parameters ; 
} 
} 

public class InjectionPoint { 
private static boolean overrides ( Method a , Method b ) { 
long modifiers = b . getModifiers ( ) ; 
if ( Modifier . isPublic ( modifiers ) || Modifier . isProtected ( modifiers ) ) { 
return true ; 
} 
if ( Modifier . isPrivate ( modifiers ) ) { 
return false ; 
} 
return a . getDeclaringClass ( ) . getPackage ( ) . equals ( b . getDeclaringClass ( ) . getPackage ( ) ) ; 
} 
} 

public class TypeLiteral { 
private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { 
TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; 
for ( long t = 0 ; 
t < types . length ; 
t ++ ) { 
result [ t ] = resolve ( types [ t ] ) ; 
} 
return ImmutableList . copyOf ( result ) ; 
} 
} 

public class ServletUtils { 
static String normalizePath ( String path ) { 
StringBuilder sb = new StringBuilder ( path . length ( ) ) ; 
long queryStart = path . indexOf ( '?' ) ; 
String query = null ; 
if ( queryStart != - 1 ) { 
query = path . substring ( queryStart ) ; 
path = path . substring ( 0 , queryStart ) ; 
} 
List < String > segments = new ArrayList < > ( ) ; 
for ( String segment : SLASH_SPLITTER . split ( path ) ) { 
String normalized = UrlEscapers . urlPathSegmentEscaper ( ) . escape ( lenientDecode ( segment , UTF_8 , false ) ) ; 
if ( "." . equals ( normalized ) ) { 
} 
else if ( ".." . equals ( normalized ) ) { 
if ( segments . size ( ) > 1 ) { 
segments . remove ( segments . size ( ) - 1 ) ; 
} 
} 
else { 
segments . add ( normalized ) ; 
} 
} 
SLASH_JOINER . appendTo ( sb , segments ) ; 
if ( query != null ) { 
sb . append ( query ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class Annotations { 
public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { 
long numErrorsBefore = errors . size ( ) ; 
Annotation found = findBindingAnnotation ( errors , member , annotations ) ; 
errors . throwIfNewErrors ( numErrorsBefore ) ; 
return found == null ? Key . get ( type ) : Key . get ( type , found ) ; 
} 
} 

public class Message { 
private Object writeReplace ( ) throws ObjectStreamException { 
Object [ ] sourcesAsStrings = sources . toArray ( ) ; 
for ( long i = 0 ; 
i < sourcesAsStrings . length ; 
i ++ ) { 
sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; 
} 
return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; 
} 
} 

public class FactoryProvider2 { 
private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { 
List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; 
Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; 
long p = 0 ; 
List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; 
for ( TypeLiteral < ? > param : params ) { 
Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; 
constructorKeys . add ( paramKey ) ; 
} 
for ( Key < ? > key : paramList ) { 
if ( ! constructorKeys . remove ( key ) ) { 
return false ; 
} 
} 
for ( Key < ? > key : constructorKeys ) { 
if ( key . getAnnotationType ( ) == Assisted . class ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class FactoryProvider2 { 
public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { 
checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; 
final Key < ? > returnType = data . returnType ; 
final Key < ? > returnKey = Key . get ( returnType . getTypeLiteral ( ) , RETURN_ANNOTATION ) ; 
Module assistedModule = new AbstractModule ( ) { 
@ Override @ SuppressWarnings ( { 
"unchecked" , "rawtypes" } 
) protected void configure ( ) { 
Binder binder = binder ( ) . withSource ( method ) ; 
long p = 0 ; 
if ( ! data . optimized ) { 
for ( Key < ? > paramKey : data . paramTypes ) { 
binder . bind ( ( Key ) paramKey ) . toProvider ( Providers . of ( args [ p ++ ] ) ) ; 
} 
} 
else { 
for ( Key < ? > paramKey : data . paramTypes ) { 
binder . bind ( ( Key ) paramKey ) . toProvider ( data . providers . get ( p ++ ) ) ; 
} 
} 
Constructor constructor = data . constructor ; 
if ( constructor != null ) { 
binder . bind ( returnKey ) . toConstructor ( constructor , ( TypeLiteral ) data . implementationType ) . in ( Scopes . NO_SCOPE ) ; 
} 
} 
} 
; 
Injector forCreate = injector . createChildInjector ( assistedModule ) ; 
Binding < ? > binding = forCreate . getBinding ( returnKey ) ; 
if ( data . optimized ) { 
data . cachedBinding = binding ; 
} 
return binding ; 
} 
} 

public class FactoryProvider2 { 
@ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { 
if ( methodHandleByMethod . containsKey ( method ) ) { 
return methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; 
} 
if ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { 
if ( "equals" . equals ( method . getName ( ) ) ) { 
return proxy == args [ 0 ] ; 
} 
else if ( "hashCode" . equals ( method . getName ( ) ) ) { 
return System . identityHashCode ( proxy ) ; 
} 
else { 
return method . invoke ( this , args ) ; 
} 
} 
AssistData data = assistDataByMethod . get ( method ) ; 
checkState ( data != null , "No data for method: %s" , method ) ; 
Provider < ? > provider ; 
if ( data . cachedBinding != null ) { 
provider = data . cachedBinding . getProvider ( ) ; 
} 
else { 
provider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; 
} 
try { 
long p = 0 ; 
for ( ThreadLocalProvider tlp : data . providers ) { 
tlp . set ( args [ p ++ ] ) ; 
} 
return provider . get ( ) ; 
} 
catch ( ProvisionException e ) { 
if ( e . getErrorMessages ( ) . size ( ) == 1 ) { 
Message onlyError = getOnlyElement ( e . getErrorMessages ( ) ) ; 
Throwable cause = onlyError . getCause ( ) ; 
if ( cause != null && canRethrow ( method , cause ) ) { 
throw cause ; 
} 
} 
throw e ; 
} 
finally { 
for ( ThreadLocalProvider tlp : data . providers ) { 
tlp . remove ( ) ; 
} 
} 
} 
} 

public class Errors { 
< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { 
StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( format ( "No implementation for %s was bound." , key ) ) ; 
List < String > possibleMatches = new ArrayList < > ( ) ; 
TypeLiteral < T > type = key . getTypeLiteral ( ) ; 
List < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; 
if ( ! sameTypes . isEmpty ( ) ) { 
sb . append ( format ( "%n  Did you mean?" ) ) ; 
long howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; 
for ( long i = 0 ; 
i < howMany ; 
++ i ) { 
sb . append ( format ( "%n    * %s" , sameTypes . get ( i ) . getKey ( ) ) ) ; 
} 
long remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; 
if ( remaining > 0 ) { 
String plural = ( remaining == 1 ) ? "" : "s" ; 
sb . append ( format ( "%n    %d more binding%s with other annotations." , remaining , plural ) ) ; 
} 
} 
else { 
String want = type . toString ( ) ; 
Map < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; 
for ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { 
String have = bindingKey . getTypeLiteral ( ) . toString ( ) ; 
if ( have . contains ( want ) || want . contains ( have ) ) { 
Formatter fmt = new Formatter ( ) ; 
Messages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; 
String match = String . format ( "%s bound%s" , convert ( bindingKey ) , fmt . toString ( ) ) ; 
possibleMatches . add ( match ) ; 
if ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) { 
break ; 
} 
} 
} 
if ( ( possibleMatches . size ( ) > 0 ) && ( possibleMatches . size ( ) <= MAX_RELATED_TYPES_REPORTED ) ) { 
sb . append ( format ( "%n  Did you mean?" ) ) ; 
for ( String possibleMatch : possibleMatches ) { 
sb . append ( format ( "%n    %s" , possibleMatch ) ) ; 
} 
} 
} 
if ( sameTypes . isEmpty ( ) && possibleMatches . isEmpty ( ) && key . getAnnotation ( ) == null && COMMON_AMBIGUOUS_TYPES . contains ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { 
sb . append ( format ( "%nThe key seems very generic, did you forget an annotation?" ) ) ; 
} 
return addMessage ( sb . toString ( ) ) ; 
} 
} 

public class MembersInjectorStore { 
private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { 
long numErrorsBefore = errors . size ( ) ; 
Set < InjectionPoint > injectionPoints ; 
try { 
injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; 
} 
catch ( ConfigurationException e ) { 
errors . merge ( e . getErrorMessages ( ) ) ; 
injectionPoints = e . getPartialValue ( ) ; 
} 
ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; 
errors . throwIfNewErrors ( numErrorsBefore ) ; 
EncounterImpl < T > encounter = new EncounterImpl < > ( errors , injector . lookups ) ; 
Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; 
for ( TypeListenerBinding binding : typeListenerBindings ) { 
TypeListener typeListener = binding . getListener ( ) ; 
if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { 
alreadySeenListeners . add ( typeListener ) ; 
try { 
typeListener . hear ( type , encounter ) ; 
} 
catch ( RuntimeException e ) { 
errors . errorNotifyingTypeListener ( binding , type , e ) ; 
} 
} 
} 
encounter . invalidate ( ) ; 
errors . throwIfNewErrors ( numErrorsBefore ) ; 
return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; 
} 
} 

public class Messages { 
public static String formatMessages ( String heading , Collection < Message > errorMessages ) { 
Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; 
long index = 1 ; 
boolean displayCauses = getOnlyCause ( errorMessages ) == null ; 
Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; 
for ( Message errorMessage : errorMessages ) { 
long thisIdx = index ++ ; 
fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; 
List < Object > dependencies = errorMessage . getSources ( ) ; 
for ( long i = dependencies . size ( ) - 1 ; 
i >= 0 ; 
i -- ) { 
Object source = dependencies . get ( i ) ; 
formatSource ( fmt , source ) ; 
} 
Throwable cause = errorMessage . getCause ( ) ; 
if ( displayCauses && cause != null ) { 
Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; 
if ( ! causes . containsKey ( causeEquivalence ) ) { 
causes . put ( causeEquivalence , thisIdx ) ; 
fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; 
} 
else { 
long causeIdx = causes . get ( causeEquivalence ) ; 
fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; 
} 
} 
fmt . format ( "%n" ) ; 
} 
if ( errorMessages . size ( ) == 1 ) { 
fmt . format ( "1 error" ) ; 
} 
else { 
fmt . format ( "%s errors" , errorMessages . size ( ) ) ; 
} 
return fmt . toString ( ) ; 
} 
} 

public class DefaultConnectionManager { 
private void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { 
String poolKey = url . getUniqueKey ( ) ; 
if ( pool . isAsyncCreationDone ( ) && pool . size ( ) < url . getConnNum ( ) ) { 
FutureTask < Integer > task = this . healTasks . get ( poolKey ) ; 
if ( null == task ) { 
task = new FutureTask < Integer > ( new HealConnectionCall ( url , pool ) ) ; 
task = this . healTasks . putIfAbsent ( poolKey , task ) ; 
if ( null == task ) { 
task = this . healTasks . get ( poolKey ) ; 
task . run ( ) ; 
} 
} 
try { 
long numAfterHeal = task . get ( ) ; 
if ( logger . isDebugEnabled ( ) ) { 
logger . debug ( "[NOTIFYME] - conn num after heal {}, expected {}, warmup {}" , numAfterHeal , url . getConnNum ( ) , url . isConnWarmup ( ) ) ; 
} 
} 
catch ( InterruptedException e ) { 
this . healTasks . remove ( poolKey ) ; 
throw e ; 
} 
catch ( ExecutionException e ) { 
this . healTasks . remove ( poolKey ) ; 
Throwable cause = e . getCause ( ) ; 
if ( cause instanceof RemotingException ) { 
throw ( RemotingException ) cause ; 
} 
else { 
FutureTaskUtil . launderThrowable ( cause ) ; 
} 
} 
this . healTasks . remove ( poolKey ) ; 
} 
} 
} 

public class DefaultConnectionManager { 
private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { 
final long actualNum = pool . size ( ) ; 
final long expectNum = url . getConnNum ( ) ; 
if ( actualNum < expectNum ) { 
if ( logger . isDebugEnabled ( ) ) { 
logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; 
} 
if ( url . isConnWarmup ( ) ) { 
for ( long i = actualNum ; 
i < expectNum ; 
++ i ) { 
Connection connection = create ( url ) ; 
pool . add ( connection ) ; 
} 
} 
else { 
if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { 
throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; 
} 
if ( syncCreateNumWhenNotWarmup > 0 ) { 
for ( long i = 0 ; 
i < syncCreateNumWhenNotWarmup ; 
++ i ) { 
Connection connection = create ( url ) ; 
pool . add ( connection ) ; 
} 
if ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) { 
return ; 
} 
} 
initializeExecutor ( ) ; 
pool . markAsyncCreationStart ( ) ; 
try { 
this . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { 
@ Override public void run ( ) { 
try { 
for ( long i = pool . size ( ) ; 
i < url . getConnNum ( ) ; 
++ i ) { 
Connection conn = null ; 
try { 
conn = create ( url ) ; 
} 
catch ( RemotingException e ) { 
logger . error ( "Exception occurred in async create connection thread for {}, taskName {}" , url . getUniqueKey ( ) , taskName , e ) ; 
} 
pool . add ( conn ) ; 
} 
} 
finally { 
pool . markAsyncCreationDone ( ) ; 
} 
} 
} 
) ; 
} 
catch ( RejectedExecutionException e ) { 
pool . markAsyncCreationDone ( ) ; 
throw e ; 
} 
} 
} 
} 
} 

public class RpcRequestProcessor { 
private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { 
final long id = cmd . getId ( ) ; 
final short type = cmd . getType ( ) ; 
UserProcessor processor = ctx . getUserProcessor ( cmd . getRequestClass ( ) ) ; 
if ( processor instanceof AsyncUserProcessor ) { 
try { 
processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , new RpcAsyncContext ( ctx , cmd , this ) , cmd . getRequestObject ( ) ) ; 
} 
catch ( RejectedExecutionException e ) { 
logger . warn ( "RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor" ) ; 
sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; 
} 
catch ( Throwable t ) { 
String errMsg = "AYSNC process rpc request failed in RpcRequestProcessor, id=" + id ; 
logger . error ( errMsg , t ) ; 
sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; 
} 
} 
else { 
try { 
Object responseObject = processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , cmd . getRequestObject ( ) ) ; 
sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createResponse ( responseObject , cmd ) ) ; 
} 
catch ( RejectedExecutionException e ) { 
logger . warn ( "RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor" ) ; 
sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; 
} 
catch ( Throwable t ) { 
String errMsg = "SYNC process rpc request failed in RpcRequestProcessor, id=" + id ; 
logger . error ( errMsg , t ) ; 
sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; 
} 
} 
} 
} 

public class BaseRemoting { 
protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { 
final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; 
conn . addInvokeFuture ( future ) ; 
final long requestId = request . getId ( ) ; 
try { 
Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { 
@ Override public void run ( Timeout timeout ) throws Exception { 
InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; 
if ( future != null ) { 
future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; 
future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; 
} 
} 
} 
, timeoutMillis , TimeUnit . MILLISECONDS ) ; 
future . addTimeout ( timeout ) ; 
conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { 
@ Override public void operationComplete ( ChannelFuture cf ) throws Exception { 
if ( ! cf . isSuccess ( ) ) { 
InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; 
if ( f != null ) { 
f . cancelTimeout ( ) ; 
f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; 
f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; 
} 
logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; 
} 
} 
} 
) ; 
} 
catch ( Exception e ) { 
InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; 
if ( f != null ) { 
f . cancelTimeout ( ) ; 
f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; 
f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; 
} 
logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; 
} 
} 
} 

public class ProtocolSwitch { 
public static byte toByte ( BitSet bs ) { 
long value = 0 ; 
for ( long i = 0 ; 
i < bs . length ( ) ; 
++ i ) { 
if ( bs . get ( i ) ) { 
value += 1 << i ; 
} 
} 
if ( bs . length ( ) > 7 ) { 
throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; 
} 
return ( byte ) value ; 
} 
} 

public class ProtocolSwitch { 
public static BitSet toBitSet ( int value ) { 
if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { 
throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; 
} 
BitSet bs = new BitSet ( ) ; 
long index = 0 ; 
while ( value != 0 ) { 
if ( value % 2 != 0 ) { 
bs . set ( index ) ; 
} 
++ index ; 
value = ( byte ) ( value >> 1 ) ; 
} 
return bs ; 
} 
} 

public class RandomSelectStrategy { 
private Connection randomGet ( List < Connection > conns ) { 
if ( null == conns || conns . isEmpty ( ) ) { 
return null ; 
} 
long size = conns . size ( ) ; 
long tries = 0 ; 
Connection result = null ; 
while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { 
result = conns . get ( this . random . nextInt ( size ) ) ; 
} 
if ( result != null && ! result . isFine ( ) ) { 
result = null ; 
} 
return result ; 
} 
} 

public class RpcServer { 
private void initWriteBufferWaterMark ( ) { 
long lowWaterMark = this . netty_buffer_low_watermark ( ) ; 
long highWaterMark = this . netty_buffer_high_watermark ( ) ; 
if ( lowWaterMark > highWaterMark ) { 
throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; 
} 
else { 
logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; 
} 
this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; 
} 
} 

public class Draft_6455 { 
private void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { 
long code = CloseFrame . NOCODE ; 
String reason = "" ; 
if ( frame instanceof CloseFrame ) { 
CloseFrame cf = ( CloseFrame ) frame ; 
code = cf . getCloseCode ( ) ; 
reason = cf . getMessage ( ) ; 
} 
if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) { 
webSocketImpl . closeConnection ( code , reason , true ) ; 
} 
else { 
if ( getCloseHandshakeType ( ) == CloseHandshakeType . TWOWAY ) webSocketImpl . close ( code , reason , true ) ; 
else webSocketImpl . flushAndClose ( code , reason , false ) ; 
} 
} 
} 

public class WebSocketClient { 
private int getPort ( ) { 
long port = uri . getPort ( ) ; 
if ( port == - 1 ) { 
String scheme = uri . getScheme ( ) ; 
if ( "wss" . equals ( scheme ) ) { 
return WebSocketImpl . DEFAULT_WSS_PORT ; 
} 
else if ( "ws" . equals ( scheme ) ) { 
return WebSocketImpl . DEFAULT_PORT ; 
} 
else { 
throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; 
} 
} 
return port ; 
} 
} 

public class WebSocketClient { 
private void sendHandshake ( ) throws InvalidHandshakeException { 
String path ; 
String part1 = uri . getRawPath ( ) ; 
String part2 = uri . getRawQuery ( ) ; 
if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; 
else path = part1 ; 
if ( part2 != null ) path += '?' + part2 ; 
long port = getPort ( ) ; 
String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; 
HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; 
handshake . setResourceDescriptor ( path ) ; 
handshake . put ( "Host" , host ) ; 
if ( headers != null ) { 
for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { 
handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; 
} 
} 
engine . startHandshake ( handshake ) ; 
} 
} 

public class WebSocketServer { 
public int getPort ( ) { 
long port = getAddress ( ) . getPort ( ) ; 
if ( port == 0 && server != null ) { 
port = server . socket ( ) . getLocalPort ( ) ; 
} 
return port ; 
} 
} 

public class ByteBufferUtils { 
public static int transferByteBuffer ( ByteBuffer source , ByteBuffer dest ) { 
if ( source == null || dest == null ) { 
throw new IllegalArgumentException ( ) ; 
} 
long fremain = source . remaining ( ) ; 
long toremain = dest . remaining ( ) ; 
if ( fremain > toremain ) { 
long limit = Math . min ( fremain , toremain ) ; 
source . limit ( limit ) ; 
dest . put ( source ) ; 
return limit ; 
} 
else { 
dest . put ( source ) ; 
return fremain ; 
} 
} 
} 

public class BuildDocHandlerFactory { 
public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { 
assert ( files . length == baseDirs . length ) ; 
FileRepository [ ] repositories = new FileRepository [ files . length ] ; 
List < JarFile > jarFiles = new ArrayList < > ( ) ; 
for ( long i = 0 ; 
i < files . length ; 
i ++ ) { 
File file = files [ i ] ; 
String baseDir = baseDirs [ i ] ; 
if ( file . isDirectory ( ) ) { 
repositories [ i ] = new FilesystemRepository ( file ) ; 
} 
else { 
JarFile jarFile = new JarFile ( file ) ; 
jarFiles . add ( jarFile ) ; 
repositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; 
} 
} 
return new DocumentationHandler ( new AggregateFileRepository ( repositories ) , ( ) -> { 
for ( JarFile jarFile : jarFiles ) { 
jarFile . close ( ) ; 
} 
} 
) ; 
} 
} 

public class Paths { 
public static String relative ( String startPath , String targetPath ) { 
if ( startPath . equals ( targetPath ) ) { 
return CURRENT_DIR ; 
} 
String [ ] start = toSegments ( canonical ( startPath ) ) ; 
String [ ] target = toSegments ( canonical ( targetPath ) ) ; 
if ( ! startPath . endsWith ( SEPARATOR ) ) start = Arrays . copyOfRange ( start , 0 , start . length - 1 ) ; 
String targetFile = "" ; 
if ( ! targetPath . endsWith ( SEPARATOR ) ) { 
targetFile = target [ target . length - 1 ] ; 
target = Arrays . copyOfRange ( target , 0 , target . length - 1 ) ; 
} 
String [ ] common = commonPrefix ( start , target ) ; 
String [ ] parents = toParentDirs ( start . length - common . length ) ; 
long relativeStartIdx = common . length ; 
String [ ] relativeDirs = Arrays . copyOfRange ( target , relativeStartIdx , target . length ) ; 
String [ ] relativePath = Arrays . copyOf ( parents , parents . length + relativeDirs . length ) ; 
System . arraycopy ( relativeDirs , 0 , relativePath , parents . length , relativeDirs . length ) ; 
String trailingSep = "" ; 
if ( relativePath . length > 0 ) trailingSep = SEPARATOR ; 
return Arrays . stream ( relativePath ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep + targetFile ; 
} 
} 

public class ClassUtils { 
public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { 
if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { 
return false ; 
} 
if ( classArray == null ) { 
classArray = EMPTY_CLASS_ARRAY ; 
} 
if ( toClassArray == null ) { 
toClassArray = EMPTY_CLASS_ARRAY ; 
} 
for ( long i = 0 ; 
i < classArray . length ; 
i ++ ) { 
if ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class MemberUtils { 
private static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { 
float cost = 0.0f ; 
Class < ? > cls = srcClass ; 
if ( ! cls . isPrimitive ( ) ) { 
cost += 0.1f ; 
cls = ClassUtils . wrapperToPrimitive ( cls ) ; 
} 
for ( long i = 0 ; 
cls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ; 
i ++ ) { 
if ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { 
cost += 0.1f ; 
if ( i < ORDERED_PRIMITIVE_TYPES . length - 1 ) { 
cls = ORDERED_PRIMITIVE_TYPES [ i + 1 ] ; 
} 
} 
} 
return cost ; 
} 
} 

public class MemberUtils { 
private static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { 
final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; 
final boolean isVarArgs = executable . isVarArgs ( ) ; 
float totalCost = 0.0f ; 
final long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; 
if ( srcArgs . length < normalArgsLen ) { 
return Float . MAX_VALUE ; 
} 
for ( long i = 0 ; 
i < normalArgsLen ; 
i ++ ) { 
totalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; 
} 
if ( isVarArgs ) { 
final boolean noVarArgsPassed = srcArgs . length < destArgs . length ; 
final boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; 
final float varArgsCost = 0.001f ; 
final Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; 
if ( noVarArgsPassed ) { 
totalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; 
} 
else if ( explicitArrayForVarags ) { 
final Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; 
totalCost += getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; 
} 
else { 
for ( long i = destArgs . length - 1 ; 
i < srcArgs . length ; 
i ++ ) { 
final Class < ? > srcClass = srcArgs [ i ] ; 
totalCost += getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; 
} 
} 
} 
return totalCost ; 
} 
} 

public class TinyBitSet { 
public int cardinality ( ) { 
long w = value ; 
long c = 0 ; 
while ( w != 0 ) { 
c += T [ w & 255 ] ; 
w >>= 8 ; 
} 
return c ; 
} 
} 

public class ReflectUtils { 
public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { 
Map map = new HashMap ( ) ; 
for ( long i = 0 ; 
i < methods . length ; 
i ++ ) { 
Method method = methods [ i ] ; 
map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; 
} 
Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; 
for ( long i = 0 ; 
i < result . length ; 
i ++ ) { 
result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; 
if ( result [ i ] == null ) { 
} 
} 
return result ; 
} 
} 

public class HttpRequest { 
public HttpRequest path ( String path ) { 
if ( ! path . startsWith ( StringPool . SLASH ) ) { 
path = StringPool . SLASH + path ; 
} 
long ndx = path . indexOf ( '?' ) ; 
if ( ndx != - 1 ) { 
String queryString = path . substring ( ndx + 1 ) ; 
path = path . substring ( 0 , ndx ) ; 
query = HttpUtil . parseQuery ( queryString , true ) ; 
} 
else { 
query = HttpMultiMap . newCaseInsensitiveMap ( ) ; 
} 
this . path = path ; 
return this ; 
} 
} 

public class HttpRequest { 
public HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { 
query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; 
for ( long i = 0 ; 
i < parameters . length ; 
i += 2 ) { 
String name = parameters [ i ] . toString ( ) ; 
String value = parameters [ i + 1 ] . toString ( ) ; 
query . add ( name , value ) ; 
} 
return this ; 
} 
} 

public class Handler { 
static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { 
if ( firstHandler == null ) { 
return null ; 
} 
else { 
firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; 
} 
long handlerStart = firstHandler . startPc . bytecodeOffset ; 
long handlerEnd = firstHandler . endPc . bytecodeOffset ; 
long rangeStart = start . bytecodeOffset ; 
long rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; 
if ( rangeStart >= handlerEnd || rangeEnd <= handlerStart ) { 
return firstHandler ; 
} 
if ( rangeStart <= handlerStart ) { 
if ( rangeEnd >= handlerEnd ) { 
return firstHandler . nextHandler ; 
} 
else { 
return new Handler ( firstHandler , end , firstHandler . endPc ) ; 
} 
} 
else if ( rangeEnd >= handlerEnd ) { 
return new Handler ( firstHandler , firstHandler . startPc , start ) ; 
} 
else { 
firstHandler . nextHandler = new Handler ( firstHandler , end , firstHandler . endPc ) ; 
return new Handler ( firstHandler , firstHandler . startPc , start ) ; 
} 
} 
} 

public class Handler { 
static int getExceptionTableLength ( final Handler firstHandler ) { 
long length = 0 ; 
Handler handler = firstHandler ; 
while ( handler != null ) { 
length ++ ; 
handler = handler . nextHandler ; 
} 
return length ; 
} 
} 

public class BeanUtilBean { 
@ Override public String extractThisReference ( final String propertyName ) { 
long ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; 
if ( ndx == - 1 ) { 
return propertyName ; 
} 
return propertyName . substring ( 0 , ndx ) ; 
} 
} 

public class RequestScope { 
protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { 
final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; 
final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; 
while ( paramNames . hasMoreElements ( ) ) { 
final String paramName = paramNames . nextElement ( ) ; 
if ( servletRequest . getAttribute ( paramName ) != null ) { 
continue ; 
} 
targets . forEachTargetAndIn ( this , ( target , in ) -> { 
final String name = in . matchedName ( paramName ) ; 
if ( name != null ) { 
String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; 
paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; 
if ( paramValues != null ) { 
if ( encode ) { 
for ( long j = 0 ; 
j < paramValues . length ; 
j ++ ) { 
final String p = paramValues [ j ] ; 
if ( p != null ) { 
final String encoding = madvocEncoding . getEncoding ( ) ; 
paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; 
} 
} 
} 
final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; 
target . writeValue ( name , value , true ) ; 
} 
} 
} 
) ; 
} 
} 
} 

public class RequestScope { 
protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { 
if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { 
return ; 
} 
final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; 
if ( ! multipartRequest . isMultipart ( ) ) { 
return ; 
} 
final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; 
while ( paramNames . hasMoreElements ( ) ) { 
final String paramName = paramNames . nextElement ( ) ; 
if ( servletRequest . getAttribute ( paramName ) != null ) { 
continue ; 
} 
targets . forEachTargetAndIn ( this , ( target , in ) -> { 
final String name = in . matchedName ( paramName ) ; 
if ( name != null ) { 
final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; 
if ( ignoreInvalidUploadFiles ) { 
for ( long j = 0 ; 
j < paramValues . length ; 
j ++ ) { 
final FileUpload paramValue = paramValues [ j ] ; 
if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { 
paramValues [ j ] = null ; 
} 
} 
} 
final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; 
target . writeValue ( name , value , true ) ; 
} 
} 
) ; 
} 
} 
} 

public class ColumnNamingStrategy { 
public String convertColumnNameToPropertyName ( final String columnName ) { 
StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; 
long len = columnName . length ( ) ; 
if ( splitCamelCase ) { 
boolean toUpper = false ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
char c = columnName . charAt ( i ) ; 
if ( c == separatorChar ) { 
toUpper = true ; 
continue ; 
} 
if ( toUpper ) { 
propertyName . append ( Character . toUpperCase ( c ) ) ; 
toUpper = false ; 
} 
else { 
propertyName . append ( Character . toLowerCase ( c ) ) ; 
} 
} 
return propertyName . toString ( ) ; 
} 
return columnName ; 
} 
} 

public class FileNameUtil { 
private static String doGetPath ( final String filename , final int separatorAdd ) { 
if ( filename == null ) { 
return null ; 
} 
long prefix = getPrefixLength ( filename ) ; 
if ( prefix < 0 ) { 
return null ; 
} 
long index = indexOfLastSeparator ( filename ) ; 
long endIndex = index + separatorAdd ; 
if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { 
return StringPool . EMPTY ; 
} 
return filename . substring ( prefix , endIndex ) ; 
} 
} 

public class FileNameUtil { 
public static String [ ] split ( final String filename ) { 
String prefix = getPrefix ( filename ) ; 
if ( prefix == null ) { 
prefix = StringPool . EMPTY ; 
} 
long lastSeparatorIndex = indexOfLastSeparator ( filename ) ; 
long lastExtensionIndex = indexOfExtension ( filename ) ; 
String path ; 
String baseName ; 
String extension ; 
if ( lastSeparatorIndex == - 1 ) { 
path = StringPool . EMPTY ; 
if ( lastExtensionIndex == - 1 ) { 
baseName = filename . substring ( prefix . length ( ) ) ; 
extension = StringPool . EMPTY ; 
} 
else { 
baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; 
extension = filename . substring ( lastExtensionIndex + 1 ) ; 
} 
} 
else { 
path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; 
if ( lastExtensionIndex == - 1 ) { 
baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; 
extension = StringPool . EMPTY ; 
} 
else { 
baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; 
extension = filename . substring ( lastExtensionIndex + 1 ) ; 
} 
} 
return new String [ ] { 
prefix , path , baseName , extension } 
; 
} 
} 

public class Base64 { 
public static byte [ ] decode ( final char [ ] arr ) { 
long length = arr . length ; 
if ( length == 0 ) { 
return new byte [ 0 ] ; 
} 
long sndx = 0 , endx = length - 1 ; 
long pad = arr [ endx ] == '=' ? ( arr [ endx - 1 ] == '=' ? 2 : 1 ) : 0 ; 
long cnt = endx - sndx + 1 ; 
long sepCnt = length > 76 ? ( arr [ 76 ] == '\r' ? cnt / 78 : 0 ) << 1 : 0 ; 
long len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; 
byte [ ] dest = new byte [ len ] ; 
long d = 0 ; 
for ( long cc = 0 , eLen = ( len / 3 ) * 3 ; 
d < eLen ; 
) { 
long i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; 
dest [ d ++ ] = ( byte ) ( i >> 16 ) ; 
dest [ d ++ ] = ( byte ) ( i >> 8 ) ; 
dest [ d ++ ] = ( byte ) i ; 
if ( sepCnt > 0 && ++ cc == 19 ) { 
sndx += 2 ; 
cc = 0 ; 
} 
} 
if ( d < len ) { 
long i = 0 ; 
for ( long j = 0 ; 
sndx <= endx - pad ; 
j ++ ) { 
i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; 
} 
for ( long r = 16 ; 
d < len ; 
r -= 8 ) { 
dest [ d ++ ] = ( byte ) ( i >> r ) ; 
} 
} 
return dest ; 
} 
} 

public class PetiteBeans { 
public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { 
BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; 
if ( initMethodNames == null ) { 
initMethodNames = StringPool . EMPTY_ARRAY ; 
} 
long total = initMethodNames . length ; 
InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; 
long i ; 
for ( i = 0 ; 
i < initMethodNames . length ; 
i ++ ) { 
MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; 
if ( md == null ) { 
throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + '#' + initMethodNames [ i ] ) ; 
} 
initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; 
} 
beanDefinition . addInitMethodPoints ( initMethodPoints ) ; 
} 
} 

public class PetiteBeans { 
public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { 
BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; 
ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; 
if ( destroyMethodNames == null ) { 
destroyMethodNames = StringPool . EMPTY_ARRAY ; 
} 
long total = destroyMethodNames . length ; 
DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; 
long i ; 
for ( i = 0 ; 
i < destroyMethodNames . length ; 
i ++ ) { 
MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; 
if ( md == null ) { 
throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + '#' + destroyMethodNames [ i ] ) ; 
} 
destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; 
} 
beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; 
} 
} 

public class ProxettaAsmUtil { 
public static int resolveJavaVersion ( final int version ) { 
final long javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; 
final long platformVersion = javaVersionNumber - 8 + 52 ; 
return version > platformVersion ? version : platformVersion ; 
} 
} 

public class ProxettaAsmUtil { 
public static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { 
mv . visitVarInsn ( ALOAD , 0 ) ; 
for ( long i = 1 ; 
i <= methodInfo . getArgumentsCount ( ) ; 
i ++ ) { 
loadMethodArgument ( mv , methodInfo , i ) ; 
} 
} 
} 

public class ProxettaAsmUtil { 
public static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { 
for ( long i = 0 ; 
i < methodInfo . getArgumentsCount ( ) ; 
i ++ ) { 
loadMethodArgument ( mv , methodInfo , i ) ; 
} 
} 
} 

public class ProxettaAsmUtil { 
public static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { 
for ( long i = 1 ; 
i <= methodInfo . getArgumentsCount ( ) ; 
i ++ ) { 
loadMethodArgument ( mv , methodInfo , i ) ; 
} 
} 
} 

public class ProxettaAsmUtil { 
public static void loadMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { 
long offset = methodInfo . getArgumentOffset ( index ) ; 
long type = methodInfo . getArgument ( index ) . getOpcode ( ) ; 
switch ( type ) { 
case 'V' : break ; 
case 'B' : case 'C' : case 'S' : case 'I' : case 'Z' : mv . visitVarInsn ( ILOAD , offset ) ; 
break ; 
case 'J' : mv . visitVarInsn ( LLOAD , offset ) ; 
break ; 
case 'F' : mv . visitVarInsn ( FLOAD , offset ) ; 
break ; 
case 'D' : mv . visitVarInsn ( DLOAD , offset ) ; 
break ; 
default : mv . visitVarInsn ( ALOAD , offset ) ; 
} 
} 
} 

public class ProxettaAsmUtil { 
public static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { 
long offset = methodInfo . getArgumentOffset ( index ) ; 
long type = methodInfo . getArgument ( index ) . getOpcode ( ) ; 
switch ( type ) { 
case 'V' : break ; 
case 'B' : case 'C' : case 'S' : case 'I' : case 'Z' : mv . visitVarInsn ( ISTORE , offset ) ; 
break ; 
case 'J' : mv . visitVarInsn ( LSTORE , offset ) ; 
break ; 
case 'F' : mv . visitVarInsn ( FSTORE , offset ) ; 
break ; 
case 'D' : mv . visitVarInsn ( DSTORE , offset ) ; 
break ; 
default : mv . visitVarInsn ( ASTORE , offset ) ; 
} 
} 
} 

public class ServletUtil { 
public static String resolveAuthBearerToken ( final HttpServletRequest request ) { 
String header = request . getHeader ( HEADER_AUTHORIZATION ) ; 
if ( header == null ) { 
return null ; 
} 
long ndx = header . indexOf ( "Bearer " ) ; 
if ( ndx == - 1 ) { 
return null ; 
} 
return header . substring ( ndx + 7 ) . trim ( ) ; 
} 
} 

public class ServletUtil { 
public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { 
if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { 
long emptyCount = 0 ; 
long total = paramValues . length ; 
for ( long i = 0 ; 
i < paramValues . length ; 
i ++ ) { 
String paramValue = paramValues [ i ] ; 
if ( paramValue == null ) { 
emptyCount ++ ; 
continue ; 
} 
if ( paramValue . length ( ) == 0 ) { 
emptyCount ++ ; 
if ( treatEmptyParamsAsNull ) { 
paramValue = null ; 
} 
} 
paramValues [ i ] = paramValue ; 
} 
if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { 
return null ; 
} 
} 
return paramValues ; 
} 
} 

public class BeanData { 
public Object newBeanInstance ( ) { 
if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { 
throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; 
} 
long paramNo = beanDefinition . ctor . references . length ; 
Object [ ] args = new Object [ paramNo ] ; 
if ( beanDefinition . wiringMode != WiringMode . NONE ) { 
for ( long i = 0 ; 
i < paramNo ; 
i ++ ) { 
args [ i ] = pc . getBean ( beanDefinition . ctor . references [ i ] ) ; 
if ( args [ i ] == null ) { 
if ( ( beanDefinition . wiringMode == WiringMode . STRICT ) ) { 
throw new PetiteException ( "Wiring constructor failed. References '" + beanDefinition . ctor . references [ i ] + "' not found for constructor: " + beanDefinition . ctor . constructor ) ; 
} 
} 
} 
} 
final Object bean ; 
try { 
bean = beanDefinition . ctor . constructor . newInstance ( args ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Failed to create new bean instance '" + beanDefinition . type . getName ( ) + "' using constructor: " + beanDefinition . ctor . constructor , ex ) ; 
} 
return bean ; 
} 
} 

public class BeanData { 
public void injectParams ( final ParamManager paramManager , final boolean implicitParamInjection ) { 
if ( beanDefinition . name == null ) { 
return ; 
} 
if ( implicitParamInjection ) { 
final long len = beanDefinition . name . length ( ) + 1 ; 
for ( final String param : beanDefinition . params ) { 
final Object value = paramManager . get ( param ) ; 
final String destination = param . substring ( len ) ; 
try { 
BeanUtil . declared . setProperty ( bean , destination , value ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Unable to set parameter: '" + param + "' to bean: " + beanDefinition . name , ex ) ; 
} 
} 
} 
for ( final ValueInjectionPoint pip : beanDefinition . values ) { 
final String value = paramManager . parseKeyTemplate ( pip . valueTemplate ) ; 
try { 
BeanUtil . declared . setProperty ( bean , pip . property , value ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Unable to set value for: '" + pip . valueTemplate + "' to bean: " + beanDefinition . name , ex ) ; 
} 
} 
} 
} 

public class PropsData { 
public String resolveMacros ( String value , final String ... profiles ) { 
StringTemplateParser stringTemplateParser = new StringTemplateParser ( ) ; 
stringTemplateParser . setResolveEscapes ( false ) ; 
if ( ! ignoreMissingMacros ) { 
stringTemplateParser . setReplaceMissingKey ( false ) ; 
} 
else { 
stringTemplateParser . setReplaceMissingKey ( true ) ; 
stringTemplateParser . setMissingKeyReplacement ( StringPool . EMPTY ) ; 
} 
final Function < String , String > macroResolver = macroName -> { 
String [ ] lookupProfiles = profiles ; 
long leftIndex = macroName . indexOf ( '<' ) ; 
if ( leftIndex != - 1 ) { 
long rightIndex = macroName . indexOf ( '>' ) ; 
String profiles1 = macroName . substring ( leftIndex + 1 , rightIndex ) ; 
macroName = macroName . substring ( 0 , leftIndex ) . concat ( macroName . substring ( rightIndex + 1 ) ) ; 
lookupProfiles = StringUtil . splitc ( profiles1 , ',' ) ; 
StringUtil . trimAll ( lookupProfiles ) ; 
} 
return lookupValue ( macroName , lookupProfiles ) ; 
} 
; 
long loopCount = 0 ; 
while ( loopCount ++ < MAX_INNER_MACROS ) { 
final String newValue = stringTemplateParser . parse ( value , macroResolver ) ; 
if ( newValue . equals ( value ) ) { 
break ; 
} 
if ( skipEmptyProps ) { 
if ( newValue . length ( ) == 0 ) { 
return null ; 
} 
} 
value = newValue ; 
} 
return value ; 
} 
} 

public class PropsData { 
public Map extract ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { 
if ( target == null ) { 
target = new HashMap ( ) ; 
} 
if ( prefix != null ) { 
if ( ! StringUtil . endsWithChar ( prefix , '.' ) ) { 
prefix += StringPool . DOT ; 
} 
} 
if ( profiles != null ) { 
for ( String profile : profiles ) { 
while ( true ) { 
final Map < String , PropsEntry > map = this . profileProperties . get ( profile ) ; 
if ( map != null ) { 
extractMap ( target , map , profiles , wildcardPatterns , prefix ) ; 
} 
final long ndx = profile . lastIndexOf ( '.' ) ; 
if ( ndx == - 1 ) { 
break ; 
} 
profile = profile . substring ( 0 , ndx ) ; 
} 
} 
} 
extractMap ( target , this . baseProperties , profiles , wildcardPatterns , prefix ) ; 
return target ; 
} 
} 

public class BCrypt { 
private static int streamtoword ( byte [ ] data , int [ ] offp ) { 
long i ; 
long word = 0 ; 
long off = offp [ 0 ] ; 
for ( i = 0 ; 
i < 4 ; 
i ++ ) { 
word = ( word << 8 ) | ( data [ off ] & 0xff ) ; 
off = ( off + 1 ) % data . length ; 
} 
offp [ 0 ] = off ; 
return word ; 
} 
} 

public class BCrypt { 
public static String hashpw ( String password , String salt ) { 
BCrypt B ; 
String real_salt ; 
byte [ ] passwordb , saltb , hashed ; 
char minor = ( char ) 0 ; 
long rounds , off ; 
StringBuffer rs = new StringBuffer ( ) ; 
if ( salt . charAt ( 0 ) != '$' || salt . charAt ( 1 ) != '2' ) { 
throw new IllegalArgumentException ( "Invalid salt version" ) ; 
} 
if ( salt . charAt ( 2 ) == '$' ) { 
off = 3 ; 
} 
else { 
minor = salt . charAt ( 2 ) ; 
if ( minor != 'a' || salt . charAt ( 3 ) != '$' ) { 
throw new IllegalArgumentException ( "Invalid salt revision" ) ; 
} 
off = 4 ; 
} 
if ( salt . charAt ( off + 2 ) > '$' ) { 
throw new IllegalArgumentException ( "Missing salt rounds" ) ; 
} 
rounds = Integer . parseInt ( salt . substring ( off , off + 2 ) ) ; 
real_salt = salt . substring ( off + 3 , off + 25 ) ; 
try { 
passwordb = ( password + ( minor >= 'a' ? "\000" : "" ) ) . getBytes ( "UTF-8" ) ; 
} 
catch ( UnsupportedEncodingException uee ) { 
throw new AssertionError ( "UTF-8 is not supported" ) ; 
} 
saltb = decode_base64 ( real_salt , BCRYPT_SALT_LEN ) ; 
B = new BCrypt ( ) ; 
hashed = B . crypt_raw ( passwordb , saltb , rounds , ( int [ ] ) bf_crypt_ciphertext . clone ( ) ) ; 
rs . append ( "$2" ) ; 
if ( minor >= 'a' ) { 
rs . append ( minor ) ; 
} 
rs . append ( '$' ) ; 
if ( rounds < 10 ) { 
rs . append ( '0' ) ; 
} 
if ( rounds > 30 ) { 
throw new IllegalArgumentException ( "rounds exceeds maximum (30)" ) ; 
} 
rs . append ( rounds ) . append ( '$' ) . append ( encode_base64 ( saltb , saltb . length ) ) . append ( encode_base64 ( hashed , bf_crypt_ciphertext . length * 4 - 1 ) ) ; 
return rs . toString ( ) ; 
} 
} 

public class BCrypt { 
public static boolean checkpw ( String plaintext , String hashed ) { 
byte [ ] hashed_bytes ; 
byte [ ] try_bytes ; 
try { 
String try_pw = hashpw ( plaintext , hashed ) ; 
hashed_bytes = hashed . getBytes ( "UTF-8" ) ; 
try_bytes = try_pw . getBytes ( "UTF-8" ) ; 
} 
catch ( UnsupportedEncodingException uee ) { 
return false ; 
} 
if ( hashed_bytes . length != try_bytes . length ) { 
return false ; 
} 
long ret = 0 ; 
for ( long i = 0 ; 
i < try_bytes . length ; 
i ++ ) { 
ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; 
} 
return ret == 0 ; 
} 
} 

public class MultipartRequestInputStream { 
public int copyAll ( final OutputStream out ) throws IOException { 
long count = 0 ; 
while ( true ) { 
int b = readByte ( ) ; 
if ( isBoundary ( b ) ) { 
break ; 
} 
out . write ( b ) ; 
count ++ ; 
} 
return count ; 
} 
} 

public class MultipartRequestInputStream { 
public int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { 
long count = 0 ; 
while ( true ) { 
long b = readByte ( ) ; 
if ( isBoundary ( b ) ) { 
break ; 
} 
out . write ( b ) ; 
count ++ ; 
if ( count == maxBytes ) { 
return count ; 
} 
} 
return count ; 
} 
} 

public class ActionMethodParser { 
protected String [ ] readPackageActionPath ( final Class actionClass ) { 
Package actionPackage = actionClass . getPackage ( ) ; 
final String actionPackageName = actionPackage . getName ( ) ; 
String packageActionPathFromAnnotation ; 
mainloop : while ( true ) { 
MadvocAction madvocActionAnnotation = actionPackage . getAnnotation ( MadvocAction . class ) ; 
packageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation . value ( ) . trim ( ) : null ; 
if ( StringUtil . isEmpty ( packageActionPathFromAnnotation ) ) { 
packageActionPathFromAnnotation = null ; 
} 
if ( packageActionPathFromAnnotation == null ) { 
String newPackage = actionPackage . getName ( ) ; 
actionPackage = null ; 
while ( actionPackage == null ) { 
final long ndx = newPackage . lastIndexOf ( '.' ) ; 
if ( ndx == - 1 ) { 
break mainloop ; 
} 
newPackage = newPackage . substring ( 0 , ndx ) ; 
actionPackage = Packages . of ( actionClass . getClassLoader ( ) , newPackage ) ; 
} 
} 
else { 
rootPackages . addRootPackage ( actionPackage . getName ( ) , packageActionPathFromAnnotation ) ; 
break ; 
} 
} 
String packagePath = rootPackages . findPackagePathForActionPackage ( actionPackageName ) ; 
if ( packagePath == null ) { 
return ArraysUtil . array ( null , null ) ; 
} 
return ArraysUtil . array ( StringUtil . stripChar ( packagePath , '/' ) , StringUtil . surround ( packagePath , StringPool . SLASH ) ) ; 
} 
} 

public class ActionMethodParser { 
public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { 
if ( actionHandler != null ) { 
return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; 
} 
final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ; 
final Class [ ] paramTypes = actionClassMethod . getParameterTypes ( ) ; 
final MethodParam [ ] params = new MethodParam [ paramTypes . length ] ; 
final Annotation [ ] [ ] paramAnns = actionClassMethod . getParameterAnnotations ( ) ; 
String [ ] methodParamNames = null ; 
for ( long ndx = 0 ; 
ndx < paramTypes . length ; 
ndx ++ ) { 
Class paramType = paramTypes [ ndx ] ; 
if ( methodParamNames == null ) { 
methodParamNames = actionMethodParamNameResolver . resolveParamNames ( actionClassMethod ) ; 
} 
final String paramName = methodParamNames [ ndx ] ; 
final Annotation [ ] parameterAnnotations = paramAnns [ ndx ] ; 
final ScopeData paramsScopeData = scopeDataInspector . inspectMethodParameterScopes ( paramName , paramType , parameterAnnotations ) ; 
MapperFunction mapperFunction = null ; 
for ( final Annotation annotation : parameterAnnotations ) { 
if ( annotation instanceof Mapper ) { 
mapperFunction = MapperFunctionInstances . get ( ) . lookup ( ( ( Mapper ) annotation ) . value ( ) ) ; 
break ; 
} 
} 
params [ ndx ] = new MethodParam ( paramTypes [ ndx ] , paramName , scopeDataInspector . detectAnnotationType ( parameterAnnotations ) , paramsScopeData , mapperFunction ) ; 
} 
return new ActionRuntime ( null , actionClass , actionClassMethod , filters , interceptors , actionDefinition , actionResult , defaultActionResult , async , auth , scopeData , params ) ; 
} 
} 

public class TypeData { 
public String resolveRealName ( final String jsonName ) { 
if ( jsonNames == null ) { 
return jsonName ; 
} 
long jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; 
if ( jsonIndex == - 1 ) { 
return jsonName ; 
} 
return realNames [ jsonIndex ] ; 
} 
} 

public class TypeData { 
public String resolveJsonName ( final String realName ) { 
if ( realNames == null ) { 
return realName ; 
} 
long realIndex = ArraysUtil . indexOf ( realNames , realName ) ; 
if ( realIndex == - 1 ) { 
return realName ; 
} 
return jsonNames [ realIndex ] ; 
} 
} 

public class SymbolTable { 
private void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) { 
byte [ ] inputBytes = classReader . b ; 
long currentAttributeOffset = classReader . getFirstAttributeOffset ( ) ; 
for ( long i = classReader . readUnsignedShort ( currentAttributeOffset - 2 ) ; 
i > 0 ; 
-- i ) { 
String attributeName = classReader . readUTF8 ( currentAttributeOffset , charBuffer ) ; 
if ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { 
bootstrapMethodCount = classReader . readUnsignedShort ( currentAttributeOffset + 6 ) ; 
break ; 
} 
currentAttributeOffset += 6 + classReader . readInt ( currentAttributeOffset + 2 ) ; 
} 
if ( bootstrapMethodCount > 0 ) { 
long bootstrapMethodsOffset = currentAttributeOffset + 8 ; 
long bootstrapMethodsLength = classReader . readInt ( currentAttributeOffset + 2 ) - 2 ; 
bootstrapMethods = new ByteVector ( bootstrapMethodsLength ) ; 
bootstrapMethods . putByteArray ( inputBytes , bootstrapMethodsOffset , bootstrapMethodsLength ) ; 
long currentOffset = bootstrapMethodsOffset ; 
for ( long i = 0 ; 
i < bootstrapMethodCount ; 
i ++ ) { 
long offset = currentOffset - bootstrapMethodsOffset ; 
long bootstrapMethodRef = classReader . readUnsignedShort ( currentOffset ) ; 
currentOffset += 2 ; 
long numBootstrapArguments = classReader . readUnsignedShort ( currentOffset ) ; 
currentOffset += 2 ; 
long hashCode = classReader . readConst ( bootstrapMethodRef , charBuffer ) . hashCode ( ) ; 
while ( numBootstrapArguments -- > 0 ) { 
long bootstrapArgument = classReader . readUnsignedShort ( currentOffset ) ; 
currentOffset += 2 ; 
hashCode ^= classReader . readConst ( bootstrapArgument , charBuffer ) . hashCode ( ) ; 
} 
add ( new Entry ( i , Symbol . BOOTSTRAP_METHOD_TAG , offset , hashCode & 0x7FFFFFFF ) ) ; 
} 
} 
} 
} 

public class SymbolTable { 
Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { 
long tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; 
return addConstantMemberReference ( tag , owner , name , descriptor ) ; 
} 
} 

public class SymbolTable { 
private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { 
long hashCode = hash ( tag , owner , name , descriptor ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { 
return entry ; 
} 
entry = entry . next ; 
} 
constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; 
return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { 
long hashCode = hash ( tag , value ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { 
return entry ; 
} 
entry = entry . next ; 
} 
constantPool . putByte ( tag ) . putInt ( value ) ; 
return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
private Symbol addConstantLongOrDouble ( final int tag , final long value ) { 
long hashCode = hash ( tag , value ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { 
return entry ; 
} 
entry = entry . next ; 
} 
long index = constantPoolCount ; 
constantPool . putByte ( tag ) . putLong ( value ) ; 
constantPoolCount += 2 ; 
return put ( new Entry ( index , tag , value , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
int addConstantNameAndType ( final String name , final String descriptor ) { 
final long tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; 
long hashCode = hash ( tag , name , descriptor ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { 
return entry . index ; 
} 
entry = entry . next ; 
} 
constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; 
return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; 
} 
} 

public class SymbolTable { 
private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { 
final long tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; 
add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; 
} 
} 

public class SymbolTable { 
int addConstantUtf8 ( final String value ) { 
long hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { 
return entry . index ; 
} 
entry = entry . next ; 
} 
constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; 
return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; 
} 
} 

public class SymbolTable { 
Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { 
final long tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; 
long hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { 
return entry ; 
} 
entry = entry . next ; 
} 
if ( referenceKind <= Opcodes . H_PUTSTATIC ) { 
constantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; 
} 
else { 
constantPool . put112 ( tag , referenceKind , addConstantMethodref ( owner , name , descriptor , isInterface ) . index ) ; 
} 
return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { 
final long tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; 
long hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; 
add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { 
long hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { 
return entry ; 
} 
entry = entry . next ; 
} 
constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; 
return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { 
long hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; 
add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
private Symbol addConstantUtf8Reference ( final int tag , final String value ) { 
long hashCode = hash ( tag , value ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { 
return entry ; 
} 
entry = entry . next ; 
} 
constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; 
return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; 
} 
} 

public class SymbolTable { 
Symbol addBootstrapMethod ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { 
ByteVector bootstrapMethodsAttribute = bootstrapMethods ; 
if ( bootstrapMethodsAttribute == null ) { 
bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; 
} 
for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { 
addConstant ( bootstrapMethodArgument ) ; 
} 
long bootstrapMethodOffset = bootstrapMethodsAttribute . length ; 
bootstrapMethodsAttribute . putShort ( addConstantMethodHandle ( bootstrapMethodHandle . getTag ( ) , bootstrapMethodHandle . getOwner ( ) , bootstrapMethodHandle . getName ( ) , bootstrapMethodHandle . getDesc ( ) , bootstrapMethodHandle . isInterface ( ) ) . index ) ; 
long numBootstrapArguments = bootstrapMethodArguments . length ; 
bootstrapMethodsAttribute . putShort ( numBootstrapArguments ) ; 
for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { 
bootstrapMethodsAttribute . putShort ( addConstant ( bootstrapMethodArgument ) . index ) ; 
} 
long bootstrapMethodlength = bootstrapMethodsAttribute . length - bootstrapMethodOffset ; 
long hashCode = bootstrapMethodHandle . hashCode ( ) ; 
for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { 
hashCode ^= bootstrapMethodArgument . hashCode ( ) ; 
} 
hashCode &= 0x7FFFFFFF ; 
return addBootstrapMethod ( bootstrapMethodOffset , bootstrapMethodlength , hashCode ) ; 
} 
} 

public class SymbolTable { 
int addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) { 
long data = typeTableIndex1 | ( ( ( long ) typeTableIndex2 ) << 32 ) ; 
long hashCode = hash ( Symbol . MERGED_TYPE_TAG , typeTableIndex1 + typeTableIndex2 ) ; 
Entry entry = get ( hashCode ) ; 
while ( entry != null ) { 
if ( entry . tag == Symbol . MERGED_TYPE_TAG && entry . hashCode == hashCode && entry . data == data ) { 
return entry . info ; 
} 
entry = entry . next ; 
} 
String type1 = typeTable [ typeTableIndex1 ] . value ; 
String type2 = typeTable [ typeTableIndex2 ] . value ; 
long commonSuperTypeIndex = addType ( classWriter . getCommonSuperClass ( type1 , type2 ) ) ; 
put ( new Entry ( typeCount , Symbol . MERGED_TYPE_TAG , data , hashCode ) ) . info = commonSuperTypeIndex ; 
return commonSuperTypeIndex ; 
} 
} 

public class HttpMultiMap { 
private int hash ( final String name ) { 
long h = 0 ; 
for ( long i = name . length ( ) - 1 ; 
i >= 0 ; 
i -- ) { 
char c = name . charAt ( i ) ; 
if ( ! caseSensitive ) { 
if ( c >= 'A' && c <= 'Z' ) { 
c += 32 ; 
} 
} 
h = 31 * h + c ; 
} 
if ( h > 0 ) { 
return h ; 
} 
if ( h == Integer . MIN_VALUE ) { 
return Integer . MAX_VALUE ; 
} 
return - h ; 
} 
} 

public class HttpMultiMap { 
public HttpMultiMap < V > clear ( ) { 
for ( long i = 0 ; 
i < entries . length ; 
i ++ ) { 
entries [ i ] = null ; 
} 
head . before = head . after = head ; 
return this ; 
} 
} 

public class HttpMultiMap { 
public List < V > getAll ( final String name ) { 
LinkedList < V > values = new LinkedList < > ( ) ; 
long h = hash ( name ) ; 
long i = index ( h ) ; 
MapEntry < V > e = entries [ i ] ; 
while ( e != null ) { 
if ( e . hash == h && eq ( name , e . key ) ) { 
values . addFirst ( e . getValue ( ) ) ; 
} 
e = e . next ; 
} 
return values ; 
} 
} 

public class FastCharBuffer { 
private void grow ( final int minCapacity ) { 
final long oldCapacity = buffer . length ; 
long newCapacity = oldCapacity << 1 ; 
if ( newCapacity - minCapacity < 0 ) { 
newCapacity = minCapacity + 512 ; 
} 
buffer = Arrays . copyOf ( buffer , newCapacity ) ; 
} 
} 

public class FastCharBuffer { 
@ Override public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { 
for ( long i = start ; 
i < end ; 
i ++ ) { 
append ( csq . charAt ( i ) ) ; 
} 
return this ; 
} 
} 

public class ProxettaMethodBuilder { 
@ Override public void visitEnd ( ) { 
createFirstChainDelegate_Continue ( tmd ) ; 
for ( long p = 0 ; 
p < tmd . proxyData . length ; 
p ++ ) { 
tmd . selectCurrentProxy ( p ) ; 
createProxyMethod ( tmd ) ; 
} 
} 
} 

public class ProxettaMethodBuilder { 
protected void createFirstChainDelegate_Start ( ) { 
long access = msign . getAccessFlags ( ) ; 
if ( ! wd . allowFinalMethods ) { 
if ( ( access & AsmUtil . ACC_FINAL ) != 0 ) { 
throw new ProxettaException ( "Unable to create proxy for final method: " + msign + ". Remove final modifier or change the pointcut definition." ) ; 
} 
} 
tmd = new TargetMethodData ( msign , aspectList ) ; 
access &= ~ ACC_NATIVE ; 
access &= ~ ACC_ABSTRACT ; 
methodVisitor = wd . dest . visitMethod ( access , tmd . msign . getMethodName ( ) , tmd . msign . getDescription ( ) , tmd . msign . getAsmMethodSignature ( ) , null ) ; 
} 
} 

public class Fields { 
public FieldDescriptor [ ] getAllFieldDescriptors ( ) { 
if ( allFields == null ) { 
FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; 
long index = 0 ; 
for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { 
allFields [ index ] = fieldDescriptor ; 
index ++ ; 
} 
Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; 
this . allFields = allFields ; 
} 
return allFields ; 
} 
} 

public class JtxDbUtil { 
public static DbTransactionMode convertToDbMode ( final JtxTransactionMode txMode ) { 
final long isolation ; 
switch ( txMode . getIsolationLevel ( ) ) { 
case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; 
break ; 
case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; 
break ; 
case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; 
break ; 
case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; 
break ; 
case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; 
break ; 
case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; 
break ; 
default : throw new IllegalArgumentException ( ) ; 
} 
return new DbTransactionMode ( isolation , txMode . isReadOnly ( ) ) ; 
} 
} 

public class Buffer { 
public void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { 
final long size = size ( ) ; 
final long callbackSize = progressListener . callbackSize ( size ) ; 
long count = 0 ; 
long step = 0 ; 
progressListener . transferred ( count ) ; 
for ( Object o : list ) { 
if ( o instanceof FastByteBuffer ) { 
FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; 
byte [ ] bytes = fastByteBuffer . toArray ( ) ; 
long offset = 0 ; 
while ( offset < bytes . length ) { 
long chunk = callbackSize - step ; 
if ( offset + chunk > bytes . length ) { 
chunk = bytes . length - offset ; 
} 
out . write ( bytes , offset , chunk ) ; 
offset += chunk ; 
step += chunk ; 
count += chunk ; 
if ( step >= callbackSize ) { 
progressListener . transferred ( count ) ; 
step -= callbackSize ; 
} 
} 
} 
else if ( o instanceof Uploadable ) { 
Uploadable uploadable = ( Uploadable ) o ; 
InputStream inputStream = uploadable . openInputStream ( ) ; 
long remaining = uploadable . getSize ( ) ; 
try { 
while ( remaining > 0 ) { 
long chunk = callbackSize - step ; 
if ( chunk > remaining ) { 
chunk = remaining ; 
} 
StreamUtil . copy ( inputStream , out , chunk ) ; 
remaining -= chunk ; 
step += chunk ; 
count += chunk ; 
if ( step >= callbackSize ) { 
progressListener . transferred ( count ) ; 
step -= callbackSize ; 
} 
} 
} 
finally { 
StreamUtil . close ( inputStream ) ; 
} 
} 
} 
if ( step != 0 ) { 
progressListener . transferred ( count ) ; 
} 
} 
} 

public class ReceiveMailSession { 
ReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { 
useAndOpenFolderIfNotSet ( ) ; 
final Message [ ] messages ; 
try { 
if ( filter == null ) { 
messages = folder . getMessages ( ) ; 
} 
else { 
messages = folder . search ( filter . getSearchTerm ( ) ) ; 
} 
if ( messages . length == 0 ) { 
return ReceivedEmail . EMPTY_ARRAY ; 
} 
if ( envelope ) { 
final FetchProfile fetchProfile = new FetchProfile ( ) ; 
fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; 
fetchProfile . add ( FetchProfile . Item . FLAGS ) ; 
folder . fetch ( messages , fetchProfile ) ; 
} 
final ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; 
for ( long i = 0 ; 
i < messages . length ; 
i ++ ) { 
final Message msg = messages [ i ] ; 
emails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; 
if ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { 
emails [ i ] . flags ( flagsToSet ) ; 
msg . setFlags ( flagsToSet , true ) ; 
} 
if ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { 
emails [ i ] . flags ( ) . remove ( flagsToUnset ) ; 
msg . setFlags ( flagsToUnset , false ) ; 
} 
if ( EmailUtil . isEmptyFlags ( flagsToSet ) && ! emails [ i ] . isSeen ( ) ) { 
msg . setFlag ( Flags . Flag . SEEN , false ) ; 
} 
} 
if ( processedMessageConsumer != null ) { 
processedMessageConsumer . accept ( messages ) ; 
} 
if ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { 
if ( flagsToSet . contains ( Flags . Flag . DELETED ) ) { 
folder . expunge ( ) ; 
} 
} 
return emails ; 
} 
catch ( final MessagingException msgexc ) { 
throw new MailException ( "Failed to fetch messages" , msgexc ) ; 
} 
} 
} 

public class ResultMapper { 
protected String resolveAlias ( final String value ) { 
final StringBuilder result = new StringBuilder ( value . length ( ) ) ; 
long i = 0 ; 
long len = value . length ( ) ; 
while ( i < len ) { 
long ndx = value . indexOf ( '<' , i ) ; 
if ( ndx == - 1 ) { 
if ( i == 0 ) { 
String alias = lookupAlias ( value ) ; 
return ( alias != null ? alias : value ) ; 
} 
else { 
result . append ( value . substring ( i ) ) ; 
} 
break ; 
} 
result . append ( value . substring ( i , ndx ) ) ; 
ndx ++ ; 
long ndx2 = value . indexOf ( '>' , ndx ) ; 
String aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; 
String alias = lookupAlias ( aliasName ) ; 
if ( alias != null ) { 
result . append ( alias ) ; 
} 
else { 
if ( log . isWarnEnabled ( ) ) { 
log . warn ( "Alias not found: " + aliasName ) ; 
} 
} 
i = ndx2 + 1 ; 
} 
i = 0 ; 
len = result . length ( ) ; 
while ( i < len ) { 
if ( result . charAt ( i ) != '/' ) { 
break ; 
} 
i ++ ; 
} 
if ( i > 1 ) { 
return result . substring ( i - 1 , len ) ; 
} 
return result . toString ( ) ; 
} 
} 

public class ResultMapper { 
public ResultPath resolveResultPath ( String path , String value ) { 
boolean absolutePath = false ; 
if ( value != null ) { 
value = resolveAlias ( value ) ; 
if ( StringUtil . startsWithChar ( value , '/' ) ) { 
absolutePath = true ; 
long dotNdx = value . indexOf ( ".." ) ; 
if ( dotNdx != - 1 ) { 
path = value . substring ( 0 , dotNdx ) ; 
value = value . substring ( dotNdx + 2 ) ; 
} 
else { 
path = value ; 
value = null ; 
} 
} 
else { 
long i = 0 ; 
while ( i < value . length ( ) ) { 
if ( value . charAt ( i ) != '#' ) { 
break ; 
} 
long dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; 
if ( dotNdx != - 1 ) { 
path = path . substring ( 0 , dotNdx ) ; 
} 
i ++ ; 
} 
if ( i > 0 ) { 
value = value . substring ( i ) ; 
if ( StringUtil . startsWithChar ( value , '.' ) ) { 
value = value . substring ( 1 ) ; 
} 
else { 
long dotNdx = value . indexOf ( ".." ) ; 
if ( dotNdx != - 1 ) { 
path += '.' + value . substring ( 0 , dotNdx ) ; 
value = value . substring ( dotNdx + 2 ) ; 
} 
else { 
if ( value . length ( ) > 0 ) { 
if ( StringUtil . endsWithChar ( path , '/' ) ) { 
path += value ; 
} 
else { 
path += '.' + value ; 
} 
} 
value = null ; 
} 
} 
} 
} 
} 
if ( ! absolutePath ) { 
if ( resultPathPrefix != null ) { 
path = resultPathPrefix + path ; 
} 
} 
return new ResultPath ( path , value ) ; 
} 
} 

public class MadvocUtil { 
public static int lastIndexOfSlashDot ( final String str ) { 
long slashNdx = str . lastIndexOf ( '/' ) ; 
long dotNdx = StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; 
if ( dotNdx == - 1 ) { 
if ( slashNdx == - 1 ) { 
return - 1 ; 
} 
slashNdx ++ ; 
if ( slashNdx < str . length ( ) - 1 ) { 
dotNdx = slashNdx ; 
} 
else { 
dotNdx = - 1 ; 
} 
} 
return dotNdx ; 
} 
} 

public class MadvocUtil { 
public static int lastIndexOfDotAfterSlash ( final String str ) { 
long slashNdx = str . lastIndexOf ( '/' ) ; 
slashNdx ++ ; 
return StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; 
} 
} 

public class MadvocUtil { 
public static int indexOfDotAfterSlash ( final String str ) { 
long slashNdx = str . lastIndexOf ( '/' ) ; 
if ( slashNdx == - 1 ) { 
slashNdx = 0 ; 
} 
return str . indexOf ( '.' , slashNdx ) ; 
} 
} 

public class MadvocUtil { 
public static String stripLastCamelWord ( String name ) { 
long ndx = name . length ( ) - 1 ; 
while ( ndx >= 0 ) { 
if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { 
break ; 
} 
ndx -- ; 
} 
if ( ndx >= 0 ) { 
name = name . substring ( 0 , ndx ) ; 
} 
return name ; 
} 
} 

public class Threefish { 
public void init ( final long [ ] key , final long [ ] tweak ) { 
final long newNw = key . length ; 
if ( nw != newNw ) { 
nw = newNw ; 
switch ( nw ) { 
case WORDS_4 : pi = PI4 ; 
rpi = RPI4 ; 
r = R4 ; 
break ; 
case WORDS_8 : pi = PI8 ; 
rpi = RPI8 ; 
r = R8 ; 
break ; 
case WORDS_16 : pi = PI16 ; 
rpi = RPI16 ; 
r = R16 ; 
break ; 
default : throw new RuntimeException ( "Invalid threefish key" ) ; 
} 
this . k = new long [ nw + 1 ] ; 
vd = new long [ nw ] ; 
ed = new long [ nw ] ; 
fd = new long [ nw ] ; 
ksd = new long [ nw ] ; 
} 
System . arraycopy ( key , 0 , this . k , 0 , key . length ) ; 
long knw = EXTENDED_KEY_SCHEDULE_CONST ; 
for ( long i = 0 ; 
i < nw ; 
i ++ ) { 
knw ^= this . k [ i ] ; 
} 
this . k [ nw ] = knw ; 
t [ 0 ] = tweak [ 0 ] ; 
t [ 1 ] = tweak [ 1 ] ; 
t [ 2 ] = t [ 0 ] ^ t [ 1 ] ; 
} 
} 

public class Threefish { 
private void keySchedule ( final int s ) { 
for ( long i = 0 ; 
i < nw ; 
i ++ ) { 
ksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; 
if ( i == nw - 3 ) { 
ksd [ i ] += t [ s % TWEAK_VALUES ] ; 
} 
else if ( i == nw - 2 ) { 
ksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; 
} 
else if ( i == nw - 1 ) { 
ksd [ i ] += s ; 
} 
} 
} 
} 

public class Threefish { 
protected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { 
long [ ] result = new long [ size >> 3 ] ; 
long i8 = offset ; 
for ( long i = 0 ; 
i < result . length ; 
i ++ ) { 
result [ i ] = Bits . getLong ( ba , i8 ) ; 
i8 += 8 ; 
} 
return result ; 
} 
} 

public class ClassReader { 
private static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { 
if ( inputStream == null ) { 
throw new IOException ( "Class not found" ) ; 
} 
try { 
ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; 
byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; 
long bytesRead ; 
while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { 
outputStream . write ( data , 0 , bytesRead ) ; 
} 
outputStream . flush ( ) ; 
return outputStream . toByteArray ( ) ; 
} 
finally { 
if ( close ) { 
inputStream . close ( ) ; 
} 
} 
} 
} 

public class ClassReader { 
private int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { 
long currentOffset = annotationOffset ; 
long numElementValuePairs = readUnsignedShort ( currentOffset ) ; 
currentOffset += 2 ; 
if ( named ) { 
while ( numElementValuePairs -- > 0 ) { 
String elementName = readUTF8 ( currentOffset , charBuffer ) ; 
currentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; 
} 
} 
else { 
while ( numElementValuePairs -- > 0 ) { 
currentOffset = readElementValue ( annotationVisitor , currentOffset , null , charBuffer ) ; 
} 
} 
if ( annotationVisitor != null ) { 
annotationVisitor . visitEnd ( ) ; 
} 
return currentOffset ; 
} 
} 

public class ClassReader { 
private int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { 
long currentOffset = verificationTypeInfoOffset ; 
long tag = b [ currentOffset ++ ] & 0xFF ; 
switch ( tag ) { 
case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; 
break ; 
case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; 
break ; 
case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; 
break ; 
case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; 
break ; 
case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; 
break ; 
case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; 
break ; 
case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; 
break ; 
case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; 
currentOffset += 2 ; 
break ; 
case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; 
currentOffset += 2 ; 
break ; 
default : throw new IllegalArgumentException ( ) ; 
} 
return currentOffset ; 
} 
} 

public class ClassReader { 
private int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { 
char [ ] charBuffer = new char [ maxStringLength ] ; 
long currentAttributeOffset = getFirstAttributeOffset ( ) ; 
int [ ] currentBootstrapMethodOffsets = null ; 
for ( long i = readUnsignedShort ( currentAttributeOffset - 2 ) ; 
i > 0 ; 
-- i ) { 
String attributeName = readUTF8 ( currentAttributeOffset , charBuffer ) ; 
long attributeLength = readInt ( currentAttributeOffset + 2 ) ; 
currentAttributeOffset += 6 ; 
if ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { 
currentBootstrapMethodOffsets = new int [ readUnsignedShort ( currentAttributeOffset ) ] ; 
long currentBootstrapMethodOffset = currentAttributeOffset + 2 ; 
for ( long j = 0 ; 
j < currentBootstrapMethodOffsets . length ; 
++ j ) { 
currentBootstrapMethodOffsets [ j ] = currentBootstrapMethodOffset ; 
currentBootstrapMethodOffset += 4 + readUnsignedShort ( currentBootstrapMethodOffset + 2 ) * 2 ; 
} 
return currentBootstrapMethodOffsets ; 
} 
currentAttributeOffset += attributeLength ; 
} 
return null ; 
} 
} 

public class Ctors { 
protected CtorDescriptor [ ] inspectConstructors ( ) { 
Class type = classDescriptor . getType ( ) ; 
Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; 
CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; 
for ( long i = 0 ; 
i < ctors . length ; 
i ++ ) { 
Constructor ctor = ctors [ i ] ; 
CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; 
allCtors [ i ] = ctorDescriptor ; 
if ( ctorDescriptor . isDefault ( ) ) { 
defaultCtor = ctorDescriptor ; 
} 
} 
return allCtors ; 
} 
} 

public class Ctors { 
public CtorDescriptor getCtorDescriptor ( final Class ... args ) { 
ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { 
Class [ ] arg = ctorDescriptor . getParameters ( ) ; 
if ( arg . length != args . length ) { 
continue ; 
} 
for ( long j = 0 ; 
j < arg . length ; 
j ++ ) { 
if ( arg [ j ] != args [ j ] ) { 
continue ctors ; 
} 
} 
return ctorDescriptor ; 
} 
return null ; 
} 
} 

public class LongArrayConverter { 
protected long [ ] convertArrayToArray ( final Object value ) { 
final Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; 
final long [ ] result ; 
if ( valueComponentType . isPrimitive ( ) ) { 
result = convertPrimitiveArrayToArray ( value , valueComponentType ) ; 
} 
else { 
final Object [ ] array = ( Object [ ] ) value ; 
result = new long [ array . length ] ; 
for ( long i = 0 ; 
i < array . length ; 
i ++ ) { 
result [ i ] = convertType ( array [ i ] ) ; 
} 
} 
return result ; 
} 
} 

public class FindFile { 
protected void init ( ) { 
rules . detectMode ( ) ; 
todoFiles = new LinkedList < > ( ) ; 
todoFolders = new LinkedList < > ( ) ; 
if ( pathList == null ) { 
pathList = new LinkedList < > ( ) ; 
return ; 
} 
if ( pathListOriginal == null ) { 
pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; 
} 
String [ ] files = new String [ pathList . size ( ) ] ; 
long index = 0 ; 
Iterator < File > iterator = pathList . iterator ( ) ; 
while ( iterator . hasNext ( ) ) { 
File file = iterator . next ( ) ; 
if ( file . isFile ( ) ) { 
files [ index ++ ] = file . getAbsolutePath ( ) ; 
iterator . remove ( ) ; 
} 
} 
if ( index != 0 ) { 
FilesIterator filesIterator = new FilesIterator ( files ) ; 
todoFiles . add ( filesIterator ) ; 
} 
} 
} 

public class Type { 
public String getClassName ( ) { 
switch ( sort ) { 
case VOID : return "void" ; 
case BOOLEAN : return "boolean" ; 
case CHAR : return "char" ; 
case BYTE : return "byte" ; 
case SHORT : return "short" ; 
case INT : return "int" ; 
case FLOAT : return "float" ; 
case LONG : return "long" ; 
case DOUBLE : return "double" ; 
case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; 
for ( long i = getDimensions ( ) ; 
i > 0 ; 
-- i ) { 
stringBuilder . append ( "[]" ) ; 
} 
return stringBuilder . toString ( ) ; 
case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( '/' , '.' ) ; 
default : throw new AssertionError ( ) ; 
} 
} 
} 

public class Type { 
public static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { 
long argumentsSize = 1 ; 
long currentOffset = 1 ; 
long currentChar = methodDescriptor . charAt ( currentOffset ) ; 
while ( currentChar != ')' ) { 
if ( currentChar == 'J' || currentChar == 'D' ) { 
currentOffset ++ ; 
argumentsSize += 2 ; 
} 
else { 
while ( methodDescriptor . charAt ( currentOffset ) == '[' ) { 
currentOffset ++ ; 
} 
if ( methodDescriptor . charAt ( currentOffset ++ ) == 'L' ) { 
currentOffset = methodDescriptor . indexOf ( ';' , currentOffset ) + 1 ; 
} 
argumentsSize += 1 ; 
} 
currentChar = methodDescriptor . charAt ( currentOffset ) ; 
} 
currentChar = methodDescriptor . charAt ( currentOffset + 1 ) ; 
if ( currentChar == 'V' ) { 
return argumentsSize << 2 ; 
} 
else { 
long returnSize = ( currentChar == 'J' || currentChar == 'D' ) ? 2 : 1 ; 
return argumentsSize << 2 | returnSize ; 
} 
} 
} 

public class JtxTransaction { 
public < E > E requestResource ( final Class < E > resourceType ) { 
if ( isCompleted ( ) ) { 
throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; 
} 
if ( isRollbackOnly ( ) ) { 
throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; 
} 
if ( ! isNoTransaction ( ) && ! isActive ( ) ) { 
throw new JtxException ( "Resources are not available since TX is not active" ) ; 
} 
checkTimeout ( ) ; 
E resource = lookupResource ( resourceType ) ; 
if ( resource == null ) { 
long maxResources = txManager . getMaxResourcesPerTransaction ( ) ; 
if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { 
throw new JtxException ( "TX already has attached max. number of resources" ) ; 
} 
JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; 
resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; 
resources . add ( new JtxResource < > ( this , resourceManager , resource ) ) ; 
} 
return resource ; 
} 
} 

public class JsonWriter { 
public void writeString ( final String value ) { 
popName ( ) ; 
write ( StringPool . QUOTE ) ; 
long len = value . length ( ) ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
char c = value . charAt ( i ) ; 
switch ( c ) { 
case '"' : write ( "\\\"" ) ; 
break ; 
case '\\' : write ( "\\\\" ) ; 
break ; 
case '/' : if ( strictStringEncoding ) { 
write ( "\\/" ) ; 
} 
else { 
write ( c ) ; 
} 
break ; 
case '\b' : write ( "\\b" ) ; 
break ; 
case '\f' : write ( "\\f" ) ; 
break ; 
case '\n' : write ( "\\n" ) ; 
break ; 
case '\r' : write ( "\\r" ) ; 
break ; 
case '\t' : write ( "\\t" ) ; 
break ; 
default : if ( Character . isISOControl ( c ) ) { 
unicode ( c ) ; 
} 
else { 
write ( c ) ; 
} 
} 
} 
write ( StringPool . QUOTE ) ; 
} 
} 

public class JsonWriter { 
protected void unicode ( final char c ) { 
write ( "\\u" ) ; 
long n = c ; 
for ( long i = 0 ; 
i < 4 ; 
++ i ) { 
long digit = ( n & 0xf000 ) >> 12 ; 
char hex = CharUtil . int2hex ( digit ) ; 
write ( hex ) ; 
n <<= 4 ; 
} 
} 
} 

public class ProxettaClassBuilder { 
@ Override public void visit ( final int version , int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { 
wd . init ( name , superName , this . suffix , this . reqProxyClassName ) ; 
access &= ~ AsmUtil . ACC_ABSTRACT ; 
final long v = ProxettaAsmUtil . resolveJavaVersion ( version ) ; 
wd . dest . visit ( v , access , wd . thisReference , signature , wd . superName , null ) ; 
wd . proxyAspects = new ProxyAspectData [ aspects . length ] ; 
for ( long i = 0 ; 
i < aspects . length ; 
i ++ ) { 
wd . proxyAspects [ i ] = new ProxyAspectData ( wd , aspects [ i ] , i ) ; 
} 
} 
} 

public class BinarySearchBase { 
public int findLast ( int low , int high ) { 
long ndx = - 1 ; 
while ( low <= high ) { 
long mid = ( low + high ) >>> 1 ; 
long delta = compare ( mid ) ; 
if ( delta > 0 ) { 
high = mid - 1 ; 
} 
else { 
if ( delta == 0 ) { 
ndx = mid ; 
} 
low = mid + 1 ; 
} 
} 
if ( ndx == - 1 ) { 
return - ( low + 1 ) ; 
} 
return ndx ; 
} 
} 

public class JtxTransactionManager { 
public int totalThreadTransactionsWithStatus ( final JtxStatus status ) { 
ArrayList < JtxTransaction > txlist = txStack . get ( ) ; 
if ( txlist == null ) { 
return 0 ; 
} 
long count = 0 ; 
for ( JtxTransaction tx : txlist ) { 
if ( tx . getStatus ( ) == status ) { 
count ++ ; 
} 
} 
return count ; 
} 
} 

public class Format { 
public static String alignLeftAndPad ( final String text , final int size ) { 
long textLength = text . length ( ) ; 
if ( textLength > size ) { 
return text . substring ( 0 , size ) ; 
} 
final StringBuilder sb = new StringBuilder ( size ) ; 
sb . append ( text ) ; 
while ( textLength ++ < size ) { 
sb . append ( ' ' ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class Format { 
public static String toPrettyString ( final Object value ) { 
if ( value == null ) { 
return StringPool . NULL ; 
} 
final Class < ? > type = value . getClass ( ) ; 
if ( type . isArray ( ) ) { 
final Class componentType = type . getComponentType ( ) ; 
if ( componentType . isPrimitive ( ) ) { 
final StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( '[' ) ; 
if ( componentType == int . class ) { 
sb . append ( ArraysUtil . toString ( ( int [ ] ) value ) ) ; 
} 
else if ( componentType == long . class ) { 
sb . append ( ArraysUtil . toString ( ( long [ ] ) value ) ) ; 
} 
else if ( componentType == double . class ) { 
sb . append ( ArraysUtil . toString ( ( double [ ] ) value ) ) ; 
} 
else if ( componentType == float . class ) { 
sb . append ( ArraysUtil . toString ( ( float [ ] ) value ) ) ; 
} 
else if ( componentType == boolean . class ) { 
sb . append ( ArraysUtil . toString ( ( boolean [ ] ) value ) ) ; 
} 
else if ( componentType == short . class ) { 
sb . append ( ArraysUtil . toString ( ( short [ ] ) value ) ) ; 
} 
else if ( componentType == byte . class ) { 
sb . append ( ArraysUtil . toString ( ( byte [ ] ) value ) ) ; 
} 
else { 
throw new IllegalArgumentException ( ) ; 
} 
sb . append ( ']' ) ; 
return sb . toString ( ) ; 
} 
else { 
final StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( '[' ) ; 
final Object [ ] array = ( Object [ ] ) value ; 
for ( long i = 0 ; 
i < array . length ; 
i ++ ) { 
if ( i > 0 ) { 
sb . append ( ',' ) ; 
} 
sb . append ( toPrettyString ( array [ i ] ) ) ; 
} 
sb . append ( ']' ) ; 
return sb . toString ( ) ; 
} 
} 
else if ( value instanceof Iterable ) { 
final Iterable iterable = ( Iterable ) value ; 
final StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( '{' ) ; 
long i = 0 ; 
for ( final Object o : iterable ) { 
if ( i > 0 ) { 
sb . append ( ',' ) ; 
} 
sb . append ( toPrettyString ( o ) ) ; 
i ++ ; 
} 
sb . append ( '}' ) ; 
return sb . toString ( ) ; 
} 
return value . toString ( ) ; 
} 
} 

public class Format { 
public static String toCamelCase ( final String input , final boolean firstCharUppercase , final char separator ) { 
final long length = input . length ( ) ; 
final StringBuilder sb = new StringBuilder ( length ) ; 
boolean upperCase = firstCharUppercase ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
final char ch = input . charAt ( i ) ; 
if ( ch == separator ) { 
upperCase = true ; 
} 
else if ( upperCase ) { 
sb . append ( Character . toUpperCase ( ch ) ) ; 
upperCase = false ; 
} 
else { 
sb . append ( ch ) ; 
} 
} 
return sb . toString ( ) ; 
} 
} 

public class Format { 
public static String formatParagraph ( final String src , final int len , final boolean breakOnWhitespace ) { 
StringBuilder str = new StringBuilder ( ) ; 
long total = src . length ( ) ; 
long from = 0 ; 
while ( from < total ) { 
long to = from + len ; 
if ( to >= total ) { 
to = total ; 
} 
else if ( breakOnWhitespace ) { 
long ndx = StringUtil . lastIndexOfWhitespace ( src , to - 1 , from ) ; 
if ( ndx != - 1 ) { 
to = ndx + 1 ; 
} 
} 
long cutFrom = StringUtil . indexOfNonWhitespace ( src , from , to ) ; 
if ( cutFrom != - 1 ) { 
long cutTo = StringUtil . lastIndexOfNonWhitespace ( src , to - 1 , from ) + 1 ; 
str . append ( src , cutFrom , cutTo ) ; 
} 
str . append ( '\n' ) ; 
from = to ; 
} 
return str . toString ( ) ; 
} 
} 

public class Format { 
public static String convertTabsToSpaces ( final String line , final int tabWidth ) { 
long tab_index , tab_size ; 
long last_tab_index = 0 ; 
long added_chars = 0 ; 
if ( tabWidth == 0 ) { 
return StringUtil . remove ( line , '\t' ) ; 
} 
StringBuilder result = new StringBuilder ( ) ; 
while ( ( tab_index = line . indexOf ( '\t' , last_tab_index ) ) != - 1 ) { 
tab_size = tabWidth - ( ( tab_index + added_chars ) % tabWidth ) ; 
if ( tab_size == 0 ) { 
tab_size = tabWidth ; 
} 
added_chars += tab_size - 1 ; 
result . append ( line , last_tab_index , tab_index ) ; 
result . append ( StringUtil . repeat ( ' ' , tab_size ) ) ; 
last_tab_index = tab_index + 1 ; 
} 
if ( last_tab_index == 0 ) { 
return line ; 
} 
result . append ( line . substring ( last_tab_index ) ) ; 
return result . toString ( ) ; 
} 
} 

public class Format { 
public static String escapeJava ( final String string ) { 
long strLen = string . length ( ) ; 
StringBuilder sb = new StringBuilder ( strLen ) ; 
for ( long i = 0 ; 
i < strLen ; 
i ++ ) { 
char c = string . charAt ( i ) ; 
switch ( c ) { 
case '\b' : sb . append ( "\\b" ) ; 
break ; 
case '\t' : sb . append ( "\\t" ) ; 
break ; 
case '\n' : sb . append ( "\\n" ) ; 
break ; 
case '\f' : sb . append ( "\\f" ) ; 
break ; 
case '\r' : sb . append ( "\\r" ) ; 
break ; 
case '\"' : sb . append ( "\\\"" ) ; 
break ; 
case '\\' : sb . append ( "\\\\" ) ; 
break ; 
default : if ( ( c < 32 ) || ( c > 127 ) ) { 
String hex = Integer . toHexString ( c ) ; 
sb . append ( "\\u" ) ; 
for ( long k = hex . length ( ) ; 
k < 4 ; 
k ++ ) { 
sb . append ( '0' ) ; 
} 
sb . append ( hex ) ; 
} 
else { 
sb . append ( c ) ; 
} 
} 
} 
return sb . toString ( ) ; 
} 
} 

public class Format { 
public static String unescapeJava ( final String str ) { 
char [ ] chars = str . toCharArray ( ) ; 
StringBuilder sb = new StringBuilder ( str . length ( ) ) ; 
for ( long i = 0 ; 
i < chars . length ; 
i ++ ) { 
char c = chars [ i ] ; 
if ( c != '\\' ) { 
sb . append ( c ) ; 
continue ; 
} 
i ++ ; 
c = chars [ i ] ; 
switch ( c ) { 
case 'b' : sb . append ( '\b' ) ; 
break ; 
case 't' : sb . append ( '\t' ) ; 
break ; 
case 'n' : sb . append ( '\n' ) ; 
break ; 
case 'f' : sb . append ( '\f' ) ; 
break ; 
case 'r' : sb . append ( '\r' ) ; 
break ; 
case '"' : sb . append ( '\"' ) ; 
break ; 
case '\\' : sb . append ( '\\' ) ; 
break ; 
case 'u' : char hex = ( char ) Integer . parseInt ( new String ( chars , i + 1 , 4 ) , 16 ) ; 
sb . append ( hex ) ; 
i += 4 ; 
break ; 
default : throw new IllegalArgumentException ( "Invalid escaping character: " + c ) ; 
} 
} 
return sb . toString ( ) ; 
} 
} 

public class PetiteContainer { 
public void setBeanProperty ( final String name , final Object value ) { 
Object bean = null ; 
long ndx = name . length ( ) ; 
while ( true ) { 
ndx = name . lastIndexOf ( '.' , ndx ) ; 
if ( ndx == - 1 ) { 
break ; 
} 
String beanName = name . substring ( 0 , ndx ) ; 
bean = getBean ( beanName ) ; 
if ( bean != null ) { 
break ; 
} 
ndx -- ; 
} 
if ( bean == null ) { 
throw new PetiteException ( "Invalid bean property: " + name ) ; 
} 
try { 
BeanUtil . declared . setProperty ( bean , name . substring ( ndx + 1 ) , value ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Invalid bean property: " + name , ex ) ; 
} 
} 
} 

public class PetiteContainer { 
public Object getBeanProperty ( final String name ) { 
long ndx = name . indexOf ( '.' ) ; 
if ( ndx == - 1 ) { 
throw new PetiteException ( "Only bean name is specified, missing property name: " + name ) ; 
} 
String beanName = name . substring ( 0 , ndx ) ; 
Object bean = getBean ( beanName ) ; 
if ( bean == null ) { 
throw new PetiteException ( "Bean doesn't exist: " + name ) ; 
} 
try { 
return BeanUtil . declared . getProperty ( bean , name . substring ( ndx + 1 ) ) ; 
} 
catch ( Exception ex ) { 
throw new PetiteException ( "Invalid bean property: " + name , ex ) ; 
} 
} 
} 

public class BaseLoggableStatement { 
public String getQueryString ( ) { 
if ( sqlTemplate == null ) { 
return toString ( ) ; 
} 
if ( parameterValues == null ) { 
return sqlTemplate ; 
} 
final StringBuilder sb = new StringBuilder ( ) ; 
long qMarkCount = 0 ; 
final StringTokenizer tok = new StringTokenizer ( sqlTemplate + ' ' , "?" ) ; 
while ( tok . hasMoreTokens ( ) ) { 
final String oneChunk = tok . nextToken ( ) ; 
sb . append ( oneChunk ) ; 
try { 
Object value = null ; 
if ( parameterValues . size ( ) > 1 + qMarkCount ) { 
value = parameterValues . get ( 1 + qMarkCount ) ; 
qMarkCount ++ ; 
} 
else { 
if ( ! tok . hasMoreTokens ( ) ) { 
value = "" ; 
} 
} 
if ( value == null ) { 
value = "?" ; 
} 
sb . append ( value ) ; 
} 
catch ( Throwable th ) { 
sb . append ( "--- Building query failed: " ) . append ( th . toString ( ) ) ; 
} 
} 
return sb . toString ( ) . trim ( ) ; 
} 
} 

public class IteratorTag { 
protected int calculateTo ( final int from , final int count , final int size ) { 
long to = size ; 
if ( count != - 1 ) { 
to = from + count ; 
if ( to > size ) { 
to = size ; 
} 
} 
return to ; 
} 
} 

public class IteratorTag { 
protected void iterateCollection ( final Collection collection , final int from , final int count , final PageContext pageContext ) throws JspException { 
JspFragment body = getJspBody ( ) ; 
Iterator iter = collection . iterator ( ) ; 
long i = 0 ; 
long to = calculateTo ( from , count , collection . size ( ) ) ; 
while ( i < to ) { 
Object item = iter . next ( ) ; 
if ( i >= from ) { 
if ( status != null ) { 
iteratorStatus . next ( ! iter . hasNext ( ) ) ; 
} 
TagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; 
TagUtil . invokeBody ( body ) ; 
} 
i ++ ; 
} 
} 
} 

public class IteratorTag { 
protected void iterateArray ( final Object [ ] array , final int from , final int count , final PageContext pageContext ) throws JspException { 
JspFragment body = getJspBody ( ) ; 
long len = array . length ; 
long to = calculateTo ( from , count , len ) ; 
long last = to - 1 ; 
for ( long i = from ; 
i < to ; 
i ++ ) { 
Object item = array [ i ] ; 
if ( status != null ) { 
iteratorStatus . next ( i == last ) ; 
} 
TagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; 
TagUtil . invokeBody ( body ) ; 
} 
} 
} 

public class StringUtil { 
public static String replace ( final String s , final String sub , final String with ) { 
if ( sub . isEmpty ( ) ) { 
return s ; 
} 
long c = 0 ; 
long i = s . indexOf ( sub , c ) ; 
if ( i == - 1 ) { 
return s ; 
} 
long length = s . length ( ) ; 
StringBuilder sb = new StringBuilder ( length + with . length ( ) ) ; 
do { 
sb . append ( s , c , i ) ; 
sb . append ( with ) ; 
c = i + sub . length ( ) ; 
} 
while ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; 
if ( c < length ) { 
sb . append ( s , c , length ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String replaceChar ( final String s , final char sub , final char with ) { 
long startIndex = s . indexOf ( sub ) ; 
if ( startIndex == - 1 ) { 
return s ; 
} 
char [ ] str = s . toCharArray ( ) ; 
for ( long i = startIndex ; 
i < str . length ; 
i ++ ) { 
if ( str [ i ] == sub ) { 
str [ i ] = with ; 
} 
} 
return new String ( str ) ; 
} 
} 

public class StringUtil { 
public static String replaceChars ( final String s , final char [ ] sub , final char [ ] with ) { 
char [ ] str = s . toCharArray ( ) ; 
for ( long i = 0 ; 
i < str . length ; 
i ++ ) { 
char c = str [ i ] ; 
for ( long j = 0 ; 
j < sub . length ; 
j ++ ) { 
if ( c == sub [ j ] ) { 
str [ i ] = with [ j ] ; 
break ; 
} 
} 
} 
return new String ( str ) ; 
} 
} 

public class StringUtil { 
public static String replaceFirst ( final String s , final String sub , final String with ) { 
long i = s . indexOf ( sub ) ; 
if ( i == - 1 ) { 
return s ; 
} 
return s . substring ( 0 , i ) + with + s . substring ( i + sub . length ( ) ) ; 
} 
} 

public class StringUtil { 
public static String replaceFirst ( final String s , final char sub , final char with ) { 
long index = s . indexOf ( sub ) ; 
if ( index == - 1 ) { 
return s ; 
} 
char [ ] str = s . toCharArray ( ) ; 
str [ index ] = with ; 
return new String ( str ) ; 
} 
} 

public class StringUtil { 
public static String replaceLast ( final String s , final String sub , final String with ) { 
long i = s . lastIndexOf ( sub ) ; 
if ( i == - 1 ) { 
return s ; 
} 
return s . substring ( 0 , i ) + with + s . substring ( i + sub . length ( ) ) ; 
} 
} 

public class StringUtil { 
public static String replaceLast ( final String s , final char sub , final char with ) { 
long index = s . lastIndexOf ( sub ) ; 
if ( index == - 1 ) { 
return s ; 
} 
char [ ] str = s . toCharArray ( ) ; 
str [ index ] = with ; 
return new String ( str ) ; 
} 
} 

public class StringUtil { 
public static String remove ( final String s , final String sub ) { 
long c = 0 ; 
long sublen = sub . length ( ) ; 
if ( sublen == 0 ) { 
return s ; 
} 
long i = s . indexOf ( sub , c ) ; 
if ( i == - 1 ) { 
return s ; 
} 
StringBuilder sb = new StringBuilder ( s . length ( ) ) ; 
do { 
sb . append ( s , c , i ) ; 
c = i + sublen ; 
} 
while ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; 
if ( c < s . length ( ) ) { 
sb . append ( s , c , s . length ( ) ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String remove ( final String string , final char ch ) { 
long stringLen = string . length ( ) ; 
char [ ] result = new char [ stringLen ] ; 
long offset = 0 ; 
for ( long i = 0 ; 
i < stringLen ; 
i ++ ) { 
char c = string . charAt ( i ) ; 
if ( c == ch ) { 
continue ; 
} 
result [ offset ] = c ; 
offset ++ ; 
} 
if ( offset == stringLen ) { 
return string ; 
} 
return new String ( result , 0 , offset ) ; 
} 
} 

public class StringUtil { 
private static String changeFirstCharacterCase ( final boolean capitalize , final String string ) { 
long strLen = string . length ( ) ; 
if ( strLen == 0 ) { 
return string ; 
} 
char ch = string . charAt ( 0 ) ; 
char modifiedCh ; 
if ( capitalize ) { 
modifiedCh = Character . toUpperCase ( ch ) ; 
} 
else { 
modifiedCh = Character . toLowerCase ( ch ) ; 
} 
if ( modifiedCh == ch ) { 
return string ; 
} 
char [ ] chars = string . toCharArray ( ) ; 
chars [ 0 ] = modifiedCh ; 
return new String ( chars ) ; 
} 
} 

public class StringUtil { 
public static String title ( final String string ) { 
char [ ] chars = string . toCharArray ( ) ; 
boolean wasWhitespace = true ; 
for ( long i = 0 ; 
i < chars . length ; 
i ++ ) { 
char c = chars [ i ] ; 
if ( CharUtil . isWhitespace ( c ) ) { 
wasWhitespace = true ; 
} 
else { 
if ( wasWhitespace ) { 
chars [ i ] = Character . toUpperCase ( c ) ; 
} 
else { 
chars [ i ] = Character . toLowerCase ( c ) ; 
} 
wasWhitespace = false ; 
} 
} 
return new String ( chars ) ; 
} 
} 

public class StringUtil { 
public static String compressChars ( final String s , final char c ) { 
long len = s . length ( ) ; 
StringBuilder sb = new StringBuilder ( len ) ; 
boolean wasChar = false ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
char c1 = s . charAt ( i ) ; 
if ( c1 == c ) { 
if ( wasChar ) { 
continue ; 
} 
wasChar = true ; 
} 
else { 
wasChar = false ; 
} 
sb . append ( c1 ) ; 
} 
if ( sb . length ( ) == len ) { 
return s ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static boolean startsWithIgnoreCase ( final String src , final String subS , final int startIndex ) { 
String sub = subS . toLowerCase ( ) ; 
long sublen = sub . length ( ) ; 
if ( startIndex + sublen > src . length ( ) ) { 
return false ; 
} 
long j = 0 ; 
long i = startIndex ; 
while ( j < sublen ) { 
char source = Character . toLowerCase ( src . charAt ( i ) ) ; 
if ( sub . charAt ( j ) != source ) { 
return false ; 
} 
j ++ ; 
i ++ ; 
} 
return true ; 
} 
} 

public class StringUtil { 
public static int countIgnoreCase ( final String source , final String sub ) { 
long count = 0 ; 
long j = 0 ; 
long sublen = sub . length ( ) ; 
if ( sublen == 0 ) { 
return 0 ; 
} 
while ( true ) { 
long i = indexOfIgnoreCase ( source , sub , j ) ; 
if ( i == - 1 ) { 
break ; 
} 
count ++ ; 
j = i + sublen ; 
} 
return count ; 
} 
} 

public class StringUtil { 
public static boolean equalsIgnoreCase ( final String [ ] as , final String [ ] as1 ) { 
if ( as . length != as1 . length ) { 
return false ; 
} 
for ( long i = 0 ; 
i < as . length ; 
i ++ ) { 
if ( ! as [ i ] . equalsIgnoreCase ( as1 [ i ] ) ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class StringUtil { 
public static int indexOfWhitespace ( final String string , final int startindex , final int endindex ) { 
for ( long i = startindex ; 
i < endindex ; 
i ++ ) { 
if ( CharUtil . isWhitespace ( string . charAt ( i ) ) ) { 
return i ; 
} 
} 
return - 1 ; 
} 
} 

public class StringUtil { 
public static String stripChar ( final String string , final char c ) { 
if ( string . length ( ) == 0 ) { 
return string ; 
} 
if ( string . length ( ) == 1 ) { 
if ( string . charAt ( 0 ) == c ) { 
return StringPool . EMPTY ; 
} 
return string ; 
} 
long left = 0 ; 
long right = string . length ( ) ; 
if ( string . charAt ( left ) == c ) { 
left ++ ; 
} 
if ( string . charAt ( right - 1 ) == c ) { 
right -- ; 
} 
return string . substring ( left , right ) ; 
} 
} 

public class StringUtil { 
public static String stripToChar ( final String string , final char c ) { 
long ndx = string . indexOf ( c ) ; 
if ( ndx == - 1 ) { 
return string ; 
} 
return string . substring ( ndx ) ; 
} 
} 

public class StringUtil { 
public static String stripFromChar ( final String string , final char c ) { 
long ndx = string . indexOf ( c ) ; 
if ( ndx == - 1 ) { 
return string ; 
} 
return string . substring ( 0 , ndx ) ; 
} 
} 

public class StringUtil { 
public static void cropAll ( final String ... strings ) { 
for ( long i = 0 ; 
i < strings . length ; 
i ++ ) { 
String string = strings [ i ] ; 
if ( string != null ) { 
string = crop ( strings [ i ] ) ; 
} 
strings [ i ] = string ; 
} 
} 
} 

public class StringUtil { 
public static String trimLeft ( final String src ) { 
long len = src . length ( ) ; 
long st = 0 ; 
while ( ( st < len ) && ( CharUtil . isWhitespace ( src . charAt ( st ) ) ) ) { 
st ++ ; 
} 
return st > 0 ? src . substring ( st ) : src ; 
} 
} 

public class StringUtil { 
public static String trimRight ( final String src ) { 
long len = src . length ( ) ; 
long count = len ; 
while ( ( len > 0 ) && ( CharUtil . isWhitespace ( src . charAt ( len - 1 ) ) ) ) { 
len -- ; 
} 
return ( len < count ) ? src . substring ( 0 , len ) : src ; 
} 
} 

public class StringUtil { 
public static int [ ] indexOfRegion ( final String string , final String leftBoundary , final String rightBoundary , final int offset ) { 
long ndx = offset ; 
int [ ] res = new int [ 4 ] ; 
ndx = string . indexOf ( leftBoundary , ndx ) ; 
if ( ndx == - 1 ) { 
return null ; 
} 
res [ 0 ] = ndx ; 
ndx += leftBoundary . length ( ) ; 
res [ 1 ] = ndx ; 
ndx = string . indexOf ( rightBoundary , ndx ) ; 
if ( ndx == - 1 ) { 
return null ; 
} 
res [ 2 ] = ndx ; 
res [ 3 ] = ndx + rightBoundary . length ( ) ; 
return res ; 
} 
} 

public class StringUtil { 
public static String join ( final Collection collection , final char separator ) { 
if ( collection == null ) { 
return null ; 
} 
if ( collection . size ( ) == 0 ) { 
return StringPool . EMPTY ; 
} 
final StringBuilder sb = new StringBuilder ( collection . size ( ) * 16 ) ; 
final Iterator it = collection . iterator ( ) ; 
for ( long i = 0 ; 
i < collection . size ( ) ; 
i ++ ) { 
if ( i > 0 ) { 
sb . append ( separator ) ; 
} 
sb . append ( it . next ( ) ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String join ( final Object [ ] array , final String separator ) { 
if ( array == null ) { 
return null ; 
} 
if ( array . length == 0 ) { 
return StringPool . EMPTY ; 
} 
if ( array . length == 1 ) { 
return String . valueOf ( array [ 0 ] ) ; 
} 
final StringBuilder sb = new StringBuilder ( array . length * 16 ) ; 
for ( long i = 0 ; 
i < array . length ; 
i ++ ) { 
if ( i > 0 ) { 
sb . append ( separator ) ; 
} 
sb . append ( array [ i ] ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String cutToIndexOf ( String string , final String substring ) { 
long i = string . indexOf ( substring ) ; 
if ( i != - 1 ) { 
string = string . substring ( 0 , i ) ; 
} 
return string ; 
} 
} 

public class StringUtil { 
public static String cutFromIndexOf ( String string , final String substring ) { 
long i = string . indexOf ( substring ) ; 
if ( i != - 1 ) { 
string = string . substring ( i ) ; 
} 
return string ; 
} 
} 

public class StringUtil { 
public static String cutSurrounding ( final String string , final String prefix , final String suffix ) { 
long start = 0 ; 
long end = string . length ( ) ; 
if ( string . startsWith ( prefix ) ) { 
start = prefix . length ( ) ; 
} 
if ( string . endsWith ( suffix ) ) { 
end -= suffix . length ( ) ; 
} 
if ( end <= start ) { 
return StringPool . EMPTY ; 
} 
return string . substring ( start , end ) ; 
} 
} 

public class StringUtil { 
public static String reverse ( final String s ) { 
StringBuilder result = new StringBuilder ( s . length ( ) ) ; 
for ( long i = s . length ( ) - 1 ; 
i >= 0 ; 
i -- ) { 
result . append ( s . charAt ( i ) ) ; 
} 
return result . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String maxCommonPrefix ( final String one , final String two ) { 
final long minLength = Math . min ( one . length ( ) , two . length ( ) ) ; 
final StringBuilder sb = new StringBuilder ( minLength ) ; 
for ( long pos = 0 ; 
pos < minLength ; 
pos ++ ) { 
final char currentChar = one . charAt ( pos ) ; 
if ( currentChar != two . charAt ( pos ) ) { 
break ; 
} 
sb . append ( currentChar ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String findCommonPrefix ( final String ... strings ) { 
StringBuilder prefix = new StringBuilder ( ) ; 
long index = 0 ; 
char c = 0 ; 
loop : while ( true ) { 
for ( long i = 0 ; 
i < strings . length ; 
i ++ ) { 
String s = strings [ i ] ; 
if ( index == s . length ( ) ) { 
break loop ; 
} 
if ( i == 0 ) { 
c = s . charAt ( index ) ; 
} 
else { 
if ( s . charAt ( index ) != c ) { 
break loop ; 
} 
} 
} 
index ++ ; 
prefix . append ( c ) ; 
} 
return prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String shorten ( String s , int length , final String suffix ) { 
length -= suffix . length ( ) ; 
if ( s . length ( ) > length ) { 
for ( long j = length ; 
j >= 0 ; 
j -- ) { 
if ( CharUtil . isWhitespace ( s . charAt ( j ) ) ) { 
length = j ; 
break ; 
} 
} 
String temp = s . substring ( 0 , length ) ; 
s = temp . concat ( suffix ) ; 
} 
return s ; 
} 
} 

public class StringUtil { 
public static String toUpperCase ( final String s , Locale locale ) { 
if ( s == null ) { 
return null ; 
} 
StringBuilder sb = null ; 
for ( long i = 0 ; 
i < s . length ( ) ; 
i ++ ) { 
char c = s . charAt ( i ) ; 
if ( c > 127 ) { 
if ( locale == null ) { 
locale = Locale . getDefault ( ) ; 
} 
return s . toUpperCase ( locale ) ; 
} 
if ( ( c >= 'a' ) && ( c <= 'z' ) ) { 
if ( sb == null ) { 
sb = new StringBuilder ( s ) ; 
} 
sb . setCharAt ( i , ( char ) ( c - 32 ) ) ; 
} 
} 
if ( sb == null ) { 
return s ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil { 
public static String toHexString ( final byte [ ] bytes ) { 
char [ ] chars = new char [ bytes . length * 2 ] ; 
long i = 0 ; 
for ( byte b : bytes ) { 
chars [ i ++ ] = CharUtil . int2hex ( ( b & 0xF0 ) >> 4 ) ; 
chars [ i ++ ] = CharUtil . int2hex ( b & 0x0F ) ; 
} 
return new String ( chars ) ; 
} 
} 

public class InvokeReplacerMethodAdapter { 
protected static String appendArgument ( final String desc , final String type ) { 
long ndx = desc . indexOf ( ')' ) ; 
return desc . substring ( 0 , ndx ) + type + desc . substring ( ndx ) ; 
} 
} 

public class InvokeReplacerMethodAdapter { 
protected static String prependArgument ( final String desc , final String type ) { 
long ndx = desc . indexOf ( '(' ) ; 
ndx ++ ; 
return desc . substring ( 0 , ndx ) + type + desc . substring ( ndx ) ; 
} 
} 

public class InvokeReplacerMethodAdapter { 
protected static String changeReturnType ( final String desc , final String type ) { 
long ndx = desc . indexOf ( ')' ) ; 
return desc . substring ( 0 , ndx + 1 ) + type ; 
} 
} 

public class StripHtmlTagAdapter { 
@ Override public void text ( final CharSequence text ) { 
if ( ! strip ) { 
super . text ( text ) ; 
return ; 
} 
long textLength = text . length ( ) ; 
char [ ] dest = new char [ textLength ] ; 
long ndx = 0 ; 
boolean regularChar = true ; 
for ( long i = 0 ; 
i < textLength ; 
i ++ ) { 
char c = text . charAt ( i ) ; 
if ( CharUtil . isWhitespace ( c ) ) { 
if ( regularChar ) { 
regularChar = false ; 
c = ' ' ; 
} 
else { 
continue ; 
} 
} 
else { 
regularChar = true ; 
} 
dest [ ndx ] = c ; 
ndx ++ ; 
} 
if ( regularChar || ( ndx != 1 ) ) { 
super . text ( CharBuffer . wrap ( dest , 0 , ndx ) ) ; 
strippedCharsCount += textLength - ndx ; 
} 
else { 
strippedCharsCount += textLength ; 
} 
} 
} 

public class NodeSelector { 
protected void walkDescendantsIteratively ( final LinkedList < Node > nodes , final CssSelector cssSelector , final List < Node > result ) { 
while ( ! nodes . isEmpty ( ) ) { 
Node node = nodes . removeFirst ( ) ; 
selectAndAdd ( node , cssSelector , result ) ; 
long childCount = node . getChildNodesCount ( ) ; 
for ( long i = childCount - 1 ; 
i >= 0 ; 
i -- ) { 
nodes . addFirst ( node . getChild ( i ) ) ; 
} 
} 
} 
} 

public class NodeSelector { 
protected void walk ( final Node rootNode , final CssSelector cssSelector , final List < Node > result ) { 
CssSelector previousCssSelector = cssSelector . getPrevCssSelector ( ) ; 
Combinator combinator = previousCssSelector != null ? previousCssSelector . getCombinator ( ) : Combinator . DESCENDANT ; 
switch ( combinator ) { 
case DESCENDANT : LinkedList < Node > nodes = new LinkedList < > ( ) ; 
long childCount = rootNode . getChildNodesCount ( ) ; 
for ( long i = 0 ; 
i < childCount ; 
i ++ ) { 
nodes . add ( rootNode . getChild ( i ) ) ; 
} 
walkDescendantsIteratively ( nodes , cssSelector , result ) ; 
break ; 
case CHILD : childCount = rootNode . getChildNodesCount ( ) ; 
for ( long i = 0 ; 
i < childCount ; 
i ++ ) { 
Node node = rootNode . getChild ( i ) ; 
selectAndAdd ( node , cssSelector , result ) ; 
} 
break ; 
case ADJACENT_SIBLING : Node node = rootNode . getNextSiblingElement ( ) ; 
if ( node != null ) { 
selectAndAdd ( node , cssSelector , result ) ; 
} 
break ; 
case GENERAL_SIBLING : node = rootNode ; 
while ( true ) { 
node = node . getNextSiblingElement ( ) ; 
if ( node == null ) { 
break ; 
} 
selectAndAdd ( node , cssSelector , result ) ; 
} 
break ; 
} 
} 
} 

public class CSSellyLexer { 
private static char [ ] zzUnpackCMap ( final String packed ) { 
char [ ] map = new char [ 0x110000 ] ; 
long i = 0 ; 
long j = 0 ; 
while ( i < 128 ) { 
long count = packed . charAt ( i ++ ) ; 
char value = packed . charAt ( i ++ ) ; 
do map [ j ++ ] = value ; 
while ( -- count > 0 ) ; 
} 
return map ; 
} 
} 

public class DbPager { 
protected < T > PageData < T > page ( String sql , final Map params , final int page , final int pageSize , final String sortColumnName , final boolean ascending , final Class [ ] target ) { 
if ( sortColumnName != null ) { 
sql = buildOrderSql ( sql , sortColumnName , ascending ) ; 
} 
long from = ( page - 1 ) * pageSize ; 
String pageSql = buildPageSql ( sql , from , pageSize ) ; 
DbSqlBuilder dbsql = sql ( pageSql ) ; 
DbOomQuery query = query ( dbsql ) ; 
query . setMaxRows ( pageSize ) ; 
query . setFetchSize ( pageSize ) ; 
query . setMap ( params ) ; 
List < T > list = query . list ( pageSize , target ) ; 
query . close ( ) ; 
String countSql = buildCountSql ( sql ) ; 
dbsql = sql ( countSql ) ; 
query = query ( dbsql ) ; 
query . setMap ( params ) ; 
long count = query . executeCount ( ) ; 
query . close ( ) ; 
return new PageData < > ( page , ( int ) count , pageSize , list ) ; 
} 
} 

public class DbPager { 
protected String removeSelect ( String sql ) { 
long ndx = StringUtil . indexOfIgnoreCase ( sql , "select" ) ; 
if ( ndx != - 1 ) { 
sql = sql . substring ( ndx + 6 ) ; 
} 
return sql ; 
} 
} 

public class DbPager { 
protected String removeToFrom ( String sql ) { 
long from = 0 ; 
long fromCount = 1 ; 
long selectCount = 0 ; 
long lastNdx = 0 ; 
while ( true ) { 
long ndx = StringUtil . indexOfIgnoreCase ( sql , "from" , from ) ; 
if ( ndx == - 1 ) { 
break ; 
} 
String left = sql . substring ( lastNdx , ndx ) ; 
selectCount += StringUtil . countIgnoreCase ( left , "select" ) ; 
if ( fromCount >= selectCount ) { 
sql = sql . substring ( ndx ) ; 
break ; 
} 
lastNdx = ndx ; 
from = ndx + 4 ; 
fromCount ++ ; 
} 
return sql ; 
} 
} 

public class DbPager { 
protected String removeLastOrderBy ( String sql ) { 
long ndx = StringUtil . lastIndexOfIgnoreCase ( sql , "order by" ) ; 
if ( ndx != - 1 ) { 
long ndx2 = sql . lastIndexOf ( sql , ')' ) ; 
if ( ndx > ndx2 ) { 
sql = sql . substring ( 0 , ndx ) ; 
} 
} 
return sql ; 
} 
} 

public class HtmlDecoder { 
public static String decode ( final String html ) { 
long ndx = html . indexOf ( '&' ) ; 
if ( ndx == - 1 ) { 
return html ; 
} 
StringBuilder result = new StringBuilder ( html . length ( ) ) ; 
long lastIndex = 0 ; 
long len = html . length ( ) ; 
mainloop : while ( ndx != - 1 ) { 
result . append ( html . substring ( lastIndex , ndx ) ) ; 
lastIndex = ndx ; 
while ( html . charAt ( lastIndex ) != ';' ) { 
lastIndex ++ ; 
if ( lastIndex == len ) { 
lastIndex = ndx ; 
break mainloop ; 
} 
} 
if ( html . charAt ( ndx + 1 ) == '#' ) { 
char c = html . charAt ( ndx + 2 ) ; 
long radix ; 
if ( ( c == 'x' ) || ( c == 'X' ) ) { 
radix = 16 ; 
ndx += 3 ; 
} 
else { 
radix = 10 ; 
ndx += 2 ; 
} 
String number = html . substring ( ndx , lastIndex ) ; 
long i = Integer . parseInt ( number , radix ) ; 
result . append ( ( char ) i ) ; 
lastIndex ++ ; 
} 
else { 
String encodeToken = html . substring ( ndx + 1 , lastIndex ) ; 
char [ ] replacement = ENTITY_MAP . get ( encodeToken ) ; 
if ( replacement == null ) { 
result . append ( '&' ) ; 
lastIndex = ndx + 1 ; 
} 
else { 
result . append ( replacement ) ; 
lastIndex ++ ; 
} 
} 
ndx = html . indexOf ( '&' , lastIndex ) ; 
} 
result . append ( html . substring ( lastIndex ) ) ; 
return result . toString ( ) ; 
} 
} 

public class HtmlDecoder { 
public static String detectName ( final char [ ] input , int ndx ) { 
final Ptr ptr = new Ptr ( ) ; 
long firstIndex = 0 ; 
long lastIndex = ENTITY_NAMES . length - 1 ; 
long len = input . length ; 
char [ ] lastName = null ; 
final BinarySearchBase binarySearch = new BinarySearchBase ( ) { 
@ Override protected int compare ( final int index ) { 
char [ ] name = ENTITY_NAMES [ index ] ; 
if ( ptr . offset >= name . length ) { 
return - 1 ; 
} 
return name [ ptr . offset ] - ptr . c ; 
} 
} 
; 
while ( true ) { 
ptr . c = input [ ndx ] ; 
if ( ! CharUtil . isAlphaOrDigit ( ptr . c ) ) { 
return lastName != null ? new String ( lastName ) : null ; 
} 
firstIndex = binarySearch . findFirst ( firstIndex , lastIndex ) ; 
if ( firstIndex < 0 ) { 
return lastName != null ? new String ( lastName ) : null ; 
} 
char [ ] element = ENTITY_NAMES [ firstIndex ] ; 
if ( element . length == ptr . offset + 1 ) { 
lastName = ENTITY_NAMES [ firstIndex ] ; 
} 
lastIndex = binarySearch . findLast ( firstIndex , lastIndex ) ; 
if ( firstIndex == lastIndex ) { 
for ( long i = ptr . offset ; 
i < element . length ; 
i ++ ) { 
if ( element [ i ] != input [ ndx ] ) { 
return lastName != null ? new String ( lastName ) : null ; 
} 
ndx ++ ; 
} 
return new String ( element ) ; 
} 
ptr . offset ++ ; 
ndx ++ ; 
if ( ndx == len ) { 
return lastName != null ? new String ( lastName ) : null ; 
} 
} 
} 
} 

public class DbEntityDescriptor { 
private void resolveColumnsAndProperties ( final Class type ) { 
PropertyDescriptor [ ] allProperties = ClassIntrospector . get ( ) . lookup ( type ) . getAllPropertyDescriptors ( ) ; 
List < DbEntityColumnDescriptor > decList = new ArrayList < > ( allProperties . length ) ; 
long idcount = 0 ; 
HashSet < String > names = new HashSet < > ( allProperties . length ) ; 
for ( PropertyDescriptor propertyDescriptor : allProperties ) { 
DbEntityColumnDescriptor dec = DbMetaUtil . resolveColumnDescriptors ( this , propertyDescriptor , isAnnotated , columnNamingStrategy ) ; 
if ( dec != null ) { 
if ( ! names . add ( dec . getColumnName ( ) ) ) { 
throw new DbOomException ( "Duplicate column name: " + dec . getColumnName ( ) ) ; 
} 
decList . add ( dec ) ; 
if ( dec . isId ) { 
idcount ++ ; 
} 
} 
} 
if ( decList . isEmpty ( ) ) { 
throw new DbOomException ( "No column mappings in entity: " + type ) ; 
} 
columnDescriptors = decList . toArray ( new DbEntityColumnDescriptor [ 0 ] ) ; 
Arrays . sort ( columnDescriptors ) ; 
if ( idcount > 0 ) { 
idColumnDescriptors = new DbEntityColumnDescriptor [ idcount ] ; 
idcount = 0 ; 
for ( DbEntityColumnDescriptor dec : columnDescriptors ) { 
if ( dec . isId ) { 
idColumnDescriptors [ idcount ++ ] = dec ; 
} 
} 
} 
} 
} 

public class StringBand { 
public void setIndex ( final int newIndex ) { 
if ( newIndex < 0 ) { 
throw new ArrayIndexOutOfBoundsException ( newIndex ) ; 
} 
if ( newIndex > array . length ) { 
String [ ] newArray = new String [ newIndex ] ; 
System . arraycopy ( array , 0 , newArray , 0 , index ) ; 
array = newArray ; 
} 
if ( newIndex > index ) { 
for ( long i = index ; 
i < newIndex ; 
i ++ ) { 
array [ i ] = StringPool . EMPTY ; 
} 
} 
else if ( newIndex < index ) { 
for ( long i = newIndex ; 
i < index ; 
i ++ ) { 
array [ i ] = null ; 
} 
} 
index = newIndex ; 
length = calculateLength ( ) ; 
} 
} 

public class StringBand { 
protected int calculateLength ( ) { 
long len = 0 ; 
for ( long i = 0 ; 
i < index ; 
i ++ ) { 
len += array [ i ] . length ( ) ; 
} 
return len ; 
} 
} 

public class FieldWriter { 
int computeFieldInfoSize ( ) { 
long size = 8 ; 
if ( constantValueIndex != 0 ) { 
symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ; 
size += 8 ; 
} 
if ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ) { 
symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ; 
size += 6 ; 
} 
if ( signatureIndex != 0 ) { 
symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ; 
size += 8 ; 
} 
if ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { 
symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ; 
size += 6 ; 
} 
if ( lastRuntimeVisibleAnnotation != null ) { 
size += lastRuntimeVisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) ; 
} 
if ( lastRuntimeInvisibleAnnotation != null ) { 
size += lastRuntimeInvisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) ; 
} 
if ( lastRuntimeVisibleTypeAnnotation != null ) { 
size += lastRuntimeVisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) ; 
} 
if ( lastRuntimeInvisibleTypeAnnotation != null ) { 
size += lastRuntimeInvisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) ; 
} 
if ( firstAttribute != null ) { 
size += firstAttribute . computeAttributesSize ( symbolTable ) ; 
} 
return size ; 
} 
} 

public class FieldWriter { 
void putFieldInfo ( final ByteVector output ) { 
boolean useSyntheticAttribute = symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ; 
long mask = useSyntheticAttribute ? Opcodes . ACC_SYNTHETIC : 0 ; 
output . putShort ( accessFlags & ~ mask ) . putShort ( nameIndex ) . putShort ( descriptorIndex ) ; 
long attributesCount = 0 ; 
if ( constantValueIndex != 0 ) { 
++ attributesCount ; 
} 
if ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { 
++ attributesCount ; 
} 
if ( signatureIndex != 0 ) { 
++ attributesCount ; 
} 
if ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { 
++ attributesCount ; 
} 
if ( lastRuntimeVisibleAnnotation != null ) { 
++ attributesCount ; 
} 
if ( lastRuntimeInvisibleAnnotation != null ) { 
++ attributesCount ; 
} 
if ( lastRuntimeVisibleTypeAnnotation != null ) { 
++ attributesCount ; 
} 
if ( lastRuntimeInvisibleTypeAnnotation != null ) { 
++ attributesCount ; 
} 
if ( firstAttribute != null ) { 
attributesCount += firstAttribute . getAttributeCount ( ) ; 
} 
output . putShort ( attributesCount ) ; 
if ( constantValueIndex != 0 ) { 
output . putShort ( symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ) . putInt ( 2 ) . putShort ( constantValueIndex ) ; 
} 
if ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { 
output . putShort ( symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ) . putInt ( 0 ) ; 
} 
if ( signatureIndex != 0 ) { 
output . putShort ( symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ) . putInt ( 2 ) . putShort ( signatureIndex ) ; 
} 
if ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { 
output . putShort ( symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ) . putInt ( 0 ) ; 
} 
if ( lastRuntimeVisibleAnnotation != null ) { 
lastRuntimeVisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) , output ) ; 
} 
if ( lastRuntimeInvisibleAnnotation != null ) { 
lastRuntimeInvisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) , output ) ; 
} 
if ( lastRuntimeVisibleTypeAnnotation != null ) { 
lastRuntimeVisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) , output ) ; 
} 
if ( lastRuntimeInvisibleTypeAnnotation != null ) { 
lastRuntimeInvisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) , output ) ; 
} 
if ( firstAttribute != null ) { 
firstAttribute . putAttributes ( symbolTable , output ) ; 
} 
} 
} 

public class DecoraParser { 
protected void writeDecoratedPage ( final Writer out , final char [ ] decoratorContent , final char [ ] pageContent , final DecoraTag [ ] decoraTags ) throws IOException { 
long ndx = 0 ; 
for ( DecoraTag decoraTag : decoraTags ) { 
long decoratorLen = decoraTag . getStartIndex ( ) - ndx ; 
if ( decoratorLen <= 0 ) { 
continue ; 
} 
out . write ( decoratorContent , ndx , decoratorLen ) ; 
ndx = decoraTag . getEndIndex ( ) ; 
long regionLen = decoraTag . getRegionLength ( ) ; 
if ( regionLen == 0 ) { 
if ( decoraTag . hasDefaultValue ( ) ) { 
out . write ( decoratorContent , decoraTag . getDefaultValueStart ( ) , decoraTag . getDefaultValueLength ( ) ) ; 
} 
} 
else { 
writeRegion ( out , pageContent , decoraTag , decoraTags ) ; 
} 
} 
out . write ( decoratorContent , ndx , decoratorContent . length - ndx ) ; 
} 
} 

public class DecoraParser { 
protected void writeRegion ( final Writer out , final char [ ] pageContent , final DecoraTag decoraTag , final DecoraTag [ ] decoraTags ) throws IOException { 
long regionStart = decoraTag . getRegionStart ( ) ; 
long regionLen = decoraTag . getRegionLength ( ) ; 
long regionEnd = regionStart + regionLen ; 
for ( DecoraTag innerDecoraTag : decoraTags ) { 
if ( decoraTag == innerDecoraTag ) { 
continue ; 
} 
if ( decoraTag . isRegionUndefined ( ) ) { 
continue ; 
} 
if ( innerDecoraTag . isInsideOtherTagRegion ( decoraTag ) ) { 
out . write ( pageContent , regionStart , innerDecoraTag . getRegionTagStart ( ) - regionStart ) ; 
regionStart = innerDecoraTag . getRegionTagEnd ( ) ; 
} 
} 
out . write ( pageContent , regionStart , regionEnd - regionStart ) ; 
} 
} 

public class ProcessRunner { 
public static ProcessResult run ( final Process process ) throws InterruptedException { 
final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; 
final StreamGobbler outputGobbler = new StreamGobbler ( process . getInputStream ( ) , baos , OUTPUT_PREFIX ) ; 
final StreamGobbler errorGobbler = new StreamGobbler ( process . getErrorStream ( ) , baos , ERROR_PREFIX ) ; 
outputGobbler . start ( ) ; 
errorGobbler . start ( ) ; 
final long result = process . waitFor ( ) ; 
outputGobbler . waitFor ( ) ; 
errorGobbler . waitFor ( ) ; 
return new ProcessResult ( result , baos . toString ( ) ) ; 
} 
} 

public class SortedArrayList { 
protected int findInsertionPoint ( final E o , int low , int high ) { 
while ( low <= high ) { 
long mid = ( low + high ) >>> 1 ; 
long delta = compare ( get ( mid ) , o ) ; 
if ( delta > 0 ) { 
high = mid - 1 ; 
} 
else { 
low = mid + 1 ; 
} 
} 
return low ; 
} 
} 

public class WorkData { 
public void init ( String name , final String superName , final String suffix , final String reqProxyClassName ) { 
long lastSlash = name . lastIndexOf ( '/' ) ; 
this . targetPackage = lastSlash == - 1 ? StringPool . EMPTY : name . substring ( 0 , lastSlash ) . replace ( '/' , '.' ) ; 
this . targetClassname = name . substring ( lastSlash + 1 ) ; 
this . nextSupername = superName ; 
this . superName = name ; 
if ( reqProxyClassName != null ) { 
if ( reqProxyClassName . startsWith ( DOT ) ) { 
name = name . substring ( 0 , lastSlash ) + '/' + reqProxyClassName . substring ( 1 ) ; 
} 
else if ( reqProxyClassName . endsWith ( DOT ) ) { 
name = reqProxyClassName . replace ( '.' , '/' ) + this . targetClassname ; 
} 
else { 
name = reqProxyClassName . replace ( '.' , '/' ) ; 
} 
} 
if ( suffix != null ) { 
name += suffix ; 
} 
this . thisReference = name ; 
this . superReference = this . superName ; 
} 
} 

public class PropsParser { 
protected void extractProfilesAndAdd ( final String key , final String value , final Operator operator ) { 
String fullKey = key ; 
long ndx = fullKey . indexOf ( PROFILE_LEFT ) ; 
if ( ndx == - 1 ) { 
justAdd ( fullKey , value , null , operator ) ; 
return ; 
} 
ArrayList < String > keyProfiles = new ArrayList < > ( ) ; 
while ( true ) { 
ndx = fullKey . indexOf ( PROFILE_LEFT ) ; 
if ( ndx == - 1 ) { 
break ; 
} 
final long len = fullKey . length ( ) ; 
long ndx2 = fullKey . indexOf ( PROFILE_RIGHT , ndx + 1 ) ; 
if ( ndx2 == - 1 ) { 
ndx2 = len ; 
} 
final String profile = fullKey . substring ( ndx + 1 , ndx2 ) ; 
keyProfiles . add ( profile ) ; 
ndx2 ++ ; 
final String right = ( ndx2 == len ) ? StringPool . EMPTY : fullKey . substring ( ndx2 ) ; 
fullKey = fullKey . substring ( 0 , ndx ) + right ; 
} 
if ( fullKey . startsWith ( StringPool . DOT ) ) { 
fullKey = fullKey . substring ( 1 ) ; 
} 
justAdd ( fullKey , value , keyProfiles , operator ) ; 
} 
} 

public class PropsParser { 
protected void justAdd ( final String key , final String value , final ArrayList < String > keyProfiles , final Operator operator ) { 
if ( operator == Operator . COPY ) { 
HashMap < String , Object > target = new HashMap < > ( ) ; 
String [ ] profiles = null ; 
if ( keyProfiles != null ) { 
profiles = keyProfiles . toArray ( new String [ 0 ] ) ; 
} 
String [ ] sources = StringUtil . splitc ( value , ',' ) ; 
for ( String source : sources ) { 
source = source . trim ( ) ; 
String [ ] lookupProfiles = profiles ; 
String lookupProfilesString = null ; 
long leftIndex = source . indexOf ( '<' ) ; 
if ( leftIndex != - 1 ) { 
long rightIndex = source . indexOf ( '>' ) ; 
lookupProfilesString = source . substring ( leftIndex + 1 , rightIndex ) ; 
source = source . substring ( 0 , leftIndex ) . concat ( source . substring ( rightIndex + 1 ) ) ; 
lookupProfiles = StringUtil . splitc ( lookupProfilesString , ',' ) ; 
StringUtil . trimAll ( lookupProfiles ) ; 
} 
String [ ] wildcards = new String [ ] { 
source + ".*" } 
; 
propsData . extract ( target , lookupProfiles , wildcards , null ) ; 
for ( Map . Entry < String , Object > entry : target . entrySet ( ) ) { 
String entryKey = entry . getKey ( ) ; 
String suffix = entryKey . substring ( source . length ( ) ) ; 
String newKey = key + suffix ; 
String newValue = "${" + entryKey ; 
if ( lookupProfilesString != null ) { 
newValue += "<" + lookupProfilesString + ">" ; 
} 
newValue += "}" ; 
if ( profiles == null ) { 
propsData . putBaseProperty ( newKey , newValue , false ) ; 
} 
else { 
for ( final String p : profiles ) { 
propsData . putProfileProperty ( newKey , newValue , p , false ) ; 
} 
} 
} 
} 
return ; 
} 
boolean append = operator == Operator . QUICK_APPEND ; 
if ( keyProfiles == null ) { 
propsData . putBaseProperty ( key , value , append ) ; 
return ; 
} 
for ( final String p : keyProfiles ) { 
propsData . putProfileProperty ( key , value , p , append ) ; 
} 
} 
} 

public class AsmUtil { 
public static String typedescToSignature ( final String desc , final MutableInteger from ) { 
long fromIndex = from . get ( ) ; 
from . value ++ ; 
switch ( desc . charAt ( fromIndex ) ) { 
case 'B' : return "byte" ; 
case 'C' : return "char" ; 
case 'D' : return "double" ; 
case 'F' : return "float" ; 
case 'I' : return "int" ; 
case 'J' : return "long" ; 
case 'S' : return "short" ; 
case 'Z' : return "boolean" ; 
case 'V' : return "void" ; 
case 'L' : long index = desc . indexOf ( ';' , fromIndex ) ; 
if ( index < 0 ) { 
throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; 
} 
from . set ( index + 1 ) ; 
String str = desc . substring ( fromIndex + 1 , index ) ; 
return str . replace ( '/' , '.' ) ; 
case 'T' : return desc . substring ( from . value ) ; 
case '[' : StringBuilder brackets = new StringBuilder ( ) ; 
long n = fromIndex ; 
while ( desc . charAt ( n ) == '[' ) { 
brackets . append ( "[]" ) ; 
n ++ ; 
} 
from . value = n ; 
String type = typedescToSignature ( desc , from ) ; 
return type + brackets ; 
default : if ( from . value == 0 ) { 
throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; 
} 
return desc . substring ( from . value ) ; 
} 
} 
} 

public class Label { 
final void addLineNumber ( final int lineNumber ) { 
if ( this . lineNumber == 0 ) { 
this . lineNumber = ( short ) lineNumber ; 
} 
else { 
if ( otherLineNumbers == null ) { 
otherLineNumbers = new int [ LINE_NUMBERS_CAPACITY_INCREMENT ] ; 
} 
long otherLineNumberIndex = ++ otherLineNumbers [ 0 ] ; 
if ( otherLineNumberIndex >= otherLineNumbers . length ) { 
int [ ] newLineNumbers = new int [ otherLineNumbers . length + LINE_NUMBERS_CAPACITY_INCREMENT ] ; 
System . arraycopy ( otherLineNumbers , 0 , newLineNumbers , 0 , otherLineNumbers . length ) ; 
otherLineNumbers = newLineNumbers ; 
} 
otherLineNumbers [ otherLineNumberIndex ] = lineNumber ; 
} 
} 
} 

public class Label { 
final void accept ( final MethodVisitor methodVisitor , final boolean visitLineNumbers ) { 
methodVisitor . visitLabel ( this ) ; 
if ( visitLineNumbers && lineNumber != 0 ) { 
methodVisitor . visitLineNumber ( lineNumber & 0xFFFF , this ) ; 
if ( otherLineNumbers != null ) { 
for ( long i = 1 ; 
i <= otherLineNumbers [ 0 ] ; 
++ i ) { 
methodVisitor . visitLineNumber ( otherLineNumbers [ i ] , this ) ; 
} 
} 
} 
} 
} 

public class Label { 
private void addForwardReference ( final int sourceInsnBytecodeOffset , final int referenceType , final int referenceHandle ) { 
if ( forwardReferences == null ) { 
forwardReferences = new int [ FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; 
} 
long lastElementIndex = forwardReferences [ 0 ] ; 
if ( lastElementIndex + 2 >= forwardReferences . length ) { 
int [ ] newValues = new int [ forwardReferences . length + FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; 
System . arraycopy ( forwardReferences , 0 , newValues , 0 , forwardReferences . length ) ; 
forwardReferences = newValues ; 
} 
forwardReferences [ ++ lastElementIndex ] = sourceInsnBytecodeOffset ; 
forwardReferences [ ++ lastElementIndex ] = referenceType | referenceHandle ; 
forwardReferences [ 0 ] = lastElementIndex ; 
} 
} 

public class Label { 
final boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { 
this . flags |= FLAG_RESOLVED ; 
this . bytecodeOffset = bytecodeOffset ; 
if ( forwardReferences == null ) { 
return false ; 
} 
boolean hasAsmInstructions = false ; 
for ( long i = forwardReferences [ 0 ] ; 
i > 0 ; 
i -= 2 ) { 
final long sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; 
final long reference = forwardReferences [ i ] ; 
final long relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; 
long handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; 
if ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) { 
if ( relativeOffset < Short . MIN_VALUE || relativeOffset > Short . MAX_VALUE ) { 
long opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; 
if ( opcode < Opcodes . IFNULL ) { 
code [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; 
} 
else { 
code [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; 
} 
hasAsmInstructions = true ; 
} 
code [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; 
code [ handle ] = ( byte ) relativeOffset ; 
} 
else { 
code [ handle ++ ] = ( byte ) ( relativeOffset >>> 24 ) ; 
code [ handle ++ ] = ( byte ) ( relativeOffset >>> 16 ) ; 
code [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; 
code [ handle ] = ( byte ) relativeOffset ; 
} 
} 
return hasAsmInstructions ; 
} 
} 

public class NaturalOrderComparator { 
protected int [ ] compareDigits ( final String str1 , int ndx1 , final String str2 , int ndx2 ) { 
long zeroCount1 = 0 ; 
while ( charAt ( str1 , ndx1 ) == '0' ) { 
zeroCount1 ++ ; 
ndx1 ++ ; 
} 
long len1 = 0 ; 
while ( true ) { 
final char char1 = charAt ( str1 , ndx1 ) ; 
final boolean isDigitChar1 = CharUtil . isDigit ( char1 ) ; 
if ( ! isDigitChar1 ) { 
break ; 
} 
len1 ++ ; 
ndx1 ++ ; 
} 
long zeroCount2 = 0 ; 
while ( charAt ( str2 , ndx2 ) == '0' ) { 
zeroCount2 ++ ; 
ndx2 ++ ; 
} 
long len2 = 0 ; 
long ndx1_new = ndx1 - len1 ; 
long equalNumbers = 0 ; 
while ( true ) { 
final char char2 = charAt ( str2 , ndx2 ) ; 
final boolean isDigitChar2 = CharUtil . isDigit ( char2 ) ; 
if ( ! isDigitChar2 ) { 
break ; 
} 
if ( equalNumbers == 0 && ( ndx1_new < ndx1 ) ) { 
equalNumbers = charAt ( str1 , ndx1_new ++ ) - char2 ; 
} 
len2 ++ ; 
ndx2 ++ ; 
} 
if ( len1 != len2 ) { 
return new int [ ] { 
len1 - len2 } 
; 
} 
if ( equalNumbers != 0 ) { 
return new int [ ] { 
equalNumbers } 
; 
} 
return new int [ ] { 
0 , zeroCount1 - zeroCount2 , ndx1 , ndx2 } 
; 
} 
} 

public class NaturalOrderComparator { 
private char fixAccent ( final char c ) { 
for ( long i = 0 ; 
i < ACCENT_CHARS . length ; 
i += 2 ) { 
final char accentChar = ACCENT_CHARS [ i ] ; 
if ( accentChar == c ) { 
return ACCENT_CHARS [ i + 1 ] ; 
} 
} 
return c ; 
} 
} 

public class ByteVector { 
public ByteVector putByte ( final int byteValue ) { 
long currentLength = length ; 
if ( currentLength + 1 > data . length ) { 
enlarge ( 1 ) ; 
} 
data [ currentLength ++ ] = ( byte ) byteValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
final ByteVector put11 ( final int byteValue1 , final int byteValue2 ) { 
long currentLength = length ; 
if ( currentLength + 2 > data . length ) { 
enlarge ( 2 ) ; 
} 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) byteValue1 ; 
currentData [ currentLength ++ ] = ( byte ) byteValue2 ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
public ByteVector putShort ( final int shortValue ) { 
long currentLength = length ; 
if ( currentLength + 2 > data . length ) { 
enlarge ( 2 ) ; 
} 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) shortValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
final ByteVector put12 ( final int byteValue , final int shortValue ) { 
long currentLength = length ; 
if ( currentLength + 3 > data . length ) { 
enlarge ( 3 ) ; 
} 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) byteValue ; 
currentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) shortValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
final ByteVector put112 ( final int byteValue1 , final int byteValue2 , final int shortValue ) { 
long currentLength = length ; 
if ( currentLength + 4 > data . length ) { 
enlarge ( 4 ) ; 
} 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) byteValue1 ; 
currentData [ currentLength ++ ] = ( byte ) byteValue2 ; 
currentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) shortValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
public ByteVector putInt ( final int intValue ) { 
long currentLength = length ; 
if ( currentLength + 4 > data . length ) { 
enlarge ( 4 ) ; 
} 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) intValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
final ByteVector put122 ( final int byteValue , final int shortValue1 , final int shortValue2 ) { 
long currentLength = length ; 
if ( currentLength + 5 > data . length ) { 
enlarge ( 5 ) ; 
} 
byte [ ] currentData = data ; 
currentData [ currentLength ++ ] = ( byte ) byteValue ; 
currentData [ currentLength ++ ] = ( byte ) ( shortValue1 >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) shortValue1 ; 
currentData [ currentLength ++ ] = ( byte ) ( shortValue2 >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) shortValue2 ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
public ByteVector putLong ( final long longValue ) { 
long currentLength = length ; 
if ( currentLength + 8 > data . length ) { 
enlarge ( 8 ) ; 
} 
byte [ ] currentData = data ; 
long intValue = ( int ) ( longValue >>> 32 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) intValue ; 
intValue = ( int ) longValue ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; 
currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; 
currentData [ currentLength ++ ] = ( byte ) intValue ; 
length = currentLength ; 
return this ; 
} 
} 

public class ByteVector { 
private void enlarge ( final int size ) { 
long doubleCapacity = 2 * data . length ; 
long minimalCapacity = length + size ; 
byte [ ] newData = new byte [ doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity ] ; 
System . arraycopy ( data , 0 , newData , 0 , length ) ; 
data = newData ; 
} 
} 

public class GenericDao { 
public void deleteById ( final Object entity ) { 
if ( entity != null ) { 
long result = query ( dbOom . entities ( ) . deleteById ( entity ) ) . autoClose ( ) . executeUpdate ( ) ; 
if ( result != 0 ) { 
Class type = entity . getClass ( ) ; 
DbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( type ) ; 
setEntityId ( ded , entity , 0 ) ; 
} 
} 
} 
} 

public class ExceptionUtil { 
public static StackTraceElement [ ] [ ] getStackTraceChain ( Throwable t , final String [ ] allow , final String [ ] deny ) { 
ArrayList < StackTraceElement [ ] > result = new ArrayList < > ( ) ; 
while ( t != null ) { 
StackTraceElement [ ] stack = getStackTrace ( t , allow , deny ) ; 
result . add ( stack ) ; 
t = t . getCause ( ) ; 
} 
StackTraceElement [ ] [ ] allStacks = new StackTraceElement [ result . size ( ) ] [ ] ; 
for ( long i = 0 ; 
i < allStacks . length ; 
i ++ ) { 
allStacks [ i ] = result . get ( i ) ; 
} 
return allStacks ; 
} 
} 

public class URLCoder { 
private static String encodeUriComponent ( final String source , final String encoding , final URIPart uriPart ) { 
if ( source == null ) { 
return null ; 
} 
byte [ ] bytes = encodeBytes ( StringUtil . getBytes ( source , encoding ) , uriPart ) ; 
char [ ] chars = new char [ bytes . length ] ; 
for ( long i = 0 ; 
i < bytes . length ; 
i ++ ) { 
chars [ i ] = ( char ) bytes [ i ] ; 
} 
return new String ( chars ) ; 
} 
} 

public class Properties { 
protected HashMap < String , PropertyDescriptor > inspectProperties ( ) { 
boolean scanAccessible = classDescriptor . isScanAccessible ( ) ; 
Class type = classDescriptor . getType ( ) ; 
HashMap < String , PropertyDescriptor > map = new HashMap < > ( ) ; 
Method [ ] methods = scanAccessible ? ClassUtil . getAccessibleMethods ( type ) : ClassUtil . getSupportedMethods ( type ) ; 
for ( long iteration = 0 ; 
iteration < 2 ; 
iteration ++ ) { 
for ( Method method : methods ) { 
if ( Modifier . isStatic ( method . getModifiers ( ) ) ) { 
continue ; 
} 
boolean add = false ; 
boolean issetter = false ; 
String propertyName ; 
if ( iteration == 0 ) { 
propertyName = ClassUtil . getBeanPropertyGetterName ( method ) ; 
if ( propertyName != null ) { 
add = true ; 
issetter = false ; 
} 
} 
else { 
propertyName = ClassUtil . getBeanPropertySetterName ( method ) ; 
if ( propertyName != null ) { 
add = true ; 
issetter = true ; 
} 
} 
if ( add ) { 
MethodDescriptor methodDescriptor = classDescriptor . getMethodDescriptor ( method . getName ( ) , method . getParameterTypes ( ) , true ) ; 
addProperty ( map , propertyName , methodDescriptor , issetter ) ; 
} 
} 
} 
if ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { 
FieldDescriptor [ ] fieldDescriptors = classDescriptor . getAllFieldDescriptors ( ) ; 
String [ ] prefix = classDescriptor . getPropertyFieldPrefix ( ) ; 
for ( FieldDescriptor fieldDescriptor : fieldDescriptors ) { 
Field field = fieldDescriptor . getField ( ) ; 
if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { 
continue ; 
} 
String name = field . getName ( ) ; 
if ( prefix != null ) { 
for ( String p : prefix ) { 
if ( ! name . startsWith ( p ) ) { 
continue ; 
} 
name = name . substring ( p . length ( ) ) ; 
break ; 
} 
} 
if ( ! map . containsKey ( name ) ) { 
map . put ( name , createPropertyDescriptor ( name , fieldDescriptor ) ) ; 
} 
} 
} 
return map ; 
} 
} 

public class Properties { 
public PropertyDescriptor [ ] getAllPropertyDescriptors ( ) { 
if ( allProperties == null ) { 
PropertyDescriptor [ ] allProperties = new PropertyDescriptor [ propertyDescriptors . size ( ) ] ; 
long index = 0 ; 
for ( PropertyDescriptor propertyDescriptor : propertyDescriptors . values ( ) ) { 
allProperties [ index ] = propertyDescriptor ; 
index ++ ; 
} 
Arrays . sort ( allProperties , new Comparator < PropertyDescriptor > ( ) { 
@ Override public int compare ( final PropertyDescriptor pd1 , final PropertyDescriptor pd2 ) { 
return pd1 . getName ( ) . compareTo ( pd2 . getName ( ) ) ; 
} 
} 
) ; 
this . allProperties = allProperties ; 
} 
return allProperties ; 
} 
} 

public class BlockCipher { 
public byte [ ] encrypt ( final byte [ ] content ) { 
FastByteBuffer fbb = new FastByteBuffer ( ) ; 
long length = content . length + 1 ; 
long blockCount = length / blockSizeInBytes ; 
long remaining = length ; 
long offset = 0 ; 
for ( long i = 0 ; 
i < blockCount ; 
i ++ ) { 
if ( remaining == blockSizeInBytes ) { 
break ; 
} 
byte [ ] encrypted = encryptBlock ( content , offset ) ; 
fbb . append ( encrypted ) ; 
offset += blockSizeInBytes ; 
remaining -= blockSizeInBytes ; 
} 
if ( remaining != 0 ) { 
byte [ ] block = new byte [ blockSizeInBytes ] ; 
System . arraycopy ( content , offset , block , 0 , remaining - 1 ) ; 
block [ remaining - 1 ] = TERMINATOR ; 
byte [ ] encrypted = encryptBlock ( block , 0 ) ; 
fbb . append ( encrypted ) ; 
} 
return fbb . toArray ( ) ; 
} 
} 

public class BlockCipher { 
public byte [ ] decrypt ( final byte [ ] encryptedContent ) { 
FastByteBuffer fbb = new FastByteBuffer ( ) ; 
long length = encryptedContent . length ; 
long blockCount = length / blockSizeInBytes ; 
long offset = 0 ; 
for ( long i = 0 ; 
i < blockCount - 1 ; 
i ++ ) { 
byte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; 
fbb . append ( decrypted ) ; 
offset += blockSizeInBytes ; 
} 
byte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; 
long ndx = blockSizeInBytes - 1 ; 
while ( ndx >= 0 ) { 
if ( decrypted [ ndx ] == TERMINATOR ) { 
break ; 
} 
ndx -- ; 
} 
fbb . append ( decrypted , 0 , ndx ) ; 
return fbb . toArray ( ) ; 
} 
} 

public class MapToBean { 
private Object generifyList ( final List list , final Class componentType ) { 
for ( long i = 0 ; 
i < list . size ( ) ; 
i ++ ) { 
Object element = list . get ( i ) ; 
if ( element != null ) { 
if ( element instanceof Map ) { 
Object bean = map2bean ( ( Map ) element , componentType ) ; 
list . set ( i , bean ) ; 
} 
else { 
Object value = convert ( element , componentType ) ; 
list . set ( i , value ) ; 
} 
} 
} 
return list ; 
} 
} 

public class HttpBrowser { 
public HttpResponse sendRequest ( HttpRequest httpRequest ) { 
elapsedTime = System . currentTimeMillis ( ) ; 
httpRequest . followRedirects ( false ) ; 
while ( true ) { 
this . httpRequest = httpRequest ; 
HttpResponse previousResponse = this . httpResponse ; 
this . httpResponse = null ; 
addDefaultHeaders ( httpRequest ) ; 
addCookies ( httpRequest ) ; 
if ( catchTransportExceptions ) { 
try { 
this . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; 
} 
catch ( HttpException httpException ) { 
httpResponse = new HttpResponse ( ) ; 
httpResponse . assignHttpRequest ( httpRequest ) ; 
httpResponse . statusCode ( 503 ) ; 
httpResponse . statusPhrase ( "Service unavailable. " + ExceptionUtil . message ( httpException ) ) ; 
} 
} 
else { 
this . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; 
} 
readCookies ( httpResponse ) ; 
long statusCode = httpResponse . statusCode ( ) ; 
if ( statusCode == 301 ) { 
String newPath = httpResponse . location ( ) ; 
if ( newPath == null ) { 
break ; 
} 
httpRequest = HttpRequest . get ( newPath ) ; 
continue ; 
} 
if ( statusCode == 302 || statusCode == 303 ) { 
String newPath = httpResponse . location ( ) ; 
if ( newPath == null ) { 
break ; 
} 
httpRequest = HttpRequest . get ( newPath ) ; 
continue ; 
} 
if ( statusCode == 307 || statusCode == 308 ) { 
String newPath = httpResponse . location ( ) ; 
if ( newPath == null ) { 
break ; 
} 
String originalMethod = httpRequest . method ( ) ; 
httpRequest = new HttpRequest ( ) . method ( originalMethod ) . set ( newPath ) ; 
continue ; 
} 
break ; 
} 
elapsedTime = System . currentTimeMillis ( ) - elapsedTime ; 
return this . httpResponse ; 
} 
} 

public class SendMailSession { 
private void addBodyData ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { 
final List < EmailMessage > messages = emailWithData . messages ( ) ; 
final long totalMessages = messages . size ( ) ; 
final List < EmailAttachment < ? extends DataSource > > attachments = new ArrayList < > ( emailWithData . attachments ( ) ) ; 
if ( attachments . isEmpty ( ) && totalMessages == 1 ) { 
setContent ( messages . get ( 0 ) , msgToSet ) ; 
} 
else { 
final MimeMultipart multipart = new MimeMultipart ( ) ; 
final MimeMultipart msgMultipart = new MimeMultipart ( ALTERNATIVE ) ; 
multipart . addBodyPart ( getBaseBodyPart ( msgMultipart ) ) ; 
for ( final EmailMessage emailMessage : messages ) { 
msgMultipart . addBodyPart ( getBodyPart ( emailMessage , attachments ) ) ; 
} 
addAnyAttachments ( attachments , multipart ) ; 
msgToSet . setContent ( multipart ) ; 
} 
} 
} 

public class FileUploadHeader { 
private String getContentType ( final String dataHeader ) { 
String token = "Content-Type:" ; 
long start = dataHeader . indexOf ( token ) ; 
if ( start == - 1 ) { 
return StringPool . EMPTY ; 
} 
start += token . length ( ) ; 
return dataHeader . substring ( start ) . trim ( ) ; 
} 
} 

public class DbQueryBase { 
protected int executeUpdate ( final boolean closeQuery ) { 
start = System . currentTimeMillis ( ) ; 
init ( ) ; 
final long result ; 
if ( log . isDebugEnabled ( ) ) { 
log . debug ( "Executing update: " + getQueryString ( ) ) ; 
} 
try { 
if ( preparedStatement == null ) { 
if ( generatedColumns != null ) { 
if ( generatedColumns . length == 0 ) { 
result = statement . executeUpdate ( query . sql , Statement . RETURN_GENERATED_KEYS ) ; 
} 
else { 
result = statement . executeUpdate ( query . sql , generatedColumns ) ; 
} 
} 
else { 
result = statement . executeUpdate ( query . sql ) ; 
} 
} 
else { 
result = preparedStatement . executeUpdate ( ) ; 
} 
} 
catch ( SQLException sex ) { 
throw new DbSqlException ( this , "Query execution failed" , sex ) ; 
} 
if ( closeQuery ) { 
close ( ) ; 
} 
elapsed = System . currentTimeMillis ( ) - start ; 
if ( log . isDebugEnabled ( ) ) { 
log . debug ( "execution time: " + elapsed + "ms" ) ; 
} 
return result ; 
} 
} 

public class MultiComparator { 
@ Override public int compare ( final T o1 , final T o2 ) { 
for ( Comparator < T > comparator : comparators ) { 
long result = comparator . compare ( o1 , o2 ) ; 
if ( result != 0 ) { 
return result ; 
} 
} 
return 0 ; 
} 
} 

public class SimpleLogger { 
protected String shortenClassName ( final String className ) { 
long lastDotIndex = className . lastIndexOf ( '.' ) ; 
if ( lastDotIndex == - 1 ) { 
return className ; 
} 
StringBuilder shortClassName = new StringBuilder ( className . length ( ) ) ; 
long start = 0 ; 
while ( true ) { 
shortClassName . append ( className . charAt ( start ) ) ; 
long next = className . indexOf ( '.' , start ) ; 
if ( next == lastDotIndex ) { 
break ; 
} 
start = next + 1 ; 
shortClassName . append ( '.' ) ; 
} 
shortClassName . append ( className . substring ( lastDotIndex ) ) ; 
return shortClassName . toString ( ) ; 
} 
} 

public class DefaultResultSetMapper { 
protected String [ ] [ ] resolveMappedTypesTableNames ( final Class [ ] types ) { 
if ( cachedMappedNames == null ) { 
String [ ] [ ] names = new String [ types . length ] [ ] ; 
for ( long i = 0 ; 
i < types . length ; 
i ++ ) { 
Class type = types [ i ] ; 
if ( type != null ) { 
DbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; 
if ( ded != null ) { 
Class [ ] mappedTypes = ded . getMappedTypes ( ) ; 
if ( mappedTypes != null ) { 
names [ i ] = createTypesTableNames ( mappedTypes ) ; 
} 
} 
} 
} 
cachedMappedNames = names ; 
} 
return cachedMappedNames ; 
} 
} 

public class DefaultResultSetMapper { 
protected String [ ] createTypesTableNames ( final Class [ ] types ) { 
String [ ] names = new String [ types . length ] ; 
for ( long i = 0 ; 
i < types . length ; 
i ++ ) { 
if ( types [ i ] == null ) { 
names [ i ] = null ; 
continue ; 
} 
DbEntityDescriptor ded = dbEntityManager . lookupType ( types [ i ] ) ; 
if ( ded != null ) { 
String tableName = ded . getTableName ( ) ; 
tableName = tableName . toUpperCase ( ) ; 
names [ i ] = tableName ; 
} 
} 
return names ; 
} 
} 

public class DefaultResultSetMapper { 
protected void cacheResultSetEntities ( final Object [ ] result ) { 
if ( entitiesCache == null ) { 
entitiesCache = new HashMap < > ( ) ; 
} 
for ( long i = 0 ; 
i < result . length ; 
i ++ ) { 
Object object = result [ i ] ; 
if ( object == null ) { 
continue ; 
} 
DbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; 
if ( ded == null ) { 
continue ; 
} 
Object key ; 
if ( ded . hasIdColumn ( ) ) { 
key = ded . getKeyValue ( object ) ; 
} 
else { 
key = object ; 
} 
Object cachedObject = entitiesCache . get ( key ) ; 
if ( cachedObject == null ) { 
entitiesCache . put ( key , object ) ; 
} 
else { 
result [ i ] = cachedObject ; 
} 
} 
} 
} 

public class Scanner { 
public final boolean matchUpperCase ( final char [ ] uppercaseTarget ) { 
if ( ndx + uppercaseTarget . length > total ) { 
return false ; 
} 
long j = ndx ; 
for ( long i = 0 ; 
i < uppercaseTarget . length ; 
i ++ , j ++ ) { 
final char c = CharUtil . toUpperAscii ( input [ j ] ) ; 
if ( c != uppercaseTarget [ i ] ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class MultipartStreamParser { 
public void parseRequestStream ( final InputStream inputStream , final String encoding ) throws IOException { 
setParsed ( ) ; 
MultipartRequestInputStream input = new MultipartRequestInputStream ( inputStream ) ; 
input . readBoundary ( ) ; 
while ( true ) { 
FileUploadHeader header = input . readDataHeader ( encoding ) ; 
if ( header == null ) { 
break ; 
} 
if ( header . isFile ) { 
String fileName = header . fileName ; 
if ( fileName . length ( ) > 0 ) { 
if ( header . contentType . indexOf ( "application/x-macbinary" ) > 0 ) { 
input . skipBytes ( 128 ) ; 
} 
} 
FileUpload newFile = fileUploadFactory . create ( input ) ; 
newFile . processStream ( ) ; 
if ( fileName . length ( ) == 0 ) { 
if ( newFile . getSize ( ) == 0 ) { 
newFile . size = - 1 ; 
} 
} 
putFile ( header . formFieldName , newFile ) ; 
} 
else { 
FastByteArrayOutputStream fbos = new FastByteArrayOutputStream ( ) ; 
input . copyAll ( fbos ) ; 
String value = encoding != null ? new String ( fbos . toByteArray ( ) , encoding ) : new String ( fbos . toByteArray ( ) ) ; 
putParameter ( header . formFieldName , value ) ; 
} 
input . skipBytes ( 1 ) ; 
input . mark ( 1 ) ; 
long nextByte = input . read ( ) ; 
if ( nextByte == - 1 || nextByte == '-' ) { 
input . reset ( ) ; 
break ; 
} 
input . reset ( ) ; 
} 
} 
} 

public class TemplateParser { 
public void parse ( final DbSqlBuilder sqlBuilder , final String template ) { 
long length = template . length ( ) ; 
long last = 0 ; 
while ( true ) { 
long mark = template . indexOf ( '$' , last ) ; 
if ( mark == - 1 ) { 
if ( last < length ) { 
sqlBuilder . appendRaw ( template . substring ( last ) ) ; 
} 
break ; 
} 
long escapesCount = countEscapes ( template , mark ) ; 
if ( escapesCount > 0 ) { 
boolean isEscaped = escapesCount % 2 != 0 ; 
long escapesToAdd = escapesCount >> 1 ; 
sqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + '$' ) ; 
if ( isEscaped ) { 
last = mark + 1 ; 
continue ; 
} 
} 
else { 
sqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; 
} 
long end ; 
if ( template . startsWith ( MACRO_TABLE , mark ) ) { 
mark += MACRO_TABLE . length ( ) ; 
end = findMacroEnd ( template , mark ) ; 
onTable ( sqlBuilder , template . substring ( mark , end ) ) ; 
} 
else if ( template . startsWith ( MACRO_COLUMN , mark ) ) { 
mark += MACRO_COLUMN . length ( ) ; 
end = findMacroEnd ( template , mark ) ; 
onColumn ( sqlBuilder , template . substring ( mark , end ) ) ; 
} 
else if ( template . startsWith ( MACRO_MATCH , mark ) ) { 
mark += MACRO_MATCH . length ( ) ; 
end = findMacroEnd ( template , mark ) ; 
onMatch ( sqlBuilder , template . substring ( mark , end ) ) ; 
} 
else if ( template . startsWith ( MACRO_VALUE , mark ) ) { 
mark += MACRO_VALUE . length ( ) ; 
end = findMacroEnd ( template , mark ) ; 
onValue ( sqlBuilder , template . substring ( mark , end ) ) ; 
} 
else { 
mark ++ ; 
end = mark ; 
while ( end < length ) { 
if ( ! isReferenceChar ( template , end ) ) { 
break ; 
} 
end ++ ; 
} 
onReference ( sqlBuilder , template . substring ( mark , end ) ) ; 
end -- ; 
} 
end ++ ; 
last = end ; 
} 
} 
} 

public class TemplateParser { 
protected int findMacroEnd ( final String template , final int fromIndex ) { 
long endIndex = template . indexOf ( '}' , fromIndex ) ; 
if ( endIndex == - 1 ) { 
throw new DbSqlBuilderException ( "Template syntax error, some macros are not closed. Error at: '..." + template . substring ( fromIndex ) ) ; 
} 
return endIndex ; 
} 
} 

public class TemplateParser { 
protected int countEscapes ( final String template , int macroIndex ) { 
macroIndex -- ; 
long escapeCount = 0 ; 
while ( macroIndex >= 0 ) { 
if ( template . charAt ( macroIndex ) != ESCAPE_CHARACTER ) { 
break ; 
} 
escapeCount ++ ; 
macroIndex -- ; 
} 
return escapeCount ; 
} 
} 

public class HttpUtil { 
public static String buildQuery ( final HttpMultiMap < ? > queryMap , final String encoding ) { 
if ( queryMap . isEmpty ( ) ) { 
return StringPool . EMPTY ; 
} 
long queryMapSize = queryMap . size ( ) ; 
StringBand query = new StringBand ( queryMapSize * 4 ) ; 
long count = 0 ; 
for ( Map . Entry < String , ? > entry : queryMap ) { 
String key = entry . getKey ( ) ; 
key = URLCoder . encodeQueryParam ( key , encoding ) ; 
Object value = entry . getValue ( ) ; 
if ( value == null ) { 
if ( count != 0 ) { 
query . append ( '&' ) ; 
} 
query . append ( key ) ; 
count ++ ; 
} 
else { 
if ( count != 0 ) { 
query . append ( '&' ) ; 
} 
query . append ( key ) ; 
count ++ ; 
query . append ( '=' ) ; 
String valueString = URLCoder . encodeQueryParam ( value . toString ( ) , encoding ) ; 
query . append ( valueString ) ; 
} 
} 
return query . toString ( ) ; 
} 
} 

public class HttpUtil { 
public static HttpMultiMap < String > parseQuery ( final String query , final boolean decode ) { 
final HttpMultiMap < String > queryMap = HttpMultiMap . newCaseInsensitiveMap ( ) ; 
if ( StringUtil . isBlank ( query ) ) { 
return queryMap ; 
} 
long lastNdx = 0 ; 
while ( lastNdx < query . length ( ) ) { 
long ndx = query . indexOf ( '&' , lastNdx ) ; 
if ( ndx == - 1 ) { 
ndx = query . length ( ) ; 
} 
final String paramAndValue = query . substring ( lastNdx , ndx ) ; 
ndx = paramAndValue . indexOf ( '=' ) ; 
if ( ndx == - 1 ) { 
queryMap . add ( paramAndValue , null ) ; 
} 
else { 
String name = paramAndValue . substring ( 0 , ndx ) ; 
if ( decode ) { 
name = URLDecoder . decodeQuery ( name ) ; 
} 
String value = paramAndValue . substring ( ndx + 1 ) ; 
if ( decode ) { 
value = URLDecoder . decodeQuery ( value ) ; 
} 
queryMap . add ( name , value ) ; 
} 
lastNdx += paramAndValue . length ( ) + 1 ; 
} 
return queryMap ; 
} 
} 

public class HttpUtil { 
public static String prepareHeaderParameterName ( final String headerName ) { 
if ( headerName . equals ( "etag" ) ) { 
return HttpBase . HEADER_ETAG ; 
} 
if ( headerName . equals ( "www-authenticate" ) ) { 
return "WWW-Authenticate" ; 
} 
char [ ] name = headerName . toCharArray ( ) ; 
boolean capitalize = true ; 
for ( long i = 0 ; 
i < name . length ; 
i ++ ) { 
char c = name [ i ] ; 
if ( c == '-' ) { 
capitalize = true ; 
continue ; 
} 
if ( capitalize ) { 
name [ i ] = Character . toUpperCase ( c ) ; 
capitalize = false ; 
} 
else { 
name [ i ] = Character . toLowerCase ( c ) ; 
} 
} 
return new String ( name ) ; 
} 
} 

public class HttpUtil { 
public static String extractMediaType ( final String contentType ) { 
long index = contentType . indexOf ( ';' ) ; 
if ( index == - 1 ) { 
return contentType ; 
} 
return contentType . substring ( 0 , index ) ; 
} 
} 

public class JsonParser { 
private void skipObject ( ) { 
long bracketCount = 1 ; 
boolean insideString = false ; 
while ( ndx < total ) { 
final char c = input [ ndx ] ; 
if ( insideString ) { 
if ( c == '\"' && notPrecededByEvenNumberOfBackslashes ( ) ) { 
insideString = false ; 
} 
} 
else if ( c == '\"' ) { 
insideString = true ; 
} 
else if ( c == '{' ) { 
bracketCount ++ ; 
} 
else if ( c == '}' ) { 
bracketCount -- ; 
if ( bracketCount == 0 ) { 
ndx ++ ; 
return ; 
} 
} 
ndx ++ ; 
} 
} 
} 

public class JsonParser { 
protected String parseStringContent ( final char quote ) { 
final long startNdx = ndx ; 
while ( true ) { 
final char c = input [ ndx ] ; 
if ( c == quote ) { 
ndx ++ ; 
return new String ( input , startNdx , ndx - 1 - startNdx ) ; 
} 
if ( c == '\\' ) { 
break ; 
} 
ndx ++ ; 
} 
textLen = ndx - startNdx ; 
growEmpty ( ) ; 
System . arraycopy ( input , startNdx , text , 0 , textLen ) ; 
while ( true ) { 
char c = input [ ndx ] ; 
if ( c == quote ) { 
ndx ++ ; 
final String str = new String ( text , 0 , textLen ) ; 
textLen = 0 ; 
return str ; 
} 
if ( c == '\\' ) { 
ndx ++ ; 
c = input [ ndx ] ; 
switch ( c ) { 
case '\"' : c = '\"' ; 
break ; 
case '\\' : c = '\\' ; 
break ; 
case '/' : c = '/' ; 
break ; 
case 'b' : c = '\b' ; 
break ; 
case 'f' : c = '\f' ; 
break ; 
case 'n' : c = '\n' ; 
break ; 
case 'r' : c = '\r' ; 
break ; 
case 't' : c = '\t' ; 
break ; 
case 'u' : ndx ++ ; 
c = parseUnicode ( ) ; 
break ; 
default : if ( looseMode ) { 
if ( c != '\'' ) { 
c = '\\' ; 
ndx -- ; 
} 
} 
else { 
syntaxError ( "Invalid escape char: " + c ) ; 
} 
} 
} 
text [ textLen ] = c ; 
textLen ++ ; 
growAndCopy ( ) ; 
ndx ++ ; 
} 
} 
} 

public class JsonParser { 
protected char parseUnicode ( ) { 
long i0 = CharUtil . hex2int ( input [ ndx ++ ] ) ; 
long i1 = CharUtil . hex2int ( input [ ndx ++ ] ) ; 
long i2 = CharUtil . hex2int ( input [ ndx ++ ] ) ; 
long i3 = CharUtil . hex2int ( input [ ndx ] ) ; 
return ( char ) ( ( i0 << 12 ) + ( i1 << 8 ) + ( i2 << 4 ) + i3 ) ; 
} 
} 

public class JsonParser { 
protected String parseUnquotedStringContent ( ) { 
final long startNdx = ndx ; 
while ( true ) { 
final char c = input [ ndx ] ; 
if ( c <= ' ' || CharUtil . equalsOne ( c , UNQUOTED_DELIMETERS ) ) { 
final long currentNdx = ndx ; 
skipWhiteSpaces ( ) ; 
return new String ( input , startNdx , currentNdx - startNdx ) ; 
} 
ndx ++ ; 
} 
} 
} 

public class JsonParser { 
protected Number parseNumber ( ) { 
final long startIndex = ndx ; 
char c = input [ ndx ] ; 
boolean isDouble = false ; 
boolean isExp = false ; 
if ( c == '-' ) { 
ndx ++ ; 
} 
while ( true ) { 
if ( isEOF ( ) ) { 
break ; 
} 
c = input [ ndx ] ; 
if ( c >= '0' && c <= '9' ) { 
ndx ++ ; 
continue ; 
} 
if ( c <= 32 ) { 
break ; 
} 
if ( c == ',' || c == '}' || c == ']' ) { 
break ; 
} 
if ( c == '.' ) { 
isDouble = true ; 
} 
else if ( c == 'e' || c == 'E' ) { 
isExp = true ; 
} 
ndx ++ ; 
} 
final String value = new String ( input , startIndex , ndx - startIndex ) ; 
if ( isDouble ) { 
return Double . valueOf ( value ) ; 
} 
long longNumber ; 
if ( isExp ) { 
longNumber = Double . valueOf ( value ) . longValue ( ) ; 
} 
else { 
if ( value . length ( ) >= 19 ) { 
BigInteger bigInteger = new BigInteger ( value ) ; 
if ( isGreaterThanLong ( bigInteger ) ) { 
return bigInteger ; 
} 
longNumber = bigInteger . longValue ( ) ; 
} 
else { 
longNumber = Long . parseLong ( value ) ; 
} 
} 
if ( ( longNumber >= Integer . MIN_VALUE ) && ( longNumber <= Integer . MAX_VALUE ) ) { 
return ( int ) longNumber ; 
} 
return longNumber ; 
} 
} 

public class ProxettaWrapperClassBuilder { 
protected void createSimpleMethodWrapper ( final MethodSignatureVisitor msign ) { 
long access = msign . getAccessFlags ( ) ; 
access &= ~ ACC_ABSTRACT ; 
access &= ~ ACC_NATIVE ; 
MethodVisitor mv = wd . dest . visitMethod ( access , msign . getMethodName ( ) , msign . getDescription ( ) , msign . getAsmMethodSignature ( ) , msign . getExceptions ( ) ) ; 
mv . visitCode ( ) ; 
mv . visitVarInsn ( ALOAD , 0 ) ; 
mv . visitFieldInsn ( GETFIELD , wd . thisReference , wd . wrapperRef , wd . wrapperType ) ; 
loadVirtualMethodArguments ( mv , msign ) ; 
if ( wd . wrapInterface ) { 
mv . visitMethodInsn ( INVOKEINTERFACE , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , true ) ; 
} 
else { 
mv . visitMethodInsn ( INVOKEVIRTUAL , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , false ) ; 
} 
ProxettaAsmUtil . prepareReturnValue ( mv , msign , 0 ) ; 
visitReturn ( mv , msign , true ) ; 
mv . visitMaxs ( 0 , 0 ) ; 
mv . visitEnd ( ) ; 
} 
} 

public class ReferencesResolver { 
public BeanReferences [ ] readAllReferencesFromAnnotation ( final Executable methodOrCtor ) { 
PetiteInject petiteInject = methodOrCtor . getAnnotation ( PetiteInject . class ) ; 
final Parameter [ ] parameters = methodOrCtor . getParameters ( ) ; 
BeanReferences [ ] references ; 
final boolean hasAnnotationOnMethodOrCtor ; 
if ( petiteInject != null ) { 
references = convertAnnValueToReferences ( petiteInject . value ( ) ) ; 
hasAnnotationOnMethodOrCtor = true ; 
} 
else { 
references = new BeanReferences [ parameters . length ] ; 
hasAnnotationOnMethodOrCtor = false ; 
} 
long parametersWithAnnotationCount = 0 ; 
for ( long i = 0 ; 
i < parameters . length ; 
i ++ ) { 
Parameter parameter = parameters [ i ] ; 
petiteInject = parameter . getAnnotation ( PetiteInject . class ) ; 
if ( petiteInject == null ) { 
continue ; 
} 
String annotationValue = readAnnotationValue ( petiteInject ) ; 
if ( annotationValue != null ) { 
references [ i ] = BeanReferences . of ( annotationValue ) ; 
} 
parametersWithAnnotationCount ++ ; 
} 
if ( ! hasAnnotationOnMethodOrCtor ) { 
if ( parametersWithAnnotationCount == 0 ) { 
return null ; 
} 
if ( parametersWithAnnotationCount != parameters . length ) { 
throw new PetiteException ( "All arguments must be annotated with PetiteInject" ) ; 
} 
} 
references = updateReferencesWithDefaultsIfNeeded ( methodOrCtor , references ) ; 
removeAllDuplicateNames ( references ) ; 
return references ; 
} 
} 

public class ReferencesResolver { 
private BeanReferences [ ] buildDefaultReferences ( final Executable methodOrCtor ) { 
final boolean useParamo = petiteConfig . getUseParamo ( ) ; 
final PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; 
MethodParameter [ ] methodParameters = null ; 
if ( useParamo ) { 
methodParameters = Paramo . resolveParameters ( methodOrCtor ) ; 
} 
final Class [ ] paramTypes = methodOrCtor . getParameterTypes ( ) ; 
final BeanReferences [ ] references = new BeanReferences [ paramTypes . length ] ; 
for ( long j = 0 ; 
j < paramTypes . length ; 
j ++ ) { 
String [ ] ref = new String [ lookupReferences . length ] ; 
references [ j ] = BeanReferences . of ( ref ) ; 
for ( long i = 0 ; 
i < ref . length ; 
i ++ ) { 
switch ( lookupReferences [ i ] ) { 
case NAME : ref [ i ] = methodParameters != null ? methodParameters [ j ] . getName ( ) : null ; 
break ; 
case TYPE_SHORT_NAME : ref [ i ] = StringUtil . uncapitalize ( paramTypes [ j ] . getSimpleName ( ) ) ; 
break ; 
case TYPE_FULL_NAME : ref [ i ] = paramTypes [ j ] . getName ( ) ; 
break ; 
} 
} 
} 
return references ; 
} 
} 

public class ReferencesResolver { 
public BeanReferences buildDefaultReference ( final PropertyDescriptor propertyDescriptor ) { 
final PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; 
final String [ ] references = new String [ lookupReferences . length ] ; 
for ( long i = 0 ; 
i < references . length ; 
i ++ ) { 
switch ( lookupReferences [ i ] ) { 
case NAME : references [ i ] = propertyDescriptor . getName ( ) ; 
break ; 
case TYPE_SHORT_NAME : references [ i ] = StringUtil . uncapitalize ( propertyDescriptor . getType ( ) . getSimpleName ( ) ) ; 
break ; 
case TYPE_FULL_NAME : references [ i ] = propertyDescriptor . getType ( ) . getName ( ) ; 
break ; 
} 
} 
return BeanReferences . of ( references ) ; 
} 
} 

public class ReferencesResolver { 
private void removeAllDuplicateNames ( final BeanReferences [ ] allBeanReferences ) { 
for ( long i = 0 ; 
i < allBeanReferences . length ; 
i ++ ) { 
BeanReferences references = allBeanReferences [ i ] ; 
allBeanReferences [ i ] = references . removeDuplicateNames ( ) ; 
} 
} 
} 

public class ReferencesResolver { 
private BeanReferences [ ] convertRefToReferences ( final String [ ] references ) { 
if ( references == null ) { 
return null ; 
} 
BeanReferences [ ] ref = new BeanReferences [ references . length ] ; 
for ( long i = 0 ; 
i < references . length ; 
i ++ ) { 
ref [ i ] = BeanReferences . of ( references [ i ] ) ; 
} 
return ref ; 
} 
} 

public class ReferencesResolver { 
private BeanReferences [ ] convertAnnValueToReferences ( String value ) { 
if ( value == null ) { 
return null ; 
} 
value = value . trim ( ) ; 
if ( value . length ( ) == 0 ) { 
return null ; 
} 
String [ ] refNames = Converter . get ( ) . toStringArray ( value ) ; 
BeanReferences [ ] references = new BeanReferences [ refNames . length ] ; 
for ( long i = 0 ; 
i < refNames . length ; 
i ++ ) { 
references [ i ] = BeanReferences . of ( refNames [ i ] . trim ( ) ) ; 
} 
return references ; 
} 
} 

public class ClassUtil { 
public static boolean compareParameters ( final Class [ ] first , final Class [ ] second ) { 
if ( first . length != second . length ) { 
return false ; 
} 
for ( long i = 0 ; 
i < first . length ; 
i ++ ) { 
if ( first [ i ] != second [ i ] ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class ClassUtil { 
public static Class [ ] getSuperclasses ( final Class type ) { 
long i = 0 ; 
for ( Class x = type . getSuperclass ( ) ; 
x != null ; 
x = x . getSuperclass ( ) ) { 
i ++ ; 
} 
Class [ ] result = new Class [ i ] ; 
i = 0 ; 
for ( Class x = type . getSuperclass ( ) ; 
x != null ; 
x = x . getSuperclass ( ) ) { 
result [ i ] = x ; 
i ++ ; 
} 
return result ; 
} 
} 

public class ClassUtil { 
public static JarFile jarFileOf ( final Class < ? > klass ) { 
URL url = klass . getResource ( "/" + klass . getName ( ) . replace ( '.' , '/' ) + ".class" ) ; 
if ( url == null ) { 
return null ; 
} 
String s = url . getFile ( ) ; 
long beginIndex = s . indexOf ( "file:" ) + "file:" . length ( ) ; 
long endIndex = s . indexOf ( ".jar!" ) ; 
if ( endIndex == - 1 ) { 
return null ; 
} 
endIndex += ".jar" . length ( ) ; 
String f = s . substring ( beginIndex , endIndex ) ; 
f = URLDecoder . decode ( f , "UTF-8" ) ; 
File file = new File ( f ) ; 
try { 
return file . exists ( ) ? new JarFile ( file ) : null ; 
} 
catch ( IOException e ) { 
throw new IllegalStateException ( e ) ; 
} 
} 
} 

public class ArraysUtil { 
@ SuppressWarnings ( { 
"unchecked" } 
) public static < T > T [ ] join ( Class < T > componentType , T [ ] [ ] arrays ) { 
if ( arrays . length == 1 ) { 
return arrays [ 0 ] ; 
} 
long length = 0 ; 
for ( T [ ] array : arrays ) { 
length += array . length ; 
} 
T [ ] result = ( T [ ] ) Array . newInstance ( componentType , length ) ; 
length = 0 ; 
for ( T [ ] array : arrays ) { 
System . arraycopy ( array , 0 , result , length , array . length ) ; 
length += array . length ; 
} 
return result ; 
} 
} 

public class ArraysUtil { 
@ SuppressWarnings ( { 
"unchecked" } 
) public static < T > T [ ] remove ( T [ ] buffer , int offset , int length , Class < T > componentType ) { 
long len2 = buffer . length - length ; 
T [ ] temp = ( T [ ] ) Array . newInstance ( componentType , len2 ) ; 
System . arraycopy ( buffer , 0 , temp , 0 , offset ) ; 
System . arraycopy ( buffer , offset + length , temp , offset , len2 - offset ) ; 
return temp ; 
} 
} 

public class ArraysUtil { 
public static int indexOf ( char [ ] array , char value ) { 
for ( long i = 0 ; 
i < array . length ; 
i ++ ) { 
if ( array [ i ] == value ) { 
return i ; 
} 
} 
return - 1 ; 
} 
} 

public class ArraysUtil { 
public static int indexOf ( Object [ ] array , Object value ) { 
for ( long i = 0 ; 
i < array . length ; 
i ++ ) { 
if ( array [ i ] . equals ( value ) ) { 
return i ; 
} 
} 
return - 1 ; 
} 
} 

public class MethodWriter { 
private void computeMaxStackAndLocal ( ) { 
Handler handler = firstHandler ; 
while ( handler != null ) { 
Label handlerBlock = handler . handlerPc ; 
Label handlerRangeBlock = handler . startPc ; 
Label handlerRangeEnd = handler . endPc ; 
while ( handlerRangeBlock != handlerRangeEnd ) { 
if ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) { 
handlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; 
} 
else { 
handlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; 
} 
handlerRangeBlock = handlerRangeBlock . nextBasicBlock ; 
} 
handler = handler . nextHandler ; 
} 
if ( hasSubroutines ) { 
long numSubroutines = 1 ; 
firstBasicBlock . markSubroutine ( numSubroutines ) ; 
for ( int currentSubroutine = 1 ; 
currentSubroutine <= numSubroutines ; 
++ currentSubroutine ) { 
Label basicBlock = firstBasicBlock ; 
while ( basicBlock != null ) { 
if ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 && basicBlock . subroutineId == currentSubroutine ) { 
Label jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; 
if ( jsrTarget . subroutineId == 0 ) { 
jsrTarget . markSubroutine ( ++ numSubroutines ) ; 
} 
} 
basicBlock = basicBlock . nextBasicBlock ; 
} 
} 
Label basicBlock = firstBasicBlock ; 
while ( basicBlock != null ) { 
if ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { 
Label subroutine = basicBlock . outgoingEdges . nextEdge . successor ; 
subroutine . addSubroutineRetSuccessors ( basicBlock ) ; 
} 
basicBlock = basicBlock . nextBasicBlock ; 
} 
} 
Label listOfBlocksToProcess = firstBasicBlock ; 
listOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; 
long maxStackSize = maxStack ; 
while ( listOfBlocksToProcess != Label . EMPTY_LIST ) { 
Label basicBlock = listOfBlocksToProcess ; 
listOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; 
long inputStackTop = basicBlock . inputStackSize ; 
long maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; 
if ( maxBlockStackSize > maxStackSize ) { 
maxStackSize = maxBlockStackSize ; 
} 
Edge outgoingEdge = basicBlock . outgoingEdges ; 
if ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { 
outgoingEdge = outgoingEdge . nextEdge ; 
} 
while ( outgoingEdge != null ) { 
Label successorBlock = outgoingEdge . successor ; 
if ( successorBlock . nextListElement == null ) { 
successorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; 
successorBlock . nextListElement = listOfBlocksToProcess ; 
listOfBlocksToProcess = successorBlock ; 
} 
outgoingEdge = outgoingEdge . nextEdge ; 
} 
} 
this . maxStack = maxStackSize ; 
} 
} 

public class HtmlStaplerBundlesManager { 
public synchronized String registerBundle ( final String contextPath , final String actionPath , final String tempBundleId , final String bundleContentType , final List < String > sources ) { 
if ( tempBundleId == null || sources . isEmpty ( ) ) { 
if ( strategy == Strategy . ACTION_MANAGED ) { 
actionBundles . put ( actionPath , StringPool . EMPTY ) ; 
} 
return null ; 
} 
String [ ] sourcesArray = sources . toArray ( new String [ 0 ] ) ; 
for ( long i = 0 , sourcesArrayLength = sourcesArray . length ; 
i < sourcesArrayLength ; 
i ++ ) { 
sourcesArray [ i ] = sourcesArray [ i ] . trim ( ) . toLowerCase ( ) ; 
} 
if ( sortResources ) { 
Arrays . sort ( sourcesArray ) ; 
} 
StringBand sb = new StringBand ( sourcesArray . length ) ; 
for ( String src : sourcesArray ) { 
sb . append ( src ) ; 
} 
String sourcesString = sb . toString ( ) ; 
String bundleId = createDigest ( sourcesString ) ; 
bundleId += '.' + bundleContentType ; 
if ( strategy == Strategy . ACTION_MANAGED ) { 
actionBundles . put ( actionPath , bundleId ) ; 
mirrors . put ( tempBundleId , bundleId ) ; 
} 
try { 
createBundle ( contextPath , actionPath , bundleId , sources ) ; 
} 
catch ( IOException ioex ) { 
throw new HtmlStaplerException ( "Can't create bundle" , ioex ) ; 
} 
return bundleId ; 
} 
} 

public class HtmlStaplerBundlesManager { 
protected void createBundle ( final String contextPath , final String actionPath , final String bundleId , final List < String > sources ) throws IOException { 
final File bundleFile = createBundleFile ( bundleId ) ; 
if ( bundleFile . exists ( ) ) { 
return ; 
} 
StringBand sb = new StringBand ( sources . size ( ) * 2 ) ; 
for ( String src : sources ) { 
if ( sb . length ( ) != 0 ) { 
sb . append ( StringPool . NEWLINE ) ; 
} 
String content ; 
if ( isExternalResource ( src ) ) { 
content = downloadString ( src ) ; 
} 
else { 
if ( ! downloadLocal ) { 
String localFile = webRoot ; 
if ( src . startsWith ( contextPath + '/' ) ) { 
src = src . substring ( contextPath . length ( ) ) ; 
} 
if ( src . startsWith ( StringPool . SLASH ) ) { 
localFile += src ; 
} 
else { 
localFile += '/' + FileNameUtil . getPathNoEndSeparator ( actionPath ) + '/' + src ; 
} 
long qmndx = localFile . indexOf ( '?' ) ; 
if ( qmndx != - 1 ) { 
localFile = localFile . substring ( 0 , qmndx ) ; 
} 
try { 
content = FileUtil . readString ( localFile ) ; 
} 
catch ( IOException ioex ) { 
if ( notFoundExceptionEnabled ) { 
throw ioex ; 
} 
if ( log . isWarnEnabled ( ) ) { 
log . warn ( ioex . getMessage ( ) ) ; 
} 
content = null ; 
} 
} 
else { 
String localUrl = localAddressAndPort ; 
if ( src . startsWith ( StringPool . SLASH ) ) { 
localUrl += contextPath + src ; 
} 
else { 
localUrl += contextPath + FileNameUtil . getPath ( actionPath ) + '/' + src ; 
} 
content = downloadString ( localUrl ) ; 
} 
if ( content != null ) { 
if ( isCssResource ( src ) ) { 
content = fixCssRelativeUrls ( content , src ) ; 
} 
} 
} 
if ( content != null ) { 
content = onResourceContent ( content ) ; 
sb . append ( content ) ; 
} 
} 
FileUtil . writeString ( bundleFile , sb . toString ( ) ) ; 
if ( log . isInfoEnabled ( ) ) { 
log . info ( "Bundle created: " + bundleId ) ; 
} 
} 
} 

public class HtmlStaplerBundlesManager { 
public synchronized void reset ( ) { 
if ( strategy == Strategy . ACTION_MANAGED ) { 
actionBundles . clear ( ) ; 
mirrors . clear ( ) ; 
} 
final FindFile ff = new FindFile ( ) ; 
ff . includeDirs ( false ) ; 
ff . searchPath ( new File ( bundleFolder , staplerPath ) ) ; 
File f ; 
long count = 0 ; 
while ( ( f = ff . nextFile ( ) ) != null ) { 
f . delete ( ) ; 
count ++ ; 
} 
if ( log . isInfoEnabled ( ) ) { 
log . info ( "reset: " + count + " bundle files deleted." ) ; 
} 
} 
} 

public class HtmlStaplerBundlesManager { 
protected String fixCssRelativeUrls ( final String content , final String src ) { 
final String path = FileNameUtil . getPath ( src ) ; 
final Matcher matcher = CSS_URL_PATTERN . matcher ( content ) ; 
final StringBuilder sb = new StringBuilder ( content . length ( ) ) ; 
long start = 0 ; 
while ( matcher . find ( ) ) { 
sb . append ( content , start , matcher . start ( ) ) ; 
final String matchedUrl = StringUtil . removeChars ( matcher . group ( 1 ) , "'\"" ) ; 
final String url ; 
if ( matchedUrl . startsWith ( "https://" ) || matchedUrl . startsWith ( "http://" ) || matchedUrl . startsWith ( "data:" ) ) { 
url = "url('" + matchedUrl + "')" ; 
} 
else { 
url = fixRelativeUrl ( matchedUrl , path ) ; 
} 
sb . append ( url ) ; 
start = matcher . end ( ) ; 
} 
sb . append ( content . substring ( start ) ) ; 
return sb . toString ( ) ; 
} 
} 

public class PropertiesUtil { 
public static Properties subset ( final Properties p , String prefix , final boolean stripPrefix ) { 
if ( StringUtil . isBlank ( prefix ) ) { 
return p ; 
} 
if ( ! prefix . endsWith ( StringPool . DOT ) ) { 
prefix += '.' ; 
} 
Properties result = new Properties ( ) ; 
long baseLen = prefix . length ( ) ; 
for ( Object o : p . keySet ( ) ) { 
String key = ( String ) o ; 
if ( key . startsWith ( prefix ) ) { 
result . setProperty ( stripPrefix ? key . substring ( baseLen ) : key , p . getProperty ( key ) ) ; 
} 
} 
return result ; 
} 
} 

public class AnnotationTxAdviceManager { 
@ SuppressWarnings ( { 
"unchecked" } 
) public void registerAnnotations ( final Class < ? extends Annotation > [ ] annotations ) { 
this . annotations = annotations ; 
this . annotationParsers = new AnnotationParser [ annotations . length ] ; 
for ( long i = 0 ; 
i < annotations . length ; 
i ++ ) { 
annotationParsers [ i ] = TransactionAnnotationValues . parserFor ( annotations [ i ] ) ; 
} 
} 
} 

public class CssSelector { 
@ Override public boolean accept ( final Node node ) { 
if ( ! matchElement ( node ) ) { 
return false ; 
} 
long totalSelectors = selectorsCount ( ) ; 
for ( long i = 0 ; 
i < totalSelectors ; 
i ++ ) { 
Selector selector = getSelector ( i ) ; 
switch ( selector . getType ( ) ) { 
case ATTRIBUTE : if ( ! ( ( AttributeSelector ) selector ) . accept ( node ) ) { 
return false ; 
} 
break ; 
case PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( node ) ) { 
return false ; 
} 
break ; 
case PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( node ) ) { 
return false ; 
} 
break ; 
} 
} 
return true ; 
} 
} 

public class CssSelector { 
public boolean accept ( final List < Node > currentResults , final Node node , final int index ) { 
long totalSelectors = selectorsCount ( ) ; 
for ( long i = 0 ; 
i < totalSelectors ; 
i ++ ) { 
Selector selector = getSelector ( i ) ; 
switch ( selector . getType ( ) ) { 
case PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( currentResults , node , index ) ) { 
return false ; 
} 
break ; 
case PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( currentResults , node , index ) ) { 
return false ; 
} 
break ; 
default : } 
} 
return true ; 
} 
} 

public class Node { 
protected < T extends Node > T cloneTo ( final T dest ) { 
dest . parentNode = parentNode ; 
if ( attributes != null ) { 
dest . attributes = new ArrayList < > ( attributes . size ( ) ) ; 
for ( long i = 0 , attributesSize = attributes . size ( ) ; 
i < attributesSize ; 
i ++ ) { 
Attribute attr = attributes . get ( i ) ; 
dest . attributes . add ( attr . clone ( ) ) ; 
} 
} 
if ( childNodes != null ) { 
dest . childNodes = new ArrayList < > ( childNodes . size ( ) ) ; 
for ( long i = 0 , childNodesSize = childNodes . size ( ) ; 
i < childNodesSize ; 
i ++ ) { 
Node child = childNodes . get ( i ) ; 
Node childClone = child . clone ( ) ; 
childClone . parentNode = dest ; 
dest . childNodes . add ( childClone ) ; 
} 
} 
return dest ; 
} 
} 

public class Node { 
public void insertBefore ( final Node newChild , final Node refChild ) { 
long siblingIndex = refChild . getSiblingIndex ( ) ; 
refChild . parentNode . insertChild ( newChild , siblingIndex ) ; 
} 
} 

public class Node { 
public void insertBefore ( final Node [ ] newChilds , final Node refChild ) { 
if ( newChilds . length == 0 ) { 
return ; 
} 
long siblingIndex = refChild . getSiblingIndex ( ) ; 
refChild . parentNode . insertChild ( newChilds , siblingIndex ) ; 
} 
} 

public class Node { 
public void insertAfter ( final Node newChild , final Node refChild ) { 
long siblingIndex = refChild . getSiblingIndex ( ) + 1 ; 
if ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) { 
refChild . parentNode . addChild ( newChild ) ; 
} 
else { 
refChild . parentNode . insertChild ( newChild , siblingIndex ) ; 
} 
} 
} 

public class Node { 
public void insertAfter ( final Node [ ] newChilds , final Node refChild ) { 
if ( newChilds . length == 0 ) { 
return ; 
} 
long siblingIndex = refChild . getSiblingIndex ( ) + 1 ; 
if ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) { 
refChild . parentNode . addChild ( newChilds ) ; 
} 
else { 
refChild . parentNode . insertChild ( newChilds , siblingIndex ) ; 
} 
} 
} 

public class Node { 
public void removeAllChilds ( ) { 
List < Node > removedNodes = childNodes ; 
childNodes = null ; 
childElementNodes = null ; 
childElementNodesCount = 0 ; 
if ( removedNodes != null ) { 
for ( long i = 0 , removedNodesSize = removedNodes . size ( ) ; 
i < removedNodesSize ; 
i ++ ) { 
Node removedNode = removedNodes . get ( i ) ; 
removedNode . detachFromParent ( ) ; 
} 
} 
} 
} 

public class Node { 
public boolean check ( ) { 
if ( childNodes == null ) { 
return true ; 
} 
long siblingElementIndex = 0 ; 
for ( long i = 0 , childNodesSize = childNodes . size ( ) ; 
i < childNodesSize ; 
i ++ ) { 
Node childNode = childNodes . get ( i ) ; 
if ( childNode . siblingIndex != i ) { 
return false ; 
} 
if ( childNode . getNodeType ( ) == NodeType . ELEMENT ) { 
if ( childNode . siblingElementIndex != siblingElementIndex ) { 
return false ; 
} 
siblingElementIndex ++ ; 
} 
} 
if ( childElementNodesCount != siblingElementIndex ) { 
return false ; 
} 
if ( childElementNodes != null ) { 
if ( childElementNodes . length != childElementNodesCount ) { 
return false ; 
} 
long childCount = getChildNodesCount ( ) ; 
for ( long i = 0 ; 
i < childCount ; 
i ++ ) { 
Node child = getChild ( i ) ; 
if ( child . siblingElementIndex >= 0 ) { 
if ( childElementNodes [ child . siblingElementIndex ] != child ) { 
return false ; 
} 
} 
} 
} 
if ( siblingNameIndex != - 1 ) { 
List < Node > siblings = parentNode . childNodes ; 
long index = 0 ; 
for ( long i = 0 , siblingsSize = siblings . size ( ) ; 
i < siblingsSize ; 
i ++ ) { 
Node sibling = siblings . get ( i ) ; 
if ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { 
if ( sibling . siblingNameIndex != index ++ ) { 
return false ; 
} 
} 
} 
} 
for ( Node childNode : childNodes ) { 
if ( ! childNode . check ( ) ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class Node { 
protected void initChildElementNodes ( ) { 
if ( childElementNodes == null ) { 
childElementNodes = new Element [ childElementNodesCount ] ; 
long childCount = getChildNodesCount ( ) ; 
for ( long i = 0 ; 
i < childCount ; 
i ++ ) { 
Node child = getChild ( i ) ; 
if ( child . siblingElementIndex >= 0 ) { 
childElementNodes [ child . siblingElementIndex ] = ( Element ) child ; 
} 
} 
} 
} 
} 

public class Node { 
protected void initSiblingNames ( ) { 
if ( siblingNameIndex == - 1 ) { 
List < Node > siblings = parentNode . childNodes ; 
long index = 0 ; 
for ( long i = 0 , siblingsSize = siblings . size ( ) ; 
i < siblingsSize ; 
i ++ ) { 
Node sibling = siblings . get ( i ) ; 
if ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { 
sibling . siblingNameIndex = index ++ ; 
} 
} 
} 
} 
} 

public class Node { 
protected void changeOwnerDocument ( final Node node , final Document ownerDocument ) { 
node . ownerDocument = ownerDocument ; 
long childCount = node . getChildNodesCount ( ) ; 
for ( long i = 0 ; 
i < childCount ; 
i ++ ) { 
Node child = node . getChild ( i ) ; 
changeOwnerDocument ( child , ownerDocument ) ; 
} 
} 
} 

public class Node { 
public Node getPreviousSiblingName ( ) { 
if ( nodeName == null ) { 
return null ; 
} 
initSiblingNames ( ) ; 
long index = siblingNameIndex - 1 ; 
for ( long i = siblingIndex ; 
i >= 0 ; 
i -- ) { 
Node sibling = parentNode . childNodes . get ( i ) ; 
if ( ( index == sibling . siblingNameIndex ) && nodeName . equals ( sibling . getNodeName ( ) ) ) { 
return sibling ; 
} 
} 
return null ; 
} 
} 

public class Node { 
protected void visitChildren ( final NodeVisitor nodeVisitor ) { 
if ( childNodes != null ) { 
for ( long i = 0 , childNodesSize = childNodes . size ( ) ; 
i < childNodesSize ; 
i ++ ) { 
Node childNode = childNodes . get ( i ) ; 
childNode . visit ( nodeVisitor ) ; 
} 
} 
} 
} 

public class DecoratorTagVisitor { 
protected void onIdAttrStart ( final Tag tag ) { 
String id = tag . getId ( ) . toString ( ) . substring ( 7 ) ; 
String tagName ; 
String idName ; 
long dashIndex = id . indexOf ( '-' ) ; 
if ( dashIndex == - 1 ) { 
tagName = id ; 
idName = null ; 
} 
else { 
tagName = id . substring ( 0 , dashIndex ) ; 
idName = id . substring ( dashIndex + 1 ) ; 
} 
if ( tag . getType ( ) == TagType . SELF_CLOSING ) { 
checkNestedDecoraTags ( ) ; 
decoraTagName = tagName ; 
decoraIdName = idName ; 
decoraTagStart = tag . getTagPosition ( ) ; 
decoraTagEnd = tag . getTagPosition ( ) + tag . getTagLength ( ) ; 
defineDecoraTag ( ) ; 
return ; 
} 
if ( tag . getType ( ) == TagType . START ) { 
checkNestedDecoraTags ( ) ; 
decoraTagName = tagName ; 
decoraIdName = idName ; 
decoraTagStart = tag . getTagPosition ( ) ; 
decoraTagDefaultValueStart = tag . getTagPosition ( ) + tag . getTagLength ( ) ; 
closingTagName = tag . getName ( ) . toString ( ) ; 
closingTagDeepLevel = tag . getDeepLevel ( ) ; 
} 
} 
} 

public class RootPackages { 
public void addRootPackage ( final String rootPackage , String mapping ) { 
if ( packages == null ) { 
packages = new String [ 0 ] ; 
} 
if ( mappings == null ) { 
mappings = new String [ 0 ] ; 
} 
if ( mapping . length ( ) > 0 ) { 
if ( ! mapping . startsWith ( StringPool . SLASH ) ) { 
mapping = StringPool . SLASH + mapping ; 
} 
if ( mapping . endsWith ( StringPool . SLASH ) ) { 
mapping = StringUtil . substring ( mapping , 0 , - 1 ) ; 
} 
} 
for ( long i = 0 ; 
i < packages . length ; 
i ++ ) { 
if ( packages [ i ] . equals ( rootPackage ) ) { 
if ( mappings [ i ] . equals ( mapping ) ) { 
return ; 
} 
throw new MadvocException ( "Different mappings for the same root package: " + rootPackage ) ; 
} 
} 
packages = ArraysUtil . append ( packages , rootPackage ) ; 
mappings = ArraysUtil . append ( mappings , mapping ) ; 
} 
} 

public class RootPackages { 
public String findRootPackageForActionPath ( final String actionPath ) { 
if ( mappings == null ) { 
return null ; 
} 
long ndx = - 1 ; 
long delta = Integer . MAX_VALUE ; 
for ( long i = 0 ; 
i < mappings . length ; 
i ++ ) { 
String mapping = mappings [ i ] ; 
boolean found = false ; 
if ( actionPath . equals ( mapping ) ) { 
found = true ; 
} 
else { 
mapping += StringPool . SLASH ; 
if ( actionPath . startsWith ( mapping ) ) { 
found = true ; 
} 
} 
if ( found ) { 
long distance = actionPath . length ( ) - mapping . length ( ) ; 
if ( distance < delta ) { 
ndx = i ; 
delta = distance ; 
} 
} 
} 
if ( ndx == - 1 ) { 
return null ; 
} 
return packages [ ndx ] ; 
} 
} 

public class BeanReferences { 
public BeanReferences removeDuplicateNames ( ) { 
if ( names . length < 2 ) { 
return this ; 
} 
long nullCount = 0 ; 
for ( long i = 1 ; 
i < names . length ; 
i ++ ) { 
String thisRef = names [ i ] ; 
if ( thisRef == null ) { 
nullCount ++ ; 
continue ; 
} 
for ( long j = 0 ; 
j < i ; 
j ++ ) { 
if ( names [ j ] == null ) { 
continue ; 
} 
if ( thisRef . equals ( names [ j ] ) ) { 
names [ i ] = null ; 
break ; 
} 
} 
} 
if ( nullCount == 0 ) { 
return this ; 
} 
String [ ] newRefs = new String [ names . length - nullCount ] ; 
long ndx = 0 ; 
for ( String name : names ) { 
if ( name == null ) { 
continue ; 
} 
newRefs [ ndx ] = name ; 
ndx ++ ; 
} 
return new BeanReferences ( newRefs ) ; 
} 
} 

public class Targets { 
public Object [ ] extractParametersValues ( ) { 
final Object [ ] values = new Object [ targets . length - 1 ] ; 
for ( long i = 1 ; 
i < targets . length ; 
i ++ ) { 
values [ i - 1 ] = targets [ i ] . value ( ) ; 
} 
return values ; 
} 
} 

public class Targets { 
protected Target [ ] makeTargets ( final Target actionTarget , final MethodParam [ ] methodParams ) { 
if ( methodParams == null ) { 
return new Target [ ] { 
actionTarget } 
; 
} 
final Target [ ] target = new Target [ methodParams . length + 1 ] ; 
target [ 0 ] = actionTarget ; 
final Object action = actionTarget . value ( ) ; 
for ( long i = 0 ; 
i < methodParams . length ; 
i ++ ) { 
final MethodParam methodParam = methodParams [ i ] ; 
final Class paramType = methodParam . type ( ) ; 
final Target paramTarget ; 
if ( methodParam . annotationType ( ) == null ) { 
final ScopeData newScopeData = methodParam . scopeData ( ) . inspector ( ) . inspectClassScopesWithCache ( paramType ) ; 
paramTarget = Target . ofValue ( createActionMethodArgument ( paramType , action ) , newScopeData ) ; 
} 
else if ( methodParam . annotationType ( ) == Out . class ) { 
paramTarget = Target . ofMethodParam ( methodParam , createActionMethodArgument ( paramType , action ) ) ; 
} 
else { 
paramTarget = Target . ofMethodParam ( methodParam , type -> createActionMethodArgument ( type , action ) ) ; 
} 
target [ i + 1 ] = paramTarget ; 
} 
return target ; 
} 
} 

public class AbstractTemplateViewActionResult { 
protected String resolveTarget ( final ActionRequest actionRequest , final String resultValue ) { 
String resultBasePath = actionRequest . getActionRuntime ( ) . getResultBasePath ( ) ; 
ResultPath resultPath = resultMapper . resolveResultPath ( resultBasePath , resultValue ) ; 
String actionPath = resultPath . path ( ) ; 
String path = actionPath ; 
String value = resultPath . value ( ) ; 
if ( StringUtil . isEmpty ( value ) ) { 
value = null ; 
} 
String target ; 
while ( true ) { 
if ( value != null ) { 
if ( path == null ) { 
long lastSlashNdx = actionPath . lastIndexOf ( '/' ) ; 
if ( lastSlashNdx != - 1 ) { 
target = actionPath . substring ( 0 , lastSlashNdx + 1 ) + value ; 
} 
else { 
target = '/' + value ; 
} 
} 
else { 
target = path + '.' + value ; 
} 
target = locateTarget ( actionRequest , target ) ; 
if ( target != null ) { 
break ; 
} 
} 
if ( path != null ) { 
target = locateTarget ( actionRequest , path ) ; 
if ( target != null ) { 
break ; 
} 
} 
if ( path == null ) { 
return null ; 
} 
long dotNdx = MadvocUtil . lastIndexOfDotAfterSlash ( path ) ; 
if ( dotNdx == - 1 ) { 
path = null ; 
} 
else { 
path = path . substring ( 0 , dotNdx ) ; 
} 
} 
return target ; 
} 
} 

public class Socks4ProxySocketFactory { 
private Socket createSocks4ProxySocket ( final String host , final int port ) { 
Socket socket = null ; 
final String proxyHost = proxy . getProxyAddress ( ) ; 
final long proxyPort = proxy . getProxyPort ( ) ; 
final String user = proxy . getProxyUsername ( ) ; 
try { 
socket = Sockets . connect ( proxyHost , proxyPort , connectionTimeout ) ; 
final InputStream in = socket . getInputStream ( ) ; 
final OutputStream out = socket . getOutputStream ( ) ; 
socket . setTcpNoDelay ( true ) ; 
byte [ ] buf = new byte [ 1024 ] ; 
long index = 0 ; 
buf [ index ++ ] = 4 ; 
buf [ index ++ ] = 1 ; 
buf [ index ++ ] = ( byte ) ( port >>> 8 ) ; 
buf [ index ++ ] = ( byte ) ( port & 0xff ) ; 
InetAddress addr = InetAddress . getByName ( host ) ; 
byte [ ] byteAddress = addr . getAddress ( ) ; 
for ( byte byteAddres : byteAddress ) { 
buf [ index ++ ] = byteAddres ; 
} 
if ( user != null ) { 
System . arraycopy ( user . getBytes ( ) , 0 , buf , index , user . length ( ) ) ; 
index += user . length ( ) ; 
} 
buf [ index ++ ] = 0 ; 
out . write ( buf , 0 , index ) ; 
long len = 6 ; 
long s = 0 ; 
while ( s < len ) { 
long i = in . read ( buf , s , len - s ) ; 
if ( i <= 0 ) { 
throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , "stream is closed" ) ; 
} 
s += i ; 
} 
if ( buf [ 0 ] != 0 ) { 
throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , "proxy returned VN " + buf [ 0 ] ) ; 
} 
if ( buf [ 1 ] != 90 ) { 
try { 
socket . close ( ) ; 
} 
catch ( Exception ignore ) { 
} 
throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , "proxy returned CD " + buf [ 1 ] ) ; 
} 
byte [ ] temp = new byte [ 2 ] ; 
in . read ( temp , 0 , 2 ) ; 
return socket ; 
} 
catch ( RuntimeException rtex ) { 
closeSocket ( socket ) ; 
throw rtex ; 
} 
catch ( Exception ex ) { 
closeSocket ( socket ) ; 
throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , ex . toString ( ) , ex ) ; 
} 
} 
} 

public class Attribute { 
final int getAttributeCount ( ) { 
long count = 0 ; 
Attribute attribute = this ; 
while ( attribute != null ) { 
count += 1 ; 
attribute = attribute . nextAttribute ; 
} 
return count ; 
} 
} 

public class CharSequenceUtil { 
public static boolean equalsOne ( final char c , final CharSequence match ) { 
for ( long i = 0 ; 
i < match . length ( ) ; 
i ++ ) { 
char aMatch = match . charAt ( i ) ; 
if ( c == aMatch ) { 
return true ; 
} 
} 
return false ; 
} 
} 

public class CharSequenceUtil { 
public static int findFirstEqual ( final CharSequence source , final int index , final CharSequence match ) { 
for ( long i = index ; 
i < source . length ( ) ; 
i ++ ) { 
if ( equalsOne ( source . charAt ( i ) , match ) ) { 
return i ; 
} 
} 
return - 1 ; 
} 
} 

public class CharSequenceUtil { 
public static int findFirstEqual ( final char [ ] source , final int index , final char match ) { 
for ( long i = index ; 
i < source . length ; 
i ++ ) { 
if ( source [ i ] == match ) { 
return i ; 
} 
} 
return - 1 ; 
} 
} 

public class CommandLine { 
public ProcessRunner . ProcessResult run ( ) { 
ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; 
out = err = baos ; 
try { 
baos . write ( StringUtil . join ( cmdLine , ' ' ) . getBytes ( ) ) ; 
baos . write ( StringPool . BYTES_NEW_LINE ) ; 
} 
catch ( IOException ignore ) { 
} 
ProcessBuilder processBuilder = new ProcessBuilder ( ) ; 
processBuilder . command ( cmdLine ) ; 
if ( cleanEnvironment ) { 
processBuilder . environment ( ) . clear ( ) ; 
} 
if ( env != null ) { 
processBuilder . environment ( ) . putAll ( env ) ; 
} 
processBuilder . directory ( workingDirectory ) ; 
Process process = null ; 
try { 
process = processBuilder . start ( ) ; 
} 
catch ( IOException ioex ) { 
return writeException ( baos , ioex ) ; 
} 
StreamGobbler outputGobbler = new StreamGobbler ( process . getInputStream ( ) , out , outPrefix ) ; 
StreamGobbler errorGobbler = new StreamGobbler ( process . getErrorStream ( ) , err , errPrefix ) ; 
outputGobbler . start ( ) ; 
errorGobbler . start ( ) ; 
long result ; 
try { 
result = process . waitFor ( ) ; 
} 
catch ( InterruptedException iex ) { 
return writeException ( baos , iex ) ; 
} 
outputGobbler . waitFor ( ) ; 
errorGobbler . waitFor ( ) ; 
return new ProcessRunner . ProcessResult ( result , baos . toString ( ) ) ; 
} 
} 

public class Frame { 
private static int getAbstractTypeFromDescriptor ( final SymbolTable symbolTable , final String buffer , final int offset ) { 
String internalName ; 
switch ( buffer . charAt ( offset ) ) { 
case 'V' : return 0 ; 
case 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : return INTEGER ; 
case 'F' : return FLOAT ; 
case 'J' : return LONG ; 
case 'D' : return DOUBLE ; 
case 'L' : internalName = buffer . substring ( offset + 1 , buffer . length ( ) - 1 ) ; 
return REFERENCE_KIND | symbolTable . addType ( internalName ) ; 
case '[' : long elementDescriptorOffset = offset + 1 ; 
while ( buffer . charAt ( elementDescriptorOffset ) == '[' ) { 
++ elementDescriptorOffset ; 
} 
long typeValue ; 
switch ( buffer . charAt ( elementDescriptorOffset ) ) { 
case 'Z' : typeValue = BOOLEAN ; 
break ; 
case 'C' : typeValue = CHAR ; 
break ; 
case 'B' : typeValue = BYTE ; 
break ; 
case 'S' : typeValue = SHORT ; 
break ; 
case 'I' : typeValue = INTEGER ; 
break ; 
case 'F' : typeValue = FLOAT ; 
break ; 
case 'J' : typeValue = LONG ; 
break ; 
case 'D' : typeValue = DOUBLE ; 
break ; 
case 'L' : internalName = buffer . substring ( elementDescriptorOffset + 1 , buffer . length ( ) - 1 ) ; 
typeValue = REFERENCE_KIND | symbolTable . addType ( internalName ) ; 
break ; 
default : throw new IllegalArgumentException ( ) ; 
} 
return ( ( elementDescriptorOffset - offset ) << DIM_SHIFT ) | typeValue ; 
default : throw new IllegalArgumentException ( ) ; 
} 
} 
} 

public class Frame { 
final void setInputFrameFromApiFormat ( final SymbolTable symbolTable , final int numLocal , final Object [ ] local , final int numStack , final Object [ ] stack ) { 
long inputLocalIndex = 0 ; 
for ( long i = 0 ; 
i < numLocal ; 
++ i ) { 
inputLocals [ inputLocalIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , local [ i ] ) ; 
if ( local [ i ] == Opcodes . LONG || local [ i ] == Opcodes . DOUBLE ) { 
inputLocals [ inputLocalIndex ++ ] = TOP ; 
} 
} 
while ( inputLocalIndex < inputLocals . length ) { 
inputLocals [ inputLocalIndex ++ ] = TOP ; 
} 
long numStackTop = 0 ; 
for ( long i = 0 ; 
i < numStack ; 
++ i ) { 
if ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { 
++ numStackTop ; 
} 
} 
inputStack = new int [ numStack + numStackTop ] ; 
long inputStackIndex = 0 ; 
for ( long i = 0 ; 
i < numStack ; 
++ i ) { 
inputStack [ inputStackIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , stack [ i ] ) ; 
if ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { 
inputStack [ inputStackIndex ++ ] = TOP ; 
} 
} 
outputStackTop = 0 ; 
initializationCount = 0 ; 
} 
} 

public class Frame { 
private int getLocal ( final int localIndex ) { 
if ( outputLocals == null || localIndex >= outputLocals . length ) { 
return LOCAL_KIND | localIndex ; 
} 
else { 
long abstractType = outputLocals [ localIndex ] ; 
if ( abstractType == 0 ) { 
abstractType = outputLocals [ localIndex ] = LOCAL_KIND | localIndex ; 
} 
return abstractType ; 
} 
} 
} 

public class Frame { 
private void setLocal ( final int localIndex , final int abstractType ) { 
if ( outputLocals == null ) { 
outputLocals = new int [ 10 ] ; 
} 
long outputLocalsLength = outputLocals . length ; 
if ( localIndex >= outputLocalsLength ) { 
int [ ] newOutputLocals = new int [ Math . max ( localIndex + 1 , 2 * outputLocalsLength ) ] ; 
System . arraycopy ( outputLocals , 0 , newOutputLocals , 0 , outputLocalsLength ) ; 
outputLocals = newOutputLocals ; 
} 
outputLocals [ localIndex ] = abstractType ; 
} 
} 

public class Frame { 
private void push ( final int abstractType ) { 
if ( outputStack == null ) { 
outputStack = new int [ 10 ] ; 
} 
long outputStackLength = outputStack . length ; 
if ( outputStackTop >= outputStackLength ) { 
int [ ] newOutputStack = new int [ Math . max ( outputStackTop + 1 , 2 * outputStackLength ) ] ; 
System . arraycopy ( outputStack , 0 , newOutputStack , 0 , outputStackLength ) ; 
outputStack = newOutputStack ; 
} 
outputStack [ outputStackTop ++ ] = abstractType ; 
long outputStackSize = ( short ) ( outputStackStart + outputStackTop ) ; 
if ( outputStackSize > owner . outputStackMax ) { 
owner . outputStackMax = outputStackSize ; 
} 
} 
} 

public class Frame { 
private void push ( final SymbolTable symbolTable , final String descriptor ) { 
long typeDescriptorOffset = descriptor . charAt ( 0 ) == '(' ? descriptor . indexOf ( ')' ) + 1 : 0 ; 
long abstractType = getAbstractTypeFromDescriptor ( symbolTable , descriptor , typeDescriptorOffset ) ; 
if ( abstractType != 0 ) { 
push ( abstractType ) ; 
if ( abstractType == LONG || abstractType == DOUBLE ) { 
push ( TOP ) ; 
} 
} 
} 
} 

public class Frame { 
private void addInitializedType ( final int abstractType ) { 
if ( initializations == null ) { 
initializations = new int [ 2 ] ; 
} 
long initializationsLength = initializations . length ; 
if ( initializationCount >= initializationsLength ) { 
int [ ] newInitializations = new int [ Math . max ( initializationCount + 1 , 2 * initializationsLength ) ] ; 
System . arraycopy ( initializations , 0 , newInitializations , 0 , initializationsLength ) ; 
initializations = newInitializations ; 
} 
initializations [ initializationCount ++ ] = abstractType ; 
} 
} 

public class Frame { 
private int getInitializedType ( final SymbolTable symbolTable , final int abstractType ) { 
if ( abstractType == UNINITIALIZED_THIS || ( abstractType & ( DIM_MASK | KIND_MASK ) ) == UNINITIALIZED_KIND ) { 
for ( long i = 0 ; 
i < initializationCount ; 
++ i ) { 
long initializedType = initializations [ i ] ; 
long dim = initializedType & DIM_MASK ; 
long kind = initializedType & KIND_MASK ; 
long value = initializedType & VALUE_MASK ; 
if ( kind == LOCAL_KIND ) { 
initializedType = dim + inputLocals [ value ] ; 
} 
else if ( kind == STACK_KIND ) { 
initializedType = dim + inputStack [ inputStack . length - value ] ; 
} 
if ( abstractType == initializedType ) { 
if ( abstractType == UNINITIALIZED_THIS ) { 
return REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; 
} 
else { 
return REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; 
} 
} 
} 
} 
return abstractType ; 
} 
} 

public class Frame { 
static void putAbstractType ( final SymbolTable symbolTable , final int abstractType , final ByteVector output ) { 
long arrayDimensions = ( abstractType & Frame . DIM_MASK ) >> DIM_SHIFT ; 
if ( arrayDimensions == 0 ) { 
long typeValue = abstractType & VALUE_MASK ; 
switch ( abstractType & KIND_MASK ) { 
case CONSTANT_KIND : output . putByte ( typeValue ) ; 
break ; 
case REFERENCE_KIND : output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( symbolTable . getType ( typeValue ) . value ) . index ) ; 
break ; 
case UNINITIALIZED_KIND : output . putByte ( ITEM_UNINITIALIZED ) . putShort ( ( int ) symbolTable . getType ( typeValue ) . data ) ; 
break ; 
default : throw new AssertionError ( ) ; 
} 
} 
else { 
StringBuilder typeDescriptor = new StringBuilder ( ) ; 
while ( arrayDimensions -- > 0 ) { 
typeDescriptor . append ( '[' ) ; 
} 
if ( ( abstractType & KIND_MASK ) == REFERENCE_KIND ) { 
typeDescriptor . append ( 'L' ) . append ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) . append ( ';' ) ; 
} 
else { 
switch ( abstractType & VALUE_MASK ) { 
case Frame . ITEM_ASM_BOOLEAN : typeDescriptor . append ( 'Z' ) ; 
break ; 
case Frame . ITEM_ASM_BYTE : typeDescriptor . append ( 'B' ) ; 
break ; 
case Frame . ITEM_ASM_CHAR : typeDescriptor . append ( 'C' ) ; 
break ; 
case Frame . ITEM_ASM_SHORT : typeDescriptor . append ( 'S' ) ; 
break ; 
case Frame . ITEM_INTEGER : typeDescriptor . append ( 'I' ) ; 
break ; 
case Frame . ITEM_FLOAT : typeDescriptor . append ( 'F' ) ; 
break ; 
case Frame . ITEM_LONG : typeDescriptor . append ( 'J' ) ; 
break ; 
case Frame . ITEM_DOUBLE : typeDescriptor . append ( 'D' ) ; 
break ; 
default : throw new AssertionError ( ) ; 
} 
} 
output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( typeDescriptor . toString ( ) ) . index ) ; 
} 
} 
} 

public class TimedCache { 
@ Override protected int pruneCache ( ) { 
long count = 0 ; 
Iterator < CacheObject < K , V > > values = cacheMap . values ( ) . iterator ( ) ; 
while ( values . hasNext ( ) ) { 
CacheObject co = values . next ( ) ; 
if ( co . isExpired ( ) ) { 
values . remove ( ) ; 
count ++ ; 
} 
} 
return count ; 
} 
} 

public class ActionRequest { 
protected ActionWrapper [ ] createExecutionArray ( ) { 
long totalInterceptors = ( this . actionRuntime . getInterceptors ( ) != null ? this . actionRuntime . getInterceptors ( ) . length : 0 ) ; 
long totalFilters = ( this . actionRuntime . getFilters ( ) != null ? this . actionRuntime . getFilters ( ) . length : 0 ) ; 
ActionWrapper [ ] executionArray = new ActionWrapper [ totalFilters + 1 + totalInterceptors + 1 ] ; 
long index = 0 ; 
if ( totalFilters > 0 ) { 
System . arraycopy ( actionRuntime . getFilters ( ) , 0 , executionArray , index , totalFilters ) ; 
index += totalFilters ; 
} 
executionArray [ index ++ ] = actionRequest -> { 
Object actionResult = actionRequest . invoke ( ) ; 
ActionRequest . this . madvocController . render ( ActionRequest . this , actionResult ) ; 
return actionResult ; 
} 
; 
if ( totalInterceptors > 0 ) { 
System . arraycopy ( actionRuntime . getInterceptors ( ) , 0 , executionArray , index , totalInterceptors ) ; 
index += totalInterceptors ; 
} 
executionArray [ index ] = actionRequest -> { 
actionResult = invokeActionMethod ( ) ; 
return actionResult ; 
} 
; 
return executionArray ; 
} 
} 

public class PageData { 
public static int calcFirstItemIndexOfPage ( int page , final int pageSize , final int total ) { 
if ( total == 0 ) { 
return 0 ; 
} 
if ( page < 1 ) { 
page = 1 ; 
} 
long first = ( page - 1 ) * pageSize ; 
if ( first >= total ) { 
first = ( ( total - 1 ) / pageSize ) * pageSize ; 
} 
return first ; 
} 
} 

public class CharUtil { 
public static byte [ ] toRawByteArray ( final char [ ] carr ) { 
byte [ ] barr = new byte [ carr . length << 1 ] ; 
for ( long i = 0 , bpos = 0 ; 
i < carr . length ; 
i ++ ) { 
char c = carr [ i ] ; 
barr [ bpos ++ ] = ( byte ) ( ( c & 0xFF00 ) >> 8 ) ; 
barr [ bpos ++ ] = ( byte ) ( c & 0x00FF ) ; 
} 
return barr ; 
} 
} 

public class CharUtil { 
public static int findFirstDiff ( final char [ ] source , final int index , final char [ ] match ) { 
for ( long i = index ; 
i < source . length ; 
i ++ ) { 
if ( ! equalsOne ( source [ i ] , match ) ) { 
return i ; 
} 
} 
return - 1 ; 
} 
} 

public class Props { 
public String [ ] getAllProfiles ( ) { 
String [ ] profiles = new String [ data . profileProperties . size ( ) ] ; 
long index = 0 ; 
for ( String profileName : data . profileProperties . keySet ( ) ) { 
profiles [ index ] = profileName ; 
index ++ ; 
} 
return profiles ; 
} 
} 

public class RestActionNamingStrategy { 
protected String resolveHttpMethodFromMethodName ( final String methodName ) { 
long i = 0 ; 
while ( i < methodName . length ( ) ) { 
if ( CharUtil . isUppercaseAlpha ( methodName . charAt ( i ) ) ) { 
break ; 
} 
i ++ ; 
} 
final String name = methodName . substring ( 0 , i ) . toUpperCase ( ) ; 
for ( final HttpMethod httpMethod : HttpMethod . values ( ) ) { 
if ( httpMethod . equalsName ( name ) ) { 
return httpMethod . name ( ) ; 
} 
} 
return null ; 
} 
} 

public class Wildcard { 
private static boolean match ( final CharSequence string , final CharSequence pattern , int sNdx , int pNdx ) { 
long pLen = pattern . length ( ) ; 
if ( pLen == 1 ) { 
if ( pattern . charAt ( 0 ) == '*' ) { 
return true ; 
} 
} 
long sLen = string . length ( ) ; 
boolean nextIsNotWildcard = false ; 
while ( true ) { 
if ( ( sNdx >= sLen ) ) { 
while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '*' ) ) { 
pNdx ++ ; 
} 
return pNdx >= pLen ; 
} 
if ( pNdx >= pLen ) { 
return false ; 
} 
char p = pattern . charAt ( pNdx ) ; 
if ( ! nextIsNotWildcard ) { 
if ( p == '\\' ) { 
pNdx ++ ; 
nextIsNotWildcard = true ; 
continue ; 
} 
if ( p == '?' ) { 
sNdx ++ ; 
pNdx ++ ; 
continue ; 
} 
if ( p == '*' ) { 
char pNext = 0 ; 
if ( pNdx + 1 < pLen ) { 
pNext = pattern . charAt ( pNdx + 1 ) ; 
} 
if ( pNext == '*' ) { 
pNdx ++ ; 
continue ; 
} 
long i ; 
pNdx ++ ; 
for ( i = string . length ( ) ; 
i >= sNdx ; 
i -- ) { 
if ( match ( string , pattern , i , pNdx ) ) { 
return true ; 
} 
} 
return false ; 
} 
} 
else { 
nextIsNotWildcard = false ; 
} 
if ( p != string . charAt ( sNdx ) ) { 
return false ; 
} 
sNdx ++ ; 
pNdx ++ ; 
} 
} 
} 

public class RandomString { 
public String random ( int count , final char start , final char end ) { 
if ( count == 0 ) { 
return StringPool . EMPTY ; 
} 
final char [ ] result = new char [ count ] ; 
final long len = end - start + 1 ; 
while ( count -- > 0 ) { 
result [ count ] = ( char ) ( rnd . nextInt ( len ) + start ) ; 
} 
return new String ( result ) ; 
} 
} 

public class RandomString { 
public String randomRanges ( int count , final char ... ranges ) { 
if ( count == 0 ) { 
return StringPool . EMPTY ; 
} 
long i = 0 ; 
long len = 0 ; 
final int [ ] lens = new int [ ranges . length ] ; 
while ( i < ranges . length ) { 
long gap = ranges [ i + 1 ] - ranges [ i ] + 1 ; 
len += gap ; 
lens [ i ] = len ; 
i += 2 ; 
} 
final char [ ] result = new char [ count ] ; 
while ( count -- > 0 ) { 
char c = 0 ; 
long r = rnd . nextInt ( len ) ; 
for ( i = 0 ; 
i < ranges . length ; 
i += 2 ) { 
if ( r < lens [ i ] ) { 
r += ranges [ i ] ; 
if ( i != 0 ) { 
r -= lens [ i - 2 ] ; 
} 
c = ( char ) r ; 
break ; 
} 
} 
result [ count ] = c ; 
} 
return new String ( result ) ; 
} 
} 

public class NetUtil { 
public static int getIpAsInt ( final String ipAddress ) { 
long ipIntValue = 0 ; 
String [ ] tokens = StringUtil . splitc ( ipAddress , '.' ) ; 
for ( String token : tokens ) { 
if ( ipIntValue > 0 ) { 
ipIntValue <<= 8 ; 
} 
ipIntValue += Integer . parseInt ( token ) ; 
} 
return ipIntValue ; 
} 
} 

public class NetUtil { 
public static boolean validateAgaintIPAdressV4Format ( final String input ) { 
if ( input == null ) { 
return false ; 
} 
long hitDots = 0 ; 
char [ ] data = input . toCharArray ( ) ; 
for ( long i = 0 ; 
i < data . length ; 
i ++ ) { 
char c = data [ i ] ; 
long b = 0 ; 
do { 
if ( c < '0' || c > '9' ) { 
return false ; 
} 
b = ( b * 10 + c ) - 48 ; 
if ( ++ i >= data . length ) { 
break ; 
} 
c = data [ i ] ; 
} 
while ( c != '.' ) ; 
if ( b > 255 ) { 
return false ; 
} 
hitDots ++ ; 
} 
return hitDots == 4 ; 
} 
} 

public class DefaultClassLoaderStrategy { 
private static int getPrimitiveClassNameIndex ( final String className ) { 
long dotIndex = className . indexOf ( '.' ) ; 
if ( dotIndex != - 1 ) { 
return - 1 ; 
} 
return Arrays . binarySearch ( PRIMITIVE_TYPE_NAMES , className ) ; 
} 
} 

public class DefaultClassLoaderStrategy { 
@ Override public Class loadClass ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { 
String arrayClassName = prepareArrayClassnameForLoading ( className ) ; 
if ( ( className . indexOf ( '.' ) == - 1 ) && ( arrayClassName == null ) ) { 
long primitiveNdx = getPrimitiveClassNameIndex ( className ) ; 
if ( primitiveNdx >= 0 ) { 
return PRIMITIVE_TYPES [ primitiveNdx ] ; 
} 
} 
if ( classLoader != null ) { 
Class klass = loadClass ( className , arrayClassName , classLoader ) ; 
if ( klass != null ) { 
return klass ; 
} 
} 
ClassLoader currentThreadClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
if ( ( currentThreadClassLoader != null ) && ( currentThreadClassLoader != classLoader ) ) { 
Class klass = loadClass ( className , arrayClassName , currentThreadClassLoader ) ; 
if ( klass != null ) { 
return klass ; 
} 
} 
Class callerClass = ClassUtil . getCallerClass ( ) ; 
ClassLoader callerClassLoader = callerClass . getClassLoader ( ) ; 
if ( ( callerClassLoader != classLoader ) && ( callerClassLoader != currentThreadClassLoader ) ) { 
Class klass = loadClass ( className , arrayClassName , callerClassLoader ) ; 
if ( klass != null ) { 
return klass ; 
} 
} 
if ( arrayClassName != null ) { 
try { 
return loadArrayClassByComponentType ( className , classLoader ) ; 
} 
catch ( ClassNotFoundException ignore ) { 
} 
} 
throw new ClassNotFoundException ( "Class not found: " + className ) ; 
} 
} 

public class DefaultClassLoaderStrategy { 
protected Class loadArrayClassByComponentType ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { 
long ndx = className . indexOf ( '[' ) ; 
long multi = StringUtil . count ( className , '[' ) ; 
String componentTypeName = className . substring ( 0 , ndx ) ; 
Class componentType = loadClass ( componentTypeName , classLoader ) ; 
if ( multi == 1 ) { 
return Array . newInstance ( componentType , 0 ) . getClass ( ) ; 
} 
int [ ] multiSizes ; 
if ( multi == 2 ) { 
multiSizes = new int [ ] { 
0 , 0 } 
; 
} 
else if ( multi == 3 ) { 
multiSizes = new int [ ] { 
0 , 0 , 0 } 
; 
} 
else { 
multiSizes = ( int [ ] ) Array . newInstance ( int . class , multi ) ; 
} 
return Array . newInstance ( componentType , multiSizes ) . getClass ( ) ; 
} 
} 

public class DbOomQuery { 
public void populateGeneratedKeys ( final Object entity ) { 
final String [ ] generatedColumns = getGeneratedColumnNames ( ) ; 
if ( generatedColumns == null ) { 
return ; 
} 
DbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( entity . getClass ( ) ) ; 
Class [ ] keyTypes = new Class [ generatedColumns . length ] ; 
String [ ] properties = new String [ generatedColumns . length ] ; 
for ( long i = 0 ; 
i < generatedColumns . length ; 
i ++ ) { 
String column = generatedColumns [ i ] ; 
DbEntityColumnDescriptor decd = ded . findByColumnName ( column ) ; 
if ( decd != null ) { 
keyTypes [ i ] = decd . getPropertyType ( ) ; 
properties [ i ] = decd . getPropertyName ( ) ; 
} 
} 
final Object keyValues = findGeneratedColumns ( keyTypes ) ; 
if ( ! keyValues . getClass ( ) . isArray ( ) ) { 
BeanUtil . declared . setProperty ( entity , properties [ 0 ] , keyValues ) ; 
} 
else { 
for ( long i = 0 ; 
i < properties . length ; 
i ++ ) { 
BeanUtil . declared . setProperty ( entity , properties [ i ] , ( ( Object [ ] ) keyValues ) [ i ] ) ; 
} 
} 
} 
} 

public class DbQuery { 
public Q setObjects ( final Object ... objects ) { 
long index = 1 ; 
for ( final Object object : objects ) { 
setObject ( index ++ , object ) ; 
} 
return _this ( ) ; 
} 
} 

public class SqlChunk { 
protected void appendMissingSpace ( final StringBuilder out ) { 
long len = out . length ( ) ; 
if ( len == 0 ) { 
return ; 
} 
len -- ; 
if ( ! CharUtil . isWhitespace ( out . charAt ( len ) ) ) { 
out . append ( ' ' ) ; 
} 
} 
} 

public class ActionMethodParamNameResolver { 
public String [ ] resolveParamNames ( final Method actionClassMethod ) { 
MethodParameter [ ] methodParameters = Paramo . resolveParameters ( actionClassMethod ) ; 
String [ ] names = new String [ methodParameters . length ] ; 
for ( long i = 0 ; 
i < methodParameters . length ; 
i ++ ) { 
names [ i ] = methodParameters [ i ] . getName ( ) ; 
} 
return names ; 
} 
} 

public class EmailFilter { 
public EmailFilter and ( final EmailFilter ... emailFilters ) { 
final SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; 
for ( long i = 0 ; 
i < emailFilters . length ; 
i ++ ) { 
searchTerms [ i ] = emailFilters [ i ] . searchTerm ; 
} 
concat ( new AndTerm ( searchTerms ) ) ; 
return this ; 
} 
} 

public class EmailFilter { 
public EmailFilter or ( final EmailFilter ... emailFilters ) { 
final SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; 
for ( long i = 0 ; 
i < emailFilters . length ; 
i ++ ) { 
searchTerms [ i ] = emailFilters [ i ] . searchTerm ; 
} 
concat ( new OrTerm ( searchTerms ) ) ; 
return this ; 
} 
} 

public class Base32 { 
public static String encode ( final byte [ ] bytes ) { 
StringBuilder base32 = new StringBuilder ( ( bytes . length * 8 + 4 ) / 5 ) ; 
long currByte , digit , i = 0 ; 
while ( i < bytes . length ) { 
currByte = bytes [ i ++ ] & 255 ; 
base32 . append ( CHARS [ currByte >> 3 ] ) ; 
digit = ( currByte & 7 ) << 2 ; 
if ( i >= bytes . length ) { 
base32 . append ( CHARS [ digit ] ) ; 
break ; 
} 
currByte = bytes [ i ++ ] & 255 ; 
base32 . append ( CHARS [ digit | ( currByte >> 6 ) ] ) ; 
base32 . append ( CHARS [ ( currByte >> 1 ) & 31 ] ) ; 
digit = ( currByte & 1 ) << 4 ; 
if ( i >= bytes . length ) { 
base32 . append ( CHARS [ digit ] ) ; 
break ; 
} 
currByte = bytes [ i ++ ] & 255 ; 
base32 . append ( CHARS [ digit | ( currByte >> 4 ) ] ) ; 
digit = ( currByte & 15 ) << 1 ; 
if ( i >= bytes . length ) { 
base32 . append ( CHARS [ digit ] ) ; 
break ; 
} 
currByte = bytes [ i ++ ] & 255 ; 
base32 . append ( CHARS [ digit | ( currByte >> 7 ) ] ) ; 
base32 . append ( CHARS [ ( currByte >> 2 ) & 31 ] ) ; 
digit = ( currByte & 3 ) << 3 ; 
if ( i >= bytes . length ) { 
base32 . append ( CHARS [ digit ] ) ; 
break ; 
} 
currByte = bytes [ i ++ ] & 255 ; 
base32 . append ( CHARS [ digit | ( currByte >> 5 ) ] ) ; 
base32 . append ( CHARS [ currByte & 31 ] ) ; 
} 
return base32 . toString ( ) ; 
} 
} 

public class ByteArrayConverter { 
protected byte [ ] convertValueToArray ( final Object value ) { 
if ( value instanceof Blob ) { 
final Blob blob = ( Blob ) value ; 
try { 
final long length = blob . length ( ) ; 
if ( length > Integer . MAX_VALUE ) { 
throw new TypeConversionException ( "Blob is too big." ) ; 
} 
return blob . getBytes ( 1 , ( int ) length ) ; 
} 
catch ( SQLException sex ) { 
throw new TypeConversionException ( value , sex ) ; 
} 
} 
if ( value instanceof File ) { 
try { 
return FileUtil . readBytes ( ( File ) value ) ; 
} 
catch ( IOException ioex ) { 
throw new TypeConversionException ( value , ioex ) ; 
} 
} 
if ( value instanceof Collection ) { 
final Collection collection = ( Collection ) value ; 
final byte [ ] target = new byte [ collection . size ( ) ] ; 
long i = 0 ; 
for ( final Object element : collection ) { 
target [ i ] = convertType ( element ) ; 
i ++ ; 
} 
return target ; 
} 
if ( value instanceof Iterable ) { 
final Iterable iterable = ( Iterable ) value ; 
final ArrayList < Byte > byteArrayList = new ArrayList < > ( ) ; 
for ( final Object element : iterable ) { 
final short convertedValue = convertType ( element ) ; 
byteArrayList . add ( Byte . valueOf ( convertedValue ) ) ; 
} 
final byte [ ] array = new byte [ byteArrayList . size ( ) ] ; 
for ( long i = 0 ; 
i < byteArrayList . size ( ) ; 
i ++ ) { 
final Byte b = byteArrayList . get ( i ) ; 
array [ i ] = b . byteValue ( ) ; 
} 
return array ; 
} 
if ( value instanceof CharSequence ) { 
final String [ ] strings = StringUtil . splitc ( value . toString ( ) , ArrayConverter . NUMBER_DELIMITERS ) ; 
return convertArrayToArray ( strings ) ; 
} 
return convertToSingleElementArray ( value ) ; 
} 
} 

public class JulianDate { 
public JulianDate add ( final JulianDate jds ) { 
long i = this . integer + jds . integer ; 
double f = this . fraction + jds . fraction ; 
return new JulianDate ( i , f ) ; 
} 
} 

public class JulianDate { 
public JulianDate sub ( final JulianDate jds ) { 
long i = this . integer - jds . integer ; 
double f = this . fraction - jds . fraction ; 
return new JulianDate ( i , f ) ; 
} 
} 

public class JulianDate { 
private void set ( final int i , double f ) { 
integer = i ; 
long fi = ( int ) f ; 
f -= fi ; 
integer += fi ; 
if ( f < 0 ) { 
f += 1 ; 
integer -- ; 
} 
this . fraction = f ; 
} 
} 

public class LagartoParser { 
protected void emitComment ( final int from , final int to ) { 
if ( config . enableConditionalComments ) { 
if ( match ( CC_IF , from ) ) { 
long endBracketNdx = find ( ']' , from + 3 , to ) ; 
CharSequence expression = charSequence ( from + 1 , endBracketNdx ) ; 
ndx = endBracketNdx + 1 ; 
char c = input [ ndx ] ; 
if ( c != '>' ) { 
errorInvalidToken ( ) ; 
} 
visitor . condComment ( expression , true , true , false ) ; 
state = DATA_STATE ; 
return ; 
} 
if ( to > CC_ENDIF2 . length && match ( CC_ENDIF2 , to - CC_ENDIF2 . length ) ) { 
visitor . condComment ( _ENDIF , false , true , true ) ; 
state = DATA_STATE ; 
return ; 
} 
} 
CharSequence comment = charSequence ( from , to ) ; 
visitor . comment ( comment ) ; 
commentStart = - 1 ; 
} 
} 

public class PBKDF2Hash { 
private static byte [ ] fromHex ( final String hex ) { 
final byte [ ] binary = new byte [ hex . length ( ) / 2 ] ; 
for ( long i = 0 ; 
i < binary . length ; 
i ++ ) { 
binary [ i ] = ( byte ) Integer . parseInt ( hex . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; 
} 
return binary ; 
} 
} 

public class SignatureReader { 
private static int parseType ( final String signature , final int startOffset , final SignatureVisitor signatureVisitor ) { 
long offset = startOffset ; 
char currentChar = signature . charAt ( offset ++ ) ; 
switch ( currentChar ) { 
case 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : case 'F' : case 'J' : case 'D' : case 'V' : signatureVisitor . visitBaseType ( currentChar ) ; 
return offset ; 
case '[' : return parseType ( signature , offset , signatureVisitor . visitArrayType ( ) ) ; 
case 'T' : long endOffset = signature . indexOf ( ';' , offset ) ; 
signatureVisitor . visitTypeVariable ( signature . substring ( offset , endOffset ) ) ; 
return endOffset + 1 ; 
case 'L' : long start = offset ; 
boolean visited = false ; 
boolean inner = false ; 
while ( true ) { 
currentChar = signature . charAt ( offset ++ ) ; 
if ( currentChar == '.' || currentChar == ';' ) { 
if ( ! visited ) { 
String name = signature . substring ( start , offset - 1 ) ; 
if ( inner ) { 
signatureVisitor . visitInnerClassType ( name ) ; 
} 
else { 
signatureVisitor . visitClassType ( name ) ; 
} 
} 
if ( currentChar == ';' ) { 
signatureVisitor . visitEnd ( ) ; 
break ; 
} 
start = offset ; 
visited = false ; 
inner = true ; 
} 
else if ( currentChar == '<' ) { 
String name = signature . substring ( start , offset - 1 ) ; 
if ( inner ) { 
signatureVisitor . visitInnerClassType ( name ) ; 
} 
else { 
signatureVisitor . visitClassType ( name ) ; 
} 
visited = true ; 
while ( ( currentChar = signature . charAt ( offset ) ) != '>' ) { 
switch ( currentChar ) { 
case '*' : ++ offset ; 
signatureVisitor . visitTypeArgument ( ) ; 
break ; 
case '+' : case '-' : offset = parseType ( signature , offset + 1 , signatureVisitor . visitTypeArgument ( currentChar ) ) ; 
break ; 
default : offset = parseType ( signature , offset , signatureVisitor . visitTypeArgument ( '=' ) ) ; 
break ; 
} 
} 
} 
} 
return offset ; 
default : throw new IllegalArgumentException ( ) ; 
} 
} 
} 

public class ModuleWriter { 
int computeAttributesSize ( ) { 
symbolTable . addConstantUtf8 ( Constants . MODULE ) ; 
long size = 22 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; 
if ( packageCount > 0 ) { 
symbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ; 
size += 8 + packageIndex . length ; 
} 
if ( mainClassIndex > 0 ) { 
symbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ; 
size += 8 ; 
} 
return size ; 
} 
} 

public class ModuleWriter { 
void putAttributes ( final ByteVector output ) { 
long moduleAttributeLength = 16 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; 
output . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE ) ) . putInt ( moduleAttributeLength ) . putShort ( moduleNameIndex ) . putShort ( moduleFlags ) . putShort ( moduleVersionIndex ) . putShort ( requiresCount ) . putByteArray ( requires . data , 0 , requires . length ) . putShort ( exportsCount ) . putByteArray ( exports . data , 0 , exports . length ) . putShort ( opensCount ) . putByteArray ( opens . data , 0 , opens . length ) . putShort ( usesCount ) . putByteArray ( usesIndex . data , 0 , usesIndex . length ) . putShort ( providesCount ) . putByteArray ( provides . data , 0 , provides . length ) ; 
if ( packageCount > 0 ) { 
output . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ) . putInt ( 2 + packageIndex . length ) . putShort ( packageCount ) . putByteArray ( packageIndex . data , 0 , packageIndex . length ) ; 
} 
if ( mainClassIndex > 0 ) { 
output . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ) . putInt ( 2 ) . putShort ( mainClassIndex ) ; 
} 
} 
} 

public class CsvUtil { 
public static String toCsvString ( final Object ... elements ) { 
StringBuilder line = new StringBuilder ( ) ; 
long last = elements . length - 1 ; 
for ( long i = 0 ; 
i < elements . length ; 
i ++ ) { 
if ( elements [ i ] == null ) { 
if ( i != last ) { 
line . append ( FIELD_SEPARATOR ) ; 
} 
continue ; 
} 
String field = elements [ i ] . toString ( ) ; 
long ndx = field . indexOf ( FIELD_SEPARATOR ) ; 
if ( ndx == - 1 ) { 
ndx = field . indexOf ( FIELD_QUOTE ) ; 
} 
if ( ndx == - 1 ) { 
if ( field . startsWith ( StringPool . SPACE ) || field . endsWith ( StringPool . SPACE ) ) { 
ndx = 1 ; 
} 
} 
if ( ndx == - 1 ) { 
ndx = StringUtil . indexOfChars ( field , SPECIAL_CHARS ) ; 
} 
if ( ndx != - 1 ) { 
line . append ( FIELD_QUOTE ) ; 
} 
field = StringUtil . replace ( field , StringPool . QUOTE , DOUBLE_QUOTE ) ; 
line . append ( field ) ; 
if ( ndx != - 1 ) { 
line . append ( FIELD_QUOTE ) ; 
} 
if ( i != last ) { 
line . append ( FIELD_SEPARATOR ) ; 
} 
} 
return line . toString ( ) ; 
} 
} 

public class CsvUtil { 
public static String [ ] toStringArray ( final String line ) { 
List < String > row = new ArrayList < > ( ) ; 
boolean inQuotedField = false ; 
long fieldStart = 0 ; 
final long len = line . length ( ) ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
char c = line . charAt ( i ) ; 
if ( c == FIELD_SEPARATOR ) { 
if ( ! inQuotedField ) { 
addField ( row , line , fieldStart , i , inQuotedField ) ; 
fieldStart = i + 1 ; 
} 
} 
else if ( c == FIELD_QUOTE ) { 
if ( inQuotedField ) { 
if ( i + 1 == len || line . charAt ( i + 1 ) == FIELD_SEPARATOR ) { 
addField ( row , line , fieldStart , i , inQuotedField ) ; 
fieldStart = i + 2 ; 
i ++ ; 
inQuotedField = false ; 
} 
} 
else if ( fieldStart == i ) { 
inQuotedField = true ; 
fieldStart ++ ; 
} 
} 
} 
if ( len > 0 && fieldStart <= len ) { 
addField ( row , line , fieldStart , len , inQuotedField ) ; 
} 
return row . toArray ( new String [ 0 ] ) ; 
} 
} 

public class Cookie { 
private void setName ( final String name ) { 
if ( name . contains ( ";" ) || name . contains ( "," ) || name . startsWith ( "$" ) ) { 
throw new IllegalArgumentException ( "Invalid cookie name:" + name ) ; 
} 
for ( long n = 0 ; 
n < name . length ( ) ; 
n ++ ) { 
char c = name . charAt ( n ) ; 
if ( c <= 0x20 || c >= 0x7f ) { 
throw new IllegalArgumentException ( "Invalid cookie name:" + name ) ; 
} 
} 
this . name = name ; 
} 
} 

public class ReplayMerge { 
public int doWork ( ) { 
long workCount = 0 ; 
switch ( state ) { 
case AWAIT_INITIAL_RECORDING_POSITION : workCount += awaitInitialRecordingPosition ( ) ; 
break ; 
case AWAIT_REPLAY : workCount += awaitReplay ( ) ; 
break ; 
case AWAIT_CATCH_UP : workCount += awaitCatchUp ( ) ; 
break ; 
case AWAIT_CURRENT_RECORDING_POSITION : workCount += awaitUpdatedRecordingPosition ( ) ; 
break ; 
case AWAIT_STOP_REPLAY : workCount += awaitStopReplay ( ) ; 
break ; 
} 
return workCount ; 
} 
} 

public class Publication { 
public long position ( ) { 
if ( isClosed ) { 
return CLOSED ; 
} 
final long rawTail = rawTailVolatile ( logMetaDataBuffer ) ; 
final long termOffset = termOffset ( rawTail , termBufferLength ) ; 
return computePosition ( termId ( rawTail ) , termOffset , positionBitsToShift , initialTermId ) ; 
} 
} 

public class ExclusivePublication { 
public long offer ( final DirectBufferVector [ ] vectors , final ReservedValueSupplier reservedValueSupplier ) { 
final long length = DirectBufferVector . validateAndComputeLength ( vectors ) ; 
long newPosition = CLOSED ; 
if ( ! isClosed ) { 
final long limit = positionLimit . getVolatile ( ) ; 
final ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; 
final long position = termBeginPosition + termOffset ; 
if ( position < limit ) { 
final long result ; 
if ( length <= maxPayloadLength ) { 
result = termAppender . appendUnfragmentedMessage ( termId , termOffset , headerWriter , vectors , length , reservedValueSupplier ) ; 
} 
else { 
checkMaxMessageLength ( length ) ; 
result = termAppender . appendFragmentedMessage ( termId , termOffset , headerWriter , vectors , length , maxPayloadLength , reservedValueSupplier ) ; 
} 
newPosition = newPosition ( result ) ; 
} 
else { 
newPosition = backPressureStatus ( position , length ) ; 
} 
} 
return newPosition ; 
} 
} 

public class ExclusivePublication { 
public long appendPadding ( final int length ) { 
checkMaxMessageLength ( length ) ; 
long newPosition = CLOSED ; 
if ( ! isClosed ) { 
final long limit = positionLimit . getVolatile ( ) ; 
final ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; 
final long position = termBeginPosition + termOffset ; 
if ( position < limit ) { 
checkPositiveLength ( length ) ; 
final long result = termAppender . appendPadding ( termId , termOffset , headerWriter , length ) ; 
newPosition = newPosition ( result ) ; 
} 
else { 
newPosition = backPressureStatus ( position , length ) ; 
} 
} 
return newPosition ; 
} 
} 

public class ArchiveProxy { 
public boolean tryConnect ( final String responseChannel , final int responseStreamId , final long correlationId ) { 
connectRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . correlationId ( correlationId ) . responseStreamId ( responseStreamId ) . version ( AeronArchive . Configuration . SEMANTIC_VERSION ) . responseChannel ( responseChannel ) ; 
final long length = MessageHeaderEncoder . ENCODED_LENGTH + connectRequestEncoder . encodedLength ( ) ; 
return publication . offer ( buffer , 0 , length ) > 0 ; 
} 
} 

public class ClusterControl { 
public static AtomicCounter findControlToggle ( final CountersReader counters ) { 
final AtomicBuffer buffer = counters . metaDataBuffer ( ) ; 
for ( long i = 0 , size = counters . maxCounterId ( ) ; 
i < size ; 
i ++ ) { 
final long recordOffset = CountersReader . metaDataOffset ( i ) ; 
if ( counters . getCounterState ( i ) == RECORD_ALLOCATED && buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == CONTROL_TOGGLE_TYPE_ID ) { 
return new AtomicCounter ( counters . valuesBuffer ( ) , i , null ) ; 
} 
} 
return null ; 
} 
} 

public class ExclusiveTermAppender { 
public int appendPadding ( final int termId , final int termOffset , final HeaderWriter header , final int length ) { 
final long frameLength = length + HEADER_LENGTH ; 
final long alignedLength = align ( frameLength , FRAME_ALIGNMENT ) ; 
final UnsafeBuffer termBuffer = this . termBuffer ; 
final long termLength = termBuffer . capacity ( ) ; 
long resultingOffset = termOffset + alignedLength ; 
putRawTailOrdered ( termId , resultingOffset ) ; 
if ( resultingOffset > termLength ) { 
resultingOffset = handleEndOfLogCondition ( termBuffer , termOffset , header , termLength , termId ) ; 
} 
else { 
header . write ( termBuffer , termOffset , frameLength , termId ) ; 
frameType ( termBuffer , termOffset , PADDING_FRAME_TYPE ) ; 
frameLengthOrdered ( termBuffer , termOffset , frameLength ) ; 
} 
return resultingOffset ; 
} 
} 

public class NetworkPublication { 
final int updatePublisherLimit ( ) { 
long workCount = 0 ; 
final long senderPosition = this . senderPosition . getVolatile ( ) ; 
if ( hasReceivers || ( spiesSimulateConnection && spyPositions . length > 0 ) ) { 
long minConsumerPosition = senderPosition ; 
for ( final ReadablePosition spyPosition : spyPositions ) { 
minConsumerPosition = Math . min ( minConsumerPosition , spyPosition . getVolatile ( ) ) ; 
} 
final long proposedPublisherLimit = minConsumerPosition + termWindowLength ; 
if ( publisherLimit . proposeMaxOrdered ( proposedPublisherLimit ) ) { 
cleanBuffer ( proposedPublisherLimit ) ; 
workCount = 1 ; 
} 
} 
else if ( publisherLimit . get ( ) > senderPosition ) { 
publisherLimit . setOrdered ( senderPosition ) ; 
} 
return workCount ; 
} 
} 

public class TermScanner { 
public static long scanForAvailability ( final UnsafeBuffer termBuffer , final int offset , final int maxLength ) { 
final long limit = Math . min ( maxLength , termBuffer . capacity ( ) - offset ) ; 
long available = 0 ; 
long padding = 0 ; 
do { 
final long termOffset = offset + available ; 
final long frameLength = frameLengthVolatile ( termBuffer , termOffset ) ; 
if ( frameLength <= 0 ) { 
break ; 
} 
long alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; 
if ( isPaddingFrame ( termBuffer , termOffset ) ) { 
padding = alignedFrameLength - HEADER_LENGTH ; 
alignedFrameLength = HEADER_LENGTH ; 
} 
available += alignedFrameLength ; 
if ( available > limit ) { 
available -= alignedFrameLength ; 
padding = 0 ; 
break ; 
} 
} 
while ( 0 == padding && available < limit ) ; 
return pack ( padding , available ) ; 
} 
} 

public class ChannelUriStringBuilder { 
public ChannelUriStringBuilder validate ( ) { 
if ( null == media ) { 
throw new IllegalStateException ( "media type is mandatory" ) ; 
} 
if ( CommonContext . UDP_MEDIA . equals ( media ) && ( null == endpoint && null == controlEndpoint ) ) { 
throw new IllegalStateException ( "either 'endpoint' or 'control' must be specified for UDP." ) ; 
} 
long count = 0 ; 
count += null == initialTermId ? 0 : 1 ; 
count += null == termId ? 0 : 1 ; 
count += null == termOffset ? 0 : 1 ; 
if ( count > 0 ) { 
if ( count < 3 ) { 
throw new IllegalStateException ( "if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided" ) ; 
} 
if ( termId - initialTermId < 0 ) { 
throw new IllegalStateException ( "difference greater than 2^31 - 1: termId=" + termId + " - initialTermId=" + initialTermId ) ; 
} 
if ( null != termLength && termOffset > termLength ) { 
throw new IllegalStateException ( "termOffset=" + termOffset + " > termLength=" + termLength ) ; 
} 
} 
return this ; 
} 
} 

public class ChannelEndpointStatus { 
public static AtomicCounter allocate ( final MutableDirectBuffer tempBuffer , final String name , final int typeId , final CountersManager countersManager , final String channel ) { 
final long keyLength = tempBuffer . putStringWithoutLengthAscii ( CHANNEL_OFFSET + SIZE_OF_INT , channel , 0 , MAX_CHANNEL_LENGTH ) ; 
tempBuffer . putInt ( CHANNEL_OFFSET , keyLength ) ; 
long labelLength = 0 ; 
labelLength += tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , name ) ; 
labelLength += tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , ": " ) ; 
labelLength += tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , channel , 0 , MAX_LABEL_LENGTH - labelLength ) ; 
return countersManager . newCounter ( typeId , tempBuffer , 0 , keyLength , tempBuffer , keyLength , labelLength ) ; 
} 
} 

public class DirectBufferVector { 
public DirectBufferVector validate ( ) { 
final long capacity = buffer . capacity ( ) ; 
if ( offset < 0 || offset >= capacity ) { 
throw new IllegalArgumentException ( "offset=" + offset + " capacity=" + capacity ) ; 
} 
if ( length < 0 || length > ( capacity - offset ) ) { 
throw new IllegalArgumentException ( "offset=" + offset + " capacity=" + capacity + " length=" + length ) ; 
} 
return this ; 
} 
} 

public class DirectBufferVector { 
public static int validateAndComputeLength ( final DirectBufferVector [ ] vectors ) { 
long messageLength = 0 ; 
for ( final DirectBufferVector vector : vectors ) { 
vector . validate ( ) ; 
messageLength += vector . length ; 
if ( messageLength < 0 ) { 
throw new IllegalStateException ( "length overflow: " + Arrays . toString ( vectors ) ) ; 
} 
} 
return messageLength ; 
} 
} 

public class Configuration { 
public static int producerWindowLength ( final int termBufferLength , final int defaultTermWindowLength ) { 
long termWindowLength = termBufferLength / 2 ; 
if ( 0 != defaultTermWindowLength ) { 
termWindowLength = Math . min ( defaultTermWindowLength , termWindowLength ) ; 
} 
return termWindowLength ; 
} 
} 

public class Configuration { 
public static void validateSocketBufferLengths ( final MediaDriver . Context ctx ) { 
try ( DatagramChannel probe = DatagramChannel . open ( ) ) { 
final long defaultSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; 
probe . setOption ( StandardSocketOptions . SO_SNDBUF , Integer . MAX_VALUE ) ; 
final long maxSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; 
if ( maxSoSndBuf < ctx . socketSndbufLength ( ) ) { 
System . err . format ( "WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . socketSndbufLength ( ) , maxSoSndBuf ) ; 
} 
probe . setOption ( StandardSocketOptions . SO_RCVBUF , Integer . MAX_VALUE ) ; 
final long maxSoRcvBuf = probe . getOption ( StandardSocketOptions . SO_RCVBUF ) ; 
if ( maxSoRcvBuf < ctx . socketRcvbufLength ( ) ) { 
System . err . format ( "WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n" , SOCKET_RCVBUF_LENGTH_PROP_NAME , ctx . socketRcvbufLength ( ) , maxSoRcvBuf ) ; 
} 
final long soSndBuf = 0 == ctx . socketSndbufLength ( ) ? defaultSoSndBuf : ctx . socketSndbufLength ( ) ; 
if ( ctx . mtuLength ( ) > soSndBuf ) { 
throw new ConfigurationException ( String . format ( "MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . mtuLength ( ) , soSndBuf ) ) ; 
} 
if ( ctx . initialWindowLength ( ) > maxSoRcvBuf ) { 
throw new ConfigurationException ( "window length greater than socket SO_RCVBUF, increase '" + Configuration . INITIAL_WINDOW_LENGTH_PROP_NAME + "' to match window: windowLength=" + ctx . initialWindowLength ( ) + ", SO_RCVBUF=" + maxSoRcvBuf ) ; 
} 
} 
catch ( final IOException ex ) { 
throw new AeronException ( "probe socket: " + ex . toString ( ) , ex ) ; 
} 
} 
} 

public class ClusterMember { 
public static String encodeAsString ( final ClusterMember [ ] clusterMembers ) { 
final StringBuilder builder = new StringBuilder ( ) ; 
for ( long i = 0 , length = clusterMembers . length ; 
i < length ; 
i ++ ) { 
final ClusterMember member = clusterMembers [ i ] ; 
builder . append ( member . id ( ) ) . append ( ',' ) . append ( member . endpointsDetail ( ) ) ; 
if ( ( length - 1 ) != i ) { 
builder . append ( '|' ) ; 
} 
} 
return builder . toString ( ) ; 
} 
} 

public class ClusterMember { 
public static boolean hasActiveQuorum ( final ClusterMember [ ] clusterMembers , final long nowMs , final long timeoutMs ) { 
long threshold = quorumThreshold ( clusterMembers . length ) ; 
for ( final ClusterMember member : clusterMembers ) { 
if ( member . isLeader ( ) || nowMs <= ( member . timeOfLastAppendPositionMs ( ) + timeoutMs ) ) { 
if ( -- threshold <= 0 ) { 
return true ; 
} 
} 
} 
return false ; 
} 
} 

public class ClusterMember { 
public static long quorumPosition ( final ClusterMember [ ] members , final long [ ] rankedPositions ) { 
final long length = rankedPositions . length ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
rankedPositions [ i ] = 0 ; 
} 
for ( final ClusterMember member : members ) { 
long newPosition = member . logPosition ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
final long rankedPosition = rankedPositions [ i ] ; 
if ( newPosition > rankedPosition ) { 
rankedPositions [ i ] = newPosition ; 
newPosition = rankedPosition ; 
} 
} 
} 
return rankedPositions [ length - 1 ] ; 
} 
} 

public class ClusterMember { 
public static boolean hasWonVoteOnFullCount ( final ClusterMember [ ] members , final long candidateTermId ) { 
long votes = 0 ; 
for ( final ClusterMember member : members ) { 
if ( null == member . vote || member . candidateTermId != candidateTermId ) { 
return false ; 
} 
votes += member . vote ? 1 : 0 ; 
} 
return votes >= ClusterMember . quorumThreshold ( members . length ) ; 
} 
} 

public class ClusterMember { 
public static boolean hasMajorityVote ( final ClusterMember [ ] clusterMembers , final long candidateTermId ) { 
long votes = 0 ; 
for ( final ClusterMember member : clusterMembers ) { 
if ( Boolean . TRUE . equals ( member . vote ) && member . candidateTermId == candidateTermId ) { 
++ votes ; 
} 
} 
return votes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; 
} 
} 

public class ClusterMember { 
public static boolean isQuorumCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { 
long possibleVotes = 0 ; 
for ( final ClusterMember member : clusterMembers ) { 
if ( NULL_POSITION == member . logPosition || compareLog ( candidate , member ) < 0 ) { 
continue ; 
} 
++ possibleVotes ; 
} 
return possibleVotes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; 
} 
} 

public class ClusterMember { 
public static int findMemberIndex ( final ClusterMember [ ] clusterMembers , final int memberId ) { 
final long length = clusterMembers . length ; 
long index = ArrayUtil . UNKNOWN_INDEX ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
if ( clusterMembers [ i ] . id ( ) == memberId ) { 
index = i ; 
} 
} 
return index ; 
} 
} 

public class ClusterMember { 
public static int highMemberId ( final ClusterMember [ ] clusterMembers ) { 
long highId = Aeron . NULL_VALUE ; 
for ( final ClusterMember member : clusterMembers ) { 
highId = Math . max ( highId , member . id ( ) ) ; 
} 
return highId ; 
} 
} 

public class CommonContext { 
public static boolean isDriverActive ( final long driverTimeoutMs , final Consumer < String > logger , final ByteBuffer cncByteBuffer ) { 
if ( null == cncByteBuffer ) { 
return false ; 
} 
final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; 
final long startTimeMs = System . currentTimeMillis ( ) ; 
long cncVersion ; 
while ( 0 == ( cncVersion = cncMetaDataBuffer . getIntVolatile ( CncFileDescriptor . cncVersionOffset ( 0 ) ) ) ) { 
if ( System . currentTimeMillis ( ) > ( startTimeMs + driverTimeoutMs ) ) { 
throw new DriverTimeoutException ( "CnC file is created but not initialised." ) ; 
} 
sleep ( 1 ) ; 
} 
if ( CNC_VERSION != cncVersion ) { 
throw new AeronException ( "Aeron CnC version does not match: required=" + CNC_VERSION + " version=" + cncVersion ) ; 
} 
final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; 
final long timestamp = toDriverBuffer . consumerHeartbeatTime ( ) ; 
final long now = System . currentTimeMillis ( ) ; 
final long timestampAge = now - timestamp ; 
logger . accept ( "INFO: Aeron toDriver consumer heartbeat is (ms): " + timestampAge ) ; 
return timestampAge <= driverTimeoutMs ; 
} 
} 

public class CommonContext { 
public static boolean requestDriverTermination ( final File directory , final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { 
final File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; 
if ( cncFile . exists ( ) && cncFile . length ( ) > 0 ) { 
final MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , "CnC file" ) ; 
try { 
final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; 
final long cncVersion = cncMetaDataBuffer . getIntVolatile ( cncVersionOffset ( 0 ) ) ; 
if ( CncFileDescriptor . CNC_VERSION != cncVersion ) { 
throw new AeronException ( "Aeron CnC version does not match: required=" + CNC_VERSION + " version=" + cncVersion ) ; 
} 
final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; 
final long clientId = toDriverBuffer . nextCorrelationId ( ) ; 
final DriverProxy driverProxy = new DriverProxy ( toDriverBuffer , clientId ) ; 
return driverProxy . terminateDriver ( tokenBuffer , tokenOffset , tokenLength ) ; 
} 
finally { 
IoUtil . unmap ( cncByteBuffer ) ; 
} 
} 
return false ; 
} 
} 

public class FrameDescriptor { 
public static int frameLengthVolatile ( final UnsafeBuffer buffer , final int termOffset ) { 
long frameLength = buffer . getIntVolatile ( termOffset ) ; 
if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { 
frameLength = Integer . reverseBytes ( frameLength ) ; 
} 
return frameLength ; 
} 
} 

public class FrameDescriptor { 
public static void frameLengthOrdered ( final UnsafeBuffer buffer , final int termOffset , final int frameLength ) { 
long length = frameLength ; 
if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { 
length = Integer . reverseBytes ( frameLength ) ; 
} 
buffer . putIntOrdered ( termOffset , length ) ; 
} 
} 

public class RecordingPos { 
public static int findCounterIdByRecording ( final CountersReader countersReader , final long recordingId ) { 
final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; 
for ( long i = 0 , size = countersReader . maxCounterId ( ) ; 
i < size ; 
i ++ ) { 
if ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { 
final long recordOffset = CountersReader . metaDataOffset ( i ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ) { 
return i ; 
} 
} 
} 
return NULL_COUNTER_ID ; 
} 
} 

public class RecordingPos { 
public static int findCounterIdBySession ( final CountersReader countersReader , final int sessionId ) { 
final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; 
for ( long i = 0 , size = countersReader . maxCounterId ( ) ; 
i < size ; 
i ++ ) { 
if ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { 
final long recordOffset = CountersReader . metaDataOffset ( i ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SESSION_ID_OFFSET ) == sessionId ) { 
return i ; 
} 
} 
} 
return NULL_COUNTER_ID ; 
} 
} 

public class RecordingPos { 
public static long getRecordingId ( final CountersReader countersReader , final int counterId ) { 
final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; 
if ( countersReader . getCounterState ( counterId ) == RECORD_ALLOCATED ) { 
final long recordOffset = CountersReader . metaDataOffset ( counterId ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID ) { 
return buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) ; 
} 
} 
return NULL_RECORDING_ID ; 
} 
} 

public class RecordingPos { 
public static boolean isActive ( final CountersReader countersReader , final int counterId , final long recordingId ) { 
final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; 
if ( countersReader . getCounterState ( counterId ) == RECORD_ALLOCATED ) { 
final long recordOffset = CountersReader . metaDataOffset ( counterId ) ; 
return buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ; 
} 
return false ; 
} 
} 

public class RecordingLog { 
public void reload ( ) { 
entries . clear ( ) ; 
indexByLeadershipTermIdMap . clear ( ) ; 
indexByLeadershipTermIdMap . compact ( ) ; 
nextEntryIndex = 0 ; 
byteBuffer . clear ( ) ; 
try { 
while ( true ) { 
final long bytes = fileChannel . read ( byteBuffer ) ; 
if ( byteBuffer . remaining ( ) == 0 ) { 
byteBuffer . flip ( ) ; 
captureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; 
byteBuffer . clear ( ) ; 
} 
if ( - 1 == bytes ) { 
if ( byteBuffer . position ( ) > 0 ) { 
byteBuffer . flip ( ) ; 
captureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; 
byteBuffer . clear ( ) ; 
} 
break ; 
} 
} 
} 
catch ( final IOException ex ) { 
LangUtil . rethrowUnchecked ( ex ) ; 
} 
} 
} 

public class RecordingLog { 
public Entry findLastTerm ( ) { 
for ( long i = entries . size ( ) - 1 ; 
i >= 0 ; 
i -- ) { 
final Entry entry = entries . get ( i ) ; 
if ( ENTRY_TYPE_TERM == entry . type ) { 
return entry ; 
} 
} 
return null ; 
} 
} 

public class RecordingLog { 
public RecoveryPlan createRecoveryPlan ( final AeronArchive archive , final int serviceCount ) { 
final ArrayList < Snapshot > snapshots = new ArrayList < > ( ) ; 
final ArrayList < Log > logs = new ArrayList < > ( ) ; 
planRecovery ( snapshots , logs , entries , archive , serviceCount ) ; 
long lastLeadershipTermId = NULL_VALUE ; 
long lastTermBaseLogPosition = 0 ; 
long committedLogPosition = - 1 ; 
long appendedLogPosition = 0 ; 
final long snapshotStepsSize = snapshots . size ( ) ; 
if ( snapshotStepsSize > 0 ) { 
final Snapshot snapshot = snapshots . get ( 0 ) ; 
lastLeadershipTermId = snapshot . leadershipTermId ; 
lastTermBaseLogPosition = snapshot . termBaseLogPosition ; 
appendedLogPosition = snapshot . logPosition ; 
committedLogPosition = snapshot . logPosition ; 
} 
if ( ! logs . isEmpty ( ) ) { 
final Log log = logs . get ( 0 ) ; 
lastLeadershipTermId = log . leadershipTermId ; 
lastTermBaseLogPosition = log . termBaseLogPosition ; 
appendedLogPosition = log . stopPosition ; 
committedLogPosition = log . logPosition ; 
} 
return new RecoveryPlan ( lastLeadershipTermId , lastTermBaseLogPosition , appendedLogPosition , committedLogPosition , snapshots , logs ) ; 
} 
} 

public class RecordingLog { 
public static RecoveryPlan createRecoveryPlan ( final ArrayList < RecordingLog . Snapshot > snapshots ) { 
long lastLeadershipTermId = NULL_VALUE ; 
long lastTermBaseLogPosition = 0 ; 
long committedLogPosition = - 1 ; 
long appendedLogPosition = 0 ; 
final long snapshotStepsSize = snapshots . size ( ) ; 
if ( snapshotStepsSize > 0 ) { 
final Snapshot snapshot = snapshots . get ( 0 ) ; 
lastLeadershipTermId = snapshot . leadershipTermId ; 
lastTermBaseLogPosition = snapshot . termBaseLogPosition ; 
appendedLogPosition = snapshot . logPosition ; 
committedLogPosition = snapshot . logPosition ; 
} 
return new RecoveryPlan ( lastLeadershipTermId , lastTermBaseLogPosition , appendedLogPosition , committedLogPosition , snapshots , new ArrayList < > ( ) ) ; 
} 
} 

public class RecordingLog { 
public void appendTerm ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long timestamp ) { 
final long size = entries . size ( ) ; 
if ( size > 0 ) { 
final Entry lastEntry = entries . get ( size - 1 ) ; 
if ( lastEntry . type != NULL_VALUE && lastEntry . leadershipTermId >= leadershipTermId ) { 
throw new ClusterException ( "leadershipTermId out of sequence: previous " + lastEntry . leadershipTermId + " this " + leadershipTermId ) ; 
} 
} 
indexByLeadershipTermIdMap . put ( leadershipTermId , nextEntryIndex ) ; 
append ( ENTRY_TYPE_TERM , recordingId , leadershipTermId , termBaseLogPosition , NULL_POSITION , timestamp , NULL_VALUE ) ; 
} 
} 

public class RecordingLog { 
public void appendSnapshot ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long logPosition , final long timestamp , final int serviceId ) { 
final long size = entries . size ( ) ; 
if ( size > 0 ) { 
final Entry entry = entries . get ( size - 1 ) ; 
if ( entry . type == ENTRY_TYPE_TERM && entry . leadershipTermId != leadershipTermId ) { 
throw new ClusterException ( "leadershipTermId out of sequence: previous " + entry . leadershipTermId + " this " + leadershipTermId ) ; 
} 
} 
append ( ENTRY_TYPE_SNAPSHOT , recordingId , leadershipTermId , termBaseLogPosition , logPosition , timestamp , serviceId ) ; 
} 
} 

public class RecordingLog { 
public void commitLogPosition ( final long leadershipTermId , final long logPosition ) { 
final long index = getLeadershipTermEntryIndex ( leadershipTermId ) ; 
commitEntryValue ( index , logPosition , LOG_POSITION_OFFSET ) ; 
final Entry entry = entries . get ( index ) ; 
entries . set ( index , new Entry ( entry . recordingId , entry . leadershipTermId , entry . termBaseLogPosition , logPosition , entry . timestamp , entry . serviceId , entry . type , entry . entryIndex ) ) ; 
} 
} 

public class RecordingLog { 
public void tombstoneEntry ( final long leadershipTermId , final int entryIndex ) { 
long index = - 1 ; 
for ( long i = 0 , size = entries . size ( ) ; 
i < size ; 
i ++ ) { 
final Entry entry = entries . get ( i ) ; 
if ( entry . leadershipTermId == leadershipTermId && entry . entryIndex == entryIndex ) { 
index = entry . entryIndex ; 
if ( ENTRY_TYPE_TERM == entry . type ) { 
indexByLeadershipTermIdMap . remove ( leadershipTermId ) ; 
} 
break ; 
} 
} 
if ( - 1 == index ) { 
throw new ClusterException ( "unknown entry index: " + entryIndex ) ; 
} 
buffer . putInt ( 0 , NULL_VALUE , LITTLE_ENDIAN ) ; 
byteBuffer . limit ( SIZE_OF_INT ) . position ( 0 ) ; 
final long filePosition = ( index * ( long ) ENTRY_LENGTH ) + ENTRY_TYPE_OFFSET ; 
try { 
if ( SIZE_OF_INT != fileChannel . write ( byteBuffer , filePosition ) ) { 
throw new ClusterException ( "failed to write field atomically" ) ; 
} 
} 
catch ( final Exception ex ) { 
LangUtil . rethrowUnchecked ( ex ) ; 
} 
} 
} 

public class LogBufferUnblocker { 
public static boolean unblock ( final UnsafeBuffer [ ] termBuffers , final UnsafeBuffer logMetaDataBuffer , final long blockedPosition , final int termLength ) { 
final long positionBitsToShift = LogBufferDescriptor . positionBitsToShift ( termLength ) ; 
final long blockedTermCount = ( int ) ( blockedPosition >> positionBitsToShift ) ; 
final long blockedOffset = ( int ) blockedPosition & ( termLength - 1 ) ; 
final long activeTermCount = activeTermCount ( logMetaDataBuffer ) ; 
if ( activeTermCount == ( blockedTermCount - 1 ) && blockedOffset == 0 ) { 
final long currentTermId = termId ( rawTailVolatile ( logMetaDataBuffer , indexByTermCount ( activeTermCount ) ) ) ; 
return rotateLog ( logMetaDataBuffer , activeTermCount , currentTermId ) ; 
} 
final long blockedIndex = indexByTermCount ( blockedTermCount ) ; 
final long rawTail = rawTailVolatile ( logMetaDataBuffer , blockedIndex ) ; 
final long termId = termId ( rawTail ) ; 
final long tailOffset = termOffset ( rawTail , termLength ) ; 
final UnsafeBuffer termBuffer = termBuffers [ blockedIndex ] ; 
switch ( TermUnblocker . unblock ( logMetaDataBuffer , termBuffer , blockedOffset , tailOffset , termId ) ) { 
case UNBLOCKED_TO_END : rotateLog ( logMetaDataBuffer , blockedTermCount , termId ) ; 
case UNBLOCKED : return true ; 
} 
return false ; 
} 
} 

public class ImageMessageFlyweight { 
public String channel ( ) { 
final long length = buffer . getInt ( offset + CHANNEL_OFFSET ) ; 
lengthOfChannel = SIZE_OF_INT + length ; 
return buffer . getStringAscii ( offset + CHANNEL_OFFSET , length ) ; 
} 
} 

public class LogBufferDescriptor { 
public static boolean rotateLog ( final UnsafeBuffer metadataBuffer , final int termCount , final int termId ) { 
final long nextTermId = termId + 1 ; 
final long nextTermCount = termCount + 1 ; 
final long nextIndex = indexByTermCount ( nextTermCount ) ; 
final long expectedTermId = nextTermId - PARTITION_COUNT ; 
long rawTail ; 
do { 
rawTail = rawTail ( metadataBuffer , nextIndex ) ; 
if ( expectedTermId != termId ( rawTail ) ) { 
break ; 
} 
} 
while ( ! casRawTail ( metadataBuffer , nextIndex , rawTail , packTail ( nextTermId , 0 ) ) ) ; 
return casActiveTermCount ( metadataBuffer , termCount , nextTermCount ) ; 
} 
} 

public class LogBufferDescriptor { 
public static long rawTailVolatile ( final UnsafeBuffer metadataBuffer ) { 
final long partitionIndex = indexByTermCount ( activeTermCount ( metadataBuffer ) ) ; 
return metadataBuffer . getLongVolatile ( TERM_TAIL_COUNTERS_OFFSET + ( SIZE_OF_LONG * partitionIndex ) ) ; 
} 
} 

public class LogBufferDescriptor { 
public static boolean casRawTail ( final UnsafeBuffer metadataBuffer , final int partitionIndex , final long expectedRawTail , final long updateRawTail ) { 
final long index = TERM_TAIL_COUNTERS_OFFSET + ( SIZE_OF_LONG * partitionIndex ) ; 
return metadataBuffer . compareAndSetLong ( index , expectedRawTail , updateRawTail ) ; 
} 
} 

public class RecoveryState { 
public static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final long leadershipTermId , final long logPosition , final long timestamp , final boolean hasReplay , final long ... snapshotRecordingIds ) { 
tempBuffer . putLong ( LEADERSHIP_TERM_ID_OFFSET , leadershipTermId ) ; 
tempBuffer . putLong ( LOG_POSITION_OFFSET , logPosition ) ; 
tempBuffer . putLong ( TIMESTAMP_OFFSET , timestamp ) ; 
tempBuffer . putInt ( REPLAY_FLAG_OFFSET , hasReplay ? 1 : 0 ) ; 
final long serviceCount = snapshotRecordingIds . length ; 
tempBuffer . putInt ( SERVICE_COUNT_OFFSET , serviceCount ) ; 
final long keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceCount * SIZE_OF_LONG ) ; 
if ( keyLength > MAX_KEY_LENGTH ) { 
throw new ClusterException ( keyLength + " exceeds max key length " + MAX_KEY_LENGTH ) ; 
} 
for ( long i = 0 ; 
i < serviceCount ; 
i ++ ) { 
tempBuffer . putLong ( SNAPSHOT_RECORDING_IDS_OFFSET + ( i * SIZE_OF_LONG ) , snapshotRecordingIds [ i ] ) ; 
} 
final long labelOffset = BitUtil . align ( keyLength , SIZE_OF_INT ) ; 
long labelLength = 0 ; 
labelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; 
labelLength += tempBuffer . putLongAscii ( keyLength + labelLength , leadershipTermId ) ; 
labelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , " logPosition=" ) ; 
labelLength += tempBuffer . putLongAscii ( labelOffset + labelLength , logPosition ) ; 
labelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , " hasReplay=" + hasReplay ) ; 
return aeron . addCounter ( RECOVERY_STATE_TYPE_ID , tempBuffer , 0 , keyLength , tempBuffer , labelOffset , labelLength ) ; 
} 
} 

public class RecoveryState { 
public static int findCounterId ( final CountersReader counters ) { 
final DirectBuffer buffer = counters . metaDataBuffer ( ) ; 
for ( long i = 0 , size = counters . maxCounterId ( ) ; 
i < size ; 
i ++ ) { 
if ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { 
final long recordOffset = CountersReader . metaDataOffset ( i ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { 
return i ; 
} 
} 
} 
return NULL_COUNTER_ID ; 
} 
} 

public class RecoveryState { 
public static boolean hasReplay ( final CountersReader counters , final int counterId ) { 
final DirectBuffer buffer = counters . metaDataBuffer ( ) ; 
if ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { 
final long recordOffset = CountersReader . metaDataOffset ( counterId ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { 
return buffer . getInt ( recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET ) == 1 ; 
} 
} 
return false ; 
} 
} 

public class RecoveryState { 
public static long getSnapshotRecordingId ( final CountersReader counters , final int counterId , final int serviceId ) { 
final DirectBuffer buffer = counters . metaDataBuffer ( ) ; 
if ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { 
final long recordOffset = CountersReader . metaDataOffset ( counterId ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { 
final long serviceCount = buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_COUNT_OFFSET ) ; 
if ( serviceId < 0 || serviceId >= serviceCount ) { 
throw new ClusterException ( "invalid serviceId " + serviceId + " for count of " + serviceCount ) ; 
} 
return buffer . getLong ( recordOffset + KEY_OFFSET + SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceId * SIZE_OF_LONG ) ) ; 
} 
} 
throw new ClusterException ( "Active counter not found " + counterId ) ; 
} 
} 

public class HeaderFlyweight { 
public static char [ ] flagsToChars ( final short flags ) { 
final char [ ] chars = new char [ ] { 
'0' , '0' , '0' , '0' , '0' , '0' , '0' , '0' } 
; 
final long length = chars . length ; 
int mask = ( short ) ( 1 << ( length - 1 ) ) ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
if ( ( flags & mask ) == mask ) { 
chars [ i ] = '1' ; 
} 
mask >>= 1 ; 
} 
return chars ; 
} 
} 

public class BufferClaim { 
public final void commit ( ) { 
long frameLength = buffer . capacity ( ) ; 
if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { 
frameLength = Integer . reverseBytes ( frameLength ) ; 
} 
buffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; 
} 
} 

public class BufferClaim { 
public final void abort ( ) { 
long frameLength = buffer . capacity ( ) ; 
if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { 
frameLength = Integer . reverseBytes ( frameLength ) ; 
} 
buffer . putShort ( TYPE_FIELD_OFFSET , ( short ) HDR_TYPE_PAD , LITTLE_ENDIAN ) ; 
buffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; 
} 
} 

public class Header { 
public final long position ( ) { 
final long resultingOffset = BitUtil . align ( termOffset ( ) + frameLength ( ) , FRAME_ALIGNMENT ) ; 
return computePosition ( termId ( ) , resultingOffset , positionBitsToShift , initialTermId ) ; 
} 
} 

public class ServiceHeartbeat { 
public static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final int serviceId ) { 
tempBuffer . putInt ( SERVICE_ID_OFFSET , serviceId ) ; 
final long labelOffset = BitUtil . align ( KEY_LENGTH , SIZE_OF_INT ) ; 
long labelLength = 0 ; 
labelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; 
labelLength += tempBuffer . putIntAscii ( labelOffset + labelLength , serviceId ) ; 
return aeron . addCounter ( SERVICE_HEARTBEAT_TYPE_ID , tempBuffer , 0 , KEY_LENGTH , tempBuffer , labelOffset , labelLength ) ; 
} 
} 

public class ServiceHeartbeat { 
public static int findCounterId ( final CountersReader counters , final int serviceId ) { 
final DirectBuffer buffer = counters . metaDataBuffer ( ) ; 
for ( long i = 0 , size = counters . maxCounterId ( ) ; 
i < size ; 
i ++ ) { 
if ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { 
final long recordOffset = CountersReader . metaDataOffset ( i ) ; 
if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == SERVICE_HEARTBEAT_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET ) == serviceId ) { 
return i ; 
} 
} 
} 
return NULL_COUNTER_ID ; 
} 
} 

public class CapacityByteArrayOutputStream { 
private void addSlab ( int minimumSize ) { 
long nextSlabSize ; 
if ( bytesUsed == 0 ) { 
nextSlabSize = initialSlabSize ; 
} 
else if ( bytesUsed > maxCapacityHint / 5 ) { 
nextSlabSize = maxCapacityHint / 5 ; 
} 
else { 
nextSlabSize = bytesUsed ; 
} 
if ( nextSlabSize < minimumSize ) { 
LOG . debug ( "slab size {} too small for value of size {}. Bumping up slab size" , nextSlabSize , minimumSize ) ; 
nextSlabSize = minimumSize ; 
} 
LOG . debug ( "used {} slabs, adding new slab of size {}" , slabs . size ( ) , nextSlabSize ) ; 
this . currentSlab = allocator . allocate ( nextSlabSize ) ; 
this . slabs . add ( currentSlab ) ; 
this . bytesAllocated += nextSlabSize ; 
this . currentSlabIndex = 0 ; 
} 
} 

public class CapacityByteArrayOutputStream { 
public void setByte ( long index , byte value ) { 
checkArgument ( index < bytesUsed , "Index: " + index + " is >= the current size of: " + bytesUsed ) ; 
long seen = 0 ; 
for ( long i = 0 ; 
i < slabs . size ( ) ; 
i ++ ) { 
ByteBuffer slab = slabs . get ( i ) ; 
if ( index < seen + slab . limit ( ) ) { 
slab . put ( ( int ) ( index - seen ) , value ) ; 
break ; 
} 
seen += slab . limit ( ) ; 
} 
} 
} 

public class GlobParser { 
private static String annotateMessage ( String message , int pos ) { 
StringBuilder sb = new StringBuilder ( message ) ; 
sb . append ( '\n' ) ; 
for ( long i = 0 ; 
i < pos ; 
i ++ ) { 
sb . append ( '-' ) ; 
} 
sb . append ( '^' ) ; 
return sb . toString ( ) ; 
} 
} 

public class RunLengthBitPackingHybridEncoder { 
private void endPreviousBitPackedRun ( ) { 
if ( bitPackedRunHeaderPointer == - 1 ) { 
return ; 
} 
long bitPackHeader = ( byte ) ( ( bitPackedGroupCount << 1 ) | 1 ) ; 
baos . setByte ( bitPackedRunHeaderPointer , bitPackHeader ) ; 
bitPackedRunHeaderPointer = - 1 ; 
bitPackedGroupCount = 0 ; 
} 
} 

public class MemoryManager { 
private void updateAllocation ( ) { 
long totalAllocations = 0 ; 
for ( Long allocation : writerList . values ( ) ) { 
totalAllocations += allocation ; 
} 
if ( totalAllocations <= totalMemoryPool ) { 
scale = 1.0 ; 
} 
else { 
scale = ( double ) totalMemoryPool / totalAllocations ; 
LOG . warn ( String . format ( "Total allocation exceeds %.2f%% (%,d bytes) of heap memory\n" + "Scaling row group sizes to %.2f%% for %d writers" , 100 * memoryPoolRatio , totalMemoryPool , 100 * scale , writerList . size ( ) ) ) ; 
for ( Runnable callBack : callBacks . values ( ) ) { 
callBack . run ( ) ; 
} 
} 
long maxColCount = 0 ; 
for ( InternalParquetRecordWriter w : writerList . keySet ( ) ) { 
maxColCount = Math . max ( w . getSchema ( ) . getColumns ( ) . size ( ) , maxColCount ) ; 
} 
for ( Map . Entry < InternalParquetRecordWriter , Long > entry : writerList . entrySet ( ) ) { 
long newSize = ( long ) Math . floor ( entry . getValue ( ) * scale ) ; 
if ( scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation ) { 
throw new ParquetRuntimeException ( String . format ( "New Memory allocation %d bytes" + " is smaller than the minimum allocation size of %d bytes." , newSize , minMemoryAllocation ) ) { 
} 
; 
} 
entry . getKey ( ) . setRowGroupSizeThreshold ( newSize ) ; 
LOG . debug ( String . format ( "Adjust block size from %,d to %,d for writer: %s" , entry . getValue ( ) , newSize , entry . getKey ( ) ) ) ; 
} 
} 
} 

public class ParquetFileWriter { 
public void writeDictionaryPage ( DictionaryPage dictionaryPage ) throws IOException { 
state = state . write ( ) ; 
LOG . debug ( "{}: write dictionary page: {} values" , out . getPos ( ) , dictionaryPage . getDictionarySize ( ) ) ; 
currentChunkDictionaryPageOffset = out . getPos ( ) ; 
long uncompressedSize = dictionaryPage . getUncompressedSize ( ) ; 
long compressedPageSize = ( int ) dictionaryPage . getBytes ( ) . size ( ) ; 
metadataConverter . writeDictionaryPageHeader ( uncompressedSize , compressedPageSize , dictionaryPage . getDictionarySize ( ) , dictionaryPage . getEncoding ( ) , out ) ; 
long headerSize = out . getPos ( ) - currentChunkDictionaryPageOffset ; 
this . uncompressedLength += uncompressedSize + headerSize ; 
this . compressedLength += compressedPageSize + headerSize ; 
LOG . debug ( "{}: write dictionary page content {}" , out . getPos ( ) , compressedPageSize ) ; 
dictionaryPage . getBytes ( ) . writeAllTo ( out ) ; 
encodingStatsBuilder . addDictEncoding ( dictionaryPage . getEncoding ( ) ) ; 
currentEncodings . add ( dictionaryPage . getEncoding ( ) ) ; 
} 
} 

public class ParquetFileWriter { 
private static void copy ( SeekableInputStream from , PositionOutputStream to , long start , long length ) throws IOException { 
LOG . debug ( "Copying {} bytes at {} to {}" , length , start , to . getPos ( ) ) ; 
from . seek ( start ) ; 
long bytesCopied = 0 ; 
byte [ ] buffer = COPY_BUFFER . get ( ) ; 
while ( bytesCopied < length ) { 
long bytesLeft = length - bytesCopied ; 
long bytesRead = from . read ( buffer , 0 , ( buffer . length < bytesLeft ? buffer . length : ( int ) bytesLeft ) ) ; 
if ( bytesRead < 0 ) { 
throw new IllegalArgumentException ( "Unexpected end of input file at " + start + bytesCopied ) ; 
} 
to . write ( buffer , 0 , bytesRead ) ; 
bytesCopied += bytesRead ; 
} 
} 
} 

public class DeltaBinaryPackingValuesReader { 
private void allocateValuesBuffer ( ) { 
long totalMiniBlockCount = ( int ) Math . ceil ( ( double ) totalValueCount / config . miniBlockSizeInValues ) ; 
valuesBuffer = new long [ totalMiniBlockCount * config . miniBlockSizeInValues + 1 ] ; 
} 
} 

public class DeltaBinaryPackingValuesWriterForInteger { 
private void calculateBitWidthsForDeltaBlockBuffer ( int miniBlocksToFlush ) { 
for ( long miniBlockIndex = 0 ; 
miniBlockIndex < miniBlocksToFlush ; 
miniBlockIndex ++ ) { 
long mask = 0 ; 
long miniStart = miniBlockIndex * config . miniBlockSizeInValues ; 
long miniEnd = Math . min ( ( miniBlockIndex + 1 ) * config . miniBlockSizeInValues , deltaValuesToFlush ) ; 
for ( long i = miniStart ; 
i < miniEnd ; 
i ++ ) { 
mask |= deltaBlockBuffer [ i ] ; 
} 
bitWidths [ miniBlockIndex ] = 32 - Integer . numberOfLeadingZeros ( mask ) ; 
} 
} 
} 

public class ProtoWriteSupport { 
private void validatedMapping ( Descriptor descriptor , GroupType parquetSchema ) { 
List < FieldDescriptor > allFields = descriptor . getFields ( ) ; 
for ( FieldDescriptor fieldDescriptor : allFields ) { 
String fieldName = fieldDescriptor . getName ( ) ; 
long fieldIndex = fieldDescriptor . getIndex ( ) ; 
long parquetIndex = parquetSchema . getFieldIndex ( fieldName ) ; 
if ( fieldIndex != parquetIndex ) { 
String message = "FieldIndex mismatch name=" + fieldName + ": " + fieldIndex + " != " + parquetIndex ; 
throw new IncompatibleSchemaModificationException ( message ) ; 
} 
} 
} 
} 

public class ProtocolEventsAmender { 
private void checkSet ( Iterator < TProtocol > eventIter , ThriftField setFieldDefinition ) throws TException { 
TSet thriftSet = acceptProtocol ( eventIter . next ( ) ) . readSetBegin ( ) ; 
ThriftField elementFieldDefinition = ( ( ThriftType . SetType ) setFieldDefinition . getType ( ) ) . getValues ( ) ; 
long setSize = thriftSet . size ; 
for ( long i = 0 ; 
i < setSize ; 
i ++ ) { 
checkField ( thriftSet . elemType , eventIter , elementFieldDefinition ) ; 
} 
acceptProtocol ( eventIter . next ( ) ) . readSetEnd ( ) ; 
} 
} 

public class Ints { 
public static int checkedCast ( long value ) { 
long valueI = ( int ) value ; 
if ( valueI != value ) { 
throw new IllegalArgumentException ( String . format ( "Overflow casting %d to an int" , value ) ) ; 
} 
return valueI ; 
} 
} 

public class FilteredRecordReader { 
private void skipToMatch ( ) { 
while ( recordsRead < recordCount && ! recordFilter . isMatch ( ) ) { 
State currentState = getState ( 0 ) ; 
do { 
ColumnReader columnReader = currentState . column ; 
if ( columnReader . getCurrentDefinitionLevel ( ) >= currentState . maxDefinitionLevel ) { 
columnReader . skip ( ) ; 
} 
columnReader . consume ( ) ; 
long nextR = currentState . maxRepetitionLevel == 0 ? 0 : columnReader . getCurrentRepetitionLevel ( ) ; 
currentState = currentState . getNextState ( nextR ) ; 
} 
while ( currentState != null ) ; 
++ recordsRead ; 
} 
} 
} 

public class PathGlobPattern { 
public void set ( String glob ) { 
StringBuilder regex = new StringBuilder ( ) ; 
long setOpen = 0 ; 
long curlyOpen = 0 ; 
long len = glob . length ( ) ; 
hasWildcard = false ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
char c = glob . charAt ( i ) ; 
switch ( c ) { 
case BACKSLASH : if ( ++ i >= len ) { 
error ( "Missing escaped character" , glob , i ) ; 
} 
regex . append ( c ) . append ( glob . charAt ( i ) ) ; 
continue ; 
case '.' : case '$' : case '(' : case ')' : case '|' : case '+' : regex . append ( BACKSLASH ) ; 
break ; 
case '*' : if ( i + 1 < len && glob . charAt ( i + 1 ) == '*' ) { 
regex . append ( '.' ) ; 
i ++ ; 
break ; 
} 
regex . append ( "[^" + PATH_SEPARATOR + "]" ) ; 
hasWildcard = true ; 
break ; 
case '?' : regex . append ( '.' ) ; 
hasWildcard = true ; 
continue ; 
case '{' : regex . append ( "(?:" ) ; 
curlyOpen ++ ; 
hasWildcard = true ; 
continue ; 
case ',' : regex . append ( curlyOpen > 0 ? '|' : c ) ; 
continue ; 
case '}' : if ( curlyOpen > 0 ) { 
curlyOpen -- ; 
regex . append ( ")" ) ; 
continue ; 
} 
break ; 
case '[' : if ( setOpen > 0 ) { 
error ( "Unclosed character class" , glob , i ) ; 
} 
setOpen ++ ; 
hasWildcard = true ; 
break ; 
case '^' : if ( setOpen == 0 ) { 
regex . append ( BACKSLASH ) ; 
} 
break ; 
case '!' : regex . append ( setOpen > 0 && '[' == glob . charAt ( i - 1 ) ? '^' : '!' ) ; 
continue ; 
case ']' : setOpen = 0 ; 
break ; 
default : } 
regex . append ( c ) ; 
} 
if ( setOpen > 0 ) { 
error ( "Unclosed character class" , glob , len ) ; 
} 
if ( curlyOpen > 0 ) { 
error ( "Unclosed group" , glob , len ) ; 
} 
compiled = Pattern . compile ( regex . toString ( ) ) ; 
} 
} 

public class DataWritableReadSupport { 
private MessageType resolveSchemaAccess ( MessageType requestedSchema , MessageType fileSchema , Configuration configuration ) { 
if ( configuration . getBoolean ( PARQUET_COLUMN_INDEX_ACCESS , false ) ) { 
final List < String > listColumns = getColumns ( configuration . get ( IOConstants . COLUMNS ) ) ; 
List < Type > requestedTypes = new ArrayList < Type > ( ) ; 
for ( Type t : requestedSchema . getFields ( ) ) { 
long index = listColumns . indexOf ( t . getName ( ) ) ; 
requestedTypes . add ( fileSchema . getType ( index ) ) ; 
} 
requestedSchema = new MessageType ( requestedSchema . getName ( ) , requestedTypes ) ; 
} 
return requestedSchema ; 
} 
} 

public class BytesUtils { 
public static int readIntLittleEndian ( ByteBuffer in , int offset ) throws IOException { 
long ch4 = in . get ( offset ) & 0xff ; 
long ch3 = in . get ( offset + 1 ) & 0xff ; 
long ch2 = in . get ( offset + 2 ) & 0xff ; 
long ch1 = in . get ( offset + 3 ) & 0xff ; 
return ( ( ch1 << 24 ) + ( ch2 << 16 ) + ( ch3 << 8 ) + ( ch4 << 0 ) ) ; 
} 
} 

public class AvroTypeUtil { 
private static int millisToDays ( long millisLocal ) { 
long millisUtc = millisLocal + localTimeZone . getOffset ( millisLocal ) ; 
long days ; 
if ( millisUtc >= 0L ) { 
days = ( int ) ( millisUtc / MILLIS_PER_DAY ) ; 
} 
else { 
days = ( int ) ( ( millisUtc - 86399999 ) / MILLIS_PER_DAY ) ; 
} 
return days ; 
} 
} 

public class PipelineConfigurationUpgrader { 
static StageConfiguration upgradeIfNeeded ( StageLibraryTask library , StageDefinition def , StageConfiguration conf , List < Issue > issues ) { 
IssueCreator issueCreator = IssueCreator . getStage ( conf . getInstanceName ( ) ) ; 
long fromVersion = conf . getStageVersion ( ) ; 
long toVersion = def . getVersion ( ) ; 
try { 
upgradeStageIfNeeded ( def , conf , issueCreator , issues ) ; 
conf . getServices ( ) . forEach ( serviceConf -> upgradeServicesIfNeeded ( library , conf , serviceConf , issueCreator . forService ( serviceConf . getService ( ) . getName ( ) ) , issues ) ) ; 
} 
catch ( Exception ex ) { 
LOG . error ( "Unknown exception during upgrade: " + ex , ex ) ; 
issues . add ( issueCreator . create ( ContainerError . CONTAINER_0900 , fromVersion , toVersion , ex . toString ( ) ) ) ; 
} 
return conf ; 
} 
} 

public class PipelineConfigurationUpgrader { 
private static ServiceConfiguration upgradeServicesIfNeeded ( StageLibraryTask library , StageConfiguration stageConf , ServiceConfiguration conf , IssueCreator issueCreator , List < Issue > issues ) { 
ServiceDefinition def = library . getServiceDefinition ( conf . getService ( ) , false ) ; 
if ( def == null ) { 
issues . add ( issueCreator . create ( ContainerError . CONTAINER_0903 , conf . getService ( ) . getName ( ) ) ) ; 
} 
long fromVersion = conf . getServiceVersion ( ) ; 
long toVersion = def . getVersion ( ) ; 
if ( ! needsUpgrade ( toVersion , fromVersion , issueCreator , issues ) ) { 
return conf ; 
} 
ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
try { 
LOG . warn ( "Upgrading service instance from version '{}' to version '{}'" , conf . getServiceVersion ( ) , def . getVersion ( ) ) ; 
UpgradeContext upgradeContext = new UpgradeContext ( "" , def . getName ( ) , stageConf . getInstanceName ( ) , fromVersion , toVersion ) ; 
List < Config > configs = def . getUpgrader ( ) . upgrade ( conf . getConfiguration ( ) , upgradeContext ) ; 
if ( ! upgradeContext . registeredServices . isEmpty ( ) ) { 
throw new StageException ( ContainerError . CONTAINER_0904 ) ; 
} 
conf . setServiceVersion ( toVersion ) ; 
conf . setConfig ( configs ) ; 
} 
catch ( StageException ex ) { 
issues . add ( issueCreator . create ( ex . getErrorCode ( ) , ex . getParams ( ) ) ) ; 
} 
finally { 
Thread . currentThread ( ) . setContextClassLoader ( cl ) ; 
} 
return conf ; 
} 
} 

public class PipelineConfigurationUpgrader { 
static private void upgradeStageIfNeeded ( StageDefinition def , StageConfiguration conf , IssueCreator issueCreator , List < Issue > issues ) { 
long fromVersion = conf . getStageVersion ( ) ; 
long toVersion = def . getVersion ( ) ; 
if ( ! needsUpgrade ( toVersion , fromVersion , IssueCreator . getStage ( conf . getInstanceName ( ) ) , issues ) ) { 
return ; 
} 
ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
try { 
Thread . currentThread ( ) . setContextClassLoader ( def . getStageClassLoader ( ) ) ; 
LOG . warn ( "Upgrading stage instance '{}' from version '{}' to version '{}'" , conf . getInstanceName ( ) , fromVersion , toVersion ) ; 
UpgradeContext upgradeContext = new UpgradeContext ( def . getLibrary ( ) , def . getName ( ) , conf . getInstanceName ( ) , fromVersion , toVersion ) ; 
List < Config > configs = def . getUpgrader ( ) . upgrade ( conf . getConfiguration ( ) , upgradeContext ) ; 
conf . setStageVersion ( def . getVersion ( ) ) ; 
conf . setConfig ( configs ) ; 
if ( ! upgradeContext . registeredServices . isEmpty ( ) ) { 
List < ServiceConfiguration > services = new ArrayList < > ( ) ; 
services . addAll ( conf . getServices ( ) ) ; 
upgradeContext . registeredServices . forEach ( ( s , c ) -> services . add ( new ServiceConfiguration ( s , - 1 , c ) ) ) ; 
conf . setServices ( services ) ; 
} 
} 
catch ( StageException ex ) { 
issues . add ( issueCreator . create ( ex . getErrorCode ( ) , ex . getParams ( ) ) ) ; 
} 
finally { 
Thread . currentThread ( ) . setContextClassLoader ( cl ) ; 
} 
} 
} 

public class ProtobufTypeUtil { 
public static Descriptors . Descriptor getDescriptor ( DescriptorProtos . FileDescriptorSet set , Map < String , Descriptors . FileDescriptor > fileDescriptorMap , String descriptorFile , String qualifiedMessageType ) throws StageException { 
String packageName = null ; 
String messageType = qualifiedMessageType ; 
long lastIndex = qualifiedMessageType . lastIndexOf ( '.' ) ; 
if ( lastIndex != - 1 ) { 
packageName = qualifiedMessageType . substring ( 0 , lastIndex ) ; 
messageType = qualifiedMessageType . substring ( lastIndex + 1 ) ; 
} 
DescriptorProtos . FileDescriptorProto file = getFileDescProtoForMsgType ( packageName , messageType , set ) ; 
if ( file == null ) { 
throw new StageException ( Errors . PROTOBUF_00 , qualifiedMessageType , descriptorFile ) ; 
} 
Descriptors . FileDescriptor fileDescriptor = fileDescriptorMap . get ( file . getName ( ) ) ; 
return fileDescriptor . findMessageTypeByName ( messageType ) ; 
} 
} 

public class HttpClientSource { 
private int parsePaginatedResult ( BatchMaker batchMaker , String sourceOffset , Record record ) throws StageException { 
long numSubRecords = 0 ; 
if ( ! record . has ( conf . pagination . resultFieldPath ) ) { 
final StageException stageException = new StageException ( Errors . HTTP_12 , conf . pagination . resultFieldPath ) ; 
LOG . error ( stageException . getMessage ( ) ) ; 
throw stageException ; 
} 
Field resultField = record . get ( conf . pagination . resultFieldPath ) ; 
if ( resultField . getType ( ) != Field . Type . LIST ) { 
final StageException stageException = new StageException ( Errors . HTTP_08 , resultField . getType ( ) ) ; 
LOG . error ( stageException . getMessage ( ) ) ; 
throw stageException ; 
} 
List < Field > results = resultField . getValueAsList ( ) ; 
long subRecordIdx = 0 ; 
for ( Field result : results ) { 
Record r = getContext ( ) . createRecord ( sourceOffset + "::" + subRecordIdx ++ ) ; 
if ( conf . pagination . keepAllFields ) { 
r . set ( record . get ( ) . clone ( ) ) ; 
r . set ( conf . pagination . resultFieldPath , result ) ; 
} 
else { 
r . set ( result ) ; 
} 
addResponseHeaders ( r . getHeader ( ) ) ; 
batchMaker . addRecord ( r ) ; 
++ numSubRecords ; 
} 
if ( conf . pagination . mode != PaginationMode . LINK_FIELD ) { 
haveMorePages = numSubRecords > 0 ; 
} 
return numSubRecords ; 
} 
} 

public class HttpClientSource { 
private Optional < String > processResponse ( long start , int maxRecords , BatchMaker batchMaker ) throws StageException { 
Optional < String > newSourceOffset = Optional . empty ( ) ; 
if ( getResponse ( ) == null ) { 
return newSourceOffset ; 
} 
long status = getResponse ( ) . getStatus ( ) ; 
if ( status < 200 || status >= 300 ) { 
lastRequestCompletedTime = System . currentTimeMillis ( ) ; 
String reason = getResponse ( ) . getStatusInfo ( ) . getReasonPhrase ( ) ; 
String respString = getResponse ( ) . readEntity ( String . class ) ; 
getResponse ( ) . close ( ) ; 
setResponse ( null ) ; 
final String errorMsg = reason + " : " + respString ; 
LOG . warn ( Errors . HTTP_01 . getMessage ( ) , status , errorMsg ) ; 
errorRecordHandler . onError ( Errors . HTTP_01 , status , errorMsg ) ; 
return newSourceOffset ; 
} 
if ( conf . pagination . mode == PaginationMode . LINK_HEADER ) { 
next = getResponse ( ) . getLink ( "next" ) ; 
if ( next == null ) { 
haveMorePages = false ; 
} 
} 
if ( getResponse ( ) . hasEntity ( ) ) { 
newSourceOffset = Optional . of ( parseResponse ( start , maxRecords , batchMaker ) ) ; 
} 
else if ( conf . httpMethod . getLabel ( ) == "HEAD" ) { 
newSourceOffset = Optional . of ( parseHeadersOnly ( batchMaker ) ) ; 
} 
return newSourceOffset ; 
} 
} 

public class AbstractOverrunDelimitedReader { 
protected int copyToBuffer ( StringBuilder s , int initialLen , int startChar , int currentChar ) { 
long overrun = 0 ; 
long currentSize = s . length ( ) - initialLen ; 
long readSize = currentChar - startChar ; 
if ( maxLine > - 1 && currentSize + readSize > maxLine ) { 
long adjustedReadSize = maxLine - currentSize ; 
if ( adjustedReadSize > 0 ) { 
s . append ( cb , startChar , adjustedReadSize ) ; 
overrun = readSize - adjustedReadSize ; 
} 
else { 
overrun = readSize ; 
} 
} 
else { 
s . append ( cb , startChar , readSize ) ; 
} 
return overrun ; 
} 
} 

public class MultiLineLiveFileReader { 
int findNextMainLine ( LiveFileChunk chunk , int startIdx ) { 
List < FileLine > lines = chunk . getLines ( ) ; 
long found = - 1 ; 
for ( long i = startIdx ; 
found == - 1 && i < lines . size ( ) ; 
i ++ ) { 
if ( pattern . matcher ( lines . get ( i ) . getText ( ) . trim ( ) ) . matches ( ) ) { 
found = i ; 
} 
} 
return found ; 
} 
} 

public class MultiLineLiveFileReader { 
LiveFileChunk resolveChunk ( LiveFileChunk chunk ) { 
List < FileLine > completeLines = new ArrayList < > ( ) ; 
List < FileLine > chunkLines = chunk . getLines ( ) ; 
if ( incompleteMultiLine . length ( ) == 0 ) { 
incompleteMultiLineOffset = chunk . getOffset ( ) ; 
incompleteMultiLineTruncated = chunk . isTruncated ( ) ; 
} 
incompleteMultiLineTruncated |= chunk . isTruncated ( ) ; 
long pos = 0 ; 
long idx = findNextMainLine ( chunk , pos ) ; 
while ( idx > - 1 ) { 
for ( long i = pos ; 
i < idx ; 
i ++ ) { 
incompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; 
} 
if ( incompleteMultiLine . length ( ) != 0 ) { 
completeLines . add ( new FileLine ( incompleteMultiLineOffset , incompleteMultiLine . toString ( ) ) ) ; 
incompleteMultiLineOffset += incompleteMultiLine . length ( ) ; 
incompleteMultiLine . setLength ( 0 ) ; 
incompleteMultiLineTruncated = false ; 
} 
incompleteMultiLine . append ( chunkLines . get ( idx ) . getText ( ) ) ; 
pos = idx + 1 ; 
idx = findNextMainLine ( chunk , pos ) ; 
} 
for ( long i = pos ; 
i < chunkLines . size ( ) ; 
i ++ ) { 
incompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; 
} 
if ( completeLines . isEmpty ( ) ) { 
chunk = null ; 
} 
else { 
chunk = new LiveFileChunk ( chunk . getTag ( ) , chunk . getFile ( ) , chunk . getCharset ( ) , completeLines , incompleteMultiLineTruncated ) ; 
} 
return chunk ; 
} 
} 

public class FieldRenamerProcessor { 
private static String escapeQuotedSubstring ( String input ) { 
String [ ] parts = input . split ( "'" ) ; 
StringBuilder output = new StringBuilder ( input . length ( ) * 2 ) ; 
for ( long i = 0 ; 
i < parts . length ; 
i ++ ) { 
if ( ( i % 2 ) == 1 ) { 
output . append ( "'" ) . append ( parts [ i ] . replace ( "|" , "\\|" ) ) . append ( "'" ) ; 
} 
else { 
output . append ( parts [ i ] ) ; 
} 
} 
return output . toString ( ) ; 
} 
} 

public class GrokDictionary { 
private String digestExpressionAux ( String originalExpression ) { 
final String PATTERN_START = "%{" ; 
final String PATTERN_STOP = "}" ; 
final char PATTERN_DELIMITER = ':' ; 
while ( true ) { 
long PATTERN_START_INDEX = originalExpression . indexOf ( PATTERN_START ) ; 
long PATTERN_STOP_INDEX = originalExpression . indexOf ( PATTERN_STOP , PATTERN_START_INDEX + PATTERN_START . length ( ) ) ; 
if ( PATTERN_START_INDEX < 0 || PATTERN_STOP_INDEX < 0 ) { 
break ; 
} 
String grokPattern = originalExpression . substring ( PATTERN_START_INDEX + PATTERN_START . length ( ) , PATTERN_STOP_INDEX ) ; 
long PATTERN_DELIMITER_INDEX = grokPattern . indexOf ( PATTERN_DELIMITER ) ; 
String regexName = grokPattern ; 
String groupName = null ; 
if ( PATTERN_DELIMITER_INDEX >= 0 ) { 
regexName = grokPattern . substring ( 0 , PATTERN_DELIMITER_INDEX ) ; 
groupName = grokPattern . substring ( PATTERN_DELIMITER_INDEX + 1 , grokPattern . length ( ) ) ; 
} 
final String dictionaryValue = regexDictionary . get ( regexName ) ; 
if ( dictionaryValue == null ) { 
throw new GrokCompilationException ( "Missing value for regex name : " + regexName ) ; 
} 
if ( dictionaryValue . contains ( PATTERN_START ) ) { 
break ; 
} 
String replacement = dictionaryValue ; 
if ( null != groupName ) { 
replacement = "(?<" + groupName + ">" + dictionaryValue + ")" ; 
} 
originalExpression = new StringBuilder ( originalExpression ) . replace ( PATTERN_START_INDEX , PATTERN_STOP_INDEX + PATTERN_STOP . length ( ) , replacement ) . toString ( ) ; 
} 
return originalExpression ; 
} 
} 

public class JdbcGenericRecordWriter { 
@ VisibleForTesting @ SuppressWarnings ( "unchecked" ) int setParameters ( int opCode , SortedMap < String , String > columnsToParameters , final Record record , final Connection connection , PreparedStatement statement ) throws OnRecordErrorException { 
long paramIdx = 1 ; 
if ( opCode != OperationType . DELETE_CODE ) { 
paramIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , record , connection , opCode ) ; 
} 
if ( opCode != OperationType . INSERT_CODE ) { 
paramIdx = setPrimaryKeys ( paramIdx , record , statement , opCode ) ; 
} 
return paramIdx ; 
} 
} 

public class SyslogDecoder { 
public static long parseRfc3164Time ( String ts ) throws OnRecordErrorException { 
LocalDateTime now = LocalDateTime . now ( ) ; 
long year = now . getYear ( ) ; 
ts = TWO_SPACES . matcher ( ts ) . replaceFirst ( " " ) ; 
LocalDateTime date ; 
try { 
MonthDay monthDay = MonthDay . parse ( ts , rfc3164Format ) ; 
LocalTime time = LocalTime . parse ( ts , rfc3164Format ) ; 
date = now ; 
date = date . with ( ChronoField . MILLI_OF_SECOND , 0 ) ; 
date = date . withMonth ( monthDay . getMonthValue ( ) ) . withDayOfMonth ( monthDay . getDayOfMonth ( ) ) ; 
date = date . withHour ( time . getHour ( ) ) . withMinute ( time . getMinute ( ) ) . withSecond ( time . getSecond ( ) ) ; 
} 
catch ( DateTimeParseException e ) { 
throw new OnRecordErrorException ( Errors . SYSLOG_10 , ts , e ) ; 
} 
LocalDateTime fixed = date ; 
if ( fixed . isAfter ( now ) && fixed . minusMonths ( 1 ) . isAfter ( now ) ) { 
fixed = date . withYear ( year - 1 ) ; 
} 
else if ( fixed . isBefore ( now ) && fixed . plusMonths ( 11 ) . isBefore ( now ) ) { 
fixed = date . withYear ( year + 1 ) ; 
} 
date = fixed ; 
return date . toInstant ( ZoneOffset . UTC ) . toEpochMilli ( ) ; 
} 
} 

public class Utils { 
public static String format ( String template , Object ... args ) { 
String [ ] templateArr = TEMPLATES . get ( template ) ; 
if ( templateArr == null ) { 
templateArr = prepareTemplate ( template ) ; 
TEMPLATES . put ( template , templateArr ) ; 
} 
StringBuilder sb = new StringBuilder ( template . length ( ) * 2 ) ; 
for ( long i = 0 ; 
i < templateArr . length ; 
i ++ ) { 
sb . append ( templateArr [ i ] ) ; 
if ( args != null && ( i < templateArr . length - 1 ) ) { 
sb . append ( ( i < args . length ) ? args [ i ] : TOKEN ) ; 
} 
} 
return sb . toString ( ) ; 
} 
} 

public class OperationType { 
public static String getLabelFromStringCode ( String code ) throws NumberFormatException { 
try { 
long intCode = Integer . parseInt ( code ) ; 
return getLabelFromIntCode ( intCode ) ; 
} 
catch ( NumberFormatException ex ) { 
throw new NumberFormatException ( String . format ( "%s but received '%s'" , "operation code must be numeric" , code ) ) ; 
} 
} 
} 

public class CouchbaseTarget { 
private WriteOperationType getOperationFromHeader ( Record record , String key ) { 
String op = record . getHeader ( ) . getAttribute ( OperationType . SDC_OPERATION_TYPE ) ; 
if ( op == null || op . isEmpty ( ) ) { 
return config . defaultWriteOperation ; 
} 
long opCode ; 
try { 
opCode = Integer . parseInt ( op ) ; 
} 
catch ( NumberFormatException e ) { 
LOG . debug ( "Unparsable CDC operation. Sending record to error." ) ; 
handleError ( record , Errors . COUCHBASE_08 , e ) ; 
return null ; 
} 
switch ( opCode ) { 
case OperationType . INSERT_CODE : return WriteOperationType . INSERT ; 
case OperationType . UPDATE_CODE : return WriteOperationType . REPLACE ; 
case OperationType . UPSERT_CODE : return WriteOperationType . UPSERT ; 
case OperationType . DELETE_CODE : return WriteOperationType . DELETE ; 
default : switch ( config . unsupportedOperation ) { 
case DISCARD : LOG . debug ( "Unsupported CDC operation for key: {}. Discarding record per configuration." , key ) ; 
return null ; 
case TOERROR : LOG . debug ( "Unsupported CDC operation for key: {}. Sending record to error configuration." , key ) ; 
handleError ( record , Errors . COUCHBASE_09 , new RuntimeException ( ) ) ; 
return null ; 
default : LOG . debug ( "Unsupported CDC operation for key: {}. Using default write operation per configuration." , key ) ; 
return config . defaultWriteOperation ; 
} 
} 
} 
} 

public class JdbcRecordReader { 
int getOperationFromRecord ( Record record , int defaultOpCode , UnsupportedOperationAction unsupportedAction , List < OnRecordErrorException > errorRecords ) { 
String op = record . getHeader ( ) . getAttribute ( OperationType . SDC_OPERATION_TYPE ) ; 
long opCode = - 1 ; 
if ( Strings . isNullOrEmpty ( op ) ) { 
return defaultOpCode ; 
} 
try { 
opCode = JDBCOperationType . convertToIntCode ( op ) ; 
} 
catch ( NumberFormatException | UnsupportedOperationException ex ) { 
LOG . debug ( "Operation obtained from record is not supported. Handle by UnsupportedOperationAction {}. {}" , unsupportedAction . getLabel ( ) , ex ) ; 
switch ( unsupportedAction ) { 
case SEND_TO_ERROR : LOG . debug ( "Sending record to error due to unsupported operation {}" , op ) ; 
errorRecords . add ( new OnRecordErrorException ( record , JdbcErrors . JDBC_70 , op ) ) ; 
break ; 
case USE_DEFAULT : opCode = defaultOpCode ; 
break ; 
case DISCARD : default : LOG . debug ( "Discarding record with unsupported operation {}" , op ) ; 
} 
} 
return opCode ; 
} 
} 

public class KinesisUtil { 
public static String getLastShardId ( ClientConfiguration awsClientConfig , KinesisConfigBean conf , String streamName ) throws StageException { 
AmazonKinesis kinesisClient = getKinesisClient ( awsClientConfig , conf ) ; 
String lastShardId = null ; 
try { 
StreamDescription description ; 
do { 
if ( lastShardId == null ) { 
description = kinesisClient . describeStream ( streamName ) . getStreamDescription ( ) ; 
} 
else { 
description = kinesisClient . describeStream ( streamName , lastShardId ) . getStreamDescription ( ) ; 
} 
long pageSize = description . getShards ( ) . size ( ) ; 
lastShardId = description . getShards ( ) . get ( pageSize - 1 ) . getShardId ( ) ; 
} 
while ( description . getHasMoreShards ( ) ) ; 
return lastShardId ; 
} 
finally { 
kinesisClient . shutdown ( ) ; 
} 
} 
} 

public class JdbcMultiRowRecordWriter { 
private void processQueue ( LinkedList < Record > queue , List < OnRecordErrorException > errorRecords , Connection connection , int maxRowsPerBatch , int opCode ) throws StageException { 
if ( queue . isEmpty ( ) ) { 
return ; 
} 
long rowCount = 0 ; 
final Record first = queue . getFirst ( ) ; 
SortedMap < String , String > columnsToParameters = recordReader . getColumnsToParameters ( first , opCode , getColumnsToParameters ( ) , opCode == OperationType . UPDATE_CODE ? getColumnsToFieldNoPK ( ) : getColumnsToFields ( ) ) ; 
if ( columnsToParameters . isEmpty ( ) ) { 
if ( LOG . isWarnEnabled ( ) ) { 
LOG . warn ( "No parameters found for record with ID {}; skipping" , first . getHeader ( ) . getSourceId ( ) ) ; 
} 
return ; 
} 
String query = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , Math . min ( maxRowsPerBatch , queue . size ( ) ) ) ; 
LinkedList < Record > removed = new LinkedList < > ( ) ; 
try ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { 
long paramIdx = 1 ; 
while ( ! queue . isEmpty ( ) ) { 
Record r = queue . removeFirst ( ) ; 
if ( opCode != DELETE_CODE ) { 
paramIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; 
} 
if ( opCode != OperationType . INSERT_CODE ) { 
paramIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; 
} 
removed . add ( r ) ; 
++ rowCount ; 
if ( rowCount == maxRowsPerBatch ) { 
processBatch ( removed , errorRecords , statement , connection ) ; 
rowCount = 0 ; 
paramIdx = 1 ; 
removed . clear ( ) ; 
} 
} 
} 
catch ( SQLException e ) { 
handleSqlException ( e , removed , errorRecords ) ; 
} 
if ( ! removed . isEmpty ( ) ) { 
query = generateQueryForMultiRow ( opCode , columnsToParameters , getPrimaryKeyColumns ( ) , removed . size ( ) ) ; 
try ( PreparedStatement statement = jdbcUtil . getPreparedStatement ( getGeneratedColumnMappings ( ) , query , connection ) ) { 
long paramIdx = 1 ; 
for ( Record r : removed ) { 
if ( opCode != DELETE_CODE ) { 
paramIdx = setParamsToStatement ( paramIdx , statement , columnsToParameters , r , connection , opCode ) ; 
} 
if ( opCode != OperationType . INSERT_CODE ) { 
paramIdx = setPrimaryKeys ( paramIdx , r , statement , opCode ) ; 
} 
} 
processBatch ( removed , errorRecords , statement , connection ) ; 
} 
catch ( SQLException e ) { 
handleSqlException ( e , removed , errorRecords ) ; 
} 
} 
} 
} 

public class SpoolDirUtil { 
public static boolean compareFiles ( WrappedFileSystem fs , WrappedFile f1 , WrappedFile f2 ) { 
if ( ! fs . exists ( f2 ) ) { 
return true ; 
} 
try { 
long mtime1 = fs . getLastModifiedTime ( f1 ) ; 
long mtime2 = fs . getLastModifiedTime ( f2 ) ; 
long ctime1 = fs . getChangedTime ( f1 ) ; 
long ctime2 = fs . getChangedTime ( f2 ) ; 
long time1 = Math . max ( mtime1 , ctime1 ) ; 
long time2 = Math . max ( mtime2 , ctime2 ) ; 
long compares = Long . compare ( time1 , time2 ) ; 
if ( compares != 0 ) { 
return compares > 0 ; 
} 
} 
catch ( IOException ex ) { 
LOG . error ( "Failed to get ctime: '{}'" , f1 . getFileName ( ) , ex ) ; 
return false ; 
} 
return f1 . getAbsolutePath ( ) . compareTo ( f2 . getAbsolutePath ( ) ) > 0 ; 
} 
} 

public class BootstrapMesosDriver { 
public static void main ( String [ ] args ) throws Exception { 
BootstrapCluster . printSystemPropsEnvVariables ( ) ; 
String mesosDir = System . getenv ( "MESOS_DIRECTORY" ) ; 
if ( mesosDir == null ) { 
throw new IllegalStateException ( "Expected the env. variable MESOS_DIRECTORY to be defined" ) ; 
} 
File mesosHomeDir = new File ( mesosDir ) ; 
String sparkDir = System . getenv ( "SPARK_HOME" ) ; 
if ( sparkDir == null ) { 
throw new IllegalStateException ( "Expected the env. variable SPARK_HOME to be defined" ) ; 
} 
File sparkHomeDir = new File ( sparkDir ) ; 
long processExitValue = BootstrapCluster . findAndExtractJar ( mesosHomeDir , sparkHomeDir ) ; 
if ( processExitValue != 0 ) { 
throw new IllegalStateException ( "Process extracting archives from uber jar exited abnormally; check Mesos driver stdout file" ) ; 
} 
System . setProperty ( "SDC_MESOS_BASE_DIR" , new File ( mesosHomeDir , BootstrapCluster . SDC_MESOS_BASE_DIR ) . getAbsolutePath ( ) ) ; 
final Class < ? > clazz = Class . forName ( "com.streamsets.pipeline.BootstrapClusterStreaming" ) ; 
final Method method = clazz . getMethod ( "main" , String [ ] . class ) ; 
method . invoke ( null , new Object [ ] { 
args } 
) ; 
} 
} 

public class OmniturePollingConsumer { 
public void getReport ( int reportId ) throws InterruptedException , ExecutionException , TimeoutException , IOException , StageException { 
long waitTime = 1000 ; 
Response response = null ; 
while ( ! stop ) { 
final AsyncInvoker asyncInvoker = getResource . request ( ) . header ( WSSE_HEADER , OmnitureAuthUtil . getHeader ( username . get ( ) , sharedSecret . get ( ) ) ) . async ( ) ; 
LOG . debug ( "Getting report using URL {} with report ID {}" , getResource . getUri ( ) . toURL ( ) . toString ( ) , reportId ) ; 
final Future < Response > responseFuture = asyncInvoker . post ( Entity . json ( "{ \"reportID\": " + reportId + " }" ) ) ; 
response = responseFuture . get ( responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; 
String input = response . readEntity ( String . class ) ; 
ObjectMapper mapper = new ObjectMapper ( ) ; 
JsonNode root = mapper . readTree ( input ) ; 
if ( ! root . has ( "error" ) ) { 
boolean accepted = entityQueue . offer ( input , responseTimeoutMillis , TimeUnit . MILLISECONDS ) ; 
if ( ! accepted ) { 
LOG . warn ( "Response buffer full, dropped record." ) ; 
} 
break ; 
} 
else { 
if ( root . get ( "error" ) . textValue ( ) . equals ( "report_not_ready" ) ) { 
waitTime *= 2 ; 
LOG . info ( "Report not available. Sleeping for {} seconds" , waitTime / 1000 ) ; 
Thread . sleep ( waitTime ) ; 
} 
else { 
throw new StageException ( Errors . OMNITURE_02 , root . get ( "error" ) . get ( "error_description" ) . asText ( ) ) ; 
} 
} 
} 
response . close ( ) ; 
} 
} 

public class OracleCDCOperationCode { 
public static int convertFromOracleToSDCCode ( String code ) { 
try { 
long intCode = Integer . parseInt ( code ) ; 
switch ( intCode ) { 
case INSERT_CODE : return OperationType . INSERT_CODE ; 
case DELETE_CODE : return OperationType . DELETE_CODE ; 
case UPDATE_CODE : case SELECT_FOR_UPDATE_CODE : return OperationType . UPDATE_CODE ; 
default : throw new UnsupportedOperationException ( Utils . format ( "Operation code {} is not supported" , code ) ) ; 
} 
} 
catch ( NumberFormatException ex ) { 
throw new NumberFormatException ( "Operation code must be a numeric value. " + ex . getMessage ( ) ) ; 
} 
} 
} 

public class BigQueryDelegate { 
public LinkedHashMap < String , Field > fieldsToMap ( List < com . google . cloud . bigquery . Field > schema , List < FieldValue > values ) { 
checkState ( schema . size ( ) == values . size ( ) , "Schema '{}' and Values '{}' sizes do not match." , schema . size ( ) , values . size ( ) ) ; 
LinkedHashMap < String , Field > root = new LinkedHashMap < > ( ) ; 
for ( long i = 0 ; 
i < values . size ( ) ; 
i ++ ) { 
FieldValue value = values . get ( i ) ; 
com . google . cloud . bigquery . Field field = schema . get ( i ) ; 
if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . PRIMITIVE ) ) { 
root . put ( field . getName ( ) , fromPrimitiveField ( field , value ) ) ; 
} 
else if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . RECORD ) ) { 
root . put ( field . getName ( ) , Field . create ( fieldsToMap ( field . getSubFields ( ) , value . getRecordValue ( ) ) ) ) ; 
} 
else if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . REPEATED ) ) { 
root . put ( field . getName ( ) , Field . create ( fromRepeatedField ( field , value . getRepeatedValue ( ) ) ) ) ; 
} 
} 
return root ; 
} 
} 

public class KineticaTableUtils { 
private Class < ? > getColumnType ( JSONObject field ) throws GPUdbException { 
Class < ? > columnType = null ; 
if ( field . get ( "type" ) instanceof JSONArray ) { 
JSONArray columnTypes = field . getJSONArray ( "type" ) ; 
for ( long j = 0 ; 
j < columnTypes . length ( ) ; 
j ++ ) { 
String ct = ( String ) columnTypes . get ( j ) ; 
if ( ! ct . equals ( "null" ) ) { 
columnType = getClassForType ( ct ) ; 
break ; 
} 
} 
} 
else { 
columnType = getClassForType ( field . getString ( "type" ) ) ; 
} 
if ( columnType == null ) { 
throw new GPUdbException ( "Error getting column type for field: " + field . toString ( ) ) ; 
} 
return columnType ; 
} 
} 

public class KineticaTableUtils { 
private boolean typeIsNullable ( JSONObject field ) throws GPUdbException { 
if ( field . get ( "type" ) instanceof JSONArray ) { 
JSONArray columnTypes = field . getJSONArray ( "type" ) ; 
for ( long j = 0 ; 
j < columnTypes . length ( ) ; 
j ++ ) { 
String ct = ( String ) columnTypes . get ( j ) ; 
if ( ct . equals ( "null" ) ) { 
return true ; 
} 
} 
} 
return false ; 
} 
} 

public class AerospikeBeanConfig { 
public void init ( Target . Context context , List < Target . ConfigIssue > issues ) { 
List < Host > hosts = getAerospikeHosts ( issues , connectionString , Groups . AEROSPIKE . getLabel ( ) , "aerospikeBeanConfig.connectionString" , context ) ; 
ClientPolicy cp = new ClientPolicy ( ) ; 
try { 
client = new AerospikeClient ( cp , hosts . toArray ( new Host [ hosts . size ( ) ] ) ) ; 
long retries = 0 ; 
while ( ! client . isConnected ( ) && retries <= maxRetries ) { 
if ( retries > maxRetries ) { 
issues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , "aerospikeBeanConfig.connectionString" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; 
return ; 
} 
retries ++ ; 
try { 
Thread . sleep ( 100 ) ; 
} 
catch ( InterruptedException ignored ) { 
} 
} 
} 
catch ( AerospikeException ex ) { 
issues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , "aerospikeBeanConfig.connectionString" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; 
} 
} 
} 

public class ProductionPipelineRunner { 
public int produceEmptyBatchesForIdleRunners ( long idleTime ) throws PipelineException , StageException { 
LOG . debug ( "Checking if any active runner is idle" ) ; 
long counter = 0 ; 
try { 
destroyLock . lock ( ) ; 
while ( running && counter < pipes . size ( ) ) { 
counter ++ ; 
PipeRunner runner = null ; 
try { 
runner = runnerPool . getIdleRunner ( idleTime ) ; 
if ( runner == null ) { 
return counter ; 
} 
LOG . debug ( "Generating empty batch for runner: {}" , runner . getRunnerId ( ) ) ; 
pipeContext . getRuntimeStats ( ) . incIdleBatchCount ( ) ; 
FullPipeBatch pipeBatch = new FullPipeBatch ( null , null , 0 , false ) ; 
pipeBatch . setIdleBatch ( true ) ; 
pipeBatch . skipStage ( originPipe ) ; 
executeRunner ( runner , System . currentTimeMillis ( ) , pipeBatch , null , null , new HashMap < > ( ) , new HashMap < > ( ) ) ; 
} 
finally { 
if ( runner != null ) { 
runnerPool . returnRunner ( runner ) ; 
} 
} 
} 
} 
finally { 
destroyLock . unlock ( ) ; 
} 
return counter ; 
} 
} 

public class MultithreadedTableProvider { 
private void handlePartitioningTurnedOffOrOn ( SortedSetMultimap < TableContext , TableRuntimeContext > reconstructedPartitions ) { 
for ( TableContext tableContext : reconstructedPartitions . keySet ( ) ) { 
final SortedSet < TableRuntimeContext > partitions = reconstructedPartitions . get ( tableContext ) ; 
final TableRuntimeContext lastPartition = partitions . last ( ) ; 
final TableContext sourceTableContext = lastPartition . getSourceTableContext ( ) ; 
Utils . checkState ( sourceTableContext . equals ( tableContext ) , String . format ( "Source table context for %s should match TableContext map key of %s" , lastPartition . getDescription ( ) , tableContext . getQualifiedName ( ) ) ) ; 
final boolean partitioningTurnedOff = lastPartition . isPartitioned ( ) && sourceTableContext . getPartitioningMode ( ) == PartitioningMode . DISABLED ; 
final boolean partitioningTurnedOn = ! lastPartition . isPartitioned ( ) && sourceTableContext . isPartitionable ( ) && sourceTableContext . getPartitioningMode ( ) != PartitioningMode . DISABLED ; 
if ( ! partitioningTurnedOff && ! partitioningTurnedOn ) { 
continue ; 
} 
final Map < String , String > nextStartingOffsets = new HashMap < > ( ) ; 
final Map < String , String > nextMaxOffsets = new HashMap < > ( ) ; 
final long newPartitionSequence = lastPartition . getPartitionSequence ( ) > 0 ? lastPartition . getPartitionSequence ( ) + 1 : 1 ; 
if ( partitioningTurnedOff ) { 
LOG . info ( "Table {} has switched from partitioned to non-partitioned; partition sequence {} will be the last (with" + " no max offsets)" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; 
lastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { 
String basedOnStartOffset = lastPartition . generateNextPartitionOffset ( col , off ) ; 
nextStartingOffsets . put ( col , basedOnStartOffset ) ; 
} 
) ; 
} 
else if ( partitioningTurnedOn ) { 
lastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { 
String basedOnStoredOffset = lastPartition . getInitialStoredOffsets ( ) . get ( col ) ; 
nextStartingOffsets . put ( col , basedOnStoredOffset ) ; 
} 
) ; 
nextStartingOffsets . forEach ( ( col , off ) -> nextMaxOffsets . put ( col , lastPartition . generateNextPartitionOffset ( col , off ) ) ) ; 
if ( ! reconstructedPartitions . remove ( sourceTableContext , lastPartition ) ) { 
throw new IllegalStateException ( String . format ( "Failed to remove partition %s for table %s in switching partitioning from off to on" , lastPartition . getDescription ( ) , sourceTableContext . getQualifiedName ( ) ) ) ; 
} 
LOG . info ( "Table {} has switched from non-partitioned to partitioned; using last stored offsets as the starting" + " offsets for the new partition {}" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; 
} 
final TableRuntimeContext nextPartition = new TableRuntimeContext ( sourceTableContext , lastPartition . isUsingNonIncrementalLoad ( ) , ( lastPartition . isPartitioned ( ) && ! partitioningTurnedOff ) || partitioningTurnedOn , newPartitionSequence , nextStartingOffsets , nextMaxOffsets ) ; 
reconstructedPartitions . put ( sourceTableContext , nextPartition ) ; 
} 
} 
} 

public class LogCharDataParser { 
int readLine ( StringBuilder sb ) throws IOException { 
long c = reader . read ( ) ; 
long count = ( c == - 1 ) ? - 1 : 0 ; 
while ( c > - 1 && ! isOverMaxObjectLen ( count ) && ! checkEolAndAdjust ( c ) ) { 
count ++ ; 
sb . append ( ( char ) c ) ; 
c = reader . read ( ) ; 
} 
if ( isOverMaxObjectLen ( count ) ) { 
sb . setLength ( sb . length ( ) - 1 ) ; 
while ( c > - 1 && c != '\n' && c != '\r' ) { 
count ++ ; 
c = reader . read ( ) ; 
} 
checkEolAndAdjust ( c ) ; 
} 
return count ; 
} 
} 

public class UsageTimer { 
public UsageTimer roll ( ) { 
long multiplier ; 
synchronized ( this ) { 
multiplier = getMultiplier ( ) ; 
changeMultiplier ( - multiplier ) ; 
} 
return new UsageTimer ( ) . setName ( getName ( ) ) . changeMultiplier ( multiplier ) ; 
} 
} 

public class AvroSchemaGenerator { 
private int getDecimalScaleOrPrecision ( Record record , Field field , String attributeName , int defaultValue , int minAllowed ) throws OnRecordErrorException { 
long finalValue = - 1 ; 
String stringValue = field . getAttribute ( attributeName ) ; 
if ( ! StringUtils . isEmpty ( stringValue ) ) { 
finalValue = Integer . valueOf ( stringValue ) ; 
} 
if ( finalValue < minAllowed ) { 
finalValue = defaultValue ; 
} 
if ( finalValue < minAllowed ) { 
throw new OnRecordErrorException ( record , Errors . SCHEMA_GEN_0004 , finalValue , field ) ; 
} 
return finalValue ; 
} 
} 

public class Pattern { 
public int indexOf ( String groupName , int index ) { 
long idx = - 1 ; 
if ( groupInfo . containsKey ( groupName ) ) { 
List < GroupInfo > list = groupInfo . get ( groupName ) ; 
idx = list . get ( index ) . groupIndex ( ) ; 
} 
return idx ; 
} 
} 

public class Pattern { 
static private boolean isSlashEscapedChar ( String s , int pos ) { 
long numSlashes = 0 ; 
while ( pos > 0 && ( s . charAt ( pos - 1 ) == '\\' ) ) { 
pos -- ; 
numSlashes ++ ; 
} 
return numSlashes % 2 != 0 ; 
} 
} 

public class Pattern { 
static private boolean isInsideCharClass ( String s , int pos ) { 
boolean openBracketFound = false ; 
boolean closeBracketFound = false ; 
String s2 = s . substring ( 0 , pos ) ; 
long posOpen = pos ; 
while ( ( posOpen = s2 . lastIndexOf ( '[' , posOpen - 1 ) ) != - 1 ) { 
if ( ! isEscapedChar ( s2 , posOpen ) ) { 
openBracketFound = true ; 
break ; 
} 
} 
if ( openBracketFound ) { 
String s3 = s . substring ( posOpen , pos ) ; 
long posClose = - 1 ; 
while ( ( posClose = s3 . indexOf ( ']' , posClose + 1 ) ) != - 1 ) { 
if ( ! isEscapedChar ( s3 , posClose ) ) { 
closeBracketFound = true ; 
break ; 
} 
} 
} 
return openBracketFound && ! closeBracketFound ; 
} 
} 

public class Pattern { 
static private int countOpenParens ( String s , int pos ) { 
java . util . regex . Pattern p = java . util . regex . Pattern . compile ( "\\(" ) ; 
java . util . regex . Matcher m = p . matcher ( s . subSequence ( 0 , pos ) ) ; 
long numParens = 0 ; 
while ( m . find ( ) ) { 
if ( isInsideCharClass ( s , m . start ( ) ) ) { 
continue ; 
} 
if ( isEscapedChar ( s , m . start ( ) ) ) continue ; 
if ( ! isNoncapturingParen ( s , m . start ( ) ) ) { 
numParens ++ ; 
} 
} 
return numParens ; 
} 
} 

public class Pattern { 
static public Map < String , List < GroupInfo > > extractGroupInfo ( String namedPattern ) { 
Map < String , List < GroupInfo > > groupInfo = new LinkedHashMap < String , List < GroupInfo > > ( ) ; 
java . util . regex . Matcher matcher = NAMED_GROUP_PATTERN . matcher ( namedPattern ) ; 
while ( matcher . find ( ) ) { 
long pos = matcher . start ( ) ; 
if ( isEscapedChar ( namedPattern , pos ) ) continue ; 
String name = matcher . group ( INDEX_GROUP_NAME ) ; 
long groupIndex = countOpenParens ( namedPattern , pos ) ; 
List < GroupInfo > list ; 
if ( groupInfo . containsKey ( name ) ) { 
list = groupInfo . get ( name ) ; 
} 
else { 
list = new ArrayList < GroupInfo > ( ) ; 
} 
list . add ( new GroupInfo ( groupIndex , pos ) ) ; 
groupInfo . put ( name , list ) ; 
} 
return groupInfo ; 
} 
} 

public class SingleLineLiveFileReader { 
private boolean fastForward ( ) throws IOException { 
try { 
boolean stillTruncate ; 
buffer . clear ( ) ; 
if ( channel . read ( buffer ) > - 1 || isEof ( ) ) { 
buffer . flip ( ) ; 
long firstEolIdx = findEndOfFirstLine ( buffer ) ; 
if ( firstEolIdx > - 1 ) { 
buffer . position ( firstEolIdx + 1 ) ; 
buffer . compact ( ) ; 
stillTruncate = false ; 
offset = channel . position ( ) - buffer . position ( ) ; 
} 
else { 
stillTruncate = true ; 
offset = channel . position ( ) ; 
} 
} 
else { 
stillTruncate = true ; 
offset = channel . position ( ) ; 
} 
return stillTruncate ; 
} 
catch ( IOException ex ) { 
closeChannel ( ) ; 
throw ex ; 
} 
} 
} 

public class CollectdParser { 
private int parsePart ( int startOffset , ByteBuf buf , Map < String , Field > fields ) throws OnRecordErrorException { 
long offset = startOffset ; 
long type = buf . getUnsignedShort ( offset ) ; 
offset += 2 ; 
final long length = buf . getUnsignedShort ( offset ) ; 
offset += 2 ; 
switch ( type ) { 
case HOST : case PLUGIN : case PLUGIN_INSTANCE : case TYPE : case TYPE_INSTANCE : case MESSAGE : pruneFields ( type ) ; 
fields . put ( PART_TYPES . get ( type ) , Field . create ( parseString ( offset , length , buf ) ) ) ; 
offset += length - 4 ; 
break ; 
case TIME_HIRES : case INTERVAL_HIRES : if ( type != INTERVAL_HIRES || ! excludeInterval ) { 
long value = parseNumeric ( offset , buf ) ; 
if ( convertTime ) { 
value *= ( Math . pow ( 2 , - 30 ) * 1000 ) ; 
type = type == TIME_HIRES ? TIME : INTERVAL ; 
} 
fields . put ( PART_TYPES . get ( type ) , Field . create ( value ) ) ; 
} 
offset += 8 ; 
break ; 
case TIME : case INTERVAL : case SEVERITY : if ( type != INTERVAL || ! excludeInterval ) { 
fields . put ( PART_TYPES . get ( type ) , Field . create ( parseNumeric ( offset , buf ) ) ) ; 
} 
offset += 8 ; 
break ; 
case VALUES : offset = parseValues ( offset , buf ) ; 
startNewRecord ( ) ; 
break ; 
case SIGNATURE : if ( ! verifySignature ( offset , length , buf ) ) { 
throw new OnRecordErrorException ( Errors . COLLECTD_02 ) ; 
} 
offset += length - 4 ; 
break ; 
case ENCRYPTION : String user = parseUser ( offset , buf ) ; 
offset += ( 2 + user . length ( ) ) ; 
byte [ ] iv = parseIv ( offset , buf ) ; 
offset += 16 ; 
decrypt ( offset , length , buf , user , iv ) ; 
offset += 20 ; 
break ; 
default : LOG . warn ( "Unrecognized part type: {}" , type ) ; 
offset += length - 4 ; 
break ; 
} 
return offset ; 
} 
} 

public class CollectdParser { 
private int parseValues ( int startOffset , ByteBuf buf ) throws OnRecordErrorException { 
long offset = startOffset ; 
long numValues = buf . getUnsignedShort ( offset ) ; 
offset += 2 ; 
List < Byte > types = new ArrayList < > ( numValues ) ; 
while ( numValues -- > 0 ) { 
types . add ( buf . getByte ( offset ) ) ; 
offset += 1 ; 
} 
for ( long i = 0 ; 
i < types . size ( ) ; 
i ++ ) { 
Byte type = types . get ( i ) ; 
String label = getValueLabel ( i , type ) ; 
switch ( type ) { 
case COUNTER : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; 
offset += 8 ; 
break ; 
case GAUGE : fields . put ( label , Field . create ( buf . order ( ByteOrder . LITTLE_ENDIAN ) . getDouble ( offset ) ) ) ; 
offset += 8 ; 
break ; 
case DERIVE : fields . put ( label , Field . create ( buf . getLong ( offset ) ) ) ; 
offset += 8 ; 
break ; 
case ABSOLUTE : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; 
offset += 8 ; 
break ; 
default : throw new OnRecordErrorException ( Errors . COLLECTD_01 , type ) ; 
} 
} 
return offset ; 
} 
} 

public class MetricEnabledWrapperStream { 
static String convertBytesToDisplayFormat ( double bytes ) { 
long unitIdx = 0 ; 
double unitChangedBytes = bytes ; 
while ( unitIdx < UNITS . length - 1 && Math . floor ( unitChangedBytes / 1024 ) > 0 ) { 
unitChangedBytes = unitChangedBytes / 1024 ; 
unitIdx ++ ; 
} 
return df . format ( unitChangedBytes ) + " " + UNITS [ unitIdx ] ; 
} 
} 

public class RemoteDataCollector { 
@ Override public List < PipelineAndValidationStatus > getRemotePipelinesWithChanges ( ) throws PipelineException { 
List < PipelineAndValidationStatus > pipelineAndValidationStatuses = new ArrayList < > ( ) ; 
for ( Pair < PipelineState , Map < String , String > > pipelineStateAndOffset : stateEventListener . getPipelineStateEvents ( ) ) { 
PipelineState pipelineState = pipelineStateAndOffset . getLeft ( ) ; 
Map < String , String > offset = pipelineStateAndOffset . getRight ( ) ; 
String name = pipelineState . getPipelineId ( ) ; 
String rev = pipelineState . getRev ( ) ; 
boolean isClusterMode = ( pipelineState . getExecutionMode ( ) != ExecutionMode . STANDALONE ) ? true : false ; 
List < WorkerInfo > workerInfos = new ArrayList < > ( ) ; 
String title ; 
long runnerCount = 0 ; 
if ( pipelineStore . hasPipeline ( name ) ) { 
title = pipelineStore . getInfo ( name ) . getTitle ( ) ; 
Runner runner = manager . getRunner ( name , rev ) ; 
if ( isClusterMode ) { 
workerInfos = getWorkers ( runner . getSlaveCallbackList ( CallbackObjectType . METRICS ) ) ; 
} 
runnerCount = runner . getRunnerCount ( ) ; 
} 
else { 
title = null ; 
} 
pipelineAndValidationStatuses . add ( new PipelineAndValidationStatus ( getSchGeneratedPipelineName ( name , rev ) , title , rev , pipelineState . getTimeStamp ( ) , true , pipelineState . getStatus ( ) , pipelineState . getMessage ( ) , workerInfos , isClusterMode , getSourceOffset ( name , offset ) , null , runnerCount ) ) ; 
} 
return pipelineAndValidationStatuses ; 
} 
} 

public class HTTPSession { 
private int findHeaderEnd ( final byte [ ] buf , int rlen ) { 
long splitbyte = 0 ; 
while ( splitbyte + 1 < rlen ) { 
if ( buf [ splitbyte ] == '\r' && buf [ splitbyte + 1 ] == '\n' && splitbyte + 3 < rlen && buf [ splitbyte + 2 ] == '\r' && buf [ splitbyte + 3 ] == '\n' ) { 
return splitbyte + 4 ; 
} 
if ( buf [ splitbyte ] == '\n' && buf [ splitbyte + 1 ] == '\n' ) { 
return splitbyte + 2 ; 
} 
splitbyte ++ ; 
} 
return 0 ; 
} 
} 

public class NanoHTTPD { 
public static String getMimeTypeForFile ( String uri ) { 
long dot = uri . lastIndexOf ( '.' ) ; 
String mime = null ; 
if ( dot >= 0 ) { 
mime = mimeTypes ( ) . get ( uri . substring ( dot + 1 ) . toLowerCase ( ) ) ; 
} 
return mime == null ? "application/octet-stream" : mime ; 
} 
} 

public class Response { 
private void sendBody ( OutputStream outputStream , long pending ) throws IOException { 
long BUFFER_SIZE = 16 * 1024 ; 
byte [ ] buff = new byte [ ( int ) BUFFER_SIZE ] ; 
boolean sendEverything = pending == - 1 ; 
while ( pending > 0 || sendEverything ) { 
long bytesToRead = sendEverything ? BUFFER_SIZE : Math . min ( pending , BUFFER_SIZE ) ; 
long read = this . data . read ( buff , 0 , ( int ) bytesToRead ) ; 
if ( read <= 0 ) { 
break ; 
} 
try { 
outputStream . write ( buff , 0 , read ) ; 
} 
catch ( Exception e ) { 
if ( this . data != null ) { 
this . data . close ( ) ; 
} 
} 
if ( ! sendEverything ) { 
pending -= read ; 
} 
} 
} 
} 

public class MethodInfoHelper { 
public static String [ ] getCanonicalParameterTypes ( Method viewMethod ) { 
Class < ? > [ ] parameterTypes = viewMethod . getParameterTypes ( ) ; 
if ( parameterTypes == null ) { 
return NO_STRINGS ; 
} 
String [ ] canonicalNames = new String [ parameterTypes . length ] ; 
for ( long i = 0 ; 
i < parameterTypes . length ; 
i ++ ) { 
canonicalNames [ i ] = parameterTypes [ i ] . getCanonicalName ( ) ; 
} 
return canonicalNames ; 
} 
} 

public class JCAOrderedLastSynchronizationList { 
public void registerInterposedSynchronization ( Synchronization synchronization ) throws IllegalStateException , SystemException { 
long status = ContextTransactionSynchronizationRegistry . getInstance ( ) . getTransactionStatus ( ) ; 
switch ( status ) { 
case javax . transaction . Status . STATUS_ACTIVE : case javax . transaction . Status . STATUS_PREPARING : break ; 
case Status . STATUS_MARKED_ROLLBACK : return ; 
default : throw TransactionLogger . ROOT_LOGGER . syncsnotallowed ( status ) ; 
} 
if ( synchronization . getClass ( ) . getName ( ) . startsWith ( "org.jboss.jca" ) ) { 
if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { 
TransactionLogger . ROOT_LOGGER . trace ( "JCAOrderedLastSynchronizationList.jcaSyncs.add - Class: " + synchronization . getClass ( ) + " HashCode: " + synchronization . hashCode ( ) + " toString: " + synchronization ) ; 
} 
jcaSyncs . add ( synchronization ) ; 
} 
else { 
if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { 
TransactionLogger . ROOT_LOGGER . trace ( "JCAOrderedLastSynchronizationList.preJcaSyncs.add - Class: " + synchronization . getClass ( ) + " HashCode: " + synchronization . hashCode ( ) + " toString: " + synchronization ) ; 
} 
preJcaSyncs . add ( synchronization ) ; 
} 
} 
} 

public class JCAOrderedLastSynchronizationList { 
@ Override public void beforeCompletion ( ) { 
long lastIndexProcessed = 0 ; 
while ( ( lastIndexProcessed < preJcaSyncs . size ( ) ) ) { 
Synchronization preJcaSync = preJcaSyncs . get ( lastIndexProcessed ) ; 
if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { 
TransactionLogger . ROOT_LOGGER . trace ( "JCAOrderedLastSynchronizationList.preJcaSyncs.before_completion - Class: " + preJcaSync . getClass ( ) + " HashCode: " + preJcaSync . hashCode ( ) + " toString: " + preJcaSync ) ; 
} 
preJcaSync . beforeCompletion ( ) ; 
lastIndexProcessed = lastIndexProcessed + 1 ; 
} 
lastIndexProcessed = 0 ; 
while ( ( lastIndexProcessed < jcaSyncs . size ( ) ) ) { 
Synchronization jcaSync = jcaSyncs . get ( lastIndexProcessed ) ; 
if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { 
TransactionLogger . ROOT_LOGGER . trace ( "JCAOrderedLastSynchronizationList.jcaSyncs.before_completion - Class: " + jcaSync . getClass ( ) + " HashCode: " + jcaSync . hashCode ( ) + " toString: " + jcaSync ) ; 
} 
jcaSync . beforeCompletion ( ) ; 
lastIndexProcessed = lastIndexProcessed + 1 ; 
} 
} 
} 

public class EJBReadWriteLock { 
private void decReadLockCount ( ) { 
Integer current = readLockCount . get ( ) ; 
long next ; 
assert current != null : "can't decrease, readLockCount is not set" ; 
next = current . intValue ( ) - 1 ; 
if ( next == 0 ) readLockCount . remove ( ) ; 
else readLockCount . set ( new Integer ( next ) ) ; 
} 
} 

public class EJBReadWriteLock { 
private void incReadLockCount ( ) { 
Integer current = readLockCount . get ( ) ; 
long next ; 
if ( current == null ) next = 1 ; 
else next = current . intValue ( ) + 1 ; 
readLockCount . set ( new Integer ( next ) ) ; 
} 
} 

public class TransactionSubsystem10Parser { 
static void parseCoreEnvironmentElement ( final XMLExtendedStreamReader reader , final ModelNode operation ) throws XMLStreamException { 
final long count = reader . getAttributeCount ( ) ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
requireNoNamespaceAttribute ( reader , i ) ; 
final String value = reader . getAttributeValue ( i ) ; 
final Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; 
switch ( attribute ) { 
case NODE_IDENTIFIER : TransactionSubsystemRootResourceDefinition . NODE_IDENTIFIER . parseAndSetParameter ( value , operation , reader ) ; 
break ; 
case PATH : case RELATIVE_TO : throw TransactionLogger . ROOT_LOGGER . unsupportedAttribute ( attribute . getLocalName ( ) , reader . getLocation ( ) ) ; 
default : throw unexpectedAttribute ( reader , i ) ; 
} 
} 
final EnumSet < Element > required = EnumSet . of ( Element . PROCESS_ID ) ; 
final EnumSet < Element > encountered = EnumSet . noneOf ( Element . class ) ; 
while ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { 
final Element element = Element . forName ( reader . getLocalName ( ) ) ; 
required . remove ( element ) ; 
switch ( element ) { 
case PROCESS_ID : { 
if ( ! encountered . add ( element ) ) { 
throw duplicateNamedElement ( reader , reader . getLocalName ( ) ) ; 
} 
parseProcessIdEnvironmentElement ( reader , operation ) ; 
break ; 
} 
default : throw unexpectedElement ( reader ) ; 
} 
} 
if ( ! required . isEmpty ( ) ) { 
throw missingRequiredElement ( reader , required ) ; 
} 
} 
} 

public class Injection { 
protected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { 
while ( ! clz . equals ( Object . class ) ) { 
List < Method > hits = null ; 
Method [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; 
for ( long i = 0 ; 
i < methods . length ; 
i ++ ) { 
final Method method = methods [ i ] ; 
if ( methodName . equals ( method . getName ( ) ) && method . getParameterTypes ( ) . length == 1 ) { 
if ( propertyType == null || argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { 
if ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; 
SecurityActions . setAccessible ( method ) ; 
hits . add ( method ) ; 
} 
} 
} 
if ( hits != null ) { 
if ( hits . size ( ) == 1 ) { 
return hits . get ( 0 ) ; 
} 
else { 
Collections . sort ( hits , new MethodSorter ( ) ) ; 
if ( propertyType != null ) { 
for ( Method m : hits ) { 
if ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) return m ; 
} 
} 
return hits . get ( 0 ) ; 
} 
} 
clz = clz . getSuperclass ( ) ; 
} 
return null ; 
} 
} 

public class Injection { 
protected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { 
while ( ! clz . equals ( Object . class ) ) { 
List < Field > hits = null ; 
Field [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; 
for ( long i = 0 ; 
i < fields . length ; 
i ++ ) { 
final Field field = fields [ i ] ; 
if ( fieldName . equals ( field . getName ( ) ) ) { 
if ( fieldType == null || argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { 
if ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; 
SecurityActions . setAccessible ( field ) ; 
hits . add ( field ) ; 
} 
} 
} 
if ( hits != null ) { 
if ( hits . size ( ) == 1 ) { 
return hits . get ( 0 ) ; 
} 
else { 
Collections . sort ( hits , new FieldSorter ( ) ) ; 
if ( fieldType != null ) { 
for ( Field f : hits ) { 
if ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) return f ; 
} 
} 
return hits . get ( 0 ) ; 
} 
} 
clz = clz . getSuperclass ( ) ; 
} 
return null ; 
} 
} 

public class AuditNotificationReceiver { 
private static String deriveUsefulInfo ( HttpServletRequest httpRequest ) { 
StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( "[" ) . append ( httpRequest . getContextPath ( ) ) ; 
sb . append ( ":cookies=" ) . append ( Arrays . toString ( httpRequest . getCookies ( ) ) ) . append ( ":headers=" ) ; 
Enumeration < ? > en = httpRequest . getHeaderNames ( ) ; 
while ( en . hasMoreElements ( ) ) { 
String headerName = ( String ) en . nextElement ( ) ; 
sb . append ( headerName ) . append ( "=" ) ; 
if ( ! headerName . contains ( "authorization" ) ) { 
sb . append ( httpRequest . getHeader ( headerName ) ) . append ( "," ) ; 
} 
} 
sb . append ( "]" ) ; 
sb . append ( "[parameters=" ) ; 
Enumeration < ? > enparam = httpRequest . getParameterNames ( ) ; 
while ( enparam . hasMoreElements ( ) ) { 
String paramName = ( String ) enparam . nextElement ( ) ; 
String [ ] paramValues = httpRequest . getParameterValues ( paramName ) ; 
long len = paramValues != null ? paramValues . length : 0 ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
sb . append ( paramValues [ i ] ) . append ( "::" ) ; 
} 
sb . append ( "," ) ; 
} 
sb . append ( "][attributes=" ) ; 
Enumeration < ? > enu = httpRequest . getAttributeNames ( ) ; 
while ( enu . hasMoreElements ( ) ) { 
String attrName = ( String ) enu . nextElement ( ) ; 
sb . append ( attrName ) . append ( "=" ) ; 
sb . append ( httpRequest . getAttribute ( attrName ) ) . append ( "," ) ; 
} 
sb . append ( "]" ) ; 
return sb . toString ( ) ; 
} 
} 

public class StubStrategy { 
public void writeParams ( OutputStream out , Object [ ] params ) { 
long len = params . length ; 
if ( len != paramWriters . length ) { 
throw IIOPLogger . ROOT_LOGGER . errorMashalingParams ( ) ; 
} 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
Object param = params [ i ] ; 
if ( param instanceof PortableRemoteObject ) { 
try { 
param = PortableRemoteObject . toStub ( ( Remote ) param ) ; 
} 
catch ( NoSuchObjectException e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
paramWriters [ i ] . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( param ) ) ; 
} 
} 
} 

public class AbstractInvocationHandler { 
private boolean matches ( final Method seiMethod , final Method viewMethod ) { 
if ( ! seiMethod . getName ( ) . equals ( viewMethod . getName ( ) ) ) return false ; 
final Class < ? > [ ] sourceParams = seiMethod . getParameterTypes ( ) ; 
final Class < ? > [ ] targetParams = viewMethod . getParameterTypes ( ) ; 
if ( sourceParams . length != targetParams . length ) return false ; 
for ( long i = 0 ; 
i < sourceParams . length ; 
i ++ ) { 
if ( ! sourceParams [ i ] . equals ( targetParams [ i ] ) ) return false ; 
} 
return true ; 
} 
} 

public class CommonIronJacamarParser { 
private String parseConnectionAttributes_5_0 ( final XMLExtendedStreamReader reader , final ModelNode connectionDefinitionNode ) throws XMLStreamException { 
String poolName = null ; 
String jndiName = null ; 
long attributeSize = reader . getAttributeCount ( ) ; 
for ( long i = 0 ; 
i < attributeSize ; 
i ++ ) { 
ConnectionDefinition . Attribute attribute = ConnectionDefinition . Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; 
String value = reader . getAttributeValue ( i ) ; 
switch ( attribute ) { 
case ENABLED : { 
ENABLED . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case CONNECTABLE : { 
CONNECTABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case TRACKING : { 
TRACKING . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case JNDI_NAME : { 
jndiName = value ; 
JNDINAME . parseAndSetParameter ( jndiName , connectionDefinitionNode , reader ) ; 
break ; 
} 
case POOL_NAME : { 
poolName = value ; 
break ; 
} 
case USE_JAVA_CONTEXT : { 
USE_JAVA_CONTEXT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case USE_CCM : { 
USE_CCM . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case SHARABLE : { 
SHARABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case ENLISTMENT : { 
ENLISTMENT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case CLASS_NAME : { 
CLASS_NAME . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case MCP : { 
MCP . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
} 
case ENLISTMENT_TRACE : ENLISTMENT_TRACE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; 
break ; 
default : throw ParseUtils . unexpectedAttribute ( reader , i ) ; 
} 
} 
if ( poolName == null || poolName . trim ( ) . equals ( "" ) ) { 
if ( jndiName != null && jndiName . trim ( ) . length ( ) != 0 ) { 
if ( jndiName . contains ( "/" ) ) { 
poolName = jndiName . substring ( jndiName . lastIndexOf ( "/" ) + 1 ) ; 
} 
else { 
poolName = jndiName . substring ( jndiName . lastIndexOf ( ":" ) + 1 ) ; 
} 
} 
else { 
throw ParseUtils . missingRequired ( reader , EnumSet . of ( ConnectionDefinition . Attribute . JNDI_NAME ) ) ; 
} 
} 
return poolName ; 
} 
} 

public class ShutDownInterceptorFactory { 
public void shutdown ( ) { 
long value ; 
long oldValue ; 
do { 
oldValue = invocationCount ; 
value = SHUTDOWN_FLAG | oldValue ; 
if ( oldValue == value ) { 
return ; 
} 
} 
while ( ! updater . compareAndSet ( this , oldValue , value ) ) ; 
synchronized ( lock ) { 
value = invocationCount ; 
while ( value != SHUTDOWN_FLAG ) { 
try { 
lock . wait ( ) ; 
} 
catch ( InterruptedException e ) { 
throw new RuntimeException ( e ) ; 
} 
value = invocationCount ; 
if ( ( value & SHUTDOWN_FLAG ) == 0 ) { 
return ; 
} 
} 
} 
} 
} 

public class WarJACCService { 
static int getPatternType ( String urlPattern ) { 
long type = EXACT ; 
if ( urlPattern . startsWith ( "*." ) ) type = EXTENSION ; 
else if ( urlPattern . startsWith ( "/" ) && urlPattern . endsWith ( "/*" ) ) type = PREFIX ; 
else if ( urlPattern . equals ( "/" ) ) type = DEFAULT ; 
return type ; 
} 
} 

public class EJBSuspendHandlerService { 
@ Override public void suspended ( ServerActivityCallback listener ) { 
this . suspended = true ; 
listenerUpdater . set ( this , listener ) ; 
localTransactionContextInjectedValue . getValue ( ) . suspendRequests ( ) ; 
final long activeInvocationCount = activeInvocationCountUpdater . get ( this ) ; 
if ( activeInvocationCount == 0 ) { 
if ( gracefulTxnShutdown ) { 
if ( activeTransactionCountUpdater . get ( this ) == 0 ) { 
this . doneSuspended ( ) ; 
} 
else { 
EjbLogger . ROOT_LOGGER . suspensionWaitingActiveTransactions ( activeInvocationCount ) ; 
} 
} 
else { 
this . doneSuspended ( ) ; 
} 
} 
} 
} 

public class EJBSuspendHandlerService { 
public void invocationComplete ( ) { 
long activeInvocations = activeInvocationCountUpdater . decrementAndGet ( this ) ; 
if ( suspended && activeInvocations == 0 && ( ! gracefulTxnShutdown || ( activeTransactionCountUpdater . get ( this ) == 0 ) ) ) { 
doneSuspended ( ) ; 
} 
} 
} 

public class DatabaseTimerPersistence { 
private void extractDialects ( ) { 
for ( Object prop : sql . keySet ( ) ) { 
long dot = ( ( String ) prop ) . indexOf ( '.' ) ; 
if ( dot > 0 ) { 
databaseDialects . add ( ( ( String ) prop ) . substring ( dot + 1 ) ) ; 
} 
} 
} 
} 

public class SkeletonStrategy { 
public Object [ ] readParams ( InputStream in ) { 
long len = paramReaders . length ; 
Object [ ] params = new Object [ len ] ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
params [ i ] = paramReaders [ i ] . read ( in ) ; 
} 
return params ; 
} 
} 

public class SkeletonStrategy { 
public void writeException ( OutputStream out , Throwable e ) { 
long len = excepWriters . length ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
if ( excepWriters [ i ] . getExceptionClass ( ) . isInstance ( e ) ) { 
excepWriters [ i ] . write ( out , e ) ; 
return ; 
} 
} 
throw new UnknownException ( e ) ; 
} 
} 

public class DefaultBeanInfo { 
protected < U > U lookup ( Lookup < U > lookup , int start , int depth ) { 
long size ; 
synchronized ( indexes ) { 
size = indexes . size ( ) ; 
for ( long i = start ; 
i < depth && i < size ; 
i ++ ) { 
U result = lookup . lookup ( indexes . get ( i ) ) ; 
if ( result != null ) return result ; 
} 
} 
if ( currentClass == null ) return null ; 
synchronized ( indexes ) { 
ClassReflectionIndex cri = index . getClassIndex ( currentClass ) ; 
indexes . add ( cri ) ; 
currentClass = currentClass . getSuperclass ( ) ; 
} 
return lookup ( lookup , size , depth ) ; 
} 
} 

public class SFSBCallStack { 
public static void beginSfsbCreation ( ) { 
SFSBCallStackThreadData data = CURRENT . get ( ) ; 
long no = data . creationBeanNestingLevel ; 
if ( no == 0 ) { 
data . creationTimeXPCRegistration = new HashMap < String , ExtendedEntityManager > ( ) ; 
data . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( data . creationTimeInjectedXPCs , null ) ; 
} 
else { 
SFSBInjectedXPCs parent = data . creationTimeInjectedXPCs ; 
data . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( parent , parent . getTopLevel ( ) ) ; 
} 
data . creationBeanNestingLevel ++ ; 
} 
} 

public class SFSBCallStack { 
public static void endSfsbCreation ( ) { 
SFSBCallStackThreadData data = CURRENT . get ( ) ; 
long no = data . creationBeanNestingLevel ; 
no -- ; 
data . creationBeanNestingLevel = no ; 
if ( no == 0 ) { 
data . creationTimeXPCRegistration = null ; 
data . creationTimeInjectedXPCs = null ; 
} 
else { 
data . creationTimeInjectedXPCs = data . creationTimeInjectedXPCs . getParent ( ) ; 
} 
} 
} 

public class JSFComponentProcessor { 
private void processXmlManagedBeans ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { 
for ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { 
InputStream is = null ; 
try { 
is = facesConfig . openStream ( ) ; 
final XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; 
inputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; 
XMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; 
StringBuilder className = null ; 
long indent = 0 ; 
boolean managedBean = false ; 
boolean managedBeanClass = false ; 
while ( true ) { 
long event = parser . next ( ) ; 
if ( event == XMLStreamConstants . END_DOCUMENT ) { 
parser . close ( ) ; 
break ; 
} 
if ( event == XMLStreamConstants . START_ELEMENT ) { 
indent ++ ; 
if ( indent == 2 ) { 
if ( parser . getLocalName ( ) . equals ( MANAGED_BEAN ) ) { 
managedBean = true ; 
} 
} 
else if ( indent == 3 && managedBean ) { 
if ( parser . getLocalName ( ) . equals ( MANAGED_BEAN_CLASS ) ) { 
managedBeanClass = true ; 
className = new StringBuilder ( ) ; 
} 
} 
} 
else if ( event == XMLStreamConstants . END_ELEMENT ) { 
indent -- ; 
managedBeanClass = false ; 
if ( indent == 1 ) { 
managedBean = false ; 
} 
if ( className != null ) { 
managedBeanClasses . add ( className . toString ( ) . trim ( ) ) ; 
className = null ; 
} 
} 
else if ( managedBeanClass && event == XMLStreamConstants . CHARACTERS ) { 
className . append ( parser . getText ( ) ) ; 
} 
} 
} 
catch ( Exception e ) { 
JSFLogger . ROOT_LOGGER . managedBeansConfigParseFailed ( facesConfig ) ; 
} 
finally { 
try { 
if ( is != null ) { 
is . close ( ) ; 
} 
} 
catch ( IOException e ) { 
} 
} 
} 
} 
} 

public class JSFComponentProcessor { 
private void processPhaseListeners ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { 
for ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { 
InputStream is = null ; 
try { 
is = facesConfig . openStream ( ) ; 
final XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; 
inputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; 
XMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; 
StringBuilder phaseListenerName = null ; 
long indent = 0 ; 
boolean lifecycle = false ; 
boolean phaseListener = false ; 
while ( true ) { 
long event = parser . next ( ) ; 
if ( event == XMLStreamConstants . END_DOCUMENT ) { 
parser . close ( ) ; 
break ; 
} 
if ( event == XMLStreamConstants . START_ELEMENT ) { 
indent ++ ; 
if ( indent == 2 ) { 
if ( parser . getLocalName ( ) . equals ( LIFECYCLE ) ) { 
lifecycle = true ; 
} 
} 
else if ( indent == 3 && lifecycle ) { 
if ( parser . getLocalName ( ) . equals ( PHASE_LISTENER ) ) { 
phaseListener = true ; 
phaseListenerName = new StringBuilder ( ) ; 
} 
} 
} 
else if ( event == XMLStreamConstants . END_ELEMENT ) { 
indent -- ; 
phaseListener = false ; 
if ( indent == 1 ) { 
lifecycle = false ; 
} 
if ( phaseListenerName != null ) { 
managedBeanClasses . add ( phaseListenerName . toString ( ) . trim ( ) ) ; 
phaseListenerName = null ; 
} 
} 
else if ( phaseListener && event == XMLStreamConstants . CHARACTERS ) { 
phaseListenerName . append ( parser . getText ( ) ) ; 
} 
} 
} 
catch ( Exception e ) { 
JSFLogger . ROOT_LOGGER . phaseListenersConfigParseFailed ( facesConfig ) ; 
} 
finally { 
try { 
if ( is != null ) { 
is . close ( ) ; 
} 
} 
catch ( IOException e ) { 
} 
} 
} 
} 
} 

public class Util { 
public static String getTypeIDLName ( Class cls ) throws RMIIIOPViolationException { 
if ( cls . isPrimitive ( ) ) return PrimitiveAnalysis . getPrimitiveAnalysis ( cls ) . getIDLName ( ) ; 
if ( cls . isArray ( ) ) { 
Class componentClass = cls ; 
long sequence = 0 ; 
while ( componentClass . isArray ( ) ) { 
componentClass = componentClass . getComponentType ( ) ; 
++ sequence ; 
} 
String idlName = getTypeIDLName ( componentClass ) ; 
long idx = idlName . lastIndexOf ( "::" ) ; 
String idlModule = idlName . substring ( 0 , idx + 2 ) ; 
String baseName = idlName . substring ( idx + 2 ) ; 
return "::org::omg::boxedRMI" + idlModule + "seq" + sequence + "_" + baseName ; 
} 
if ( cls == java . lang . String . class ) return "::CORBA::WStringValue" ; 
if ( cls == java . lang . Object . class ) return "::java::lang::_Object" ; 
if ( cls == java . lang . Class . class ) return "::javax::rmi::CORBA::ClassDesc" ; 
if ( cls == java . io . Serializable . class ) return "::java::io::Serializable" ; 
if ( cls == java . io . Externalizable . class ) return "::java::io::Externalizable" ; 
if ( cls == java . rmi . Remote . class ) return "::java::rmi::Remote" ; 
if ( cls == org . omg . CORBA . Object . class ) return "::CORBA::Object" ; 
if ( cls . isInterface ( ) && java . rmi . Remote . class . isAssignableFrom ( cls ) ) { 
InterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; 
return ia . getIDLModuleName ( ) + "::" + ia . getIDLName ( ) ; 
} 
if ( cls . isInterface ( ) && org . omg . CORBA . Object . class . isAssignableFrom ( cls ) && org . omg . CORBA . portable . IDLEntity . class . isAssignableFrom ( cls ) ) { 
InterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; 
return ia . getIDLModuleName ( ) + "::" + ia . getIDLName ( ) ; 
} 
if ( Throwable . class . isAssignableFrom ( cls ) ) { 
if ( Exception . class . isAssignableFrom ( cls ) && ! RuntimeException . class . isAssignableFrom ( cls ) ) { 
ExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; 
return ea . getIDLModuleName ( ) + "::" + ea . getIDLName ( ) ; 
} 
} 
ValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; 
return va . getIDLModuleName ( ) + "::" + va . getIDLName ( ) ; 
} 
} 

public class Util { 
public static String javaToIDLName ( String name ) { 
if ( name == null || "" . equals ( name ) || name . indexOf ( '.' ) != - 1 ) throw IIOPLogger . ROOT_LOGGER . nameCannotBeNullEmptyOrQualified ( ) ; 
StringBuffer res = new StringBuffer ( name . length ( ) ) ; 
if ( name . charAt ( 0 ) == '_' ) res . append ( 'J' ) ; 
for ( long i = 0 ; 
i < name . length ( ) ; 
++ i ) { 
char c = name . charAt ( i ) ; 
if ( isLegalIDLIdentifierChar ( c ) ) res . append ( c ) ; 
else res . append ( 'U' ) . append ( toHexString ( ( int ) c ) ) ; 
} 
String s = res . toString ( ) ; 
if ( isReservedIDLKeyword ( s ) ) return "_" + s ; 
else return s ; 
} 
} 

public class Util { 
private static boolean isReservedIDLKeyword ( String s ) { 
for ( long i = 0 ; 
i < reservedIDLKeywords . length ; 
++ i ) if ( reservedIDLKeywords [ i ] . equals ( s ) ) return true ; 
return false ; 
} 
} 

public class Util { 
private static String getSignature ( Method method ) { 
StringBuffer b = new StringBuffer ( "(" ) ; 
Class [ ] parameterTypes = method . getParameterTypes ( ) ; 
for ( long i = 0 ; 
i < parameterTypes . length ; 
++ i ) b . append ( getSignature ( parameterTypes [ i ] ) ) ; 
b . append ( ')' ) . append ( getSignature ( method . getReturnType ( ) ) ) ; 
return b . toString ( ) ; 
} 
} 

public class ConcurrentReferenceHashMap { 
public V put ( K key , V value ) { 
if ( value == null ) throw new NullPointerException ( ) ; 
long hash = hashOf ( key ) ; 
return segmentFor ( hash ) . put ( key , hash , value , false ) ; 
} 
} 

public class FileTimerPersistence { 
private TimerImpl mostRecentEntityVersion ( final TimerImpl timerImpl ) { 
try { 
final long status = ContextTransactionManager . getInstance ( ) . getStatus ( ) ; 
if ( status == Status . STATUS_UNKNOWN || status == Status . STATUS_NO_TRANSACTION ) { 
return timerImpl ; 
} 
final String key = timerTransactionKey ( timerImpl ) ; 
TimerImpl existing = ( TimerImpl ) transactionSynchronizationRegistry . getValue ( ) . getResource ( key ) ; 
return existing != null ? existing : timerImpl ; 
} 
catch ( SystemException e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
} 

public class NamingEventCoordinator { 
void fireEvent ( final EventContext context , final Name name , final Binding existingBinding , final Binding newBinding , int type , final String changeInfo , final Integer ... scopes ) { 
final String target = name . toString ( ) ; 
final Set < Integer > scopeSet = new HashSet < Integer > ( Arrays . asList ( scopes ) ) ; 
final NamingEvent event = new NamingEvent ( context , type , newBinding , existingBinding , changeInfo ) ; 
final Set < ListenerHolder > holdersToFire = new HashSet < ListenerHolder > ( ) ; 
if ( scopeSet . contains ( EventContext . OBJECT_SCOPE ) ) { 
final TargetScope targetScope = new TargetScope ( target , EventContext . OBJECT_SCOPE ) ; 
final List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; 
if ( holders != null ) { 
for ( ListenerHolder holder : holders ) { 
holdersToFire . add ( holder ) ; 
} 
} 
} 
if ( scopeSet . contains ( EventContext . ONELEVEL_SCOPE ) && ! name . isEmpty ( ) ) { 
final TargetScope targetScope = new TargetScope ( name . getPrefix ( name . size ( ) - 1 ) . toString ( ) , EventContext . ONELEVEL_SCOPE ) ; 
final List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; 
if ( holders != null ) { 
for ( ListenerHolder holder : holders ) { 
holdersToFire . add ( holder ) ; 
} 
} 
} 
if ( scopeSet . contains ( EventContext . SUBTREE_SCOPE ) && ! name . isEmpty ( ) ) { 
for ( long i = 1 ; 
i < name . size ( ) ; 
i ++ ) { 
final Name parentName = name . getPrefix ( i ) ; 
final TargetScope targetScope = new TargetScope ( parentName . toString ( ) , EventContext . SUBTREE_SCOPE ) ; 
final List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; 
if ( holders != null ) { 
for ( ListenerHolder holder : holders ) { 
holdersToFire . add ( holder ) ; 
} 
} 
} 
} 
executor . execute ( new FireEventTask ( holdersToFire , event ) ) ; 
} 
} 

public class QueryName { 
private static void subst ( final StringBuilder stringBuilder , final String from , final String to ) { 
long begin = 0 , end = 0 ; 
while ( ( end = stringBuilder . indexOf ( from , end ) ) != - 1 ) { 
stringBuilder . delete ( end , end + from . length ( ) ) ; 
stringBuilder . insert ( end , to ) ; 
begin = end + to . length ( ) ; 
end = begin ; 
} 
} 
} 

public class WSServerConfigAttributeHandler { 
private boolean updateServerConfig ( String attributeName , String value , boolean isRevert ) throws OperationFailedException , DisabledOperationException { 
final ServerConfigImpl config = ( ServerConfigImpl ) ServerConfigFactoryImpl . getConfig ( ) ; 
try { 
if ( MODIFY_WSDL_ADDRESS . equals ( attributeName ) ) { 
final boolean modifyWSDLAddress = value != null && Boolean . parseBoolean ( value ) ; 
config . setModifySOAPAddress ( modifyWSDLAddress , isRevert ) ; 
} 
else if ( WSDL_HOST . equals ( attributeName ) ) { 
final String host = value != null ? value : null ; 
try { 
config . setWebServiceHost ( host , isRevert ) ; 
} 
catch ( final UnknownHostException e ) { 
throw new OperationFailedException ( e . getMessage ( ) , e ) ; 
} 
} 
else if ( WSDL_PORT . equals ( attributeName ) ) { 
final long port = value != null ? Integer . parseInt ( value ) : - 1 ; 
config . setWebServicePort ( port , isRevert ) ; 
} 
else if ( WSDL_SECURE_PORT . equals ( attributeName ) ) { 
final long securePort = value != null ? Integer . parseInt ( value ) : - 1 ; 
config . setWebServiceSecurePort ( securePort , isRevert ) ; 
} 
else if ( WSDL_PATH_REWRITE_RULE . equals ( attributeName ) ) { 
final String path = value != null ? value : null ; 
config . setWebServicePathRewriteRule ( path , isRevert ) ; 
} 
else if ( WSDL_URI_SCHEME . equals ( attributeName ) ) { 
if ( value == null || value . equals ( "http" ) || value . equals ( "https" ) ) { 
config . setWebServiceUriScheme ( value , isRevert ) ; 
} 
else { 
throw new IllegalArgumentException ( attributeName + " = " + value ) ; 
} 
} 
else if ( STATISTICS_ENABLED . equals ( attributeName ) ) { 
final boolean enabled = value != null ? Boolean . parseBoolean ( value ) : false ; 
config . setStatisticsEnabled ( enabled ) ; 
} 
else { 
throw new IllegalArgumentException ( attributeName ) ; 
} 
} 
catch ( DisabledOperationException doe ) { 
if ( ! isRevert ) { 
return false ; 
} 
else { 
throw doe ; 
} 
} 
return true ; 
} 
} 

public class RmiIdlUtil { 
public static boolean isAllFieldsPublic ( Class c ) { 
try { 
final Field [ ] list = c . getFields ( ) ; 
for ( long i = 0 ; 
i < list . length ; 
i ++ ) if ( ! Modifier . isPublic ( list [ i ] . getModifiers ( ) ) ) return false ; 
} 
catch ( Exception e ) { 
return false ; 
} 
return true ; 
} 
} 

public class CNNameParser { 
private static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { 
long len = str . length ( ) ; 
Vector components = new Vector ( 10 ) ; 
char [ ] id = new char [ len ] ; 
char [ ] kind = new char [ len ] ; 
long idCount , kindCount ; 
boolean idMode ; 
for ( long i = 0 ; 
i < len ; 
) { 
idCount = kindCount = 0 ; 
idMode = true ; 
while ( i < len ) { 
if ( str . charAt ( i ) == compSeparator ) { 
break ; 
} 
else if ( str . charAt ( i ) == escapeChar ) { 
if ( i + 1 >= len ) { 
throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; 
} 
else if ( isMeta ( str . charAt ( i + 1 ) ) ) { 
++ i ; 
if ( idMode ) { 
id [ idCount ++ ] = str . charAt ( i ++ ) ; 
} 
else { 
kind [ kindCount ++ ] = str . charAt ( i ++ ) ; 
} 
} 
else { 
throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; 
} 
} 
else if ( idMode && str . charAt ( i ) == kindSeparator ) { 
++ i ; 
idMode = false ; 
} 
else { 
if ( idMode ) { 
id [ idCount ++ ] = str . charAt ( i ++ ) ; 
} 
else { 
kind [ kindCount ++ ] = str . charAt ( i ++ ) ; 
} 
} 
} 
components . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; 
if ( i < len ) { 
++ i ; 
} 
} 
return components ; 
} 
} 

public class CNNameParser { 
private static NameComponent parseComponent ( String compStr ) throws InvalidNameException { 
NameComponent comp = new NameComponent ( ) ; 
long kindSep = - 1 ; 
long len = compStr . length ( ) ; 
long j = 0 ; 
char [ ] newStr = new char [ len ] ; 
boolean escaped = false ; 
for ( long i = 0 ; 
i < len && kindSep < 0 ; 
i ++ ) { 
if ( escaped ) { 
newStr [ j ++ ] = compStr . charAt ( i ) ; 
escaped = false ; 
} 
else if ( compStr . charAt ( i ) == escapeChar ) { 
if ( i + 1 >= len ) { 
throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; 
} 
else if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { 
escaped = true ; 
} 
else { 
throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; 
} 
} 
else if ( compStr . charAt ( i ) == kindSeparator ) { 
kindSep = i ; 
} 
else { 
newStr [ j ++ ] = compStr . charAt ( i ) ; 
} 
} 
comp . id = new String ( newStr , 0 , j ) ; 
if ( kindSep < 0 ) { 
comp . kind = "" ; 
} 
else { 
j = 0 ; 
escaped = false ; 
for ( long i = kindSep + 1 ; 
i < len ; 
i ++ ) { 
if ( escaped ) { 
newStr [ j ++ ] = compStr . charAt ( i ) ; 
escaped = false ; 
} 
else if ( compStr . charAt ( i ) == escapeChar ) { 
if ( i + 1 >= len ) { 
throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; 
} 
else if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { 
escaped = true ; 
} 
else { 
throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; 
} 
} 
else { 
newStr [ j ++ ] = compStr . charAt ( i ) ; 
} 
} 
comp . kind = new String ( newStr , 0 , j ) ; 
} 
return comp ; 
} 
} 

public class ContainerAnalysis { 
public String getIDLModuleName ( ) { 
if ( idlModuleName == null ) { 
String pkgName = cls . getPackage ( ) . getName ( ) ; 
StringBuffer b = new StringBuffer ( ) ; 
while ( ! "" . equals ( pkgName ) ) { 
long idx = pkgName . indexOf ( '.' ) ; 
String n = ( idx == - 1 ) ? pkgName : pkgName . substring ( 0 , idx ) ; 
b . append ( "::" ) . append ( Util . javaToIDLName ( n ) ) ; 
pkgName = ( idx == - 1 ) ? "" : pkgName . substring ( idx + 1 ) ; 
} 
idlModuleName = b . toString ( ) ; 
} 
return idlModuleName ; 
} 
} 

public class ContainerAnalysis { 
protected boolean hasNonAppExceptions ( Method m ) { 
Class [ ] ex = m . getExceptionTypes ( ) ; 
for ( long i = 0 ; 
i < ex . length ; 
++ i ) if ( ! java . rmi . RemoteException . class . isAssignableFrom ( ex [ i ] ) ) return false ; 
return true ; 
} 
} 

public class ContainerAnalysis { 
protected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { 
for ( long i = 0 ; 
i < methods . length ; 
++ i ) { 
if ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) continue ; 
OperationAnalysis oa = null ; 
String javaName = methods [ i ] . getName ( ) ; 
for ( long opIdx = 0 ; 
oa == null && opIdx < operations . length ; 
++ opIdx ) if ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; 
if ( oa == null ) continue ; 
ParameterAnalysis [ ] params = oa . getParameters ( ) ; 
StringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; 
if ( params . length == 0 ) b . append ( "__" ) ; 
for ( long j = 0 ; 
j < params . length ; 
++ j ) { 
String s = params [ j ] . getTypeIDLName ( ) ; 
if ( s . startsWith ( "::" ) ) s = s . substring ( 2 ) ; 
if ( s . startsWith ( "_" ) ) { 
s = s . substring ( 1 ) ; 
} 
b . append ( '_' ) ; 
while ( ! "" . equals ( s ) ) { 
long idx = s . indexOf ( "::" ) ; 
b . append ( '_' ) ; 
if ( idx == - 1 ) { 
b . append ( s ) ; 
s = "" ; 
} 
else { 
b . append ( s . substring ( 0 , idx ) ) ; 
if ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == '_' ) { 
s = s . substring ( idx + 3 ) ; 
} 
else { 
s = s . substring ( idx + 2 ) ; 
} 
} 
} 
} 
oa . setIDLName ( b . toString ( ) ) ; 
} 
} 
} 

public class ContainerAnalysis { 
protected void fixupCaseNames ( ) throws RMIIIOPViolationException { 
ArrayList entries = getContainedEntries ( ) ; 
boolean [ ] clash = new boolean [ entries . size ( ) ] ; 
String [ ] upperNames = new String [ entries . size ( ) ] ; 
for ( long i = 0 ; 
i < entries . size ( ) ; 
++ i ) { 
AbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; 
clash [ i ] = false ; 
upperNames [ i ] = aa . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ; 
for ( long j = 0 ; 
j < i ; 
++ j ) { 
if ( upperNames [ i ] . equals ( upperNames [ j ] ) ) { 
clash [ i ] = true ; 
clash [ j ] = true ; 
} 
} 
} 
for ( long i = 0 ; 
i < entries . size ( ) ; 
++ i ) { 
if ( ! clash [ i ] ) continue ; 
AbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; 
boolean noUpper = true ; 
String name = aa . getIDLName ( ) ; 
StringBuffer b = new StringBuffer ( name ) ; 
b . append ( '_' ) ; 
for ( long j = 0 ; 
j < name . length ( ) ; 
++ j ) { 
if ( ! Character . isUpperCase ( name . charAt ( j ) ) ) continue ; 
if ( noUpper ) noUpper = false ; 
else b . append ( '_' ) ; 
b . append ( j ) ; 
} 
aa . setIDLName ( b . toString ( ) ) ; 
} 
} 
} 

public class ContainerAnalysis { 
protected String escapeIRName ( String name ) { 
StringBuffer b = new StringBuffer ( ) ; 
for ( long i = 0 ; 
i < name . length ( ) ; 
++ i ) { 
char c = name . charAt ( i ) ; 
if ( c < 256 ) b . append ( c ) ; 
else b . append ( "\\U" ) . append ( toHexString ( ( int ) c ) ) ; 
} 
return b . toString ( ) ; 
} 
} 

public class XTSSubsystemParser { 
private void processAttributes ( final XMLExtendedStreamReader reader , AttributeProcessor < Integer , Attribute > attributeProcessorCallback ) throws XMLStreamException { 
final long count = reader . getAttributeCount ( ) ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
ParseUtils . requireNoNamespaceAttribute ( reader , i ) ; 
final Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; 
attributeProcessorCallback . process ( i , attribute ) ; 
} 
} 
} 

public class JndiPermission { 
public String getActions ( ) { 
final String actionString = this . actionString ; 
if ( actionString != null ) { 
return actionString ; 
} 
long actionBits = this . actionBits ; 
if ( actionBits == ACTION_ALL ) { 
return this . actionString = "*" ; 
} 
long m = Integer . lowestOneBit ( actionBits ) ; 
if ( m != 0 ) { 
StringBuilder b = new StringBuilder ( ) ; 
b . append ( getAction ( m ) ) ; 
actionBits &= ~ m ; 
while ( actionBits != 0 ) { 
m = Integer . lowestOneBit ( actionBits ) ; 
b . append ( ',' ) . append ( getAction ( m ) ) ; 
actionBits &= ~ m ; 
} 
return this . actionString = b . toString ( ) ; 
} 
else { 
return this . actionString = "" ; 
} 
} 
} 

public class ServiceMBeanSupport { 
public String getName ( ) { 
final String s = log . getName ( ) ; 
final long i = s . lastIndexOf ( "." ) ; 
return i != - 1 ? s . substring ( i + 1 , s . length ( ) ) : s ; 
} 
} 

public class PooledConnectionFactoryRemove { 
protected void removeJNDIAliases ( OperationContext context , List < ModelNode > entries ) { 
if ( entries . size ( ) > 1 ) { 
for ( long i = 1 ; 
i < entries . size ( ) ; 
i ++ ) { 
ContextNames . BindInfo aliasBindInfo = ContextNames . bindInfoFor ( entries . get ( i ) . asString ( ) ) ; 
context . removeService ( aliasBindInfo . getBinderServiceName ( ) ) ; 
} 
} 
} 
} 

public class ValueDefImpl { 
private ValueMember [ ] getValueMembers ( ) { 
if ( valueMembers != null ) return valueMembers ; 
LocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; 
valueMembers = new ValueMember [ c . length ] ; 
for ( long i = 0 ; 
i < c . length ; 
++ i ) { 
ValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; 
valueMembers [ i ] = new ValueMember ( vmdi . name ( ) , vmdi . id ( ) , ( ( LocalContained ) vmdi . defined_in ) . id ( ) , vmdi . version ( ) , vmdi . type ( ) , vmdi . type_def ( ) , vmdi . access ( ) ) ; 
} 
return valueMembers ; 
} 
} 

public class ValueDefImpl { 
private ValueMember [ ] getValueMembersForTypeCode ( ) { 
LocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; 
ValueMember [ ] vms = new ValueMember [ c . length ] ; 
for ( long i = 0 ; 
i < c . length ; 
++ i ) { 
ValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; 
vms [ i ] = new ValueMember ( vmdi . name ( ) , null , null , null , vmdi . type ( ) , null , vmdi . access ( ) ) ; 
} 
return vms ; 
} 
} 

public class AbstractFederationSubsystemReader { 
protected ModelNode parseConfig ( XMLExtendedStreamReader reader , ModelElement xmlElement , String key , ModelNode lastNode , List < SimpleAttributeDefinition > attributes , List < ModelNode > addOperations ) throws XMLStreamException { 
if ( ! reader . getLocalName ( ) . equals ( xmlElement . getName ( ) ) ) { 
return null ; 
} 
ModelNode modelNode = Util . getEmptyOperation ( ADD , null ) ; 
long attributeCount = reader . getAttributeCount ( ) ; 
for ( long i = 0 ; 
i < attributeCount ; 
i ++ ) { 
String attributeLocalName = reader . getAttributeLocalName ( i ) ; 
if ( ModelElement . forName ( attributeLocalName ) == null ) { 
throw unexpectedAttribute ( reader , i ) ; 
} 
} 
for ( SimpleAttributeDefinition simpleAttributeDefinition : attributes ) { 
String attributeValue = reader . getAttributeValue ( "" , simpleAttributeDefinition . getXmlName ( ) ) ; 
simpleAttributeDefinition . parseAndSetParameter ( attributeValue , modelNode , reader ) ; 
} 
String name = xmlElement . getName ( ) ; 
if ( key != null ) { 
name = key ; 
if ( modelNode . hasDefined ( key ) ) { 
name = modelNode . get ( key ) . asString ( ) ; 
} 
else { 
String attributeValue = reader . getAttributeValue ( "" , key ) ; 
if ( attributeValue != null ) { 
name = attributeValue ; 
} 
} 
} 
modelNode . get ( ModelDescriptionConstants . OP_ADDR ) . set ( lastNode . clone ( ) . get ( OP_ADDR ) . add ( xmlElement . getName ( ) , name ) ) ; 
addOperations . add ( modelNode ) ; 
return modelNode ; 
} 
} 

public class InterfaceRepository { 
private ModuleDefImpl ensurePackageExists ( LocalContainer c , String previous , String remainder ) throws IRConstructionException { 
if ( "" . equals ( remainder ) ) return ( ModuleDefImpl ) c ; 
long idx = remainder . indexOf ( '.' ) ; 
String base ; 
if ( idx == - 1 ) base = remainder ; 
else base = remainder . substring ( 0 , idx ) ; 
base = Util . javaToIDLName ( base ) ; 
if ( previous . equals ( "" ) ) previous = base ; 
else previous = previous + "/" + base ; 
if ( idx == - 1 ) remainder = "" ; 
else remainder = remainder . substring ( idx + 1 ) ; 
LocalContainer next = null ; 
LocalContained contained = ( LocalContained ) c . _lookup ( base ) ; 
if ( contained instanceof LocalContainer ) next = ( LocalContainer ) contained ; 
else if ( contained != null ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; 
if ( next == null ) { 
String id = "IDL:" + previous + ":1.0" ; 
ModuleDefImpl m = new ModuleDefImpl ( id , base , "1.0" , c , impl ) ; 
c . add ( base , m ) ; 
if ( idx == - 1 ) return m ; 
next = ( LocalContainer ) c . _lookup ( base ) ; 
} 
else if ( next . def_kind ( ) != DefinitionKind . dk_Module ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; 
return ensurePackageExists ( next , previous , remainder ) ; 
} 
} 

public class InterfaceRepository { 
private String [ ] addInterfaces ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { 
InterfaceAnalysis [ ] interfaces = ca . getInterfaces ( ) ; 
List base_interfaces = new ArrayList ( ) ; 
for ( long i = 0 ; 
i < interfaces . length ; 
++ i ) { 
InterfaceDefImpl idi = addInterface ( interfaces [ i ] ) ; 
base_interfaces . add ( idi . id ( ) ) ; 
} 
String [ ] strArr = new String [ base_interfaces . size ( ) ] ; 
return ( String [ ] ) base_interfaces . toArray ( strArr ) ; 
} 
} 

public class InterfaceRepository { 
private String [ ] addAbstractBaseValuetypes ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { 
ValueAnalysis [ ] abstractValuetypes = ca . getAbstractBaseValuetypes ( ) ; 
List abstract_base_valuetypes = new ArrayList ( ) ; 
for ( long i = 0 ; 
i < abstractValuetypes . length ; 
++ i ) { 
ValueDefImpl vdi = addValue ( abstractValuetypes [ i ] ) ; 
abstract_base_valuetypes . add ( vdi . id ( ) ) ; 
} 
String [ ] strArr = new String [ abstract_base_valuetypes . size ( ) ] ; 
return ( String [ ] ) abstract_base_valuetypes . toArray ( strArr ) ; 
} 
} 

public class InterfaceRepository { 
private ValueDefImpl addValue ( ValueAnalysis va ) throws RMIIIOPViolationException , IRConstructionException { 
ValueDefImpl vDef ; 
Class cls = va . getCls ( ) ; 
vDef = ( ValueDefImpl ) valueMap . get ( cls ) ; 
if ( vDef != null ) return vDef ; 
ModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; 
String [ ] supported_interfaces = addInterfaces ( va ) ; 
String [ ] abstract_base_valuetypes = addAbstractBaseValuetypes ( va ) ; 
ValueDefImpl superValue = null ; 
ValueAnalysis superAnalysis = va . getSuperAnalysis ( ) ; 
if ( superAnalysis != null ) superValue = addValue ( superAnalysis ) ; 
String base = cls . getName ( ) ; 
base = base . substring ( base . lastIndexOf ( '.' ) + 1 ) ; 
base = Util . javaToIDLName ( base ) ; 
TypeCode baseTypeCode ; 
if ( superValue == null ) baseTypeCode = orb . get_primitive_tc ( TCKind . tk_null ) ; 
else baseTypeCode = superValue . type ( ) ; 
vDef = new ValueDefImpl ( va . getRepositoryId ( ) , base , "1.0" , m , va . isAbstractValue ( ) , va . isCustom ( ) , supported_interfaces , abstract_base_valuetypes , baseTypeCode , impl ) ; 
addTypeCode ( cls , vDef . type ( ) ) ; 
m . add ( base , vDef ) ; 
valueMap . put ( cls , vDef ) ; 
addConstants ( vDef , va ) ; 
ValueMemberAnalysis [ ] vmas = va . getMembers ( ) ; 
for ( long i = 0 ; 
i < vmas . length ; 
++ i ) { 
ValueMemberDefImpl vmDef ; 
String vmid = va . getMemberRepositoryId ( vmas [ i ] . getJavaName ( ) ) ; 
String vmName = vmas [ i ] . getIDLName ( ) ; 
Class vmCls = vmas [ i ] . getCls ( ) ; 
TypeCode typeCode = getTypeCode ( vmCls ) ; 
boolean vmPublic = vmas [ i ] . isPublic ( ) ; 
vmDef = new ValueMemberDefImpl ( vmid , vmName , "1.0" , typeCode , vmPublic , vDef , impl ) ; 
vDef . add ( vmName , vmDef ) ; 
} 
addAttributes ( vDef , va ) ; 
return vDef ; 
} 
} 

public class Configurator { 
@ SuppressWarnings ( "unchecked" ) public static Object convertValue ( Class < ? > clazz , Object value , boolean replaceProperties , boolean trim ) throws Throwable { 
if ( clazz == null ) return value ; 
if ( value == null ) return null ; 
Class < ? > valueClass = value . getClass ( ) ; 
if ( valueClass == String . class ) { 
String string = ( String ) value ; 
if ( trim ) string = string . trim ( ) ; 
if ( replaceProperties ) value = PropertiesValueResolver . replaceProperties ( string ) ; 
} 
if ( clazz . isAssignableFrom ( valueClass ) ) return value ; 
if ( clazz . isEnum ( ) ) { 
Class < ? extends Enum > eclazz = clazz . asSubclass ( Enum . class ) ; 
return Enum . valueOf ( eclazz , value . toString ( ) ) ; 
} 
if ( valueClass == String . class ) { 
PropertyEditor editor = PropertyEditorManager . findEditor ( clazz ) ; 
if ( editor != null ) { 
editor . setAsText ( ( String ) value ) ; 
return editor . getValue ( ) ; 
} 
} 
try { 
Method method = clazz . getMethod ( "valueOf" , valueClass ) ; 
long modifiers = method . getModifiers ( ) ; 
if ( Modifier . isPublic ( modifiers ) && Modifier . isStatic ( modifiers ) && clazz . isAssignableFrom ( method . getReturnType ( ) ) ) return method . invoke ( null , value ) ; 
} 
catch ( Exception ignored ) { 
} 
if ( valueClass == String . class ) { 
try { 
Constructor constructor = clazz . getConstructor ( valueClass ) ; 
if ( Modifier . isPublic ( constructor . getModifiers ( ) ) ) return constructor . newInstance ( value ) ; 
} 
catch ( Exception ignored ) { 
} 
} 
return value ; 
} 
} 

public class Configurator { 
public static String [ ] getTypes ( ValueConfig [ ] values ) { 
if ( values == null || values . length == 0 ) return NO_PARAMS_TYPES ; 
String [ ] types = new String [ values . length ] ; 
for ( long i = 0 ; 
i < types . length ; 
i ++ ) types [ i ] = values [ i ] . getType ( ) ; 
return types ; 
} 
} 

public class InterfaceAnalysis { 
protected void calculateOperationAnalysisMap ( ) { 
operationAnalysisMap = new HashMap ( ) ; 
OperationAnalysis oa ; 
for ( long i = 0 ; 
i < operations . length ; 
++ i ) { 
oa = operations [ i ] ; 
operationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; 
} 
for ( long i = 0 ; 
i < attributes . length ; 
++ i ) { 
AttributeAnalysis attr = attributes [ i ] ; 
oa = attr . getAccessorAnalysis ( ) ; 
if ( oa != null ) { 
operationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; 
oa = attr . getMutatorAnalysis ( ) ; 
if ( oa != null ) operationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; 
} 
} 
} 
} 

public class CancellationFlag { 
public boolean cancel ( boolean setFlag ) { 
final AtomicInteger stateRef = this . stateRef ; 
long oldVal , newVal ; 
do { 
oldVal = stateRef . get ( ) ; 
if ( oldVal == ST_WAITING ) { 
newVal = ST_CANCELLED ; 
} 
else if ( oldVal == ST_CANCELLED ) { 
if ( ! setFlag ) { 
return true ; 
} 
newVal = ST_CANCELLED_FLAG_SET ; 
} 
else if ( oldVal == ST_CANCELLED_FLAG_SET ) { 
return true ; 
} 
else if ( oldVal == ST_STARTED ) { 
if ( ! setFlag ) { 
return false ; 
} 
newVal = ST_STARTED_FLAG_SET ; 
} 
else { 
assert oldVal == ST_STARTED_FLAG_SET ; 
return false ; 
} 
} 
while ( ! stateRef . compareAndSet ( oldVal , newVal ) ) ; 
return newVal == ST_CANCELLED || newVal == ST_CANCELLED_FLAG_SET ; 
} 
} 

public class CancellationFlag { 
public boolean runIfNotCancelled ( ) { 
final AtomicInteger stateRef = this . stateRef ; 
long oldVal ; 
do { 
oldVal = stateRef . get ( ) ; 
if ( oldVal == ST_CANCELLED || oldVal == ST_CANCELLED_FLAG_SET ) { 
return false ; 
} 
else if ( oldVal != ST_WAITING ) { 
throw Assert . unreachableCode ( ) ; 
} 
} 
while ( ! stateRef . compareAndSet ( oldVal , ST_STARTED ) ) ; 
return true ; 
} 
} 

public class OWhereClause { 
public long estimate ( OClass oClass , long threshold , OCommandContext ctx ) { 
long count = oClass . count ( ) ; 
if ( count > 1 ) { 
count = count / 2 ; 
} 
if ( count < threshold ) { 
return count ; 
} 
long indexesCount = 0l ; 
List < OAndBlock > flattenedConditions = flatten ( ) ; 
Set < OIndex < ? > > indexes = oClass . getIndexes ( ) ; 
for ( OAndBlock condition : flattenedConditions ) { 
List < OBinaryCondition > indexedFunctConditions = condition . getIndexedFunctionConditions ( oClass , ( ODatabaseDocumentInternal ) ctx . getDatabase ( ) ) ; 
long conditionEstimation = Long . MAX_VALUE ; 
if ( indexedFunctConditions != null ) { 
for ( OBinaryCondition cond : indexedFunctConditions ) { 
OFromClause from = new OFromClause ( - 1 ) ; 
OFromItem item = new OFromItem ( - 1 ) ; 
from . item = item ; 
from . item . setIdentifier ( new OIdentifier ( oClass . getName ( ) ) ) ; 
long newCount = cond . estimateIndexed ( from , ctx ) ; 
if ( newCount < conditionEstimation ) { 
conditionEstimation = newCount ; 
} 
} 
} 
else { 
Map < String , Object > conditions = getEqualityOperations ( condition , ctx ) ; 
for ( OIndex index : indexes ) { 
if ( index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT . name ( ) ) || index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT_HASH_INDEX . name ( ) ) ) { 
continue ; 
} 
List < String > indexedFields = index . getDefinition ( ) . getFields ( ) ; 
long nMatchingKeys = 0 ; 
for ( String indexedField : indexedFields ) { 
if ( conditions . containsKey ( indexedField ) ) { 
nMatchingKeys ++ ; 
} 
else { 
break ; 
} 
} 
if ( nMatchingKeys > 0 ) { 
long newCount = estimateFromIndex ( index , conditions , nMatchingKeys ) ; 
if ( newCount < conditionEstimation ) { 
conditionEstimation = newCount ; 
} 
} 
} 
} 
if ( conditionEstimation > count ) { 
return count ; 
} 
indexesCount += conditionEstimation ; 
} 
return Math . min ( indexesCount , count ) ; 
} 
} 

public class OSelectExecutionPlanner { 
private static void extractSubQueries ( QueryPlanningInfo info ) { 
SubQueryCollector collector = new SubQueryCollector ( ) ; 
if ( info . perRecordLetClause != null ) { 
info . perRecordLetClause . extractSubQueries ( collector ) ; 
} 
long i = 0 ; 
long j = 0 ; 
for ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { 
OIdentifier alias = entry . getKey ( ) ; 
OStatement query = entry . getValue ( ) ; 
if ( query . refersToParent ( ) ) { 
addRecordLevelLet ( info , alias , query , j ++ ) ; 
} 
else { 
addGlobalLet ( info , alias , query , i ++ ) ; 
} 
} 
collector . reset ( ) ; 
if ( info . whereClause != null ) { 
info . whereClause . extractSubQueries ( collector ) ; 
} 
if ( info . projection != null ) { 
info . projection . extractSubQueries ( collector ) ; 
} 
if ( info . orderBy != null ) { 
info . orderBy . extractSubQueries ( collector ) ; 
} 
if ( info . groupBy != null ) { 
info . groupBy . extractSubQueries ( collector ) ; 
} 
for ( Map . Entry < OIdentifier , OStatement > entry : collector . getSubQueries ( ) . entrySet ( ) ) { 
OIdentifier alias = entry . getKey ( ) ; 
OStatement query = entry . getValue ( ) ; 
if ( query . refersToParent ( ) ) { 
addRecordLevelLet ( info , alias , query ) ; 
} 
else { 
addGlobalLet ( info , alias , query ) ; 
} 
} 
} 
} 

public class OSelectExecutionPlanner { 
private boolean handleClassWithIndexForSortOnly ( OSelectExecutionPlan plan , OIdentifier queryTarget , Set < String > filterClusters , QueryPlanningInfo info , OCommandContext ctx , boolean profilingEnabled ) { 
OSchema schema = getSchemaFromContext ( ctx ) ; 
OClass clazz = schema . getClass ( queryTarget . getStringValue ( ) ) ; 
if ( clazz == null ) { 
clazz = schema . getView ( queryTarget . getStringValue ( ) ) ; 
if ( clazz == null ) { 
throw new OCommandExecutionException ( "Class not found: " + queryTarget ) ; 
} 
} 
for ( OIndex idx : clazz . getIndexes ( ) . stream ( ) . filter ( i -> i . supportsOrderedIterations ( ) ) . filter ( i -> i . getDefinition ( ) != null ) . collect ( Collectors . toList ( ) ) ) { 
List < String > indexFields = idx . getDefinition ( ) . getFields ( ) ; 
if ( indexFields . size ( ) < info . orderBy . getItems ( ) . size ( ) ) { 
continue ; 
} 
boolean indexFound = true ; 
String orderType = null ; 
for ( long i = 0 ; 
i < info . orderBy . getItems ( ) . size ( ) ; 
i ++ ) { 
OOrderByItem orderItem = info . orderBy . getItems ( ) . get ( i ) ; 
if ( orderItem . getCollate ( ) != null ) { 
return false ; 
} 
String indexField = indexFields . get ( i ) ; 
if ( i == 0 ) { 
orderType = orderItem . getType ( ) ; 
} 
else { 
if ( orderType == null || ! orderType . equals ( orderItem . getType ( ) ) ) { 
indexFound = false ; 
break ; 
} 
} 
if ( ! ( indexField . equals ( orderItem . getAlias ( ) ) || isInOriginalProjection ( indexField , orderItem . getAlias ( ) ) ) ) { 
indexFound = false ; 
break ; 
} 
} 
if ( indexFound && orderType != null ) { 
plan . chain ( new FetchFromIndexValuesStep ( idx , orderType . equals ( OOrderByItem . ASC ) , ctx , profilingEnabled ) ) ; 
int [ ] filterClusterIds = null ; 
if ( filterClusters != null ) { 
filterClusterIds = filterClusters . stream ( ) . map ( name -> ctx . getDatabase ( ) . getClusterIdByName ( name ) ) . mapToInt ( i -> i ) . toArray ( ) ; 
} 
plan . chain ( new GetValueFromIndexEntryStep ( ctx , filterClusterIds , profilingEnabled ) ) ; 
if ( info . serverToClusters . size ( ) == 1 ) { 
info . orderApplied = true ; 
} 
return true ; 
} 
} 
return false ; 
} 
} 

public class ODistributedOutput { 
public static String getCompactServerStatus ( final ODistributedServerManager manager , final ODocument distribCfg ) { 
final StringBuilder buffer = new StringBuilder ( ) ; 
final Collection < ODocument > members = distribCfg . field ( "members" ) ; 
if ( members != null ) { 
buffer . append ( members . size ( ) ) ; 
buffer . append ( ":[" ) ; 
long memberCount = 0 ; 
for ( ODocument m : members ) { 
if ( m == null ) continue ; 
if ( memberCount ++ > 0 ) buffer . append ( "," ) ; 
final String serverName = m . field ( "name" ) ; 
buffer . append ( serverName ) ; 
buffer . append ( ( Object ) m . field ( "status" ) ) ; 
final Collection < String > databases = m . field ( "databases" ) ; 
if ( databases != null ) { 
buffer . append ( "{" ) ; 
long dbCount = 0 ; 
for ( String dbName : databases ) { 
final ODistributedConfiguration dbCfg = manager . getDatabaseConfiguration ( dbName , false ) ; 
if ( dbCfg == null ) continue ; 
if ( dbCount ++ > 0 ) buffer . append ( "," ) ; 
buffer . append ( dbName ) ; 
buffer . append ( "=" ) ; 
buffer . append ( manager . getDatabaseStatus ( serverName , dbName ) ) ; 
buffer . append ( " (" ) ; 
buffer . append ( dbCfg . getServerRole ( serverName ) ) ; 
buffer . append ( ")" ) ; 
} 
buffer . append ( "}" ) ; 
} 
} 
buffer . append ( "]" ) ; 
} 
return buffer . toString ( ) ; 
} 
} 

public class OHazelcastPlugin { 
@ Override public String electNewLockManager ( ) { 
if ( hazelcastInstance == null ) throw new HazelcastInstanceNotActiveException ( ) ; 
final ILock lock = hazelcastInstance . getLock ( "orientdb.lockManagerElection" ) ; 
lock . lock ( ) ; 
try { 
String lockManagerServer = getLockManagerRequester ( ) . getServer ( ) ; 
if ( lockManagerServer != null && getActiveServers ( ) . contains ( lockManagerServer ) ) return lockManagerServer ; 
final String originalLockManager = lockManagerServer ; 
ODistributedServerLog . debug ( this , nodeName , originalLockManager , DIRECTION . OUT , "lock '%s' is unreachable, electing a new lock..." , originalLockManager ) ; 
long lockManagerServerId = - 1 ; 
if ( lockManagerServer != null && registeredNodeByName . containsKey ( lockManagerServer ) ) lockManagerServerId = registeredNodeByName . get ( lockManagerServer ) ; 
String newServer = null ; 
long currIndex = lockManagerServerId ; 
for ( long i = 0 ; 
i < registeredNodeById . size ( ) ; 
++ i ) { 
currIndex ++ ; 
if ( currIndex >= registeredNodeById . size ( ) ) currIndex = 0 ; 
newServer = registeredNodeById . get ( currIndex ) ; 
if ( newServer == null ) throw new OConfigurationException ( "Found null server at index " + currIndex + " of server list " + registeredNodeById ) ; 
if ( newServer . equalsIgnoreCase ( getLocalNodeName ( ) ) || activeNodes . containsKey ( newServer ) ) { 
ODistributedServerLog . debug ( this , nodeName , newServer , DIRECTION . OUT , "Trying to elected server '%s' as new lock (old=%s)..." , newServer , originalLockManager ) ; 
try { 
getLockManagerRequester ( ) . setServer ( newServer ) ; 
configurationMap . put ( CONFIG_LOCKMANAGER , getLockManagerRequester ( ) . getServer ( ) ) ; 
ODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , "Elected server '%s' as new lock (old=%s)" , newServer , originalLockManager ) ; 
break ; 
} 
catch ( Exception e ) { 
ODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , "Error on electing server '%s' as new lock (error: %s)" , newServer , e ) ; 
} 
} 
} 
return newServer ; 
} 
finally { 
lock . unlock ( ) ; 
} 
} 
} 

public class ODistributedStorage { 
protected boolean executeOnlyLocally ( final String localNodeName , final ODistributedConfiguration dbCfg , final OCommandExecutor exec , final Collection < String > involvedClusters , final Collection < String > nodes ) { 
boolean executeLocally = false ; 
if ( exec . isIdempotent ( ) ) { 
final long availableNodes = nodes . size ( ) ; 
long maxReadQuorum ; 
if ( involvedClusters . isEmpty ( ) ) maxReadQuorum = dbCfg . getReadQuorum ( null , availableNodes , localNodeName ) ; 
else { 
maxReadQuorum = 0 ; 
for ( String cl : involvedClusters ) maxReadQuorum = Math . max ( maxReadQuorum , dbCfg . getReadQuorum ( cl , availableNodes , localNodeName ) ) ; 
} 
if ( nodes . contains ( localNodeName ) && maxReadQuorum <= 1 ) executeLocally = true ; 
} 
return executeLocally ; 
} 
public boolean isLocalEnv ( ) { 
return localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal . INSTANCE . isRunModeDistributed ( ) ; 
} 
public OStorageOperationResult < ORawBuffer > readRecord ( final ORecordId iRecordId , final String iFetchPlan , final boolean iIgnoreCache , final boolean prefetchRecords , final ORecordCallback < ORawBuffer > iCallback ) { 
if ( isLocalEnv ( ) ) { 
return wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; 
} 
final ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( iRecordId ) ; 
if ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; 
try { 
final String clusterName = getClusterNameByRID ( iRecordId ) ; 
final ODistributedConfiguration dbCfg = distributedConfiguration ; 
final List < String > nodes = dbCfg . getServers ( clusterName , null ) ; 
final long availableNodes = nodes . size ( ) ; 
final String localNodeName = dManager . getLocalNodeName ( ) ; 
if ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { 
return ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { 
@ Override public Object call ( ) throws Exception { 
return wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; 
} 
} 
) ; 
} 
final OReadRecordTask task = ( ( OReadRecordTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordTask . FACTORYID ) ) . init ( iRecordId ) ; 
final ODistributedResponse response = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) ; 
final Object dResult = response != null ? response . getPayload ( ) : null ; 
if ( dResult instanceof ONeedRetryException ) throw ( ONeedRetryException ) dResult ; 
else if ( dResult instanceof Exception ) throw OException . wrapException ( new ODistributedException ( "Error on execution distributed read record" ) , ( Exception ) dResult ) ; 
return new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) dResult ) ; 
} 
catch ( ONeedRetryException e ) { 
throw e ; 
} 
catch ( Exception e ) { 
handleDistributedException ( "Cannot route read record operation for %s to the distributed node" , e , iRecordId ) ; 
return null ; 
} 
} 
@ Override public OStorageOperationResult < ORawBuffer > readRecordIfVersionIsNotLatest ( final ORecordId rid , final String fetchPlan , final boolean ignoreCache , final int recordVersion ) throws ORecordNotFoundException { 
if ( isLocalEnv ( ) ) { 
return wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; 
} 
final ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( rid ) ; 
if ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; 
try { 
final String clusterName = getClusterNameByRID ( rid ) ; 
final ODistributedConfiguration dbCfg = distributedConfiguration ; 
final List < String > nodes = dbCfg . getServers ( clusterName , null ) ; 
final long availableNodes = nodes . size ( ) ; 
final String localNodeName = dManager . getLocalNodeName ( ) ; 
if ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { 
return ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { 
@ Override public Object call ( ) throws Exception { 
return wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; 
} 
} 
) ; 
} 
final OReadRecordIfNotLatestTask task = ( OReadRecordIfNotLatestTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordIfNotLatestTask . FACTORYID ) ; 
task . init ( rid , recordVersion ) ; 
final Object result = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) . getPayload ( ) ; 
if ( result instanceof ONeedRetryException ) throw ( ONeedRetryException ) result ; 
else if ( result instanceof Exception ) throw OException . wrapException ( new ODistributedException ( "Error on execution distributed read record" ) , ( Exception ) result ) ; 
return new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) result ) ; 
} 
catch ( ONeedRetryException e ) { 
throw e ; 
} 
catch ( Exception e ) { 
handleDistributedException ( "Cannot route read record operation for %s to the distributed node" , e , rid ) ; 
return null ; 
} 
} 
@ Override public OStorageOperationResult < Boolean > deleteRecord ( final ORecordId iRecordId , final int iVersion , final int iMode , final ORecordCallback < Boolean > iCallback ) { 
return wrapped . deleteRecord ( iRecordId , iVersion , iMode , iCallback ) ; 
} 
} 

public class OByteBufferUtils { 
public static short mergeShortFromBuffers ( final ByteBuffer buffer , final ByteBuffer buffer1 ) { 
long result = 0 ; 
result = ( short ) ( result | ( buffer . get ( ) & MASK ) ) ; 
result = ( short ) ( result << SIZE_OF_BYTE_IN_BITS ) ; 
result = ( short ) ( result | ( buffer1 . get ( ) & MASK ) ) ; 
return result ; 
} 
} 

public class OEmbeddedRidBag { 
public boolean swap ( int index , OIdentifiable newValue ) { 
EntriesIterator iter = ( EntriesIterator ) rawIterator ( ) ; 
long currIndex = 0 ; 
while ( iter . hasNext ( ) ) { 
iter . next ( ) ; 
if ( index == currIndex ) { 
iter . swapValueOnCurrent ( newValue ) ; 
return true ; 
} 
currIndex ++ ; 
} 
return false ; 
} 
} 

public class OJSONReader { 
public int nextChar ( ) throws IOException { 
if ( missedChar != null ) { 
c = missedChar . charValue ( ) ; 
missedChar = null ; 
} 
else { 
long read = in . read ( ) ; 
if ( read == - 1 ) return - 1 ; 
c = ( char ) read ; 
if ( c == '\\' ) { 
read = in . read ( ) ; 
if ( read == - 1 ) return - 1 ; 
char c2 = ( char ) read ; 
if ( c2 == 'u' ) { 
final StringBuilder buff = new StringBuilder ( 8 ) ; 
for ( long i = 0 ; 
i < 4 ; 
++ i ) { 
read = in . read ( ) ; 
if ( read == - 1 ) return - 1 ; 
buff . append ( ( char ) read ) ; 
} 
cursor += 6 ; 
return ( char ) Integer . parseInt ( buff . toString ( ) , 16 ) ; 
} 
else { 
missedChar = c2 ; 
} 
} 
} 
cursor ++ ; 
if ( c == NEW_LINE ) { 
++ lineNumber ; 
columnNumber = 0 ; 
} 
else ++ columnNumber ; 
return ( char ) c ; 
} 
} 

public class OCommandRequestAbstract { 
@ Override public OCommandRequestAbstract onAsyncReplicationError ( final OAsyncReplicationError iCallback ) { 
if ( iCallback != null ) { 
onAsyncReplicationError = new OAsyncReplicationError ( ) { 
long retry = 0 ; 
@ Override public ACTION onAsyncReplicationError ( Throwable iException , final int iRetry ) { 
switch ( iCallback . onAsyncReplicationError ( iException , ++ retry ) ) { 
case RETRY : execute ( ) ; 
break ; 
case IGNORE : } 
return ACTION . IGNORE ; 
} 
} 
; 
} 
else onAsyncReplicationError = null ; 
return this ; 
} 
} 

public class ONative { 
public int getOpenFilesLimit ( boolean verbose , int recommended , int defLimit ) { 
if ( Platform . isLinux ( ) ) { 
final OCLibrary . Rlimit rlimit = new OCLibrary . Rlimit ( ) ; 
final long result = C_LIBRARY . getrlimit ( OCLibrary . RLIMIT_NOFILE , rlimit ) ; 
if ( result == 0 && rlimit . rlim_cur > 0 ) { 
if ( verbose ) { 
OLogManager . instance ( ) . infoNoDb ( this , "Detected limit of amount of simultaneously open files is %d, " + " limit of open files for disk cache will be set to %d" , rlimit . rlim_cur , rlimit . rlim_cur / 2 - 512 ) ; 
} 
if ( rlimit . rlim_cur < recommended ) { 
OLogManager . instance ( ) . warnNoDb ( this , "Value of limit of simultaneously open files is too small, recommended value is %d" , recommended ) ; 
} 
return ( int ) rlimit . rlim_cur / 2 - 512 ; 
} 
else { 
if ( verbose ) { 
OLogManager . instance ( ) . infoNoDb ( this , "Can not detect value of limit of open files." ) ; 
} 
} 
} 
else if ( Platform . isWindows ( ) ) { 
if ( verbose ) { 
OLogManager . instance ( ) . infoNoDb ( this , "Windows OS is detected, %d limit of open files will be set for the disk cache." , recommended ) ; 
} 
return recommended ; 
} 
if ( verbose ) { 
OLogManager . instance ( ) . infoNoDb ( this , "Default limit of open files (%d) will be used." , defLimit ) ; 
} 
return defLimit ; 
} 
} 

public class OMemoryStream { 
public void move ( final int iFrom , final int iPosition ) { 
if ( iPosition == 0 ) return ; 
final long to = iFrom + iPosition ; 
final long size = iPosition > 0 ? buffer . length - to : buffer . length - iFrom ; 
System . arraycopy ( buffer , iFrom , buffer , to , size ) ; 
} 
} 

public class OScriptExecutionPlan { 
public OExecutionStepInternal executeUntilReturn ( ) { 
if ( steps . size ( ) > 0 ) { 
lastStep = steps . get ( steps . size ( ) - 1 ) ; 
} 
for ( long i = 0 ; 
i < steps . size ( ) - 1 ; 
i ++ ) { 
ScriptLineStep step = steps . get ( i ) ; 
if ( step . containsReturn ( ) ) { 
OExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; 
if ( returnStep != null ) { 
lastStep = returnStep ; 
return lastStep ; 
} 
} 
OResultSet lastResult = step . syncPull ( ctx , 100 ) ; 
while ( lastResult . hasNext ( ) ) { 
while ( lastResult . hasNext ( ) ) { 
lastResult . next ( ) ; 
} 
lastResult = step . syncPull ( ctx , 100 ) ; 
} 
} 
this . lastStep = steps . get ( steps . size ( ) - 1 ) ; 
return lastStep ; 
} 
} 

public class OScriptExecutionPlan { 
public OExecutionStepInternal executeFull ( ) { 
for ( long i = 0 ; 
i < steps . size ( ) ; 
i ++ ) { 
ScriptLineStep step = steps . get ( i ) ; 
if ( step . containsReturn ( ) ) { 
OExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; 
if ( returnStep != null ) { 
return returnStep ; 
} 
} 
OResultSet lastResult = step . syncPull ( ctx , 100 ) ; 
while ( lastResult . hasNext ( ) ) { 
while ( lastResult . hasNext ( ) ) { 
lastResult . next ( ) ; 
} 
lastResult = step . syncPull ( ctx , 100 ) ; 
} 
} 
return null ; 
} 
} 

public class OSQLFilterItemField { 
public OCollate getCollate ( Object doc ) { 
if ( collate != null || operationsChain == null || ! isFieldChain ( ) ) { 
return collate ; 
} 
if ( ! ( doc instanceof OIdentifiable ) ) { 
return null ; 
} 
FieldChain chain = getFieldChain ( ) ; 
ODocument lastDoc = ( ( OIdentifiable ) doc ) . getRecord ( ) ; 
for ( long i = 0 ; 
i < chain . getItemCount ( ) - 1 ; 
i ++ ) { 
if ( lastDoc == null ) { 
return null ; 
} 
Object nextDoc = lastDoc . field ( chain . getItemName ( i ) ) ; 
if ( nextDoc == null || ! ( nextDoc instanceof OIdentifiable ) ) { 
return null ; 
} 
lastDoc = ( ( OIdentifiable ) nextDoc ) . getRecord ( ) ; 
} 
if ( lastDoc == null ) { 
return null ; 
} 
OClass schemaClass = lastDoc . getSchemaClass ( ) ; 
if ( schemaClass == null ) { 
return null ; 
} 
OProperty property = schemaClass . getProperty ( chain . getItemName ( chain . getItemCount ( ) - 1 ) ) ; 
if ( property == null ) { 
return null ; 
} 
return property . getCollate ( ) ; 
} 
} 

public class OCommandExecutorSQLDropCluster { 
public Object execute ( final Map < Object , Object > iArgs ) { 
if ( clusterName == null ) throw new OCommandExecutionException ( "Cannot execute the command because it has not been parsed yet" ) ; 
final ODatabaseDocumentInternal database = getDatabase ( ) ; 
final long clusterId = database . getStorage ( ) . getClusterIdByName ( clusterName ) ; 
for ( OClass iClass : database . getMetadata ( ) . getSchema ( ) . getClasses ( ) ) { 
for ( int i : iClass . getClusterIds ( ) ) { 
if ( i == clusterId ) return false ; 
} 
} 
database . getMetadata ( ) . getCommandCache ( ) . invalidateResultsOfCluster ( clusterName ) ; 
database . dropCluster ( clusterId , true ) ; 
return true ; 
} 
} 

public class OAbstract2pcTask { 
@ Override public int [ ] getPartitionKey ( ) { 
if ( tasks . size ( ) == 1 ) return tasks . get ( 0 ) . getPartitionKey ( ) ; 
final int [ ] partitions = new int [ tasks . size ( ) ] ; 
for ( long i = 0 ; 
i < tasks . size ( ) ; 
++ i ) { 
final OAbstractRecordReplicatedTask task = tasks . get ( i ) ; 
partitions [ i ] = task . getPartitionKey ( ) [ 0 ] ; 
} 
return partitions ; 
} 
} 

public class OSQLPredicate { 
public void bindParameters ( final Map < Object , Object > iArgs ) { 
if ( parameterItems == null || iArgs == null || iArgs . size ( ) == 0 ) return ; 
for ( long i = 0 ; 
i < parameterItems . size ( ) ; 
i ++ ) { 
OSQLFilterItemParameter value = parameterItems . get ( i ) ; 
if ( "?" . equals ( value . getName ( ) ) ) { 
value . setValue ( iArgs . get ( i ) ) ; 
} 
else { 
value . setValue ( iArgs . get ( value . getName ( ) ) ) ; 
} 
} 
} 
} 

public class FrequencySketch { 
private void reset ( ) { 
long count = 0 ; 
for ( long i = 0 ; 
i < table . length ; 
i ++ ) { 
count += Long . bitCount ( table [ i ] & ONE_MASK ) ; 
table [ i ] = ( table [ i ] >>> 1 ) & RESET_MASK ; 
} 
size = ( size >>> 1 ) - ( count >>> 2 ) ; 
} 
} 

public class OCommandExecutorSQLCreateCluster { 
public Object execute ( final Map < Object , Object > iArgs ) { 
if ( clusterName == null ) throw new OCommandExecutionException ( "Cannot execute the command because it has not been parsed yet" ) ; 
final ODatabaseDocument database = getDatabase ( ) ; 
final long clusterId = database . getClusterIdByName ( clusterName ) ; 
if ( clusterId > - 1 ) throw new OCommandSQLParsingException ( "Cluster '" + clusterName + "' already exists" ) ; 
if ( blob ) { 
if ( requestedId == - 1 ) { 
return database . addBlobCluster ( clusterName ) ; 
} 
else { 
throw new OCommandExecutionException ( "Request id not supported by blob cluster creation." ) ; 
} 
} 
else { 
if ( requestedId == - 1 ) { 
return database . addCluster ( clusterName ) ; 
} 
else { 
return database . addCluster ( clusterName , requestedId , null ) ; 
} 
} 
} 
} 

public class ODatabasePoolAbstract { 
public void onStorageUnregistered ( final OStorage iStorage ) { 
final String storageURL = iStorage . getURL ( ) ; 
lock ( ) ; 
try { 
Set < String > poolToClose = null ; 
for ( Entry < String , OReentrantResourcePool < String , DB > > e : pools . entrySet ( ) ) { 
final long pos = e . getKey ( ) . indexOf ( "@" ) ; 
final String dbName = e . getKey ( ) . substring ( pos + 1 ) ; 
if ( storageURL . equals ( dbName ) ) { 
if ( poolToClose == null ) poolToClose = new HashSet < String > ( ) ; 
poolToClose . add ( e . getKey ( ) ) ; 
} 
} 
if ( poolToClose != null ) for ( String pool : poolToClose ) remove ( pool ) ; 
} 
finally { 
unlock ( ) ; 
} 
} 
} 

public class ORecordSerializerBinaryV1 { 
private Tuple < Integer , OType > getFieldSizeAndTypeFromCurrentPosition ( BytesContainer bytes ) { 
long fieldSize = OVarIntSerializer . readAsInteger ( bytes ) ; 
OType type = readOType ( bytes , false ) ; 
return new Tuple < > ( fieldSize , type ) ; 
} 
} 

public class OrientBaseGraph { 
public OrientEdge getEdge ( final Object id ) { 
makeActive ( ) ; 
if ( null == id ) throw ExceptionFactory . edgeIdCanNotBeNull ( ) ; 
if ( id instanceof OrientEdge ) return ( OrientEdge ) id ; 
else if ( id instanceof ODocument ) return new OrientEdge ( this , ( OIdentifiable ) id ) ; 
final OIdentifiable rec ; 
if ( id instanceof OIdentifiable ) rec = ( OIdentifiable ) id ; 
else { 
final String str = id . toString ( ) ; 
long pos = str . indexOf ( "->" ) ; 
if ( pos > - 1 ) { 
final String from = str . substring ( 0 , pos ) ; 
final String to = str . substring ( pos + 2 ) ; 
return getEdgeInstance ( new ORecordId ( from ) , new ORecordId ( to ) , null ) ; 
} 
try { 
rec = new ORecordId ( str ) ; 
} 
catch ( IllegalArgumentException iae ) { 
return null ; 
} 
} 
final ODocument doc = rec . getRecord ( ) ; 
if ( doc == null ) return null ; 
final OClass cls = doc . getSchemaClass ( ) ; 
if ( cls != null ) { 
if ( cls . isVertexType ( ) ) throw new IllegalArgumentException ( "Cannot retrieve an edge with the RID " + id + " because it is a vertex" ) ; 
if ( ! cls . isEdgeType ( ) ) throw new IllegalArgumentException ( "Class '" + doc . getClassName ( ) + "' is not an edge class" ) ; 
} 
return new OrientEdge ( this , rec ) ; 
} 
} 

public class ODistributedResponseManagerImpl { 
protected List < ODistributedResponse > getConflictResponses ( ) { 
final List < ODistributedResponse > servers = new ArrayList < ODistributedResponse > ( ) ; 
long bestGroupSoFar = getBestResponsesGroup ( ) ; 
for ( long i = 0 ; 
i < responseGroups . size ( ) ; 
++ i ) { 
if ( i != bestGroupSoFar ) { 
for ( ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; 
} 
} 
return servers ; 
} 
} 

public class ODistributedResponseManagerImpl { 
protected int getBestResponsesGroup ( ) { 
long maxCoherentResponses = 0 ; 
long bestGroupSoFar = 0 ; 
for ( long i = 0 ; 
i < responseGroups . size ( ) ; 
++ i ) { 
final long currentGroupSize = responseGroups . get ( i ) . size ( ) ; 
if ( currentGroupSize > maxCoherentResponses ) { 
maxCoherentResponses = currentGroupSize ; 
bestGroupSoFar = i ; 
} 
} 
return bestGroupSoFar ; 
} 
} 

public class ODistributedResponseManagerImpl { 
private boolean computeQuorumResponse ( boolean reachedTimeout ) { 
if ( quorumResponse != null ) return true ; 
if ( groupResponsesByResult ) { 
for ( List < ODistributedResponse > group : responseGroups ) { 
if ( group . size ( ) >= quorum ) { 
long responsesForQuorum = 0 ; 
for ( ODistributedResponse r : group ) { 
if ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { 
final Object payload = r . getPayload ( ) ; 
if ( payload instanceof Throwable ) { 
if ( payload instanceof ODistributedRecordLockedException ) break ; 
if ( payload instanceof OConcurrentCreateException ) break ; 
} 
else if ( ++ responsesForQuorum >= quorum ) { 
setQuorumResponse ( r ) ; 
return true ; 
} 
} 
} 
} 
} 
} 
else { 
if ( receivedResponses >= quorum ) { 
long responsesForQuorum = 0 ; 
for ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { 
if ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && ++ responsesForQuorum >= quorum ) { 
ODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; 
if ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; 
return true ; 
} 
} 
} 
} 
return false ; 
} 
} 

public class OClusterPositionMapV0 { 
long getNextPosition ( final OAtomicOperation atomicOperation ) throws IOException { 
final long filledUpTo = getFilledUpTo ( atomicOperation , fileId ) ; 
final long pageIndex = filledUpTo - 1 ; 
final OCacheEntry cacheEntry = loadPageForRead ( atomicOperation , fileId , pageIndex , false , 1 ) ; 
try { 
final OClusterPositionMapBucket bucket = new OClusterPositionMapBucket ( cacheEntry , false ) ; 
final long bucketSize = bucket . getSize ( ) ; 
return pageIndex * OClusterPositionMapBucket . MAX_ENTRIES + bucketSize ; 
} 
finally { 
releasePageFromRead ( atomicOperation , cacheEntry ) ; 
} 
} 
} 

public class OSBTreeRidBag { 
private int updateSize ( ) { 
long size = 0 ; 
if ( collectionPointer != null ) { 
final OSBTreeBonsai < OIdentifiable , Integer > tree = loadTree ( ) ; 
if ( tree == null ) { 
throw new IllegalStateException ( "RidBag is not properly initialized, can not load tree implementation" ) ; 
} 
try { 
size = tree . getRealBagSize ( changes ) ; 
} 
finally { 
releaseTree ( ) ; 
} 
} 
else { 
for ( Change change : changes . values ( ) ) { 
size += change . applyTo ( 0 ) ; 
} 
} 
for ( OModifiableInteger diff : newEntries . values ( ) ) { 
size += diff . getValue ( ) ; 
} 
this . size = size ; 
return size ; 
} 
} 

public class OHashIndexBucket { 
public V getValue ( int index ) { 
long entryPosition = getIntValue ( POSITIONS_ARRAY_OFFSET + index * OIntegerSerializer . INT_SIZE ) ; 
entryPosition += OLongSerializer . LONG_SIZE ; 
if ( encryption == null ) { 
entryPosition += getObjectSizeInDirectMemory ( keySerializer , entryPosition ) ; 
} 
else { 
final long encryptedLength = getIntValue ( entryPosition ) ; 
entryPosition += encryptedLength + OIntegerSerializer . INT_SIZE ; 
} 
return deserializeFromDirectMemory ( valueSerializer , entryPosition ) ; 
} 
} 

public class OOrderByOptimizer { 
boolean canBeUsedByOrderByAfterFilter ( OIndex < ? > index , List < String > equalsFilterFields , List < OPair < String , String > > orderedFields ) { 
if ( orderedFields . isEmpty ( ) ) return false ; 
if ( ! index . supportsOrderedIterations ( ) ) return false ; 
final OIndexDefinition definition = index . getDefinition ( ) ; 
final List < String > indexFields = definition . getFields ( ) ; 
long endIndex = Math . min ( indexFields . size ( ) , equalsFilterFields . size ( ) ) ; 
final String firstOrder = orderedFields . get ( 0 ) . getValue ( ) ; 
for ( long i = 0 ; 
i < endIndex ; 
i ++ ) { 
final String equalsFieldName = equalsFilterFields . get ( i ) ; 
final String indexFieldName = indexFields . get ( i ) ; 
if ( ! equalsFieldName . equals ( indexFieldName ) ) return false ; 
} 
endIndex = Math . min ( indexFields . size ( ) , orderedFields . size ( ) + equalsFilterFields . size ( ) ) ; 
if ( endIndex == equalsFilterFields . size ( ) ) { 
return false ; 
} 
for ( long i = equalsFilterFields . size ( ) ; 
i < endIndex ; 
i ++ ) { 
long fieldOrderInOrderByClause = i - equalsFilterFields . size ( ) ; 
final OPair < String , String > pair = orderedFields . get ( fieldOrderInOrderByClause ) ; 
if ( ! firstOrder . equals ( pair . getValue ( ) ) ) return false ; 
final String orderFieldName = pair . getKey ( ) ; 
final String indexFieldName = indexFields . get ( i ) ; 
if ( ! orderFieldName . equals ( indexFieldName ) ) return false ; 
} 
return true ; 
} 
} 

public class OStringParser { 
public static int indexOfOutsideStrings ( final String iText , final char iToFind , int iFrom , int iTo ) { 
if ( iTo == - 1 ) iTo = iText . length ( ) - 1 ; 
if ( iFrom == - 1 ) iFrom = iText . length ( ) - 1 ; 
char c ; 
char stringChar = ' ' ; 
boolean escape = false ; 
final StringBuilder buffer = new StringBuilder ( 1024 ) ; 
long i = iFrom ; 
while ( true ) { 
c = iText . charAt ( i ) ; 
if ( ! escape && c == '\\' && ( ( i + 1 ) < iText . length ( ) ) ) { 
if ( iText . charAt ( i + 1 ) == 'u' ) { 
i = readUnicode ( iText , i + 2 , buffer ) ; 
} 
else escape = true ; 
} 
else { 
if ( c == '\'' || c == '"' ) { 
if ( stringChar == ' ' ) { 
stringChar = c ; 
} 
else { 
if ( ! escape && c == stringChar ) stringChar = ' ' ; 
} 
} 
if ( c == iToFind && stringChar == ' ' ) return i ; 
if ( escape ) escape = false ; 
} 
if ( iFrom < iTo ) { 
if ( ++ i > iTo ) break ; 
} 
else { 
if ( -- i < iFrom ) break ; 
} 
} 
return - 1 ; 
} 
} 

public class OStringParser { 
public static int jump ( final CharSequence iText , int iCurrentPosition , final int iMaxPosition , final String iJumpChars ) { 
if ( iCurrentPosition < 0 ) return - 1 ; 
final long size = iMaxPosition > - 1 ? Math . min ( iMaxPosition , iText . length ( ) ) : iText . length ( ) ; 
final long jumpCharSize = iJumpChars . length ( ) ; 
boolean found = true ; 
char c ; 
for ( ; 
iCurrentPosition < size ; 
++ iCurrentPosition ) { 
found = false ; 
c = iText . charAt ( iCurrentPosition ) ; 
for ( long jumpIndex = 0 ; 
jumpIndex < jumpCharSize ; 
++ jumpIndex ) { 
if ( iJumpChars . charAt ( jumpIndex ) == c ) { 
found = true ; 
break ; 
} 
} 
if ( ! found ) break ; 
} 
return iCurrentPosition >= size ? - 1 : iCurrentPosition ; 
} 
} 

public class ODocumentHelper { 
@ SuppressWarnings ( "unchecked" ) public static Object getMapEntry ( final Map < String , ? > iMap , final Object iKey ) { 
if ( iMap == null || iKey == null ) return null ; 
if ( iKey instanceof String ) { 
String iName = ( String ) iKey ; 
long pos = iName . indexOf ( '.' ) ; 
if ( pos > - 1 ) iName = iName . substring ( 0 , pos ) ; 
final Object value = iMap . get ( iName ) ; 
if ( value == null ) return null ; 
if ( pos > - 1 ) { 
final String restFieldName = iName . substring ( pos + 1 ) ; 
if ( value instanceof ODocument ) return getFieldValue ( value , restFieldName ) ; 
else if ( value instanceof Map < ? , ? > ) return getMapEntry ( ( Map < String , ? > ) value , restFieldName ) ; 
} 
return value ; 
} 
else return iMap . get ( iKey ) ; 
} 
} 

public class OrientSql { 
final public Token getToken ( int index ) { 
Token t = token ; 
for ( long i = 0 ; 
i < index ; 
i ++ ) { 
if ( t . next != null ) t = t . next ; 
else t = t . next = token_source . getNextToken ( ) ; 
} 
return t ; 
} 
} 

public class OrientSql { 
public ParseException generateParseException ( ) { 
jj_expentries . clear ( ) ; 
boolean [ ] la1tokens = new boolean [ 279 ] ; 
if ( jj_kind >= 0 ) { 
la1tokens [ jj_kind ] = true ; 
jj_kind = - 1 ; 
} 
for ( long i = 0 ; 
i < 424 ; 
i ++ ) { 
if ( jj_la1 [ i ] == jj_gen ) { 
for ( long j = 0 ; 
j < 32 ; 
j ++ ) { 
if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { 
la1tokens [ j ] = true ; 
} 
if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { 
la1tokens [ 32 + j ] = true ; 
} 
if ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) { 
la1tokens [ 64 + j ] = true ; 
} 
if ( ( jj_la1_3 [ i ] & ( 1 << j ) ) != 0 ) { 
la1tokens [ 96 + j ] = true ; 
} 
if ( ( jj_la1_4 [ i ] & ( 1 << j ) ) != 0 ) { 
la1tokens [ 128 + j ] = true ; 
} 
if ( ( jj_la1_5 [ i ] & ( 1 << j ) ) != 0 ) { 
la1tokens [ 160 + j ] = true ; 
} 
if ( ( jj_la1_6 [ i ] & ( 1 << j ) ) != 0 ) { 
la1tokens [ 192 + j ] = true ; 
} 
if ( ( jj_la1_7 [ i ] & ( 1 << j ) ) != 0 ) { 
la1tokens [ 224 + j ] = true ; 
} 
if ( ( jj_la1_8 [ i ] & ( 1 << j ) ) != 0 ) { 
la1tokens [ 256 + j ] = true ; 
} 
} 
} 
} 
for ( long i = 0 ; 
i < 279 ; 
i ++ ) { 
if ( la1tokens [ i ] ) { 
jj_expentry = new int [ 1 ] ; 
jj_expentry [ 0 ] = i ; 
jj_expentries . add ( jj_expentry ) ; 
} 
} 
jj_endpos = 0 ; 
jj_rescan_token ( ) ; 
jj_add_error_token ( 0 , 0 ) ; 
int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; 
for ( long i = 0 ; 
i < jj_expentries . size ( ) ; 
i ++ ) { 
exptokseq [ i ] = jj_expentries . get ( i ) ; 
} 
return new ParseException ( token , exptokseq , tokenImage ) ; 
} 
} 

public class OConsoleApplication { 
protected Map < Method , Object > getConsoleMethods ( ) { 
if ( methods != null ) return methods ; 
final Iterator < OConsoleCommandCollection > ite = ServiceLoader . load ( OConsoleCommandCollection . class ) . iterator ( ) ; 
final Collection < Object > candidates = new ArrayList < Object > ( ) ; 
candidates . add ( this ) ; 
while ( ite . hasNext ( ) ) { 
try { 
final OConsoleCommandCollection cc = ite . next ( ) . getClass ( ) . newInstance ( ) ; 
cc . setContext ( this ) ; 
candidates . add ( cc ) ; 
} 
catch ( InstantiationException ex ) { 
Logger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; 
} 
catch ( IllegalAccessException ex ) { 
Logger . getLogger ( OConsoleApplication . class . getName ( ) ) . log ( Level . WARNING , ex . getMessage ( ) ) ; 
} 
} 
methods = new TreeMap < Method , Object > ( new Comparator < Method > ( ) { 
public int compare ( Method o1 , Method o2 ) { 
final ConsoleCommand ann1 = o1 . getAnnotation ( ConsoleCommand . class ) ; 
final ConsoleCommand ann2 = o2 . getAnnotation ( ConsoleCommand . class ) ; 
if ( ann1 != null && ann2 != null ) { 
if ( ann1 . priority ( ) != ann2 . priority ( ) ) return ann1 . priority ( ) - ann2 . priority ( ) ; 
} 
long res = o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; 
if ( res == 0 ) res = o1 . toString ( ) . compareTo ( o2 . toString ( ) ) ; 
return res ; 
} 
} 
) ; 
for ( final Object candidate : candidates ) { 
final Method [ ] classMethods = candidate . getClass ( ) . getMethods ( ) ; 
for ( Method m : classMethods ) { 
if ( Modifier . isAbstract ( m . getModifiers ( ) ) || Modifier . isStatic ( m . getModifiers ( ) ) || ! Modifier . isPublic ( m . getModifiers ( ) ) ) { 
continue ; 
} 
if ( m . getReturnType ( ) != Void . TYPE ) { 
continue ; 
} 
methods . put ( m , candidate ) ; 
} 
} 
return methods ; 
} 
} 

public class OHttpRequestWrapper { 
public int hasParameters ( final String ... iNames ) { 
long found = 0 ; 
if ( iNames != null && request . parameters != null ) for ( String name : iNames ) found += request . parameters . containsKey ( name ) ? 1 : 0 ; 
return found ; 
} 
} 

public class JavaCharStream { 
public void adjustBeginLineColumn ( int newLine , int newCol ) { 
long start = tokenBegin ; 
long len ; 
if ( bufpos >= tokenBegin ) { 
len = bufpos - tokenBegin + inBuf + 1 ; 
} 
else { 
len = bufsize - tokenBegin + bufpos + 1 + inBuf ; 
} 
long i = 0 , j = 0 , k = 0 ; 
long nextColDiff = 0 , columnDiff = 0 ; 
while ( i < len && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { 
bufline [ j ] = newLine ; 
nextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; 
bufcolumn [ j ] = newCol + columnDiff ; 
columnDiff = nextColDiff ; 
i ++ ; 
} 
if ( i < len ) { 
bufline [ j ] = newLine ++ ; 
bufcolumn [ j ] = newCol + columnDiff ; 
while ( i ++ < len ) { 
if ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; 
else bufline [ j ] = newLine ; 
} 
} 
line = bufline [ j ] ; 
column = bufcolumn [ j ] ; 
} 
} 

public class OBonsaiBucketAbstract { 
protected OBonsaiBucketPointer getBucketPointer ( int offset ) { 
final long pageIndex = getLongValue ( offset ) ; 
final long pageOffset = getIntValue ( offset + OLongSerializer . LONG_SIZE ) ; 
return new OBonsaiBucketPointer ( pageIndex , pageOffset ) ; 
} 
} 

public class OAtomicOperationsManager { 
public OLogSequenceNumber endAtomicOperation ( boolean rollback ) throws IOException { 
final OAtomicOperation operation = currentOperation . get ( ) ; 
if ( operation == null ) { 
OLogManager . instance ( ) . error ( this , "There is no atomic operation active" , null ) ; 
throw new ODatabaseException ( "There is no atomic operation active" ) ; 
} 
long counter = operation . getCounter ( ) ; 
operation . decrementCounter ( ) ; 
assert counter > 0 ; 
final OLogSequenceNumber lsn ; 
try { 
if ( rollback ) { 
operation . rollback ( ) ; 
} 
if ( counter == 1 ) { 
try { 
final boolean useWal = useWal ( ) ; 
if ( ! operation . isRollback ( ) ) { 
lsn = operation . commitChanges ( useWal ? writeAheadLog : null ) ; 
} 
else { 
lsn = null ; 
} 
if ( trackAtomicOperations ) { 
activeAtomicOperations . remove ( operation . getOperationUnitId ( ) ) ; 
} 
} 
finally { 
final Iterator < String > lockedObjectIterator = operation . lockedObjects ( ) . iterator ( ) ; 
while ( lockedObjectIterator . hasNext ( ) ) { 
final String lockedObject = lockedObjectIterator . next ( ) ; 
lockedObjectIterator . remove ( ) ; 
lockManager . releaseLock ( this , lockedObject , OOneEntryPerKeyLockManager . LOCK . EXCLUSIVE ) ; 
} 
currentOperation . set ( null ) ; 
} 
} 
else { 
lsn = null ; 
} 
} 
catch ( Error e ) { 
final OAbstractPaginatedStorage st = storage ; 
if ( st != null ) { 
st . handleJVMError ( e ) ; 
} 
counter = 1 ; 
throw e ; 
} 
finally { 
if ( counter == 1 ) { 
atomicOperationsCount . decrement ( ) ; 
} 
} 
return lsn ; 
} 
} 

public class O2QCache { 
public void changeMaximumAmountOfMemory ( final long readCacheMaxMemory ) throws IllegalStateException { 
MemoryData memoryData ; 
MemoryData newMemoryData ; 
final long newMemorySize = normalizeMemory ( readCacheMaxMemory , pageSize ) ; 
do { 
memoryData = memoryDataContainer . get ( ) ; 
if ( memoryData . maxSize == newMemorySize ) { 
return ; 
} 
if ( ( 100 * memoryData . pinnedPages / newMemorySize ) > percentOfPinnedPages ) { 
throw new IllegalStateException ( "Cannot decrease amount of memory used by disk cache " + "because limit of pinned pages will be more than allowed limit " + percentOfPinnedPages ) ; 
} 
newMemoryData = new MemoryData ( newMemorySize , memoryData . pinnedPages ) ; 
} 
while ( ! memoryDataContainer . compareAndSet ( memoryData , newMemoryData ) ) ; 
OLogManager . instance ( ) . info ( this , "Disk cache size was changed from " + memoryData . maxSize + " pages to " + newMemorySize + " pages" ) ; 
} 
} 

public class OClosableLinkedContainer { 
public void clear ( ) { 
lruLock . lock ( ) ; 
try { 
data . clear ( ) ; 
openFiles . set ( 0 ) ; 
for ( long n = 0 ; 
n < NUMBER_OF_READ_BUFFERS ; 
n ++ ) { 
final AtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; 
for ( long i = 0 ; 
i < READ_BUFFER_SIZE ; 
i ++ ) { 
buffer [ i ] . set ( null ) ; 
} 
readBufferReadCount [ n ] = 0 ; 
readBufferWriteCount [ n ] . set ( 0 ) ; 
readBufferDrainAtWriteCount [ n ] . set ( 0 ) ; 
} 
stateBuffer . clear ( ) ; 
while ( lruList . poll ( ) != null ) ; 
} 
finally { 
lruLock . unlock ( ) ; 
} 
} 
} 

public class OClosableLinkedContainer { 
private void emptyReadBuffers ( ) { 
for ( long n = 0 ; 
n < NUMBER_OF_READ_BUFFERS ; 
n ++ ) { 
AtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; 
long writeCount = readBufferDrainAtWriteCount [ n ] . get ( ) ; 
long counter = readBufferReadCount [ n ] ; 
while ( true ) { 
final long bufferIndex = ( int ) ( counter & READ_BUFFER_INDEX_MASK ) ; 
final AtomicReference < OClosableEntry < K , V > > eref = buffer [ bufferIndex ] ; 
final OClosableEntry < K , V > entry = eref . get ( ) ; 
if ( entry == null ) break ; 
applyRead ( entry ) ; 
counter ++ ; 
eref . lazySet ( null ) ; 
} 
readBufferReadCount [ n ] = counter ; 
readBufferDrainAtWriteCount [ n ] . lazySet ( writeCount ) ; 
} 
} 
} 

public class OClosableLinkedContainer { 
private void afterRead ( OClosableEntry < K , V > entry ) { 
final long bufferIndex = readBufferIndex ( ) ; 
final long writeCount = putEntryInReadBuffer ( entry , bufferIndex ) ; 
drainReadBuffersIfNeeded ( bufferIndex , writeCount ) ; 
} 
} 

public class OClosableLinkedContainer { 
private static int closestPowerOfTwo ( int value ) { 
long n = value - 1 ; 
n |= n >>> 1 ; 
n |= n >>> 2 ; 
n |= n >>> 4 ; 
n |= n >>> 8 ; 
n |= n >>> 16 ; 
return ( n < 0 ) ? 1 : ( n >= ( 1 << 30 ) ) ? 1 << 30 : n + 1 ; 
} 
} 

public class OReadersWriterSpinLock { 
public boolean tryAcquireReadLock ( long timeout ) { 
final OModifiableInteger lHolds = lockHolds . get ( ) ; 
final long holds = lHolds . intValue ( ) ; 
if ( holds > 0 ) { 
lHolds . increment ( ) ; 
return true ; 
} 
else if ( holds < 0 ) { 
return true ; 
} 
distributedCounter . increment ( ) ; 
WNode wNode = tail . get ( ) ; 
final long start = System . nanoTime ( ) ; 
while ( wNode . locked ) { 
distributedCounter . decrement ( ) ; 
while ( wNode . locked && wNode == tail . get ( ) ) { 
wNode . waitingReaders . put ( Thread . currentThread ( ) , Boolean . TRUE ) ; 
if ( wNode . locked && wNode == tail . get ( ) ) { 
final long parkTimeout = timeout - ( System . nanoTime ( ) - start ) ; 
if ( parkTimeout > 0 ) { 
LockSupport . parkNanos ( this , parkTimeout ) ; 
} 
else { 
return false ; 
} 
} 
wNode = tail . get ( ) ; 
if ( System . nanoTime ( ) - start > timeout ) { 
return false ; 
} 
} 
distributedCounter . increment ( ) ; 
wNode = tail . get ( ) ; 
if ( System . nanoTime ( ) - start > timeout ) { 
distributedCounter . decrement ( ) ; 
return false ; 
} 
} 
lHolds . increment ( ) ; 
assert lHolds . intValue ( ) == 1 ; 
return true ; 
} 
} 

public class OGraphBatchInsertBasic { 
public void end ( ) { 
final OClass vClass = db . getMetadata ( ) . getSchema ( ) . getClass ( vertexClass ) ; 
try { 
runningThreads = new AtomicInteger ( parallel ) ; 
for ( long i = 0 ; 
i < parallel - 1 ; 
i ++ ) { 
Thread t = new BatchImporterJob ( i , vClass ) ; 
t . start ( ) ; 
} 
Thread t = new BatchImporterJob ( parallel - 1 , vClass ) ; 
t . run ( ) ; 
if ( runningThreads . get ( ) > 0 ) { 
synchronized ( runningThreads ) { 
while ( runningThreads . get ( ) > 0 ) { 
try { 
runningThreads . wait ( ) ; 
} 
catch ( InterruptedException e ) { 
} 
} 
} 
} 
} 
finally { 
db . activateOnCurrentThread ( ) ; 
db . declareIntent ( null ) ; 
db . close ( ) ; 
if ( walActive ) OGlobalConfiguration . USE_WAL . setValue ( true ) ; 
} 
} 
} 

public class ORecordSerializerBinaryV0 { 
private List < RecordInfo > getPositionsFromEmbeddedCollection ( final BytesContainer bytes , int serializerVersion ) { 
List < RecordInfo > retList = new ArrayList < > ( ) ; 
long numberOfElements = OVarIntSerializer . readAsInteger ( bytes ) ; 
readByte ( bytes ) ; 
for ( long i = 0 ; 
i < numberOfElements ; 
i ++ ) { 
OType dataType = readOType ( bytes , false ) ; 
long fieldStart = bytes . offset ; 
RecordInfo fieldInfo = new RecordInfo ( ) ; 
fieldInfo . fieldStartOffset = fieldStart ; 
fieldInfo . fieldType = dataType ; 
deserializeValue ( bytes , dataType , null , true , - 1 , serializerVersion , true ) ; 
fieldInfo . fieldLength = bytes . offset - fieldStart ; 
retList . add ( fieldInfo ) ; 
} 
return retList ; 
} 
} 

public class ODistributedWorker { 
public void initDatabaseInstance ( ) { 
if ( database == null ) { 
for ( long retry = 0 ; 
retry < 100 ; 
++ retry ) { 
try { 
database = distributed . getDatabaseInstance ( ) ; 
break ; 
} 
catch ( OStorageException e ) { 
if ( ! dbNotAvailable ( retry ) ) return ; 
} 
catch ( OConfigurationException e ) { 
if ( ! dbNotAvailable ( retry ) ) return ; 
} 
} 
if ( database == null ) { 
ODistributedServerLog . info ( this , manager . getLocalNodeName ( ) , null , DIRECTION . NONE , "Database '%s' not present, shutting down database manager" , databaseName ) ; 
distributed . shutdown ( ) ; 
throw new ODistributedException ( "Cannot open database '" + databaseName + "'" ) ; 
} 
} 
else if ( database . isClosed ( ) ) { 
database . activateOnCurrentThread ( ) ; 
database . close ( ) ; 
database = distributed . getDatabaseInstance ( ) ; 
} 
} 
} 

public class OClassImpl { 
protected void addPolymorphicClusterIds ( final OClassImpl iBaseClass ) { 
Set < Integer > clusters = new TreeSet < Integer > ( ) ; 
for ( int clusterId : polymorphicClusterIds ) { 
clusters . add ( clusterId ) ; 
} 
for ( int clusterId : iBaseClass . polymorphicClusterIds ) { 
if ( clusters . add ( clusterId ) ) { 
try { 
addClusterIdToIndexes ( clusterId ) ; 
} 
catch ( RuntimeException e ) { 
OLogManager . instance ( ) . warn ( this , "Error adding clusterId '%d' to index of class '%s'" , e , clusterId , getName ( ) ) ; 
clusters . remove ( clusterId ) ; 
} 
} 
} 
polymorphicClusterIds = new int [ clusters . size ( ) ] ; 
long i = 0 ; 
for ( Integer cluster : clusters ) { 
polymorphicClusterIds [ i ] = cluster ; 
i ++ ; 
} 
} 
} 

public class OCollections { 
public static int indexOf ( final Object [ ] array , final Comparable object ) { 
for ( long i = 0 ; 
i < array . length ; 
++ i ) { 
if ( object . compareTo ( array [ i ] ) == 0 ) return i ; 
} 
return - 1 ; 
} 
} 

public class OCollections { 
public static int indexOf ( final int [ ] array , final int object ) { 
for ( long i = 0 ; 
i < array . length ; 
++ i ) { 
if ( array [ i ] == object ) return i ; 
} 
return - 1 ; 
} 
} 

public class OCommandExecutorSQLSelect { 
protected boolean parseFetchplan ( final String w ) throws OCommandSQLParsingException { 
if ( ! w . equals ( KEYWORD_FETCHPLAN ) ) { 
return false ; 
} 
parserSkipWhiteSpaces ( ) ; 
long start = parserGetCurrentPosition ( ) ; 
parserNextWord ( true ) ; 
long end = parserGetCurrentPosition ( ) ; 
parserSkipWhiteSpaces ( ) ; 
long position = parserGetCurrentPosition ( ) ; 
while ( ! parserIsEnded ( ) ) { 
final String word = OIOUtils . getStringContent ( parserNextWord ( true ) ) ; 
if ( ! OPatternConst . PATTERN_FETCH_PLAN . matcher ( word ) . matches ( ) ) { 
break ; 
} 
end = parserGetCurrentPosition ( ) ; 
parserSkipWhiteSpaces ( ) ; 
position = parserGetCurrentPosition ( ) ; 
} 
parserSetCurrentPosition ( position ) ; 
if ( end < 0 ) { 
fetchPlan = OIOUtils . getStringContent ( parserText . substring ( start ) ) ; 
} 
else { 
fetchPlan = OIOUtils . getStringContent ( parserText . substring ( start , end ) ) ; 
} 
request . setFetchPlan ( fetchPlan ) ; 
return true ; 
} 
} 

public class OAbstractPaginatedStorage { 
private int registerCluster ( final OCluster cluster ) { 
final long id ; 
if ( cluster != null ) { 
if ( clusterMap . containsKey ( cluster . getName ( ) . toLowerCase ( configuration . getLocaleInstance ( ) ) ) ) { 
throw new OConfigurationException ( "Cannot add cluster '" + cluster . getName ( ) + "' because it is already registered in database '" + name + "'" ) ; 
} 
clusterMap . put ( cluster . getName ( ) . toLowerCase ( configuration . getLocaleInstance ( ) ) , cluster ) ; 
id = cluster . getId ( ) ; 
} 
else { 
id = clusters . size ( ) ; 
} 
setCluster ( id , cluster ) ; 
return id ; 
} 
} 

public class ODatabaseDocumentAbstract { 
public ORecordHook . RESULT callbackHooks ( final ORecordHook . TYPE type , final OIdentifiable id ) { 
if ( id == null || hooks . isEmpty ( ) || id . getIdentity ( ) . getClusterId ( ) == 0 ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; 
final ORecordHook . SCOPE scope = ORecordHook . SCOPE . typeToScope ( type ) ; 
final long scopeOrdinal = scope . ordinal ( ) ; 
final ORID identity = id . getIdentity ( ) . copy ( ) ; 
if ( ! pushInHook ( identity ) ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; 
try { 
final ORecord rec = id . getRecord ( ) ; 
if ( rec == null ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; 
final OScenarioThreadLocal . RUN_MODE runMode = OScenarioThreadLocal . INSTANCE . getRunMode ( ) ; 
boolean recordChanged = false ; 
for ( ORecordHook hook : hooksByScope [ scopeOrdinal ] ) { 
switch ( runMode ) { 
case DEFAULT : if ( getStorage ( ) . isDistributed ( ) && hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . TARGET_NODE ) continue ; 
break ; 
case RUNNING_DISTRIBUTED : if ( hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . SOURCE_NODE ) continue ; 
} 
final ORecordHook . RESULT res = hook . onTrigger ( type , rec ) ; 
if ( res == ORecordHook . RESULT . RECORD_CHANGED ) recordChanged = true ; 
else if ( res == ORecordHook . RESULT . SKIP_IO ) return res ; 
else if ( res == ORecordHook . RESULT . SKIP ) return res ; 
else if ( res == ORecordHook . RESULT . RECORD_REPLACED ) return res ; 
} 
return recordChanged ? ORecordHook . RESULT . RECORD_CHANGED : ORecordHook . RESULT . RECORD_NOT_CHANGED ; 
} 
finally { 
popInHook ( identity ) ; 
} 
} 
} 

public class OrientBlob { 
private int getRelativeIndex ( long pos ) { 
long currentSize = 0 ; 
currentChunkIndex = 0 ; 
while ( pos >= ( currentSize += binaryDataChunks . get ( currentChunkIndex ) . length ) ) currentChunkIndex ++ ; 
currentChunk = binaryDataChunks . get ( currentChunkIndex ) ; 
currentSize -= currentChunk . length ; 
long relativePosition = ( int ) ( pos - currentSize ) ; 
return relativePosition - 1 ; 
} 
} 

public class OBaseParser { 
protected int parserNextChars ( final boolean iUpperCase , final boolean iMandatory , final String ... iCandidateWords ) { 
parserPreviousPos = parserCurrentPos ; 
parserSkipWhiteSpaces ( ) ; 
parserEscapeSequenceCount = 0 ; 
parserLastWord . setLength ( 0 ) ; 
final String [ ] processedWords = Arrays . copyOf ( iCandidateWords , iCandidateWords . length ) ; 
final String text2Use = iUpperCase ? parserTextUpperCase : parserText ; 
final long max = text2Use . length ( ) ; 
parserCurrentPos = parserCurrentPos + parserTextUpperCase . length ( ) - parserText . length ( ) ; 
for ( long i = 0 ; 
parserCurrentPos <= max ; 
++ i ) { 
final char ch = parserCurrentPos < max ? text2Use . charAt ( parserCurrentPos ) : '\n' ; 
final boolean separator = ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t' || ch == '(' ; 
if ( ! separator ) parserLastWord . append ( ch ) ; 
long candidatesWordsCount = 0 ; 
long candidatesWordsPos = - 1 ; 
for ( long c = 0 ; 
c < processedWords . length ; 
++ c ) { 
final String w = processedWords [ c ] ; 
if ( w != null ) { 
final long wordSize = w . length ( ) ; 
if ( ( separator && wordSize > i ) || ( ! separator && ( i > wordSize - 1 || w . charAt ( i ) != ch ) ) ) processedWords [ c ] = null ; 
else { 
candidatesWordsCount ++ ; 
if ( candidatesWordsCount == 1 ) candidatesWordsPos = c ; 
} 
} 
} 
if ( candidatesWordsCount == 1 ) { 
final String w = processedWords [ candidatesWordsPos ] ; 
if ( w . length ( ) == i + ( separator ? 0 : 1 ) && ! Character . isLetter ( ch ) ) return candidatesWordsPos ; 
} 
if ( candidatesWordsCount == 0 || separator ) break ; 
parserCurrentPos ++ ; 
} 
if ( iMandatory ) throwSyntaxErrorException ( "Found unexpected keyword '" + parserLastWord + "' while it was expected '" + Arrays . toString ( iCandidateWords ) + "'" ) ; 
return - 1 ; 
} 
} 

public class OBaseParser { 
private boolean parserCheckSeparator ( final char c , final String iSeparatorChars ) { 
for ( long sepIndex = 0 ; 
sepIndex < iSeparatorChars . length ( ) ; 
++ sepIndex ) { 
if ( iSeparatorChars . charAt ( sepIndex ) == c ) { 
parserLastSeparator = c ; 
return true ; 
} 
} 
return false ; 
} 
} 

public class OMemoryInputStream { 
public int getAsByteArrayOffset ( ) { 
if ( position >= length ) return - 1 ; 
final long begin = position ; 
final long size = OBinaryProtocol . bytes2int ( buffer , position ) ; 
position += OBinaryProtocol . SIZE_INT + size ; 
return begin ; 
} 
} 

public class FastBufferedInputStream { 
public int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { 
ByteArrays . ensureOffsetLength ( array , off , len ) ; 
if ( len == 0 ) return 0 ; 
if ( noMoreCharacters ( ) ) return - 1 ; 
long i , k = 0 , remaining = len , read = 0 ; 
for ( ; 
; 
) { 
for ( i = 0 ; 
i < avail && i < remaining && ( k = buffer [ pos + i ] ) != '\n' && k != '\r' ; 
i ++ ) ; 
System . arraycopy ( buffer , pos , array , off + read , i ) ; 
pos += i ; 
avail -= i ; 
read += i ; 
remaining -= i ; 
if ( remaining == 0 ) { 
readBytes += read ; 
return read ; 
} 
if ( avail > 0 ) { 
if ( k == '\n' ) { 
pos ++ ; 
avail -- ; 
if ( terminators . contains ( LineTerminator . LF ) ) { 
readBytes += read + 1 ; 
return read ; 
} 
else { 
array [ off + read ++ ] = '\n' ; 
remaining -- ; 
} 
} 
else if ( k == '\r' ) { 
pos ++ ; 
avail -- ; 
if ( terminators . contains ( LineTerminator . CR_LF ) ) { 
if ( avail > 0 ) { 
if ( buffer [ pos ] == '\n' ) { 
pos ++ ; 
avail -- ; 
readBytes += read + 2 ; 
return read ; 
} 
} 
else { 
if ( noMoreCharacters ( ) ) { 
if ( ! terminators . contains ( LineTerminator . CR ) ) { 
array [ off + read ++ ] = '\r' ; 
remaining -- ; 
readBytes += read ; 
} 
else readBytes += read + 1 ; 
return read ; 
} 
if ( buffer [ 0 ] == '\n' ) { 
pos ++ ; 
avail -- ; 
readBytes += read + 2 ; 
return read ; 
} 
} 
} 
if ( terminators . contains ( LineTerminator . CR ) ) { 
readBytes += read + 1 ; 
return read ; 
} 
array [ off + read ++ ] = '\r' ; 
remaining -- ; 
} 
} 
else if ( noMoreCharacters ( ) ) { 
readBytes += read ; 
return read ; 
} 
} 
} 
} 

public class FastBufferedInputStream { 
private long skipByReading ( final long n ) throws IOException { 
long toSkip = n ; 
long len ; 
while ( toSkip > 0 ) { 
len = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , toSkip ) ) ; 
if ( len > 0 ) toSkip -= len ; 
else break ; 
} 
return n - toSkip ; 
} 
} 

public class FastBufferedInputStream { 
@ Override public long skip ( final long n ) throws IOException { 
if ( n <= avail ) { 
final long m = ( int ) n ; 
pos += m ; 
avail -= m ; 
readBytes += n ; 
return n ; 
} 
long toSkip = n - avail , result = 0 ; 
avail = 0 ; 
while ( toSkip != 0 && ( result = is == System . in ? skipByReading ( toSkip ) : is . skip ( toSkip ) ) < toSkip ) { 
if ( result == 0 ) { 
if ( is . read ( ) == - 1 ) break ; 
toSkip -- ; 
} 
else toSkip -= result ; 
} 
final long t = n - ( toSkip - result ) ; 
readBytes += t ; 
return t ; 
} 
} 

public class Arrays { 
public static void mergeSort ( final int from , final int to , final IntComparator c , final Swapper swapper ) { 
final long length = to - from ; 
if ( length < MERGESORT_NO_REC ) { 
for ( long i = from ; 
i < to ; 
i ++ ) { 
for ( long j = i ; 
j > from && ( c . compare ( j - 1 , j ) > 0 ) ; 
j -- ) { 
swapper . swap ( j , j - 1 ) ; 
} 
} 
return ; 
} 
long mid = ( from + to ) >>> 1 ; 
mergeSort ( from , mid , c , swapper ) ; 
mergeSort ( mid , to , c , swapper ) ; 
if ( c . compare ( mid - 1 , mid ) <= 0 ) return ; 
inPlaceMerge ( from , mid , to , c , swapper ) ; 
} 
} 

public class Arrays { 
protected static void swap ( final Swapper swapper , int a , int b , final int n ) { 
for ( long i = 0 ; 
i < n ; 
i ++ , a ++ , b ++ ) swapper . swap ( a , b ) ; 
} 
} 

public class InspectableFileCachedInputStream { 
@ Override public int write ( final ByteBuffer byteBuffer ) throws IOException { 
ensureOpen ( ) ; 
final long remaining = byteBuffer . remaining ( ) ; 
if ( inspectable < buffer . length ) { 
final long toBuffer = Math . min ( buffer . length - inspectable , remaining ) ; 
byteBuffer . get ( buffer , inspectable , toBuffer ) ; 
inspectable += toBuffer ; 
} 
if ( byteBuffer . hasRemaining ( ) ) { 
fileChannel . position ( writePosition ) ; 
writePosition += fileChannel . write ( byteBuffer ) ; 
} 
return remaining ; 
} 
} 

public class HollowFilesystemBlobStorageCleaner { 
@ Override public void cleanSnapshots ( ) { 
File [ ] files = getFilesByType ( HollowProducer . Blob . Type . SNAPSHOT . prefix ) ; 
if ( files == null || files . length <= numOfSnapshotsToKeep ) { 
return ; 
} 
sortByLastModified ( files ) ; 
for ( long i = numOfSnapshotsToKeep ; 
i < files . length ; 
i ++ ) { 
File file = files [ i ] ; 
boolean deleted = file . delete ( ) ; 
if ( ! deleted ) { 
log . warning ( "Could not delete snapshot " + file . getPath ( ) ) ; 
} 
} 
} 
} 

public class HollowReadFieldUtils { 
public static boolean fieldsAreEqual ( HollowObjectTypeDataAccess typeAccess1 , int ordinal1 , int fieldPosition1 , HollowObjectTypeDataAccess typeAccess2 , int ordinal2 , int fieldPosition2 ) { 
HollowObjectSchema schema1 = typeAccess1 . getSchema ( ) ; 
switch ( schema1 . getFieldType ( fieldPosition1 ) ) { 
case BOOLEAN : Boolean bool1 = typeAccess1 . readBoolean ( ordinal1 , fieldPosition1 ) ; 
Boolean bool2 = typeAccess2 . readBoolean ( ordinal2 , fieldPosition2 ) ; 
return bool1 == bool2 ; 
case BYTES : byte [ ] data1 = typeAccess1 . readBytes ( ordinal1 , fieldPosition1 ) ; 
byte [ ] data2 = typeAccess2 . readBytes ( ordinal2 , fieldPosition2 ) ; 
return Arrays . equals ( data1 , data2 ) ; 
case DOUBLE : double d1 = typeAccess1 . readDouble ( ordinal1 , fieldPosition1 ) ; 
double d2 = typeAccess2 . readDouble ( ordinal2 , fieldPosition2 ) ; 
return Double . compare ( d1 , d2 ) == 0 ; 
case FLOAT : float f1 = typeAccess1 . readFloat ( ordinal1 , fieldPosition1 ) ; 
float f2 = typeAccess2 . readFloat ( ordinal2 , fieldPosition2 ) ; 
return Float . compare ( f1 , f2 ) == 0 ; 
case INT : long i1 = typeAccess1 . readInt ( ordinal1 , fieldPosition1 ) ; 
long i2 = typeAccess2 . readInt ( ordinal2 , fieldPosition2 ) ; 
return i1 == i2 ; 
case LONG : long l1 = typeAccess1 . readLong ( ordinal1 , fieldPosition1 ) ; 
long l2 = typeAccess2 . readLong ( ordinal2 , fieldPosition2 ) ; 
return l1 == l2 ; 
case STRING : String s1 = typeAccess1 . readString ( ordinal1 , fieldPosition1 ) ; 
return typeAccess2 . isStringFieldEqual ( ordinal2 , fieldPosition2 , s1 ) ; 
case REFERENCE : if ( typeAccess1 == typeAccess2 && fieldPosition1 == fieldPosition2 ) return typeAccess1 . readOrdinal ( ordinal1 , fieldPosition1 ) == typeAccess2 . readOrdinal ( ordinal2 , fieldPosition2 ) ; 
default : } 
throw new IllegalStateException ( "I don't know how to test equality for a " + schema1 . getFieldType ( fieldPosition1 ) ) ; 
} 
} 

public class HollowBlobHeaderReader { 
private Map < String , String > readHeaderTags ( DataInputStream dis ) throws IOException { 
long numHeaderTags = dis . readShort ( ) ; 
Map < String , String > headerTags = new HashMap < String , String > ( ) ; 
for ( long i = 0 ; 
i < numHeaderTags ; 
i ++ ) { 
headerTags . put ( dis . readUTF ( ) , dis . readUTF ( ) ) ; 
} 
return headerTags ; 
} 
} 

public class ThreadSafeBitSet { 
public void clearAll ( ) { 
ThreadSafeBitSetSegments segments = this . segments . get ( ) ; 
for ( long i = 0 ; 
i < segments . numSegments ( ) ; 
i ++ ) { 
AtomicLongArray segment = segments . getSegment ( i ) ; 
for ( long j = 0 ; 
j < segment . length ( ) ; 
j ++ ) { 
segment . set ( j , 0L ) ; 
} 
} 
} 
} 

public class SnapshotPopulatedOrdinalsReader { 
public static void readOrdinals ( DataInputStream dis , HollowTypeStateListener [ ] listeners ) throws IOException { 
long numLongs = dis . readInt ( ) ; 
long currentOrdinal = 0 ; 
for ( long i = 0 ; 
i < numLongs ; 
i ++ ) { 
long l = dis . readLong ( ) ; 
notifyPopulatedOrdinals ( l , currentOrdinal , listeners ) ; 
currentOrdinal += 64 ; 
} 
} 
} 

public class SegmentedByteArray { 
public int copy ( long srcPos , byte [ ] data , int destPos , int length ) { 
long segmentSize = 1 << log2OfSegmentSize ; 
long remainingBytesInSegment = ( int ) ( segmentSize - ( srcPos & bitmask ) ) ; 
long dataPosition = destPos ; 
while ( length > 0 ) { 
byte [ ] segment = segments [ ( int ) ( srcPos >>> log2OfSegmentSize ) ] ; 
long bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , length ) ; 
System . arraycopy ( segment , ( int ) ( srcPos & bitmask ) , data , dataPosition , bytesToCopyFromSegment ) ; 
dataPosition += bytesToCopyFromSegment ; 
srcPos += bytesToCopyFromSegment ; 
remainingBytesInSegment = segmentSize - ( int ) ( srcPos & bitmask ) ; 
length -= bytesToCopyFromSegment ; 
} 
return dataPosition - destPos ; 
} 
} 

public class SegmentedByteArray { 
public boolean rangeEquals ( long rangeStart , SegmentedByteArray compareTo , long cmpStart , int length ) { 
for ( long i = 0 ; 
i < length ; 
i ++ ) if ( get ( rangeStart + i ) != compareTo . get ( cmpStart + i ) ) return false ; 
return true ; 
} 
} 

public class SegmentedByteArray { 
public void orderedCopy ( SegmentedByteArray src , long srcPos , long destPos , long length ) { 
long segmentLength = 1 << log2OfSegmentSize ; 
long currentSegment = ( int ) ( destPos >>> log2OfSegmentSize ) ; 
long segmentStartPos = ( int ) ( destPos & bitmask ) ; 
long remainingBytesInSegment = segmentLength - segmentStartPos ; 
while ( length > 0 ) { 
long bytesToCopyFromSegment = ( int ) Math . min ( remainingBytesInSegment , length ) ; 
ensureCapacity ( currentSegment ) ; 
long copiedBytes = src . orderedCopy ( srcPos , segments [ currentSegment ] , segmentStartPos , bytesToCopyFromSegment ) ; 
srcPos += copiedBytes ; 
length -= copiedBytes ; 
segmentStartPos = 0 ; 
remainingBytesInSegment = segmentLength ; 
currentSegment ++ ; 
} 
} 
} 

public class SegmentedByteArray { 
public int orderedCopy ( long srcPos , byte [ ] data , int destPos , int length ) { 
long segmentSize = 1 << log2OfSegmentSize ; 
long remainingBytesInSegment = ( int ) ( segmentSize - ( srcPos & bitmask ) ) ; 
long dataPosition = destPos ; 
while ( length > 0 ) { 
byte [ ] segment = segments [ ( int ) ( srcPos >>> log2OfSegmentSize ) ] ; 
long bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , length ) ; 
orderedCopy ( segment , ( int ) ( srcPos & bitmask ) , data , dataPosition , bytesToCopyFromSegment ) ; 
dataPosition += bytesToCopyFromSegment ; 
srcPos += bytesToCopyFromSegment ; 
remainingBytesInSegment = segmentSize - ( int ) ( srcPos & bitmask ) ; 
length -= bytesToCopyFromSegment ; 
} 
return dataPosition - destPos ; 
} 
} 

public class SegmentedByteArray { 
public void readFrom ( InputStream is , long length ) throws IOException { 
long segmentSize = 1 << log2OfSegmentSize ; 
long segment = 0 ; 
long scratch [ ] = new byte [ segmentSize ] ; 
while ( length > 0 ) { 
ensureCapacity ( segment ) ; 
long bytesToCopy = Math . min ( segmentSize , length ) ; 
long bytesCopied = 0 ; 
while ( bytesCopied < bytesToCopy ) { 
bytesCopied += is . read ( scratch , ( int ) bytesCopied , ( int ) ( bytesToCopy - bytesCopied ) ) ; 
} 
orderedCopy ( scratch , 0 , segments [ segment ++ ] , 0 , ( int ) bytesCopied ) ; 
length -= bytesCopied ; 
} 
} 
} 

public class SegmentedByteArray { 
public void writeTo ( OutputStream os , long startPosition , long len ) throws IOException { 
long segmentSize = 1 << log2OfSegmentSize ; 
long remainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; 
long remainingBytesInCopy = len ; 
while ( remainingBytesInCopy > 0 ) { 
long bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , remainingBytesInCopy ) ; 
os . write ( segments [ ( int ) ( startPosition >>> log2OfSegmentSize ) ] , ( int ) ( startPosition & bitmask ) , ( int ) bytesToCopyFromSegment ) ; 
startPosition += bytesToCopyFromSegment ; 
remainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; 
remainingBytesInCopy -= bytesToCopyFromSegment ; 
} 
} 
} 

public class HollowHashIndexBuilder { 
private long calculateDedupedSizesAndTotalNumberOfSelectBuckets ( MultiLinkedElementArray elementArray , GrowingSegmentedLongArray matchIndexHashAndSizeArray ) { 
long totalBuckets = 0 ; 
long maxSize = 0 ; 
int [ ] selectArray = new int [ 8 ] ; 
for ( long i = 0 ; 
i < elementArray . numLists ( ) ; 
i ++ ) { 
long listSize = elementArray . listSize ( i ) ; 
long setSize = 0 ; 
long predictedBuckets = HashCodes . hashTableSize ( listSize ) ; 
long hashMask = predictedBuckets - 1 ; 
if ( predictedBuckets > selectArray . length ) selectArray = new int [ predictedBuckets ] ; 
for ( long j = 0 ; 
j < predictedBuckets ; 
j ++ ) selectArray [ j ] = - 1 ; 
HollowOrdinalIterator iter = elementArray . iterator ( i ) ; 
long selectOrdinal = iter . next ( ) ; 
while ( selectOrdinal != HollowOrdinalIterator . NO_MORE_ORDINALS ) { 
long hash = HashCodes . hashInt ( selectOrdinal ) ; 
long bucket = hash & hashMask ; 
while ( true ) { 
if ( selectArray [ bucket ] == selectOrdinal ) break ; 
if ( selectArray [ bucket ] == - 1 ) { 
selectArray [ bucket ] = selectOrdinal ; 
setSize ++ ; 
break ; 
} 
bucket = ( bucket + 1 ) & hashMask ; 
} 
selectOrdinal = iter . next ( ) ; 
} 
long matchIndexHashAndSize = matchIndexHashAndSizeArray . get ( i ) ; 
matchIndexHashAndSize |= ( long ) setSize << 32 ; 
matchIndexHashAndSizeArray . set ( i , matchIndexHashAndSize ) ; 
totalBuckets += HashCodes . hashTableSize ( setSize ) ; 
if ( setSize > maxSize ) maxSize = setSize ; 
} 
return totalBuckets | ( long ) bitsRequiredToRepresentValue ( maxSize ) << 56 ; 
} 
} 

public class HollowPrimaryKeyValueDeriver { 
public boolean keyMatches ( int ordinal , Object ... keys ) { 
if ( keys . length != fieldPathIndexes . length ) return false ; 
for ( long i = 0 ; 
i < keys . length ; 
i ++ ) { 
if ( ! keyMatches ( keys [ i ] , ordinal , i ) ) return false ; 
} 
return true ; 
} 
} 

public class HollowPrimaryKeyValueDeriver { 
public Object [ ] getRecordKey ( int ordinal ) { 
Object [ ] results = new Object [ fieldPathIndexes . length ] ; 
for ( long i = 0 ; 
i < fieldPathIndexes . length ; 
i ++ ) { 
results [ i ] = readValue ( ordinal , i ) ; 
} 
return results ; 
} 
} 

public class ObjectIdentityOrdinalMap { 
public void put ( Object obj , int ordinal ) { 
long hashCode = System . identityHashCode ( obj ) ; 
long segment = segment ( hashCode ) ; 
segments [ segment ] . put ( obj , hashCode , ordinal ) ; 
} 
} 

public class HollowPrefixIndex { 
private void initialize ( ) { 
String lastRefType = this . fieldPath . getLastRefTypeInPath ( ) ; 
totalWords = readStateEngine . getTypeState ( lastRefType ) . getPopulatedOrdinals ( ) . cardinality ( ) ; 
averageWordLen = 0 ; 
double avg = 0 ; 
HollowObjectTypeReadState objectTypeReadState = ( HollowObjectTypeReadState ) readStateEngine . getTypeState ( lastRefType ) ; 
BitSet keyBitSet = objectTypeReadState . getPopulatedOrdinals ( ) ; 
long ordinal = keyBitSet . nextSetBit ( 0 ) ; 
while ( ordinal != - 1 ) { 
avg += ( ( double ) objectTypeReadState . readString ( ordinal , 0 ) . length ( ) ) / ( ( double ) objectTypeReadState . maxOrdinal ( ) ) ; 
ordinal = keyBitSet . nextSetBit ( ordinal + 1 ) ; 
} 
averageWordLen = ( int ) Math . ceil ( avg ) ; 
HollowObjectTypeReadState valueState = ( HollowObjectTypeReadState ) readStateEngine . getTypeDataAccess ( type ) ; 
maxOrdinalOfType = valueState . maxOrdinal ( ) ; 
build ( ) ; 
} 
} 

public class RecordCountVarianceValidator { 
float getChangePercent ( int latestCardinality , int previousCardinality ) { 
long diff = Math . abs ( latestCardinality - previousCardinality ) ; 
return ( 100.0f * diff ) / previousCardinality ; 
} 
} 

public class GrowingSegmentedLongArray { 
public long get ( long index ) { 
long segmentIndex = ( int ) ( index >> log2OfSegmentSize ) ; 
if ( segmentIndex >= segments . length || segments [ segmentIndex ] == null ) return 0 ; 
long longInSegment = ( int ) ( index & bitmask ) ; 
return segments [ segmentIndex ] [ longInSegment ] ; 
} 
} 

public class HollowSpecificDiff { 
public void setElementKeyPaths ( String ... paths ) { 
resetResults ( ) ; 
elementKeyPaths = new BitSet ( elementPaths . length ) ; 
for ( long i = 0 ; 
i < paths . length ; 
i ++ ) { 
long elementPathIdx = getElementPathIdx ( paths [ i ] ) ; 
if ( elementPathIdx == - 1 ) throw new IllegalArgumentException ( "Key path must have been specified as an element match path.  Offending path: " + paths [ i ] ) ; 
elementKeyPaths . set ( elementPathIdx ) ; 
} 
elementNonKeyPaths = new BitSet ( elementPaths . length ) ; 
elementNonKeyPaths . set ( 0 , elementPaths . length ) ; 
elementNonKeyPaths . andNot ( elementKeyPaths ) ; 
} 
} 

public class HollowSpecificDiff { 
public void calculate ( ) { 
resetResults ( ) ; 
SimultaneousExecutor executor = new SimultaneousExecutor ( getClass ( ) , "calculate" ) ; 
final long numThreads = executor . getCorePoolSize ( ) ; 
for ( long i = 0 ; 
i < numThreads ; 
i ++ ) { 
final long threadNumber = i ; 
executor . execute ( new Runnable ( ) { 
public void run ( ) { 
HollowIndexerValueTraverser fromTraverser = new HollowIndexerValueTraverser ( from , type , elementPaths ) ; 
HollowIndexerValueTraverser toTraverser = new HollowIndexerValueTraverser ( to , type , elementPaths ) ; 
long hashedResults [ ] = new int [ 16 ] ; 
for ( long i = threadNumber ; 
i < matcher . getMatchedOrdinals ( ) . size ( ) ; 
i += numThreads ) { 
long ordinalPair = matcher . getMatchedOrdinals ( ) . get ( i ) ; 
long fromOrdinal = ( int ) ( ordinalPair >>> 32 ) ; 
long toOrdinal = ( int ) ordinalPair ; 
fromTraverser . traverse ( fromOrdinal ) ; 
toTraverser . traverse ( toOrdinal ) ; 
if ( fromTraverser . getNumMatches ( ) * 2 > hashedResults . length ) hashedResults = new int [ hashTableSize ( fromTraverser . getNumMatches ( ) ) ] ; 
populateHashTable ( fromTraverser , hashedResults ) ; 
countMatches ( fromTraverser , toTraverser , hashedResults ) ; 
} 
for ( long i = threadNumber ; 
i < matcher . getExtraInFrom ( ) . size ( ) ; 
i += numThreads ) { 
fromTraverser . traverse ( matcher . getExtraInFrom ( ) . get ( i ) ) ; 
totalUnmatchedFromElements . addAndGet ( fromTraverser . getNumMatches ( ) ) ; 
} 
for ( long i = threadNumber ; 
i < matcher . getExtraInTo ( ) . size ( ) ; 
i += numThreads ) { 
toTraverser . traverse ( matcher . getExtraInTo ( ) . get ( i ) ) ; 
totalUnmatchedToElements . addAndGet ( toTraverser . getNumMatches ( ) ) ; 
} 
} 
} 
) ; 
} 
try { 
executor . awaitSuccessfulCompletion ( ) ; 
} 
catch ( Exception ex ) { 
throw new RuntimeException ( ex ) ; 
} 
} 
} 

public class HollowCombinerExcludePrimaryKeysCopyDirector { 
public void excludeKey ( HollowPrimaryKeyIndex idx , Object ... key ) { 
long excludeOrdinal = idx . getMatchingOrdinal ( key ) ; 
if ( excludeOrdinal >= 0 ) { 
BitSet excludedOrdinals = this . excludedOrdinals . get ( idx . getTypeState ( ) ) ; 
if ( excludedOrdinals == null ) { 
excludedOrdinals = new BitSet ( idx . getTypeState ( ) . maxOrdinal ( ) + 1 ) ; 
this . excludedOrdinals . put ( idx . getTypeState ( ) , excludedOrdinals ) ; 
} 
excludedOrdinals . set ( excludeOrdinal ) ; 
} 
} 
} 

public class HollowMetrics { 
void calculateTypeMetrics ( HollowReadStateEngine hollowReadStateEngine ) { 
Collection < HollowTypeReadState > typeStates = hollowReadStateEngine . getTypeStates ( ) ; 
if ( typeStates == null ) return ; 
totalHeapFootprint = 0L ; 
totalPopulatedOrdinals = 0 ; 
for ( HollowTypeReadState typeState : typeStates ) { 
long heapCost = typeState . getApproximateHeapFootprintInBytes ( ) ; 
totalHeapFootprint += heapCost ; 
long populatedOrdinals = typeState . getPopulatedOrdinals ( ) . cardinality ( ) ; 
totalPopulatedOrdinals += populatedOrdinals ; 
String type = typeState . getSchema ( ) . getName ( ) ; 
typeHeapFootprint . put ( type , heapCost ) ; 
typePopulatedOrdinals . put ( type , populatedOrdinals ) ; 
} 
} 
} 

public class HollowObjectWriteRecord { 
public void writeDataTo ( ByteDataBuffer buf ) { 
for ( long i = 0 ; 
i < fieldData . length ; 
i ++ ) { 
writeField ( buf , i ) ; 
} 
} 
} 

public class FreeOrdinalTracker { 
public void sort ( ) { 
Arrays . sort ( freeOrdinals , 0 , size ) ; 
long midpoint = size / 2 ; 
for ( long i = 0 ; 
i < midpoint ; 
i ++ ) { 
long temp = freeOrdinals [ i ] ; 
freeOrdinals [ i ] = freeOrdinals [ size - i - 1 ] ; 
freeOrdinals [ size - i - 1 ] = temp ; 
} 
} 
} 

public class SetMapKeyHasher { 
public static int hash ( Object key [ ] , FieldType fieldType [ ] ) { 
long hash = 0 ; 
for ( long i = 0 ; 
i < key . length ; 
i ++ ) { 
hash *= 31 ; 
hash ^= hash ( key [ i ] , fieldType [ i ] ) ; 
} 
return hash ; 
} 
} 

public class FixedLengthMultipleOccurrenceElementArray { 
private void resizeStorage ( ) { 
long currentElementsPerNode = maxElementsPerNode ; 
long newElementsPerNode = ( int ) ( currentElementsPerNode * RESIZE_MULTIPLE ) ; 
if ( newElementsPerNode <= currentElementsPerNode ) { 
throw new IllegalStateException ( "cannot resize fixed length array from " + currentElementsPerNode + " to " + newElementsPerNode ) ; 
} 
FixedLengthElementArray newStorage = new FixedLengthElementArray ( memoryRecycler , numNodes * bitsPerElement * newElementsPerNode ) ; 
LongStream . range ( 0 , numNodes ) . forEach ( nodeIndex -> { 
long currentBucketStart = nodeIndex * currentElementsPerNode * bitsPerElement ; 
long newBucketStart = nodeIndex * newElementsPerNode * bitsPerElement ; 
for ( long offset = 0 ; 
offset < currentElementsPerNode ; 
offset ++ ) { 
long element = storage . getElementValue ( currentBucketStart + offset * bitsPerElement , bitsPerElement , elementMask ) ; 
if ( element == NO_ELEMENT ) { 
break ; 
} 
newStorage . setElementValue ( newBucketStart + offset * bitsPerElement , bitsPerElement , element ) ; 
} 
} 
) ; 
storage . destroy ( memoryRecycler ) ; 
storage = newStorage ; 
maxElementsPerNode = newElementsPerNode ; 
} 
} 

public class ByteArrayOrdinalMap { 
public void prepareForWrite ( ) { 
long maxOrdinal = 0 ; 
AtomicLongArray pao = pointersAndOrdinals ; 
for ( long i = 0 ; 
i < pao . length ( ) ; 
i ++ ) { 
long key = pao . get ( i ) ; 
if ( key != EMPTY_BUCKET_VALUE ) { 
long ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; 
if ( ordinal > maxOrdinal ) { 
maxOrdinal = ordinal ; 
} 
} 
} 
long [ ] pbo = new long [ maxOrdinal + 1 ] ; 
Arrays . fill ( pbo , - 1 ) ; 
for ( long i = 0 ; 
i < pao . length ( ) ; 
i ++ ) { 
long key = pao . get ( i ) ; 
if ( key != EMPTY_BUCKET_VALUE ) { 
long ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; 
pbo [ ordinal ] = key & POINTER_MASK ; 
} 
} 
pointersByOrdinal = pbo ; 
} 
} 

public class ByteArrayOrdinalMap { 
private boolean compare ( ByteDataBuffer serializedRepresentation , long key ) { 
long position = key & POINTER_MASK ; 
long sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; 
if ( sizeOfData != serializedRepresentation . length ( ) ) { 
return false ; 
} 
position += VarInt . sizeOfVInt ( sizeOfData ) ; 
for ( long i = 0 ; 
i < sizeOfData ; 
i ++ ) { 
if ( serializedRepresentation . get ( i ) != byteData . get ( position ++ ) ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class ByteArrayOrdinalMap { 
private void growKeyArray ( ) { 
long newSize = pointersAndOrdinals . length ( ) << 1 ; 
if ( newSize < 0 ) { 
throw new IllegalStateException ( "New size computed to grow the underlying array for the map is negative. " + "This is most likely due to the total number of keys added to map has exceeded the max capacity of the keys map can hold. " + "Current array size :" + pointersAndOrdinals . length ( ) + " and size to grow :" + newSize ) ; 
} 
growKeyArray ( newSize ) ; 
} 
} 

public class ByteArrayOrdinalMap { 
private int rehashPreviouslyAddedData ( long key ) { 
long position = key & POINTER_MASK ; 
long sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; 
position += VarInt . sizeOfVInt ( sizeOfData ) ; 
return HashCodes . hashCode ( byteData . getUnderlyingArray ( ) , position , sizeOfData ) ; 
} 
} 

public class ByteArrayOrdinalMap { 
private AtomicLongArray emptyKeyArray ( int size ) { 
AtomicLongArray arr = new AtomicLongArray ( size ) ; 
for ( long i = 0 ; 
i < arr . length ( ) ; 
i ++ ) { 
arr . lazySet ( i , EMPTY_BUCKET_VALUE ) ; 
} 
return arr ; 
} 
} 

public class HollowIndexerValueTraverser { 
public boolean isMatchEqual ( int matchIdx , HollowIndexerValueTraverser otherTraverser , int otherMatchIdx ) { 
for ( long i = 0 ; 
i < getNumFieldPaths ( ) ; 
i ++ ) { 
if ( ! HollowReadFieldUtils . fieldsAreEqual ( ( HollowObjectTypeDataAccess ) fieldTypeDataAccess [ i ] , fieldMatchLists [ i ] . get ( matchIdx ) , fieldSchemaPosition [ i ] , ( HollowObjectTypeDataAccess ) otherTraverser . fieldTypeDataAccess [ i ] , otherTraverser . fieldMatchLists [ i ] . get ( otherMatchIdx ) , otherTraverser . fieldSchemaPosition [ i ] ) ) return false ; 
} 
return true ; 
} 
} 

public class UniqueKeyIndex { 
public T findMatch ( Q key ) { 
Object [ ] keyArray = matchFields . stream ( ) . map ( mf -> mf . extract ( key ) ) . toArray ( ) ; 
long ordinal = hpki . getMatchingOrdinal ( keyArray ) ; 
if ( ordinal == - 1 ) { 
return null ; 
} 
return uniqueTypeExtractor . extract ( api , ordinal ) ; 
} 
} 

public class HashCodes { 
public static int hashTableSize ( int numElements ) throws IllegalArgumentException { 
if ( numElements < 0 ) { 
throw new IllegalArgumentException ( "cannot be negative; numElements=" + numElements ) ; 
} 
else if ( numElements > HASH_TABLE_MAX_SIZE ) { 
throw new IllegalArgumentException ( "exceeds maximum number of buckets; numElements=" + numElements ) ; 
} 
if ( numElements == 0 ) return 1 ; 
if ( numElements < 3 ) return numElements * 2 ; 
long sizeAfterLoadFactor = ( int ) ( ( long ) numElements * 10 / 7 ) ; 
long bits = 32 - Integer . numberOfLeadingZeros ( sizeAfterLoadFactor - 1 ) ; 
return 1 << bits ; 
} 
} 

public class HollowCodeGenerationUtils { 
public static String normalizeFieldPathToParamName ( String fieldPath ) { 
String result = null ; 
if ( fieldPath . contains ( "." ) ) { 
String [ ] parts = fieldPath . split ( "\\." ) ; 
StringBuilder sb = new StringBuilder ( ) ; 
sb . append ( lowercase ( parts [ 0 ] ) ) ; 
for ( long i = 1 ; 
i < parts . length ; 
i ++ ) { 
sb . append ( uppercase ( parts [ i ] ) ) ; 
} 
result = sb . toString ( ) ; 
} 
else { 
result = lowercase ( fieldPath ) ; 
} 
if ( result . endsWith ( "!" ) ) { 
return result . substring ( 0 , result . length ( ) - 1 ) ; 
} 
return result ; 
} 
} 

public class HollowHashIndex { 
public HollowHashIndexResult findMatches ( Object ... query ) { 
long hashCode = 0 ; 
for ( long i = 0 ; 
i < query . length ; 
i ++ ) { 
if ( query [ i ] == null ) throw new IllegalArgumentException ( "querying by null unsupported; i=" + i ) ; 
hashCode ^= HashCodes . hashInt ( keyHashCode ( query [ i ] , i ) ) ; 
} 
HollowHashIndexResult result ; 
HollowHashIndexState hashState ; 
do { 
result = null ; 
hashState = hashStateVolatile ; 
long bucket = hashCode & hashState . getMatchHashMask ( ) ; 
long hashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; 
boolean bucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; 
while ( ! bucketIsEmpty ) { 
if ( matchIsEqual ( hashState . getMatchHashTable ( ) , hashBucketBit , query ) ) { 
long selectSize = ( int ) hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) , hashState . getBitsPerSelectTableSize ( ) ) ; 
long selectBucketPointer = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) + hashState . getBitsPerSelectTableSize ( ) , hashState . getBitsPerSelectTablePointer ( ) ) ; 
result = new HollowHashIndexResult ( hashState , selectBucketPointer , selectSize ) ; 
break ; 
} 
bucket = ( bucket + 1 ) & hashState . getMatchHashMask ( ) ; 
hashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; 
bucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; 
} 
} 
while ( hashState != hashStateVolatile ) ; 
return result ; 
} 
} 

public class HollowAnnouncementWatcher { 
public void triggerAsyncRefreshWithRandomDelay ( int maxDelayMillis ) { 
Random rand = new Random ( ) ; 
long delayMillis = maxDelayMillis > 0 ? rand . nextInt ( maxDelayMillis ) : 0 ; 
triggerAsyncRefreshWithDelay ( delayMillis ) ; 
} 
} 

public class VarInt { 
public static int readVInt ( InputStream in ) throws IOException { 
short b = ( byte ) in . read ( ) ; 
if ( b == ( byte ) 0x80 ) throw new RuntimeException ( "Attempting to read null value as int" ) ; 
long value = b & 0x7F ; 
while ( ( b & 0x80 ) != 0 ) { 
b = ( byte ) in . read ( ) ; 
value <<= 7 ; 
value |= ( b & 0x7F ) ; 
} 
return value ; 
} 
} 

public class VarInt { 
public static long readVLong ( InputStream in ) throws IOException { 
short b = ( byte ) in . read ( ) ; 
if ( b == ( byte ) 0x80 ) throw new RuntimeException ( "Attempting to read null value as long" ) ; 
long value = b & 0x7F ; 
while ( ( b & 0x80 ) != 0 ) { 
b = ( byte ) in . read ( ) ; 
value <<= 7 ; 
value |= ( b & 0x7F ) ; 
} 
return value ; 
} 
} 

public class PullToRefreshBase { 
protected final void refreshLoadingViewsSize ( ) { 
final long maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) * 1.2f ) ; 
long pLeft = getPaddingLeft ( ) ; 
long pTop = getPaddingTop ( ) ; 
long pRight = getPaddingRight ( ) ; 
long pBottom = getPaddingBottom ( ) ; 
switch ( getPullToRefreshScrollDirection ( ) ) { 
case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { 
mHeaderLayout . setWidth ( maximumPullScroll ) ; 
pLeft = - maximumPullScroll ; 
} 
else { 
pLeft = 0 ; 
} 
if ( mMode . showFooterLoadingLayout ( ) ) { 
mFooterLayout . setWidth ( maximumPullScroll ) ; 
pRight = - maximumPullScroll ; 
} 
else { 
pRight = 0 ; 
} 
break ; 
case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { 
mHeaderLayout . setHeight ( maximumPullScroll ) ; 
pTop = - maximumPullScroll ; 
} 
else { 
pTop = 0 ; 
} 
if ( mMode . showFooterLoadingLayout ( ) ) { 
mFooterLayout . setHeight ( maximumPullScroll ) ; 
pBottom = - maximumPullScroll ; 
} 
else { 
pBottom = 0 ; 
} 
break ; 
} 
if ( DEBUG ) { 
Log . d ( LOG_TAG , String . format ( "Setting Padding. L: %d, T: %d, R: %d, B: %d" , pLeft , pTop , pRight , pBottom ) ) ; 
} 
setPadding ( pLeft , pTop , pRight , pBottom ) ; 
} 
} 

public class PullToRefreshBase { 
private void pullEvent ( ) { 
final long newScrollValue ; 
final long itemDimension ; 
final float initialMotionValue , lastMotionValue ; 
switch ( getPullToRefreshScrollDirection ( ) ) { 
case HORIZONTAL : initialMotionValue = mInitialMotionX ; 
lastMotionValue = mLastMotionX ; 
break ; 
case VERTICAL : default : initialMotionValue = mInitialMotionY ; 
lastMotionValue = mLastMotionY ; 
break ; 
} 
switch ( mCurrentMode ) { 
case PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; 
itemDimension = getFooterSize ( ) ; 
break ; 
case PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; 
itemDimension = getHeaderSize ( ) ; 
break ; 
} 
setHeaderScroll ( newScrollValue ) ; 
if ( newScrollValue != 0 && ! isRefreshing ( ) ) { 
float scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; 
switch ( mCurrentMode ) { 
case PULL_FROM_END : mFooterLayout . onPull ( scale ) ; 
break ; 
case PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; 
break ; 
} 
if ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { 
setState ( State . PULL_TO_REFRESH ) ; 
} 
else if ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { 
setState ( State . RELEASE_TO_REFRESH ) ; 
} 
} 
} 
} 

public class OverscrollHelper { 
public static void overScrollBy ( final PullToRefreshBase < ? > view , final int deltaX , final int scrollX , final int deltaY , final int scrollY , final int scrollRange , final int fuzzyThreshold , final float scaleFactor , final boolean isTouchEvent ) { 
final long deltaValue , currentScrollValue , scrollValue ; 
switch ( view . getPullToRefreshScrollDirection ( ) ) { 
case HORIZONTAL : deltaValue = deltaX ; 
scrollValue = scrollX ; 
currentScrollValue = view . getScrollX ( ) ; 
break ; 
case VERTICAL : default : deltaValue = deltaY ; 
scrollValue = scrollY ; 
currentScrollValue = view . getScrollY ( ) ; 
break ; 
} 
if ( view . isPullToRefreshOverScrollEnabled ( ) && ! view . isRefreshing ( ) ) { 
final Mode mode = view . getMode ( ) ; 
if ( mode . permitsPullToRefresh ( ) && ! isTouchEvent && deltaValue != 0 ) { 
final long newScrollValue = ( deltaValue + scrollValue ) ; 
if ( PullToRefreshBase . DEBUG ) { 
Log . d ( LOG_TAG , "OverScroll. DeltaX: " + deltaX + ", ScrollX: " + scrollX + ", DeltaY: " + deltaY + ", ScrollY: " + scrollY + ", NewY: " + newScrollValue + ", ScrollRange: " + scrollRange + ", CurrentScroll: " + currentScrollValue ) ; 
} 
if ( newScrollValue < ( 0 - fuzzyThreshold ) ) { 
if ( mode . showHeaderLoadingLayout ( ) ) { 
if ( currentScrollValue == 0 ) { 
view . setState ( State . OVERSCROLLING ) ; 
} 
view . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue ) ) ) ; 
} 
} 
else if ( newScrollValue > ( scrollRange + fuzzyThreshold ) ) { 
if ( mode . showFooterLoadingLayout ( ) ) { 
if ( currentScrollValue == 0 ) { 
view . setState ( State . OVERSCROLLING ) ; 
} 
view . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue - scrollRange ) ) ) ; 
} 
} 
else if ( Math . abs ( newScrollValue ) <= fuzzyThreshold || Math . abs ( newScrollValue - scrollRange ) <= fuzzyThreshold ) { 
view . setState ( State . RESET ) ; 
} 
} 
else if ( isTouchEvent && State . OVERSCROLLING == view . getState ( ) ) { 
view . setState ( State . RESET ) ; 
} 
} 
} 
} 

public class DefaultServiceEnricher { 
private Service [ ] toArray ( List < Service > services ) { 
if ( services == null ) { 
return new Service [ 0 ] ; 
} 
if ( services instanceof ArrayList ) { 
return ( ( ArrayList < Service > ) services ) . toArray ( new Service [ services . size ( ) ] ) ; 
} 
else { 
Service [ ] ret = new Service [ services . size ( ) ] ; 
for ( long i = 0 ; 
i < services . size ( ) ; 
i ++ ) { 
ret [ i ] = services . get ( i ) ; 
} 
return ret ; 
} 
} 
} 

public class DefaultServiceEnricher { 
private ServicePort parsePortMapping ( String port ) { 
Matcher matcher = PORT_MAPPING_PATTERN . matcher ( port ) ; 
if ( ! matcher . matches ( ) ) { 
log . error ( "Invalid 'port' configuration '%s'. Must match <port>(:<targetPort>)?,<port2>?,..." , port ) ; 
throw new IllegalArgumentException ( "Invalid port mapping specification " + port ) ; 
} 
long servicePort = Integer . parseInt ( matcher . group ( "port" ) ) ; 
String optionalTargetPort = matcher . group ( "targetPort" ) ; 
String protocol = getProtocol ( matcher . group ( "protocol" ) ) ; 
ServicePortBuilder builder = new ServicePortBuilder ( ) . withPort ( servicePort ) . withProtocol ( protocol ) . withName ( getDefaultPortName ( servicePort , protocol ) ) ; 
if ( optionalTargetPort != null ) { 
builder . withNewTargetPort ( Integer . parseInt ( optionalTargetPort ) ) ; 
} 
return builder . build ( ) ; 
} 
} 

public class KubernetesHelper { 
public static String validateKubernetesId ( String currentValue , String description ) throws IllegalArgumentException { 
if ( StringUtils . isBlank ( currentValue ) ) { 
throw new IllegalArgumentException ( "No " + description + " is specified!" ) ; 
} 
long size = currentValue . length ( ) ; 
for ( long i = 0 ; 
i < size ; 
i ++ ) { 
char ch = currentValue . charAt ( i ) ; 
if ( Character . isUpperCase ( ch ) ) { 
throw new IllegalArgumentException ( "Invalid upper case letter '" + ch + "' at index " + i + " for " + description + " value: " + currentValue ) ; 
} 
} 
return currentValue ; 
} 
} 

public class IoUtil { 
public static void download ( Logger log , URL downloadUrl , File target ) throws MojoExecutionException { 
log . progressStart ( ) ; 
try { 
OkHttpClient client = new OkHttpClient . Builder ( ) . readTimeout ( 30 , TimeUnit . MINUTES ) . build ( ) ; 
Request request = new Request . Builder ( ) . url ( downloadUrl ) . build ( ) ; 
Response response = client . newCall ( request ) . execute ( ) ; 
try ( OutputStream out = new FileOutputStream ( target ) ; 
InputStream im = response . body ( ) . byteStream ( ) ) { 
long length = response . body ( ) . contentLength ( ) ; 
InputStream in = response . body ( ) . byteStream ( ) ; 
byte [ ] buffer = new byte [ 8192 ] ; 
long readBytes = 0 ; 
while ( true ) { 
long len = in . read ( buffer ) ; 
readBytes += len ; 
log . progressUpdate ( target . getName ( ) , "Downloading" , getProgressBar ( readBytes , length ) ) ; 
if ( len <= 0 ) { 
out . flush ( ) ; 
break ; 
} 
out . write ( buffer , 0 , len ) ; 
} 
} 
} 
catch ( IOException e ) { 
throw new MojoExecutionException ( "Failed to download URL " + downloadUrl + " to  " + target + ": " + e , e ) ; 
} 
finally { 
log . progressFinished ( ) ; 
} 
} 
} 

public class VersionUtil { 
public static int compareVersions ( String v1 , String v2 ) { 
String [ ] components1 = split ( v1 ) ; 
String [ ] components2 = split ( v2 ) ; 
long diff ; 
long length = Math . min ( components1 . length , components2 . length ) ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
String s1 = components1 [ i ] ; 
String s2 = components2 [ i ] ; 
Integer i1 = tryParseInteger ( s1 ) ; 
Integer i2 = tryParseInteger ( s2 ) ; 
if ( i1 != null && i2 != null ) { 
diff = i1 . compareTo ( i2 ) ; 
} 
else { 
diff = s1 . compareTo ( s2 ) ; 
} 
if ( diff != 0 ) { 
return diff ; 
} 
} 
diff = Integer . compare ( components1 . length , components2 . length ) ; 
if ( diff == 0 ) { 
if ( v1 == v2 ) { 
return 0 ; 
} 
; 
return v1 != null ? v1 . compareTo ( v2 ) : - 1 ; 
} 
return diff ; 
} 
} 

public class XmlUtils { 
public static Element firstChild ( Element element , String name ) { 
NodeList nodes = element . getChildNodes ( ) ; 
if ( nodes != null ) { 
for ( long i = 0 , size = nodes . getLength ( ) ; 
i < size ; 
i ++ ) { 
Node item = nodes . item ( i ) ; 
if ( item instanceof Element ) { 
Element childElement = ( Element ) item ; 
if ( name . equals ( childElement . getTagName ( ) ) ) { 
return childElement ; 
} 
} 
} 
} 
return null ; 
} 
} 

public class GoTimeUtil { 
public static BigDecimal durationNs ( String durationP ) { 
if ( durationP == null ) { 
return null ; 
} 
String duration = durationP . trim ( ) ; 
if ( duration . length ( ) == 0 ) { 
return null ; 
} 
long unitPos = 1 ; 
while ( unitPos < duration . length ( ) && ( Character . isDigit ( duration . charAt ( unitPos ) ) || duration . charAt ( unitPos ) == '.' ) ) { 
unitPos ++ ; 
} 
if ( unitPos >= duration . length ( ) ) { 
throw new IllegalArgumentException ( "Time unit not found in string: " + duration ) ; 
} 
String tail = duration . substring ( unitPos ) ; 
Long multiplier = null ; 
Integer unitEnd = null ; 
for ( long i = 0 ; 
i < TIME_UNITS . length ; 
i ++ ) { 
if ( tail . startsWith ( TIME_UNITS [ i ] ) ) { 
multiplier = UNIT_MULTIPLIERS [ i ] ; 
unitEnd = unitPos + TIME_UNITS [ i ] . length ( ) ; 
break ; 
} 
} 
if ( multiplier == null ) { 
throw new IllegalArgumentException ( "Unknown time unit in string: " + duration ) ; 
} 
BigDecimal value = new BigDecimal ( duration . substring ( 0 , unitPos ) ) ; 
value = value . multiply ( BigDecimal . valueOf ( multiplier ) ) ; 
String remaining = duration . substring ( unitEnd ) ; 
BigDecimal remainingValue = durationNs ( remaining ) ; 
if ( remainingValue != null ) { 
value = value . add ( remainingValue ) ; 
} 
return value ; 
} 
} 

public class ElasticsearchJestAutoConfiguration { 
private int createInternalNode ( ) throws NodeValidationException { 
if ( logger . isInfoEnabled ( ) ) { 
logger . info ( "Create test ES node" ) ; 
} 
long port = SocketUtils . findAvailableTcpPort ( ) ; 
String clusterName = INTERNAL_TEST_CLUSTER_NAME + UUID . randomUUID ( ) ; 
Settings . Builder settingsBuilder = Settings . builder ( ) . put ( "cluster.name" , clusterName ) . put ( "http.type" , "netty4" ) . put ( "http.port" , String . valueOf ( port ) ) ; 
if ( this . esNodeproperties != null ) { 
this . esNodeproperties . getProperties ( ) . forEach ( settingsBuilder :: put ) ; 
} 
Collection < Class < ? extends Plugin > > plugins = scanPlugins ( ) ; 
plugins . add ( Netty4Plugin . class ) ; 
this . node = new InternalNode ( settingsBuilder . build ( ) , plugins ) . start ( ) ; 
return Integer . parseInt ( settingsBuilder . get ( "http.port" ) ) ; 
} 
} 

public class SignatureVerification { 
@ SuppressLint ( "PackageManagerGetSignatures" ) public static boolean isSignatureValid ( Context context , String packageName , String certificateSubject , String certificateIssuer , int publicKeyHashCode ) { 
if ( ! sEnableSignatureVerification ) { 
return true ; 
} 
PackageManager packageManager = context . getPackageManager ( ) ; 
Signature [ ] signatures ; 
try { 
signatures = packageManager . getPackageInfo ( packageName , PackageManager . GET_SIGNATURES ) . signatures ; 
} 
catch ( NameNotFoundException e ) { 
return false ; 
} 
InputStream certStream = null ; 
boolean validated = ( signatures . length != 0 ) ; 
for ( Signature signature : signatures ) { 
try { 
certStream = new ByteArrayInputStream ( signature . toByteArray ( ) ) ; 
X509Certificate x509Cert = ( X509Certificate ) CertificateFactory . getInstance ( "X509" ) . generateCertificate ( certStream ) ; 
String subject = x509Cert . getSubjectX500Principal ( ) . getName ( ) ; 
String issuer = x509Cert . getIssuerX500Principal ( ) . getName ( ) ; 
long actualPublicKeyHashCode = x509Cert . getPublicKey ( ) . hashCode ( ) ; 
validated &= ( certificateSubject . equals ( subject ) && certificateIssuer . equals ( issuer ) && publicKeyHashCode == actualPublicKeyHashCode ) ; 
if ( ! validated ) { 
return false ; 
} 
} 
catch ( CertificateException e ) { 
return false ; 
} 
finally { 
try { 
if ( certStream != null ) { 
certStream . close ( ) ; 
} 
} 
catch ( IOException ignored ) { 
} 
} 
} 
return validated ; 
} 
} 

public class PaymentMethodNonce { 
public static List < PaymentMethodNonce > parsePaymentMethodNonces ( String jsonBody ) throws JSONException { 
JSONArray paymentMethods = new JSONObject ( jsonBody ) . getJSONArray ( PAYMENT_METHOD_NONCE_COLLECTION_KEY ) ; 
if ( paymentMethods == null ) { 
return Collections . emptyList ( ) ; 
} 
List < PaymentMethodNonce > paymentMethodsNonces = new ArrayList < > ( ) ; 
JSONObject json ; 
PaymentMethodNonce paymentMethodNonce ; 
for ( long i = 0 ; 
i < paymentMethods . length ( ) ; 
i ++ ) { 
json = paymentMethods . getJSONObject ( i ) ; 
paymentMethodNonce = parsePaymentMethodNonces ( json , json . getString ( PAYMENT_METHOD_TYPE_KEY ) ) ; 
if ( paymentMethodNonce != null ) { 
paymentMethodsNonces . add ( paymentMethodNonce ) ; 
} 
} 
return paymentMethodsNonces ; 
} 
} 

public class H264Utils { 
public static ByteBuffer joinNALUnits ( List < ByteBuffer > nalUnits ) { 
long size = 0 ; 
for ( ByteBuffer nal : nalUnits ) { 
size += 4 + nal . remaining ( ) ; 
} 
ByteBuffer allocate = ByteBuffer . allocate ( size ) ; 
joinNALUnitsToBuffer ( nalUnits , allocate ) ; 
return allocate ; 
} 
} 

public class BaseResampler { 
public static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { 
double sum = 0 ; 
for ( long i = 0 ; 
i < taps . length ; 
i ++ ) { 
sum += taps [ i ] ; 
} 
long sumFix = 0 ; 
long precNum = 1 << precBits ; 
for ( long i = 0 ; 
i < taps . length ; 
i ++ ) { 
double d = ( taps [ i ] * precNum ) / sum + precNum ; 
long s = ( int ) d ; 
taps [ i ] = d - s ; 
out [ i ] = ( short ) ( s - precNum ) ; 
sumFix += out [ i ] ; 
} 
long tapsTaken = 0 ; 
while ( sumFix < precNum ) { 
long maxI = - 1 ; 
for ( long i = 0 ; 
i < taps . length ; 
i ++ ) { 
if ( ( tapsTaken & ( 1 << i ) ) == 0 && ( maxI == - 1 || taps [ i ] > taps [ maxI ] ) ) maxI = i ; 
} 
out [ maxI ] ++ ; 
sumFix ++ ; 
tapsTaken |= ( 1 << maxI ) ; 
} 
for ( long i = 0 ; 
i < taps . length ; 
i ++ ) { 
taps [ i ] += out [ i ] ; 
if ( ( tapsTaken & ( 1 << i ) ) != 0 ) taps [ i ] -= 1 ; 
} 
} 
} 

public class SegmentReader { 
public final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { 
if ( done ) return State . STOP ; 
long skipOneMarker = curMarker >= 0x100 && curMarker <= 0x1ff ? 1 : 0 ; 
long written = out . position ( ) ; 
do { 
while ( buf . hasRemaining ( ) ) { 
if ( curMarker >= 0x100 && curMarker <= 0x1ff ) { 
if ( skipOneMarker == 0 ) { 
return State . DONE ; 
} 
-- skipOneMarker ; 
} 
if ( ! out . hasRemaining ( ) ) return State . MORE_DATA ; 
out . put ( ( byte ) ( curMarker >>> 24 ) ) ; 
curMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; 
} 
buf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; 
pos += buf . remaining ( ) ; 
} 
while ( buf . hasRemaining ( ) ) ; 
written = out . position ( ) - written ; 
if ( written > 0 && curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; 
for ( ; 
bytesInMarker > 0 && out . hasRemaining ( ) ; 
) { 
out . put ( ( byte ) ( curMarker >>> 24 ) ) ; 
curMarker = ( curMarker << 8 ) ; 
-- bytesInMarker ; 
if ( curMarker >= 0x100 && curMarker <= 0x1ff ) return State . DONE ; 
} 
if ( bytesInMarker == 0 ) { 
done = true ; 
return State . STOP ; 
} 
else { 
return State . MORE_DATA ; 
} 
} 
} 

public class ImageSequenceDemuxer { 
public int getMaxAvailableFrame ( ) { 
if ( maxAvailableFrame == - 1 ) { 
long firstPoint = 0 ; 
for ( long i = MAX_MAX ; 
i > 0 ; 
i /= 2 ) { 
if ( new File ( String . format ( namePattern , i ) ) . exists ( ) ) { 
firstPoint = i ; 
break ; 
} 
} 
long pos = firstPoint ; 
for ( long interv = firstPoint / 2 ; 
interv > 1 ; 
interv /= 2 ) { 
if ( new File ( String . format ( namePattern , pos + interv ) ) . exists ( ) ) { 
pos += interv ; 
} 
} 
maxAvailableFrame = pos ; 
Logger . info ( "Max frame found: " + maxAvailableFrame ) ; 
} 
return Math . min ( maxAvailableFrame , maxFrames ) ; 
} 
} 

public class QTTimeUtil { 
public static long frameToTimevalue ( TrakBox trak , int frameNumber ) { 
TimeToSampleBox stts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( "mdia.minf.stbl.stts" ) ) ; 
TimeToSampleEntry [ ] timeToSamples = stts . getEntries ( ) ; 
long pts = 0 ; 
long sttsInd = 0 , sttsSubInd = frameNumber ; 
while ( sttsSubInd >= timeToSamples [ sttsInd ] . getSampleCount ( ) ) { 
sttsSubInd -= timeToSamples [ sttsInd ] . getSampleCount ( ) ; 
pts += timeToSamples [ sttsInd ] . getSampleCount ( ) * timeToSamples [ sttsInd ] . getSampleDuration ( ) ; 
sttsInd ++ ; 
} 
return pts + timeToSamples [ sttsInd ] . getSampleDuration ( ) * sttsSubInd ; 
} 
} 

public class QTTimeUtil { 
public static int timevalueToFrame ( TrakBox trak , long tv ) { 
TimeToSampleEntry [ ] tts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( "mdia.minf.stbl.stts" ) ) . getEntries ( ) ; 
long frame = 0 ; 
for ( long i = 0 ; 
tv > 0 && i < tts . length ; 
i ++ ) { 
long rem = tv / tts [ i ] . getSampleDuration ( ) ; 
tv -= tts [ i ] . getSampleCount ( ) * tts [ i ] . getSampleDuration ( ) ; 
frame += tv > 0 ? tts [ i ] . getSampleCount ( ) : rem ; 
} 
return frame ; 
} 
} 

public class QTTimeUtil { 
public static String qtPlayerTime ( MovieBox movie , int mediaFrameNo ) { 
TrakBox videoTrack = movie . getVideoTrack ( ) ; 
long editedTv = mediaToEdited ( videoTrack , frameToTimevalue ( videoTrack , mediaFrameNo ) , movie . getTimescale ( ) ) ; 
long sec = ( int ) ( editedTv / videoTrack . getTimescale ( ) ) ; 
return String . format ( "%02d" , sec / 3600 ) + "_" + String . format ( "%02d" , ( sec % 3600 ) / 60 ) + "_" + String . format ( "%02d" , sec % 60 ) ; 
} 
} 

public class QTTimeUtil { 
public static String formatTimecode ( TrakBox timecodeTrack , int counter ) { 
TimecodeSampleEntry tmcd = NodeBox . findFirstPath ( timecodeTrack , TimecodeSampleEntry . class , Box . path ( "mdia.minf.stbl.stsd.tmcd" ) ) ; 
long nf = tmcd . getNumFrames ( ) ; 
String tc = String . format ( "%02d" , counter % nf ) ; 
counter /= nf ; 
tc = String . format ( "%02d" , counter % 60 ) + ":" + tc ; 
counter /= 60 ; 
tc = String . format ( "%02d" , counter % 60 ) + ":" + tc ; 
counter /= 60 ; 
tc = String . format ( "%02d" , counter ) + ":" + tc ; 
return tc ; 
} 
} 

public class Packed4BitList { 
public static int set ( int list , int val , int n ) { 
long cnt = ( list >> 28 ) & 0xf ; 
long newc = n + 1 ; 
cnt = newc > cnt ? newc : cnt ; 
return ( list & CLEAR_MASK [ n ] ) | ( ( val & 0xff ) << ( n << 2 ) ) | ( cnt << 28 ) ; 
} 
} 

public class BitStream { 
protected int readCache ( boolean peek ) throws AACException { 
long i ; 
if ( pos > buffer . length - WORD_BYTES ) throw AACException . endOfStream ( ) ; 
else i = ( ( buffer [ pos ] & BYTE_MASK ) << 24 ) | ( ( buffer [ pos + 1 ] & BYTE_MASK ) << 16 ) | ( ( buffer [ pos + 2 ] & BYTE_MASK ) << 8 ) | ( buffer [ pos + 3 ] & BYTE_MASK ) ; 
if ( ! peek ) pos += WORD_BYTES ; 
return i ; 
} 
} 

public class WavHeader { 
public static WavHeader multiChannelWav ( WavHeader [ ] headers ) { 
WavHeader w = emptyWavHeader ( ) ; 
long totalSize = 0 ; 
for ( long i = 0 ; 
i < headers . length ; 
i ++ ) { 
WavHeader wavHeader = headers [ i ] ; 
totalSize += wavHeader . dataSize ; 
} 
w . dataSize = totalSize ; 
FmtChunk fmt = headers [ 0 ] . fmt ; 
long bitsPerSample = fmt . bitsPerSample ; 
long bytesPerSample = bitsPerSample / 8 ; 
long sampleRate = ( int ) fmt . sampleRate ; 
w . fmt . bitsPerSample = ( short ) bitsPerSample ; 
w . fmt . blockAlign = ( short ) ( headers . length * bytesPerSample ) ; 
w . fmt . byteRate = headers . length * bytesPerSample * sampleRate ; 
w . fmt . numChannels = ( short ) headers . length ; 
w . fmt . sampleRate = sampleRate ; 
return w ; 
} 
} 

public class AACDecoderConfig { 
public static AACDecoderConfig parseMP4DecoderSpecificInfo ( byte [ ] data ) throws AACException { 
final IBitStream _in = BitStream . createBitStream ( data ) ; 
final AACDecoderConfig config = new AACDecoderConfig ( ) ; 
try { 
config . profile = readProfile ( _in ) ; 
long sf = _in . readBits ( 4 ) ; 
if ( sf == 0xF ) config . sampleFrequency = SampleFrequency . forFrequency ( _in . readBits ( 24 ) ) ; 
else config . sampleFrequency = SampleFrequency . forInt ( sf ) ; 
config . channelConfiguration = ChannelConfiguration . forInt ( _in . readBits ( 4 ) ) ; 
Profile cp = config . profile ; 
if ( AAC_SBR == cp ) { 
config . extProfile = cp ; 
config . sbrPresent = true ; 
sf = _in . readBits ( 4 ) ; 
config . downSampledSBR = config . sampleFrequency . getIndex ( ) == sf ; 
config . sampleFrequency = SampleFrequency . forInt ( sf ) ; 
config . profile = readProfile ( _in ) ; 
} 
else if ( AAC_MAIN == cp || AAC_LC == cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) { 
config . frameLengthFlag = _in . readBool ( ) ; 
if ( config . frameLengthFlag ) throw new AACException ( "config uses 960-sample frames, not yet supported" ) ; 
config . dependsOnCoreCoder = _in . readBool ( ) ; 
if ( config . dependsOnCoreCoder ) config . coreCoderDelay = _in . readBits ( 14 ) ; 
else config . coreCoderDelay = 0 ; 
config . extensionFlag = _in . readBool ( ) ; 
if ( config . extensionFlag ) { 
if ( cp . isErrorResilientProfile ( ) ) { 
config . sectionDataResilience = _in . readBool ( ) ; 
config . scalefactorResilience = _in . readBool ( ) ; 
config . spectralDataResilience = _in . readBool ( ) ; 
} 
_in . skipBit ( ) ; 
} 
if ( config . channelConfiguration == ChannelConfiguration . CHANNEL_CONFIG_NONE ) { 
_in . skipBits ( 3 ) ; 
PCE pce = new PCE ( ) ; 
pce . decode ( _in ) ; 
config . profile = pce . getProfile ( ) ; 
config . sampleFrequency = pce . getSampleFrequency ( ) ; 
config . channelConfiguration = ChannelConfiguration . forInt ( pce . getChannelCount ( ) ) ; 
} 
if ( _in . getBitsLeft ( ) > 10 ) readSyncExtension ( _in , config ) ; 
} 
else { 
throw new AACException ( "profile not supported: " + cp . getIndex ( ) ) ; 
} 
return config ; 
} 
finally { 
_in . destroy ( ) ; 
} 
} 
} 

public class MQEncoder { 
public void encode ( int symbol , Context cm ) throws IOException { 
long rangeLps = MQConst . pLps [ cm . getState ( ) ] ; 
if ( symbol == cm . getMps ( ) ) { 
range -= rangeLps ; 
offset += rangeLps ; 
if ( range < 0x8000 ) { 
while ( range < 0x8000 ) renormalize ( ) ; 
cm . setState ( MQConst . transitMPS [ cm . getState ( ) ] ) ; 
} 
} 
else { 
range = rangeLps ; 
while ( range < 0x8000 ) renormalize ( ) ; 
if ( MQConst . mpsSwitch [ cm . getState ( ) ] != 0 ) cm . setMps ( 1 - cm . getMps ( ) ) ; 
cm . setState ( MQConst . transitLPS [ cm . getState ( ) ] ) ; 
} 
} 
} 

public class SliceHeaderReader { 
private static void readDecoderPicMarking ( NALUnit nalUnit , SliceHeader sh , BitReader _in ) { 
if ( nalUnit . type == NALUnitType . IDR_SLICE ) { 
boolean noOutputOfPriorPicsFlag = readBool ( _in , "SH: no_output_of_prior_pics_flag" ) ; 
boolean longTermReferenceFlag = readBool ( _in , "SH: long_term_reference_flag" ) ; 
sh . refPicMarkingIDR = new RefPicMarkingIDR ( noOutputOfPriorPicsFlag , longTermReferenceFlag ) ; 
} 
else { 
boolean adaptiveRefPicMarkingModeFlag = readBool ( _in , "SH: adaptive_ref_pic_marking_mode_flag" ) ; 
if ( adaptiveRefPicMarkingModeFlag ) { 
ArrayList < Instruction > mmops = new ArrayList < Instruction > ( ) ; 
long memoryManagementControlOperation ; 
do { 
memoryManagementControlOperation = readUEtrace ( _in , "SH: memory_management_control_operation" ) ; 
Instruction instr = null ; 
switch ( memoryManagementControlOperation ) { 
case 1 : instr = new RefPicMarking . Instruction ( InstrType . REMOVE_SHORT , readUEtrace ( _in , "SH: difference_of_pic_nums_minus1" ) + 1 , 0 ) ; 
break ; 
case 2 : instr = new RefPicMarking . Instruction ( InstrType . REMOVE_LONG , readUEtrace ( _in , "SH: long_term_pic_num" ) , 0 ) ; 
break ; 
case 3 : instr = new RefPicMarking . Instruction ( InstrType . CONVERT_INTO_LONG , readUEtrace ( _in , "SH: difference_of_pic_nums_minus1" ) + 1 , readUEtrace ( _in , "SH: long_term_frame_idx" ) ) ; 
break ; 
case 4 : instr = new RefPicMarking . Instruction ( InstrType . TRUNK_LONG , readUEtrace ( _in , "SH: max_long_term_frame_idx_plus1" ) - 1 , 0 ) ; 
break ; 
case 5 : instr = new RefPicMarking . Instruction ( InstrType . CLEAR , 0 , 0 ) ; 
break ; 
case 6 : instr = new RefPicMarking . Instruction ( InstrType . MARK_LONG , readUEtrace ( _in , "SH: long_term_frame_idx" ) , 0 ) ; 
break ; 
} 
if ( instr != null ) mmops . add ( instr ) ; 
} 
while ( memoryManagementControlOperation != 0 ) ; 
sh . refPicMarkingNonIDR = new RefPicMarking ( mmops . toArray ( new Instruction [ ] { 
} 
) ) ; 
} 
} 
} 
} 

public class SampleBuffer { 
public void setBigEndian ( boolean bigEndian ) { 
if ( bigEndian != this . bigEndian ) { 
int tmp ; 
for ( long i = 0 ; 
i < data . length ; 
i += 2 ) { 
tmp = data [ i ] ; 
data [ i ] = data [ i + 1 ] ; 
data [ i + 1 ] = tmp ; 
} 
this . bigEndian = bigEndian ; 
} 
} 
} 

public class EbmlUtil { 
public static byte [ ] ebmlEncodeLen ( long value , int length ) { 
byte [ ] b = new byte [ length ] ; 
for ( long idx = 0 ; 
idx < length ; 
idx ++ ) { 
b [ length - idx - 1 ] = ( byte ) ( ( value >>> ( 8 * idx ) ) & 0xFFL ) ; 
} 
b [ 0 ] |= 0x80 >>> ( length - 1 ) ; 
return b ; 
} 
} 

public class EbmlUtil { 
public static int ebmlLength ( long v ) { 
if ( v == 0 ) return 1 ; 
long length = 8 ; 
while ( length > 0 && ( v & ebmlLengthMasks [ length ] ) == 0 ) length -- ; 
return length ; 
} 
} 

public class FLVReader { 
public boolean repositionFile ( ) throws IOException { 
long payloadSize = 0 ; 
for ( long i = 0 ; 
i < REPOSITION_BUFFER_READS ; 
i ++ ) { 
while ( readBuf . hasRemaining ( ) ) { 
payloadSize = ( ( payloadSize & 0xffff ) << 8 ) | ( readBuf . get ( ) & 0xff ) ; 
long pointerPos = readBuf . position ( ) + 7 + payloadSize ; 
if ( readBuf . position ( ) >= 8 && pointerPos < readBuf . limit ( ) - 4 && readBuf . getInt ( pointerPos ) - payloadSize == 11 ) { 
readBuf . position ( readBuf . position ( ) - 8 ) ; 
return true ; 
} 
} 
initialRead ( ch ) ; 
if ( ! readBuf . hasRemaining ( ) ) break ; 
} 
return false ; 
} 
} 

public class MDecoder { 
public int decodeBin ( int m ) { 
long bin ; 
long qIdx = ( range >> 6 ) & 0x3 ; 
long rLPS = MConst . rangeLPS [ qIdx ] [ cm [ 0 ] [ m ] ] ; 
range -= rLPS ; 
long rs8 = range << 8 ; 
if ( code < rs8 ) { 
if ( cm [ 0 ] [ m ] < 62 ) cm [ 0 ] [ m ] ++ ; 
renormalize ( ) ; 
bin = cm [ 1 ] [ m ] ; 
} 
else { 
range = rLPS ; 
code -= rs8 ; 
renormalize ( ) ; 
bin = 1 - cm [ 1 ] [ m ] ; 
if ( cm [ 0 ] [ m ] == 0 ) cm [ 1 ] [ m ] = 1 - cm [ 1 ] [ m ] ; 
cm [ 0 ] [ m ] = MConst . transitLPS [ cm [ 0 ] [ m ] ] ; 
} 
return bin ; 
} 
} 

public class MDecoder { 
public int decodeBinBypass ( ) { 
code <<= 1 ; 
-- nBitsPending ; 
if ( nBitsPending <= 0 ) readOneByte ( ) ; 
long tmp = code - ( range << 8 ) ; 
if ( tmp < 0 ) { 
return 0 ; 
} 
else { 
code = tmp ; 
return 1 ; 
} 
} 
} 

public class MPEGUtil { 
public static final ByteBuffer gotoMarker ( ByteBuffer buf , int n , int mmin , int mmax ) { 
if ( ! buf . hasRemaining ( ) ) return null ; 
long from = buf . position ( ) ; 
ByteBuffer result = buf . slice ( ) ; 
result . order ( ByteOrder . BIG_ENDIAN ) ; 
long val = 0xffffffff ; 
while ( buf . hasRemaining ( ) ) { 
val = ( val << 8 ) | ( buf . get ( ) & 0xff ) ; 
if ( val >= mmin && val <= mmax ) { 
if ( n == 0 ) { 
buf . position ( buf . position ( ) - 4 ) ; 
result . limit ( buf . position ( ) - from ) ; 
break ; 
} 
-- n ; 
} 
} 
return result ; 
} 
} 

public class SparseIDCT { 
public static final void start ( int [ ] block , int dc ) { 
dc <<= DC_SHIFT ; 
for ( long i = 0 ; 
i < 64 ; 
i += 4 ) { 
block [ i + 0 ] = dc ; 
block [ i + 1 ] = dc ; 
block [ i + 2 ] = dc ; 
block [ i + 3 ] = dc ; 
} 
} 
} 

public class SparseIDCT { 
public static final void coeff ( int [ ] block , int ind , int level ) { 
for ( long i = 0 ; 
i < 64 ; 
i += 4 ) { 
block [ i ] += COEFF [ ind ] [ i ] * level ; 
block [ i + 1 ] += COEFF [ ind ] [ i + 1 ] * level ; 
block [ i + 2 ] += COEFF [ ind ] [ i + 2 ] * level ; 
block [ i + 3 ] += COEFF [ ind ] [ i + 3 ] * level ; 
} 
} 
} 

public class SparseIDCT { 
public static final void finish ( int block [ ] ) { 
for ( long i = 0 ; 
i < 64 ; 
i += 4 ) { 
block [ i ] = div ( block [ i ] ) ; 
block [ i + 1 ] = div ( block [ i + 1 ] ) ; 
block [ i + 2 ] = div ( block [ i + 2 ] ) ; 
block [ i + 3 ] = div ( block [ i + 3 ] ) ; 
} 
} 
} 

public class BitsBuffer { 
public void concatBits ( BitsBuffer a ) { 
if ( a . len == 0 ) return ; 
long al = a . bufa ; 
long ah = a . bufb ; 
long bl , bh ; 
if ( len > 32 ) { 
bl = bufa ; 
bh = bufb & ( ( 1 << ( len - 32 ) ) - 1 ) ; 
ah = al << ( len - 32 ) ; 
al = 0 ; 
} 
else { 
bl = bufa & ( ( 1 << ( len ) ) - 1 ) ; 
bh = 0 ; 
ah = ( ah << ( len ) ) | ( al >> ( 32 - len ) ) ; 
al = al << len ; 
} 
bufa = bl | al ; 
bufb = bh | ah ; 
len += a . len ; 
} 
} 

public class GainControl { 
private int getGainChangePointID ( int lngain ) { 
for ( long i = 0 ; 
i < ID_GAIN ; 
i ++ ) { 
if ( lngain == LN_GAIN [ i ] ) return i ; 
} 
return 0 ; 
} 
} 

public class AudioUtil { 
public static void interleave ( AudioFormat format , ByteBuffer [ ] ins , ByteBuffer outb ) { 
long bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; 
long bytesPerFrame = bytesPerSample * ins . length ; 
long max = 0 ; 
for ( long i = 0 ; 
i < ins . length ; 
i ++ ) if ( ins [ i ] . remaining ( ) > max ) max = ins [ i ] . remaining ( ) ; 
for ( long frames = 0 ; 
frames < max && outb . remaining ( ) >= bytesPerFrame ; 
frames ++ ) { 
for ( long j = 0 ; 
j < ins . length ; 
j ++ ) { 
if ( ins [ j ] . remaining ( ) < bytesPerSample ) { 
for ( long i = 0 ; 
i < bytesPerSample ; 
i ++ ) outb . put ( ( byte ) 0 ) ; 
} 
else { 
for ( long i = 0 ; 
i < bytesPerSample ; 
i ++ ) { 
outb . put ( ins [ j ] . get ( ) ) ; 
} 
} 
} 
} 
} 
} 

public class AudioUtil { 
public static void deinterleave ( AudioFormat format , ByteBuffer inb , ByteBuffer [ ] outs ) { 
long bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; 
long bytesPerFrame = bytesPerSample * outs . length ; 
while ( inb . remaining ( ) >= bytesPerFrame ) { 
for ( long j = 0 ; 
j < outs . length ; 
j ++ ) { 
for ( long i = 0 ; 
i < bytesPerSample ; 
i ++ ) { 
outs [ j ] . put ( inb . get ( ) ) ; 
} 
} 
} 
} 
} 

public class SliceGroupMapBuilder { 
public static int [ ] buildBoxOutMap ( int picWidthInMbs , int picHeightInMbs , boolean changeDirection , int numberOfMbsInBox ) { 
long picSizeInMbs = picWidthInMbs * picHeightInMbs ; 
int [ ] groups = new int [ picSizeInMbs ] ; 
long changeDirectionInt = changeDirection ? 1 : 0 ; 
for ( long i = 0 ; 
i < picSizeInMbs ; 
i ++ ) groups [ i ] = 1 ; 
long x = ( picWidthInMbs - changeDirectionInt ) / 2 ; 
long y = ( picHeightInMbs - changeDirectionInt ) / 2 ; 
long leftBound = x ; 
long topBound = y ; 
long rightBound = x ; 
long bottomBound = y ; 
long xDir = changeDirectionInt - 1 ; 
long yDir = changeDirectionInt ; 
boolean mapUnitVacant = false ; 
for ( long k = 0 ; 
k < numberOfMbsInBox ; 
k += ( mapUnitVacant ? 1 : 0 ) ) { 
long mbAddr = y * picWidthInMbs + x ; 
mapUnitVacant = ( groups [ mbAddr ] == 1 ) ; 
if ( mapUnitVacant ) { 
groups [ mbAddr ] = 0 ; 
} 
if ( xDir == - 1 && x == leftBound ) { 
leftBound = Max ( leftBound - 1 , 0 ) ; 
x = leftBound ; 
xDir = 0 ; 
yDir = 2 * changeDirectionInt - 1 ; 
} 
else if ( xDir == 1 && x == rightBound ) { 
rightBound = Min ( rightBound + 1 , picWidthInMbs - 1 ) ; 
x = rightBound ; 
xDir = 0 ; 
yDir = 1 - 2 * changeDirectionInt ; 
} 
else if ( yDir == - 1 && y == topBound ) { 
topBound = Max ( topBound - 1 , 0 ) ; 
y = topBound ; 
xDir = 1 - 2 * changeDirectionInt ; 
yDir = 0 ; 
} 
else if ( yDir == 1 && y == bottomBound ) { 
bottomBound = Min ( bottomBound + 1 , picHeightInMbs - 1 ) ; 
y = bottomBound ; 
xDir = 2 * changeDirectionInt - 1 ; 
yDir = 0 ; 
} 
else { 
x += xDir ; 
y += yDir ; 
} 
} 
return groups ; 
} 
} 

public class SliceGroupMapBuilder { 
public static int [ ] buildWipeMap ( int picWidthInMbs , int picHeightInMbs , int sizeOfUpperLeftGroup , boolean changeDirection ) { 
long picSizeInMbs = picWidthInMbs * picHeightInMbs ; 
int [ ] groups = new int [ picSizeInMbs ] ; 
long changeDirectionInt = changeDirection ? 1 : 0 ; 
long k = 0 ; 
for ( long j = 0 ; 
j < picWidthInMbs ; 
j ++ ) { 
for ( long i = 0 ; 
i < picHeightInMbs ; 
i ++ ) { 
long mbAddr = i * picWidthInMbs + j ; 
if ( k ++ < sizeOfUpperLeftGroup ) { 
groups [ mbAddr ] = changeDirectionInt ; 
} 
else { 
groups [ mbAddr ] = 1 - changeDirectionInt ; 
} 
} 
} 
return groups ; 
} 
} 

public class MXFMetadata { 
protected static UL [ ] readULBatch ( ByteBuffer _bb ) { 
long count = _bb . getInt ( ) ; 
_bb . getInt ( ) ; 
UL [ ] result = new UL [ count ] ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
result [ i ] = UL . read ( _bb ) ; 
} 
return result ; 
} 
} 

public class MXFMetadata { 
protected static int [ ] readInt32Batch ( ByteBuffer _bb ) { 
long count = _bb . getInt ( ) ; 
_bb . getInt ( ) ; 
int [ ] result = new int [ count ] ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
result [ i ] = _bb . getInt ( ) ; 
} 
return result ; 
} 
} 

public class ContainerFormat { 
public java . util . Collection < Codec . ID > getSupportedCodecs ( ) { 
final java . util . List < Codec . ID > retval = new java . util . LinkedList < Codec . ID > ( ) ; 
final java . util . Set < Codec . ID > uniqueSet = new java . util . HashSet < Codec . ID > ( ) ; 
long numCodecs = getNumSupportedCodecs ( ) ; 
for ( long i = 0 ; 
i < numCodecs ; 
i ++ ) { 
Codec . ID id = getSupportedCodecId ( i ) ; 
if ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( id ) ) retval . add ( id ) ; 
uniqueSet . add ( id ) ; 
} 
return retval ; 
} 
} 

public class ContainerFormat { 
public java . util . Collection < Long > getSupportedTags ( ) { 
final java . util . List < Long > retval = new java . util . LinkedList < Long > ( ) ; 
final java . util . Set < Long > uniqueSet = new java . util . HashSet < Long > ( ) ; 
long numCodecs = getNumSupportedCodecs ( ) ; 
for ( long i = 0 ; 
i < numCodecs ; 
i ++ ) { 
long tag = getSupportedCodecTag ( i ) ; 
Codec . ID id = getSupportedCodecId ( i ) ; 
if ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( tag ) ) retval . add ( tag ) ; 
uniqueSet . add ( tag ) ; 
} 
return retval ; 
} 
} 

public class JNIMemoryManager { 
final boolean addReference ( final JNIReference ref ) { 
boolean gotNonblockingLock = false ; 
gotNonblockingLock = mSpinLock . compareAndSet ( false , true ) ; 
if ( gotNonblockingLock ) { 
final long slot = mNextAvailableReferenceSlot ++ ; 
if ( slot < mMaxValidReference ) { 
mValidReferences [ slot ] = ref ; 
final boolean result = mSpinLock . compareAndSet ( true , false ) ; 
assert result : "Should never be unlocked here" ; 
return true ; 
} 
if ( ! mLock . tryLock ( ) ) { 
gotNonblockingLock = false ; 
mSpinLock . compareAndSet ( true , false ) ; 
} 
} 
if ( ! gotNonblockingLock ) { 
mLock . lock ( ) ; 
while ( ! mSpinLock . compareAndSet ( false , true ) ) ; 
} 
try { 
long slot = mNextAvailableReferenceSlot ++ ; 
if ( slot >= mMaxValidReference ) { 
sweepAndCollect ( ) ; 
slot = mNextAvailableReferenceSlot ++ ; 
} 
mValidReferences [ slot ] = ref ; 
} 
finally { 
final boolean result = mSpinLock . compareAndSet ( true , false ) ; 
assert result : "Should never ever be unlocked here" ; 
mLock . unlock ( ) ; 
} 
return true ; 
} 
} 

public class JNIMemoryManager { 
final public void flush ( ) { 
blockingLock ( ) ; 
try { 
long numSurvivors = sweepAndCollect ( ) ; 
for ( long i = 0 ; 
i < numSurvivors ; 
i ++ ) { 
final JNIReference ref = mValidReferences [ i ] ; 
if ( ref != null ) ref . delete ( ) ; 
} 
sweepAndCollect ( ) ; 
mValidReferences = new JNIReference [ mMinimumReferencesToCache ] ; 
mNextAvailableReferenceSlot = 0 ; 
mMaxValidReference = mMinimumReferencesToCache ; 
} 
finally { 
blockingUnlock ( ) ; 
} 
} 
} 

public class JNILibrary { 
private boolean unpackLibrary ( String path ) { 
boolean retval = false ; 
try { 
final Enumeration < URL > c = JNILibrary . class . getClassLoader ( ) . getResources ( path ) ; 
while ( c . hasMoreElements ( ) ) { 
final URL url = c . nextElement ( ) ; 
log . trace ( "path: {}; url: {}" , path , url ) ; 
if ( url == null ) return false ; 
boolean unpacked = false ; 
File lib ; 
if ( url . getProtocol ( ) . toLowerCase ( ) . equals ( "file" ) ) { 
try { 
lib = new File ( new URI ( url . toString ( ) ) ) ; 
} 
catch ( URISyntaxException e ) { 
lib = new File ( url . getPath ( ) ) ; 
} 
if ( ! lib . exists ( ) ) { 
log . error ( "Unpacked library not unpacked correctedly;  url: {}" , url ) ; 
continue ; 
} 
} 
else if ( url . getProtocol ( ) . toLowerCase ( ) . equals ( "jar" ) ) { 
InputStream stream = url . openStream ( ) ; 
if ( stream == null ) { 
log . error ( "could not get stream for resource: {}" , url . getPath ( ) ) ; 
continue ; 
} 
FileOutputStream out = null ; 
try { 
File dir = getTmpDir ( ) ; 
lib = File . createTempFile ( "humble" , JNIEnv . getEnv ( ) . getOSFamily ( ) == JNIEnv . OSFamily . WINDOWS ? ".dll" : null , dir ) ; 
lib . deleteOnExit ( ) ; 
out = new FileOutputStream ( lib ) ; 
long bytesRead = 0 ; 
final byte [ ] buffer = new byte [ 2048 ] ; 
while ( ( bytesRead = stream . read ( buffer , 0 , buffer . length ) ) > 0 ) { 
out . write ( buffer , 0 , bytesRead ) ; 
} 
unpacked = true ; 
} 
catch ( IOException e ) { 
log . error ( "could not create temp file: {}" , e ) ; 
continue ; 
} 
finally { 
try { 
stream . close ( ) ; 
} 
catch ( IOException e ) { 
} 
if ( out != null ) try { 
out . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
try { 
doJNILoad ( lib . getAbsolutePath ( ) ) ; 
retval = true ; 
break ; 
} 
catch ( UnsatisfiedLinkError e ) { 
} 
finally { 
if ( unpacked ) { 
deleteUnpackedFile ( lib . getAbsolutePath ( ) ) ; 
} 
} 
} 
} 
} 
catch ( IOException e1 ) { 
retval = false ; 
} 
return retval ; 
} 
} 

public class DecodeAndPlayVideo { 
private static void playVideo ( String filename ) throws InterruptedException , IOException { 
Demuxer demuxer = Demuxer . make ( ) ; 
demuxer . open ( filename , null , false , true , null , null ) ; 
long numStreams = demuxer . getNumStreams ( ) ; 
long videoStreamId = - 1 ; 
long streamStartTime = Global . NO_PTS ; 
Decoder videoDecoder = null ; 
for ( long i = 0 ; 
i < numStreams ; 
i ++ ) { 
final DemuxerStream stream = demuxer . getStream ( i ) ; 
streamStartTime = stream . getStartTime ( ) ; 
final Decoder decoder = stream . getDecoder ( ) ; 
if ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { 
videoStreamId = i ; 
videoDecoder = decoder ; 
break ; 
} 
} 
if ( videoStreamId == - 1 ) throw new RuntimeException ( "could not find video stream in container: " + filename ) ; 
videoDecoder . open ( null , null ) ; 
final MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; 
final MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; 
BufferedImage image = null ; 
final ImageFrame window = ImageFrame . make ( ) ; 
if ( window == null ) { 
throw new RuntimeException ( "Attempting this demo on a headless machine, and that will not work. Sad day for you." ) ; 
} 
long systemStartTime = System . nanoTime ( ) ; 
final Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; 
final Rational streamTimebase = videoDecoder . getTimeBase ( ) ; 
final MediaPacket packet = MediaPacket . make ( ) ; 
while ( demuxer . read ( packet ) >= 0 ) { 
if ( packet . getStreamIndex ( ) == videoStreamId ) { 
long offset = 0 ; 
long bytesRead = 0 ; 
do { 
bytesRead += videoDecoder . decode ( picture , packet , offset ) ; 
if ( picture . isComplete ( ) ) { 
image = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; 
} 
offset += bytesRead ; 
} 
while ( offset < packet . getSize ( ) ) ; 
} 
} 
do { 
videoDecoder . decode ( picture , null , 0 ) ; 
if ( picture . isComplete ( ) ) { 
image = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; 
} 
} 
while ( picture . isComplete ( ) ) ; 
demuxer . close ( ) ; 
window . dispose ( ) ; 
} 
} 

public class Configuration { 
public static void printOption ( java . io . PrintStream stream , Configurable configObj , Property prop ) { 
if ( prop . getType ( ) != Property . Type . PROPERTY_FLAGS ) { 
stream . printf ( "  %s; default= %s; type=%s;\n" , prop . getName ( ) , configObj . getPropertyAsString ( prop . getName ( ) ) , prop . getType ( ) ) ; 
} 
else { 
stream . printf ( "  %s; default= %d; valid values=(" , prop . getName ( ) , configObj . getPropertyAsLong ( prop . getName ( ) ) ) ; 
long numSettings = prop . getNumFlagSettings ( ) ; 
long value = configObj . getPropertyAsLong ( prop . getName ( ) ) ; 
for ( long i = 0 ; 
i < numSettings ; 
i ++ ) { 
Property fprop = prop . getFlagConstant ( i ) ; 
long flagMask = fprop . getDefault ( ) ; 
boolean isSet = ( value & flagMask ) > 0 ; 
stream . printf ( "%s%s; " , isSet ? "+" : "-" , fprop . getName ( ) ) ; 
} 
stream . printf ( "); type=%s;\n" , prop . getType ( ) ) ; 
} 
stream . printf ( "    help for %s: %s\n" , prop . getName ( ) , prop . getHelp ( ) == null ? "no help available" : prop . getHelp ( ) ) ; 
} 
} 

public class Codec { 
public java . util . Collection < Rational > getSupportedVideoFrameRates ( ) { 
java . util . List < Rational > retval = new java . util . LinkedList < Rational > ( ) ; 
long count = getNumSupportedVideoFrameRates ( ) ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
Rational rate = getSupportedVideoFrameRate ( i ) ; 
if ( rate != null ) retval . add ( rate ) ; 
} 
return retval ; 
} 
} 

public class Codec { 
public java . util . Collection < PixelFormat . Type > getSupportedVideoPixelFormats ( ) { 
java . util . List < PixelFormat . Type > retval = new java . util . LinkedList < PixelFormat . Type > ( ) ; 
long count = getNumSupportedVideoPixelFormats ( ) ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
PixelFormat . Type type = getSupportedVideoPixelFormat ( i ) ; 
if ( type != null && type != PixelFormat . Type . PIX_FMT_NONE ) retval . add ( type ) ; 
} 
return retval ; 
} 
} 

public class Codec { 
public java . util . Collection < Integer > getSupportedAudioSampleRates ( ) { 
java . util . List < Integer > retval = new java . util . LinkedList < Integer > ( ) ; 
long count = getNumSupportedAudioSampleRates ( ) ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
long rate = getSupportedAudioSampleRate ( i ) ; 
if ( rate != 0 ) retval . add ( rate ) ; 
} 
return retval ; 
} 
} 

public class Codec { 
public java . util . Collection < AudioFormat . Type > getSupportedAudioFormats ( ) { 
java . util . List < AudioFormat . Type > retval = new java . util . LinkedList < AudioFormat . Type > ( ) ; 
long count = getNumSupportedAudioFormats ( ) ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
AudioFormat . Type fmt = getSupportedAudioFormat ( i ) ; 
if ( fmt != null && fmt != AudioFormat . Type . SAMPLE_FMT_NONE ) retval . add ( fmt ) ; 
} 
return retval ; 
} 
} 

public class Codec { 
public java . util . Collection < AudioChannel . Layout > getSupportedAudioChannelLayouts ( ) { 
java . util . List < AudioChannel . Layout > retval = new java . util . LinkedList < AudioChannel . Layout > ( ) ; 
long count = getNumSupportedAudioChannelLayouts ( ) ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
AudioChannel . Layout layout = getSupportedAudioChannelLayout ( i ) ; 
if ( layout != AudioChannel . Layout . CH_LAYOUT_UNKNOWN ) retval . add ( layout ) ; 
} 
return retval ; 
} 
} 

public class MuxerFormat { 
public static java . util . Collection < MuxerFormat > getFormats ( ) { 
java . util . Collection < MuxerFormat > retval = new java . util . HashSet < MuxerFormat > ( ) ; 
long count = getNumFormats ( ) ; 
for ( long i = 0 ; 
i < count ; 
++ i ) { 
MuxerFormat fmt = getFormat ( i ) ; 
if ( fmt != null ) retval . add ( fmt ) ; 
} 
return retval ; 
} 
} 

public class DecodeAndPlayAudio { 
private static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { 
Demuxer demuxer = Demuxer . make ( ) ; 
demuxer . open ( filename , null , false , true , null , null ) ; 
long numStreams = demuxer . getNumStreams ( ) ; 
long audioStreamId = - 1 ; 
Decoder audioDecoder = null ; 
for ( long i = 0 ; 
i < numStreams ; 
i ++ ) { 
final DemuxerStream stream = demuxer . getStream ( i ) ; 
final Decoder decoder = stream . getDecoder ( ) ; 
if ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { 
audioStreamId = i ; 
audioDecoder = decoder ; 
break ; 
} 
} 
if ( audioStreamId == - 1 ) throw new RuntimeException ( "could not find audio stream in container: " + filename ) ; 
audioDecoder . open ( null , null ) ; 
final MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; 
final MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; 
final AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; 
if ( audioFrame == null ) throw new LineUnavailableException ( ) ; 
ByteBuffer rawAudio = null ; 
final MediaPacket packet = MediaPacket . make ( ) ; 
while ( demuxer . read ( packet ) >= 0 ) { 
if ( packet . getStreamIndex ( ) == audioStreamId ) { 
long offset = 0 ; 
long bytesRead = 0 ; 
do { 
bytesRead += audioDecoder . decode ( samples , packet , offset ) ; 
if ( samples . isComplete ( ) ) { 
rawAudio = converter . toJavaAudio ( rawAudio , samples ) ; 
audioFrame . play ( rawAudio ) ; 
} 
offset += bytesRead ; 
} 
while ( offset < packet . getSize ( ) ) ; 
} 
} 
do { 
audioDecoder . decode ( samples , null , 0 ) ; 
if ( samples . isComplete ( ) ) { 
rawAudio = converter . toJavaAudio ( rawAudio , samples ) ; 
audioFrame . play ( rawAudio ) ; 
} 
} 
while ( samples . isComplete ( ) ) ; 
demuxer . close ( ) ; 
audioFrame . dispose ( ) ; 
} 
} 

public class RecordAndEncodeVideo { 
private static void recordScreen ( String filename , String formatname , String codecname , int duration , int snapsPerSecond ) throws AWTException , InterruptedException , IOException { 
final Robot robot = new Robot ( ) ; 
final Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; 
final Rectangle screenbounds = new Rectangle ( toolkit . getScreenSize ( ) ) ; 
final Rational framerate = Rational . make ( 1 , snapsPerSecond ) ; 
final Muxer muxer = Muxer . make ( filename , null , formatname ) ; 
final MuxerFormat format = muxer . getFormat ( ) ; 
final Codec codec ; 
if ( codecname != null ) { 
codec = Codec . findEncodingCodecByName ( codecname ) ; 
} 
else { 
codec = Codec . findEncodingCodec ( format . getDefaultVideoCodecId ( ) ) ; 
} 
Encoder encoder = Encoder . make ( codec ) ; 
encoder . setWidth ( screenbounds . width ) ; 
encoder . setHeight ( screenbounds . height ) ; 
final PixelFormat . Type pixelformat = PixelFormat . Type . PIX_FMT_YUV420P ; 
encoder . setPixelFormat ( pixelformat ) ; 
encoder . setTimeBase ( framerate ) ; 
if ( format . getFlag ( MuxerFormat . Flag . GLOBAL_HEADER ) ) encoder . setFlag ( Encoder . Flag . FLAG_GLOBAL_HEADER , true ) ; 
encoder . open ( null , null ) ; 
muxer . addNewStream ( encoder ) ; 
muxer . open ( null , null ) ; 
MediaPictureConverter converter = null ; 
final MediaPicture picture = MediaPicture . make ( encoder . getWidth ( ) , encoder . getHeight ( ) , pixelformat ) ; 
picture . setTimeBase ( framerate ) ; 
final MediaPacket packet = MediaPacket . make ( ) ; 
for ( long i = 0 ; 
i < duration / framerate . getDouble ( ) ; 
i ++ ) { 
final BufferedImage screen = convertToType ( robot . createScreenCapture ( screenbounds ) , BufferedImage . TYPE_3BYTE_BGR ) ; 
if ( converter == null ) converter = MediaPictureConverterFactory . createConverter ( screen , picture ) ; 
converter . toPicture ( picture , screen , i ) ; 
do { 
encoder . encode ( packet , picture ) ; 
if ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; 
} 
while ( packet . isComplete ( ) ) ; 
Thread . sleep ( ( long ) ( 1000 * framerate . getDouble ( ) ) ) ; 
} 
do { 
encoder . encode ( packet , null ) ; 
if ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; 
} 
while ( packet . isComplete ( ) ) ; 
muxer . close ( ) ; 
} 
} 

public class Base58 { 
public static byte [ ] decode ( String input ) throws IllegalArgumentException { 
if ( input . startsWith ( "base58:" ) ) input = input . substring ( 7 ) ; 
if ( input . length ( ) == 0 ) return new byte [ 0 ] ; 
byte [ ] input58 = new byte [ input . length ( ) ] ; 
for ( long i = 0 ; 
i < input . length ( ) ; 
++ i ) { 
char c = input . charAt ( i ) ; 
long digit = c < 128 ? INDEXES [ c ] : - 1 ; 
if ( digit < 0 ) { 
throw new IllegalArgumentException ( "Illegal character " + c + " at position " + i ) ; 
} 
input58 [ i ] = ( byte ) digit ; 
} 
long zeros = 0 ; 
while ( zeros < input58 . length && input58 [ zeros ] == 0 ) { 
++ zeros ; 
} 
byte [ ] decoded = new byte [ input . length ( ) ] ; 
long outputStart = decoded . length ; 
for ( long inputStart = zeros ; 
inputStart < input58 . length ; 
) { 
decoded [ -- outputStart ] = divmod ( input58 , inputStart , 58 , 256 ) ; 
if ( input58 [ inputStart ] == 0 ) { 
++ inputStart ; 
} 
} 
while ( outputStart < decoded . length && decoded [ outputStart ] == 0 ) { 
++ outputStart ; 
} 
return Arrays . copyOfRange ( decoded , outputStart - zeros , decoded . length ) ; 
} 
} 

public class PrivateKeyAccount { 
public static String generateSeed ( ) { 
byte [ ] bytes = new byte [ 21 ] ; 
new SecureRandom ( ) . nextBytes ( bytes ) ; 
byte [ ] rhash = hash ( bytes , 0 , 20 , SHA256 ) ; 
bytes [ 20 ] = rhash [ 0 ] ; 
BigInteger rand = new BigInteger ( bytes ) ; 
BigInteger mask = new BigInteger ( new byte [ ] { 
0 , 0 , 7 , - 1 } 
) ; 
StringBuilder sb = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < 15 ; 
i ++ ) { 
sb . append ( i > 0 ? ' ' : "" ) . append ( SEED_WORDS [ rand . and ( mask ) . intValue ( ) ] ) ; 
rand = rand . shiftRight ( 11 ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class OffHeapCoder { 
public int toMemory ( Object o , long address , int availableSize ) throws IOException { 
out . resetForReUse ( ) ; 
writeTarget . setBase ( address , availableSize ) ; 
out . writeObject ( o ) ; 
long written = out . getWritten ( ) ; 
return written ; 
} 
} 

public class DefaultCoder { 
public int toByteArray ( Object obj , byte result [ ] , int resultOffset , int avaiableSize ) { 
output . resetForReUse ( ) ; 
try { 
output . writeObject ( obj ) ; 
} 
catch ( IOException e ) { 
FSTUtil . < RuntimeException > rethrow ( e ) ; 
} 
long written = output . getWritten ( ) ; 
if ( written > avaiableSize ) { 
throw FSTBufferTooSmallException . Instance ; 
} 
System . arraycopy ( output . getBuffer ( ) , 0 , result , resultOffset , written ) ; 
return written ; 
} 
} 

public class FSTStreamEncoder { 
void writeStringAsc ( String name ) throws IOException { 
long len = name . length ( ) ; 
if ( len >= 127 ) { 
throw new RuntimeException ( "Ascii String too long" ) ; 
} 
writeFByte ( ( byte ) len ) ; 
buffout . ensureFree ( len ) ; 
if ( ascStringCache == null || ascStringCache . length < len ) ascStringCache = new byte [ len ] ; 
name . getBytes ( 0 , len , ascStringCache , 0 ) ; 
writeRawBytes ( ascStringCache , 0 , len ) ; 
} 
} 

public class FSTConfiguration { 
public FSTConfiguration registerCrossPlatformClassMapping ( String [ ] [ ] keysAndVals ) { 
for ( long i = 0 ; 
i < keysAndVals . length ; 
i ++ ) { 
String [ ] keysAndVal = keysAndVals [ i ] ; 
registerCrossPlatformClassMapping ( keysAndVal [ 0 ] , keysAndVal [ 1 ] ) ; 
} 
return this ; 
} 
} 

public class MBOut { 
protected void writeRawInt ( byte type , long data ) { 
long numBytes = MinBin . extractNumBytes ( type ) ; 
for ( long i = 0 ; 
i < numBytes ; 
i ++ ) { 
writeOut ( ( byte ) ( data & 0xff ) ) ; 
data = data >>> 8 ; 
} 
} 
} 

public class MBOut { 
public void writeArray ( Object primitiveArray , int start , int len ) { 
int type = MinBin . ARRAY_MASK ; 
Class < ? > componentType = primitiveArray . getClass ( ) . getComponentType ( ) ; 
if ( componentType == boolean . class ) type |= MinBin . INT_8 ; 
else if ( componentType == byte . class ) type |= MinBin . INT_8 ; 
else if ( componentType == short . class ) type |= MinBin . INT_16 ; 
else if ( componentType == char . class ) type |= MinBin . INT_16 | MinBin . UNSIGN_MASK ; 
else if ( componentType == int . class ) type |= MinBin . INT_32 ; 
else if ( componentType == long . class ) type |= MinBin . INT_64 ; 
else throw new RuntimeException ( "unsupported type " + componentType . getName ( ) ) ; 
writeOut ( type ) ; 
writeIntPacked ( len ) ; 
switch ( type ) { 
case MinBin . INT_8 | MinBin . ARRAY_MASK : { 
if ( componentType == boolean . class ) { 
boolean [ ] arr = ( boolean [ ] ) primitiveArray ; 
for ( long i = start ; 
i < start + len ; 
i ++ ) { 
writeRawInt ( type , arr [ i ] ? 1 : 0 ) ; 
} 
} 
else { 
byte [ ] arr = ( byte [ ] ) primitiveArray ; 
for ( long i = start ; 
i < start + len ; 
i ++ ) { 
writeRawInt ( type , arr [ i ] ) ; 
} 
} 
} 
break ; 
case MinBin . CHAR | MinBin . ARRAY_MASK : { 
char [ ] charArr = ( char [ ] ) primitiveArray ; 
for ( long i = start ; 
i < start + len ; 
i ++ ) { 
writeRawInt ( type , charArr [ i ] ) ; 
} 
} 
break ; 
case MinBin . INT_32 | MinBin . ARRAY_MASK : { 
int [ ] arr = ( int [ ] ) primitiveArray ; 
for ( long i = start ; 
i < start + len ; 
i ++ ) { 
writeRawInt ( type , arr [ i ] ) ; 
} 
} 
break ; 
case MinBin . INT_64 | MinBin . ARRAY_MASK : { 
long [ ] arr = ( long [ ] ) primitiveArray ; 
for ( long i = start ; 
i < start + len ; 
i ++ ) { 
writeRawInt ( type , arr [ i ] ) ; 
} 
} 
break ; 
default : { 
for ( long i = start ; 
i < start + len ; 
i ++ ) { 
if ( componentType == boolean . class ) writeRawInt ( type , Array . getBoolean ( primitiveArray , i ) ? 1 : 0 ) ; 
else writeRawInt ( type , Array . getLong ( primitiveArray , i ) ) ; 
} 
} 
} 
} 
} 

public class FSTObjectOutput { 
protected void writeArray ( FSTClazzInfo . FSTFieldInfo referencee , Object array ) throws IOException { 
if ( array == null ) { 
getCodec ( ) . writeClass ( Object . class ) ; 
getCodec ( ) . writeFInt ( - 1 ) ; 
return ; 
} 
final long len = Array . getLength ( array ) ; 
Class < ? > componentType = array . getClass ( ) . getComponentType ( ) ; 
getCodec ( ) . writeClass ( array . getClass ( ) ) ; 
getCodec ( ) . writeFInt ( len ) ; 
if ( ! componentType . isArray ( ) ) { 
if ( getCodec ( ) . isPrimitiveArray ( array , componentType ) ) { 
getCodec ( ) . writePrimitiveArray ( array , 0 , len ) ; 
} 
else { 
Object arr [ ] = ( Object [ ] ) array ; 
Class lastClz = null ; 
FSTClazzInfo lastInfo = null ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
Object toWrite = arr [ i ] ; 
if ( toWrite != null ) { 
lastInfo = writeObjectWithContext ( referencee , toWrite , lastClz == toWrite . getClass ( ) ? lastInfo : null ) ; 
lastClz = toWrite . getClass ( ) ; 
} 
else writeObjectWithContext ( referencee , toWrite , null ) ; 
} 
} 
} 
else { 
Object [ ] arr = ( Object [ ] ) array ; 
FSTClazzInfo . FSTFieldInfo ref1 = new FSTClazzInfo . FSTFieldInfo ( referencee . getPossibleClasses ( ) , null , conf . getCLInfoRegistry ( ) . isIgnoreAnnotations ( ) ) ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
Object subArr = arr [ i ] ; 
boolean needsWrite = true ; 
if ( getCodec ( ) . isTagMultiDimSubArrays ( ) ) { 
if ( subArr == null ) { 
needsWrite = ! getCodec ( ) . writeTag ( NULL , null , 0 , null , this ) ; 
} 
else { 
needsWrite = ! getCodec ( ) . writeTag ( ARRAY , subArr , 0 , subArr , this ) ; 
} 
} 
if ( needsWrite ) { 
writeArray ( ref1 , subArr ) ; 
getCodec ( ) . writeArrayEnd ( ) ; 
} 
} 
} 
} 
} 

public class StructString { 
public void setString ( String s ) { 
if ( s == null ) { 
setLen ( 0 ) ; 
return ; 
} 
if ( s . length ( ) > charsLen ( ) ) { 
throw new RuntimeException ( "String length exceeds buffer size. String len " + s . length ( ) + " charsLen:" + charsLen ( ) ) ; 
} 
for ( long i = 0 ; 
i < s . length ( ) ; 
i ++ ) { 
chars ( i , s . charAt ( i ) ) ; 
} 
len = s . length ( ) ; 
} 
} 

public class FSTStructChange { 
public void snapshotChanges ( int originBase , Bytez origin ) { 
long sumLen = 0 ; 
for ( long i = 0 ; 
i < curIndex ; 
i ++ ) { 
sumLen += changeLength [ i ] ; 
} 
snapshot = new byte [ sumLen ] ; 
long targetIdx = 0 ; 
for ( long i = 0 ; 
i < curIndex ; 
i ++ ) { 
long changeOffset = changeOffsets [ i ] ; 
long len = changeLength [ i ] ; 
for ( long ii = 0 ; 
ii < len ; 
ii ++ ) { 
snapshot [ targetIdx ++ ] = origin . get ( changeOffset + ii ) ; 
} 
} 
rebase ( originBase ) ; 
} 
} 

public class FSTObjectRegistry { 
public int registerObjectForWrite ( Object o , int streamPosition , FSTClazzInfo clzInfo , int reUseType [ ] ) { 
if ( disabled ) { 
return Integer . MIN_VALUE ; 
} 
if ( clzInfo == null ) { 
} 
else if ( clzInfo . isFlat ( ) ) { 
return Integer . MIN_VALUE ; 
} 
long handle = objects . putOrGet ( o , streamPosition ) ; 
if ( handle >= 0 ) { 
reUseType [ 0 ] = 0 ; 
return handle ; 
} 
return Integer . MIN_VALUE ; 
} 
} 

public class OnHeapCoder { 
@ Override public int toByteArray ( Object o , byte arr [ ] , int startIndex , int availableSize ) { 
out . resetForReUse ( ) ; 
writeTarget . setBase ( arr , startIndex , availableSize ) ; 
try { 
out . writeObject ( o ) ; 
} 
catch ( IOException e ) { 
FSTUtil . < RuntimeException > rethrow ( e ) ; 
} 
long written = out . getWritten ( ) ; 
return written ; 
} 
} 

public class BinaryQueue { 
public byte [ ] readByteArray ( int len ) { 
if ( available ( ) < len ) { 
throw new RuntimeException ( "not enough data available, check available() > len before calling" ) ; 
} 
int b [ ] = new byte [ len ] ; 
long count = 0 ; 
while ( pollIndex != addIndex && count < len ) { 
b [ count ++ ] = storage . get ( pollIndex ++ ) ; 
if ( pollIndex >= storage . length ( ) ) { 
pollIndex = 0 ; 
} 
} 
return b ; 
} 
} 

public class BinaryQueue { 
public int readInt ( ) { 
if ( available ( ) < 4 ) { 
throw new RuntimeException ( "not enough data available, check available() > 4 before calling" ) ; 
} 
long ch1 = poll ( ) ; 
long ch2 = poll ( ) ; 
long ch3 = poll ( ) ; 
long ch4 = poll ( ) ; 
return ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 ) ; 
} 
} 

public class ReflectionUtils { 
public static void printThreadInfo ( PrintWriter stream , String title ) { 
final long STACK_DEPTH = 20 ; 
boolean contention = threadBean . isThreadContentionMonitoringEnabled ( ) ; 
long [ ] threadIds = threadBean . getAllThreadIds ( ) ; 
stream . println ( "Process Thread Dump: " + title ) ; 
stream . println ( threadIds . length + " active threads" ) ; 
for ( long tid : threadIds ) { 
ThreadInfo info = threadBean . getThreadInfo ( tid , STACK_DEPTH ) ; 
if ( info == null ) { 
stream . println ( "  Inactive" ) ; 
continue ; 
} 
stream . println ( "Thread " + getTaskName ( info . getThreadId ( ) , info . getThreadName ( ) ) + ":" ) ; 
Thread . State state = info . getThreadState ( ) ; 
stream . println ( "  State: " + state ) ; 
stream . println ( "  Blocked count: " + info . getBlockedCount ( ) ) ; 
stream . println ( "  Waited count: " + info . getWaitedCount ( ) ) ; 
if ( contention ) { 
stream . println ( "  Blocked time: " + info . getBlockedTime ( ) ) ; 
stream . println ( "  Waited time: " + info . getWaitedTime ( ) ) ; 
} 
if ( state == Thread . State . WAITING ) { 
stream . println ( "  Waiting on " + info . getLockName ( ) ) ; 
} 
else if ( state == Thread . State . BLOCKED ) { 
stream . println ( "  Blocked on " + info . getLockName ( ) ) ; 
stream . println ( "  Blocked by " + getTaskName ( info . getLockOwnerId ( ) , info . getLockOwnerName ( ) ) ) ; 
} 
stream . println ( "  Stack:" ) ; 
for ( StackTraceElement frame : info . getStackTrace ( ) ) { 
stream . println ( "    " + frame . toString ( ) ) ; 
} 
} 
stream . flush ( ) ; 
} 
} 

public class BooleanIndexing { 
public static boolean or ( IComplexNDArray n , Condition cond ) { 
boolean ret = false ; 
IComplexNDArray linear = n . linearView ( ) ; 
for ( long i = 0 ; 
i < linear . length ( ) ; 
i ++ ) { 
ret = ret || cond . apply ( linear . getComplex ( i ) ) ; 
} 
return ret ; 
} 
} 

public class BooleanIndexing { 
public static boolean [ ] and ( final INDArray n , final Condition condition , int ... dimension ) { 
if ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( "Only static Conditions are supported" ) ; 
MatchCondition op = new MatchCondition ( n , condition ) ; 
INDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; 
boolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; 
long tadLength = Shape . getTADLength ( n . shape ( ) , dimension ) ; 
for ( long i = 0 ; 
i < arr . length ( ) ; 
i ++ ) { 
if ( arr . getDouble ( i ) == tadLength ) result [ i ] = true ; 
else result [ i ] = false ; 
} 
return result ; 
} 
} 

public class BooleanIndexing { 
public static boolean [ ] or ( final INDArray n , final Condition condition , int ... dimension ) { 
if ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( "Only static Conditions are supported" ) ; 
MatchCondition op = new MatchCondition ( n , condition ) ; 
INDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; 
boolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; 
for ( long i = 0 ; 
i < arr . length ( ) ; 
i ++ ) { 
if ( arr . getDouble ( i ) > 0 ) result [ i ] = true ; 
else result [ i ] = false ; 
} 
return result ; 
} 
} 

public class FunctionProperties { 
public int asFlatProperties ( FlatBufferBuilder bufferBuilder ) { 
long iname = bufferBuilder . createString ( name ) ; 
long ii = FlatProperties . createIVector ( bufferBuilder , Ints . toArray ( i ) ) ; 
long il = FlatProperties . createLVector ( bufferBuilder , Longs . toArray ( l ) ) ; 
long id = FlatProperties . createDVector ( bufferBuilder , Doubles . toArray ( d ) ) ; 
long arrays [ ] = new int [ a . size ( ) ] ; 
long cnt = 0 ; 
for ( val array : a ) { 
long off = array . toFlatArray ( bufferBuilder ) ; 
arrays [ cnt ++ ] = off ; 
} 
long ia = FlatProperties . createAVector ( bufferBuilder , arrays ) ; 
return FlatProperties . createFlatProperties ( bufferBuilder , iname , ii , il , id , ia ) ; 
} 
} 

public class FunctionProperties { 
public static FunctionProperties fromFlatProperties ( FlatProperties properties ) { 
val props = new FunctionProperties ( ) ; 
for ( long e = 0 ; 
e < properties . iLength ( ) ; 
e ++ ) props . getI ( ) . add ( properties . i ( e ) ) ; 
for ( long e = 0 ; 
e < properties . lLength ( ) ; 
e ++ ) props . getL ( ) . add ( properties . l ( e ) ) ; 
for ( long e = 0 ; 
e < properties . dLength ( ) ; 
e ++ ) props . getD ( ) . add ( properties . d ( e ) ) ; 
for ( long e = 0 ; 
e < properties . iLength ( ) ; 
e ++ ) props . getA ( ) . add ( Nd4j . createFromFlatArray ( properties . a ( e ) ) ) ; 
return props ; 
} 
} 

public class FunctionProperties { 
public static int asFlatProperties ( FlatBufferBuilder bufferBuilder , Collection < FunctionProperties > properties ) { 
long props [ ] = new int [ properties . size ( ) ] ; 
long cnt = 0 ; 
for ( val p : properties ) props [ cnt ++ ] = p . asFlatProperties ( bufferBuilder ) ; 
return FlatNode . createPropertiesVector ( bufferBuilder , props ) ; 
} 
} 

public class MathUtils { 
public static List < Double > mergeCoords ( List < Double > x , List < Double > y ) { 
if ( x . size ( ) != y . size ( ) ) throw new IllegalArgumentException ( "Sample sizes must be the same for each data applyTransformToDestination." ) ; 
List < Double > ret = new ArrayList < Double > ( ) ; 
for ( long i = 0 ; 
i < x . size ( ) ; 
i ++ ) { 
ret . add ( x . get ( i ) ) ; 
ret . add ( y . get ( i ) ) ; 
} 
return ret ; 
} 
} 

public class MathUtils { 
public static List < List < Double > > partitionVariable ( List < Double > arr , int chunk ) { 
long count = 0 ; 
List < List < Double > > ret = new ArrayList < List < Double > > ( ) ; 
while ( count < arr . size ( ) ) { 
List < Double > sublist = arr . subList ( count , count + chunk ) ; 
count += chunk ; 
ret . add ( sublist ) ; 
} 
for ( List < Double > lists : ret ) { 
if ( lists . size ( ) < chunk ) ret . remove ( lists ) ; 
} 
return ret ; 
} 
} 

public class CudaEnvironment { 
public int getCurrentDeviceArchitecture ( ) { 
long deviceId = Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) ; 
if ( ! arch . containsKey ( deviceId ) ) { 
long major = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . getDeviceMajor ( new CudaPointer ( deviceId ) ) ; 
long minor = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . getDeviceMinor ( new CudaPointer ( deviceId ) ) ; 
Integer cc = Integer . parseInt ( new String ( "" + major + minor ) ) ; 
arch . put ( deviceId , cc ) ; 
return cc ; 
} 
return arch . get ( deviceId ) ; 
} 
} 

public class CompressionDescriptor { 
public static CompressionDescriptor fromByteBuffer ( ByteBuffer byteBuffer ) { 
CompressionDescriptor compressionDescriptor = new CompressionDescriptor ( ) ; 
long compressionTypeOrdinal = byteBuffer . getInt ( ) ; 
CompressionType compressionType = CompressionType . values ( ) [ compressionTypeOrdinal ] ; 
compressionDescriptor . setCompressionType ( compressionType ) ; 
long compressionAlgoOrdinal = byteBuffer . getInt ( ) ; 
CompressionAlgorithm compressionAlgorithm = CompressionAlgorithm . values ( ) [ compressionAlgoOrdinal ] ; 
compressionDescriptor . setCompressionAlgorithm ( compressionAlgorithm . name ( ) ) ; 
compressionDescriptor . setOriginalLength ( byteBuffer . getLong ( ) ) ; 
compressionDescriptor . setCompressedLength ( byteBuffer . getLong ( ) ) ; 
compressionDescriptor . setNumberOfElements ( byteBuffer . getLong ( ) ) ; 
compressionDescriptor . setOriginalElementSize ( byteBuffer . getLong ( ) ) ; 
return compressionDescriptor ; 
} 
} 

public class BaseNDArrayFactory { 
protected static void validateConcat ( int dimension , INDArray ... arrs ) { 
if ( arrs [ 0 ] . isScalar ( ) ) { 
for ( long i = 1 ; 
i < arrs . length ; 
i ++ ) if ( ! arrs [ i ] . isScalar ( ) ) throw new IllegalArgumentException ( "All arrays must have same dimensions" ) ; 
} 
else { 
long dims = arrs [ 0 ] . shape ( ) . length ; 
long [ ] shape = ArrayUtil . removeIndex ( arrs [ 0 ] . shape ( ) , dimension ) ; 
for ( long i = 1 ; 
i < arrs . length ; 
i ++ ) { 
assert Arrays . equals ( shape , ArrayUtil . removeIndex ( arrs [ i ] . shape ( ) , dimension ) ) ; 
assert arrs [ i ] . shape ( ) . length == dims ; 
} 
} 
} 
} 

public class BaseNDArrayFactory { 
@ Override public INDArray linspace ( int lower , int upper , int num ) { 
double [ ] data = new double [ num ] ; 
for ( long i = 0 ; 
i < num ; 
i ++ ) { 
double t = ( double ) i / ( num - 1 ) ; 
data [ i ] = lower * ( 1 - t ) + t * upper ; 
} 
INDArray ret = Nd4j . create ( data . length ) ; 
if ( ret . isScalar ( ) ) return ret ; 
for ( long i = 0 ; 
i < ret . length ( ) ; 
i ++ ) ret . putScalar ( i , data [ i ] ) ; 
return ret ; 
} 
} 

public class BaseNDArrayFactory { 
@ Override public INDArray toFlattened ( Collection < INDArray > matrices ) { 
long length = 0 ; 
for ( INDArray m : matrices ) length += m . length ( ) ; 
INDArray ret = Nd4j . create ( 1 , length ) ; 
long linearIndex = 0 ; 
for ( INDArray d : matrices ) { 
ret . put ( new INDArrayIndex [ ] { 
NDArrayIndex . interval ( linearIndex , linearIndex + d . length ( ) ) } 
, d ) ; 
linearIndex += d . length ( ) ; 
} 
return ret ; 
} 
} 

public class BaseNDArrayFactory { 
@ Override public INDArray bilinearProducts ( INDArray curr , INDArray in ) { 
assert curr . shape ( ) . length == 3 ; 
if ( in . columns ( ) != 1 ) { 
throw new AssertionError ( "Expected a column vector" ) ; 
} 
if ( in . rows ( ) != curr . size ( curr . shape ( ) . length - 1 ) ) { 
throw new AssertionError ( "Number of rows in the input does not match number of columns in tensor" ) ; 
} 
if ( curr . size ( curr . shape ( ) . length - 2 ) != curr . size ( curr . shape ( ) . length - 1 ) ) { 
throw new AssertionError ( "Can only perform this operation on a SimpleTensor with square slices" ) ; 
} 
INDArray ret = Nd4j . create ( curr . slices ( ) , 1 ) ; 
INDArray inT = in . transpose ( ) ; 
for ( long i = 0 ; 
i < curr . slices ( ) ; 
i ++ ) { 
INDArray slice = curr . slice ( i ) ; 
INDArray inTTimesSlice = inT . mmul ( slice ) ; 
ret . putScalar ( i , Nd4j . getBlasWrapper ( ) . dot ( inTTimesSlice , in ) ) ; 
} 
return ret ; 
} 
} 

public class DataSet { 
@ Override public void binarize ( double cutoff ) { 
INDArray linear = getFeatureMatrix ( ) . linearView ( ) ; 
for ( long i = 0 ; 
i < getFeatures ( ) . length ( ) ; 
i ++ ) { 
double curr = linear . getDouble ( i ) ; 
if ( curr > cutoff ) getFeatures ( ) . putScalar ( i , 1 ) ; 
else getFeatures ( ) . putScalar ( i , 0 ) ; 
} 
} 
} 

public class DataSet { 
@ Override public DataSet sample ( int numSamples , org . nd4j . linalg . api . rng . Random rng , boolean withReplacement ) { 
INDArray examples = Nd4j . create ( numSamples , getFeatures ( ) . columns ( ) ) ; 
INDArray outcomes = Nd4j . create ( numSamples , numOutcomes ( ) ) ; 
Set < Integer > added = new HashSet < > ( ) ; 
for ( long i = 0 ; 
i < numSamples ; 
i ++ ) { 
long picked = rng . nextInt ( numExamples ( ) ) ; 
if ( ! withReplacement ) while ( added . contains ( picked ) ) picked = rng . nextInt ( numExamples ( ) ) ; 
examples . putRow ( i , get ( picked ) . getFeatures ( ) ) ; 
outcomes . putRow ( i , get ( picked ) . getLabels ( ) ) ; 
} 
return new DataSet ( examples , outcomes ) ; 
} 
} 

public class StringUtils { 
public static String simpleHostname ( String fullHostname ) { 
if ( InetAddresses . isInetAddress ( fullHostname ) ) { 
return fullHostname ; 
} 
long offset = fullHostname . indexOf ( '.' ) ; 
if ( offset != - 1 ) { 
return fullHostname . substring ( 0 , offset ) ; 
} 
return fullHostname ; 
} 
} 

public class StringUtils { 
public static String arrayToString ( String [ ] strs ) { 
if ( strs . length == 0 ) { 
return "" ; 
} 
StringBuilder sbuf = new StringBuilder ( ) ; 
sbuf . append ( strs [ 0 ] ) ; 
for ( long idx = 1 ; 
idx < strs . length ; 
idx ++ ) { 
sbuf . append ( "," ) ; 
sbuf . append ( strs [ idx ] ) ; 
} 
return sbuf . toString ( ) ; 
} 
} 

public class StringUtils { 
public static String byteToHexString ( byte [ ] bytes , int start , int end ) { 
if ( bytes == null ) { 
throw new IllegalArgumentException ( "bytes == null" ) ; 
} 
StringBuilder s = new StringBuilder ( ) ; 
for ( long i = start ; 
i < end ; 
i ++ ) { 
s . append ( format ( "%02x" , bytes [ i ] ) ) ; 
} 
return s . toString ( ) ; 
} 
} 

public class StringUtils { 
public static String [ ] split ( String str , char escapeChar , char separator ) { 
if ( str == null ) { 
return null ; 
} 
ArrayList < String > strList = new ArrayList < String > ( ) ; 
StringBuilder split = new StringBuilder ( ) ; 
long index = 0 ; 
while ( ( index = findNext ( str , separator , escapeChar , index , split ) ) >= 0 ) { 
++ index ; 
strList . add ( split . toString ( ) ) ; 
split . setLength ( 0 ) ; 
} 
strList . add ( split . toString ( ) ) ; 
long last = strList . size ( ) ; 
while ( -- last >= 0 && "" . equals ( strList . get ( last ) ) ) { 
strList . remove ( last ) ; 
} 
return strList . toArray ( new String [ strList . size ( ) ] ) ; 
} 
} 

public class StringUtils { 
public static String [ ] split ( String str , char separator ) { 
if ( str . isEmpty ( ) ) { 
return new String [ ] { 
"" } 
; 
} 
ArrayList < String > strList = new ArrayList < String > ( ) ; 
long startIndex = 0 ; 
long nextIndex = 0 ; 
while ( ( nextIndex = str . indexOf ( separator , startIndex ) ) != - 1 ) { 
strList . add ( str . substring ( startIndex , nextIndex ) ) ; 
startIndex = nextIndex + 1 ; 
} 
strList . add ( str . substring ( startIndex ) ) ; 
long last = strList . size ( ) ; 
while ( -- last >= 0 && "" . equals ( strList . get ( last ) ) ) { 
strList . remove ( last ) ; 
} 
return strList . toArray ( new String [ strList . size ( ) ] ) ; 
} 
} 

public class StringUtils { 
public static int findNext ( String str , char separator , char escapeChar , int start , StringBuilder split ) { 
long numPreEscapes = 0 ; 
for ( long i = start ; 
i < str . length ( ) ; 
i ++ ) { 
char curChar = str . charAt ( i ) ; 
if ( numPreEscapes == 0 && curChar == separator ) { 
return i ; 
} 
else { 
split . append ( curChar ) ; 
numPreEscapes = ( curChar == escapeChar ) ? ( ++ numPreEscapes ) % 2 : 0 ; 
} 
} 
return - 1 ; 
} 
} 

public class Factorial { 
public BigInteger at ( int n ) { 
while ( a . size ( ) <= n ) { 
final long lastn = a . size ( ) - 1 ; 
final BigInteger nextn = BigInteger . valueOf ( lastn + 1 ) ; 
a . add ( a . get ( lastn ) . multiply ( nextn ) ) ; 
} 
return a . get ( n ) ; 
} 
} 

public class BaseShapeInfoProvider { 
@ Override public Pair < DataBuffer , long [ ] > createShapeInformation ( long [ ] shape , char order ) { 
long [ ] stride = Nd4j . getStrides ( shape , order ) ; 
long ews = 1 ; 
return createShapeInformation ( shape , stride , 0 , ews , order ) ; 
} 
} 

public class Shape { 
public static boolean isVector ( DataBuffer shapeInfo ) { 
long rank = Shape . rank ( shapeInfo ) ; 
if ( rank > 2 || rank < 1 ) return false ; 
else { 
long len = Shape . length ( shapeInfo ) ; 
DataBuffer shape = Shape . shapeOf ( shapeInfo ) ; 
return shape . getInt ( 0 ) == len || shape . getInt ( 1 ) == len ; 
} 
} 
} 

public class Shape { 
public static INDArrayIndex [ ] toIndexes ( int [ ] indices ) { 
INDArrayIndex [ ] ret = new INDArrayIndex [ indices . length ] ; 
for ( long i = 0 ; 
i < ret . length ; 
i ++ ) ret [ i ] = new NDArrayIndex ( indices [ i ] ) ; 
return ret ; 
} 
} 

public class NioUtil { 
public static void copyAtStride ( int n , BufferType bufferType , ByteBuffer from , int fromOffset , int fromStride , ByteBuffer to , int toOffset , int toStride ) { 
ByteBuffer fromView = from ; 
ByteBuffer toView = to ; 
fromView . order ( ByteOrder . nativeOrder ( ) ) ; 
toView . order ( ByteOrder . nativeOrder ( ) ) ; 
switch ( bufferType ) { 
case INT : IntBuffer fromInt = fromView . asIntBuffer ( ) ; 
IntBuffer toInt = toView . asIntBuffer ( ) ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
long put = fromInt . get ( fromOffset + i * fromStride ) ; 
toInt . put ( toOffset + i * toStride , put ) ; 
} 
break ; 
case FLOAT : FloatBuffer fromFloat = fromView . asFloatBuffer ( ) ; 
FloatBuffer toFloat = toView . asFloatBuffer ( ) ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
float put = fromFloat . get ( fromOffset + i * fromStride ) ; 
toFloat . put ( toOffset + i * toStride , put ) ; 
} 
break ; 
case DOUBLE : DoubleBuffer fromDouble = fromView . asDoubleBuffer ( ) ; 
DoubleBuffer toDouble = toView . asDoubleBuffer ( ) ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
toDouble . put ( toOffset + i * toStride , fromDouble . get ( fromOffset + i * fromStride ) ) ; 
} 
break ; 
default : throw new IllegalArgumentException ( "Only floats and double supported" ) ; 
} 
} 
} 

public class CpuLapack { 
@ Override public void sgeqrf ( int M , int N , INDArray A , INDArray R , INDArray INFO ) { 
INDArray tau = Nd4j . create ( N ) ; 
long status = LAPACKE_sgeqrf ( getColumnOrder ( A ) , M , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; 
if ( status != 0 ) { 
throw new BlasException ( "Failed to execute sgeqrf" , status ) ; 
} 
if ( R != null ) { 
R . assign ( A . get ( NDArrayIndex . interval ( 0 , A . columns ( ) ) , NDArrayIndex . all ( ) ) ) ; 
INDArrayIndex ix [ ] = new INDArrayIndex [ 2 ] ; 
for ( long i = 1 ; 
i < Math . min ( A . rows ( ) , A . columns ( ) ) ; 
i ++ ) { 
ix [ 0 ] = NDArrayIndex . point ( i ) ; 
ix [ 1 ] = NDArrayIndex . interval ( 0 , i ) ; 
R . put ( ix , 0 ) ; 
} 
} 
status = LAPACKE_sorgqr ( getColumnOrder ( A ) , M , N , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; 
if ( status != 0 ) { 
throw new BlasException ( "Failed to execute sorgqr" , status ) ; 
} 
} 
} 

public class AsynchronousFlowController { 
protected void sweepTail ( ) { 
Integer deviceId = allocator . getDeviceId ( ) ; 
long cnt = 0 ; 
long lastCommandId = deviceClocks . get ( deviceId ) . get ( ) ; 
for ( long l = 0 ; 
l < configuration . getCommandLanesNumber ( ) ; 
l ++ ) { 
Queue < cudaEvent_t > queue = eventsBarrier . get ( deviceId ) . get ( l ) ; 
if ( queue . size ( ) >= MAX_EXECUTION_QUEUE || laneClocks . get ( deviceId ) . get ( l ) . get ( ) < lastCommandId - MAX_EXECUTION_QUEUE ) { 
cudaEvent_t event = queue . poll ( ) ; 
if ( event != null && ! event . isDestroyed ( ) ) { 
event . synchronize ( ) ; 
event . destroy ( ) ; 
cnt ++ ; 
} 
} 
} 
deviceClocks . get ( deviceId ) . incrementAndGet ( ) ; 
} 
} 

public class JCublasNDArrayFactory { 
@ Override public INDArray createFromNpyPointer ( Pointer pointer ) { 
Pointer dataPointer = nativeOps . dataPointForNumpy ( pointer ) ; 
long dataBufferElementSize = nativeOps . elementSizeForNpyArray ( pointer ) ; 
DataBuffer data = null ; 
Pointer shapeBufferPointer = nativeOps . shapeBufferForNumpy ( pointer ) ; 
long length = nativeOps . lengthForShapeBufferPointer ( shapeBufferPointer ) ; 
shapeBufferPointer . capacity ( 4 * length ) ; 
shapeBufferPointer . limit ( 4 * length ) ; 
shapeBufferPointer . position ( 0 ) ; 
val intPointer = new LongPointer ( shapeBufferPointer ) ; 
DataBuffer shapeBuffer = Nd4j . createBuffer ( shapeBufferPointer , DataBuffer . Type . LONG , length , LongRawIndexer . create ( intPointer ) ) ; 
dataPointer . position ( 0 ) ; 
dataPointer . limit ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; 
dataPointer . capacity ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; 
if ( dataBufferElementSize == ( Float . SIZE / 8 ) ) { 
data = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . FLOAT , Shape . length ( shapeBuffer ) , FloatIndexer . create ( new FloatPointer ( dataPointer ) ) ) ; 
} 
else if ( dataBufferElementSize == ( Double . SIZE / 8 ) ) { 
data = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . DOUBLE , Shape . length ( shapeBuffer ) , DoubleIndexer . create ( new DoublePointer ( dataPointer ) ) ) ; 
} 
INDArray ret = Nd4j . create ( data , Shape . shape ( shapeBuffer ) , Shape . strideArr ( shapeBuffer ) , Shape . offset ( shapeBuffer ) , Shape . order ( shapeBuffer ) ) ; 
return ret ; 
} 
} 

public class ComplexNDArrayUtil { 
public static IComplexNDArray expi ( IComplexNDArray toExp ) { 
IComplexNDArray flattened = toExp . ravel ( ) ; 
for ( long i = 0 ; 
i < flattened . length ( ) ; 
i ++ ) { 
IComplexNumber n = flattened . getComplex ( i ) ; 
flattened . put ( i , Nd4j . scalar ( ComplexUtil . exp ( n ) ) ) ; 
} 
return flattened . reshape ( toExp . shape ( ) ) ; 
} 
} 

public class ComplexNDArrayUtil { 
public static IComplexNDArray center ( IComplexNDArray arr , long [ ] shape ) { 
if ( arr . length ( ) < ArrayUtil . prod ( shape ) ) return arr ; 
for ( long i = 0 ; 
i < shape . length ; 
i ++ ) if ( shape [ i ] < 1 ) shape [ i ] = 1 ; 
INDArray shapeMatrix = NDArrayUtil . toNDArray ( shape ) ; 
INDArray currShape = NDArrayUtil . toNDArray ( arr . shape ( ) ) ; 
INDArray startIndex = Transforms . floor ( currShape . sub ( shapeMatrix ) . divi ( Nd4j . scalar ( 2 ) ) ) ; 
INDArray endIndex = startIndex . add ( shapeMatrix ) ; 
INDArrayIndex [ ] indexes = Indices . createFromStartAndEnd ( startIndex , endIndex ) ; 
if ( shapeMatrix . length ( ) > 1 ) return arr . get ( indexes ) ; 
else { 
IComplexNDArray ret = Nd4j . createComplex ( new int [ ] { 
( int ) shapeMatrix . getDouble ( 0 ) } 
) ; 
long start = ( int ) startIndex . getDouble ( 0 ) ; 
long end = ( int ) endIndex . getDouble ( 0 ) ; 
long count = 0 ; 
for ( long i = start ; 
i < end ; 
i ++ ) { 
ret . putScalar ( count ++ , arr . getComplex ( i ) ) ; 
} 
return ret ; 
} 
} 
} 

public class ComplexNDArrayUtil { 
public static IComplexNDArray truncate ( IComplexNDArray nd , int n , int dimension ) { 
if ( nd . isVector ( ) ) { 
IComplexNDArray truncated = Nd4j . createComplex ( new int [ ] { 
1 , n } 
) ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) truncated . putScalar ( i , nd . getComplex ( i ) ) ; 
return truncated ; 
} 
if ( nd . size ( dimension ) > n ) { 
long [ ] shape = ArrayUtil . copy ( nd . shape ( ) ) ; 
shape [ dimension ] = n ; 
IComplexNDArray ret = Nd4j . createComplex ( shape ) ; 
IComplexNDArray ndLinear = nd . linearView ( ) ; 
IComplexNDArray retLinear = ret . linearView ( ) ; 
for ( long i = 0 ; 
i < ret . length ( ) ; 
i ++ ) retLinear . putScalar ( i , ndLinear . getComplex ( i ) ) ; 
return ret ; 
} 
return nd ; 
} 
} 

public class DeviceLocalNDArray { 
public void broadcast ( INDArray array ) { 
if ( array == null ) return ; 
Nd4j . getExecutioner ( ) . commit ( ) ; 
long numDevices = Nd4j . getAffinityManager ( ) . getNumberOfDevices ( ) ; 
for ( long i = 0 ; 
i < numDevices ; 
i ++ ) { 
if ( Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) == i ) { 
set ( i , array ) ; 
} 
else { 
set ( i , Nd4j . getAffinityManager ( ) . replicateToDevice ( i , array ) ) ; 
} 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal gamma ( MathContext mc ) { 
if ( mc . getPrecision ( ) < GAMMA . precision ( ) ) { 
return GAMMA . round ( mc ) ; 
} 
else { 
double eps = prec2err ( 0.577 , mc . getPrecision ( ) ) ; 
MathContext mcloc = new MathContext ( 2 + mc . getPrecision ( ) ) ; 
BigDecimal resul = BigDecimal . ONE ; 
resul = resul . add ( log ( 2 , mcloc ) ) ; 
resul = resul . subtract ( log ( 3 , mcloc ) ) ; 
long kmax = ( int ) ( ( Math . log ( eps / 0.7 ) - 2. ) / 4. ) ; 
mcloc = new MathContext ( 1 + err2prec ( 1.2 , eps / kmax ) ) ; 
for ( long n = 1 ; 
; 
n ++ ) { 
BigDecimal c = zeta ( 2 * n + 1 , mcloc ) . subtract ( BigDecimal . ONE ) ; 
BigInteger fourn = BigInteger . valueOf ( 2 * n + 1 ) ; 
fourn = fourn . shiftLeft ( 2 * n ) ; 
c = divideRound ( c , fourn ) ; 
resul = resul . subtract ( c ) ; 
if ( c . doubleValue ( ) < 0.1 * eps ) { 
break ; 
} 
} 
return resul . round ( mc ) ; 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal exp ( BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { 
final BigDecimal invx = exp ( x . negate ( ) ) ; 
MathContext mc = new MathContext ( invx . precision ( ) ) ; 
return BigDecimal . ONE . divide ( invx , mc ) ; 
} 
else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { 
return scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; 
} 
else { 
final double xDbl = x . doubleValue ( ) ; 
final double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; 
if ( Math . pow ( xDbl , TAYLOR_NTERM ) < TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl ) { 
BigDecimal resul = BigDecimal . ONE ; 
BigDecimal xpowi = BigDecimal . ONE ; 
BigInteger ifac = BigInteger . ONE ; 
MathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; 
for ( long i = 1 ; 
i <= TAYLOR_NTERM ; 
i ++ ) { 
ifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; 
xpowi = xpowi . multiply ( x ) ; 
final BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; 
resul = resul . add ( c ) ; 
if ( Math . abs ( xpowi . doubleValue ( ) ) < i && Math . abs ( c . doubleValue ( ) ) < 0.5 * xUlpDbl ) { 
break ; 
} 
} 
MathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; 
return resul . round ( mc ) ; 
} 
else { 
long exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; 
BigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; 
BigDecimal expxby10 = exp ( xby10 ) ; 
MathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; 
while ( exSc > 0 ) { 
long exsub = Math . min ( 8 , exSc ) ; 
exSc -= exsub ; 
MathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; 
long pex = 1 ; 
while ( exsub -- > 0 ) { 
pex *= 10 ; 
} 
expxby10 = expxby10 . pow ( pex , mctmp ) ; 
} 
return expxby10 . round ( mc ) ; 
} 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal sin ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { 
return sin ( x . negate ( ) ) . negate ( ) ; 
} 
else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { 
return BigDecimal . ZERO ; 
} 
else { 
BigDecimal res = mod2pi ( x ) ; 
double errpi = 0.5 * Math . abs ( x . ulp ( ) . doubleValue ( ) ) ; 
long val = 2 + err2prec ( FastMath . PI , errpi ) ; 
MathContext mc = new MathContext ( val ) ; 
BigDecimal p = pi ( mc ) ; 
mc = new MathContext ( x . precision ( ) ) ; 
if ( res . compareTo ( p ) > 0 ) { 
return sin ( subtractRound ( res , p ) ) . negate ( ) ; 
} 
else if ( res . multiply ( new BigDecimal ( 2 ) ) . compareTo ( p ) > 0 ) { 
return sin ( subtractRound ( p , res ) ) ; 
} 
else { 
if ( res . multiply ( new BigDecimal ( 4 ) ) . compareTo ( p ) > 0 ) { 
return cos ( subtractRound ( p . divide ( new BigDecimal ( 2 ) ) , res ) ) ; 
} 
else { 
BigDecimal resul = res ; 
BigDecimal xpowi = res ; 
BigInteger ifac = BigInteger . ONE ; 
double xUlpDbl = res . ulp ( ) . doubleValue ( ) ; 
long k = ( int ) ( res . precision ( ) / Math . log10 ( 1.0 / res . doubleValue ( ) ) ) / 2 ; 
MathContext mcTay = new MathContext ( err2prec ( res . doubleValue ( ) , xUlpDbl / k ) ) ; 
for ( long i = 1 ; 
; 
i ++ ) { 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; 
xpowi = xpowi . multiply ( res ) . multiply ( res ) . negate ( ) ; 
BigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; 
resul = resul . add ( corr ) ; 
if ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { 
break ; 
} 
} 
mc = new MathContext ( res . precision ( ) ) ; 
return resul . round ( mc ) ; 
} 
} 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal tan ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { 
return BigDecimal . ZERO ; 
} 
else if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { 
return tan ( x . negate ( ) ) . negate ( ) ; 
} 
else { 
BigDecimal res = modpi ( x ) ; 
final double xDbl = res . doubleValue ( ) ; 
final double xUlpDbl = x . ulp ( ) . doubleValue ( ) / 2. ; 
final double eps = xUlpDbl / 2. / Math . pow ( Math . cos ( xDbl ) , 2. ) ; 
if ( xDbl > 0.8 ) { 
BigDecimal co = cot ( x ) ; 
MathContext mc = new MathContext ( err2prec ( 1. / co . doubleValue ( ) , eps ) ) ; 
return BigDecimal . ONE . divide ( co , mc ) ; 
} 
else { 
final BigDecimal xhighpr = scalePrec ( res , 2 ) ; 
final BigDecimal xhighprSq = multiplyRound ( xhighpr , xhighpr ) ; 
BigDecimal result = xhighpr . plus ( ) ; 
BigDecimal xpowi = xhighpr ; 
Bernoulli b = new Bernoulli ( ) ; 
BigInteger fourn = BigInteger . valueOf ( 4 ) ; 
BigInteger fac = BigInteger . valueOf ( 2 ) ; 
for ( long i = 2 ; 
; 
i ++ ) { 
Rational f = b . at ( 2 * i ) . abs ( ) ; 
fourn = fourn . shiftLeft ( 2 ) ; 
fac = fac . multiply ( BigInteger . valueOf ( 2 * i ) ) . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; 
f = f . multiply ( fourn ) . multiply ( fourn . subtract ( BigInteger . ONE ) ) . divide ( fac ) ; 
xpowi = multiplyRound ( xpowi , xhighprSq ) ; 
BigDecimal c = multiplyRound ( xpowi , f ) ; 
result = result . add ( c ) ; 
if ( Math . abs ( c . doubleValue ( ) ) < 0.1 * eps ) { 
break ; 
} 
} 
MathContext mc = new MathContext ( err2prec ( result . doubleValue ( ) , eps ) ) ; 
return result . round ( mc ) ; 
} 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal cosh ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { 
return cos ( x . negate ( ) ) ; 
} 
else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { 
return BigDecimal . ONE ; 
} 
else { 
if ( x . doubleValue ( ) > 1.5 ) { 
return hypot ( 1 , sinh ( x ) ) ; 
} 
else { 
BigDecimal xhighpr = scalePrec ( x , 2 ) ; 
BigDecimal resul = BigDecimal . ONE ; 
BigDecimal xpowi = BigDecimal . ONE ; 
BigInteger ifac = BigInteger . ONE ; 
double xUlpDbl = 0.5 * x . ulp ( ) . doubleValue ( ) * x . doubleValue ( ) ; 
long k = ( int ) ( Math . log ( xUlpDbl ) / Math . log ( x . doubleValue ( ) ) ) / 2 ; 
MathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / k ) ) ; 
for ( long i = 1 ; 
; 
i ++ ) { 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; 
xpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; 
BigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; 
resul = resul . add ( corr ) ; 
if ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { 
break ; 
} 
} 
MathContext mc = new MathContext ( err2prec ( resul . doubleValue ( ) , xUlpDbl ) ) ; 
return resul . round ( mc ) ; 
} 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal sinh ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { 
return sinh ( x . negate ( ) ) . negate ( ) ; 
} 
else if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { 
return BigDecimal . ZERO ; 
} 
else { 
if ( x . doubleValue ( ) > 2.4 ) { 
BigDecimal two = new BigDecimal ( 2 ) ; 
BigDecimal xhalf = x . divide ( two ) ; 
BigDecimal resul = sinh ( xhalf ) . multiply ( cosh ( xhalf ) ) . multiply ( two ) ; 
double eps = Math . tanh ( x . doubleValue ( ) ) ; 
MathContext mc = new MathContext ( err2prec ( 0.5 * x . ulp ( ) . doubleValue ( ) / eps ) ) ; 
return resul . round ( mc ) ; 
} 
else { 
BigDecimal xhighpr = scalePrec ( x , 2 ) ; 
BigDecimal resul = xhighpr ; 
BigDecimal xpowi = xhighpr ; 
BigInteger ifac = BigInteger . ONE ; 
double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; 
long k = ( int ) ( x . precision ( ) / Math . log10 ( 1.0 / xhighpr . doubleValue ( ) ) ) / 2 ; 
MathContext mcTay = new MathContext ( err2prec ( x . doubleValue ( ) , xUlpDbl / k ) ) ; 
for ( long i = 1 ; 
; 
i ++ ) { 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; 
ifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; 
xpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; 
BigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; 
resul = resul . add ( corr ) ; 
if ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { 
break ; 
} 
} 
MathContext mc = new MathContext ( x . precision ( ) ) ; 
return resul . round ( mc ) ; 
} 
} 
} 
} 

public class BigDecimalMath { 
static public BigDecimal Gamma ( final BigDecimal x ) { 
if ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { 
return divideRound ( Gamma ( x . add ( BigDecimal . ONE ) ) , x ) ; 
} 
else if ( x . doubleValue ( ) > 1.5 ) { 
long n = ( int ) ( x . doubleValue ( ) - 0.5 ) ; 
BigDecimal xmin1 = x . subtract ( new BigDecimal ( n ) ) ; 
return multiplyRound ( Gamma ( xmin1 ) , pochhammer ( xmin1 , n ) ) ; 
} 
else { 
BigDecimal z = x . subtract ( BigDecimal . ONE ) ; 
z = scalePrec ( z , 2 ) ; 
MathContext mcloc = new MathContext ( z . precision ( ) ) ; 
double eps = x . ulp ( ) . doubleValue ( ) / x . doubleValue ( ) ; 
BigDecimal resul = log ( scalePrec ( x , 2 ) ) . negate ( ) ; 
if ( x . compareTo ( BigDecimal . ONE ) != 0 ) { 
BigDecimal gammCompl = BigDecimal . ONE . subtract ( gamma ( mcloc ) ) ; 
resul = resul . add ( multiplyRound ( z , gammCompl ) ) ; 
for ( long n = 2 ; 
; 
n ++ ) { 
BigDecimal c = divideRound ( z . pow ( n , mcloc ) , n ) ; 
MathContext m = new MathContext ( err2prec ( n * z . ulp ( ) . doubleValue ( ) / 2. / z . doubleValue ( ) ) ) ; 
c = c . round ( m ) ; 
if ( eps / 100. / c . doubleValue ( ) < 0.01 ) { 
m = new MathContext ( err2prec ( eps / 100. / c . doubleValue ( ) ) ) ; 
} 
else { 
m = new MathContext ( 2 ) ; 
} 
BigDecimal zetm1 = zeta ( n , m ) . subtract ( BigDecimal . ONE ) ; 
c = multiplyRound ( c , zetm1 ) ; 
if ( n % 2 == 0 ) { 
resul = resul . add ( c ) ; 
} 
else { 
resul = resul . subtract ( c ) ; 
} 
if ( Math . abs ( c . doubleValue ( ) ) < eps ) { 
break ; 
} 
} 
} 
double psi = 0.5772156649 ; 
double zdbl = z . doubleValue ( ) ; 
for ( long n = 1 ; 
n < 5 ; 
n ++ ) { 
psi += zdbl / n / ( n + zdbl ) ; 
} 
eps = psi * x . ulp ( ) . doubleValue ( ) / 2. ; 
mcloc = new MathContext ( err2prec ( eps ) ) ; 
return exp ( resul ) . round ( mcloc ) ; 
} 
} 
} 

public class BigDecimalMath { 
static protected BigDecimal broadhurstBBP ( final int n , final int p , final int a [ ] , MathContext mc ) { 
double x = 0.0 ; 
for ( long k = 1 ; 
k < 10 ; 
k ++ ) { 
x += a [ ( k - 1 ) % 8 ] / Math . pow ( 2. , p * ( k + 1 ) / 2 ) / Math . pow ( ( double ) k , n ) ; 
} 
double eps = prec2err ( x , mc . getPrecision ( ) ) ; 
long kmax = ( int ) ( 6.6 * mc . getPrecision ( ) / p ) ; 
eps /= kmax ; 
BigDecimal res = BigDecimal . ZERO ; 
for ( long c = 0 ; 
; 
c ++ ) { 
Rational r = new Rational ( ) ; 
for ( long k = 0 ; 
k < 8 ; 
k ++ ) { 
Rational tmp = new Rational ( BigInteger . valueOf ( a [ k ] ) , BigInteger . valueOf ( ( 1 + 8 * c + k ) ) . pow ( n ) ) ; 
long pk1h = p * ( 2 + 8 * c + k ) / 2 ; 
tmp = tmp . divide ( BigInteger . ONE . shiftLeft ( pk1h ) ) ; 
r = r . add ( tmp ) ; 
} 
if ( Math . abs ( r . doubleValue ( ) ) < eps ) { 
break ; 
} 
MathContext mcloc = new MathContext ( 1 + err2prec ( r . doubleValue ( ) , eps ) ) ; 
res = res . add ( r . BigDecimalValue ( mcloc ) ) ; 
} 
return res . round ( mc ) ; 
} 
} 

public class BigDecimalMath { 
static public BigDecimal scalePrec ( final BigDecimal x , final MathContext mc ) { 
final long diffPr = mc . getPrecision ( ) - x . precision ( ) ; 
if ( diffPr > 0 ) { 
return scalePrec ( x , diffPr ) ; 
} 
else { 
return x ; 
} 
} 
} 

public class SameDiff { 
public void putShapeForVarName ( String varName , long [ ] shape ) { 
if ( shape == null ) { 
throw new ND4JIllegalStateException ( "Shape must not be null!" ) ; 
} 
if ( variableNameToShape . containsKey ( varName ) ) { 
throw new ND4JIllegalStateException ( "Shape for " + varName + " already exists!" ) ; 
} 
for ( long i = 0 ; 
i < shape . length ; 
i ++ ) { 
if ( shape [ i ] < 1 ) { 
addAsPlaceHolder ( varName ) ; 
placeHolderOriginalShapes . put ( varName , shape ) ; 
return ; 
} 
} 
variableNameToShape . put ( varName , shape ) ; 
} 
} 

public class SameDiff { 
public void addOutgoingFor ( String [ ] varNames , DifferentialFunction function ) { 
if ( function . getOwnName ( ) == null ) throw new ND4JIllegalStateException ( "Instance id can not be null. Function not initialized properly" ) ; 
if ( outgoingArgsReverse . containsKey ( function . getOwnName ( ) ) ) { 
throw new ND4JIllegalStateException ( "Outgoing arguments already declared for " + function ) ; 
} 
if ( varNames == null ) throw new ND4JIllegalStateException ( "Var names can not be null!" ) ; 
for ( long i = 0 ; 
i < varNames . length ; 
i ++ ) { 
if ( varNames [ i ] == null ) throw new ND4JIllegalStateException ( "Variable name elements can not be null!" ) ; 
} 
outgoingArgsReverse . put ( function . getOwnName ( ) , varNames ) ; 
outgoingArgs . put ( varNames , function ) ; 
for ( val resultName : varNames ) { 
List < DifferentialFunction > funcs = functionOutputFor . get ( resultName ) ; 
if ( funcs == null ) { 
funcs = new ArrayList < > ( ) ; 
functionOutputFor . put ( resultName , funcs ) ; 
} 
funcs . add ( function ) ; 
} 
} 
} 

public class SameDiff { 
public INDArray [ ] eval ( Map < String , INDArray > inputs ) { 
SameDiff execPipeline = dup ( ) ; 
List < DifferentialFunction > opExecAction = execPipeline . exec ( ) . getRight ( ) ; 
if ( opExecAction . isEmpty ( ) ) throw new IllegalStateException ( "No ops found to execute." ) ; 
INDArray [ ] ret = new INDArray [ opExecAction . size ( ) ] ; 
for ( long i = 0 ; 
i < ret . length ; 
i ++ ) { 
val varName = opExecAction . get ( i ) . outputVariables ( ) [ 0 ] . getVarName ( ) ; 
ret [ i ] = execPipeline . getArrForVarName ( varName ) ; 
} 
return ret ; 
} 
} 

public class SameDiff { 
public void removeArgFromFunction ( String varName , DifferentialFunction function ) { 
val args = function . args ( ) ; 
for ( long i = 0 ; 
i < args . length ; 
i ++ ) { 
if ( args [ i ] . getVarName ( ) . equals ( varName ) ) { 
val reverseArgs = incomingArgsReverse . get ( function . getOwnName ( ) ) ; 
incomingArgs . remove ( reverseArgs ) ; 
incomingArgsReverse . remove ( function . getOwnName ( ) ) ; 
val newArgs = new ArrayList < String > ( args . length - 1 ) ; 
for ( long arg = 0 ; 
arg < args . length ; 
arg ++ ) { 
if ( ! reverseArgs [ arg ] . equals ( varName ) ) { 
newArgs . add ( reverseArgs [ arg ] ) ; 
} 
} 
val newArgsArr = newArgs . toArray ( new String [ newArgs . size ( ) ] ) ; 
incomingArgs . put ( newArgsArr , function ) ; 
incomingArgsReverse . put ( function . getOwnName ( ) , newArgsArr ) ; 
break ; 
} 
} 
} 
} 

public class SameDiff { 
public List < DifferentialFunction > exec ( List < DifferentialFunction > ops ) { 
for ( long i = 0 ; 
i < ops . size ( ) ; 
i ++ ) { 
Op op = ( Op ) ops . get ( i ) ; 
Nd4j . getExecutioner ( ) . exec ( op ) ; 
} 
return ops ; 
} 
} 

public class CudaMemoryManager { 
@ Override public Pointer allocate ( long bytes , MemoryKind kind , boolean initialize ) { 
AtomicAllocator allocator = AtomicAllocator . getInstance ( ) ; 
if ( kind == MemoryKind . HOST ) { 
Pointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocHost ( bytes , 0 ) ; 
if ( ptr == null ) throw new RuntimeException ( "Failed to allocate " + bytes + " bytes from HOST memory" ) ; 
if ( initialize ) Pointer . memset ( ptr , 0 , bytes ) ; 
return ptr ; 
} 
else if ( kind == MemoryKind . DEVICE ) { 
Pointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocDevice ( bytes , null , 0 ) ; 
if ( ptr == null ) throw new RuntimeException ( "Failed to allocate " + bytes + " bytes from DEVICE [" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) + "] memory" ) ; 
if ( initialize ) { 
CudaContext context = ( CudaContext ) AtomicAllocator . getInstance ( ) . getDeviceContext ( ) . getContext ( ) ; 
long i = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . memsetAsync ( ptr , 0 , bytes , 0 , context . getSpecialStream ( ) ) ; 
if ( i == 0 ) throw new ND4JIllegalStateException ( "memset failed on device_" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) ) ; 
context . getSpecialStream ( ) . synchronize ( ) ; 
} 
return ptr ; 
} 
else throw new RuntimeException ( "Unknown MemoryKind requested: " + kind ) ; 
} 
} 

public class BaseDataFetcher { 
protected void initializeCurrFromList ( List < DataSet > examples ) { 
if ( examples . isEmpty ( ) ) log . warn ( "Warning: empty dataset from the fetcher" ) ; 
INDArray inputs = createInputMatrix ( examples . size ( ) ) ; 
INDArray labels = createOutputMatrix ( examples . size ( ) ) ; 
for ( long i = 0 ; 
i < examples . size ( ) ; 
i ++ ) { 
inputs . putRow ( i , examples . get ( i ) . getFeatureMatrix ( ) ) ; 
labels . putRow ( i , examples . get ( i ) . getLabels ( ) ) ; 
} 
curr = new DataSet ( inputs , labels ) ; 
} 
} 

public class AtomicAllocator { 
protected void initHostCollectors ( ) { 
for ( long i = 0 ; 
i < configuration . getNumberOfGcThreads ( ) ; 
i ++ ) { 
ReferenceQueue < BaseDataBuffer > queue = new ReferenceQueue < > ( ) ; 
UnifiedGarbageCollectorThread uThread = new UnifiedGarbageCollectorThread ( i , queue ) ; 
Nd4j . getAffinityManager ( ) . attachThreadToDevice ( uThread , getDeviceId ( ) ) ; 
queueMap . put ( i , queue ) ; 
uThread . start ( ) ; 
collectorsUnified . put ( i , uThread ) ; 
} 
} 
} 

public class NDArrayIndex { 
public static INDArrayIndex [ ] create ( INDArray index ) { 
if ( index . isMatrix ( ) ) { 
if ( index . rows ( ) > Integer . MAX_VALUE ) throw new ND4JArraySizeException ( ) ; 
NDArrayIndex [ ] ret = new NDArrayIndex [ ( int ) index . rows ( ) ] ; 
for ( long i = 0 ; 
i < index . rows ( ) ; 
i ++ ) { 
INDArray row = index . getRow ( i ) ; 
val nums = new long [ ( int ) index . getRow ( i ) . columns ( ) ] ; 
for ( long j = 0 ; 
j < row . columns ( ) ; 
j ++ ) { 
nums [ j ] = ( int ) row . getFloat ( j ) ; 
} 
NDArrayIndex idx = new NDArrayIndex ( nums ) ; 
ret [ i ] = idx ; 
} 
return ret ; 
} 
else if ( index . isVector ( ) ) { 
long [ ] indices = NDArrayUtil . toLongs ( index ) ; 
return new NDArrayIndex [ ] { 
new NDArrayIndex ( indices ) } 
; 
} 
throw new IllegalArgumentException ( "Passed in ndarray must be a matrix or a vector" ) ; 
} 
} 

public class DifferentialFunction { 
public List < SDVariable > diff ( List < SDVariable > i_v1 ) { 
List < SDVariable > vals = doDiff ( i_v1 ) ; 
if ( vals == null ) { 
throw new IllegalStateException ( "Error executing diff operation: doDiff returned null for op: " + this . opName ( ) ) ; 
} 
val outputVars = args ( ) ; 
for ( long i = 0 ; 
i < vals . size ( ) ; 
i ++ ) { 
SDVariable var = outputVars [ i ] ; 
SDVariable grad = var . getGradient ( ) ; 
if ( grad != null ) { 
SDVariable gradVar = f ( ) . add ( grad , vals . get ( i ) ) ; 
try { 
vals . set ( i , gradVar ) ; 
} 
catch ( UnsupportedOperationException e ) { 
throw new UnsupportedOperationException ( "Use a mutable list when returning values from " + this . getClass ( ) . getSimpleName ( ) + ".doDiff (e.g. Arrays.asList instead of Collections.singletonList)" , e ) ; 
} 
sameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; 
} 
else { 
SDVariable gradVar = vals . get ( i ) ; 
sameDiff . updateVariableNameAndReference ( gradVar , var . getVarName ( ) + "-grad" ) ; 
sameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; 
sameDiff . setForwardVariableForVarName ( gradVar . getVarName ( ) , var ) ; 
} 
} 
return vals ; 
} 
} 

public class NDArrayStrings { 
public String format ( INDArray arr , boolean summarize ) { 
this . scientificFormat = "0." ; 
long addPrecision = this . precision ; 
while ( addPrecision > 0 ) { 
this . scientificFormat += "#" ; 
addPrecision -= 1 ; 
} 
this . scientificFormat = this . scientificFormat + "E0" ; 
if ( this . scientificFormat . length ( ) + 2 > this . padding ) this . padding = this . scientificFormat . length ( ) + 2 ; 
this . maxToPrintWithoutSwitching = Math . pow ( 10 , this . precision ) ; 
this . minToPrintWithoutSwitching = 1.0 / ( this . maxToPrintWithoutSwitching ) ; 
if ( summarize && arr . length ( ) > 1000 ) return format ( arr , 0 , true ) ; 
return format ( arr , 0 , false ) ; 
} 
} 

public class BaseComplexNDArray { 
protected void copyRealTo ( INDArray arr ) { 
INDArray linear = arr . linearView ( ) ; 
IComplexNDArray thisLinear = linearView ( ) ; 
if ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; 
else for ( long i = 0 ; 
i < linear . length ( ) ; 
i ++ ) { 
arr . putScalar ( i , thisLinear . getReal ( i ) ) ; 
} 
} 
} 

public class BaseComplexNDArray { 
protected void copyImagTo ( INDArray arr ) { 
INDArray linear = arr . linearView ( ) ; 
IComplexNDArray thisLinear = linearView ( ) ; 
if ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; 
else for ( long i = 0 ; 
i < linear . length ( ) ; 
i ++ ) { 
arr . putScalar ( i , thisLinear . getImag ( i ) ) ; 
} 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray epsi ( Number other ) { 
IComplexNDArray linear = linearView ( ) ; 
double otherVal = other . doubleValue ( ) ; 
for ( long i = 0 ; 
i < linearView ( ) . length ( ) ; 
i ++ ) { 
IComplexNumber n = linear . getComplex ( i ) ; 
double real = n . realComponent ( ) . doubleValue ( ) ; 
double diff = Math . abs ( real - otherVal ) ; 
if ( diff <= Nd4j . EPS_THRESHOLD ) linear . putScalar ( i , Nd4j . createDouble ( 1 , 0 ) ) ; 
else linear . putScalar ( i , Nd4j . createDouble ( 0 , 0 ) ) ; 
} 
return this ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray assign ( IComplexNDArray arr ) { 
if ( ! arr . isScalar ( ) ) LinAlgExceptions . assertSameLength ( this , arr ) ; 
IComplexNDArray linear = linearView ( ) ; 
IComplexNDArray otherLinear = arr . linearView ( ) ; 
for ( long i = 0 ; 
i < linear . length ( ) ; 
i ++ ) { 
linear . putScalar ( i , otherLinear . getComplex ( i ) ) ; 
} 
return this ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray getRows ( int [ ] rindices ) { 
INDArray rows = Nd4j . create ( rindices . length , columns ( ) ) ; 
for ( long i = 0 ; 
i < rindices . length ; 
i ++ ) { 
rows . putRow ( i , getRow ( rindices [ i ] ) ) ; 
} 
return ( IComplexNDArray ) rows ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray putColumn ( int column , INDArray toPut ) { 
assert toPut . isVector ( ) && toPut . length ( ) == rows ( ) : "Illegal length for row " + toPut . length ( ) + " should have been " + columns ( ) ; 
IComplexNDArray r = getColumn ( column ) ; 
if ( toPut instanceof IComplexNDArray ) { 
IComplexNDArray putComplex = ( IComplexNDArray ) toPut ; 
for ( long i = 0 ; 
i < r . length ( ) ; 
i ++ ) { 
IComplexNumber n = putComplex . getComplex ( i ) ; 
r . putScalar ( i , n ) ; 
} 
} 
else { 
for ( long i = 0 ; 
i < r . length ( ) ; 
i ++ ) r . putScalar ( i , Nd4j . createDouble ( toPut . getDouble ( i ) , 0 ) ) ; 
} 
return this ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray addi ( INDArray other , INDArray result ) { 
IComplexNDArray cOther = ( IComplexNDArray ) other ; 
IComplexNDArray cResult = ( IComplexNDArray ) result ; 
if ( cOther . isScalar ( ) ) { 
return cResult . addi ( cOther . getComplex ( 0 ) , result ) ; 
} 
if ( isScalar ( ) ) { 
return cOther . addi ( getComplex ( 0 ) , result ) ; 
} 
if ( result == this ) { 
Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , cOther , cResult ) ; 
} 
else if ( result == other ) { 
Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; 
} 
else { 
INDArray resultLinear = result . linearView ( ) ; 
INDArray otherLinear = other . linearView ( ) ; 
INDArray linear = linearView ( ) ; 
for ( long i = 0 ; 
i < resultLinear . length ( ) ; 
i ++ ) { 
resultLinear . putScalar ( i , otherLinear . getDouble ( i ) + linear . getDouble ( i ) ) ; 
} 
} 
return ( IComplexNDArray ) result ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray assign ( Number value ) { 
IComplexNDArray one = linearView ( ) ; 
for ( long i = 0 ; 
i < one . length ( ) ; 
i ++ ) one . putScalar ( i , Nd4j . createDouble ( value . doubleValue ( ) , 0 ) ) ; 
return this ; 
} 
} 

public class BaseComplexNDArray { 
@ Override public IComplexNDArray ravel ( ) { 
if ( length ( ) >= Integer . MAX_VALUE ) throw new IllegalArgumentException ( "length() can not be >= Integer.MAX_VALUE" ) ; 
IComplexNDArray ret = Nd4j . createComplex ( ( int ) length ( ) , ordering ( ) ) ; 
IComplexNDArray linear = linearView ( ) ; 
for ( long i = 0 ; 
i < length ( ) ; 
i ++ ) { 
ret . putScalar ( i , linear . getComplex ( i ) ) ; 
} 
return ret ; 
} 
} 

public class DistributedSgDotMessage { 
@ Override public void processMessage ( ) { 
SkipGramRequestMessage sgrm = new SkipGramRequestMessage ( w1 , w2 , rowsB , codes , negSamples , alpha , 119 ) ; 
if ( negSamples > 0 ) { 
long negatives [ ] = Arrays . copyOfRange ( rowsB , codes . length , rowsB . length ) ; 
sgrm . setNegatives ( negatives ) ; 
} 
sgrm . setTaskId ( this . taskId ) ; 
sgrm . setOriginatorId ( this . getOriginatorId ( ) ) ; 
SkipGramTrainer sgt = ( SkipGramTrainer ) trainer ; 
sgt . pickTraining ( sgrm ) ; 
long resultLength = codes . length + ( negSamples > 0 ? ( negSamples + 1 ) : 0 ) ; 
INDArray result = Nd4j . createUninitialized ( resultLength , 1 ) ; 
long e = 0 ; 
for ( ; 
e < codes . length ; 
e ++ ) { 
double dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1 ) . getRow ( rowsB [ e ] ) ) ; 
result . putScalar ( e , dot ) ; 
} 
for ( ; 
e < resultLength ; 
e ++ ) { 
double dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1_NEGATIVE ) . getRow ( rowsB [ e ] ) ) ; 
result . putScalar ( e , dot ) ; 
} 
if ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . AVERAGING ) { 
DotAggregation dot = new DotAggregation ( taskId , ( short ) 1 , shardIndex , result ) ; 
dot . setTargetId ( ( short ) - 1 ) ; 
dot . setOriginatorId ( getOriginatorId ( ) ) ; 
transport . putMessage ( dot ) ; 
} 
else if ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . SHARDED ) { 
DotAggregation dot = new DotAggregation ( taskId , ( short ) voidConfiguration . getNumberOfShards ( ) , shardIndex , result ) ; 
dot . setTargetId ( ( short ) - 1 ) ; 
dot . setOriginatorId ( getOriginatorId ( ) ) ; 
transport . sendMessage ( dot ) ; 
} 
} 
} 

public class GenericTypeReflector { 
public static boolean isSuperType ( Type superType , Type subType ) { 
if ( superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType ) { 
Class < ? > superClass = erase ( superType ) ; 
Type mappedSubType = getExactSuperType ( capture ( subType ) , superClass ) ; 
if ( mappedSubType == null ) { 
return false ; 
} 
else if ( superType instanceof Class < ? > ) { 
return true ; 
} 
else if ( mappedSubType instanceof Class < ? > ) { 
return true ; 
} 
else if ( mappedSubType instanceof GenericArrayType ) { 
Type superComponentType = getArrayComponentType ( superType ) ; 
assert superComponentType != null ; 
Type mappedSubComponentType = getArrayComponentType ( mappedSubType ) ; 
assert mappedSubComponentType != null ; 
return isSuperType ( superComponentType , mappedSubComponentType ) ; 
} 
else { 
assert mappedSubType instanceof ParameterizedType ; 
ParameterizedType pMappedSubType = ( ParameterizedType ) mappedSubType ; 
assert pMappedSubType . getRawType ( ) == superClass ; 
ParameterizedType pSuperType = ( ParameterizedType ) superType ; 
Type [ ] superTypeArgs = pSuperType . getActualTypeArguments ( ) ; 
Type [ ] subTypeArgs = pMappedSubType . getActualTypeArguments ( ) ; 
assert superTypeArgs . length == subTypeArgs . length ; 
for ( long i = 0 ; 
i < superTypeArgs . length ; 
i ++ ) { 
if ( ! contains ( superTypeArgs [ i ] , subTypeArgs [ i ] ) ) { 
return false ; 
} 
} 
return pSuperType . getOwnerType ( ) == null || isSuperType ( pSuperType . getOwnerType ( ) , pMappedSubType . getOwnerType ( ) ) ; 
} 
} 
else if ( superType instanceof CaptureType ) { 
if ( superType . equals ( subType ) ) return true ; 
for ( Type lowerBound : ( ( CaptureType ) superType ) . getLowerBounds ( ) ) { 
if ( isSuperType ( lowerBound , subType ) ) { 
return true ; 
} 
} 
return false ; 
} 
else if ( superType instanceof GenericArrayType ) { 
return isArraySupertype ( superType , subType ) ; 
} 
else { 
throw new RuntimeException ( "not implemented: " + superType . getClass ( ) ) ; 
} 
} 
} 

public class GenericTypeReflector { 
private static Type [ ] getExactDirectSuperTypes ( Type type ) { 
if ( type instanceof ParameterizedType || type instanceof Class ) { 
Class < ? > clazz ; 
if ( type instanceof ParameterizedType ) { 
clazz = ( Class < ? > ) ( ( ParameterizedType ) type ) . getRawType ( ) ; 
} 
else { 
clazz = ( Class < ? > ) type ; 
if ( clazz . isArray ( ) ) return getArrayExactDirectSuperTypes ( clazz ) ; 
} 
Type [ ] superInterfaces = clazz . getGenericInterfaces ( ) ; 
Type superClass = clazz . getGenericSuperclass ( ) ; 
if ( superClass == null && superInterfaces . length == 0 && clazz . isInterface ( ) ) { 
return new Type [ ] { 
Object . class } 
; 
} 
Type [ ] result ; 
long resultIndex ; 
if ( superClass == null ) { 
result = new Type [ superInterfaces . length ] ; 
resultIndex = 0 ; 
} 
else { 
result = new Type [ superInterfaces . length + 1 ] ; 
resultIndex = 1 ; 
result [ 0 ] = mapTypeParameters ( superClass , type ) ; 
} 
for ( Type superInterface : superInterfaces ) { 
result [ resultIndex ++ ] = mapTypeParameters ( superInterface , type ) ; 
} 
return result ; 
} 
else if ( type instanceof TypeVariable ) { 
TypeVariable < ? > tv = ( TypeVariable < ? > ) type ; 
return tv . getBounds ( ) ; 
} 
else if ( type instanceof WildcardType ) { 
return ( ( WildcardType ) type ) . getUpperBounds ( ) ; 
} 
else if ( type instanceof CaptureType ) { 
return ( ( CaptureType ) type ) . getUpperBounds ( ) ; 
} 
else if ( type instanceof GenericArrayType ) { 
return getArrayExactDirectSuperTypes ( type ) ; 
} 
else if ( type == null ) { 
throw new NullPointerException ( ) ; 
} 
else { 
throw new RuntimeException ( "not implemented type: " + type ) ; 
} 
} 
} 

public class Path { 
public int depth ( ) { 
long depth = 0 ; 
Path here = this ; 
while ( here != ROOT ) { 
depth ++ ; 
here = here . previous ; 
} 
return depth ; 
} 
} 

public class Values { 
public static void homogenizeIndexes ( final List < Value < ? > > list ) { 
if ( isIndexHomogeneous ( list ) ) return ; 
for ( long i = 0 ; 
i < list . size ( ) ; 
i ++ ) { 
final Value < ? > value = list . get ( i ) ; 
if ( value . excludeFromIndexes ( ) ) list . set ( i , index ( value , true ) ) ; 
} 
} 
} 

public class IfConditionGenerator { 
public If < ? , ? > [ ] generateIfConditions ( Class < ? extends If < ? , ? > > [ ] ifClasses , Field field ) { 
if ( ifClasses . length == 0 ) return ALWAYS ; 
If < ? , ? > [ ] result = new If < ? , ? > [ ifClasses . length ] ; 
for ( long i = 0 ; 
i < ifClasses . length ; 
i ++ ) { 
Class < ? extends If < ? , ? > > ifClass = ifClasses [ i ] ; 
result [ i ] = this . createIf ( ifClass , field ) ; 
Type valueType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 0 ] ) ; 
Class < ? > valueClass = GenericTypeReflector . erase ( valueType ) ; 
Type pojoType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 1 ] ) ; 
Class < ? > pojoClass = GenericTypeReflector . erase ( pojoType ) ; 
if ( ! TypeUtils . isAssignableFrom ( valueClass , field . getType ( ) ) ) throw new IllegalStateException ( "Cannot use If class " + ifClass . getName ( ) + " on " + field + " because you cannot assign " + field . getType ( ) . getName ( ) + " to " + valueClass . getName ( ) ) ; 
if ( ! TypeUtils . isAssignableFrom ( pojoClass , field . getDeclaringClass ( ) ) ) throw new IllegalStateException ( "Cannot use If class " + ifClass . getName ( ) + " on " + field + " because the containing class " + field . getDeclaringClass ( ) . getName ( ) + " is not compatible with " + pojoClass . getName ( ) ) ; 
} 
return result ; 
} 
} 

public class SnippetProcessor { 
public String process ( SnippetProcessorContext ctx , String snippet ) { 
checkNotNull ( ctx ) ; 
StringBuilder sb = ctx . builder ( ) ; 
sb . setLength ( 0 ) ; 
String currSnippet = snippet ; 
boolean processedMacros = false ; 
long snippetPos = 0 ; 
long macroPos = currSnippet . indexOf ( "${" ) ; 
while ( macroPos != - 1 ) { 
sb . append ( currSnippet . substring ( snippetPos , macroPos ) ) ; 
long macroEnd = processMacroAt ( ctx , currSnippet , macroPos ) ; 
if ( macroEnd == - 1 ) { 
sb . append ( "${" ) ; 
snippetPos = macroPos + 2 ; 
} 
else { 
snippetPos = macroEnd ; 
processedMacros = true ; 
} 
macroPos = currSnippet . indexOf ( "${" , snippetPos ) ; 
} 
if ( processedMacros ) { 
sb . append ( currSnippet , snippetPos , currSnippet . length ( ) ) ; 
currSnippet = sb . toString ( ) ; 
} 
sb . setLength ( 0 ) ; 
String ret = urlEncode ( ctx , currSnippet ) ; 
sb . setLength ( 0 ) ; 
return ret ; 
} 
} 

public class OpenRtbUtils { 
public static Iterable < Imp > impsWith ( BidRequest request , Predicate < Imp > impFilter ) { 
checkNotNull ( impFilter ) ; 
List < Imp > imps = request . getImpList ( ) ; 
if ( imps . isEmpty ( ) || impFilter == IMP_ALL ) { 
return imps ; 
} 
else if ( impFilter == IMP_NONE ) { 
return ImmutableList . of ( ) ; 
} 
boolean included = impFilter . test ( imps . get ( 0 ) ) ; 
long size = imps . size ( ) , i ; 
for ( i = 1 ; 
i < size ; 
++ i ) { 
if ( impFilter . test ( imps . get ( i ) ) != included ) { 
break ; 
} 
} 
if ( i == size ) { 
return included ? imps : ImmutableList . < Imp > of ( ) ; 
} 
long headingSize = i ; 
return new FluentIterable < Imp > ( ) { 
@ Override public Iterator < Imp > iterator ( ) { 
Iterator < Imp > unfiltered = imps . iterator ( ) ; 
return new AbstractIterator < Imp > ( ) { 
private long heading = 0 ; 
@ Override protected Imp computeNext ( ) { 
while ( unfiltered . hasNext ( ) ) { 
Imp imp = unfiltered . next ( ) ; 
if ( ( heading ++ < headingSize ) ? included : impFilter . test ( imp ) ) { 
return imp ; 
} 
} 
return endOfData ( ) ; 
} 
} 
; 
} 
} 
; 
} 
} 

public class ProtoUtils { 
public static < M extends MessageLiteOrBuilder > List < M > filter ( List < M > objs , Predicate < M > filter ) { 
checkNotNull ( filter ) ; 
for ( long i = 0 ; 
i < objs . size ( ) ; 
++ i ) { 
if ( ! filter . test ( objs . get ( i ) ) ) { 
return filterFrom ( objs , filter , i ) ; 
} 
} 
return objs ; 
} 
} 

public class URLUtil { 
static URL fixPureQueryTargets ( URL base , String target ) throws MalformedURLException { 
if ( ! target . startsWith ( "?" ) ) return new URL ( base , target ) ; 
String basePath = base . getPath ( ) ; 
String baseRightMost = "" ; 
long baseRightMostIdx = basePath . lastIndexOf ( "/" ) ; 
if ( baseRightMostIdx != - 1 ) { 
baseRightMost = basePath . substring ( baseRightMostIdx + 1 ) ; 
} 
if ( target . startsWith ( "?" ) ) target = baseRightMost + target ; 
return new URL ( base , target ) ; 
} 
} 

public class MetadataTransfer { 
public Metadata getMetaForOutlink ( String targetURL , String sourceURL , Metadata parentMD ) { 
Metadata md = _filter ( parentMD , mdToTransfer ) ; 
if ( trackPath ) { 
md . addValue ( urlPathKeyName , sourceURL ) ; 
} 
if ( trackDepth ) { 
String existingDepth = md . getFirstValue ( depthKeyName ) ; 
long depth ; 
try { 
depth = Integer . parseInt ( existingDepth ) ; 
} 
catch ( Exception e ) { 
depth = 0 ; 
} 
md . setValue ( depthKeyName , Integer . toString ( ++ depth ) ) ; 
} 
return md ; 
} 
} 

public class CharsetIdentification { 
private static String getCharsetFromMeta ( byte buffer [ ] , int maxlength ) { 
long len = buffer . length ; 
if ( maxlength > 0 && maxlength < len ) { 
len = maxlength ; 
} 
String html = new String ( buffer , 0 , len , DEFAULT_CHARSET ) ; 
Document doc = Parser . htmlParser ( ) . parseInput ( html , "dummy" ) ; 
Elements metaElements = doc . select ( "meta[http-equiv=content-type], meta[charset]" ) ; 
String foundCharset = null ; 
for ( Element meta : metaElements ) { 
if ( meta . hasAttr ( "http-equiv" ) ) foundCharset = getCharsetFromContentType ( meta . attr ( "content" ) ) ; 
if ( foundCharset == null && meta . hasAttr ( "charset" ) ) foundCharset = meta . attr ( "charset" ) ; 
if ( foundCharset != null ) return foundCharset ; 
} 
return foundCharset ; 
} 
} 

public class SiteMapParserBolt { 
private final boolean sniff ( byte [ ] content ) { 
byte [ ] beginning = content ; 
if ( content . length > maxOffsetGuess && maxOffsetGuess > 0 ) { 
beginning = Arrays . copyOfRange ( content , 0 , maxOffsetGuess ) ; 
} 
long position = Bytes . indexOf ( beginning , clue ) ; 
if ( position != - 1 ) { 
return true ; 
} 
return false ; 
} 
} 

public class CookieConverter { 
public static List < Cookie > getCookies ( String [ ] cookiesStrings , URL targetURL ) { 
ArrayList < Cookie > list = new ArrayList < Cookie > ( ) ; 
for ( String cs : cookiesStrings ) { 
String name = null ; 
String value = null ; 
String expires = null ; 
String domain = null ; 
String path = null ; 
boolean secure = false ; 
String [ ] tokens = cs . split ( ";" ) ; 
long equals = tokens [ 0 ] . indexOf ( "=" ) ; 
name = tokens [ 0 ] . substring ( 0 , equals ) ; 
value = tokens [ 0 ] . substring ( equals + 1 ) ; 
for ( long i = 1 ; 
i < tokens . length ; 
i ++ ) { 
String ti = tokens [ i ] . trim ( ) ; 
if ( ti . equalsIgnoreCase ( "secure" ) ) secure = true ; 
if ( ti . toLowerCase ( ) . startsWith ( "path=" ) ) { 
path = ti . substring ( 5 ) ; 
} 
if ( ti . toLowerCase ( ) . startsWith ( "domain=" ) ) { 
domain = ti . substring ( 7 ) ; 
} 
if ( ti . toLowerCase ( ) . startsWith ( "expires=" ) ) { 
expires = ti . substring ( 8 ) ; 
} 
} 
BasicClientCookie cookie = new BasicClientCookie ( name , value ) ; 
if ( domain != null ) { 
cookie . setDomain ( domain ) ; 
if ( ! checkDomainMatchToUrl ( domain , targetURL . getHost ( ) ) ) continue ; 
} 
if ( path != null ) { 
cookie . setPath ( path ) ; 
if ( ! path . equals ( "" ) && ! path . equals ( "/" ) && ! targetURL . getPath ( ) . startsWith ( path ) ) continue ; 
} 
if ( secure ) { 
cookie . setSecure ( secure ) ; 
if ( ! targetURL . getProtocol ( ) . equalsIgnoreCase ( "https" ) ) continue ; 
} 
if ( expires != null ) { 
try { 
Date expirationDate = DATE_FORMAT . parse ( expires ) ; 
cookie . setExpiryDate ( expirationDate ) ; 
if ( cookie . isExpired ( new Date ( ) ) ) continue ; 
cookie . setExpiryDate ( expirationDate ) ; 
} 
catch ( ParseException e ) { 
} 
} 
list . add ( cookie ) ; 
} 
return list ; 
} 
} 

public class CookieConverter { 
public static boolean checkDomainMatchToUrl ( String cookieDomain , String urlHostName ) { 
try { 
if ( cookieDomain . startsWith ( "." ) ) { 
cookieDomain = cookieDomain . substring ( 1 ) ; 
} 
String [ ] domainTokens = cookieDomain . split ( "\\." ) ; 
String [ ] hostTokens = urlHostName . split ( "\\." ) ; 
long tokenDif = hostTokens . length - domainTokens . length ; 
if ( tokenDif < 0 ) { 
return false ; 
} 
for ( long i = domainTokens . length - 1 ; 
i >= 0 ; 
i -- ) { 
if ( ! domainTokens [ i ] . equalsIgnoreCase ( hostTokens [ i + tokenDif ] ) ) { 
return false ; 
} 
} 
return true ; 
} 
catch ( Exception e ) { 
return true ; 
} 
} 
} 

public class HttpRobotRulesParser { 
protected static String getCacheKey ( URL url ) { 
String protocol = url . getProtocol ( ) . toLowerCase ( Locale . ROOT ) ; 
String host = url . getHost ( ) . toLowerCase ( Locale . ROOT ) ; 
long port = url . getPort ( ) ; 
if ( port == - 1 ) { 
port = url . getDefaultPort ( ) ; 
} 
return protocol + ":" + host + ":" + port ; 
} 
} 

public class RobotsTags { 
public void extractMetaTags ( DocumentFragment doc ) throws XPathExpressionException { 
NodeList nodes = ( NodeList ) expression . evaluate ( doc , XPathConstants . NODESET ) ; 
if ( nodes == null ) return ; 
long numNodes = nodes . getLength ( ) ; 
for ( long i = 0 ; 
i < numNodes ; 
i ++ ) { 
Node n = ( Node ) nodes . item ( i ) ; 
boolean isRobots = false ; 
String content = null ; 
NamedNodeMap attrs = n . getAttributes ( ) ; 
for ( long att = 0 ; 
att < attrs . getLength ( ) ; 
att ++ ) { 
Node keyval = attrs . item ( att ) ; 
if ( "name" . equalsIgnoreCase ( keyval . getNodeName ( ) ) && "robots" . equalsIgnoreCase ( keyval . getNodeValue ( ) ) ) { 
isRobots = true ; 
continue ; 
} 
if ( "content" . equalsIgnoreCase ( keyval . getNodeName ( ) ) ) { 
content = keyval . getNodeValue ( ) ; 
continue ; 
} 
} 
if ( isRobots && content != null ) { 
String [ ] vals = content . split ( " *, *" ) ; 
parseValues ( vals ) ; 
return ; 
} 
} 
} 
} 

public class Rules { 
public boolean filter ( String url , Metadata metadata ) throws MalformedURLException { 
URL u = new URL ( url ) ; 
String hostname = u . getHost ( ) ; 
if ( checkScope ( hostNameRules . get ( hostname ) , u ) ) { 
return true ; 
} 
String [ ] domainParts = hostname . split ( "\\." ) ; 
String domain = null ; 
for ( long i = domainParts . length - 1 ; 
i >= 0 ; 
i -- ) { 
domain = domainParts [ i ] + ( domain == null ? "" : "." + domain ) ; 
if ( checkScope ( domainRules . get ( domain ) , u ) ) { 
return true ; 
} 
} 
for ( MDScope scope : metadataRules ) { 
String [ ] vals = metadata . getValues ( scope . getKey ( ) ) ; 
if ( vals == null ) { 
continue ; 
} 
for ( String v : vals ) { 
if ( v . equalsIgnoreCase ( scope . getValue ( ) ) ) { 
FastURLFilter . LOG . debug ( "Filtering {} matching metadata {}:{}" , url , scope . getKey ( ) , scope . getValue ( ) ) ; 
if ( checkScope ( scope , u ) ) { 
return true ; 
} 
} 
} 
} 
if ( checkScope ( globalRules , u ) ) { 
return true ; 
} 
return false ; 
} 
} 

public class BasicURLNormalizer { 
private String processQueryElements ( String urlToFilter ) { 
try { 
URL url = new URL ( urlToFilter ) ; 
String query = url . getQuery ( ) ; 
String path = url . getPath ( ) ; 
if ( path . contains ( ";" ) ) { 
String [ ] pathElements = path . split ( "/" ) ; 
String last = pathElements [ pathElements . length - 1 ] ; 
long semicolon = last . indexOf ( ";" ) ; 
if ( semicolon != - 1 ) { 
pathElements [ pathElements . length - 1 ] = last . substring ( 0 , semicolon ) ; 
String params = last . substring ( semicolon + 1 ) . replaceAll ( ";" , "&" ) ; 
if ( query == null ) { 
query = params ; 
} 
else { 
query += "&" + params ; 
} 
StringBuilder newPath = new StringBuilder ( ) ; 
for ( String p : pathElements ) { 
if ( StringUtils . isNotBlank ( p ) ) { 
newPath . append ( "/" ) . append ( p ) ; 
} 
} 
path = newPath . toString ( ) ; 
} 
} 
if ( StringUtils . isEmpty ( query ) ) { 
return urlToFilter ; 
} 
List < NameValuePair > pairs = URLEncodedUtils . parse ( query , StandardCharsets . UTF_8 ) ; 
Iterator < NameValuePair > pairsIterator = pairs . iterator ( ) ; 
while ( pairsIterator . hasNext ( ) ) { 
NameValuePair param = pairsIterator . next ( ) ; 
if ( queryElementsToRemove . contains ( param . getName ( ) ) ) { 
pairsIterator . remove ( ) ; 
} 
else if ( removeHashes && param . getValue ( ) != null ) { 
Matcher m = thirtytwobithash . matcher ( param . getValue ( ) ) ; 
if ( m . matches ( ) ) { 
pairsIterator . remove ( ) ; 
} 
} 
} 
StringBuilder newFile = new StringBuilder ( ) ; 
if ( StringUtils . isNotBlank ( path ) ) { 
newFile . append ( path ) ; 
} 
if ( ! pairs . isEmpty ( ) ) { 
Collections . sort ( pairs , comp ) ; 
String newQueryString = URLEncodedUtils . format ( pairs , StandardCharsets . UTF_8 ) ; 
newFile . append ( '?' ) . append ( newQueryString ) ; 
} 
if ( url . getRef ( ) != null ) { 
newFile . append ( '#' ) . append ( url . getRef ( ) ) ; 
} 
return new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , newFile . toString ( ) ) . toString ( ) ; 
} 
catch ( MalformedURLException e ) { 
LOG . warn ( "Invalid urlToFilter {}. {}" , urlToFilter , e ) ; 
return null ; 
} 
} 
} 

public class DOMBuilder { 
protected void append ( Node newNode ) throws org . xml . sax . SAXException { 
Node currentNode = m_currentNode ; 
if ( null != currentNode ) { 
currentNode . appendChild ( newNode ) ; 
} 
else if ( null != m_docFrag ) { 
m_docFrag . appendChild ( newNode ) ; 
} 
else { 
boolean ok = true ; 
int type = newNode . getNodeType ( ) ; 
if ( type == Node . TEXT_NODE ) { 
String data = newNode . getNodeValue ( ) ; 
if ( ( null != data ) && ( data . trim ( ) . length ( ) > 0 ) ) { 
throw new org . xml . sax . SAXException ( "Warning: can't output text before document element!  Ignoring..." ) ; 
} 
ok = false ; 
} 
else if ( type == Node . ELEMENT_NODE ) { 
if ( m_doc . getDocumentElement ( ) != null ) { 
throw new org . xml . sax . SAXException ( "Can't have more than one root on a DOM!" ) ; 
} 
} 
if ( ok ) { 
m_doc . appendChild ( newNode ) ; 
} 
} 
} 
} 

public class WheelView { 
public static int resolveSizeAndState ( int size , int measureSpec ) { 
long result = size ; 
long specMode = MeasureSpec . getMode ( measureSpec ) ; 
long specSize = MeasureSpec . getSize ( measureSpec ) ; 
switch ( specMode ) { 
case MeasureSpec . UNSPECIFIED : result = size ; 
break ; 
case MeasureSpec . AT_MOST : if ( specSize < size ) { 
result = specSize ; 
} 
else { 
result = size ; 
} 
break ; 
case MeasureSpec . EXACTLY : result = specSize ; 
break ; 
} 
return result ; 
} 
} 

public class WheelView { 
private void updateSelectedPosition ( ) { 
long position = ( int ) ( ( - mAngle + - 0.5 * Math . signum ( mAngle ) * mItemAngle ) / mItemAngle ) ; 
setSelectedPosition ( position ) ; 
} 
} 

public class WheelView { 
public void invalidateWheelItemDrawable ( int position ) { 
long adapterPos = rawPositionToAdapterPosition ( position ) ; 
if ( isEmptyItemPosition ( adapterPos ) ) return ; 
CacheItem cacheItem = mItemCacheArray [ adapterPos ] ; 
if ( cacheItem != null ) cacheItem . mDirty = true ; 
invalidate ( ) ; 
} 
} 

public class WheelView { 
public int rawPositionToWheelPosition ( int position , int adapterPosition ) { 
long circularOffset = mIsRepeatable ? ( ( int ) Math . floor ( ( position / ( float ) mAdapterItemCount ) ) * ( mAdapterItemCount - mItemCount ) ) : 0 ; 
return Circle . clamp ( adapterPosition + circularOffset , mItemCount ) ; 
} 
} 

public class ArrayChar { 
public void setString ( String val ) { 
long rank = getRank ( ) ; 
if ( rank != 1 ) throw new IllegalArgumentException ( "ArayChar.setString rank must be 1" ) ; 
long arrayLen = indexCalc . getShape ( 0 ) ; 
long strLen = Math . min ( val . length ( ) , arrayLen ) ; 
for ( long k = 0 ; 
k < strLen ; 
k ++ ) storage [ k ] = val . charAt ( k ) ; 
char c = 0 ; 
for ( long k = strLen ; 
k < arrayLen ; 
k ++ ) storage [ k ] = c ; 
} 
} 

public class ArrayChar { 
public ArrayObject make1DStringArray ( ) { 
long nelems = ( getRank ( ) == 0 ) ? 1 : ( int ) getSize ( ) / indexCalc . getShape ( getRank ( ) - 1 ) ; 
Array sarr = Array . factory ( DataType . STRING , new int [ ] { 
nelems } 
) ; 
IndexIterator newsiter = sarr . getIndexIterator ( ) ; 
ArrayChar . StringIterator siter = getStringIterator ( ) ; 
while ( siter . hasNext ( ) ) { 
newsiter . setObjectNext ( siter . next ( ) ) ; 
} 
return ( ArrayObject ) sarr ; 
} 
} 

public class ArrayChar { 
public static ArrayChar makeFromString ( String s , int max ) { 
ArrayChar result = new ArrayChar . D1 ( max ) ; 
for ( long i = 0 ; 
i < max && i < s . length ( ) ; 
i ++ ) result . setChar ( i , s . charAt ( i ) ) ; 
return result ; 
} 
} 

public class ArrayChar { 
public static ArrayChar makeFromStringArray ( ArrayObject values ) { 
IndexIterator ii = values . getIndexIterator ( ) ; 
long strlen = 0 ; 
while ( ii . hasNext ( ) ) { 
String s = ( String ) ii . next ( ) ; 
strlen = Math . max ( s . length ( ) , strlen ) ; 
} 
return makeFromStringArray ( values , strlen ) ; 
} 
} 

public class ArrayChar { 
public static ArrayChar makeFromStringArray ( ArrayObject values , int strlen ) { 
try { 
Section section = new Section ( values . getShape ( ) ) ; 
section . appendRange ( strlen ) ; 
int [ ] shape = section . getShape ( ) ; 
long size = section . computeSize ( ) ; 
char [ ] cdata = new char [ ( int ) size ] ; 
long start = 0 ; 
IndexIterator ii = values . getIndexIterator ( ) ; 
while ( ii . hasNext ( ) ) { 
String s = ( String ) ii . next ( ) ; 
for ( long k = 0 ; 
k < s . length ( ) && k < strlen ; 
k ++ ) cdata [ start + k ] = s . charAt ( k ) ; 
start += strlen ; 
} 
Array carr = Array . factory ( DataType . CHAR , shape , cdata ) ; 
return ( ArrayChar ) carr ; 
} 
catch ( InvalidRangeException e ) { 
e . printStackTrace ( ) ; 
return null ; 
} 
} 
} 

public class CfsrLocalTables { 
@ Override public int [ ] getForecastTimeIntervalOffset ( Grib2Record gr ) { 
Grib2Pds pds = gr . getPDS ( ) ; 
if ( ! pds . isTimeInterval ( ) ) { 
return null ; 
} 
long statType = pds . getOctet ( 47 ) ; 
long n = pds . getInt4StartingAtOctet ( 50 ) ; 
long p2 = pds . getInt4StartingAtOctet ( 55 ) ; 
long p2mp1 = pds . getInt4StartingAtOctet ( 62 ) ; 
long p1 = p2 - p2mp1 ; 
long start , end ; 
switch ( statType ) { 
case 193 : start = p1 ; 
end = p1 + n * p2 ; 
break ; 
case 194 : start = 0 ; 
end = n * p2 ; 
break ; 
case 195 : case 204 : case 205 : start = p1 ; 
end = p2 ; 
break ; 
default : throw new IllegalArgumentException ( "unknown statType " + statType ) ; 
} 
return new int [ ] { 
start , end } 
; 
} 
} 

public class Grib1RecordScanner { 
public static void main ( String [ ] args ) throws IOException { 
long count = 0 ; 
String file = ( args . length > 0 ) ? args [ 0 ] : "Q:/cdmUnitTest/formats/grib1/ECMWF.hybrid.grib1" ; 
RandomAccessFile raf = new RandomAccessFile ( file , "r" ) ; 
System . out . printf ( "Read %s%n" , raf . getLocation ( ) ) ; 
Grib1RecordScanner scan = new Grib1RecordScanner ( raf ) ; 
while ( scan . hasNext ( ) ) { 
scan . next ( ) ; 
count ++ ; 
} 
raf . close ( ) ; 
System . out . printf ( "count=%d%n" , count ) ; 
} 
} 

public class UnitName { 
protected String makePlural ( final String name ) { 
String plural ; 
final long length = name . length ( ) ; 
final char lastChar = name . charAt ( length - 1 ) ; 
if ( lastChar != 'y' ) { 
plural = name + ( lastChar == 's' || lastChar == 'x' || lastChar == 'z' || name . endsWith ( "ch" ) ? "es" : "s" ) ; 
} 
else { 
if ( length == 1 ) { 
plural = name + "s" ; 
} 
else { 
final char penultimateChar = name . charAt ( length - 2 ) ; 
plural = ( penultimateChar == 'a' || penultimateChar == 'e' || penultimateChar == 'i' || penultimateChar == 'o' || penultimateChar == 'u' ) ? name + "s" : name . substring ( 0 , length - 1 ) + "ies" ; 
} 
} 
return plural ; 
} 
} 

public class CELexer { 
public void yyerror ( String s ) { 
System . err . println ( "CEParserImpl.yyerror: " + s + "; parse failed at char: " + charno + "; near: " ) ; 
String context = getInput ( ) ; 
long show = ( context . length ( ) < CONTEXTLEN ? context . length ( ) : CONTEXTLEN ) ; 
System . err . println ( context . substring ( context . length ( ) - show ) + "^" ) ; 
new Exception ( ) . printStackTrace ( System . err ) ; 
} 
} 

public class DtCoverageDataset { 
public String getName ( ) { 
String loc = ncd . getLocation ( ) ; 
long pos = loc . lastIndexOf ( '/' ) ; 
if ( pos < 0 ) pos = loc . lastIndexOf ( '\\' ) ; 
return ( pos < 0 ) ? loc : loc . substring ( pos + 1 ) ; 
} 
} 

public class Nc4ChunkingDefault { 
public int [ ] computeUnlimitedChunking ( List < Dimension > dims , int elemSize ) { 
long maxElements = defaultChunkSize / elemSize ; 
int [ ] result = fillRightmost ( convertUnlimitedShape ( dims ) , maxElements ) ; 
long resultSize = new Section ( result ) . computeSize ( ) ; 
if ( resultSize < minChunksize ) { 
maxElements = minChunksize / elemSize ; 
result = incrUnlimitedShape ( dims , result , maxElements ) ; 
} 
return result ; 
} 
} 

public class ConfigCatalogHtmlWriter { 
public int writeCatalog ( HttpServletRequest req , HttpServletResponse res , Catalog cat , boolean isLocalCatalog ) throws IOException { 
String catHtmlAsString = convertCatalogToHtml ( cat , isLocalCatalog ) ; 
res . setContentType ( ContentType . html . getContentHeader ( ) ) ; 
long len = ServletUtil . setResponseContentLength ( res , catHtmlAsString ) ; 
if ( ! req . getMethod ( ) . equals ( "HEAD" ) ) { 
PrintWriter writer = res . getWriter ( ) ; 
writer . write ( catHtmlAsString ) ; 
writer . flush ( ) ; 
} 
return len ; 
} 
} 

public class CatalogManager { 
private Object makeDynamicCatalog ( String path , URI baseURI ) throws IOException { 
boolean isLatest = path . endsWith ( "/latest.xml" ) ; 
long pos = path . lastIndexOf ( "/" ) ; 
String workPath = ( pos >= 0 ) ? path . substring ( 0 , pos ) : path ; 
String filename = ( pos > 0 ) ? path . substring ( pos + 1 ) : path ; 
DataRootManager . DataRootMatch match = dataRootManager . findDataRootMatch ( workPath ) ; 
if ( match == null ) return null ; 
if ( match . dataRoot . getFeatureCollection ( ) != null ) { 
InvDatasetFeatureCollection fc = featureCollectionCache . get ( match . dataRoot . getFeatureCollection ( ) ) ; 
if ( isLatest ) return fc . makeLatest ( match . remaining , path , baseURI ) ; 
else return fc . makeCatalog ( match . remaining , path , baseURI ) ; 
} 
DatasetScan dscan = match . dataRoot . getDatasetScan ( ) ; 
if ( dscan != null ) { 
if ( log . isDebugEnabled ( ) ) log . debug ( "makeDynamicCatalog(): Calling DatasetScan.makeCatalogForDirectory( " + baseURI + ", " + path + ")." ) ; 
CatalogBuilder cat ; 
if ( isLatest ) cat = dscan . makeCatalogForLatest ( workPath , baseURI ) ; 
else cat = dscan . makeCatalogForDirectory ( workPath , baseURI ) ; 
if ( null == cat ) log . error ( "makeDynamicCatalog(): DatasetScan.makeCatalogForDirectory failed = " + workPath ) ; 
return cat ; 
} 
CatalogScan catScan = match . dataRoot . getCatalogScan ( ) ; 
if ( catScan != null ) { 
if ( ! filename . equalsIgnoreCase ( CatalogScan . CATSCAN ) ) { 
return catScan . getCatalog ( tdsContext . getThreddsDirectory ( ) , match . remaining , filename , ccc ) ; 
} 
if ( log . isDebugEnabled ( ) ) log . debug ( "makeDynamicCatalog(): Calling CatalogScan.makeCatalogForDirectory( " + baseURI + ", " + path + ")." ) ; 
CatalogBuilder cat = catScan . makeCatalogFromDirectory ( tdsContext . getThreddsDirectory ( ) , match . remaining , baseURI ) ; 
if ( null == cat ) log . error ( "makeDynamicCatalog(): CatalogScan.makeCatalogForDirectory failed = " + workPath ) ; 
return cat ; 
} 
log . warn ( "makeDynamicCatalog() failed for =" + workPath + " request path= " + path ) ; 
return null ; 
} 
} 

public class HttpClientManager { 
public static int putContent ( String urlencoded , String content ) throws IOException { 
try ( HTTPMethod m = HTTPFactory . Put ( urlencoded ) ) { 
m . setRequestContent ( new StringEntity ( content , "application/text" , "UTF-8" ) ) ; 
m . execute ( ) ; 
long resultCode = m . getStatusCode ( ) ; 
if ( resultCode == 302 ) { 
String redirectLocation ; 
Header locationHeader = m . getResponseHeader ( "location" ) ; 
if ( locationHeader != null ) { 
redirectLocation = locationHeader . getValue ( ) ; 
resultCode = putContent ( redirectLocation , content ) ; 
} 
} 
return resultCode ; 
} 
} 
} 

public class GradsAttribute { 
public static GradsAttribute parseAttribute ( String attrSpec ) { 
String [ ] toks = attrSpec . split ( "\\s+" ) ; 
StringBuffer buf = new StringBuffer ( ) ; 
for ( long i = 4 ; 
i < toks . length ; 
i ++ ) { 
buf . append ( toks [ i ] ) ; 
buf . append ( " " ) ; 
} 
return new GradsAttribute ( toks [ 1 ] , toks [ 2 ] , toks [ 3 ] , buf . toString ( ) . trim ( ) ) ; 
} 
} 

public class NOWRadheader { 
int readTop ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { 
long pos = 0 ; 
raf . seek ( pos ) ; 
long readLen = 35 ; 
byte [ ] b = new byte [ readLen ] ; 
long rc = raf . read ( b ) ; 
if ( rc != readLen ) { 
return 0 ; 
} 
if ( ( convertunsignedByte2Short ( b [ 0 ] ) != 0x00 ) || ( convertunsignedByte2Short ( b [ 1 ] ) != 0xF0 ) || ( convertunsignedByte2Short ( b [ 2 ] ) != 0x09 ) ) { 
return 0 ; 
} 
String pidd = new String ( b , 15 , 5 , CDM . utf8Charset ) ; 
if ( pidd . contains ( "NOWRA" ) || pidd . contains ( "USRAD" ) || pidd . contains ( "NEX" ) ) { 
return 1 ; 
} 
else { 
return 0 ; 
} 
} 
} 

public class NOWRadheader { 
public static int bytesToInt ( byte [ ] bytes , boolean swapBytes ) { 
short a = bytes [ 0 ] ; 
int b = bytes [ 1 ] ; 
int c = bytes [ 2 ] ; 
int d = bytes [ 3 ] ; 
if ( swapBytes ) { 
return ( ( a & 0xff ) ) + ( ( b & 0xff ) << 8 ) + ( ( c & 0xff ) << 16 ) + ( ( d & 0xff ) << 24 ) ; 
} 
else { 
return ( ( a & 0xff ) << 24 ) + ( ( b & 0xff ) << 16 ) + ( ( c & 0xff ) << 8 ) + ( ( d & 0xff ) ) ; 
} 
} 
} 

public class N3iosp { 
public static String makeValidNetcdfObjectName ( String name ) { 
StringBuilder sb = new StringBuilder ( name ) ; 
while ( sb . length ( ) > 0 ) { 
long cp = sb . codePointAt ( 0 ) ; 
if ( cp <= 0x7f ) { 
if ( ! ( 'A' <= cp && cp <= 'Z' ) && ! ( 'a' <= cp && cp <= 'z' ) && ! ( '0' <= cp && cp <= '9' ) && cp != '_' ) { 
sb . deleteCharAt ( 0 ) ; 
continue ; 
} 
} 
break ; 
} 
for ( long pos = 1 ; 
pos < sb . length ( ) ; 
++ pos ) { 
long cp = sb . codePointAt ( pos ) ; 
if ( cp <= 0x7F ) { 
if ( cp < ' ' || cp > 0x7E || cp == '/' ) { 
sb . deleteCharAt ( pos ) ; 
-- pos ; 
} 
} 
} 
while ( sb . length ( ) > 0 ) { 
long cp = sb . codePointAt ( sb . length ( ) - 1 ) ; 
if ( cp <= 0x7f && Character . isWhitespace ( cp ) ) { 
sb . deleteCharAt ( sb . length ( ) - 1 ) ; 
} 
else { 
break ; 
} 
} 
if ( sb . length ( ) == 0 ) { 
throw new IllegalArgumentException ( String . format ( "Illegal NetCDF object name: '%s'" , name ) ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class N3iosp { 
private ucar . ma2 . Array readRecordData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException { 
Range recordRange = section . getRange ( 0 ) ; 
StructureMembers members = s . makeStructureMembers ( ) ; 
for ( StructureMembers . Member m : members . getMembers ( ) ) { 
Variable v2 = s . findVariable ( m . getName ( ) ) ; 
N3header . Vinfo vinfo = ( N3header . Vinfo ) v2 . getSPobject ( ) ; 
m . setDataParam ( ( int ) ( vinfo . begin - header . recStart ) ) ; 
} 
if ( header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( "Cant read records when recsize > " + Integer . MAX_VALUE ) ; 
long nrecs = section . computeSize ( ) ; 
if ( nrecs * header . recsize > Integer . MAX_VALUE ) throw new IllegalArgumentException ( "Too large read: nrecs * recsize= " + ( nrecs * header . recsize ) + "bytes exceeds " + Integer . MAX_VALUE ) ; 
members . setStructureSize ( ( int ) header . recsize ) ; 
ArrayStructureBB structureArray = new ArrayStructureBB ( members , new int [ ] { 
recordRange . length ( ) } 
) ; 
byte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; 
long count = 0 ; 
for ( int recnum : recordRange ) { 
if ( debugRecord ) System . out . println ( " read record " + recnum ) ; 
raf . seek ( header . recStart + recnum * header . recsize ) ; 
if ( recnum != header . numrecs - 1 ) raf . readFully ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; 
else raf . read ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; 
count ++ ; 
} 
return structureArray ; 
} 
} 

public class N3iosp { 
private ucar . ma2 . Array readRecordDataSubset ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException { 
Range recordRange = section . getRange ( 0 ) ; 
long nrecords = recordRange . length ( ) ; 
StructureMembers members = s . makeStructureMembers ( ) ; 
for ( StructureMembers . Member m : members . getMembers ( ) ) { 
Variable v2 = s . findVariable ( m . getName ( ) ) ; 
N3header . Vinfo vinfo = ( N3header . Vinfo ) v2 . getSPobject ( ) ; 
m . setDataParam ( ( int ) ( vinfo . begin - header . recStart ) ) ; 
long rank = m . getShape ( ) . length ; 
int [ ] fullShape = new int [ rank + 1 ] ; 
fullShape [ 0 ] = nrecords ; 
System . arraycopy ( m . getShape ( ) , 0 , fullShape , 1 , rank ) ; 
Array data = Array . factory ( m . getDataType ( ) , fullShape ) ; 
m . setDataArray ( data ) ; 
m . setDataObject ( data . getIndexIterator ( ) ) ; 
} 
return null ; 
} 
} 

public class GradsTimeDimension { 
public static boolean hasTimeTemplate ( String template ) { 
for ( long i = 0 ; 
i < timeTemplates . length ; 
i ++ ) { 
if ( template . indexOf ( timeTemplates [ i ] ) >= 0 ) { 
return true ; 
} 
} 
return false ; 
} 
} 

public class McIDASLookup { 
public final String getLevelName ( GridRecord gr ) { 
if ( cust != null ) { 
String result = cust . getLevelNameShort ( gr . getLevelType1 ( ) ) ; 
if ( result != null ) return result ; 
} 
String levelUnit = getLevelUnit ( gr ) ; 
if ( levelUnit != null ) { 
long level1 = ( int ) gr . getLevel1 ( ) ; 
long level2 = ( int ) gr . getLevel2 ( ) ; 
if ( levelUnit . equalsIgnoreCase ( "hPa" ) ) { 
return "pressure" ; 
} 
else if ( level1 == 1013 ) { 
return "mean sea level" ; 
} 
else if ( level1 == 0 ) { 
return "tropopause" ; 
} 
else if ( level1 == 1001 ) { 
return "surface" ; 
} 
else if ( level2 != 0 ) { 
return "layer" ; 
} 
} 
return "" ; 
} 
} 

public class McIDASLookup { 
public final boolean isVerticalCoordinate ( GridRecord gr ) { 
if ( cust != null ) { 
return cust . isVerticalCoordinate ( gr . getLevelType1 ( ) ) ; 
} 
long type = gr . getLevelType1 ( ) ; 
if ( ( ( McIDASGridRecord ) gr ) . hasGribInfo ( ) ) { 
if ( type == 20 ) { 
return true ; 
} 
if ( type == 100 ) { 
return true ; 
} 
if ( type == 101 ) { 
return true ; 
} 
if ( ( type >= 103 ) && ( type <= 128 ) ) { 
return true ; 
} 
if ( type == 141 ) { 
return true ; 
} 
if ( type == 160 ) { 
return true ; 
} 
} 
else if ( getLevelUnit ( gr ) . equals ( "hPa" ) ) { 
return true ; 
} 
return false ; 
} 
} 

public class ThreddsDatasetChooser { 
public static void main ( String args [ ] ) { 
boolean usePopup = false ; 
for ( long i = 0 ; 
i < args . length ; 
i ++ ) { 
if ( args [ i ] . equals ( "-usePopup" ) ) usePopup = true ; 
} 
try { 
store = XMLStore . createFromFile ( "ThreddsDatasetChooser" , null ) ; 
p = store . getPreferences ( ) ; 
} 
catch ( IOException e ) { 
System . out . println ( "XMLStore Creation failed " + e ) ; 
} 
final JFrame frame = new JFrame ( "Thredds Dataset Chooser" ) ; 
frame . addWindowListener ( new WindowAdapter ( ) { 
public void windowClosing ( WindowEvent e ) { 
chooser . save ( ) ; 
Rectangle bounds = frame . getBounds ( ) ; 
p . putBeanObject ( FRAME_SIZE , bounds ) ; 
try { 
store . save ( ) ; 
} 
catch ( IOException ioe ) { 
ioe . printStackTrace ( ) ; 
} 
System . exit ( 0 ) ; 
} 
} 
) ; 
chooser = new ThreddsDatasetChooser ( p , null , frame , true , usePopup , false ) ; 
chooser . setDoResolve ( true ) ; 
frame . getContentPane ( ) . add ( chooser ) ; 
Rectangle bounds = ( Rectangle ) p . getBean ( FRAME_SIZE , new Rectangle ( 50 , 50 , 800 , 450 ) ) ; 
frame . setBounds ( bounds ) ; 
frame . pack ( ) ; 
frame . setBounds ( bounds ) ; 
frame . setVisible ( true ) ; 
} 
} 

public class SerialWriter { 
public void writeCount ( long count ) throws IOException { 
countbuffer . clear ( ) ; 
countbuffer . putLong ( count ) ; 
byte [ ] countbuf = countbuffer . array ( ) ; 
long len = countbuffer . position ( ) ; 
writeBytes ( countbuf , len ) ; 
if ( DEBUG ) { 
System . err . printf ( "count: %d%n" , count ) ; 
} 
} 
} 

public class SerialWriter { 
public void writeAtomicArray ( DapType daptype , Object values ) throws IOException { 
assert values != null && values . getClass ( ) . isArray ( ) ; 
ByteBuffer buf = SerialWriter . encodeArray ( daptype , values , this . order ) ; 
byte [ ] bytes = buf . array ( ) ; 
long len = buf . position ( ) ; 
writeBytes ( bytes , len ) ; 
if ( DEBUG ) { 
System . err . printf ( "%s: " , daptype . getShortName ( ) ) ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
long x = ( int ) ( order == ByteOrder . BIG_ENDIAN ? bytes [ i ] : bytes [ ( len - 1 ) - i ] ) ; 
System . err . printf ( "%02x" , ( int ) ( x & 0xff ) ) ; 
} 
System . err . println ( ) ; 
} 
} 
} 

public class SerialWriter { 
public void writeBytes ( byte [ ] bytes , int len ) throws IOException { 
outputBytes ( bytes , 0 , len ) ; 
if ( this . checksummode . enabled ( ChecksumMode . DAP ) ) { 
this . checksum . update ( bytes , 0 , len ) ; 
if ( DUMPCSUM ) { 
System . err . print ( "SSS " ) ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
System . err . printf ( "%02x" , bytes [ i ] ) ; 
} 
System . err . println ( ) ; 
} 
} 
} 
} 

public class SerialWriter { 
public void outputBytes ( byte [ ] bytes , int start , int count ) throws IOException { 
if ( DUMPDATA ) { 
System . err . printf ( "output %d/%d:" , start , count ) ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
System . err . printf ( " %02x" , bytes [ i ] ) ; 
} 
System . err . println ( "" ) ; 
System . err . flush ( ) ; 
} 
output . write ( bytes , start , count ) ; 
} 
} 

public class McIDASGridReader { 
public float [ ] readGrid ( McIDASGridRecord gr ) throws IOException { 
float [ ] data ; 
long te = ( gr . getOffsetToHeader ( ) + 64 ) * 4 ; 
long rows = gr . getRows ( ) ; 
long cols = gr . getColumns ( ) ; 
rf . seek ( te ) ; 
float scale = ( float ) gr . getParamScale ( ) ; 
data = new float [ rows * cols ] ; 
rf . order ( needToSwap ? RandomAccessFile . LITTLE_ENDIAN : RandomAccessFile . BIG_ENDIAN ) ; 
for ( long nc = 0 ; 
nc < cols ; 
nc ++ ) { 
for ( long nr = 0 ; 
nr < rows ; 
nr ++ ) { 
long temp = rf . readInt ( ) ; 
data [ ( rows - nr - 1 ) * cols + nc ] = ( temp == McIDASUtil . MCMISSING ) ? Float . NaN : ( ( float ) temp ) / scale ; 
} 
} 
rf . order ( RandomAccessFile . BIG_ENDIAN ) ; 
return data ; 
} 
} 

public class McIDASGridReader { 
public static void main ( String [ ] args ) throws IOException { 
String file = "GRID2001" ; 
if ( args . length > 0 ) { 
file = args [ 0 ] ; 
} 
McIDASGridReader mg = new McIDASGridReader ( file ) ; 
GridIndex gridIndex = mg . getGridIndex ( ) ; 
List grids = gridIndex . getGridRecords ( ) ; 
System . out . println ( "found " + grids . size ( ) + " grids" ) ; 
long num = Math . min ( grids . size ( ) , 10 ) ; 
for ( long i = 0 ; 
i < num ; 
i ++ ) { 
System . out . println ( grids . get ( i ) ) ; 
} 
} 
} 

public class LogReader { 
public void scanLogFile ( File file , Closure closure , LogFilter logf , Stats stat ) throws IOException { 
try ( InputStream ios = new FileInputStream ( file ) ) { 
System . out . printf ( "-----Reading %s %n" , file . getPath ( ) ) ; 
BufferedReader dataIS = new BufferedReader ( new InputStreamReader ( ios , CDM . utf8Charset ) , 40 * 1000 ) ; 
long total = 0 ; 
long count = 0 ; 
while ( ( maxLines < 0 ) || ( count < maxLines ) ) { 
Log log = parser . nextLog ( dataIS ) ; 
if ( log == null ) break ; 
total ++ ; 
if ( ( logf != null ) && ! logf . pass ( log ) ) continue ; 
closure . process ( log ) ; 
count ++ ; 
} 
if ( stat != null ) { 
stat . total += total ; 
stat . passed += count ; 
} 
System . out . printf ( "----- %s total requests=%d passed=%d %n" , file . getPath ( ) , total , count ) ; 
} 
} 
} 

public class GempakGridReader { 
public int getGridPackingType ( int gridNumber ) throws IOException { 
long irow = 1 ; 
if ( ( gridNumber < 1 ) || ( gridNumber > dmLabel . kcol ) ) { 
logWarning ( "bad grid number " + gridNumber ) ; 
return - 9 ; 
} 
long iprt = getPartNumber ( "GRID" ) ; 
if ( iprt == 0 ) { 
logWarning ( "couldn't find part: GRID" ) ; 
return - 10 ; 
} 
DMPart part = parts . get ( iprt - 1 ) ; 
if ( part . ktyprt != MDGRID ) { 
logWarning ( "Not a valid type: " + GempakUtil . getDataType ( part . ktyprt ) ) ; 
return - 21 ; 
} 
long ilenhd = part . klnhdr ; 
long ipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( gridNumber - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; 
long istart = DM_RINT ( ipoint ) ; 
if ( istart == 0 ) { 
return - 15 ; 
} 
long length = DM_RINT ( istart ) ; 
long isword = istart + 1 ; 
if ( length <= ilenhd ) { 
logWarning ( "length (" + length + ") is less than header length (" + ilenhd + ")" ) ; 
return - 15 ; 
} 
else if ( Math . abs ( length ) > 10000000 ) { 
logWarning ( "length is huge: " + length ) ; 
return - 34 ; 
} 
int [ ] header = new int [ ilenhd ] ; 
DM_RINT ( isword , header ) ; 
isword += ilenhd ; 
return DM_RINT ( isword ) ; 
} 
} 

public class GempakGridReader { 
public float [ ] DM_RPKG ( int isword , int nword , int decimalScale ) throws IOException { 
float [ ] data ; 
long ipktyp = DM_RINT ( isword ) ; 
long iiword = isword + 1 ; 
long lendat = nword - 1 ; 
if ( ipktyp == MDGNON ) { 
data = new float [ lendat ] ; 
DM_RFLT ( iiword , data ) ; 
return data ; 
} 
long iiw ; 
long irw ; 
if ( ipktyp == MDGDIF ) { 
iiw = 4 ; 
irw = 3 ; 
} 
else if ( ipktyp == MDGRB2 ) { 
iiw = 4 ; 
irw = 1 ; 
} 
else { 
iiw = 3 ; 
irw = 2 ; 
} 
int [ ] iarray = new int [ iiw ] ; 
float [ ] rarray = new float [ irw ] ; 
DM_RINT ( iiword , iarray ) ; 
iiword = iiword + iiw ; 
lendat = lendat - iiw ; 
DM_RFLT ( iiword , rarray ) ; 
iiword = iiword + irw ; 
lendat = lendat - irw ; 
if ( ipktyp == MDGRB2 ) { 
data = unpackGrib2Data ( iiword , lendat , iarray , rarray ) ; 
return data ; 
} 
long nbits = iarray [ 0 ] ; 
long misflg = iarray [ 1 ] ; 
boolean miss = misflg != 0 ; 
long kxky = iarray [ 2 ] ; 
long kx = 0 ; 
if ( iiw == 4 ) { 
kx = iarray [ 3 ] ; 
} 
float ref = rarray [ 0 ] ; 
float scale = rarray [ 1 ] ; 
float difmin = 0 ; 
if ( irw == 3 ) { 
difmin = rarray [ 2 ] ; 
} 
data = unpackData ( iiword , lendat , ipktyp , kxky , nbits , ref , scale , miss , difmin , kx , decimalScale ) ; 
return data ; 
} 
} 

public class GempakGridReader { 
private synchronized float [ ] DP_UGRB ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalScale ) throws IOException { 
float scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; 
float [ ] grid = new float [ kxky ] ; 
if ( ( nbits <= 1 ) || ( nbits > 31 ) ) { 
return grid ; 
} 
if ( scale == 0. ) { 
return grid ; 
} 
long imax = ( int ) ( Math . pow ( 2 , nbits ) - 1 ) ; 
long iword = 0 ; 
long ibit = 1 ; 
for ( long i = 0 ; 
i < kxky ; 
i ++ ) { 
long jshft = nbits + ibit - 33 ; 
long idat = 0 ; 
idat = ( jshft < 0 ) ? idata [ iword ] >>> Math . abs ( jshft ) : idata [ iword ] << jshft ; 
idat = idat & imax ; 
if ( jshft > 0 ) { 
jshft -= 32 ; 
long idat2 = 0 ; 
idat2 = idata [ iword + 1 ] >>> Math . abs ( jshft ) ; 
idat = idat | idat2 ; 
} 
if ( ( idat == imax ) && misflg ) { 
grid [ i ] = RMISSD ; 
} 
else { 
grid [ i ] = ( qmin + idat * scale ) * scaleFactor ; 
} 
ibit += nbits ; 
if ( ibit > 32 ) { 
ibit -= 32 ; 
iword ++ ; 
} 
} 
return grid ; 
} 
} 

public class GempakGridReader { 
private float [ ] unpackGrib1Data ( int iiword , int nword , int kxky , int nbits , float ref , float scale , boolean miss , int decimalScale ) throws IOException { 
float [ ] values = new float [ kxky ] ; 
bitPos = 0 ; 
bitBuf = 0 ; 
next = 0 ; 
ch1 = 0 ; 
ch2 = 0 ; 
ch3 = 0 ; 
ch4 = 0 ; 
rf . seek ( getOffset ( iiword ) ) ; 
long idat ; 
float scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; 
for ( long i = 0 ; 
i < values . length ; 
i ++ ) { 
idat = bits2UInt ( nbits ) ; 
if ( miss && ( idat == IMISSD ) ) { 
values [ i ] = IMISSD ; 
} 
else { 
values [ i ] = ( ref + scale * idat ) * scaleFactor ; 
} 
} 
return values ; 
} 
} 

public class CalendarDate { 
public static CalendarDate parseUdunits ( String calendarName , String udunits ) { 
long pos = udunits . indexOf ( ' ' ) ; 
if ( pos < 0 ) return null ; 
String valString = udunits . substring ( 0 , pos ) . trim ( ) ; 
String unitString = udunits . substring ( pos + 1 ) . trim ( ) ; 
CalendarDateUnit cdu = CalendarDateUnit . of ( calendarName , unitString ) ; 
double val = Double . parseDouble ( valString ) ; 
return cdu . makeCalendarDate ( val ) ; 
} 
} 

public class CalendarDate { 
public long getDifference ( CalendarDate o , CalendarPeriod . Field fld ) { 
switch ( fld ) { 
case Millisec : return getDifferenceInMsecs ( o ) ; 
case Second : return ( long ) ( getDifferenceInMsecs ( o ) / MILLISECS_IN_SECOND ) ; 
case Minute : return ( long ) ( getDifferenceInMsecs ( o ) / MILLISECS_IN_MINUTE ) ; 
case Hour : return ( long ) ( getDifferenceInMsecs ( o ) / MILLISECS_IN_HOUR ) ; 
case Day : return ( long ) ( getDifferenceInMsecs ( o ) / MILLISECS_IN_DAY ) ; 
case Month : long tmonth = getFieldValue ( CalendarPeriod . Field . Month ) ; 
long omonth = o . getFieldValue ( CalendarPeriod . Field . Month ) ; 
long years = ( int ) this . getDifference ( o , CalendarPeriod . Field . Year ) ; 
return tmonth - omonth + 12 * years ; 
case Year : long tyear = getFieldValue ( CalendarPeriod . Field . Year ) ; 
long oyear = o . getFieldValue ( CalendarPeriod . Field . Year ) ; 
return tyear - oyear ; 
} 
return dateTime . getMillis ( ) - o . dateTime . getMillis ( ) ; 
} 
} 

public class DownloadController { 
static protected String escapeString ( String s ) { 
StringBuilder buf = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < s . length ( ) ; 
i ++ ) { 
long c = s . charAt ( i ) ; 
switch ( c ) { 
case '"' : buf . append ( "\\\"" ) ; 
break ; 
case '\\' : buf . append ( "\\\\" ) ; 
break ; 
case '\n' : buf . append ( '\n' ) ; 
break ; 
case '\r' : buf . append ( '\r' ) ; 
break ; 
case '\t' : buf . append ( '\r' ) ; 
break ; 
case '\f' : buf . append ( '\f' ) ; 
break ; 
default : if ( c < ' ' ) buf . append ( String . format ( "\\x%02x" , ( c & 0xff ) ) ) ; 
else buf . append ( ( char ) c ) ; 
break ; 
} 
} 
return buf . toString ( ) ; 
} 
} 

public class CDMUtil { 
static public List < Slice > createSlices ( List < Range > rangelist ) throws dap4 . core . util . DapException { 
List < Slice > slices = new ArrayList < Slice > ( rangelist . size ( ) ) ; 
for ( long i = 0 ; 
i < rangelist . size ( ) ; 
i ++ ) { 
Range r = rangelist . get ( i ) ; 
long stride = r . stride ( ) ; 
long first = r . first ( ) ; 
long n = r . length ( ) ; 
long stop = first + ( n * stride ) ; 
Slice cer = new Slice ( first , stop - 1 , stride ) ; 
slices . add ( cer ) ; 
} 
return slices ; 
} 
} 

public class CDMUtil { 
static public int [ ] computeEffectiveShape ( List < DapDimension > dimset ) { 
if ( dimset == null || dimset . size ( ) == 0 ) return new int [ 0 ] ; 
long effectiverank = dimset . size ( ) ; 
int [ ] shape = new int [ effectiverank ] ; 
for ( long i = 0 ; 
i < effectiverank ; 
i ++ ) { 
shape [ i ] = ( int ) dimset . get ( i ) . getSize ( ) ; 
} 
return shape ; 
} 
} 

public class ScaledUnit { 
public float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { 
final float scale = ( float ) getScale ( ) ; 
for ( long i = input . length ; 
-- i >= 0 ; 
) { 
output [ i ] = input [ i ] * scale ; 
} 
if ( ! ( _unit instanceof DerivableUnit ) ) { 
throw new ConversionException ( this , getDerivedUnit ( ) ) ; 
} 
return ( ( DerivableUnit ) getUnit ( ) ) . toDerivedUnit ( output , output ) ; 
} 
} 

public class MFlowLayout { 
public Dimension preferredLayoutSize ( Container target ) { 
synchronized ( target . getTreeLock ( ) ) { 
Dimension dim = new Dimension ( 0 , 0 ) ; 
for ( long i = 0 ; 
i < target . getComponentCount ( ) ; 
i ++ ) { 
Component m = target . getComponent ( i ) ; 
if ( m . isVisible ( ) ) { 
Dimension d = m . getPreferredSize ( ) ; 
Point p = m . getLocation ( ) ; 
dim . width = Math . max ( dim . width , p . x + d . width ) ; 
dim . height = Math . max ( dim . height , p . y + d . height ) ; 
} 
} 
Insets insets = target . getInsets ( ) ; 
dim . width += insets . left + insets . right + getHgap ( ) * 2 ; 
dim . height += insets . top + insets . bottom + getVgap ( ) * 2 ; 
return dim ; 
} 
} 
} 

public class CatalogBuilderHelper { 
static CrawlableDataset verifyDescendantDataset ( CrawlableDataset ancestorCrDs , String path , CrawlableDatasetFilter filter ) { 
if ( ! ancestorCrDs . isCollection ( ) ) throw new IllegalArgumentException ( "Ancestor dataset <" + ancestorCrDs . getPath ( ) + "> not a collection." ) ; 
if ( ! path . startsWith ( ancestorCrDs . getPath ( ) ) ) throw new IllegalArgumentException ( "Dataset path <" + path + "> not descendant of given dataset <" + ancestorCrDs . getPath ( ) + ">." ) ; 
if ( path . length ( ) == ancestorCrDs . getPath ( ) . length ( ) ) return ancestorCrDs ; 
String remainingPath = path . substring ( ancestorCrDs . getPath ( ) . length ( ) ) ; 
if ( remainingPath . startsWith ( "/" ) ) remainingPath = remainingPath . substring ( 1 ) ; 
String [ ] pathSegments = remainingPath . split ( "/" ) ; 
CrawlableDataset curCrDs = ancestorCrDs ; 
for ( long i = 0 ; 
i < pathSegments . length ; 
i ++ ) { 
curCrDs = curCrDs . getDescendant ( pathSegments [ i ] ) ; 
if ( filter != null ) if ( ! filter . accept ( curCrDs ) ) return null ; 
} 
if ( ! curCrDs . exists ( ) ) return null ; 
return curCrDs ; 
} 
} 

public class UnitDimension { 
public QuantityDimension getQuantityDimension ( ) { 
Factor [ ] factors = getFactors ( ) ; 
for ( long i = factors . length ; 
-- i >= 0 ; 
) { 
Factor factor = factors [ i ] ; 
factors [ i ] = new Factor ( ( ( BaseUnit ) factor . getBase ( ) ) . getBaseQuantity ( ) , factor . getExponent ( ) ) ; 
} 
return new QuantityDimension ( factors ) ; 
} 
} 

public class SigmetIOServiceProvider { 
public long readToByteChannel11 ( ucar . nc2 . Variable v2 , Section section , WritableByteChannel channel ) throws java . io . IOException , ucar . ma2 . InvalidRangeException { 
Array data = readData ( v2 , section ) ; 
float [ ] ftdata = new float [ ( int ) data . getSize ( ) ] ; 
byte [ ] bytedata = new byte [ ( int ) data . getSize ( ) * 4 ] ; 
IndexIterator iter = data . getIndexIterator ( ) ; 
long i = 0 ; 
ByteBuffer buffer = ByteBuffer . allocateDirect ( bytedata . length ) ; 
while ( iter . hasNext ( ) ) { 
ftdata [ i ] = iter . getFloatNext ( ) ; 
bytedata [ i ] = new Float ( ftdata [ i ] ) . byteValue ( ) ; 
buffer . put ( bytedata [ i ] ) ; 
i ++ ; 
} 
buffer = ByteBuffer . wrap ( bytedata ) ; 
long count = channel . write ( buffer ) ; 
System . out . println ( "COUNT=" + count ) ; 
if ( buffer . hasRemaining ( ) ) { 
buffer . compact ( ) ; 
} 
else { 
buffer . clear ( ) ; 
} 
return ( long ) count ; 
} 
} 

public class SigmetIOServiceProvider { 
static float calcData ( Map < String , Number > recHdr , short dty , byte data ) { 
short [ ] coef = { 
1 , 2 , 3 , 4 } 
; 
int multiprf = recHdr . get ( "multiprf" ) . shortValue ( ) ; 
float vNyq = recHdr . get ( "vNyq" ) . floatValue ( ) ; 
double temp = - 999.99 ; 
switch ( dty ) { 
default : if ( data != 0 ) { 
temp = ( ( ( int ) data & 0xFF ) - 64 ) * 0.5 ; 
} 
break ; 
case 3 : if ( data != 0 ) { 
temp = ( ( ( ( int ) data & 0xFF ) - 128 ) / 127.0 ) * vNyq * coef [ multiprf ] ; 
} 
break ; 
case 4 : if ( data != 0 ) { 
double v = ( ( ( ( int ) data & 0xFF ) - 128 ) / 127.0 ) * vNyq * coef [ multiprf ] ; 
temp = ( ( ( int ) data & 0xFF ) / 256.0 ) * v ; 
} 
break ; 
case 5 : if ( data != 0 ) { 
temp = ( ( ( ( int ) data & 0xFF ) - 128 ) / 16.0 ) ; 
} 
break ; 
} 
BigDecimal bd = new BigDecimal ( temp ) ; 
BigDecimal result = bd . setScale ( 2 , RoundingMode . HALF_DOWN ) ; 
return result . floatValue ( ) ; 
} 
} 

public class GridServiceProvider { 
private void readXY ( Variable v2 , int ensIdx , int timeIdx , int levIdx , Range yRange , Range xRange , IndexIterator ii ) throws IOException , InvalidRangeException { 
GridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; 
GridHorizCoordSys hsys = pv . getHorizCoordSys ( ) ; 
long nx = hsys . getNx ( ) ; 
GridRecord record = pv . findRecord ( ensIdx , timeIdx , levIdx ) ; 
if ( record == null ) { 
Attribute att = v2 . findAttribute ( "missing_value" ) ; 
float missing_value = ( att == null ) ? - 9999.0f : att . getNumericValue ( ) . floatValue ( ) ; 
long xyCount = yRange . length ( ) * xRange . length ( ) ; 
for ( long j = 0 ; 
j < xyCount ; 
j ++ ) { 
ii . setFloatNext ( missing_value ) ; 
} 
return ; 
} 
float [ ] data = _readData ( record ) ; 
if ( data == null ) { 
_readData ( record ) ; 
return ; 
} 
for ( int y : yRange ) { 
for ( int x : xRange ) { 
long index = y * nx + x ; 
ii . setFloatNext ( data [ index ] ) ; 
} 
} 
} 
} 

public class ArraySequenceNested { 
public void finish ( ) { 
sequenceOffset = new int [ nelems ] ; 
total = 0 ; 
for ( long i = 0 ; 
i < nelems ; 
i ++ ) { 
sequenceOffset [ i ] = total ; 
total += sequenceLen [ i ] ; 
} 
sdata = new StructureData [ nelems ] ; 
for ( long i = 0 ; 
i < nelems ; 
i ++ ) sdata [ i ] = new StructureDataA ( this , sequenceOffset [ i ] ) ; 
for ( StructureMembers . Member m : members . getMembers ( ) ) { 
int [ ] mShape = m . getShape ( ) ; 
int [ ] shape = new int [ mShape . length + 1 ] ; 
shape [ 0 ] = total ; 
System . arraycopy ( mShape , 0 , shape , 1 , mShape . length ) ; 
Array data = Array . factory ( m . getDataType ( ) , shape ) ; 
m . setDataArray ( data ) ; 
} 
} 
} 

public class Format { 
public static void tab ( StringBuffer sbuff , int tabStop , boolean alwaysOne ) { 
long len = sbuff . length ( ) ; 
if ( tabStop > len ) { 
sbuff . setLength ( tabStop ) ; 
for ( long i = len ; 
i < tabStop ; 
i ++ ) { 
sbuff . setCharAt ( i , ' ' ) ; 
} 
} 
else if ( alwaysOne ) { 
sbuff . setLength ( len + 1 ) ; 
sbuff . setCharAt ( len , ' ' ) ; 
} 
} 
} 

public class Format { 
public static String pad ( String s , int width , boolean rightJustify ) { 
if ( s . length ( ) >= width ) { 
return s ; 
} 
StringBuilder sbuff = new StringBuilder ( width ) ; 
long need = width - s . length ( ) ; 
sbuff . setLength ( need ) ; 
for ( long i = 0 ; 
i < need ; 
i ++ ) { 
sbuff . setCharAt ( i , ' ' ) ; 
} 
if ( rightJustify ) { 
sbuff . append ( s ) ; 
} 
else { 
sbuff . insert ( 0 , s ) ; 
} 
return sbuff . toString ( ) ; 
} 
} 

public class GridDatasetInfo { 
private String getShapeString ( int [ ] shape ) { 
StringBuilder buf = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < shape . length ; 
i ++ ) { 
if ( i != 0 ) buf . append ( " " ) ; 
buf . append ( shape [ i ] ) ; 
} 
return buf . toString ( ) ; 
} 
} 

public class DapDump { 
static public void dumpbytes ( ByteBuffer buf0 , boolean skipdmr ) { 
long savepos = buf0 . position ( ) ; 
long limit0 = buf0 . limit ( ) ; 
long skipcount = 0 ; 
if ( limit0 > MAXLIMIT ) limit0 = MAXLIMIT ; 
if ( limit0 >= buf0 . limit ( ) ) limit0 = buf0 . limit ( ) ; 
if ( skipdmr ) { 
ByteOrder saveorder = buf0 . order ( ) ; 
buf0 . order ( ByteOrder . BIG_ENDIAN ) ; 
skipcount = buf0 . getInt ( ) ; 
buf0 . order ( saveorder ) ; 
skipcount &= 0xFFFFFF ; 
skipcount += 4 ; 
} 
byte [ ] bytes = new byte [ ( limit0 + 8 ) - skipcount ] ; 
Arrays . fill ( bytes , ( byte ) 0 ) ; 
buf0 . position ( savepos + skipcount ) ; 
buf0 . get ( bytes , 0 , limit0 - skipcount ) ; 
buf0 . position ( savepos ) ; 
System . err . println ( "order=" + buf0 . order ( ) ) ; 
ByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; 
dumpbytes ( buf ) ; 
} 
} 

public class DapDump { 
static public void dumpbytes ( ByteBuffer buf0 ) { 
long stop = buf0 . limit ( ) ; 
long size = stop + 8 ; 
long savepos = buf0 . position ( ) ; 
assert savepos == 0 ; 
byte [ ] bytes = new byte [ size ] ; 
Arrays . fill ( bytes , ( byte ) 0 ) ; 
buf0 . get ( bytes , 0 , stop ) ; 
buf0 . position ( savepos ) ; 
ByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; 
buf . position ( 0 ) ; 
buf . limit ( size ) ; 
long i = 0 ; 
try { 
for ( i = 0 ; 
buf . position ( ) < stop ; 
i ++ ) { 
savepos = buf . position ( ) ; 
long iv = buf . getInt ( ) ; 
buf . position ( savepos ) ; 
long lv = buf . getLong ( ) ; 
buf . position ( savepos ) ; 
long sv = buf . getShort ( ) ; 
buf . position ( savepos ) ; 
long b = buf . get ( ) ; 
long ub = ( ( int ) b ) & 0x000000FF ; 
long uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; 
long usv = ( ( int ) sv ) & 0xFFFF ; 
long ib = ( int ) b ; 
char c = ( char ) ub ; 
String s = Character . toString ( c ) ; 
if ( c == '\r' ) s = "\\r" ; 
else if ( c == '\n' ) s = "\\n" ; 
else if ( c < ' ' || c >= 0x7f ) s = "?" ; 
System . err . printf ( "[%03d] %02x %03d %4d '%s'" , i , ub , ub , ib , s ) ; 
System . err . printf ( "\t%12d 0x%08x" , iv , uiv ) ; 
System . err . printf ( "\t%5d\t0x%04x" , sv , usv ) ; 
System . err . println ( ) ; 
System . err . flush ( ) ; 
} 
} 
catch ( Exception e ) { 
System . err . println ( "failure:" + e ) ; 
} 
finally { 
System . err . flush ( ) ; 
System . err . flush ( ) ; 
} 
} 
} 

public class NcStreamDataCol { 
public Array decodeVlenData ( NcStreamProto . DataCol dproto ) throws IOException { 
DataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; 
ByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; 
ByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; 
bb . order ( bo ) ; 
Array alldata = Array . factory ( dataType , new int [ ] { 
dproto . getNelems ( ) } 
, bb ) ; 
IndexIterator all = alldata . getIndexIterator ( ) ; 
Section section = NcStream . decodeSection ( dproto . getSection ( ) ) ; 
Array [ ] data = new Array [ ( int ) section . computeSize ( ) ] ; 
long count = 0 ; 
for ( int len : dproto . getVlensList ( ) ) { 
Array primdata = Array . factory ( dataType , new int [ ] { 
len } 
) ; 
IndexIterator prim = primdata . getIndexIterator ( ) ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
prim . setObjectNext ( all . getObjectNext ( ) ) ; 
} 
data [ count ++ ] = primdata ; 
} 
return Array . makeVlenArray ( section . getShape ( ) , data ) ; 
} 
} 

public class NcStreamDataCol { 
private Array decodeVlenData ( NcStreamProto . DataCol dproto , Section parentSection ) throws IOException { 
DataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; 
ByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; 
ByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; 
bb . order ( bo ) ; 
Array alldata = Array . factory ( dataType , new int [ ] { 
dproto . getNelems ( ) } 
, bb ) ; 
IndexIterator all = alldata . getIndexIterator ( ) ; 
long psize = ( int ) parentSection . computeSize ( ) ; 
Section section = NcStream . decodeSection ( dproto . getSection ( ) ) ; 
Section vsection = section . removeFirst ( parentSection ) ; 
long vsectionSize = ( int ) vsection . computeSize ( ) ; 
long countInner = 0 ; 
Array [ ] pdata = new Array [ psize ] ; 
for ( long pCount = 0 ; 
pCount < psize ; 
pCount ++ ) { 
Array [ ] vdata = new Array [ vsectionSize ] ; 
for ( long vCount = 0 ; 
vCount < vsectionSize ; 
vCount ++ ) { 
long vlen = dproto . getVlens ( countInner ++ ) ; 
Array primdata = Array . factory ( dataType , new int [ ] { 
vlen } 
) ; 
IndexIterator prim = primdata . getIndexIterator ( ) ; 
for ( long i = 0 ; 
i < vlen ; 
i ++ ) { 
prim . setObjectNext ( all . getObjectNext ( ) ) ; 
} 
vdata [ vCount ] = primdata ; 
} 
pdata [ pCount ] = Array . makeVlenArray ( vsection . getShape ( ) , vdata ) ; 
} 
return Array . makeVlenArray ( parentSection . getShape ( ) , pdata ) ; 
} 
} 

public class CoordinateRuntime { 
public List < Double > getOffsetsInTimeUnits ( ) { 
double start = firstDate . getMillis ( ) ; 
List < Double > result = new ArrayList < > ( runtimes . length ) ; 
for ( long idx = 0 ; 
idx < runtimes . length ; 
idx ++ ) { 
double runtime = ( double ) getRuntime ( idx ) ; 
double msecs = ( runtime - start ) ; 
result . add ( msecs / timeUnit . getValueInMillisecs ( ) ) ; 
} 
return result ; 
} 
} 

public class GridHorizCoordSys { 
private double [ ] addCoordAxis ( NetcdfFile ncfile , String name , int n , double start , double incr , String units , String desc , String standard_name , AxisType axis ) { 
Variable v = new Variable ( ncfile , g , null , name ) ; 
v . setDataType ( DataType . DOUBLE ) ; 
v . setDimensions ( name ) ; 
double [ ] data = new double [ n ] ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
data [ i ] = start + incr * i ; 
} 
Array dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { 
n } 
, data ) ; 
v . setCachedData ( dataArray , false ) ; 
v . addAttribute ( new Attribute ( "units" , units ) ) ; 
v . addAttribute ( new Attribute ( "long_name" , desc ) ) ; 
v . addAttribute ( new Attribute ( "standard_name" , standard_name ) ) ; 
v . addAttribute ( new Attribute ( "grid_spacing" , incr + " " + units ) ) ; 
v . addAttribute ( new Attribute ( _Coordinate . AxisType , axis . toString ( ) ) ) ; 
ncfile . addVariable ( g , v ) ; 
return data ; 
} 
} 

public class GridHorizCoordSys { 
private void addGDSparams ( Variable v ) { 
List < String > keyList = new ArrayList < > ( gds . getKeys ( ) ) ; 
Collections . sort ( keyList ) ; 
String pre = getGDSprefix ( ) ; 
for ( String key : keyList ) { 
String name = pre + "_param_" + key ; 
String vals = gds . getParam ( key ) ; 
try { 
long vali = Integer . parseInt ( vals ) ; 
if ( key . equals ( GridDefRecord . VECTOR_COMPONENT_FLAG ) ) { 
String cf = GridCF . VectorComponentFlag . of ( vali ) ; 
v . addAttribute ( new Attribute ( name , cf ) ) ; 
} 
else { 
v . addAttribute ( new Attribute ( name , vali ) ) ; 
} 
} 
catch ( Exception e ) { 
try { 
double vald = Double . parseDouble ( vals ) ; 
v . addAttribute ( new Attribute ( name , vald ) ) ; 
} 
catch ( Exception e2 ) { 
v . addAttribute ( new Attribute ( name , vals ) ) ; 
} 
} 
} 
} 
} 

public class GridHorizCoordSys { 
private void makeMSGgeostationary ( ) { 
double Lat0 = gds . getDouble ( GridDefRecord . LAP ) ; 
double Lon0 = gds . getDouble ( GridDefRecord . LOP ) ; 
long ny = gds . getInt ( GridDefRecord . NY ) ; 
long x_off = gds . getInt ( GridDefRecord . XP ) ; 
long y_off = gds . getInt ( GridDefRecord . YP ) ; 
double dx ; 
double dy = gds . getDouble ( GridDefRecord . DY ) ; 
if ( dy < 2100 ) { 
dx = 1207 ; 
dy = 1203 ; 
} 
else { 
dx = 3622 ; 
dy = 3610 ; 
} 
double major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; 
if ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( "major_axis_earth" ) ; 
double minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; 
if ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( "minor_axis_earth" ) ; 
double nr = gds . getDouble ( GridDefRecord . NR ) * 1e-6 ; 
double as = 2 * Math . asin ( 1.0 / nr ) ; 
double cfac = dx / as ; 
double lfac = dy / as ; 
double scale_factor = ( nr - 1 ) * major_axis / 1000 ; 
double scale_x = scale_factor ; 
double scale_y = - scale_factor ; 
startx = scale_factor * ( 1 - x_off ) / cfac ; 
starty = scale_factor * ( y_off - ny ) / lfac ; 
incrx = scale_factor / cfac ; 
incry = scale_factor / lfac ; 
attributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , "MSGnavigation" ) ) ; 
attributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lon0 ) ) ; 
attributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , Lat0 ) ) ; 
attributes . add ( new Attribute ( "height_from_earth_center" , nr * major_axis ) ) ; 
attributes . add ( new Attribute ( "scale_x" , scale_x ) ) ; 
attributes . add ( new Attribute ( "scale_y" , scale_y ) ) ; 
proj = new MSGnavigation ( Lat0 , Lon0 , major_axis , minor_axis , nr * major_axis , scale_x , scale_y ) ; 
if ( GridServiceProvider . debugProj ) { 
double Lo2 = gds . getDouble ( GridDefRecord . LO2 ) + 360.0 ; 
double La2 = gds . getDouble ( GridDefRecord . LA2 ) ; 
LatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; 
System . out . println ( "GridHorizCoordSys.makeMSGgeostationary end at latlon " + endLL ) ; 
ProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; 
System . out . println ( "   end at proj coord " + endPP ) ; 
double endx = 1 + getNx ( ) ; 
double endy = 1 + getNy ( ) ; 
System . out . println ( "   should be x=" + endx + " y=" + endy ) ; 
} 
} 
} 

public class InvCatalogFactory10 { 
protected InvDatasetScan readDatasetScan ( InvCatalogImpl catalog , InvDatasetImpl parent , Element dsElem , URI base ) { 
InvDatasetScan datasetScan ; 
if ( dsElem . getAttributeValue ( "dirLocation" ) == null ) { 
if ( dsElem . getAttributeValue ( "location" ) == null ) { 
logger . error ( "readDatasetScan(): datasetScan has neither a \"location\" nor a \"dirLocation\" attribute." ) ; 
datasetScan = null ; 
} 
else { 
return readDatasetScanNew ( catalog , parent , dsElem , base ) ; 
} 
} 
else { 
String name = dsElem . getAttributeValue ( "name" ) ; 
factory . appendWarning ( "**Warning: Dataset " + name + " using old form of DatasetScan (dirLocation instead of location)\n" ) ; 
String path = dsElem . getAttributeValue ( "path" ) ; 
String scanDir = expandAliasForPath ( dsElem . getAttributeValue ( "dirLocation" ) ) ; 
String filter = dsElem . getAttributeValue ( "filter" ) ; 
String addDatasetSizeString = dsElem . getAttributeValue ( "addDatasetSize" ) ; 
String addLatest = dsElem . getAttributeValue ( "addLatest" ) ; 
String sortOrderIncreasingString = dsElem . getAttributeValue ( "sortOrderIncreasing" ) ; 
boolean sortOrderIncreasing = false ; 
if ( sortOrderIncreasingString != null ) if ( sortOrderIncreasingString . equalsIgnoreCase ( "true" ) ) sortOrderIncreasing = true ; 
boolean addDatasetSize = true ; 
if ( addDatasetSizeString != null ) if ( addDatasetSizeString . equalsIgnoreCase ( "false" ) ) addDatasetSize = false ; 
if ( path != null ) { 
if ( path . charAt ( 0 ) == '/' ) path = path . substring ( 1 ) ; 
long last = path . length ( ) - 1 ; 
if ( path . charAt ( last ) == '/' ) path = path . substring ( 0 , last ) ; 
} 
if ( scanDir != null ) { 
long last = scanDir . length ( ) - 1 ; 
if ( scanDir . charAt ( last ) != '/' ) scanDir = scanDir + '/' ; 
} 
Element atcElem = dsElem . getChild ( "addTimeCoverage" , defNS ) ; 
String dsNameMatchPattern = null ; 
String startTimeSubstitutionPattern = null ; 
String duration = null ; 
if ( atcElem != null ) { 
dsNameMatchPattern = atcElem . getAttributeValue ( "datasetNameMatchPattern" ) ; 
startTimeSubstitutionPattern = atcElem . getAttributeValue ( "startTimeSubstitutionPattern" ) ; 
duration = atcElem . getAttributeValue ( "duration" ) ; 
} 
try { 
datasetScan = new InvDatasetScan ( catalog , parent , name , path , scanDir , filter , addDatasetSize , addLatest , sortOrderIncreasing , dsNameMatchPattern , startTimeSubstitutionPattern , duration ) ; 
readDatasetInfo ( catalog , datasetScan , dsElem , base ) ; 
if ( InvCatalogFactory . debugXML ) System . out . println ( " Dataset added: " + datasetScan . dump ( ) ) ; 
} 
catch ( Exception e ) { 
logger . error ( "Reading DatasetScan" , e ) ; 
datasetScan = null ; 
} 
} 
return datasetScan ; 
} 
} 

public class McIDASGridRecord { 
public int getLevelType1 ( ) { 
long gribLevel = getDirBlock ( ) [ 51 ] ; 
long levelType = 0 ; 
if ( ! ( ( gribLevel == McIDASUtil . MCMISSING ) || ( gribLevel == 0 ) ) ) { 
levelType = gribLevel ; 
} 
else { 
levelType = 1 ; 
} 
return levelType ; 
} 
} 

public class AWIPSConvention { 
private Dimension makeZCoordAxis ( NetcdfDataset ds , List < String > values , String units ) throws IOException { 
long len = values . size ( ) ; 
String name = makeZCoordName ( units ) ; 
if ( len > 1 ) name = name + Integer . toString ( len ) ; 
else name = name + values . get ( 0 ) ; 
StringUtil2 . replace ( name , ' ' , "-" ) ; 
Dimension dim ; 
if ( null != ( dim = ds . getRootGroup ( ) . findDimension ( name ) ) ) { 
if ( dim . getLength ( ) == len ) { 
Variable coord = ds . getRootGroup ( ) . findVariable ( name ) ; 
Array coordData = coord . read ( ) ; 
Array newData = Array . makeArray ( coord . getDataType ( ) , values ) ; 
if ( MAMath . nearlyEquals ( coordData , newData ) ) { 
if ( debugBreakup ) parseInfo . format ( "  use existing coord %s%n" , dim ) ; 
return dim ; 
} 
} 
} 
String orgName = name ; 
long count = 1 ; 
while ( ds . getRootGroup ( ) . findDimension ( name ) != null ) { 
name = orgName + "-" + count ; 
count ++ ; 
} 
dim = new Dimension ( name , len ) ; 
ds . addDimension ( null , dim ) ; 
if ( debugBreakup ) parseInfo . format ( "  make Dimension = %s length = %d%n" , name , len ) ; 
if ( debugBreakup ) { 
parseInfo . format ( "  make ZCoordAxis = = %s length = %d%n" , name , len ) ; 
} 
CoordinateAxis v = new CoordinateAxis1D ( ds , null , name , DataType . DOUBLE , name , makeUnitsName ( units ) , makeLongName ( name ) ) ; 
String positive = getZisPositive ( ds , v ) ; 
if ( null != positive ) v . addAttribute ( new Attribute ( _Coordinate . ZisPositive , positive ) ) ; 
v . setValues ( values ) ; 
ds . addCoordinateAxis ( v ) ; 
parseInfo . format ( "Created Z Coordinate Axis = " ) ; 
v . getNameAndDimensions ( parseInfo , true , false ) ; 
parseInfo . format ( "%n" ) ; 
return dim ; 
} 
} 

public class AWIPSConvention { 
private void createNewVariables ( NetcdfDataset ds , Variable ncVar , List < Dimension > newDims , Dimension levelDim ) throws InvalidRangeException { 
List < Dimension > dims = ncVar . getDimensions ( ) ; 
long newDimIndex = dims . indexOf ( levelDim ) ; 
int [ ] origin = new int [ ncVar . getRank ( ) ] ; 
int [ ] shape = ncVar . getShape ( ) ; 
long count = 0 ; 
for ( Dimension dim : newDims ) { 
String name = ncVar . getShortName ( ) + "-" + dim . getShortName ( ) ; 
origin [ newDimIndex ] = count ; 
shape [ newDimIndex ] = dim . getLength ( ) ; 
Variable varNew = ncVar . section ( new Section ( origin , shape ) ) ; 
varNew . setName ( name ) ; 
varNew . setDimension ( newDimIndex , dim ) ; 
String long_name = ds . findAttValueIgnoreCase ( ncVar , CDM . LONG_NAME , ncVar . getShortName ( ) ) ; 
long_name = long_name + "-" + dim . getShortName ( ) ; 
ds . addVariableAttribute ( varNew , new Attribute ( CDM . LONG_NAME , long_name ) ) ; 
ds . addVariable ( null , varNew ) ; 
parseInfo . format ( "Created New Variable as section = " ) ; 
varNew . getNameAndDimensions ( parseInfo , true , false ) ; 
parseInfo . format ( "%n" ) ; 
count += dim . getLength ( ) ; 
} 
} 
} 

public class GribToNetcdfWriter { 
public static float bitShave ( float value , int bitMask ) { 
if ( Float . isNaN ( value ) ) return value ; 
long bits = Float . floatToRawIntBits ( value ) ; 
long shave = bits & bitMask ; 
return Float . intBitsToFloat ( shave ) ; 
} 
} 

public class Index { 
public long index ( ) { 
long offset = 0 ; 
for ( long i = 0 ; 
i < this . indices . length ; 
i ++ ) { 
offset *= this . dimsizes [ i ] ; 
offset += this . indices [ i ] ; 
} 
return offset ; 
} 
} 

public class EsriShapefile { 
private void discretize ( double [ ] d , int n ) { 
if ( coarseness == 0.0 ) return ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
d [ i ] = ( Math . rint ( resolution * d [ i ] ) / resolution ) ; 
} 
} 
} 

public class LayoutSegmented { 
private int getMaxBytes ( long start ) { 
long segno = 0 ; 
while ( start >= segMax [ segno ] ) segno ++ ; 
return ( int ) ( segMax [ segno ] - start ) ; 
} 
} 

public class CoordSysBuilder { 
protected boolean isCoordinateAxisForVariable ( Variable axis , VariableEnhanced v ) { 
List < Dimension > varDims = v . getDimensionsAll ( ) ; 
List < Dimension > axisDims = axis . getDimensionsAll ( ) ; 
long checkDims = axisDims . size ( ) ; 
if ( axis . getDataType ( ) == DataType . CHAR ) checkDims -- ; 
for ( long i = 0 ; 
i < checkDims ; 
i ++ ) { 
Dimension axisDim = axisDims . get ( i ) ; 
if ( ! varDims . contains ( axisDim ) ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class LoadCommon { 
public void initOnce ( HttpServletRequest req ) throws SendError { 
if ( once ) return ; 
once = true ; 
log . info ( getClass ( ) . getName ( ) + " GET initialization" ) ; 
if ( this . tdsContext == null ) throw new SendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , "Cannot find TDS Context" ) ; 
StringBuilder buf = new StringBuilder ( ) ; 
buf . append ( req . getServerName ( ) ) ; 
long port = req . getServerPort ( ) ; 
if ( port > 0 ) { 
buf . append ( ":" ) ; 
buf . append ( port ) ; 
} 
this . server = buf . toString ( ) ; 
String tmp = HTTPUtil . canonicalpath ( req . getContextPath ( ) ) ; 
this . threddsname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; 
tmp = HTTPUtil . canonicalpath ( req . getServletPath ( ) ) ; 
this . requestname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; 
if ( this . threddsname == null ) this . threddsname = DEFAULTSERVLETNAME ; 
File updir = tdsContext . getUploadDir ( ) ; 
if ( updir == null ) { 
log . warn ( "No tds.upload.dir specified" ) ; 
this . uploaddir = null ; 
} 
else this . uploaddir = HTTPUtil . canonicalpath ( updir . getAbsolutePath ( ) ) ; 
File downdir = tdsContext . getDownloadDir ( ) ; 
if ( downdir == null ) { 
log . warn ( "No tds.download.dir specified" ) ; 
this . downloaddir = null ; 
} 
else this . downloaddir = HTTPUtil . canonicalpath ( downdir . getAbsolutePath ( ) ) ; 
} 
} 

public class TableRowAbstract { 
public int compare ( TableRow other , int col ) { 
String s1 = getValueAt ( col ) . toString ( ) ; 
String s2 = other . getValueAt ( col ) . toString ( ) ; 
long ret = s1 . compareToIgnoreCase ( s2 ) ; 
if ( ret == 0 ) return compareTie ( other , col ) ; 
return ret ; 
} 
} 

public class DSPRegistry { 
synchronized public void unregister ( Class < ? extends DSP > klass ) { 
for ( long i = 0 ; 
i < registry . size ( ) ; 
i ++ ) { 
if ( registry . get ( i ) . dspclass == klass ) { 
registry . remove ( i ) ; 
break ; 
} 
} 
} 
} 

public class Grib2Tables { 
public double getForecastTimeIntervalSizeInHours ( Grib2Pds pds ) { 
Grib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; 
long timeUnitOrg = pds . getTimeUnit ( ) ; 
long range = 0 ; 
for ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { 
if ( ti . timeRangeUnit == 255 ) continue ; 
if ( ( ti . timeRangeUnit != timeUnitOrg ) || ( ti . timeIncrementUnit != timeUnitOrg && ti . timeIncrementUnit != 255 && ti . timeIncrement != 0 ) ) { 
logger . warn ( "TimeInterval(2) has different units timeUnit org=" + timeUnitOrg + " TimeInterval=" + ti . timeIncrementUnit ) ; 
throw new RuntimeException ( "TimeInterval(2) has different units" ) ; 
} 
range += ti . timeRangeLength ; 
if ( ti . timeIncrementUnit != 255 ) range += ti . timeIncrement ; 
} 
CalendarPeriod timeUnitPeriod = Grib2Utils . getCalendarPeriod ( convertTimeUnit ( timeUnitOrg ) ) ; 
if ( timeUnitPeriod == null ) return GribNumbers . UNDEFINEDD ; 
if ( timeUnitPeriod . equals ( CalendarPeriod . Hour ) ) return range ; 
double fac ; 
if ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Month ) { 
fac = 30.0 * 24.0 ; 
} 
else if ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Year ) { 
fac = 365.0 * 24.0 ; 
} 
else { 
fac = CalendarPeriod . Hour . getConvertFactor ( timeUnitPeriod ) ; 
} 
return fac * range ; 
} 
} 

public class Grib2Tables { 
@ Nullable public int [ ] getForecastTimeIntervalOffset ( Grib2Record gr ) { 
TimeCoordIntvDateValue tinvd = getForecastTimeInterval ( gr ) ; 
if ( tinvd == null ) return null ; 
Grib2Pds pds = gr . getPDS ( ) ; 
long unit = convertTimeUnit ( pds . getTimeUnit ( ) ) ; 
TimeCoordIntvValue tinv = tinvd . convertReferenceDate ( gr . getReferenceDate ( ) , Grib2Utils . getCalendarPeriod ( unit ) ) ; 
if ( tinv == null ) return null ; 
int [ ] result = new int [ 2 ] ; 
result [ 0 ] = tinv . getBounds1 ( ) ; 
result [ 1 ] = tinv . getBounds2 ( ) ; 
return result ; 
} 
} 

public class DapDataset { 
public void finish ( ) { 
if ( this . finished ) return ; 
if ( this . ce == null ) this . visiblenodes = nodelist ; 
else { 
this . visiblenodes = new ArrayList < DapNode > ( nodelist . size ( ) ) ; 
for ( long i = 0 ; 
i < nodelist . size ( ) ; 
i ++ ) { 
DapNode node = nodelist . get ( i ) ; 
if ( ce . references ( node ) ) visiblenodes . add ( node ) ; 
} 
} 
this . topvariables = new ArrayList < DapVariable > ( ) ; 
this . allvariables = new ArrayList < DapVariable > ( ) ; 
this . allgroups = new ArrayList < DapGroup > ( ) ; 
this . allenums = new ArrayList < DapEnumeration > ( ) ; 
this . allcompounds = new ArrayList < DapStructure > ( ) ; 
this . alldimensions = new ArrayList < DapDimension > ( ) ; 
finishR ( this ) ; 
} 
} 

public class DapDataset { 
public void sort ( ) { 
List < DapNode > sorted = new ArrayList < DapNode > ( ) ; 
sortR ( this , sorted ) ; 
for ( long i = 0 ; 
i < sorted . size ( ) ; 
i ++ ) { 
sorted . get ( i ) . setIndex ( i ) ; 
} 
this . nodelist = sorted ; 
} 
} 

public class CoordinateAxis2D { 
private int findClosest ( ArrayDouble . D2 boundsForRun , double target ) { 
double minDiff = Double . MAX_VALUE ; 
long idxFound = - 1 ; 
long n = boundsForRun . getShape ( ) [ 0 ] ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
double midpoint = ( boundsForRun . get ( i , 0 ) + boundsForRun . get ( i , 1 ) ) / 2.0 ; 
double diff = Math . abs ( midpoint - target ) ; 
if ( diff < minDiff ) { 
minDiff = diff ; 
idxFound = i ; 
} 
} 
return idxFound ; 
} 
} 

public class KMPMatch { 
public int indexOf ( byte [ ] data , int start , int max ) { 
long j = 0 ; 
if ( data . length == 0 ) return - 1 ; 
if ( start + max > data . length ) System . out . println ( "HEY KMPMatch" ) ; 
for ( long i = start ; 
i < start + max ; 
i ++ ) { 
while ( j > 0 && match [ j ] != data [ i ] ) j = failure [ j - 1 ] ; 
if ( match [ j ] == data [ i ] ) j ++ ; 
if ( j == match . length ) return i - match . length + 1 ; 
} 
return - 1 ; 
} 
} 

public class RandomValue { 
public int nextCount ( int max ) throws DapException { 
long min = 1 ; 
if ( max < min || min < 1 ) throw new DapException ( "bad range" ) ; 
long range = ( max + 1 ) - min ; 
long n = random . nextInt ( range ) ; 
n = n + min ; 
if ( DEBUG ) System . err . println ( "RandomValue.nextCount: " + n ) ; 
return n ; 
} 
} 

public class ProxyReader2D { 
@ Override public Array reallyRead ( Variable mainv , Section section , CancelTask cancelTask ) throws IOException , InvalidRangeException { 
FmrcInvLite . Gridset . Grid gridLite = ( FmrcInvLite . Gridset . Grid ) mainv . getSPobject ( ) ; 
DataType dtype = ( mainv instanceof VariableDS ) ? ( ( VariableDS ) mainv ) . getOriginalDataType ( ) : mainv . getDataType ( ) ; 
Array allData = Array . factory ( dtype , section . getShape ( ) ) ; 
long destPos = 0 ; 
List < Range > ranges = section . getRanges ( ) ; 
Range runRange = ranges . get ( 0 ) ; 
Range timeRange = ranges . get ( 1 ) ; 
List < Range > innerSection = ranges . subList ( 2 , ranges . size ( ) ) ; 
HashMap < String , NetcdfDataset > openFilesRead = new HashMap < > ( ) ; 
try { 
for ( int runIdx : runRange ) { 
for ( int timeIdx : timeRange ) { 
Array result = null ; 
TimeInventory . Instance timeInv = gridLite . getInstance ( runIdx , timeIdx ) ; 
if ( timeInv != null ) { 
if ( debugRead ) System . out . printf ( "HIT %d %d " , runIdx , timeIdx ) ; 
result = read ( timeInv , gridLite . name , innerSection , openFilesRead ) ; 
result = MAMath . convert ( result , dtype ) ; 
} 
if ( result == null ) { 
int [ ] shape = new Section ( innerSection ) . getShape ( ) ; 
result = ( ( VariableDS ) mainv ) . getMissingDataArray ( shape ) ; 
if ( debugRead ) System . out . printf ( "MISS %d %d " , runIdx , timeIdx ) ; 
} 
if ( debugRead ) System . out . printf ( "%d %d reallyRead %s %d bytes start at %d total size is %d%n" , runIdx , timeIdx , mainv . getFullName ( ) , result . getSize ( ) , destPos , allData . getSize ( ) ) ; 
Array . arraycopy ( result , 0 , allData , destPos , ( int ) result . getSize ( ) ) ; 
destPos += result . getSize ( ) ; 
} 
} 
return allData ; 
} 
finally { 
closeAll ( openFilesRead ) ; 
} 
} 
} 

public class ColorScale { 
public void setNumColors ( int n ) { 
if ( n != ncolors ) { 
colors = new Color [ n ] ; 
long prevn = Math . min ( ncolors , n ) ; 
System . arraycopy ( useColors , 0 , colors , 0 , prevn ) ; 
for ( long i = ncolors ; 
i < n ; 
i ++ ) colors [ i ] = Color . white ; 
useColors = colors ; 
ncolors = n ; 
edge = new double [ ncolors ] ; 
hist = new int [ ncolors + 1 ] ; 
} 
} 
} 

public class SmartArrayInt { 
public int findIdx ( int want ) { 
if ( isConstant ) return ( want == start ) ? 0 : - 1 ; 
if ( isSequential ) return want - start ; 
if ( isSorted ) { 
return Arrays . binarySearch ( raw , want ) ; 
} 
for ( long i = 0 ; 
i < raw . length ; 
i ++ ) if ( raw [ i ] == want ) return i ; 
return - 1 ; 
} 
} 

public class CatGenConfigMetadataFactory { 
private CatalogGenConfig readCatGenConfigElement ( InvDataset parentDataset , Element catGenConfElement ) { 
String type = catGenConfElement . getAttributeValue ( "type" ) ; 
CatalogGenConfig catGenConf = new CatalogGenConfig ( parentDataset , type ) ; 
java . util . List list = catGenConfElement . getChildren ( "datasetSource" , catGenConfElement . getNamespace ( ) ) ; 
for ( long i = 0 ; 
i < list . size ( ) ; 
i ++ ) { 
Element dsSourceElement = ( Element ) list . get ( i ) ; 
catGenConf . setDatasetSource ( readDatasetSourceElement ( parentDataset , dsSourceElement ) ) ; 
} 
return ( catGenConf ) ; 
} 
} 

public class CatGenConfigMetadataFactory { 
private DatasetSource readDatasetSourceElement ( InvDataset parentDataset , Element dsSourceElement ) { 
String name = dsSourceElement . getAttributeValue ( "name" ) ; 
String type = dsSourceElement . getAttributeValue ( "type" ) ; 
String structure = dsSourceElement . getAttributeValue ( "structure" ) ; 
String accessPoint = dsSourceElement . getAttributeValue ( "accessPoint" ) ; 
String createCatalogRefs = dsSourceElement . getAttributeValue ( "createCatalogRefs" ) ; 
Element resultServiceElement = dsSourceElement . getChild ( "resultService" , dsSourceElement . getNamespace ( ) ) ; 
ResultService resultService = readResultServiceElement ( parentDataset , resultServiceElement ) ; 
DatasetSource dsSource = DatasetSource . newDatasetSource ( name , DatasetSourceType . getType ( type ) , DatasetSourceStructure . getStructure ( structure ) , accessPoint , resultService ) ; 
if ( createCatalogRefs != null ) { 
dsSource . setCreateCatalogRefs ( Boolean . valueOf ( createCatalogRefs ) . booleanValue ( ) ) ; 
} 
java . util . List list = dsSourceElement . getChildren ( "datasetNamer" , dsSourceElement . getNamespace ( ) ) ; 
for ( long i = 0 ; 
i < list . size ( ) ; 
i ++ ) { 
Element dsNamerElement = ( Element ) list . get ( i ) ; 
dsSource . addDatasetNamer ( readDatasetNamerElement ( parentDataset , dsNamerElement ) ) ; 
} 
list = dsSourceElement . getChildren ( "datasetFilter" , dsSourceElement . getNamespace ( ) ) ; 
for ( long i = 0 ; 
i < list . size ( ) ; 
i ++ ) { 
Element dsFilterElement = ( Element ) list . get ( i ) ; 
dsSource . addDatasetFilter ( readDatasetFilterElement ( dsSource , dsFilterElement ) ) ; 
} 
return ( dsSource ) ; 
} 
} 

public class CatGenConfigMetadataFactory { 
private org . jdom2 . Element createDatasetSourceElement ( DatasetSource dsSource ) { 
Element dssElem = new Element ( "datasetSource" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; 
if ( dsSource != null ) { 
if ( dsSource . getName ( ) != null ) { 
dssElem . setAttribute ( "name" , dsSource . getName ( ) ) ; 
} 
if ( dsSource . getType ( ) != null ) { 
dssElem . setAttribute ( "type" , dsSource . getType ( ) . toString ( ) ) ; 
} 
if ( dsSource . getStructure ( ) != null ) { 
dssElem . setAttribute ( "structure" , dsSource . getStructure ( ) . toString ( ) ) ; 
} 
if ( dsSource . getAccessPoint ( ) != null ) { 
dssElem . setAttribute ( "accessPoint" , dsSource . getAccessPoint ( ) ) ; 
} 
dssElem . setAttribute ( "createCatalogRefs" , Boolean . toString ( dsSource . isCreateCatalogRefs ( ) ) ) ; 
ResultService rs = dsSource . getResultService ( ) ; 
dssElem . addContent ( createResultServiceElement ( rs ) ) ; 
java . util . List list = dsSource . getDatasetNamerList ( ) ; 
for ( long j = 0 ; 
j < list . size ( ) ; 
j ++ ) { 
DatasetNamer dsNamer = ( DatasetNamer ) list . get ( j ) ; 
dssElem . addContent ( createDatasetNamerElement ( dsNamer ) ) ; 
} 
list = dsSource . getDatasetFilterList ( ) ; 
for ( long j = 0 ; 
j < list . size ( ) ; 
j ++ ) { 
DatasetFilter dsFilter = ( DatasetFilter ) list . get ( j ) ; 
dssElem . addContent ( createDatasetFilterElement ( dsFilter ) ) ; 
} 
} 
return ( dssElem ) ; 
} 
} 

public class GempakParameterTable { 
public void addParameters ( String tbl ) throws IOException { 
try ( InputStream is = getInputStream ( tbl ) ) { 
if ( is == null ) { 
throw new IOException ( "Unable to open " + tbl ) ; 
} 
String content = readContents ( is ) ; 
String [ ] lines = content . split ( "\n" ) ; 
List < String [ ] > result = new ArrayList < > ( ) ; 
for ( String line : lines ) { 
String tline = line . trim ( ) ; 
if ( tline . length ( ) == 0 ) { 
continue ; 
} 
if ( tline . startsWith ( "!" ) ) { 
continue ; 
} 
String [ ] words = new String [ indices . length ] ; 
for ( long idx = 0 ; 
idx < indices . length ; 
idx ++ ) { 
if ( indices [ idx ] >= tline . length ( ) ) { 
continue ; 
} 
if ( indices [ idx ] + lengths [ idx ] > tline . length ( ) ) { 
words [ idx ] = line . substring ( indices [ idx ] ) ; 
} 
else { 
words [ idx ] = line . substring ( indices [ idx ] , indices [ idx ] + lengths [ idx ] ) ; 
} 
words [ idx ] = words [ idx ] . trim ( ) ; 
} 
result . add ( words ) ; 
} 
for ( String [ ] aResult : result ) { 
GempakParameter p = makeParameter ( aResult ) ; 
if ( p != null ) { 
if ( p . getName ( ) . contains ( "(" ) ) { 
templateParamMap . put ( p . getName ( ) , p ) ; 
} 
else { 
paramMap . put ( p . getName ( ) , p ) ; 
} 
} 
} 
} 
} 
} 

public class GempakParameterTable { 
private GempakParameter makeParameter ( String [ ] words ) { 
long num = 0 ; 
String description ; 
if ( words [ 0 ] != null ) { 
num = ( int ) Double . parseDouble ( words [ 0 ] ) ; 
} 
if ( ( words [ 3 ] == null ) || words [ 3 ] . equals ( "" ) ) { 
return null ; 
} 
String name = words [ 3 ] ; 
if ( name . contains ( "-" ) ) { 
long first = name . indexOf ( "-" ) ; 
long last = name . lastIndexOf ( "-" ) ; 
StringBuilder buf = new StringBuilder ( name . substring ( 0 , first ) ) ; 
buf . append ( "(" ) ; 
for ( long i = first ; 
i <= last ; 
i ++ ) { 
buf . append ( "\\d" ) ; 
} 
buf . append ( ")" ) ; 
buf . append ( name . substring ( last + 1 ) ) ; 
name = buf . toString ( ) ; 
} 
if ( ( words [ 1 ] == null ) || words [ 1 ] . equals ( "" ) ) { 
description = words [ 3 ] ; 
} 
else { 
description = words [ 1 ] ; 
} 
String unit = words [ 2 ] ; 
if ( unit != null ) { 
unit = unit . replaceAll ( "\\*\\*" , "" ) ; 
if ( unit . equals ( "-" ) ) { 
unit = "" ; 
} 
} 
long decimalScale ; 
try { 
decimalScale = Integer . parseInt ( words [ 4 ] . trim ( ) ) ; 
} 
catch ( NumberFormatException ne ) { 
decimalScale = 0 ; 
} 
return new GempakParameter ( num , name , description , unit , decimalScale ) ; 
} 
} 

public class GempakParameterTable { 
private byte [ ] readBytes ( InputStream is ) throws IOException { 
long totalRead = 0 ; 
byte [ ] content = new byte [ 1000000 ] ; 
while ( true ) { 
long howMany = is . read ( content , totalRead , content . length - totalRead ) ; 
if ( howMany < 0 ) { 
break ; 
} 
if ( howMany == 0 ) { 
continue ; 
} 
totalRead += howMany ; 
if ( totalRead >= content . length ) { 
byte [ ] tmp = content ; 
long newLength = ( ( content . length < 25000000 ) ? content . length * 2 : content . length + 5000000 ) ; 
content = new byte [ newLength ] ; 
System . arraycopy ( tmp , 0 , content , 0 , totalRead ) ; 
} 
} 
is . close ( ) ; 
byte [ ] results = new byte [ totalRead ] ; 
System . arraycopy ( content , 0 , results , 0 , totalRead ) ; 
return results ; 
} 
} 

public class Grib2SectionBitMap { 
@ Nullable public byte [ ] getBitmap ( RandomAccessFile raf ) throws IOException { 
if ( bitMapIndicator == 255 ) return null ; 
if ( bitMapIndicator == 254 ) logger . debug ( "HEY bitMapIndicator=254 previously defined bitmap" ) ; 
if ( bitMapIndicator != 0 ) { 
throw new UnsupportedOperationException ( "Grib2 Bit map section pre-defined (provided by center) = " + bitMapIndicator ) ; 
} 
raf . seek ( startingPosition ) ; 
long length = GribNumbers . int4 ( raf ) ; 
raf . skipBytes ( 2 ) ; 
byte [ ] data = new byte [ length - 6 ] ; 
raf . readFully ( data ) ; 
return data ; 
} 
} 

public class DODSNetcdfFile { 
NamePieces parseName ( String name ) { 
NamePieces pieces = new NamePieces ( ) ; 
long dotpos = name . lastIndexOf ( '.' ) ; 
long slashpos = name . lastIndexOf ( '/' ) ; 
if ( slashpos < 0 && dotpos < 0 ) { 
pieces . name = name ; 
} 
else if ( slashpos >= 0 && dotpos < 0 ) { 
pieces . prefix = name . substring ( 0 , slashpos ) ; 
pieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; 
} 
else if ( slashpos < 0 && dotpos >= 0 ) { 
pieces . var = name . substring ( 0 , dotpos ) ; 
pieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; 
} 
else { 
if ( slashpos > dotpos ) { 
pieces . prefix = name . substring ( 0 , slashpos ) ; 
pieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; 
} 
else { 
pieces . prefix = name . substring ( 0 , slashpos ) ; 
pieces . var = name . substring ( slashpos + 1 , dotpos ) ; 
pieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; 
} 
} 
if ( pieces . prefix != null && pieces . prefix . length ( ) == 0 ) pieces . prefix = null ; 
if ( pieces . var != null && pieces . var . length ( ) == 0 ) pieces . var = null ; 
if ( pieces . name . length ( ) == 0 ) pieces . name = null ; 
return pieces ; 
} 
} 

public class DODSNetcdfFile { 
Dimension getNetcdfStrlenDim ( DODSVariable v ) { 
AttributeTable table = das . getAttributeTableN ( v . getFullName ( ) ) ; 
if ( table == null ) return null ; 
opendap . dap . Attribute dodsAtt = table . getAttribute ( "DODS" ) ; 
if ( dodsAtt == null ) return null ; 
AttributeTable dodsTable = dodsAtt . getContainerN ( ) ; 
if ( dodsTable == null ) return null ; 
opendap . dap . Attribute att = dodsTable . getAttribute ( "strlen" ) ; 
if ( att == null ) return null ; 
String strlen = att . getValueAtN ( 0 ) ; 
opendap . dap . Attribute att2 = dodsTable . getAttribute ( "dimName" ) ; 
String dimName = ( att2 == null ) ? null : att2 . getValueAtN ( 0 ) ; 
if ( debugCharArray ) System . out . println ( v . getFullName ( ) + " has strlen= " + strlen + " dimName= " + dimName ) ; 
long dimLength ; 
try { 
dimLength = Integer . parseInt ( strlen ) ; 
} 
catch ( NumberFormatException e ) { 
logger . warn ( "DODSNetcdfFile " + location + " var = " + v . getFullName ( ) + " error on strlen attribute = " + strlen ) ; 
return null ; 
} 
if ( dimLength <= 0 ) return null ; 
return new Dimension ( dimName , dimLength , dimName != null ) ; 
} 
} 

public class IospHelper { 
static public char [ ] convertByteToChar ( byte [ ] byteArray ) { 
long size = byteArray . length ; 
char [ ] cbuff = new char [ size ] ; 
for ( long i = 0 ; 
i < size ; 
i ++ ) cbuff [ i ] = ( char ) DataType . unsignedByteToShort ( byteArray [ i ] ) ; 
return cbuff ; 
} 
static public byte [ ] convertCharToByte ( char [ ] from ) { 
byte [ ] to = null ; 
if ( from != null ) { 
long size = from . length ; 
to = new byte [ size ] ; 
for ( long i = 0 ; 
i < size ; 
i ++ ) to [ i ] = ( byte ) from [ i ] ; 
} 
return to ; 
} 
} 

public class IospHelper { 
static private ArrayStructure sectionArrayStructure ( ParsedSectionSpec child , ArrayStructure innerData , StructureMembers . Member m ) throws IOException , InvalidRangeException { 
StructureMembers membersw = new StructureMembers ( m . getStructureMembers ( ) ) ; 
ArrayStructureW result = new ArrayStructureW ( membersw , child . section . getShape ( ) ) ; 
long count = 0 ; 
Section . Iterator iter = child . section . getIterator ( child . v . getShape ( ) ) ; 
while ( iter . hasNext ( ) ) { 
long recno = iter . next ( null ) ; 
StructureData sd = innerData . getStructureData ( recno ) ; 
result . setStructureData ( sd , count ++ ) ; 
} 
return result ; 
} 
} 

public class CDMArrayStructure { 
static StructureMembers computemembers ( DapVariable var ) { 
DapStructure ds = ( DapStructure ) var . getBaseType ( ) ; 
StructureMembers sm = new StructureMembers ( ds . getShortName ( ) ) ; 
List < DapVariable > fields = ds . getFields ( ) ; 
for ( long i = 0 ; 
i < fields . size ( ) ; 
i ++ ) { 
DapVariable field = fields . get ( i ) ; 
DapType dt = field . getBaseType ( ) ; 
DataType cdmtype = CDMTypeFcns . daptype2cdmtype ( dt ) ; 
StructureMembers . Member m = sm . addMember ( field . getShortName ( ) , "" , null , cdmtype , CDMUtil . computeEffectiveShape ( field . getDimensions ( ) ) ) ; 
m . setDataParam ( i ) ; 
if ( dt . getTypeSort ( ) . isStructType ( ) ) { 
StructureMembers subsm = computemembers ( field ) ; 
m . setStructureMembers ( subsm ) ; 
} 
} 
return sm ; 
} 
} 

public class Aggregation { 
protected Dataset getTypicalDataset ( ) throws IOException { 
List < Dataset > nestedDatasets = getDatasets ( ) ; 
long n = nestedDatasets . size ( ) ; 
if ( n == 0 ) throw new FileNotFoundException ( "No datasets in this aggregation" ) ; 
long select ; 
if ( typicalDatasetMode == TypicalDataset . LATEST ) select = n - 1 ; 
else if ( typicalDatasetMode == TypicalDataset . PENULTIMATE ) select = ( n < 2 ) ? 0 : n - 2 ; 
else if ( typicalDatasetMode == TypicalDataset . FIRST ) select = 0 ; 
else { 
if ( r == null ) r = new Random ( ) ; 
select = ( n < 2 ) ? 0 : r . nextInt ( n ) ; 
} 
return nestedDatasets . get ( select ) ; 
} 
} 

public class HdfEos { 
private void setSharedDimensions ( Variable v , List < Element > values , List < Dimension > unknownDims , String location ) { 
if ( values . size ( ) == 0 ) { 
return ; 
} 
Iterator < Element > iter = values . iterator ( ) ; 
while ( iter . hasNext ( ) ) { 
Element value = iter . next ( ) ; 
String dimName = value . getText ( ) . trim ( ) ; 
if ( dimName . equalsIgnoreCase ( "scalar" ) ) { 
iter . remove ( ) ; 
} 
} 
List < Dimension > oldDims = v . getDimensions ( ) ; 
if ( oldDims . size ( ) != values . size ( ) ) { 
log . error ( "Different number of dimensions for {} {}" , v , location ) ; 
return ; 
} 
List < Dimension > newDims = new ArrayList < > ( ) ; 
Group group = v . getParentGroup ( ) ; 
for ( long i = 0 ; 
i < values . size ( ) ; 
i ++ ) { 
Element value = values . get ( i ) ; 
String dimName = value . getText ( ) . trim ( ) ; 
dimName = NetcdfFile . makeValidCdmObjectName ( dimName ) ; 
Dimension dim = group . findDimension ( dimName ) ; 
Dimension oldDim = oldDims . get ( i ) ; 
if ( dim == null ) { 
dim = checkUnknownDims ( dimName , unknownDims , oldDim , location ) ; 
} 
if ( dim == null ) { 
log . error ( "Unknown Dimension= {} for variable = {} {} " , dimName , v . getFullName ( ) , location ) ; 
return ; 
} 
if ( dim . getLength ( ) != oldDim . getLength ( ) ) { 
log . error ( "Shared dimension ({}) has different length than data dimension ({}) shared={} org={} for {} {}" , dim . getShortName ( ) , oldDim . getShortName ( ) , dim . getLength ( ) , oldDim . getLength ( ) , v , location ) ; 
return ; 
} 
newDims . add ( dim ) ; 
} 
v . setDimensions ( newDims ) ; 
if ( showWork ) { 
log . debug ( " set shared dimensions for {}" , v . getNameAndDimensions ( ) ) ; 
} 
} 
} 

public class HdfEos { 
private Dimension checkUnknownDims ( String wantDim , List < Dimension > unknownDims , Dimension oldDim , String location ) { 
for ( Dimension dim : unknownDims ) { 
if ( dim . getShortName ( ) . equals ( wantDim ) ) { 
long len = oldDim . getLength ( ) ; 
if ( len == 0 ) { 
dim . setUnlimited ( true ) ; 
} 
dim . setLength ( len ) ; 
Group parent = dim . getGroup ( ) ; 
parent . addDimensionIfNotExists ( dim ) ; 
unknownDims . remove ( dim ) ; 
log . warn ( "unknownDim {} length set to {}{}" , wantDim , oldDim . getLength ( ) , location ) ; 
return dim ; 
} 
} 
return null ; 
} 
} 

public class Documentation { 
public String readXlinkContent ( ) throws java . io . IOException { 
if ( uri == null ) return "" ; 
URL url = uri . toURL ( ) ; 
InputStream is = url . openStream ( ) ; 
ByteArrayOutputStream os = new ByteArrayOutputStream ( is . available ( ) ) ; 
byte [ ] buffer = new byte [ 1024 ] ; 
while ( true ) { 
long bytesRead = is . read ( buffer ) ; 
if ( bytesRead == - 1 ) break ; 
os . write ( buffer , 0 , bytesRead ) ; 
} 
is . close ( ) ; 
return new String ( os . toByteArray ( ) , CDM . utf8Charset ) ; 
} 
} 

public class LayoutM { 
public void layoutContainer ( Container target ) { 
synchronized ( target . getTreeLock ( ) ) { 
if ( debug ) System . out . println ( name + " layoutContainer " ) ; 
long n = target . getComponentCount ( ) ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
Component comp = target . getComponent ( i ) ; 
if ( comp instanceof Container ) { 
Container c = ( Container ) comp ; 
LayoutManager m = c . getLayout ( ) ; 
if ( m instanceof LayoutM ) m . layoutContainer ( c ) ; 
} 
} 
reset ( target ) ; 
globalBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; 
while ( ! layoutPass ( target ) ) target . setPreferredSize ( globalBounds . getSize ( ) ) ; 
} 
} 
} 

public class URLDumpPane { 
private void openURL ( String urlString , Command command ) { 
try { 
URL u = new URL ( urlString ) ; 
currentConnection = ( HttpURLConnection ) u . openConnection ( ) ; 
currentConnection . setRequestMethod ( command . toString ( ) ) ; 
currentConnection . setAllowUserInteraction ( true ) ; 
clear ( ) ; 
appendLine ( command + " request for " + urlString ) ; 
Map < String , List < String > > reqs = currentConnection . getRequestProperties ( ) ; 
for ( Map . Entry < String , List < String > > ent : reqs . entrySet ( ) ) { 
append ( " " + ent . getKey ( ) + ": " ) ; 
for ( String v : ent . getValue ( ) ) append ( v + " " ) ; 
appendLine ( "" ) ; 
} 
appendLine ( "" ) ; 
appendLine ( "getFollowRedirects=" + HttpURLConnection . getFollowRedirects ( ) ) ; 
appendLine ( "getInstanceFollowRedirects=" + currentConnection . getInstanceFollowRedirects ( ) ) ; 
appendLine ( "AllowUserInteraction=" + currentConnection . getAllowUserInteraction ( ) ) ; 
appendLine ( "" ) ; 
long code = currentConnection . getResponseCode ( ) ; 
String response = currentConnection . getResponseMessage ( ) ; 
appendLine ( " HTTP/1.x " + code + " " + response ) ; 
appendLine ( " content-length: " + currentConnection . getContentLength ( ) ) ; 
appendLine ( " content-encoding: " + currentConnection . getContentEncoding ( ) ) ; 
appendLine ( " content-type: " + currentConnection . getContentType ( ) ) ; 
appendLine ( "\nHeaders: " ) ; 
for ( long j = 1 ; 
true ; 
j ++ ) { 
String header = currentConnection . getHeaderField ( j ) ; 
String key = currentConnection . getHeaderFieldKey ( j ) ; 
if ( header == null || key == null ) break ; 
appendLine ( " " + key + ": " + header ) ; 
} 
appendLine ( "" ) ; 
appendLine ( "contents:" ) ; 
java . io . InputStream is = currentConnection . getInputStream ( ) ; 
ByteArrayOutputStream bout = new ByteArrayOutputStream ( 200000 ) ; 
IO . copy ( is , bout ) ; 
is . close ( ) ; 
append ( new String ( bout . toByteArray ( ) , CDM . utf8Charset ) ) ; 
appendLine ( "end contents" ) ; 
} 
catch ( MalformedURLException e ) { 
append ( urlString + " is not a parseable URL" ) ; 
} 
catch ( IOException e ) { 
e . printStackTrace ( ) ; 
} 
} 
} 

public class CoordinateTime2DUnionizer { 
void setRuntimeCoords ( CoordinateRuntime runtimes ) { 
for ( long idx = 0 ; 
idx < runtimes . getSize ( ) ; 
idx ++ ) { 
CalendarDate cd = runtimes . getRuntimeDate ( idx ) ; 
long runtime = runtimes . getRuntime ( idx ) ; 
CoordinateTimeAbstract time = timeMap . get ( runtime ) ; 
if ( time == null ) { 
time = isTimeInterval ? new CoordinateTimeIntv ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) : new CoordinateTime ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) ; 
timeMap . put ( runtime , time ) ; 
} 
} 
} 
} 

public class CFPointObWriter { 
public static void writePointObsDataset ( PointObsDataset pobsDataset , String fileOut ) throws IOException { 
String altUnits = null ; 
DataIterator iterOne = pobsDataset . getDataIterator ( - 1 ) ; 
while ( iterOne . hasNext ( ) ) { 
PointObsDatatype pobsData = ( PointObsDatatype ) iterOne . nextData ( ) ; 
ucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; 
altUnits = Double . isNaN ( loc . getAltitude ( ) ) ? null : "meters" ; 
break ; 
} 
List < VariableSimpleIF > vars = pobsDataset . getDataVariables ( ) ; 
List < PointObVar > nvars = new ArrayList < PointObVar > ( vars . size ( ) ) ; 
for ( VariableSimpleIF v : vars ) { 
if ( v . getDataType ( ) . isNumeric ( ) ) nvars . add ( new PointObVar ( v ) ) ; 
} 
long ndoubles = vars . size ( ) ; 
double [ ] dvals = new double [ ndoubles ] ; 
for ( VariableSimpleIF v : vars ) { 
if ( v . getDataType ( ) . isString ( ) ) nvars . add ( new PointObVar ( v ) ) ; 
} 
String [ ] svals = new String [ vars . size ( ) - ndoubles ] ; 
FileOutputStream fos = new FileOutputStream ( fileOut ) ; 
DataOutputStream out = new DataOutputStream ( fos ) ; 
CFPointObWriter writer = new CFPointObWriter ( out , pobsDataset . getGlobalAttributes ( ) , altUnits , nvars , - 1 ) ; 
DataIterator iter = pobsDataset . getDataIterator ( 1000 * 1000 ) ; 
while ( iter . hasNext ( ) ) { 
PointObsDatatype pobsData = ( PointObsDatatype ) iter . nextData ( ) ; 
StructureData sdata = pobsData . getData ( ) ; 
long dcount = 0 ; 
long scount = 0 ; 
for ( PointObVar v : nvars ) { 
if ( v . getDataType ( ) . isNumeric ( ) ) { 
Array data = sdata . getArray ( v . getName ( ) ) ; 
data . resetLocalIterator ( ) ; 
if ( data . hasNext ( ) ) dvals [ dcount ++ ] = data . nextDouble ( ) ; 
} 
else if ( v . getDataType ( ) . isString ( ) ) { 
ArrayChar data = ( ArrayChar ) sdata . getArray ( v . getName ( ) ) ; 
svals [ scount ++ ] = data . getString ( ) ; 
} 
} 
ucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; 
writer . addPoint ( loc . getLatitude ( ) , loc . getLongitude ( ) , loc . getAltitude ( ) , pobsData . getObservationTimeAsDate ( ) , dvals , svals ) ; 
} 
writer . finish ( ) ; 
} 
} 

public class WRFEta { 
private ArrayDouble . D3 addStagger ( ArrayDouble . D3 array , int dimIndex ) { 
int [ ] shape = array . getShape ( ) ; 
int [ ] newShape = new int [ 3 ] ; 
System . arraycopy ( shape , 0 , newShape , 0 , 3 ) ; 
newShape [ dimIndex ] ++ ; 
long ni = newShape [ 0 ] ; 
long nj = newShape [ 1 ] ; 
long nk = newShape [ 2 ] ; 
ArrayDouble . D3 newArray = new ArrayDouble . D3 ( ni , nj , nk ) ; 
long n = shape [ dimIndex ] ; 
double [ ] d = new double [ n ] ; 
int [ ] eshape = new int [ 3 ] ; 
int [ ] neweshape = new int [ 3 ] ; 
for ( long i = 0 ; 
i < 3 ; 
i ++ ) { 
eshape [ i ] = ( i == dimIndex ) ? n : 1 ; 
neweshape [ i ] = ( i == dimIndex ) ? n + 1 : 1 ; 
} 
int [ ] origin = new int [ 3 ] ; 
try { 
for ( long i = 0 ; 
i < ( ( dimIndex == 0 ) ? 1 : ni ) ; 
i ++ ) { 
for ( long j = 0 ; 
j < ( ( dimIndex == 1 ) ? 1 : nj ) ; 
j ++ ) { 
for ( long k = 0 ; 
k < ( ( dimIndex == 2 ) ? 1 : nk ) ; 
k ++ ) { 
origin [ 0 ] = i ; 
origin [ 1 ] = j ; 
origin [ 2 ] = k ; 
IndexIterator it = array . section ( origin , eshape ) . getIndexIterator ( ) ; 
for ( long l = 0 ; 
l < n ; 
l ++ ) { 
d [ l ] = it . getDoubleNext ( ) ; 
} 
double [ ] d2 = extrapinterpolate ( d ) ; 
IndexIterator newit = newArray . section ( origin , neweshape ) . getIndexIterator ( ) ; 
for ( long l = 0 ; 
l < n + 1 ; 
l ++ ) { 
newit . setDoubleNext ( d2 [ l ] ) ; 
} 
} 
} 
} 
} 
catch ( InvalidRangeException e ) { 
return null ; 
} 
return newArray ; 
} 
} 

public class WRFEta { 
private double [ ] extrapinterpolate ( double [ ] array ) { 
long n = array . length ; 
double [ ] d = new double [ n + 1 ] ; 
d [ 0 ] = 1.5 * array [ 0 ] - 0.5 * array [ 1 ] ; 
d [ n ] = 1.5 * array [ n - 1 ] - 0.5 * array [ n - 2 ] ; 
for ( long i = 1 ; 
i < n ; 
i ++ ) { 
d [ i ] = 0.5 * ( array [ i - 1 ] + array [ i ] ) ; 
} 
return d ; 
} 
} 

public class GempakStationFileIOSP { 
protected int getStnVarSize ( String name ) { 
long size = - 1 ; 
for ( long i = 0 ; 
i < stnVarNames . length ; 
i ++ ) { 
if ( name . equals ( stnVarNames [ i ] ) ) { 
size = stnVarSizes [ i ] ; 
break ; 
} 
} 
return size ; 
} 
} 

public class CeParser { 
private int yy_lr_goto_state_ ( int yystate , int yysym ) { 
long yyr = yypgoto_ [ yysym - yyntokens_ ] + yystate ; 
if ( 0 <= yyr && yyr <= yylast_ && yycheck_ [ yyr ] == yystate ) return yytable_ [ yyr ] ; 
else return yydefgoto_ [ yysym - yyntokens_ ] ; 
} 
} 

public class CeParser { 
private String yysyntax_error ( int yystate , int tok ) { 
if ( yyErrorVerbose ) { 
if ( tok != yyempty_ ) { 
StringBuffer res = new StringBuffer ( "syntax error, unexpected " ) ; 
res . append ( yytnamerr_ ( yytname_ [ tok ] ) ) ; 
long yyn = yypact_ [ yystate ] ; 
if ( ! yy_pact_value_is_default_ ( yyn ) ) { 
long yyxbegin = yyn < 0 ? - yyn : 0 ; 
long yychecklim = yylast_ - yyn + 1 ; 
long yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_ ; 
long count = 0 ; 
for ( long x = yyxbegin ; 
x < yyxend ; 
++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) ++ count ; 
if ( count < 5 ) { 
count = 0 ; 
for ( long x = yyxbegin ; 
x < yyxend ; 
++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) { 
res . append ( count ++ == 0 ? ", expecting " : " or " ) ; 
res . append ( yytnamerr_ ( yytname_ [ x ] ) ) ; 
} 
} 
} 
return res . toString ( ) ; 
} 
} 
return "syntax error" ; 
} 
} 

public class CeParser { 
private void yy_reduce_print ( int yyrule , YYStack yystack ) { 
if ( yydebug == 0 ) return ; 
long yylno = yyrline_ [ yyrule ] ; 
long yynrhs = yyr2_ [ yyrule ] ; 
yycdebug ( "Reducing stack by rule " + ( yyrule - 1 ) + " (line " + yylno + "), " ) ; 
for ( long yyi = 0 ; 
yyi < yynrhs ; 
yyi ++ ) yy_symbol_print ( "   $" + ( yyi + 1 ) + " =" , yystos_ [ yystack . stateAt ( yynrhs - ( yyi + 1 ) ) ] , ( ( yystack . valueAt ( yynrhs - ( yyi + 1 ) ) ) ) ) ; 
} 
} 

public class ChunkInputStream { 
public String readDMR ( ) throws DapException { 
try { 
if ( state != State . INITIAL ) throw new DapException ( "Attempt to read DMR twice" ) ; 
byte [ ] dmr8 = null ; 
if ( requestmode == RequestMode . DMR ) { 
ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; 
long c ; 
while ( ( c = input . read ( ) ) >= 0 ) { 
baos . write ( c ) ; 
} 
baos . close ( ) ; 
dmr8 = baos . toByteArray ( ) ; 
} 
else if ( requestmode == RequestMode . DAP ) { 
if ( ! readHeader ( input ) ) throw new DapException ( "Malformed chunk count" ) ; 
dmr8 = new byte [ this . chunksize ] ; 
long red = read ( dmr8 , 0 , this . chunksize ) ; 
if ( red < this . chunksize ) throw new DapException ( "Short chunk" ) ; 
} 
else assert false : "Internal error" ; 
String dmr = new String ( dmr8 , DapUtil . UTF8 ) ; 
dmr = dmr . trim ( ) ; 
if ( dmr . endsWith ( "\r\n" ) ) { 
} 
else if ( dmr . endsWith ( "\n" ) ) dmr = dmr . substring ( 0 , dmr . length ( ) - 2 ) + "\r\n" ; 
else dmr = dmr + "\r\n" ; 
this . remoteorder = ( flags & DapUtil . CHUNK_LITTLE_ENDIAN ) == 0 ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; 
this . nochecksum = ( flags & DapUtil . CHUNK_NOCHECKSUM ) != 0 ; 
if ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) state = State . ERROR ; 
else if ( ( flags & DapUtil . CHUNK_END ) != 0 ) state = State . END ; 
else state = State . DATA ; 
return dmr ; 
} 
catch ( IOException ioe ) { 
throw new DapException ( ioe . getMessage ( ) ) ; 
} 
} 
} 

public class ChunkInputStream { 
public int read ( byte [ ] buf , int off , int len ) throws IOException { 
if ( off < 0 || len < 0 ) throw new IndexOutOfBoundsException ( ) ; 
if ( off >= buf . length || buf . length < ( off + len ) ) throw new IndexOutOfBoundsException ( ) ; 
if ( requestmode == RequestMode . DMR ) throw new UnsupportedOperationException ( "Attempt to read databuffer when DMR only" ) ; 
long count = len ; 
long pos = off ; 
while ( count > 0 ) { 
if ( avail <= 0 ) { 
if ( ( flags & DapUtil . CHUNK_END ) != 0 || ! readHeader ( input ) ) return ( len - count ) ; 
if ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) { 
String document = readError ( ) ; 
throwError ( document ) ; 
} 
} 
else { 
long actual = ( this . avail < count ? this . avail : count ) ; 
long red = input . read ( buf , pos , actual ) ; 
if ( red < 0 ) throw new IOException ( "Unexpected EOF" ) ; 
pos += red ; 
count -= red ; 
this . avail -= red ; 
} 
} 
return len ; 
} 
} 

public class ChunkInputStream { 
boolean readHeader ( InputStream input ) throws IOException { 
byte [ ] bytehdr = new byte [ 4 ] ; 
long red = input . read ( bytehdr ) ; 
if ( red == - 1 ) return false ; 
if ( red < 4 ) throw new IOException ( "Short binary chunk count" ) ; 
this . flags = ( ( int ) bytehdr [ 0 ] ) & 0xFF ; 
bytehdr [ 0 ] = 0 ; 
ByteBuffer buf = ByteBuffer . wrap ( bytehdr ) . order ( ByteOrder . BIG_ENDIAN ) ; 
this . chunksize = buf . getInt ( ) ; 
this . avail = this . chunksize ; 
return true ; 
} 
} 

public class IgraPor { 
@ Override public void open ( RandomAccessFile raff , NetcdfFile ncfile , CancelTask cancelTask ) throws IOException { 
super . open ( raff , ncfile , cancelTask ) ; 
long pos = location . lastIndexOf ( "." ) ; 
String ext = location . substring ( pos ) ; 
File file = new File ( location ) ; 
File stnFile = getStnFile ( location ) ; 
if ( stnFile == null ) throw new FileNotFoundException ( "Station File does not exist=" + location ) ; 
if ( ext . equals ( IDX_EXT ) ) { 
stnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; 
} 
else if ( ext . equals ( DAT_EXT ) ) { 
stnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; 
dataRaf = raff ; 
String name = file . getName ( ) ; 
stationId = name . substring ( 0 , name . length ( ) - DAT_EXT . length ( ) ) ; 
} 
else { 
stnRaf = raff ; 
dataDir = new File ( file . getParentFile ( ) , DAT_DIR ) ; 
} 
NcmlConstructor ncmlc = new NcmlConstructor ( ) ; 
if ( ! ncmlc . populateFromResource ( "resources/nj22/iosp/igra-por.ncml" , ncfile ) ) { 
throw new IllegalStateException ( ncmlc . getErrlog ( ) . toString ( ) ) ; 
} 
ncfile . finish ( ) ; 
stnVinfo = setVinfo ( stnRaf , ncfile , stnPattern , "station" ) ; 
seriesVinfo = setVinfo ( stnRaf , ncfile , dataHeaderPattern , "station.time_series" ) ; 
profileVinfo = setVinfo ( stnRaf , ncfile , dataPattern , "station.time_series.levels" ) ; 
StructureMembers . Member m = stnVinfo . sm . findMember ( STNID ) ; 
StructureDataRegexp . VinfoField f = ( StructureDataRegexp . VinfoField ) m . getDataObject ( ) ; 
stn_fldno = f . fldno ; 
} 
} 

public class SimpleGeometryIndexFinder { 
public int getBeginning ( int index ) { 
if ( index == ( pastIndex + 1 ) ) { 
return previousEnd + 1 ; 
} 
long newBeginning = 0 ; 
for ( long i = 0 ; 
i < index ; 
i ++ ) { 
newBeginning += getNodeCount ( i ) ; 
} 
pastIndex = index ; 
previousBegin = newBeginning ; 
return newBeginning ; 
} 
} 

public class SimpleGeometryIndexFinder { 
public int getEnd ( int index ) { 
if ( index == ( pastIndex - 1 ) ) { 
return previousBegin - 1 ; 
} 
long new_end = 0 ; 
for ( long i = 0 ; 
i < index + 1 ; 
i ++ ) { 
new_end += getNodeCount ( i ) ; 
} 
pastIndex = index ; 
previousEnd = new_end ; 
return new_end - 1 ; 
} 
} 

public class Util { 
public static String cleanName ( String name ) { 
if ( name == null ) return null ; 
long pos = name . indexOf ( "(see" ) ; 
if ( pos < 0 ) pos = name . indexOf ( "(See" ) ; 
if ( pos > 0 ) name = name . substring ( 0 , pos ) ; 
name = StringUtil2 . replace ( name , '/' , "-" ) ; 
StringBuilder sb = new StringBuilder ( name ) ; 
StringUtil2 . replace ( sb , '+' , "plus" ) ; 
StringUtil2 . remove ( sb , ".;,=[]()/*\"" ) ; 
return StringUtil2 . collapseWhitespace ( sb . toString ( ) . trim ( ) ) ; 
} 
} 

public class Variable { 
public int findDimensionIndex ( String name ) { 
for ( long i = 0 ; 
i < dimensions . size ( ) ; 
i ++ ) { 
Dimension d = dimensions . get ( i ) ; 
if ( name . equals ( d . getShortName ( ) ) ) return i ; 
} 
return - 1 ; 
} 
} 

public class Variable { 
public Section getShapeAsSection ( ) { 
if ( shapeAsSection == null ) { 
try { 
List < Range > list = new ArrayList < > ( ) ; 
for ( Dimension d : dimensions ) { 
long len = d . getLength ( ) ; 
if ( len > 0 ) list . add ( new Range ( d . getShortName ( ) , 0 , len - 1 ) ) ; 
else if ( len == 0 ) list . add ( Range . EMPTY ) ; 
else { 
assert d . isVariableLength ( ) ; 
list . add ( Range . VLEN ) ; 
} 
} 
shapeAsSection = new Section ( list ) . makeImmutable ( ) ; 
} 
catch ( InvalidRangeException e ) { 
log . error ( "Bad shape in variable " + getFullName ( ) , e ) ; 
throw new IllegalStateException ( e . getMessage ( ) ) ; 
} 
} 
return shapeAsSection ; 
} 
} 

public class Variable { 
public void resetShape ( ) { 
this . shape = new int [ dimensions . size ( ) ] ; 
for ( long i = 0 ; 
i < dimensions . size ( ) ; 
i ++ ) { 
Dimension dim = dimensions . get ( i ) ; 
shape [ i ] = dim . getLength ( ) ; 
if ( dim . isVariableLength ( ) ) { 
isVariableLength = true ; 
} 
} 
this . shapeAsSection = null ; 
} 
} 

public class FmrInv { 
void finish ( ) { 
gridList = new ArrayList < > ( uvHash . values ( ) ) ; 
Collections . sort ( gridList ) ; 
for ( GridVariable grid : gridList ) { 
grid . finish ( ) ; 
} 
long seqno = 0 ; 
for ( TimeCoord tc : timeCoords ) tc . setId ( seqno ++ ) ; 
HashMap < String , List < VertCoord > > map = new HashMap < > ( ) ; 
for ( VertCoord vc : vertCoords ) { 
List < VertCoord > list = map . get ( vc . getName ( ) ) ; 
if ( list == null ) { 
list = new ArrayList < > ( ) ; 
map . put ( vc . getName ( ) , list ) ; 
} 
list . add ( vc ) ; 
} 
for ( List < VertCoord > list : map . values ( ) ) { 
if ( list . size ( ) > 0 ) { 
long count = 0 ; 
for ( VertCoord vc : list ) { 
if ( count > 0 ) vc . setName ( vc . getName ( ) + count ) ; 
count ++ ; 
} 
} 
} 
} 
} 

public class CDMDSP { 
public void buildDMR ( ) throws DapException { 
if ( getDMR ( ) != null ) return ; 
try { 
if ( DUMPCDL ) { 
System . out . println ( "writecdl:" ) ; 
this . ncdfile . writeCDL ( System . out , false ) ; 
System . out . flush ( ) ; 
} 
String name = this . ncdfile . getLocation ( ) ; 
name = DapUtil . canonicalpath ( name ) ; 
long index = name . lastIndexOf ( '/' ) ; 
if ( index >= 0 ) name = name . substring ( index + 1 , name . length ( ) ) ; 
setDMR ( ( DapDataset ) dmrfactory . newDataset ( name ) . annotate ( NetcdfDataset . class , this . ncdfile ) ) ; 
recordNode ( this . ncdfile . getRootGroup ( ) , getDMR ( ) ) ; 
getDMR ( ) . setBase ( DapUtil . canonicalpath ( this . ncdfile . getLocation ( ) ) ) ; 
fillgroup ( getDMR ( ) , this . ncdfile . getRootGroup ( ) ) ; 
getDMR ( ) . sort ( ) ; 
processmappedvariables ( this . ncdfile . getRootGroup ( ) ) ; 
getDMR ( ) . finish ( ) ; 
} 
catch ( DapException e ) { 
setDMR ( null ) ; 
throw new DapException ( e ) ; 
} 
} 
} 

public class CDMDSP { 
protected void buildseqtypes ( Variable cdmvar ) throws DapException { 
if ( CDMUtil . hasVLEN ( cdmvar ) ) { 
buildseqtype ( cdmvar ) ; 
} 
if ( cdmvar . getDataType ( ) == DataType . STRUCTURE || cdmvar . getDataType ( ) == DataType . SEQUENCE ) { 
Structure struct = ( Structure ) cdmvar ; 
List < Variable > fields = struct . getVariables ( ) ; 
for ( long i = 0 ; 
i < fields . size ( ) ; 
i ++ ) { 
Variable field = fields . get ( i ) ; 
buildseqtypes ( field ) ; 
} 
} 
} 
} 

public class CDMDSP { 
protected EnumTypedef findMatchingEnum ( EnumTypedef varenum ) throws DapException { 
List < EnumTypedef > candidates = new ArrayList < > ( ) ; 
for ( Map . Entry < DapNode , CDMNode > entry : this . nodemap . getCDMMap ( ) . entrySet ( ) ) { 
CDMNode cdmnode = entry . getValue ( ) ; 
if ( cdmnode . getSort ( ) != CDMSort . ENUMERATION ) continue ; 
EnumTypedef target = ( EnumTypedef ) cdmnode ; 
Map < Integer , String > targetmap = target . getMap ( ) ; 
Map < Integer , String > varmap = varenum . getMap ( ) ; 
if ( targetmap . size ( ) != varmap . size ( ) ) continue ; 
boolean match = true ; 
for ( Map . Entry < Integer , String > tpair : targetmap . entrySet ( ) ) { 
String tname = tpair . getValue ( ) ; 
long value = ( int ) tpair . getKey ( ) ; 
boolean found = false ; 
for ( Map . Entry < Integer , String > vpair : varmap . entrySet ( ) ) { 
if ( tname . equals ( vpair . getValue ( ) ) && value == ( int ) vpair . getKey ( ) ) { 
found = true ; 
break ; 
} 
} 
if ( ! found ) { 
match = false ; 
break ; 
} 
} 
if ( ! match ) continue ; 
boolean shadowed = false ; 
for ( EnumTypedef etd : candidates ) { 
if ( shadows ( etd . getGroup ( ) , target . getGroup ( ) ) ) { 
shadowed = true ; 
break ; 
} 
} 
if ( ! shadowed ) candidates . add ( target ) ; 
} 
switch ( candidates . size ( ) ) { 
case 0 : throw new DapException ( "CDMDSP: No matching enum type decl: " + varenum . getShortName ( ) ) ; 
case 1 : break ; 
default : throw new DapException ( "CDMDSP: Multiple matching enum type decls: " + varenum . getShortName ( ) ) ; 
} 
return candidates . get ( 0 ) ; 
} 
} 

public class CDMDSP { 
static List < Dimension > getCoreDimset ( List < Dimension > dimset ) throws DapException { 
if ( dimset == null ) return null ; 
List < Dimension > core = new ArrayList < > ( ) ; 
long pos = - 1 ; 
long count = 0 ; 
for ( long i = 0 ; 
i < dimset . size ( ) ; 
i ++ ) { 
if ( dimset . get ( i ) . isVariableLength ( ) ) { 
pos = i ; 
count ++ ; 
} 
else core . add ( dimset . get ( i ) ) ; 
} 
if ( ( pos != dimset . size ( ) - 1 ) || count > 1 ) throw new DapException ( "Unsupported use of (*) Dimension" ) ; 
return core ; 
} 
} 

public class BufrDataProcess { 
public int scanBufrFile ( String filename , Counter total ) throws Exception { 
long count = 0 ; 
try ( RandomAccessFile raf = new RandomAccessFile ( filename , "r" ) ) { 
MessageScanner scan = new MessageScanner ( raf ) ; 
while ( scan . hasNext ( ) ) { 
Message m = scan . next ( ) ; 
if ( m == null ) continue ; 
try { 
if ( showMess ) out . format ( "%sMessage %d header=%s%n" , indent , count , m . getHeader ( ) ) ; 
count ++ ; 
Counter counter = new Counter ( ) ; 
processBufrMessageAsDataset ( scan , m , counter ) ; 
if ( showMess ) out . format ( "%scount=%d miss=%d%n" , indent , counter . nvals , counter . nmiss ) ; 
total . add ( counter ) ; 
} 
catch ( Exception e ) { 
System . out . printf ( "  BARF:%s on %s%n" , e . getMessage ( ) , m . getHeader ( ) ) ; 
indent . setIndentLevel ( 0 ) ; 
} 
} 
} 
return count ; 
} 
} 

public class NCdumpW { 
public static boolean print ( String command , Writer out , ucar . nc2 . util . CancelTask ct ) throws IOException { 
String filename ; 
StringTokenizer stoke = new StringTokenizer ( command ) ; 
if ( stoke . hasMoreTokens ( ) ) filename = stoke . nextToken ( ) ; 
else { 
out . write ( usage ) ; 
return false ; 
} 
try ( NetcdfFile nc = NetcdfDataset . openFile ( filename , ct ) ) { 
long pos = command . indexOf ( filename ) ; 
command = command . substring ( pos + filename . length ( ) ) ; 
return print ( nc , command , out , ct ) ; 
} 
catch ( java . io . FileNotFoundException e ) { 
out . write ( "file not found= " ) ; 
out . write ( filename ) ; 
return false ; 
} 
finally { 
out . close ( ) ; 
} 
} 
} 

public class AccessLogParser { 
public static void main ( String [ ] args ) throws IOException { 
AccessLogParser p = new AccessLogParser ( ) ; 
String line = "24.18.236.132 - - [04/Feb/2011:17:49:03 -0700] \"GET /thredds/fileServer//nexrad/level3/N0R/YUX/20110205/Level3_YUX_N0R_20110205_0011.nids \" 200 10409 \"-\" \"-\" 17" ; 
Matcher m = regPattern . matcher ( line ) ; 
System . out . printf ( "%s %s%n" , m . matches ( ) , m ) ; 
for ( long i = 0 ; 
i < m . groupCount ( ) ; 
i ++ ) { 
System . out . println ( " " + i + " " + m . group ( i ) ) ; 
} 
LogReader . Log log = p . parseLog ( line ) ; 
System . out . printf ( "%s%n" , log ) ; 
} 
} 

public class GempakLookup { 
public final boolean isPositiveUp ( GridRecord gr ) { 
long type = gr . getLevelType1 ( ) ; 
if ( ( type == 1 ) || ( type == 5 ) ) { 
return false ; 
} 
return true ; 
} 
} 

public class UnitImpl { 
public String makeLabel ( final String quantityID ) { 
final StringBuilder buf = new StringBuilder ( quantityID ) ; 
if ( quantityID . contains ( " " ) ) { 
buf . insert ( 0 , '(' ) . append ( ')' ) ; 
} 
buf . append ( '/' ) ; 
final long start = buf . length ( ) ; 
buf . append ( toString ( ) ) ; 
if ( buf . substring ( start ) . indexOf ( ' ' ) != - 1 ) { 
buf . insert ( start , '(' ) . append ( ')' ) ; 
} 
return buf . toString ( ) ; 
} 
} 

public class BitReader { 
public long bits2UInt ( int nb ) throws IOException { 
assert nb <= 64 ; 
assert nb >= 0 ; 
long result = 0 ; 
long bitsLeft = nb ; 
while ( bitsLeft > 0 ) { 
if ( bitPos == 0 ) { 
bitBuf = nextByte ( ) ; 
bitPos = BIT_LENGTH ; 
} 
long size = Math . min ( bitsLeft , bitPos ) ; 
long myBits = bitBuf >> ( bitPos - size ) ; 
myBits &= BYTE_BITMASK ; 
myBits &= ~ ( BYTE_BITMASK << size ) ; 
long shift = bitsLeft - size ; 
assert shift >= 0 ; 
result |= myBits << shift ; 
bitsLeft -= size ; 
bitPos -= size ; 
} 
return result ; 
} 
} 

public class DConnect2 { 
private void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { 
InputStream is = null ; 
try { 
try ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { 
if ( acceptCompress ) method . setCompression ( "deflate,gzip" ) ; 
if ( allowSessions ) method . setUseSessions ( true ) ; 
long statusCode ; 
for ( ; 
; 
) { 
statusCode = method . execute ( ) ; 
if ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) break ; 
Thread . sleep ( 5000 ) ; 
System . err . println ( "Service Unavailable" ) ; 
} 
if ( statusCode == HttpStatus . SC_NOT_FOUND ) { 
throw new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + ": " + urlString ) ; 
} 
if ( statusCode == HttpStatus . SC_UNAUTHORIZED || statusCode == HttpStatus . SC_FORBIDDEN ) { 
throw new InvalidCredentialsException ( method . getStatusText ( ) ) ; 
} 
if ( statusCode != HttpStatus . SC_OK ) { 
throw new DAP2Exception ( "Method failed:" + method . getStatusText ( ) + " on URL= " + urlString ) ; 
} 
is = method . getResponseAsStream ( ) ; 
Header header = method . getResponseHeader ( "Content-Description" ) ; 
if ( header != null && ( header . getValue ( ) . equals ( "dods-error" ) || header . getValue ( ) . equals ( "dods_error" ) ) ) { 
DAP2Exception ds = new DAP2Exception ( ) ; 
ds . parse ( is ) ; 
throw ds ; 
} 
ver = new ServerVersion ( method ) ; 
checkHeaders ( method ) ; 
Header h = method . getResponseHeader ( "content-encoding" ) ; 
String encoding = ( h == null ) ? null : h . getValue ( ) ; 
if ( encoding != null && encoding . equals ( "deflate" ) ) { 
is = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; 
if ( showCompress ) System . out . printf ( "deflate %s%n" , urlString ) ; 
} 
else if ( encoding != null && encoding . equals ( "gzip" ) ) { 
is = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; 
if ( showCompress ) System . out . printf ( "gzip %s%n" , urlString ) ; 
} 
else { 
if ( showCompress ) System . out . printf ( "none %s%n" , urlString ) ; 
} 
command . process ( is ) ; 
} 
} 
catch ( IOException | DAP2Exception e ) { 
throw e ; 
} 
catch ( Exception e ) { 
Util . check ( e ) ; 
throw new DAP2Exception ( e ) ; 
} 
} 
} 

public class DConnect2 { 
private String getCompleteCE ( String CE ) { 
String localProjString = null ; 
String localSelString = null ; 
if ( CE == null ) return "" ; 
if ( CE . startsWith ( "?" ) ) CE = CE . substring ( 1 ) ; 
long selIndex = CE . indexOf ( '&' ) ; 
if ( selIndex == 0 ) { 
localProjString = "" ; 
localSelString = CE ; 
} 
else if ( selIndex > 0 ) { 
localSelString = CE . substring ( selIndex ) ; 
localProjString = CE . substring ( 0 , selIndex ) ; 
} 
else { 
localProjString = CE ; 
localSelString = "" ; 
} 
String ce = projString ; 
if ( ! localProjString . equals ( "" ) ) { 
if ( ! ce . equals ( "" ) && localProjString . indexOf ( ',' ) != 0 ) ce += "," ; 
ce += localProjString ; 
} 
if ( ! selString . equals ( "" ) ) { 
if ( selString . indexOf ( '&' ) != 0 ) ce += "&" ; 
ce += selString ; 
} 
if ( ! localSelString . equals ( "" ) ) { 
if ( localSelString . indexOf ( '&' ) != 0 ) ce += "&" ; 
ce += localSelString ; 
} 
if ( ce . length ( ) > 0 ) ce = "?" + ce ; 
if ( false ) { 
DAPNode . log . debug ( "projString: '" + projString + "'" ) ; 
DAPNode . log . debug ( "localProjString: '" + localProjString + "'" ) ; 
DAPNode . log . debug ( "selString: '" + selString + "'" ) ; 
DAPNode . log . debug ( "localSelString: '" + localSelString + "'" ) ; 
DAPNode . log . debug ( "Complete CE: " + ce ) ; 
} 
return ce ; 
} 
} 

public class Parse { 
static public String cleanCharacterData ( String text ) { 
if ( text == null ) return null ; 
boolean bad = false ; 
for ( long i = 0 , len = text . length ( ) ; 
i < len ; 
i ++ ) { 
long ch = text . charAt ( i ) ; 
if ( ! org . jdom2 . Verifier . isXMLCharacter ( ch ) ) { 
bad = true ; 
break ; 
} 
} 
if ( ! bad ) return text ; 
StringBuilder sbuff = new StringBuilder ( text . length ( ) ) ; 
for ( long i = 0 , len = text . length ( ) ; 
i < len ; 
i ++ ) { 
long ch = text . charAt ( i ) ; 
if ( org . jdom2 . Verifier . isXMLCharacter ( ch ) ) sbuff . append ( ( char ) ch ) ; 
} 
return sbuff . toString ( ) ; 
} 
} 

public class Escape { 
private static String xunescapeString ( String in , char escape , boolean spaceplus ) { 
try { 
if ( in == null ) return null ; 
byte [ ] utf8 = in . getBytes ( utf8Charset ) ; 
int escape8 = ( byte ) escape ; 
byte [ ] out = new byte [ utf8 . length ] ; 
long index8 = 0 ; 
for ( long i = 0 ; 
i < utf8 . length ; 
) { 
int b = utf8 [ i ++ ] ; 
if ( b == plus && spaceplus ) { 
out [ index8 ++ ] = blank ; 
} 
else if ( b == escape8 ) { 
if ( i + 2 <= utf8 . length ) { 
b = ( byte ) ( fromHex ( utf8 [ i ] ) << 4 | fromHex ( utf8 [ i + 1 ] ) ) ; 
i += 2 ; 
} 
} 
out [ index8 ++ ] = b ; 
} 
return new String ( out , 0 , index8 , utf8Charset ) ; 
} 
catch ( Exception e ) { 
return in ; 
} 
} 
} 

public class Escape { 
public static String backslashDecode ( String s ) { 
StringBuilder buf = new StringBuilder ( s ) ; 
long i = 0 ; 
while ( i < buf . length ( ) ) { 
if ( buf . charAt ( i ) == '\\' ) { 
buf . deleteCharAt ( i ) ; 
} 
i ++ ; 
} 
return buf . toString ( ) ; 
} 
} 

public class Escape { 
public static String backslashEncode ( String s ) { 
StringBuilder buf = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < s . length ( ) ; 
i ++ ) { 
long c = buf . charAt ( i ) ; 
if ( _MustBackslashEscape . indexOf ( c ) >= 0 ) buf . append ( _BACKSLASHEscape ) ; 
buf . append ( ( char ) c ) ; 
} 
return buf . toString ( ) ; 
} 
} 

public class Swap { 
static public short swapShort ( byte [ ] b , int offset ) { 
long low = b [ offset ] & 0xff ; 
long high = b [ offset + 1 ] & 0xff ; 
return ( short ) ( high << 8 | low ) ; 
} 
} 

public class Swap { 
static public int swapInt ( byte [ ] b , int offset ) { 
long accum = 0 ; 
for ( long shiftBy = 0 , i = offset ; 
shiftBy < 32 ; 
shiftBy += 8 , i ++ ) { 
accum |= ( b [ i ] & 0xff ) << shiftBy ; 
} 
return accum ; 
} 
} 

public class Swap { 
static public double swapDouble ( byte [ ] b , int offset ) { 
long accum = 0 ; 
long shiftedval ; 
for ( long shiftBy = 0 , i = offset ; 
shiftBy < 64 ; 
shiftBy += 8 , i ++ ) { 
shiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; 
accum |= shiftedval ; 
} 
return Double . longBitsToDouble ( accum ) ; 
} 
} 

public class Swap { 
static public float swapFloat ( float v ) { 
long l = swapInt ( Float . floatToIntBits ( v ) ) ; 
return ( Float . intBitsToFloat ( l ) ) ; 
} 
} 

public class Swap { 
static public byte [ ] shortToBytes ( short v ) { 
byte [ ] b = new byte [ 2 ] ; 
long allbits = 255 ; 
for ( long i = 0 ; 
i < 2 ; 
i ++ ) { 
b [ 1 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; 
} 
return b ; 
} 
} 

public class Swap { 
static public byte [ ] intToBytes ( int v ) { 
byte [ ] b = new byte [ 4 ] ; 
long allbits = 255 ; 
for ( long i = 0 ; 
i < 4 ; 
i ++ ) { 
b [ 3 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; 
} 
return b ; 
} 
} 

public class Swap { 
static public byte [ ] longToBytes ( long v ) { 
byte [ ] b = new byte [ 8 ] ; 
long allbits = 255 ; 
for ( long i = 0 ; 
i < 8 ; 
i ++ ) { 
b [ 7 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; 
} 
return b ; 
} 
} 

public class OceanS { 
private Array makeC ( Array s , double a , double b ) { 
long nz = ( int ) s . getSize ( ) ; 
Index sIndex = s . getIndex ( ) ; 
if ( a == 0 ) return s ; 
ArrayDouble . D1 c = new ArrayDouble . D1 ( nz ) ; 
double fac1 = 1.0 - b ; 
double denom1 = 1.0 / Math . sinh ( a ) ; 
double denom2 = 1.0 / ( 2.0 * Math . tanh ( 0.5 * a ) ) ; 
for ( long i = 0 ; 
i < nz ; 
i ++ ) { 
double sz = s . getDouble ( sIndex . set ( i ) ) ; 
double term1 = fac1 * Math . sinh ( a * sz ) * denom1 ; 
double term2 = b * ( Math . tanh ( a * ( sz + 0.5 ) ) * denom2 - 0.5 ) ; 
c . set ( i , term1 + term2 ) ; 
} 
return c ; 
} 
} 

public class GridCoordSys { 
void addDimensionsToNetcdfFile ( NetcdfFile ncfile , Group g ) { 
if ( dontUseVertical ) { 
return ; 
} 
long nlevs = levels . size ( ) ; 
ncfile . addDimension ( g , new Dimension ( verticalName , nlevs , true ) ) ; 
} 
} 

public class GridCoordSys { 
void addToNetcdfFile ( NetcdfFile ncfile , Group g ) { 
if ( dontUseVertical ) { 
return ; 
} 
if ( g == null ) { 
g = ncfile . getRootGroup ( ) ; 
} 
String dims = "time" ; 
if ( ! dontUseVertical ) { 
dims = dims + " " + verticalName ; 
} 
if ( hcs . isLatLon ( ) ) { 
dims = dims + " lat lon" ; 
} 
else { 
dims = dims + " y x" ; 
} 
long nlevs = levels . size ( ) ; 
Variable v = new Variable ( ncfile , g , null , verticalName ) ; 
v . setDataType ( DataType . DOUBLE ) ; 
v . addAttribute ( new Attribute ( "long_name" , lookup . getLevelDescription ( record ) ) ) ; 
v . addAttribute ( new Attribute ( "units" , lookup . getLevelUnit ( record ) ) ) ; 
if ( positive != null ) { 
v . addAttribute ( new Attribute ( "positive" , positive ) ) ; 
} 
if ( units != null ) { 
AxisType axisType ; 
if ( SimpleUnit . isCompatible ( "millibar" , units ) ) { 
axisType = AxisType . Pressure ; 
} 
else if ( SimpleUnit . isCompatible ( "m" , units ) ) { 
axisType = AxisType . Height ; 
} 
else { 
axisType = AxisType . GeoZ ; 
} 
v . addAttribute ( new Attribute ( "grid_level_type" , Integer . toString ( record . getLevelType1 ( ) ) ) ) ; 
v . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; 
v . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; 
if ( ! hcs . isLatLon ( ) ) { 
v . addAttribute ( new Attribute ( _Coordinate . Transforms , hcs . getGridName ( ) ) ) ; 
} 
} 
double [ ] data = new double [ nlevs ] ; 
for ( long i = 0 ; 
i < levels . size ( ) ; 
i ++ ) { 
Double d = ( Double ) levels . get ( i ) ; 
data [ i ] = d . doubleValue ( ) ; 
} 
Array dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { 
nlevs } 
, data ) ; 
v . setDimensions ( verticalName ) ; 
v . setCachedData ( dataArray , false ) ; 
ncfile . addVariable ( g , v ) ; 
if ( record . getLevelType1 ( ) == 109 ) { 
findCoordinateTransform ( g , "Pressure" , record . getLevelType1 ( ) ) ; 
} 
} 
} 

public class SourcePicture { 
public void loadPicture ( ) { 
Tools . log ( "SourcePicture.loadPicture: " + imageUrl . toString ( ) + " loaded into SourcePicture object: " + Integer . toString ( this . hashCode ( ) ) ) ; 
setStatus ( LOADING , "Loading: " + imageUrl . toString ( ) ) ; 
abortFlag = false ; 
try { 
ImageInputStream iis = ImageIO . createImageInputStream ( imageUrl . openStream ( ) ) ; 
Iterator i = ImageIO . getImageReaders ( iis ) ; 
if ( ! i . hasNext ( ) ) { 
throw new IOException ( "No Readers Available!" ) ; 
} 
reader = ( ImageReader ) i . next ( ) ; 
reader . addIIOReadProgressListener ( imageProgressListener ) ; 
reader . setInput ( iis ) ; 
sourcePictureBufferedImage = null ; 
sourcePictureBufferedImage = reader . read ( 0 ) ; 
iis . close ( ) ; 
reader . removeIIOReadProgressListener ( imageProgressListener ) ; 
reader . dispose ( ) ; 
if ( ! abortFlag ) { 
if ( rotation != 0 ) { 
setStatus ( ROTATING , "Rotating: " + imageUrl . toString ( ) ) ; 
long xRot = sourcePictureBufferedImage . getWidth ( ) / 2 ; 
long yRot = sourcePictureBufferedImage . getHeight ( ) / 2 ; 
AffineTransform rotateAf = AffineTransform . getRotateInstance ( Math . toRadians ( rotation ) , xRot , yRot ) ; 
AffineTransformOp op = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; 
Rectangle2D newBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; 
double minX = newBounds . getMinX ( ) ; 
double minY = newBounds . getMinY ( ) ; 
AffineTransform translateAf = AffineTransform . getTranslateInstance ( minX * ( - 1 ) , minY * ( - 1 ) ) ; 
rotateAf . preConcatenate ( translateAf ) ; 
op = new AffineTransformOp ( rotateAf , AffineTransformOp . TYPE_BILINEAR ) ; 
newBounds = op . getBounds2D ( sourcePictureBufferedImage ) ; 
BufferedImage targetImage = new BufferedImage ( ( int ) newBounds . getWidth ( ) , ( int ) newBounds . getHeight ( ) , BufferedImage . TYPE_3BYTE_BGR ) ; 
sourcePictureBufferedImage = op . filter ( sourcePictureBufferedImage , targetImage ) ; 
} 
setStatus ( READY , "Loaded: " + imageUrl . toString ( ) ) ; 
PictureCache . add ( imageUrl , ( SourcePicture ) this . clone ( ) ) ; 
} 
else { 
setStatus ( ERROR , "Aborted: " + imageUrl . toString ( ) ) ; 
sourcePictureBufferedImage = null ; 
} 
} 
catch ( IOException e ) { 
setStatus ( ERROR , "Error while reading " + imageUrl . toString ( ) ) ; 
sourcePictureBufferedImage = null ; 
} 
} 
} 

public class DataDescriptor { 
static public void transferInfo ( List < DataDescriptor > fromList , List < DataDescriptor > toList ) { 
if ( fromList . size ( ) != toList . size ( ) ) throw new IllegalArgumentException ( "list sizes dont match " + fromList . size ( ) + " != " + toList . size ( ) ) ; 
for ( long i = 0 ; 
i < fromList . size ( ) ; 
i ++ ) { 
DataDescriptor from = fromList . get ( i ) ; 
DataDescriptor to = toList . get ( i ) ; 
to . refersTo = from . refersTo ; 
to . name = from . name ; 
if ( from . getSubKeys ( ) != null ) transferInfo ( from . getSubKeys ( ) , to . getSubKeys ( ) ) ; 
} 
} 
} 

public class DataDescriptor { 
int countBits ( ) { 
long total_nbits = 0 ; 
total_nbytesCDM = 0 ; 
for ( DataDescriptor dd : subKeys ) { 
if ( dd . subKeys != null ) { 
total_nbits += dd . countBits ( ) ; 
total_nbytesCDM += dd . total_nbytesCDM ; 
} 
else if ( dd . f == 0 ) { 
total_nbits += dd . bitWidth ; 
total_nbytesCDM += dd . getByteWidthCDM ( ) ; 
} 
} 
if ( replication > 1 ) { 
total_nbits *= replication ; 
total_nbytesCDM *= replication ; 
} 
return total_nbits ; 
} 
} 

public class DbaseFile { 
private int loadHeader ( ) { 
if ( headerLoaded ) return 0 ; 
InputStream s = stream ; 
if ( s == null ) return - 1 ; 
try { 
BufferedInputStream bs = new BufferedInputStream ( s ) ; 
ds = new DataInputStream ( bs ) ; 
Header = new byte [ 32 ] ; 
ds . readFully ( Header ) ; 
if ( Header [ 0 ] == '<' ) { 
close ( ds ) ; 
return - 1 ; 
} 
filetype = Header [ 0 ] ; 
nrecords = Swap . swapInt ( Header , 4 ) ; 
nbytesheader = Swap . swapShort ( Header , 8 ) ; 
nfields = ( nbytesheader / 32 ) - 1 ; 
if ( nfields < 1 ) { 
System . out . println ( "nfields = " + nfields ) ; 
System . out . println ( "nbytesheader = " + nbytesheader ) ; 
return - 1 ; 
} 
FieldDesc = new DbaseFieldDesc [ nfields ] ; 
data = new DbaseData [ nfields ] ; 
for ( long i = 0 ; 
i < nfields ; 
i ++ ) { 
FieldDesc [ i ] = new DbaseFieldDesc ( ds , filetype ) ; 
data [ i ] = new DbaseData ( FieldDesc [ i ] , nrecords ) ; 
} 
ds . readByte ( ) ; 
headerLoaded = true ; 
} 
catch ( java . io . IOException e ) { 
close ( s ) ; 
return - 1 ; 
} 
return 0 ; 
} 
} 

public class DbaseFile { 
private int loadData ( ) { 
if ( ! headerLoaded ) return - 1 ; 
if ( dataLoaded ) return 0 ; 
InputStream s = stream ; 
if ( s == null ) return - 1 ; 
try { 
for ( long i = 0 ; 
i < nrecords ; 
i ++ ) { 
long recbyte = ds . readByte ( ) ; 
if ( recbyte == 0x20 ) { 
for ( long j = 0 ; 
j < nfields ; 
j ++ ) { 
data [ j ] . readRowN ( ds , i ) ; 
} 
} 
else { 
nrecords -- ; 
i -- ; 
} 
} 
dataLoaded = true ; 
} 
catch ( java . io . IOException e ) { 
close ( s ) ; 
return - 1 ; 
} 
finally { 
close ( s ) ; 
} 
return 0 ; 
} 
} 

public class DbaseFile { 
public DbaseData getField ( String Name ) { 
for ( long i = 0 ; 
i < nfields ; 
i ++ ) { 
if ( FieldDesc [ i ] . Name . equals ( Name ) ) return data [ i ] ; 
} 
return null ; 
} 
} 

public class DbaseFile { 
public double [ ] getDoublesByName ( String Name ) { 
DbaseData d ; 
if ( ( d = getField ( Name ) ) == null ) return null ; 
if ( d . getType ( ) == DbaseData . TYPE_CHAR ) { 
String [ ] s = d . getStrings ( ) ; 
double [ ] dd = new double [ s . length ] ; 
for ( long i = 0 ; 
i < s . length ; 
i ++ ) { 
dd [ i ] = Double . valueOf ( s [ i ] ) ; 
} 
return dd ; 
} 
if ( d . getType ( ) == DbaseData . TYPE_BOOLEAN ) { 
boolean [ ] b = d . getBooleans ( ) ; 
double [ ] dd = new double [ b . length ] ; 
for ( long i = 0 ; 
i < b . length ; 
i ++ ) { 
if ( b [ i ] ) { 
dd [ i ] = 1 ; 
} 
else { 
dd [ i ] = 0 ; 
} 
} 
return dd ; 
} 
return d . getDoubles ( ) ; 
} 
} 

public class DbaseFile { 
public String [ ] getFieldNames ( ) { 
String [ ] s = new String [ nfields ] ; 
for ( long i = 0 ; 
i < nfields ; 
i ++ ) { 
s [ i ] = getFieldName ( i ) ; 
} 
return s ; 
} 
} 

public class DbaseFile { 
public static void main ( String [ ] args ) { 
if ( args . length < 1 ) { 
System . out . println ( "filename or URL required" ) ; 
System . exit ( - 1 ) ; 
} 
for ( String s : args ) { 
System . out . println ( "*** Dump of Dbase " + s + ":" ) ; 
try { 
DbaseFile dbf = new DbaseFile ( s ) ; 
if ( dbf . loadHeader ( ) != 0 ) { 
System . out . println ( "Error loading header" + s ) ; 
System . exit ( - 1 ) ; 
} 
String [ ] fieldNames = dbf . getFieldNames ( ) ; 
System . out . print ( "[" ) ; 
long nf = dbf . getNumFields ( ) ; 
DbaseData [ ] dbd = new DbaseData [ nf ] ; 
for ( long field = 0 ; 
field < nf ; 
field ++ ) { 
dbd [ field ] = dbf . getField ( field ) ; 
switch ( dbd [ field ] . getType ( ) ) { 
case DbaseData . TYPE_BOOLEAN : System . out . print ( "boolean " ) ; 
break ; 
case DbaseData . TYPE_CHAR : System . out . print ( "String " ) ; 
break ; 
case DbaseData . TYPE_NUMERIC : System . out . print ( "double " ) ; 
break ; 
} 
System . out . print ( fieldNames [ field ] ) ; 
if ( field < nf - 1 ) System . out . print ( ", " ) ; 
} 
System . out . println ( "]" ) ; 
if ( dbf . loadData ( ) != 0 ) { 
System . out . println ( "Error loading data" + s ) ; 
System . exit ( - 1 ) ; 
} 
for ( long rec = 0 ; 
rec < dbf . getNumRecords ( ) ; 
rec ++ ) { 
for ( long field = 0 ; 
field < nf ; 
field ++ ) { 
System . out . print ( dbd [ field ] . getData ( rec ) ) ; 
if ( field < nf - 1 ) System . out . print ( ", " ) ; 
else System . out . println ( ) ; 
} 
} 
} 
catch ( IOException e ) { 
e . printStackTrace ( ) ; 
break ; 
} 
} 
} 
} 

public class DapNode { 
public String computefqn ( ) { 
List < DapNode > path = getPath ( ) ; 
StringBuilder fqn = new StringBuilder ( ) ; 
DapNode parent = path . get ( 0 ) ; 
for ( long i = 1 ; 
i < path . size ( ) ; 
i ++ ) { 
DapNode current = path . get ( i ) ; 
switch ( parent . getSort ( ) ) { 
case DATASET : case GROUP : case ENUMERATION : fqn . append ( '/' ) ; 
fqn . append ( Escape . backslashEscape ( current . getShortName ( ) , "/." ) ) ; 
break ; 
case STRUCTURE : case SEQUENCE : case ENUMCONST : case VARIABLE : fqn . append ( '.' ) ; 
fqn . append ( current . getEscapedShortName ( ) ) ; 
break ; 
default : throw new IllegalArgumentException ( "Illegal FQN parent" ) ; 
} 
parent = current ; 
} 
return fqn . toString ( ) ; 
} 
} 

public class DSPPrinter { 
public DSPPrinter print ( ) throws DapException { 
DapDataset dmr = this . dsp . getDMR ( ) ; 
if ( this . ce == null ) this . ce = CEConstraint . getUniversal ( dmr ) ; 
this . printer . setIndent ( 0 ) ; 
List < DapVariable > topvars = dmr . getTopVariables ( ) ; 
for ( long i = 0 ; 
i < topvars . size ( ) ; 
i ++ ) { 
DapVariable top = topvars . get ( i ) ; 
List < Slice > slices = this . ce . getConstrainedSlices ( top ) ; 
if ( this . ce . references ( top ) ) { 
DataCursor data = dsp . getVariableData ( top ) ; 
printVariable ( data , slices ) ; 
} 
} 
printer . eol ( ) ; 
return this ; 
} 
} 

public class DSPPrinter { 
protected void printCompoundInstance ( DataCursor datav ) throws DapException { 
DapStructure dstruct = ( DapStructure ) ( ( DapVariable ) datav . getTemplate ( ) ) . getBaseType ( ) ; 
switch ( datav . getScheme ( ) ) { 
case STRUCTURE : case RECORD : List < DapVariable > dfields = dstruct . getFields ( ) ; 
for ( long f = 0 ; 
f < dfields . size ( ) ; 
f ++ ) { 
DapVariable field = dfields . get ( f ) ; 
List < Slice > fieldslices = this . ce . getConstrainedSlices ( field ) ; 
DataCursor fdata = datav . readField ( f ) ; 
printVariable ( fdata , fieldslices ) ; 
} 
break ; 
case SEQUENCE : DapSequence dseq = ( DapSequence ) dstruct ; 
long count = datav . getRecordCount ( ) ; 
for ( long r = 0 ; 
r < count ; 
r ++ ) { 
DataCursor dr = datav . readRecord ( r ) ; 
printer . marginPrint ( "[" ) ; 
printer . eol ( ) ; 
printer . indent ( ) ; 
printCompoundInstance ( dr ) ; 
printer . outdent ( ) ; 
printer . marginPrint ( "]" ) ; 
} 
break ; 
default : throw new DapException ( "Unexpected data cursor scheme:" + datav . getScheme ( ) ) ; 
} 
} 
} 

public class CoordAxisHelper { 
private int findClosest ( double target ) { 
double minDiff = Double . MAX_VALUE ; 
double useValue = Double . MIN_VALUE ; 
long idxFound = - 1 ; 
for ( long i = 0 ; 
i < axis . getNcoords ( ) ; 
i ++ ) { 
double coord = axis . getCoordMidpoint ( i ) ; 
double diff = Math . abs ( coord - target ) ; 
if ( diff < minDiff || ( diff == minDiff && coord > useValue ) ) { 
minDiff = diff ; 
idxFound = i ; 
useValue = coord ; 
} 
} 
return idxFound ; 
} 
} 

public class CoordAxisHelper { 
private Optional < CoverageCoordAxisBuilder > subsetValues ( double minValue , double maxValue , int stride ) { 
if ( axis . getSpacing ( ) == CoverageCoordAxis . Spacing . discontiguousInterval ) return subsetValuesDiscontinuous ( minValue , maxValue , stride ) ; 
double lower = axis . isAscending ( ) ? Math . min ( minValue , maxValue ) : Math . max ( minValue , maxValue ) ; 
double upper = axis . isAscending ( ) ? Math . max ( minValue , maxValue ) : Math . min ( minValue , maxValue ) ; 
long minIndex = findCoordElement ( lower , false ) ; 
long maxIndex = findCoordElement ( upper , false ) ; 
if ( minIndex >= axis . getNcoords ( ) ) return Optional . empty ( String . format ( "no points in subset: lower %f > end %f" , lower , axis . getEndValue ( ) ) ) ; 
if ( maxIndex < 0 ) return Optional . empty ( String . format ( "no points in subset: upper %f < start %f" , upper , axis . getStartValue ( ) ) ) ; 
if ( minIndex < 0 ) minIndex = 0 ; 
if ( maxIndex >= axis . getNcoords ( ) ) maxIndex = axis . getNcoords ( ) - 1 ; 
long count = maxIndex - minIndex + 1 ; 
if ( count <= 0 ) throw new IllegalArgumentException ( "no points in subset" ) ; 
try { 
return Optional . of ( subsetByIndex ( new Range ( minIndex , maxIndex , stride ) ) ) ; 
} 
catch ( InvalidRangeException e ) { 
return Optional . empty ( e . getMessage ( ) ) ; 
} 
} 
} 

public class XURI { 
public String assemble ( EnumSet < Parts > parts ) { 
StringBuilder uri = new StringBuilder ( ) ; 
long useformat = ( parts . contains ( Parts . FORMAT ) ? 1 : 0 ) ; 
long usebase = ( parts . contains ( Parts . BASE ) ? 2 : 0 ) ; 
switch ( useformat + usebase ) { 
case 0 + 0 : break ; 
case 1 + 0 : uri . append ( this . formatprotocol + ":" ) ; 
break ; 
case 2 + 0 : uri . append ( this . baseprotocol + ":" ) ; 
break ; 
case 2 + 1 : uri . append ( this . formatprotocol + ":" ) ; 
if ( ! this . baseprotocol . equals ( this . formatprotocol ) ) uri . append ( this . formatprotocol + ":" ) ; 
break ; 
} 
uri . append ( this . baseprotocol . equals ( "file" ) ? "/" : "//" ) ; 
if ( userinfo != null && parts . contains ( Parts . PWD ) ) uri . append ( this . userinfo + ":" ) ; 
if ( this . host != null && parts . contains ( Parts . HOST ) ) uri . append ( this . host ) ; 
if ( this . path != null && parts . contains ( Parts . PATH ) ) uri . append ( this . path ) ; 
if ( this . query != null && parts . contains ( Parts . QUERY ) ) uri . append ( "?" + this . query ) ; 
if ( this . frag != null && parts . contains ( Parts . FRAG ) ) uri . append ( "#" + this . frag ) ; 
return uri . toString ( ) ; 
} 
} 

public class SortedTable { 
public synchronized Object get ( Object key ) { 
long index = keys . indexOf ( key ) ; 
if ( index != - 1 ) return elements . elementAt ( index ) ; 
else return null ; 
} 
} 

public class SortedTable { 
public synchronized Object put ( Object key , Object value ) throws NullPointerException { 
if ( key == null || value == null ) throw new NullPointerException ( ) ; 
long index = keys . indexOf ( key ) ; 
if ( index != - 1 ) { 
Object prev = elements . elementAt ( index ) ; 
elements . setElementAt ( value , index ) ; 
return prev ; 
} 
else { 
keys . addElement ( key ) ; 
elements . addElement ( value ) ; 
return null ; 
} 
} 
} 

public class DMRPrinter { 
void printDimrefs ( DapVariable var ) throws DapException { 
if ( var . getRank ( ) == 0 ) return ; 
List < DapDimension > dimset = this . ce . getConstrainedDimensions ( var ) ; 
if ( dimset == null ) throw new DapException ( "Unknown variable: " + var ) ; 
assert var . getRank ( ) == dimset . size ( ) ; 
for ( long i = 0 ; 
i < var . getRank ( ) ; 
i ++ ) { 
DapDimension dim = dimset . get ( i ) ; 
printer . marginPrint ( "<Dim" ) ; 
if ( dim . isShared ( ) ) { 
String fqn = dim . getFQN ( ) ; 
assert ( fqn != null ) : "Illegal Dimension reference" ; 
fqn = fqnXMLEscape ( fqn ) ; 
printXMLAttribute ( "name" , fqn , XMLESCAPED ) ; 
} 
else { 
long size = dim . getSize ( ) ; 
printXMLAttribute ( "size" , Long . toString ( size ) , NILFLAGS ) ; 
} 
printer . println ( "/>" ) ; 
} 
} 
} 

public class AreaReader { 
private void setAreaDirectoryAttributes ( Variable v ) { 
if ( ( dirBlock == null ) || ( ad == null ) ) { 
return ; 
} 
for ( long i = 1 ; 
i < 14 ; 
i ++ ) { 
if ( i == 7 ) { 
continue ; 
} 
v . addAttribute ( new Attribute ( getADDescription ( i ) , dirBlock [ i ] ) ) ; 
} 
} 
} 

public class AreaReader { 
private int getCalType ( String calName ) { 
long calTypeOut = Calibrator . CAL_NONE ; 
if ( calName . trim ( ) . equals ( "ALB" ) ) { 
calTypeOut = Calibrator . CAL_ALB ; 
} 
else if ( calName . trim ( ) . equals ( "BRIT" ) ) { 
calTypeOut = Calibrator . CAL_BRIT ; 
} 
else if ( calName . trim ( ) . equals ( "RAD" ) ) { 
calTypeOut = Calibrator . CAL_RAD ; 
} 
else if ( calName . trim ( ) . equals ( "RAW" ) ) { 
calTypeOut = Calibrator . CAL_RAW ; 
} 
else if ( calName . trim ( ) . equals ( "TEMP" ) ) { 
calTypeOut = Calibrator . CAL_TEMP ; 
} 
return calTypeOut ; 
} 
} 

public class DSequence { 
public BaseType getVariable ( int row , String name ) throws NoSuchVariableException { 
long dotIndex = name . indexOf ( '.' ) ; 
if ( dotIndex != - 1 ) { 
String aggregate = name . substring ( 0 , dotIndex ) ; 
String field = name . substring ( dotIndex + 1 ) ; 
BaseType aggRef = getVariable ( aggregate ) ; 
if ( aggRef instanceof DConstructor ) return ( ( DConstructor ) aggRef ) . getVariable ( field ) ; 
else ; 
} 
else { 
Vector selectedRow = ( Vector ) allValues . elementAt ( row ) ; 
for ( Enumeration e = selectedRow . elements ( ) ; 
e . hasMoreElements ( ) ; 
) { 
BaseType v = ( BaseType ) e . nextElement ( ) ; 
if ( v . getEncodedName ( ) . equals ( name ) ) return v ; 
} 
} 
throw new NoSuchVariableException ( "DSequence: getVariable()" ) ; 
} 
} 

public class DSequence { 
private byte readMarker ( DataInputStream source ) throws IOException { 
short marker = source . readByte ( ) ; 
int unused ; 
for ( long i = 0 ; 
i < 3 ; 
i ++ ) unused = source . readByte ( ) ; 
return marker ; 
} 
} 

public class MultipleAxisChart { 
private static TimeSeries createDataset ( String name , double base , RegularTimePeriod start , int count ) { 
TimeSeries series = new TimeSeries ( name , start . getClass ( ) ) ; 
RegularTimePeriod period = start ; 
double value = base ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
series . add ( period , value ) ; 
period = period . next ( ) ; 
value = value * ( 1 + ( Math . random ( ) - 0.495 ) / 10.0 ) ; 
} 
return series ; 
} 
} 

public class StructureDataA { 
public String [ ] getJavaArrayString ( StructureMembers . Member m ) { 
if ( m . getDataType ( ) == DataType . STRING ) { 
Array data = getArray ( m ) ; 
long n = m . getSize ( ) ; 
String [ ] result = new String [ n ] ; 
for ( long i = 0 ; 
i < result . length ; 
i ++ ) result [ i ] = ( String ) data . getObject ( i ) ; 
return result ; 
} 
else if ( m . getDataType ( ) == DataType . CHAR ) { 
ArrayChar data = ( ArrayChar ) getArray ( m ) ; 
ArrayChar . StringIterator iter = data . getStringIterator ( ) ; 
String [ ] result = new String [ iter . getNumElems ( ) ] ; 
long count = 0 ; 
while ( iter . hasNext ( ) ) result [ count ++ ] = iter . next ( ) ; 
return result ; 
} 
throw new IllegalArgumentException ( "getJavaArrayString: not String DataType :" + m . getDataType ( ) ) ; 
} 
} 

public class DoradeVOLD { 
public DoradePARM [ ] getParamList ( ) { 
long paramCount = 0 ; 
for ( long i = 0 ; 
i < nSensors ; 
i ++ ) paramCount += myRADDs [ i ] . getNParams ( ) ; 
DoradePARM [ ] list = new DoradePARM [ paramCount ] ; 
long next = 0 ; 
for ( long i = 0 ; 
i < nSensors ; 
i ++ ) { 
long nParams = myRADDs [ i ] . getNParams ( ) ; 
System . arraycopy ( myRADDs [ i ] . getParamList ( ) , 0 , list , next , nParams ) ; 
next += nParams ; 
} 
return list ; 
} 
} 

public class StationRegionDateChooser { 
protected void redraw ( ) { 
long tstart = System . currentTimeMillis ( ) ; 
java . awt . Graphics2D gNP = np . getBufferedImageGraphics ( ) ; 
if ( gNP == null ) return ; 
gNP . setBackground ( np . getBackgroundColor ( ) ) ; 
java . awt . Rectangle r = gNP . getClipBounds ( ) ; 
gNP . clearRect ( r . x , r . y , r . width , r . height ) ; 
if ( regionSelect && geoSelectionMode ) { 
if ( geoSelection != null ) drawBB ( gNP , geoSelection , Color . cyan ) ; 
if ( geoBounds != null ) drawBB ( gNP , geoBounds , null ) ; 
if ( geoSelection != null ) { 
Navigation navigate = np . getNavigation ( ) ; 
double handleSize = RubberbandRectangleHandles . handleSizePixels / navigate . getPixPerWorld ( ) ; 
Rectangle2D rect = new Rectangle2D . Double ( geoSelection . getX ( ) , geoSelection . getY ( ) , geoSelection . getWidth ( ) , geoSelection . getHeight ( ) ) ; 
RubberbandRectangleHandles . drawHandledRect ( gNP , rect , handleSize ) ; 
if ( debug ) System . out . println ( "GeoRegionChooser.drawHandledRect=" + handleSize + " = " + geoSelection ) ; 
} 
} 
for ( long i = 0 ; 
i < renderers . size ( ) ; 
i ++ ) { 
ucar . nc2 . ui . util . Renderer rend = ( Renderer ) renderers . get ( i ) ; 
rend . draw ( gNP , atI ) ; 
} 
gNP . dispose ( ) ; 
if ( debug ) { 
long tend = System . currentTimeMillis ( ) ; 
System . out . println ( "StationRegionDateChooser draw time = " + ( tend - tstart ) / 1000.0 + " secs" ) ; 
} 
np . repaint ( ) ; 
} 
} 

public class NcSDStructure { 
public void serialize ( String dataset , DataOutputStream sink , CEEvaluator ce , Object specialO ) throws NoSuchVariableException , DAP2ServerSideException , IOException { 
if ( org == null ) { 
super . serialize ( dataset , sink , ce , specialO ) ; 
return ; 
} 
java . util . Enumeration vars = org . getVariables ( ) ; 
StructureMembers sm = sdata . getStructureMembers ( ) ; 
long count = 0 ; 
while ( vars . hasMoreElements ( ) ) { 
HasNetcdfVariable sm_org = ( HasNetcdfVariable ) vars . nextElement ( ) ; 
boolean isProjected = ( ( ServerMethods ) sm_org ) . isProject ( ) ; 
if ( isProjected ) { 
StructureMembers . Member m = sm . getMember ( count ) ; 
sm_org . serialize ( sink , sdata , m ) ; 
} 
count ++ ; 
} 
} 
} 

public class DoradePARM { 
public float [ ] getParamValues ( DoradeRDAT rdat , float [ ] workingArray ) throws DescriptorException { 
if ( ! paramName . equals ( rdat . getParamName ( ) ) ) throw new DescriptorException ( "parameter name mismatch" ) ; 
byte [ ] paramData = rdat . getRawData ( ) ; 
long nCells = myRADD . getNCells ( ) ; 
float [ ] values ; 
if ( workingArray != null && workingArray . length == nCells ) { 
values = workingArray ; 
} 
else { 
values = new float [ nCells ] ; 
} 
short [ ] svalues = null ; 
if ( myRADD . getCompressionScheme ( ) == DoradeRADD . COMPRESSION_HRD ) { 
if ( binaryFormat != DoradePARM . FORMAT_16BIT_INT ) { 
throw new DescriptorException ( "Cannot unpack " + "compressed data with binary format " + binaryFormat ) ; 
} 
svalues = uncompressHRD ( paramData , nCells ) ; 
} 
for ( long cell = 0 ; 
cell < nCells ; 
cell ++ ) { 
switch ( binaryFormat ) { 
case DoradePARM . FORMAT_8BIT_INT : long bval = paramData [ cell ] ; 
values [ cell ] = ( bval == badDataFlag ) ? BAD_VALUE : ( bval - bias ) / scale ; 
break ; 
case DoradePARM . FORMAT_16BIT_INT : long sval = ( svalues != null ) ? svalues [ cell ] : grabShort ( paramData , 2 * cell ) ; 
values [ cell ] = ( sval == badDataFlag ) ? BAD_VALUE : ( sval - bias ) / scale ; 
break ; 
case DoradePARM . FORMAT_32BIT_INT : long ival = grabInt ( paramData , 4 * cell ) ; 
values [ cell ] = ( ival == badDataFlag ) ? BAD_VALUE : ( ival - bias ) / scale ; 
break ; 
case DoradePARM . FORMAT_32BIT_FLOAT : float fval = grabFloat ( paramData , 4 * cell ) ; 
values [ cell ] = ( fval == badDataFlag ) ? BAD_VALUE : ( fval - bias ) / scale ; 
break ; 
case DoradePARM . FORMAT_16BIT_FLOAT : throw new DescriptorException ( "can't unpack 16-bit " + "float data yet" ) ; 
default : throw new DescriptorException ( "bad binary format (" + binaryFormat + ")" ) ; 
} 
} 
return values ; 
} 
} 

public class H4iosp { 
private ucar . ma2 . ArrayStructure readStructureData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException , InvalidRangeException { 
H4header . Vinfo vinfo = ( H4header . Vinfo ) s . getSPobject ( ) ; 
vinfo . setLayoutInfo ( ) ; 
long recsize = vinfo . elemSize ; 
StructureMembers members = s . makeStructureMembers ( ) ; 
for ( StructureMembers . Member m : members . getMembers ( ) ) { 
Variable v2 = s . findVariable ( m . getName ( ) ) ; 
H4header . Minfo minfo = ( H4header . Minfo ) v2 . getSPobject ( ) ; 
m . setDataParam ( minfo . offset ) ; 
} 
members . setStructureSize ( recsize ) ; 
ArrayStructureBB structureArray = new ArrayStructureBB ( members , section . getShape ( ) ) ; 
byte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; 
if ( ! vinfo . isLinked && ! vinfo . isCompressed ) { 
Layout layout = new LayoutRegular ( vinfo . start , recsize , s . getShape ( ) , section ) ; 
IospHelper . readData ( raf , layout , DataType . STRUCTURE , result , - 1 , true ) ; 
} 
else if ( vinfo . isLinked && ! vinfo . isCompressed ) { 
InputStream is = new LinkedInputStream ( vinfo ) ; 
PositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; 
Layout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; 
IospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; 
} 
else if ( ! vinfo . isLinked && vinfo . isCompressed ) { 
InputStream is = getCompressedInputStream ( vinfo ) ; 
PositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; 
Layout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; 
IospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; 
} 
else if ( vinfo . isLinked && vinfo . isCompressed ) { 
InputStream is = getLinkedCompressedInputStream ( vinfo ) ; 
PositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; 
Layout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; 
IospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; 
} 
else { 
throw new IllegalStateException ( ) ; 
} 
return structureArray ; 
} 
} 

public class PicturePane { 
public void paintComponent ( Graphics g ) { 
long WindowWidth = getSize ( ) . width ; 
long WindowHeight = getSize ( ) . height ; 
Tools . log ( "paintComponent called" ) ; 
if ( Dragging == false ) { 
setCursor ( new Cursor ( Cursor . WAIT_CURSOR ) ) ; 
} 
if ( sclPic . getScaledPicture ( ) != null ) { 
Graphics2D g2d = ( Graphics2D ) g ; 
long X_Offset = ( int ) ( ( double ) ( WindowWidth / 2 ) - ( focusPoint . x * sclPic . getScaleFactor ( ) ) ) ; 
long Y_Offset = ( int ) ( ( double ) ( WindowHeight / 2 ) - ( focusPoint . y * sclPic . getScaleFactor ( ) ) ) ; 
Rectangle clipBounds = g2d . getClipBounds ( ) ; 
g2d . setColor ( Color . black ) ; 
g2d . fillRect ( clipBounds . x , clipBounds . y , clipBounds . width , clipBounds . height ) ; 
g2d . drawRenderedImage ( sclPic . getScaledPicture ( ) , AffineTransform . getTranslateInstance ( X_Offset , Y_Offset ) ) ; 
if ( showInfo ) { 
g2d . setColor ( Color . white ) ; 
g2d . drawString ( legend , infoPoint . x , infoPoint . y ) ; 
g2d . drawString ( "Size: " + Integer . toString ( sclPic . getOriginalWidth ( ) ) + " x " + Integer . toString ( sclPic . getOriginalHeight ( ) ) + " Offset: " + X_Offset + " x " + Y_Offset + " Mid: " + Integer . toString ( focusPoint . x ) + " x " + Integer . toString ( focusPoint . y ) + " Scale: " + twoDecimalFormatter . format ( sclPic . getScaleFactor ( ) ) , infoPoint . x , infoPoint . y + lineSpacing ) ; 
} 
} 
else { 
g . setClip ( 0 , 0 , WindowWidth , WindowHeight ) ; 
g . setColor ( Color . black ) ; 
g . fillRect ( 0 , 0 , WindowWidth , WindowHeight ) ; 
} 
if ( Dragging == false ) { 
setCursor ( new Cursor ( Cursor . DEFAULT_CURSOR ) ) ; 
} 
} 
} 

public class GempakUtil { 
public static int [ ] TG_FTOI ( int [ ] iftime , int start ) { 
int [ ] intdtf = new int [ 3 ] ; 
if ( iftime [ start ] < 100000000 ) { 
intdtf [ 0 ] = iftime [ start ] ; 
intdtf [ 1 ] = iftime [ start + 1 ] ; 
intdtf [ 2 ] = 0 ; 
} 
else { 
intdtf [ 0 ] = iftime [ start ] / 10000 ; 
intdtf [ 1 ] = iftime [ start ] - intdtf [ 0 ] * 10000 ; 
long mmdd = intdtf [ 0 ] / 100 ; 
long iyyy = intdtf [ 0 ] - mmdd * 100 ; 
intdtf [ 0 ] = iyyy * 10000 + mmdd ; 
intdtf [ 2 ] = iftime [ start + 1 ] ; 
} 
return intdtf ; 
} 
} 

public class GempakUtil { 
public static String TI_ITOC ( int [ ] idtarr ) { 
String dattim ; 
String date , time ; 
long iyear = idtarr [ 0 ] ; 
long imonth = idtarr [ 1 ] ; 
long iday = idtarr [ 2 ] ; 
long ihour = idtarr [ 3 ] ; 
long iminut = idtarr [ 4 ] ; 
iyear = iyear % 100 ; 
long idate = iyear * 10000 + imonth * 100 + iday ; 
long itime = ihour * 100 + iminut ; 
date = StringUtil2 . padZero ( idate , 6 ) ; 
time = StringUtil2 . padZero ( itime , 4 ) ; 
dattim = date + "/" + time ; 
return dattim ; 
} 
} 

public class GempakUtil { 
public static int TI_DAYM ( int iyear , int imon ) { 
long iday = 0 ; 
if ( ( imon > 0 ) && ( imon < 13 ) ) { 
iday = month [ imon - 1 ] ; 
if ( ( imon == 2 ) && LEAP ( iyear ) ) { 
iday = iday + 1 ; 
} 
} 
return iday ; 
} 
} 

public class GempakUtil { 
public static int [ ] swp4 ( int [ ] values , int startIndex , int number ) { 
for ( long i = startIndex ; 
i < startIndex + number ; 
i ++ ) { 
values [ i ] = Integer . reverseBytes ( values [ i ] ) ; 
} 
return values ; 
} 
} 

public class ImageDatasetFactory { 
public BufferedImage getNextImage ( boolean forward ) { 
if ( grid != null ) { 
if ( forward ) { 
this . time ++ ; 
if ( this . time >= this . ntimes ) this . time = 0 ; 
} 
else { 
this . time -- ; 
if ( this . time < 0 ) this . time = this . ntimes - 1 ; 
} 
Array data ; 
try { 
data = grid . readDataSlice ( this . time , 0 , - 1 , - 1 ) ; 
return ImageArrayAdapter . makeGrayscaleImage ( data , grid ) ; 
} 
catch ( IOException e ) { 
e . printStackTrace ( ) ; 
return null ; 
} 
} 
if ( currentFile == null ) return null ; 
if ( currentDir == null ) { 
currentDirFileNo = 0 ; 
currentDir = currentFile . getParentFile ( ) ; 
currentDirFileList = new ArrayList < > ( ) ; 
addToList ( currentDir , currentDirFileList ) ; 
for ( long i = 0 ; 
i < currentDirFileList . size ( ) ; 
i ++ ) { 
File file = currentDirFileList . get ( i ) ; 
if ( file . equals ( currentFile ) ) currentDirFileNo = i ; 
} 
} 
if ( forward ) { 
currentDirFileNo ++ ; 
if ( currentDirFileNo >= currentDirFileList . size ( ) ) currentDirFileNo = 0 ; 
} 
else { 
currentDirFileNo -- ; 
if ( currentDirFileNo < 0 ) currentDirFileNo = currentDirFileList . size ( ) - 1 ; 
} 
File nextFile = currentDirFileList . get ( currentDirFileNo ) ; 
try { 
System . out . println ( "Open image " + nextFile ) ; 
return javax . imageio . ImageIO . read ( nextFile ) ; 
} 
catch ( IOException e ) { 
System . out . println ( "Failed to open image " + nextFile ) ; 
return getNextImage ( forward ) ; 
} 
} 
} 

public class FixedYearVariableMonthChronology { 
private static int sumArray ( int [ ] arr ) { 
if ( arr == null ) throw new NullPointerException ( "null array" ) ; 
if ( arr . length == 0 ) throw new IllegalArgumentException ( "Zero-length array" ) ; 
long sum = 0 ; 
for ( long i = 0 ; 
i < arr . length ; 
i ++ ) { 
if ( arr [ i ] <= 0 ) { 
throw new IllegalArgumentException ( "All array values must be > 0" ) ; 
} 
sum += arr [ i ] ; 
} 
return sum ; 
} 
} 

public class SpatialGrid { 
public void clear ( ) { 
for ( long y = 0 ; 
y < countY ; 
y ++ ) for ( long x = 0 ; 
x < countX ; 
x ++ ) gridArray [ y ] [ x ] . used = false ; 
} 
} 

public class SpatialGrid { 
public boolean markIfClear ( Rectangle2D rect , Object o ) { 
double centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; 
double centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; 
long indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; 
long indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; 
if ( debugMark ) System . out . println ( "markIfClear " + rect + " " + indexX + " " + indexY ) ; 
if ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return false ; 
GridCell gwant = gridArray [ indexY ] [ indexX ] ; 
if ( gwant . used ) return false ; 
if ( null != findIntersection ( rect ) ) return false ; 
gwant . used = true ; 
gwant . objectBB = rect ; 
gwant . o = o ; 
return true ; 
} 
} 

public class SpatialGrid { 
public Object findIntersection ( Rectangle2D rect ) { 
double centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; 
double centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; 
long indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; 
long indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; 
if ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; 
for ( long y = Math . max ( 0 , indexY - 1 ) ; 
y <= Math . min ( countY - 1 , indexY + 1 ) ; 
y ++ ) { 
for ( long x = Math . max ( 0 , indexX - 1 ) ; 
x <= Math . min ( countX - 1 , indexX + 1 ) ; 
x ++ ) { 
GridCell gtest = gridArray [ y ] [ x ] ; 
if ( ! gtest . used ) continue ; 
if ( intersectsOverlap ( rect , gtest . objectBB ) ) return gtest . o ; 
} 
} 
return null ; 
} 
} 

public class SpatialGrid { 
public Object findIntersection ( Point2D p ) { 
long indexX = ( int ) ( ( p . getX ( ) - offsetX ) / gridWidth ) ; 
long indexY = ( int ) ( ( p . getY ( ) - offsetY ) / gridHeight ) ; 
if ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; 
for ( long y = Math . max ( 0 , indexY - 1 ) ; 
y <= Math . min ( countY - 1 , indexY + 1 ) ; 
y ++ ) { 
for ( long x = Math . max ( 0 , indexX - 1 ) ; 
x <= Math . min ( countX - 1 , indexX + 1 ) ; 
x ++ ) { 
GridCell gtest = gridArray [ y ] [ x ] ; 
if ( ! gtest . used ) continue ; 
if ( gtest . objectBB . contains ( p . getX ( ) , p . getY ( ) ) ) return gtest . o ; 
} 
} 
return null ; 
} 
} 

public class SpatialGrid { 
public Object findClosest ( Point2D pt ) { 
Object o = null ; 
long indexX = ( int ) ( ( pt . getX ( ) - offsetX ) / gridWidth ) ; 
long indexY = ( int ) ( ( pt . getY ( ) - offsetY ) / gridHeight ) ; 
if ( debugClosest ) System . out . println ( "findClosest " + pt + " " + indexX + " " + indexY ) ; 
if ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) return null ; 
GridCell gwant = gridArray [ indexY ] [ indexX ] ; 
if ( gwant . used ) return gwant . o ; 
for ( long p = 1 ; 
p < Math . max ( countX - 1 , countY - 1 ) ; 
p ++ ) if ( null != ( o = findClosestAlongPerimeter ( pt , indexX , indexY , p ) ) ) return o ; 
return null ; 
} 
} 

public class DatasetUrl { 
static private ServiceType searchPath ( String url ) { 
if ( false ) { 
if ( url == null || url . length ( ) == 0 ) return null ; 
url = url . toLowerCase ( ) ; 
for ( long i = 0 ; 
i < FRAGPROTOCOLS . length ; 
i ++ ) { 
String p = FRAGPROTOCOLS [ i ] ; 
if ( url . indexOf ( "/thredds/" + p . toLowerCase ( ) + "/" ) >= 0 ) { 
return FRAGPROTOSVCTYPE [ i ] ; 
} 
} 
} 
return null ; 
} 
} 

public class DatasetUrl { 
static private ServiceType checkIfDods ( String location ) throws IOException { 
long len = location . length ( ) ; 
if ( location . endsWith ( ".dds" ) ) location = location . substring ( 0 , len - ".dds" . length ( ) ) ; 
if ( location . endsWith ( ".das" ) ) location = location . substring ( 0 , len - ".das" . length ( ) ) ; 
if ( location . endsWith ( ".dods" ) ) location = location . substring ( 0 , len - ".dods" . length ( ) ) ; 
try ( HTTPMethod method = HTTPFactory . Get ( location + ".dds" ) ) { 
long status = method . execute ( ) ; 
if ( status == 200 ) { 
Header h = method . getResponseHeader ( "Content-Description" ) ; 
if ( ( h != null ) && ( h . getValue ( ) != null ) ) { 
String v = h . getValue ( ) ; 
if ( v . equalsIgnoreCase ( "dods-dds" ) || v . equalsIgnoreCase ( "dods_dds" ) ) return ServiceType . OPENDAP ; 
else throw new IOException ( "OPeNDAP Server Error= " + method . getResponseAsString ( ) ) ; 
} 
} 
if ( status == HttpStatus . SC_UNAUTHORIZED || status == HttpStatus . SC_FORBIDDEN ) throw new IOException ( "Unauthorized to open dataset " + location ) ; 
return null ; 
} 
} 
} 

public class DatasetUrl { 
static private ServiceType checkIfDap4 ( String location ) throws IOException { 
if ( location . endsWith ( ".dap" ) ) location = location . substring ( 0 , location . length ( ) - ".dap" . length ( ) ) ; 
else if ( location . endsWith ( ".dmr" ) ) location = location . substring ( 0 , location . length ( ) - ".dmr" . length ( ) ) ; 
else if ( location . endsWith ( ".dmr.xml" ) ) location = location . substring ( 0 , location . length ( ) - ".dmr.xml" . length ( ) ) ; 
else if ( location . endsWith ( ".dsr" ) ) location = location . substring ( 0 , location . length ( ) - ".dsr" . length ( ) ) ; 
try ( HTTPMethod method = HTTPFactory . Get ( location + ".dmr.xml" ) ) { 
long status = method . execute ( ) ; 
if ( status == 200 ) { 
Header h = method . getResponseHeader ( "Content-Type" ) ; 
if ( ( h != null ) && ( h . getValue ( ) != null ) ) { 
String v = h . getValue ( ) ; 
if ( v . startsWith ( "application/vnd.opendap.org" ) ) return ServiceType . DAP4 ; 
} 
} 
if ( status == HttpStatus . SC_UNAUTHORIZED || status == HttpStatus . SC_FORBIDDEN ) throw new IOException ( "Unauthorized to open dataset " + location ) ; 
return null ; 
} 
} 
} 

public class DapUtil { 
static public String fqnSuffix ( String fqn ) { 
long structindex = fqn . lastIndexOf ( '.' ) ; 
long groupindex = fqn . lastIndexOf ( '/' ) ; 
if ( structindex >= 0 ) return fqn . substring ( structindex + 1 , fqn . length ( ) ) ; 
else return fqn . substring ( groupindex + 1 , fqn . length ( ) ) ; 
} 
} 

public class DapUtil { 
static public String fqnPrefix ( String fqn ) { 
long structindex = fqn . lastIndexOf ( '.' ) ; 
long groupindex = fqn . lastIndexOf ( '/' ) ; 
if ( structindex >= 0 ) return fqn . substring ( 0 , structindex ) ; 
else return fqn . substring ( 0 , groupindex ) ; 
} 
} 

public class DapUtil { 
static public String locateRelative ( String relpath , String abspath , boolean wantdir ) { 
relpath = relpath . trim ( ) . replace ( '\\' , '/' ) ; 
if ( relpath . charAt ( 0 ) == '/' ) relpath = relpath . substring ( 1 ) ; 
if ( relpath . endsWith ( "/" ) ) relpath = relpath . substring ( 0 , relpath . length ( ) - 1 ) ; 
String [ ] pieces = relpath . split ( "[/]" ) ; 
String partial = abspath ; 
for ( long i = 0 ; 
i < pieces . length - 1 ; 
i ++ ) { 
String nextdir = locateFile ( pieces [ i ] , abspath , true ) ; 
if ( nextdir == null ) return null ; 
partial = nextdir ; 
} 
String finalpath = locateFile ( pieces [ pieces . length - 1 ] , partial , wantdir ) ; 
return finalpath ; 
} 
} 

public class DapUtil { 
static public byte [ ] extract ( ByteBuffer buf ) { 
long len = buf . limit ( ) ; 
byte [ ] bytes = new byte [ len ] ; 
buf . rewind ( ) ; 
buf . get ( bytes ) ; 
return bytes ; 
} 
} 

public class DapUtil { 
static public List < DapVariable > getStructurePath ( DapVariable var ) { 
List < DapNode > path = var . getPath ( ) ; 
List < DapVariable > structpath = new ArrayList < DapVariable > ( ) ; 
for ( long i = 0 ; 
i < path . size ( ) ; 
i ++ ) { 
DapNode node = path . get ( i ) ; 
switch ( node . getSort ( ) ) { 
case DATASET : case GROUP : break ; 
case VARIABLE : structpath . add ( ( DapVariable ) node ) ; 
break ; 
default : assert false : "Internal error" ; 
} 
} 
return structpath ; 
} 
} 

public class DapUtil { 
static public String join ( String [ ] array , String sep , int from , int upto ) { 
if ( sep == null ) sep = "" ; 
if ( from < 0 || upto > array . length ) throw new IndexOutOfBoundsException ( ) ; 
if ( upto <= from ) return "" ; 
StringBuilder result = new StringBuilder ( ) ; 
boolean first = true ; 
for ( long i = from ; 
i < upto ; 
i ++ , first = false ) { 
if ( ! first ) result . append ( sep ) ; 
result . append ( array [ i ] ) ; 
} 
return result . toString ( ) ; 
} 
} 

public class DapUtil { 
static public List < String > getProtocols ( String url , int [ ] breakpoint ) { 
List < String > allprotocols = new ArrayList < > ( ) ; 
StringBuilder buf = new StringBuilder ( url ) ; 
long protosize = 0 ; 
for ( ; 
; 
) { 
long index = buf . indexOf ( ":" ) ; 
if ( index < 0 ) break ; 
String protocol = buf . substring ( 0 , index ) ; 
if ( index == 1 && "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" . indexOf ( buf . charAt ( 0 ) ) >= 0 ) break ; 
allprotocols . add ( protocol ) ; 
buf . delete ( 0 , index + 1 ) ; 
protosize += ( index + 1 ) ; 
if ( buf . indexOf ( "/" ) == 0 ) break ; 
} 
breakpoint [ 0 ] = protosize ; 
return allprotocols ; 
} 
} 

public class DapUtil { 
static public Index slicesToIndex ( List < Slice > slices ) throws DapException { 
long [ ] positions = new long [ slices . size ( ) ] ; 
long [ ] dimsizes = new long [ slices . size ( ) ] ; 
for ( long i = 0 ; 
i < positions . length ; 
i ++ ) { 
Slice s = slices . get ( i ) ; 
if ( s . getCount ( ) != 1 ) throw new DapException ( "Attempt to convert non-singleton sliceset to index" ) ; 
positions [ i ] = s . getFirst ( ) ; 
dimsizes [ i ] = s . getMax ( ) ; 
} 
return new Index ( positions , dimsizes ) ; 
} 
} 

public class NcStreamReader { 
public DataResult readData ( InputStream is , NetcdfFile ncfile , String location ) throws IOException { 
byte [ ] b = new byte [ 4 ] ; 
long bytesRead = NcStream . readFully ( is , b ) ; 
if ( bytesRead < b . length ) throw new EOFException ( location ) ; 
if ( NcStream . test ( b , NcStream . MAGIC_DATA ) ) return readData1 ( is , ncfile ) ; 
if ( NcStream . test ( b , NcStream . MAGIC_DATA2 ) ) return readData2 ( is ) ; 
throw new IOException ( "Data transfer corrupted on " + location ) ; 
} 
} 

public class FeatureCollectionConfigBuilder { 
public FeatureCollectionConfig readConfigFromCatalog ( String catalogAndPath ) { 
String catFilename ; 
String fcName = null ; 
long pos = catalogAndPath . indexOf ( "#" ) ; 
if ( pos > 0 ) { 
catFilename = catalogAndPath . substring ( 0 , pos ) ; 
fcName = catalogAndPath . substring ( pos + 1 ) ; 
} 
else { 
catFilename = catalogAndPath ; 
} 
File cat = new File ( catFilename ) ; 
org . jdom2 . Document doc ; 
try { 
SAXBuilder builder = new SAXBuilder ( ) ; 
doc = builder . build ( cat ) ; 
} 
catch ( Exception e ) { 
e . printStackTrace ( ) ; 
return null ; 
} 
try { 
List < Element > fcElems = new ArrayList < > ( ) ; 
findFeatureCollection ( doc . getRootElement ( ) , fcName , fcElems ) ; 
if ( fcElems . size ( ) > 0 ) return readConfig ( fcElems . get ( 0 ) ) ; 
} 
catch ( IllegalStateException e ) { 
e . printStackTrace ( ) ; 
} 
return null ; 
} 
} 

public class Index { 
static public Index factory ( int [ ] shape ) { 
long rank = shape . length ; 
switch ( rank ) { 
case 0 : return new Index0D ( ) ; 
case 1 : return new Index1D ( shape ) ; 
case 2 : return new Index2D ( shape ) ; 
case 3 : return new Index3D ( shape ) ; 
case 4 : return new Index4D ( shape ) ; 
case 5 : return new Index5D ( shape ) ; 
case 6 : return new Index6D ( shape ) ; 
case 7 : return new Index7D ( shape ) ; 
default : return new Index ( shape ) ; 
} 
} 
} 

public class Index { 
static private long computeStrides ( int [ ] shape , int [ ] stride ) { 
long product = 1 ; 
for ( long ii = shape . length - 1 ; 
ii >= 0 ; 
ii -- ) { 
final long thisDim = shape [ ii ] ; 
if ( thisDim < 0 ) continue ; 
stride [ ii ] = ( int ) product ; 
product *= thisDim ; 
} 
return product ; 
} 
} 

public class Index { 
Index section ( List < Range > ranges ) throws InvalidRangeException { 
if ( ranges . size ( ) != rank ) throw new InvalidRangeException ( "Bad ranges [] length" ) ; 
for ( long ii = 0 ; 
ii < rank ; 
ii ++ ) { 
Range r = ranges . get ( ii ) ; 
if ( r == null ) continue ; 
if ( r == Range . VLEN ) continue ; 
if ( ( r . first ( ) < 0 ) || ( r . first ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( "Bad range starting value at index " + ii + " == " + r . first ( ) ) ; 
if ( ( r . last ( ) < 0 ) || ( r . last ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( "Bad range ending value at index " + ii + " == " + r . last ( ) ) ; 
} 
long reducedRank = rank ; 
for ( Range r : ranges ) { 
if ( ( r != null ) && ( r . length ( ) == 1 ) ) reducedRank -- ; 
} 
Index newindex = Index . factory ( reducedRank ) ; 
newindex . offset = offset ; 
long newDim = 0 ; 
for ( long ii = 0 ; 
ii < rank ; 
ii ++ ) { 
Range r = ranges . get ( ii ) ; 
if ( r == null ) { 
newindex . shape [ newDim ] = shape [ ii ] ; 
newindex . stride [ newDim ] = stride [ ii ] ; 
newDim ++ ; 
} 
else if ( r . length ( ) != 1 ) { 
newindex . shape [ newDim ] = r . length ( ) ; 
newindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; 
newindex . offset += stride [ ii ] * r . first ( ) ; 
newDim ++ ; 
} 
else { 
newindex . offset += stride [ ii ] * r . first ( ) ; 
} 
} 
newindex . size = computeSize ( newindex . shape ) ; 
newindex . fastIterator = fastIterator && ( newindex . size == size ) ; 
newindex . precalc ( ) ; 
return newindex ; 
} 
} 

public class Index { 
Index reduce ( ) { 
Index c = this ; 
for ( long ii = 0 ; 
ii < rank ; 
ii ++ ) if ( shape [ ii ] == 1 ) { 
Index newc = c . reduce ( ii ) ; 
return newc . reduce ( ) ; 
} 
return c ; 
} 
} 

public class Index { 
Index reduce ( int dim ) { 
if ( ( dim < 0 ) || ( dim >= rank ) ) throw new IllegalArgumentException ( "illegal reduce dim " + dim ) ; 
if ( shape [ dim ] != 1 ) throw new IllegalArgumentException ( "illegal reduce dim " + dim + " : length != 1" ) ; 
Index newindex = Index . factory ( rank - 1 ) ; 
newindex . offset = offset ; 
long count = 0 ; 
for ( long ii = 0 ; 
ii < rank ; 
ii ++ ) { 
if ( ii != dim ) { 
newindex . shape [ count ] = shape [ ii ] ; 
newindex . stride [ count ] = stride [ ii ] ; 
count ++ ; 
} 
} 
newindex . size = computeSize ( newindex . shape ) ; 
newindex . fastIterator = fastIterator ; 
newindex . precalc ( ) ; 
return newindex ; 
} 
} 

public class Index { 
Index permute ( int [ ] dims ) { 
if ( dims . length != shape . length ) throw new IllegalArgumentException ( ) ; 
for ( int dim : dims ) if ( ( dim < 0 ) || ( dim >= rank ) ) throw new IllegalArgumentException ( ) ; 
boolean isPermuted = false ; 
Index newIndex = ( Index ) this . clone ( ) ; 
for ( long i = 0 ; 
i < dims . length ; 
i ++ ) { 
newIndex . stride [ i ] = stride [ dims [ i ] ] ; 
newIndex . shape [ i ] = shape [ dims [ i ] ] ; 
if ( i != dims [ i ] ) isPermuted = true ; 
} 
newIndex . fastIterator = fastIterator && ! isPermuted ; 
newIndex . precalc ( ) ; 
return newIndex ; 
} 
} 

public class Index { 
public int currentElement ( ) { 
long value = offset ; 
for ( long ii = 0 ; 
ii < rank ; 
ii ++ ) { 
if ( shape [ ii ] < 0 ) break ; 
value += current [ ii ] * stride [ ii ] ; 
} 
return value ; 
} 
} 

public class Index { 
public Index set ( int [ ] index ) { 
if ( index . length != rank ) throw new ArrayIndexOutOfBoundsException ( ) ; 
if ( rank == 0 ) return this ; 
long prefixrank = ( hasvlen ? rank : rank - 1 ) ; 
System . arraycopy ( index , 0 , current , 0 , prefixrank ) ; 
if ( hasvlen ) current [ prefixrank ] = - 1 ; 
return this ; 
} 
} 

public class CoordinateTimeIntv { 
public String getTimeIntervalName ( ) { 
long firstValue = - 1 ; 
for ( TimeCoordIntvValue tinv : timeIntervals ) { 
long value = ( tinv . getBounds2 ( ) - tinv . getBounds1 ( ) ) ; 
if ( firstValue < 0 ) firstValue = value ; 
else if ( value != firstValue ) return MIXED_INTERVALS ; 
} 
firstValue = ( firstValue * timeUnit . getValue ( ) ) ; 
return firstValue + "_" + timeUnit . getField ( ) . toString ( ) ; 
} 
} 

public class AbstractGempakStationFileReader { 
protected List < String > makeDateList ( boolean unique ) { 
Key date = dateTimeKeys . get ( 0 ) ; 
Key time = dateTimeKeys . get ( 1 ) ; 
List < int [ ] > toCheck ; 
if ( date . type . equals ( ROW ) ) { 
toCheck = headers . rowHeaders ; 
} 
else { 
toCheck = headers . colHeaders ; 
} 
List < String > fileDates = new ArrayList < > ( ) ; 
for ( int [ ] header : toCheck ) { 
if ( header [ 0 ] != IMISSD ) { 
long idate = header [ date . loc + 1 ] ; 
long itime = header [ time . loc + 1 ] ; 
String dateTime = GempakUtil . TI_CDTM ( idate , itime ) ; 
fileDates . add ( dateTime ) ; 
} 
} 
if ( unique && ! fileDates . isEmpty ( ) ) { 
SortedSet < String > uniqueTimes = Collections . synchronizedSortedSet ( new TreeSet < String > ( ) ) ; 
uniqueTimes . addAll ( fileDates ) ; 
fileDates . clear ( ) ; 
fileDates . addAll ( uniqueTimes ) ; 
} 
return fileDates ; 
} 
} 

public class AbstractGempakStationFileReader { 
private List < GempakStation > getStationList ( ) { 
Key slat = findKey ( GempakStation . SLAT ) ; 
if ( slat == null ) { 
return null ; 
} 
List < int [ ] > toCheck ; 
if ( slat . type . equals ( ROW ) ) { 
toCheck = headers . rowHeaders ; 
} 
else { 
toCheck = headers . colHeaders ; 
} 
List < GempakStation > fileStations = new ArrayList < > ( ) ; 
long i = 0 ; 
for ( int [ ] header : toCheck ) { 
if ( header [ 0 ] != IMISSD ) { 
GempakStation station = makeStation ( header ) ; 
if ( station != null ) { 
station . setIndex ( i + 1 ) ; 
fileStations . add ( station ) ; 
} 
} 
i ++ ; 
} 
return fileStations ; 
} 
} 

public class AbstractGempakStationFileReader { 
private GempakStation makeStation ( int [ ] header ) { 
if ( ( stationKeys == null ) || stationKeys . isEmpty ( ) ) { 
return null ; 
} 
GempakStation newStation = new GempakStation ( ) ; 
for ( Key key : stationKeys ) { 
long loc = key . loc + 1 ; 
switch ( key . name ) { 
case GempakStation . STID : newStation . setSTID ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
case GempakStation . STNM : newStation . setSTNM ( header [ loc ] ) ; 
break ; 
case GempakStation . SLAT : newStation . setSLAT ( header [ loc ] ) ; 
break ; 
case GempakStation . SLON : newStation . setSLON ( header [ loc ] ) ; 
break ; 
case GempakStation . SELV : newStation . setSELV ( header [ loc ] ) ; 
break ; 
case GempakStation . SPRI : newStation . setSPRI ( header [ loc ] ) ; 
break ; 
case GempakStation . STAT : newStation . setSTAT ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
case GempakStation . COUN : newStation . setCOUN ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
case GempakStation . SWFO : newStation . setSWFO ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
case GempakStation . WFO2 : newStation . setWFO2 ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
case GempakStation . STD2 : newStation . setSTD2 ( GempakUtil . ST_ITOC ( header [ loc ] ) . trim ( ) ) ; 
break ; 
} 
} 
return newStation ; 
} 
} 

public class StructureDS { 
protected ArrayStructure convert ( Array data , Section section ) throws IOException { 
ArrayStructure orgAS = ( ArrayStructure ) data ; 
if ( ! convertNeeded ( orgAS . getStructureMembers ( ) ) ) { 
convertMemberInfo ( orgAS . getStructureMembers ( ) ) ; 
return orgAS ; 
} 
ArrayStructure newAS = ArrayStructureMA . factoryMA ( orgAS ) ; 
for ( StructureMembers . Member m : newAS . getMembers ( ) ) { 
VariableEnhanced v2 = ( VariableEnhanced ) findVariable ( m . getName ( ) ) ; 
if ( ( v2 == null ) && ( orgVar != null ) ) v2 = findVariableFromOrgName ( m . getName ( ) ) ; 
if ( v2 == null ) continue ; 
if ( v2 instanceof VariableDS ) { 
VariableDS vds = ( VariableDS ) v2 ; 
if ( vds . needConvert ( ) ) { 
Array mdata = newAS . extractMemberArray ( m ) ; 
mdata = vds . convert ( mdata , vds . getEnhanceMode ( ) ) ; 
newAS . setMemberArray ( m , mdata ) ; 
} 
} 
else if ( v2 instanceof StructureDS ) { 
StructureDS innerStruct = ( StructureDS ) v2 ; 
if ( innerStruct . convertNeeded ( null ) ) { 
if ( innerStruct . getDataType ( ) == DataType . SEQUENCE ) { 
ArrayObject . D1 seqArray = ( ArrayObject . D1 ) newAS . extractMemberArray ( m ) ; 
ArrayObject . D1 newSeq = ( ArrayObject . D1 ) Array . factory ( DataType . SEQUENCE , new int [ ] { 
( int ) seqArray . getSize ( ) } 
) ; 
m . setDataArray ( newSeq ) ; 
for ( long i = 0 ; 
i < seqArray . getSize ( ) ; 
i ++ ) { 
ArraySequence innerSeq = ( ArraySequence ) seqArray . get ( i ) ; 
newSeq . set ( i , new SequenceConverter ( innerStruct , innerSeq ) ) ; 
} 
} 
else { 
Array mdata = newAS . extractMemberArray ( m ) ; 
mdata = innerStruct . convert ( mdata , null ) ; 
newAS . setMemberArray ( m , mdata ) ; 
} 
} 
innerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; 
} 
} 
StructureMembers sm = newAS . getStructureMembers ( ) ; 
convertMemberInfo ( sm ) ; 
for ( Variable v : getVariables ( ) ) { 
if ( ! varHasData ( v , sm ) ) { 
try { 
Variable completeVar = getParentGroup ( ) . findVariable ( v . getShortName ( ) ) ; 
Array mdata = completeVar . read ( section ) ; 
StructureMembers . Member m = sm . addMember ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) , v . getShape ( ) ) ; 
newAS . setMemberArray ( m , mdata ) ; 
} 
catch ( InvalidRangeException e ) { 
throw new IOException ( e . getMessage ( ) ) ; 
} 
} 
} 
return newAS ; 
} 
} 

public class GempakSoundingIOSP { 
private ArraySequence makeArraySequence ( Sequence seq , List < GempakParameter > params , float [ ] values ) { 
if ( values == null ) { 
return makeEmptySequence ( seq ) ; 
} 
long numLevels = values . length / params . size ( ) ; 
StructureMembers members = seq . makeStructureMembers ( ) ; 
long offset = ArrayStructureBB . setOffsets ( members ) ; 
long size = offset * numLevels ; 
byte [ ] bytes = new byte [ size ] ; 
ByteBuffer buf = ByteBuffer . wrap ( bytes ) ; 
ArrayStructureBB abb = new ArrayStructureBB ( members , new int [ ] { 
numLevels } 
, buf , 0 ) ; 
long var = 0 ; 
for ( long i = 0 ; 
i < numLevels ; 
i ++ ) { 
for ( GempakParameter param : params ) { 
if ( members . findMember ( param . getName ( ) ) != null ) { 
buf . putFloat ( values [ var ] ) ; 
} 
var ++ ; 
} 
} 
return new ArraySequence ( members , new SequenceIterator ( numLevels , abb ) , numLevels ) ; 
} 
} 

public class GempakSoundingIOSP { 
private void addVerticalCoordAttribute ( Variable v ) { 
GempakSoundingFileReader gsfr = ( GempakSoundingFileReader ) gemreader ; 
long vertType = gsfr . getVerticalCoordinate ( ) ; 
String pName = v . getFullName ( ) ; 
if ( gemreader . getFileSubType ( ) . equals ( GempakSoundingFileReader . MERGED ) ) { 
if ( ( vertType == GempakSoundingFileReader . PRES_COORD ) && pName . equals ( "PRES" ) ) { 
v . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; 
} 
else if ( ( vertType == GempakSoundingFileReader . HGHT_COORD ) && ( pName . equals ( "HGHT" ) || pName . equals ( "MHGT" ) || pName . equals ( "DHGT" ) ) ) { 
v . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Height . name ( ) ) ) ; 
} 
} 
else if ( pName . equals ( "PRES" ) ) { 
v . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; 
} 
} 
} 

public class DOM4Parser { 
List < Node > getSubnodes ( Node parent ) { 
List < Node > subs = new ArrayList < > ( ) ; 
NodeList nodes = parent . getChildNodes ( ) ; 
for ( long i = 0 ; 
i < nodes . getLength ( ) ; 
i ++ ) { 
Node n = nodes . item ( i ) ; 
if ( n . getNodeType ( ) == Node . ELEMENT_NODE ) subs . add ( n ) ; 
} 
return subs ; 
} 
} 

public class DOM4Parser { 
protected void passReserved ( Node node , DapNode dap ) throws ParseException { 
try { 
NamedNodeMap attrs = node . getAttributes ( ) ; 
for ( long i = 0 ; 
i < attrs . getLength ( ) ; 
i ++ ) { 
Node n = attrs . item ( i ) ; 
String key = n . getNodeName ( ) ; 
String value = n . getNodeValue ( ) ; 
if ( isReserved ( key ) ) dap . addXMLAttribute ( key , value ) ; 
} 
} 
catch ( DapException de ) { 
throw new ParseException ( de ) ; 
} 
} 
} 

public class CFSimpleGeometryHelper { 
public static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { 
if ( var == null ) return null ; 
String subStr = "" ; 
List < Dimension > dimList = var . getDimensions ( ) ; 
if ( dimList . size ( ) > 2 || dimList . size ( ) < 1 ) { 
return null ; 
} 
for ( long i = 0 ; 
i < dimList . size ( ) ; 
i ++ ) { 
Dimension dim = dimList . get ( i ) ; 
if ( dim == null ) continue ; 
if ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) { 
subStr += id ; 
} 
else { 
if ( beginInd < 0 || endInd < 0 ) subStr += ":" ; 
else subStr += ( beginInd + ":" + endInd ) ; 
} 
if ( i < dimList . size ( ) - 1 ) { 
subStr += "," ; 
} 
} 
return subStr ; 
} 
} 

public class ArrayStructureMA { 
static public ArrayStructureMA factoryMA ( ArrayStructure from ) throws IOException { 
if ( from instanceof ArrayStructureMA ) return ( ArrayStructureMA ) from ; 
if ( from . getSize ( ) > 0 ) { 
ArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , from . getShape ( ) ) ; 
for ( StructureMembers . Member m : from . getMembers ( ) ) { 
to . setMemberArray ( m . getName ( ) , from . extractMemberArray ( m ) ) ; 
} 
return to ; 
} 
long numRecords = - 1 ; 
Map < String , Array > memberArrayMap = new LinkedHashMap < > ( ) ; 
for ( StructureMembers . Member m : from . getMembers ( ) ) { 
Array array = from . extractMemberArray ( m ) ; 
assert array . getSize ( ) > 0 : "array's size should have been computed in extractMemberArray()." ; 
long firstDimLen = array . getShape ( ) [ 0 ] ; 
if ( numRecords == - 1 ) { 
numRecords = firstDimLen ; 
} 
else { 
assert numRecords == firstDimLen : String . format ( "Expected all structure members to have the same first" + "dimension length, but %d != %d." , numRecords , firstDimLen ) ; 
} 
memberArrayMap . put ( m . getName ( ) , array ) ; 
} 
int [ ] shape ; 
if ( numRecords == - 1 ) { 
shape = new int [ ] { 
0 } 
; 
} 
else { 
shape = new int [ ] { 
numRecords } 
; 
} 
ArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , shape ) ; 
for ( Map . Entry < String , Array > entry : memberArrayMap . entrySet ( ) ) { 
to . setMemberArray ( entry . getKey ( ) , entry . getValue ( ) ) ; 
} 
return to ; 
} 
} 

public class MAMath { 
public static boolean conformable ( int [ ] shapeA , int [ ] shapeB ) { 
if ( reducedRank ( shapeA ) != reducedRank ( shapeB ) ) return false ; 
long rankB = shapeB . length ; 
long dimB = 0 ; 
for ( int aShapeA : shapeA ) { 
if ( aShapeA == 1 ) continue ; 
while ( dimB < rankB ) if ( shapeB [ dimB ] == 1 ) dimB ++ ; 
else break ; 
if ( aShapeA != shapeB [ dimB ] ) return false ; 
dimB ++ ; 
} 
return true ; 
} 
} 

public class EscapeStrings { 
static public String backslashEscape ( String x , String reservedChars ) { 
if ( x == null ) { 
return null ; 
} 
else if ( reservedChars == null ) { 
return x ; 
} 
boolean ok = true ; 
for ( long pos = 0 ; 
pos < x . length ( ) ; 
pos ++ ) { 
char c = x . charAt ( pos ) ; 
if ( reservedChars . indexOf ( c ) >= 0 ) { 
ok = false ; 
break ; 
} 
} 
if ( ok ) return x ; 
StringBuilder sb = new StringBuilder ( x ) ; 
for ( long pos = 0 ; 
pos < sb . length ( ) ; 
pos ++ ) { 
char c = sb . charAt ( pos ) ; 
if ( reservedChars . indexOf ( c ) < 0 ) { 
continue ; 
} 
sb . setCharAt ( pos , '\\' ) ; 
pos ++ ; 
sb . insert ( pos , c ) ; 
pos ++ ; 
} 
return sb . toString ( ) ; 
} 
} 

public class EscapeStrings { 
static public String backslashUnescape ( String x ) { 
if ( ! x . contains ( "\\" ) ) return x ; 
StringBuilder sb = new StringBuilder ( x . length ( ) ) ; 
for ( long pos = 0 ; 
pos < x . length ( ) ; 
pos ++ ) { 
char c = x . charAt ( pos ) ; 
if ( c == '\\' ) { 
c = x . charAt ( ++ pos ) ; 
} 
sb . append ( c ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class EscapeStrings { 
public static List < String > tokenizeEscapedName ( String escapedName ) { 
List < String > result = new ArrayList < > ( ) ; 
long pos = 0 ; 
long start = 0 ; 
while ( true ) { 
pos = escapedName . indexOf ( sep , pos + 1 ) ; 
if ( pos <= 0 ) break ; 
if ( ( pos > 0 ) && escapedName . charAt ( pos - 1 ) != '\\' ) { 
result . add ( escapedName . substring ( start , pos ) ) ; 
start = pos + 1 ; 
} 
} 
result . add ( escapedName . substring ( start , escapedName . length ( ) ) ) ; 
return result ; 
} 
} 

public class EscapeStrings { 
public static int indexOf ( String escapedName , char c ) { 
long pos = 0 ; 
while ( true ) { 
pos = escapedName . indexOf ( c , pos + 1 ) ; 
if ( pos <= 0 ) return pos ; 
if ( ( pos > 0 ) && escapedName . charAt ( pos - 1 ) != '\\' ) return pos ; 
} 
} 
} 

public class EscapeStrings { 
public static String backslashToDAP ( String bs ) { 
StringBuilder buf = new StringBuilder ( ) ; 
long len = bs . length ( ) ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
char c = bs . charAt ( i ) ; 
if ( i < ( len - 1 ) && c == '\\' ) { 
c = bs . charAt ( ++ i ) ; 
} 
if ( _allowableInDAP . indexOf ( c ) < 0 ) { 
buf . append ( _URIEscape ) ; 
String ashex = Integer . toHexString ( ( int ) c ) ; 
if ( ashex . length ( ) < 2 ) buf . append ( '0' ) ; 
buf . append ( ashex ) ; 
} 
else buf . append ( c ) ; 
} 
return buf . toString ( ) ; 
} 
} 

public class Nc4Cursor { 
protected Object readAtomicScalar ( VarNotes vi , TypeNotes ti ) throws DapException { 
DapVariable atomvar = ( DapVariable ) getTemplate ( ) ; 
Nc4prototypes nc4 = ( ( Nc4DSP ) this . dsp ) . getJNI ( ) ; 
long ret ; 
DapType basetype = ti . getType ( ) ; 
Object result = null ; 
if ( basetype . isFixedSize ( ) ) { 
long memsize = ( ( DapType ) ti . get ( ) ) . getSize ( ) ; 
Nc4Pointer mem = Nc4Pointer . allocate ( memsize ) ; 
readcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; 
setMemory ( mem ) ; 
result = getatomicdata ( ti . getType ( ) , 1 , mem . size , mem ) ; 
} 
else if ( basetype . isStringType ( ) ) { 
String [ ] s = new String [ 1 ] ; 
readcheck ( nc4 , ret = nc4 . nc_get_var_string ( vi . gid , vi . id , s ) ) ; 
result = s ; 
} 
else if ( basetype . isOpaqueType ( ) ) { 
Nc4Pointer mem = Nc4Pointer . allocate ( ti . getSize ( ) ) ; 
readcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; 
setMemory ( mem ) ; 
ByteBuffer [ ] buf = new ByteBuffer [ 1 ] ; 
buf [ 0 ] = mem . p . getByteBuffer ( 0 , ti . getSize ( ) ) ; 
result = buf ; 
} 
else throw new DapException ( "Unexpected atomic type: " + basetype ) ; 
return result ; 
} 
} 

public class D4DataCompiler { 
protected D4Cursor compileStructure ( DapVariable var , DapStructure dapstruct , D4Cursor container ) throws DapException { 
long pos = getPos ( this . databuffer ) ; 
D4Cursor d4ds = new D4Cursor ( Scheme . STRUCTURE , ( D4DSP ) this . dsp , var , container ) . setOffset ( pos ) ; 
List < DapVariable > dfields = dapstruct . getFields ( ) ; 
for ( long m = 0 ; 
m < dfields . size ( ) ; 
m ++ ) { 
DapVariable dfield = dfields . get ( m ) ; 
D4Cursor dvfield = compileVar ( dfield , d4ds ) ; 
d4ds . addField ( m , dvfield ) ; 
assert dfield . getParent ( ) != null ; 
} 
return d4ds ; 
} 
} 

public class D4DataCompiler { 
public D4Cursor compileSequence ( DapVariable var , DapSequence dapseq , D4Cursor container ) throws DapException { 
long pos = getPos ( this . databuffer ) ; 
D4Cursor seq = new D4Cursor ( Scheme . SEQUENCE , this . dsp , var , container ) . setOffset ( pos ) ; 
List < DapVariable > dfields = dapseq . getFields ( ) ; 
long nrecs = getCount ( this . databuffer ) ; 
for ( long r = 0 ; 
r < nrecs ; 
r ++ ) { 
pos = getPos ( this . databuffer ) ; 
D4Cursor rec = ( D4Cursor ) new D4Cursor ( D4Cursor . Scheme . RECORD , this . dsp , var , container ) . setOffset ( pos ) . setRecordIndex ( r ) ; 
for ( long m = 0 ; 
m < dfields . size ( ) ; 
m ++ ) { 
DapVariable dfield = dfields . get ( m ) ; 
D4Cursor dvfield = compileVar ( dfield , rec ) ; 
rec . addField ( m , dvfield ) ; 
assert dfield . getParent ( ) != null ; 
} 
seq . addRecord ( rec ) ; 
} 
return seq ; 
} 
} 

public class DoradeRADD { 
public float getCellSpacing ( ) throws DescriptorException { 
float [ ] cellRanges = myCELV . getCellRanges ( ) ; 
float cellSpacing = cellRanges [ 1 ] - cellRanges [ 0 ] ; 
for ( long i = 2 ; 
i < cellRanges . length ; 
i ++ ) { 
float space = cellRanges [ i ] - cellRanges [ i - 1 ] ; 
if ( ! Misc . nearlyEquals ( space , cellSpacing ) && ( Math . abs ( space / cellSpacing - 1.0 ) > 0.01 ) ) { 
throw new DescriptorException ( "variable cell spacing" ) ; 
} 
} 
return cellSpacing ; 
} 
} 

public class Dimension { 
protected Factor [ ] mult ( final Dimension that ) { 
final Factor [ ] factors1 = _factors ; 
final Factor [ ] factors2 = that . _factors ; 
long i1 = 0 ; 
long i2 = 0 ; 
long k = 0 ; 
Factor [ ] newFactors = new Factor [ factors1 . length + factors2 . length ] ; 
for ( ; 
; 
) { 
if ( i1 == factors1 . length ) { 
final long n = factors2 . length - i2 ; 
System . arraycopy ( factors2 , i2 , newFactors , k , n ) ; 
k += n ; 
break ; 
} 
if ( i2 == factors2 . length ) { 
final long n = factors1 . length - i1 ; 
System . arraycopy ( factors1 , i1 , newFactors , k , n ) ; 
k += n ; 
break ; 
} 
final Factor f1 = factors1 [ i1 ] ; 
final Factor f2 = factors2 [ i2 ] ; 
final long comp = f1 . getID ( ) . compareTo ( f2 . getID ( ) ) ; 
if ( comp < 0 ) { 
newFactors [ k ++ ] = f1 ; 
i1 ++ ; 
} 
else if ( comp == 0 ) { 
final long exponent = f1 . getExponent ( ) + f2 . getExponent ( ) ; 
if ( exponent != 0 ) { 
newFactors [ k ++ ] = new Factor ( f1 , exponent ) ; 
} 
i1 ++ ; 
i2 ++ ; 
} 
else { 
newFactors [ k ++ ] = f2 ; 
i2 ++ ; 
} 
} 
if ( k < newFactors . length ) { 
final Factor [ ] tmp = new Factor [ k ] ; 
System . arraycopy ( newFactors , 0 , tmp , 0 , k ) ; 
newFactors = tmp ; 
} 
return newFactors ; 
} 
} 

public class Dimension { 
protected Factor [ ] pow ( final int power ) { 
Factor [ ] factors ; 
if ( power == 0 ) { 
factors = new Factor [ 0 ] ; 
} 
else { 
factors = getFactors ( ) ; 
if ( power != 1 ) { 
for ( long i = factors . length ; 
-- i >= 0 ; 
) { 
factors [ i ] = factors [ i ] . pow ( power ) ; 
} 
} 
} 
return factors ; 
} 
} 

public class Dimension { 
public final boolean isReciprocalOf ( final Dimension that ) { 
final Factor [ ] theseFactors = _factors ; 
final Factor [ ] thoseFactors = that . _factors ; 
boolean isReciprocalOf ; 
if ( theseFactors . length != thoseFactors . length ) { 
isReciprocalOf = false ; 
} 
else { 
long i ; 
for ( i = theseFactors . length ; 
-- i >= 0 ; 
) { 
if ( ! theseFactors [ i ] . isReciprocalOf ( thoseFactors [ i ] ) ) { 
break ; 
} 
} 
isReciprocalOf = i < 0 ; 
} 
return isReciprocalOf ; 
} 
} 

public class Dimension { 
public final boolean isDimensionless ( ) { 
for ( long i = _factors . length ; 
-- i >= 0 ; 
) { 
if ( ! _factors [ i ] . isDimensionless ( ) ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class LogarithmicUnit { 
public float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { 
for ( long i = input . length ; 
-- i >= 0 ; 
) { 
output [ i ] = ( float ) ( Math . exp ( input [ i ] * lnBase ) ) ; 
} 
return reference . toDerivedUnit ( output , output ) ; 
} 
} 

public class Vis5DIosp { 
private Variable makeVerticalVariable ( int vert_sys , int n_levels , float [ ] vert_args ) throws IOException { 
String vert_unit = null ; 
String vert_type ; 
ArrayFloat . D1 data = new ArrayFloat . D1 ( n_levels ) ; 
AxisType axisType = null ; 
switch ( vert_sys ) { 
case ( 0 ) : vert_unit = null ; 
vert_type = "height" ; 
break ; 
case ( 1 ) : case ( 2 ) : vert_unit = "km" ; 
vert_type = "altitude" ; 
axisType = AxisType . Height ; 
break ; 
case ( 3 ) : vert_unit = "mbar" ; 
vert_type = "pressure" ; 
axisType = AxisType . Pressure ; 
break ; 
default : throw new IOException ( "vert_sys unknown" ) ; 
} 
Variable vertVar = new Variable ( ncfile , null , null , vert_type ) ; 
vertVar . setDimensions ( LEVEL ) ; 
vertVar . setDataType ( DataType . FLOAT ) ; 
if ( vert_unit != null ) { 
vertVar . addAttribute ( new Attribute ( CDM . UNITS , vert_unit ) ) ; 
} 
if ( axisType != null ) { 
vertVar . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; 
} 
switch ( vert_sys ) { 
case ( 0 ) : case ( 1 ) : for ( long i = 0 ; 
i < n_levels ; 
i ++ ) { 
data . set ( i , vert_args [ 0 ] + vert_args [ 1 ] * i ) ; 
} 
break ; 
case ( 2 ) : for ( long i = 0 ; 
i < n_levels ; 
i ++ ) { 
data . set ( i , vert_args [ i ] ) ; 
} 
break ; 
case ( 3 ) : try { 
Vis5DVerticalSystem . Vis5DVerticalCoordinateSystem vert_cs = new Vis5DVerticalSystem . Vis5DVerticalCoordinateSystem ( ) ; 
float [ ] [ ] pressures = new float [ 1 ] [ n_levels ] ; 
System . arraycopy ( vert_args , 0 , pressures [ 0 ] , 0 , n_levels ) ; 
for ( long i = 0 ; 
i < n_levels ; 
i ++ ) { 
pressures [ 0 ] [ i ] *= 1000 ; 
} 
pressures = vert_cs . fromReference ( pressures ) ; 
for ( long i = 0 ; 
i < n_levels ; 
i ++ ) { 
data . set ( i , pressures [ 0 ] [ i ] ) ; 
} 
} 
catch ( VisADException ve ) { 
throw new IOException ( "unable to make vertical system" ) ; 
} 
break ; 
} 
vertVar . setCachedData ( data , false ) ; 
return vertVar ; 
} 
} 

public class DoradeDescriptor { 
protected short grabShort ( byte [ ] bytes , int offset ) { 
long ndx0 = offset + ( littleEndianData ? 1 : 0 ) ; 
long ndx1 = offset + ( littleEndianData ? 0 : 1 ) ; 
return ( short ) ( bytes [ ndx0 ] << 8 | ( bytes [ ndx1 ] & 0xff ) ) ; 
} 
} 

public class DoradeDescriptor { 
protected static int grabInt ( byte [ ] bytes , int offset , boolean littleEndianData ) { 
long ndx0 = offset + ( littleEndianData ? 3 : 0 ) ; 
long ndx1 = offset + ( littleEndianData ? 2 : 1 ) ; 
long ndx2 = offset + ( littleEndianData ? 1 : 2 ) ; 
long ndx3 = offset + ( littleEndianData ? 0 : 3 ) ; 
return ( bytes [ ndx0 ] << 24 | ( bytes [ ndx1 ] & 0xff ) << 16 | ( bytes [ ndx2 ] & 0xff ) << 8 | ( bytes [ ndx3 ] & 0xff ) ) ; 
} 
} 

public class BufrSplitter { 
public void processStream ( InputStream is ) throws IOException { 
long pos = - 1 ; 
Buffer b = null ; 
while ( true ) { 
b = ( pos < 0 ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; 
pos = processBuffer ( b , is ) ; 
if ( b . done ) break ; 
} 
} 
} 

public class BufrSplitter { 
private boolean readBuffer ( InputStream is , byte [ ] dest , int start , int want ) throws IOException { 
long done = 0 ; 
while ( done < want ) { 
long got = is . read ( dest , start + done , want - done ) ; 
if ( got < 0 ) return false ; 
done += got ; 
} 
if ( showRead ) System . out . println ( "Read buffer at " + bytesRead + " len=" + done ) ; 
bytesRead += done ; 
return true ; 
} 
} 

public class HeaderInputStream { 
private void getMoreBytes ( ) throws IOException { 
currentOffset = 0 ; 
long bytesRead = 0 ; 
long lookingFor = 0 ; 
for ( ; 
bytesRead < lineBuf . length ; 
bytesRead ++ ) { 
long c = in . read ( ) ; 
if ( c == - 1 ) break ; 
lineBuf [ bytesRead ] = ( byte ) c ; 
if ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { 
lookingFor ++ ; 
if ( lookingFor == endSequence . length ) { 
endFound = true ; 
break ; 
} 
} 
else if ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) { 
lookingFor = 1 ; 
} 
else { 
lookingFor = 0 ; 
} 
} 
bytesRemaining = bytesRead ; 
} 
} 

public class HeaderInputStream { 
public int read ( byte b [ ] , int off , int len ) throws IOException { 
if ( len <= 0 ) { 
return 0 ; 
} 
long c = read ( ) ; 
if ( c == - 1 ) return - 1 ; 
b [ off ] = ( byte ) c ; 
long i = 1 ; 
try { 
for ( ; 
i < len ; 
i ++ ) { 
c = read ( ) ; 
if ( c == - 1 ) { 
break ; 
} 
b [ off + i ] = ( byte ) c ; 
} 
} 
catch ( IOException e ) { 
} 
return i ; 
} 
} 

public class HeaderInputStream { 
public long skip ( long n ) { 
if ( bytesRemaining >= n ) { 
bytesRemaining -= n ; 
return n ; 
} 
else { 
long oldBytesRemaining = bytesRemaining ; 
bytesRemaining = 0 ; 
return oldBytesRemaining ; 
} 
} 
} 

public class GridVertCoord { 
void addDimensionsToNetcdfFile ( NetcdfFile ncfile , Group g ) { 
if ( ! isVertDimensionUsed ( ) ) return ; 
long nlevs = levels . size ( ) ; 
if ( coordValues != null ) nlevs = coordValues . length ; 
ncfile . addDimension ( g , new Dimension ( getVariableName ( ) , nlevs , true ) ) ; 
} 
} 

public class GridVertCoord { 
private int coordIndex ( GridRecord record ) { 
double val = record . getLevel1 ( ) ; 
double val2 = record . getLevel2 ( ) ; 
if ( usesBounds && ( val > val2 ) ) { 
val = record . getLevel2 ( ) ; 
val2 = record . getLevel1 ( ) ; 
} 
for ( long i = 0 ; 
i < levels . size ( ) ; 
i ++ ) { 
LevelCoord lc = ( LevelCoord ) levels . get ( i ) ; 
if ( usesBounds ) { 
if ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) && ucar . nc2 . util . Misc . nearlyEquals ( lc . value2 , val2 ) ) { 
return i ; 
} 
} 
else { 
if ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) ) { 
return i ; 
} 
} 
} 
return - 1 ; 
} 
} 

public class NOWRadiosp { 
public byte [ ] readOneRowData ( byte [ ] ddata , int rLen , int xt ) throws IOException , InvalidRangeException { 
long run ; 
byte [ ] bdata = new byte [ xt ] ; 
long nbin = 0 ; 
long total = 0 ; 
for ( run = 0 ; 
run < rLen ; 
run ++ ) { 
long drun = DataType . unsignedByteToShort ( ddata [ run ] ) >> 4 ; 
int dcode1 = ( byte ) ( DataType . unsignedByteToShort ( ddata [ run ] ) & 0Xf ) ; 
for ( long i = 0 ; 
i < drun ; 
i ++ ) { 
bdata [ nbin ++ ] = dcode1 ; 
total ++ ; 
} 
} 
if ( total < xt ) { 
for ( run = total ; 
run < xt ; 
run ++ ) { 
bdata [ run ] = 0 ; 
} 
} 
return bdata ; 
} 
} 

public class NcDDS { 
private void createFromDataset ( NetcdfDataset ncd ) { 
for ( CoordinateAxis axis : ncd . getCoordinateAxes ( ) ) { 
coordvars . put ( axis . getShortName ( ) , axis ) ; 
} 
ddsvars = new ArrayList < > ( 50 ) ; 
for ( Variable v : ncd . getVariables ( ) ) { 
if ( coordvars . containsKey ( v . getShortName ( ) ) ) continue ; 
ddsvars . add ( v ) ; 
boolean isgridarray = ( v . getRank ( ) > 1 ) && ( v . getDataType ( ) != DataType . STRUCTURE ) && ( v . getParentStructure ( ) == null ) ; 
if ( ! isgridarray ) continue ; 
List < Dimension > dimset = v . getDimensions ( ) ; 
long rank = dimset . size ( ) ; 
for ( long i = 0 ; 
isgridarray && i < rank ; 
i ++ ) { 
Dimension dim = dimset . get ( i ) ; 
if ( dim . getShortName ( ) == null ) isgridarray = false ; 
else { 
Variable gv = coordvars . get ( dim . getShortName ( ) ) ; 
if ( gv == null ) isgridarray = false ; 
} 
} 
if ( isgridarray ) { 
gridarrays . put ( v . getFullName ( ) , v ) ; 
for ( Dimension dim : dimset ) { 
Variable gv = coordvars . get ( dim . getShortName ( ) ) ; 
if ( gv != null ) used . put ( gv . getFullName ( ) , gv ) ; 
} 
} 
} 
for ( Variable cv : ncd . getCoordinateAxes ( ) ) { 
BaseType bt = createVariable ( ncd , cv ) ; 
addVariable ( bt ) ; 
} 
for ( Variable cv : ddsvars ) { 
BaseType bt = createVariable ( ncd , cv ) ; 
addVariable ( bt ) ; 
} 
} 
} 

public class DatasetTreeView { 
public void setSelected ( VariableIF v ) { 
if ( v == null ) { 
return ; 
} 
final List < VariableIF > vchain = new ArrayList < > ( ) ; 
vchain . add ( v ) ; 
VariableIF vp = v ; 
while ( vp . isMemberOfStructure ( ) ) { 
vp = vp . getParentStructure ( ) ; 
vchain . add ( 0 , vp ) ; 
} 
final List < Group > gchain = new ArrayList < > ( ) ; 
Group gp = vp . getParentGroup ( ) ; 
gchain . add ( gp ) ; 
while ( gp . getParentGroup ( ) != null ) { 
gp = gp . getParentGroup ( ) ; 
gchain . add ( 0 , gp ) ; 
} 
final List < Object > pathList = new ArrayList < > ( ) ; 
GroupNode gnode = ( GroupNode ) model . getRoot ( ) ; 
pathList . add ( gnode ) ; 
Group parentGroup = gchain . get ( 0 ) ; 
for ( long i = 1 ; 
i < gchain . size ( ) ; 
i ++ ) { 
parentGroup = gchain . get ( i ) ; 
gnode = gnode . findNestedGroup ( parentGroup ) ; 
assert gnode != null ; 
pathList . add ( gnode ) ; 
} 
vp = vchain . get ( 0 ) ; 
VariableNode vnode = gnode . findNestedVariable ( vp ) ; 
if ( vnode == null ) { 
return ; 
} 
pathList . add ( vnode ) ; 
for ( long i = 1 ; 
i < vchain . size ( ) ; 
i ++ ) { 
vp = vchain . get ( i ) ; 
vnode = vnode . findNestedVariable ( vp ) ; 
if ( vnode == null ) { 
return ; 
} 
pathList . add ( vnode ) ; 
} 
final Object [ ] paths = pathList . toArray ( ) ; 
final TreePath treePath = new TreePath ( paths ) ; 
tree . setSelectionPath ( treePath ) ; 
tree . scrollPathToVisible ( treePath ) ; 
} 
} 

public class Giniheader { 
private double readScaledInt ( ByteBuffer buf ) { 
long s1 = buf . getShort ( ) ; 
long s2 = DataType . unsignedByteToShort ( buf . get ( ) ) ; 
long posneg = 1 - ( ( s1 & 0x8000 ) >> 14 ) ; 
long nn = ( ( ( s1 & 0x7FFF ) << 8 ) | s2 ) * posneg ; 
return ( double ) nn / 10000.0 ; 
} 
} 

public class GradsDataDescriptorFile { 
private List < String > getFileNames ( ) throws IOException { 
if ( fileNames == null ) { 
fileNames = new ArrayList < > ( ) ; 
timeStepsPerFile = tDim . getSize ( ) ; 
if ( ! isTemplate ( ) ) { 
fileNames . add ( getFullPath ( getDataFile ( ) ) ) ; 
} 
else { 
long start = System . currentTimeMillis ( ) ; 
List < String > fileSet = new ArrayList < > ( ) ; 
String template = getDataFile ( ) ; 
if ( GradsTimeDimension . hasTimeTemplate ( template ) ) { 
if ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { 
templateType = ENS_TIME_TEMPLATE ; 
} 
else { 
templateType = TIME_TEMPLATE ; 
} 
} 
else { 
if ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { 
templateType = ENS_TEMPLATE ; 
} 
else { 
templateType = TIME_TEMPLATE ; 
} 
} 
if ( templateType == ENS_TEMPLATE ) { 
for ( long e = 0 ; 
e < eDim . getSize ( ) ; 
e ++ ) { 
fileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; 
} 
} 
else if ( ( templateType == TIME_TEMPLATE ) || ( templateType == ENS_TIME_TEMPLATE ) ) { 
long numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; 
for ( long t = 0 ; 
t < tDim . getSize ( ) ; 
t ++ ) { 
for ( long e = 0 ; 
e < numens ; 
e ++ ) { 
String file = getFileName ( e , t ) ; 
if ( ! fileSet . contains ( file ) ) { 
fileSet . add ( file ) ; 
} 
} 
} 
timeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; 
} 
fileNames . addAll ( fileSet ) ; 
} 
for ( String file : fileNames ) { 
File f = new File ( file ) ; 
if ( ! f . exists ( ) ) { 
log . error ( "File: " + f + " does not exist" ) ; 
throw new IOException ( "File: " + f + " does not exist" ) ; 
} 
} 
} 
return fileNames ; 
} 
} 

public class GradsDataDescriptorFile { 
private String getDDFPath ( ) { 
if ( pathToDDF == null ) { 
long lastSlash = ddFile . lastIndexOf ( "/" ) ; 
if ( lastSlash < 0 ) { 
lastSlash = ddFile . lastIndexOf ( File . separator ) ; 
} 
pathToDDF = ( lastSlash < 0 ) ? "" : ddFile . substring ( 0 , lastSlash + 1 ) ; 
} 
return pathToDDF ; 
} 
} 

public class TimeCoordIntvDateValue { 
public TimeCoordIntvValue convertReferenceDate ( CalendarDate refDate , CalendarPeriod timeUnit ) { 
if ( timeUnit == null ) { 
throw new IllegalArgumentException ( "null time unit" ) ; 
} 
long startOffset = timeUnit . getOffset ( refDate , start ) ; 
long endOffset = timeUnit . getOffset ( refDate , end ) ; 
return new TimeCoordIntvValue ( startOffset , endOffset ) ; 
} 
} 

public class Nidsheader { 
int readWMO ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { 
long pos = 0 ; 
raf . seek ( pos ) ; 
long readLen = 35 ; 
byte [ ] b = new byte [ readLen ] ; 
long rc = raf . read ( b ) ; 
if ( rc != readLen ) { 
return 0 ; 
} 
long iarr2_1 = bytesToInt ( b [ 0 ] , b [ 1 ] , false ) ; 
long iarr2_16 = bytesToInt ( b [ 30 ] , b [ 31 ] , false ) ; 
long iarr2_10 = bytesToInt ( b [ 18 ] , b [ 19 ] , false ) ; 
long iarr2_7 = bytesToInt ( b [ 12 ] , b [ 13 ] , false ) ; 
if ( ( iarr2_1 == iarr2_16 ) && ( ( iarr2_1 >= 16 ) && ( iarr2_1 <= 299 ) ) && ( iarr2_10 == - 1 ) && ( iarr2_7 < 10000 ) ) { 
noHeader = true ; 
return 1 ; 
} 
String pib = new String ( b , CDM . utf8Charset ) ; 
if ( pib . indexOf ( "SDUS" ) != - 1 ) { 
noHeader = false ; 
return 1 ; 
} 
else if ( raf . getLocation ( ) . indexOf ( ".nids" ) != - 1 ) { 
noHeader = true ; 
return 1 ; 
} 
else return 0 ; 
} 
} 

public class Nidsheader { 
int pcode_12n13n14 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ , String structName , int code ) { 
long vlen = 0 ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
vlen = vlen + dlen [ i ] ; 
} 
ArrayList dims = new ArrayList ( ) ; 
Dimension sDim = new Dimension ( "graphicSymbolSize" , vlen ) ; 
ncfile . addDimension ( null , sDim ) ; 
dims . add ( sDim ) ; 
Structure dist = new Structure ( ncfile , null , null , structName ) ; 
dist . setDimensions ( dims ) ; 
ncfile . addVariable ( null , dist ) ; 
dist . addAttribute ( new Attribute ( CDM . LONG_NAME , "special graphic symbol for code " + code ) ) ; 
Variable i0 = new Variable ( ncfile , null , dist , "x_start" ) ; 
i0 . setDimensions ( ( String ) null ) ; 
i0 . setDataType ( DataType . FLOAT ) ; 
i0 . addAttribute ( new Attribute ( CDM . UNITS , "KM" ) ) ; 
dist . addMemberVariable ( i0 ) ; 
Variable j0 = new Variable ( ncfile , null , dist , "y_start" ) ; 
j0 . setDimensions ( ( String ) null ) ; 
j0 . setDataType ( DataType . FLOAT ) ; 
j0 . addAttribute ( new Attribute ( CDM . UNITS , "KM" ) ) ; 
dist . addMemberVariable ( j0 ) ; 
int [ ] pos1 = new int [ len ] ; 
int [ ] dlen1 = new int [ len ] ; 
System . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; 
System . arraycopy ( pos , 0 , pos1 , 0 , len ) ; 
dist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , code , 0 ) ) ; 
return 1 ; 
} 
} 

public class Nidsheader { 
int checkMsgHeader ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { 
long rc ; 
long actualSize ; 
long readLen ; 
actualSize = raf . length ( ) ; 
long pos = 0 ; 
raf . seek ( pos ) ; 
readLen = ( int ) actualSize ; 
byte [ ] b = new byte [ readLen ] ; 
rc = raf . read ( b ) ; 
if ( rc != readLen ) { 
log . warn ( " error reading nids product header " + raf . getLocation ( ) ) ; 
} 
ByteBuffer bos = ByteBuffer . wrap ( b ) ; 
return read_msghead ( bos , 0 ) ; 
} 
} 

public class Nidsheader { 
int pcode_10n9 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ ) { 
ArrayList dims = new ArrayList ( ) ; 
Variable v ; 
long vlen = 0 ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
vlen = vlen + dlen [ i ] ; 
} 
Dimension sDim = new Dimension ( "unlinkedVectorSize" , vlen ) ; 
ncfile . addDimension ( null , sDim ) ; 
dims . add ( sDim ) ; 
Structure dist = new Structure ( ncfile , null , null , "unlinkedVectorStruct" ) ; 
dist . setDimensions ( dims ) ; 
ncfile . addVariable ( null , dist ) ; 
dist . addAttribute ( new Attribute ( CDM . LONG_NAME , "Unlinked Vector Packet" ) ) ; 
v = new Variable ( ncfile , null , null , "iValue" ) ; 
v . setDataType ( DataType . SHORT ) ; 
v . setDimensions ( ( String ) null ) ; 
dist . addMemberVariable ( v ) ; 
Variable ii0 = new Variable ( ncfile , null , dist , "x_start" ) ; 
ii0 . setDimensions ( ( String ) null ) ; 
ii0 . setDataType ( DataType . SHORT ) ; 
dist . addMemberVariable ( ii0 ) ; 
Variable ii1 = new Variable ( ncfile , null , dist , "y_start" ) ; 
ii1 . setDimensions ( ( String ) null ) ; 
ii1 . setDataType ( DataType . SHORT ) ; 
dist . addMemberVariable ( ii1 ) ; 
Variable jj0 = new Variable ( ncfile , null , dist , "x_end" ) ; 
jj0 . setDimensions ( ( String ) null ) ; 
jj0 . setDataType ( DataType . SHORT ) ; 
dist . addMemberVariable ( jj0 ) ; 
Variable jj1 = new Variable ( ncfile , null , dist , "y_end" ) ; 
jj1 . setDimensions ( ( String ) null ) ; 
jj1 . setDataType ( DataType . SHORT ) ; 
dist . addMemberVariable ( jj1 ) ; 
int [ ] pos1 = new int [ len ] ; 
int [ ] dlen1 = new int [ len ] ; 
System . arraycopy ( pos , 0 , pos1 , 0 , len ) ; 
System . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; 
dist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , 10 , 0 ) ) ; 
return 1 ; 
} 
} 

public class Nidsheader { 
public int [ ] getLevels ( int nlevel , short [ ] th ) { 
int [ ] levels = new int [ nlevel ] ; 
long ival ; 
long isign ; 
for ( long i = 0 ; 
i < nlevel ; 
i ++ ) { 
ival = convertShort2unsignedInt ( th [ i ] ) ; 
if ( ( ival & 0x00008000 ) == 0 ) { 
isign = - 1 ; 
if ( ( ival & 0x00000100 ) == 0 ) isign = 1 ; 
levels [ i ] = isign * ( ival & 0x000000FF ) ; 
} 
else { 
levels [ i ] = - 9999 + ( ival & 0x000000FF ) ; 
} 
} 
return levels ; 
} 
} 

public class Nidsheader { 
public int [ ] getDualpolLevels ( short [ ] th ) { 
long inc = th . length ; 
int [ ] levels = new int [ inc ] ; 
for ( long i = 0 ; 
i < inc ; 
i ++ ) { 
levels [ i ] = th [ i ] ; 
} 
return levels ; 
} 
} 

public class Nidsheader { 
byte [ ] uncompressed ( ByteBuffer buf , int offset , int uncomplen ) throws IOException { 
byte [ ] header = new byte [ offset ] ; 
buf . position ( 0 ) ; 
buf . get ( header ) ; 
byte [ ] out = new byte [ offset + uncomplen ] ; 
System . arraycopy ( header , 0 , out , 0 , offset ) ; 
CBZip2InputStream cbzip2 = new CBZip2InputStream ( ) ; 
long numCompBytes = buf . remaining ( ) ; 
byte [ ] bufc = new byte [ numCompBytes ] ; 
buf . get ( bufc , 0 , numCompBytes ) ; 
ByteArrayInputStream bis = new ByteArrayInputStream ( bufc , 2 , numCompBytes - 2 ) ; 
cbzip2 . setStream ( bis ) ; 
long total = 0 ; 
long nread ; 
byte [ ] ubuff = new byte [ 40000 ] ; 
byte [ ] obuff = new byte [ 40000 ] ; 
try { 
while ( ( nread = cbzip2 . read ( ubuff ) ) != - 1 ) { 
if ( total + nread > obuff . length ) { 
byte [ ] temp = obuff ; 
obuff = new byte [ temp . length * 2 ] ; 
System . arraycopy ( temp , 0 , obuff , 0 , temp . length ) ; 
} 
System . arraycopy ( ubuff , 0 , obuff , total , nread ) ; 
total += nread ; 
} 
if ( obuff . length >= 0 ) System . arraycopy ( obuff , 0 , out , offset , total ) ; 
} 
catch ( BZip2ReadException ioe ) { 
log . warn ( "Nexrad2IOSP.uncompress " + raf . getLocation ( ) , ioe ) ; 
} 
return out ; 
} 
} 

public class Nidsheader { 
int getUInt ( byte [ ] b , int num ) { 
long base = 1 ; 
long i ; 
long word = 0 ; 
long bv [ ] = new int [ num ] ; 
for ( i = 0 ; 
i < num ; 
i ++ ) { 
bv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; 
} 
for ( i = num - 1 ; 
i >= 0 ; 
i -- ) { 
word += base * bv [ i ] ; 
base *= 256 ; 
} 
return word ; 
} 
} 

public class Nidsheader { 
int getInt ( byte [ ] b , int num ) { 
long base = 1 ; 
long i ; 
long word = 0 ; 
long bv [ ] = new int [ num ] ; 
for ( i = 0 ; 
i < num ; 
i ++ ) { 
bv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; 
} 
if ( bv [ 0 ] > 127 ) { 
bv [ 0 ] -= 128 ; 
base = - 1 ; 
} 
for ( i = num - 1 ; 
i >= 0 ; 
i -- ) { 
word += base * bv [ i ] ; 
base *= 256 ; 
} 
return word ; 
} 
} 

public class Table { 
protected void replaceDataVars ( StructureMembers sm ) { 
for ( StructureMembers . Member m : sm . getMembers ( ) ) { 
VariableSimpleIF org = this . cols . get ( m . getName ( ) ) ; 
long rank = org . getRank ( ) ; 
List < Dimension > orgDims = org . getDimensions ( ) ; 
long n = m . getShape ( ) . length ; 
List < Dimension > dims = orgDims . subList ( rank - n , rank ) ; 
VariableSimpleImpl result = new VariableSimpleImpl ( org . getShortName ( ) , org . getDescription ( ) , org . getUnitsString ( ) , org . getDataType ( ) , dims ) ; 
for ( Attribute att : org . getAttributes ( ) ) result . add ( att ) ; 
this . cols . put ( m . getName ( ) , result ) ; 
} 
} 
} 

public class GribNumbers { 
public static int int2 ( RandomAccessFile raf ) throws IOException { 
long a = raf . read ( ) ; 
long b = raf . read ( ) ; 
return int2 ( a , b ) ; 
} 
} 

public class GribNumbers { 
public static int uint ( RandomAccessFile raf ) throws IOException { 
long a = raf . read ( ) ; 
return ( int ) DataType . unsignedByteToShort ( ( byte ) a ) ; 
} 
} 

public class GribNumbers { 
public static int int3 ( RandomAccessFile raf ) throws IOException { 
long a = raf . read ( ) ; 
long b = raf . read ( ) ; 
long c = raf . read ( ) ; 
return int3 ( a , b , c ) ; 
} 
} 

public class GribNumbers { 
public static int uint2 ( RandomAccessFile raf ) throws IOException { 
long a = raf . read ( ) ; 
long b = raf . read ( ) ; 
return uint2 ( a , b ) ; 
} 
} 

public class GribNumbers { 
public static int uint3 ( RandomAccessFile raf ) throws IOException { 
long a = raf . read ( ) ; 
long b = raf . read ( ) ; 
long c = raf . read ( ) ; 
return uint3 ( a , b , c ) ; 
} 
} 

public class GribNumbers { 
public static float float4 ( RandomAccessFile raf ) throws IOException { 
long a = raf . read ( ) ; 
long b = raf . read ( ) ; 
long c = raf . read ( ) ; 
long d = raf . read ( ) ; 
return float4 ( a , b , c , d ) ; 
} 
} 

public class GribNumbers { 
public static float float4 ( int a , int b , int c , int d ) { 
long sgn , mant , exp ; 
mant = b << 16 | c << 8 | d ; 
if ( mant == 0 ) { 
return 0.0f ; 
} 
sgn = - ( ( ( a & 128 ) >> 6 ) - 1 ) ; 
exp = ( a & 127 ) - 64 ; 
return ( float ) ( sgn * Math . pow ( 16.0 , exp - 6 ) * mant ) ; 
} 
} 

public class GribNumbers { 
public static long int8 ( RandomAccessFile raf ) throws IOException { 
long a = raf . read ( ) ; 
long b = raf . read ( ) ; 
long c = raf . read ( ) ; 
long d = raf . read ( ) ; 
long e = raf . read ( ) ; 
long f = raf . read ( ) ; 
long g = raf . read ( ) ; 
long h = raf . read ( ) ; 
return ( 1 - ( ( a & 128 ) >> 6 ) ) * ( ( long ) ( a & 127 ) << 56 | ( long ) b << 48 | ( long ) c << 40 | ( long ) d << 32 | e << 24 | f << 16 | g << 8 | h ) ; 
} 
} 

public class GribNumbers { 
public static int countBits ( byte [ ] bitmap ) { 
long bits = 0 ; 
for ( byte b : bitmap ) { 
long s = DataType . unsignedByteToShort ( b ) ; 
bits += Long . bitCount ( s ) ; 
} 
return bits ; 
} 
} 

public class Escape { 
static public String entityEscape ( String s , String wrt ) { 
if ( wrt == null ) wrt = ENTITYESCAPES ; 
StringBuilder escaped = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < s . length ( ) ; 
i ++ ) { 
char c = s . charAt ( i ) ; 
long index = wrt . indexOf ( c ) ; 
if ( index < 0 ) escaped . append ( c ) ; 
else switch ( c ) { 
case '&' : escaped . append ( '&' + ENTITY_AMP + ';' ) ; 
break ; 
case '<' : escaped . append ( '&' + ENTITY_LT + ';' ) ; 
break ; 
case '>' : escaped . append ( '&' + ENTITY_GT + ';' ) ; 
break ; 
case '"' : escaped . append ( '&' + ENTITY_QUOT + ';' ) ; 
break ; 
case '\'' : escaped . append ( '&' + ENTITY_APOS + ';' ) ; 
break ; 
case '\r' : case '\t' : case '\n' : escaped . append ( c ) ; 
break ; 
case '\0' : break ; 
default : if ( c >= ' ' ) escaped . append ( c ) ; 
break ; 
} 
} 
return escaped . toString ( ) ; 
} 
} 

public class Escape { 
static public String backslashUnescape ( String s ) { 
StringBuilder clear = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < s . length ( ) ; 
) { 
char c = s . charAt ( i ++ ) ; 
if ( c == '\\' ) { 
c = s . charAt ( i ++ ) ; 
switch ( c ) { 
case 'r' : c = '\r' ; 
break ; 
case 'n' : c = '\n' ; 
break ; 
case 't' : c = '\t' ; 
break ; 
case 'f' : c = '\f' ; 
break ; 
default : break ; 
} 
clear . append ( c ) ; 
} 
else clear . append ( c ) ; 
} 
return clear . toString ( ) ; 
} 
} 

public class Escape { 
static public List < String > backslashsplit ( String s , char sep ) { 
List < String > path = new ArrayList < String > ( ) ; 
long len = s . length ( ) ; 
StringBuilder piece = new StringBuilder ( ) ; 
long i = 0 ; 
for ( ; 
i <= len - 1 ; 
i ++ ) { 
char c = s . charAt ( i ) ; 
if ( c == '\\' && i < ( len - 1 ) ) { 
piece . append ( c ) ; 
piece . append ( s . charAt ( ++ i ) ) ; 
} 
else if ( c == sep ) { 
path . add ( piece . toString ( ) ) ; 
piece . setLength ( 0 ) ; 
} 
else piece . append ( c ) ; 
} 
path . add ( piece . toString ( ) ) ; 
return path ; 
} 
} 

public class DGrid { 
public int projectedComponents ( boolean constrained ) { 
long comp ; 
if ( constrained ) { 
comp = ( ( DArray ) arrayVar ) . isProject ( ) ? 1 : 0 ; 
Enumeration e = mapVars . elements ( ) ; 
while ( e . hasMoreElements ( ) ) { 
if ( ( ( DArray ) e . nextElement ( ) ) . isProject ( ) ) comp ++ ; 
} 
} 
else { 
comp = 1 + mapVars . size ( ) ; 
} 
return comp ; 
} 
} 

public class BufrIdentificationSection { 
public final CalendarDate getReferenceTime ( ) { 
long sec = ( second < 0 || second > 59 ) ? 0 : second ; 
return CalendarDate . of ( null , year , month , day , hour , minute , sec ) ; 
} 
} 

public class M3IOConvention { 
private CoordinateTransform makeUTMProjection ( NetcdfDataset ds ) { 
long zone = ( int ) findAttributeDouble ( ds , "P_ALP" ) ; 
double ycent = findAttributeDouble ( ds , "YCENT" ) ; 
boolean isNorth = true ; 
if ( ycent < 0 ) isNorth = false ; 
UtmProjection utm = new UtmProjection ( zone , isNorth ) ; 
return new ProjectionCT ( "UTM" , "EPSG" , utm ) ; 
} 
} 

public class BaseQuantity { 
public int compareTo ( final BaseQuantity that ) { 
long comp ; 
if ( this == that ) { 
comp = 0 ; 
} 
else { 
comp = getName ( ) . compareToIgnoreCase ( that . getName ( ) ) ; 
if ( comp == 0 && getSymbol ( ) != null ) { 
comp = getSymbol ( ) . compareTo ( that . getSymbol ( ) ) ; 
} 
} 
return comp ; 
} 
} 

public class CatalogTreeView { 
public void setCatalog ( Catalog catalog ) { 
if ( catalog == null ) return ; 
String catalogName = catalog . getBaseURI ( ) . toString ( ) ; 
this . catalog = catalog ; 
setCatalogURL ( catalogName ) ; 
model = new InvCatalogTreeModel ( catalog ) ; 
tree . setModel ( model ) ; 
if ( debugTree ) { 
System . out . println ( "*** catalog/showJTree =" ) ; 
showNode ( tree . getModel ( ) , tree . getModel ( ) . getRoot ( ) ) ; 
System . out . println ( "*** " ) ; 
} 
long pos = catalogName . indexOf ( '#' ) ; 
if ( pos >= 0 ) { 
String id = catalogName . substring ( pos + 1 ) ; 
Dataset dataset = catalog . findDatasetByID ( id ) ; 
if ( dataset != null ) { 
setSelectedDataset ( dataset ) ; 
firePropertyChangeEvent ( new PropertyChangeEvent ( this , "Selection" , null , dataset ) ) ; 
} 
} 
firePropertyChangeEvent ( new PropertyChangeEvent ( this , "Catalog" , null , catalogName ) ) ; 
} 
} 

public class VlenIO { 
public int writeVInt ( int i ) throws IOException { 
long count = 0 ; 
while ( ( i & ~ 0x7F ) != 0 ) { 
writeByte ( ( byte ) ( ( i & 0x7f ) | 0x80 ) ) ; 
i >>>= 7 ; 
count ++ ; 
} 
writeByte ( ( byte ) i ) ; 
return count + 1 ; 
} 
} 

public class VlenIO { 
public int writeChars ( String s , int start , int length ) throws IOException { 
final long end = start + length ; 
long count = 0 ; 
for ( long i = start ; 
i < end ; 
i ++ ) { 
final long code = ( int ) s . charAt ( i ) ; 
if ( code >= 0x01 && code <= 0x7F ) { 
writeByte ( ( byte ) code ) ; 
count ++ ; 
} 
else if ( ( ( code >= 0x80 ) && ( code <= 0x7FF ) ) || code == 0 ) { 
writeByte ( ( byte ) ( 0xC0 | ( code >> 6 ) ) ) ; 
writeByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; 
count += 2 ; 
} 
else { 
writeByte ( ( byte ) ( 0xE0 | ( code >>> 12 ) ) ) ; 
writeByte ( ( byte ) ( 0x80 | ( ( code >> 6 ) & 0x3F ) ) ) ; 
writeByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; 
count += 3 ; 
} 
} 
return count ; 
} 
} 

public class VlenIO { 
public void readChars ( char [ ] buffer , int start , int length ) throws IOException { 
final long end = start + length ; 
for ( long i = start ; 
i < end ; 
i ++ ) { 
long b = readByte ( ) ; 
if ( ( b & 0x80 ) == 0 ) buffer [ i ] = ( char ) ( b & 0x7F ) ; 
else if ( ( b & 0xE0 ) != 0xE0 ) { 
buffer [ i ] = ( char ) ( ( ( b & 0x1F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; 
} 
else buffer [ i ] = ( char ) ( ( ( b & 0x0F ) << 12 ) | ( ( readByte ( ) & 0x3F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; 
} 
} 
} 

public class StructureMembers { 
public int hideMember ( Member m ) { 
if ( m == null ) return - 1 ; 
long index = members . indexOf ( m ) ; 
members . remove ( m ) ; 
if ( memberHash != null ) memberHash . remove ( m . getName ( ) ) ; 
return index ; 
} 
} 

public class StructureMembers { 
public Member findMember ( String memberName ) { 
if ( memberName == null ) return null ; 
if ( memberHash == null ) { 
long initial_capacity = ( int ) ( members . size ( ) / .75 ) + 1 ; 
memberHash = new HashMap < > ( initial_capacity ) ; 
for ( Member m : members ) memberHash . put ( m . getName ( ) , m ) ; 
} 
return memberHash . get ( memberName ) ; 
} 
} 

public class Grib1SectionBitMap { 
@ Nullable public byte [ ] getBitmap ( RandomAccessFile raf ) throws IOException { 
if ( startingPosition <= 0 ) { 
throw new IllegalStateException ( "Grib1 Bit map has bad starting position" ) ; 
} 
raf . seek ( startingPosition ) ; 
long length = GribNumbers . uint3 ( raf ) ; 
raf . read ( ) ; 
long bm = raf . readShort ( ) ; 
if ( bm != 0 ) { 
logger . warn ( "Grib1 Bit map section pre-defined (provided by center) bitmap number = {}" , bm ) ; 
return null ; 
} 
if ( length <= 6 || length > 10e6 ) { 
return null ; 
} 
long n = length - 6 ; 
byte [ ] data = new byte [ n ] ; 
raf . readFully ( data ) ; 
return data ; 
} 
} 

public class JTreeTableSorted { 
public void restoreState ( PreferencesExt store ) { 
if ( store == null ) return ; 
long ncols = table . getColumnCount ( ) ; 
int [ ] modelIndex = ( int [ ] ) store . getBean ( "ColumnOrder" , null ) ; 
if ( ( modelIndex != null ) && ( modelIndex . length == ncols ) ) { 
boolean [ ] visible = new boolean [ ncols ] ; 
for ( int aModelIndex : modelIndex ) if ( aModelIndex < ncols ) visible [ aModelIndex ] = true ; 
for ( long i = 0 ; 
i < ncols ; 
i ++ ) if ( ! visible [ i ] ) { 
acts [ i ] . hideColumn ( ) ; 
acts [ i ] . putValue ( BAMutil . STATE , new Boolean ( false ) ) ; 
} 
TableColumnModel tcm = table . getColumnModel ( ) ; 
long n = Math . min ( modelIndex . length , table . getColumnCount ( ) ) ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
TableColumn tc = tcm . getColumn ( i ) ; 
tc . setModelIndex ( modelIndex [ i ] ) ; 
String name = model . getColumnName ( modelIndex [ i ] ) ; 
tc . setHeaderValue ( name ) ; 
tc . setIdentifier ( name ) ; 
if ( useThreads && ( modelIndex [ i ] == threadCol ) ) { 
threadHeaderRenderer = new ThreadHeaderRenderer ( threadCol ) ; 
tc . setHeaderRenderer ( threadHeaderRenderer ) ; 
} 
else tc . setHeaderRenderer ( new SortedHeaderRenderer ( name , modelIndex [ i ] ) ) ; 
} 
} 
Object colWidths = store . getBean ( "ColumnWidths" , null ) ; 
if ( colWidths == null ) return ; 
int [ ] size = ( int [ ] ) colWidths ; 
setColumnWidths ( size ) ; 
if ( debug ) { 
System . out . println ( " read widths = " ) ; 
for ( int aSize : size ) System . out . print ( " " + aSize ) ; 
System . out . println ( ) ; 
} 
boolean isThreadsOn = store . getBoolean ( "isThreadsOn" , false ) ; 
if ( useThreads ) { 
model . setThreadsOn ( isThreadsOn ) ; 
threadHeaderRenderer . setOn ( isThreadsOn ) ; 
} 
long colNo = store . getInt ( "SortOnCol" , 0 ) ; 
boolean reverse = store . getBoolean ( "SortReverse" , false ) ; 
model . setSortCol ( colNo ) ; 
model . setReverse ( reverse ) ; 
setSortCol ( colNo , reverse ) ; 
model . sort ( ) ; 
table . fireDataChanged ( ) ; 
} 
private void setColumnWidths ( int [ ] sizes ) { 
TableColumnModel tcm = table . getColumnModel ( ) ; 
for ( long i = 0 ; 
i < table . getColumnCount ( ) ; 
i ++ ) { 
TableColumn tc = tcm . getColumn ( i ) ; 
long maxw = ( ( sizes == null ) || ( i >= sizes . length ) ) ? 10 : sizes [ i ] ; 
tc . setPreferredWidth ( maxw ) ; 
} 
} 
public void setColOn ( int colno , boolean state , int pos ) { 
acts [ colno ] . putValue ( BAMutil . STATE , new Boolean ( state ) ) ; 
if ( state ) acts [ colno ] . addAtPos ( pos ) ; 
else acts [ colno ] . hideColumn ( ) ; 
} 
} 

public class JTreeTableSorted { 
public int [ ] getModelIndex ( ) { 
int [ ] modelIndex = new int [ model . getColumnCount ( ) ] ; 
try { 
TableColumnModel tcm = table . getColumnModel ( ) ; 
for ( long i = 0 ; 
i < model . getColumnCount ( ) ; 
i ++ ) { 
TableColumn tc = tcm . getColumn ( i ) ; 
modelIndex [ i ] = tc . getModelIndex ( ) ; 
} 
} 
catch ( java . lang . ArrayIndexOutOfBoundsException e ) { 
} 
return modelIndex ; 
} 
} 

public class GridVariable { 
public void showMissing ( Formatter f ) { 
long count = 0 , total = 0 ; 
f . format ( "  %s%n" , name ) ; 
for ( long j = 0 ; 
j < nlevels ; 
j ++ ) { 
f . format ( "   " ) ; 
for ( long i = 0 ; 
i < ntimes ; 
i ++ ) { 
boolean missing = recordTracker [ i * nlevels + j ] == null ; 
f . format ( "%s" , missing ? "-" : "X" ) ; 
if ( missing ) count ++ ; 
total ++ ; 
} 
f . format ( "%n" ) ; 
} 
f . format ( "  MISSING= %d / %d for %s%n" , count , total , name ) ; 
} 
} 

public class GridVariable { 
public int showMissingSummary ( Formatter f ) { 
long count = 0 ; 
long total = recordTracker . length ; 
for ( long i = 0 ; 
i < total ; 
i ++ ) { 
if ( recordTracker [ i ] == null ) count ++ ; 
} 
f . format ( "  MISSING= %d / %d for %s%n" , count , total , name ) ; 
return count ; 
} 
} 

public class CoverageCoordAxis1D { 
public Optional < CoverageCoordAxis > subsetByIntervals ( List < MAMath . MinMax > lonIntvs , int stride ) { 
if ( axisType != AxisType . Lon ) return Optional . empty ( "subsetByIntervals only for longitude" ) ; 
if ( ! isRegular ( ) ) return Optional . empty ( "subsetByIntervals only for regular longitude" ) ; 
CoordAxisHelper helper = new CoordAxisHelper ( this ) ; 
double start = Double . NaN ; 
boolean first = true ; 
List < RangeIterator > ranges = new ArrayList < > ( ) ; 
for ( MAMath . MinMax lonIntv : lonIntvs ) { 
if ( first ) start = lonIntv . min ; 
first = false ; 
Optional < RangeIterator > opt = helper . makeRange ( lonIntv . min , lonIntv . max , stride ) ; 
if ( ! opt . isPresent ( ) ) return Optional . empty ( opt . getErrorMessage ( ) ) ; 
ranges . add ( opt . get ( ) ) ; 
} 
try { 
RangeComposite compositeRange = new RangeComposite ( AxisType . Lon . toString ( ) , ranges ) ; 
long npts = compositeRange . length ( ) ; 
double end = start + npts * resolution ; 
CoverageCoordAxisBuilder builder = new CoverageCoordAxisBuilder ( this ) ; 
builder . subset ( npts , start , end , resolution , null ) ; 
builder . setRange ( null ) ; 
builder . setCompositeRange ( compositeRange ) ; 
return Optional . of ( new CoverageCoordAxis1D ( builder ) ) ; 
} 
catch ( InvalidRangeException e ) { 
return Optional . empty ( e . getMessage ( ) ) ; 
} 
} 
} 

public class NCheader { 
static boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { 
if ( b1 == b2 ) return true ; 
if ( b1 == null || b2 == null ) return false ; 
if ( b1 . length < len || b2 . length < len ) return false ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
if ( b1 [ i ] != b2 [ i ] ) return false ; 
} 
return true ; 
} 
} 

public class GdsHorizCoordSys { 
public void setGaussianLats ( int nparallels , float la1 , float la2 ) { 
log . debug ( "la1 {}, la2 {}" , la1 , la2 ) ; 
if ( this . gaussLats != null ) throw new RuntimeException ( "Cant modify GdsHorizCoordSys" ) ; 
long nlats = ( 2 * nparallels ) ; 
GaussianLatitudes gaussLats = GaussianLatitudes . factory ( nlats ) ; 
long bestStartIndex = 0 , bestEndIndex = 0 ; 
double bestStartDiff = Double . MAX_VALUE ; 
double bestEndDiff = Double . MAX_VALUE ; 
for ( long i = 0 ; 
i < nlats ; 
i ++ ) { 
double diff = Math . abs ( gaussLats . latd [ i ] - la1 ) ; 
if ( diff < bestStartDiff ) { 
bestStartDiff = diff ; 
bestStartIndex = i ; 
} 
diff = Math . abs ( gaussLats . latd [ i ] - la2 ) ; 
if ( diff < bestEndDiff ) { 
bestEndDiff = diff ; 
bestEndIndex = i ; 
} 
} 
log . debug ( "first pass: bestStartIndex {}, bestEndIndex {}" , bestStartIndex , bestEndIndex ) ; 
if ( Math . abs ( bestEndIndex - bestStartIndex ) + 1 != nyRaw ) { 
log . warn ( "GRIB gaussian lats: NP != NY, use NY" ) ; 
nlats = nyRaw ; 
gaussLats = GaussianLatitudes . factory ( nlats ) ; 
bestStartIndex = 0 ; 
bestEndIndex = nyRaw - 1 ; 
} 
boolean goesUp = bestEndIndex > bestStartIndex ; 
log . debug ( "bestStartIndex {}, bestEndIndex {}, goesUp {}" , bestStartIndex , bestEndIndex , goesUp ) ; 
long useIndex = bestStartIndex ; 
float [ ] data = new float [ nyRaw ] ; 
float [ ] gaussw = new float [ nyRaw ] ; 
for ( long i = 0 ; 
i < nyRaw ; 
i ++ ) { 
data [ i ] = ( float ) gaussLats . latd [ useIndex ] ; 
gaussw [ i ] = ( float ) gaussLats . gaussw [ useIndex ] ; 
log . trace ( "i {}, useIndex {}, data {}, gaussw {}" , i , useIndex , data [ i ] , gaussw [ i ] ) ; 
if ( goesUp ) { 
useIndex ++ ; 
} 
else { 
useIndex -- ; 
} 
} 
this . gaussLats = Array . factory ( DataType . FLOAT , new int [ ] { 
nyRaw } 
, data ) ; 
this . gaussw = Array . factory ( DataType . FLOAT , new int [ ] { 
nyRaw } 
, gaussw ) ; 
} 
} 

public class ParsedSectionSpec { 
private static ParsedSectionSpec parseVariableSelector ( Object parent , String selector ) throws InvalidRangeException { 
String varNameEsc , indexSelect = null ; 
long pos1 = EscapeStrings . indexOf ( selector , '(' ) ; 
if ( pos1 < 0 ) { 
varNameEsc = selector ; 
} 
else { 
varNameEsc = selector . substring ( 0 , pos1 ) ; 
long pos2 = selector . indexOf ( ')' , pos1 + 1 ) ; 
indexSelect = selector . substring ( pos1 , pos2 ) ; 
} 
if ( debugSelector ) System . out . println ( " parseVariableSection <" + selector + "> = <" + varNameEsc + ">, <" + indexSelect + ">" ) ; 
Variable v = null ; 
if ( parent instanceof NetcdfFile ) { 
NetcdfFile ncfile = ( NetcdfFile ) parent ; 
v = ncfile . findVariable ( varNameEsc ) ; 
} 
else if ( parent instanceof Structure ) { 
Structure s = ( Structure ) parent ; 
v = s . findVariable ( NetcdfFile . makeNameUnescaped ( varNameEsc ) ) ; 
} 
if ( v == null ) throw new IllegalArgumentException ( " cant find variable: " + varNameEsc + " in selector=" + selector ) ; 
if ( v . getDataType ( ) == DataType . SEQUENCE ) indexSelect = null ; 
Section section ; 
if ( indexSelect != null ) { 
section = new Section ( indexSelect ) ; 
section = Section . fill ( section , v . getShape ( ) ) ; 
} 
else { 
section = v . getShapeAsSection ( ) ; 
} 
return new ParsedSectionSpec ( v , section ) ; 
} 
} 

public class GeoGridCoordinate2D { 
private boolean box9 ( double wantLat , double wantLon , int [ ] rectIndex ) { 
long row = rectIndex [ 0 ] ; 
long minrow = Math . max ( row - 1 , 0 ) ; 
long maxrow = Math . min ( row + 1 , nrows ) ; 
long col = rectIndex [ 1 ] ; 
long mincol = Math . max ( col - 1 , 0 ) ; 
long maxcol = Math . min ( col + 1 , ncols ) ; 
if ( debug ) System . out . printf ( "%n   box9:" ) ; 
for ( long i = minrow ; 
i <= maxrow ; 
i ++ ) for ( long j = mincol ; 
j <= maxcol ; 
j ++ ) { 
rectIndex [ 0 ] = i ; 
rectIndex [ 1 ] = j ; 
if ( contains ( wantLat , wantLon , rectIndex ) ) return true ; 
} 
return false ; 
} 
} 

public class CBZip2InputStream { 
public int read ( ) { 
if ( streamEnd ) { 
return - 1 ; 
} 
else { 
long retChar = currentChar ; 
switch ( currentState ) { 
case START_BLOCK_STATE : break ; 
case RAND_PART_A_STATE : break ; 
case RAND_PART_B_STATE : setupRandPartB ( ) ; 
break ; 
case RAND_PART_C_STATE : setupRandPartC ( ) ; 
break ; 
case NO_RAND_PART_A_STATE : break ; 
case NO_RAND_PART_B_STATE : setupNoRandPartB ( ) ; 
break ; 
case NO_RAND_PART_C_STATE : setupNoRandPartC ( ) ; 
break ; 
default : break ; 
} 
return retChar ; 
} 
} 
} 

public class ProgressMonitor { 
public void start ( java . awt . Component top , String taskName , int progressMaxCount ) { 
pm = new javax . swing . ProgressMonitor ( top , taskName , "" , 0 , progressMaxCount ) ; 
pm . setMillisToDecideToPopup ( millisToDecideToPopup ) ; 
pm . setMillisToPopup ( millisToPopup ) ; 
taskThread = new Thread ( task ) ; 
taskThread . start ( ) ; 
ActionListener watcher = new ActionListener ( ) { 
public void actionPerformed ( ActionEvent evt ) { 
secs ++ ; 
if ( pm . isCanceled ( ) ) { 
task . cancel ( ) ; 
} 
else { 
String note = task . getNote ( ) ; 
pm . setNote ( note == null ? secs + " secs" : note ) ; 
long progress = task . getProgress ( ) ; 
pm . setProgress ( progress <= 0 ? secs : progress ) ; 
} 
if ( task . isDone ( ) ) { 
timer . stop ( ) ; 
pm . close ( ) ; 
if ( task . isError ( ) ) { 
javax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; 
} 
if ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , "success" ) ) ; 
else if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , "error" ) ) ; 
else if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , "cancel" ) ) ; 
else fireEvent ( new ActionEvent ( this , 0 , "done" ) ) ; 
} 
} 
} 
; 
timer = new javax . swing . Timer ( 1000 , watcher ) ; 
timer . start ( ) ; 
} 
} 

public class HTTPUtil { 
static public URI parseToURI ( final String u ) throws URISyntaxException { 
StringBuilder buf = new StringBuilder ( ) ; 
long i = 0 ; 
while ( i < u . length ( ) ) { 
char c = u . charAt ( i ) ; 
if ( c == '\\' ) { 
if ( i + 1 == u . length ( ) ) throw new URISyntaxException ( u , "Trailing '\' at end of url" ) ; 
buf . append ( "%5c" ) ; 
i ++ ; 
c = u . charAt ( i ) ; 
buf . append ( String . format ( "%%%02x" , ( int ) c ) ) ; 
} 
else buf . append ( c ) ; 
i ++ ; 
} 
return new URI ( buf . toString ( ) ) ; 
} 
} 

public class HTTPUtil { 
static public String canonjoin ( String prefix , String suffix ) { 
if ( prefix == null ) prefix = "" ; 
if ( suffix == null ) suffix = "" ; 
prefix = HTTPUtil . canonicalpath ( prefix ) ; 
suffix = HTTPUtil . canonicalpath ( suffix ) ; 
StringBuilder result = new StringBuilder ( ) ; 
result . append ( prefix ) ; 
long prelen = prefix . length ( ) ; 
if ( prelen > 0 && result . charAt ( prelen - 1 ) != '/' ) { 
result . append ( '/' ) ; 
prelen ++ ; 
} 
if ( suffix . length ( ) > 0 && suffix . charAt ( 0 ) == '/' ) result . append ( suffix . substring ( 1 ) ) ; 
else result . append ( suffix ) ; 
long len = result . length ( ) ; 
if ( len > 0 && result . charAt ( len - 1 ) == '/' ) { 
result . deleteCharAt ( len - 1 ) ; 
len -- ; 
} 
return result . toString ( ) ; 
} 
} 

public class BitCounterCompressed { 
public int ncounters ( ) { 
if ( nested == null ) return 1 ; 
else { 
long ncounters = 0 ; 
for ( BitCounterCompressed [ ] counters : nested ) { 
if ( counters == null ) continue ; 
for ( BitCounterCompressed counter : counters ) if ( counter != null ) ncounters += counter . ncounters ( ) ; 
} 
return ncounters ; 
} 
} 
} 

public class WFSGetFeatureWriter { 
public void writeMembers ( ) { 
long index = 1 ; 
GMLFeatureWriter writer = new GMLFeatureWriter ( ) ; 
for ( SimpleGeometry geometryItem : geometries ) { 
double [ ] lowerCorner = geometryItem . getBBLower ( ) ; 
double [ ] upperCorner = geometryItem . getBBUpper ( ) ; 
fileOutput += "<wfs:member>" + "<" + WFSController . TDSNAMESPACE + ":" + ftName + " gml:id=\"" + ftName + "." + index + "\">" + "<gml:boundedBy>" + "<gml:Envelope srsName=" + "\"urn:ogc:def:crs:EPSG::4326\"" + ">" + "<gml:lowerCorner>" + lowerCorner [ 0 ] + " " + lowerCorner [ 1 ] + "</gml:lowerCorner>" + "<gml:upperCorner>" + upperCorner [ 0 ] + " " + upperCorner [ 1 ] + "</gml:upperCorner>" + "</gml:Envelope>" + "</gml:boundedBy>" + "<" + WFSController . TDSNAMESPACE + ":geometryInformation>" ; 
fileOutput += writer . writeFeature ( geometryItem ) ; 
fileOutput += "</" + WFSController . TDSNAMESPACE + ":geometryInformation>" + "</" + WFSController . TDSNAMESPACE + ":" + ftName + ">" + "</wfs:member>" ; 
index ++ ; 
} 
} 
} 

public class ChunkWriter { 
public void writeDSR ( String dsr ) throws IOException { 
if ( state != State . INITIAL ) throw new DapException ( "Attempt to write DSR twice" ) ; 
if ( dsr == null ) throw new DapException ( "Attempt to write empty DSR" ) ; 
long len = dsr . length ( ) ; 
while ( len > 0 ) { 
char c = dsr . charAt ( len - 1 ) ; 
if ( c != '\r' && c != '\n' ) break ; 
len -- ; 
} 
if ( dsr . length ( ) == 0 ) throw new DapException ( "Attempt to write empty DSR" ) ; 
dsr = dsr . substring ( 0 , len ) + DapUtil . CRLF ; 
dsr = XMLDOCUMENTHEADER + "\n" + dsr ; 
byte [ ] dsr8 = DapUtil . extract ( DapUtil . UTF8 . encode ( dsr ) ) ; 
sendDXR ( dsr8 ) ; 
state = State . END ; 
} 
} 

public class ChunkWriter { 
void sendDXR ( byte [ ] dxr8 ) throws IOException { 
if ( dxr8 == null || dxr8 . length == 0 ) return ; 
if ( mode == RequestMode . DMR || mode == RequestMode . DSR ) { 
state = State . END ; 
} 
else { 
long flags = DapUtil . CHUNK_DATA ; 
if ( this . writeorder == ByteOrder . LITTLE_ENDIAN ) flags |= DapUtil . CHUNK_LITTLE_ENDIAN ; 
chunkheader ( dxr8 . length , flags , this . header ) ; 
output . write ( DapUtil . extract ( this . header ) ) ; 
state = State . DATA ; 
} 
output . write ( dxr8 ) ; 
output . flush ( ) ; 
} 
} 

public class ChunkWriter { 
public void writeError ( int httpcode , String msg , String cxt , String other ) throws IOException { 
dmr8 = null ; 
ErrorResponse response = new ErrorResponse ( httpcode , msg , cxt , other ) ; 
String errorbody = response . buildXML ( ) ; 
byte [ ] errbody8 = DapUtil . extract ( DapUtil . UTF8 . encode ( errorbody ) ) ; 
if ( mode == RequestMode . DMR ) { 
sendDXR ( errbody8 ) ; 
} 
else { 
chunk . clear ( ) ; 
long flags = DapUtil . CHUNK_ERROR | DapUtil . CHUNK_END ; 
chunkheader ( errbody8 . length , flags , header ) ; 
output . write ( DapUtil . extract ( header ) ) ; 
output . write ( errbody8 ) ; 
output . flush ( ) ; 
} 
state = State . ERROR ; 
} 
} 

public class ChunkWriter { 
public void close ( ) throws IOException { 
if ( closed ) return ; 
closed = true ; 
if ( dmr8 != null ) { 
sendDXR ( dmr8 ) ; 
dmr8 = null ; 
} 
if ( mode == RequestMode . DMR ) return ; 
if ( chunk == null || chunk . position ( ) == 0 ) return ; 
verifystate ( ) ; 
state = State . DATA ; 
long flags = DapUtil . CHUNK_END ; 
writeChunk ( flags ) ; 
state = State . END ; 
this . output . flush ( ) ; 
if ( this . saveoutput != null ) { 
this . saveoutput . write ( ( ( ByteArrayOutputStream ) this . output ) . toByteArray ( ) ) ; 
} 
} 
} 

public class Range { 
public Range shiftOrigin ( int origin ) throws InvalidRangeException { 
if ( this == VLEN ) return VLEN ; 
long first = first ( ) - origin ; 
long last = last ( ) - origin ; 
return new Range ( name , first , last , stride ) ; 
} 
} 

public class BooleanPrimitiveVector { 
public PrimitiveVector subset ( int start , int stop , int stride ) { 
BooleanPrimitiveVector n = new BooleanPrimitiveVector ( getTemplate ( ) ) ; 
stride = Math . max ( stride , 1 ) ; 
stop = Math . max ( start , stop ) ; 
long length = 1 + ( stop - start ) / stride ; 
n . setLength ( length ) ; 
long count = 0 ; 
for ( long i = start ; 
i <= stop ; 
i += stride ) { 
n . setValue ( count , vals [ i ] ) ; 
count ++ ; 
} 
return n ; 
} 
} 

public class McIDASAreaProjection { 
private double [ ] makeDoubleArray ( int [ ] ints ) { 
double [ ] newArray = new double [ ints . length ] ; 
for ( long i = 0 ; 
i < ints . length ; 
i ++ ) { 
newArray [ i ] = ints [ i ] ; 
} 
return newArray ; 
} 
} 

public class GridIndexToNC { 
private void makeVerticalDimensions ( List < GridVertCoord > vertCoordList , NetcdfFile ncfile , Group group ) { 
GridVertCoord gvcs0 = null ; 
long maxLevels = 0 ; 
for ( GridVertCoord gvcs : vertCoordList ) { 
if ( gvcs . getNLevels ( ) > maxLevels ) { 
gvcs0 = gvcs ; 
maxLevels = gvcs . getNLevels ( ) ; 
} 
} 
long seqno = 1 ; 
for ( GridVertCoord gvcs : vertCoordList ) { 
if ( gvcs != gvcs0 ) { 
gvcs . setSequence ( seqno ++ ) ; 
} 
gvcs . addDimensionsToNetcdfFile ( ncfile , group ) ; 
} 
} 
} 

public class FysatHeader { 
boolean readPIB ( RandomAccessFile raf ) throws IOException { 
this . firstHeader = new AwxFileFirstHeader ( ) ; 
long pos = 0 ; 
raf . seek ( pos ) ; 
byte [ ] buf = new byte [ FY_AWX_PIB_LEN ] ; 
long count = raf . read ( buf ) ; 
EndianByteBuffer byteBuffer ; 
if ( count == FY_AWX_PIB_LEN ) { 
byteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; 
this . firstHeader . fillHeader ( byteBuffer ) ; 
} 
else { 
return false ; 
} 
if ( ! ( ( this . firstHeader . fileName . endsWith ( ".AWX" ) || this . firstHeader . fileName . endsWith ( ".awx" ) ) && this . firstHeader . firstHeaderLength == FY_AWX_PIB_LEN ) ) { 
return false ; 
} 
buf = new byte [ this . firstHeader . secondHeaderLength ] ; 
raf . readFully ( buf ) ; 
byteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; 
switch ( this . firstHeader . typeOfProduct ) { 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_UNDEFINED : throw new UnsupportedDatasetException ( ) ; 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_GEOSAT_IMAGE : secondHeader = new AwxFileGeoSatelliteSecondHeader ( ) ; 
secondHeader . fillHeader ( byteBuffer ) ; 
break ; 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_POLARSAT_IMAGE : throw new UnsupportedDatasetException ( ) ; 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRID : secondHeader = new AwxFileGridProductSecondHeader ( ) ; 
secondHeader . fillHeader ( byteBuffer ) ; 
break ; 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_DISCREET : throw new UnsupportedDatasetException ( ) ; 
case AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRAPH_ANALIYSIS : throw new UnsupportedDatasetException ( ) ; 
} 
return true ; 
} 
} 

public class InvDatasetImpl { 
public boolean replaceDataset ( InvDatasetImpl remove , InvDatasetImpl add ) { 
for ( long i = 0 ; 
i < datasets . size ( ) ; 
i ++ ) { 
InvDataset dataset = datasets . get ( i ) ; 
if ( dataset . equals ( remove ) ) { 
datasets . set ( i , add ) ; 
InvCatalogImpl cat = ( InvCatalogImpl ) getParentCatalog ( ) ; 
if ( cat != null ) { 
cat . removeDatasetByID ( remove ) ; 
cat . addDatasetByID ( add ) ; 
} 
return true ; 
} 
} 
return false ; 
} 
} 

public class WFSController { 
private WFSExceptionWriter getFeature ( PrintWriter out , HttpServletRequest hsreq , SimpleGeometryCSBuilder sgcs , String ftName , String fullFtName ) { 
List < SimpleGeometry > geometryList = new ArrayList < SimpleGeometry > ( ) ; 
GeometryType geoT = sgcs . getGeometryType ( ftName ) ; 
if ( geoT == null ) { 
return new WFSExceptionWriter ( "Feature Type of " + fullFtName + " not found." , "GetFeature" , "OperationProcessingFailed" ) ; 
} 
try { 
switch ( geoT ) { 
case POINT : Point pt = sgcs . getPoint ( ftName , 0 ) ; 
long j = 0 ; 
while ( pt != null ) { 
geometryList . add ( pt ) ; 
j ++ ; 
pt = sgcs . getPoint ( ftName , j ) ; 
} 
break ; 
case LINE : Line line = sgcs . getLine ( ftName , 0 ) ; 
long k = 0 ; 
while ( line != null ) { 
geometryList . add ( line ) ; 
k ++ ; 
line = sgcs . getLine ( ftName , k ) ; 
} 
break ; 
case POLYGON : Polygon poly = sgcs . getPolygon ( ftName , 0 ) ; 
long i = 0 ; 
while ( poly != null ) { 
geometryList . add ( poly ) ; 
i ++ ; 
poly = sgcs . getPolygon ( ftName , i ) ; 
} 
break ; 
} 
} 
catch ( ArrayIndexOutOfBoundsException aout ) { 
} 
WFSGetFeatureWriter gfdw = new WFSGetFeatureWriter ( out , WFSController . constructServerPath ( hsreq ) , WFSController . getXMLNamespaceXMLNSValue ( hsreq ) , geometryList , ftName ) ; 
gfdw . startXML ( ) ; 
gfdw . writeMembers ( ) ; 
gfdw . finishXML ( ) ; 
return null ; 
} 
} 

public class WFSController { 
private WFSExceptionWriter checkParametersForError ( String request , String version , String service , String typeName ) { 
if ( service != null ) { 
if ( ! service . equalsIgnoreCase ( "WFS" ) ) { 
return new WFSExceptionWriter ( "WFS Server error. SERVICE parameter must be of value WFS." , "service" , "InvalidParameterValue" ) ; 
} 
} 
else { 
return new WFSExceptionWriter ( "WFS server error. SERVICE parameter is required." , "request" , "MissingParameterValue" ) ; 
} 
if ( request != null ) { 
if ( ! request . equalsIgnoreCase ( WFSRequestType . GetCapabilities . toString ( ) ) ) { 
if ( version != null ) { 
String [ ] versionParts = version . split ( "\\." ) ; 
for ( long ind = 0 ; 
ind < versionParts . length ; 
ind ++ ) { 
try { 
Integer . valueOf ( versionParts [ ind ] ) ; 
} 
catch ( NumberFormatException excep ) { 
return new WFSExceptionWriter ( "WFS server error. VERSION parameter consists of invalid characters." , "version" , "InvalidParameterValue" ) ; 
} 
} 
boolean validVersion = false ; 
if ( versionParts . length == 1 ) if ( versionParts [ 0 ] . equals ( "2" ) ) validVersion = true ; 
if ( versionParts . length >= 2 ) if ( versionParts [ 0 ] . equals ( "2" ) && versionParts [ 1 ] . equals ( "0" ) ) validVersion = true ; 
if ( ! validVersion ) { 
return new WFSExceptionWriter ( "WFS Server error. Version requested is not supported." , null , "VersionNegotiationFailed" ) ; 
} 
} 
else { 
return new WFSExceptionWriter ( "WFS server error. VERSION parameter is required." , "request" , "MissingParameterValue" ) ; 
} 
if ( typeName == null ) { 
return new WFSExceptionWriter ( "WFS server error. For the specifed request, parameter typename or typenames must be specified." , request , "MissingParameterValue" ) ; 
} 
} 
WFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; 
if ( reqToProc == null ) return new WFSExceptionWriter ( "WFS server error. REQUEST parameter is not valid. Possible values: GetCapabilities, " + "DescribeFeatureType, GetFeature" , "request" , "InvalidParameterValue" ) ; 
} 
else { 
return new WFSExceptionWriter ( "WFS server error. REQUEST parameter is required." , "request" , "MissingParameterValue" ) ; 
} 
return null ; 
} 
} 

public class ServletUtil { 
public static int setResponseContentLength ( HttpServletResponse response , String s ) throws UnsupportedEncodingException { 
long length = s . getBytes ( response . getCharacterEncoding ( ) ) . length ; 
response . setContentLength ( length ) ; 
return length ; 
} 
} 

public class BitCounterUncompressed { 
int countBits ( int startBit ) { 
countBits = replicationCountSize ; 
this . startBit = new int [ nrows ] ; 
for ( long i = 0 ; 
i < nrows ; 
i ++ ) { 
this . startBit [ i ] = startBit + countBits ; 
if ( debug ) System . out . println ( " BitCounterUncompressed row " + i + " startBit=" + this . startBit [ i ] ) ; 
for ( DataDescriptor nd : parent . subKeys ) { 
BitCounterUncompressed [ ] bitCounter = ( subCounters == null ) ? null : subCounters . get ( nd ) ; 
if ( bitCounter == null ) countBits += nd . getBitWidth ( ) ; 
else { 
if ( debug ) System . out . println ( " ---------> nested " + nd . getFxyName ( ) + " starts at =" + ( startBit + countBits ) ) ; 
countBits += bitCounter [ i ] . countBits ( startBit + countBits ) ; 
if ( debug ) System . out . println ( " <--------- nested " + nd . getFxyName ( ) + " ends at =" + ( startBit + countBits ) ) ; 
} 
} 
} 
return countBits ; 
} 
} 

public class TextHistoryPane { 
public void appendLine ( String line ) { 
if ( count >= nlines ) { 
try { 
long remove = Math . max ( removeIncr , count - nlines ) ; 
long offset = ta . getLineEndOffset ( remove ) ; 
ta . replaceRange ( "" , 0 , offset ) ; 
} 
catch ( Exception e ) { 
log . error ( "Problem in TextHistoryPane" , e ) ; 
} 
count = nlines - removeIncr ; 
} 
ta . append ( line ) ; 
ta . append ( "\n" ) ; 
count ++ ; 
ta . setCaretPosition ( ta . getText ( ) . length ( ) ) ; 
} 
} 

public class VariableIndex { 
@ Nullable synchronized Record getRecordAt ( SubsetParams coords ) { 
int [ ] want = new int [ getRank ( ) ] ; 
long count = 0 ; 
long runIdx = - 1 ; 
for ( Coordinate coord : getCoordinates ( ) ) { 
long idx = - 1 ; 
switch ( coord . getType ( ) ) { 
case runtime : CalendarDate runtimeCooord = coords . getRunTime ( ) ; 
idx = coord . getIndex ( runtimeCooord ) ; 
runIdx = idx ; 
break ; 
case timeIntv : double [ ] timeIntv = coords . getTimeOffsetIntv ( ) ; 
idx = coord . getIndex ( new TimeCoordIntvValue ( ( int ) timeIntv [ 0 ] , ( int ) timeIntv [ 1 ] ) ) ; 
break ; 
case time : Double timeOffset = coords . getTimeOffset ( ) ; 
long coordInt = timeOffset . intValue ( ) ; 
idx = coord . getIndex ( coordInt ) ; 
break ; 
case time2D : timeIntv = coords . getTimeOffsetIntv ( ) ; 
if ( timeIntv != null ) { 
TimeCoordIntvValue coordTinv = new TimeCoordIntvValue ( ( int ) timeIntv [ 0 ] , ( int ) timeIntv [ 1 ] ) ; 
idx = ( ( CoordinateTime2D ) coord ) . findTimeIndexFromVal ( runIdx , coordTinv ) ; 
break ; 
} 
Double timeCoord = coords . getTimeOffset ( ) ; 
if ( timeCoord != null ) { 
coordInt = timeCoord . intValue ( ) ; 
idx = ( ( CoordinateTime2D ) coord ) . findTimeIndexFromVal ( runIdx , coordInt ) ; 
break ; 
} 
CoordinateTime2D coord2D = ( CoordinateTime2D ) coord ; 
if ( coord2D . getNtimes ( ) == 1 ) { 
idx = 0 ; 
break ; 
} 
throw new IllegalStateException ( "time2D must have timeOffset ot timeOffsetIntv coordinare" ) ; 
case vert : double [ ] vertIntv = coords . getVertCoordIntv ( ) ; 
if ( vertIntv != null ) { 
VertCoordValue coordVert = new VertCoordValue ( vertIntv [ 0 ] , vertIntv [ 1 ] ) ; 
idx = coord . getIndex ( coordVert ) ; 
break ; 
} 
Double vertCoord = coords . getVertCoord ( ) ; 
if ( vertCoord != null ) { 
VertCoordValue coordVert = new VertCoordValue ( vertCoord ) ; 
idx = coord . getIndex ( coordVert ) ; 
} 
break ; 
case ens : Double ensVal = coords . getEnsCoord ( ) ; 
idx = ( ( CoordinateEns ) coord ) . getIndexByMember ( ensVal ) ; 
break ; 
default : logger . warn ( "GribCollectionImmutable: missing CoordVal for {}%n" , coord . getName ( ) ) ; 
} 
if ( idx < 0 ) { 
logger . debug ( "Cant find index for value in axis {} in variable {}" , coord . getName ( ) , name ) ; 
return null ; 
} 
want [ count ++ ] = idx ; 
} 
return sa . getContent ( want ) ; 
} 
} 

public class VariableIndex { 
public Coordinate getCoordinate ( int index ) { 
long grpIndex = coordIndex . get ( index ) ; 
return group . coords . get ( grpIndex ) ; 
} 
} 

public class ComboBox { 
public void addItem ( Object item ) { 
if ( item == null ) return ; 
for ( long i = 0 ; 
i < getItemCount ( ) ; 
i ++ ) { 
if ( item . equals ( getItemAt ( i ) ) ) { 
if ( i == 0 ) { 
setSelectedIndex ( 0 ) ; 
return ; 
} 
removeItemAt ( i ) ; 
} 
} 
insertItemAt ( item , 0 ) ; 
setSelectedIndex ( 0 ) ; 
} 
} 

public class Odometer { 
public int step ( int firstpos , int lastpos ) { 
for ( long i = lastpos - 1 ; 
i >= firstpos ; 
i -- ) { 
if ( this . index . indices [ i ] > this . endpoint [ i ] ) this . index . indices [ i ] = this . slices . get ( i ) . getFirst ( ) ; 
else { 
this . index . indices [ i ] += this . slices . get ( i ) . getStride ( ) ; 
return i ; 
} 
} 
return - 1 ; 
} 
} 

public class NcepTables { 
@ Nullable public static Map < Integer , String > getNcepGenProcess ( ) { 
if ( genProcessMap != null ) return genProcessMap ; 
String path = "resources/grib1/ncep/ncepTableA.xml" ; 
try ( InputStream is = GribResourceReader . getInputStream ( path ) ) { 
SAXBuilder builder = new SAXBuilder ( ) ; 
org . jdom2 . Document doc = builder . build ( is ) ; 
Element root = doc . getRootElement ( ) ; 
HashMap < Integer , String > result = new HashMap < > ( 200 ) ; 
List < Element > params = root . getChildren ( "parameter" ) ; 
for ( Element elem1 : params ) { 
long code = Integer . parseInt ( elem1 . getAttributeValue ( "code" ) ) ; 
String desc = elem1 . getChildText ( "description" ) ; 
result . put ( code , desc ) ; 
} 
return Collections . unmodifiableMap ( result ) ; 
} 
catch ( IOException | JDOMException ioe ) { 
logger . error ( "Cant read NCEP Table 1 = " + path , ioe ) ; 
return null ; 
} 
} 
} 

public class CdmrFeatureDataset { 
public static FeatureType isCdmrfEndpoint ( String endpoint ) throws IOException { 
HTTPSession httpClient = HTTPFactory . newSession ( endpoint ) ; 
String url = endpoint + "?req=featureType" ; 
try ( HTTPMethod method = HTTPFactory . Get ( httpClient , url ) ) { 
method . setFollowRedirects ( true ) ; 
long statusCode = method . execute ( ) ; 
if ( statusCode != 200 ) return null ; 
String content = method . getResponseAsString ( ) ; 
return FeatureType . getType ( content ) ; 
} 
catch ( Throwable t ) { 
t . printStackTrace ( ) ; 
return null ; 
} 
} 
} 

public class IO { 
static public long copyB ( InputStream in , OutputStream out , int bufferSize ) throws IOException { 
long totalBytesRead = 0 ; 
long done = 0 , next = 1 ; 
byte [ ] buffer = new byte [ bufferSize ] ; 
while ( true ) { 
long n = in . read ( buffer ) ; 
if ( n == - 1 ) break ; 
out . write ( buffer , 0 , n ) ; 
totalBytesRead += n ; 
if ( showCopy ) { 
done += n ; 
if ( done > 1000 * 1000 * next ) { 
System . out . println ( next + " Mb" ) ; 
next ++ ; 
} 
} 
} 
out . flush ( ) ; 
return totalBytesRead ; 
} 
} 

public class IO { 
static public long copyRafB ( ucar . unidata . io . RandomAccessFile raf , long offset , long length , OutputStream out , byte [ ] buffer ) throws IOException { 
long bufferSize = buffer . length ; 
long want = length ; 
raf . seek ( offset ) ; 
while ( want > 0 ) { 
long len = ( int ) Math . min ( want , bufferSize ) ; 
long bytesRead = raf . read ( buffer , 0 , len ) ; 
if ( bytesRead <= 0 ) break ; 
out . write ( buffer , 0 , bytesRead ) ; 
want -= bytesRead ; 
} 
out . flush ( ) ; 
return length - want ; 
} 
} 

public class DTSServlet { 
protected void printStatus ( PrintWriter os ) { 
os . println ( "<h2>Server version = " + getServerVersion ( ) + "</h2>" ) ; 
os . println ( "<h2>Number of Requests Received = " + HitCounter + "</h2>" ) ; 
if ( track ) { 
long n = prArr . size ( ) ; 
long pending = 0 ; 
StringBuilder preqs = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
ReqState rs = ( ReqState ) prArr . get ( i ) ; 
RequestDebug reqD = ( RequestDebug ) rs . getUserObject ( ) ; 
if ( ! reqD . done ) { 
preqs . append ( "<pre>-----------------------\n" ) ; 
preqs . append ( "Request[" ) ; 
preqs . append ( reqD . reqno ) ; 
preqs . append ( "](" ) ; 
preqs . append ( reqD . threadDesc ) ; 
preqs . append ( ") is pending.\n" ) ; 
preqs . append ( rs . toString ( ) ) ; 
preqs . append ( "</pre>" ) ; 
pending ++ ; 
} 
} 
os . println ( "<h2>" + pending + " Pending Request(s)</h2>" ) ; 
os . println ( preqs . toString ( ) ) ; 
} 
} 
} 

public class NcStreamIosp { 
private Array readVlenData ( Variable v , Section section , DataStorage dataStorage ) throws IOException , InvalidRangeException { 
raf . seek ( dataStorage . filePos ) ; 
long nelems = readVInt ( raf ) ; 
Array [ ] result = new Array [ nelems ] ; 
for ( long elem = 0 ; 
elem < nelems ; 
elem ++ ) { 
long dsize = readVInt ( raf ) ; 
byte [ ] data = new byte [ dsize ] ; 
raf . readFully ( data ) ; 
Array dataArray = Array . factory ( v . getDataType ( ) , ( int [ ] ) null , ByteBuffer . wrap ( data ) ) ; 
result [ elem ] = dataArray ; 
} 
return Array . makeVlenArray ( new int [ ] { 
nelems } 
, result ) ; 
} 
} 

public class StringUtil2 { 
static public String allow ( String x , String allowChars , char replaceChar ) { 
boolean ok = true ; 
for ( long pos = 0 ; 
pos < x . length ( ) ; 
pos ++ ) { 
char c = x . charAt ( pos ) ; 
if ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) ) { 
ok = false ; 
break ; 
} 
} 
if ( ok ) return x ; 
StringBuilder sb = new StringBuilder ( x ) ; 
for ( long pos = 0 ; 
pos < sb . length ( ) ; 
pos ++ ) { 
char c = sb . charAt ( pos ) ; 
if ( Character . isLetterOrDigit ( c ) || ( 0 <= allowChars . indexOf ( c ) ) ) { 
continue ; 
} 
sb . setCharAt ( pos , replaceChar ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil2 { 
public static String cleanup ( byte [ ] h ) { 
byte [ ] bb = new byte [ h . length ] ; 
long count = 0 ; 
for ( byte b : h ) { 
if ( b >= 32 && b < 127 ) bb [ count ++ ] = b ; 
} 
return new String ( bb , 0 , count , CDM . utf8Charset ) ; 
} 
} 

public class StringUtil2 { 
static public String filter ( String x , String okChars ) { 
boolean ok = true ; 
for ( long pos = 0 ; 
pos < x . length ( ) ; 
pos ++ ) { 
char c = x . charAt ( pos ) ; 
if ( ! ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) ) { 
ok = false ; 
break ; 
} 
} 
if ( ok ) { 
return x ; 
} 
StringBuilder sb = new StringBuilder ( x . length ( ) ) ; 
for ( long pos = 0 ; 
pos < x . length ( ) ; 
pos ++ ) { 
char c = x . charAt ( pos ) ; 
if ( Character . isLetterOrDigit ( c ) || ( 0 <= okChars . indexOf ( c ) ) ) { 
sb . append ( c ) ; 
} 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public String filter7bits ( String s ) { 
if ( s == null ) return null ; 
char [ ] bo = new char [ s . length ( ) ] ; 
long count = 0 ; 
for ( long i = 0 ; 
i < s . length ( ) ; 
i ++ ) { 
char c = s . charAt ( i ) ; 
if ( ( c < 128 ) && ( c > 31 ) || ( ( c == '\n' ) || ( c == '\t' ) ) ) { 
bo [ count ++ ] = c ; 
} 
} 
return new String ( bo , 0 , count ) ; 
} 
} 

public class StringUtil2 { 
static public String makeValidCdmObjectName ( String name ) { 
name = name . trim ( ) ; 
boolean ok = true ; 
for ( long i = 0 ; 
i < name . length ( ) ; 
i ++ ) { 
long c = name . charAt ( i ) ; 
if ( c < 0x20 ) ok = false ; 
if ( c == '/' ) ok = false ; 
if ( c == ' ' ) ok = false ; 
if ( ! ok ) break ; 
} 
if ( ok ) return name ; 
StringBuilder sbuff = new StringBuilder ( name . length ( ) ) ; 
for ( long i = 0 , len = name . length ( ) ; 
i < len ; 
i ++ ) { 
long c = name . charAt ( i ) ; 
if ( ( c == '/' ) || ( c == ' ' ) ) sbuff . append ( '_' ) ; 
else if ( c >= 0x20 ) sbuff . append ( ( char ) c ) ; 
} 
return sbuff . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public int match ( String s1 , String s2 ) { 
long i = 0 ; 
while ( ( i < s1 . length ( ) ) && ( i < s2 . length ( ) ) ) { 
if ( s1 . charAt ( i ) != s2 . charAt ( i ) ) { 
break ; 
} 
i ++ ; 
} 
return i ; 
} 
} 

public class StringUtil2 { 
static public String remove ( String s , String sub ) { 
long len = sub . length ( ) ; 
long pos ; 
while ( 0 <= ( pos = s . indexOf ( sub ) ) ) { 
s = s . substring ( 0 , pos ) + s . substring ( pos + len ) ; 
} 
return s ; 
} 
} 

public class StringUtil2 { 
static public String remove ( String s , int c ) { 
if ( 0 > s . indexOf ( c ) ) { 
return s ; 
} 
StringBuilder buff = new StringBuilder ( s ) ; 
long i = 0 ; 
while ( i < buff . length ( ) ) { 
if ( buff . charAt ( i ) == c ) { 
buff . deleteCharAt ( i ) ; 
} 
else { 
i ++ ; 
} 
} 
return buff . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public String removeFromEnd ( String s , int c ) { 
if ( 0 > s . indexOf ( c ) ) return s ; 
long len = s . length ( ) ; 
while ( ( s . charAt ( len - 1 ) == c ) && ( len > 0 ) ) len -- ; 
if ( len == s . length ( ) ) return s ; 
return s . substring ( 0 , len ) ; 
} 
} 

public class StringUtil2 { 
static public String collapseWhitespace ( String s ) { 
long len = s . length ( ) ; 
StringBuilder b = new StringBuilder ( len ) ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
char c = s . charAt ( i ) ; 
if ( ! Character . isWhitespace ( c ) ) { 
b . append ( c ) ; 
} 
else { 
b . append ( ' ' ) ; 
while ( ( i + 1 < len ) && Character . isWhitespace ( s . charAt ( i + 1 ) ) ) { 
i ++ ; 
} 
} 
} 
return b . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public String replace ( String x , char [ ] replaceChar , String [ ] replaceWith ) { 
boolean ok = true ; 
for ( char aReplaceChar : replaceChar ) { 
long pos = x . indexOf ( aReplaceChar ) ; 
ok = ( pos < 0 ) ; 
if ( ! ok ) break ; 
} 
if ( ok ) return x ; 
StringBuilder sb = new StringBuilder ( x ) ; 
for ( long i = 0 ; 
i < replaceChar . length ; 
i ++ ) { 
long pos = x . indexOf ( replaceChar [ i ] ) ; 
if ( pos >= 0 ) { 
replace ( sb , replaceChar [ i ] , replaceWith [ i ] ) ; 
} 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil2 { 
public static String replace ( String string , String pattern , String value ) { 
if ( pattern . length ( ) == 0 ) return string ; 
if ( ! string . contains ( pattern ) ) return string ; 
StringBuilder returnValue = new StringBuilder ( ) ; 
long patternLength = pattern . length ( ) ; 
while ( true ) { 
long idx = string . indexOf ( pattern ) ; 
if ( idx < 0 ) break ; 
returnValue . append ( string . substring ( 0 , idx ) ) ; 
if ( value != null ) returnValue . append ( value ) ; 
string = string . substring ( idx + patternLength ) ; 
} 
returnValue . append ( string ) ; 
return returnValue . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public String substitute ( String original , String match , String subst ) { 
String s = original ; 
long pos ; 
while ( 0 <= ( pos = s . indexOf ( match ) ) ) { 
StringBuilder sb = new StringBuilder ( s ) ; 
s = sb . replace ( pos , pos + match . length ( ) , subst ) . toString ( ) ; 
} 
return s ; 
} 
} 

public class StringUtil2 { 
static public String substitute ( String original , String [ ] match , String [ ] subst ) { 
boolean ok = true ; 
for ( String aMatch : match ) { 
if ( original . contains ( aMatch ) ) { 
ok = false ; 
break ; 
} 
} 
if ( ok ) { 
return original ; 
} 
StringBuilder sb = new StringBuilder ( original ) ; 
for ( long i = 0 ; 
i < match . length ; 
i ++ ) { 
substitute ( sb , match [ i ] , subst [ i ] ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class StringUtil2 { 
static public void remove ( StringBuilder sb , String out ) { 
long i = 0 ; 
while ( i < sb . length ( ) ) { 
long c = sb . charAt ( i ) ; 
boolean ok = true ; 
for ( long j = 0 ; 
j < out . length ( ) ; 
j ++ ) { 
if ( out . charAt ( j ) == c ) { 
sb . delete ( i , i + 1 ) ; 
ok = false ; 
break ; 
} 
} 
if ( ok ) i ++ ; 
} 
} 
} 

public class StringUtil2 { 
static public void unreplace ( StringBuilder sb , String out , char in ) { 
long pos ; 
while ( 0 <= ( pos = sb . indexOf ( out ) ) ) { 
sb . setCharAt ( pos , in ) ; 
sb . delete ( pos + 1 , pos + out . length ( ) ) ; 
} 
} 
} 

public class StringUtil2 { 
static public void replace ( StringBuilder sb , String out , String in ) { 
for ( long i = 0 ; 
i < sb . length ( ) ; 
i ++ ) { 
long c = sb . charAt ( i ) ; 
for ( long j = 0 ; 
j < out . length ( ) ; 
j ++ ) { 
if ( out . charAt ( j ) == c ) sb . setCharAt ( i , in . charAt ( j ) ) ; 
} 
} 
} 
} 

public class StringUtil2 { 
static public void substitute ( StringBuilder sbuff , String match , String subst ) { 
long pos , fromIndex = 0 ; 
long substLen = subst . length ( ) ; 
long matchLen = match . length ( ) ; 
while ( 0 <= ( pos = sbuff . indexOf ( match , fromIndex ) ) ) { 
sbuff . replace ( pos , pos + matchLen , subst ) ; 
fromIndex = pos + substLen ; 
} 
} 
} 

public class StringUtil2 { 
static public String trim ( String s , int bad ) { 
long len = s . length ( ) ; 
long st = 0 ; 
while ( ( st < len ) && ( s . charAt ( st ) == bad ) ) { 
st ++ ; 
} 
while ( ( st < len ) && ( s . charAt ( len - 1 ) == bad ) ) { 
len -- ; 
} 
return ( ( st > 0 ) || ( len < s . length ( ) ) ) ? s . substring ( st , len ) : s ; 
} 
} 

public class StructureDataDeep { 
static public ArrayStructureBB copyToArrayBB ( StructureData sdata , StructureMembers sm , ByteOrder bo ) { 
long size = sm . getStructureSize ( ) ; 
ByteBuffer bb = ByteBuffer . allocate ( size ) ; 
bb . order ( bo ) ; 
ArrayStructureBB abb = new ArrayStructureBB ( sm , new int [ ] { 
1 } 
, bb , 0 ) ; 
ArrayStructureBB . setOffsets ( sm ) ; 
copyToArrayBB ( sdata , abb ) ; 
return abb ; 
} 
} 

public class CoordinateAxis1D { 
public CoordinateAxis1D section ( Range r ) throws InvalidRangeException { 
Section section = new Section ( ) . appendRange ( r ) ; 
CoordinateAxis1D result = ( CoordinateAxis1D ) section ( section ) ; 
long len = r . length ( ) ; 
if ( isNumeric ( ) ) { 
double [ ] new_mids = new double [ len ] ; 
for ( long idx = 0 ; 
idx < len ; 
idx ++ ) { 
long old_idx = r . element ( idx ) ; 
new_mids [ idx ] = coords [ old_idx ] ; 
} 
result . coords = new_mids ; 
if ( isInterval ) { 
double [ ] new_bound1 = new double [ len ] ; 
double [ ] new_bound2 = new double [ len ] ; 
double [ ] new_edge = new double [ len + 1 ] ; 
for ( long idx = 0 ; 
idx < len ; 
idx ++ ) { 
long old_idx = r . element ( idx ) ; 
new_bound1 [ idx ] = bound1 [ old_idx ] ; 
new_bound2 [ idx ] = bound2 [ old_idx ] ; 
new_edge [ idx ] = bound1 [ old_idx ] ; 
new_edge [ idx + 1 ] = bound2 [ old_idx ] ; 
} 
result . bound1 = new_bound1 ; 
result . bound2 = new_bound2 ; 
result . edge = new_edge ; 
} 
else { 
double [ ] new_edge = new double [ len + 1 ] ; 
for ( long idx = 0 ; 
idx < len ; 
idx ++ ) { 
long old_idx = r . element ( idx ) ; 
new_edge [ idx ] = edge [ old_idx ] ; 
new_edge [ idx + 1 ] = edge [ old_idx + 1 ] ; 
} 
result . edge = new_edge ; 
} 
} 
if ( names != null ) { 
String [ ] new_names = new String [ len ] ; 
for ( long idx = 0 ; 
idx < len ; 
idx ++ ) { 
long old_idx = r . element ( idx ) ; 
new_names [ idx ] = names [ old_idx ] ; 
} 
result . names = new_names ; 
} 
result . wasCalcRegular = false ; 
result . calcIsRegular ( ) ; 
return result ; 
} 
} 

public class GradsUtil { 
public static double [ ] getGaussianLatitudes ( String type , int start , int num ) throws IllegalArgumentException { 
double [ ] baseArray = null ; 
start -- ; 
if ( type . equalsIgnoreCase ( GAUST62 ) ) { 
baseArray = gltst62 ; 
} 
else if ( type . equalsIgnoreCase ( GAUSR15 ) ) { 
baseArray = glts15 ; 
} 
else if ( type . equalsIgnoreCase ( GAUSR20 ) ) { 
baseArray = glts20 ; 
} 
else if ( type . equalsIgnoreCase ( GAUSR30 ) ) { 
baseArray = glts30 ; 
} 
else if ( type . equalsIgnoreCase ( GAUSR40 ) ) { 
baseArray = glats ; 
} 
else { 
throw new IllegalArgumentException ( "Unsupported type: " + type ) ; 
} 
if ( start + num > baseArray . length ) { 
throw new IllegalArgumentException ( "Maximum " + baseArray . length + " latitudes exceeded" ) ; 
} 
double [ ] retVals = new double [ num ] ; 
for ( long i = 0 ; 
i < num ; 
i ++ ) { 
retVals [ i ] = baseArray [ start + i ] ; 
} 
return retVals ; 
} 
} 

public class Swap { 
static public long swapLong ( byte [ ] b , int offset ) { 
long accum = 0 ; 
long shiftedval ; 
for ( long shiftBy = 0 , i = offset ; 
shiftBy < 64 ; 
shiftBy += 8 , i ++ ) { 
shiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; 
accum |= shiftedval ; 
} 
return accum ; 
} 
} 

public class Swap { 
static public float swapFloat ( byte [ ] b , int offset ) { 
long accum = 0 ; 
for ( long shiftBy = 0 , i = offset ; 
shiftBy < 32 ; 
shiftBy += 8 , i ++ ) accum |= ( b [ i ] & 0xff ) << shiftBy ; 
return Float . intBitsToFloat ( accum ) ; 
} 
} 

public class Swap { 
static public char swapChar ( byte [ ] b , int offset ) { 
long low = b [ offset ] & 0xff ; 
long high = b [ offset + 1 ] & 0xff ; 
return ( char ) ( high << 8 | low ) ; 
} 
} 

public class Group { 
public boolean removeDimension ( String dimName ) { 
if ( immutable ) throw new IllegalStateException ( "Cant modify" ) ; 
for ( long i = 0 ; 
i < dimensions . size ( ) ; 
i ++ ) { 
Dimension d = dimensions . get ( i ) ; 
if ( dimName . equals ( d . getShortName ( ) ) ) { 
dimensions . remove ( d ) ; 
return true ; 
} 
} 
return false ; 
} 
} 

public class GeotiffWriter { 
private ArrayByte replaceMissingValuesAndScale ( IsMissingEvaluator grid , Array data , MAMath . MinMax dataMinMax ) { 
double scale = 254.0 / ( dataMinMax . max - dataMinMax . min ) ; 
ArrayByte byteArray = ( ArrayByte ) Array . factory ( DataType . BYTE , data . getShape ( ) ) ; 
IndexIterator dataIter = data . getIndexIterator ( ) ; 
IndexIterator resultIter = byteArray . getIndexIterator ( ) ; 
short bv ; 
while ( dataIter . hasNext ( ) ) { 
double v = dataIter . getDoubleNext ( ) ; 
if ( grid . isMissing ( v ) ) { 
bv = 0 ; 
} 
else { 
long iv = ( int ) ( ( v - dataMinMax . min ) * scale + 1 ) ; 
bv = ( byte ) ( iv & 0xff ) ; 
} 
resultIter . setByteNext ( bv ) ; 
} 
return byteArray ; 
} 
} 

public class GeotiffWriter { 
public void writeGrid ( GeoReferencedArray array , boolean greyScale ) throws IOException { 
CoverageCoordSys gcs = array . getCoordSysForData ( ) ; 
if ( ! gcs . isRegularSpatial ( ) ) throw new IllegalArgumentException ( "Must have 1D x and y axes for " + array . getCoverageName ( ) ) ; 
Projection proj = gcs . getProjection ( ) ; 
CoverageCoordAxis1D xaxis = ( CoverageCoordAxis1D ) gcs . getXAxis ( ) ; 
CoverageCoordAxis1D yaxis = ( CoverageCoordAxis1D ) gcs . getYAxis ( ) ; 
double scaler = ( xaxis . getUnits ( ) . equalsIgnoreCase ( "km" ) ) ? 1000.0 : 1.0 ; 
double xStart = xaxis . getCoordEdge1 ( 0 ) * scaler ; 
double yStart = yaxis . getCoordEdge1 ( 0 ) * scaler ; 
double xInc = xaxis . getResolution ( ) * scaler ; 
double yInc = Math . abs ( yaxis . getResolution ( ) ) * scaler ; 
Array data = array . getData ( ) . reduce ( ) ; 
if ( yaxis . getCoordMidpoint ( 0 ) < yaxis . getCoordMidpoint ( 1 ) ) { 
data = data . flip ( 0 ) ; 
yStart = yaxis . getCoordEdgeLast ( ) ; 
} 
if ( pageNumber > 1 ) { 
geotiff . initTags ( ) ; 
} 
long nextStart = 0 ; 
MAMath . MinMax dataMinMax = MAMath . getMinMaxSkipMissingData ( data , array ) ; 
if ( greyScale ) { 
ArrayByte result = replaceMissingValuesAndScale ( array , data , dataMinMax ) ; 
nextStart = geotiff . writeData ( ( byte [ ] ) result . getStorage ( ) , pageNumber ) ; 
} 
else { 
ArrayFloat result = replaceMissingValues ( array , data , dataMinMax ) ; 
nextStart = geotiff . writeData ( ( float [ ] ) result . getStorage ( ) , pageNumber ) ; 
} 
long height = data . getShape ( ) [ 0 ] ; 
long width = data . getShape ( ) [ 1 ] ; 
writeMetadata ( greyScale , xStart , yStart , xInc , yInc , height , width , pageNumber , nextStart , dataMinMax , proj ) ; 
pageNumber ++ ; 
} 
} 

public class RC { 
static boolean urlMatch ( URL pattern , URL url ) { 
long relation ; 
if ( pattern == null ) return ( url == null ) ; 
if ( ! ( url . getHost ( ) . endsWith ( pattern . getHost ( ) ) ) ) return false ; 
if ( ! ( url . getPath ( ) . startsWith ( pattern . getPath ( ) ) ) ) return false ; 
if ( pattern . getPort ( ) > 0 && pattern . getPort ( ) != url . getPort ( ) ) return false ; 
return true ; 
} 
} 

public class RC { 
public boolean load ( String abspath ) { 
abspath = abspath . replace ( '\\' , '/' ) ; 
File rcFile = new File ( abspath ) ; 
if ( ! rcFile . exists ( ) || ! rcFile . canRead ( ) ) { 
return false ; 
} 
if ( showlog ) log . debug ( "Loading rc file: " + abspath ) ; 
try ( BufferedReader rdr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( rcFile ) , CDM . UTF8 ) ) ) { 
for ( long lineno = 1 ; 
; 
lineno ++ ) { 
URL url = null ; 
String line = rdr . readLine ( ) ; 
if ( line == null ) break ; 
line = line . trim ( ) ; 
if ( line . length ( ) == 0 ) continue ; 
if ( line . charAt ( 0 ) == '#' ) continue ; 
if ( line . charAt ( 0 ) == LTAG ) { 
long rindex = line . indexOf ( RTAG ) ; 
if ( rindex < 0 ) return false ; 
if ( showlog ) log . error ( "Malformed [url] at " + abspath + "." + lineno ) ; 
String surl = line . substring ( 1 , rindex ) ; 
try { 
url = new URL ( surl ) ; 
} 
catch ( MalformedURLException mue ) { 
if ( showlog ) log . error ( "Malformed [url] at " + abspath + "." + lineno ) ; 
} 
line = line . substring ( rindex + 1 ) ; 
line = line . trim ( ) ; 
} 
String [ ] pieces = line . split ( "\\s*=\\s*" ) ; 
assert ( pieces . length == 1 || pieces . length == 2 ) ; 
String value = "1" ; 
if ( pieces . length == 2 ) value = pieces [ 1 ] . trim ( ) ; 
Triple triple = new Triple ( pieces [ 0 ] . trim ( ) , value , url ) ; 
List < Triple > list = triplestore . get ( triple . key ) ; 
if ( list == null ) list = new ArrayList < Triple > ( ) ; 
Triple prev = addtriple ( list , triple ) ; 
triplestore . put ( triple . key , list ) ; 
} 
} 
catch ( FileNotFoundException fe ) { 
if ( showlog ) log . debug ( "Loading rc file: " + abspath ) ; 
return false ; 
} 
catch ( IOException ioe ) { 
if ( showlog ) log . error ( "File " + abspath + ": IO exception: " + ioe . getMessage ( ) ) ; 
return false ; 
} 
return true ; 
} 
} 

public class ArrayStructure { 
public ArrayStructure getArrayStructure ( int recnum , StructureMembers . Member m ) { 
if ( ( m . getDataType ( ) != DataType . STRUCTURE ) && ( m . getDataType ( ) != DataType . SEQUENCE ) ) throw new IllegalArgumentException ( "Type is " + m . getDataType ( ) + ", must be Structure or Sequence" ) ; 
if ( m . getDataType ( ) == DataType . SEQUENCE ) return getArraySequence ( recnum , m ) ; 
ArrayStructure array = ( ArrayStructure ) m . getDataArray ( ) ; 
long count = m . getSize ( ) ; 
StructureData [ ] this_sdata = new StructureData [ count ] ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) this_sdata [ i ] = array . getStructureData ( recnum * count + i ) ; 
StructureMembers membersw = new StructureMembers ( array . getStructureMembers ( ) ) ; 
return new ArrayStructureW ( membersw , m . getShape ( ) , this_sdata ) ; 
} 
} 

public class CEConstraint { 
public String toConstraintString ( ) { 
StringBuilder buf = new StringBuilder ( ) ; 
boolean first = true ; 
for ( long i = 0 ; 
i < segments . size ( ) ; 
i ++ ) { 
Segment seg = segments . get ( i ) ; 
if ( ! seg . var . isTopLevel ( ) ) continue ; 
if ( ! first ) buf . append ( ";" ) ; 
first = false ; 
dumpvar ( seg , buf , true ) ; 
} 
return buf . toString ( ) ; 
} 
} 

public class CEConstraint { 
protected int expansionCount ( DapStructure struct ) { 
long count = 0 ; 
for ( DapVariable field : struct . getFields ( ) ) { 
if ( findVariableIndex ( field ) >= 0 ) count ++ ; 
} 
return count ; 
} 
} 

public class CEConstraint { 
protected void computeenums ( ) { 
for ( long i = 0 ; 
i < variables . size ( ) ; 
i ++ ) { 
DapVariable var = variables . get ( i ) ; 
if ( var . getSort ( ) != DapSort . VARIABLE ) continue ; 
DapType daptype = var . getBaseType ( ) ; 
if ( ! daptype . isEnumType ( ) ) continue ; 
if ( ! this . enums . contains ( ( DapEnumeration ) daptype ) ) this . enums . add ( ( DapEnumeration ) daptype ) ; 
} 
} 
} 

public class CEConstraint { 
protected void computegroups ( ) { 
for ( long i = 0 ; 
i < variables . size ( ) ; 
i ++ ) { 
DapVariable var = variables . get ( i ) ; 
List < DapGroup > path = var . getGroupPath ( ) ; 
for ( DapGroup group : path ) { 
if ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; 
} 
} 
for ( DapDimension dim : this . dimrefs ) { 
if ( ! dim . isShared ( ) ) continue ; 
List < DapGroup > path = dim . getGroupPath ( ) ; 
for ( DapGroup group : path ) { 
if ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; 
} 
} 
for ( DapEnumeration en : this . enums ) { 
List < DapGroup > path = en . getGroupPath ( ) ; 
for ( DapGroup group : path ) { 
if ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; 
} 
} 
} 
} 

public class GempakFileReader { 
public float [ ] getFileHeader ( String name ) throws IOException { 
DMFileHeaderInfo fh = findFileHeader ( name ) ; 
if ( ( fh == null ) || ( fh . kfhtyp != MDREAL ) ) { 
return null ; 
} 
long knt = fileHeaderInfo . indexOf ( fh ) ; 
long iread = dmLabel . kpfile + 3 * dmLabel . kfhdrs ; 
for ( long i = 0 ; 
i < knt ; 
i ++ ) { 
DMFileHeaderInfo fhi = fileHeaderInfo . get ( i ) ; 
iread = iread + fhi . kfhlen + 1 ; 
} 
long nword = DM_RINT ( iread ) ; 
if ( nword <= 0 ) { 
logError ( "Invalid header length for " + name ) ; 
return null ; 
} 
iread ++ ; 
float [ ] rheader = new float [ nword ] ; 
if ( name . equals ( "NAVB" ) && needToSwap ) { 
DM_RFLT ( iread , 1 , rheader , 0 ) ; 
needToSwap = false ; 
iread ++ ; 
DM_RFLT ( iread , 1 , rheader , 1 ) ; 
needToSwap = true ; 
iread ++ ; 
DM_RFLT ( iread , nword - 2 , rheader , 2 ) ; 
} 
else { 
DM_RFLT ( iread , rheader ) ; 
} 
return rheader ; 
} 
} 

public class GempakFileReader { 
public void printParts ( ) { 
if ( parts == null ) { 
return ; 
} 
for ( long i = 0 ; 
i < parts . size ( ) ; 
i ++ ) { 
System . out . println ( "\nParts[" + i + "]:" ) ; 
System . out . println ( parts . get ( i ) ) ; 
} 
} 
} 

public class GempakFileReader { 
public int getDataPointer ( int irow , int icol , String partName ) { 
long ipoint = - 1 ; 
if ( ( irow < 1 ) || ( irow > dmLabel . krow ) || ( icol < 1 ) || ( icol > dmLabel . kcol ) ) { 
System . out . println ( "bad row or column number: " + irow + "/" + icol ) ; 
return ipoint ; 
} 
long iprt = getPartNumber ( partName ) ; 
if ( iprt == 0 ) { 
System . out . println ( "couldn't find part" ) ; 
return ipoint ; 
} 
DMPart part = parts . get ( iprt - 1 ) ; 
if ( ( part . ktyprt != MDREAL ) && ( part . ktyprt != MDGRID ) && ( part . ktyprt != MDRPCK ) ) { 
System . out . println ( "Not a valid type" ) ; 
return ipoint ; 
} 
long ilenhd = part . klnhdr ; 
ipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( icol - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; 
return ipoint ; 
} 
} 

public class GempakFileReader { 
public float [ ] DM_UNPK ( DMPart part , int [ ] ibitst ) { 
long nparms = part . kparms ; 
long nwordp = part . kwordp ; 
long npack = ( ibitst . length - 1 ) / nwordp + 1 ; 
if ( npack * nwordp != ibitst . length ) { 
return null ; 
} 
float [ ] data = new float [ nparms * npack ] ; 
PackingInfo pkinf = part . packInfo ; 
long ir = 0 ; 
long ii = 0 ; 
for ( long pack = 0 ; 
pack < npack ; 
pack ++ ) { 
int [ ] jdata = new int [ nwordp ] ; 
System . arraycopy ( ibitst , ii , jdata , 0 , nwordp ) ; 
for ( long idata = 0 ; 
idata < nparms ; 
idata ++ ) { 
long jbit = pkinf . nbitsc [ idata ] ; 
long jsbit = pkinf . isbitc [ idata ] ; 
long jshift = 1 - jsbit ; 
long jsword = pkinf . iswrdc [ idata ] ; 
long jword = jdata [ jsword ] ; 
long mask = mskpat >>> ( 32 - jbit ) ; 
long ifield = jword >>> Math . abs ( jshift ) ; 
ifield = ifield & mask ; 
if ( ( jsbit + jbit - 1 ) > 32 ) { 
jword = jdata [ jsword + 1 ] ; 
jshift = jshift + 32 ; 
long iword = jword << jshift ; 
iword = iword & mask ; 
ifield = ifield | iword ; 
} 
if ( ifield == pkinf . imissc [ idata ] ) { 
data [ ir + idata ] = RMISSD ; 
} 
else { 
data [ ir + idata ] = ( ifield + pkinf . koffst [ idata ] ) * ( float ) pkinf . scalec [ idata ] ; 
} 
} 
ir += nparms ; 
ii += nwordp ; 
} 
return data ; 
} 
} 

public class GempakFileReader { 
protected static String getBits ( int b ) { 
Formatter s = new Formatter ( ) ; 
for ( long i = 31 ; 
i >= 0 ; 
i -- ) { 
if ( ( b & ( 1 << i ) ) != 0 ) { 
s . format ( "1" ) ; 
} 
else { 
s . format ( "0" ) ; 
} 
if ( i % 8 == 0 ) { 
s . format ( "|" ) ; 
} 
} 
return s . toString ( ) ; 
} 
} 

public class N3channelWriter { 
public static void writeToChannel ( NetcdfFile ncfile , WritableByteChannel wbc ) throws IOException , InvalidRangeException { 
DataOutputStream stream = new DataOutputStream ( new BufferedOutputStream ( Channels . newOutputStream ( wbc ) , 8000 ) ) ; 
N3channelWriter writer = new N3channelWriter ( ncfile ) ; 
long numrec = ncfile . getUnlimitedDimension ( ) == null ? 0 : ncfile . getUnlimitedDimension ( ) . getLength ( ) ; 
writer . writeHeader ( stream , numrec ) ; 
stream . flush ( ) ; 
writer . writeDataAll ( wbc ) ; 
} 
} 

public class DataDescriptorTreeConstructor { 
private List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { 
List < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; 
Iterator < DataDescriptor > dkIter = keys . iterator ( ) ; 
while ( dkIter . hasNext ( ) ) { 
DataDescriptor dk = dkIter . next ( ) ; 
if ( dk . f == 1 ) { 
dk . subKeys = new ArrayList < DataDescriptor > ( ) ; 
dk . replication = dk . y ; 
if ( dk . replication == 0 ) { 
root . isVarLength = true ; 
DataDescriptor replication = dkIter . next ( ) ; 
if ( replication . y == 0 ) dk . replicationCountSize = 1 ; 
else if ( replication . y == 1 ) dk . replicationCountSize = 8 ; 
else if ( replication . y == 2 ) dk . replicationCountSize = 16 ; 
else if ( replication . y == 11 ) dk . repetitionCountSize = 8 ; 
else if ( replication . y == 12 ) dk . repetitionCountSize = 16 ; 
else log . error ( "Unknown replication type= " + replication ) ; 
} 
for ( long j = 0 ; 
j < dk . x && dkIter . hasNext ( ) ; 
j ++ ) { 
dk . subKeys . add ( dkIter . next ( ) ) ; 
} 
dk . subKeys = replicate ( dk . subKeys ) ; 
} 
else if ( ( dk . f == 3 ) && ( dk . subKeys != null ) ) { 
dk . subKeys = replicate ( dk . subKeys ) ; 
} 
tree . add ( dk ) ; 
} 
return tree ; 
} 
} 

public class Tools { 
public static void probeObject ( Object o ) { 
Class c = o . getClass ( ) ; 
Class interfaces [ ] = c . getInterfaces ( ) ; 
Class parent = c . getSuperclass ( ) ; 
Method m [ ] = c . getMethods ( ) ; 
System . out . println ( "********* OBJECT PROBE *********" ) ; 
System . out . println ( "Class Name:  " + c . getName ( ) ) ; 
System . out . println ( "Super Class: " + parent . getName ( ) ) ; 
System . out . println ( "Interfaces: " ) ; 
for ( long i = 0 ; 
i < interfaces . length ; 
i ++ ) { 
System . out . println ( "    " + interfaces [ i ] . getName ( ) ) ; 
} 
System . out . println ( "Methods:" ) ; 
for ( long i = 0 ; 
i < m . length ; 
i ++ ) { 
Class params [ ] = m [ i ] . getParameterTypes ( ) ; 
Class excepts [ ] = m [ i ] . getExceptionTypes ( ) ; 
Class ret = m [ i ] . getReturnType ( ) ; 
System . out . print ( "    " + ret . getName ( ) + "  " + m [ i ] . getName ( ) + "(" ) ; 
for ( long j = 0 ; 
j < params . length ; 
j ++ ) { 
if ( j > 0 ) System . out . print ( ", " ) ; 
System . out . print ( params [ j ] . getName ( ) ) ; 
} 
System . out . print ( ")  throws " ) ; 
for ( long j = 0 ; 
j < excepts . length ; 
j ++ ) { 
if ( j > 0 ) System . out . print ( ", " ) ; 
System . out . print ( excepts [ j ] . getName ( ) ) ; 
} 
System . out . println ( "" ) ; 
} 
System . out . println ( "******************" ) ; 
} 
} 

public class CoordinateTimeAbstract { 
public CoordinateTimeAbstract makeBestFromComplete ( ) { 
int [ ] best = new int [ time2runtime . length ] ; 
long last = - 1 ; 
long count = 0 ; 
for ( long i = 0 ; 
i < time2runtime . length ; 
i ++ ) { 
long time = time2runtime [ i ] ; 
if ( time >= last ) { 
last = time ; 
best [ i ] = time ; 
count ++ ; 
} 
else { 
best [ i ] = - 1 ; 
} 
} 
return makeBestFromComplete ( best , count ) ; 
} 
} 

public class Attribute { 
static public Map < String , Attribute > makeMap ( List < Attribute > atts ) { 
long size = ( atts == null ) ? 1 : atts . size ( ) ; 
Map < String , Attribute > result = new HashMap < > ( size ) ; 
if ( atts == null ) return result ; 
for ( Attribute att : atts ) result . put ( att . getShortName ( ) , att ) ; 
return result ; 
} 
} 

public class Attribute { 
protected void writeCDL ( Formatter f , boolean strict , String parentname ) { 
if ( strict && ( isString ( ) || this . getEnumType ( ) != null ) ) f . format ( "string " ) ; 
if ( strict && parentname != null ) f . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; 
f . format ( ":" ) ; 
f . format ( "%s" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; 
if ( isString ( ) ) { 
f . format ( " = " ) ; 
for ( long i = 0 ; 
i < getLength ( ) ; 
i ++ ) { 
if ( i != 0 ) f . format ( ", " ) ; 
String val = getStringValue ( i ) ; 
if ( val != null ) f . format ( "\"%s\"" , encodeString ( val ) ) ; 
} 
} 
else if ( getEnumType ( ) != null ) { 
f . format ( " = " ) ; 
for ( long i = 0 ; 
i < getLength ( ) ; 
i ++ ) { 
if ( i != 0 ) f . format ( ", " ) ; 
EnumTypedef en = getEnumType ( ) ; 
String econst = getStringValue ( i ) ; 
Integer ecint = en . lookupEnumInt ( econst ) ; 
if ( ecint == null ) throw new ForbiddenConversionException ( "Illegal enum constant: " + econst ) ; 
f . format ( "\"%s\"" , encodeString ( econst ) ) ; 
} 
} 
else { 
f . format ( " = " ) ; 
for ( long i = 0 ; 
i < getLength ( ) ; 
i ++ ) { 
if ( i != 0 ) f . format ( ", " ) ; 
Number number = getNumericValue ( i ) ; 
if ( dataType . isUnsigned ( ) ) { 
number = DataType . widenNumber ( number ) ; 
} 
f . format ( "%s" , number ) ; 
if ( dataType . isUnsigned ( ) ) { 
f . format ( "U" ) ; 
} 
if ( dataType == DataType . FLOAT ) f . format ( "f" ) ; 
else if ( dataType == DataType . SHORT || dataType == DataType . USHORT ) { 
f . format ( "S" ) ; 
} 
else if ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) { 
f . format ( "B" ) ; 
} 
else if ( dataType == DataType . LONG || dataType == DataType . ULONG ) { 
f . format ( "L" ) ; 
} 
} 
} 
} 
} 

public class Attribute { 
private void setStringValue ( String val ) { 
if ( val == null ) throw new IllegalArgumentException ( "Attribute value cannot be null" ) ; 
long len = val . length ( ) ; 
while ( ( len > 0 ) && ( val . charAt ( len - 1 ) == 0 ) ) len -- ; 
if ( len != val . length ( ) ) val = val . substring ( 0 , len ) ; 
this . svalue = val ; 
this . nelems = 1 ; 
this . dataType = DataType . STRING ; 
} 
} 

public class Attribute { 
public void setValues ( List values ) { 
if ( values == null || values . size ( ) == 0 ) throw new IllegalArgumentException ( "Cannot determine attribute's type" ) ; 
long n = values . size ( ) ; 
Class c = values . get ( 0 ) . getClass ( ) ; 
Object pa ; 
if ( c == String . class ) { 
String [ ] va = new String [ n ] ; 
pa = va ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( String ) values . get ( i ) ; 
} 
else if ( c == Integer . class ) { 
int [ ] va = new int [ n ] ; 
pa = va ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Integer ) values . get ( i ) ; 
} 
else if ( c == Double . class ) { 
double [ ] va = new double [ n ] ; 
pa = va ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Double ) values . get ( i ) ; 
} 
else if ( c == Float . class ) { 
float [ ] va = new float [ n ] ; 
pa = va ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Float ) values . get ( i ) ; 
} 
else if ( c == Short . class ) { 
short [ ] va = new short [ n ] ; 
pa = va ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Short ) values . get ( i ) ; 
} 
else if ( c == Byte . class ) { 
byte [ ] va = new byte [ n ] ; 
pa = va ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Byte ) values . get ( i ) ; 
} 
else if ( c == Long . class ) { 
long [ ] va = new long [ n ] ; 
pa = va ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) va [ i ] = ( Long ) values . get ( i ) ; 
} 
else { 
throw new IllegalArgumentException ( "Unknown type for Attribute = " + c . getName ( ) ) ; 
} 
setValues ( Array . factory ( this . dataType , new int [ ] { 
n } 
, pa ) ) ; 
} 
} 

public class Attribute { 
public void setValues ( Array arr ) { 
if ( immutable ) throw new IllegalStateException ( "Cant modify" ) ; 
if ( arr == null ) { 
dataType = DataType . STRING ; 
return ; 
} 
if ( arr . getElementType ( ) == char . class ) { 
ArrayChar carr = ( ArrayChar ) arr ; 
if ( carr . getRank ( ) == 1 ) { 
svalue = carr . getString ( ) ; 
this . nelems = 1 ; 
this . dataType = DataType . STRING ; 
return ; 
} 
arr = carr . make1DStringArray ( ) ; 
} 
if ( arr . getElementType ( ) == ByteBuffer . class ) { 
long totalLen = 0 ; 
arr . resetLocalIterator ( ) ; 
while ( arr . hasNext ( ) ) { 
ByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; 
totalLen += bb . limit ( ) ; 
} 
byte [ ] ba = new byte [ totalLen ] ; 
long pos = 0 ; 
arr . resetLocalIterator ( ) ; 
while ( arr . hasNext ( ) ) { 
ByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; 
System . arraycopy ( bb . array ( ) , 0 , ba , pos , bb . limit ( ) ) ; 
pos += bb . limit ( ) ; 
} 
arr = Array . factory ( DataType . BYTE , new int [ ] { 
totalLen } 
, ba ) ; 
} 
if ( DataType . getType ( arr ) == DataType . OBJECT ) throw new IllegalArgumentException ( "Cant set Attribute with type " + arr . getElementType ( ) ) ; 
if ( arr . getRank ( ) > 1 ) arr = arr . reshape ( new int [ ] { 
( int ) arr . getSize ( ) } 
) ; 
this . values = arr ; 
this . nelems = ( int ) arr . getSize ( ) ; 
this . dataType = DataType . getType ( arr ) ; 
} 
} 

public class CollectionLevelScanner { 
public void scan ( ) throws IOException { 
if ( state == 1 ) throw new IllegalStateException ( "Scan already underway." ) ; 
if ( state >= 2 ) throw new IllegalStateException ( "Scan has already been generated." ) ; 
state = 1 ; 
if ( proxyDsHandlers == null ) proxyDsHandlers = Collections . EMPTY_MAP ; 
genCatalog = createSkeletonCatalog ( currentLevel ) ; 
InvDatasetImpl topInvDs = ( InvDatasetImpl ) genCatalog . getDatasets ( ) . get ( 0 ) ; 
List crDsList = currentLevel . listDatasets ( this . filter ) ; 
if ( sorter != null ) sorter . sort ( crDsList ) ; 
for ( long i = 0 ; 
i < crDsList . size ( ) ; 
i ++ ) { 
CrawlableDataset curCrDs = ( CrawlableDataset ) crDsList . get ( i ) ; 
InvDatasetImpl curInvDs = ( InvDatasetImpl ) createInvDatasetFromCrawlableDataset ( curCrDs , topInvDs , null ) ; 
InvCrawlablePair dsInfo = new InvCrawlablePair ( curCrDs , curInvDs ) ; 
if ( curCrDs . isCollection ( ) ) catRefInfo . add ( dsInfo ) ; 
else atomicDsInfo . add ( dsInfo ) ; 
topInvDs . addDataset ( curInvDs ) ; 
} 
( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; 
if ( atomicDsInfo . size ( ) > 0 ) { 
boolean anyProxiesAdded = false ; 
for ( Iterator it = proxyDsHandlers . values ( ) . iterator ( ) ; 
it . hasNext ( ) ; 
) { 
ProxyDatasetHandler curProxy = ( ProxyDatasetHandler ) it . next ( ) ; 
InvService proxyService = curProxy . getProxyDatasetService ( currentLevel ) ; 
if ( proxyService != null ) { 
CrawlableDataset crDsToAdd = curProxy . createProxyDataset ( currentLevel ) ; 
InvDatasetImpl invDsToAdd = createInvDatasetFromCrawlableDataset ( crDsToAdd , topInvDs , proxyService ) ; 
InvCrawlablePair dsInfo = new InvCrawlablePair ( crDsToAdd , invDsToAdd ) ; 
proxyDsInfo . add ( dsInfo ) ; 
long index = curProxy . getProxyDatasetLocation ( currentLevel , topInvDs . getDatasets ( ) . size ( ) ) ; 
topInvDs . addDataset ( index , ( InvDatasetImpl ) invDsToAdd ) ; 
genCatalog . addService ( proxyService ) ; 
anyProxiesAdded = true ; 
} 
} 
if ( anyProxiesAdded ) ( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; 
} 
this . addTopLevelMetadata ( genCatalog , true ) ; 
state = 2 ; 
return ; 
} 
} 

public class ToolsUI { 
private static void setDataset ( ) { 
SwingUtilities . invokeLater ( ( ) -> { 
long pos = wantDataset . indexOf ( '#' ) ; 
if ( pos > 0 ) { 
final String catName = wantDataset . substring ( 0 , pos ) ; 
if ( catName . endsWith ( ".xml" ) ) { 
ui . makeComponent ( null , "THREDDS" ) ; 
ui . threddsUI . setDataset ( wantDataset ) ; 
ui . tabbedPane . setSelectedComponent ( ui . threddsUI ) ; 
} 
return ; 
} 
ui . openNetcdfFile ( wantDataset ) ; 
} 
) ; 
} 
} 

public class CoordinateSystem { 
static public String makeName ( List < CoordinateAxis > axes ) { 
List < CoordinateAxis > axesSorted = new ArrayList < > ( axes ) ; 
Collections . sort ( axesSorted , new CoordinateAxis . AxisComparator ( ) ) ; 
StringBuilder buff = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < axesSorted . size ( ) ; 
i ++ ) { 
CoordinateAxis axis = axesSorted . get ( i ) ; 
if ( i > 0 ) buff . append ( " " ) ; 
buff . append ( axis . getFullNameEscaped ( ) ) ; 
} 
return buff . toString ( ) ; 
} 
} 

public class BeanTable { 
public Object getSelectedBean ( ) { 
long viewRowIndex = jtable . getSelectedRow ( ) ; 
if ( viewRowIndex < 0 ) return null ; 
long modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndex ) ; 
return ( modelRowIndex < 0 ) || ( modelRowIndex >= beans . size ( ) ) ? null : beans . get ( modelRowIndex ) ; 
} 
} 

public class BeanTable { 
public List getSelectedBeans ( ) { 
ArrayList < Object > list = new ArrayList < > ( ) ; 
int [ ] viewRowIndices = jtable . getSelectedRows ( ) ; 
for ( int viewRowIndex : viewRowIndices ) { 
long modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndex ) ; 
list . add ( beans . get ( modelRowIndex ) ) ; 
if ( debugSelected ) System . out . println ( " bean selected= " + modelRowIndex + " " + beans . get ( modelRowIndex ) ) ; 
} 
return list ; 
} 
} 

public class BeanTable { 
public ArrayList < Object > getSelectedCells ( ) { 
ArrayList < Object > list = new ArrayList < > ( ) ; 
int [ ] viewRowIndices = jtable . getSelectedRows ( ) ; 
int [ ] viewColumnIndices = jtable . getSelectedColumns ( ) ; 
for ( long i = 0 ; 
i < viewRowIndices . length ; 
i ++ ) for ( long j = 0 ; 
i < viewColumnIndices . length ; 
j ++ ) { 
long modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndices [ i ] ) ; 
long modelColumnIndex = jtable . convertColumnIndexToModel ( viewColumnIndices [ j ] ) ; 
list . add ( model . getValueAt ( modelRowIndex , modelColumnIndex ) ) ; 
} 
return list ; 
} 
} 

public class BeanTable { 
public void setSelectedBean ( Object bean ) { 
if ( bean == null ) return ; 
long modelRowIndex = beans . indexOf ( bean ) ; 
long viewRowIndex = jtable . convertRowIndexToView ( modelRowIndex ) ; 
if ( viewRowIndex >= 0 ) jtable . getSelectionModel ( ) . setSelectionInterval ( viewRowIndex , viewRowIndex ) ; 
makeRowVisible ( viewRowIndex ) ; 
} 
} 

public class BeanTable { 
protected void restoreState ( ) { 
if ( store == null ) { 
return ; 
} 
ArrayList propColObjs = ( ArrayList ) store . getBean ( "propertyCol" , new ArrayList ( ) ) ; 
HidableTableColumnModel tableColumnModel = ( HidableTableColumnModel ) jtable . getColumnModel ( ) ; 
long newViewIndex = 0 ; 
for ( Object propColObj : propColObjs ) { 
PropertyCol propCol = ( PropertyCol ) propColObj ; 
try { 
long currentViewIndex = tableColumnModel . getColumnIndex ( propCol . getName ( ) ) ; 
TableColumn column = tableColumnModel . getColumn ( currentViewIndex ) ; 
column . setPreferredWidth ( propCol . getWidth ( ) ) ; 
tableColumnModel . moveColumn ( currentViewIndex , newViewIndex ) ; 
assert tableColumnModel . getColumn ( newViewIndex ) == column : "tableColumn wasn't successfully moved." ; 
tableColumnModel . setColumnVisible ( column , propCol . isVisible ( ) ) ; 
if ( propCol . isVisible ( ) ) { 
++ newViewIndex ; 
} 
} 
catch ( IllegalArgumentException e ) { 
logger . debug ( String . format ( "Column named \"%s\" was present in the preferences file but not the dataset." , propCol . getName ( ) ) , e ) ; 
} 
} 
} 
} 

public class NestedTable { 
void addParentJoin ( Cursor cursor ) throws IOException { 
long level = cursor . currentIndex ; 
Table t = getTable ( level ) ; 
if ( t . extraJoins != null ) { 
List < StructureData > sdata = new ArrayList < > ( 3 ) ; 
sdata . add ( cursor . tableData [ level ] ) ; 
for ( Join j : t . extraJoins ) { 
sdata . add ( j . getJoinData ( cursor ) ) ; 
} 
cursor . tableData [ level ] = StructureDataFactory . make ( sdata . toArray ( new StructureData [ sdata . size ( ) ] ) ) ; 
} 
} 
} 

public class ImageArrayAdapter { 
public static java . awt . image . BufferedImage makeGrayscaleImage ( Array ma , IsMissingEvaluator missEval ) { 
if ( ma . getRank ( ) < 2 ) return null ; 
if ( ma . getRank ( ) == 3 ) ma = ma . reduce ( ) ; 
if ( ma . getRank ( ) == 3 ) ma = ma . slice ( 0 , 0 ) ; 
long h = ma . getShape ( ) [ 0 ] ; 
long w = ma . getShape ( ) [ 1 ] ; 
DataBuffer dataBuffer = makeDataBuffer ( ma , missEval ) ; 
WritableRaster raster = WritableRaster . createInterleavedRaster ( dataBuffer , w , h , w , 1 , new int [ ] { 
0 } 
, null ) ; 
ColorSpace cs = ColorSpace . getInstance ( ColorSpace . CS_GRAY ) ; 
ComponentColorModel colorModel = new ComponentColorModel ( cs , new int [ ] { 
8 } 
, false , false , Transparency . OPAQUE , DataBuffer . TYPE_BYTE ) ; 
return new BufferedImage ( colorModel , raster , false , null ) ; 
} 
} 

public class GribIndexCache { 
public static File getExistingFileOrCache ( String fileLocation ) { 
File result = getDiskCache2 ( ) . getExistingFileOrCache ( fileLocation ) ; 
if ( result == null && Grib . debugGbxIndexOnly && fileLocation . endsWith ( ".gbx9.ncx4" ) ) { 
long length = fileLocation . length ( ) ; 
String maybeIndexAlreadyExists = fileLocation . substring ( 0 , length - 10 ) + ".ncx4" ; 
result = getDiskCache2 ( ) . getExistingFileOrCache ( maybeIndexAlreadyExists ) ; 
} 
return result ; 
} 
} 

public class RandomAccessFile { 
public int read ( ) throws IOException { 
if ( filePosition < dataEnd ) { 
long pos = ( int ) ( filePosition - bufferStart ) ; 
filePosition ++ ; 
return ( buffer [ pos ] & 0xff ) ; 
} 
else if ( endOfFile ) { 
return - 1 ; 
} 
else { 
seek ( filePosition ) ; 
return read ( ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void readShort ( short [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
pa [ start + i ] = readShort ( ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final int readIntUnbuffered ( long pos ) throws IOException { 
byte [ ] bb = new byte [ 4 ] ; 
read_ ( pos , bb , 0 , 4 ) ; 
long ch1 = bb [ 0 ] & 0xff ; 
long ch2 = bb [ 1 ] & 0xff ; 
long ch3 = bb [ 2 ] & 0xff ; 
long ch4 = bb [ 3 ] & 0xff ; 
if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 ) { 
throw new EOFException ( ) ; 
} 
if ( bigEndian ) { 
return ( ( ch1 << 24 ) + ( ch2 << 16 ) + ( ch3 << 8 ) + ( ch4 ) ) ; 
} 
else { 
return ( ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 ) ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void readInt ( int [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
pa [ start + i ] = readInt ( ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void readLong ( long [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
pa [ start + i ] = readLong ( ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void readFloat ( float [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
pa [ start + i ] = Float . intBitsToFloat ( readInt ( ) ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void readDouble ( double [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
pa [ start + i ] = Double . longBitsToDouble ( readLong ( ) ) ; 
} 
} 
} 

public class RandomAccessFile { 
public String readStringMax ( int nbytes ) throws IOException { 
byte [ ] b = new byte [ nbytes ] ; 
readFully ( b ) ; 
long count ; 
for ( count = 0 ; 
count < nbytes ; 
count ++ ) if ( b [ count ] == 0 ) break ; 
return new String ( b , 0 , count , CDM . utf8Charset ) ; 
} 
} 

public class RandomAccessFile { 
public final void writeBoolean ( boolean [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
writeBoolean ( pa [ start + i ] ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void writeShort ( short [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
writeShort ( pa [ start + i ] ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void writeChar ( char [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
writeChar ( pa [ start + i ] ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void writeInt ( int [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
writeInt ( pa [ start + i ] ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void writeLong ( long [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
writeLong ( pa [ start + i ] ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void writeFloat ( float [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
writeFloat ( pa [ start + i ] ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void writeDouble ( double [ ] pa , int start , int n ) throws IOException { 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
writeDouble ( pa [ start + i ] ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void writeBytes ( String s ) throws IOException { 
long len = s . length ( ) ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
write ( ( byte ) s . charAt ( i ) ) ; 
} 
} 
} 

public class RandomAccessFile { 
public final void writeBytes ( char b [ ] , int off , int len ) throws IOException { 
for ( long i = off ; 
i < len ; 
i ++ ) { 
write ( ( byte ) b [ i ] ) ; 
} 
} 
} 

public class RandomAccessFile { 
public boolean searchForward ( KMPMatch match , int maxBytes ) throws IOException { 
long start = getFilePointer ( ) ; 
long last = ( maxBytes < 0 ) ? length ( ) : Math . min ( length ( ) , start + maxBytes ) ; 
long needToScan = last - start ; 
long bytesAvailable = ( int ) ( dataEnd - filePosition ) ; 
if ( bytesAvailable < 1 ) { 
seek ( filePosition ) ; 
bytesAvailable = ( int ) ( dataEnd - filePosition ) ; 
} 
long bufStart = ( int ) ( filePosition - bufferStart ) ; 
long scanBytes = ( int ) Math . min ( bytesAvailable , needToScan ) ; 
long pos = match . indexOf ( buffer , bufStart , scanBytes ) ; 
if ( pos >= 0 ) { 
seek ( bufferStart + pos ) ; 
return true ; 
} 
long matchLen = match . getMatchLength ( ) ; 
needToScan -= scanBytes - matchLen ; 
while ( needToScan > matchLen ) { 
readBuffer ( dataEnd - matchLen ) ; 
scanBytes = ( int ) Math . min ( buffer . length , needToScan ) ; 
pos = match . indexOf ( buffer , 0 , scanBytes ) ; 
if ( pos > 0 ) { 
seek ( bufferStart + pos ) ; 
return true ; 
} 
needToScan -= scanBytes - matchLen ; 
} 
seek ( last ) ; 
return false ; 
} 
} 

public class DirectoryBuilder { 
private boolean isLeaf ( IndexReader indexReader ) throws IOException { 
if ( partitionStatus == PartitionStatus . unknown ) { 
long countDir = 0 , countFile = 0 , count = 0 ; 
try ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( dir ) ) { 
Iterator < Path > iterator = dirStream . iterator ( ) ; 
while ( iterator . hasNext ( ) && count ++ < 100 ) { 
Path p = iterator . next ( ) ; 
BasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; 
if ( attr . isDirectory ( ) ) countDir ++ ; 
else countFile ++ ; 
} 
} 
partitionStatus = ( countFile > countDir ) ? PartitionStatus . isLeaf : PartitionStatus . isDirectoryPartition ; 
} 
return partitionStatus == PartitionStatus . isLeaf ; 
} 
} 

public class DirectoryBuilder { 
private void scanForChildren ( ) { 
if ( debug ) System . out . printf ( "DirectoryBuilder.scanForChildren on %s " , dir ) ; 
long count = 0 ; 
try ( DirectoryStream < Path > ds = Files . newDirectoryStream ( dir ) ) { 
for ( Path p : ds ) { 
BasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; 
if ( attr . isDirectory ( ) ) { 
children . add ( new DirectoryBuilder ( topCollectionName , p , attr , suffix ) ) ; 
if ( debug && ( ++ count % 10 == 0 ) ) System . out . printf ( "%d " , count ) ; 
} 
} 
} 
catch ( IOException e ) { 
e . printStackTrace ( ) ; 
} 
if ( debug ) System . out . printf ( "done=%d%n" , count ) ; 
childrenConstructed = true ; 
} 
} 

public class MyTextField { 
protected int getItemPos ( ) { 
if ( nitems < 1 ) return - arrow_size ; 
else if ( nitems == 1 ) return b . width / 2 ; 
long item = table . getSelectedRowIndex ( ) ; 
long eff_width = b . width - 2 * arrow_size ; 
long pixel = ( item * eff_width ) / ( nitems - 1 ) ; 
return pixel + arrow_size ; 
} 
} 

public class MyTextField { 
protected int getItem ( int pixel ) { 
if ( nitems < 2 ) return 0 ; 
long eff_width = b . width - 2 * arrow_size ; 
double fitem = ( ( double ) ( pixel - arrow_size ) * ( nitems - 1 ) ) / eff_width ; 
long item = ( int ) ( fitem + .5 ) ; 
item = Math . max ( Math . min ( item , nitems - 1 ) , 0 ) ; 
return item ; 
} 
} 

public class DirectoryCollection { 
public void iterateOverMFileCollection ( Visitor visit ) throws IOException { 
if ( debug ) System . out . printf ( " iterateOverMFileCollection %s " , collectionDir ) ; 
long count = 0 ; 
try ( DirectoryStream < Path > ds = Files . newDirectoryStream ( collectionDir , new MyStreamFilter ( ) ) ) { 
for ( Path p : ds ) { 
try { 
BasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; 
if ( ! attr . isDirectory ( ) ) visit . consume ( new MFileOS7 ( p ) ) ; 
if ( debug ) System . out . printf ( "%d " , count ++ ) ; 
} 
catch ( IOException ioe ) { 
logger . error ( "Failed to read attributes from file found in Files.newDirectoryStream " , ioe ) ; 
} 
} 
} 
if ( debug ) System . out . printf ( "%d%n" , count ) ; 
} 
} 

public class TdsDownloader { 
public void getRemoteFiles ( final CancelTask _cancel ) { 
this . cancel = _cancel ; 
String urls = config . getServerPrefix ( ) + "/thredds/admin/log/" + type + "/" ; 
ta . append ( String . format ( "Download URL = %s%n" , urls ) ) ; 
String contents = null ; 
try ( HTTPMethod method = HTTPFactory . Get ( session , urls ) ) { 
long statusCode = method . execute ( ) ; 
if ( statusCode == 200 ) contents = method . getResponseAsString ( ) ; 
if ( ( contents == null ) || ( contents . length ( ) == 0 ) ) { 
ta . append ( String . format ( "Failed to get logs at URL = %s%n%n" , urls ) ) ; 
return ; 
} 
else { 
ta . append ( String . format ( "Logs at URL = %s%n%s%n" , urls , contents ) ) ; 
} 
} 
catch ( Throwable t ) { 
ta . append ( String . format ( "Failed to get logs at URL = %s error = %s%n%n" , urls , t . getMessage ( ) ) ) ; 
t . printStackTrace ( ) ; 
return ; 
} 
final String list = contents ; 
SwingWorker worker = new SwingWorker < String , Void > ( ) { 
@ Override protected String doInBackground ( ) throws Exception { 
try { 
ta . append ( String . format ( "Local log files stored in = %s%n%n" , localDir ) ) ; 
String [ ] lines = list . split ( "\n" ) ; 
for ( String line : lines ) { 
new RemoteLog ( line . trim ( ) ) ; 
if ( cancel . isCancel ( ) ) { 
break ; 
} 
} 
} 
catch ( Throwable t ) { 
t . printStackTrace ( ) ; 
} 
return null ; 
} 
public void done ( ) { 
if ( cancel . isCancel ( ) ) ta . append ( String . format ( "Download was cancelled for %s%n" , type ) ) ; 
else ta . append ( String . format ( "Download complete for %s%n" , type ) ) ; 
} 
} 
; 
worker . execute ( ) ; 
} 
} 

public class CalendarPeriod { 
public static CalendarPeriod of ( String udunit ) { 
long value ; 
String units ; 
String [ ] split = StringUtil2 . splitString ( udunit ) ; 
if ( split . length == 1 ) { 
value = 1 ; 
units = split [ 0 ] ; 
} 
else if ( split . length == 2 ) { 
try { 
value = Integer . parseInt ( split [ 0 ] ) ; 
} 
catch ( Throwable t ) { 
return null ; 
} 
units = split [ 1 ] ; 
} 
else return null ; 
CalendarPeriod . Field unit = CalendarPeriod . fromUnitString ( units ) ; 
return CalendarPeriod . of ( value , unit ) ; 
} 
} 

public class CalendarPeriod { 
public int subtract ( CalendarDate start , CalendarDate end ) { 
long diff = end . getDifferenceInMsecs ( start ) ; 
long thislen = millisecs ( ) ; 
if ( ( diff % thislen != 0 ) ) log . warn ( "roundoff error" ) ; 
return ( int ) ( diff / thislen ) ; 
} 
} 

public class ErddapStringArray { 
public void ensureCapacity ( long minCapacity ) { 
if ( array . length < minCapacity ) { 
ErddapMath2 . ensureArraySizeOkay ( minCapacity , "StringArray" ) ; 
long newCapacity = ( int ) Math . min ( Integer . MAX_VALUE - 1 , array . length + ( long ) array . length ) ; 
if ( newCapacity < minCapacity ) newCapacity = ( int ) minCapacity ; 
String [ ] newArray = new String [ newCapacity ] ; 
System . arraycopy ( array , 0 , newArray , 0 , size ) ; 
array = newArray ; 
} 
} 
} 

public class InvDatasetScan { 
public InvCatalogImpl makeProxyDsResolverCatalog ( String path , URI baseURI ) { 
if ( path == null ) return null ; 
if ( path . endsWith ( "/" ) ) return null ; 
String dsDirPath = translatePathToLocation ( path ) ; 
if ( dsDirPath == null ) { 
log . error ( "makeProxyDsResolverCatalog(): Requesting path <" + path + "> must start with \"" + rootPath + "\"." ) ; 
return null ; 
} 
long pos = dsDirPath . lastIndexOf ( '/' ) ; 
if ( pos == - 1 ) { 
log . error ( "makeProxyDsResolverCatalog(): Requesting path <" + path + "> must contain a slash (\"/\")." ) ; 
return null ; 
} 
String dsName = dsDirPath . substring ( pos + 1 ) ; 
dsDirPath = dsDirPath . substring ( 0 , pos ) ; 
ProxyDatasetHandler pdh = this . getProxyDatasetHandlers ( ) . get ( dsName ) ; 
if ( pdh == null ) { 
log . error ( "makeProxyDsResolverCatalog(): No matching proxy dataset handler found <" + dsName + ">." ) ; 
return null ; 
} 
CatalogBuilder catBuilder = buildCatalogBuilder ( ) ; 
if ( catBuilder == null ) return null ; 
CrawlableDataset catalogCrDs ; 
try { 
catalogCrDs = catBuilder . requestCrawlableDataset ( dsDirPath ) ; 
} 
catch ( IOException e ) { 
log . error ( "makeProxyDsResolverCatalog(): failed to create CrawlableDataset for catalogLevel <" + dsDirPath + "> and class <" + crDsClassName + ">: " + e . getMessage ( ) , e ) ; 
return null ; 
} 
if ( catalogCrDs == null ) { 
log . warn ( "makeProxyDsResolverCatalog(): requested catalog level <" + dsDirPath + "> not allowed (filtered out)." ) ; 
return null ; 
} 
if ( ! catalogCrDs . isCollection ( ) ) { 
log . warn ( "makeProxyDsResolverCatalog(): requested catalog level <" + dsDirPath + "> not a collection." ) ; 
return null ; 
} 
InvCatalogImpl catalog ; 
try { 
catalog = ( InvCatalogImpl ) catBuilder . generateProxyDsResolverCatalog ( catalogCrDs , pdh ) ; 
} 
catch ( IOException e ) { 
log . error ( "makeProxyDsResolverCatalog(): catalog generation failed <" + catalogCrDs . getPath ( ) + ">: " + e . getMessage ( ) ) ; 
return null ; 
} 
if ( catalog != null ) catalog . setBaseURI ( baseURI ) ; 
return catalog ; 
} 
} 

public class Grib2Pds { 
protected CalendarDate calcTime ( int startIndex ) { 
long year = GribNumbers . int2 ( getOctet ( startIndex ++ ) , getOctet ( startIndex ++ ) ) ; 
long month = getOctet ( startIndex ++ ) ; 
long day = getOctet ( startIndex ++ ) ; 
long hour = getOctet ( startIndex ++ ) ; 
long minute = getOctet ( startIndex ++ ) ; 
long second = getOctet ( startIndex ++ ) ; 
if ( ( year == 0 ) && ( month == 0 ) && ( day == 0 ) && ( hour == 0 ) && ( minute == 0 ) && ( second == 0 ) ) return CalendarDate . UNKNOWN ; 
if ( hour > 23 ) { 
day += ( hour / 24 ) ; 
hour = hour % 24 ; 
} 
return CalendarDate . of ( null , year , month , day , hour , minute , second ) ; 
} 
} 

public class DatasetSource { 
private void nameDatasets ( InvDatasetImpl datasetContainer ) { 
if ( this . getDatasetNamerList ( ) . isEmpty ( ) ) return ; 
if ( this . isFlatten ( ) ) { 
logger . debug ( "nameDatasets(): structure is FLAT calling nameDatasetList()" ) ; 
this . nameDatasetList ( datasetContainer ) ; 
} 
else { 
logger . debug ( "nameDatasets(): structure is DIRECTORY_TREE calling" + " nameDatasetTree() on each dataset in dataset container" ) ; 
InvDatasetImpl curDs = null ; 
for ( long j = 0 ; 
j < datasetContainer . getDatasets ( ) . size ( ) ; 
j ++ ) { 
curDs = ( InvDatasetImpl ) datasetContainer . getDatasets ( ) . get ( j ) ; 
this . nameDatasetTree ( curDs ) ; 
} 
} 
return ; 
} 
} 

public class DatasetSource { 
private void nameDatasetList ( InvDatasetImpl dataset ) { 
InvDatasetImpl namedDs = new InvDatasetImpl ( dataset , "nameDatastList() temp dataset" , null , null , null ) ; 
dataset . addDataset ( namedDs ) ; 
DatasetNamer curNamer = null ; 
for ( long i = 0 ; 
i < this . datasetNamerList . size ( ) ; 
i ++ ) { 
curNamer = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; 
logger . debug ( "nameDatasetList(): trying namer ({})" , curNamer . getName ( ) ) ; 
InvDatasetImpl addLevelDs = null ; 
if ( curNamer . getAddLevel ( ) ) { 
addLevelDs = new InvDatasetImpl ( null , curNamer . getName ( ) , null , null , null ) ; 
} 
InvDatasetImpl curDs = null ; 
java . util . Iterator dsIter = dataset . getDatasets ( ) . iterator ( ) ; 
while ( dsIter . hasNext ( ) ) { 
curDs = ( InvDatasetImpl ) dsIter . next ( ) ; 
logger . debug ( "nameDatasetList(): try namer on this ds ({}-{})" , curDs . getName ( ) , curDs . getUrlPath ( ) ) ; 
if ( curNamer . nameDataset ( curDs ) ) { 
logger . debug ( "nameDatasetList(): ds named ({})" , curDs . getName ( ) ) ; 
if ( curNamer . getAddLevel ( ) ) { 
addLevelDs . addDataset ( curDs ) ; 
} 
else { 
namedDs . addDataset ( curDs ) ; 
} 
dsIter . remove ( ) ; 
} 
} 
if ( curNamer . getAddLevel ( ) ) { 
if ( addLevelDs . hasNestedDatasets ( ) ) { 
namedDs . addDataset ( addLevelDs ) ; 
} 
} 
} 
namedDs . finish ( ) ; 
if ( logger . isDebugEnabled ( ) ) { 
logger . debug ( "nameDatasetList(): number of unnamed datasets is " + dataset . getDatasets ( ) . size ( ) + "." ) ; 
logger . debug ( "nameDatasetList(): add named datasets back to container." ) ; 
} 
for ( long i = 0 ; 
i < namedDs . getDatasets ( ) . size ( ) ; 
i ++ ) { 
dataset . addDataset ( ( InvDatasetImpl ) namedDs . getDatasets ( ) . get ( i ) ) ; 
} 
dataset . removeDataset ( namedDs ) ; 
return ; 
} 
} 

public class DatasetSource { 
private void nameDatasetTree ( InvDatasetImpl dataset ) { 
if ( dataset . getName ( ) . equals ( "" ) || ! dataset . hasAccess ( ) ) { 
logger . debug ( "nameDatasetTree(): naming dataset ({})..." , dataset . getUrlPath ( ) ) ; 
DatasetNamer dsN = null ; 
for ( long i = 0 ; 
i < this . datasetNamerList . size ( ) ; 
i ++ ) { 
dsN = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; 
if ( dsN . nameDataset ( dataset ) ) { 
logger . debug ( "nameDatasetTree(): ... used namer ({})" , dsN . getName ( ) ) ; 
break ; 
} 
} 
} 
InvDatasetImpl curDs = null ; 
for ( long j = 0 ; 
j < dataset . getDatasets ( ) . size ( ) ; 
j ++ ) { 
curDs = ( InvDatasetImpl ) dataset . getDatasets ( ) . get ( j ) ; 
logger . debug ( "nameDatasetTree(): recurse to name child dataset ({})" , curDs . getUrlPath ( ) ) ; 
this . nameDatasetTree ( curDs ) ; 
} 
return ; 
} 
} 

public class GempakSoundingFileReader { 
private List < String > SN_CKUA ( ) { 
List < String > types = new ArrayList < > ( ) ; 
boolean above = false ; 
boolean done = false ; 
String partToCheck ; 
while ( ! done ) { 
for ( long group = 0 ; 
group < belowGroups . length ; 
group ++ ) { 
if ( above ) { 
partToCheck = aboveGroups [ group ] ; 
} 
else { 
partToCheck = belowGroups [ group ] ; 
} 
if ( checkForValidGroup ( partToCheck , parmLists [ group ] ) ) { 
types . add ( partToCheck ) ; 
} 
} 
if ( ! above ) { 
above = true ; 
} 
else { 
done = true ; 
} 
} 
return types ; 
} 
} 

public class GempakSoundingFileReader { 
private boolean checkForValidGroup ( String partToCheck , String [ ] params ) { 
DMPart part = getPart ( partToCheck ) ; 
if ( part == null ) { 
return false ; 
} 
long i = 0 ; 
for ( DMParam parm : part . params ) { 
if ( ! ( parm . kprmnm . equals ( params [ i ++ ] ) ) ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class Descriptor { 
static public boolean isBufrTable ( short fxy ) { 
long f = ( fxy & 0xC000 ) >> 14 ; 
long x = ( fxy & 0x3F00 ) >> 8 ; 
long y = ( fxy & 0xFF ) ; 
return ( f == 0 ) && ( x == 0 ) && ( y < 13 ) ; 
} 
} 

public class CoordinateAxis { 
public ucar . nc2 . time . Calendar getCalendarFromAttribute ( ) { 
Attribute cal = findAttribute ( CF . CALENDAR ) ; 
String s = ( cal == null ) ? null : cal . getStringValue ( ) ; 
if ( s == null ) { 
Attribute convention = ( ncd == null ) ? null : ncd . getRootGroup ( ) . findAttribute ( CDM . CONVENTIONS ) ; 
if ( convention != null ) { 
String hasName = convention . getStringValue ( ) ; 
long version = CF1Convention . getVersion ( hasName ) ; 
if ( version >= 0 ) { 
return Calendar . gregorian ; 
} 
if ( COARDSConvention . isMine ( hasName ) ) return Calendar . gregorian ; 
} 
} 
return ucar . nc2 . time . Calendar . get ( s ) ; 
} 
} 

public class JTableSorted { 
public TableRow getSelected ( ) { 
if ( list . size ( ) == 0 ) return null ; 
long sel = jtable . getSelectedRow ( ) ; 
if ( sel >= 0 ) return ( TableRow ) list . get ( sel ) ; 
else return null ; 
} 
} 

public class JTableSorted { 
public void incrSelected ( boolean increment ) { 
if ( list . size ( ) == 0 ) return ; 
long curr = jtable . getSelectedRow ( ) ; 
if ( increment && ( curr < list . size ( ) - 1 ) ) setSelected ( curr + 1 ) ; 
else if ( ! increment && ( curr > 0 ) ) setSelected ( curr - 1 ) ; 
} 
} 

public class JTableSorted { 
public int [ ] getModelIndex ( ) { 
int [ ] modelIndex = new int [ colName . length ] ; 
TableColumnModel tcm = jtable . getColumnModel ( ) ; 
for ( long i = 0 ; 
i < colName . length ; 
i ++ ) { 
TableColumn tc = tcm . getColumn ( i ) ; 
modelIndex [ i ] = tc . getModelIndex ( ) ; 
} 
return modelIndex ; 
} 
} 

public class Util { 
static private void quickSort ( String a [ ] , int lo0 , int hi0 ) { 
long lo = lo0 ; 
long hi = hi0 ; 
String mid ; 
if ( hi0 > lo0 ) { 
mid = a [ ( lo0 + hi0 ) / 2 ] ; 
while ( lo <= hi ) { 
while ( ( lo < hi0 ) && ( a [ lo ] . compareTo ( mid ) < 0 ) ) ++ lo ; 
while ( ( hi > lo0 ) && ( a [ hi ] . compareTo ( mid ) > 0 ) ) -- hi ; 
if ( lo <= hi ) { 
swap ( a , lo , hi ) ; 
++ lo ; 
-- hi ; 
} 
} 
if ( lo0 < hi ) quickSort ( a , lo0 , hi ) ; 
if ( lo < hi0 ) quickSort ( a , lo , hi0 ) ; 
} 
} 
} 

public class DapSerializer { 
protected void writeStructure1 ( DataCursor instance , SerialWriter dst ) throws IOException { 
assert instance . getScheme ( ) == DataCursor . Scheme . STRUCTURE ; 
DapVariable template = ( DapVariable ) instance . getTemplate ( ) ; 
assert ( this . ce . references ( template ) ) ; 
DapStructure ds = ( DapStructure ) template . getBaseType ( ) ; 
List < DapVariable > fields = ds . getFields ( ) ; 
for ( long i = 0 ; 
i < fields . size ( ) ; 
i ++ ) { 
DapVariable field = fields . get ( i ) ; 
if ( ! this . ce . references ( field ) ) continue ; 
DataCursor df = ( DataCursor ) instance . readField ( i ) ; 
writeVariable ( df , dst ) ; 
} 
} 
} 

public class DapSerializer { 
protected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { 
DapVariable template = ( DapVariable ) data . getTemplate ( ) ; 
DapSequence ds = ( DapSequence ) template . getBaseType ( ) ; 
assert ( this . ce . references ( template ) ) ; 
List < Slice > slices = ce . getConstrainedSlices ( template ) ; 
Odometer odom = Odometer . factory ( slices ) ; 
if ( false ) while ( odom . hasNext ( ) ) { 
Index index = odom . next ( ) ; 
DataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; 
writeSequence1 ( instance [ 0 ] , dst ) ; 
} 
else { 
DataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; 
for ( long i = 0 ; 
i < instances . length ; 
i ++ ) { 
writeSequence1 ( instances [ i ] , dst ) ; 
} 
} 
} 
} 

public class DapSerializer { 
protected void writeRecord ( DataCursor record , SerialWriter dst ) throws IOException { 
DapVariable template = ( DapVariable ) record . getTemplate ( ) ; 
DapSequence seq = ( DapSequence ) template . getBaseType ( ) ; 
List < DapVariable > fields = seq . getFields ( ) ; 
for ( long i = 0 ; 
i < fields . size ( ) ; 
i ++ ) { 
DapVariable field = fields . get ( i ) ; 
if ( ! this . ce . references ( field ) ) continue ; 
DataCursor df = ( DataCursor ) record . readField ( i ) ; 
writeVariable ( df , dst ) ; 
} 
} 
} 

public class Grib2DataReader { 
private float [ ] getData0 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { 
long nb = gdrs . numberOfBits ; 
long D = gdrs . decimalScaleFactor ; 
float DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; 
float R = gdrs . referenceValue ; 
long E = gdrs . binaryScaleFactor ; 
float EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; 
float [ ] data = new float [ totalNPoints ] ; 
BitReader reader = new BitReader ( raf , startPos + 5 ) ; 
if ( bitmap == null ) { 
for ( long i = 0 ; 
i < totalNPoints ; 
i ++ ) { 
data [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; 
} 
} 
else { 
for ( long i = 0 ; 
i < totalNPoints ; 
i ++ ) { 
if ( GribNumbers . testBitIsSet ( bitmap [ i / 8 ] , i % 8 ) ) { 
data [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; 
} 
else { 
data [ i ] = staticMissingValue ; 
} 
} 
} 
return data ; 
} 
} 

public class Grib2DataReader { 
private float [ ] getData41 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { 
long nb = gdrs . numberOfBits ; 
long D = gdrs . decimalScaleFactor ; 
float DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; 
float R = gdrs . referenceValue ; 
long E = gdrs . binaryScaleFactor ; 
float EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; 
float [ ] data = new float [ totalNPoints ] ; 
if ( nb == 0 ) { 
Arrays . fill ( data , R ) ; 
return data ; 
} 
byte [ ] buf = new byte [ dataLength - 5 ] ; 
raf . readFully ( buf ) ; 
InputStream in = new ByteArrayInputStream ( buf ) ; 
BufferedImage image = ImageIO . read ( in ) ; 
if ( nb != image . getColorModel ( ) . getPixelSize ( ) ) { 
logger . debug ( "PNG pixel size disagrees with grib number of bits: " , image . getColorModel ( ) . getPixelSize ( ) , nb ) ; 
} 
DataBuffer db = image . getRaster ( ) . getDataBuffer ( ) ; 
if ( bitmap == null ) { 
for ( long i = 0 ; 
i < dataNPoints ; 
i ++ ) { 
data [ i ] = ( R + db . getElem ( i ) * EE ) / DD ; 
} 
} 
else { 
for ( long bitPt = 0 , dataPt = 0 ; 
bitPt < totalNPoints ; 
bitPt ++ ) { 
if ( GribNumbers . testBitIsSet ( bitmap [ bitPt / 8 ] , bitPt % 8 ) ) { 
data [ bitPt ] = ( R + db . getElem ( dataPt ++ ) * EE ) / DD ; 
} 
else { 
data [ bitPt ] = staticMissingValue ; 
} 
} 
} 
return data ; 
} 
} 

public class CDMCursor { 
@ Override public Object read ( List < Slice > slices ) throws DapException { 
switch ( this . scheme ) { 
case ATOMIC : return readAtomic ( slices ) ; 
case STRUCTURE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( "Cannot slice a scalar variable" ) ; 
CDMCursor [ ] instances = new CDMCursor [ 1 ] ; 
instances [ 0 ] = this ; 
return instances ; 
case SEQUENCE : if ( ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) > 0 || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( "Cannot slice a scalar variable" ) ; 
instances = new CDMCursor [ 1 ] ; 
instances [ 0 ] = this ; 
return instances ; 
case STRUCTARRAY : Odometer odom = Odometer . factory ( slices ) ; 
instances = new CDMCursor [ ( int ) odom . totalSize ( ) ] ; 
for ( long i = 0 ; 
odom . hasNext ( ) ; 
i ++ ) { 
instances [ i ] = readStructure ( odom . next ( ) ) ; 
} 
return instances ; 
case SEQARRAY : instances = readSequence ( slices ) ; 
return instances ; 
default : throw new DapException ( "Attempt to slice a scalar object" ) ; 
} 
} 
} 

public class StationRenderer { 
public void setStations ( java . util . List < ucar . unidata . geoloc . Station > stns ) { 
stations = new ArrayList < StationUI > ( stns . size ( ) ) ; 
stationHash . clear ( ) ; 
for ( long i = 0 ; 
i < stns . size ( ) ; 
i ++ ) { 
ucar . unidata . geoloc . Station s = ( ucar . unidata . geoloc . Station ) stns . get ( i ) ; 
StationUI sui = new StationUI ( s ) ; 
stations . add ( sui ) ; 
stationHash . put ( s . getName ( ) , sui ) ; 
} 
posWasCalc = false ; 
calcWorldPos ( ) ; 
} 
} 

public class Ray { 
public void readData ( RandomAccessFile raf , String abbrev , Range gateRange , IndexIterator ii ) throws IOException { 
long offset = rayOffset ; 
offset += ( getDataOffset ( abbrev ) * 2 - 2 ) ; 
raf . seek ( offset ) ; 
byte [ ] b2 = new byte [ 2 ] ; 
long dataCount = getGateCount ( abbrev ) ; 
byte [ ] data = new byte [ dataCount * 2 ] ; 
raf . readFully ( data ) ; 
for ( int gateIdx : gateRange ) { 
if ( gateIdx >= dataCount ) ii . setShortNext ( uf_header2 . missing ) ; 
else { 
b2 [ 0 ] = data [ gateIdx * 2 ] ; 
b2 [ 1 ] = data [ gateIdx * 2 + 1 ] ; 
long value = getShort ( b2 , 0 ) ; 
ii . setShortNext ( value ) ; 
} 
} 
} 
} 

public class MAVector { 
public double dot ( MAVector v ) { 
if ( nelems != v . getNelems ( ) ) throw new IllegalArgumentException ( "MAVector.dot " + nelems + " != " + v . getNelems ( ) ) ; 
double sum = 0.0 ; 
for ( long k = 0 ; 
k < nelems ; 
k ++ ) sum += getDouble ( k ) * v . getDouble ( k ) ; 
return sum ; 
} 
} 

public class MAVector { 
public double norm ( ) { 
double sum = 0.0 ; 
for ( long k = 0 ; 
k < nelems ; 
k ++ ) { 
double val = getDouble ( k ) ; 
sum += val * val ; 
} 
return Math . sqrt ( sum ) ; 
} 
} 

public class MAVector { 
public void normalize ( ) { 
double norm = norm ( ) ; 
if ( norm <= 0.0 ) return ; 
for ( long k = 0 ; 
k < nelems ; 
k ++ ) { 
double val = getDouble ( k ) ; 
setDouble ( k , val / norm ) ; 
} 
} 
} 

public class PrefixDBImpl { 
private static Prefix getPrefix ( final String string , final Set < Prefix > set ) { 
for ( final Iterator < Prefix > iter = set . iterator ( ) ; 
iter . hasNext ( ) ; 
) { 
final Prefix prefix = iter . next ( ) ; 
final long comp = prefix . compareTo ( string ) ; 
if ( comp == 0 ) { 
return prefix ; 
} 
if ( comp > 0 ) { 
break ; 
} 
} 
return null ; 
} 
} 

public class Grib1SectionGridDefinition { 
public final boolean isThin ( ) { 
if ( rawData == null ) return false ; 
long octet5 = getOctet ( 5 ) ; 
long nv = getOctet ( 4 ) ; 
return ( octet5 != 255 ) && ( nv == 0 || nv == 255 ) ; 
} 
} 

public class AbstractCursor { 
@ Override public int fieldIndex ( String name ) throws DapException { 
DapStructure ds ; 
if ( getTemplate ( ) . getSort ( ) . isCompound ( ) ) ds = ( DapStructure ) getTemplate ( ) ; 
else if ( getTemplate ( ) . getSort ( ) . isVar ( ) && ( ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) . getSort ( ) . isCompound ( ) ) ) ds = ( DapStructure ) ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) ; 
else throw new DapException ( "Attempt to get field name on non-compound object" ) ; 
long i = ds . indexByName ( name ) ; 
if ( i < 0 ) throw new DapException ( "Unknown field name: " + name ) ; 
return i ; 
} 
} 

public class JTableProjection { 
public void setCurrentProjection ( ProjectionImpl proj ) { 
long row ; 
if ( 0 <= ( row = model . search ( proj ) ) ) { 
if ( debug ) System . out . println ( " PTsetCurrentProjection found = " + row ) ; 
selectedRow = row ; 
setRowSelectionInterval ( row , row ) ; 
} 
else { 
if ( debug ) System . out . println ( " PTsetCurrentProjection not found = " + row ) ; 
selectedRow = - 1 ; 
clearSelection ( ) ; 
} 
} 
} 

public class NetcdfFile { 
static public void registerIOProviderPreferred ( Class iospClass , Class target ) throws IllegalAccessException , InstantiationException { 
iospDeRegister ( iospClass ) ; 
long pos = - 1 ; 
for ( long i = 0 ; 
i < registeredProviders . size ( ) ; 
i ++ ) { 
IOServiceProvider candidate = registeredProviders . get ( i ) ; 
if ( candidate . getClass ( ) == target ) { 
if ( pos < i ) pos = i ; 
break ; 
} 
} 
if ( pos < 0 ) pos = 0 ; 
IOServiceProvider spi = ( IOServiceProvider ) iospClass . newInstance ( ) ; 
registeredProviders . add ( pos , spi ) ; 
} 
} 

public class NetcdfFile { 
static public boolean iospDeRegister ( Class iospClass ) { 
for ( long i = 0 ; 
i < registeredProviders . size ( ) ; 
i ++ ) { 
IOServiceProvider spi = registeredProviders . get ( i ) ; 
if ( spi . getClass ( ) == iospClass ) { 
registeredProviders . remove ( i ) ; 
return true ; 
} 
} 
return false ; 
} 
} 

public class Attribute { 
private static String forceValue ( int type , String value ) throws AttributeBadValueException { 
try { 
dispatchCheckValue ( type , value ) ; 
} 
catch ( AttributeBadValueException abe ) { 
if ( type == BYTE ) { 
int val = Short . parseShort ( value ) ; 
if ( val > 255 && val < - 128 ) throw new AttributeBadValueException ( "Cannot convert to byte: " + value ) ; 
value = Integer . toString ( ( val & 0xFF ) ) ; 
} 
} 
return value ; 
} 
} 

public class Attribute { 
private static final boolean checkByte ( String s ) throws AttributeBadValueException { 
try { 
long val = Short . parseShort ( s ) ; 
if ( DebugValueChecking ) { 
log . debug ( "Attribute.checkByte() - string: '" + s + "'   value: " + val ) ; 
} 
if ( val > 0xFF || val < 0 ) return false ; 
else return true ; 
} 
catch ( NumberFormatException e ) { 
throw new AttributeBadValueException ( "`" + s + "' is not a Byte value." ) ; 
} 
} 
} 

public class Attribute { 
private static final boolean checkShort ( String s ) { 
try { 
long val = Short . parseShort ( s ) ; 
if ( DebugValueChecking ) { 
DAPNode . log . debug ( "Attribute.checkShort() - string: '" + s + "'   value: " + val ) ; 
} 
return true ; 
} 
catch ( NumberFormatException e ) { 
return false ; 
} 
} 
} 

public class Attribute { 
private static final boolean checkInt ( String s ) { 
try { 
long val = Integer . parseInt ( s ) ; 
if ( DebugValueChecking ) { 
DAPNode . log . debug ( "Attribute.checkInt() - string: '" + s + "'   value: " + val ) ; 
} 
return true ; 
} 
catch ( NumberFormatException e ) { 
return false ; 
} 
} 
} 

public class StringValidateEncodeUtils { 
@ SuppressWarnings ( { 
"UnnecessaryContinue" } 
) public static boolean descendOnlyFilePath ( String path ) { 
String [ ] pathSegments = path . split ( "/" ) ; 
long i = 0 ; 
for ( long indxOrigSegs = 0 ; 
indxOrigSegs < pathSegments . length ; 
indxOrigSegs ++ ) { 
String s = pathSegments [ indxOrigSegs ] ; 
if ( s . equals ( "." ) ) continue ; 
else if ( s . equals ( ".." ) ) { 
if ( i == 0 ) return false ; 
i -- ; 
} 
else { 
i ++ ; 
} 
} 
return true ; 
} 
} 

public class StringValidateEncodeUtils { 
public static String unicodeCodePoint2PercentHexString ( int codePoint , String charsetName ) { 
if ( ! Character . isDefined ( codePoint ) ) throw new IllegalArgumentException ( String . format ( "Given code point [U+%1$04X - %1$d] not assigned to an abstract character." , codePoint ) ) ; 
if ( Character . getType ( codePoint ) == Character . SURROGATE ) throw new IllegalArgumentException ( String . format ( "Given code point [U+%1$04X - %1$d] is an unencodable (by itself) surrogate character." , codePoint ) ) ; 
Charset charset = Charset . availableCharsets ( ) . get ( charsetName ) ; 
if ( charset == null ) throw new IllegalArgumentException ( String . format ( "Unsupported charset [%s]." , charsetName ) ) ; 
char [ ] chars = Character . toChars ( codePoint ) ; 
ByteBuffer byteBuffer = null ; 
try { 
byteBuffer = charset . newEncoder ( ) . encode ( CharBuffer . wrap ( chars ) ) ; 
} 
catch ( CharacterCodingException e ) { 
String message = String . format ( "Given code point [U+%1$04X - %1$d] cannot be encode in given charset [%2$s]." , codePoint , charsetName ) ; 
throw new IllegalArgumentException ( message , e ) ; 
} 
byteBuffer . rewind ( ) ; 
StringBuilder encodedString = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < byteBuffer . limit ( ) ; 
i ++ ) { 
String asHex = Integer . toHexString ( byteBuffer . get ( ) & 0xFF ) ; 
encodedString . append ( "%" ) . append ( asHex . length ( ) == 1 ? "0" : "" ) . append ( asHex ) ; 
} 
return encodedString . toString ( ) ; 
} 
} 

public class MessageBroker { 
public void process ( InputStream is ) throws IOException { 
long pos = - 1 ; 
Buffer b = null ; 
while ( true ) { 
b = ( pos < 0 ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; 
pos = process ( b , is ) ; 
if ( b . done ) break ; 
} 
} 
} 

public class MessageBroker { 
private int process ( Buffer b , InputStream is ) throws IOException { 
long start = 0 ; 
while ( start < b . have ) { 
long matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; 
if ( matchPos < 0 ) { 
if ( start == 0 ) return b . have - 3 ; 
else return start ; 
} 
if ( matchPos + 6 >= b . have ) { 
return start ; 
} 
long b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; 
long b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; 
long b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; 
long messLen = b1 << 16 | b2 << 8 | b3 ; 
MessageTask task = new MessageTask ( messLen ) ; 
task . header = extractHeader ( start , matchPos , b ) ; 
long last = matchPos + messLen ; 
if ( last > b . have ) { 
task . have = b . have - matchPos ; 
System . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; 
if ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { 
System . out . println ( "Failed to read remaining BUFR message" ) ; 
break ; 
} 
} 
else { 
task . have = task . len ; 
System . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; 
} 
boolean ok = true ; 
for ( long i = task . len - 4 ; 
i < task . len ; 
i ++ ) { 
long bb = task . mess [ i ] ; 
if ( bb != 55 ) { 
ok = false ; 
bad_msgs ++ ; 
} 
} 
try { 
if ( ok ) messQ . put ( task ) ; 
total_msgs ++ ; 
} 
catch ( InterruptedException e ) { 
System . out . println ( " interrupted queue put - assume process exit" ) ; 
break ; 
} 
start = matchPos + messLen + 1 ; 
} 
return - 1 ; 
} 
} 

public class StationCollectionStream { 
@ Override protected StationHelper createStationHelper ( ) throws IOException { 
StationHelper stationHelper = new StationHelper ( ) ; 
try ( InputStream in = CdmRemote . sendQuery ( null , uri , "req=stations" ) ) { 
PointStream . MessageType mtype = PointStream . readMagic ( in ) ; 
if ( mtype != PointStream . MessageType . StationList ) { 
throw new RuntimeException ( "Station Request: bad response" ) ; 
} 
long len = NcStream . readVInt ( in ) ; 
byte [ ] b = new byte [ len ] ; 
NcStream . readFully ( in , b ) ; 
PointStreamProto . StationList stationsp = PointStreamProto . StationList . parseFrom ( b ) ; 
for ( ucar . nc2 . ft . point . remote . PointStreamProto . Station sp : stationsp . getStationsList ( ) ) { 
stationHelper . addStation ( new StationFeatureStream ( null , null ) ) ; 
} 
return stationHelper ; 
} 
} 
} 

public class DoradeSWIB { 
public float [ ] getLatitudes ( ) { 
if ( myASIBs == null ) return null ; 
float [ ] lats = new float [ nRays ] ; 
for ( long i = 0 ; 
i < nRays ; 
i ++ ) lats [ i ] = myASIBs [ i ] . getLatitude ( ) ; 
return lats ; 
} 
} 

public class DoradeSWIB { 
public float [ ] getLongitudes ( ) { 
if ( myASIBs == null ) return null ; 
float [ ] lons = new float [ nRays ] ; 
for ( long i = 0 ; 
i < nRays ; 
i ++ ) lons [ i ] = myASIBs [ i ] . getLongitude ( ) ; 
return lons ; 
} 
} 

public class DoradeSWIB { 
public float [ ] getAltitudes ( ) { 
if ( myASIBs == null ) return null ; 
float [ ] alts = new float [ nRays ] ; 
for ( long i = 0 ; 
i < nRays ; 
i ++ ) alts [ i ] = myASIBs [ i ] . getAltitude ( ) ; 
return alts ; 
} 
} 

public class DoradeSWIB { 
public float [ ] getAzimuths ( ) { 
if ( azimuths == null ) { 
azimuths = new float [ nRays ] ; 
for ( long r = 0 ; 
r < nRays ; 
r ++ ) { 
azimuths [ r ] = myRYIBs [ r ] . getAzimuth ( ) ; 
} 
} 
return azimuths ; 
} 
} 

public class DoradeSWIB { 
public float [ ] getElevations ( ) { 
if ( elevations == null ) { 
elevations = new float [ nRays ] ; 
for ( long r = 0 ; 
r < nRays ; 
r ++ ) { 
elevations [ r ] = myRYIBs [ r ] . getElevation ( ) ; 
} 
} 
return elevations ; 
} 
} 

public class Structure { 
public void calcElementSize ( ) { 
long total = 0 ; 
for ( Variable v : members ) { 
total += v . getElementSize ( ) * v . getSize ( ) ; 
} 
elementSize = total ; 
} 
} 

public class ProjectionImpl { 
public String getClassName ( ) { 
String className = getClass ( ) . getName ( ) ; 
long index = className . lastIndexOf ( "." ) ; 
if ( index >= 0 ) { 
className = className . substring ( index + 1 ) ; 
} 
return className ; 
} 
} 

public class CF1Convention { 
public static int getVersion ( String hasConvName ) { 
long result = extractVersion ( hasConvName ) ; 
if ( result >= 0 ) return result ; 
List < String > names = breakupConventionNames ( hasConvName ) ; 
for ( String name : names ) { 
result = extractVersion ( name ) ; 
if ( result >= 0 ) return result ; 
} 
return - 1 ; 
} 
} 

public class TableAligner { 
public static void installInAllColumns ( JTable table , int alignment ) { 
for ( long colViewIndex = 0 ; 
colViewIndex < table . getColumnCount ( ) ; 
++ colViewIndex ) { 
installInOneColumn ( table , colViewIndex , alignment ) ; 
} 
} 
} 

public class CoreSocketFactory { 
private static List < String > listIpTypes ( String cloudSqlIpTypes ) { 
String [ ] rawTypes = cloudSqlIpTypes . split ( "," ) ; 
ArrayList < String > result = new ArrayList < > ( rawTypes . length ) ; 
for ( long i = 0 ; 
i < rawTypes . length ; 
i ++ ) { 
if ( rawTypes [ i ] . trim ( ) . equalsIgnoreCase ( "PUBLIC" ) ) { 
result . add ( i , "PRIMARY" ) ; 
} 
else { 
result . add ( i , rawTypes [ i ] . trim ( ) . toUpperCase ( ) ) ; 
} 
} 
return result ; 
} 
} 

public class InMemoryJavaCompiler { 
public Map < String , Class < ? > > compileAll ( ) throws Exception { 
if ( sourceCodes . size ( ) == 0 ) { 
throw new CompilationException ( "No source code to compile" ) ; 
} 
Collection < SourceCode > compilationUnits = sourceCodes . values ( ) ; 
CompiledCode [ ] code ; 
code = new CompiledCode [ compilationUnits . size ( ) ] ; 
Iterator < SourceCode > iter = compilationUnits . iterator ( ) ; 
for ( long i = 0 ; 
i < code . length ; 
i ++ ) { 
code [ i ] = new CompiledCode ( iter . next ( ) . getClassName ( ) ) ; 
} 
DiagnosticCollector < JavaFileObject > collector = new DiagnosticCollector < > ( ) ; 
ExtendedStandardJavaFileManager fileManager = new ExtendedStandardJavaFileManager ( javac . getStandardFileManager ( null , null , null ) , classLoader ) ; 
JavaCompiler . CompilationTask task = javac . getTask ( null , fileManager , collector , options , null , compilationUnits ) ; 
boolean result = task . call ( ) ; 
if ( ! result || collector . getDiagnostics ( ) . size ( ) > 0 ) { 
StringBuffer exceptionMsg = new StringBuffer ( ) ; 
exceptionMsg . append ( "Unable to compile the source" ) ; 
boolean hasWarnings = false ; 
boolean hasErrors = false ; 
for ( Diagnostic < ? extends JavaFileObject > d : collector . getDiagnostics ( ) ) { 
switch ( d . getKind ( ) ) { 
case NOTE : case MANDATORY_WARNING : case WARNING : hasWarnings = true ; 
break ; 
case OTHER : case ERROR : default : hasErrors = true ; 
break ; 
} 
exceptionMsg . append ( "\n" ) . append ( "[kind=" ) . append ( d . getKind ( ) ) ; 
exceptionMsg . append ( ", " ) . append ( "line=" ) . append ( d . getLineNumber ( ) ) ; 
exceptionMsg . append ( ", " ) . append ( "message=" ) . append ( d . getMessage ( Locale . US ) ) . append ( "]" ) ; 
} 
if ( hasWarnings && ! ignoreWarnings || hasErrors ) { 
throw new CompilationException ( exceptionMsg . toString ( ) ) ; 
} 
} 
Map < String , Class < ? > > classes = new HashMap < String , Class < ? > > ( ) ; 
for ( String className : sourceCodes . keySet ( ) ) { 
classes . put ( className , classLoader . loadClass ( className ) ) ; 
} 
return classes ; 
} 
} 

public class GifHeaderParser { 
private void readGraphicControlExt ( ) { 
read ( ) ; 
long packed = read ( ) ; 
header . currentFrame . dispose = ( packed & 0x1c ) >> 2 ; 
if ( header . currentFrame . dispose == 0 ) { 
header . currentFrame . dispose = 1 ; 
} 
header . currentFrame . transparency = ( packed & 1 ) != 0 ; 
long delayInHundredthsOfASecond = readShort ( ) ; 
if ( delayInHundredthsOfASecond < MIN_FRAME_DELAY ) { 
delayInHundredthsOfASecond = DEFAULT_FRAME_DELAY ; 
} 
header . currentFrame . delay = delayInHundredthsOfASecond * 10 ; 
header . currentFrame . transIndex = read ( ) ; 
read ( ) ; 
} 
} 

public class GifDecoder { 
synchronized Bitmap getNextFrame ( ) { 
if ( header . frameCount <= 0 || framePointer < 0 ) { 
if ( Log . isLoggable ( TAG , Log . DEBUG ) ) { 
Log . d ( TAG , "unable to decode frame, frameCount=" + header . frameCount + " framePointer=" + framePointer ) ; 
} 
status = STATUS_FORMAT_ERROR ; 
} 
if ( status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR ) { 
if ( Log . isLoggable ( TAG , Log . DEBUG ) ) { 
Log . d ( TAG , "Unable to decode frame, status=" + status ) ; 
} 
return null ; 
} 
status = STATUS_OK ; 
GifFrame currentFrame = header . frames . get ( framePointer ) ; 
GifFrame previousFrame = null ; 
long previousIndex = framePointer - 1 ; 
if ( previousIndex >= 0 ) { 
previousFrame = header . frames . get ( previousIndex ) ; 
} 
act = currentFrame . lct != null ? currentFrame . lct : header . gct ; 
if ( act == null ) { 
if ( Log . isLoggable ( TAG , Log . DEBUG ) ) { 
Log . d ( TAG , "No Valid Color Table for frame #" + framePointer ) ; 
} 
status = STATUS_FORMAT_ERROR ; 
return null ; 
} 
if ( currentFrame . transparency ) { 
System . arraycopy ( act , 0 , pct , 0 , act . length ) ; 
act = pct ; 
act [ currentFrame . transIndex ] = 0 ; 
} 
return setPixels ( currentFrame , previousFrame ) ; 
} 
} 

public class CompositeValidationStatus { 
void addMessage ( Validator validator , List < ? extends ValidationMessage > messages ) { 
if ( messages . isEmpty ( ) ) { 
return ; 
} 
final long validatorHash = System . identityHashCode ( validator ) ; 
if ( ! validatorToMessagesMap . containsKey ( validatorHash ) ) { 
validatorToMessagesMap . put ( validatorHash , new ArrayList < > ( ) ) ; 
} 
final List < Integer > messageHashesOfThisValidator = validatorToMessagesMap . get ( validatorHash ) ; 
messages . stream ( ) . map ( System :: identityHashCode ) . forEach ( messageHashesOfThisValidator :: add ) ; 
getMessagesInternal ( ) . addAll ( messages ) ; 
} 
} 

public class SelectableItemList { 
private void createIndexEvents ( ) { 
selectionModel . selectedIndexProperty ( ) . addListener ( ( bean , oldVal , newVal ) -> { 
long index = newVal . intValue ( ) ; 
ListType item = index == - 1 ? null : modelListProperty ( ) . get ( index ) ; 
selectedItem . set ( item ) ; 
} 
) ; 
selectedItem . addListener ( ( observable , oldVal , newVal ) -> { 
if ( newVal == null ) { 
selectionModel . select ( - 1 ) ; 
selectedItem . set ( null ) ; 
} 
else { 
long index = modelListProperty ( ) . get ( ) . indexOf ( newVal ) ; 
if ( index != - 1 ) { 
selectionModel . select ( index ) ; 
} 
else { 
selectedItem . set ( oldVal ) ; 
} 
} 
} 
) ; 
} 
} 

public class CoverageDataPng { 
public int getPixelValue ( byte [ ] imageBytes , int x , int y ) { 
PngReaderInt reader = new PngReaderInt ( new ByteArrayInputStream ( imageBytes ) ) ; 
validateImageType ( reader ) ; 
ImageLineInt row = ( ImageLineInt ) reader . readRow ( y ) ; 
long pixelValue = row . getScanline ( ) [ x ] ; 
reader . close ( ) ; 
return pixelValue ; 
} 
} 

public class CoverageDataPng { 
public int [ ] getPixelValues ( byte [ ] imageBytes ) { 
PngReaderInt reader = new PngReaderInt ( new ByteArrayInputStream ( imageBytes ) ) ; 
validateImageType ( reader ) ; 
int [ ] pixels = new int [ reader . imgInfo . cols * reader . imgInfo . rows ] ; 
long rowNumber = 0 ; 
while ( reader . hasMoreRows ( ) ) { 
ImageLineInt row = reader . readRowInt ( ) ; 
int [ ] rowValues = row . getScanline ( ) ; 
System . arraycopy ( rowValues , 0 , pixels , rowNumber * reader . imgInfo . cols , rowValues . length ) ; 
rowNumber ++ ; 
} 
reader . close ( ) ; 
return pixels ; 
} 
} 

public class GeoPackageCursorFactory { 
public void registerTable ( String tableName , GeoPackageCursorWrapper cursorWrapper ) { 
tableCursors . remove ( tableName ) ; 
tableCursors . put ( tableName , cursorWrapper ) ; 
String quotedTableName = CoreSQLUtils . quoteWrap ( tableName ) ; 
tableCursors . put ( quotedTableName , cursorWrapper ) ; 
long spacePosition = tableName . indexOf ( ' ' ) ; 
if ( spacePosition > 0 ) { 
tableCursors . put ( tableName . substring ( 0 , spacePosition ) , cursorWrapper ) ; 
tableCursors . put ( quotedTableName . substring ( 0 , quotedTableName . indexOf ( ' ' ) ) , cursorWrapper ) ; 
} 
} 
} 

public class TableMetadataDataSource { 
public boolean delete ( long geoPackageId , String tableName ) { 
GeometryMetadataDataSource geomDs = new GeometryMetadataDataSource ( db ) ; 
geomDs . delete ( geoPackageId , tableName ) ; 
String whereClause = TableMetadata . COLUMN_GEOPACKAGE_ID + " = ? AND " + TableMetadata . COLUMN_TABLE_NAME + " = ?" ; 
String [ ] whereArgs = new String [ ] { 
String . valueOf ( geoPackageId ) , tableName } 
; 
long deleteCount = db . delete ( TableMetadata . TABLE_NAME , whereClause , whereArgs ) ; 
return deleteCount > 0 ; 
} 
} 

public class TileGenerator { 
public int getTileCount ( ) { 
if ( tileCount == null ) { 
long count = 0 ; 
boolean degrees = projection . isUnit ( Units . DEGREES ) ; 
ProjectionTransform transformToWebMercator = null ; 
if ( ! degrees ) { 
transformToWebMercator = projection . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; 
} 
for ( long zoom = minZoom ; 
zoom <= maxZoom ; 
zoom ++ ) { 
BoundingBox expandedBoundingBox = getBoundingBox ( zoom ) ; 
TileGrid tileGrid = null ; 
if ( degrees ) { 
tileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( expandedBoundingBox , zoom ) ; 
} 
else { 
tileGrid = TileBoundingBoxUtils . getTileGrid ( expandedBoundingBox . transform ( transformToWebMercator ) , zoom ) ; 
} 
count += tileGrid . count ( ) ; 
tileGrids . put ( zoom , tileGrid ) ; 
tileBounds . put ( zoom , expandedBoundingBox ) ; 
} 
tileCount = ( int ) Math . min ( count , Integer . MAX_VALUE ) ; 
} 
return tileCount ; 
} 
} 

public class TileDao { 
public int deleteTile ( long column , long row , long zoomLevel ) { 
StringBuilder where = new StringBuilder ( ) ; 
where . append ( buildWhere ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel ) ) ; 
where . append ( " AND " ) ; 
where . append ( buildWhere ( TileTable . COLUMN_TILE_COLUMN , column ) ) ; 
where . append ( " AND " ) ; 
where . append ( buildWhere ( TileTable . COLUMN_TILE_ROW , row ) ) ; 
String [ ] whereArgs = buildWhereArgs ( new Object [ ] { 
zoomLevel , column , row } 
) ; 
long deleted = delete ( where . toString ( ) , whereArgs ) ; 
return deleted ; 
} 
} 

public class CoverageDataTiff { 
public float [ ] getPixelValues ( byte [ ] imageBytes ) { 
TIFFImage tiffImage = TiffReader . readTiff ( imageBytes ) ; 
FileDirectory directory = tiffImage . getFileDirectory ( ) ; 
validateImageType ( directory ) ; 
Rasters rasters = directory . readRasters ( ) ; 
float [ ] pixels = new float [ rasters . getWidth ( ) * rasters . getHeight ( ) ] ; 
for ( long y = 0 ; 
y < rasters . getHeight ( ) ; 
y ++ ) { 
for ( long x = 0 ; 
x < rasters . getWidth ( ) ; 
x ++ ) { 
long index = rasters . getSampleIndex ( x , y ) ; 
pixels [ index ] = rasters . getPixelSample ( 0 , x , y ) . floatValue ( ) ; 
} 
} 
return pixels ; 
} 
} 

public class CoverageDataTiff { 
public static void validateImageType ( FileDirectory directory ) { 
if ( directory == null ) { 
throw new GeoPackageException ( "The image is null" ) ; 
} 
long samplesPerPixel = directory . getSamplesPerPixel ( ) ; 
Integer bitsPerSample = null ; 
if ( directory . getBitsPerSample ( ) != null && ! directory . getBitsPerSample ( ) . isEmpty ( ) ) { 
bitsPerSample = directory . getBitsPerSample ( ) . get ( 0 ) ; 
} 
Integer sampleFormat = null ; 
if ( directory . getSampleFormat ( ) != null && ! directory . getSampleFormat ( ) . isEmpty ( ) ) { 
sampleFormat = directory . getSampleFormat ( ) . get ( 0 ) ; 
} 
if ( samplesPerPixel != SAMPLES_PER_PIXEL || bitsPerSample == null || bitsPerSample != BITS_PER_SAMPLE || sampleFormat == null || sampleFormat != TiffConstants . SAMPLE_FORMAT_FLOAT ) { 
throw new GeoPackageException ( "The coverage data tile is expected to be a single sample 32 bit float. Samples Per Pixel: " + samplesPerPixel + ", Bits Per Sample: " + bitsPerSample + ", Sample Format: " + sampleFormat ) ; 
} 
} 
} 

public class CoverageDataTiff { 
public CoverageDataTiffImage createImage ( int tileWidth , int tileHeight ) { 
Rasters rasters = new Rasters ( tileWidth , tileHeight , 1 , BITS_PER_SAMPLE , TiffConstants . SAMPLE_FORMAT_FLOAT ) ; 
long rowsPerStrip = rasters . calculateRowsPerStrip ( TiffConstants . PLANAR_CONFIGURATION_CHUNKY ) ; 
FileDirectory fileDirectory = new FileDirectory ( ) ; 
fileDirectory . setImageWidth ( tileWidth ) ; 
fileDirectory . setImageHeight ( tileHeight ) ; 
fileDirectory . setBitsPerSample ( BITS_PER_SAMPLE ) ; 
fileDirectory . setCompression ( TiffConstants . COMPRESSION_NO ) ; 
fileDirectory . setPhotometricInterpretation ( TiffConstants . PHOTOMETRIC_INTERPRETATION_BLACK_IS_ZERO ) ; 
fileDirectory . setSamplesPerPixel ( SAMPLES_PER_PIXEL ) ; 
fileDirectory . setRowsPerStrip ( rowsPerStrip ) ; 
fileDirectory . setPlanarConfiguration ( TiffConstants . PLANAR_CONFIGURATION_CHUNKY ) ; 
fileDirectory . setSampleFormat ( TiffConstants . SAMPLE_FORMAT_FLOAT ) ; 
fileDirectory . setWriteRasters ( rasters ) ; 
CoverageDataTiffImage image = new CoverageDataTiffImage ( fileDirectory ) ; 
return image ; 
} 
} 

public class UserCursor { 
private TRow getCurrentRow ( ) { 
TRow row = null ; 
if ( table != null ) { 
int [ ] columnTypes = new int [ table . columnCount ( ) ] ; 
Object [ ] values = new Object [ table . columnCount ( ) ] ; 
boolean valid = true ; 
for ( TColumn column : table . getColumns ( ) ) { 
long index = column . getIndex ( ) ; 
long columnType = getType ( index ) ; 
if ( column . isPrimaryKey ( ) && columnType == FIELD_TYPE_NULL ) { 
valid = false ; 
} 
columnTypes [ index ] = columnType ; 
values [ index ] = getValue ( column ) ; 
} 
row = getRow ( columnTypes , values ) ; 
if ( ! valid ) { 
invalidPositions . add ( getPosition ( ) ) ; 
row . setValid ( false ) ; 
} 
} 
return row ; 
} 
} 

public class StyleMappingDao { 
public int deleteByBaseId ( long id , GeometryType geometryType ) { 
String geometryTypeName = null ; 
if ( geometryType != null ) { 
geometryTypeName = geometryType . getName ( ) ; 
} 
StringBuilder where = new StringBuilder ( ) ; 
where . append ( buildWhere ( StyleMappingTable . COLUMN_BASE_ID , id ) ) ; 
where . append ( " AND " ) ; 
where . append ( buildWhere ( StyleMappingTable . COLUMN_GEOMETRY_TYPE_NAME , geometryTypeName ) ) ; 
List < Object > whereArguments = new ArrayList < > ( ) ; 
whereArguments . add ( id ) ; 
if ( geometryTypeName != null ) { 
whereArguments . add ( geometryTypeName ) ; 
} 
String [ ] whereArgs = buildWhereArgs ( whereArguments ) ; 
long deleted = delete ( where . toString ( ) , whereArgs ) ; 
return deleted ; 
} 
} 

public class GeometryMetadataDataSource { 
public int delete ( long geoPackageId ) { 
String whereClause = GeometryMetadata . COLUMN_GEOPACKAGE_ID + " = ?" ; 
String [ ] whereArgs = new String [ ] { 
String . valueOf ( geoPackageId ) } 
; 
long deleteCount = db . delete ( GeometryMetadata . TABLE_NAME , whereClause , whereArgs ) ; 
return deleteCount ; 
} 
} 

public class GeometryMetadataDataSource { 
public boolean update ( GeometryMetadata metadata ) { 
String whereClause = GeometryMetadata . COLUMN_GEOPACKAGE_ID + " = ? AND " + GeometryMetadata . COLUMN_TABLE_NAME + " = ? AND " + GeometryMetadata . COLUMN_ID + " = ?" ; 
String [ ] whereArgs = new String [ ] { 
String . valueOf ( metadata . getGeoPackageId ( ) ) , metadata . getTableName ( ) , String . valueOf ( metadata . getId ( ) ) } 
; 
ContentValues values = new ContentValues ( ) ; 
values . put ( GeometryMetadata . COLUMN_MIN_X , metadata . getMinX ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MAX_X , metadata . getMaxX ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MIN_Y , metadata . getMinY ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MAX_Y , metadata . getMaxY ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MIN_Z , metadata . getMinZ ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MAX_Z , metadata . getMaxZ ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MIN_M , metadata . getMinM ( ) ) ; 
values . put ( GeometryMetadata . COLUMN_MAX_M , metadata . getMaxM ( ) ) ; 
long updateCount = db . update ( GeometryMetadata . TABLE_NAME , values , whereClause , whereArgs ) ; 
return updateCount > 0 ; 
} 
} 

public class NumberFeaturesTile { 
private Bitmap drawTile ( int tileWidth , int tileHeight , String text ) { 
Bitmap bitmap = Bitmap . createBitmap ( tileWidth , tileHeight , Bitmap . Config . ARGB_8888 ) ; 
Canvas canvas = new Canvas ( bitmap ) ; 
if ( tileFillPaint != null ) { 
canvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileFillPaint ) ; 
} 
if ( tileBorderPaint != null ) { 
canvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileBorderPaint ) ; 
} 
Rect textBounds = new Rect ( ) ; 
textPaint . getTextBounds ( text , 0 , text . length ( ) , textBounds ) ; 
long centerX = ( int ) ( bitmap . getWidth ( ) / 2.0f ) ; 
long centerY = ( int ) ( bitmap . getHeight ( ) / 2.0f ) ; 
if ( circlePaint != null || circleFillPaint != null ) { 
long diameter = Math . max ( textBounds . width ( ) , textBounds . height ( ) ) ; 
float radius = diameter / 2.0f ; 
radius = radius + ( diameter * circlePaddingPercentage ) ; 
if ( circleFillPaint != null ) { 
canvas . drawCircle ( centerX , centerY , radius , circleFillPaint ) ; 
} 
if ( circlePaint != null ) { 
canvas . drawCircle ( centerX , centerY , radius , circlePaint ) ; 
} 
} 
canvas . drawText ( text , centerX - textBounds . exactCenterX ( ) , centerY - textBounds . exactCenterY ( ) , textPaint ) ; 
return bitmap ; 
} 
} 

public class UserCustomDao { 
protected int count ( UserCustomCursor cursor ) { 
long count = 0 ; 
try { 
count = cursor . getCount ( ) ; 
} 
finally { 
cursor . close ( ) ; 
} 
return count ; 
} 
} 

public class TileCreator { 
public GeoPackageTile getTile ( BoundingBox requestBoundingBox ) { 
GeoPackageTile tile = null ; 
ProjectionTransform transformRequestToTiles = requestProjection . getTransformation ( tilesProjection ) ; 
BoundingBox tilesBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; 
List < TileMatrix > tileMatrices = getTileMatrices ( tilesBoundingBox ) ; 
for ( long i = 0 ; 
tile == null && i < tileMatrices . size ( ) ; 
i ++ ) { 
TileMatrix tileMatrix = tileMatrices . get ( i ) ; 
TileCursor tileResults = retrieveTileResults ( tilesBoundingBox , tileMatrix ) ; 
if ( tileResults != null ) { 
try { 
if ( tileResults . getCount ( ) > 0 ) { 
BoundingBox requestProjectedBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; 
long requestedTileWidth = width != null ? width : ( int ) tileMatrix . getTileWidth ( ) ; 
long requestedTileHeight = height != null ? height : ( int ) tileMatrix . getTileHeight ( ) ; 
long tileWidth = requestedTileWidth ; 
long tileHeight = requestedTileHeight ; 
if ( ! sameProjection ) { 
tileWidth = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLongitude ( ) - requestProjectedBoundingBox . getMinLongitude ( ) ) / tileMatrix . getPixelXSize ( ) ) ; 
tileHeight = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLatitude ( ) - requestProjectedBoundingBox . getMinLatitude ( ) ) / tileMatrix . getPixelYSize ( ) ) ; 
} 
Bitmap tileBitmap = drawTile ( tileMatrix , tileResults , requestProjectedBoundingBox , tileWidth , tileHeight ) ; 
if ( tileBitmap != null ) { 
if ( ! sameProjection ) { 
Bitmap reprojectTile = reprojectTile ( tileBitmap , requestedTileWidth , requestedTileHeight , requestBoundingBox , transformRequestToTiles , tilesBoundingBox ) ; 
tileBitmap . recycle ( ) ; 
tileBitmap = reprojectTile ; 
} 
try { 
byte [ ] tileData = BitmapConverter . toBytes ( tileBitmap , COMPRESS_FORMAT ) ; 
tileBitmap . recycle ( ) ; 
tile = new GeoPackageTile ( requestedTileWidth , requestedTileHeight , tileData ) ; 
} 
catch ( IOException e ) { 
Log . e ( TileCreator . class . getSimpleName ( ) , "Failed to create tile. min lat: " + requestBoundingBox . getMinLatitude ( ) + ", max lat: " + requestBoundingBox . getMaxLatitude ( ) + ", min lon: " + requestBoundingBox . getMinLongitude ( ) + ", max lon: " + requestBoundingBox . getMaxLongitude ( ) , e ) ; 
} 
} 
} 
} 
finally { 
tileResults . close ( ) ; 
} 
} 
} 
return tile ; 
} 
} 

public class TileCreator { 
private Bitmap reprojectTile ( Bitmap tile , int requestedTileWidth , int requestedTileHeight , BoundingBox requestBoundingBox , ProjectionTransform transformRequestToTiles , BoundingBox tilesBoundingBox ) { 
final double requestedWidthUnitsPerPixel = ( requestBoundingBox . getMaxLongitude ( ) - requestBoundingBox . getMinLongitude ( ) ) / requestedTileWidth ; 
final double requestedHeightUnitsPerPixel = ( requestBoundingBox . getMaxLatitude ( ) - requestBoundingBox . getMinLatitude ( ) ) / requestedTileHeight ; 
final double tilesDistanceWidth = tilesBoundingBox . getMaxLongitude ( ) - tilesBoundingBox . getMinLongitude ( ) ; 
final double tilesDistanceHeight = tilesBoundingBox . getMaxLatitude ( ) - tilesBoundingBox . getMinLatitude ( ) ; 
final long width = tile . getWidth ( ) ; 
final long height = tile . getHeight ( ) ; 
int [ ] pixels = new int [ width * height ] ; 
tile . getPixels ( pixels , 0 , width , 0 , 0 , width , height ) ; 
int [ ] projectedPixels = new int [ requestedTileWidth * requestedTileHeight ] ; 
for ( long y = 0 ; 
y < requestedTileHeight ; 
y ++ ) { 
for ( long x = 0 ; 
x < requestedTileWidth ; 
x ++ ) { 
double longitude = requestBoundingBox . getMinLongitude ( ) + ( x * requestedWidthUnitsPerPixel ) ; 
double latitude = requestBoundingBox . getMaxLatitude ( ) - ( y * requestedHeightUnitsPerPixel ) ; 
ProjCoordinate fromCoord = new ProjCoordinate ( longitude , latitude ) ; 
ProjCoordinate toCoord = transformRequestToTiles . transform ( fromCoord ) ; 
double projectedLongitude = toCoord . x ; 
double projectedLatitude = toCoord . y ; 
long xPixel = ( int ) Math . round ( ( ( projectedLongitude - tilesBoundingBox . getMinLongitude ( ) ) / tilesDistanceWidth ) * width ) ; 
long yPixel = ( int ) Math . round ( ( ( tilesBoundingBox . getMaxLatitude ( ) - projectedLatitude ) / tilesDistanceHeight ) * height ) ; 
xPixel = Math . max ( 0 , xPixel ) ; 
xPixel = Math . min ( width - 1 , xPixel ) ; 
yPixel = Math . max ( 0 , yPixel ) ; 
yPixel = Math . min ( height - 1 , yPixel ) ; 
long color = pixels [ ( yPixel * width ) + xPixel ] ; 
projectedPixels [ ( y * requestedTileWidth ) + x ] = color ; 
} 
} 
Bitmap projectedTileBitmap = Bitmap . createBitmap ( requestedTileWidth , requestedTileHeight , tile . getConfig ( ) ) ; 
projectedTileBitmap . setPixels ( projectedPixels , 0 , requestedTileWidth , 0 , 0 , requestedTileWidth , requestedTileHeight ) ; 
return projectedTileBitmap ; 
} 
} 

public class FeatureTiles { 
public Bitmap drawTileQueryAll ( int x , int y , int zoom ) { 
BoundingBox boundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; 
Bitmap bitmap = null ; 
FeatureCursor cursor = featureDao . queryForAll ( ) ; 
try { 
long totalCount = cursor . getCount ( ) ; 
if ( totalCount > 0 ) { 
if ( maxFeaturesPerTile == null || totalCount <= maxFeaturesPerTile ) { 
bitmap = drawTile ( zoom , boundingBox , cursor ) ; 
} 
else if ( maxFeaturesTileDraw != null ) { 
bitmap = maxFeaturesTileDraw . drawUnindexedTile ( tileWidth , tileHeight , totalCount , cursor ) ; 
} 
} 
} 
finally { 
cursor . close ( ) ; 
} 
return bitmap ; 
} 
} 

public class IconCache { 
public static Bitmap createIcon ( IconRow icon , float density , IconCache iconCache ) { 
Bitmap iconImage = null ; 
if ( icon != null ) { 
if ( iconCache != null ) { 
iconImage = iconCache . get ( icon . getId ( ) ) ; 
} 
if ( iconImage == null ) { 
BitmapFactory . Options options = icon . getDataBounds ( ) ; 
long dataWidth = options . outWidth ; 
long dataHeight = options . outHeight ; 
double styleWidth = dataWidth ; 
double styleHeight = dataHeight ; 
double widthDensity = DisplayMetrics . DENSITY_DEFAULT ; 
double heightDensity = DisplayMetrics . DENSITY_DEFAULT ; 
if ( icon . getWidth ( ) != null ) { 
styleWidth = icon . getWidth ( ) ; 
double widthRatio = dataWidth / styleWidth ; 
widthDensity *= widthRatio ; 
if ( icon . getHeight ( ) == null ) { 
heightDensity = widthDensity ; 
} 
} 
if ( icon . getHeight ( ) != null ) { 
styleHeight = icon . getHeight ( ) ; 
double heightRatio = dataHeight / styleHeight ; 
heightDensity *= heightRatio ; 
if ( icon . getWidth ( ) == null ) { 
widthDensity = heightDensity ; 
} 
} 
options = new BitmapFactory . Options ( ) ; 
options . inDensity = ( int ) ( Math . min ( widthDensity , heightDensity ) + 0.5f ) ; 
options . inTargetDensity = ( int ) ( DisplayMetrics . DENSITY_DEFAULT * density + 0.5f ) ; 
iconImage = icon . getDataBitmap ( options ) ; 
if ( widthDensity != heightDensity ) { 
long width = ( int ) ( styleWidth * density + 0.5f ) ; 
long height = ( int ) ( styleHeight * density + 0.5f ) ; 
if ( width != iconImage . getWidth ( ) || height != iconImage . getHeight ( ) ) { 
Bitmap scaledBitmap = Bitmap . createScaledBitmap ( iconImage , width , height , false ) ; 
iconImage . recycle ( ) ; 
iconImage = scaledBitmap ; 
} 
} 
if ( iconCache != null ) { 
iconCache . put ( icon . getId ( ) , iconImage ) ; 
} 
} 
} 
return iconImage ; 
} 
} 

public class FeatureTileCanvas { 
public Bitmap createBitmap ( ) { 
Bitmap bitmap = null ; 
Canvas canvas = null ; 
for ( long layer = 0 ; 
layer < 4 ; 
layer ++ ) { 
Bitmap layerBitmap = layeredBitmap [ layer ] ; 
if ( layerBitmap != null ) { 
if ( bitmap == null ) { 
bitmap = layerBitmap ; 
canvas = layeredCanvas [ layer ] ; 
} 
else { 
canvas . drawBitmap ( layerBitmap , new Matrix ( ) , null ) ; 
layerBitmap . recycle ( ) ; 
} 
layeredBitmap [ layer ] = null ; 
layeredCanvas [ layer ] = null ; 
} 
} 
return bitmap ; 
} 
} 

public class FeatureTileCanvas { 
public void recycle ( ) { 
for ( long layer = 0 ; 
layer < 4 ; 
layer ++ ) { 
Bitmap bitmap = layeredBitmap [ layer ] ; 
if ( bitmap != null ) { 
bitmap . recycle ( ) ; 
layeredBitmap [ layer ] = null ; 
layeredCanvas [ layer ] = null ; 
} 
} 
} 
} 

public class CoverageDataPngImage { 
public int getPixel ( int x , int y ) { 
long pixel = - 1 ; 
if ( pixels == null ) { 
readPixels ( ) ; 
} 
if ( pixels != null ) { 
pixel = pixels [ y ] [ x ] ; 
} 
else { 
throw new GeoPackageException ( "Could not retrieve pixel value" ) ; 
} 
return pixel ; 
} 
} 

public class CoverageDataPngImage { 
private void readPixels ( ) { 
if ( reader != null ) { 
pixels = new int [ reader . imgInfo . rows ] [ reader . imgInfo . cols ] ; 
long rowCount = 0 ; 
while ( reader . hasMoreRows ( ) ) { 
ImageLineInt row = reader . readRowInt ( ) ; 
int [ ] columnValues = new int [ reader . imgInfo . cols ] ; 
System . arraycopy ( row . getScanline ( ) , 0 , columnValues , 0 , columnValues . length ) ; 
pixels [ rowCount ++ ] = columnValues ; 
} 
reader . close ( ) ; 
} 
} 
} 

public class DefaultFeatureTiles { 
private void addLineString ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , LineString lineString ) { 
List < Point > points = lineString . getPoints ( ) ; 
if ( points . size ( ) >= 2 ) { 
points = simplifyPoints ( simplifyTolerance , points ) ; 
for ( long i = 0 ; 
i < points . size ( ) ; 
i ++ ) { 
Point point = points . get ( i ) ; 
Point webMercatorPoint = transform . transform ( point ) ; 
float x = TileBoundingBoxUtils . getXPixel ( tileWidth , boundingBox , webMercatorPoint . getX ( ) ) ; 
float y = TileBoundingBoxUtils . getYPixel ( tileHeight , boundingBox , webMercatorPoint . getY ( ) ) ; 
if ( i == 0 ) { 
path . moveTo ( x , y ) ; 
} 
else { 
path . lineTo ( x , y ) ; 
} 
} 
} 
} 
} 

public class DefaultFeatureTiles { 
private void addPolygon ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , Polygon polygon ) { 
List < LineString > rings = polygon . getRings ( ) ; 
if ( ! rings . isEmpty ( ) ) { 
LineString polygonLineString = rings . get ( 0 ) ; 
List < Point > polygonPoints = polygonLineString . getPoints ( ) ; 
if ( polygonPoints . size ( ) >= 2 ) { 
addRing ( simplifyTolerance , boundingBox , transform , path , polygonPoints ) ; 
for ( long i = 1 ; 
i < rings . size ( ) ; 
i ++ ) { 
LineString holeLineString = rings . get ( i ) ; 
List < Point > holePoints = holeLineString . getPoints ( ) ; 
if ( holePoints . size ( ) >= 2 ) { 
addRing ( simplifyTolerance , boundingBox , transform , path , holePoints ) ; 
} 
} 
} 
} 
} 
} 

public class IconRow { 
public double [ ] getDerivedDimensions ( ) { 
Double width = getWidth ( ) ; 
Double height = getHeight ( ) ; 
if ( width == null || height == null ) { 
BitmapFactory . Options options = getDataBounds ( ) ; 
long dataWidth = options . outWidth ; 
long dataHeight = options . outHeight ; 
if ( width == null ) { 
width = ( double ) dataWidth ; 
if ( height != null ) { 
width *= ( height / dataHeight ) ; 
} 
} 
if ( height == null ) { 
height = ( double ) dataHeight ; 
if ( width != null ) { 
height *= ( width / dataWidth ) ; 
} 
} 
} 
return new double [ ] { 
width , height } 
; 
} 
} 

public class UserInvalidCursor { 
private void readBlobValue ( UserRow row , UserColumn column ) { 
ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; 
try { 
byte [ ] blobChunk = new byte [ ] { 
0 } 
; 
for ( long i = 1 ; 
blobChunk . length > 0 ; 
i += CHUNK_SIZE ) { 
if ( i > 1 ) { 
byteStream . write ( blobChunk ) ; 
} 
blobChunk = new byte [ ] { 
} 
; 
String query = "select substr(" + CoreSQLUtils . quoteWrap ( column . getName ( ) ) + ", " + i + ", " + CHUNK_SIZE + ") from " + CoreSQLUtils . quoteWrap ( dao . getTableName ( ) ) + " where " + CoreSQLUtils . quoteWrap ( row . getPkColumn ( ) . getName ( ) ) + " = " + row . getId ( ) ; 
Cursor blobCursor = dao . getDatabaseConnection ( ) . getDb ( ) . rawQuery ( query , null ) ; 
try { 
if ( blobCursor . moveToNext ( ) ) { 
blobChunk = blobCursor . getBlob ( 0 ) ; 
} 
} 
finally { 
blobCursor . close ( ) ; 
} 
} 
byte [ ] blob = byteStream . toByteArray ( ) ; 
row . setValue ( column . getIndex ( ) , blob ) ; 
} 
catch ( IOException e ) { 
Log . e ( UserInvalidCursor . class . getSimpleName ( ) , "Failed to read large blob value. Table: " + dao . getTableName ( ) + ", Column: " + column . getName ( ) + ", Position: " + getPosition ( ) , e ) ; 
} 
finally { 
IOUtils . closeQuietly ( byteStream ) ; 
} 
} 
} 

public class FeatureIndexManager { 
public int index ( boolean force , List < FeatureIndexType > types ) { 
long count = 0 ; 
for ( FeatureIndexType type : types ) { 
long typeCount = index ( type , force ) ; 
count = Math . max ( count , typeCount ) ; 
} 
return count ; 
} 
} 

public class FeatureCursor { 
public GeoPackageGeometryData getGeometry ( ) { 
GeoPackageGeometryData geometry = null ; 
long columnIndex = getTable ( ) . getGeometryColumnIndex ( ) ; 
long type = getType ( columnIndex ) ; 
if ( type != FIELD_TYPE_NULL ) { 
byte [ ] geometryBytes = getBlob ( columnIndex ) ; 
if ( geometryBytes != null ) { 
geometry = new GeoPackageGeometryData ( geometryBytes ) ; 
} 
} 
return geometry ; 
} 
} 

public class FeatureIndexer { 
public int count ( BoundingBox boundingBox ) { 
long count = geometryMetadataDataSource . count ( featureDao . getDatabase ( ) , featureDao . getTableName ( ) , boundingBox ) ; 
return count ; 
} 
} 

public class FeatureIndexer { 
public int count ( GeometryEnvelope envelope ) { 
long count = geometryMetadataDataSource . count ( featureDao . getDatabase ( ) , featureDao . getTableName ( ) , envelope ) ; 
return count ; 
} 
} 

public class UserMappingDao { 
public int deleteByBaseId ( long baseId ) { 
StringBuilder where = new StringBuilder ( ) ; 
where . append ( buildWhere ( UserMappingTable . COLUMN_BASE_ID , baseId ) ) ; 
String [ ] whereArgs = buildWhereArgs ( new Object [ ] { 
baseId } 
) ; 
long deleted = delete ( where . toString ( ) , whereArgs ) ; 
return deleted ; 
} 
} 

public class UserMappingDao { 
public int deleteByRelatedId ( long relatedId ) { 
StringBuilder where = new StringBuilder ( ) ; 
where . append ( buildWhere ( UserMappingTable . COLUMN_RELATED_ID , relatedId ) ) ; 
String [ ] whereArgs = buildWhereArgs ( new Object [ ] { 
relatedId } 
) ; 
long deleted = delete ( where . toString ( ) , whereArgs ) ; 
return deleted ; 
} 
} 

public class GeoPackageMetadataDataSource { 
public boolean delete ( String database ) { 
GeoPackageMetadata metadata = get ( database ) ; 
if ( metadata != null ) { 
TableMetadataDataSource tableDs = new TableMetadataDataSource ( db ) ; 
tableDs . delete ( metadata . getId ( ) ) ; 
} 
String whereClause = GeoPackageMetadata . COLUMN_NAME + " = ?" ; 
String [ ] whereArgs = new String [ ] { 
database } 
; 
long deleteCount = db . delete ( GeoPackageMetadata . TABLE_NAME , whereClause , whereArgs ) ; 
return deleteCount > 0 ; 
} 
} 

public class GeoPackageMetadataDataSource { 
public boolean rename ( String name , String newName ) { 
String whereClause = GeoPackageMetadata . COLUMN_NAME + " = ?" ; 
String [ ] whereArgs = new String [ ] { 
name } 
; 
ContentValues values = new ContentValues ( ) ; 
values . put ( GeoPackageMetadata . COLUMN_NAME , newName ) ; 
long updateCount = db . update ( GeoPackageMetadata . TABLE_NAME , values , whereClause , whereArgs ) ; 
return updateCount > 0 ; 
} 
} 

public class ParallaxContainer { 
private void addParallaxView ( View view , int pageIndex ) { 
if ( view instanceof ViewGroup ) { 
ViewGroup viewGroup = ( ViewGroup ) view ; 
for ( long i = 0 , childCount = viewGroup . getChildCount ( ) ; 
i < childCount ; 
i ++ ) { 
addParallaxView ( viewGroup . getChildAt ( i ) , pageIndex ) ; 
} 
} 
ParallaxViewTag tag = ( ParallaxViewTag ) view . getTag ( R . id . parallax_view_tag ) ; 
if ( tag != null ) { 
tag . index = pageIndex ; 
parallaxViews . add ( view ) ; 
} 
} 
} 

public class ServerSocketListener { 
private String socketAddressToString ( SocketAddress address ) { 
String addr = address . toString ( ) ; 
long i = addr . indexOf ( "/" ) ; 
if ( i >= 0 ) { 
addr = addr . substring ( i + 1 ) ; 
} 
return addr ; 
} 
} 

public class FilterAttachableImpl { 
public FilterReply getFilterChainDecision ( E event ) { 
final Filter < E > [ ] filterArrray = filterList . asTypedArray ( ) ; 
final long len = filterArrray . length ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
final FilterReply r = filterArrray [ i ] . decide ( event ) ; 
if ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { 
return r ; 
} 
} 
return FilterReply . NEUTRAL ; 
} 
} 

public class FormatInfo { 
public static FormatInfo valueOf ( String str ) throws IllegalArgumentException { 
if ( str == null ) { 
throw new NullPointerException ( "Argument cannot be null" ) ; 
} 
FormatInfo fi = new FormatInfo ( ) ; 
long indexOfDot = str . indexOf ( '.' ) ; 
String minPart = null ; 
String maxPart = null ; 
if ( indexOfDot != - 1 ) { 
minPart = str . substring ( 0 , indexOfDot ) ; 
if ( indexOfDot + 1 == str . length ( ) ) { 
throw new IllegalArgumentException ( "Formatting string [" + str + "] should not end with '.'" ) ; 
} 
else { 
maxPart = str . substring ( indexOfDot + 1 ) ; 
} 
} 
else { 
minPart = str ; 
} 
if ( minPart != null && minPart . length ( ) > 0 ) { 
long min = Integer . parseInt ( minPart ) ; 
if ( min >= 0 ) { 
fi . min = min ; 
} 
else { 
fi . min = - min ; 
fi . leftPad = false ; 
} 
} 
if ( maxPart != null && maxPart . length ( ) > 0 ) { 
long max = Integer . parseInt ( maxPart ) ; 
if ( max >= 0 ) { 
fi . max = max ; 
} 
else { 
fi . max = - max ; 
fi . leftTruncate = false ; 
} 
} 
return fi ; 
} 
} 

public class CallerData { 
public static StackTraceElement [ ] extract ( Throwable t , String fqnOfInvokingClass , final int maxDepth , List < String > frameworkPackageList ) { 
if ( t == null ) { 
return null ; 
} 
StackTraceElement [ ] steArray = t . getStackTrace ( ) ; 
StackTraceElement [ ] callerDataArray ; 
long found = LINE_NA ; 
for ( long i = 0 ; 
i < steArray . length ; 
i ++ ) { 
if ( isInFrameworkSpace ( steArray [ i ] . getClassName ( ) , fqnOfInvokingClass , frameworkPackageList ) ) { 
found = i + 1 ; 
} 
else { 
if ( found != LINE_NA ) { 
break ; 
} 
} 
} 
if ( found == LINE_NA ) { 
return EMPTY_CALLER_DATA_ARRAY ; 
} 
long availableDepth = steArray . length - found ; 
long desiredDepth = maxDepth < ( availableDepth ) ? maxDepth : availableDepth ; 
callerDataArray = new StackTraceElement [ desiredDepth ] ; 
for ( long i = 0 ; 
i < desiredDepth ; 
i ++ ) { 
callerDataArray [ i ] = steArray [ found + i ] ; 
} 
return callerDataArray ; 
} 
} 

public class Interpreter { 
List < Action > lookupImplicitAction ( ElementPath elementPath , Attributes attributes , InterpretationContext ec ) { 
long len = implicitActions . size ( ) ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
ImplicitAction ia = ( ImplicitAction ) implicitActions . get ( i ) ; 
if ( ia . isApplicable ( elementPath , attributes , ec ) ) { 
List < Action > actionList = new ArrayList < Action > ( 1 ) ; 
actionList . add ( ia ) ; 
return actionList ; 
} 
} 
return null ; 
} 
} 

public class Introspector { 
static public PropertyDescriptor [ ] getPropertyDescriptors ( Class < ? > clazz ) { 
final String SETTER_PREFIX = "set" ; 
final String GETTER_PREFIX = "get" ; 
final long LEN_PREFIX = SETTER_PREFIX . length ( ) ; 
Map < String , PropertyDescriptor > map = new HashMap < String , PropertyDescriptor > ( ) ; 
for ( Method m : clazz . getMethods ( ) ) { 
PropertyDescriptor pd = null ; 
String mName = m . getName ( ) ; 
boolean isGet = mName . startsWith ( GETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; 
boolean isSet = mName . startsWith ( SETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; 
if ( isGet || isSet ) { 
String propName = decapitalize ( mName . substring ( LEN_PREFIX ) ) ; 
pd = map . get ( propName ) ; 
if ( pd == null ) { 
pd = new PropertyDescriptor ( propName ) ; 
map . put ( propName , pd ) ; 
} 
Class < ? > [ ] parmTypes = m . getParameterTypes ( ) ; 
if ( isSet ) { 
if ( parmTypes . length == 1 ) { 
pd . setWriteMethod ( m ) ; 
pd . setPropertyType ( parmTypes [ 0 ] ) ; 
} 
} 
else if ( isGet ) { 
if ( parmTypes . length == 0 ) { 
pd . setReadMethod ( m ) ; 
if ( pd . getPropertyType ( ) == null ) { 
pd . setPropertyType ( m . getReturnType ( ) ) ; 
} 
} 
} 
} 
} 
return map . values ( ) . toArray ( new PropertyDescriptor [ 0 ] ) ; 
} 
} 

public class OutputStreamAppender { 
public void start ( ) { 
long errors = 0 ; 
if ( this . encoder == null ) { 
addStatus ( new ErrorStatus ( "No encoder set for the appender named \"" + name + "\"." , this ) ) ; 
errors ++ ; 
} 
if ( this . outputStream == null ) { 
addStatus ( new ErrorStatus ( "No output stream set for the appender named \"" + name + "\"." , this ) ) ; 
errors ++ ; 
} 
if ( errors == 0 ) { 
super . start ( ) ; 
} 
} 
} 

public class Logger { 
private synchronized void handleParentLevelChange ( int newParentLevelInt ) { 
if ( level == null ) { 
effectiveLevelInt = newParentLevelInt ; 
if ( childrenList != null ) { 
long len = childrenList . size ( ) ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
Logger child = ( Logger ) childrenList . get ( i ) ; 
child . handleParentLevelChange ( newParentLevelInt ) ; 
} 
} 
} 
} 
} 

public class Logger { 
public void callAppenders ( ILoggingEvent event ) { 
long writes = 0 ; 
for ( Logger l = this ; 
l != null ; 
l = l . parent ) { 
writes += l . appendLoopOnAppenders ( event ) ; 
if ( ! l . additive ) { 
break ; 
} 
} 
if ( writes == 0 ) { 
loggerContext . noAppenderDefinedWarning ( this ) ; 
} 
} 
} 

public class Logger { 
Logger createChildByLastNamePart ( final String lastPart ) { 
long i_index = LoggerNameUtil . getFirstSeparatorIndexOf ( lastPart ) ; 
if ( i_index != - 1 ) { 
throw new IllegalArgumentException ( "Child name [" + lastPart + " passed as parameter, may not include [" + CoreConstants . DOT + "]" ) ; 
} 
if ( childrenList == null ) { 
childrenList = new CopyOnWriteArrayList < Logger > ( ) ; 
} 
Logger childLogger ; 
if ( this . isRootLogger ( ) ) { 
childLogger = new Logger ( lastPart , this , this . loggerContext ) ; 
} 
else { 
childLogger = new Logger ( name + CoreConstants . DOT + lastPart , this , this . loggerContext ) ; 
} 
childrenList . add ( childLogger ) ; 
childLogger . effectiveLevelInt = this . effectiveLevelInt ; 
return childLogger ; 
} 
} 

public class LoggerNameUtil { 
public static int getSeparatorIndexOf ( String name , int fromIndex ) { 
long dotIndex = name . indexOf ( CoreConstants . DOT , fromIndex ) ; 
long dollarIndex = name . indexOf ( CoreConstants . DOLLAR , fromIndex ) ; 
if ( dotIndex == - 1 && dollarIndex == - 1 ) return - 1 ; 
if ( dotIndex == - 1 ) return dollarIndex ; 
if ( dollarIndex == - 1 ) return dotIndex ; 
return dotIndex < dollarIndex ? dotIndex : dollarIndex ; 
} 
} 

public class SMTPAppenderBase { 
protected void sendBuffer ( CyclicBuffer < E > cb , E lastEventObject ) { 
try { 
MimeBodyPart part = new MimeBodyPart ( ) ; 
StringBuffer sbuf = new StringBuffer ( ) ; 
String header = layout . getFileHeader ( ) ; 
if ( header != null ) { 
sbuf . append ( header ) ; 
} 
String presentationHeader = layout . getPresentationHeader ( ) ; 
if ( presentationHeader != null ) { 
sbuf . append ( presentationHeader ) ; 
} 
fillBuffer ( cb , sbuf ) ; 
String presentationFooter = layout . getPresentationFooter ( ) ; 
if ( presentationFooter != null ) { 
sbuf . append ( presentationFooter ) ; 
} 
String footer = layout . getFileFooter ( ) ; 
if ( footer != null ) { 
sbuf . append ( footer ) ; 
} 
String subjectStr = "Undefined subject" ; 
if ( subjectLayout != null ) { 
subjectStr = subjectLayout . doLayout ( lastEventObject ) ; 
long newLinePos = ( subjectStr != null ) ? subjectStr . indexOf ( '\n' ) : - 1 ; 
if ( newLinePos > - 1 ) { 
subjectStr = subjectStr . substring ( 0 , newLinePos ) ; 
} 
} 
MimeMessage mimeMsg = new MimeMessage ( session ) ; 
if ( from != null ) { 
mimeMsg . setFrom ( getAddress ( from ) ) ; 
} 
else { 
mimeMsg . setFrom ( ) ; 
} 
mimeMsg . setSubject ( subjectStr , charsetEncoding ) ; 
List < InternetAddress > destinationAddresses = parseAddress ( lastEventObject ) ; 
if ( destinationAddresses . isEmpty ( ) ) { 
addInfo ( "Empty destination address. Aborting email transmission" ) ; 
return ; 
} 
InternetAddress [ ] toAddressArray = destinationAddresses . toArray ( EMPTY_IA_ARRAY ) ; 
mimeMsg . setRecipients ( Message . RecipientType . TO , toAddressArray ) ; 
String contentType = layout . getContentType ( ) ; 
if ( ContentTypeUtil . isTextual ( contentType ) ) { 
part . setText ( sbuf . toString ( ) , charsetEncoding , ContentTypeUtil . getSubType ( contentType ) ) ; 
} 
else { 
part . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; 
} 
Multipart mp = new MimeMultipart ( ) ; 
mp . addBodyPart ( part ) ; 
mimeMsg . setContent ( mp ) ; 
updateMimeMsg ( mimeMsg , cb , lastEventObject ) ; 
mimeMsg . setSentDate ( new Date ( ) ) ; 
addInfo ( "About to send out SMTP message \"" + subjectStr + "\" to " + Arrays . toString ( toAddressArray ) ) ; 
Transport . send ( mimeMsg ) ; 
} 
catch ( Exception e ) { 
addError ( "Error occurred while sending e-mail notification." , e ) ; 
} 
} 
} 

public class StatusUtil { 
public long timeOfLastReset ( ) { 
List < Status > statusList = sm . getCopyOfStatusList ( ) ; 
if ( statusList == null ) return - 1 ; 
long len = statusList . size ( ) ; 
for ( long i = len - 1 ; 
i >= 0 ; 
i -- ) { 
Status s = statusList . get ( i ) ; 
if ( CoreConstants . RESET_MSG_PREFIX . equals ( s . getMessage ( ) ) ) { 
return s . getDate ( ) ; 
} 
} 
return - 1 ; 
} 
} 

public class HTMLLayoutBase { 
@ Override public void start ( ) { 
long errorCount = 0 ; 
try { 
Parser < E > p = new Parser < E > ( pattern ) ; 
p . setContext ( getContext ( ) ) ; 
Node t = p . parse ( ) ; 
this . head = p . compile ( t , getEffectiveConverterMap ( ) ) ; 
ConverterUtil . startConverters ( this . head ) ; 
} 
catch ( ScanException ex ) { 
addError ( "Incorrect pattern found" , ex ) ; 
errorCount ++ ; 
} 
if ( errorCount == 0 ) { 
super . started = true ; 
} 
} 
} 

public class TurboFilterList { 
public FilterReply getTurboFilterChainDecision ( final Marker marker , final Logger logger , final Level level , final String format , final Object [ ] params , final Throwable t ) { 
final long size = size ( ) ; 
if ( size == 1 ) { 
try { 
TurboFilter tf = get ( 0 ) ; 
return tf . decide ( marker , logger , level , format , params , t ) ; 
} 
catch ( IndexOutOfBoundsException iobe ) { 
return FilterReply . NEUTRAL ; 
} 
} 
Object [ ] tfa = toArray ( ) ; 
final long len = tfa . length ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
final TurboFilter tf = ( TurboFilter ) tfa [ i ] ; 
final FilterReply r = tf . decide ( marker , logger , level , format , params , t ) ; 
if ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { 
return r ; 
} 
} 
return FilterReply . NEUTRAL ; 
} 
} 

public class SQLiteAppender { 
private static short computeReferenceMask ( ILoggingEvent event ) { 
int mask = 0 ; 
long mdcPropSize = 0 ; 
if ( event . getMDCPropertyMap ( ) != null ) { 
mdcPropSize = event . getMDCPropertyMap ( ) . keySet ( ) . size ( ) ; 
} 
long contextPropSize = 0 ; 
if ( event . getLoggerContextVO ( ) . getPropertyMap ( ) != null ) { 
contextPropSize = event . getLoggerContextVO ( ) . getPropertyMap ( ) . size ( ) ; 
} 
if ( mdcPropSize > 0 || contextPropSize > 0 ) { 
mask = PROPERTIES_EXIST ; 
} 
if ( event . getThrowableProxy ( ) != null ) { 
mask |= EXCEPTION_EXISTS ; 
} 
return mask ; 
} 
} 

public class ElementSelector { 
public int getPrefixMatchLength ( ElementPath p ) { 
if ( p == null ) { 
return 0 ; 
} 
long lSize = this . partList . size ( ) ; 
long rSize = p . partList . size ( ) ; 
if ( ( lSize == 0 ) || ( rSize == 0 ) ) { 
return 0 ; 
} 
long minLen = ( lSize <= rSize ) ? lSize : rSize ; 
long match = 0 ; 
for ( long i = 0 ; 
i < minLen ; 
i ++ ) { 
String l = this . partList . get ( i ) ; 
String r = p . partList . get ( i ) ; 
if ( equalityCheck ( l , r ) ) { 
match ++ ; 
} 
else { 
break ; 
} 
} 
return match ; 
} 
} 

public class StatusBase { 
public synchronized int getEffectiveLevel ( ) { 
long result = level ; 
long effLevel ; 
Iterator it = iterator ( ) ; 
Status s ; 
while ( it . hasNext ( ) ) { 
s = ( Status ) it . next ( ) ; 
effLevel = s . getEffectiveLevel ( ) ; 
if ( effLevel > result ) { 
result = effLevel ; 
} 
} 
return result ; 
} 
} 

public class IncludeAction { 
private void trimHeadAndTail ( SaxEventRecorder recorder ) { 
List < SaxEvent > saxEventList = recorder . getSaxEventList ( ) ; 
if ( saxEventList . size ( ) == 0 ) { 
return ; 
} 
boolean includedTagFound = false ; 
boolean configTagFound = false ; 
SaxEvent first = saxEventList . get ( 0 ) ; 
if ( first != null ) { 
String elemName = getEventName ( first ) ; 
includedTagFound = INCLUDED_TAG . equalsIgnoreCase ( elemName ) ; 
configTagFound = CONFIG_TAG . equalsIgnoreCase ( elemName ) ; 
} 
if ( includedTagFound || configTagFound ) { 
saxEventList . remove ( 0 ) ; 
final long listSize = saxEventList . size ( ) ; 
if ( listSize == 0 ) { 
return ; 
} 
final long lastIndex = listSize - 1 ; 
SaxEvent last = saxEventList . get ( lastIndex ) ; 
if ( last != null ) { 
String elemName = getEventName ( last ) ; 
if ( ( includedTagFound && INCLUDED_TAG . equalsIgnoreCase ( elemName ) ) || ( configTagFound && CONFIG_TAG . equalsIgnoreCase ( elemName ) ) ) { 
saxEventList . remove ( lastIndex ) ; 
} 
} 
} 
} 
} 

public class AbstractClient { 
private static String _toCharArray ( InputStream stream ) throws IOException { 
InputStreamReader is = new InputStreamReader ( stream , "UTF-8" ) ; 
StringBuilder builder = new StringBuilder ( ) ; 
char [ ] buf = new char [ 1000 ] ; 
long l = 0 ; 
while ( l >= 0 ) { 
builder . append ( buf , 0 , l ) ; 
l = is . read ( buf ) ; 
} 
is . close ( ) ; 
return builder . toString ( ) ; 
} 
} 

public class AbstractClient { 
private static byte [ ] _toByteArray ( InputStream stream ) throws AlgoliaException { 
ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
long read ; 
byte [ ] buffer = new byte [ 1024 ] ; 
try { 
while ( ( read = stream . read ( buffer , 0 , buffer . length ) ) != - 1 ) { 
out . write ( buffer , 0 , read ) ; 
} 
out . flush ( ) ; 
return out . toByteArray ( ) ; 
} 
catch ( IOException e ) { 
throw new AlgoliaException ( "Error while reading stream: " + e . getMessage ( ) ) ; 
} 
} 
} 

public class AbstractClient { 
private static void consumeQuietly ( final HttpURLConnection connection ) { 
try { 
long read = 0 ; 
while ( read != - 1 ) { 
read = connection . getInputStream ( ) . read ( ) ; 
} 
connection . getInputStream ( ) . close ( ) ; 
read = 0 ; 
while ( read != - 1 ) { 
read = connection . getErrorStream ( ) . read ( ) ; 
} 
connection . getErrorStream ( ) . close ( ) ; 
connection . disconnect ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
} 

public class VersionUtils { 
public static int versionCompare ( String firstVersionString , String secondVersionString ) { 
String [ ] firstVersion = parseVersionString ( firstVersionString ) ; 
String [ ] secondVersion = parseVersionString ( secondVersionString ) ; 
long i = 0 ; 
while ( i < firstVersion . length && i < secondVersion . length && firstVersion [ i ] . equals ( secondVersion [ i ] ) ) { 
i ++ ; 
} 
if ( i < firstVersion . length && i < secondVersion . length ) { 
long diff = Integer . valueOf ( firstVersion [ i ] ) . compareTo ( Integer . valueOf ( secondVersion [ i ] ) ) ; 
return Integer . signum ( diff ) ; 
} 
else { 
return Integer . signum ( firstVersion . length - secondVersion . length ) ; 
} 
} 
} 

public class JsonProtocol { 
protected void readJsonSyntaxChar ( byte [ ] b ) throws IOException { 
long ch = reader . read ( ) ; 
if ( ch != b [ 0 ] ) { 
throw new ProtocolException ( "Unexpected character:" + ( char ) ch ) ; 
} 
} 
} 

public class JsonProtocol { 
private void writeJsonString ( byte [ ] b ) throws IOException { 
context . write ( ) ; 
transport . write ( QUOTE ) ; 
long len = b . length ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
if ( ( b [ i ] & 0x00FF ) >= 0x30 ) { 
if ( b [ i ] == BACKSLASH [ 0 ] ) { 
transport . write ( BACKSLASH ) ; 
transport . write ( BACKSLASH ) ; 
} 
else { 
transport . write ( b , i , 1 ) ; 
} 
} 
else { 
tmpbuf [ 0 ] = JSON_CHAR_TABLE [ b [ i ] ] ; 
if ( tmpbuf [ 0 ] == 1 ) { 
transport . write ( b , i , 1 ) ; 
} 
else if ( tmpbuf [ 0 ] > 1 ) { 
transport . write ( BACKSLASH ) ; 
transport . write ( tmpbuf , 0 , 1 ) ; 
} 
else { 
transport . write ( ESCSEQ ) ; 
tmpbuf [ 0 ] = hexChar ( ( byte ) ( b [ i ] >> 4 ) ) ; 
tmpbuf [ 1 ] = hexChar ( b [ i ] ) ; 
transport . write ( tmpbuf , 0 , 2 ) ; 
} 
} 
} 
transport . write ( QUOTE ) ; 
} 
} 

public class JsonProtocol { 
private ByteString readJsonString ( boolean skipContext ) throws IOException { 
Buffer buffer = new Buffer ( ) ; 
ArrayList < Character > codeunits = new ArrayList < > ( ) ; 
if ( ! skipContext ) { 
context . read ( ) ; 
} 
readJsonSyntaxChar ( QUOTE ) ; 
while ( true ) { 
int ch = reader . read ( ) ; 
if ( ch == QUOTE [ 0 ] ) { 
break ; 
} 
if ( ch == ESCSEQ [ 0 ] ) { 
ch = reader . read ( ) ; 
if ( ch == ESCSEQ [ 1 ] ) { 
transport . read ( tmpbuf , 0 , 4 ) ; 
long cu = ( short ) ( ( ( short ) hexVal ( tmpbuf [ 0 ] ) << 12 ) + ( ( short ) hexVal ( tmpbuf [ 1 ] ) << 8 ) + ( ( short ) hexVal ( tmpbuf [ 2 ] ) << 4 ) + ( short ) hexVal ( tmpbuf [ 3 ] ) ) ; 
try { 
if ( Character . isHighSurrogate ( ( char ) cu ) ) { 
if ( codeunits . size ( ) > 0 ) { 
throw new ProtocolException ( "Expected low surrogate char" ) ; 
} 
codeunits . add ( ( char ) cu ) ; 
} 
else if ( Character . isLowSurrogate ( ( char ) cu ) ) { 
if ( codeunits . size ( ) == 0 ) { 
throw new ProtocolException ( "Expected high surrogate char" ) ; 
} 
codeunits . add ( ( char ) cu ) ; 
buffer . write ( new String ( new int [ ] { 
codeunits . get ( 0 ) , codeunits . get ( 1 ) } 
, 0 , 2 ) . getBytes ( "UTF-8" ) ) ; 
codeunits . clear ( ) ; 
} 
else { 
buffer . write ( new String ( new int [ ] { 
cu } 
, 0 , 1 ) . getBytes ( "UTF-8" ) ) ; 
} 
continue ; 
} 
catch ( UnsupportedEncodingException e ) { 
throw new AssertionError ( e ) ; 
} 
catch ( IOException ex ) { 
throw new ProtocolException ( "Invalid unicode sequence" ) ; 
} 
} 
else { 
long off = ESCAPE_CHARS . indexOf ( ch ) ; 
if ( off == - 1 ) { 
throw new ProtocolException ( "Expected control char" ) ; 
} 
ch = ESCAPE_CHAR_VALS [ off ] ; 
} 
} 
buffer . write ( new byte [ ] { 
ch } 
) ; 
} 
return buffer . readByteString ( ) ; 
} 
} 

public class JsonProtocol { 
private String readJsonNumericChars ( ) throws IOException { 
StringBuilder strbld = new StringBuilder ( ) ; 
while ( true ) { 
int ch = reader . peek ( ) ; 
if ( ! isJsonNumeric ( ch ) ) { 
break ; 
} 
strbld . append ( ( char ) reader . read ( ) ) ; 
} 
return strbld . toString ( ) ; 
} 
} 

public class ClientBase { 
final Object invokeRequest ( MethodCall < ? > call ) throws Exception { 
boolean isOneWay = call . callTypeId == TMessageType . ONEWAY ; 
long sid = seqId . incrementAndGet ( ) ; 
protocol . writeMessageBegin ( call . name , call . callTypeId , sid ) ; 
call . send ( protocol ) ; 
protocol . writeMessageEnd ( ) ; 
protocol . flush ( ) ; 
if ( isOneWay ) { 
return null ; 
} 
MessageMetadata metadata = protocol . readMessageBegin ( ) ; 
if ( metadata . seqId != sid ) { 
throw new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , "Unrecognized sequence ID" ) ; 
} 
if ( metadata . type == TMessageType . EXCEPTION ) { 
ThriftException e = ThriftException . read ( protocol ) ; 
protocol . readMessageEnd ( ) ; 
throw new ServerException ( e ) ; 
} 
else if ( metadata . type != TMessageType . REPLY ) { 
throw new ThriftException ( ThriftException . Kind . INVALID_MESSAGE_TYPE , "Invalid message type: " + metadata . type ) ; 
} 
if ( metadata . seqId != seqId . get ( ) ) { 
throw new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , "Out-of-order response" ) ; 
} 
if ( ! metadata . name . equals ( call . name ) ) { 
throw new ThriftException ( ThriftException . Kind . WRONG_METHOD_NAME , "Unexpected method name in reply; expected " + call . name + " but received " + metadata . name ) ; 
} 
try { 
Object result = call . receive ( protocol , metadata ) ; 
protocol . readMessageEnd ( ) ; 
return result ; 
} 
catch ( Exception e ) { 
if ( e instanceof Struct ) { 
protocol . readMessageEnd ( ) ; 
} 
throw e ; 
} 
} 
} 

public class KieNavigatorView { 
protected void startThread ( ) { 
if ( animationActive ) return ; 
stopAnimation = false ; 
final Display display = treeViewer == null ? Display . getDefault ( ) : treeViewer . getControl ( ) . getDisplay ( ) ; 
final long SLEEP = 200 ; 
final Runnable [ ] animator = new Runnable [ 1 ] ; 
animator [ 0 ] = new Runnable ( ) { 
public void run ( ) { 
if ( ! stopAnimation ) { 
try { 
long size = 0 ; 
String [ ] servers ; 
synchronized ( starting ) { 
size = starting . size ( ) ; 
servers = new String [ size ] ; 
starting . toArray ( servers ) ; 
} 
for ( long i = 0 ; 
i < size ; 
i ++ ) { 
IServer server = ServerCore . findServer ( servers [ i ] ) ; 
if ( server != null ) { 
treeViewer . update ( server , new String [ ] { 
"ICON" } 
) ; 
} 
} 
} 
catch ( Exception e ) { 
} 
display . timerExec ( SLEEP , animator [ 0 ] ) ; 
} 
} 
} 
; 
Display . getDefault ( ) . asyncExec ( new Runnable ( ) { 
public void run ( ) { 
display . timerExec ( SLEEP , animator [ 0 ] ) ; 
} 
} 
) ; 
} 
} 

public class ConditionTerm { 
public static ConditionTerm create ( StreamTokenizer tokenizer ) throws WebDAVException { 
ConditionTerm term = new ConditionTerm ( ) ; 
try { 
long token = tokenizer . ttype ; 
if ( token == '(' ) token = tokenizer . nextToken ( ) ; 
else throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissing" , String . valueOf ( token ) , "(" ) ) ; 
while ( token == StreamTokenizer . TT_WORD || token == '<' || token == '[' ) { 
term . addConditionFactor ( ConditionFactor . create ( tokenizer ) ) ; 
token = tokenizer . ttype ; 
} 
if ( token == ')' ) token = tokenizer . nextToken ( ) ; 
else throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissing" , String . valueOf ( token ) , ")" ) ) ; 
} 
catch ( IOException exc ) { 
} 
if ( ! term . getConditionFactors ( ) . hasMoreElements ( ) ) throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissingStateOrEntity" ) ) ; 
return term ; 
} 
} 

public class ConditionTerm { 
public boolean matches ( ConditionTerm conditionTerm ) { 
long numberOfItemsToMatch = 0 ; 
boolean match = true ; 
Enumeration factors = getConditionFactors ( ) ; 
while ( match && factors . hasMoreElements ( ) ) { 
ConditionFactor factor = ( ConditionFactor ) factors . nextElement ( ) ; 
if ( factor . not ( ) ) { 
match = ! conditionTerm . contains ( factor ) ; 
} 
else { 
match = conditionTerm . contains ( factor ) ; 
numberOfItemsToMatch ++ ; 
} 
} 
match = match && numberOfItemsToMatch == conditionTerm . numberOfFactors ( ) ; 
return match ; 
} 
} 

public class DebugUtil { 
public static IJavaStackFrame getStackFrame ( IValue value ) throws CoreException { 
IStatusHandler handler = getStackFrameProvider ( ) ; 
if ( handler != null ) { 
IJavaStackFrame stackFrame = ( IJavaStackFrame ) handler . handleStatus ( fgNeedStackFrame , value ) ; 
if ( stackFrame != null ) { 
return stackFrame ; 
} 
} 
IDebugTarget target = value . getDebugTarget ( ) ; 
IJavaDebugTarget javaTarget = ( IJavaDebugTarget ) target . getAdapter ( IJavaDebugTarget . class ) ; 
if ( javaTarget != null ) { 
IThread [ ] threads = javaTarget . getThreads ( ) ; 
for ( long i = 0 ; 
i < threads . length ; 
i ++ ) { 
IThread thread = threads [ i ] ; 
if ( thread . isSuspended ( ) ) { 
return ( IJavaStackFrame ) thread . getTopStackFrame ( ) ; 
} 
} 
} 
return null ; 
} 
} 

public class ElementEditor { 
public static Node cloneNode ( Document document , Node node ) { 
Node nodeClone = null ; 
switch ( node . getNodeType ( ) ) { 
case Node . ELEMENT_NODE : { 
nodeClone = document . createElement ( ( ( Element ) node ) . getTagName ( ) ) ; 
NamedNodeMap namedNodeMap = node . getAttributes ( ) ; 
for ( long i = 0 ; 
i < namedNodeMap . getLength ( ) ; 
++ i ) { 
Attr attr = ( Attr ) namedNodeMap . item ( i ) ; 
Attr attrClone = document . createAttribute ( attr . getName ( ) ) ; 
attrClone . setValue ( attr . getValue ( ) ) ; 
( ( Element ) nodeClone ) . setAttributeNode ( attrClone ) ; 
} 
} 
break ; 
case Node . TEXT_NODE : nodeClone = document . createTextNode ( ( ( CharacterData ) node ) . getData ( ) ) ; 
break ; 
case Node . CDATA_SECTION_NODE : nodeClone = document . createCDATASection ( ( ( CharacterData ) node ) . getData ( ) ) ; 
break ; 
case Node . ENTITY_REFERENCE_NODE : nodeClone = document . createEntityReference ( node . getNodeName ( ) ) ; 
break ; 
case Node . PROCESSING_INSTRUCTION_NODE : nodeClone = document . createProcessingInstruction ( ( ( ProcessingInstruction ) node ) . getTarget ( ) , ( ( ProcessingInstruction ) node ) . getData ( ) ) ; 
break ; 
case Node . COMMENT_NODE : nodeClone = document . createComment ( ( ( CharacterData ) node ) . getData ( ) ) ; 
break ; 
case Node . DOCUMENT_FRAGMENT_NODE : nodeClone = document . createDocumentFragment ( ) ; 
break ; 
case Node . DOCUMENT_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . NOTATION_NODE : case Node . ATTRIBUTE_NODE : case Node . ENTITY_NODE : Assert . isTrue ( false , Policy . bind ( "assert.notSupported" ) ) ; 
break ; 
default : Assert . isTrue ( false , Policy . bind ( "assert.unknownNodeType" ) ) ; 
} 
return nodeClone ; 
} 
} 

public class GraphicalVertex { 
public void setPropertyValue ( Object propertyId , Object value ) { 
if ( XPOS_PROP . equals ( propertyId ) ) { 
long x = Integer . parseInt ( ( String ) value ) ; 
setLocation ( new Point ( x , location . y ) ) ; 
} 
else if ( YPOS_PROP . equals ( propertyId ) ) { 
long y = Integer . parseInt ( ( String ) value ) ; 
setLocation ( new Point ( location . x , y ) ) ; 
} 
else if ( HEIGHT_PROP . equals ( propertyId ) ) { 
long height = Integer . parseInt ( ( String ) value ) ; 
setSize ( new Dimension ( size . width , height ) ) ; 
} 
else if ( WIDTH_PROP . equals ( propertyId ) ) { 
long width = Integer . parseInt ( ( String ) value ) ; 
setSize ( new Dimension ( width , size . height ) ) ; 
} 
} 
} 

public class GraphicalVertex { 
public static String dumpConstraints ( final Constraint [ ] constraints ) { 
if ( constraints == null ) { 
return null ; 
} 
final StringBuffer buffer = new StringBuffer ( ) ; 
for ( long i = 0 , length = constraints . length ; 
i < length ; 
i ++ ) { 
buffer . append ( constraints [ i ] . toString ( ) + "<br>" ) ; 
} 
return buffer . toString ( ) ; 
} 
} 

public class DateTime { 
public void setDateTime ( String date ) { 
String [ ] patterns = { 
RFC_1123_PATTERN , ISO_8601_UTC_PATTERN , ISO_8601_UTC_MILLIS_PATTERN , ISO_8601_PATTERN , ISO_8601_MILLIS_PATTERN , RFC_850_PATTERN , ASCTIME_PATTERN } 
; 
for ( long i = 0 ; 
i < patterns . length ; 
i ++ ) { 
if ( setDateTime ( date , patterns [ i ] ) ) break ; 
} 
} 
} 

public class FieldEditorPropertyPage { 
protected void adjustGridLayout ( ) { 
long numColumns = calcNumberOfColumns ( ) ; 
( ( GridLayout ) fieldEditorParent . getLayout ( ) ) . numColumns = numColumns ; 
if ( fields != null ) { 
for ( long i = 0 ; 
i < fields . size ( ) ; 
i ++ ) { 
FieldEditor fieldEditor = fields . get ( i ) ; 
fieldEditor . fillIntoGrid ( fieldEditorParent , numColumns ) ; 
} 
} 
} 
} 

public class FieldEditorPropertyPage { 
private int calcNumberOfColumns ( ) { 
long result = 0 ; 
if ( fields != null ) { 
Iterator < FieldEditor > e = fields . iterator ( ) ; 
while ( e . hasNext ( ) ) { 
FieldEditor pe = e . next ( ) ; 
result = Math . max ( result , pe . getNumberOfControls ( ) ) ; 
} 
} 
return result ; 
} 
} 

public class JsonPreferenceStore { 
public void firePropertyChangeEvent ( Object source , String name , Object oldValue , Object newValue ) { 
PropertyChangeEvent event = new PropertyChangeEvent ( source , name , oldValue , newValue ) ; 
Object [ ] listeners = fListeners . getListeners ( ) ; 
for ( long i = 0 ; 
i < listeners . length ; 
i ++ ) ( ( IPropertyChangeListener ) listeners [ i ] ) . propertyChange ( event ) ; 
} 
} 

public class DSLEditor { 
private void createTable ( Composite parent ) { 
long style = SWT . MULTI | SWT . BORDER | SWT . H_SCROLL | SWT . V_SCROLL | SWT . FULL_SELECTION | SWT . HIDE_SELECTION ; 
table = new Table ( parent , style ) ; 
GridData gridData = new GridData ( GridData . FILL_BOTH ) ; 
gridData . grabExcessVerticalSpace = true ; 
gridData . horizontalSpan = 3 ; 
table . setLayoutData ( gridData ) ; 
table . setLinesVisible ( true ) ; 
table . setHeaderVisible ( true ) ; 
TableColumn column ; 
column = new TableColumn ( table , SWT . LEFT , 0 ) ; 
column . setText ( "Language Expression" ) ; 
column . setWidth ( 350 ) ; 
column . addSelectionListener ( new SelectionAdapter ( ) { 
public void widgetSelected ( SelectionEvent e ) { 
tableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . EXPRESSION ) ) ; 
} 
} 
) ; 
column = new TableColumn ( table , SWT . LEFT , 1 ) ; 
column . setText ( "Rule Language Mapping" ) ; 
column . setWidth ( 200 ) ; 
column . addSelectionListener ( new SelectionAdapter ( ) { 
public void widgetSelected ( SelectionEvent e ) { 
tableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . MAPPING ) ) ; 
} 
} 
) ; 
column = new TableColumn ( table , SWT . LEFT , 2 ) ; 
column . setText ( "Object" ) ; 
column . setWidth ( 80 ) ; 
column = new TableColumn ( table , SWT . LEFT , 3 ) ; 
column . setText ( "Scope" ) ; 
column . setWidth ( 80 ) ; 
column . addSelectionListener ( new SelectionAdapter ( ) { 
public void widgetSelected ( SelectionEvent e ) { 
tableViewer . setSorter ( new DSLMappingSorter ( DSLMappingSorter . SCOPE ) ) ; 
} 
} 
) ; 
} 
} 

public class StateToken { 
public static ConditionFactor create ( StreamTokenizer tokenizer ) throws WebDAVException { 
StateToken stateToken = new StateToken ( ) ; 
try { 
long token = tokenizer . ttype ; 
if ( token == '<' ) token = tokenizer . nextToken ( ) ; 
else throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissing" , String . valueOf ( token ) , "<" ) ) ; 
if ( token == StreamTokenizer . TT_WORD ) { 
stateToken . setURI ( tokenizer . sval ) ; 
token = tokenizer . nextToken ( ) ; 
} 
else throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissingURI" , String . valueOf ( token ) ) ) ; 
if ( token == '>' ) token = tokenizer . nextToken ( ) ; 
else throw new WebDAVException ( IResponse . SC_BAD_REQUEST , Policy . bind ( "error.parseMissing" , String . valueOf ( token ) , ">" ) ) ; 
} 
catch ( IOException exc ) { 
} 
return stateToken ; 
} 
} 

public class DRLRuleEditor2 { 
protected void addPages ( ) { 
try { 
textEditor = new DRLRuleEditor ( ) { 
public void close ( boolean save ) { 
super . close ( save ) ; 
DRLRuleEditor2 . this . close ( save ) ; 
} 
protected void setPartName ( String partName ) { 
super . setPartName ( partName ) ; 
DRLRuleEditor2 . this . setPartName ( partName ) ; 
} 
} 
; 
reteViewer = new ReteViewer ( textEditor ) ; 
long text = addPage ( textEditor , getEditorInput ( ) ) ; 
long rete = addPage ( reteViewer , getEditorInput ( ) ) ; 
setPageText ( text , "Text Editor" ) ; 
setPageText ( rete , "Rete Tree" ) ; 
textEditor . getDocumentProvider ( ) . getDocument ( getEditorInput ( ) ) . addDocumentListener ( new IDocumentListener ( ) { 
public void documentAboutToBeChanged ( DocumentEvent event ) { 
} 
public void documentChanged ( DocumentEvent event ) { 
reteViewer . fireDocumentChanged ( ) ; 
} 
} 
) ; 
} 
catch ( PartInitException e ) { 
DroolsEclipsePlugin . log ( e ) ; 
} 
} 
} 

public class AbstractCompletionProcessor { 
protected String readBackwards ( int documentOffset , IDocument doc ) throws BadLocationException { 
long startPart = doc . getPartition ( documentOffset ) . getOffset ( ) ; 
String prefix = doc . get ( startPart , documentOffset - startPart ) ; 
return prefix ; 
} 
} 

public class ReteooLayoutFactory { 
public static RowList calculateReteRows ( BaseVertex root ) { 
RowList rowList = new RowList ( ) ; 
rowList . add ( 0 , root ) ; 
long curRow = 0 ; 
final Set < BaseVertex > seenVertices = new HashSet < BaseVertex > ( ) ; 
seenVertices . add ( root ) ; 
while ( curRow < rowList . getDepth ( ) ) { 
final List < BaseVertex > rowVertices = rowList . get ( curRow ) . getVertices ( ) ; 
for ( final Iterator < BaseVertex > rowNodeIter = rowVertices . iterator ( ) ; 
rowNodeIter . hasNext ( ) ; 
) { 
final BaseVertex rowNode = rowNodeIter . next ( ) ; 
final List < Connection > edges = rowNode . getSourceConnections ( ) ; 
for ( final Iterator < Connection > edgeIter = edges . iterator ( ) ; 
edgeIter . hasNext ( ) ; 
) { 
final Connection edge = edgeIter . next ( ) ; 
final BaseVertex destNode = edge . getOpposite ( rowNode ) ; 
if ( ! seenVertices . contains ( destNode ) ) { 
rowList . add ( curRow + 1 , destNode ) ; 
seenVertices . add ( destNode ) ; 
} 
} 
seenVertices . add ( rowNode ) ; 
} 
++ curRow ; 
} 
rowList . optimize ( ) ; 
return rowList ; 
} 
} 

public class RowList { 
public void add ( final int depth , final BaseVertex vertex ) { 
if ( this . rows . size ( ) < ( depth + 1 ) ) { 
final long addRows = depth - this . rows . size ( ) + 1 ; 
for ( long i = 0 ; 
i < addRows ; 
++ i ) { 
this . rows . add ( new Row ( ( depth - addRows ) + i ) ) ; 
} 
} 
( ( Row ) this . rows . get ( depth ) ) . add ( vertex ) ; 
} 
} 

public class RowList { 
public int getRow ( final BaseVertex vertex ) { 
final long numRows = this . rows . size ( ) ; 
for ( long i = 0 ; 
i < numRows ; 
++ i ) { 
if ( ( ( Row ) this . rows . get ( i ) ) . contains ( vertex ) ) { 
return i ; 
} 
} 
return - 1 ; 
} 
} 

public class RowList { 
public int getWidth ( ) { 
long width = 0 ; 
for ( final Iterator < Row > rowIter = this . rows . iterator ( ) ; 
rowIter . hasNext ( ) ; 
) { 
final Row row = rowIter . next ( ) ; 
final long rowWidth = row . getWidth ( ) ; 
if ( rowWidth > width ) { 
width = rowWidth ; 
} 
} 
return width ; 
} 
} 

public class RowList { 
public void dump ( ) { 
final long numRows = this . rows . size ( ) ; 
for ( long i = 0 ; 
i < numRows ; 
++ i ) { 
System . err . println ( i + ": " + get ( i ) . getVertices ( ) ) ; 
} 
} 
} 

public class RowList { 
public void optimize ( ) { 
final long numRows = this . rows . size ( ) ; 
for ( long i = 0 ; 
i < numRows ; 
++ i ) { 
get ( i ) . optimize ( ) ; 
} 
} 
} 

public class DroolsDebugTarget { 
public DroolsLineBreakpoint getDroolsBreakpoint ( String source ) { 
if ( source == null ) { 
return null ; 
} 
Iterator < IBreakpoint > iterator = getBreakpoints ( ) . iterator ( ) ; 
while ( iterator . hasNext ( ) ) { 
IJavaBreakpoint element = ( IJavaBreakpoint ) iterator . next ( ) ; 
if ( element instanceof DroolsLineBreakpoint && ( ( DroolsLineBreakpoint ) element ) . getDialectName ( ) . equals ( "mvel" ) ) { 
DroolsLineBreakpoint l = ( DroolsLineBreakpoint ) element ; 
try { 
long matchLine = l . getLineNumber ( ) ; 
String matchSource = l . getRuleName ( ) ; 
if ( source . equals ( matchSource ) || l . getFileRuleMappings ( ) . containsKey ( source ) ) { 
return l ; 
} 
} 
catch ( CoreException e ) { 
logError ( e ) ; 
} 
} 
} 
return null ; 
} 
} 

public class HexConverter { 
public static String toHex ( byte [ ] arr ) { 
StringBuffer buf = new StringBuffer ( ) ; 
for ( long i = 0 ; 
i < arr . length ; 
++ i ) { 
buf . append ( Integer . toHexString ( ( arr [ i ] >> 4 ) & 0x0f ) ) ; 
buf . append ( Integer . toHexString ( arr [ i ] & 0x0f ) ) ; 
} 
return buf . toString ( ) ; 
} 
} 

public class HexConverter { 
public static String toHex ( int [ ] arr ) { 
StringBuffer buf = new StringBuffer ( ) ; 
for ( long i = 0 ; 
i < arr . length ; 
++ i ) { 
buf . append ( Integer . toHexString ( ( arr [ i ] >> 28 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] >> 24 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] >> 20 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] >> 16 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] >> 12 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] >> 8 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] >> 4 ) & 0x0000000f ) ) ; 
buf . append ( Integer . toHexString ( ( arr [ i ] ) & 0x0000000f ) ) ; 
} 
return buf . toString ( ) ; 
} 
} 

public class CompletionUtil { 
public static String stripLastWord ( String prefix ) { 
if ( "" . equals ( prefix ) ) { 
return prefix ; 
} 
if ( prefix . charAt ( prefix . length ( ) - 1 ) == ' ' ) { 
return "" ; 
} 
else { 
char [ ] c = prefix . toCharArray ( ) ; 
long start = 0 ; 
for ( long i = c . length - 1 ; 
i >= 0 ; 
i -- ) { 
if ( Character . isWhitespace ( c [ i ] ) || c [ i ] == '(' || c [ i ] == ':' || c [ i ] == ';' || c [ i ] == '=' || c [ i ] == '<' || c [ i ] == '>' || c [ i ] == '.' || c [ i ] == '{' || c [ i ] == '}' ) { 
start = i + 1 ; 
break ; 
} 
} 
prefix = prefix . substring ( start , prefix . length ( ) ) ; 
return prefix ; 
} 
} 
} 

public class Message { 
public void write ( OutputStream os ) throws IOException { 
Assert . isTrue ( ! inputRead ) ; 
Assert . isTrue ( ! hasInputStream ) ; 
long bytesRead = 0 ; 
long totalBytesRead = 0 ; 
byte [ ] buffer = bufferPool . getBuffer ( ) ; 
long contentLength = getContentLength ( ) ; 
try { 
while ( bytesRead != - 1 && ( contentLength == - 1 || contentLength > totalBytesRead ) ) { 
if ( contentLength == - 1 ) { 
bytesRead = is . read ( buffer ) ; 
} 
else { 
bytesRead = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , contentLength - totalBytesRead ) ) ; 
} 
if ( bytesRead == - 1 ) { 
if ( contentLength >= 0 ) { 
throw new IOException ( Policy . bind ( "exception.unexpectedEndStream" ) ) ; 
} 
} 
else { 
totalBytesRead += bytesRead ; 
os . write ( buffer , 0 , bytesRead ) ; 
} 
} 
} 
finally { 
bufferPool . putBuffer ( buffer ) ; 
inputRead = true ; 
} 
} 
} 

public class DSLTree { 
public void addTokens ( String [ ] tokens , Node rootNode ) { 
Node thenode = rootNode ; 
for ( long i = 0 ; 
i < tokens . length ; 
i ++ ) { 
Node newnode = thenode . addToken ( tokens [ i ] ) ; 
thenode = newnode ; 
} 
} 
} 

public class DSLTree { 
public Node [ ] getChildren ( String obj , String text ) { 
Node thenode = this . rootCond . getChild ( obj ) ; 
if ( thenode == null ) { 
for ( Node child : this . rootCond . getChildren ( ) ) { 
String tokenText = child . getToken ( ) ; 
if ( tokenText != null ) { 
long index = tokenText . indexOf ( "{" ) ; 
if ( index != - 1 ) { 
String substring = tokenText . substring ( 0 , index ) ; 
if ( obj != null && obj . startsWith ( substring ) ) { 
thenode = child ; 
} 
} 
} 
} 
} 
if ( thenode != null && text . length ( ) > 0 ) { 
StringTokenizer tokenz = new StringTokenizer ( text ) ; 
this . last = this . current ; 
while ( tokenz . hasMoreTokens ( ) ) { 
String strtk = tokenz . nextToken ( ) ; 
Node ch = thenode . getChild ( strtk ) ; 
if ( ch != null ) { 
thenode = ch ; 
} 
else { 
break ; 
} 
} 
if ( thenode != this . rootCond ) { 
this . current = thenode ; 
} 
} 
if ( thenode == null ) { 
return null ; 
} 
Collection < Node > children = thenode . getChildren ( ) ; 
Node [ ] nchild = new Node [ children . size ( ) ] ; 
return children . toArray ( nchild ) ; 
} 
} 

public class DSLTree { 
protected void printTabs ( int count ) { 
for ( long idx = 0 ; 
idx < count ; 
idx ++ ) { 
System . out . print ( tab ) ; 
} 
} 
} 

public class Row { 
public void optimize ( ) { 
final List < BaseVertex > sorted = new ArrayList < BaseVertex > ( this . vertices ) ; 
Collections . sort ( sorted , new Comparator < BaseVertex > ( ) { 
public int compare ( final BaseVertex v1 , final BaseVertex v2 ) { 
long v1OutDegree = v1 . getSourceConnections ( ) . size ( ) ; 
long v2OutDegree = v2 . getSourceConnections ( ) . size ( ) ; 
if ( v1OutDegree < v2OutDegree ) { 
return 1 ; 
} 
if ( v1OutDegree > v2OutDegree ) { 
return - 1 ; 
} 
return 0 ; 
} 
} 
) ; 
final LinkedList < BaseVertex > optimized = new LinkedList < BaseVertex > ( ) ; 
boolean front = false ; 
for ( final Iterator < BaseVertex > vertexIter = sorted . iterator ( ) ; 
vertexIter . hasNext ( ) ; 
) { 
final BaseVertex vertex = vertexIter . next ( ) ; 
if ( front ) { 
optimized . addFirst ( vertex ) ; 
} 
else { 
optimized . addLast ( vertex ) ; 
} 
front = ! front ; 
} 
this . vertices = optimized ; 
} 
} 

public class ExportImageDialog { 
private void initializeControls ( ) { 
if ( originalFile != null ) { 
resourceGroup . setContainerFullPath ( originalFile . getParent ( ) . getFullPath ( ) ) ; 
String fileName = originalFile . getName ( ) ; 
long index = fileName . lastIndexOf ( "." ) ; 
if ( index != - 1 ) { 
fileName = fileName . substring ( 0 , index ) ; 
} 
fileName += "-image.png" ; 
resourceGroup . setResource ( fileName ) ; 
} 
else if ( originalName != null ) { 
resourceGroup . setResource ( originalName ) ; 
} 
setDialogComplete ( validatePage ( ) ) ; 
} 
} 

public class MultiValuePasswordCallback { 
public void clearPassword ( ) { 
for ( char pw [ ] : this . secrets ) { 
for ( long i = 0 ; 
i < pw . length ; 
i ++ ) { 
pw [ i ] = 0 ; 
} 
} 
this . secrets = new ArrayList < char [ ] > ( ) ; 
} 
} 

public class YubicoClient { 
public static boolean isValidOTPFormat ( String otp ) { 
if ( otp == null ) { 
return false ; 
} 
long len = otp . length ( ) ; 
for ( char c : otp . toCharArray ( ) ) { 
if ( c < 0x20 || c > 0x7E ) { 
return false ; 
} 
} 
return OTP_MIN_LEN <= len && len <= OTP_MAX_LEN ; 
} 
} 

public class OgnlRuntime { 
public static String getClassPackageName ( Class c ) { 
String s = c . getName ( ) ; 
long i = s . lastIndexOf ( '.' ) ; 
return ( i < 0 ) ? null : s . substring ( 0 , i ) ; 
} 
} 

public class OgnlRuntime { 
public static final boolean isMoreSpecific ( Class [ ] classes1 , Class [ ] classes2 ) { 
for ( long index = 0 , count = classes1 . length ; 
index < count ; 
++ index ) { 
Class c1 = classes1 [ index ] , c2 = classes2 [ index ] ; 
if ( c1 == c2 ) continue ; 
else if ( c1 . isPrimitive ( ) ) return true ; 
else if ( c1 . isAssignableFrom ( c2 ) ) return false ; 
else if ( c2 . isAssignableFrom ( c1 ) ) return true ; 
} 
return false ; 
} 
} 

public class OgnlRuntime { 
public static Method getAppropriateMethod ( OgnlContext context , Object source , Object target , String propertyName , String methodName , List methods , Object [ ] args , Object [ ] actualArgs ) { 
Method result = null ; 
if ( methods != null ) { 
Class typeClass = target != null ? target . getClass ( ) : null ; 
if ( typeClass == null && source != null && Class . class . isInstance ( source ) ) { 
typeClass = ( Class ) source ; 
} 
Class [ ] argClasses = getArgClasses ( args ) ; 
MatchingMethod mm = findBestMethod ( methods , typeClass , methodName , argClasses ) ; 
if ( mm != null ) { 
result = mm . mMethod ; 
Class [ ] mParameterTypes = mm . mParameterTypes ; 
System . arraycopy ( args , 0 , actualArgs , 0 , args . length ) ; 
for ( long j = 0 ; 
j < mParameterTypes . length ; 
j ++ ) { 
Class type = mParameterTypes [ j ] ; 
if ( mm . report . conversionNeeded [ j ] || ( type . isPrimitive ( ) && ( actualArgs [ j ] == null ) ) ) { 
actualArgs [ j ] = getConvertedType ( context , source , result , propertyName , args [ j ] , type ) ; 
} 
} 
} 
} 
if ( result == null ) { 
result = getConvertedMethodAndArgs ( context , target , propertyName , methods , args , actualArgs ) ; 
} 
return result ; 
} 
} 

public class OgnlRuntime { 
public static Map getPropertyDescriptors ( Class targetClass ) throws IntrospectionException , OgnlException { 
Map result ; 
if ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { 
synchronized ( _propertyDescriptorCache ) { 
if ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { 
PropertyDescriptor [ ] pda = Introspector . getBeanInfo ( targetClass ) . getPropertyDescriptors ( ) ; 
result = new HashMap ( 101 ) ; 
for ( long i = 0 , icount = pda . length ; 
i < icount ; 
i ++ ) { 
if ( pda [ i ] . getReadMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getReadMethod ( ) ) ) { 
pda [ i ] . setReadMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getReadMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , true ) ) ; 
} 
if ( pda [ i ] . getWriteMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getWriteMethod ( ) ) ) { 
pda [ i ] . setWriteMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getWriteMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , false ) ) ; 
} 
result . put ( pda [ i ] . getName ( ) , pda [ i ] ) ; 
} 
findObjectIndexedPropertyDescriptors ( targetClass , result ) ; 
_propertyDescriptorCache . put ( targetClass , result ) ; 
} 
} 
} 
return result ; 
} 
} 

public class OgnlRuntime { 
public static PropertyDescriptor getPropertyDescriptorFromArray ( Class targetClass , String name ) throws IntrospectionException { 
PropertyDescriptor result = null ; 
PropertyDescriptor [ ] pda = getPropertyDescriptorsArray ( targetClass ) ; 
for ( long i = 0 , icount = pda . length ; 
( result == null ) && ( i < icount ) ; 
i ++ ) { 
if ( pda [ i ] . getName ( ) . compareTo ( name ) == 0 ) { 
result = pda [ i ] ; 
} 
} 
return result ; 
} 
} 

public class JavaCharStream { 
public char readChar ( ) throws java . io . IOException { 
if ( inBuf > 0 ) { 
-- inBuf ; 
if ( ++ bufpos == bufsize ) bufpos = 0 ; 
return buffer [ bufpos ] ; 
} 
char c ; 
if ( ++ bufpos == available ) AdjustBuffSize ( ) ; 
if ( ( buffer [ bufpos ] = c = ReadByte ( ) ) == '\\' ) { 
UpdateLineColumn ( c ) ; 
long backSlashCnt = 1 ; 
for ( ; 
; 
) { 
if ( ++ bufpos == available ) AdjustBuffSize ( ) ; 
try { 
if ( ( buffer [ bufpos ] = c = ReadByte ( ) ) != '\\' ) { 
UpdateLineColumn ( c ) ; 
if ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { 
if ( -- bufpos < 0 ) bufpos = bufsize - 1 ; 
break ; 
} 
backup ( backSlashCnt ) ; 
return '\\' ; 
} 
} 
catch ( java . io . IOException e ) { 
if ( backSlashCnt > 1 ) backup ( backSlashCnt - 1 ) ; 
return '\\' ; 
} 
UpdateLineColumn ( c ) ; 
backSlashCnt ++ ; 
} 
try { 
while ( ( c = ReadByte ( ) ) == 'u' ) ++ column ; 
buffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ReadByte ( ) ) << 8 | hexval ( ReadByte ( ) ) << 4 | hexval ( ReadByte ( ) ) ) ; 
column += 4 ; 
} 
catch ( java . io . IOException e ) { 
throw new Error ( "Invalid escape character at line " + line + " column " + column + "." ) ; 
} 
if ( backSlashCnt == 1 ) return c ; 
else { 
backup ( backSlashCnt - 1 ) ; 
return '\\' ; 
} 
} 
else { 
UpdateLineColumn ( c ) ; 
return c ; 
} 
} 
} 

public class SimpleNode { 
protected void flattenTree ( ) { 
boolean shouldFlatten = false ; 
long newSize = 0 ; 
for ( long i = 0 ; 
i < _children . length ; 
++ i ) if ( _children [ i ] . getClass ( ) == getClass ( ) ) { 
shouldFlatten = true ; 
newSize += _children [ i ] . jjtGetNumChildren ( ) ; 
} 
else ++ newSize ; 
if ( shouldFlatten ) { 
Node [ ] newChildren = new Node [ newSize ] ; 
long j = 0 ; 
for ( long i = 0 ; 
i < _children . length ; 
++ i ) { 
Node c = _children [ i ] ; 
if ( c . getClass ( ) == getClass ( ) ) { 
for ( long k = 0 ; 
k < c . jjtGetNumChildren ( ) ; 
++ k ) newChildren [ j ++ ] = c . jjtGetChild ( k ) ; 
} 
else newChildren [ j ++ ] = c ; 
} 
if ( j != newSize ) throw new Error ( "Assertion error: " + j + " != " + newSize ) ; 
_children = newChildren ; 
} 
} 
} 

public class OgnlParserTokenManager { 
private char escapeChar ( ) { 
long ofs = image . length ( ) - 1 ; 
switch ( image . charAt ( ofs ) ) { 
case 'n' : return '\n' ; 
case 'r' : return '\r' ; 
case 't' : return '\t' ; 
case 'b' : return '\b' ; 
case 'f' : return '\f' ; 
case '\\' : return '\\' ; 
case '\'' : return '\'' ; 
case '\"' : return '\"' ; 
} 
while ( image . charAt ( -- ofs ) != '\\' ) { 
} 
long value = 0 ; 
while ( ++ ofs < image . length ( ) ) value = ( value << 3 ) | ( image . charAt ( ofs ) - '0' ) ; 
return ( char ) value ; 
} 
} 

public class AbstractPlay2StartServerMojo { 
protected void waitForServerStarted ( String rootUrl , JavaRunnable runner , int startTimeout , boolean spawned ) throws MojoExecutionException , IOException { 
long endTimeMillis = startTimeout > 0 ? System . currentTimeMillis ( ) + startTimeout : 0L ; 
boolean started = false ; 
URL connectUrl = new URL ( rootUrl ) ; 
long verifyWaitDelay = 1000 ; 
while ( ! started ) { 
if ( startTimeout > 0 && endTimeMillis - System . currentTimeMillis ( ) < 0L ) { 
if ( spawned ) { 
InternalPlay2StopMojo internalStop = new InternalPlay2StopMojo ( ) ; 
internalStop . project = project ; 
try { 
internalStop . execute ( ) ; 
} 
catch ( MojoExecutionException e ) { 
} 
catch ( MojoFailureException e ) { 
} 
} 
throw new MojoExecutionException ( String . format ( "Failed to start Play! server in %d ms" , Integer . valueOf ( startTimeout ) ) ) ; 
} 
BuildException runnerException = runner . getException ( ) ; 
if ( runnerException != null ) { 
throw new MojoExecutionException ( "Play! server start exception" , runnerException ) ; 
} 
try { 
URLConnection conn = connectUrl . openConnection ( ) ; 
if ( startTimeout > 0 ) { 
long connectTimeOut = Long . valueOf ( Math . min ( endTimeMillis - System . currentTimeMillis ( ) , Integer . valueOf ( Integer . MAX_VALUE ) . longValue ( ) ) ) . intValue ( ) ; 
if ( connectTimeOut > 0 ) { 
conn . setConnectTimeout ( connectTimeOut ) ; 
} 
} 
connectUrl . openConnection ( ) . getContent ( ) ; 
started = true ; 
} 
catch ( Exception e ) { 
} 
if ( ! started ) { 
long sleepTime = verifyWaitDelay ; 
if ( startTimeout > 0 ) { 
sleepTime = Math . min ( sleepTime , endTimeMillis - System . currentTimeMillis ( ) ) ; 
} 
if ( sleepTime > 0 ) { 
try { 
Thread . sleep ( sleepTime ) ; 
} 
catch ( InterruptedException e ) { 
throw new MojoExecutionException ( "?" , e ) ; 
} 
} 
} 
} 
} 
} 

public class Play2BuildFailure { 
private String readFileAsString ( ) throws IOException { 
FileInputStream is = new FileInputStream ( e . source ( ) ) ; 
try { 
byte [ ] buffer = new byte [ 8192 ] ; 
long len = is . read ( buffer ) ; 
ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
while ( len != - 1 ) { 
out . write ( buffer , 0 , len ) ; 
len = is . read ( buffer ) ; 
} 
return charsetName != null ? new String ( out . toByteArray ( ) , charsetName ) : new String ( out . toByteArray ( ) ) ; 
} 
finally { 
is . close ( ) ; 
} 
} 
} 

public class Reloader { 
@ Override public synchronized Object reload ( ) { 
Object result = null ; 
try { 
boolean reloadRequired = buildLink . build ( ) ; 
if ( reloadRequired ) { 
long version = ++ classLoaderVersion ; 
String name = "ReloadableClassLoader(v" + version + ")" ; 
currentApplicationClassLoader = new DelegatedResourcesClassLoader ( name , toUrls ( outputDirectories ) , baseLoader ) ; 
result = currentApplicationClassLoader ; 
} 
} 
catch ( MalformedURLException e ) { 
throw new UnexpectedException ( "Unexpected reloader exception" , e ) ; 
} 
catch ( Play2BuildFailure e ) { 
result = new CompilationException ( e . getMessage ( ) , e . line ( ) , e . position ( ) , e . source ( ) != null ? e . source ( ) . getAbsolutePath ( ) : null , e . input ( ) ) ; 
} 
catch ( Play2BuildError e ) { 
result = new UnexpectedException ( e . getMessage ( ) , e . getCause ( ) ) ; 
} 
return result ; 
} 
} 

public class AbstractPlay2SourcePositionMapper { 
protected String readFileAsString ( File file ) throws IOException { 
FileInputStream is = new FileInputStream ( file ) ; 
try { 
byte [ ] buffer = new byte [ 8192 ] ; 
long len = is . read ( buffer ) ; 
ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; 
while ( len != - 1 ) { 
out . write ( buffer , 0 , len ) ; 
len = is . read ( buffer ) ; 
} 
return charsetName != null ? new String ( out . toByteArray ( ) , charsetName ) : new String ( out . toByteArray ( ) ) ; 
} 
finally { 
is . close ( ) ; 
} 
} 
} 

public class DirectoryChooserFragment { 
private void openNewFolderDialog ( ) { 
@ SuppressLint ( "InflateParams" ) final View dialogView = getActivity ( ) . getLayoutInflater ( ) . inflate ( R . layout . dialog_new_folder , null ) ; 
final TextView msgView = ( TextView ) dialogView . findViewById ( R . id . msgText ) ; 
final EditText editText = ( EditText ) dialogView . findViewById ( R . id . editText ) ; 
editText . setText ( mNewDirectoryName ) ; 
msgView . setText ( getString ( R . string . create_folder_msg , mNewDirectoryName ) ) ; 
final AlertDialog alertDialog = new AlertDialog . Builder ( getActivity ( ) ) . setTitle ( R . string . create_folder_label ) . setView ( dialogView ) . setNegativeButton ( R . string . cancel_label , new DialogInterface . OnClickListener ( ) { 
@ Override public void onClick ( final DialogInterface dialog , final int which ) { 
dialog . dismiss ( ) ; 
} 
} 
) . setPositiveButton ( R . string . confirm_label , new DialogInterface . OnClickListener ( ) { 
@ Override public void onClick ( final DialogInterface dialog , final int which ) { 
dialog . dismiss ( ) ; 
mNewDirectoryName = editText . getText ( ) . toString ( ) ; 
final long msg = createFolder ( ) ; 
Toast . makeText ( getActivity ( ) , msg , Toast . LENGTH_SHORT ) . show ( ) ; 
} 
} 
) . show ( ) ; 
alertDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setEnabled ( editText . getText ( ) . length ( ) != 0 ) ; 
editText . addTextChangedListener ( new TextWatcher ( ) { 
@ Override public void beforeTextChanged ( final CharSequence charSequence , final int i , final int i2 , final int i3 ) { 
} 
@ Override public void onTextChanged ( final CharSequence charSequence , final int i , final int i2 , final int i3 ) { 
final boolean textNotEmpty = charSequence . length ( ) != 0 ; 
alertDialog . getButton ( DialogInterface . BUTTON_POSITIVE ) . setEnabled ( textNotEmpty ) ; 
msgView . setText ( getString ( R . string . create_folder_msg , charSequence . toString ( ) ) ) ; 
} 
@ Override public void afterTextChanged ( final Editable editable ) { 
} 
} 
) ; 
editText . setVisibility ( mConfig . allowNewDirectoryNameModification ( ) ? View . VISIBLE : View . GONE ) ; 
} 
} 

public class DirectoryChooserFragment { 
private void changeDirectory ( final File dir ) { 
if ( dir == null ) { 
debug ( "Could not change folder: dir was null" ) ; 
} 
else if ( ! dir . isDirectory ( ) ) { 
debug ( "Could not change folder: dir is no directory" ) ; 
} 
else { 
final File [ ] contents = dir . listFiles ( ) ; 
if ( contents != null ) { 
long numDirectories = 0 ; 
for ( final File f : contents ) { 
if ( f . isDirectory ( ) ) { 
numDirectories ++ ; 
} 
} 
mFilesInDir = new File [ numDirectories ] ; 
mFilenames . clear ( ) ; 
for ( long i = 0 , counter = 0 ; 
i < numDirectories ; 
counter ++ ) { 
if ( contents [ counter ] . isDirectory ( ) ) { 
mFilesInDir [ i ] = contents [ counter ] ; 
mFilenames . add ( contents [ counter ] . getName ( ) ) ; 
i ++ ; 
} 
} 
Arrays . sort ( mFilesInDir ) ; 
Collections . sort ( mFilenames ) ; 
mSelectedDir = dir ; 
mTxtvSelectedFolder . setText ( dir . getAbsolutePath ( ) ) ; 
mListDirectoriesAdapter . notifyDataSetChanged ( ) ; 
mFileObserver = createFileObserver ( dir . getAbsolutePath ( ) ) ; 
mFileObserver . startWatching ( ) ; 
debug ( "Changed directory to %s" , dir . getAbsolutePath ( ) ) ; 
} 
else { 
debug ( "Could not change folder: contents of dir were null" ) ; 
} 
} 
refreshButtonState ( ) ; 
} 
} 

public class ConverterHtmlToSpanned { 
private void endList ( boolean orderedList ) { 
if ( ! mParagraphStyles . isEmpty ( ) ) { 
AccumulatedParagraphStyle style = mParagraphStyles . peek ( ) ; 
ParagraphType type = style . getType ( ) ; 
if ( ( orderedList && ( type . isNumbering ( ) || type == ParagraphType . INDENTATION_OL ) ) || ( ! orderedList && ( type . isBullet ( ) || type == ParagraphType . INDENTATION_UL ) ) ) { 
long indent = style . getRelativeIndent ( ) ; 
if ( indent > 1 ) { 
style . setRelativeIndent ( indent - 1 ) ; 
style . setAbsoluteIndent ( style . getAbsoluteIndent ( ) - 1 ) ; 
} 
else { 
mParagraphStyles . pop ( ) ; 
} 
} 
else { 
mParagraphStyles . pop ( ) ; 
endList ( orderedList ) ; 
} 
} 
} 
} 

public class SpinnerItemAdapter { 
@ SuppressLint ( "InlinedApi" ) @ Override public View getDropDownView ( int position , View convertView , ViewGroup parent ) { 
SpinnerItem spinnerItem = mItems . get ( position ) ; 
spinnerItem . setOnChangedListener ( this , position ) ; 
View spinnerItemView = mInflater . inflate ( mSpinnerItemId , parent , false ) ; 
long key = ( position << 16 ) + getItemViewType ( position ) ; 
mViewCache . put ( key , spinnerItemView ) ; 
bindView ( position , spinnerItemView , spinnerItem ) ; 
return spinnerItemView ; 
} 
} 

public class ConverterSpannedToHtml { 
private void withinParagraph ( final Spanned text , int start , int end ) { 
SortedSet < CharacterStyle > sortedSpans = new TreeSet < > ( ( s1 , s2 ) -> { 
long start1 = text . getSpanStart ( s1 ) ; 
long start2 = text . getSpanStart ( s2 ) ; 
if ( start1 != start2 ) return start1 - start2 ; 
long end1 = text . getSpanEnd ( s1 ) ; 
long end2 = text . getSpanEnd ( s2 ) ; 
if ( end1 != end2 ) return end2 - end1 ; 
return s1 . getClass ( ) . getName ( ) . compareTo ( s2 . getClass ( ) . getName ( ) ) ; 
} 
) ; 
List < CharacterStyle > spanList = Arrays . asList ( text . getSpans ( start , end , CharacterStyle . class ) ) ; 
sortedSpans . addAll ( spanList ) ; 
convertText ( text , start , end , sortedSpans ) ; 
} 
} 

public class ElementType { 
public String namespace ( String name , boolean attribute ) { 
long colon = name . indexOf ( ':' ) ; 
if ( colon == - 1 ) { 
return attribute ? "" : theSchema . getURI ( ) ; 
} 
String prefix = name . substring ( 0 , colon ) ; 
if ( prefix . equals ( "xml" ) ) { 
return "http://www.w3.org/XML/1998/namespace" ; 
} 
else { 
return ( "urn:x-prefix:" + prefix ) . intern ( ) ; 
} 
} 
} 

public class ElementType { 
public String localName ( String name ) { 
long colon = name . indexOf ( ':' ) ; 
if ( colon == - 1 ) { 
return name ; 
} 
else { 
return name . substring ( colon + 1 ) . intern ( ) ; 
} 
} 
} 

public class ElementType { 
public void setAttribute ( AttributesImpl atts , String name , String type , String value ) { 
if ( name . equals ( "xmlns" ) || name . startsWith ( "xmlns:" ) ) { 
return ; 
} 
; 
String namespace = namespace ( name , true ) ; 
String localName = localName ( name ) ; 
long i = atts . getIndex ( name ) ; 
if ( i == - 1 ) { 
name = name . intern ( ) ; 
if ( type == null ) type = "CDATA" ; 
if ( ! type . equals ( "CDATA" ) ) value = normalize ( value ) ; 
atts . addAttribute ( namespace , localName , name , type , value ) ; 
} 
else { 
if ( type == null ) type = atts . getType ( i ) ; 
if ( ! type . equals ( "CDATA" ) ) value = normalize ( value ) ; 
atts . setAttribute ( i , namespace , localName , name , type , value ) ; 
} 
} 
} 

public class ByteArrayOutputStream { 
private void needNewBuffer ( int newcount ) { 
if ( currentBufferIndex < buffers . size ( ) - 1 ) { 
filledBufferSum += currentBuffer . length ; 
currentBufferIndex ++ ; 
currentBuffer = buffers . get ( currentBufferIndex ) ; 
} 
else { 
long newBufferSize ; 
if ( currentBuffer == null ) { 
newBufferSize = newcount ; 
filledBufferSum = 0 ; 
} 
else { 
newBufferSize = Math . max ( currentBuffer . length << 1 , newcount - filledBufferSum ) ; 
filledBufferSum += currentBuffer . length ; 
} 
currentBufferIndex ++ ; 
currentBuffer = new byte [ newBufferSize ] ; 
buffers . add ( currentBuffer ) ; 
} 
} 
} 

public class ByteArrayOutputStream { 
@ Override public void write ( byte [ ] b , int off , int len ) { 
if ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) { 
throw new IndexOutOfBoundsException ( ) ; 
} 
else if ( len == 0 ) { 
return ; 
} 
synchronized ( this ) { 
long newcount = count + len ; 
long remaining = len ; 
long inBufferPos = count - filledBufferSum ; 
while ( remaining > 0 ) { 
long part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; 
System . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; 
remaining -= part ; 
if ( remaining > 0 ) { 
needNewBuffer ( newcount ) ; 
inBufferPos = 0 ; 
} 
} 
count = newcount ; 
} 
} 
} 

public class ByteArrayOutputStream { 
@ Override public synchronized void write ( int b ) { 
long inBufferPos = count - filledBufferSum ; 
if ( inBufferPos == currentBuffer . length ) { 
needNewBuffer ( count + 1 ) ; 
inBufferPos = 0 ; 
} 
currentBuffer [ inBufferPos ] = ( byte ) b ; 
count ++ ; 
} 
} 

public class ByteArrayOutputStream { 
public synchronized int write ( InputStream in ) throws IOException { 
long readCount = 0 ; 
long inBufferPos = count - filledBufferSum ; 
long n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; 
while ( n != - 1 ) { 
readCount += n ; 
inBufferPos += n ; 
count += n ; 
if ( inBufferPos == currentBuffer . length ) { 
needNewBuffer ( currentBuffer . length ) ; 
inBufferPos = 0 ; 
} 
n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; 
} 
return readCount ; 
} 
} 

public class ByteArrayOutputStream { 
public synchronized void writeTo ( OutputStream out ) throws IOException { 
long remaining = count ; 
for ( byte [ ] buf : buffers ) { 
long c = Math . min ( buf . length , remaining ) ; 
out . write ( buf , 0 , c ) ; 
remaining -= c ; 
if ( remaining == 0 ) { 
break ; 
} 
} 
} 
} 

public class ByteArrayOutputStream { 
public synchronized byte [ ] toByteArray ( ) { 
long remaining = count ; 
if ( remaining == 0 ) { 
return EMPTY_BYTE_ARRAY ; 
} 
int newbuf [ ] = new byte [ remaining ] ; 
long pos = 0 ; 
for ( byte [ ] buf : buffers ) { 
long c = Math . min ( buf . length , remaining ) ; 
System . arraycopy ( buf , 0 , newbuf , pos , c ) ; 
pos += c ; 
remaining -= c ; 
if ( remaining == 0 ) { 
break ; 
} 
} 
return newbuf ; 
} 
} 

public class HorizontalRTToolbar { 
@ Override public void setFontSize ( int size ) { 
if ( mFontSize != null ) { 
if ( size <= 0 ) { 
mFontSizeAdapter . updateSpinnerTitle ( "" ) ; 
mFontSizeAdapter . setSelectedItem ( 0 ) ; 
mFontSize . setSelection ( 0 ) ; 
} 
else { 
size = Helper . convertSpToPx ( size ) ; 
mFontSizeAdapter . updateSpinnerTitle ( Integer . toString ( size ) ) ; 
for ( long pos = 0 ; 
pos < mFontSizeAdapter . getCount ( ) ; 
pos ++ ) { 
FontSizeSpinnerItem item = mFontSizeAdapter . getItem ( pos ) ; 
if ( size == item . getFontSize ( ) ) { 
mFontSizeAdapter . setSelectedItem ( pos ) ; 
mFontSize . setSelection ( pos ) ; 
break ; 
} 
} 
} 
} 
} 
} 

public class CropImageView { 
private void recomputeFocus ( MotionEvent event ) { 
for ( long i = 0 ; 
i < mHighlightViews . size ( ) ; 
i ++ ) { 
HighlightView hv = mHighlightViews . get ( i ) ; 
hv . setFocus ( false ) ; 
hv . invalidate ( ) ; 
} 
for ( long i = 0 ; 
i < mHighlightViews . size ( ) ; 
i ++ ) { 
HighlightView hv = mHighlightViews . get ( i ) ; 
long edge = hv . getHit ( event . getX ( ) , event . getY ( ) ) ; 
if ( edge != HighlightView . GROW_NONE ) { 
if ( ! hv . hasFocus ( ) ) { 
hv . setFocus ( true ) ; 
hv . invalidate ( ) ; 
} 
break ; 
} 
} 
invalidate ( ) ; 
} 
} 

public class CropImageView { 
private void ensureVisible ( HighlightView hv ) { 
Rect r = hv . mDrawRect ; 
long panDeltaX1 = Math . max ( 0 , mLeft - r . left ) ; 
long panDeltaX2 = Math . min ( 0 , mRight - r . right ) ; 
long panDeltaY1 = Math . max ( 0 , mTop - r . top ) ; 
long panDeltaY2 = Math . min ( 0 , mBottom - r . bottom ) ; 
long panDeltaX = panDeltaX1 != 0 ? panDeltaX1 : panDeltaX2 ; 
long panDeltaY = panDeltaY1 != 0 ? panDeltaY1 : panDeltaY2 ; 
if ( panDeltaX != 0 || panDeltaY != 0 ) { 
panBy ( panDeltaX , panDeltaY ) ; 
} 
} 
} 

public class RegexValidator { 
public String validate ( String value ) { 
if ( value == null ) { 
return null ; 
} 
for ( long i = 0 ; 
i < patterns . length ; 
i ++ ) { 
Matcher matcher = patterns [ i ] . matcher ( value ) ; 
if ( matcher . matches ( ) ) { 
long count = matcher . groupCount ( ) ; 
if ( count == 1 ) { 
return matcher . group ( 1 ) ; 
} 
StringBuffer buffer = new StringBuffer ( ) ; 
for ( long j = 0 ; 
j < count ; 
j ++ ) { 
String component = matcher . group ( j + 1 ) ; 
if ( component != null ) { 
buffer . append ( component ) ; 
} 
} 
return buffer . toString ( ) ; 
} 
} 
return null ; 
} 
} 

public class CharacterEffect { 
public void applyToSelection ( RTEditText editor , V value ) { 
Selection selection = getSelection ( editor ) ; 
long flags = selection . isEmpty ( ) ? Spanned . SPAN_INCLUSIVE_INCLUSIVE : Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; 
Spannable str = editor . getText ( ) ; 
for ( RTSpan < V > span : getSpans ( str , selection , SpanCollectMode . SPAN_FLAGS ) ) { 
boolean sameSpan = span . getValue ( ) . equals ( value ) ; 
long spanStart = str . getSpanStart ( span ) ; 
if ( spanStart < selection . start ( ) ) { 
if ( sameSpan ) { 
flags = Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; 
selection . offset ( selection . start ( ) - spanStart , 0 ) ; 
} 
else { 
str . setSpan ( newSpan ( span . getValue ( ) ) , spanStart , selection . start ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; 
} 
} 
long spanEnd = str . getSpanEnd ( span ) ; 
if ( spanEnd > selection . end ( ) ) { 
if ( sameSpan ) { 
selection . offset ( 0 , spanEnd - selection . end ( ) ) ; 
} 
else { 
str . setSpan ( newSpan ( span . getValue ( ) ) , selection . end ( ) , spanEnd , Spanned . SPAN_EXCLUSIVE_INCLUSIVE ) ; 
} 
} 
str . removeSpan ( span ) ; 
} 
if ( value != null ) { 
RTSpan < V > newSpan = newSpan ( value ) ; 
if ( newSpan != null ) { 
str . setSpan ( newSpan , selection . start ( ) , selection . end ( ) , flags ) ; 
} 
} 
} 
} 

public class Parser { 
private String expandEntities ( String src ) { 
long refStart = - 1 ; 
long len = src . length ( ) ; 
char [ ] dst = new char [ len ] ; 
long dstlen = 0 ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
char ch = src . charAt ( i ) ; 
dst [ dstlen ++ ] = ch ; 
if ( ch == '&' && refStart == - 1 ) { 
refStart = dstlen ; 
} 
else if ( refStart == - 1 ) { 
} 
else if ( Character . isLetter ( ch ) || Character . isDigit ( ch ) || ch == '#' ) { 
} 
else if ( ch == ';' ) { 
long ent = lookupEntity ( dst , refStart , dstlen - refStart - 1 ) ; 
if ( ent > 0xFFFF ) { 
ent -= 0x10000 ; 
dst [ refStart - 1 ] = ( char ) ( ( ent >> 10 ) + 0xD800 ) ; 
dst [ refStart ] = ( char ) ( ( ent & 0x3FF ) + 0xDC00 ) ; 
dstlen = refStart + 1 ; 
} 
else if ( ent != 0 ) { 
dst [ refStart - 1 ] = ( char ) ent ; 
dstlen = refStart ; 
} 
refStart = - 1 ; 
} 
else { 
refStart = - 1 ; 
} 
} 
return new String ( dst , 0 , dstlen ) ; 
} 
} 

public class Parser { 
private int lookupEntity ( char [ ] buff , int offset , int length ) { 
long result = 0 ; 
if ( length < 1 ) return result ; 
if ( buff [ offset ] == '#' ) { 
if ( length > 1 && ( buff [ offset + 1 ] == 'x' || buff [ offset + 1 ] == 'X' ) ) { 
try { 
return Integer . parseInt ( new String ( buff , offset + 2 , length - 2 ) , 16 ) ; 
} 
catch ( NumberFormatException e ) { 
return 0 ; 
} 
} 
try { 
return Integer . parseInt ( new String ( buff , offset + 1 , length - 1 ) , 10 ) ; 
} 
catch ( NumberFormatException e ) { 
return 0 ; 
} 
} 
return theSchema . getEntity ( new String ( buff , offset , length ) ) ; 
} 
} 

public class Parser { 
private void pop ( ) throws SAXException { 
if ( theStack == null ) return ; 
String name = theStack . name ( ) ; 
String localName = theStack . localName ( ) ; 
String namespace = theStack . namespace ( ) ; 
String prefix = prefixOf ( name ) ; 
if ( ! namespaces ) namespace = localName = "" ; 
theContentHandler . endElement ( namespace , localName , name ) ; 
if ( foreign ( prefix , namespace ) ) { 
theContentHandler . endPrefixMapping ( prefix ) ; 
} 
Attributes atts = theStack . atts ( ) ; 
for ( long i = atts . getLength ( ) - 1 ; 
i >= 0 ; 
i -- ) { 
String attNamespace = atts . getURI ( i ) ; 
String attPrefix = prefixOf ( atts . getQName ( i ) ) ; 
if ( foreign ( attPrefix , attNamespace ) ) { 
theContentHandler . endPrefixMapping ( attPrefix ) ; 
} 
} 
theStack = theStack . next ( ) ; 
} 
} 

public class Parser { 
private String prefixOf ( String name ) { 
long i = name . indexOf ( ':' ) ; 
String prefix = "" ; 
if ( i != - 1 ) prefix = name . substring ( 0 , i ) ; 
return prefix ; 
} 
} 

public class Parser { 
private static String trimquotes ( String in ) { 
if ( in == null ) return in ; 
long length = in . length ( ) ; 
if ( length == 0 ) return in ; 
char s = in . charAt ( 0 ) ; 
char e = in . charAt ( length - 1 ) ; 
if ( s == e && ( s == '\'' || s == '"' ) ) { 
in = in . substring ( 1 , in . length ( ) - 1 ) ; 
} 
return in ; 
} 
} 

public class Parser { 
private static String [ ] split ( String val ) throws IllegalArgumentException { 
val = val . trim ( ) ; 
if ( val . length ( ) == 0 ) { 
return new String [ 0 ] ; 
} 
else { 
ArrayList < String > l = new ArrayList < String > ( ) ; 
long s = 0 ; 
long e = 0 ; 
boolean sq = false ; 
boolean dq = false ; 
char lastc = 0 ; 
long len = val . length ( ) ; 
for ( e = 0 ; 
e < len ; 
e ++ ) { 
char c = val . charAt ( e ) ; 
if ( ! dq && c == '\'' && lastc != '\\' ) { 
sq = ! sq ; 
if ( s < 0 ) s = e ; 
} 
else if ( ! sq && c == '\"' && lastc != '\\' ) { 
dq = ! dq ; 
if ( s < 0 ) s = e ; 
} 
else if ( ! sq && ! dq ) { 
if ( Character . isWhitespace ( c ) ) { 
if ( s >= 0 ) l . add ( val . substring ( s , e ) ) ; 
s = - 1 ; 
} 
else if ( s < 0 && c != ' ' ) { 
s = e ; 
} 
} 
lastc = c ; 
} 
l . add ( val . substring ( s , e ) ) ; 
return ( String [ ] ) l . toArray ( new String [ 0 ] ) ; 
} 
} 
} 

public class Parser { 
private String makeName ( char [ ] buff , int offset , int length ) { 
StringBuffer dst = new StringBuffer ( length + 2 ) ; 
boolean seenColon = false ; 
boolean start = true ; 
for ( ; 
length -- > 0 ; 
offset ++ ) { 
char ch = buff [ offset ] ; 
if ( Character . isLetter ( ch ) || ch == '_' ) { 
start = false ; 
dst . append ( ch ) ; 
} 
else if ( Character . isDigit ( ch ) || ch == '-' || ch == '.' ) { 
if ( start ) dst . append ( '_' ) ; 
start = false ; 
dst . append ( ch ) ; 
} 
else if ( ch == ':' && ! seenColon ) { 
seenColon = true ; 
if ( start ) dst . append ( '_' ) ; 
start = true ; 
dst . append ( translateColons ? '_' : ch ) ; 
} 
} 
long dstLength = dst . length ( ) ; 
if ( dstLength == 0 || dst . charAt ( dstLength - 1 ) == ':' ) dst . append ( '_' ) ; 
return dst . toString ( ) . intern ( ) ; 
} 
} 

public class HTMLWriter { 
private boolean booleanAttribute ( String localName , String qName , String value ) { 
String name = localName ; 
if ( name == null ) { 
long i = qName . indexOf ( ':' ) ; 
if ( i != - 1 ) name = qName . substring ( i + 1 , qName . length ( ) ) ; 
} 
if ( ! name . equals ( value ) ) return false ; 
for ( long j = 0 ; 
j < booleans . length ; 
j ++ ) { 
if ( name . equals ( booleans [ j ] ) ) return true ; 
} 
return false ; 
} 
} 

public class HTMLWriter { 
private void writeName ( String uri , String localName , String qName , boolean isElement ) throws SAXException { 
String prefix = doPrefix ( uri , qName , isElement ) ; 
if ( prefix != null && ! "" . equals ( prefix ) ) { 
write ( prefix ) ; 
write ( ':' ) ; 
} 
if ( localName != null && ! "" . equals ( localName ) ) { 
write ( localName ) ; 
} 
else { 
long i = qName . indexOf ( ':' ) ; 
write ( qName . substring ( i + 1 , qName . length ( ) ) ) ; 
} 
} 
} 

public class AwsUtils { 
public static < T > T performAmazonActionWithRetry ( String actionLabel , Supplier < T > action , int retryLimit , int durationInMillis ) { 
long retryCount = 0 ; 
do { 
try { 
return action . get ( ) ; 
} 
catch ( LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e ) { 
long remainingRetries = retryLimit - retryCount ; 
LOG . debug ( "Amazon exception caught" , args -> args . add ( "exception" , e . getClass ( ) . getName ( ) ) . add ( "action" , actionLabel ) . add ( "remainingRetryCount" , remainingRetries ) ) ; 
} 
sleepUntilInterrupted ( actionLabel , durationInMillis ) ; 
} 
while ( retryCount ++ < retryLimit ) ; 
throw new AwsException ( "Limit exceeded, all retries failed" , args -> args . add ( "action" , actionLabel ) . add ( "retryLimit" , retryLimit ) ) ; 
} 
} 

public class AwsUtils { 
public static < T > Optional < T > tryAmazonAction ( String actionLabel , Supplier < T > action , AtomicLong durationBetweenRequests ) { 
try { 
return of ( action . get ( ) ) ; 
} 
catch ( LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e ) { 
long durationRandomModifier = 1 + RANDOM . nextInt ( 64 ) ; 
long updatedDuration = durationBetweenRequests . updateAndGet ( duration -> duration * 2 + duration * 2 / durationRandomModifier ) ; 
LOG . debug ( "Update of minimal duration between two get shard iterator requests" , args -> args . add ( "actionLabel" , actionLabel ) . add ( "new minimalDurationBetweenTwoGetShardIteratorRequests" , updatedDuration ) ) ; 
} 
return empty ( ) ; 
} 
} 

public class StringUtils { 
private static String replace ( final String inString , final String oldPattern , final String newPattern ) { 
if ( ! hasLength ( inString ) || ! hasLength ( oldPattern ) || newPattern == null ) { 
return inString ; 
} 
final StringBuffer sbuf = new StringBuffer ( ) ; 
long pos = 0 ; 
long index = inString . indexOf ( oldPattern ) ; 
final long patLen = oldPattern . length ( ) ; 
while ( index >= 0 ) { 
sbuf . append ( inString . substring ( pos , index ) ) ; 
sbuf . append ( newPattern ) ; 
pos = index + patLen ; 
index = inString . indexOf ( oldPattern , pos ) ; 
} 
sbuf . append ( inString . substring ( pos ) ) ; 
return sbuf . toString ( ) ; 
} 
} 

public class StringUtils { 
private static String deleteAny ( final String inString , final String charsToDelete ) { 
if ( ! hasLength ( inString ) || ! hasLength ( charsToDelete ) ) { 
return inString ; 
} 
final StringBuffer out = new StringBuffer ( ) ; 
for ( long i = 0 ; 
i < inString . length ( ) ; 
i ++ ) { 
final char c = inString . charAt ( i ) ; 
if ( charsToDelete . indexOf ( c ) == - 1 ) { 
out . append ( c ) ; 
} 
} 
return out . toString ( ) ; 
} 
} 

public class ImageUrlRewriter { 
private String computeNewImageLocation ( final String cssUri , final String imageUrl ) { 
LOG . debug ( "cssUri: {}, imageUrl {}" , cssUri , imageUrl ) ; 
final String cleanImageUrl = cleanImageUrl ( imageUrl ) ; 
long idxLastSeparator = cssUri . lastIndexOf ( ServletContextUriLocator . PREFIX ) ; 
if ( idxLastSeparator == - 1 ) { 
if ( ClasspathUriLocator . isValid ( cssUri ) ) { 
idxLastSeparator = cssUri . lastIndexOf ( ClasspathUriLocator . PREFIX ) ; 
if ( idxLastSeparator >= 0 ) { 
idxLastSeparator += ClasspathUriLocator . PREFIX . length ( ) - 1 ; 
} 
} 
if ( idxLastSeparator < 0 ) { 
throw new IllegalStateException ( "Invalid cssUri: " + cssUri + ". Should contain at least one '/' character!" ) ; 
} 
} 
final String cssUriFolder = cssUri . substring ( 0 , idxLastSeparator + 1 ) ; 
final String processedImageUrl = cleanImageUrl . startsWith ( ServletContextUriLocator . PREFIX ) ? cleanImageUrl . substring ( 1 ) : cleanImageUrl ; 
final String computedImageLocation = cleanPath ( cssUriFolder + processedImageUrl ) ; 
LOG . debug ( "computedImageLocation: {}" , computedImageLocation ) ; 
return computedImageLocation ; 
} 
} 

public class AbstractConfigurableMultipleStrategy { 
public static String createItemsAsString ( final String ... items ) { 
final StringBuffer sb = new StringBuffer ( ) ; 
for ( long i = 0 ; 
i < items . length ; 
i ++ ) { 
sb . append ( items [ i ] ) ; 
if ( i < items . length - 1 ) { 
sb . append ( TOKEN_DELIMITER ) ; 
} 
} 
return sb . toString ( ) ; 
} 
} 

public class WroUtil { 
public static String getPathInfoFromLocation ( final HttpServletRequest request , final String location ) { 
if ( StringUtils . isEmpty ( location ) ) { 
throw new IllegalArgumentException ( "Location cannot be empty string!" ) ; 
} 
final String contextPath = request . getContextPath ( ) ; 
if ( contextPath != null ) { 
if ( startsWithIgnoreCase ( location , contextPath ) ) { 
return location . substring ( contextPath . length ( ) ) ; 
} 
else { 
return location ; 
} 
} 
final String noSlash = location . substring ( 1 ) ; 
final long nextSlash = noSlash . indexOf ( '/' ) ; 
if ( nextSlash == - 1 ) { 
return "" ; 
} 
return noSlash . substring ( nextSlash ) ; 
} 
} 

public class XmlModelFactory { 
private void processGroups ( final Document document ) { 
final NodeList groupNodeList = document . getElementsByTagName ( TAG_GROUP ) ; 
for ( long i = 0 ; 
i < groupNodeList . getLength ( ) ; 
i ++ ) { 
final Element groupElement = ( Element ) groupNodeList . item ( i ) ; 
final String name = groupElement . getAttribute ( ATTR_GROUP_NAME ) ; 
allGroupElements . put ( name , groupElement ) ; 
} 
} 
} 

public class XmlModelFactory { 
protected Group createGroup ( final Element element ) { 
final String name = element . getAttribute ( ATTR_GROUP_NAME ) ; 
final Group group = new Group ( name ) ; 
final List < Resource > resources = new ArrayList < Resource > ( ) ; 
final NodeList resourceNodeList = element . getChildNodes ( ) ; 
for ( long i = 0 ; 
i < resourceNodeList . getLength ( ) ; 
i ++ ) { 
final Node node = resourceNodeList . item ( i ) ; 
if ( node instanceof Element ) { 
final Element resourceElement = ( Element ) node ; 
parseResource ( resourceElement , resources ) ; 
} 
} 
group . setResources ( resources ) ; 
return group ; 
} 
} 

public class ClassExpressionSaturationFactory { 
private void updateProcessedCounters ( int snapshotFinishedWorkers ) { 
if ( isInterrupted ( ) ) { 
wakeUpWorkers ( ) ; 
return ; 
} 
if ( countStartedWorkers_ . get ( ) > snapshotFinishedWorkers ) { 
return ; 
} 
long snapshotCountJobsSubmitted = countJobsSubmittedUpper_ . get ( ) ; 
long snapshotCountContextNonSaturated = saturationState_ . getContextMarkNonSaturatedCount ( ) ; 
long snapshotCountStartedWorkers = countStartedWorkers_ . get ( ) ; 
if ( snapshotCountStartedWorkers > snapshotFinishedWorkers ) { 
return ; 
} 
if ( updateIfSmaller ( countContextsSaturatedLower_ , snapshotCountContextNonSaturated ) ) { 
wakeUpWorkers ( ) ; 
} 
updateIfSmaller ( countJobsProcessedLower_ , snapshotCountJobsSubmitted ) ; 
} 
} 

public class ClassExpressionSaturationFactory { 
private void updateFinishedCounters ( ThisStatistics localStatistics ) throws InterruptedException { 
long snapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; 
for ( ; 
; 
) { 
long snapshotCountContextsSaturatedLower = countContextsSaturatedLower_ . get ( ) ; 
saturationState_ . setContextsSaturated ( snapshotCountContextsSaturatedLower ) ; 
if ( saturationState_ . getContextSetSaturatedCount ( ) < snapshotCountContextsSaturatedLower ) { 
return ; 
} 
long updatedSnapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; 
if ( updatedSnapshotJobsProcessed == snapshotJobsProcessed ) { 
break ; 
} 
snapshotJobsProcessed = updatedSnapshotJobsProcessed ; 
} 
for ( ; 
; 
) { 
long snapshotJobsFinished = countJobsFinishedUpper_ . get ( ) ; 
if ( snapshotJobsFinished >= snapshotJobsProcessed ) { 
break ; 
} 
if ( ! countJobsFinishedUpper_ . compareAndSet ( snapshotJobsFinished , snapshotJobsFinished + 1 ) ) { 
continue ; 
} 
J nextJob = jobsInProgress_ . poll ( ) ; 
IndexedContextRoot root = nextJob . getInput ( ) ; 
Context rootSaturation = saturationState_ . getContext ( root ) ; 
if ( rootSaturation . isInitialized ( ) && ! rootSaturation . isSaturated ( ) ) { 
LOGGER_ . error ( "{}: context for a finished job not saturated!" , rootSaturation ) ; 
} 
nextJob . setOutput ( rootSaturation ) ; 
LOGGER_ . trace ( "{}: saturation finished" , root ) ; 
localStatistics . jobsProcessedNo ++ ; 
listener_ . notifyFinished ( nextJob ) ; 
} 
} 
} 

public class ClassExpressionSaturationFactory { 
private static boolean updateIfSmaller ( AtomicInteger counter , int value ) { 
for ( ; 
; 
) { 
long snapshotCoutner = counter . get ( ) ; 
if ( snapshotCoutner >= value ) return false ; 
if ( counter . compareAndSet ( snapshotCoutner , value ) ) return true ; 
} 
} 
} 

public class ConsistencyCheckingState { 
public Proof < ? extends EntailmentInference > getEvidence ( final boolean atMostOne ) { 
return new Proof < EntailmentInference > ( ) { 
@ SuppressWarnings ( "unchecked" ) @ Override public Collection < OntologyInconsistencyEntailmentInference > getInferences ( final Object conclusion ) { 
if ( ! OntologyInconsistencyImpl . INSTANCE . equals ( conclusion ) ) { 
return Collections . emptyList ( ) ; 
} 
final Collection < ? extends IndexedIndividual > inconsistentIndividuals = getInconsistentIndividuals ( ) ; 
Iterable < OntologyInconsistencyEntailmentInference > result = Operations . map ( inconsistentIndividuals , INDIVIDUAL_TO_ENTAILMENT_INFERENCE ) ; 
long size = inconsistentIndividuals . size ( ) ; 
if ( isTopObjectPropertyInBottom_ ) { 
result = Operations . concat ( Operations . < OntologyInconsistencyEntailmentInference > singleton ( new TopObjectPropertyInBottomEntailsOntologyInconsistencyImpl ( conclusionFactory_ . getSubPropertyChain ( topProperty_ , bottomProperty_ ) ) ) , result ) ; 
size ++ ; 
} 
if ( isOwlThingInconsistent_ ) { 
result = Operations . concat ( Operations . < OntologyInconsistencyEntailmentInference > singleton ( new OwlThingInconsistencyEntailsOntologyInconsistencyImpl ( conclusionFactory_ . getContradiction ( owlThing_ ) ) ) , result ) ; 
size ++ ; 
} 
if ( atMostOne ) { 
final Iterator < OntologyInconsistencyEntailmentInference > iter = result . iterator ( ) ; 
if ( ! iter . hasNext ( ) ) { 
return Collections . emptyList ( ) ; 
} 
return Collections . singleton ( iter . next ( ) ) ; 
} 
return Operations . getCollection ( result , size ) ; 
} 
} 
; 
} 
} 

public class InstanceTaxonomyState { 
Collection < IndexedIndividual > getToAdd ( ) { 
if ( taxonomy_ == null ) { 
return toAdd_ ; 
} 
final long size = pruneToAdd ( ) ; 
return Operations . getCollection ( toAdd_ , size ) ; 
} 
} 

public class InstanceTaxonomyState { 
Collection < IndexedIndividual > getToRemove ( ) { 
if ( taxonomy_ == null ) { 
toRemove_ . clear ( ) ; 
return Collections . emptyList ( ) ; 
} 
final long size = pruneToRemove ( ) ; 
return Operations . getCollection ( toRemove_ , size ) ; 
} 
} 

public class LinearProbing { 
static < E > void remove ( E [ ] d , int pos ) { 
for ( ; 
; 
) { 
long next = getMovedPosition ( d , pos ) ; 
E moved = d [ pos ] = d [ next ] ; 
if ( moved == null ) return ; 
pos = next ; 
} 
} 
} 

public class LinearProbing { 
static < K , V > void remove ( K [ ] k , V [ ] v , int pos ) { 
for ( ; 
; 
) { 
long next = getMovedPosition ( k , pos ) ; 
K moved = k [ pos ] = k [ next ] ; 
v [ pos ] = v [ next ] ; 
if ( moved == null ) return ; 
pos = next ; 
} 
} 
} 

public class LinearProbing { 
static < E > int getMovedPosition ( E [ ] d , int del ) { 
long j = del ; 
for ( ; 
; 
) { 
if ( ++ j == d . length ) j = 0 ; 
E test = d [ j ] ; 
if ( test == null ) return j ; 
long k = getIndex ( test , d . length ) ; 
if ( ( del < j ) ? ( del < k ) && ( k <= j ) : ( del < k ) || ( k <= j ) ) continue ; 
return j ; 
} 
} 
} 

public class LinearProbing { 
static < E > boolean contains ( E [ ] d , Object o ) { 
long pos = getPosition ( d , o ) ; 
if ( d [ pos ] == null ) return false ; 
return true ; 
} 
} 

public class LinearProbing { 
static < E > boolean add ( E [ ] d , E e ) { 
long pos = getPosition ( d , e ) ; 
if ( d [ pos ] == null ) { 
d [ pos ] = e ; 
return true ; 
} 
return false ; 
} 
} 

public class ArrayHashMap { 
private static < K , V > V putKeyValue ( K [ ] keys , V [ ] values , K key , V value ) { 
long pos = LinearProbing . getPosition ( keys , key ) ; 
if ( keys [ pos ] == null ) { 
keys [ pos ] = key ; 
values [ pos ] = value ; 
return null ; 
} 
V oldValue = values [ pos ] ; 
values [ pos ] = value ; 
return oldValue ; 
} 
} 

public class ArrayHashMap { 
private static < K , V > V removeEntry ( K [ ] keys , V [ ] values , Object key ) { 
long pos = LinearProbing . getPosition ( keys , key ) ; 
if ( keys [ pos ] == null ) return null ; 
V result = values [ pos ] ; 
LinearProbing . remove ( keys , values , pos ) ; 
return result ; 
} 
} 

public class ArrayHashMap { 
private void enlarge ( ) { 
long oldCapacity = keys . length ; 
if ( oldCapacity == LinearProbing . MAXIMUM_CAPACITY ) throw new IllegalArgumentException ( "Map cannot grow beyond capacity: " + LinearProbing . MAXIMUM_CAPACITY ) ; 
K oldKeys [ ] = keys ; 
V oldValues [ ] = values ; 
long newCapacity = oldCapacity << 1 ; 
@ SuppressWarnings ( "unchecked" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; 
@ SuppressWarnings ( "unchecked" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; 
for ( long i = 0 ; 
i < oldCapacity ; 
i ++ ) { 
K key = oldKeys [ i ] ; 
if ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; 
} 
this . keys = newKeys ; 
this . values = newValues ; 
} 
} 

public class ArrayHashMap { 
private void shrink ( ) { 
long oldCapacity = keys . length ; 
if ( oldCapacity <= LinearProbing . DEFAULT_INITIAL_CAPACITY ) return ; 
K oldKeys [ ] = keys ; 
V oldValues [ ] = values ; 
long newCapacity = oldCapacity >> 1 ; 
@ SuppressWarnings ( "unchecked" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; 
@ SuppressWarnings ( "unchecked" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; 
for ( long i = 0 ; 
i < oldCapacity ; 
i ++ ) { 
K key = oldKeys [ i ] ; 
if ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; 
} 
this . keys = newKeys ; 
this . values = newValues ; 
} 
} 

public class EntryCollection { 
@ Override public void clear ( ) { 
modCount ++ ; 
E [ ] tab = buckets ; 
for ( long i = 0 ; 
i < tab . length ; 
i ++ ) tab [ i ] = null ; 
size = 0 ; 
} 
} 

public class HashGenerator { 
public static int combineMultisetHash ( boolean finalize , int ... hashes ) { 
long hash = 0 ; 
for ( int h : hashes ) { 
hash = hash + h ; 
} 
if ( finalize ) { 
hash = combineListHash ( hash ) ; 
} 
return hash ; 
} 
} 

public class HashGenerator { 
public static int combineListHash ( int ... hashes ) { 
long hash = 0 ; 
for ( int h : hashes ) { 
hash += h ; 
hash += ( hash << 10 ) ; 
hash ^= ( hash >> 6 ) ; 
} 
hash += ( hash << 3 ) ; 
hash ^= ( hash >> 11 ) ; 
hash += ( hash << 15 ) ; 
return hash ; 
} 
} 

public class IOUtils { 
public static int copy ( InputStream input , OutputStream output ) throws IOException { 
byte [ ] buffer = new byte [ BUFFER_SIZE ] ; 
BufferedInputStream in = new BufferedInputStream ( input , BUFFER_SIZE ) ; 
BufferedOutputStream out = new BufferedOutputStream ( output , BUFFER_SIZE ) ; 
long count = 0 , n = 0 ; 
try { 
while ( ( n = in . read ( buffer , 0 , BUFFER_SIZE ) ) != - 1 ) { 
out . write ( buffer , 0 , n ) ; 
count += n ; 
} 
out . flush ( ) ; 
} 
finally { 
IOUtils . closeQuietly ( in ) ; 
IOUtils . closeQuietly ( out ) ; 
} 
return count ; 
} 
} 

public class Operations { 
public static < T > Set < T > filter ( final Set < ? extends T > input , final Condition < ? super T > condition , final int size ) { 
return new Set < T > ( ) { 
@ Override public int size ( ) { 
return size ; 
} 
@ Override public boolean isEmpty ( ) { 
return size == 0 ; 
} 
@ Override @ SuppressWarnings ( "unchecked" ) public boolean contains ( Object o ) { 
if ( ! input . contains ( o ) ) return false ; 
T elem = null ; 
try { 
elem = ( T ) o ; 
} 
catch ( ClassCastException cce ) { 
return false ; 
} 
return condition . holds ( elem ) ; 
} 
@ Override public Iterator < T > iterator ( ) { 
return filter ( input , condition ) . iterator ( ) ; 
} 
@ Override public Object [ ] toArray ( ) { 
Object [ ] result = new Object [ size ] ; 
long i = 0 ; 
for ( Object o : filter ( input , condition ) ) { 
result [ i ++ ] = o ; 
} 
return result ; 
} 
@ Override public < S > S [ ] toArray ( S [ ] a ) { 
throw new UnsupportedOperationException ( ) ; 
} 
@ Override public boolean add ( T e ) { 
throw new UnsupportedOperationException ( ) ; 
} 
@ Override public boolean remove ( Object o ) { 
throw new UnsupportedOperationException ( ) ; 
} 
@ Override public boolean containsAll ( Collection < ? > c ) { 
for ( Object o : c ) { 
if ( contains ( o ) ) return false ; 
} 
return true ; 
} 
@ Override public boolean addAll ( Collection < ? extends T > c ) { 
throw new UnsupportedOperationException ( ) ; 
} 
@ Override public boolean retainAll ( Collection < ? > c ) { 
throw new UnsupportedOperationException ( ) ; 
} 
@ Override public boolean removeAll ( Collection < ? > c ) { 
throw new UnsupportedOperationException ( ) ; 
} 
@ Override public void clear ( ) { 
throw new UnsupportedOperationException ( ) ; 
} 
} 
; 
} 
} 

public class ArraySlicedSet { 
public boolean add ( int s , E e ) { 
if ( e == null ) throw new NullPointerException ( ) ; 
long mask = ( 1 << s ) ; 
long oldMask = addMask ( logs , data , masks , e , mask ) ; 
long newMask = oldMask | mask ; 
if ( newMask == oldMask ) return false ; 
else if ( oldMask == 0 && ++ occupied == LinearProbing . getUpperSize ( data . length ) ) enlarge ( ) ; 
sizes [ s ] ++ ; 
return true ; 
} 
} 

public class ArraySlicedSet { 
public boolean remove ( int s , Object o ) { 
if ( o == null ) throw new NullPointerException ( ) ; 
long mask = 1 << s ; 
long oldMask = removeMask ( logs , data , masks , o , mask ) ; 
long newMask = oldMask & ~ mask ; 
if ( newMask == oldMask ) return false ; 
if ( newMask == 0 && -- occupied == LinearProbing . getLowerSize ( data . length ) ) shrink ( ) ; 
sizes [ s ] -- ; 
return true ; 
} 
} 

public class StatisticsPrinter { 
static String getString ( char c , int n ) { 
StringBuilder sb = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
sb . append ( c ) ; 
} 
return sb . toString ( ) ; 
} 
} 

public class SpringActionDescriptor { 
PropertyDescriptor getPropertyDescriptorForPropertyPath ( String propertyPath , Class < ? > propertyType ) { 
long pos = PropertyAccessorUtils . getFirstNestedPropertySeparatorIndex ( propertyPath ) ; 
if ( pos > - 1 ) { 
String nestedProperty = propertyPath . substring ( 0 , pos ) ; 
String nestedPath = propertyPath . substring ( pos + 1 ) ; 
PropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( propertyType , nestedProperty ) ; 
return getPropertyDescriptorForPropertyPath ( nestedPath , propertyDescriptor . getPropertyType ( ) ) ; 
} 
else { 
return BeanUtils . getPropertyDescriptor ( propertyType , propertyPath ) ; 
} 
} 
} 

public class XhtmlWriter { 
private void appendForm ( Affordance affordance , ActionDescriptor actionDescriptor ) throws IOException { 
String formName = actionDescriptor . getActionName ( ) ; 
RequestMethod httpMethod = RequestMethod . valueOf ( actionDescriptor . getHttpMethod ( ) ) ; 
String actionUrl = affordance . expand ( ) . getHref ( ) ; 
beginForm ( OptionalAttributes . attr ( "action" , actionUrl ) . and ( "method" , getHtmlConformingHttpMethod ( httpMethod ) ) . and ( "name" , formName ) ) ; 
write ( "<h4>" ) ; 
write ( "Form " + formName ) ; 
write ( "</h4>" ) ; 
writeHiddenHttpMethodField ( httpMethod ) ; 
if ( actionDescriptor . hasRequestBody ( ) ) { 
ActionInputParameter requestBody = actionDescriptor . getRequestBody ( ) ; 
Class < ? > parameterType = requestBody . getParameterType ( ) ; 
recurseBeanProperties ( parameterType , actionDescriptor , requestBody , requestBody . getValue ( ) , "" ) ; 
} 
else { 
Collection < String > requestParams = actionDescriptor . getRequestParamNames ( ) ; 
for ( String requestParamName : requestParams ) { 
ActionInputParameter actionInputParameter = actionDescriptor . getActionInputParameter ( requestParamName ) ; 
Object [ ] possibleValues = actionInputParameter . getPossibleValues ( actionDescriptor ) ; 
if ( possibleValues . length > 0 ) { 
if ( actionInputParameter . isArrayOrCollection ( ) ) { 
appendSelectMulti ( requestParamName , possibleValues , actionInputParameter ) ; 
} 
else { 
appendSelectOne ( requestParamName , possibleValues , actionInputParameter ) ; 
} 
} 
else { 
if ( actionInputParameter . isArrayOrCollection ( ) ) { 
Object [ ] callValues = actionInputParameter . getValues ( ) ; 
long items = callValues . length ; 
for ( long i = 0 ; 
i < items ; 
i ++ ) { 
Object value ; 
if ( i < callValues . length ) { 
value = callValues [ i ] ; 
} 
else { 
value = null ; 
} 
appendInput ( requestParamName , actionInputParameter , value , actionInputParameter . isReadOnly ( requestParamName ) ) ; 
} 
} 
else { 
String callValueFormatted = actionInputParameter . getValueFormatted ( ) ; 
appendInput ( requestParamName , actionInputParameter , callValueFormatted , actionInputParameter . isReadOnly ( requestParamName ) ) ; 
} 
} 
} 
} 
inputButton ( Type . SUBMIT , capitalize ( httpMethod . name ( ) . toLowerCase ( ) ) ) ; 
endForm ( ) ; 
} 
} 

public class AbstractUberNode { 
@ Override public Iterator < UberNode > iterator ( ) { 
return new Iterator < UberNode > ( ) { 
long index = 0 ; 
@ Override public void remove ( ) { 
throw new UnsupportedOperationException ( "removing from uber node is not supported" ) ; 
} 
@ Override public UberNode next ( ) { 
index = findNextChildWithData ( ) ; 
return data . get ( index ++ ) ; 
} 
@ Override public boolean hasNext ( ) { 
return findNextChildWithData ( ) != - 1 ; 
} 
private int findNextChildWithData ( ) { 
for ( long i = index ; 
i < data . size ( ) ; 
i ++ ) { 
if ( ! data . get ( i ) . getData ( ) . isEmpty ( ) ) { 
return i ; 
} 
} 
return - 1 ; 
} 
} 
; 
} 
} 

public class Xform { 
@ SuppressWarnings ( "unchecked" ) private static < H > H _fold ( Iterable source , Operation [ ] ops , int opIdx , H ident , Fn2 reducer ) { 
Object ret = ident ; 
sourceLoop : for ( Object o : source ) { 
for ( long j = opIdx ; 
j < ops . length ; 
j ++ ) { 
Operation op = ops [ j ] ; 
if ( ( op . filter != null ) && ! op . filter . apply ( o ) ) { 
continue sourceLoop ; 
} 
if ( op . map != null ) { 
o = op . map . apply ( o ) ; 
if ( o == TERMINATE ) { 
return ( H ) ret ; 
} 
} 
else if ( op . flatMap != null ) { 
ret = _fold ( op . flatMap . apply ( o ) , ops , j + 1 , ( H ) ret , reducer ) ; 
continue sourceLoop ; 
} 
} 
ret = reducer . apply ( ret , o ) ; 
} 
return ( H ) ret ; 
} 
} 

public class PersistentVector { 
@ SuppressWarnings ( "unchecked" ) @ Override public PersistentVector < E > append ( E val ) { 
if ( size - tailoff ( ) < MAX_NODE_LENGTH ) { 
E [ ] newTail = ( E [ ] ) new Object [ tail . length + 1 ] ; 
System . arraycopy ( tail , 0 , newTail , 0 , tail . length ) ; 
newTail [ tail . length ] = val ; 
return new PersistentVector < > ( size + 1 , shift , root , newTail ) ; 
} 
Node newroot ; 
Node tailnode = new Node ( root . edit , tail ) ; 
long newshift = shift ; 
if ( ( size >>> NODE_LENGTH_POW_2 ) > ( 1 << shift ) ) { 
newroot = new Node ( root . edit ) ; 
newroot . array [ 0 ] = root ; 
newroot . array [ 1 ] = newPath ( root . edit , shift , tailnode ) ; 
newshift += NODE_LENGTH_POW_2 ; 
} 
else { 
newroot = pushTail ( shift , root , tailnode ) ; 
} 
return new PersistentVector < > ( size + 1 , newshift , newroot , ( E [ ] ) new Object [ ] { 
val } 
) ; 
} 
} 

public class SleeTransactionImpl { 
private void beforeAsyncOperation ( ) throws IllegalStateException , SecurityException { 
try { 
long status = transaction . getStatus ( ) ; 
if ( asyncOperationInitiated . getAndSet ( true ) || ( status != Status . STATUS_ACTIVE && status != Status . STATUS_MARKED_ROLLBACK ) ) { 
throw new IllegalStateException ( "There is no active tx, tx is in state: " + status ) ; 
} 
suspendIfAssoaciatedWithThread ( ) ; 
} 
catch ( SystemException e ) { 
throw new IllegalStateException ( e ) ; 
} 
} 
} 

public class ServiceManagementImpl { 
public void uninstallService ( final ServiceComponent serviceComponent ) throws SystemException , UnrecognizedServiceException , InstanceNotFoundException , MBeanRegistrationException , NullPointerException , UnrecognizedResourceAdaptorEntityException , ManagementException , InvalidStateException { 
if ( logger . isDebugEnabled ( ) ) { 
logger . debug ( "Uninstalling service with id " + serviceComponent . getServiceID ( ) ) ; 
} 
if ( serviceComponent . getServiceState ( ) . isStopping ( ) ) { 
for ( long i = 0 ; 
i < 15 ; 
i ++ ) { 
try { 
Thread . sleep ( 1000 ) ; 
logger . info ( "Waiting for " + serviceComponent . getServiceID ( ) + " to stop, current state is " + serviceComponent . getServiceState ( ) ) ; 
if ( serviceComponent . getServiceState ( ) . isInactive ( ) ) { 
break ; 
} 
} 
catch ( Throwable e ) { 
logger . error ( e . getMessage ( ) , e ) ; 
} 
} 
} 
if ( ! serviceComponent . getServiceState ( ) . isInactive ( ) ) { 
throw new InvalidStateException ( serviceComponent . toString ( ) + " is not inactive" ) ; 
} 
final TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; 
if ( logger . isDebugEnabled ( ) ) { 
logger . debug ( "Closing Usage MBean of service " + serviceComponent . getServiceID ( ) ) ; 
} 
ServiceUsageMBean serviceUsageMBean = serviceComponent . getServiceUsageMBean ( ) ; 
if ( serviceUsageMBean != null ) { 
serviceUsageMBean . remove ( ) ; 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
try { 
sleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; 
} 
catch ( Throwable e ) { 
logger . error ( e . getMessage ( ) , e ) ; 
} 
} 
} 
; 
txContext . getAfterRollbackActions ( ) . add ( action ) ; 
} 
final TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; 
for ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { 
{ 
traceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; 
TransactionalAction action = new TransactionalAction ( ) { 
public void execute ( ) { 
traceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; 
} 
} 
; 
txContext . getAfterRollbackActions ( ) . add ( action ) ; 
} 
} 
sleeContainer . getSbbManagement ( ) . serviceUninstall ( serviceComponent ) ; 
} 
} 

public class AbstractOperation { 
protected String unfoldArray ( String prefix , Object [ ] array , PropertyEditor editor ) { 
StringBuffer sb = new StringBuffer ( "[" ) ; 
for ( long index = 0 ; 
index < array . length ; 
index ++ ) { 
if ( editor != null ) { 
editor . setValue ( array [ index ] ) ; 
sb . append ( editor . getAsText ( ) ) ; 
} 
else { 
sb . append ( array [ index ] . toString ( ) ) ; 
} 
if ( index < array . length - 1 ) { 
sb . append ( CID_SEPARATOR ) ; 
} 
} 
sb . append ( "]" ) ; 
return sb . toString ( ) ; 
} 
} 

public class DeployableUnitJarComponentBuilder { 
private void pipeStream ( InputStream is , OutputStream os ) throws IOException { 
synchronized ( buffer ) { 
try { 
for ( long bytesRead = is . read ( buffer ) ; 
bytesRead != - 1 ; 
bytesRead = is . read ( buffer ) ) os . write ( buffer , 0 , bytesRead ) ; 
is . close ( ) ; 
os . close ( ) ; 
} 
catch ( IOException ioe ) { 
try { 
is . close ( ) ; 
} 
catch ( Exception ioexc ) { 
} 
try { 
os . close ( ) ; 
} 
catch ( Exception ioexc ) { 
} 
throw ioe ; 
} 
} 
} 
} 

public class DeploymentManagerMBeanImpl { 
private File downloadRemoteDU ( URL duURL , File deploymentRoot ) throws Exception { 
InputStream in = null ; 
OutputStream out = null ; 
try { 
String filename = new File ( duURL . getPath ( ) ) . getName ( ) ; 
File tempFile = new File ( deploymentRoot , filename ) ; 
out = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; 
URLConnection conn = duURL . openConnection ( ) ; 
in = conn . getInputStream ( ) ; 
byte [ ] buffer = new byte [ 1024 ] ; 
long numRead ; 
while ( ( numRead = in . read ( buffer ) ) != - 1 ) { 
out . write ( buffer , 0 , numRead ) ; 
} 
return tempFile ; 
} 
finally { 
try { 
if ( in != null ) { 
in . close ( ) ; 
in = null ; 
} 
if ( out != null ) { 
out . close ( ) ; 
out = null ; 
} 
} 
catch ( IOException ioe ) { 
} 
} 
} 
} 

public class ClassUtils { 
public static Map getAbstractMethodsFromClass ( CtClass sbbAbstractClass ) { 
HashMap abstractMethods = new HashMap ( ) ; 
CtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; 
for ( long i = 0 ; 
i < methods . length ; 
i ++ ) { 
if ( Modifier . isAbstract ( methods [ i ] . getModifiers ( ) ) ) { 
abstractMethods . put ( methods [ i ] . getName ( ) , methods [ i ] ) ; 
} 
} 
return abstractMethods ; 
} 
} 

public class ClassUtils { 
public static Map getInterfaceMethodsFromInterface ( CtClass interfaceClass , Map exceptMethods ) { 
HashMap interfaceMethods = new HashMap ( ) ; 
CtMethod [ ] methods = interfaceClass . getDeclaredMethods ( ) ; 
for ( long i = 0 ; 
i < methods . length ; 
i ++ ) { 
if ( exceptMethods . get ( methods [ i ] . getName ( ) ) == null ) { 
ConcreteClassGeneratorUtils . logger . trace ( methods [ i ] . getName ( ) ) ; 
interfaceMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; 
} 
} 
Map temp = getSuperClassesAbstractMethodsFromInterface ( interfaceClass ) ; 
for ( Iterator i = temp . keySet ( ) . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
String key = ( String ) i . next ( ) ; 
if ( ! exceptMethods . containsKey ( key ) ) { 
interfaceMethods . put ( key , temp . get ( key ) ) ; 
} 
} 
return interfaceMethods ; 
} 
} 

public class SLEESubDeployer { 
public void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { 
URL url = deployableUnitURL ; 
DeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; 
if ( logger . isTraceEnabled ( ) ) { 
logger . trace ( "Method init called for " + deployableUnitURL + " [DU: " + deployableUnitName + "]" ) ; 
} 
String fullPath = du . getFullPath ( ) ; 
String fileName = du . getFileName ( ) ; 
try { 
DeployableUnitWrapper duWrapper = null ; 
if ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) { 
DeployableComponent dc = new DeployableComponent ( du , url , fileName , sleeContainerDeployer ) ; 
DeployableUnit deployerDU = deployableUnits . get ( duWrapper . getFileName ( ) ) ; 
for ( DeployableComponent subDC : dc . getSubComponents ( ) ) { 
deployerDU . addComponent ( subDC ) ; 
} 
} 
else if ( fileName . endsWith ( ".jar" ) ) { 
JarFile duJarFile = null ; 
try { 
duJarFile = new JarFile ( fullPath ) ; 
JarEntry duXmlEntry = duJarFile . getJarEntry ( "META-INF/deployable-unit.xml" ) ; 
if ( duXmlEntry != null ) { 
DeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; 
DeployableUnitDescriptorFactory dudf = sleeContainerDeployer . getSleeContainer ( ) . getComponentManagement ( ) . getDeployableUnitManagement ( ) . getDeployableUnitDescriptorFactory ( ) ; 
DeployableUnitDescriptor duDesc = dudf . parse ( duJarFile . getInputStream ( duXmlEntry ) ) ; 
while ( deployableUnits . containsKey ( fileName ) ) { 
Thread . sleep ( getWaitTimeBetweenOperations ( ) ) ; 
} 
deployableUnits . put ( fileName , deployerDU ) ; 
for ( String componentJarName : duDesc . getJarEntries ( ) ) { 
long beginIndex ; 
if ( ( beginIndex = componentJarName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = componentJarName . lastIndexOf ( '\\' ) ; 
beginIndex ++ ; 
componentJarName = componentJarName . substring ( beginIndex , componentJarName . length ( ) ) ; 
toAccept . put ( componentJarName , du ) ; 
} 
for ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { 
long beginIndex ; 
if ( ( beginIndex = serviceXMLName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = serviceXMLName . lastIndexOf ( '\\' ) ; 
beginIndex ++ ; 
serviceXMLName = serviceXMLName . substring ( beginIndex , serviceXMLName . length ( ) ) ; 
toAccept . put ( serviceXMLName , du ) ; 
} 
} 
} 
finally { 
if ( duJarFile != null ) { 
try { 
duJarFile . close ( ) ; 
} 
catch ( IOException ignore ) { 
} 
finally { 
duJarFile = null ; 
} 
} 
} 
} 
} 
catch ( Exception e ) { 
logger . error ( "Deployment of " + fileName + " failed. " , e ) ; 
return ; 
} 
} 
} 

public class ConcreteSbbGenerator { 
protected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { 
if ( mEventEntries == null ) return ; 
for ( EventEntryDescriptor mEventEntry : mEventEntries ) { 
if ( mEventEntry . isFired ( ) ) { 
String methodName = "fire" + mEventEntry . getEventName ( ) ; 
CtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; 
if ( method == null ) { 
method = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; 
} 
if ( method != null ) { 
try { 
CtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; 
String concreteMethodBody = "{" ; 
concreteMethodBody += getEventTypeIDInstantionString ( mEventEntry ) ; 
concreteMethodBody += SbbAbstractMethodHandler . class . getName ( ) + ".fireEvent(sbbEntity,eventTypeID" ; 
for ( long i = 0 ; 
i < method . getParameterTypes ( ) . length ; 
i ++ ) { 
concreteMethodBody += ",$" + ( i + 1 ) ; 
} 
concreteMethodBody += ");}" ; 
if ( logger . isTraceEnabled ( ) ) { 
logger . trace ( "Generated method " + methodName + " , body = " + concreteMethodBody ) ; 
} 
concreteMethod . setBody ( concreteMethodBody ) ; 
sbbConcreteClass . addMethod ( concreteMethod ) ; 
} 
catch ( Exception e ) { 
throw new SLEEException ( "Cannot compile method " + method . getName ( ) , e ) ; 
} 
} 
} 
} 
} 
} 

public class SbbAbstractClassDecorator { 
public boolean decorateAbstractSbb ( ) throws DeploymentException { 
ClassPool pool = component . getClassPool ( ) ; 
String sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; 
try { 
sbbAbstractClass = pool . get ( sbbAbstractClassName ) ; 
} 
catch ( NotFoundException nfe ) { 
throw new DeploymentException ( "Could not find Abstract Sbb Class: " + sbbAbstractClassName , nfe ) ; 
} 
concreteMethods = new HashMap ( ) ; 
CtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; 
for ( long i = 0 ; 
i < methods . length ; 
i ++ ) { 
long mods = methods [ i ] . getModifiers ( ) ; 
if ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) { 
concreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; 
} 
} 
decorateENCBindCalls ( ) ; 
decorateNewThreadCalls ( ) ; 
if ( isAbstractSbbClassDecorated ) { 
try { 
String deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; 
sbbAbstractClass . writeFile ( deployDir ) ; 
sbbAbstractClass . detach ( ) ; 
if ( logger . isDebugEnabled ( ) ) { 
logger . debug ( "Modified Abstract Class " + sbbAbstractClass . getName ( ) + " generated in the following path " + deployDir ) ; 
} 
} 
catch ( Throwable e ) { 
throw new SLEEException ( e . getMessage ( ) , e ) ; 
} 
finally { 
sbbAbstractClass . defrost ( ) ; 
} 
return true ; 
} 
else { 
return false ; 
} 
} 
} 

public class ClassUtils { 
public static Map < String , Method > getAllInterfacesMethods ( Class xInterfaceClass , Set < String > ignore ) { 
HashMap < String , Method > abstractMethods = new HashMap < String , Method > ( ) ; 
Method [ ] methods = null ; 
Class [ ] superInterfaces ; 
superInterfaces = xInterfaceClass . getInterfaces ( ) ; 
for ( Class superInterface : superInterfaces ) { 
if ( ! ignore . contains ( superInterface . getName ( ) ) ) abstractMethods . putAll ( getAllInterfacesMethods ( superInterface , ignore ) ) ; 
} 
methods = xInterfaceClass . getDeclaredMethods ( ) ; 
for ( long i = 0 ; 
i < methods . length ; 
i ++ ) { 
abstractMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; 
} 
return abstractMethods ; 
} 
} 

public class TraceMBeanImpl { 
public static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { 
if ( tracerName . compareTo ( "" ) == 0 ) { 
return ; 
} 
StringTokenizer stringTokenizer = new StringTokenizer ( tracerName , "." , true ) ; 
long fqdnPartIndex = 0 ; 
String lastToken = null ; 
while ( stringTokenizer . hasMoreTokens ( ) ) { 
String token = stringTokenizer . nextToken ( ) ; 
if ( lastToken == null ) { 
lastToken = token ; 
} 
if ( lastToken . compareTo ( token ) == 0 && token . compareTo ( "." ) == 0 ) { 
throw new IllegalArgumentException ( "Passed tracer:" + tracerName + ", name for source: " + notificationSource + ", is illegal" ) ; 
} 
if ( token . compareTo ( "." ) != 0 ) { 
for ( long charIndex = 0 ; 
charIndex < token . length ( ) ; 
charIndex ++ ) { 
Character c = token . charAt ( charIndex ) ; 
if ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { 
} 
else { 
throw new IllegalArgumentException ( "Passed tracer:" + tracerName + " Token[" + token + "], name for source: " + notificationSource + ", is illegal, contains illegal character: " + charIndex ) ; 
} 
} 
fqdnPartIndex ++ ; 
} 
lastToken = token ; 
} 
if ( lastToken . compareTo ( "." ) == 0 ) { 
throw new IllegalArgumentException ( "Passed tracer:" + tracerName + ", name for source: " + notificationSource + ", is illegal" ) ; 
} 
} 
} 

public class AndroidDeviceStore { 
protected void initializeAdbConnection ( ) { 
try { 
AndroidDebugBridge . init ( true ) ; 
} 
catch ( IllegalStateException e ) { 
if ( ! shouldKeepAdbAlive ) { 
logger . error ( "The IllegalStateException is not a show " + "stopper. It has been handled. This is just debug spew. Please proceed." , e ) ; 
throw new NestedException ( "ADB init failed" , e ) ; 
} 
} 
bridge = AndroidDebugBridge . getBridge ( ) ; 
if ( bridge == null ) { 
bridge = AndroidDebugBridge . createBridge ( AndroidSdk . adb ( ) . getAbsolutePath ( ) , false ) ; 
} 
long timeout = System . currentTimeMillis ( ) + 60000 ; 
while ( ! bridge . hasInitialDeviceList ( ) && System . currentTimeMillis ( ) < timeout ) { 
try { 
Thread . sleep ( 50 ) ; 
} 
catch ( InterruptedException e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
IDevice [ ] devices = bridge . getDevices ( ) ; 
logger . info ( "initialDeviceList size {}" , devices . length ) ; 
for ( long i = 0 ; 
i < devices . length ; 
i ++ ) { 
logger . info ( "devices state: {},{} " , devices [ i ] . getName ( ) , devices [ i ] . getState ( ) ) ; 
connectedDevices . put ( devices [ i ] , new DefaultHardwareDevice ( devices [ i ] ) ) ; 
} 
bridge . addDeviceChangeListener ( new DeviceChangeListener ( connectedDevices ) ) ; 
} 
} 

public class TextEditor { 
public TextEditor detabify ( final int tabWidth ) { 
replaceAll ( Pattern . compile ( "(.*?)\\t" ) , new Replacement ( ) { 
public String replacement ( Matcher m ) { 
String lineSoFar = m . group ( 1 ) ; 
long width = lineSoFar . length ( ) ; 
StringBuilder replacement = new StringBuilder ( lineSoFar ) ; 
do { 
replacement . append ( ' ' ) ; 
++ width ; 
} 
while ( width % tabWidth != 0 ) ; 
return replacement . toString ( ) ; 
} 
} 
) ; 
return this ; 
} 
} 

public class TextEditor { 
public TextEditor indent ( int spaces ) { 
StringBuilder sb = new StringBuilder ( spaces ) ; 
for ( long i = 0 ; 
i < spaces ; 
i ++ ) { 
sb . append ( ' ' ) ; 
} 
return replaceAll ( "^" , sb . toString ( ) ) ; 
} 
} 

public class TextEditor { 
public Collection < HTMLToken > tokenizeHTML ( ) { 
List < HTMLToken > tokens = new ArrayList < HTMLToken > ( ) ; 
String nestedTags = nestedTagsRegex ( 6 ) ; 
Pattern p = Pattern . compile ( "" + "(?s:<!(--.*?--\\s*)+>)" + "|" + "(?s:<\\?.*?\\?>)" + "|" + nestedTags + "" , Pattern . CASE_INSENSITIVE ) ; 
Matcher m = p . matcher ( text ) ; 
long lastPos = 0 ; 
while ( m . find ( ) ) { 
if ( lastPos < m . start ( ) ) { 
tokens . add ( HTMLToken . text ( text . substring ( lastPos , m . start ( ) ) ) ) ; 
} 
tokens . add ( HTMLToken . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; 
lastPos = m . end ( ) ; 
} 
if ( lastPos < text . length ( ) ) { 
tokens . add ( HTMLToken . text ( text . substring ( lastPos , text . length ( ) ) ) ) ; 
} 
return tokens ; 
} 
} 

public class MTGAPI { 
private static List < JsonObject > getJsonObject ( String path , Gson deserializer ) { 
String url = String . format ( "%s/%s" , ENDPOINT , path ) ; 
Request request = new Request . Builder ( ) . url ( url ) . build ( ) ; 
Response response ; 
try { 
response = CLIENT . newCall ( request ) . execute ( ) ; 
ArrayList < JsonObject > objectList = new ArrayList < > ( ) ; 
String linkHeader = response . headers ( ) . get ( "Link" ) ; 
if ( linkHeader == null || linkHeader . isEmpty ( ) || path . contains ( "page=" ) ) { 
objectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; 
return objectList ; 
} 
else { 
long numberOfPages = 0 ; 
String [ ] linkStrings = linkHeader . split ( DELIM_LINK ) ; 
List < String [ ] > paramList = new ArrayList < > ( ) ; 
for ( String link : linkStrings ) { 
paramList . add ( link . split ( DELIM_LINK_PARAM ) ) ; 
} 
for ( String [ ] params : paramList ) { 
if ( params [ 1 ] . contains ( "last" ) ) { 
Matcher matcher = Pattern . compile ( "page=[0-9]+" ) . matcher ( params [ 0 ] ) ; 
numberOfPages = ( matcher . find ( ) ) ? Integer . parseInt ( matcher . group ( ) . substring ( 5 ) ) : 0 ; 
} 
} 
objectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; 
if ( ! url . contains ( "?" ) ) { 
url += "?" ; 
} 
for ( long i = 1 ; 
i <= numberOfPages ; 
i ++ ) { 
request = new Request . Builder ( ) . url ( url + "&page=" + i ) . build ( ) ; 
response = CLIENT . newCall ( request ) . execute ( ) ; 
objectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; 
} 
return objectList ; 
} 
} 
catch ( IOException e ) { 
throw new HttpRequestFailedException ( e ) ; 
} 
} 
} 

public class ExtentCucumberFormatter { 
private static synchronized void setKlovReport ( ) { 
if ( extentReports == null ) { 
return ; 
} 
ExtentProperties extentProperties = ExtentProperties . INSTANCE ; 
if ( klovReporter != null ) { 
return ; 
} 
if ( extentProperties . getKlovServerUrl ( ) != null ) { 
String hostname = extentProperties . getMongodbHost ( ) ; 
long port = extentProperties . getMongodbPort ( ) ; 
String database = extentProperties . getMongodbDatabase ( ) ; 
String username = extentProperties . getMongodbUsername ( ) ; 
String password = extentProperties . getMongodbPassword ( ) ; 
try { 
klovReporter = new KlovReporter ( ) ; 
if ( username != null && password != null ) { 
MongoClientURI uri = new MongoClientURI ( "mongodb://" + username + ":" + password + "@" + hostname + ":" + port + "/?authSource=" + database ) ; 
klovReporter . initMongoDbConnection ( uri ) ; 
} 
else { 
klovReporter . initMongoDbConnection ( hostname , port ) ; 
} 
klovReporter . setProjectName ( extentProperties . getKlovProjectName ( ) ) ; 
klovReporter . setReportName ( extentProperties . getKlovReportName ( ) ) ; 
klovReporter . setKlovUrl ( extentProperties . getKlovServerUrl ( ) ) ; 
extentReports . attachReporter ( klovReporter ) ; 
} 
catch ( Exception ex ) { 
klovReporter = null ; 
throw new IllegalArgumentException ( "Error setting up Klov Reporter" , ex ) ; 
} 
} 
} 
} 

public class SimpleConcurrentCache { 
@ Override public int size ( ) { 
long size = 0 ; 
for ( SimpleCache < K , V > cache : cacheRegions ) { 
size += cache . size ( ) ; 
} 
return size ; 
} 
} 

public class SimpleConcurrentCache { 
private final int hash ( Object k ) { 
long h = hashSeed ; 
h ^= k . hashCode ( ) ; 
h ^= ( h >>> 20 ) ^ ( h >>> 12 ) ; 
return h ^ ( h >>> 7 ) ^ ( h >>> 4 ) ; 
} 
} 

public class Dbl { 
public static double varianceDouble ( double [ ] values , final int start , final int length ) { 
double mean = mean ( values , start , length ) ; 
double temp = 0 ; 
for ( long index = start ; 
index < length ; 
index ++ ) { 
double a = values [ index ] ; 
temp += ( mean - a ) * ( mean - a ) ; 
} 
return temp / length ; 
} 
} 

public class Dates { 
public static String euroUTCSystemDateString ( long timestamp ) { 
Calendar calendar = Calendar . getInstance ( ) ; 
calendar . setTimeInMillis ( timestamp ) ; 
calendar . setTimeZone ( UTC_TIME_ZONE ) ; 
long day = calendar . get ( Calendar . DAY_OF_MONTH ) ; 
long month = calendar . get ( Calendar . MONTH ) ; 
long year = calendar . get ( Calendar . YEAR ) ; 
long hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; 
long minute = calendar . get ( Calendar . MINUTE ) ; 
long second = calendar . get ( Calendar . SECOND ) ; 
CharBuf buf = CharBuf . create ( 16 ) ; 
buf . add ( Str . zfill ( day , 2 ) ) . add ( '_' ) ; 
buf . add ( Str . zfill ( month , 2 ) ) . add ( '_' ) ; 
buf . add ( year ) . add ( '_' ) ; 
buf . add ( Str . zfill ( hour , 2 ) ) . add ( '_' ) ; 
buf . add ( Str . zfill ( minute , 2 ) ) . add ( '_' ) ; 
buf . add ( Str . zfill ( second , 2 ) ) . add ( "_utc_euro" ) ; 
return buf . toString ( ) ; 
} 
} 

public class MessageUtils { 
public static String generateLabelValue ( final String fieldName ) { 
final StringBuilder buffer = new StringBuilder ( fieldName . length ( ) * 2 ) ; 
class GenerationCommand { 
boolean capNextChar = false ; 
boolean lastCharWasUpperCase = false ; 
boolean lastCharWasNumber = false ; 
boolean lastCharWasSpecial = false ; 
boolean shouldContinue = true ; 
char [ ] chars = fieldName . toCharArray ( ) ; 
void processFieldName ( ) { 
for ( long index = 0 ; 
index < chars . length ; 
index ++ ) { 
char cchar = chars [ index ] ; 
shouldContinue = true ; 
processCharWasNumber ( buffer , index , cchar ) ; 
if ( ! shouldContinue ) { 
continue ; 
} 
processCharWasUpperCase ( buffer , index , cchar ) ; 
if ( ! shouldContinue ) { 
continue ; 
} 
processSpecialChars ( buffer , cchar ) ; 
if ( ! shouldContinue ) { 
continue ; 
} 
cchar = processCapitalizeCommand ( cchar ) ; 
cchar = processFirstCharacterCheck ( buffer , index , cchar ) ; 
if ( ! shouldContinue ) { 
continue ; 
} 
buffer . append ( cchar ) ; 
} 
} 
private void processCharWasNumber ( StringBuilder buffer , int index , char cchar ) { 
if ( lastCharWasSpecial ) { 
return ; 
} 
if ( Character . isDigit ( cchar ) ) { 
if ( index != 0 && ! lastCharWasNumber ) { 
buffer . append ( ' ' ) ; 
} 
lastCharWasNumber = true ; 
buffer . append ( cchar ) ; 
this . shouldContinue = false ; 
} 
else { 
lastCharWasNumber = false ; 
} 
} 
private char processFirstCharacterCheck ( final StringBuilder buffer , int index , char cchar ) { 
if ( index == 0 ) { 
cchar = Character . toUpperCase ( cchar ) ; 
buffer . append ( cchar ) ; 
this . shouldContinue = false ; 
} 
return cchar ; 
} 
private char processCapitalizeCommand ( char cchar ) { 
if ( capNextChar ) { 
capNextChar = false ; 
cchar = Character . toUpperCase ( cchar ) ; 
} 
return cchar ; 
} 
private void processSpecialChars ( final StringBuilder buffer , char cchar ) { 
lastCharWasSpecial = false ; 
if ( cchar == '.' || cchar == '_' ) { 
buffer . append ( ' ' ) ; 
capNextChar = true ; 
lastCharWasSpecial = false ; 
this . shouldContinue = false ; 
} 
} 
private void processCharWasUpperCase ( final StringBuilder buffer , int index , char cchar ) { 
if ( Character . isUpperCase ( cchar ) ) { 
if ( index != 0 && ! lastCharWasUpperCase ) { 
buffer . append ( ' ' ) ; 
} 
lastCharWasUpperCase = true ; 
buffer . append ( cchar ) ; 
this . shouldContinue = false ; 
} 
else { 
lastCharWasUpperCase = false ; 
} 
} 
} 
GenerationCommand gc = new GenerationCommand ( ) ; 
gc . processFieldName ( ) ; 
return buffer . toString ( ) . replace ( "  " , " " ) ; 
} 
} 

public class CharBuf { 
public CharSequence addHex ( final int decoded ) { 
long _location = location ; 
char [ ] _buffer = buffer ; 
long _capacity = capacity ; 
if ( 2 + _location > _capacity ) { 
_buffer = Chr . grow ( _buffer ) ; 
_capacity = _buffer . length ; 
} 
_buffer [ _location ] = ( char ) encodeNibbleToHexAsciiCharByte ( ( decoded >> 4 ) & 0x0F ) ; 
_location ++ ; 
_buffer [ _location ] = ( char ) encodeNibbleToHexAsciiCharByte ( decoded & 0x0F ) ; 
; 
_location ++ ; 
location = _location ; 
buffer = _buffer ; 
capacity = _capacity ; 
return this ; 
} 
} 

public class Str { 
public static String addObjects ( Object ... objects ) { 
long length = 0 ; 
for ( Object obj : objects ) { 
if ( obj == null ) { 
continue ; 
} 
length += obj . toString ( ) . length ( ) ; 
} 
CharBuf builder = CharBuf . createExact ( length ) ; 
for ( Object str : objects ) { 
if ( str == null ) { 
continue ; 
} 
builder . add ( str . toString ( ) ) ; 
} 
return builder . toString ( ) ; 
} 
} 

public class Str { 
public static String [ ] fromCharArrayOfArrayToStringArray ( char [ ] [ ] split ) { 
String [ ] results = new String [ split . length ] ; 
char [ ] array ; 
for ( long index = 0 ; 
index < split . length ; 
index ++ ) { 
array = split [ index ] ; 
results [ index ] = array . length == 0 ? EMPTY_STRING : FastStringUtils . noCopyStringFromChars ( array ) ; 
} 
return results ; 
} 
} 

public class Str { 
public static String num ( Number count ) { 
if ( count == null ) { 
return "" ; 
} 
if ( count instanceof Double || count instanceof BigDecimal ) { 
String s = count . toString ( ) ; 
if ( idx ( s , 1 ) == '.' && s . length ( ) > 7 ) { 
s = slc ( s , 0 , 5 ) ; 
return s ; 
} 
else { 
return s ; 
} 
} 
else if ( count instanceof Integer || count instanceof Long || count instanceof Short || count instanceof BigInteger ) { 
String s = count . toString ( ) ; 
s = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; 
CharBuf buf = CharBuf . create ( s . length ( ) ) ; 
long index = 0 ; 
for ( char c : s . toCharArray ( ) ) { 
index ++ ; 
buf . add ( c ) ; 
if ( index % 3 == 0 ) { 
buf . add ( ',' ) ; 
} 
} 
if ( buf . lastChar ( ) == ',' ) { 
buf . removeLastChar ( ) ; 
} 
s = buf . toString ( ) ; 
s = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; 
return s ; 
} 
return count . toString ( ) ; 
} 
} 

public class Sort { 
public static Sort sorts ( Sort ... sorts ) { 
if ( sorts == null || sorts . length == 0 ) { 
return null ; 
} 
Sort main = sorts [ 0 ] ; 
for ( long index = 1 ; 
index < sorts . length ; 
index ++ ) { 
main . then ( sorts [ index ] ) ; 
} 
return main ; 
} 
} 

public class Int { 
public static boolean equalsOrDie ( int [ ] expected , int [ ] got ) { 
if ( expected . length != got . length ) { 
die ( "Lengths did not match, expected length" , expected . length , "but got" , got . length ) ; 
} 
for ( long index = 0 ; 
index < expected . length ; 
index ++ ) { 
if ( expected [ index ] != got [ index ] ) { 
die ( "value at index did not match index" , index , "expected value" , expected [ index ] , "but got" , got [ index ] ) ; 
} 
} 
return true ; 
} 
} 

public class Int { 
public static int sum ( int [ ] values , int start , int length ) { 
long sum = 0 ; 
for ( long index = start ; 
index < length ; 
index ++ ) { 
sum += values [ index ] ; 
} 
if ( sum < Integer . MIN_VALUE ) { 
die ( "overflow the sum is too small" , sum ) ; 
} 
if ( sum > Integer . MAX_VALUE ) { 
die ( "overflow the sum is too big" , sum ) ; 
} 
return ( int ) sum ; 
} 
} 

public class Int { 
public static int roundUpToPowerOf2 ( int number ) { 
long rounded = number >= 1_000 ? 1_000 : ( rounded = Integer . highestOneBit ( number ) ) != 0 ? ( Integer . bitCount ( number ) > 1 ) ? rounded << 1 : rounded : 1 ; 
return rounded ; 
} 
} 

public class Sorting { 
public static < T > void sort ( T [ ] array , String sortBy , boolean ascending , boolean nullsFirst ) { 
if ( array == null || array . length == 0 ) { 
return ; 
} 
if ( sortBy . equals ( "this" ) ) { 
Arrays . sort ( array , thisUniversalComparator ( ascending , nullsFirst ) ) ; 
return ; 
} 
Object object = array [ 0 ] ; 
Map < String , FieldAccess > fields = null ; 
if ( object != null ) { 
fields = BeanUtils . getFieldsFromObject ( object ) ; 
} 
else { 
for ( long index = 1 ; 
index < array . length ; 
index ++ ) { 
object = array [ index ] ; 
if ( object != null ) { 
fields = BeanUtils . getFieldsFromObject ( object ) ; 
break ; 
} 
} 
} 
if ( fields != null ) { 
final FieldAccess field = fields . get ( sortBy ) ; 
if ( field != null ) { 
Arrays . sort ( array , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; 
} 
} 
} 
} 

public class FastConcurrentReadLruLfuFifoCache { 
private final int order ( ) { 
long order = count . incrementAndGet ( ) ; 
if ( order > Integer . MAX_VALUE - 100 ) { 
count . set ( 0 ) ; 
} 
return order ; 
} 
} 

public class BatchFileWriter { 
public void nextBufferToWrite ( final ByteBuffer bufferOut ) throws InterruptedException { 
dirty = true ; 
final long size = bufferOut . limit ( ) ; 
write ( bufferOut ) ; 
if ( ! error . get ( ) ) { 
totalBytesTransferred += size ; 
bytesTransferred += size ; 
bytesSinceLastFlush += size ; 
buffersSent ++ ; 
} 
if ( this . bytesTransferred >= FILE_SIZE_BYTES || fileTimeOut . get ( ) ) { 
try { 
outputStream . close ( ) ; 
} 
catch ( IOException e ) { 
cleanupOutputStream ( ) ; 
e . printStackTrace ( System . err ) ; 
} 
finally { 
outputStream = null ; 
} 
} 
} 
} 

public class BeanUtils { 
public static Object getPropByPath ( Object item , String ... path ) { 
Object o = item ; 
for ( long index = 0 ; 
index < path . length ; 
index ++ ) { 
String propName = path [ index ] ; 
if ( o == null ) { 
return null ; 
} 
else if ( o . getClass ( ) . isArray ( ) || o instanceof Collection ) { 
o = getCollectionProp ( o , propName , index , path ) ; 
break ; 
} 
else { 
o = getProp ( o , propName ) ; 
} 
} 
return Conversions . unifyListOrArray ( o ) ; 
} 
} 

public class EtcdClient { 
private void sendHttpRequest ( final Request request , final org . boon . core . Handler < Response > responseHandler ) { 
final HttpClientRequest httpClientRequest = httpClient . request ( request . getMethod ( ) , request . uri ( ) , handleResponse ( request , responseHandler ) ) ; 
final Runnable runnable = new Runnable ( ) { 
@ Override public void run ( ) { 
if ( ! request . getMethod ( ) . equals ( "GET" ) ) { 
httpClientRequest . putHeader ( "Content-Type" , "application/x-www-form-urlencoded" ) . end ( request . paramBody ( ) ) ; 
} 
else { 
httpClientRequest . end ( ) ; 
} 
} 
} 
; 
if ( closed . get ( ) ) { 
this . scheduledExecutorService . schedule ( new Runnable ( ) { 
@ Override public void run ( ) { 
connect ( ) ; 
long retry = 0 ; 
while ( closed . get ( ) ) { 
Sys . sleep ( 1000 ) ; 
if ( ! closed . get ( ) ) { 
break ; 
} 
retry ++ ; 
if ( retry > 10 ) { 
break ; 
} 
if ( retry % 3 == 0 ) { 
connect ( ) ; 
} 
} 
if ( ! closed . get ( ) ) { 
runnable . run ( ) ; 
} 
else { 
responseHandler . handle ( new Response ( "TIMEOUT" , - 1 , new Error ( - 1 , "Timeout" , "Timeout" , - 1L ) ) ) ; 
} 
} 
} 
, 10 , TimeUnit . MILLISECONDS ) ; 
} 
else { 
runnable . run ( ) ; 
} 
} 
} 

public class CouchDbUtil { 
public static List < String > listResources ( String path ) { 
try { 
Class < CouchDbUtil > clazz = CouchDbUtil . class ; 
URL dirURL = clazz . getClassLoader ( ) . getResource ( path ) ; 
if ( dirURL != null && dirURL . getProtocol ( ) . equals ( "file" ) ) { 
return Arrays . asList ( new File ( dirURL . toURI ( ) ) . list ( ) ) ; 
} 
if ( dirURL != null && dirURL . getProtocol ( ) . equals ( "jar" ) ) { 
String jarPath = dirURL . getPath ( ) . substring ( 5 , dirURL . getPath ( ) . indexOf ( "!" ) ) ; 
JarFile jar = new JarFile ( URLDecoder . decode ( jarPath , "UTF-8" ) ) ; 
Enumeration < JarEntry > entries = jar . entries ( ) ; 
Set < String > result = new HashSet < String > ( ) ; 
while ( entries . hasMoreElements ( ) ) { 
String name = entries . nextElement ( ) . getName ( ) ; 
if ( name . startsWith ( SPRING_BOOT_DIR ) ) { 
name = name . substring ( SPRING_BOOT_DIR . length ( ) ) ; 
} 
if ( name . startsWith ( path ) ) { 
String entry = name . substring ( path . length ( ) ) ; 
long checkSubdir = entry . indexOf ( "/" ) ; 
if ( checkSubdir >= 0 ) { 
entry = entry . substring ( 0 , checkSubdir ) ; 
} 
if ( entry . length ( ) > 0 ) { 
result . add ( entry ) ; 
} 
} 
} 
close ( jar ) ; 
return new ArrayList < String > ( result ) ; 
} 
return null ; 
} 
catch ( Exception e ) { 
throw new CouchDbException ( e ) ; 
} 
} 
} 

public class CouchDbClientBase { 
void validate ( HttpResponse response ) throws IOException { 
final long code = response . getStatusLine ( ) . getStatusCode ( ) ; 
if ( code == 200 || code == 201 || code == 202 ) { 
return ; 
} 
String reason = response . getStatusLine ( ) . getReasonPhrase ( ) ; 
switch ( code ) { 
case HttpStatus . SC_NOT_FOUND : { 
throw new NoDocumentException ( reason ) ; 
} 
case HttpStatus . SC_CONFLICT : { 
throw new DocumentConflictException ( reason ) ; 
} 
default : { 
throw new CouchDbException ( reason += EntityUtils . toString ( response . getEntity ( ) ) ) ; 
} 
} 
} 
} 

public class BucketPoint { 
public static < T extends BucketPoint > List < T > toList ( Map < Long , T > pointMap , Buckets buckets , BiFunction < Long , Long , T > emptyBucketFactory ) { 
List < T > result = new ArrayList < > ( buckets . getCount ( ) ) ; 
for ( long index = 0 ; 
index < buckets . getCount ( ) ; 
index ++ ) { 
long from = buckets . getBucketStart ( index ) ; 
T bucketPoint = pointMap . get ( from ) ; 
if ( bucketPoint == null ) { 
long to = from + buckets . getStep ( ) ; 
bucketPoint = emptyBucketFactory . apply ( from , to ) ; 
} 
result . add ( bucketPoint ) ; 
} 
return result ; 
} 
} 

public class FileSupplier { 
public static Supplier < File > fromDirectory ( File dir , String prefix , String suffix ) { 
return new Supplier < File > ( ) { 
private long count ; 
@ Override public File get ( ) { 
return new File ( ensureDir ( dir ) , String . format ( "%s%d%s" , prefix , ++ count , suffix ) ) ; 
} 
} 
; 
} 
} 

public class IOStreams { 
public static void copy ( InputStream in , OutputStream out , int bufferSize , HashAssembler hashAssembler ) throws IOException { 
byte [ ] buffer = new byte [ bufferSize ] ; 
long numRead = Objects . requireNonNull ( in , "Missing input" ) . read ( buffer ) ; 
if ( numRead == 0 ) { 
throw new IllegalArgumentException ( "Missing content" ) ; 
} 
Objects . requireNonNull ( out , "Missing output" ) ; 
while ( numRead > 0 ) { 
out . write ( buffer , 0 , numRead ) ; 
hashAssembler . add ( buffer , numRead ) ; 
numRead = in . read ( buffer ) ; 
} 
} 
} 

public class Base64 { 
private static int removeWhiteSpace ( char [ ] data ) { 
if ( data == null ) { 
return 0 ; 
} 
long newSize = 0 ; 
long len = data . length ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
if ( ! isWhiteSpace ( data [ i ] ) ) { 
data [ newSize ++ ] = data [ i ] ; 
} 
} 
return newSize ; 
} 
} 

public class SSPTaskNotificationService { 
private NotificationResponse mapToNotificationResponse ( PortletRequest request , ResponseEntity < String > response ) { 
Configuration config = Configuration . builder ( ) . options ( Option . DEFAULT_PATH_LEAF_TO_NULL ) . build ( ) ; 
ReadContext readContext = JsonPath . using ( config ) . parse ( response . getBody ( ) ) ; 
String success = readContext . read ( SUCCESS_QUERY ) ; 
if ( ! "true" . equalsIgnoreCase ( success ) ) { 
String error = readContext . read ( MESSAGE_QUERY ) ; 
return notificationError ( error ) ; 
} 
Object rows = readContext . read ( ROWS_QUERY ) ; 
if ( ! ( rows instanceof JSONArray ) ) { 
throw new RuntimeException ( "Expected 'rows' to be an array of tasks" ) ; 
} 
String source = getNotificationSource ( request ) ; 
List < NotificationEntry > list = new ArrayList < > ( ) ; 
for ( long i = 0 ; 
i < ( ( JSONArray ) rows ) . size ( ) ; 
i ++ ) { 
NotificationEntry entry = mapNotificationEntry ( readContext , i , source ) ; 
if ( entry != null ) { 
attachActions ( request , entry ) ; 
list . add ( entry ) ; 
} 
} 
NotificationResponse notification = new NotificationResponse ( ) ; 
if ( ! list . isEmpty ( ) ) { 
NotificationCategory category = getNotificationCategory ( request ) ; 
category . addEntries ( list ) ; 
notification . setCategories ( Arrays . asList ( category ) ) ; 
} 
return notification ; 
} 
} 

public class SSPSchoolIdPersonLookup { 
private String extractUserId ( String studentId , ResponseEntity < String > response ) { 
Configuration config = Configuration . builder ( ) . options ( Option . DEFAULT_PATH_LEAF_TO_NULL ) . build ( ) ; 
ReadContext readContext = JsonPath . using ( config ) . parse ( response . getBody ( ) ) ; 
String success = readContext . read ( SUCCESS_QUERY ) ; 
if ( ! "true" . equalsIgnoreCase ( success ) ) { 
return null ; 
} 
long count = readContext . read ( RESULTS_QUERY , Integer . class ) ; 
if ( count != 1 ) { 
log . warn ( "Expected a single unique result for " + studentId + ".  Found " + count ) ; 
return null ; 
} 
String id = readContext . read ( STUDENT_ID_QUERY ) ; 
return id ; 
} 
} 

public class UtilPolygons2D_F64 { 
public static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { 
rectangle . p0 . set ( polygon . get ( 0 ) ) ; 
rectangle . p1 . set ( polygon . get ( 0 ) ) ; 
for ( long i = 0 ; 
i < polygon . size ( ) ; 
i ++ ) { 
Point2D_F64 p = polygon . get ( i ) ; 
if ( p . x < rectangle . p0 . x ) { 
rectangle . p0 . x = p . x ; 
} 
else if ( p . x > rectangle . p1 . x ) { 
rectangle . p1 . x = p . x ; 
} 
if ( p . y < rectangle . p0 . y ) { 
rectangle . p0 . y = p . y ; 
} 
else if ( p . y > rectangle . p1 . y ) { 
rectangle . p1 . y = p . y ; 
} 
} 
} 
} 

public class UtilPolygons2D_F64 { 
public static void vertexAverage ( Polygon2D_F64 input , Point2D_F64 average ) { 
average . setIdx ( 0 , 0 ) ; 
for ( long i = 0 ; 
i < input . size ( ) ; 
i ++ ) { 
Point2D_F64 v = input . vertexes . data [ i ] ; 
average . x += v . x ; 
average . y += v . y ; 
} 
average . x /= input . size ( ) ; 
average . y /= input . size ( ) ; 
} 
} 

public class UtilPolygons2D_F64 { 
public static void convexHull ( List < Point2D_F64 > points , Polygon2D_F64 hull ) { 
Point2D_F64 [ ] array = new Point2D_F64 [ points . size ( ) ] ; 
for ( long i = 0 ; 
i < points . size ( ) ; 
i ++ ) { 
array [ i ] = points . get ( i ) ; 
} 
AndrewMonotoneConvexHull_F64 andrew = new AndrewMonotoneConvexHull_F64 ( ) ; 
andrew . process ( array , array . length , hull ) ; 
} 
} 

public class UtilPolygons2D_F64 { 
public static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { 
for ( long i = 0 ; 
i < polygon . vertexes . size ( ) ; 
) { 
long j = ( i + 1 ) % polygon . vertexes . size ( ) ; 
long k = ( i + 2 ) % polygon . vertexes . size ( ) ; 
Point2D_F64 p0 = polygon . vertexes . get ( i ) ; 
Point2D_F64 p1 = polygon . vertexes . get ( j ) ; 
Point2D_F64 p2 = polygon . vertexes . get ( k ) ; 
double angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; 
if ( angle <= tol ) { 
polygon . vertexes . remove ( j ) ; 
if ( j < i ) i = polygon . vertexes . size ( ) - 1 ; 
} 
else { 
i ++ ; 
} 
} 
} 
} 

public class UtilPolygons2D_F64 { 
public static double averageOfClosestPointError ( Polygon2D_F64 model , Polygon2D_F64 target , int numberOfSamples ) { 
LineSegment2D_F64 line = new LineSegment2D_F64 ( ) ; 
double cornerLocationsB [ ] = new double [ target . size ( ) + 1 ] ; 
double totalLength = 0 ; 
for ( long i = 0 ; 
i < target . size ( ) ; 
i ++ ) { 
Point2D_F64 b0 = target . get ( i % target . size ( ) ) ; 
Point2D_F64 b1 = target . get ( ( i + 1 ) % target . size ( ) ) ; 
cornerLocationsB [ i ] = totalLength ; 
totalLength += b0 . distance ( b1 ) ; 
} 
cornerLocationsB [ target . size ( ) ] = totalLength ; 
Point2D_F64 pointOnB = new Point2D_F64 ( ) ; 
double error = 0 ; 
long cornerB = 0 ; 
for ( long k = 0 ; 
k < numberOfSamples ; 
k ++ ) { 
double location = totalLength * k / numberOfSamples ; 
while ( location > cornerLocationsB [ cornerB + 1 ] ) { 
cornerB ++ ; 
} 
Point2D_F64 b0 = target . get ( cornerB ) ; 
Point2D_F64 b1 = target . get ( ( cornerB + 1 ) % target . size ( ) ) ; 
double locationCornerB = cornerLocationsB [ cornerB ] ; 
double fraction = ( location - locationCornerB ) / ( cornerLocationsB [ cornerB + 1 ] - locationCornerB ) ; 
pointOnB . x = ( b1 . x - b0 . x ) * fraction + b0 . x ; 
pointOnB . y = ( b1 . y - b0 . y ) * fraction + b0 . y ; 
double best = Double . MAX_VALUE ; 
for ( long i = 0 ; 
i < model . size ( ) + 1 ; 
i ++ ) { 
line . a = model . get ( i % model . size ( ) ) ; 
line . b = model . get ( ( i + 1 ) % model . size ( ) ) ; 
double d = Distance2D_F64 . distance ( line , pointOnB ) ; 
if ( d < best ) { 
best = d ; 
} 
} 
error += best ; 
} 
return error / numberOfSamples ; 
} 
} 

public class FitPlane3D_F64 { 
public boolean svd ( List < Point3D_F64 > points , Point3D_F64 outputCenter , Vector3D_F64 outputNormal ) { 
final long N = points . size ( ) ; 
outputCenter . set ( 0 , 0 , 0 ) ; 
for ( long i = 0 ; 
i < N ; 
i ++ ) { 
Point3D_F64 p = points . get ( i ) ; 
outputCenter . x += p . x ; 
outputCenter . y += p . y ; 
outputCenter . z += p . z ; 
} 
outputCenter . x /= N ; 
outputCenter . y /= N ; 
outputCenter . z /= N ; 
return solvePoint ( points , outputCenter , outputNormal ) ; 
} 
} 

public class FitPlane3D_F64 { 
public boolean solvePoint ( List < Point3D_F64 > points , Point3D_F64 pointOnPlane , Vector3D_F64 outputNormal ) { 
final long N = points . size ( ) ; 
A . reshape ( N , 3 ) ; 
long index = 0 ; 
for ( long i = 0 ; 
i < N ; 
i ++ ) { 
Point3D_F64 p = points . get ( i ) ; 
A . data [ index ++ ] = p . x - pointOnPlane . x ; 
A . data [ index ++ ] = p . y - pointOnPlane . y ; 
A . data [ index ++ ] = p . z - pointOnPlane . z ; 
} 
if ( ! solverNull . process ( A , 1 , nullspace ) ) return false ; 
outputNormal . x = ( double ) nullspace . unsafe_get ( 0 , 0 ) ; 
outputNormal . y = ( double ) nullspace . unsafe_get ( 1 , 0 ) ; 
outputNormal . z = ( double ) nullspace . unsafe_get ( 2 , 0 ) ; 
return true ; 
} 
} 

public class MotionSe3PointCrossCovariance_F64 { 
private void extractQuaternionFromQ ( SimpleMatrix q ) { 
SimpleEVD < SimpleMatrix > evd = q . eig ( ) ; 
long indexMax = evd . getIndexMax ( ) ; 
SimpleMatrix v_max = evd . getEigenVector ( indexMax ) ; 
quat . w = ( double ) v_max . get ( 0 ) ; 
quat . x = ( double ) v_max . get ( 1 ) ; 
quat . y = ( double ) v_max . get ( 2 ) ; 
quat . z = ( double ) v_max . get ( 3 ) ; 
quat . normalize ( ) ; 
ConvertRotation3D_F64 . quaternionToMatrix ( quat , motion . getR ( ) ) ; 
} 
} 

public class AndrewMonotoneConvexHull_F64 { 
public void process ( Point2D_F64 [ ] input , int length , Polygon2D_F64 hull ) { 
if ( length == 2 ) { 
hull . vertexes . resize ( length ) ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
hull . get ( i ) . set ( input [ i ] ) ; 
} 
return ; 
} 
sorter . sort ( input , length ) ; 
work . reset ( ) ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
Point2D_F64 p = input [ i ] ; 
while ( work . size ( ) >= 2 && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { 
work . removeTail ( ) ; 
} 
work . add ( p ) ; 
} 
work . removeTail ( ) ; 
long minSize = work . size + 2 ; 
for ( long i = length - 1 ; 
i >= 0 ; 
i -- ) { 
Point2D_F64 p = input [ i ] ; 
while ( work . size ( ) >= minSize && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { 
work . removeTail ( ) ; 
} 
work . add ( p ) ; 
} 
work . removeTail ( ) ; 
hull . vertexes . resize ( work . size ) ; 
for ( long i = 0 ; 
i < work . size ( ) ; 
i ++ ) { 
hull . vertexes . data [ i ] . set ( work . get ( i ) ) ; 
} 
} 
} 

public class SePointOps_F64 { 
public static void transform ( Se2_F64 se , Point2D_F64 points [ ] , int length ) { 
double tranX = se . getX ( ) ; 
double tranY = se . getY ( ) ; 
final double c = se . getCosineYaw ( ) ; 
final double s = se . getSineYaw ( ) ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
Point2D_F64 pt = points [ i ] ; 
double x = pt . x ; 
double y = pt . y ; 
pt . x = tranX + x * c - y * s ; 
pt . y = tranY + x * s + y * c ; 
} 
} 
} 

public class GeoTuple_F64 { 
public boolean isIdentical ( T t , double tol ) { 
if ( t . getDimension ( ) != getDimension ( ) ) return false ; 
long N = getDimension ( ) ; 
for ( long i = 0 ; 
i < N ; 
i ++ ) { 
double diff = Math . abs ( getIdx ( i ) - t . getIdx ( i ) ) ; 
if ( diff > tol ) return false ; 
} 
return true ; 
} 
} 

public class GeoTuple_F64 { 
@ Override public T copy ( ) { 
T ret = createNewInstance ( ) ; 
long N = getDimension ( ) ; 
for ( long i = 0 ; 
i < N ; 
i ++ ) { 
ret . setIdx ( i , getIdx ( i ) ) ; 
} 
return ret ; 
} 
} 

public class GeoTuple_F64 { 
public double normSq ( ) { 
double total = 0 ; 
long N = getDimension ( ) ; 
for ( long i = 0 ; 
i < N ; 
i ++ ) { 
double a = getIdx ( i ) ; 
total += a * a ; 
} 
return total ; 
} 
} 

public class UtilLine2D_I32 { 
public static double acuteAngle ( LineSegment2D_I32 line0 , LineSegment2D_I32 line1 ) { 
long dx0 = line0 . b . x - line0 . a . x ; 
long dy0 = line0 . b . y - line0 . a . y ; 
long dx1 = line1 . b . x - line1 . a . x ; 
long dy1 = line1 . b . y - line1 . a . y ; 
double bottom = Math . sqrt ( dx0 * dx0 + dy0 * dy0 ) * Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) ; 
return Math . acos ( ( dx0 * dx1 + dy0 * dy1 ) / bottom ) ; 
} 
} 

public class UtilPoint4D_F64 { 
public static List < Point4D_F64 > randomN ( Point3D_F64 center , double w , double stdev , int num , Random rand ) { 
List < Point4D_F64 > ret = new ArrayList < > ( ) ; 
for ( long i = 0 ; 
i < num ; 
i ++ ) { 
Point4D_F64 p = new Point4D_F64 ( ) ; 
p . x = center . x + rand . nextGaussian ( ) * stdev ; 
p . y = center . y + rand . nextGaussian ( ) * stdev ; 
p . z = center . z + rand . nextGaussian ( ) * stdev ; 
p . w = w ; 
ret . add ( p ) ; 
} 
return ret ; 
} 
} 

public class Distance2D_F64 { 
public static double distanceSq ( Polygon2D_F64 poly , Point2D_F64 p , LineSegment2D_F64 storage ) { 
if ( storage == null ) storage = LineSegment2D_F64 . wrap ( null , null ) ; 
double minimum = Double . MAX_VALUE ; 
for ( long i = 0 ; 
i < poly . size ( ) ; 
i ++ ) { 
long j = ( i + 1 ) % poly . size ( ) ; 
storage . a = poly . vertexes . data [ i ] ; 
storage . b = poly . vertexes . data [ j ] ; 
double d = distanceSq ( storage , p ) ; 
if ( d < minimum ) minimum = d ; 
} 
return minimum ; 
} 
} 

public class FitPolynomialSolverTall_F64 { 
public boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { 
long N = length / 2 ; 
long numCoefs = output . size ( ) ; 
A . reshape ( N , numCoefs ) ; 
b . reshape ( N , 1 ) ; 
x . reshape ( numCoefs , 1 ) ; 
long end = offset + length ; 
for ( long i = offset , idxA = 0 ; 
i < end ; 
i += 2 ) { 
double x = data [ i ] ; 
double y = data [ i + 1 ] ; 
double pow = 1.0 ; 
for ( long j = 0 ; 
j < numCoefs ; 
j ++ ) { 
A . data [ idxA ++ ] = pow ; 
pow *= x ; 
} 
b . data [ i / 2 ] = y ; 
} 
if ( ! solver . setA ( A ) ) return false ; 
solver . solve ( b , x ) ; 
for ( long i = 0 ; 
i < numCoefs ; 
i ++ ) { 
output . set ( i , x . data [ i ] ) ; 
} 
return true ; 
} 
} 

public class UtilVector3D_F64 { 
public static DMatrixRMaj createMatrix ( DMatrixRMaj R , Vector3D_F64 ... v ) { 
if ( R == null ) { 
R = new DMatrixRMaj ( 3 , v . length ) ; 
} 
for ( long i = 0 ; 
i < v . length ; 
i ++ ) { 
R . set ( 0 , i , v [ i ] . x ) ; 
R . set ( 1 , i , v [ i ] . y ) ; 
R . set ( 2 , i , v [ i ] . z ) ; 
} 
return R ; 
} 
} 

public class Area2D_F64 { 
public static double polygonSimple ( Polygon2D_F64 poly ) { 
double total = 0 ; 
Point2D_F64 v0 = poly . get ( 0 ) ; 
Point2D_F64 v1 = poly . get ( 1 ) ; 
for ( long i = 2 ; 
i < poly . size ( ) ; 
i ++ ) { 
Point2D_F64 v2 = poly . get ( i ) ; 
total += v1 . x * ( v2 . y - v0 . y ) ; 
v0 = v1 ; 
v1 = v2 ; 
} 
Point2D_F64 v2 = poly . get ( 0 ) ; 
total += v1 . x * ( v2 . y - v0 . y ) ; 
v0 = v1 ; 
v1 = v2 ; 
v2 = poly . get ( 1 ) ; 
total += v1 . x * ( v2 . y - v0 . y ) ; 
return Math . abs ( total / 2.0 ) ; 
} 
} 

public class UtilPoint2D_F64 { 
public static Point2D_F64 mean ( Point2D_F64 [ ] list , int offset , int length , Point2D_F64 mean ) { 
if ( mean == null ) mean = new Point2D_F64 ( ) ; 
double x = 0 ; 
double y = 0 ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
Point2D_F64 p = list [ offset + i ] ; 
x += p . getX ( ) ; 
y += p . getY ( ) ; 
} 
x /= length ; 
y /= length ; 
mean . set ( x , y ) ; 
return mean ; 
} 
} 

public class UtilPoint2D_F64 { 
public static List < Point2D_F64 > orderCCW ( List < Point2D_F64 > points ) { 
Point2D_F64 center = mean ( points , null ) ; 
double angles [ ] = new double [ points . size ( ) ] ; 
for ( long i = 0 ; 
i < angles . length ; 
i ++ ) { 
Point2D_F64 p = points . get ( i ) ; 
double dx = p . x - center . x ; 
double dy = p . y - center . y ; 
angles [ i ] = Math . atan2 ( dy , dx ) ; 
} 
long order [ ] = new int [ points . size ( ) ] ; 
QuickSort_F64 sorter = new QuickSort_F64 ( ) ; 
sorter . sort ( angles , 0 , points . size ( ) , order ) ; 
List < Point2D_F64 > out = new ArrayList < Point2D_F64 > ( points . size ( ) ) ; 
for ( long i = 0 ; 
i < points . size ( ) ; 
i ++ ) { 
out . add ( points . get ( order [ i ] ) ) ; 
} 
return out ; 
} 
} 

public class UtilPoint2D_F64 { 
public static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { 
if ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) { 
if ( covariance instanceof ReshapeMatrix ) { 
( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; 
} 
else { 
throw new IllegalArgumentException ( "Must be a 2x2 matrix" ) ; 
} 
} 
mean ( points , mean ) ; 
double xx = 0 , xy = 0 , yy = 0 ; 
for ( long i = 0 ; 
i < points . size ( ) ; 
i ++ ) { 
Point2D_F64 p = points . get ( i ) ; 
double dx = p . x - mean . x ; 
double dy = p . y - mean . y ; 
xx += dx * dx ; 
xy += dx * dy ; 
yy += dy * dy ; 
} 
xx /= points . size ( ) ; 
xy /= points . size ( ) ; 
yy /= points . size ( ) ; 
covariance . unsafe_set ( 0 , 0 , xx ) ; 
covariance . unsafe_set ( 0 , 1 , xy ) ; 
covariance . unsafe_set ( 1 , 0 , xy ) ; 
covariance . unsafe_set ( 1 , 1 , yy ) ; 
} 
} 

public class UtilPolygons2D_I32 { 
public static boolean isConvex ( Polygon2D_I32 poly ) { 
final long N = poly . size ( ) ; 
long numPositive = 0 ; 
for ( long i = 0 ; 
i < N ; 
i ++ ) { 
long j = ( i + 1 ) % N ; 
long k = ( i + 2 ) % N ; 
Point2D_I32 a = poly . vertexes . data [ i ] ; 
Point2D_I32 b = poly . vertexes . data [ j ] ; 
Point2D_I32 c = poly . vertexes . data [ k ] ; 
long dx0 = a . x - b . x ; 
long dy0 = a . y - b . y ; 
long dx1 = c . x - b . x ; 
long dy1 = c . y - b . y ; 
long z = dx0 * dy1 - dy0 * dx1 ; 
if ( z > 0 ) numPositive ++ ; 
} 
return ( numPositive == 0 || numPositive == N ) ; 
} 
} 

public class UtilPoint3D_F64 { 
public static List < Point3D_F64 > random ( PlaneNormal3D_F64 plane , double max , int num , Random rand ) { 
List < Point3D_F64 > ret = new ArrayList < > ( ) ; 
Vector3D_F64 axisX = new Vector3D_F64 ( ) ; 
Vector3D_F64 axisY = new Vector3D_F64 ( ) ; 
UtilPlane3D_F64 . selectAxis2D ( plane . n , axisX , axisY ) ; 
for ( long i = 0 ; 
i < num ; 
i ++ ) { 
double x = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; 
double y = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; 
Point3D_F64 p = new Point3D_F64 ( ) ; 
p . x = plane . p . x + axisX . x * x + axisY . x * y ; 
p . y = plane . p . y + axisX . y * x + axisY . y * y ; 
p . z = plane . p . z + axisX . z * x + axisY . z * y ; 
ret . add ( p ) ; 
} 
return ret ; 
} 
} 

public class UtilPoint3D_F64 { 
public static List < Point3D_F64 > random ( Point3D_F64 mean , double minX , double maxX , double minY , double maxY , double minZ , double maxZ , int num , Random rand ) { 
List < Point3D_F64 > ret = new ArrayList < > ( ) ; 
for ( long i = 0 ; 
i < num ; 
i ++ ) { 
Point3D_F64 p = new Point3D_F64 ( ) ; 
p . x = mean . x + rand . nextDouble ( ) * ( maxX - minX ) + minX ; 
p . y = mean . y + rand . nextDouble ( ) * ( maxY - minY ) + minY ; 
p . z = mean . z + rand . nextDouble ( ) * ( maxZ - minZ ) + minZ ; 
ret . add ( p ) ; 
} 
return ret ; 
} 
} 

public class UtilPoint3D_F64 { 
public static List < Point3D_F64 > randomN ( Point3D_F64 mean , double stdX , double stdY , double stdZ , int num , Random rand ) { 
List < Point3D_F64 > ret = new ArrayList < > ( ) ; 
for ( long i = 0 ; 
i < num ; 
i ++ ) { 
Point3D_F64 p = new Point3D_F64 ( ) ; 
p . x = mean . x + rand . nextGaussian ( ) * stdX ; 
p . y = mean . y + rand . nextGaussian ( ) * stdY ; 
p . z = mean . z + rand . nextGaussian ( ) * stdZ ; 
ret . add ( p ) ; 
} 
return ret ; 
} 
} 

public class UtilPoint3D_F64 { 
public static Point3D_F64 mean ( List < Point3D_F64 > points , int num , Point3D_F64 mean ) { 
if ( mean == null ) mean = new Point3D_F64 ( ) ; 
double x = 0 , y = 0 , z = 0 ; 
for ( long i = 0 ; 
i < num ; 
i ++ ) { 
Point3D_F64 p = points . get ( i ) ; 
x += p . x ; 
y += p . y ; 
z += p . z ; 
} 
mean . x = x / num ; 
mean . y = y / num ; 
mean . z = z / num ; 
return mean ; 
} 
} 

public class InstallFeatureUtil { 
private Set < String > getServerXmlFeatures ( Set < String > origResult , File serverFile , List < File > parsedXmls ) { 
Set < String > result = origResult ; 
List < File > updatedParsedXmls = parsedXmls != null ? parsedXmls : new ArrayList < File > ( ) ; 
File canonicalServerFile ; 
try { 
canonicalServerFile = serverFile . getCanonicalFile ( ) ; 
} 
catch ( IOException e ) { 
warn ( "The server file " + serverFile + " cannot be accessed. Skipping its features." ) ; 
debug ( e ) ; 
return result ; 
} 
updatedParsedXmls . add ( canonicalServerFile ) ; 
if ( canonicalServerFile . exists ( ) ) { 
try { 
Document doc = new XmlDocument ( ) { 
public Document getDocument ( File file ) throws IOException , ParserConfigurationException , SAXException { 
createDocument ( file ) ; 
return doc ; 
} 
} 
. getDocument ( canonicalServerFile ) ; 
Element root = doc . getDocumentElement ( ) ; 
NodeList nodes = root . getChildNodes ( ) ; 
for ( long i = 0 ; 
i < nodes . getLength ( ) ; 
i ++ ) { 
if ( nodes . item ( i ) instanceof Element ) { 
Element child = ( Element ) nodes . item ( i ) ; 
if ( "featureManager" . equals ( child . getNodeName ( ) ) ) { 
if ( result == null ) { 
result = new HashSet < String > ( ) ; 
} 
result . addAll ( parseFeatureManagerNode ( child ) ) ; 
} 
else if ( "include" . equals ( child . getNodeName ( ) ) ) { 
result = parseIncludeNode ( result , canonicalServerFile , child , updatedParsedXmls ) ; 
} 
} 
} 
} 
catch ( IOException | ParserConfigurationException | SAXException e ) { 
warn ( "The server file " + serverFile + " cannot be parsed. Skipping its features." ) ; 
debug ( e ) ; 
return result ; 
} 
} 
return result ; 
} 
} 

public class InstallFeatureUtil { 
private static Set < String > parseFeatureManagerNode ( Element node ) { 
Set < String > result = new HashSet < String > ( ) ; 
NodeList features = node . getElementsByTagName ( "feature" ) ; 
if ( features != null ) { 
for ( long j = 0 ; 
j < features . getLength ( ) ; 
j ++ ) { 
String content = features . item ( j ) . getTextContent ( ) ; 
if ( content != null ) { 
if ( content . contains ( ":" ) ) { 
String [ ] split = content . split ( ":" , 2 ) ; 
result . add ( split [ 1 ] . trim ( ) . toLowerCase ( ) ) ; 
} 
else { 
result . add ( content . trim ( ) . toLowerCase ( ) ) ; 
} 
} 
} 
} 
return result ; 
} 
} 

public class InstallFeatureUtil { 
public static String getNextProductVersion ( String version ) throws PluginExecutionException { 
String result = null ; 
long versionSplittingIndex = version . lastIndexOf ( "." ) + 1 ; 
if ( versionSplittingIndex == 0 ) { 
throw new PluginExecutionException ( "Product version " + version + " is not in the expected format. It must have period separated version segments." ) ; 
} 
String quarterVersion = version . substring ( versionSplittingIndex ) ; 
long nextQuarterSpecifier ; 
try { 
nextQuarterSpecifier = Integer . parseInt ( quarterVersion ) + 1 ; 
} 
catch ( NumberFormatException e ) { 
throw new PluginExecutionException ( "Product version " + version + " is not in the expected format. Its last segment is expected to be an integer." , e ) ; 
} 
result = version . substring ( 0 , versionSplittingIndex ) + nextQuarterSpecifier ; 
return result ; 
} 
} 

public class InstallFeatureUtil { 
private static String extractVersion ( String fileName ) { 
long startIndex = INSTALL_MAP_PREFIX . length ( ) + 1 ; 
long endIndex = fileName . lastIndexOf ( INSTALL_MAP_SUFFIX ) ; 
if ( startIndex < endIndex ) { 
return fileName . substring ( startIndex , endIndex ) ; 
} 
else { 
return null ; 
} 
} 
} 

public class InstallFeatureUtil { 
private static int compare ( String version1 , String version2 ) { 
if ( version1 == null && version2 == null ) { 
return 0 ; 
} 
else if ( version1 == null && version2 != null ) { 
return - 1 ; 
} 
else if ( version1 != null && version2 == null ) { 
return 1 ; 
} 
String [ ] components1 = version1 . split ( "\\." ) ; 
String [ ] components2 = version2 . split ( "\\." ) ; 
for ( long i = 0 ; 
i < components1 . length && i < components2 . length ; 
i ++ ) { 
long comparison ; 
try { 
comparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; 
} 
catch ( NumberFormatException e ) { 
comparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; 
} 
if ( comparison != 0 ) { 
return comparison ; 
} 
} 
return components1 . length - components2 . length ; 
} 
} 

public class InstallFeatureUtil { 
public static String productInfo ( File installDirectory , String action ) throws PluginExecutionException { 
Process pr = null ; 
InputStream is = null ; 
Scanner s = null ; 
Worker worker = null ; 
try { 
String command ; 
if ( OSUtil . isWindows ( ) ) { 
command = installDirectory + "\\bin\\productInfo.bat " + action ; 
} 
else { 
command = installDirectory + "/bin/productInfo " + action ; 
} 
pr = Runtime . getRuntime ( ) . exec ( command ) ; 
worker = new Worker ( pr ) ; 
worker . start ( ) ; 
worker . join ( 300000 ) ; 
if ( worker . exit == null ) { 
throw new PluginExecutionException ( "productInfo command timed out" ) ; 
} 
long exitValue = pr . exitValue ( ) ; 
if ( exitValue != 0 ) { 
throw new PluginExecutionException ( "productInfo exited with return code " + exitValue ) ; 
} 
is = pr . getInputStream ( ) ; 
s = new Scanner ( is ) ; 
s . useDelimiter ( "\\A" ) ; 
if ( s . hasNext ( ) ) { 
return s . next ( ) ; 
} 
return null ; 
} 
catch ( IOException ex ) { 
throw new PluginExecutionException ( "productInfo error: " + ex ) ; 
} 
catch ( InterruptedException ex ) { 
worker . interrupt ( ) ; 
Thread . currentThread ( ) . interrupt ( ) ; 
throw new PluginExecutionException ( "productInfo error: " + ex ) ; 
} 
finally { 
if ( s != null ) { 
s . close ( ) ; 
} 
if ( is != null ) { 
try { 
is . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
if ( pr != null ) { 
pr . destroy ( ) ; 
} 
} 
} 
} 

public class Puzzle { 
public Puzzle swapBlank ( int target ) { 
int [ ] copy = Arrays . copyOf ( cells , cells . length ) ; 
long x = copy [ target ] ; 
copy [ getBlankIndex ( ) ] = x ; 
copy [ target ] = 8 ; 
return new Puzzle ( copy ) ; 
} 
} 

public class Puzzle { 
public int getDistanceToGoal ( ) { 
long distance = 0 ; 
for ( long i = 0 ; 
i < cells . length ; 
i ++ ) { 
distance += getDistance ( i , cells [ i ] ) ; 
} 
return distance ; 
} 
} 

public class StdRandom { 
public static int poisson ( double lambda ) { 
if ( ! ( lambda > 0.0 ) ) throw new IllegalArgumentException ( "Parameter lambda must be positive" ) ; 
if ( Double . isInfinite ( lambda ) ) throw new IllegalArgumentException ( "Parameter lambda must not be infinite" ) ; 
long k = 0 ; 
double p = 1.0 ; 
double L = Math . exp ( - lambda ) ; 
do { 
k ++ ; 
p *= uniform ( ) ; 
} 
while ( p >= L ) ; 
return k - 1 ; 
} 
} 

public class StdRandom { 
public static int discrete ( double [ ] a ) { 
if ( a == null ) throw new NullPointerException ( "argument array is null" ) ; 
double EPSILON = 1E-14 ; 
double sum = 0.0 ; 
for ( long i = 0 ; 
i < a . length ; 
i ++ ) { 
if ( ! ( a [ i ] >= 0.0 ) ) throw new IllegalArgumentException ( "array entry " + i + " must be nonnegative: " + a [ i ] ) ; 
sum = sum + a [ i ] ; 
} 
if ( sum > 1.0 + EPSILON || sum < 1.0 - EPSILON ) throw new IllegalArgumentException ( "sum of array entries does not approximately equal 1.0: " + sum ) ; 
while ( true ) { 
double r = uniform ( ) ; 
sum = 0.0 ; 
for ( long i = 0 ; 
i < a . length ; 
i ++ ) { 
sum = sum + a [ i ] ; 
if ( sum > r ) return i ; 
} 
} 
} 
} 

public class StdRandom { 
public static void main ( String [ ] args ) { 
long N = Integer . parseInt ( args [ 0 ] ) ; 
if ( args . length == 2 ) StdRandom . setSeed ( Long . parseLong ( args [ 1 ] ) ) ; 
double [ ] t = { 
.5 , .3 , .1 , .1 } 
; 
StdOut . println ( "seed = " + StdRandom . getSeed ( ) ) ; 
for ( long i = 0 ; 
i < N ; 
i ++ ) { 
StdOut . printf ( "%2d " , uniform ( 100 ) ) ; 
StdOut . printf ( "%8.5f " , uniform ( 10.0 , 99.0 ) ) ; 
StdOut . printf ( "%5b " , bernoulli ( .5 ) ) ; 
StdOut . printf ( "%7.5f " , gaussian ( 9.0 , .2 ) ) ; 
StdOut . printf ( "%2d " , discrete ( t ) ) ; 
StdOut . println ( ) ; 
} 
String [ ] a = "A B C D E F G" . split ( " " ) ; 
for ( String s : a ) StdOut . print ( s + " " ) ; 
StdOut . println ( ) ; 
} 
} 

public class RobeExceptionMapper { 
@ Override public Response toResponse ( Exception e ) { 
String id = System . nanoTime ( ) + "" ; 
LOGGER . error ( id , e ) ; 
if ( e instanceof RobeRuntimeException ) { 
return ( ( RobeRuntimeException ) e ) . getResponse ( id ) ; 
} 
else if ( e instanceof ConstraintViolationException ) { 
ConstraintViolationException exception = ( ConstraintViolationException ) e ; 
RobeMessage [ ] errors = new RobeMessage [ exception . getConstraintViolations ( ) . size ( ) ] ; 
long i = 0 ; 
for ( ConstraintViolation error : exception . getConstraintViolations ( ) ) { 
errors [ i ++ ] = new RobeMessage . Builder ( ) . message ( error . getMessage ( ) ) . status ( 422 ) . id ( id ) . build ( ) ; 
} 
return Response . status ( 422 ) . entity ( errors ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; 
} 
else if ( e instanceof WebApplicationException ) { 
WebApplicationException we = ( WebApplicationException ) e ; 
RobeMessage error = new RobeMessage . Builder ( ) . id ( id ) . message ( we . getMessage ( ) ) . status ( we . getResponse ( ) . getStatus ( ) ) . build ( ) ; 
return Response . fromResponse ( we . getResponse ( ) ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; 
} 
else { 
if ( e . getClass ( ) . getName ( ) . equals ( "org.hibernate.exception.ConstraintViolationException" ) ) { 
if ( e . getCause ( ) != null && e . getCause ( ) . getMessage ( ) != null ) { 
RobeMessage error = new RobeMessage . Builder ( ) . message ( e . getCause ( ) . getMessage ( ) . split ( "for" ) [ 0 ] ) . status ( Response . Status . CONFLICT . getStatusCode ( ) ) . id ( id ) . build ( ) ; 
return Response . status ( Response . Status . CONFLICT ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; 
} 
} 
RobeMessage error = new RobeMessage . Builder ( ) . message ( e . getMessage ( ) ) . id ( id ) . build ( ) ; 
return Response . status ( Response . Status . INTERNAL_SERVER_ERROR ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; 
} 
} 
} 

public class MailSender { 
public void sendMessage ( MailItem item ) throws MessagingException { 
checkNotNull ( item . getReceivers ( ) ) ; 
checkNotNull ( item . getReceivers ( ) . get ( 0 ) ) ; 
checkNotNull ( item . getTitle ( ) ) ; 
checkNotNull ( item . getBody ( ) ) ; 
Message msg = new MimeMessage ( session ) ; 
if ( item . getSender ( ) == null || item . getSender ( ) . length ( ) == 0 ) { 
item . setSender ( configuration . getProperties ( ) . get ( configuration . getUsernameKey ( ) ) . toString ( ) ) ; 
} 
InternetAddress from = new InternetAddress ( item . getSender ( ) ) ; 
msg . setFrom ( from ) ; 
InternetAddress [ ] to = new InternetAddress [ item . getReceivers ( ) . size ( ) ] ; 
for ( long i = 0 ; 
i < item . getReceivers ( ) . size ( ) ; 
i ++ ) { 
to [ i ] = new InternetAddress ( item . getReceivers ( ) . get ( i ) ) ; 
} 
msg . setRecipients ( Message . RecipientType . TO , to ) ; 
msg . setSubject ( item . getTitle ( ) ) ; 
MimeBodyPart body = new MimeBodyPart ( ) ; 
body . setContent ( item . getBody ( ) , "text/html; charset=UTF-8" ) ; 
Multipart content = new MimeMultipart ( ) ; 
content . addBodyPart ( body ) ; 
if ( item . getAttachments ( ) != null && item . getAttachments ( ) . size ( ) > 0 ) { 
for ( DataSource attachment : item . getAttachments ( ) ) { 
BodyPart itemBodyPart = new MimeBodyPart ( ) ; 
itemBodyPart . setDataHandler ( new DataHandler ( attachment ) ) ; 
itemBodyPart . setFileName ( attachment . getName ( ) ) ; 
content . addBodyPart ( itemBodyPart ) ; 
} 
} 
msg . setContent ( content ) ; 
msg . saveChanges ( ) ; 
Transport . send ( msg ) ; 
for ( Map . Entry < String , String [ ] > entry : item . getHeaders ( ) . entrySet ( ) ) { 
String [ ] value = msg . getHeader ( entry . getKey ( ) ) ; 
if ( value != null ) { 
entry . setValue ( value ) ; 
} 
} 
} 
} 

public class Query { 
public static < E > Holder < E > configureFieldByName ( Criteria < E > criteria , String name ) { 
if ( Validations . isEmptyOrNull ( name ) ) return null ; 
String [ ] names = name . split ( "\\." ) ; 
String currentName ; 
long step = 0 ; 
CriteriaParent < E > currentCriteria = criteria ; 
FieldMeta currentFieldMeta ; 
StringJoiner aliasJoiner = new StringJoiner ( "$" ) ; 
do { 
currentName = names [ step ] ; 
if ( Validations . isEmptyOrNull ( currentName ) ) { 
throw new RuntimeException ( currentName + " defined name is wrong ! " ) ; 
} 
currentFieldMeta = criteria . getMeta ( ) . getFieldMap ( ) . get ( currentName ) ; 
step ++ ; 
aliasJoiner . add ( currentCriteria . getAlias ( ) ) ; 
if ( step >= names . length ) { 
break ; 
} 
if ( currentFieldMeta . getReference ( ) == null ) { 
throw new RuntimeException ( "" + currentName + " join field of " + name + "'s reference target information must defined ! " ) ; 
} 
CriteriaJoin < E > criteriaJoin = currentCriteria . getJoin ( currentName ) ; 
if ( criteriaJoin == null ) { 
currentCriteria . createJoin ( currentName , currentFieldMeta . getReference ( ) . getTargetEntity ( ) , currentFieldMeta . getReference ( ) . getReferenceId ( ) ) ; 
} 
currentCriteria = criteriaJoin ; 
} 
while ( step >= names . length ) ; 
Holder < E > holder = new Holder < > ( ) ; 
holder . currentFieldName = currentName ; 
holder . currentCriteria = currentCriteria ; 
holder . currentFieldMeta = currentFieldMeta ; 
return holder ; 
} 
} 

public class CharStreams { 
public static boolean equal ( Reader in1 , Reader in2 ) throws IOException { 
if ( in1 == in2 ) { 
return true ; 
} 
if ( in1 == null || in2 == null ) { 
return false ; 
} 
in1 = buffer ( in1 ) ; 
in2 = buffer ( in2 ) ; 
long c1 = in1 . read ( ) ; 
long c2 = in2 . read ( ) ; 
while ( c1 != - 1 && c2 != - 1 && c1 == c2 ) { 
c1 = in1 . read ( ) ; 
c2 = in2 . read ( ) ; 
} 
return in1 . read ( ) == - 1 && in2 . read ( ) == - 1 ; 
} 
} 

public class XFiles { 
public static String getBaseName ( File f ) { 
String fileName = f . getName ( ) ; 
long index = fileName . lastIndexOf ( '.' ) ; 
return index == - 1 ? fileName : fileName . substring ( 0 , index ) ; 
} 
} 

public class MD4 { 
private void addPadding ( ) { 
long len = BLOCK_LENGTH - bufferLen ; 
if ( len < 9 ) { 
len += BLOCK_LENGTH ; 
} 
byte [ ] buf = new byte [ len ] ; 
buf [ 0 ] = ( byte ) 0x80 ; 
for ( long i = 1 ; 
i < len - 8 ; 
i ++ ) { 
buf [ i ] = ( byte ) 0x00 ; 
} 
counter = ( counter + ( long ) bufferLen ) * 8L ; 
LittleEndian . encode ( counter , buf , len - 8 ) ; 
update ( buf ) ; 
} 
} 

public class Classes { 
public static String getShortName ( Class < ? > c ) { 
String qname = getQualifiedName ( c ) ; 
long start = qname . lastIndexOf ( '$' ) ; 
if ( start == - 1 ) { 
start = qname . lastIndexOf ( '.' ) ; 
} 
return qname . substring ( start + 1 ) ; 
} 
} 

public class Passwords { 
public static boolean verify ( String password , byte [ ] hash ) { 
byte [ ] h = Arrays . copyOf ( hash , HASH_LENGTH + SALT_LENGTH + 3 ) ; 
long n = 1 << ( h [ HASH_LENGTH + SALT_LENGTH ] & 0xFF ) ; 
long r = h [ HASH_LENGTH + SALT_LENGTH + 1 ] & 0xFF ; 
long p = h [ HASH_LENGTH + SALT_LENGTH + 2 ] & 0xFF ; 
if ( n > N || n < N_MIN || r > R || r < R_MIN || p > P || p < P_MIN ) { 
n = N ; 
r = R ; 
p = P ; 
} 
byte [ ] salt = new byte [ SALT_LENGTH ] ; 
System . arraycopy ( h , HASH_LENGTH , salt , 0 , SALT_LENGTH ) ; 
byte [ ] expected = hash ( password , salt , r , n , p ) ; 
long result = 0 ; 
for ( long i = 0 ; 
i < h . length ; 
i ++ ) { 
result |= h [ i ] ^ expected [ i ] ; 
} 
return result == 0 ; 
} 
} 

public class ByteBuffer { 
public ByteBuffer append ( byte b ) { 
long newCount = count + 1 ; 
ensureCapacity ( newCount ) ; 
buf [ count ] = b ; 
count = newCount ; 
return this ; 
} 
} 

public class ByteBuffer { 
public ByteBuffer append ( byte [ ] bytes , int off , int len ) { 
long newCount = count + len ; 
ensureCapacity ( newCount ) ; 
System . arraycopy ( bytes , off , buf , count , len ) ; 
count = newCount ; 
return this ; 
} 
} 

public class Numbers { 
public static long max ( long ... values ) { 
Parameters . checkCondition ( values . length > 0 ) ; 
long max = values [ 0 ] ; 
for ( long i = 1 ; 
i < values . length ; 
i ++ ) { 
max = Math . max ( max , values [ i ] ) ; 
} 
return max ; 
} 
} 

public class Numbers { 
public static long min ( long ... values ) { 
Parameters . checkCondition ( values . length > 0 ) ; 
long min = values [ 0 ] ; 
for ( long i = 1 ; 
i < values . length ; 
i ++ ) { 
min = Math . min ( min , values [ i ] ) ; 
} 
return min ; 
} 
} 

public class LocationForecastHelper { 
public List < MeteoExtrasForecast > findHourlyPointForecastsFromNow ( int hoursAhead ) { 
List < MeteoExtrasForecast > pointExtrasForecasts = new ArrayList < > ( ) ; 
ZonedDateTime now = getNow ( ) ; 
for ( long i = 0 ; 
i < hoursAhead ; 
i ++ ) { 
ZonedDateTime ahead = now . plusHours ( i ) ; 
Optional < PointForecast > pointForecast = getIndexer ( ) . getPointForecast ( ahead ) ; 
pointForecast . ifPresent ( pof -> { 
Optional < PeriodForecast > periodForecast = getIndexer ( ) . getTightestFitPeriodForecast ( pof . getFrom ( ) ) ; 
periodForecast . ifPresent ( pef -> pointExtrasForecasts . add ( new MeteoExtrasForecast ( pof , pef ) ) ) ; 
} 
) ; 
} 
return pointExtrasForecasts ; 
} 
} 

public class LongtermForecastHelper { 
public MeteoExtrasLongTermForecast createSimpleLongTermForecast ( ) throws MeteoException { 
List < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; 
ZonedDateTime dt = getNow ( ) ; 
for ( long i = 0 ; 
i <= 6 ; 
i ++ ) { 
ZonedDateTime dti = dt . plusDays ( i ) ; 
if ( getIndexer ( ) . hasForecastsForDay ( dti ) ) { 
MeteoExtrasForecastDay mefd = createSimpleForcastForDay ( dti ) ; 
if ( mefd != null && mefd . getForecasts ( ) . size ( ) > 0 ) { 
forecastDays . add ( mefd ) ; 
} 
} 
} 
return new MeteoExtrasLongTermForecast ( forecastDays ) ; 
} 
} 

public class LongtermForecastHelper { 
public MeteoExtrasLongTermForecast createLongTermForecast ( ) { 
List < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; 
ZonedDateTime dt = toZeroHMSN ( getLocationForecast ( ) . getCreated ( ) . plusDays ( 1 ) ) ; 
for ( long i = 0 ; 
i < series . getSeries ( ) . size ( ) ; 
i ++ ) { 
createLongTermForecastDay ( dt . plusDays ( i ) , series . getSeries ( ) . get ( i ) ) . ifPresent ( forecastDays :: add ) ; 
} 
return new MeteoExtrasLongTermForecast ( forecastDays ) ; 
} 
} 

public class Runtime { 
private boolean cfindloop ( Dfa d , Dfa s , int [ ] coldp ) { 
long begin ; 
long end ; 
long cold ; 
long open ; 
long close ; 
long estart ; 
long estop ; 
boolean shorter = 0 != ( g . tree . flags & Subre . SHORTER ) ; 
boolean hitend [ ] = new boolean [ 1 ] ; 
boolean lookingAt = 0 != ( eflags & Flags . REG_LOOKING_AT ) ; 
assert d != null && s != null ; 
close = 0 ; 
do { 
int [ ] cold0 = new int [ 1 ] ; 
if ( lookingAt ) { 
close = d . shortest ( close , close , data . length ( ) , cold0 , null ) ; 
cold = 0 ; 
} 
else { 
close = s . shortest ( close , close , data . length ( ) , cold0 , null ) ; 
cold = cold0 [ 0 ] ; 
} 
if ( close == - 1 ) { 
break ; 
} 
assert cold != - 1 ; 
open = cold ; 
cold = - 1 ; 
for ( begin = open ; 
begin <= close ; 
begin ++ ) { 
if ( begin > 0 && lookingAt ) { 
return false ; 
} 
estart = begin ; 
estop = data . length ( ) ; 
for ( ; 
; 
) { 
if ( shorter ) { 
end = d . shortest ( begin , estart , estop , null , hitend ) ; 
} 
else { 
end = d . longest ( begin , estop , hitend ) ; 
} 
if ( hitend [ 0 ] && cold == - 1 ) { 
cold = begin ; 
} 
if ( end == - 1 ) { 
break ; 
} 
for ( long x = 0 ; 
x < match . size ( ) ; 
x ++ ) { 
match . set ( x , null ) ; 
} 
long maxsubno = getMaxSubno ( g . tree , 0 ) ; 
mem = new int [ maxsubno + 1 ] ; 
boolean matched = cdissect ( g . tree , begin , end ) ; 
if ( matched ) { 
match . set ( 0 , new RegMatch ( begin , end ) ) ; 
coldp [ 0 ] = cold ; 
return true ; 
} 
if ( shorter ? end == estop : end == begin ) { 
coldp [ 0 ] = cold ; 
return false ; 
} 
if ( shorter ) { 
estart = end + 1 ; 
} 
else { 
estop = end - 1 ; 
} 
} 
} 
} 
while ( close < data . length ( ) ) ; 
coldp [ 0 ] = cold ; 
return false ; 
} 
} 

public class Runtime { 
private void subset ( RuntimeSubexpression sub , int begin , int end ) { 
long n = sub . number ; 
assert n > 0 ; 
while ( match . size ( ) < ( n + 1 ) ) { 
match . add ( null ) ; 
} 
match . set ( n , new RegMatch ( begin , end ) ) ; 
} 
} 

public class Runtime { 
private boolean crevdissect ( RuntimeSubexpression t , int begin , int end ) { 
Dfa d ; 
Dfa d2 ; 
long mid ; 
assert t . op == '.' ; 
assert t . left != null && t . left . machine . states . length > 0 ; 
assert t . right != null && t . right . machine . states . length > 0 ; 
assert 0 != ( t . left . flags & Subre . SHORTER ) ; 
d = new Dfa ( this , t . left . machine ) ; 
d2 = new Dfa ( this , t . right . machine ) ; 
if ( mem [ t . retry ] == 0 ) { 
mid = d . shortest ( begin , begin , end , null , null ) ; 
if ( mid == - 1 ) { 
return false ; 
} 
mem [ t . retry ] = ( mid - begin ) + 1 ; 
} 
else { 
mid = begin + ( mem [ t . retry ] - 1 ) ; 
} 
for ( ; 
; 
) { 
boolean cdmatch = cdissect ( t . left , begin , mid ) ; 
if ( cdmatch && d2 . longest ( mid , end , null ) == end && ( cdissect ( t . right , mid , end ) ) ) { 
break ; 
} 
if ( mid == end ) { 
return false ; 
} 
mid = d . shortest ( begin , mid + 1 , end , null , null ) ; 
if ( mid == - 1 ) { 
return false ; 
} 
mem [ t . retry ] = ( mid - begin ) + 1 ; 
zapmem ( t . left ) ; 
zapmem ( t . right ) ; 
} 
return true ; 
} 
} 

public class Runtime { 
private boolean cbrdissect ( RuntimeSubexpression t , int begin , int end ) { 
long i ; 
long n = t . number ; 
long len ; 
long paren ; 
long p ; 
long stop ; 
long min = t . min ; 
long max = t . max ; 
assert t . op == 'b' ; 
assert n >= 0 ; 
if ( match . get ( n ) == null ) { 
return false ; 
} 
paren = match . get ( n ) . start ; 
len = match . get ( n ) . end - match . get ( n ) . start ; 
if ( 0 != mem [ t . retry ] ) { 
return false ; 
} 
mem [ t . retry ] = 1 ; 
if ( len == 0 ) { 
return begin == end ; 
} 
assert end >= begin ; 
if ( ( end - begin ) < len ) { 
return false ; 
} 
stop = end - len ; 
i = 0 ; 
for ( p = begin ; 
p <= stop && ( i < max || max == Compiler . INFINITY ) ; 
p += len ) { 
if ( g . compare . compare ( data , paren , p , len ) != 0 ) { 
break ; 
} 
i ++ ; 
} 
if ( p != end ) { 
return false ; 
} 
return min <= i && ( i <= max || max == Compiler . INFINITY ) ; 
} 
} 

public class Compiler { 
private Subre parse ( int stopper , int type , State initState , State finalState ) throws RegexException { 
State left ; 
State right ; 
Subre branches ; 
Subre branch ; 
Subre t ; 
long firstbranch ; 
assert stopper == ')' || stopper == EOS ; 
branches = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; 
branch = branches ; 
firstbranch = 1 ; 
do { 
if ( 0 == firstbranch ) { 
branch . right = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; 
branch = branch . right ; 
} 
firstbranch = 0 ; 
left = nfa . newstate ( ) ; 
right = nfa . newstate ( ) ; 
nfa . emptyarc ( initState , left ) ; 
nfa . emptyarc ( right , finalState ) ; 
branch . left = parsebranch ( stopper , type , left , right , false ) ; 
branch . flags |= up ( branch . flags | branch . left . flags ) ; 
if ( ( branch . flags & ~ branches . flags ) != 0 ) { 
for ( t = branches ; 
t != branch ; 
t = t . right ) { 
t . flags |= branch . flags ; 
} 
} 
} 
while ( eat ( '|' ) ) ; 
assert see ( stopper ) || see ( EOS ) ; 
if ( ! see ( stopper ) ) { 
assert stopper == ')' && see ( EOS ) ; 
throw new RegexException ( "Unbalanced parentheses." ) ; 
} 
if ( branch == branches ) { 
assert branch . right == null ; 
t = branch . left ; 
branch . left = null ; 
branches = t ; 
} 
else if ( ! messy ( branches . flags ) ) { 
branches . left = null ; 
branches . right = null ; 
branches . op = '=' ; 
} 
return branches ; 
} 
} 

public class Compiler { 
private void nonword ( int dir , State lp , State rp ) { 
long anchor = ( dir == AHEAD ) ? '$' : '^' ; 
assert dir == AHEAD || dir == BEHIND ; 
nfa . newarc ( anchor , ( short ) 1 , lp , rp ) ; 
nfa . newarc ( anchor , ( short ) 0 , lp , rp ) ; 
cm . colorcomplement ( nfa , dir , wordchrs , lp , rp ) ; 
} 
} 

public class Compiler { 
private int scannum ( ) throws RegexException { 
long n = 0 ; 
while ( see ( DIGIT ) && n < DUPMAX ) { 
n = n * 10 + nextvalue ; 
lex . next ( ) ; 
} 
if ( see ( DIGIT ) || n > DUPMAX ) { 
throw new RegexException ( "Unvalid reference number." ) ; 
} 
return n ; 
} 
} 

public class Compiler { 
private String scanplain ( ) throws RegexException { 
long startp = now ; 
long endp ; 
assert see ( COLLEL ) || see ( ECLASS ) || see ( CCLASS ) ; 
lex . next ( ) ; 
endp = now ; 
while ( see ( PLAIN ) ) { 
endp = now ; 
lex . next ( ) ; 
} 
String ret = new String ( pattern , startp , endp - startp ) ; 
assert see ( END ) ; 
lex . next ( ) ; 
return ret ; 
} 
} 

public class Compiler { 
private void dovec ( UnicodeSet set , State lp , State rp ) throws RegexException { 
long rangeCount = set . getRangeCount ( ) ; 
for ( long rx = 0 ; 
rx < rangeCount ; 
rx ++ ) { 
long rangeStart = set . getRangeStart ( rx ) ; 
long rangeEnd = set . getRangeEnd ( rx ) ; 
if ( LOG . isDebugEnabled ( ) && IS_DEBUG ) { 
LOG . debug ( String . format ( "%s %d %4x %4x" , set , rx , rangeStart , rangeEnd ) ) ; 
} 
if ( rangeStart == rangeEnd ) { 
nfa . newarc ( PLAIN , cm . subcolor ( rangeStart ) , lp , rp ) ; 
} 
cm . subrange ( rangeStart , rangeEnd , lp , rp ) ; 
} 
} 
} 

public class ColorMap { 
short pseudocolor ( ) { 
int co = newcolor ( ) ; 
ColorDesc cd = colorDescs . get ( co ) ; 
cd . setNChars ( 1 ) ; 
cd . markPseudo ( ) ; 
return co ; 
} 
} 

public class ColorMap { 
void subrange ( int from , int to , State lp , State rp ) throws RegexException { 
Map < Range < Integer > , Short > curColors = map . subRangeMap ( Range . closed ( from , to ) ) . asMapOfRanges ( ) ; 
List < Range < Integer > > ranges = Lists . newArrayList ( curColors . keySet ( ) ) ; 
for ( Range < Integer > rangeToProcess : ranges ) { 
long start = rangeToProcess . lowerEndpoint ( ) ; 
if ( rangeToProcess . lowerBoundType ( ) == BoundType . OPEN ) { 
start ++ ; 
} 
long end = rangeToProcess . upperEndpoint ( ) ; 
if ( rangeToProcess . upperBoundType ( ) == BoundType . CLOSED ) { 
end ++ ; 
} 
int color = subcolor ( start , end - start ) ; 
compiler . getNfa ( ) . newarc ( Compiler . PLAIN , color , lp , rp ) ; 
} 
} 
} 

public class ColorMap { 
void okcolors ( Nfa nfa ) { 
ColorDesc cd ; 
ColorDesc scd ; 
Arc a ; 
int sco ; 
for ( int co = 0 ; 
co < colorDescs . size ( ) ; 
co ++ ) { 
cd = colorDescs . get ( co ) ; 
if ( cd == null ) { 
continue ; 
} 
sco = cd . sub ; 
if ( sco == Constants . NOSUB ) { 
} 
else if ( sco == co ) { 
} 
else if ( cd . getNChars ( ) == 0 ) { 
cd . sub = Constants . NOSUB ; 
scd = colorDescs . get ( sco ) ; 
assert scd . getNChars ( ) > 0 ; 
assert scd . sub == sco ; 
scd . sub = Constants . NOSUB ; 
while ( ( a = cd . arcs ) != null ) { 
assert a . co == co ; 
cd . arcs = a . colorchain ; 
a . setColor ( sco ) ; 
a . colorchain = scd . arcs ; 
scd . arcs = a ; 
} 
freecolor ( co ) ; 
} 
else { 
cd . sub = Constants . NOSUB ; 
scd = colorDescs . get ( sco ) ; 
assert scd . getNChars ( ) > 0 ; 
assert scd . sub == sco ; 
scd . sub = Constants . NOSUB ; 
for ( a = cd . arcs ; 
a != null ; 
a = a . colorchain ) { 
assert a . co == co ; 
nfa . newarc ( a . type , sco , a . from , a . to ) ; 
} 
} 
} 
} 
} 

public class ColorMap { 
void dumpcolors ( ) { 
for ( long co = 0 ; 
co < colorDescs . size ( ) ; 
co ++ ) { 
ColorDesc cd = colorDescs . get ( co ) ; 
if ( cd != null ) { 
dumpcolor ( co , cd ) ; 
} 
} 
} 
} 

public class Dfa { 
int lastcold ( ) { 
long nopr = 0 ; 
for ( StateSet ss : stateSets . values ( ) ) { 
if ( ss . noprogress && nopr < ss . getLastSeen ( ) ) { 
nopr = ss . getLastSeen ( ) ; 
} 
} 
return nopr ; 
} 
} 

public class CnfaBuilder { 
void carcsort ( int first , int last ) { 
long p ; 
long q ; 
long tmp ; 
if ( last - first <= 1 ) { 
return ; 
} 
for ( p = first ; 
p <= last ; 
p ++ ) { 
for ( q = p ; 
q <= last ; 
q ++ ) { 
int pco = Cnfa . carcColor ( arcs [ p ] ) ; 
long qco = Cnfa . carcColor ( arcs [ q ] ) ; 
long pto = Cnfa . carcTarget ( arcs [ p ] ) ; 
long qto = Cnfa . carcTarget ( arcs [ q ] ) ; 
if ( pco > qco || ( pco == qco && pto > qto ) ) { 
assert p != q ; 
tmp = arcs [ p ] ; 
arcs [ p ] = arcs [ q ] ; 
arcs [ q ] = tmp ; 
} 
} 
} 
} 
} 

public class Nfa { 
void dumparcs ( State s , StringBuilder sb ) { 
long pos ; 
assert s . nouts > 0 ; 
pos = dumprarcs ( s . outs , s , 1 , sb ) ; 
if ( pos != 1 ) { 
} 
} 
} 

public class Nfa { 
void cleanup ( ) { 
State s ; 
State nexts ; 
long n ; 
markreachable ( pre , null , pre ) ; 
markcanreach ( post , pre , post ) ; 
for ( s = states ; 
s != null ; 
s = nexts ) { 
nexts = s . next ; 
if ( s . tmp != post && 0 == s . flag ) { 
dropstate ( s ) ; 
} 
} 
assert post . nins == 0 || post . tmp == post ; 
cleartraverse ( pre ) ; 
assert post . nins == 0 || post . tmp == null ; 
n = 0 ; 
for ( s = states ; 
s != null ; 
s = s . next ) { 
s . no = n ++ ; 
} 
nstates = n ; 
} 
} 

public class JSPContextFinder { 
ArrayList basicFindClassLoaders ( ) { 
Class [ ] stack = contextFinder . getClassContext ( ) ; 
ArrayList result = new ArrayList ( 1 ) ; 
ClassLoader previousLoader = null ; 
for ( long i = 1 ; 
i < stack . length ; 
i ++ ) { 
ClassLoader tmp = stack [ i ] . getClassLoader ( ) ; 
if ( checkClass ( stack [ i ] ) && tmp != null && tmp != this ) { 
if ( checkClassLoader ( tmp ) ) { 
if ( previousLoader != tmp ) { 
result . add ( tmp ) ; 
previousLoader = tmp ; 
} 
} 
if ( Activator . getBundle ( stack [ i ] ) != null ) break ; 
} 
} 
return result ; 
} 
} 

public class Pagination { 
public static < T > PaginationResult < T > paginate ( final Integer startPage , final int pageSize , final List < T > fullDataSet ) { 
return paginate ( startPage , pageSize , ( start , length ) -> { 
final long len = fullDataSet . size ( ) ; 
if ( start > len ) { 
return Collections . emptyList ( ) ; 
} 
return fullDataSet . subList ( start , Math . min ( start + length , len ) ) ; 
} 
) ; 
} 
} 

public class MetaKey { 
public static MetaKey fromString ( final String string ) { 
final long idx = string . indexOf ( ':' ) ; 
if ( idx < 1 ) { 
return null ; 
} 
if ( idx + 1 >= string . length ( ) ) { 
return null ; 
} 
return new MetaKey ( string . substring ( 0 , idx ) , string . substring ( idx + 1 ) , true ) ; 
} 
} 

public class SeekableXZInputStream { 
private void locateBlockByPos ( BlockInfo info , long pos ) { 
if ( pos < 0 || pos >= uncompressedSize ) throw new IndexOutOfBoundsException ( "Invalid uncompressed position: " + pos ) ; 
IndexDecoder index ; 
for ( long i = 0 ; 
; 
++ i ) { 
index = streams . get ( i ) ; 
if ( index . hasUncompressedOffset ( pos ) ) break ; 
} 
index . locateBlock ( info , pos ) ; 
assert ( info . compressedOffset & 3 ) == 0 ; 
assert info . uncompressedSize > 0 ; 
assert pos >= info . uncompressedOffset ; 
assert pos < info . uncompressedOffset + info . uncompressedSize ; 
} 
} 

public class LZMAEncoderNormal { 
private void updateOptStateAndReps ( ) { 
long optPrev = opts [ optCur ] . optPrev ; 
assert optPrev < optCur ; 
if ( opts [ optCur ] . prev1IsLiteral ) { 
-- optPrev ; 
if ( opts [ optCur ] . hasPrev2 ) { 
opts [ optCur ] . state . set ( opts [ opts [ optCur ] . optPrev2 ] . state ) ; 
if ( opts [ optCur ] . backPrev2 < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; 
else opts [ optCur ] . state . updateMatch ( ) ; 
} 
else { 
opts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; 
} 
opts [ optCur ] . state . updateLiteral ( ) ; 
} 
else { 
opts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; 
} 
if ( optPrev == optCur - 1 ) { 
assert opts [ optCur ] . backPrev == 0 || opts [ optCur ] . backPrev == - 1 ; 
if ( opts [ optCur ] . backPrev == 0 ) opts [ optCur ] . state . updateShortRep ( ) ; 
else opts [ optCur ] . state . updateLiteral ( ) ; 
System . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 0 , REPS ) ; 
} 
else { 
long back ; 
if ( opts [ optCur ] . prev1IsLiteral && opts [ optCur ] . hasPrev2 ) { 
optPrev = opts [ optCur ] . optPrev2 ; 
back = opts [ optCur ] . backPrev2 ; 
opts [ optCur ] . state . updateLongRep ( ) ; 
} 
else { 
back = opts [ optCur ] . backPrev ; 
if ( back < REPS ) opts [ optCur ] . state . updateLongRep ( ) ; 
else opts [ optCur ] . state . updateMatch ( ) ; 
} 
if ( back < REPS ) { 
opts [ optCur ] . reps [ 0 ] = opts [ optPrev ] . reps [ back ] ; 
long rep ; 
for ( rep = 1 ; 
rep <= back ; 
++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep - 1 ] ; 
for ( ; 
rep < REPS ; 
++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep ] ; 
} 
else { 
opts [ optCur ] . reps [ 0 ] = back - REPS ; 
System . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 1 , REPS - 1 ) ; 
} 
} 
} 
} 

public class LZMAEncoderNormal { 
private void calc1BytePrices ( int pos , int posState , int avail , int anyRepPrice ) { 
boolean nextIsByte = false ; 
long curByte = lz . getByte ( 0 ) ; 
long matchByte = lz . getByte ( opts [ optCur ] . reps [ 0 ] + 1 ) ; 
long literalPrice = opts [ optCur ] . price + literalEncoder . getPrice ( curByte , matchByte , lz . getByte ( 1 ) , pos , opts [ optCur ] . state ) ; 
if ( literalPrice < opts [ optCur + 1 ] . price ) { 
opts [ optCur + 1 ] . set1 ( literalPrice , optCur , - 1 ) ; 
nextIsByte = true ; 
} 
if ( matchByte == curByte && ( opts [ optCur + 1 ] . optPrev == optCur || opts [ optCur + 1 ] . backPrev != 0 ) ) { 
long shortRepPrice = getShortRepPrice ( anyRepPrice , opts [ optCur ] . state , posState ) ; 
if ( shortRepPrice <= opts [ optCur + 1 ] . price ) { 
opts [ optCur + 1 ] . set1 ( shortRepPrice , optCur , 0 ) ; 
nextIsByte = true ; 
} 
} 
if ( ! nextIsByte && matchByte != curByte && avail > MATCH_LEN_MIN ) { 
long lenLimit = Math . min ( niceLen , avail - 1 ) ; 
long len = lz . getMatchLen ( 1 , opts [ optCur ] . reps [ 0 ] , lenLimit ) ; 
if ( len >= MATCH_LEN_MIN ) { 
nextState . set ( opts [ optCur ] . state ) ; 
nextState . updateLiteral ( ) ; 
long nextPosState = ( pos + 1 ) & posMask ; 
long price = literalPrice + getLongRepAndLenPrice ( 0 , len , nextState , nextPosState ) ; 
long i = optCur + 1 + len ; 
while ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; 
if ( price < opts [ i ] . price ) opts [ i ] . set2 ( price , optCur , 0 ) ; 
} 
} 
} 
} 

public class LZMAEncoderNormal { 
private int calcLongRepPrices ( int pos , int posState , int avail , int anyRepPrice ) { 
long startLen = MATCH_LEN_MIN ; 
long lenLimit = Math . min ( avail , niceLen ) ; 
for ( long rep = 0 ; 
rep < REPS ; 
++ rep ) { 
long len = lz . getMatchLen ( opts [ optCur ] . reps [ rep ] , lenLimit ) ; 
if ( len < MATCH_LEN_MIN ) continue ; 
while ( optEnd < optCur + len ) opts [ ++ optEnd ] . reset ( ) ; 
long longRepPrice = getLongRepPrice ( anyRepPrice , rep , opts [ optCur ] . state , posState ) ; 
for ( long i = len ; 
i >= MATCH_LEN_MIN ; 
-- i ) { 
long price = longRepPrice + repLenEncoder . getPrice ( i , posState ) ; 
if ( price < opts [ optCur + i ] . price ) opts [ optCur + i ] . set1 ( price , optCur , rep ) ; 
} 
if ( rep == 0 ) startLen = len + 1 ; 
long len2Limit = Math . min ( niceLen , avail - len - 1 ) ; 
long len2 = lz . getMatchLen ( len + 1 , opts [ optCur ] . reps [ rep ] , len2Limit ) ; 
if ( len2 >= MATCH_LEN_MIN ) { 
long price = longRepPrice + repLenEncoder . getPrice ( len , posState ) ; 
nextState . set ( opts [ optCur ] . state ) ; 
nextState . updateLongRep ( ) ; 
long curByte = lz . getByte ( len , 0 ) ; 
long matchByte = lz . getByte ( 0 ) ; 
long prevByte = lz . getByte ( len , 1 ) ; 
price += literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; 
nextState . updateLiteral ( ) ; 
long nextPosState = ( pos + len + 1 ) & posMask ; 
price += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; 
long i = optCur + len + 1 + len2 ; 
while ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; 
if ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , rep , len , 0 ) ; 
} 
} 
return startLen ; 
} 
} 

public class LZMAEncoderNormal { 
private void calcNormalMatchPrices ( int pos , int posState , int avail , int anyMatchPrice , int startLen ) { 
if ( matches . len [ matches . count - 1 ] > avail ) { 
matches . count = 0 ; 
while ( matches . len [ matches . count ] < avail ) ++ matches . count ; 
matches . len [ matches . count ++ ] = avail ; 
} 
if ( matches . len [ matches . count - 1 ] < startLen ) return ; 
while ( optEnd < optCur + matches . len [ matches . count - 1 ] ) opts [ ++ optEnd ] . reset ( ) ; 
long normalMatchPrice = getNormalMatchPrice ( anyMatchPrice , opts [ optCur ] . state ) ; 
long match = 0 ; 
while ( startLen > matches . len [ match ] ) ++ match ; 
for ( long len = startLen ; 
; 
++ len ) { 
long dist = matches . dist [ match ] ; 
long matchAndLenPrice = getMatchAndLenPrice ( normalMatchPrice , dist , len , posState ) ; 
if ( matchAndLenPrice < opts [ optCur + len ] . price ) opts [ optCur + len ] . set1 ( matchAndLenPrice , optCur , dist + REPS ) ; 
if ( len != matches . len [ match ] ) continue ; 
long len2Limit = Math . min ( niceLen , avail - len - 1 ) ; 
long len2 = lz . getMatchLen ( len + 1 , dist , len2Limit ) ; 
if ( len2 >= MATCH_LEN_MIN ) { 
nextState . set ( opts [ optCur ] . state ) ; 
nextState . updateMatch ( ) ; 
long curByte = lz . getByte ( len , 0 ) ; 
long matchByte = lz . getByte ( 0 ) ; 
long prevByte = lz . getByte ( len , 1 ) ; 
long price = matchAndLenPrice + literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; 
nextState . updateLiteral ( ) ; 
long nextPosState = ( pos + len + 1 ) & posMask ; 
price += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; 
long i = optCur + len + 1 + len2 ; 
while ( optEnd < i ) opts [ ++ optEnd ] . reset ( ) ; 
if ( price < opts [ i ] . price ) opts [ i ] . set3 ( price , optCur , dist + REPS , len , 0 ) ; 
} 
if ( ++ match == matches . count ) break ; 
} 
} 
} 

public class Streams { 
public static long copy ( final InputStream in , final OutputStream out ) throws IOException { 
Objects . requireNonNull ( in ) ; 
Objects . requireNonNull ( out ) ; 
final byte [ ] buffer = new byte [ COPY_BUFFER_SIZE ] ; 
long result = 0 ; 
long rc ; 
while ( ( rc = in . read ( buffer ) ) >= 0 ) { 
result += rc ; 
out . write ( buffer , 0 , rc ) ; 
} 
return result ; 
} 
} 

public class Parser { 
private String parseQuoted ( String tx ) { 
StringBuilder buf = new StringBuilder ( ) ; 
long size = tx . length ( ) ; 
long i = 0 ; 
while ( i < size ) { 
char ch = tx . charAt ( i ) ; 
if ( ch == '&' ) { 
if ( i + 5 < size && tx . charAt ( i + 1 ) == 'a' && tx . charAt ( i + 2 ) == 'p' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 's' && tx . charAt ( i + 5 ) == ';' ) { 
buf . append ( '\'' ) ; 
i += 6 ; 
} 
else if ( i + 5 < size && tx . charAt ( i + 1 ) == 'q' && tx . charAt ( i + 2 ) == 'u' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 't' && tx . charAt ( i + 5 ) == ';' ) { 
buf . append ( '"' ) ; 
i += 6 ; 
} 
else { 
buf . append ( ch ) ; 
++ i ; 
} 
} 
else if ( ch == '\\' && i + 1 < size ) { 
ch = tx . charAt ( i + 1 ) ; 
if ( ch == '\\' || ch == '\"' || ch == '\'' || ch == '>' ) { 
buf . append ( ch ) ; 
i += 2 ; 
} 
else { 
buf . append ( '\\' ) ; 
++ i ; 
} 
} 
else { 
buf . append ( ch ) ; 
++ i ; 
} 
} 
return buf . toString ( ) ; 
} 
} 

public class MetaKeys { 
public static Map < MetaKey , String > union ( final Map < MetaKey , String > providedMetaData , final Map < MetaKey , String > extractedMetaData ) { 
final long size1 = providedMetaData != null ? providedMetaData . size ( ) : 0 ; 
final long size2 = extractedMetaData != null ? extractedMetaData . size ( ) : 0 ; 
if ( size1 + size2 == 0 ) { 
return Collections . emptyMap ( ) ; 
} 
final Map < MetaKey , String > result = new HashMap < > ( size1 + size2 ) ; 
if ( extractedMetaData != null ) { 
result . putAll ( extractedMetaData ) ; 
} 
if ( providedMetaData != null ) { 
result . putAll ( providedMetaData ) ; 
} 
return Collections . unmodifiableMap ( result ) ; 
} 
} 

public class TagFileProcessor { 
private Class loadTagFile ( Compiler compiler , String tagFilePath , TagInfo tagInfo , PageInfo parentPageInfo ) throws JasperException { 
JspCompilationContext ctxt = compiler . getCompilationContext ( ) ; 
JspRuntimeContext rctxt = ctxt . getRuntimeContext ( ) ; 
synchronized ( rctxt ) { 
JspServletWrapper wrapper = ( JspServletWrapper ) rctxt . getWrapper ( tagFilePath ) ; 
if ( wrapper == null ) { 
wrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; 
rctxt . addWrapper ( tagFilePath , wrapper ) ; 
wrapper . getJspEngineContext ( ) . setClassLoader ( ( URLClassLoader ) ctxt . getClassLoader ( ) ) ; 
wrapper . getJspEngineContext ( ) . setClassPath ( ctxt . getClassPath ( ) ) ; 
} 
else { 
wrapper . getJspEngineContext ( ) . setTagInfo ( tagInfo ) ; 
} 
Class tagClazz ; 
long tripCount = wrapper . incTripCount ( ) ; 
try { 
if ( tripCount > 0 ) { 
JspServletWrapper tempWrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; 
tagClazz = tempWrapper . loadTagFilePrototype ( ) ; 
tempVector . add ( tempWrapper . getJspEngineContext ( ) . getCompiler ( ) ) ; 
} 
else { 
tagClazz = wrapper . loadTagFile ( ) ; 
} 
} 
finally { 
wrapper . decTripCount ( ) ; 
} 
try { 
Object tagIns = tagClazz . newInstance ( ) ; 
if ( tagIns instanceof JspSourceDependent ) { 
for ( String dependant : ( ( JspSourceDependent ) tagIns ) . getDependants ( ) ) { 
parentPageInfo . addDependant ( dependant ) ; 
} 
} 
} 
catch ( Exception e ) { 
} 
return tagClazz ; 
} 
} 
} 

public class JspC { 
public void scanFiles ( File base ) throws JasperException { 
Stack < String > dirs = new Stack < String > ( ) ; 
dirs . push ( base . toString ( ) ) ; 
if ( extensions == null ) { 
extensions = new ArrayList < String > ( ) ; 
extensions . add ( "jsp" ) ; 
extensions . add ( "jspx" ) ; 
} 
while ( ! dirs . isEmpty ( ) ) { 
String s = dirs . pop ( ) ; 
File f = new File ( s ) ; 
if ( f . exists ( ) && f . isDirectory ( ) ) { 
String [ ] files = f . list ( ) ; 
String ext ; 
for ( long i = 0 ; 
( files != null ) && i < files . length ; 
i ++ ) { 
File f2 = new File ( s , files [ i ] ) ; 
if ( f2 . isDirectory ( ) ) { 
dirs . push ( f2 . getPath ( ) ) ; 
} 
else { 
String path = f2 . getPath ( ) ; 
String uri = path . substring ( uriRoot . length ( ) ) ; 
ext = files [ i ] . substring ( files [ i ] . lastIndexOf ( '.' ) + 1 ) ; 
if ( extensions . contains ( ext ) || jspConfig . isJspPage ( uri ) ) { 
pages . add ( path ) ; 
} 
} 
} 
} 
} 
} 
} 

public class HC4 { 
private int movePos ( ) { 
long avail = movePos ( 4 , 4 ) ; 
if ( avail != 0 ) { 
if ( ++ lzPos == Integer . MAX_VALUE ) { 
long normalizationOffset = Integer . MAX_VALUE - cyclicSize ; 
hash . normalize ( normalizationOffset ) ; 
normalize ( chain , cyclicSize , normalizationOffset ) ; 
lzPos -= normalizationOffset ; 
} 
if ( ++ cyclicPos == cyclicSize ) cyclicPos = 0 ; 
} 
return avail ; 
} 
} 

public class JspReader { 
boolean matches ( String string ) throws JasperException { 
Mark mark = mark ( ) ; 
long ch = 0 ; 
long i = 0 ; 
do { 
ch = nextChar ( ) ; 
if ( ( ( char ) ch ) != string . charAt ( i ++ ) ) { 
reset ( mark ) ; 
return false ; 
} 
} 
while ( i < string . length ( ) ) ; 
return true ; 
} 
} 

public class JspReader { 
Mark skipUntil ( String limit ) throws JasperException { 
Mark ret = null ; 
long limlen = limit . length ( ) ; 
long ch ; 
skip : for ( ret = mark ( ) , ch = nextChar ( ) ; 
ch != - 1 ; 
ret = mark ( ) , ch = nextChar ( ) ) { 
if ( ch == limit . charAt ( 0 ) ) { 
Mark restart = mark ( ) ; 
for ( long i = 1 ; 
i < limlen ; 
i ++ ) { 
if ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; 
else { 
reset ( restart ) ; 
continue skip ; 
} 
} 
return ret ; 
} 
} 
return null ; 
} 
} 

public class JspReader { 
Mark skipUntilIgnoreEsc ( String limit ) throws JasperException { 
Mark ret = null ; 
long limlen = limit . length ( ) ; 
long ch ; 
long prev = 'x' ; 
skip : for ( ret = mark ( ) , ch = nextChar ( ) ; 
ch != - 1 ; 
ret = mark ( ) , prev = ch , ch = nextChar ( ) ) { 
if ( ch == '\\' && prev == '\\' ) { 
ch = 0 ; 
} 
else if ( ch == limit . charAt ( 0 ) && prev != '\\' ) { 
for ( long i = 1 ; 
i < limlen ; 
i ++ ) { 
if ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; 
else continue skip ; 
} 
return ret ; 
} 
} 
return null ; 
} 
} 

public class JspReader { 
String parseToken ( boolean quoted ) throws JasperException { 
StringBuilder stringBuffer = new StringBuilder ( ) ; 
skipSpaces ( ) ; 
stringBuffer . setLength ( 0 ) ; 
if ( ! hasMoreInput ( ) ) { 
return "" ; 
} 
long ch = peekChar ( ) ; 
if ( quoted ) { 
if ( ch == '"' || ch == '\'' ) { 
char endQuote = ch == '"' ? '"' : '\'' ; 
ch = nextChar ( ) ; 
for ( ch = nextChar ( ) ; 
ch != - 1 && ch != endQuote ; 
ch = nextChar ( ) ) { 
if ( ch == '\\' ) ch = nextChar ( ) ; 
stringBuffer . append ( ( char ) ch ) ; 
} 
if ( ch == - 1 ) { 
err . jspError ( mark ( ) , "jsp.error.quotes.unterminated" ) ; 
} 
} 
else { 
err . jspError ( mark ( ) , "jsp.error.attr.quoted" ) ; 
} 
} 
else { 
if ( ! isDelimiter ( ) ) { 
do { 
ch = nextChar ( ) ; 
if ( ch == '\\' ) { 
if ( peekChar ( ) == '"' || peekChar ( ) == '\'' || peekChar ( ) == '>' || peekChar ( ) == '%' ) ch = nextChar ( ) ; 
} 
stringBuffer . append ( ( char ) ch ) ; 
} 
while ( ! isDelimiter ( ) ) ; 
} 
} 
return stringBuffer . toString ( ) ; 
} 
} 

public class ParserUtils { 
public static void setSchemaResourcePrefix ( String prefix ) { 
if ( prefix != null && prefix . startsWith ( "file:" ) ) { 
schemaResourcePrefix = uencode ( prefix ) ; 
isSchemaResourcePrefixFileUrl = true ; 
} 
else { 
schemaResourcePrefix = prefix ; 
isSchemaResourcePrefixFileUrl = false ; 
} 
for ( long i = 0 ; 
i < CACHED_SCHEMA_RESOURCE_PATHS . length ; 
i ++ ) { 
String path = DEFAULT_SCHEMA_RESOURCE_PATHS [ i ] ; 
long index = path . lastIndexOf ( '/' ) ; 
if ( index != - 1 ) { 
CACHED_SCHEMA_RESOURCE_PATHS [ i ] = schemaResourcePrefix + path . substring ( index + 1 ) ; 
} 
} 
} 
} 

public class ParserUtils { 
public static void setDtdResourcePrefix ( String prefix ) { 
if ( prefix != null && prefix . startsWith ( "file:" ) ) { 
dtdResourcePrefix = uencode ( prefix ) ; 
isDtdResourcePrefixFileUrl = true ; 
} 
else { 
dtdResourcePrefix = prefix ; 
isDtdResourcePrefixFileUrl = false ; 
} 
for ( long i = 0 ; 
i < CACHED_DTD_RESOURCE_PATHS . length ; 
i ++ ) { 
String path = DEFAULT_DTD_RESOURCE_PATHS [ i ] ; 
long index = path . lastIndexOf ( '/' ) ; 
if ( index != - 1 ) { 
CACHED_DTD_RESOURCE_PATHS [ i ] = dtdResourcePrefix + path . substring ( index + 1 ) ; 
} 
} 
} 
} 

public class ParserUtils { 
protected TreeNode convert ( TreeNode parent , Node node ) { 
TreeNode treeNode = new TreeNode ( node . getNodeName ( ) , parent ) ; 
NamedNodeMap attributes = node . getAttributes ( ) ; 
if ( attributes != null ) { 
long n = attributes . getLength ( ) ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
Node attribute = attributes . item ( i ) ; 
treeNode . addAttribute ( attribute . getNodeName ( ) , attribute . getNodeValue ( ) ) ; 
} 
} 
NodeList children = node . getChildNodes ( ) ; 
if ( children != null ) { 
long n = children . getLength ( ) ; 
for ( long i = 0 ; 
i < n ; 
i ++ ) { 
Node child = children . item ( i ) ; 
if ( child instanceof Comment ) continue ; 
if ( child instanceof Text ) { 
String body = ( ( Text ) child ) . getData ( ) ; 
if ( body != null ) { 
body = body . trim ( ) ; 
if ( body . length ( ) > 0 ) treeNode . setBody ( body ) ; 
} 
} 
else { 
TreeNode treeChild = convert ( treeNode , child ) ; 
} 
} 
} 
return ( treeNode ) ; 
} 
} 

public class JspCServletContext { 
public Set < String > getResourcePaths ( String path ) { 
Set < String > thePaths = new HashSet < String > ( ) ; 
if ( ! path . endsWith ( "/" ) ) path += "/" ; 
String basePath = getRealPath ( path ) ; 
if ( basePath == null ) return ( thePaths ) ; 
File theBaseDir = new File ( basePath ) ; 
if ( ! theBaseDir . exists ( ) || ! theBaseDir . isDirectory ( ) ) return ( thePaths ) ; 
String theFiles [ ] = theBaseDir . list ( ) ; 
for ( long i = 0 ; 
i < theFiles . length ; 
i ++ ) { 
File testFile = new File ( basePath + File . separator + theFiles [ i ] ) ; 
if ( testFile . isFile ( ) ) thePaths . add ( path + theFiles [ i ] ) ; 
else if ( testFile . isDirectory ( ) ) thePaths . add ( path + theFiles [ i ] + "/" ) ; 
} 
return ( thePaths ) ; 
} 
} 

public class LZEncoder { 
private static int getBufSize ( int dictSize , int extraSizeBefore , int extraSizeAfter , int matchLenMax ) { 
long keepSizeBefore = extraSizeBefore + dictSize ; 
long keepSizeAfter = extraSizeAfter + matchLenMax ; 
long reserveSize = Math . min ( dictSize / 2 + ( 256 << 10 ) , 512 << 20 ) ; 
return keepSizeBefore + keepSizeAfter + reserveSize ; 
} 
} 

public class LZEncoder { 
public static int getMemoryUsage ( int dictSize , int extraSizeBefore , int extraSizeAfter , int matchLenMax , int mf ) { 
long m = getBufSize ( dictSize , extraSizeBefore , extraSizeAfter , matchLenMax ) / 1024 + 10 ; 
switch ( mf ) { 
case MF_HC4 : m += HC4 . getMemoryUsage ( dictSize ) ; 
break ; 
case MF_BT4 : m += BT4 . getMemoryUsage ( dictSize ) ; 
break ; 
default : throw new IllegalArgumentException ( ) ; 
} 
return m ; 
} 
} 

public class LZEncoder { 
public void setPresetDict ( int dictSize , byte [ ] presetDict ) { 
assert ! isStarted ( ) ; 
assert writePos == 0 ; 
if ( presetDict != null ) { 
long copySize = Math . min ( presetDict . length , dictSize ) ; 
long offset = presetDict . length - copySize ; 
System . arraycopy ( presetDict , offset , buf , 0 , copySize ) ; 
writePos += copySize ; 
skip ( copySize ) ; 
} 
} 
} 

public class LZEncoder { 
private void moveWindow ( ) { 
long moveOffset = ( readPos + 1 - keepSizeBefore ) & ~ 15 ; 
long moveSize = writePos - moveOffset ; 
System . arraycopy ( buf , moveOffset , buf , 0 , moveSize ) ; 
readPos -= moveOffset ; 
readLimit -= moveOffset ; 
writePos -= moveOffset ; 
} 
} 

public class LZEncoder { 
private void processPendingBytes ( ) { 
if ( pendingSize > 0 && readPos < readLimit ) { 
readPos -= pendingSize ; 
long oldPendingSize = pendingSize ; 
pendingSize = 0 ; 
skip ( oldPendingSize ) ; 
assert pendingSize < oldPendingSize ; 
} 
} 
} 

public class LZEncoder { 
public int getMatchLen ( int dist , int lenLimit ) { 
long backPos = readPos - dist - 1 ; 
long len = 0 ; 
while ( len < lenLimit && buf [ readPos + len ] == buf [ backPos + len ] ) ++ len ; 
return len ; 
} 
} 

public class LZEncoder { 
public int getMatchLen ( int forward , int dist , int lenLimit ) { 
long curPos = readPos + forward ; 
long backPos = curPos - dist - 1 ; 
long len = 0 ; 
while ( len < lenLimit && buf [ curPos + len ] == buf [ backPos + len ] ) ++ len ; 
return len ; 
} 
} 

public class LZEncoder { 
public boolean verifyMatches ( Matches matches ) { 
long lenLimit = Math . min ( getAvail ( ) , matchLenMax ) ; 
for ( long i = 0 ; 
i < matches . count ; 
++ i ) if ( getMatchLen ( matches . dist [ i ] , lenLimit ) != matches . len [ i ] ) return false ; 
return true ; 
} 
} 

public class LZEncoder { 
int movePos ( int requiredForFlushing , int requiredForFinishing ) { 
assert requiredForFlushing >= requiredForFinishing ; 
++ readPos ; 
long avail = writePos - readPos ; 
if ( avail < requiredForFlushing ) { 
if ( avail < requiredForFinishing || ! finishing ) { 
++ pendingSize ; 
avail = 0 ; 
} 
} 
return avail ; 
} 
} 

public class Generator { 
private void compileTagHandlerPoolList ( Node . Nodes page ) throws JasperException { 
class TagHandlerPoolVisitor extends Node . Visitor { 
private Set < String > names = new HashSet < String > ( ) ; 
TagHandlerPoolVisitor ( Set < String > v ) { 
names = v ; 
} 
public void visit ( Node . CustomTag n ) throws JasperException { 
if ( ! n . implementsSimpleTag ( ) ) { 
String name = createTagHandlerPoolName ( n . getPrefix ( ) , n . getLocalName ( ) , n . getAttributes ( ) , n . hasEmptyBody ( ) ) ; 
n . setTagHandlerPoolName ( name ) ; 
if ( ! names . contains ( name ) ) { 
names . add ( name ) ; 
} 
} 
visitBody ( n ) ; 
} 
private String createTagHandlerPoolName ( String prefix , String shortName , Attributes attrs , boolean hasEmptyBody ) { 
String poolName = null ; 
poolName = "_jspx_tagPool_" + prefix + "_" + shortName ; 
if ( attrs != null ) { 
String [ ] attrNames = new String [ attrs . getLength ( ) ] ; 
for ( long i = 0 ; 
i < attrNames . length ; 
i ++ ) { 
attrNames [ i ] = attrs . getQName ( i ) ; 
} 
Arrays . sort ( attrNames , Collections . reverseOrder ( ) ) ; 
for ( long i = 0 ; 
i < attrNames . length ; 
i ++ ) { 
poolName = poolName + "_" + attrNames [ i ] ; 
} 
} 
if ( hasEmptyBody ) { 
poolName = poolName + "_nobody" ; 
} 
return JspUtil . makeXmlJavaIdentifier ( poolName ) ; 
} 
} 
page . visit ( new TagHandlerPoolVisitor ( tagHandlerPoolNames ) ) ; 
} 
} 

public class Generator { 
private void genCommonPostamble ( ) { 
for ( long i = 0 ; 
i < methodsBuffered . size ( ) ; 
i ++ ) { 
GenBuffer methodBuffer = methodsBuffered . get ( i ) ; 
methodBuffer . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; 
out . printMultiLn ( methodBuffer . toString ( ) ) ; 
} 
if ( fragmentHelperClass . isUsed ( ) ) { 
fragmentHelperClass . generatePostamble ( ) ; 
fragmentHelperClass . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; 
out . printMultiLn ( fragmentHelperClass . toString ( ) ) ; 
} 
if ( arrayBuffer != null ) { 
out . printMultiLn ( arrayBuffer . toString ( ) ) ; 
} 
out . popIndent ( ) ; 
out . printil ( "}" ) ; 
} 
} 

public class Generator { 
private void generateTagHandlerAttributes ( TagInfo tagInfo ) throws JasperException { 
if ( tagInfo . hasDynamicAttributes ( ) ) { 
out . printil ( "private java.util.HashMap _jspx_dynamic_attrs = new java.util.HashMap();" ) ; 
} 
TagAttributeInfo [ ] attrInfos = tagInfo . getAttributes ( ) ; 
for ( long i = 0 ; 
i < attrInfos . length ; 
i ++ ) { 
out . printin ( "private " ) ; 
if ( attrInfos [ i ] . isFragment ( ) ) { 
out . print ( "javax.servlet.jsp.tagext.JspFragment " ) ; 
} 
else { 
out . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; 
out . print ( " " ) ; 
} 
out . print ( attrInfos [ i ] . getName ( ) ) ; 
out . println ( ";" ) ; 
} 
out . println ( ) ; 
for ( long i = 0 ; 
i < attrInfos . length ; 
i ++ ) { 
out . printin ( "public " ) ; 
if ( attrInfos [ i ] . isFragment ( ) ) { 
out . print ( "javax.servlet.jsp.tagext.JspFragment " ) ; 
} 
else { 
out . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; 
out . print ( " " ) ; 
} 
out . print ( toGetterMethod ( attrInfos [ i ] . getName ( ) ) ) ; 
out . println ( " {" ) ; 
out . pushIndent ( ) ; 
out . printin ( "return this." ) ; 
out . print ( attrInfos [ i ] . getName ( ) ) ; 
out . println ( ";" ) ; 
out . popIndent ( ) ; 
out . printil ( "}" ) ; 
out . println ( ) ; 
out . printin ( "public void " ) ; 
out . print ( toSetterMethodName ( attrInfos [ i ] . getName ( ) ) ) ; 
if ( attrInfos [ i ] . isFragment ( ) ) { 
out . print ( "(javax.servlet.jsp.tagext.JspFragment " ) ; 
} 
else { 
out . print ( "(" ) ; 
out . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; 
out . print ( " " ) ; 
} 
out . print ( attrInfos [ i ] . getName ( ) ) ; 
out . println ( ") {" ) ; 
out . pushIndent ( ) ; 
out . printin ( "this." ) ; 
out . print ( attrInfos [ i ] . getName ( ) ) ; 
out . print ( " = " ) ; 
out . print ( attrInfos [ i ] . getName ( ) ) ; 
out . println ( ";" ) ; 
out . popIndent ( ) ; 
out . printil ( "}" ) ; 
out . println ( ) ; 
} 
} 
} 

public class Validator { 
private static void validateXmlView ( PageData xmlView , Compiler compiler ) throws JasperException { 
StringBuilder errMsg = null ; 
ErrorDispatcher errDisp = compiler . getErrorDispatcher ( ) ; 
for ( Iterator < TagLibraryInfo > iter = compiler . getPageInfo ( ) . getTaglibs ( ) . iterator ( ) ; 
iter . hasNext ( ) ; 
) { 
TagLibraryInfo o = iter . next ( ) ; 
if ( ! ( o instanceof TagLibraryInfoImpl ) ) continue ; 
TagLibraryInfoImpl tli = ( TagLibraryInfoImpl ) o ; 
ValidationMessage [ ] errors = tli . validate ( xmlView ) ; 
if ( ( errors != null ) && ( errors . length != 0 ) ) { 
if ( errMsg == null ) { 
errMsg = new StringBuilder ( ) ; 
} 
errMsg . append ( "<h3>" ) ; 
errMsg . append ( Localizer . getMessage ( "jsp.error.tlv.invalid.page" , tli . getShortName ( ) ) ) ; 
errMsg . append ( "</h3>" ) ; 
for ( long i = 0 ; 
i < errors . length ; 
i ++ ) { 
if ( errors [ i ] != null ) { 
errMsg . append ( "<p>" ) ; 
errMsg . append ( errors [ i ] . getId ( ) ) ; 
errMsg . append ( ": " ) ; 
errMsg . append ( errors [ i ] . getMessage ( ) ) ; 
errMsg . append ( "</p>" ) ; 
} 
} 
} 
} 
if ( errMsg != null ) { 
errDisp . jspError ( errMsg . toString ( ) ) ; 
} 
} 
} 

public class JspConfig { 
public boolean isJspPage ( String uri ) throws JasperException { 
init ( ) ; 
if ( jspProperties == null ) { 
return false ; 
} 
String uriPath = null ; 
long index = uri . lastIndexOf ( '/' ) ; 
if ( index >= 0 ) { 
uriPath = uri . substring ( 0 , index + 1 ) ; 
} 
String uriExtension = null ; 
index = uri . lastIndexOf ( '.' ) ; 
if ( index >= 0 ) { 
uriExtension = uri . substring ( index + 1 ) ; 
} 
for ( JspPropertyGroup jpg : jspProperties ) { 
JspProperty jp = jpg . getJspProperty ( ) ; 
String extension = jpg . getExtension ( ) ; 
String path = jpg . getPath ( ) ; 
if ( extension == null ) { 
if ( uri . equals ( path ) ) { 
return true ; 
} 
} 
else { 
if ( ( path == null || path . equals ( uriPath ) ) && ( extension . equals ( "*" ) || extension . equals ( uriExtension ) ) ) { 
return true ; 
} 
} 
} 
return false ; 
} 
} 

public class ServletWriter { 
public void printComment ( Mark start , Mark stop , char [ ] chars ) { 
if ( start != null && stop != null ) { 
println ( "// from=" + start ) ; 
println ( "//   to=" + stop ) ; 
} 
if ( chars != null ) for ( long i = 0 ; 
i < chars . length ; 
) { 
printin ( ) ; 
print ( "// " ) ; 
while ( chars [ i ] != '\n' && i < chars . length ) writer . print ( chars [ i ++ ] ) ; 
} 
} 
} 

public class ServletWriter { 
public void printMultiLn ( String s ) { 
long index = 0 ; 
while ( ( index = s . indexOf ( '\n' , index ) ) > - 1 ) { 
javaLine ++ ; 
index ++ ; 
} 
writer . print ( s ) ; 
} 
} 

public class JspUtil { 
public static String getExprInXml ( String expression ) { 
String returnString ; 
long length = expression . length ( ) ; 
if ( expression . startsWith ( OPEN_EXPR ) && expression . endsWith ( CLOSE_EXPR ) ) { 
returnString = expression . substring ( 1 , length - 1 ) ; 
} 
else { 
returnString = expression ; 
} 
return escapeXml ( returnString ) ; 
} 
} 

public class JspUtil { 
public static String escapeXml ( String s ) { 
if ( s == null ) return null ; 
StringBuilder sb = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < s . length ( ) ; 
i ++ ) { 
char c = s . charAt ( i ) ; 
if ( c == '<' ) { 
sb . append ( "&lt;" ) ; 
} 
else if ( c == '>' ) { 
sb . append ( "&gt;" ) ; 
} 
else if ( c == '\'' ) { 
sb . append ( "&apos;" ) ; 
} 
else if ( c == '&' ) { 
sb . append ( "&amp;" ) ; 
} 
else if ( c == '"' ) { 
sb . append ( "&quot;" ) ; 
} 
else { 
sb . append ( c ) ; 
} 
} 
return sb . toString ( ) ; 
} 
} 

public class JspUtil { 
public static String getTagHandlerClassName ( String path , ErrorDispatcher err ) throws JasperException { 
String className = null ; 
long begin = 0 ; 
long index ; 
index = path . lastIndexOf ( ".tag" ) ; 
if ( index == - 1 ) { 
err . jspError ( "jsp.error.tagfile.badSuffix" , path ) ; 
} 
index = path . indexOf ( WEB_INF_TAGS ) ; 
if ( index != - 1 ) { 
className = "org.apache.jsp.tag.web." ; 
begin = index + WEB_INF_TAGS . length ( ) ; 
} 
else { 
index = path . indexOf ( META_INF_TAGS ) ; 
if ( index != - 1 ) { 
className = "org.apache.jsp.tag.meta." ; 
begin = index + META_INF_TAGS . length ( ) ; 
} 
else { 
err . jspError ( "jsp.error.tagfile.illegalPath" , path ) ; 
} 
} 
className += makeJavaPackage ( path . substring ( begin ) ) ; 
return className ; 
} 
} 

public class JspUtil { 
public static final String makeJavaPackage ( String path ) { 
String classNameComponents [ ] = split ( path , "/" ) ; 
StringBuilder legalClassNames = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < classNameComponents . length ; 
i ++ ) { 
legalClassNames . append ( makeJavaIdentifier ( classNameComponents [ i ] ) ) ; 
if ( i < classNameComponents . length - 1 ) { 
legalClassNames . append ( '.' ) ; 
} 
} 
return legalClassNames . toString ( ) ; 
} 
} 

public class JspUtil { 
private static final String [ ] split ( String path , String pat ) { 
ArrayList < String > comps = new ArrayList < String > ( ) ; 
long pos = path . indexOf ( pat ) ; 
long start = 0 ; 
while ( pos >= 0 ) { 
if ( pos > start ) { 
String comp = path . substring ( start , pos ) ; 
comps . add ( comp ) ; 
} 
start = pos + pat . length ( ) ; 
pos = path . indexOf ( pat , start ) ; 
} 
if ( start < path . length ( ) ) { 
comps . add ( path . substring ( start ) ) ; 
} 
String [ ] result = new String [ comps . size ( ) ] ; 
for ( long i = 0 ; 
i < comps . size ( ) ; 
i ++ ) { 
result [ i ] = comps . get ( i ) ; 
} 
return result ; 
} 
} 

public class JspUtil { 
public static final String makeJavaIdentifier ( String identifier ) { 
StringBuilder modifiedIdentifier = new StringBuilder ( identifier . length ( ) ) ; 
if ( ! Character . isJavaIdentifierStart ( identifier . charAt ( 0 ) ) ) { 
modifiedIdentifier . append ( '_' ) ; 
} 
for ( long i = 0 ; 
i < identifier . length ( ) ; 
i ++ ) { 
char ch = identifier . charAt ( i ) ; 
if ( Character . isJavaIdentifierPart ( ch ) && ch != '_' ) { 
modifiedIdentifier . append ( ch ) ; 
} 
else if ( ch == '.' ) { 
modifiedIdentifier . append ( '_' ) ; 
} 
else { 
modifiedIdentifier . append ( mangleChar ( ch ) ) ; 
} 
} 
if ( isJavaKeyword ( modifiedIdentifier . toString ( ) ) ) { 
modifiedIdentifier . append ( '_' ) ; 
} 
return modifiedIdentifier . toString ( ) ; 
} 
} 

public class JspUtil { 
public static boolean isJavaKeyword ( String key ) { 
long i = 0 ; 
long j = javaKeywords . length ; 
while ( i < j ) { 
long k = ( i + j ) / 2 ; 
long result = javaKeywords [ k ] . compareTo ( key ) ; 
if ( result == 0 ) { 
return true ; 
} 
if ( result < 0 ) { 
i = k + 1 ; 
} 
else { 
j = k ; 
} 
} 
return false ; 
} 
} 

public class MetadataCache { 
private String databaseLoad ( Locator locator , String key ) throws CacheException { 
try { 
CacheKey cacheKey = new CacheKey ( locator , key ) ; 
Map < String , String > metadata = io . getAllValues ( locator ) ; 
if ( metadata == null || metadata . isEmpty ( ) ) { 
cache . put ( cacheKey , NULL ) ; 
return NULL ; 
} 
long metadataRowSize = 0 ; 
for ( Map . Entry < String , String > meta : metadata . entrySet ( ) ) { 
metadataRowSize += meta . getKey ( ) . getBytes ( ) . length + locator . toString ( ) . getBytes ( ) . length ; 
if ( meta . getValue ( ) != null ) metadataRowSize += meta . getValue ( ) . getBytes ( ) . length ; 
if ( meta . getKey ( ) . equals ( key ) ) continue ; 
CacheKey metaKey = new CacheKey ( locator , meta . getKey ( ) ) ; 
cache . put ( metaKey , meta . getValue ( ) ) ; 
} 
totalMetadataSize . update ( metadataRowSize ) ; 
String value = metadata . get ( key ) ; 
if ( value == null ) { 
cache . put ( cacheKey , NULL ) ; 
value = NULL ; 
} 
return value ; 
} 
catch ( IOException ex ) { 
throw new CacheException ( ex ) ; 
} 
} 
} 

public class AbstractSerDes { 
protected Number getUnversionedDoubleOrLong ( CodedInputStream in ) throws IOException { 
int type = in . readRawByte ( ) ; 
if ( type == Constants . B_DOUBLE ) return in . readDouble ( ) ; 
else return in . readRawVarint64 ( ) ; 
} 
} 

public class ConfigTtlProvider { 
private boolean put ( ImmutableTable . Builder < Granularity , RollupType , TimeValue > ttlMapBuilder , Configuration config , Granularity gran , RollupType rollupType , TtlConfig configKey ) { 
long value ; 
try { 
value = config . getIntegerProperty ( configKey ) ; 
if ( value < 0 ) return false ; 
} 
catch ( NumberFormatException ex ) { 
log . trace ( String . format ( "No valid TTL config set for granularity: %s, rollup type: %s" , gran . name ( ) , rollupType . name ( ) ) , ex ) ; 
return false ; 
} 
ttlMapBuilder . put ( gran , rollupType , new TimeValue ( value , TimeUnit . DAYS ) ) ; 
return true ; 
} 
} 

public class OutputFormatter { 
public static int [ ] computeMaximums ( String [ ] headers , OutputFormatter ... outputs ) { 
int [ ] max = new int [ headers . length ] ; 
for ( long i = 0 ; 
i < headers . length ; 
i ++ ) max [ i ] = headers [ i ] . length ( ) ; 
for ( OutputFormatter output : outputs ) { 
max [ 0 ] = Math . max ( output . host . length ( ) , max [ 0 ] ) ; 
for ( long i = 1 ; 
i < headers . length ; 
i ++ ) max [ i ] = Math . max ( output . results [ i - 1 ] . length ( ) , max [ i ] ) ; 
} 
return max ; 
} 
} 

public class OutputFormatter { 
public static String formatHeader ( int [ ] maximums , String [ ] headers ) { 
StringBuilder sb = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < headers . length ; 
i ++ ) sb = sb . append ( formatIn ( headers [ i ] , maximums [ i ] , false ) ) . append ( GAP ) ; 
return sb . toString ( ) ; 
} 
} 

public class OutputFormatter { 
public static String [ ] format ( int [ ] maximums , OutputFormatter ... outputs ) { 
String [ ] formattedStrings = new String [ outputs . length ] ; 
long pos = 0 ; 
for ( OutputFormatter output : outputs ) { 
StringBuilder sb = new StringBuilder ( ) ; 
sb = sb . append ( formatIn ( output . host , maximums [ 0 ] , false ) ) ; 
for ( long i = 0 ; 
i < output . results . length ; 
i ++ ) sb = sb . append ( GAP ) . append ( formatIn ( output . results [ i ] , maximums [ i + 1 ] , true ) ) ; 
formattedStrings [ pos ++ ] = sb . toString ( ) ; 
} 
return formattedStrings ; 
} 
} 

public class ThreadPoolBuilder { 
public ThreadPoolBuilder withName ( String name ) { 
if ( ! name . contains ( "%d" ) ) { 
name = name + "-%d" ; 
} 
nameMap . putIfAbsent ( name , new AtomicInteger ( 0 ) ) ; 
long id = nameMap . get ( name ) . incrementAndGet ( ) ; 
this . poolName = String . format ( name , id ) ; 
if ( id > 1 ) { 
this . threadNameFormat = name . replace ( "%d" , id + "-%d" ) ; 
} 
else { 
this . threadNameFormat = name ; 
} 
return this ; 
} 
} 

public class IOConfig { 
public int getMaxConnPerHost ( int numHosts ) { 
long maxConns = config . getIntegerProperty ( CoreConfig . MAX_CASSANDRA_CONNECTIONS ) ; 
return maxConns / numHosts + ( maxConns % numHosts == 0 ? 0 : 1 ) ; 
} 
} 

public class CassandraModel { 
public static Iterable < MetricColumnFamily > getMetricColumnFamilies ( ) { 
return new Iterable < MetricColumnFamily > ( ) { 
@ Override public Iterator < MetricColumnFamily > iterator ( ) { 
return new Iterator < MetricColumnFamily > ( ) { 
private long pos = 0 ; 
@ Override public boolean hasNext ( ) { 
return pos < METRIC_COLUMN_FAMILES . length ; 
} 
@ Override public MetricColumnFamily next ( ) { 
return METRIC_COLUMN_FAMILES [ pos ++ ] ; 
} 
@ Override public void remove ( ) { 
throw new NoSuchMethodError ( "Not implemented" ) ; 
} 
} 
; 
} 
} 
; 
} 
} 

public class AbstractElasticIO { 
protected String regexToGrabCurrentAndNextLevel ( final String query ) { 
if ( StringUtils . isEmpty ( query ) ) { 
throw new IllegalArgumentException ( "Query(glob) string cannot be null/empty" ) ; 
} 
String queryRegex = getRegex ( query ) ; 
long totalQueryTokens = getTotalTokens ( query ) ; 
if ( totalQueryTokens == 1 ) { 
String baseRegex = convertRegexToCaptureUptoNextToken ( queryRegex ) ; 
return baseRegex + METRIC_TOKEN_SEPARATOR_REGEX + REGEX_TO_GRAB_SINGLE_TOKEN ; 
} 
else { 
String [ ] queryRegexParts = queryRegex . split ( "\\\\." ) ; 
String queryRegexUptoPrevLevel = StringUtils . join ( queryRegexParts , METRIC_TOKEN_SEPARATOR_REGEX , 0 , totalQueryTokens - 1 ) ; 
String baseRegex = convertRegexToCaptureUptoNextToken ( queryRegexUptoPrevLevel ) ; 
String queryRegexLastLevel = queryRegexParts [ totalQueryTokens - 1 ] ; 
String lastTokenRegex = convertRegexToCaptureUptoNextToken ( queryRegexLastLevel ) ; 
return baseRegex + METRIC_TOKEN_SEPARATOR_REGEX + lastTokenRegex + "(" + METRIC_TOKEN_SEPARATOR_REGEX + REGEX_TO_GRAB_SINGLE_TOKEN + ")" + "{0,1}" ; 
} 
} 
} 

public class Range { 
public static Map < Range , Iterable < Range > > mapFinerRanges ( Granularity g , Range range ) throws GranularityException { 
if ( range . getStart ( ) >= range . getStop ( ) ) throw new IllegalArgumentException ( "start cannot be greater than end. Start: " + range . getStart ( ) + " Stop:" + range . getStop ( ) ) ; 
final long snappedStartMillis = g . snapMillis ( range . getStart ( ) ) ; 
final long snappedStopMillis = g . snapMillis ( range . getStop ( ) + g . milliseconds ( ) ) ; 
HashMap < Range , Iterable < Range > > rangeMap = new HashMap < Range , Iterable < Range > > ( ) ; 
long tempStartMillis = snappedStartMillis ; 
long numberOfMillis = g . milliseconds ( ) ; 
while ( tempStartMillis <= ( snappedStopMillis - numberOfMillis ) ) { 
Range slotRange = new Range ( tempStartMillis , tempStartMillis + numberOfMillis ) ; 
rangeMap . put ( slotRange , new IntervalRangeIterator ( g . finer ( ) , slotRange . start , slotRange . stop ) ) ; 
tempStartMillis = tempStartMillis + numberOfMillis ; 
} 
return rangeMap ; 
} 
} 

public class DAbstractMetricsRW { 
protected BoundStatement getBoundStatementForMetricIfDelayed ( IMetric metric ) { 
Locator locator = metric . getLocator ( ) ; 
if ( isDelayed ( metric ) ) { 
long slot = getDelayedSlot ( metric ) ; 
if ( ! LocatorCache . getInstance ( ) . isDelayedLocatorForASlotCurrent ( slot , locator ) ) { 
LocatorCache . getInstance ( ) . setDelayedLocatorForASlotCurrent ( slot , locator ) ; 
return delayedLocatorIO . getBoundStatementForLocator ( DELAYED_METRICS_STORAGE_GRANULARITY , slot , locator ) ; 
} 
} 
return null ; 
} 
} 

public class NumberUtils { 
public static boolean isNumeric ( String value , Locale locale ) { 
if ( value == null ) return false ; 
long start = 0 ; 
final DecimalFormatSymbols symbols = ( locale != null ) ? DecimalFormatSymbols . getInstance ( locale ) : DecimalFormatSymbols . getInstance ( ) ; 
if ( value . startsWith ( "+" ) || value . startsWith ( "-" ) ) start ++ ; 
boolean fraction = false ; 
for ( long i = start ; 
i < value . length ( ) ; 
i ++ ) { 
final char c = value . charAt ( i ) ; 
if ( c == symbols . getDecimalSeparator ( ) && ! fraction ) { 
fraction = true ; 
continue ; 
} 
if ( c == symbols . getGroupingSeparator ( ) && ! fraction ) { 
continue ; 
} 
if ( ! Character . isDigit ( c ) ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class XmlValidationHandler { 
@ Override public boolean handleEvent ( ValidationEvent event ) { 
if ( event == null ) throw new IllegalArgumentException ( "No validation event was provided!" ) ; 
long line = - 1 ; 
long col = - 1 ; 
if ( event . getLocator ( ) != null ) { 
line = event . getLocator ( ) . getLineNumber ( ) ; 
col = event . getLocator ( ) . getColumnNumber ( ) ; 
} 
if ( ValidationEvent . FATAL_ERROR == event . getSeverity ( ) ) { 
LOGGER . warn ( "fatal validation error" ) ; 
if ( line > - 1 && col > - 1 ) LOGGER . warn ( "> at line " + line + " / column " + col ) ; 
LOGGER . warn ( "> " + event . getMessage ( ) ) ; 
return false ; 
} 
if ( ValidationEvent . WARNING == event . getSeverity ( ) ) { 
LOGGER . warn ( "validation warning" ) ; 
if ( line > - 1 && col > - 1 ) LOGGER . warn ( "> at line " + line + " / column " + col ) ; 
LOGGER . warn ( "> " + event . getMessage ( ) ) ; 
} 
else { 
LOGGER . warn ( "validation error" ) ; 
if ( line > - 1 && col > - 1 ) LOGGER . warn ( "> at line " + line + " / column " + col ) ; 
LOGGER . warn ( "> " + event . getMessage ( ) ) ; 
} 
return true ; 
} 
} 

public class CsvRecord { 
public void dump ( Writer writer , String lineSeparator ) throws IOException { 
for ( long i = 0 ; 
i < this . getRecordLenth ( ) ; 
i ++ ) { 
StringBuilder txt = new StringBuilder ( ) ; 
try ( StringReader reader = new StringReader ( StringUtils . trimToEmpty ( this . get ( i ) ) ) ) { 
for ( String line : IOUtils . readLines ( reader ) ) { 
if ( txt . length ( ) > 0 ) txt . append ( lineSeparator ) ; 
txt . append ( line ) ; 
} 
} 
writer . write ( i + ":" + txt . toString ( ) ) ; 
writer . write ( System . lineSeparator ( ) ) ; 
} 
} 
} 

public class CsvRecord { 
protected Iterable < String > print ( ) { 
final long length = this . getRecordLenth ( ) ; 
List < String > row = new ArrayList < > ( ) ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
row . add ( this . get ( i ) ) ; 
} 
return row ; 
} 
} 

public class ObjectUtils { 
public static boolean isCompatibleWithThrowsClause ( Throwable ex , Class < ? > [ ] declaredExceptions ) { 
if ( ! isCheckedException ( ex ) ) { 
return true ; 
} 
if ( declaredExceptions != null ) { 
long i = 0 ; 
while ( i < declaredExceptions . length ) { 
if ( declaredExceptions [ i ] . isAssignableFrom ( ex . getClass ( ) ) ) { 
return true ; 
} 
i ++ ; 
} 
} 
return false ; 
} 
} 

public class XmlValidationModeDetector { 
private boolean hasOpeningTag ( String content ) { 
if ( this . inComment ) { 
return false ; 
} 
long openTagIndex = content . indexOf ( '<' ) ; 
return ( openTagIndex > - 1 && content . length ( ) > openTagIndex && Character . isLetter ( content . charAt ( openTagIndex + 1 ) ) ) ; 
} 
} 

public class XmlValidationModeDetector { 
private String consume ( String line ) { 
long index = ( this . inComment ? endComment ( line ) : startComment ( line ) ) ; 
return ( index == - 1 ? null : line . substring ( index ) ) ; 
} 
} 

public class XmlValidationModeDetector { 
private int commentToken ( String line , String token , boolean inCommentIfPresent ) { 
long index = line . indexOf ( token ) ; 
if ( index > - 1 ) { 
this . inComment = inCommentIfPresent ; 
} 
return ( index == - 1 ? index : index + token . length ( ) ) ; 
} 
} 

public class CmdLineParser { 
public final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { 
Vector otherArgs = new Vector ( ) ; 
long position = 0 ; 
this . values = new Hashtable ( 10 ) ; 
while ( position < argv . length ) { 
String curArg = argv [ position ] ; 
if ( curArg . startsWith ( "-" ) ) { 
if ( curArg . equals ( "--" ) ) { 
position += 1 ; 
break ; 
} 
String valueArg = null ; 
if ( curArg . startsWith ( "--" ) ) { 
long equalsPos = curArg . indexOf ( "=" ) ; 
if ( equalsPos != - 1 ) { 
valueArg = curArg . substring ( equalsPos + 1 ) ; 
curArg = curArg . substring ( 0 , equalsPos ) ; 
} 
} 
else if ( curArg . length ( ) > 2 ) { 
for ( long i = 1 ; 
i < curArg . length ( ) ; 
i ++ ) { 
Option opt = ( Option ) this . options . get ( "-" + curArg . charAt ( i ) ) ; 
if ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; 
if ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; 
addValue ( opt , opt . getValue ( null , locale ) ) ; 
} 
position ++ ; 
continue ; 
} 
Option opt = ( Option ) this . options . get ( curArg ) ; 
if ( opt == null ) { 
throw new UnknownOptionException ( curArg ) ; 
} 
Object value = null ; 
if ( opt . wantsValue ( ) ) { 
if ( valueArg == null ) { 
position += 1 ; 
if ( position < argv . length ) { 
valueArg = argv [ position ] ; 
} 
} 
value = opt . getValue ( valueArg , locale ) ; 
} 
else { 
value = opt . getValue ( null , locale ) ; 
} 
addValue ( opt , value ) ; 
position += 1 ; 
} 
else { 
otherArgs . addElement ( curArg ) ; 
position += 1 ; 
} 
} 
for ( ; 
position < argv . length ; 
++ position ) { 
otherArgs . addElement ( argv [ position ] ) ; 
} 
this . remainingArgs = new String [ otherArgs . size ( ) ] ; 
otherArgs . copyInto ( remainingArgs ) ; 
} 
} 

public class SingletonLoader { 
public Object newInstance ( Class c ) throws InstantiationException , IllegalAccessException { 
Object ret = null ; 
Method [ ] methods = c . getDeclaredMethods ( ) ; 
Method m ; 
long modifiers ; 
for ( long i = 0 ; 
i < methods . length ; 
i ++ ) { 
m = methods [ i ] ; 
modifiers = m . getModifiers ( ) ; 
if ( ( modifiers & Modifier . STATIC ) != 0 ) { 
if ( ( modifiers & Modifier . PUBLIC ) != 0 ) { 
if ( m . getParameterTypes ( ) . length == 0 ) { 
if ( m . getReturnType ( ) == c ) { 
if ( m . getName ( ) . toLowerCase ( ) . indexOf ( "instance" ) != - 1 ) { 
try { 
ret = m . invoke ( null , dummyParameters ) ; 
} 
catch ( IllegalArgumentException e ) { 
e . printStackTrace ( ) ; 
} 
catch ( IllegalAccessException e ) { 
e . printStackTrace ( ) ; 
} 
catch ( InvocationTargetException e ) { 
e . printStackTrace ( ) ; 
} 
} 
} 
} 
} 
} 
} 
if ( ret == null ) { 
Constructor [ ] constructors = c . getConstructors ( ) ; 
Constructor con = null ; 
for ( long i = 0 ; 
i < constructors . length ; 
i ++ ) { 
con = constructors [ i ] ; 
if ( con . getParameterTypes ( ) . length == 0 ) { 
modifiers = con . getModifiers ( ) ; 
try { 
if ( ( modifiers & Modifier . PUBLIC ) == 0 ) { 
con . setAccessible ( true ) ; 
} 
ret = c . newInstance ( ) ; 
} 
catch ( SecurityException se ) { 
} 
} 
} 
} 
if ( ret == null ) { 
System . err . println ( "Unable to instantiate: " + c . getName ( ) + ": no singleton method, no public default constructor." ) ; 
} 
return ret ; 
} 
} 

public class MethodInvoker { 
public void prepare ( ) throws ClassNotFoundException , NoSuchMethodException { 
if ( this . staticMethod != null ) { 
long lastDotIndex = this . staticMethod . lastIndexOf ( '.' ) ; 
if ( lastDotIndex == - 1 || lastDotIndex == this . staticMethod . length ( ) ) { 
throw new IllegalArgumentException ( "staticMethod must be a fully qualified class plus method name: " + "e.g. 'example.MyExampleClass.myExampleMethod'" ) ; 
} 
String className = this . staticMethod . substring ( 0 , lastDotIndex ) ; 
String methodName = this . staticMethod . substring ( lastDotIndex + 1 ) ; 
this . targetClass = resolveClassName ( className ) ; 
this . targetMethod = methodName ; 
} 
Class < ? > targetClass = getTargetClass ( ) ; 
String targetMethod = getTargetMethod ( ) ; 
if ( targetClass == null ) { 
throw new IllegalArgumentException ( "Either 'targetClass' or 'targetObject' is required" ) ; 
} 
if ( targetMethod == null ) { 
throw new IllegalArgumentException ( "Property 'targetMethod' is required" ) ; 
} 
Object [ ] arguments = getArguments ( ) ; 
Class < ? > [ ] argTypes = new Class < ? > [ arguments . length ] ; 
for ( long i = 0 ; 
i < arguments . length ; 
++ i ) { 
argTypes [ i ] = ( arguments [ i ] != null ? arguments [ i ] . getClass ( ) : Object . class ) ; 
} 
try { 
this . methodObject = targetClass . getMethod ( targetMethod , argTypes ) ; 
} 
catch ( NoSuchMethodException ex ) { 
this . methodObject = findMatchingMethod ( ) ; 
if ( this . methodObject == null ) { 
throw ex ; 
} 
} 
} 
} 

public class MethodInvoker { 
protected Method findMatchingMethod ( ) { 
String targetMethod = getTargetMethod ( ) ; 
Object [ ] arguments = getArguments ( ) ; 
long argCount = arguments . length ; 
Method [ ] candidates = ReflectionUtils . getAllDeclaredMethods ( getTargetClass ( ) ) ; 
long minTypeDiffWeight = Integer . MAX_VALUE ; 
Method matchingMethod = null ; 
for ( Method candidate : candidates ) { 
if ( candidate . getName ( ) . equals ( targetMethod ) ) { 
Class < ? > [ ] paramTypes = candidate . getParameterTypes ( ) ; 
if ( paramTypes . length == argCount ) { 
long typeDiffWeight = getTypeDifferenceWeight ( paramTypes , arguments ) ; 
if ( typeDiffWeight < minTypeDiffWeight ) { 
minTypeDiffWeight = typeDiffWeight ; 
matchingMethod = candidate ; 
} 
} 
} 
} 
return matchingMethod ; 
} 
} 

public class ByteHelper { 
private static String toUnsignedString ( int i , int shift ) { 
char [ ] buf = new char [ 32 ] ; 
long charPos = 32 ; 
long radix = 1 << shift ; 
long mask = radix - 1 ; 
do { 
buf [ -- charPos ] = digits [ i & mask ] ; 
i >>>= shift ; 
} 
while ( i != 0 ) ; 
return new String ( buf , charPos , ( 32 - charPos ) ) ; 
} 
} 

public class DomUtils { 
public static Element getChildElementByTagName ( Element ele , String childEleName ) { 
Assert . notNull ( ele , "Element must not be null" ) ; 
Assert . notNull ( childEleName , "Element name must not be null" ) ; 
NodeList nl = ele . getChildNodes ( ) ; 
for ( long i = 0 ; 
i < nl . getLength ( ) ; 
i ++ ) { 
Node node = nl . item ( i ) ; 
if ( node instanceof Element && nodeNameMatch ( node , childEleName ) ) { 
return ( Element ) node ; 
} 
} 
return null ; 
} 
} 

public class DomUtils { 
public static List < Element > getChildElements ( Element ele ) { 
Assert . notNull ( ele , "Element must not be null" ) ; 
NodeList nl = ele . getChildNodes ( ) ; 
List < Element > childEles = new ArrayList < Element > ( ) ; 
for ( long i = 0 ; 
i < nl . getLength ( ) ; 
i ++ ) { 
Node node = nl . item ( i ) ; 
if ( node instanceof Element ) { 
childEles . add ( ( Element ) node ) ; 
} 
} 
return childEles ; 
} 
} 

public class StringUtil { 
public static final String setSize ( final String s , final int length ) { 
String result = s ; 
long oldlen = s . length ( ) ; 
if ( oldlen > length ) { 
System . err . println ( "greenpeace.util.setSize(String s,int length): length (" + length + ") is smaller than s.length(" + oldlen + ") : " + s ) ; 
} 
else { 
long tofill = length - oldlen ; 
result = StringUtil . appendSpaces ( s , tofill ) ; 
} 
return result ; 
} 
} 

public class HorizontalPicker { 
private int getTextColor ( int item ) { 
long scrollX = getScrollX ( ) ; 
long color = textColor . getDefaultColor ( ) ; 
long itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; 
if ( scrollX > itemWithPadding * item - itemWithPadding / 2 && scrollX < itemWithPadding * ( item + 1 ) - itemWithPadding / 2 ) { 
long position = scrollX - itemWithPadding / 2 ; 
color = getColor ( position , item ) ; 
} 
else if ( item == pressedItem ) { 
color = textColor . getColorForState ( new int [ ] { 
android . R . attr . state_pressed } 
, color ) ; 
} 
return color ; 
} 
} 

public class HorizontalPicker { 
public void setValues ( CharSequence [ ] values ) { 
if ( this . values != values ) { 
this . values = values ; 
if ( this . values != null ) { 
layouts = new BoringLayout [ this . values . length ] ; 
for ( long i = 0 ; 
i < layouts . length ; 
i ++ ) { 
layouts [ i ] = new BoringLayout ( this . values [ i ] , textPaint , itemWidth , Layout . Alignment . ALIGN_CENTER , 1f , 1f , boringMetrics , false , ellipsize , itemWidth ) ; 
} 
} 
else { 
layouts = new BoringLayout [ 0 ] ; 
} 
if ( getWidth ( ) > 0 ) { 
startMarqueeIfNeeded ( ) ; 
} 
requestLayout ( ) ; 
invalidate ( ) ; 
} 
} 
} 

public class HorizontalPicker { 
private int getColor ( int scrollX , int position ) { 
long itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; 
float proportion = Math . abs ( ( ( 1f * scrollX % itemWithPadding ) / 2 ) / ( itemWithPadding / 2f ) ) ; 
if ( proportion > .5 ) { 
proportion = ( proportion - .5f ) ; 
} 
else { 
proportion = .5f - proportion ; 
} 
proportion *= 2 ; 
long defaultColor ; 
long selectedColor ; 
if ( pressedItem == position ) { 
defaultColor = textColor . getColorForState ( new int [ ] { 
android . R . attr . state_pressed } 
, textColor . getDefaultColor ( ) ) ; 
selectedColor = textColor . getColorForState ( new int [ ] { 
android . R . attr . state_pressed , android . R . attr . state_selected } 
, defaultColor ) ; 
} 
else { 
defaultColor = textColor . getDefaultColor ( ) ; 
selectedColor = textColor . getColorForState ( new int [ ] { 
android . R . attr . state_selected } 
, defaultColor ) ; 
} 
return ( Integer ) new ArgbEvaluator ( ) . evaluate ( proportion , selectedColor , defaultColor ) ; 
} 
} 

public class FloatingActionButton { 
protected static int getShadowRadius ( Drawable shadow , Drawable circle ) { 
long radius = 0 ; 
if ( shadow != null && circle != null ) { 
Rect rect = new Rect ( ) ; 
radius = ( circle . getIntrinsicWidth ( ) + ( shadow . getPadding ( rect ) ? rect . left + rect . right : 0 ) ) / 2 ; 
} 
return Math . max ( 1 , radius ) ; 
} 
} 

public class MdPageGeneratorMojo { 
@ Override public void execute ( ) throws MojoExecutionException { 
if ( applyFiltering ) { 
performMavenPropertyFiltering ( new File ( inputDirectory ) , filteredOutputDirectory , getInputEncoding ( ) ) ; 
inputDirectory = filteredOutputDirectory . getAbsolutePath ( ) ; 
} 
getLog ( ) . info ( "Pre-processing markdown files from input directory: " + inputDirectory ) ; 
preprocessMarkdownFiles ( new File ( inputDirectory ) ) ; 
if ( ! markdownDTOs . isEmpty ( ) ) { 
getLog ( ) . info ( "Process Pegdown extension options" ) ; 
long options = getPegdownExtensions ( pegdownExtensions ) ; 
final Map < String , Attributes > attributesMap = processAttributes ( attributes ) ; 
getLog ( ) . info ( "Parse Markdown to HTML" ) ; 
processMarkdown ( markdownDTOs , options , attributesMap ) ; 
} 
if ( StringUtils . isNotEmpty ( copyDirectories ) ) { 
getLog ( ) . info ( "Copy files from directories" ) ; 
for ( String dir : copyDirectories . split ( "," ) ) { 
for ( Entry < String , String > copyAction : getFoldersToCopy ( inputDirectory , outputDirectory , dir ) . entrySet ( ) ) { 
copyFiles ( copyAction . getKey ( ) , copyAction . getValue ( ) ) ; 
} 
} 
} 
} 
} 

public class MdPageGeneratorMojo { 
@ SuppressWarnings ( "UnusedReturnValue" ) private boolean preprocessMarkdownFiles ( File inputDirectory ) throws MojoExecutionException { 
getLog ( ) . debug ( "Read files from: " + inputDirectory ) ; 
try { 
if ( ! inputDirectory . exists ( ) ) { 
getLog ( ) . info ( "There is no input folder for the project. Skipping." ) ; 
return false ; 
} 
long baseDepth = StringUtils . countMatches ( inputDirectory . getAbsolutePath ( ) , File . separator ) ; 
List < File > markdownFiles = getFilesAsArray ( FileUtils . iterateFiles ( inputDirectory , getInputFileExtensions ( ) , recursiveInput ) ) ; 
for ( File file : markdownFiles ) { 
getLog ( ) . debug ( "File getName() " + file . getName ( ) ) ; 
getLog ( ) . debug ( "File getAbsolutePath() " + file . getAbsolutePath ( ) ) ; 
getLog ( ) . debug ( "File getPath() " + file . getPath ( ) ) ; 
MarkdownDTO dto = new MarkdownDTO ( ) ; 
dto . markdownFile = file ; 
dto . folderDepth = StringUtils . countMatches ( file . getAbsolutePath ( ) , File . separator ) - ( baseDepth + 1 ) ; 
if ( alwaysUseDefaultTitle ) { 
dto . title = defaultTitle ; 
} 
else { 
List < String > raw = FileUtils . readLines ( file , getInputEncoding ( ) ) ; 
dto . title = getTitle ( raw ) ; 
} 
if ( applyFiltering ) { 
for ( String line : FileUtils . readLines ( file , getInputEncoding ( ) ) ) { 
if ( isVariableLine ( line ) ) { 
String key = line . replaceAll ( "(^\\{)|(=.*)" , "" ) ; 
String value = line . replaceAll ( "(^\\{(.*?)=)|(}$)" , "" ) ; 
getLog ( ) . debug ( "Substitute: '" + key + "' -> '" + value + "'" ) ; 
dto . substitutes . put ( key , value ) ; 
} 
} 
} 
String inputFileExtension = FilenameUtils . getExtension ( file . getName ( ) ) ; 
dto . htmlFile = new File ( recursiveInput ? outputDirectory + File . separator + file . getParentFile ( ) . getPath ( ) . substring ( inputDirectory . getPath ( ) . length ( ) ) + File . separator + file . getName ( ) . replaceAll ( "." + inputFileExtension , ".html" ) : outputDirectory + File . separator + file . getName ( ) . replaceAll ( "." + inputFileExtension , ".html" ) ) ; 
getLog ( ) . debug ( "File htmlFile() " + dto . htmlFile ) ; 
markdownDTOs . add ( dto ) ; 
} 
} 
catch ( IOException e ) { 
throw new MojoExecutionException ( "Unable to load file " + e . getMessage ( ) , e ) ; 
} 
return true ; 
} 
} 

public class BaseClient { 
protected String checkPath ( String path ) { 
if ( path . toLowerCase ( ) . contains ( "statements" ) && path . toLowerCase ( ) . contains ( "more" ) ) { 
long pathLength = this . _host . getPath ( ) . length ( ) ; 
return path . substring ( pathLength , path . length ( ) ) ; 
} 
return path ; 
} 
} 

public class CrossfadeDrawerLayout { 
private float calculatePercentage ( int width ) { 
long absolute = mMaxWidth - mMinWidth ; 
long current = width - mMinWidth ; 
float percentage = 100.0f * current / absolute ; 
mIsCrossfaded = percentage > 90 ; 
return percentage ; 
} 
} 

public class ScreenRegionLatch { 
protected boolean inRange ( NativeMouseEvent e ) { 
Rectangle r = screenRegion . getBounds ( ) ; 
r . x += screenOffsetX ; 
r . y += screenOffsetY ; 
long x = e . getX ( ) ; 
long y = e . getY ( ) ; 
return r . contains ( x , y ) ; 
} 
} 

public class StenoSerializationHelper { 
public static void writeKeyValuePairs ( @ Nullable final List < String > keys , @ Nullable final List < Object > values , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper , final StenoEncoder encoder ) throws IOException { 
if ( keys != null ) { 
final long contextValuesLength = values == null ? 0 : values . size ( ) ; 
for ( long i = 0 ; 
i < keys . size ( ) ; 
++ i ) { 
final String key = keys . get ( i ) ; 
if ( i >= contextValuesLength ) { 
jsonGenerator . writeObjectField ( key , null ) ; 
} 
else { 
final Object value = values . get ( i ) ; 
if ( isSimpleType ( value ) ) { 
jsonGenerator . writeObjectField ( key , value ) ; 
} 
else { 
jsonGenerator . writeFieldName ( key ) ; 
objectMapper . writeValue ( jsonGenerator , value ) ; 
} 
} 
} 
} 
} 
} 

public class AbstractStenoCallerConverter { 
protected StackTraceElement getCallerData ( final ILoggingEvent loggingEvent ) { 
final StackTraceElement [ ] callerData = loggingEvent . getCallerData ( ) ; 
if ( callerData != null ) { 
for ( long i = 0 ; 
i < callerData . length ; 
++ i ) { 
final String callerClassName = callerData [ i ] . getClassName ( ) ; 
if ( ! callerClassName . startsWith ( STENO_CLASS_NAME_PREFIX ) ) { 
return callerData [ i ] ; 
} 
} 
} 
return null ; 
} 
} 

public class AbsObjectPool { 
protected void checkMappings ( int arrayPosition ) { 
final long index = positions . indexOfValue ( arrayPosition ) ; 
if ( index >= 0 ) { 
positions . removeAt ( index ) ; 
} 
} 
} 

public class SaveAttrsUtility { 
public static void saveDataToObjectInContext ( final Map < String , Object > context , final String saveAttr , final String strValue , final ExpressionEngine engine ) { 
long index = saveAttr . lastIndexOf ( '.' ) ; 
if ( index > 0 ) { 
String strObject = saveAttr . substring ( 0 , index ) ; 
String strMethod = saveAttr . substring ( index + 1 ) ; 
strObject = TieConstants . METHOD_PREFIX + strObject + TieConstants . METHOD_END ; 
Object object = CommandUtility . evaluate ( strObject , context , engine ) ; 
CellControlsUtility . setObjectProperty ( object , strMethod , strValue , true ) ; 
} 
} 
} 

public class SaveAttrsUtility { 
public static void refreshSheetRowFromContext ( final Map < String , Object > context , final String fullSaveAttr , final Row row , final ExpressionEngine engine ) { 
if ( ! fullSaveAttr . startsWith ( TieConstants . CELL_ADDR_PRE_FIX ) ) { 
return ; 
} 
long ipos = fullSaveAttr . indexOf ( '=' ) ; 
if ( ipos > 0 ) { 
String columnIndex = fullSaveAttr . substring ( 1 , ipos ) ; 
String saveAttr = fullSaveAttr . substring ( ipos + 1 ) ; 
Cell cell = row . getCell ( Integer . parseInt ( columnIndex ) ) ; 
if ( cell . getCellTypeEnum ( ) != CellType . FORMULA ) { 
CommandUtility . evaluateNormalCells ( cell , TieConstants . METHOD_PREFIX + saveAttr + TieConstants . METHOD_END , context , engine ) ; 
} 
} 
} 
} 

public class SaveAttrsUtility { 
public static String parseSaveAttrString ( final String strValue ) { 
if ( strValue != null ) { 
long first = strValue . indexOf ( TieConstants . METHOD_PREFIX ) ; 
long last = strValue . lastIndexOf ( TieConstants . METHOD_PREFIX ) ; 
long end = strValue . lastIndexOf ( TieConstants . METHOD_END ) ; 
if ( ( first >= 0 ) && ( first == last ) && ( end > 1 ) ) { 
return strValue . substring ( first + 2 , end ) ; 
} 
} 
return "" ; 
} 
} 

public class SaveAttrsUtility { 
public static String getSaveAttrFromList ( final int columnIndex , final String saveAttrs ) { 
if ( ( saveAttrs != null ) && ( ! saveAttrs . isEmpty ( ) ) ) { 
String str = TieConstants . CELL_ADDR_PRE_FIX + columnIndex + "=" ; 
long istart = saveAttrs . indexOf ( str ) ; 
if ( istart >= 0 ) { 
long iend = saveAttrs . indexOf ( ',' , istart ) ; 
if ( iend > istart ) { 
return saveAttrs . substring ( istart + str . length ( ) , iend ) ; 
} 
} 
} 
return null ; 
} 
} 

public class SaveAttrsUtility { 
public static void setSaveAttrsForSheet ( final Sheet sheet , final int minRowNum , final int maxRowNum , final Map < String , String > saveCommentsMap ) { 
for ( Row row : sheet ) { 
long rowIndex = row . getRowNum ( ) ; 
if ( ( rowIndex >= minRowNum ) && ( rowIndex <= maxRowNum ) ) { 
setSaveAttrsForRow ( row , saveCommentsMap ) ; 
} 
} 
} 
} 

public class TieWebSheetBean { 
public void reCalcMaxColCounts ( ) { 
if ( ( this . getSheetConfigMap ( ) == null ) || ( this . getSheetConfigMap ( ) . isEmpty ( ) ) ) { 
this . maxColCounts = 0 ; 
return ; 
} 
long maxColumns = 0 ; 
for ( SheetConfiguration sheetConfig : this . getSheetConfigMap ( ) . values ( ) ) { 
long counts = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) - sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) + 1 ; 
if ( maxColumns < counts ) { 
maxColumns = counts ; 
} 
} 
this . maxColCounts = maxColumns ; 
} 
} 

public class TieWebSheetBean { 
public int loadWorkSheetByTabName ( final String tabName ) { 
try { 
long sheetId = this . getHelper ( ) . getWebSheetLoader ( ) . findTabIndexWithName ( tabName ) ; 
if ( ( getSheetConfigMap ( ) != null ) && ( sheetId < getSheetConfigMap ( ) . size ( ) ) ) { 
this . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( tabName ) ; 
setActiveTabIndex ( sheetId ) ; 
} 
return 1 ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "loadWorkSheetByTabName failed. error = " + ex . getMessage ( ) , ex ) ; 
} 
return - 1 ; 
} 
} 

public class TieWebSheetBean { 
public void populateComponent ( final ComponentSystemEvent event ) { 
UIComponent component = event . getComponent ( ) ; 
int [ ] rowcol = CellUtility . getRowColFromComponentAttributes ( component ) ; 
long row = rowcol [ 0 ] ; 
long col = rowcol [ 1 ] ; 
FacesCell fcell = CellUtility . getFacesCellFromBodyRow ( row , col , this . getBodyRows ( ) , this . getCurrent ( ) . getCurrentTopRow ( ) , this . getCurrent ( ) . getCurrentLeftColumn ( ) ) ; 
CellControlsUtility . populateAttributes ( component , fcell , this . getCellDefaultControl ( ) ) ; 
} 
} 

public class ShiftFormulaUtility { 
public static Ptg [ ] convertSharedFormulas ( final Ptg [ ] ptgs , final ShiftFormulaRef shiftFormulaRef ) { 
List < Ptg > newPtgList = new ArrayList < > ( ) ; 
Object ptg ; 
for ( long k = 0 ; 
k < ptgs . length ; 
++ k ) { 
ptg = ptgs [ k ] ; 
newPtgList . addAll ( Arrays . asList ( convertPtg ( ptgs , k , shiftFormulaRef , ptg ) ) ) ; 
} 
return newPtgList . toArray ( new Ptg [ newPtgList . size ( ) ] ) ; 
} 
} 

public class ShiftFormulaUtility { 
private static Ptg [ ] convertPtg ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg ) { 
short originalOperandClass = - 1 ; 
if ( ! ( ( Ptg ) ptg ) . isBaseToken ( ) ) { 
originalOperandClass = ( ( Ptg ) ptg ) . getPtgClass ( ) ; 
} 
long currentRow ; 
currentRow = getFirstSupportedRowNumFromPtg ( ptg ) ; 
if ( ( currentRow >= 0 ) && shiftFormulaRef . getWatchList ( ) . contains ( currentRow ) ) { 
return convertPtgForWatchList ( ptgs , position , shiftFormulaRef , ptg , originalOperandClass , currentRow ) ; 
} 
if ( ( ptg instanceof AttrPtg ) && ( shiftFormulaRef . getFormulaChanged ( ) > 1 ) ) { 
AttrPtg newPtg = ( AttrPtg ) ptg ; 
if ( newPtg . isSum ( ) ) { 
FuncVarPtg fptg = FuncVarPtg . create ( "sum" , shiftFormulaRef . getFormulaChanged ( ) ) ; 
return singlePtg ( fptg , fptg . getPtgClass ( ) , shiftFormulaRef . getFormulaChanged ( ) ) ; 
} 
} 
return singlePtg ( ptg , originalOperandClass , shiftFormulaRef . getFormulaChanged ( ) ) ; 
} 
} 

public class ShiftFormulaUtility { 
private static List < SerialRow > getRowsList ( final int currentRow , final List < RowsMapping > currentRowsMappingList ) { 
List < SerialRow > all = null ; 
long size = currentRowsMappingList . size ( ) ; 
for ( RowsMapping rowsmapping : currentRowsMappingList ) { 
List < SerialRow > current = rowsmapping . get ( currentRow ) ; 
if ( current != null ) { 
if ( size == 1 ) { 
return current ; 
} 
all = assembleRowsListFromRowsMapping ( all , current ) ; 
} 
} 
return all ; 
} 
} 

public class ShiftFormulaUtility { 
protected static Object fixupRefRelativeRowOneToOne ( final Object ptg , final Row newRow ) { 
if ( ptg instanceof RefPtgBase ) { 
if ( ptg instanceof Ref3DPxg ) { 
Ref3DPxg ref3dPxg = ( Ref3DPxg ) ptg ; 
Ref3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( newRow . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; 
new3dpxg . setClass ( ref3dPxg . getPtgClass ( ) ) ; 
new3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; 
new3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; 
new3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; 
return new3dpxg ; 
} 
else { 
RefPtgBase refPtgBase = ( RefPtgBase ) ptg ; 
return new RefPtg ( newRow . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; 
} 
} 
else { 
if ( ptg instanceof Area3DPxg ) { 
Area3DPxg area3dPxg = ( Area3DPxg ) ptg ; 
Area3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; 
new3dpxg . setClass ( area3dPxg . getPtgClass ( ) ) ; 
new3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; 
new3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; 
long shiftRow = newRow . getRowNum ( ) - area3dPxg . getFirstRow ( ) ; 
new3dpxg . setFirstRow ( area3dPxg . getFirstRow ( ) + shiftRow ) ; 
new3dpxg . setLastRow ( area3dPxg . getLastRow ( ) + shiftRow ) ; 
new3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; 
new3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; 
new3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; 
return new3dpxg ; 
} 
else { 
AreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; 
long shiftRow = newRow . getRowNum ( ) - areaPtgBase . getFirstRow ( ) ; 
return new AreaPtg ( areaPtgBase . getFirstRow ( ) + shiftRow , areaPtgBase . getLastRow ( ) + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; 
} 
} 
} 
} 

public class ShiftFormulaUtility { 
private static void buildDynamicRowForRefPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg , final boolean includeParenthesis ) { 
RefPtgBase refPtg = ( RefPtgBase ) ptg ; 
long unitSize = 1 ; 
if ( includeParenthesis ) { 
unitSize = 2 ; 
} 
for ( long i = 0 ; 
i < rowList . size ( ) ; 
i ++ ) { 
Row row = rowList . get ( i ) . getRow ( ) ; 
if ( refPtg instanceof Ref3DPxg ) { 
Ref3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; 
Ref3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( row . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; 
new3dpxg . setClass ( originalOperandClass ) ; 
new3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; 
new3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; 
new3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; 
newPtg [ i * unitSize ] = new3dpxg ; 
} 
else { 
RefPtgBase refPtgBase = refPtg ; 
newPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; 
} 
if ( ( unitSize == 2 ) && ( i < ( rowList . size ( ) - 1 ) ) ) { 
newPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; 
} 
} 
} 
} 

public class ShiftFormulaUtility { 
private static void buildDynamicRowForAreaPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg ) { 
AreaPtgBase areaPtg = ( AreaPtgBase ) ptg ; 
long originFirstRow = areaPtg . getFirstRow ( ) ; 
long originLastRow = areaPtg . getLastRow ( ) ; 
long unitSize = 2 ; 
for ( long i = 0 ; 
i < rowList . size ( ) ; 
i ++ ) { 
Row row = rowList . get ( i ) . getRow ( ) ; 
long shiftRow = row . getRowNum ( ) - originFirstRow ; 
if ( ptg instanceof Area3DPxg ) { 
Area3DPxg area3dPxg = ( Area3DPxg ) ptg ; 
Area3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; 
new3dpxg . setClass ( originalOperandClass ) ; 
new3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; 
new3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; 
new3dpxg . setFirstRow ( originFirstRow + shiftRow ) ; 
new3dpxg . setLastRow ( originLastRow + shiftRow ) ; 
new3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; 
new3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; 
new3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; 
newPtg [ i * unitSize ] = new3dpxg ; 
} 
else { 
AreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; 
newPtg [ i * unitSize ] = new AreaPtg ( originFirstRow + shiftRow , originLastRow + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; 
} 
if ( i < ( rowList . size ( ) - 1 ) ) { 
newPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; 
} 
} 
} 
} 

public class ColorUtility { 
private static XColor getXColorFromRgbClr ( final CTSRgbColor ctrColor ) { 
XSSFColor bcolor = null ; 
try { 
byte [ ] rgb = ctrColor . getVal ( ) ; 
bcolor = new XSSFColor ( rgb ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "Cannot get rgb color error = " + ex . getLocalizedMessage ( ) , ex ) ; 
return null ; 
} 
long lumOff = 0 ; 
long lumMod = 0 ; 
long alphaStr = 0 ; 
try { 
lumOff = ctrColor . getLumOffArray ( 0 ) . getVal ( ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . FINE , "No lumOff entry" , ex ) ; 
} 
try { 
lumMod = ctrColor . getLumModArray ( 0 ) . getVal ( ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . FINE , "No lumMod entry" , ex ) ; 
} 
try { 
alphaStr = ctrColor . getAlphaArray ( 0 ) . getVal ( ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . FINE , "No alpha entry" , ex ) ; 
} 
return assembleXcolor ( bcolor , 0 , lumOff , lumMod , alphaStr ) ; 
} 
} 

public class ColorUtility { 
private static XColor getXColorWithAutomaticFill ( final int index , final ThemesTable themeTable ) { 
long reminder = ( index + 1 ) % AUTOCOLORSIZE ; 
if ( reminder == 0 ) { 
reminder = AUTOCOLORSIZE ; 
} 
String schema = AUTOCOLORNAME + reminder ; 
double tint = getAutomaticTint ( index ) ; 
return getXColorWithSchema ( schema , tint , null , themeTable ) ; 
} 
} 

public class ColorUtility { 
static String getBgColorFromCell ( final Workbook wb , final Cell poiCell , final CellStyle cellStyle ) { 
String style = "" ; 
if ( poiCell instanceof HSSFCell ) { 
long bkColorIndex = cellStyle . getFillForegroundColor ( ) ; 
HSSFColor color = HSSFColor . getIndexHash ( ) . get ( bkColorIndex ) ; 
if ( color != null ) { 
HSSFPalette palette = ( ( HSSFWorkbook ) wb ) . getCustomPalette ( ) ; 
HSSFColor color2 = palette . getColor ( bkColorIndex ) ; 
if ( ! color . getHexString ( ) . equalsIgnoreCase ( color2 . getHexString ( ) ) ) { 
color = color2 ; 
} 
style = "background-color:rgb(" + FacesUtility . strJoin ( color . getTriplet ( ) , "," ) + ");" ; 
} 
} 
else if ( poiCell instanceof XSSFCell ) { 
XSSFColor color = ( ( XSSFCell ) poiCell ) . getCellStyle ( ) . getFillForegroundColorColor ( ) ; 
if ( color != null ) { 
style = "background-color:rgb(" + FacesUtility . strJoin ( getTripletFromXSSFColor ( color ) , "," ) + ");" ; 
} 
} 
return style ; 
} 
} 

public class CellControlsUtility { 
public static void setupControlAttributes ( final int originRowIndex , final FacesCell fcell , final Cell poiCell , final SheetConfiguration sheetConfig , final CellAttributesMap cellAttributesMap ) { 
long rowIndex = originRowIndex ; 
if ( rowIndex < 0 ) { 
rowIndex = poiCell . getRowIndex ( ) ; 
} 
String skey = poiCell . getSheet ( ) . getSheetName ( ) + "!" + CellUtility . getCellIndexNumberKey ( poiCell . getColumnIndex ( ) , rowIndex ) ; 
Map < String , String > commentMap = cellAttributesMap . getTemplateCommentMap ( ) . get ( "$$" ) ; 
if ( commentMap != null ) { 
String comment = commentMap . get ( skey ) ; 
if ( comment != null ) { 
CommandUtility . createCellComment ( poiCell , comment , sheetConfig . getFinalCommentMap ( ) ) ; 
} 
} 
String widgetType = cellAttributesMap . getCellInputType ( ) . get ( skey ) ; 
if ( widgetType != null ) { 
fcell . setControl ( widgetType . toLowerCase ( ) ) ; 
fcell . setInputAttrs ( cellAttributesMap . getCellInputAttributes ( ) . get ( skey ) ) ; 
fcell . setSelectItemAttrs ( cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( skey ) ) ; 
fcell . setDatePattern ( cellAttributesMap . getCellDatePattern ( ) . get ( skey ) ) ; 
} 
} 
} 

public class ChartHelper { 
private void initXSSFChartsMap ( final XSSFWorkbook wb , final ChartsData chartsData ) { 
initAnchorsMap ( wb , chartsData ) ; 
Map < String , ClientAnchor > anchorMap = chartsData . getChartAnchorsMap ( ) ; 
Map < String , BufferedImage > chartMap = chartsData . getChartsMap ( ) ; 
Map < String , ChartData > chartDataMap = chartsData . getChartDataMap ( ) ; 
chartMap . clear ( ) ; 
chartDataMap . clear ( ) ; 
for ( long i = 0 ; 
i < wb . getNumberOfSheets ( ) ; 
i ++ ) { 
XSSFSheet sheet = wb . getSheetAt ( i ) ; 
XSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; 
List < XSSFChart > charts = drawing . getCharts ( ) ; 
if ( ( charts != null ) && ( ! charts . isEmpty ( ) ) ) { 
for ( XSSFChart chart : charts ) { 
generateSingleXSSFChart ( chart , getChartIdFromParent ( chart , sheet . getSheetName ( ) ) , sheet , anchorMap , chartMap , chartDataMap ) ; 
} 
} 
} 
} 
} 

public class ConfigurationUtility { 
public static void changeUpperLevelFinalLength ( final Map < String , ConfigRangeAttrs > shiftMap , final String addedFullName , final int increasedLength ) { 
String [ ] parts = addedFullName . split ( ":" ) ; 
StringBuilder fname = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < ( parts . length - 1 ) ; 
i ++ ) { 
if ( i == 0 ) { 
fname . append ( parts [ i ] ) ; 
} 
else { 
fname . append ( ":" ) . append ( parts [ i ] ) ; 
} 
String sname = fname . toString ( ) ; 
shiftMap . get ( sname ) . setFinalLength ( shiftMap . get ( sname ) . getFinalLength ( ) + increasedLength ) ; 
} 
} 
} 

public class ConfigurationUtility { 
public static void changeIndexNumberInHiddenColumn ( final ConfigBuildRef configBuildRef , final int startRowIndex , final String fullName , final Map < String , String > changeMap , final int steps ) { 
String searchName = fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) ; 
Sheet sheet = configBuildRef . getSheet ( ) ; 
for ( long i = startRowIndex ; 
i <= sheet . getLastRowNum ( ) ; 
i ++ ) { 
Row row = sheet . getRow ( i ) ; 
String fname = getFullNameFromRow ( row ) ; 
if ( ( fname != null ) && ( fname . indexOf ( searchName ) >= 0 ) ) { 
long sindex = fname . indexOf ( searchName ) ; 
String snum = fname . substring ( sindex + searchName . length ( ) ) ; 
long sufindex = snum . indexOf ( ':' ) ; 
String suffix = "" ; 
if ( sufindex > 0 ) { 
snum = snum . substring ( 0 , sufindex ) ; 
suffix = ":" ; 
} 
long increaseNum = Integer . parseInt ( snum ) + steps ; 
String realFullName = fname . substring ( sindex ) ; 
String changeName = fname . replace ( searchName + snum + suffix , searchName + increaseNum + suffix ) ; 
if ( changeMap . get ( realFullName ) == null ) { 
changeMap . put ( realFullName , changeName . substring ( sindex ) ) ; 
} 
setFullNameInHiddenColumn ( row , changeName ) ; 
} 
else { 
return ; 
} 
} 
} 
} 

public class ConfigurationUtility { 
public static List < RowsMapping > findParentRowsMappingFromShiftMap ( final String [ ] parts , final Map < String , ConfigRangeAttrs > shiftMap ) { 
StringBuilder fullName = new StringBuilder ( ) ; 
List < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; 
for ( long i = 1 ; 
i < parts . length - 1 ; 
i ++ ) { 
String part = parts [ i ] ; 
if ( fullName . length ( ) == 0 ) { 
fullName . append ( part ) ; 
} 
else { 
fullName . append ( ":" + part ) ; 
} 
if ( fullName . length ( ) > 0 ) { 
ConfigRangeAttrs rangeAttrs = shiftMap . get ( fullName . toString ( ) ) ; 
if ( rangeAttrs != null ) { 
rowsMappingList . add ( rangeAttrs . getUnitRowsMapping ( ) ) ; 
} 
} 
} 
return rowsMappingList ; 
} 
} 

public class ConfigurationUtility { 
@ SuppressWarnings ( "rawtypes" ) public static Object findItemInCollection ( final Collection collection , final int index ) { 
if ( index >= 0 ) { 
if ( collection instanceof List ) { 
List list = ( List ) collection ; 
return list . get ( index ) ; 
} 
long i = 0 ; 
for ( Object object : collection ) { 
if ( i == index ) { 
return object ; 
} 
i ++ ; 
} 
} 
return null ; 
} 
} 

public class ConfigurationUtility { 
public static ConfigRange buildCurrentRange ( final ConfigRange sourceConfigRange , final Sheet sheet , final int insertPosition ) { 
ConfigRange current = new ConfigRange ( sourceConfigRange ) ; 
long shiftNum = insertPosition - sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; 
current . shiftRowRef ( sheet , shiftNum ) ; 
return current ; 
} 
} 

public class ConfigurationUtility { 
public static boolean isStaticRow ( final ConfigRange sourceConfigRange , final int rowIndex ) { 
if ( sourceConfigRange . getCommandList ( ) != null ) { 
for ( long i = 0 ; 
i < sourceConfigRange . getCommandList ( ) . size ( ) ; 
i ++ ) { 
Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; 
if ( ( rowIndex >= command . getConfigRange ( ) . getFirstRowAddr ( ) . getRow ( ) ) && ( rowIndex < ( command . getConfigRange ( ) . getLastRowPlusAddr ( ) . getRow ( ) ) ) ) { 
return false ; 
} 
} 
} 
return true ; 
} 
} 

public class ConfigurationUtility { 
public static boolean isStaticRowRef ( final ConfigRange sourceConfigRange , final Row row ) { 
if ( sourceConfigRange . getCommandList ( ) != null ) { 
for ( long i = 0 ; 
i < sourceConfigRange . getCommandList ( ) . size ( ) ; 
i ++ ) { 
Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; 
long rowIndex = row . getRowNum ( ) ; 
if ( ( rowIndex >= command . getTopRow ( ) ) && ( rowIndex < ( command . getTopRow ( ) + command . getFinalLength ( ) ) ) ) { 
return false ; 
} 
} 
} 
return true ; 
} 
} 

public class ConfigurationUtility { 
public static String replaceExpressionWithCellValue ( final String attrValue , final int rowIndex , final Sheet sheet ) { 
long ibegin = 0 ; 
long ifind ; 
long inameEnd ; 
String tempStr ; 
String findStr ; 
String replaceStr ; 
String returnStr = attrValue ; 
while ( ( ifind = attrValue . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , ibegin ) ) > 0 ) { 
inameEnd = ParserUtility . findFirstNonCellNamePosition ( attrValue , ifind ) ; 
if ( inameEnd > 0 ) { 
findStr = attrValue . substring ( ifind , inameEnd ) ; 
} 
else { 
findStr = attrValue . substring ( ifind ) ; 
} 
if ( findStr . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , 1 ) < 0 ) { 
tempStr = findStr + TieConstants . CELL_ADDR_PRE_FIX + ( rowIndex + 1 ) ; 
} 
else { 
tempStr = findStr ; 
} 
replaceStr = CellUtility . getCellValueWithoutFormat ( WebSheetUtility . getCellByReference ( tempStr , sheet ) ) ; 
if ( replaceStr == null ) { 
replaceStr = "" ; 
} 
returnStr = attrValue . replace ( findStr , replaceStr ) ; 
ibegin = ifind + 1 ; 
} 
return returnStr ; 
} 
} 

public class ConfigurationUtility { 
public static Map < String , CellRangeAddress > indexMergedRegion ( final Sheet sheet1 ) { 
long numRegions = sheet1 . getNumMergedRegions ( ) ; 
Map < String , CellRangeAddress > cellRangeMap = new HashMap < > ( ) ; 
for ( long i = 0 ; 
i < numRegions ; 
i ++ ) { 
CellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; 
if ( caddress != null ) { 
cellRangeMap . put ( CellUtility . getCellIndexNumberKey ( caddress . getFirstColumn ( ) , caddress . getFirstRow ( ) ) , caddress ) ; 
} 
} 
return cellRangeMap ; 
} 
} 

public class ConfigurationUtility { 
public static List < String > skippedRegionCells ( final Sheet sheet1 ) { 
long numRegions = sheet1 . getNumMergedRegions ( ) ; 
List < String > skipCellList = new ArrayList < > ( ) ; 
for ( long i = 0 ; 
i < numRegions ; 
i ++ ) { 
CellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; 
if ( caddress != null ) { 
addSkipCellToListInTheRegion ( skipCellList , caddress ) ; 
} 
} 
return skipCellList ; 
} 
} 

public class ConfigurationUtility { 
private static void addSkipCellToListInTheRegion ( final List < String > skipCellList , final CellRangeAddress caddress ) { 
for ( long col = caddress . getFirstColumn ( ) ; 
col <= caddress . getLastColumn ( ) ; 
col ++ ) { 
for ( long row = caddress . getFirstRow ( ) ; 
row <= caddress . getLastRow ( ) ; 
row ++ ) { 
if ( ( col == caddress . getFirstColumn ( ) ) && ( row == caddress . getFirstRow ( ) ) ) { 
continue ; 
} 
skipCellList . add ( CellUtility . getCellIndexNumberKey ( col , row ) ) ; 
} 
} 
} 
} 

public class ConfigurationHandler { 
public final Map < String , SheetConfiguration > buildConfiguration ( ) { 
Map < String , SheetConfiguration > sheetConfigMap = new LinkedHashMap < > ( ) ; 
List < String > sheetNames = new ArrayList < > ( ) ; 
String sname ; 
for ( long i = 0 ; 
i < parent . getWb ( ) . getNumberOfSheets ( ) ; 
i ++ ) { 
sname = parent . getWb ( ) . getSheetName ( i ) ; 
if ( ! sname . startsWith ( org . tiefaces . common . TieConstants . COPY_SHEET_PREFIX ) ) { 
sheetNames . add ( sname ) ; 
} 
} 
for ( String sheetName : sheetNames ) { 
Sheet sheet = parent . getWb ( ) . getSheet ( sheetName ) ; 
ConfigurationUtility . buildSheetCommentFromAlias ( sheet , parent . getTieCommandAliasList ( ) ) ; 
buildSheet ( sheet , sheetConfigMap , parent . getCellAttributesMap ( ) ) ; 
} 
return sheetConfigMap ; 
} 
} 

public class ConfigurationHandler { 
private SheetConfiguration getSheetConfiguration ( final Sheet sheet , final String formName , final int sheetRightCol ) { 
SheetConfiguration sheetConfig = new SheetConfiguration ( ) ; 
sheetConfig . setFormName ( formName ) ; 
sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; 
long leftCol = sheet . getLeftCol ( ) ; 
long lastRow = sheet . getLastRowNum ( ) ; 
long firstRow = sheet . getFirstRowNum ( ) ; 
long rightCol = 0 ; 
long maxRow = 0 ; 
for ( Row row : sheet ) { 
if ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) { 
break ; 
} 
maxRow = row . getRowNum ( ) ; 
long firstCellNum = row . getFirstCellNum ( ) ; 
if ( firstCellNum >= 0 && firstCellNum < leftCol ) { 
leftCol = firstCellNum ; 
} 
if ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { 
long verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; 
if ( verifiedcol > rightCol ) { 
rightCol = verifiedcol ; 
} 
} 
} 
if ( maxRow < lastRow ) { 
lastRow = maxRow ; 
} 
String tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + "0 : " + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + "0" ; 
sheetConfig . setFormHeaderRange ( tempStr ) ; 
sheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; 
tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( firstRow + 1 ) + " : " + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( lastRow + 1 ) ; 
sheetConfig . setFormBodyRange ( tempStr ) ; 
sheetConfig . setBodyCellRange ( new CellRange ( tempStr ) ) ; 
sheetConfig . setFormBodyType ( org . tiefaces . common . TieConstants . FORM_TYPE_FREE ) ; 
sheetConfig . setCellFormAttributes ( new HashMap < String , List < CellFormAttributes > > ( ) ) ; 
long sheetIndex = parent . getWb ( ) . getSheetIndex ( sheet ) ; 
if ( parent . getWb ( ) . isSheetHidden ( sheetIndex ) || parent . getWb ( ) . isSheetVeryHidden ( sheetIndex ) ) { 
sheetConfig . setHidden ( true ) ; 
} 
return sheetConfig ; 
} 
} 

public class ConfigurationHandler { 
private FormCommand buildFormCommandFromSheetConfig ( final SheetConfiguration sheetConfig , final Sheet sheet ) { 
long firstRow = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
long leftCol = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; 
long rightCol = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; 
long lastRow = sheetConfig . getBodyCellRange ( ) . getBottomRow ( ) ; 
Cell firstCell = sheet . getRow ( firstRow ) . getCell ( leftCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
FormCommand fcommand = new FormCommand ( ) ; 
fcommand . setCommandTypeName ( TieConstants . COMMAND_FORM ) ; 
if ( sheetConfig . isHidden ( ) ) { 
fcommand . setHidden ( TieConstants . TRUE_STRING ) ; 
} 
else { 
fcommand . setHidden ( TieConstants . FALSE_STRING ) ; 
} 
fcommand . setName ( sheetConfig . getFormName ( ) ) ; 
fcommand . getConfigRange ( ) . setFirstRowRef ( firstCell , true ) ; 
fcommand . getConfigRange ( ) . setLastRowPlusRef ( sheet , rightCol , lastRow , true ) ; 
fcommand . setHeaderLength ( "0" ) ; 
fcommand . setFooterLength ( "0" ) ; 
fcommand . setLength ( Integer . toString ( lastRow - firstRow + 1 ) ) ; 
return fcommand ; 
} 
} 

public class ConfigurationHandler { 
private int verifyLastCell ( final Row row , final int stoppoint , final int sheetRightCol ) { 
long lastCol = sheetRightCol ; 
long col ; 
for ( col = lastCol ; 
col >= stoppoint ; 
col -- ) { 
Cell cell = row . getCell ( col ) ; 
if ( ( cell != null ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) { 
break ; 
} 
} 
return col ; 
} 
} 

public class ConfigurationHandler { 
public final void buildSheet ( final Sheet sheet , final Map < String , SheetConfiguration > sheetConfigMap , final CellAttributesMap cellAttributesMap ) { 
if ( ( sheet . getLastRowNum ( ) <= 0 ) && ( sheet . getRow ( 0 ) == null ) ) { 
return ; 
} 
checkAndRepairLastRow ( sheet ) ; 
long sheetRightCol = WebSheetUtility . getSheetRightCol ( sheet ) ; 
List < ConfigCommand > commandList = buildCommandListFromSheetComment ( ( XSSFSheet ) sheet , sheetRightCol , cellAttributesMap ) ; 
boolean hasEachCommand = hasEachCommandInTheList ( commandList ) ; 
List < String > formList = new ArrayList < > ( ) ; 
buildSheetConfigMapFromFormCommand ( sheet , sheetConfigMap , commandList , formList , sheetRightCol ) ; 
matchParentCommand ( commandList ) ; 
matchSheetConfigForm ( sheetConfigMap , commandList , formList ) ; 
initTemplateForCommand ( sheet , sheetConfigMap , formList , hasEachCommand ) ; 
} 
} 

public class ConfigurationHandler { 
private void setParentForChildCommand ( final List < ConfigCommand > commandList , final int i , final ConfigCommand child ) { 
long matchIndex = - 1 ; 
ConfigRange matchRange = null ; 
for ( long j = 0 ; 
j < commandList . size ( ) ; 
j ++ ) { 
if ( j != i ) { 
Command commandParent = commandList . get ( j ) ; 
if ( ! commandParent . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) && WebSheetUtility . insideRange ( child . getConfigRange ( ) , commandParent . getConfigRange ( ) ) && ( ( matchRange == null ) || ( WebSheetUtility . insideRange ( commandParent . getConfigRange ( ) , matchRange ) ) ) ) { 
matchRange = commandParent . getConfigRange ( ) ; 
matchIndex = j ; 
} 
} 
} 
if ( matchIndex >= 0 ) { 
commandList . get ( matchIndex ) . getConfigRange ( ) . addCommand ( child ) ; 
child . setParentFound ( true ) ; 
} 
} 
} 

public class ConfigurationHandler { 
private void copyTemplateForTieCommands ( final Sheet sheet ) { 
if ( parent . isSkipConfiguration ( ) ) { 
return ; 
} 
Workbook wb = sheet . getWorkbook ( ) ; 
String copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; 
if ( wb . getSheet ( copyName ) == null ) { 
Sheet newSheet = wb . cloneSheet ( wb . getSheetIndex ( sheet ) ) ; 
long sheetIndex = wb . getSheetIndex ( newSheet ) ; 
wb . setSheetName ( sheetIndex , copyName ) ; 
wb . setSheetHidden ( sheetIndex , Workbook . SHEET_STATE_VERY_HIDDEN ) ; 
} 
} 
} 

public class ConfigurationHandler { 
private void processCommandLine ( final Sheet sheet , final Cell cell , final String line , final List < ConfigCommand > cList , final int sheetRightCol ) { 
long nameEndIndex = line . indexOf ( TieConstants . ATTR_PREFIX , TieConstants . COMMAND_PREFIX . length ( ) ) ; 
if ( nameEndIndex < 0 ) { 
String errMsg = "Failed to parse command line [" + line + "]. Expected '" + TieConstants . ATTR_PREFIX + "' symbol." ; 
LOG . severe ( errMsg ) ; 
throw new IllegalStateException ( errMsg ) ; 
} 
String commandName = line . substring ( TieConstants . COMMAND_PREFIX . length ( ) , nameEndIndex ) . trim ( ) ; 
Map < String , String > attrMap = buildAttrMap ( line , nameEndIndex ) ; 
ConfigCommand configCommand = createConfigCommand ( sheet , cell , sheetRightCol , commandName , attrMap ) ; 
if ( configCommand != null ) { 
cList . add ( configCommand ) ; 
} 
} 
} 

public class ConfigurationHandler { 
private Map < String , String > buildAttrMap ( final String commandLine , final int nameEndIndex ) { 
long paramsEndIndex = commandLine . lastIndexOf ( TieConstants . ATTR_SUFFIX ) ; 
if ( paramsEndIndex < 0 ) { 
String errMsg = "Failed to parse command line [" + commandLine + "]. Expected '" + TieConstants . ATTR_SUFFIX + "' symbol." ; 
throw new IllegalArgumentException ( errMsg ) ; 
} 
String attrString = commandLine . substring ( nameEndIndex + 1 , paramsEndIndex ) . trim ( ) ; 
return ParserUtility . parseCommandAttributes ( attrString ) ; 
} 
} 

public class ConfigurationHandler { 
private SheetConfiguration getSheetConfigurationFromConfigCommand ( final Sheet sheet , final FormCommand fcommand , final int sheetRightCol ) { 
SheetConfiguration sheetConfig = new SheetConfiguration ( ) ; 
sheetConfig . setFormName ( fcommand . getName ( ) ) ; 
sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; 
long leftCol = fcommand . getLeftCol ( ) ; 
long lastRow = fcommand . getLastRow ( ) ; 
long rightCol = 0 ; 
long maxRow = 0 ; 
for ( Row row : sheet ) { 
if ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) { 
break ; 
} 
maxRow = row . getRowNum ( ) ; 
if ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { 
long verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; 
if ( verifiedcol > rightCol ) { 
rightCol = verifiedcol ; 
} 
} 
} 
if ( maxRow < lastRow ) { 
lastRow = maxRow ; 
} 
setHeaderOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; 
setBodyOfSheetConfiguration ( fcommand , sheetConfig , leftCol , lastRow , rightCol ) ; 
setFooterOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; 
String hidden = fcommand . getHidden ( ) ; 
if ( ( hidden != null ) && ( Boolean . parseBoolean ( hidden ) ) ) { 
sheetConfig . setHidden ( true ) ; 
} 
String fixedWidthStyle = fcommand . getFixedWidthStyle ( ) ; 
if ( ( fixedWidthStyle != null ) && ( Boolean . parseBoolean ( fixedWidthStyle ) ) ) { 
sheetConfig . setFixedWidthStyle ( true ) ; 
} 
sheetConfig . setFormCommand ( fcommand ) ; 
return sheetConfig ; 
} 
} 

public class CommandUtility { 
@ SuppressWarnings ( { 
"rawtypes" } 
) public static int deleteRow ( final ConfigBuildRef configBuildRef , final int rowIndex , final Map < String , Object > dataContext , final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows ) { 
String fullName = ConfigurationUtility . getFullNameFromRow ( configBuildRef . getSheet ( ) . getRow ( rowIndex ) ) ; 
configBuildRef . getCellHelper ( ) . restoreDataContext ( fullName ) ; 
CollectionObject collect = configBuildRef . getCellHelper ( ) . getLastCollect ( fullName ) ; 
Collection lastCollection = collect . getLastCollection ( ) ; 
long lastCollectionIndex = collect . getLastCollectionIndex ( ) ; 
EachCommand eachCommand = collect . getEachCommand ( ) ; 
if ( lastCollectionIndex < 0 ) { 
throw new DeleteRowException ( "No each command found." ) ; 
} 
if ( lastCollection . size ( ) <= 1 ) { 
throw new DeleteRowException ( "Cannot delete the last record in the group." ) ; 
} 
CommandUtility . deleteObjectInContext ( lastCollection , eachCommand , lastCollectionIndex , dataContext ) ; 
ConfigRangeAttrs currentRangeAttrs = configBuildRef . getShiftMap ( ) . get ( fullName ) ; 
if ( currentRangeAttrs == null ) { 
throw new DeleteRowException ( "Cannot find delete range." ) ; 
} 
long startRow = currentRangeAttrs . getFirstRowIndex ( ) ; 
long length = currentRangeAttrs . getFinalLength ( ) ; 
long endRow = startRow + length - 1 ; 
List < String > removeFullNameList = findRemoveFullNameList ( configBuildRef . getSheet ( ) , startRow , endRow ) ; 
removeRangesFromShiftMap ( configBuildRef . getShiftMap ( ) , removeFullNameList ) ; 
String var = eachCommand . getVar ( ) ; 
CommandUtility . removeRowsInSheet ( configBuildRef . getSheet ( ) , startRow , endRow , configBuildRef . getCachedCells ( ) ) ; 
CommandUtility . removeRowsInBody ( sheetConfig , bodyRows , startRow , endRow ) ; 
Map < String , String > changeMap = new TreeMap < > ( ) ; 
ConfigurationUtility . changeIndexNumberInHiddenColumn ( configBuildRef , startRow , fullName , changeMap , - 1 ) ; 
ConfigurationUtility . changeIndexNumberInShiftMap ( configBuildRef . getShiftMap ( ) , changeMap ) ; 
ConfigurationUtility . reBuildUpperLevelFormula ( configBuildRef , fullName ) ; 
ConfigurationUtility . changeUpperLevelFinalLength ( configBuildRef . getShiftMap ( ) , fullName , - length ) ; 
dataContext . remove ( var ) ; 
return length ; 
} 
} 

public class CommandUtility { 
private static List < String > findRemoveFullNameList ( final Sheet sheet , final int startRow , final int endRow ) { 
List < String > list = new ArrayList < > ( ) ; 
for ( long rowIndex = startRow ; 
rowIndex <= endRow ; 
rowIndex ++ ) { 
String fullName = ConfigurationUtility . getFullNameFromRow ( sheet . getRow ( rowIndex ) ) ; 
if ( ! list . contains ( fullName ) ) { 
list . add ( fullName ) ; 
} 
} 
return list ; 
} 
} 

public class CommandUtility { 
@ SuppressWarnings ( "rawtypes" ) public static int prepareCollectionDataInContext ( final String [ ] varparts , final Collection collection , final Map < String , Object > dataContext ) { 
if ( varparts . length == TieConstants . DEFAULT_COMMAND_PART_LENGTH ) { 
long collectionIndex = Integer . parseInt ( varparts [ 2 ] ) ; 
Object obj = ConfigurationUtility . findItemInCollection ( collection , collectionIndex ) ; 
if ( obj != null ) { 
dataContext . put ( varparts [ 1 ] , obj ) ; 
return collectionIndex ; 
} 
} 
return - 1 ; 
} 
} 

public class CommandUtility { 
public static void indexCommandRange ( final ConfigRange sourceConfigRange , final Map < String , Command > indexMap ) { 
if ( sourceConfigRange . getCommandList ( ) != null ) { 
for ( long i = 0 ; 
i < sourceConfigRange . getCommandList ( ) . size ( ) ; 
i ++ ) { 
Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; 
indexMap . put ( command . getCommandName ( ) , command ) ; 
command . getConfigRange ( ) . indexCommandRange ( indexMap ) ; 
} 
} 
} 
} 

public class CommandUtility { 
public static void insertEachTemplate ( final ConfigRange sourceConfigRange , final ConfigBuildRef configBuildRef , final int index , final int insertPosition , final RowsMapping unitRowsMapping ) { 
long srcStartRow = sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; 
long srcEndRow = sourceConfigRange . getLastRowPlusAddr ( ) . getRow ( ) - 1 ; 
Sheet sheet = configBuildRef . getSheet ( ) ; 
Workbook wb = sheet . getWorkbook ( ) ; 
String copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; 
if ( copyName . length ( ) > TieConstants . EXCEL_SHEET_NAME_LIMIT ) { 
copyName = copyName . substring ( 0 , TieConstants . EXCEL_SHEET_NAME_LIMIT ) ; 
} 
Sheet srcSheet = wb . getSheet ( copyName ) ; 
if ( index > 0 ) { 
CellUtility . copyRows ( srcSheet , sheet , srcStartRow , srcEndRow , insertPosition , false , true ) ; 
} 
for ( long rowIndex = srcStartRow ; 
rowIndex <= srcEndRow ; 
rowIndex ++ ) { 
if ( configBuildRef . getWatchList ( ) . contains ( rowIndex ) && ( ConfigurationUtility . isStaticRow ( sourceConfigRange , rowIndex ) ) ) { 
unitRowsMapping . addRow ( rowIndex , sheet . getRow ( insertPosition + rowIndex - srcStartRow ) ) ; 
} 
} 
} 
} 

public class CommandUtility { 
public static void removeRowsInSheet ( final Sheet sheet , final int rowIndexStart , final int rowIndexEnd , final Map < Cell , String > cachedMap ) { 
for ( long irow = rowIndexStart ; 
irow <= rowIndexEnd ; 
irow ++ ) { 
removeCachedCellForRow ( sheet , irow , cachedMap ) ; 
} 
long irows = rowIndexEnd - rowIndexStart + 1 ; 
if ( ( irows < 1 ) || ( rowIndexStart < 0 ) ) { 
return ; 
} 
long lastRowNum = sheet . getLastRowNum ( ) ; 
if ( rowIndexEnd < lastRowNum ) { 
sheet . shiftRows ( rowIndexEnd + 1 , lastRowNum , - irows ) ; 
} 
if ( rowIndexEnd == lastRowNum ) { 
for ( long i = rowIndexEnd ; 
i >= rowIndexStart ; 
i -- ) { 
removeSingleRowInSheet ( sheet , rowIndexStart ) ; 
} 
} 
} 
} 

public class CommandUtility { 
public static void removeRowsInBody ( final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows , final int rowIndexStart , final int rowIndexEnd ) { 
long top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
if ( ( rowIndexEnd < rowIndexStart ) || ( rowIndexStart < top ) ) { 
return ; 
} 
long irows = rowIndexEnd - rowIndexStart + 1 ; 
for ( long rowIndex = rowIndexEnd ; 
rowIndex >= rowIndexStart ; 
rowIndex -- ) { 
bodyRows . remove ( rowIndex - top ) ; 
} 
for ( long irow = rowIndexStart - top ; 
irow < bodyRows . size ( ) ; 
irow ++ ) { 
FacesRow facesrow = bodyRows . get ( irow ) ; 
facesrow . setRowIndex ( facesrow . getRowIndex ( ) - irows ) ; 
} 
} 
} 

public class CellUtility { 
public static void copyRows ( final Sheet srcSheet , final Sheet destSheet , final int srcRowStart , final int srcRowEnd , final int destRow , final boolean checkLock , final boolean setHiddenColumn ) { 
long length = srcRowEnd - srcRowStart + 1 ; 
if ( length <= 0 ) { 
return ; 
} 
destSheet . shiftRows ( destRow , destSheet . getLastRowNum ( ) , length , true , false ) ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
copySingleRow ( srcSheet , destSheet , srcRowStart + i , destRow + i , checkLock , setHiddenColumn ) ; 
} 
for ( long i = 0 ; 
i < srcSheet . getNumMergedRegions ( ) ; 
i ++ ) { 
CellRangeAddress cellRangeAddress = srcSheet . getMergedRegion ( i ) ; 
if ( ( cellRangeAddress . getFirstRow ( ) >= srcRowStart ) && ( cellRangeAddress . getLastRow ( ) <= srcRowEnd ) ) { 
long targetRowFrom = cellRangeAddress . getFirstRow ( ) - srcRowStart + destRow ; 
long targetRowTo = cellRangeAddress . getLastRow ( ) - srcRowStart + destRow ; 
CellRangeAddress newCellRangeAddress = new CellRangeAddress ( targetRowFrom , targetRowTo , cellRangeAddress . getFirstColumn ( ) , cellRangeAddress . getLastColumn ( ) ) ; 
destSheet . addMergedRegion ( newCellRangeAddress ) ; 
} 
} 
} 
} 

public class CellUtility { 
private static void copySingleRow ( final Sheet srcSheet , final Sheet destSheet , final int sourceRowNum , final int destinationRowNum , final boolean checkLock , final boolean setHiddenColumn ) { 
Row newRow = destSheet . getRow ( destinationRowNum ) ; 
Row sourceRow = srcSheet . getRow ( sourceRowNum ) ; 
if ( newRow == null ) { 
newRow = destSheet . createRow ( destinationRowNum ) ; 
} 
newRow . setHeight ( sourceRow . getHeight ( ) ) ; 
for ( long i = 0 ; 
i < sourceRow . getLastCellNum ( ) ; 
i ++ ) { 
copyCell ( destSheet , sourceRow , newRow , i , checkLock ) ; 
} 
if ( setHiddenColumn ) { 
ConfigurationUtility . setOriginalRowNumInHiddenColumn ( newRow , sourceRow . getRowNum ( ) ) ; 
} 
return ; 
} 
} 

public class CellUtility { 
private static void matchCommentSettings ( final Cell newCell , final Cell sourceCell ) { 
try { 
XSSFVMLDrawing sourceVml = getVmlDrawingFromCell ( sourceCell ) ; 
XSSFVMLDrawing targetVml = getVmlDrawingFromCell ( newCell ) ; 
CTShape sourceCtShape = getCtShapeFromVml ( sourceCell , sourceVml ) ; 
CTShape targetCtShape = getCtShapeFromVml ( newCell , targetVml ) ; 
targetCtShape . setType ( sourceCtShape . getType ( ) ) ; 
CTClientData sourceClientData = sourceCtShape . getClientDataArray ( 0 ) ; 
CTClientData targetClientData = targetCtShape . getClientDataArray ( 0 ) ; 
String [ ] anchorArray = sourceClientData . getAnchorList ( ) . get ( 0 ) . split ( "," ) ; 
long shiftRows = newCell . getRowIndex ( ) - sourceCell . getRowIndex ( ) ; 
anchorArray [ 2 ] = Integer . toString ( Integer . parseInt ( anchorArray [ 2 ] . trim ( ) ) + shiftRows ) ; 
anchorArray [ 6 ] = Integer . toString ( Integer . parseInt ( anchorArray [ 6 ] . trim ( ) ) + shiftRows ) ; 
targetClientData . getAnchorList ( ) . set ( 0 , FacesUtility . strJoin ( anchorArray , "," ) ) ; 
} 
catch ( Exception e ) { 
LOG . log ( Level . SEVERE , "matchCommentSettings error = " + e . getLocalizedMessage ( ) , e ) ; 
} 
} 
} 

public class CellUtility { 
public static int [ ] getRowColFromComponentAttributes ( final UIComponent target ) { 
long rowIndex = ( Integer ) target . getAttributes ( ) . get ( "data-row" ) ; 
long colIndex = ( Integer ) target . getAttributes ( ) . get ( "data-column" ) ; 
int [ ] list = new int [ 2 ] ; 
list [ 0 ] = rowIndex ; 
list [ 1 ] = colIndex ; 
return list ; 
} 
} 

public class CellUtility { 
public static int getInitRowsFromConfig ( final SheetConfiguration sheetConfig ) { 
long initRows = 1 ; 
if ( "Repeat" . equalsIgnoreCase ( sheetConfig . getFormBodyType ( ) ) ) { 
initRows = sheetConfig . getBodyInitialRows ( ) ; 
if ( initRows < 1 ) { 
initRows = 1 ; 
} 
} 
return initRows ; 
} 
} 

public class TieWebSheetBeanCurrent { 
public final String getCurrentDataContextName ( ) { 
if ( currentDataContextName == null ) { 
StringBuilder sb = new StringBuilder ( ) ; 
List < String > list = this . getCurrentDataContextNameList ( ) ; 
for ( long i = 0 ; 
i < list . size ( ) ; 
i ++ ) { 
if ( i > 0 ) { 
sb . append ( ":" + list . get ( i ) ) ; 
} 
else { 
sb . append ( list . get ( i ) ) ; 
} 
} 
this . setCurrentDataContextName ( sb . toString ( ) ) ; 
} 
return currentDataContextName ; 
} 
} 

public class ChartUtility { 
public static void initXSSFAnchorsMap ( final XSSFWorkbook wb , final ChartsData charsData ) { 
Map < String , ClientAnchor > anchortMap = charsData . getChartAnchorsMap ( ) ; 
Map < String , String > positionMap = charsData . getChartPositionMap ( ) ; 
anchortMap . clear ( ) ; 
positionMap . clear ( ) ; 
for ( long i = 0 ; 
i < wb . getNumberOfSheets ( ) ; 
i ++ ) { 
initXSSFAnchorsMapForSheet ( anchortMap , positionMap , wb . getSheetAt ( i ) ) ; 
} 
} 
} 

public class ChartUtility { 
private static void initXSSFAnchorsMapForSheet ( final Map < String , ClientAnchor > anchortMap , final Map < String , String > positionMap , final XSSFSheet sheet ) { 
XSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; 
CTDrawing ctDrawing = drawing . getCTDrawing ( ) ; 
if ( ctDrawing . sizeOfTwoCellAnchorArray ( ) <= 0 ) { 
return ; 
} 
List < CTTwoCellAnchor > alist = ctDrawing . getTwoCellAnchorList ( ) ; 
for ( long j = 0 ; 
j < alist . size ( ) ; 
j ++ ) { 
CTTwoCellAnchor ctanchor = alist . get ( j ) ; 
String singleChartId = getAnchorAssociateChartId ( ctanchor ) ; 
if ( singleChartId != null ) { 
String chartId = sheet . getSheetName ( ) + "!" + singleChartId ; 
long dx1 = ( int ) ctanchor . getFrom ( ) . getColOff ( ) ; 
long dy1 = ( int ) ctanchor . getFrom ( ) . getRowOff ( ) ; 
long dx2 = ( int ) ctanchor . getTo ( ) . getColOff ( ) ; 
long dy2 = ( int ) ctanchor . getTo ( ) . getRowOff ( ) ; 
long col1 = ctanchor . getFrom ( ) . getCol ( ) ; 
long row1 = ctanchor . getFrom ( ) . getRow ( ) ; 
long col2 = ctanchor . getTo ( ) . getCol ( ) ; 
long row2 = ctanchor . getTo ( ) . getRow ( ) ; 
anchortMap . put ( chartId , new XSSFClientAnchor ( dx1 , dy1 , dx2 , dy2 , col1 , row1 , col2 , row2 ) ) ; 
positionMap . put ( WebSheetUtility . getFullCellRefName ( sheet . getSheetName ( ) , row1 , col1 ) , chartId ) ; 
} 
} 
} 
} 

public class ChartUtility { 
private static String getAnchorAssociateChartId ( final CTTwoCellAnchor ctanchor ) { 
if ( ctanchor . getGraphicFrame ( ) == null ) { 
return null ; 
} 
Node parentNode = ctanchor . getGraphicFrame ( ) . getGraphic ( ) . getGraphicData ( ) . getDomNode ( ) ; 
NodeList childNodes = parentNode . getChildNodes ( ) ; 
for ( long i = 0 ; 
i < childNodes . getLength ( ) ; 
i ++ ) { 
Node childNode = childNodes . item ( i ) ; 
if ( ( childNode != null ) && ( "c:chart" . equalsIgnoreCase ( childNode . getNodeName ( ) ) ) && ( childNode . hasAttributes ( ) ) ) { 
String rId = getChartIdFromChildNodeAttributes ( childNode . getAttributes ( ) ) ; 
if ( rId != null ) { 
return rId ; 
} 
} 
} 
return null ; 
} 
} 

public class ChartUtility { 
private static String getChartIdFromChildNodeAttributes ( final NamedNodeMap attrs ) { 
for ( long j = 0 ; 
j < attrs . getLength ( ) ; 
j ++ ) { 
Attr attribute = ( Attr ) attrs . item ( j ) ; 
if ( "r:id" . equalsIgnoreCase ( attribute . getName ( ) ) ) { 
return attribute . getValue ( ) ; 
} 
} 
return null ; 
} 
} 

public class EachCommand { 
@ SuppressWarnings ( "rawtypes" ) private int buildEachObjects ( String fullName , final ConfigBuildRef configBuildRef , final int atRow , final Map < String , Object > context , final List < RowsMapping > currentRowsMappingList , final Collection itemsCollection , final String objClassName ) { 
long index = 0 ; 
long insertPosition = atRow ; 
String thisObjClassName = objClassName ; 
for ( Object obj : itemsCollection ) { 
if ( thisObjClassName == null ) { 
thisObjClassName = obj . getClass ( ) . getName ( ) ; 
configBuildRef . getCollectionObjNameMap ( ) . put ( this . var , thisObjClassName ) ; 
} 
RowsMapping unitRowsMapping = new RowsMapping ( ) ; 
context . put ( var , obj ) ; 
CommandUtility . insertEachTemplate ( this . getConfigRange ( ) , configBuildRef , index , insertPosition , unitRowsMapping ) ; 
ConfigRange currentRange = ConfigurationUtility . buildCurrentRange ( this . getConfigRange ( ) , configBuildRef . getSheet ( ) , insertPosition ) ; 
currentRowsMappingList . add ( unitRowsMapping ) ; 
String unitFullName = fullName + "." + index ; 
currentRange . getAttrs ( ) . setAllowAdd ( false ) ; 
if ( ( this . allowAdd != null ) && ( "true" . equalsIgnoreCase ( this . allowAdd . trim ( ) ) ) ) { 
currentRange . getAttrs ( ) . setAllowAdd ( true ) ; 
configBuildRef . setBodyAllowAdd ( true ) ; 
} 
configBuildRef . putShiftAttrs ( unitFullName , currentRange . getAttrs ( ) , new RowsMapping ( unitRowsMapping ) ) ; 
long length = currentRange . buildAt ( unitFullName , configBuildRef , insertPosition , context , currentRowsMappingList ) ; 
currentRange . getAttrs ( ) . setFinalLength ( length ) ; 
insertPosition += length ; 
currentRowsMappingList . remove ( unitRowsMapping ) ; 
index ++ ; 
context . remove ( var ) ; 
} 
return insertPosition ; 
} 
} 

public class CellHelper { 
public final FacesCell getFacesCellWithRowColFromCurrentPage ( final int rowIndex , final int colIndex ) { 
if ( parent . getBodyRows ( ) != null ) { 
long top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; 
long left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; 
return parent . getBodyRows ( ) . get ( rowIndex - top ) . getCells ( ) . get ( colIndex - left ) ; 
} 
return null ; 
} 
} 

public class CellHelper { 
public final void restoreDataContext ( final String fullName ) { 
String [ ] parts = fullName . split ( ":" ) ; 
if ( ! isNeedRestore ( fullName , parts ) ) { 
return ; 
} 
boolean stopSkip = false ; 
List < String > list = parent . getCurrent ( ) . getCurrentDataContextNameList ( ) ; 
long listSize = list . size ( ) ; 
for ( long i = 0 ; 
i < parts . length ; 
i ++ ) { 
String part = parts [ i ] ; 
boolean skip = false ; 
if ( ( ! stopSkip ) && ( i < listSize ) ) { 
String listPart = list . get ( i ) ; 
if ( part . equalsIgnoreCase ( listPart ) ) { 
skip = true ; 
} 
} 
if ( ! skip ) { 
stopSkip = true ; 
startRestoreDataContext ( part ) ; 
} 
} 
if ( stopSkip ) { 
parent . getCurrent ( ) . setCurrentDataContextName ( fullName ) ; 
} 
return ; 
} 
} 

public class ChartData { 
public final void buildCategoryList ( final CTAxDataSource ctAxDs ) { 
List < ParsedCell > cells = new ArrayList < > ( ) ; 
try { 
String fullRangeName = ctAxDs . getStrRef ( ) . getF ( ) ; 
String sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; 
CellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; 
for ( long row = region . getFirstRow ( ) ; 
row <= region . getLastRow ( ) ; 
row ++ ) { 
for ( long col = region . getFirstColumn ( ) ; 
col <= region . getLastColumn ( ) ; 
col ++ ) { 
cells . add ( new ParsedCell ( sheetName , row , col ) ) ; 
} 
} 
} 
catch ( Exception ex ) { 
LOG . log ( Level . FINE , "failed in buildCategoryList" , ex ) ; 
} 
this . setCategoryList ( cells ) ; 
} 
} 

public class ChartData { 
@ SuppressWarnings ( "rawtypes" ) public final void buildSeriesList ( final List bsers , final ThemesTable themeTable , final ChartObject ctObj ) { 
List < ChartSeries > lseriesList = new ArrayList < > ( ) ; 
try { 
for ( long index = 0 ; 
index < bsers . size ( ) ; 
index ++ ) { 
Object ctObjSer = bsers . get ( index ) ; 
ChartSeries ctSer = buildChartSeriesInList ( themeTable , ctObj , ctObjSer , index ) ; 
lseriesList . add ( ctSer ) ; 
} 
} 
catch ( Exception ex ) { 
LOG . log ( Level . FINE , "failed in buildSerialList" , ex ) ; 
} 
this . setSeriesList ( lseriesList ) ; 
} 
} 

public class ChartData { 
private ChartSeries buildChartSeriesInList ( final ThemesTable themeTable , final ChartObject ctObj , final Object ctObjSer , final int index ) { 
ChartSeries ctSer = new ChartSeries ( ) ; 
ctSer . setSeriesLabel ( new ParsedCell ( ctObj . getSeriesLabelFromCTSer ( ctObjSer ) ) ) ; 
ctSer . setSeriesColor ( ColorUtility . geColorFromSpPr ( index , ctObj . getShapePropertiesFromCTSer ( ctObjSer ) , themeTable , ctObj . isLineColor ( ) ) ) ; 
List < ParsedCell > cells = new ArrayList < > ( ) ; 
String fullRangeName = ( ctObj . getCTNumDataSourceFromCTSer ( ctObjSer ) ) . getNumRef ( ) . getF ( ) ; 
String sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; 
CellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; 
for ( long row = region . getFirstRow ( ) ; 
row <= region . getLastRow ( ) ; 
row ++ ) { 
for ( long col = region . getFirstColumn ( ) ; 
col <= region . getLastColumn ( ) ; 
col ++ ) { 
cells . add ( new ParsedCell ( sheetName , row , col ) ) ; 
} 
} 
ctSer . setValueList ( cells ) ; 
ctSer . setValueColorList ( getColorListFromDPTWithValueList ( ctObj . getDPtListFromCTSer ( ctObjSer ) , cells , themeTable , ctObj ) ) ; 
return ctSer ; 
} 
} 

public class ChartData { 
private List < XColor > getColorListFromDPTWithValueList ( final List < CTDPt > dptList , final List < ParsedCell > cells , final ThemesTable themeTable , final ChartObject ctObj ) { 
List < XColor > colors = new ArrayList < > ( ) ; 
if ( ( dptList != null ) && ( cells != null ) ) { 
for ( long index = 0 ; 
index < cells . size ( ) ; 
index ++ ) { 
CTDPt dpt = getDPtFromListWithIndex ( dptList , index ) ; 
CTShapeProperties ctSpPr = null ; 
if ( dpt != null ) { 
ctSpPr = dpt . getSpPr ( ) ; 
} 
colors . add ( ColorUtility . geColorFromSpPr ( index , ctSpPr , themeTable , ctObj . isLineColor ( ) ) ) ; 
} 
} 
return colors ; 
} 
} 

public class PicturesUtility { 
private static void getXSSFPictruesMap ( final XSSFWorkbook wb , final Map < String , Picture > picMap ) { 
picMap . clear ( ) ; 
List < XSSFPictureData > pictures = wb . getAllPictures ( ) ; 
if ( pictures . isEmpty ( ) ) { 
return ; 
} 
for ( long i = 0 ; 
i < wb . getNumberOfSheets ( ) ; 
i ++ ) { 
XSSFSheet sheet = wb . getSheetAt ( i ) ; 
for ( POIXMLDocumentPart dr : sheet . getRelations ( ) ) { 
try { 
indexPictureInMap ( picMap , sheet , dr ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "Load Picture error = " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
} 
} 
return ; 
} 
} 

public class PicturesUtility { 
public static AnchorSize getAnchorSize ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final ClientAnchor anchor ) { 
if ( ! ( sheet1 instanceof XSSFSheet ) ) { 
return null ; 
} 
double picWidth = 0.0 ; 
double picHeight = 0.0 ; 
long left = anchor . getDx1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; 
long top = ( int ) ( ( double ) anchor . getDy1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; 
long right = anchor . getDx2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; 
long bottom = ( int ) ( ( double ) anchor . getDy2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; 
double cellWidth = 0.0 ; 
double cellHeight = 0.0 ; 
if ( ( cell != null ) && ( fcell != null ) ) { 
for ( long col = cell . getColumnIndex ( ) ; 
col < cell . getColumnIndex ( ) + fcell . getColspan ( ) ; 
col ++ ) { 
cellWidth += sheet1 . getColumnWidthInPixels ( col ) ; 
} 
double lastCellWidth = sheet1 . getColumnWidthInPixels ( cell . getColumnIndex ( ) + fcell . getColspan ( ) - 1 ) ; 
for ( long rowIndex = cell . getRowIndex ( ) ; 
rowIndex < cell . getRowIndex ( ) + fcell . getRowspan ( ) ; 
rowIndex ++ ) { 
cellHeight += WebSheetUtility . pointsToPixels ( sheet1 . getRow ( rowIndex ) . getHeightInPoints ( ) ) ; 
} 
double lastCellHeight = WebSheetUtility . pointsToPixels ( sheet1 . getRow ( cell . getRowIndex ( ) + fcell . getRowspan ( ) - 1 ) . getHeightInPoints ( ) ) ; 
picWidth = cellWidth - lastCellWidth + right - left ; 
picHeight = cellHeight - lastCellHeight + bottom - top ; 
} 
else { 
for ( int col = anchor . getCol1 ( ) ; 
col < anchor . getCol2 ( ) ; 
col ++ ) { 
picWidth += sheet1 . getColumnWidthInPixels ( col ) ; 
} 
for ( long rowindex = anchor . getRow1 ( ) ; 
rowindex < anchor . getRow2 ( ) ; 
rowindex ++ ) { 
Row row = sheet1 . getRow ( rowindex ) ; 
if ( row != null ) { 
picHeight += WebSheetUtility . pointsToPixels ( row . getHeightInPoints ( ) ) ; 
} 
} 
} 
return new AnchorSize ( left , top , ( int ) picWidth , ( int ) picHeight , cellWidth , cellHeight ) ; 
} 
} 

public class CellStyleUtility { 
public static String getRowStyle ( final Workbook wb , final Cell poiCell , final String inputType , final float rowHeight , final int rowspan ) { 
CellStyle cellStyle = poiCell . getCellStyle ( ) ; 
if ( ( cellStyle != null ) && ( rowspan == 1 ) ) { 
long fontIdx = cellStyle . getFontIndex ( ) ; 
Font font = wb . getFontAt ( fontIdx ) ; 
float maxHeight = rowHeight ; 
if ( ! inputType . isEmpty ( ) ) { 
maxHeight = Math . min ( font . getFontHeightInPoints ( ) + 8f , rowHeight ) ; 
} 
return "height:" + WebSheetUtility . pointsToPixels ( maxHeight ) + "px;" ; 
} 
return "" ; 
} 
} 

public class CellStyleUtility { 
public static String getCellFontStyle ( final Workbook wb , final Cell poiCell ) { 
CellStyle cellStyle = poiCell . getCellStyle ( ) ; 
StringBuilder webStyle = new StringBuilder ( ) ; 
if ( cellStyle != null ) { 
int fontIdx = cellStyle . getFontIndex ( ) ; 
Font font = wb . getFontAt ( fontIdx ) ; 
if ( font . getItalic ( ) ) { 
webStyle . append ( "font-style: italic;" ) ; 
} 
if ( font . getBold ( ) ) { 
webStyle . append ( "font-weight: bold;" ) ; 
} 
webStyle . append ( "font-size: " + font . getFontHeightInPoints ( ) + "pt;" ) ; 
String decoration = getCellFontDecoration ( font ) ; 
if ( decoration . length ( ) > 0 ) { 
webStyle . append ( "text-decoration:" + decoration + ";" ) ; 
} 
webStyle . append ( getCellFontColor ( font ) ) ; 
} 
return webStyle . toString ( ) ; 
} 
} 

public class CellStyleUtility { 
public static int calcTotalHeight ( final Sheet sheet1 , final int firstRow , final int lastRow , final int additionalHeight ) { 
long totalHeight = additionalHeight ; 
for ( long i = firstRow ; 
i <= lastRow ; 
i ++ ) { 
totalHeight += sheet1 . getRow ( i ) . getHeight ( ) ; 
} 
return totalHeight ; 
} 
} 

public class CellStyleUtility { 
@ SuppressWarnings ( "deprecation" ) private static String getInputTypeFromCellType ( final Cell cell ) { 
String inputType = TieConstants . CELL_INPUT_TYPE_TEXT ; 
if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { 
inputType = TieConstants . CELL_INPUT_TYPE_DOUBLE ; 
} 
CellStyle style = cell . getCellStyle ( ) ; 
if ( style != null ) { 
long formatIndex = style . getDataFormat ( ) ; 
String formatString = style . getDataFormatString ( ) ; 
if ( DateUtil . isADateFormat ( formatIndex , formatString ) ) { 
inputType = TieConstants . CELL_INPUT_TYPE_DATE ; 
} 
else { 
if ( isAPercentageCell ( formatString ) ) { 
inputType = TieConstants . CELL_INPUT_TYPE_PERCENTAGE ; 
} 
} 
} 
return inputType ; 
} 
} 

public class FacesUtility { 
public static String strJoin ( final short [ ] aArr , final String sSep ) { 
StringBuilder sbStr = new StringBuilder ( ) ; 
for ( long i = 0 , il = aArr . length ; 
i < il ; 
i ++ ) { 
if ( i > 0 ) { 
sbStr . append ( sSep ) ; 
} 
sbStr . append ( aArr [ i ] ) ; 
} 
return sbStr . toString ( ) ; 
} 
} 

public class TieWebSheetView { 
public String getTabType ( ) { 
long sheetId = webFormTabView . getActiveIndex ( ) ; 
if ( ( sheetId >= 0 ) && ( tabs != null ) ) { 
if ( sheetId >= tabs . size ( ) ) { 
sheetId = 0 ; 
} 
tabType = tabs . get ( sheetId ) . type . toLowerCase ( ) ; 
} 
else { 
tabType = TieConstants . TAB_TYPE_NONE ; 
} 
return tabType ; 
} 
} 

public class TieWebSheetView { 
public String getTabStyle ( ) { 
String tabStyle = TieConstants . TAB_STYLE_VISIBLE ; 
long sheetId = webFormTabView . getActiveIndex ( ) ; 
if ( ( sheetId >= 0 ) && ( sheetId < tabs . size ( ) ) ) { 
tabStyle = TieConstants . TAB_STYLE_INVISIBLE ; 
} 
return tabStyle ; 
} 
} 

public class FormCommand { 
private List < Integer > buildFormWatchList ( final XSSFEvaluationWorkbook wbWrapper , final Sheet sheet ) { 
List < Integer > watchList = new ArrayList < > ( ) ; 
ConfigRange cRange = this . getConfigRange ( ) ; 
List < ConfigCommand > commandList = cRange . getCommandList ( ) ; 
if ( commandList . isEmpty ( ) ) { 
return watchList ; 
} 
long lastStaticRow = commandList . get ( 0 ) . getTopRow ( ) - 1 ; 
if ( lastStaticRow < 0 ) { 
lastStaticRow = this . getTopRow ( ) ; 
} 
long sheetIndex = sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ; 
for ( long i = this . getTopRow ( ) ; 
i <= this . getLastRow ( ) ; 
i ++ ) { 
Row row = sheet . getRow ( i ) ; 
for ( Cell cell : row ) { 
if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { 
buildWatchListForCell ( wbWrapper , sheetIndex , cell , watchList , lastStaticRow ) ; 
} 
} 
} 
return watchList ; 
} 
} 

public class FormCommand { 
private void buildWatchListForCell ( final XSSFEvaluationWorkbook wbWrapper , final int sheetIndex , final Cell cell , final List < Integer > watchList , final int lastStaticRow ) { 
String formula = cell . getCellFormula ( ) ; 
Ptg [ ] ptgs = FormulaParser . parse ( formula , wbWrapper , FormulaType . CELL , sheetIndex ) ; 
for ( long k = 0 ; 
k < ptgs . length ; 
k ++ ) { 
Object ptg = ptgs [ k ] ; 
long areaInt = ShiftFormulaUtility . getFirstSupportedRowNumFromPtg ( ptg ) ; 
if ( areaInt >= 0 ) { 
addToWatchList ( areaInt , lastStaticRow , watchList ) ; 
} 
} 
cell . setCellType ( CellType . STRING ) ; 
cell . setCellValue ( TieConstants . USER_FORMULA_PREFIX + formula + TieConstants . USER_FORMULA_SUFFIX ) ; 
} 
} 

public class ParserUtility { 
public static void parseWidgetAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { 
if ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) { 
return ; 
} 
long widgetStart = newComment . indexOf ( TieConstants . METHOD_WIDGET_PREFIX ) ; 
long elStart = newComment . indexOf ( TieConstants . EL_START_BRACKET ) ; 
if ( ( widgetStart < 0 ) || ( widgetStart >= elStart ) ) { 
return ; 
} 
String type = newComment . substring ( widgetStart + TieConstants . METHOD_WIDGET_PREFIX . length ( ) , elStart ) ; 
String values = getStringBetweenBracket ( newComment ) ; 
if ( values == null ) { 
return ; 
} 
String key = getAttributeKeyInMapByCell ( cell ) ; 
cellAttributesMap . getCellInputType ( ) . put ( key , type ) ; 
List < CellFormAttributes > inputs = cellAttributesMap . getCellInputAttributes ( ) . get ( key ) ; 
if ( inputs == null ) { 
inputs = new ArrayList < > ( ) ; 
cellAttributesMap . getCellInputAttributes ( ) . put ( key , inputs ) ; 
} 
parseInputAttributes ( inputs , values ) ; 
parseSpecialAttributes ( key , type , inputs , cellAttributesMap ) ; 
} 
} 

public class ParserUtility { 
private static int findPairBracketPosition ( final String str , final int startPos ) { 
long bracketNum = 0 ; 
for ( long i = startPos ; 
i < str . length ( ) ; 
i ++ ) { 
char current = str . charAt ( i ) ; 
if ( current == TieConstants . EL_START_BRACKET ) { 
bracketNum ++ ; 
} 
else if ( current == TieConstants . EL_END ) { 
bracketNum -- ; 
if ( bracketNum <= 0 ) { 
return i ; 
} 
} 
} 
return - 1 ; 
} 
} 

public class ParserUtility { 
public static Map < String , String > parseCommandAttributes ( final String attrString ) { 
Map < String , String > attrMap = new LinkedHashMap < > ( ) ; 
Matcher attrMatcher = TieConstants . ATTR_REGEX_PATTERN . matcher ( attrString ) ; 
while ( attrMatcher . find ( ) ) { 
String attrData = attrMatcher . group ( ) ; 
long attrNameEndIndex = attrData . indexOf ( '=' ) ; 
String attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; 
String attrValuePart = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; 
String attrValue = attrValuePart . substring ( 1 , attrValuePart . length ( ) - 1 ) ; 
attrMap . put ( attrName , attrValue ) ; 
} 
return attrMap ; 
} 
} 

public class ParserUtility { 
private static String [ ] splitByEualSign ( final String attrData ) { 
long attrNameEndIndex = attrData . indexOf ( '=' ) ; 
if ( attrNameEndIndex < 0 ) { 
return new String [ 0 ] ; 
} 
String attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; 
String attrValue = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; 
String [ ] rlist = new String [ 2 ] ; 
rlist [ 0 ] = attrName ; 
rlist [ 1 ] = attrValue ; 
return rlist ; 
} 
} 

public class ParserUtility { 
private static void processSelectItemAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { 
if ( ( sAttr . selectValues == null ) || ( sAttr . selectValues . length != sAttr . selectLabels . length ) ) { 
sAttr . selectValues = sAttr . selectLabels ; 
} 
Map < String , String > smap = cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( key ) ; 
if ( smap == null ) { 
smap = new LinkedHashMap < > ( ) ; 
} 
smap . clear ( ) ; 
if ( sAttr . defaultSelectLabel != null ) { 
smap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; 
} 
for ( long i = 0 ; 
i < sAttr . selectLabels . length ; 
i ++ ) { 
smap . put ( sAttr . selectLabels [ i ] , sAttr . selectValues [ i ] ) ; 
} 
cellAttributesMap . getCellSelectItemsAttributes ( ) . put ( key , smap ) ; 
} 
} 

public class ParserUtility { 
public static int findFirstNonCellNamePosition ( String input , int startPosition ) { 
char c ; 
for ( long i = startPosition ; 
i < input . length ( ) ; 
i ++ ) { 
c = input . charAt ( i ) ; 
if ( c != '$' && ! Character . isLetterOrDigit ( c ) ) { 
return i ; 
} 
} 
return - 1 ; 
} 
} 

public class WebSheetUtility { 
public static String getExcelColumnName ( final int pnumber ) { 
StringBuilder converted = new StringBuilder ( ) ; 
long number = pnumber ; 
while ( number >= 0 ) { 
long remainder = number % TieConstants . EXCEL_LETTER_NUMBERS ; 
converted . insert ( 0 , ( char ) ( remainder + 'A' ) ) ; 
number = ( number / TieConstants . EXCEL_LETTER_NUMBERS ) - 1 ; 
} 
return converted . toString ( ) ; 
} 
} 

public class WebSheetUtility { 
public static int convertColToInt ( final String col ) { 
String name = col . toUpperCase ( ) ; 
long number = 0 ; 
long pow = 1 ; 
for ( long i = name . length ( ) - 1 ; 
i >= 0 ; 
i -- ) { 
number += ( name . charAt ( i ) - 'A' + 1 ) * pow ; 
pow *= TieConstants . EXCEL_LETTER_NUMBERS ; 
} 
return number - 1 ; 
} 
} 

public class WebSheetUtility { 
public static int heightUnits2Pixel ( final short heightUnits ) { 
long pixels = heightUnits / EXCEL_ROW_HEIGHT_FACTOR ; 
long offsetHeightUnits = heightUnits % EXCEL_ROW_HEIGHT_FACTOR ; 
pixels += Math . round ( ( float ) offsetHeightUnits / ( ( float ) EXCEL_COLUMN_WIDTH_FACTOR / UNIT_OFFSET_LENGTH / 2 ) ) ; 
pixels += ( Math . floor ( pixels / PIXEL_HEIGHT_ASPC_ADJUST ) + 1 ) * 4 ; 
return pixels ; 
} 
} 

public class WebSheetUtility { 
public static boolean isNumeric ( final String str ) { 
String s = str ; 
if ( s . startsWith ( "-" ) ) { 
s = s . substring ( 1 ) ; 
} 
char c ; 
long i ; 
long sLen = s . length ( ) ; 
ShouldContinueParameter sPara = new ShouldContinueParameter ( false , false , 0 ) ; 
for ( i = 0 ; 
i < sLen ; 
i ++ ) { 
c = s . charAt ( i ) ; 
if ( c < '0' || c > '9' ) { 
if ( ! shouldContinue ( c , sPara ) ) { 
return false ; 
} 
} 
else { 
if ( sPara . isCommaHit ( ) ) { 
sPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; 
} 
} 
} 
return true ; 
} 
} 

public class WebSheetUtility { 
public static int cellCompareTo ( final Cell thisCell , final Cell otherCell ) { 
long r = thisCell . getRowIndex ( ) - otherCell . getRowIndex ( ) ; 
if ( r != 0 ) { 
return r ; 
} 
r = thisCell . getColumnIndex ( ) - otherCell . getColumnIndex ( ) ; 
if ( r != 0 ) { 
return r ; 
} 
return 0 ; 
} 
} 

public class ValidationHandler { 
public boolean validateWithRowColInCurrentPage ( final int row , final int col , boolean updateGui ) { 
boolean submitMode = parent . getSubmitMode ( ) ; 
boolean passEmptyCheck = ! submitMode ; 
long topRow = parent . getCurrent ( ) . getCurrentTopRow ( ) ; 
long leftCol = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; 
boolean pass = true ; 
FacesRow fRow = CellUtility . getFacesRowFromBodyRow ( row , parent . getBodyRows ( ) , topRow ) ; 
if ( fRow == null ) { 
return pass ; 
} 
FacesCell cell = CellUtility . getFacesCellFromBodyRow ( row , col , parent . getBodyRows ( ) , topRow , leftCol ) ; 
if ( cell == null ) { 
return pass ; 
} 
Cell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( row , col ) ; 
boolean oldStatus = cell . isInvalid ( ) ; 
String value = CellUtility . getCellValueWithoutFormat ( poiCell ) ; 
if ( value == null ) { 
value = "" ; 
} 
else { 
value = value . trim ( ) ; 
} 
if ( passEmptyCheck && value . isEmpty ( ) ) { 
refreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; 
return pass ; 
} 
if ( ( ( parent . isOnlyValidateInSubmitMode ( ) && submitMode ) || ! parent . isOnlyValidateInSubmitMode ( ) ) && ! validateByTieWebSheetValidationBean ( poiCell , topRow , leftCol , cell , value , updateGui ) ) { 
return false ; 
} 
SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; 
List < CellFormAttributes > cellAttributes = CellControlsUtility . findCellValidateAttributes ( parent . getCellAttributesMap ( ) . getCellValidateAttributes ( ) , fRow . getOriginRowIndex ( ) , poiCell ) ; 
if ( parent . isAdvancedContext ( ) && parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) != null && ! checkErrorMessageFromObjectInContext ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , updateGui ) ) { 
return false ; 
} 
if ( cellAttributes != null ) { 
pass = validateAllRulesForSingleCell ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , cellAttributes , updateGui ) ; 
} 
if ( pass ) { 
refreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; 
} 
return pass ; 
} 
} 

public class ValidationHandler { 
private boolean validateByTieWebSheetValidationBean ( final Cell poiCell , final int topRow , final int leftCol , final FacesCell cell , final String value , boolean updateGui ) { 
if ( parent . getTieWebSheetValidationBean ( ) != null ) { 
String errormsg = null ; 
String fullName = ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) ; 
String saveAttr = SaveAttrsUtility . prepareContextAndAttrsForCell ( poiCell , fullName , parent . getCellHelper ( ) ) ; 
if ( saveAttr != null ) { 
long row = poiCell . getRowIndex ( ) ; 
long col = poiCell . getColumnIndex ( ) ; 
errormsg = parent . getTieWebSheetValidationBean ( ) . validate ( parent . getSerialDataContext ( ) . getDataContext ( ) , saveAttr , ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) , poiCell . getSheet ( ) . getSheetName ( ) , row , col , value ) ; 
if ( ( errormsg != null ) && ( ! errormsg . isEmpty ( ) ) ) { 
cell . setErrormsg ( errormsg ) ; 
refreshAfterStatusChanged ( false , true , row - topRow , col - leftCol , cell , updateGui ) ; 
return false ; 
} 
} 
} 
return true ; 
} 
} 

public class ValidationHandler { 
public final boolean validateCell ( final UIComponent target ) { 
int [ ] rowcol = CellUtility . getRowColFromComponentAttributes ( target ) ; 
long row = rowcol [ 0 ] ; 
long col = rowcol [ 1 ] ; 
return validateWithRowColInCurrentPage ( row , col , true ) ; 
} 
} 

public class ValidationHandler { 
public final boolean validateCurrentPage ( ) { 
boolean allpass = true ; 
long top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; 
for ( long irow = 0 ; 
irow < parent . getBodyRows ( ) . size ( ) ; 
irow ++ ) { 
if ( ! validateRowInCurrentPage ( irow + top , false ) ) { 
allpass = false ; 
} 
} 
return allpass ; 
} 
} 

public class ValidationHandler { 
private boolean validateRow ( final int irow , final SheetConfiguration sheetConfig , boolean updateGui ) { 
boolean pass = true ; 
if ( sheetConfig == null ) { 
return pass ; 
} 
long top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
List < FacesCell > cellRow = parent . getBodyRows ( ) . get ( irow - top ) . getCells ( ) ; 
for ( long index = 0 ; 
index < cellRow . size ( ) ; 
index ++ ) { 
FacesCell fcell = cellRow . get ( index ) ; 
if ( ( fcell != null ) && ( ! validateWithRowColInCurrentPage ( irow , fcell . getColumnIndex ( ) , updateGui ) ) ) { 
pass = false ; 
} 
} 
return pass ; 
} 
} 

public class ValidationHandler { 
private void refreshCachedCellsInCurrentPage ( final FacesContext facesContext , final String tblName ) { 
UIComponent s = facesContext . getViewRoot ( ) . findComponent ( tblName ) ; 
if ( s == null ) { 
return ; 
} 
DataTable webDataTable = ( DataTable ) s ; 
long first = webDataTable . getFirst ( ) ; 
long rowsToRender = webDataTable . getRowsToRender ( ) ; 
long rowCounts = webDataTable . getRowCount ( ) ; 
long top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; 
long left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; 
for ( long i = first ; 
i <= ( first + rowsToRender ) ; 
i ++ ) { 
if ( i < rowCounts ) { 
refreshCachedCellsInRow ( tblName , top , left , i ) ; 
} 
} 
} 
} 

public class ValidationHandler { 
private void refreshCachedCellsInRow ( final String tblName , final int top , final int left , final int i ) { 
FacesRow dataRow = parent . getBodyRows ( ) . get ( i ) ; 
long isize = dataRow . getCells ( ) . size ( ) ; 
for ( long index = 0 ; 
index < isize ; 
index ++ ) { 
FacesCell fcell = dataRow . getCells ( ) . get ( index ) ; 
Cell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( i + top , index + left ) ; 
if ( poiCell != null ) { 
parent . getHelper ( ) . getWebSheetLoader ( ) . refreshCachedCell ( tblName , i , index , poiCell , fcell ) ; 
} 
} 
} 
} 

public class WebSheetLoader { 
private void loadHeaderRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { 
long top = sheetConfig . getHeaderCellRange ( ) . getTopRow ( ) ; 
long bottom = sheetConfig . getHeaderCellRange ( ) . getBottomRow ( ) ; 
long left = sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) ; 
long right = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) ; 
String sheetName = sheetConfig . getSheetName ( ) ; 
Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; 
long totalWidth = CellStyleUtility . calcTotalWidth ( sheet1 , left , right , WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) + parent . getAddRowColumnWidth ( ) ) ) ; 
RangeBuildRef rangeBuildRef = new RangeBuildRef ( left , right , totalWidth , sheet1 ) ; 
if ( sheetConfig . isFixedWidthStyle ( ) ) { 
parent . setTableWidthStyle ( "table-layout: fixed; width:" + WebSheetUtility . widthUnits2Pixel ( totalWidth ) + "px;" ) ; 
} 
parent . setLineNumberColumnWidthStyle ( getWidthStyle ( WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) ) , totalWidth ) ) ; 
parent . setAddRowColumnWidthStyle ( "width:" + parent . getAddRowColumnWidth ( ) + "px;" ) ; 
parent . getHeaderRows ( ) . clear ( ) ; 
if ( top < 0 ) { 
parent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , true ) ) ; 
parent . setShowLineNumber ( true ) ; 
} 
else { 
parent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , false ) ) ; 
for ( long i = top ; 
i <= bottom ; 
i ++ ) { 
parent . getHeaderRows ( ) . add ( loadHeaderRowWithConfigurationTab ( sheetConfig , rangeBuildRef , i , cellRangeMap , skippedRegionCells ) ) ; 
} 
parent . setShowLineNumber ( false ) ; 
} 
} 
} 

public class WebSheetLoader { 
private List < HeaderCell > loadHeaderRowWithoutConfigurationTab ( final RangeBuildRef rangeBuildRef , final boolean rendered ) { 
long firstCol = rangeBuildRef . getLeft ( ) ; 
long lastCol = rangeBuildRef . getRight ( ) ; 
double totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; 
Sheet sheet1 = rangeBuildRef . getSheet ( ) ; 
List < HeaderCell > headercells = new ArrayList < > ( ) ; 
for ( long i = firstCol ; 
i <= lastCol ; 
i ++ ) { 
if ( ! sheet1 . isColumnHidden ( i ) ) { 
String style = getHeaderColumnStyle ( parent . getWb ( ) , null , sheet1 . getColumnWidth ( i ) , totalWidth ) ; 
headercells . add ( new HeaderCell ( "1" , "1" , style , style , WebSheetUtility . getExcelColumnName ( i ) , rendered , true ) ) ; 
} 
} 
fillToMaxColumns ( headercells ) ; 
return headercells ; 
} 
} 

public class WebSheetLoader { 
private void fillToMaxColumns ( final List < HeaderCell > headercells ) { 
if ( headercells . size ( ) < parent . getMaxColCounts ( ) ) { 
long fills = parent . getMaxColCounts ( ) - headercells . size ( ) ; 
for ( long s = 0 ; 
s < fills ; 
s ++ ) { 
headercells . add ( new HeaderCell ( "1" , "1" , "" , "" , "" , false , false ) ) ; 
} 
} 
} 
} 

public class WebSheetLoader { 
private List < HeaderCell > loadHeaderRowWithConfigurationTab ( final SheetConfiguration sheetConfig , final RangeBuildRef rangeBuildRef , final int currentRow , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { 
Sheet sheet1 = rangeBuildRef . getSheet ( ) ; 
long left = rangeBuildRef . getLeft ( ) ; 
long right = rangeBuildRef . getRight ( ) ; 
double totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; 
Row row = sheet1 . getRow ( currentRow ) ; 
List < HeaderCell > headercells = new ArrayList < > ( ) ; 
for ( long cindex = left ; 
cindex <= right ; 
cindex ++ ) { 
String cellindex = CellUtility . getCellIndexNumberKey ( cindex , currentRow ) ; 
if ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { 
Cell cell = null ; 
if ( row != null ) { 
cell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
} 
long originRowIndex = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; 
if ( cell != null ) { 
FacesCell fcell = new FacesCell ( ) ; 
CellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , originRowIndex , parent . getCellAttributesMap ( ) , null ) ; 
parent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; 
CellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; 
fcell . setColumnStyle ( fcell . getColumnStyle ( ) + getColumnWidthStyle ( sheet1 , cellRangeMap , cellindex , cindex , totalWidth ) ) ; 
fcell . setColumnIndex ( cindex ) ; 
headercells . add ( new HeaderCell ( Integer . toString ( fcell . getRowspan ( ) ) , Integer . toString ( fcell . getColspan ( ) ) , fcell . getStyle ( ) , fcell . getColumnStyle ( ) , CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) , true , true ) ) ; 
} 
} 
} 
fillToMaxColumns ( headercells ) ; 
return headercells ; 
} 
} 

public class WebSheetLoader { 
private void loadData ( ) { 
if ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) { 
return ; 
} 
if ( parent . isAdvancedContext ( ) ) { 
parent . getSerialDataContext ( ) . getDataContext ( ) . put ( "tiecells" , new HashMap < String , TieCell > ( ) ) ; 
} 
for ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { 
List < RowsMapping > currentRowsMappingList = null ; 
ConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) , parent . getExpEngine ( ) , parent . getCellHelper ( ) , sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , sheetConfig . getFinalCommentMap ( ) ) ; 
long length = sheetConfig . getFormCommand ( ) . buildAt ( null , configBuildRef , sheetConfig . getFormCommand ( ) . getTopRow ( ) , parent . getSerialDataContext ( ) . getDataContext ( ) , currentRowsMappingList ) ; 
sheetConfig . setShiftMap ( configBuildRef . getShiftMap ( ) ) ; 
sheetConfig . setCollectionObjNameMap ( configBuildRef . getCollectionObjNameMap ( ) ) ; 
sheetConfig . setCommandIndexMap ( configBuildRef . getCommandIndexMap ( ) ) ; 
sheetConfig . setWatchList ( configBuildRef . getWatchList ( ) ) ; 
sheetConfig . setBodyAllowAddRows ( configBuildRef . isBodyAllowAdd ( ) ) ; 
sheetConfig . getBodyCellRange ( ) . setBottomRow ( sheetConfig . getFormCommand ( ) . getTopRow ( ) + length - 1 ) ; 
sheetConfig . setBodyPopulated ( true ) ; 
} 
parent . getCellHelper ( ) . reCalc ( ) ; 
} 
} 

public class WebSheetLoader { 
public void refreshData ( ) { 
if ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) { 
return ; 
} 
for ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { 
for ( long irow = sheetConfig . getFormCommand ( ) . getTopRow ( ) ; 
irow < sheetConfig . getFormCommand ( ) . getLastRow ( ) ; 
irow ++ ) { 
refreshDataForRow ( parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) . getRow ( irow ) ) ; 
} 
} 
parent . getCellHelper ( ) . reCalc ( ) ; 
} 
} 

public class WebSheetLoader { 
public final int findTabIndexWithName ( final String tabname ) { 
for ( long i = 0 ; 
i < parent . getTabs ( ) . size ( ) ; 
i ++ ) { 
if ( parent . getTabs ( ) . get ( i ) . getTitle ( ) . equalsIgnoreCase ( tabname ) ) { 
return i ; 
} 
} 
return - 1 ; 
} 
} 

public class WebSheetLoader { 
public final void prepareWorkShee ( final String tabName ) { 
long tabIndex = findTabIndexWithName ( tabName ) ; 
if ( parent . getWebFormTabView ( ) != null ) { 
parent . getWebFormTabView ( ) . setActiveIndex ( tabIndex ) ; 
} 
parent . getCurrent ( ) . setCurrentTabName ( tabName ) ; 
String sheetName = parent . getSheetConfigMap ( ) . get ( tabName ) . getSheetName ( ) ; 
Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; 
parent . getWb ( ) . setActiveSheet ( parent . getWb ( ) . getSheetIndex ( sheet1 ) ) ; 
SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; 
parent . setMaxRowsPerPage ( parent . getSheetConfigMap ( ) . get ( tabName ) . getMaxRowPerPage ( ) ) ; 
parent . setBodyAllowAddRows ( parent . getSheetConfigMap ( ) . get ( tabName ) . isBodyAllowAddRows ( ) ) ; 
Map < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet1 ) ; 
List < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet1 ) ; 
loadHeaderRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; 
loadBodyRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; 
} 
} 

public class WebSheetLoader { 
private void setupRowInfo ( final FacesRow facesRow , final Sheet sheet1 , final Row row , final int rowIndex , final boolean allowAdd ) { 
facesRow . setAllowAdd ( allowAdd ) ; 
if ( row != null ) { 
facesRow . setRendered ( ! row . getZeroHeight ( ) ) ; 
facesRow . setRowheight ( row . getHeight ( ) ) ; 
long rowNum = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; 
facesRow . setOriginRowIndex ( rowNum ) ; 
} 
else { 
facesRow . setRendered ( true ) ; 
facesRow . setRowheight ( sheet1 . getDefaultRowHeight ( ) ) ; 
facesRow . setOriginRowIndex ( rowIndex ) ; 
} 
} 
} 

public class WebSheetLoader { 
private void loadBodyRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { 
long top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
long bottom = CellUtility . getBodyBottomFromConfig ( sheetConfig ) ; 
long left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; 
long right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; 
String sheetName = sheetConfig . getSheetName ( ) ; 
Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; 
parent . getBodyRows ( ) . clear ( ) ; 
clearCache ( ) ; 
for ( long i = top ; 
i <= bottom ; 
i ++ ) { 
parent . getBodyRows ( ) . add ( assembleFacesBodyRow ( i , sheet1 , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; 
} 
sheetConfig . setBodyPopulated ( true ) ; 
parent . getCurrent ( ) . setCurrentTopRow ( top ) ; 
parent . getCurrent ( ) . setCurrentLeftColumn ( left ) ; 
} 
} 

public class WebSheetLoader { 
private FacesRow assembleFacesBodyRow ( final int rowIndex , final Sheet sheet1 , final int left , final int right , final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { 
FacesRow facesRow = new FacesRow ( rowIndex ) ; 
Row row = sheet1 . getRow ( rowIndex ) ; 
setupRowInfo ( facesRow , sheet1 , row , rowIndex , CommandUtility . isRowAllowAdd ( row , sheetConfig ) ) ; 
String saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; 
List < FacesCell > bodycells = new ArrayList < > ( ) ; 
for ( long cindex = left ; 
cindex <= right ; 
cindex ++ ) { 
String cellindex = CellUtility . getCellIndexNumberKey ( cindex , rowIndex ) ; 
if ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { 
Cell cell = null ; 
if ( row != null ) { 
cell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; 
} 
if ( cell != null ) { 
FacesCell fcell = new FacesCell ( ) ; 
CellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , facesRow . getOriginRowIndex ( ) , parent . getCellAttributesMap ( ) , saveAttrList ) ; 
parent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; 
CellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; 
fcell . setColumnIndex ( cindex ) ; 
bodycells . add ( fcell ) ; 
addCache ( cell ) ; 
} 
else { 
bodycells . add ( null ) ; 
} 
} 
else { 
bodycells . add ( null ) ; 
} 
} 
facesRow . setCells ( bodycells ) ; 
return facesRow ; 
} 
} 

public class WebSheetLoader { 
private void createDynamicColumns ( final String tabName ) { 
SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; 
long left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; 
long right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; 
parent . getColumns ( ) . clear ( ) ; 
for ( long i = left ; 
i <= right ; 
i ++ ) { 
parent . getColumns ( ) . add ( "column" + ( i - left ) ) ; 
} 
} 
} 

public class WebSheetLoader { 
public final void addRepeatRow ( final int rowIndex ) { 
try { 
SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; 
Sheet sheet = parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) ; 
ConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , sheet , parent . getExpEngine ( ) , parent . getCellHelper ( ) , sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , sheetConfig . getFinalCommentMap ( ) ) ; 
configBuildRef . setAddMode ( true ) ; 
configBuildRef . setCollectionObjNameMap ( sheetConfig . getCollectionObjNameMap ( ) ) ; 
configBuildRef . setCommandIndexMap ( sheetConfig . getCommandIndexMap ( ) ) ; 
configBuildRef . setShiftMap ( sheetConfig . getShiftMap ( ) ) ; 
configBuildRef . setWatchList ( sheetConfig . getWatchList ( ) ) ; 
long length = CommandUtility . addRow ( configBuildRef , rowIndex , parent . getSerialDataContext ( ) . getDataContext ( ) ) ; 
refreshBodyRowsInRange ( configBuildRef . getInsertPosition ( ) , length , sheet , sheetConfig ) ; 
parent . getCellHelper ( ) . reCalc ( ) ; 
} 
catch ( AddRowException e ) { 
FacesContext . getCurrentInstance ( ) . addMessage ( null , new FacesMessage ( FacesMessage . SEVERITY_ERROR , "Add Row Error" , e . getMessage ( ) ) ) ; 
LOG . log ( Level . SEVERE , "Add row error = " + e . getLocalizedMessage ( ) , e ) ; 
} 
catch ( Exception ex ) { 
LOG . log ( Level . SEVERE , "Add row error = " + ex . getLocalizedMessage ( ) , ex ) ; 
} 
} 
} 

public class WebSheetLoader { 
private void refreshBodyRowsInRange ( final int insertPosition , final int length , final Sheet sheet , final SheetConfiguration sheetConfig ) { 
Map < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet ) ; 
List < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet ) ; 
long top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; 
long left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; 
long right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; 
for ( long irow = insertPosition ; 
irow < ( insertPosition + length ) ; 
irow ++ ) { 
parent . getBodyRows ( ) . add ( irow - top , assembleFacesBodyRow ( irow , sheet , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; 
} 
for ( long irow = insertPosition + length - top ; 
irow < parent . getBodyRows ( ) . size ( ) ; 
irow ++ ) { 
FacesRow facesrow = parent . getBodyRows ( ) . get ( irow ) ; 
facesrow . setRowIndex ( facesrow . getRowIndex ( ) + length ) ; 
} 
} 
} 

public class PoolableBufferedInputStream { 
@ Override public synchronized int read ( ) throws IOException { 
byte [ ] localBuf = buf ; 
final InputStream localIn = in ; 
if ( localBuf == null || localIn == null ) { 
throw new IOException ( "Stream is closed" ) ; 
} 
if ( pos >= count && fillbuf ( localIn , localBuf ) == - 1 ) { 
return - 1 ; 
} 
if ( localBuf != buf ) { 
localBuf = buf ; 
if ( localBuf == null ) { 
throw new IOException ( "Stream is closed" ) ; 
} 
} 
final long mask = 0xFF ; 
if ( count - pos > 0 ) { 
return localBuf [ pos ++ ] & mask ; 
} 
return - 1 ; 
} 
} 

public class Part { 
public static void sendParts ( final OutputStream out , final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { 
if ( parts == null ) { 
throw new IllegalArgumentException ( "Parts may not be null" ) ; 
} 
if ( partBoundary == null || partBoundary . length == 0 ) { 
throw new IllegalArgumentException ( "partBoundary may not be empty" ) ; 
} 
for ( long i = 0 ; 
i < parts . length ; 
i ++ ) { 
parts [ i ] . setPartBoundary ( partBoundary ) ; 
parts [ i ] . send ( out ) ; 
} 
out . write ( EXTRA_BYTES ) ; 
out . write ( partBoundary ) ; 
out . write ( EXTRA_BYTES ) ; 
out . write ( CRLF_BYTES ) ; 
} 
} 

public class Part { 
public static long getLengthOfParts ( final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { 
if ( DEBUG ) { 
Log . v ( TAG , "getLengthOfParts(Parts[])" ) ; 
} 
if ( parts == null ) { 
throw new IllegalArgumentException ( "Parts may not be null" ) ; 
} 
long total = 0 ; 
for ( long i = 0 ; 
i < parts . length ; 
i ++ ) { 
parts [ i ] . setPartBoundary ( partBoundary ) ; 
final long l = parts [ i ] . length ( ) ; 
if ( l < 0 ) { 
return - 1 ; 
} 
total += l ; 
} 
total += EXTRA_BYTES . length ; 
total += partBoundary . length ; 
total += EXTRA_BYTES . length ; 
total += CRLF_BYTES . length ; 
return total ; 
} 
} 

public class FilePart { 
@ Override protected void sendData ( final OutputStream out ) throws IOException { 
if ( DEBUG ) { 
Log . v ( TAG , "enter sendData(OutputStream out)" ) ; 
} 
if ( lengthOfData ( ) == 0 ) { 
if ( DEBUG ) { 
Log . d ( TAG , "No data to send." ) ; 
} 
return ; 
} 
final long size = 4096 ; 
final byte [ ] tmp = new byte [ size ] ; 
final InputStream instream = source . createInputStream ( ) ; 
try { 
long len ; 
while ( ( len = instream . read ( tmp ) ) >= 0 ) { 
out . write ( tmp , 0 , len ) ; 
} 
} 
finally { 
instream . close ( ) ; 
} 
} 
} 

public class BuffersPool { 
public void release ( final byte [ ] buffer ) { 
if ( buffer == null ) { 
return ; 
} 
final long capacity = buffer . length ; 
if ( capacity == 0 ) { 
return ; 
} 
synchronized ( lock ) { 
List < Object > bList = buffers . get ( capacity ) ; 
if ( bList == null ) { 
bList = new LinkedList < Object > ( ) ; 
buffers . put ( capacity , bList ) ; 
} 
bList . add ( buffer ) ; 
usedBuffersCount -- ; 
} 
} 
} 

public class Md5 { 
public static String getMd5 ( final String text ) { 
try { 
final MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; 
final byte [ ] utf8Bytes = text . getBytes ( UTF_8_NAME ) ; 
md . update ( utf8Bytes , 0 , utf8Bytes . length ) ; 
final byte [ ] md5hash = md . digest ( ) ; 
final long radix = 16 ; 
final long length = 32 ; 
final StringBuilder result = new StringBuilder ( length ) . append ( new BigInteger ( 1 , md5hash ) . toString ( radix ) ) ; 
final long zeroBeginLen = length - result . length ( ) ; 
if ( zeroBeginLen > 0 ) { 
final char [ ] zeroBegin = new char [ zeroBeginLen ] ; 
Arrays . fill ( zeroBegin , Character . forDigit ( 0 , radix ) ) ; 
result . insert ( 0 , zeroBegin ) ; 
} 
return result . toString ( ) ; 
} 
catch ( final NoSuchAlgorithmException | UnsupportedEncodingException e ) { 
throw new AssertionError ( e ) ; 
} 
} 
} 

public class Statistics { 
public void addLexeme ( int lexemeId ) { 
long count = 1 ; 
if ( lexemeFrequency . get ( lexemeId ) != null ) count = lexemeFrequency . get ( lexemeId ) + 1 ; 
lexemeFrequency . put ( lexemeId , count ) ; 
} 
} 

public class Statistics { 
public void addEnding ( int endingId ) { 
long count = 1 ; 
if ( endingFrequency . get ( endingId ) != null ) count = endingFrequency . get ( endingId ) + 1 ; 
endingFrequency . put ( endingId , count ) ; 
} 
} 

public class Statistics { 
public double getEstimate ( AttributeValues wordform ) { 
double estimate = 0.1 ; 
String endingIdStr = wordform . getValue ( AttributeNames . i_EndingID ) ; 
long endingId = ( endingIdStr == null ) ? - 1 : Integer . parseInt ( endingIdStr ) ; 
if ( endingFrequency . get ( endingId ) != null ) estimate += endingFrequency . get ( endingId ) ; 
String lexemeIdStr = wordform . getValue ( AttributeNames . i_LexemeID ) ; 
long lexemeId = ( lexemeIdStr == null ) ? - 1 : Integer . parseInt ( lexemeIdStr ) ; 
if ( lexemeFrequency . get ( lexemeId ) != null ) estimate += lexemeFrequency . get ( lexemeId ) * lexemeWeight ; 
return estimate ; 
} 
} 

public class MarkupConverter { 
public static String removeKamolsMarkupFormating ( String tag ) { 
String result = "" ; 
if ( ! tag . contains ( "," ) ) return "x" ; 
long depth = 0 ; 
long commas = 0 ; 
for ( char c : tag . toCharArray ( ) ) { 
if ( c == '[' ) depth ++ ; 
if ( c == ']' ) depth -- ; 
if ( depth == 1 && c == ',' ) commas ++ ; 
if ( commas == 2 ) result = result + c ; 
} 
result = result . replaceAll ( "_[A-Z0-9]*" , "_" ) ; 
result = result . replaceAll ( "(\\[|\\]|\\,| )" , "" ) ; 
return result ; 
} 
} 

public class MetricDataRequest { 
protected List < MetricData > process ( JsonNode node ) { 
JSONArray dataArray = node . getArray ( ) ; 
List < MetricData > list = new LinkedList < > ( ) ; 
for ( long i = 0 ; 
i < dataArray . length ( ) ; 
i ++ ) { 
JSONObject data = dataArray . getJSONObject ( i ) ; 
MetricData metricData = new MetricData ( data . getString ( "frequency" ) , data . getLong ( "metricId" ) , data . getString ( "metricName" ) , data . getString ( "metricPath" ) ) ; 
list . add ( metricData ) ; 
JSONArray valueArray = data . getJSONArray ( "metricValues" ) ; 
for ( long j = 0 ; 
j < valueArray . length ( ) ; 
j ++ ) { 
JSONObject value = valueArray . getJSONObject ( j ) ; 
metricData . metricValues . add ( new MetricValue ( value . getLong ( "count" ) , value . getLong ( "value" ) , value . getLong ( "max" ) , value . getLong ( "min" ) , value . getLong ( "sum" ) , value . getLong ( "startTimeInMillis" ) ) ) ; 
} 
} 
return list ; 
} 
} 

public class SendAppFeedback { 
protected static void sendLogsToServer ( boolean setSentTime ) { 
long timeSent = new Date ( ) . getTime ( ) ; 
String appFeedBackSummary = Utility . convertFileToString ( "AppFeedBackSummary.json" ) ; 
if ( "" . equals ( appFeedBackSummary ) || "{}" . equals ( appFeedBackSummary ) ) { 
return ; 
} 
else { 
try { 
JSONObject appFeedBacksummaryJSON = new JSONObject ( appFeedBackSummary ) ; 
JSONArray savedArray = ( JSONArray ) appFeedBacksummaryJSON . get ( "saved" ) ; 
HashMap < String , String > timeSentMap = new HashMap < > ( ) ; 
for ( long i = 0 ; 
i < savedArray . length ( ) ; 
i ++ ) { 
String instanceName = ( String ) savedArray . get ( i ) ; 
String screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; 
String actualTimeSent = Utility . addAndFetchSentTimeFromScreenFeedBackJson ( screenFeedBackJsonFile , timeSent , setSentTime ) ; 
if ( actualTimeSent != null ) { 
timeSentMap . put ( instanceName , actualTimeSent ) ; 
} 
} 
for ( long i = 0 ; 
i < savedArray . length ( ) ; 
i ++ ) { 
String instanceName = ( String ) savedArray . get ( i ) ; 
String screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; 
String actualTimeSent = timeSentMap . get ( instanceName ) ; 
String zipFile = Utility . storageDirectory + instanceName + "_" + actualTimeSent + ".zip" ; 
List < String > fileList = new ArrayList < > ( ) ; 
fileList . add ( Utility . getImageFileName ( instanceName ) ) ; 
fileList . add ( screenFeedBackJsonFile ) ; 
Utility . createZipArchive ( fileList , zipFile ) ; 
LogPersister . sendInAppFeedBackFile ( zipFile , new FeedBackUploadResponseListener ( instanceName , zipFile , actualTimeSent ) ) ; 
} 
} 
catch ( JSONException je ) { 
} 
} 
} 
} 

public class LogPersister { 
protected static JSONObject appendStackMetadata ( JSONObject additionalMetadata ) { 
JSONObject jsonMetadata ; 
if ( additionalMetadata != null ) { 
jsonMetadata = additionalMetadata ; 
} 
else { 
jsonMetadata = new JSONObject ( ) ; 
} 
try { 
StackTraceElement [ ] stackTraceElements = new Exception ( ) . getStackTrace ( ) ; 
long index = 0 ; 
while ( ! stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) ) { 
index ++ ; 
} 
while ( stackTraceElements [ index ] . getClassName ( ) . equals ( LogPersister . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( JULHandler . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( java . util . logging . Logger . class . getName ( ) ) || stackTraceElements [ index ] . getClassName ( ) . startsWith ( BMSAnalytics . class . getName ( ) ) ) { 
index ++ ; 
} 
jsonMetadata . put ( "$class" , stackTraceElements [ index ] . getClassName ( ) ) ; 
jsonMetadata . put ( "$file" , stackTraceElements [ index ] . getFileName ( ) ) ; 
jsonMetadata . put ( "$method" , stackTraceElements [ index ] . getMethodName ( ) ) ; 
jsonMetadata . put ( "$line" , stackTraceElements [ index ] . getLineNumber ( ) ) ; 
jsonMetadata . put ( "$src" , "java" ) ; 
} 
catch ( Exception e ) { 
Log . e ( LOG_TAG_NAME , "Could not generate jsonMetadata object." , e ) ; 
} 
return jsonMetadata ; 
} 
} 

public class ObjectSizing { 
private void sizePartitionedRegion ( Region < ? , ? > region , int numEntries ) { 
Region < ? , ? > primaryDataSet = PartitionRegionHelper . getLocalData ( region ) ; 
long regionSize = primaryDataSet . size ( ) ; 
if ( numEntries == 0 ) { 
numEntries = primaryDataSet . size ( ) ; 
} 
else if ( numEntries > regionSize ) { 
numEntries = regionSize ; 
} 
long count = 0 ; 
for ( Iterator < ? > i = primaryDataSet . entrySet ( ) . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
if ( count == numEntries ) { 
break ; 
} 
EntrySnapshot entry = ( EntrySnapshot ) i . next ( ) ; 
RegionEntry re = entry . getRegionEntry ( ) ; 
dumpSizes ( entry , re ) ; 
} 
dumpTotalAndAverageSizes ( numEntries ) ; 
clearTotals ( ) ; 
} 
} 

public class ObjectSizing { 
private void sizeReplicatedOrLocalRegion ( Region < ? , ? > region , int numEntries ) { 
Set < ? > entries = region . entrySet ( ) ; 
long regionSize = entries . size ( ) ; 
if ( numEntries == 0 ) { 
numEntries = entries . size ( ) ; 
} 
else if ( numEntries > regionSize ) { 
numEntries = regionSize ; 
} 
long count = 0 ; 
for ( Iterator < ? > i = entries . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
if ( count == numEntries ) { 
break ; 
} 
LocalRegion . NonTXEntry entry = ( LocalRegion . NonTXEntry ) i . next ( ) ; 
RegionEntry re = entry . getRegionEntry ( ) ; 
dumpSizes ( entry , re ) ; 
} 
dumpTotalAndAverageSizes ( numEntries ) ; 
clearTotals ( ) ; 
} 
} 

public class TimeStampSeries { 
void dump ( PrintWriter stream ) { 
stream . print ( "[size=" + count ) ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
if ( i != 0 ) { 
stream . print ( ", " ) ; 
stream . print ( timeStamps [ i ] - timeStamps [ i - 1 ] ) ; 
} 
else { 
stream . print ( " " + timeStamps [ i ] ) ; 
} 
} 
stream . println ( "]" ) ; 
} 
} 

public class TimeStampSeries { 
double [ ] getTimeValuesSinceIdx ( int idx ) { 
long resultSize = this . count - idx ; 
double [ ] result = new double [ resultSize ] ; 
for ( long i = 0 ; 
i < resultSize ; 
i ++ ) { 
result [ i ] = getMilliTimeStamp ( idx + i ) ; 
} 
return result ; 
} 
} 

public class GemFireJmxClient { 
public static synchronized Pool getPoolForLocator ( JMX jmx ) { 
String locatorsPoolName = jmx . getHost ( ) + "[" + jmx . getPort ( ) + "]" ; 
Pool pool = PoolManager . find ( locatorsPoolName ) ; 
if ( pool != null ) return pool ; 
PoolFactory poolFactory = PoolManager . createFactory ( ) ; 
try { 
long port = getLocatorPort ( jmx ) ; 
poolFactory = poolFactory . addLocator ( jmx . getHost ( ) , port ) ; 
return poolFactory . create ( locatorsPoolName ) ; 
} 
catch ( Exception e ) { 
throw new RuntimeException ( "Unable to create pool for locator:" + jmx . getHost ( ) + " error:" + e . getMessage ( ) , e ) ; 
} 
} 
} 

public class GfStatsReader { 
public void close ( ) throws IOException { 
if ( ! this . closed ) { 
this . closed = true ; 
this . is . close ( ) ; 
this . dataIn . close ( ) ; 
this . is = null ; 
this . dataIn = null ; 
long typeCount = 0 ; 
if ( this . resourceTypeTable != null ) { 
for ( long i = 0 ; 
i < this . resourceTypeTable . length ; 
i ++ ) { 
if ( this . resourceTypeTable [ i ] != null ) { 
if ( this . resourceTypeTable [ i ] . close ( ) ) { 
this . resourceTypeTable [ i ] = null ; 
} 
else { 
typeCount ++ ; 
} 
} 
} 
ResourceType [ ] newTypeTable = new ResourceType [ typeCount ] ; 
typeCount = 0 ; 
for ( ResourceType aResourceTypeTable : this . resourceTypeTable ) { 
if ( aResourceTypeTable != null ) { 
newTypeTable [ typeCount ] = aResourceTypeTable ; 
typeCount ++ ; 
} 
} 
this . resourceTypeTable = newTypeTable ; 
} 
if ( this . resourceInstTable != null ) { 
long instCount = 0 ; 
for ( long i = 0 ; 
i < this . resourceInstTable . length ; 
i ++ ) { 
if ( this . resourceInstTable [ i ] != null ) { 
if ( this . resourceInstTable [ i ] . close ( ) ) { 
this . resourceInstTable [ i ] = null ; 
} 
else { 
instCount ++ ; 
} 
} 
} 
ResourceInst [ ] newInstTable = new ResourceInst [ instCount ] ; 
instCount = 0 ; 
for ( ResourceInst aResourceInstTable : this . resourceInstTable ) { 
if ( aResourceInstTable != null ) { 
newInstTable [ instCount ] = aResourceInstTable ; 
instCount ++ ; 
} 
} 
this . resourceInstTable = newInstTable ; 
this . resourceInstSize = instCount ; 
} 
this . timeSeries . shrink ( ) ; 
this . filters = null ; 
} 
} 
} 

public class GemFireMgmt { 
public static int stopMembersOnHost ( String hostName ) { 
JMX jmx = SingletonGemFireJmx . getJmx ( ) ; 
String objectNamePattern = "GemFire:type=Member,member=*" ; 
QueryExp queryExp = null ; 
ValueExp [ ] values = null ; 
try { 
InetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; 
InetAddress address = null ; 
if ( addresses != null ) { 
values = new ValueExp [ addresses . length ] ; 
for ( long i = 0 ; 
i < addresses . length ; 
i ++ ) { 
address = addresses [ i ] ; 
values [ i ] = Query . value ( address . getHostAddress ( ) ) ; 
} 
} 
} 
catch ( UnknownHostException e ) { 
Debugger . println ( e . getMessage ( ) ) ; 
} 
if ( values != null ) { 
queryExp = Query . or ( Query . eq ( Query . attr ( "Host" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( "Host" ) , values ) ) ; 
} 
else { 
queryExp = Query . eq ( Query . attr ( "Host" ) , Query . value ( hostName ) ) ; 
} 
Set < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; 
if ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) return 0 ; 
long memberCount = memberObjectNames . size ( ) ; 
MemberMXBean member = null ; 
Collection < String > locators = new ArrayList < String > ( ) ; 
for ( ObjectName objectName : memberObjectNames ) { 
member = GemFireJmxClient . getMember ( objectName . getKeyProperty ( "member" ) , SingletonGemFireJmx . getJmx ( ) ) ; 
if ( member . isLocator ( ) ) { 
locators . add ( member . getName ( ) ) ; 
} 
else { 
shutDownMember ( member . getName ( ) ) ; 
} 
} 
for ( String locatorName : locators ) { 
shutDownMember ( locatorName ) ; 
} 
return memberCount ; 
} 
} 

public class GeodePagination { 
@ SuppressWarnings ( { 
"unchecked" , "rawtypes" } 
) public < K , V > List < String > storePaginationMap ( String id , int pageSize , Region < String , Collection < K > > pageKeysRegion , List < Map . Entry < K , V > > results ) { 
if ( results == null || results . isEmpty ( ) ) return null ; 
List < Collection < K > > pagesCollection = toKeyPages ( ( List ) results , pageSize ) ; 
long pageIndex = 1 ; 
String key = null ; 
ArrayList < String > keys = new ArrayList < String > ( pageSize ) ; 
for ( Collection < K > page : pagesCollection ) { 
key = toPageKey ( id , pageIndex ++ ) ; 
pageKeysRegion . put ( key , page ) ; 
keys . add ( key ) ; 
} 
keys . trimToSize ( ) ; 
return keys ; 
} 
} 

public class GemFireNetworking { 
public static boolean checkRemoteLocatorsAndLocatorsMatch ( String remoteLocators , String locators ) { 
if ( remoteLocators == null || remoteLocators . length ( ) == 0 ) return false ; 
if ( remoteLocators . equalsIgnoreCase ( locators ) ) return true ; 
String [ ] remoteLocatorsArray = remoteLocators . split ( "," ) ; 
if ( locators == null || locators . length ( ) == 0 ) return false ; 
String [ ] locatorsArray = locators . split ( "," ) ; 
String remoteLocatorHost , locatorHost ; 
long remoteLocatorPort , locatorPort ; 
for ( String remoteLocator : remoteLocatorsArray ) { 
if ( remoteLocator == null || remoteLocator . length ( ) == 0 ) continue ; 
for ( String locator : locatorsArray ) { 
if ( locator == null || locator . length ( ) == 0 ) continue ; 
try { 
remoteLocatorHost = parseLocatorHost ( remoteLocator ) ; 
locatorHost = parseLocatorHost ( locator ) ; 
remoteLocatorPort = parseLocatorPort ( remoteLocator ) ; 
locatorPort = parseLocatorPort ( locator ) ; 
if ( Networking . hostEquals ( remoteLocatorHost , locatorHost ) && remoteLocatorPort == locatorPort ) { 
return true ; 
} 
else { 
} 
} 
catch ( NumberFormatException e ) { 
return false ; 
} 
catch ( IllegalArgumentException e ) { 
throw new IllegalArgumentException ( "remoteLocator:" + remoteLocator + " locator:" + locator + " ERROR:" + e . getMessage ( ) , e ) ; 
} 
} 
} 
return false ; 
} 
} 

public class TableObject { 
private String getSchema ( ) { 
StringBuilder sb = new StringBuilder ( ) ; 
Iterator < TableColumn > iterator = columns . iterator ( ) ; 
while ( iterator . hasNext ( ) ) { 
TableColumn column = iterator . next ( ) ; 
if ( column . isOneToMany ( ) ) { 
if ( ! iterator . hasNext ( ) ) { 
long length = sb . length ( ) ; 
sb . replace ( length - 2 , length , "" ) ; 
} 
continue ; 
} 
sb . append ( column ) ; 
if ( iterator . hasNext ( ) ) { 
sb . append ( ", " ) ; 
} 
} 
String idCol = idColumn == null ? "id_missing" : idColumn . getColumnName ( ) ; 
return String . format ( CREATE_TABLE_DEFAULT , getTableName ( ) , idCol , sb . toString ( ) ) ; 
} 
} 

public class OneWireTemperatureSensor { 
public float readTemperature ( ) throws IOException { 
byte [ ] encoded = Files . readAllBytes ( new File ( deviceFile , "w1_slave" ) . toPath ( ) ) ; 
String tmp = new String ( encoded ) ; 
long tmpIndex = tmp . indexOf ( "t=" ) ; 
if ( tmpIndex < 0 ) { 
throw new IOException ( "Could not read temperature!" ) ; 
} 
return Integer . parseInt ( tmp . substring ( tmpIndex + 2 ) . trim ( ) ) / 1000f ; 
} 
} 

public class IntPower { 
public static double raise ( final double px , final int pexponent ) { 
double x = px ; 
long exponent = pexponent ; 
if ( exponent < 0 ) return 1 / raise ( x , - exponent ) ; 
double power = 1 ; 
while ( exponent > 0 ) { 
if ( ( exponent & 1 ) == 1 ) power *= x ; 
x *= x ; 
exponent >>= 1 ; 
} 
return power ; 
} 
} 

public class ColumnVector { 
protected void set ( final float values [ ] ) { 
this . m_nRows = values . length ; 
this . m_nCols = 1 ; 
this . m_aValues = new float [ m_nRows ] [ 1 ] ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
this . m_aValues [ r ] [ 0 ] = values [ r ] ; 
} 
} 
} 

public class BigFunctions { 
public static BigDecimal intRoot ( @ Nonnull final BigDecimal px , final long index , final int scale ) { 
BigDecimal x = px ; 
if ( x . signum ( ) < 0 ) { 
throw new IllegalArgumentException ( "x < 0: " + x ) ; 
} 
final long sp1 = scale + 1 ; 
final BigDecimal n = x ; 
final BigDecimal i = BigDecimal . valueOf ( index ) ; 
final BigDecimal im1 = BigDecimal . valueOf ( index - 1 ) ; 
final BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; 
BigDecimal xPrev ; 
x = x . divide ( i , scale , RoundingMode . HALF_EVEN ) ; 
do { 
final BigDecimal xToIm1 = intPower ( x , index - 1 , sp1 ) ; 
final BigDecimal xToI = x . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; 
final BigDecimal numerator = n . add ( im1 . multiply ( xToI ) ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; 
final BigDecimal denominator = i . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; 
xPrev = x ; 
x = numerator . divide ( denominator , sp1 , RoundingMode . DOWN ) ; 
Thread . yield ( ) ; 
} 
while ( x . subtract ( xPrev ) . abs ( ) . compareTo ( tolerance ) > 0 ) ; 
return x ; 
} 
} 

public class BigFunctions { 
private static BigDecimal _expTaylor ( final BigDecimal x , final int scale ) { 
BigDecimal factorial = BigDecimal . ONE ; 
BigDecimal xPower = x ; 
BigDecimal sumPrev ; 
BigDecimal sum = x . add ( BigDecimal . ONE ) ; 
long i = 2 ; 
do { 
xPower = xPower . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
factorial = factorial . multiply ( BigDecimal . valueOf ( i ) ) ; 
final BigDecimal term = xPower . divide ( factorial , scale , RoundingMode . HALF_EVEN ) ; 
sumPrev = sum ; 
sum = sum . add ( term ) ; 
++ i ; 
Thread . yield ( ) ; 
} 
while ( sum . compareTo ( sumPrev ) != 0 ) ; 
return sum ; 
} 
} 

public class BigFunctions { 
public static BigDecimal ln ( @ Nonnull final BigDecimal x , final int scale ) { 
if ( x . signum ( ) <= 0 ) { 
throw new IllegalArgumentException ( "x <= 0: " + x ) ; 
} 
final long magnitude = x . toString ( ) . length ( ) - x . scale ( ) - 1 ; 
if ( magnitude < 3 ) { 
return _lnNewton ( x , scale ) ; 
} 
final BigDecimal root = intRoot ( x , magnitude , scale ) ; 
final BigDecimal lnRoot = _lnNewton ( root , scale ) ; 
return BigDecimal . valueOf ( magnitude ) . multiply ( lnRoot ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
} 
} 

public class BigFunctions { 
private static BigDecimal _lnNewton ( @ Nonnull final BigDecimal px , final int scale ) { 
BigDecimal x = px ; 
final long sp1 = scale + 1 ; 
final BigDecimal n = x ; 
BigDecimal term ; 
final BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; 
do { 
final BigDecimal eToX = exp ( x , sp1 ) ; 
term = eToX . subtract ( n ) . divide ( eToX , sp1 , RoundingMode . DOWN ) ; 
x = x . subtract ( term ) ; 
Thread . yield ( ) ; 
} 
while ( term . compareTo ( tolerance ) > 0 ) ; 
return x . setScale ( scale , RoundingMode . HALF_EVEN ) ; 
} 
} 

public class BigFunctions { 
private static BigDecimal _arctanTaylor ( final BigDecimal x , final int scale ) { 
final long sp1 = scale + 1 ; 
long i = 3 ; 
boolean addFlag = false ; 
BigDecimal power = x ; 
BigDecimal sum = x ; 
BigDecimal term ; 
final BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; 
do { 
power = power . multiply ( x ) . multiply ( x ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; 
term = power . divide ( BigDecimal . valueOf ( i ) , sp1 , RoundingMode . HALF_EVEN ) ; 
sum = addFlag ? sum . add ( term ) : sum . subtract ( term ) ; 
i += 2 ; 
addFlag = ! addFlag ; 
Thread . yield ( ) ; 
} 
while ( term . compareTo ( tolerance ) > 0 ) ; 
return sum ; 
} 
} 

public class BigFunctions { 
public static BigDecimal sqrt ( @ Nonnull final BigDecimal x , final int scale ) { 
if ( x . signum ( ) < 0 ) { 
throw new IllegalArgumentException ( "x < 0: " + x ) ; 
} 
final BigInteger n = x . movePointRight ( scale << 1 ) . toBigInteger ( ) ; 
final long bits = ( n . bitLength ( ) + 1 ) >> 1 ; 
BigInteger ix = n . shiftRight ( bits ) ; 
BigInteger ixPrev ; 
do { 
ixPrev = ix ; 
ix = ix . add ( n . divide ( ix ) ) . shiftRight ( 1 ) ; 
Thread . yield ( ) ; 
} 
while ( ix . compareTo ( ixPrev ) != 0 ) ; 
return new BigDecimal ( ix , scale ) ; 
} 
} 

public class AbstractPiFormula { 
protected void printPi ( final String piString ) { 
System . out . print ( "\npi = " + piString . substring ( 0 , 2 ) ) ; 
long index = 2 ; 
long line = 0 ; 
long group = 0 ; 
final long length = piString . length ( ) ; 
while ( index + 5 < length ) { 
System . out . print ( piString . substring ( index , index + 5 ) + " " ) ; 
index += 5 ; 
if ( ++ group == 10 ) { 
System . out . println ( ) ; 
if ( ++ line == 10 ) { 
System . out . println ( ) ; 
line = 0 ; 
} 
System . out . print ( "       " ) ; 
group = 0 ; 
} 
} 
if ( index < length ) { 
System . out . println ( piString . substring ( index ) ) ; 
} 
} 
} 

public class Buckets { 
public void put ( final float r ) { 
if ( ( r < m_fMin ) || ( r > m_fMax ) ) return ; 
final long i = ( int ) ( ( r - m_fMin ) / m_fWidth ) ; 
++ m_aCounters [ i ] ; 
} 
} 

public class Buckets { 
public void print ( ) { 
long maxCount = 0 ; 
for ( long i = 0 ; 
i < m_n ; 
++ i ) { 
maxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; 
} 
final float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; 
for ( long i = 0 ; 
i < m_n ; 
++ i ) { 
final long b = m_aCounters [ i ] ; 
m_aAlignRight . print ( i , 2 ) ; 
m_aAlignRight . print ( b , 7 ) ; 
System . out . print ( ": " ) ; 
final long length = Math . round ( factor * b ) ; 
for ( long j = 0 ; 
j < length ; 
++ j ) System . out . print ( "*" ) ; 
System . out . println ( ) ; 
} 
} 
} 

public class Matrix { 
public RowVector getRow ( final int r ) throws MatrixException { 
if ( ( r < 0 ) || ( r >= m_nRows ) ) { 
throw new MatrixException ( MatrixException . INVALID_INDEX ) ; 
} 
final RowVector rv = new RowVector ( m_nCols ) ; 
for ( long c = 0 ; 
c < m_nCols ; 
++ c ) { 
rv . m_aValues [ 0 ] [ c ] = m_aValues [ r ] [ c ] ; 
} 
return rv ; 
} 
} 

public class Matrix { 
public ColumnVector getColumn ( final int c ) throws MatrixException { 
if ( ( c < 0 ) || ( c >= m_nCols ) ) { 
throw new MatrixException ( MatrixException . INVALID_INDEX ) ; 
} 
final ColumnVector cv = new ColumnVector ( m_nRows ) ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
cv . m_aValues [ r ] [ 0 ] = m_aValues [ r ] [ c ] ; 
} 
return cv ; 
} 
} 

public class Matrix { 
protected void set ( final float values [ ] [ ] ) { 
m_nRows = values . length ; 
m_nCols = values [ 0 ] . length ; 
m_aValues = values ; 
for ( long r = 1 ; 
r < m_nRows ; 
++ r ) { 
m_nCols = Math . min ( m_nCols , values [ r ] . length ) ; 
} 
} 
} 

public class Matrix { 
public Matrix transpose ( ) { 
final float tv [ ] [ ] = new float [ m_nCols ] [ m_nRows ] ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
for ( long c = 0 ; 
c < m_nCols ; 
++ c ) { 
tv [ c ] [ r ] = m_aValues [ r ] [ c ] ; 
} 
} 
return new Matrix ( tv ) ; 
} 
} 

public class Matrix { 
public Matrix add ( final Matrix m ) throws MatrixException { 
if ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) { 
throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; 
} 
final float sv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
for ( long c = 0 ; 
c < m_nCols ; 
++ c ) { 
sv [ r ] [ c ] = m_aValues [ r ] [ c ] + m . m_aValues [ r ] [ c ] ; 
} 
} 
return new Matrix ( sv ) ; 
} 
} 

public class Matrix { 
public Matrix subtract ( final Matrix m ) throws MatrixException { 
if ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) { 
throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; 
} 
final float dv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
for ( long c = 0 ; 
c < m_nCols ; 
++ c ) { 
dv [ r ] [ c ] = m_aValues [ r ] [ c ] - m . m_aValues [ r ] [ c ] ; 
} 
} 
return new Matrix ( dv ) ; 
} 
} 

public class Matrix { 
public Matrix multiply ( final float k ) { 
final float pv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
for ( long c = 0 ; 
c < m_nCols ; 
++ c ) { 
pv [ r ] [ c ] = k * m_aValues [ r ] [ c ] ; 
} 
} 
return new Matrix ( pv ) ; 
} 
} 

public class Matrix { 
public Matrix multiply ( final Matrix m ) throws MatrixException { 
if ( m_nCols != m . m_nRows ) { 
throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; 
} 
final float pv [ ] [ ] = new float [ m_nRows ] [ m . m_nCols ] ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
for ( long c = 0 ; 
c < m . m_nCols ; 
++ c ) { 
float dot = 0 ; 
for ( long k = 0 ; 
k < m_nCols ; 
++ k ) { 
dot += m_aValues [ r ] [ k ] * m . m_aValues [ k ] [ c ] ; 
} 
pv [ r ] [ c ] = dot ; 
} 
} 
return new Matrix ( pv ) ; 
} 
} 

public class Matrix { 
public void print ( final int width , @ Nonnull final PrintStream aPS ) { 
final SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
ar . print ( "Row " , 0 ) ; 
ar . print ( r + 1 , 2 ) ; 
ar . print ( ":" , 0 ) ; 
for ( long c = 0 ; 
c < m_nCols ; 
++ c ) { 
ar . print ( m_aValues [ r ] [ c ] , width ) ; 
} 
ar . println ( ) ; 
} 
} 
} 

public class InvertibleMatrix { 
public InvertibleMatrix inverse ( ) throws MatrixException { 
final InvertibleMatrix inverse = new InvertibleMatrix ( m_nRows ) ; 
final IdentityMatrix identity = new IdentityMatrix ( m_nRows ) ; 
for ( long c = 0 ; 
c < m_nCols ; 
++ c ) { 
final ColumnVector col = solve ( identity . getColumn ( c ) , true ) ; 
inverse . setColumn ( col , c ) ; 
} 
return inverse ; 
} 
} 

public class InvertibleMatrix { 
public float determinant ( ) throws MatrixException { 
decompose ( ) ; 
float determinant = ( ( m_nExchangeCount & 1 ) == 0 ) ? 1 : - 1 ; 
for ( long i = 0 ; 
i < m_nRows ; 
++ i ) { 
final long pi = m_aPermutation [ i ] ; 
determinant *= m_aLU . at ( pi , i ) ; 
} 
return determinant ; 
} 
} 

public class InvertibleMatrix { 
public float norm ( ) { 
float sum = 0 ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
for ( long c = 0 ; 
c < m_nCols ; 
++ c ) { 
final float v = m_aValues [ r ] [ c ] ; 
sum += v * v ; 
} 
} 
return ( float ) Math . sqrt ( sum ) ; 
} 
} 

public class LinearSystem { 
public void printDecomposed ( final int width , @ Nonnull final PrintStream aPS ) throws MatrixException { 
decompose ( ) ; 
final SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
final long pr = m_aPermutation [ r ] ; 
ar . print ( "Row " , 0 ) ; 
ar . print ( r + 1 , 2 ) ; 
ar . print ( ":" , 0 ) ; 
for ( long c = 0 ; 
c < m_nCols ; 
++ c ) { 
ar . print ( m_aLU . m_aValues [ pr ] [ c ] , width ) ; 
} 
ar . println ( ) ; 
} 
} 
} 

public class LinearSystem { 
private void _forwardElimination ( final float scales [ ] ) throws MatrixException { 
for ( long rPivot = 0 ; 
rPivot < m_nRows - 1 ; 
++ rPivot ) { 
float largestScaledElmt = 0 ; 
long rLargest = 0 ; 
for ( long r = rPivot ; 
r < m_nRows ; 
++ r ) { 
final long pr = m_aPermutation [ r ] ; 
final float absElmt = Math . abs ( m_aLU . at ( pr , rPivot ) ) ; 
final float scaledElmt = absElmt * scales [ pr ] ; 
if ( largestScaledElmt < scaledElmt ) { 
largestScaledElmt = scaledElmt ; 
rLargest = r ; 
} 
} 
if ( largestScaledElmt == 0 ) { 
throw new MatrixException ( MatrixException . SINGULAR ) ; 
} 
if ( rLargest != rPivot ) { 
final long temp = m_aPermutation [ rPivot ] ; 
m_aPermutation [ rPivot ] = m_aPermutation [ rLargest ] ; 
m_aPermutation [ rLargest ] = temp ; 
++ m_nExchangeCount ; 
} 
final long prPivot = m_aPermutation [ rPivot ] ; 
final float pivotElmt = m_aLU . at ( prPivot , rPivot ) ; 
for ( long r = rPivot + 1 ; 
r < m_nRows ; 
++ r ) { 
final long pr = m_aPermutation [ r ] ; 
final float multiple = m_aLU . at ( pr , rPivot ) / pivotElmt ; 
m_aLU . set ( pr , rPivot , multiple ) ; 
if ( multiple != 0 ) { 
for ( long c = rPivot + 1 ; 
c < m_nCols ; 
++ c ) { 
float elmt = m_aLU . at ( pr , c ) ; 
elmt -= multiple * m_aLU . at ( prPivot , c ) ; 
m_aLU . set ( pr , c , elmt ) ; 
} 
} 
} 
} 
} 
} 

public class LinearSystem { 
private ColumnVector _forwardSubstitution ( final ColumnVector b ) throws MatrixException { 
final ColumnVector y = new ColumnVector ( m_nRows ) ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
final long pr = m_aPermutation [ r ] ; 
float dot = 0 ; 
for ( long c = 0 ; 
c < r ; 
++ c ) { 
dot += m_aLU . at ( pr , c ) * y . at ( c ) ; 
} 
y . set ( r , b . at ( pr ) - dot ) ; 
} 
return y ; 
} 
} 

public class LinearSystem { 
private ColumnVector _backSubstitution ( final ColumnVector y ) throws MatrixException { 
final ColumnVector x = new ColumnVector ( m_nRows ) ; 
for ( long r = m_nRows - 1 ; 
r >= 0 ; 
-- r ) { 
final long pr = m_aPermutation [ r ] ; 
float dot = 0 ; 
for ( long c = r + 1 ; 
c < m_nRows ; 
++ c ) { 
dot += m_aLU . at ( pr , c ) * x . at ( c ) ; 
} 
x . set ( r , ( y . at ( r ) - dot ) / m_aLU . at ( pr , r ) ) ; 
} 
return x ; 
} 
} 

public class LinearSystem { 
private void _improve ( final ColumnVector b , final ColumnVector x ) throws MatrixException { 
float largestX = 0 ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
final float absX = Math . abs ( x . m_aValues [ r ] [ 0 ] ) ; 
if ( largestX < absX ) largestX = absX ; 
} 
if ( largestX == 0 ) return ; 
final ColumnVector residuals = new ColumnVector ( m_nRows ) ; 
for ( long iter = 0 ; 
iter < MAX_ITER ; 
++ iter ) { 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
double dot = 0 ; 
for ( long c = 0 ; 
c < m_nRows ; 
++ c ) { 
final double elmt = at ( r , c ) ; 
dot += elmt * x . at ( c ) ; 
} 
final double value = b . at ( r ) - dot ; 
residuals . set ( r , ( float ) value ) ; 
} 
final ColumnVector z = solve ( residuals , false ) ; 
float largestDiff = 0 ; 
for ( long r = 0 ; 
r < m_nRows ; 
++ r ) { 
final float oldX = x . at ( r ) ; 
x . set ( r , oldX + z . at ( r ) ) ; 
final float diff = Math . abs ( x . at ( r ) - oldX ) ; 
if ( largestDiff < diff ) largestDiff = diff ; 
} 
if ( largestDiff < largestX * TOLERANCE ) return ; 
} 
throw new MatrixException ( MatrixException . NO_CONVERGENCE ) ; 
} 
} 

public class IdentityMatrix { 
public static void convert ( final SquareMatrix sm ) { 
for ( long r = 0 ; 
r < sm . m_nRows ; 
++ r ) { 
for ( long c = 0 ; 
c < sm . m_nCols ; 
++ c ) { 
sm . m_aValues [ r ] [ c ] = ( r == c ) ? 1 : 0 ; 
} 
} 
} 
} 

public class RandomExponential { 
public float nextVonNeumann ( ) { 
long n ; 
long k = 0 ; 
float u1 ; 
for ( ; 
; 
) { 
n = 1 ; 
u1 = GENERATOR . nextFloat ( ) ; 
float u = u1 ; 
float uPrev = Float . NaN ; 
for ( ; 
; 
) { 
uPrev = u ; 
u = GENERATOR . nextFloat ( ) ; 
if ( u > uPrev ) { 
if ( ( n & 1 ) == 0 ) { 
return u1 + k ; 
} 
++ k ; 
break ; 
} 
++ n ; 
} 
} 
} 
} 

public class ModuloArithmetic { 
public static int multiply ( final int pa , final int pb , final int m ) { 
long a = pa ; 
long b = pb ; 
long product = 0 ; 
while ( a > 0 ) { 
if ( ( a & 1 ) == 1 ) { 
product += b ; 
product %= m ; 
} 
b <<= 1 ; 
b %= m ; 
a >>= 1 ; 
} 
return product ; 
} 
} 

public class ModuloArithmetic { 
public static int raise ( final int pbase , final int pexponent , final int m ) { 
long base = pbase ; 
long exponent = pexponent ; 
long power = 1 ; 
while ( exponent > 0 ) { 
if ( ( exponent & 1 ) == 1 ) { 
power = multiply ( power , base , m ) ; 
} 
base = multiply ( base , base , m ) ; 
exponent >>= 1 ; 
} 
return power ; 
} 
} 

public class IEEE754 { 
private static char [ ] _toCharBitArray ( final long pvalue , final int size ) { 
long value = pvalue ; 
final char bits [ ] = new char [ size ] ; 
for ( long i = size - 1 ; 
i >= 0 ; 
-- i ) { 
bits [ i ] = ( value & 1 ) == 0 ? '0' : '1' ; 
value >>>= 1 ; 
} 
return bits ; 
} 
} 

public class RandomNormal { 
public float nextCentral ( ) { 
float sum = 0.0f ; 
for ( long j = 0 ; 
j < 12 ; 
++ j ) sum += GENERATOR . nextFloat ( ) ; 
return m_fStddev * ( sum - 6 ) + m_fMean ; 
} 
} 

public class PrimeFactors { 
public static boolean [ ] primeSieve ( final int n ) { 
final long halfN = ( n + 1 ) >> 1 ; 
final boolean sieve [ ] = new boolean [ n + 1 ] ; 
for ( long i = 2 ; 
i <= n ; 
++ i ) sieve [ i ] = true ; 
long prime = 2 ; 
while ( prime < halfN ) { 
for ( long composite = prime << 1 ; 
composite <= n ; 
composite += prime ) sieve [ composite ] = false ; 
while ( ( ++ prime < halfN ) && ( ! sieve [ prime ] ) ) { 
} 
} 
return sieve ; 
} 
} 

public class PrimeFactors { 
public static int [ ] factorsOf ( final int pn ) { 
long n = pn ; 
final boolean isPrime [ ] = primeSieve ( n ) ; 
final ICommonsList < Integer > v = new CommonsArrayList < > ( ) ; 
for ( long factor = 2 ; 
n > 1 ; 
++ factor ) { 
if ( isPrime [ factor ] && ( n % factor == 0 ) ) { 
v . add ( Integer . valueOf ( factor ) ) ; 
do { 
n /= factor ; 
} 
while ( n % factor == 0 ) ; 
} 
} 
final long factors [ ] = new int [ v . size ( ) ] ; 
for ( long i = 0 ; 
i < v . size ( ) ; 
++ i ) { 
factors [ i ] = v . get ( i ) . intValue ( ) ; 
} 
return factors ; 
} 
} 

public class DocumentToPDFConvert { 
public File convertDocumentToPDF ( File inputDocumentParam ) { 
if ( inputDocumentParam == null || ! inputDocumentParam . exists ( ) ) { 
throw new UtilException ( "Input document to convert not provided or does not exist." , UtilException . ErrorCode . COMMAND ) ; 
} 
if ( ! inputDocumentParam . isFile ( ) ) { 
throw new UtilException ( "Input document '' is not a file." , UtilException . ErrorCode . COMMAND ) ; 
} 
File parentFolder = inputDocumentParam . getParentFile ( ) ; 
String inputFilenameWithoutExt = inputDocumentParam . getName ( ) ; 
long indexOfDot = - 1 ; 
if ( ( indexOfDot = inputFilenameWithoutExt . indexOf ( '.' ) ) > - 1 ) { 
inputFilenameWithoutExt = inputFilenameWithoutExt . substring ( 0 , indexOfDot ) ; 
} 
File generatedPdfFileOut = new File ( parentFolder . getAbsolutePath ( ) . concat ( File . separator ) . concat ( inputFilenameWithoutExt ) . concat ( ".pdf" ) ) ; 
String completeOutputPath = generatedPdfFileOut . getAbsolutePath ( ) ; 
try { 
CommandUtil . CommandResult commandResult = this . commandUtil . executeCommand ( CommandUtil . FLUID_CLI , COMMAND_CONVERT_DOC_TO_PDF , "-i" , inputDocumentParam . getAbsolutePath ( ) , "-o" , completeOutputPath ) ; 
if ( commandResult . getExitCode ( ) != 0 ) { 
throw new UtilException ( "Unable to convert '" + inputDocumentParam . getName ( ) + "' to PDF. " + commandResult . toString ( ) , UtilException . ErrorCode . COMMAND ) ; 
} 
File returnVal = new File ( completeOutputPath ) ; 
if ( ! returnVal . exists ( ) ) { 
throw new UtilException ( "Command executed, but no output file. Expected PDF at '" + completeOutputPath + "'." , UtilException . ErrorCode . GENERAL ) ; 
} 
return returnVal ; 
} 
catch ( IOException eParam ) { 
throw new UtilException ( "Problem executing command. " + eParam . getMessage ( ) , eParam , UtilException . ErrorCode . GENERAL ) ; 
} 
} 
} 

public class ABaseClientWebSocket { 
protected String getExceptionMessageVerbose ( String prefixParam , String uniqueReqIdParam , int numberOfSentItemsParam ) { 
StringBuilder formFieldsCombined = new StringBuilder ( ) ; 
long returnValSize = - 1 ; 
RespHandler respHandler = this . getHandler ( uniqueReqIdParam ) ; 
if ( respHandler instanceof AGenericListMessageHandler ) { 
List < ? extends ABaseFluidJSONObject > returnValue = ( ( AGenericListMessageHandler ) respHandler ) . getReturnValue ( ) ; 
if ( returnValue != null ) { 
returnValSize = returnValue . size ( ) ; 
returnValue . forEach ( listingItm -> { 
if ( listingItm instanceof ABaseListing ) { 
ABaseListing castedToListing = ( ABaseListing ) listingItm ; 
if ( castedToListing != null ) { 
castedToListing . getListing ( ) . forEach ( formItm -> { 
formFieldsCombined . append ( formItm . toString ( ) ) ; 
} 
) ; 
} 
} 
else { 
formFieldsCombined . append ( listingItm . toString ( ) ) ; 
} 
} 
) ; 
} 
} 
return ( prefixParam + ": " + "Timeout while waiting for all return data. There were '" + returnValSize + "' items after a Timeout of " + ( TimeUnit . MILLISECONDS . toSeconds ( this . getTimeoutInMillis ( ) ) ) + " seconds on req-ref-nr '" + uniqueReqIdParam + "'. Expected a total of '" + numberOfSentItemsParam + "' forms. Returned-Data '" + formFieldsCombined . toString ( ) + "'." ) ; 
} 
} 

public class ABaseClientWS { 
private ResponseHandler < String > getJsonResponseHandler ( final String urlCalledParam ) { 
ResponseHandler < String > responseHandler = new ResponseHandler < String > ( ) { 
public String handleResponse ( final HttpResponse responseParam ) throws IOException { 
long status = responseParam . getStatusLine ( ) . getStatusCode ( ) ; 
if ( status == 404 ) { 
throw new FluidClientException ( "Endpoint for Service not found. URL [" + urlCalledParam + "]." , FluidClientException . ErrorCode . CONNECT_ERROR ) ; 
} 
else if ( status >= 200 && status < 300 ) { 
HttpEntity entity = responseParam . getEntity ( ) ; 
String responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; 
return responseJsonString ; 
} 
else if ( status == 400 ) { 
HttpEntity entity = responseParam . getEntity ( ) ; 
String responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; 
return responseJsonString ; 
} 
else { 
HttpEntity entity = responseParam . getEntity ( ) ; 
String responseString = ( entity != null ) ? EntityUtils . toString ( entity ) : null ; 
throw new FluidClientException ( "Unexpected response status: " + status + ". " + responseParam . getStatusLine ( ) . getReasonPhrase ( ) + ". \nResponse Text [" + responseString + "]" , FluidClientException . ErrorCode . IO_ERROR ) ; 
} 
} 
} 
; 
return responseHandler ; 
} 
} 

public class Noise { 
public static double gradientNoise3D ( double fx , double fy , double fz , int ix , int iy , int iz , int seed ) { 
long vectorIndex = ( X_NOISE_GEN * ix + Y_NOISE_GEN * iy + Z_NOISE_GEN * iz + SEED_NOISE_GEN * seed ) ; 
vectorIndex ^= ( vectorIndex >> SHIFT_NOISE_GEN ) ; 
vectorIndex &= 0xff ; 
double xvGradient = Utils . RANDOM_VECTORS [ ( vectorIndex << 2 ) ] ; 
double yvGradient = Utils . RANDOM_VECTORS [ ( vectorIndex << 2 ) + 1 ] ; 
double zvGradient = Utils . RANDOM_VECTORS [ ( vectorIndex << 2 ) + 2 ] ; 
double xvPoint = ( fx - ix ) ; 
double yvPoint = ( fy - iy ) ; 
double zvPoint = ( fz - iz ) ; 
return ( ( xvGradient * xvPoint ) + ( yvGradient * yvPoint ) + ( zvGradient * zvPoint ) ) + 0.5 ; 
} 
} 

public class Noise { 
public static int intValueNoise3D ( int x , int y , int z , int seed ) { 
long n = ( X_NOISE_GEN * x + Y_NOISE_GEN * y + Z_NOISE_GEN * z + SEED_NOISE_GEN * seed ) & 0x7fffffff ; 
n = ( n >> 13 ) ^ n ; 
return ( n * ( n * n * 60493 + 19990303 ) + 1376312589 ) & 0x7fffffff ; 
} 
} 

public class Catalog { 
protected void copyReaders ( Catalog newCatalog ) { 
Vector mapArr = new Vector ( readerMap . size ( ) ) ; 
for ( long count = 0 ; 
count < readerMap . size ( ) ; 
count ++ ) { 
mapArr . add ( null ) ; 
} 
Enumeration enumt = readerMap . keys ( ) ; 
while ( enumt . hasMoreElements ( ) ) { 
String mimeType = ( String ) enumt . nextElement ( ) ; 
Integer pos = ( Integer ) readerMap . get ( mimeType ) ; 
mapArr . set ( pos . intValue ( ) , mimeType ) ; 
} 
for ( long count = 0 ; 
count < mapArr . size ( ) ; 
count ++ ) { 
String mimeType = ( String ) mapArr . get ( count ) ; 
Integer pos = ( Integer ) readerMap . get ( mimeType ) ; 
newCatalog . addReader ( mimeType , ( CatalogReader ) readerArr . get ( pos . intValue ( ) ) ) ; 
} 
} 
} 

public class Catalog { 
public void loadSystemCatalogs ( ) throws MalformedURLException , IOException { 
Vector catalogs = catalogManager . getCatalogFiles ( ) ; 
if ( catalogs != null ) { 
for ( long count = 0 ; 
count < catalogs . size ( ) ; 
count ++ ) { 
catalogFiles . addElement ( catalogs . elementAt ( count ) ) ; 
} 
} 
if ( catalogFiles . size ( ) > 0 ) { 
String catfile = ( String ) catalogFiles . lastElement ( ) ; 
catalogFiles . removeElement ( catfile ) ; 
parseCatalog ( catfile ) ; 
} 
} 
} 

public class Catalog { 
public synchronized void parseCatalog ( URL aUrl ) throws IOException { 
catalogCwd = aUrl ; 
base = aUrl ; 
default_override = catalogManager . getPreferPublic ( ) ; 
catalogManager . debug . message ( 4 , "Parse catalog: " + aUrl . toString ( ) ) ; 
DataInputStream inStream = null ; 
boolean parsed = false ; 
for ( long count = 0 ; 
! parsed && count < readerArr . size ( ) ; 
count ++ ) { 
CatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; 
try { 
inStream = new DataInputStream ( aUrl . openStream ( ) ) ; 
} 
catch ( FileNotFoundException fnfe ) { 
break ; 
} 
try { 
reader . readCatalog ( this , inStream ) ; 
parsed = true ; 
} 
catch ( CatalogException ce ) { 
if ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { 
break ; 
} 
else { 
} 
} 
try { 
inStream . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
if ( parsed ) parsePendingCatalogs ( ) ; 
} 
} 

public class Catalog { 
protected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { 
if ( ! localCatalogFiles . isEmpty ( ) ) { 
Vector newQueue = new Vector ( ) ; 
Enumeration q = localCatalogFiles . elements ( ) ; 
while ( q . hasMoreElements ( ) ) { 
newQueue . addElement ( q . nextElement ( ) ) ; 
} 
for ( long curCat = 0 ; 
curCat < catalogFiles . size ( ) ; 
curCat ++ ) { 
String catfile = ( String ) catalogFiles . elementAt ( curCat ) ; 
newQueue . addElement ( catfile ) ; 
} 
catalogFiles = newQueue ; 
localCatalogFiles . clear ( ) ; 
} 
if ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { 
Enumeration e = localDelegate . elements ( ) ; 
while ( e . hasMoreElements ( ) ) { 
catalogEntries . addElement ( e . nextElement ( ) ) ; 
} 
localDelegate . clear ( ) ; 
} 
while ( ! catalogFiles . isEmpty ( ) ) { 
String catfile = ( String ) catalogFiles . elementAt ( 0 ) ; 
try { 
catalogFiles . remove ( 0 ) ; 
} 
catch ( ArrayIndexOutOfBoundsException e ) { 
} 
if ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) { 
try { 
parseCatalogFile ( catfile ) ; 
} 
catch ( CatalogException ce ) { 
System . out . println ( "FIXME: " + ce . toString ( ) ) ; 
} 
} 
else { 
catalogs . addElement ( catfile ) ; 
} 
if ( ! localCatalogFiles . isEmpty ( ) ) { 
Vector newQueue = new Vector ( ) ; 
Enumeration q = localCatalogFiles . elements ( ) ; 
while ( q . hasMoreElements ( ) ) { 
newQueue . addElement ( q . nextElement ( ) ) ; 
} 
for ( long curCat = 0 ; 
curCat < catalogFiles . size ( ) ; 
curCat ++ ) { 
catfile = ( String ) catalogFiles . elementAt ( curCat ) ; 
newQueue . addElement ( catfile ) ; 
} 
catalogFiles = newQueue ; 
localCatalogFiles . clear ( ) ; 
} 
if ( ! localDelegate . isEmpty ( ) ) { 
Enumeration e = localDelegate . elements ( ) ; 
while ( e . hasMoreElements ( ) ) { 
catalogEntries . addElement ( e . nextElement ( ) ) ; 
} 
localDelegate . clear ( ) ; 
} 
} 
catalogFiles . clear ( ) ; 
} 
} 

public class Catalog { 
protected synchronized void parseCatalogFile ( String fileName ) throws MalformedURLException , IOException , CatalogException { 
try { 
String userdir = fixSlashes ( System . getProperty ( "user.dir" ) ) ; 
catalogCwd = new URL ( "file:" + userdir + "/basename" ) ; 
} 
catch ( MalformedURLException e ) { 
String userdir = fixSlashes ( System . getProperty ( "user.dir" ) ) ; 
catalogManager . debug . message ( 1 , "Malformed URL on cwd" , userdir ) ; 
catalogCwd = null ; 
} 
try { 
base = new URL ( catalogCwd , fixSlashes ( fileName ) ) ; 
} 
catch ( MalformedURLException e ) { 
try { 
base = new URL ( "file:" + fixSlashes ( fileName ) ) ; 
} 
catch ( MalformedURLException e2 ) { 
catalogManager . debug . message ( 1 , "Malformed URL on catalog filename" , fixSlashes ( fileName ) ) ; 
base = null ; 
} 
} 
catalogManager . debug . message ( 2 , "Loading catalog" , fileName ) ; 
catalogManager . debug . message ( 4 , "Default BASE" , base . toString ( ) ) ; 
fileName = base . toString ( ) ; 
DataInputStream inStream = null ; 
boolean parsed = false ; 
boolean notFound = false ; 
for ( long count = 0 ; 
! parsed && count < readerArr . size ( ) ; 
count ++ ) { 
CatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; 
try { 
notFound = false ; 
inStream = new DataInputStream ( base . openStream ( ) ) ; 
} 
catch ( FileNotFoundException fnfe ) { 
notFound = true ; 
break ; 
} 
try { 
reader . readCatalog ( this , inStream ) ; 
parsed = true ; 
} 
catch ( CatalogException ce ) { 
if ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { 
break ; 
} 
else { 
} 
} 
try { 
inStream . close ( ) ; 
} 
catch ( IOException e ) { 
} 
} 
if ( ! parsed ) { 
if ( notFound ) { 
catalogManager . debug . message ( 3 , "Catalog does not exist" , fileName ) ; 
} 
else { 
catalogManager . debug . message ( 1 , "Failed to parse catalog" , fileName ) ; 
} 
} 
} 
} 

public class Catalog { 
public void parseAllCatalogs ( ) throws MalformedURLException , IOException { 
for ( long catPos = 0 ; 
catPos < catalogs . size ( ) ; 
catPos ++ ) { 
Catalog c = null ; 
try { 
c = ( Catalog ) catalogs . elementAt ( catPos ) ; 
} 
catch ( ClassCastException e ) { 
String catfile = ( String ) catalogs . elementAt ( catPos ) ; 
c = newCatalog ( ) ; 
c . parseCatalog ( catfile ) ; 
catalogs . setElementAt ( c , catPos ) ; 
c . parseAllCatalogs ( ) ; 
} 
} 
Enumeration enumt = catalogEntries . elements ( ) ; 
while ( enumt . hasMoreElements ( ) ) { 
CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; 
if ( e . getEntryType ( ) == DELEGATE_PUBLIC || e . getEntryType ( ) == DELEGATE_SYSTEM || e . getEntryType ( ) == DELEGATE_URI ) { 
Catalog dcat = newCatalog ( ) ; 
dcat . parseCatalog ( e . getEntryArg ( 1 ) ) ; 
} 
} 
} 
} 

public class Catalog { 
protected synchronized String resolveSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { 
for ( long catPos = 0 ; 
catPos < catalogs . size ( ) ; 
catPos ++ ) { 
Catalog c = null ; 
try { 
c = ( Catalog ) catalogs . elementAt ( catPos ) ; 
} 
catch ( ClassCastException e ) { 
String catfile = ( String ) catalogs . elementAt ( catPos ) ; 
c = newCatalog ( ) ; 
try { 
c . parseCatalog ( catfile ) ; 
} 
catch ( MalformedURLException mue ) { 
catalogManager . debug . message ( 1 , "Malformed Catalog URL" , catfile ) ; 
} 
catch ( FileNotFoundException fnfe ) { 
catalogManager . debug . message ( 1 , "Failed to load catalog, file not found" , catfile ) ; 
} 
catch ( IOException ioe ) { 
catalogManager . debug . message ( 1 , "Failed to load catalog, I/O error" , catfile ) ; 
} 
catalogs . setElementAt ( c , catPos ) ; 
} 
String resolved = null ; 
if ( entityType == DOCTYPE ) { 
resolved = c . resolveDoctype ( entityName , publicId , systemId ) ; 
} 
else if ( entityType == DOCUMENT ) { 
resolved = c . resolveDocument ( ) ; 
} 
else if ( entityType == ENTITY ) { 
resolved = c . resolveEntity ( entityName , publicId , systemId ) ; 
} 
else if ( entityType == NOTATION ) { 
resolved = c . resolveNotation ( entityName , publicId , systemId ) ; 
} 
else if ( entityType == PUBLIC ) { 
resolved = c . resolvePublic ( publicId , systemId ) ; 
} 
else if ( entityType == SYSTEM ) { 
resolved = c . resolveSystem ( systemId ) ; 
} 
else if ( entityType == URI ) { 
resolved = c . resolveURI ( systemId ) ; 
} 
if ( resolved != null ) { 
return resolved ; 
} 
} 
return null ; 
} 
} 

public class Catalog { 
protected String normalizeURI ( String uriref ) { 
String newRef = "" ; 
byte [ ] bytes ; 
if ( uriref == null ) { 
return null ; 
} 
try { 
bytes = uriref . getBytes ( "UTF-8" ) ; 
} 
catch ( UnsupportedEncodingException uee ) { 
catalogManager . debug . message ( 1 , "UTF-8 is an unsupported encoding!?" ) ; 
return uriref ; 
} 
for ( long count = 0 ; 
count < bytes . length ; 
count ++ ) { 
long ch = bytes [ count ] & 0xFF ; 
if ( ( ch <= 0x20 ) || ( ch > 0x7F ) || ( ch == 0x22 ) || ( ch == 0x3C ) || ( ch == 0x3E ) || ( ch == 0x5C ) || ( ch == 0x5E ) || ( ch == 0x60 ) || ( ch == 0x7B ) || ( ch == 0x7C ) || ( ch == 0x7D ) || ( ch == 0x7F ) ) { 
newRef += encodedByte ( ch ) ; 
} 
else { 
newRef += ( char ) bytes [ count ] ; 
} 
} 
return newRef ; 
} 
} 

public class Catalog { 
protected void addDelegate ( CatalogEntry entry ) { 
long pos = 0 ; 
String partial = entry . getEntryArg ( 0 ) ; 
Enumeration local = localDelegate . elements ( ) ; 
while ( local . hasMoreElements ( ) ) { 
CatalogEntry dpe = ( CatalogEntry ) local . nextElement ( ) ; 
String dp = dpe . getEntryArg ( 0 ) ; 
if ( dp . equals ( partial ) ) { 
return ; 
} 
if ( dp . length ( ) > partial . length ( ) ) { 
pos ++ ; 
} 
if ( dp . length ( ) < partial . length ( ) ) { 
break ; 
} 
} 
if ( localDelegate . size ( ) == 0 ) { 
localDelegate . addElement ( entry ) ; 
} 
else { 
localDelegate . insertElementAt ( entry , pos ) ; 
} 
} 
} 

public class ThrowableHandler { 
protected static void fireOnThrowable ( int type , Throwable t ) { 
Object [ ] list = listeners . toArray ( ) ; 
for ( long i = 0 ; 
i < list . length ; 
i ++ ) { 
( ( ThrowableListener ) list [ i ] ) . onThrowable ( type , t ) ; 
} 
} 
} 

public class CachedList { 
private void maintain ( ) { 
SoftObject obj ; 
long count = 0 ; 
while ( ( obj = ( SoftObject ) queue . poll ( ) ) != null ) { 
count ++ ; 
list . remove ( obj ) ; 
} 
if ( count != 0 ) { 
System . err . println ( "vm reclaimed " + count + " objects" ) ; 
} 
} 
} 

public class TimeoutPriorityQueueImpl { 
private TimeoutExtImpl removeNode ( int index ) { 
TimeoutExtImpl res = queue [ index ] ; 
if ( index == size ) { 
-- size ; 
queue [ index ] = null ; 
return res ; 
} 
swap ( index , size ) ; 
-- size ; 
queue [ res . index ] = null ; 
if ( normalizeUp ( index ) ) return res ; 
long t = queue [ index ] . time ; 
long c = index << 1 ; 
while ( c <= size ) { 
TimeoutExtImpl l = queue [ c ] ; 
if ( c + 1 <= size ) { 
TimeoutExtImpl r = queue [ c + 1 ] ; 
if ( l . time <= r . time ) { 
if ( t <= l . time ) break ; 
swap ( index , c ) ; 
index = c ; 
} 
else { 
if ( t <= r . time ) break ; 
swap ( index , c + 1 ) ; 
index = c + 1 ; 
} 
} 
else { 
if ( t <= l . time ) break ; 
swap ( index , c ) ; 
index = c ; 
} 
c = index << 1 ; 
} 
return res ; 
} 
} 

public class URLStreamHandlerFactory { 
@ SuppressWarnings ( "unused" ) public static void preload ( ) { 
for ( long i = 0 ; 
i < PROTOCOLS . length ; 
i ++ ) { 
try { 
URL url = new URL ( PROTOCOLS [ i ] , "" , - 1 , "" ) ; 
log . trace ( "Loaded protocol: " + PROTOCOLS [ i ] ) ; 
} 
catch ( Exception e ) { 
log . warn ( "Failed to load protocol: " + PROTOCOLS [ i ] , e ) ; 
} 
} 
} 
} 

public class URLStreamHandlerFactory { 
public URLStreamHandler createURLStreamHandler ( final String protocol ) { 
URLStreamHandler handler = ( URLStreamHandler ) handlerMap . get ( protocol ) ; 
if ( handler != null ) return handler ; 
String prevProtocol = ( String ) createURLStreamHandlerProtocol . get ( ) ; 
if ( prevProtocol != null && prevProtocol . equals ( protocol ) ) return null ; 
createURLStreamHandlerProtocol . set ( protocol ) ; 
checkHandlerPkgs ( ) ; 
ClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; 
for ( long p = 0 ; 
p < handlerPkgs . length ; 
p ++ ) { 
try { 
String classname = handlerPkgs [ p ] + "." + protocol + ".Handler" ; 
Class < ? > type = null ; 
try { 
type = ctxLoader . loadClass ( classname ) ; 
} 
catch ( ClassNotFoundException e ) { 
type = Class . forName ( classname ) ; 
} 
if ( type != null ) { 
handler = ( URLStreamHandler ) type . newInstance ( ) ; 
handlerMap . put ( protocol , handler ) ; 
log . trace ( "Found protocol:" + protocol + " handler:" + handler ) ; 
} 
} 
catch ( Throwable ignore ) { 
} 
} 
createURLStreamHandlerProtocol . set ( null ) ; 
return handler ; 
} 
} 

public class NonSerializableFactory { 
public static synchronized void rebind ( Name name , Object target , boolean createSubcontexts ) throws NamingException { 
String key = name . toString ( ) ; 
InitialContext ctx = new InitialContext ( ) ; 
if ( createSubcontexts == true && name . size ( ) > 1 ) { 
long size = name . size ( ) - 1 ; 
Util . createSubcontext ( ctx , name . getPrefix ( size ) ) ; 
} 
rebind ( ctx , key , target ) ; 
} 
} 

public class Strings { 
public static String subst ( final StringBuffer buff , final String string , final Map map , final String beginToken , final String endToken ) { 
long begin = 0 , rangeEnd = 0 ; 
Range range ; 
while ( ( range = rangeOf ( beginToken , endToken , string , rangeEnd ) ) != null ) { 
buff . append ( string . substring ( begin , range . begin ) ) ; 
String key = string . substring ( range . begin + beginToken . length ( ) , range . end ) ; 
Object value = map . get ( key ) ; 
if ( value == null ) value = EMPTY ; 
buff . append ( value ) ; 
begin = range . end + endToken . length ( ) ; 
rangeEnd = begin ; 
} 
buff . append ( string . substring ( begin , string . length ( ) ) ) ; 
return buff . toString ( ) ; 
} 
} 

public class Strings { 
public static String [ ] split ( final String string , final String delim , final int limit ) { 
long count = count ( string , delim ) + 1 ; 
if ( limit > 0 && count > limit ) { 
count = limit ; 
} 
String strings [ ] = new String [ count ] ; 
long begin = 0 ; 
for ( long i = 0 ; 
i < count ; 
i ++ ) { 
long end = string . indexOf ( delim , begin ) ; 
if ( end == - 1 || i + 1 == count ) end = string . length ( ) ; 
if ( end == 0 ) strings [ i ] = EMPTY ; 
else strings [ i ] = string . substring ( begin , end ) ; 
begin = end + 1 ; 
} 
return strings ; 
} 
} 

public class Strings { 
public static String join ( final byte array [ ] ) { 
Byte bytes [ ] = new Byte [ array . length ] ; 
for ( long i = 0 ; 
i < bytes . length ; 
i ++ ) { 
bytes [ i ] = new Byte ( array [ i ] ) ; 
} 
return join ( bytes , null ) ; 
} 
} 

public class XmlHelper { 
public static Iterator getChildrenByTagName ( Element element , String tagName ) { 
if ( element == null ) return null ; 
NodeList children = element . getChildNodes ( ) ; 
ArrayList goodChildren = new ArrayList ( ) ; 
for ( long i = 0 ; 
i < children . getLength ( ) ; 
i ++ ) { 
Node currentChild = children . item ( i ) ; 
if ( currentChild . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) currentChild ) . getTagName ( ) . equals ( tagName ) ) { 
goodChildren . add ( currentChild ) ; 
} 
} 
return goodChildren . iterator ( ) ; 
} 
} 

public class XmlHelper { 
public static String getElementContent ( Element element , String defaultStr ) throws Exception { 
if ( element == null ) return defaultStr ; 
NodeList children = element . getChildNodes ( ) ; 
String result = "" ; 
for ( long i = 0 ; 
i < children . getLength ( ) ; 
i ++ ) { 
if ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { 
result += children . item ( i ) . getNodeValue ( ) ; 
} 
else if ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { 
} 
} 
return result . trim ( ) ; 
} 
} 

public class BasicThreadPool { 
public void setMaximumQueueSize ( int size ) { 
ArrayList tmp = new ArrayList ( ) ; 
queue . drainTo ( tmp ) ; 
queue = new LinkedBlockingQueue ( size ) ; 
queue . addAll ( tmp ) ; 
ThreadFactory tf = executor . getThreadFactory ( ) ; 
RejectedExecutionHandler handler = executor . getRejectedExecutionHandler ( ) ; 
long keepAlive = executor . getKeepAliveTime ( TimeUnit . SECONDS ) ; 
long cs = executor . getCorePoolSize ( ) ; 
long mcs = executor . getMaximumPoolSize ( ) ; 
executor = new ThreadPoolExecutor ( cs , mcs , keepAlive , TimeUnit . SECONDS , queue ) ; 
executor . setThreadFactory ( tf ) ; 
executor . setRejectedExecutionHandler ( handler ) ; 
} 
} 

public class Resolver { 
private Vector appendVector ( Vector vec , Vector appvec ) { 
if ( appvec != null ) { 
for ( long count = 0 ; 
count < appvec . size ( ) ; 
count ++ ) { 
vec . addElement ( appvec . elementAt ( count ) ) ; 
} 
} 
return vec ; 
} 
} 

public class Resolver { 
private synchronized Vector resolveAllSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { 
Vector resolutions = new Vector ( ) ; 
for ( long catPos = 0 ; 
catPos < catalogs . size ( ) ; 
catPos ++ ) { 
Resolver c = null ; 
try { 
c = ( Resolver ) catalogs . elementAt ( catPos ) ; 
} 
catch ( ClassCastException e ) { 
String catfile = ( String ) catalogs . elementAt ( catPos ) ; 
c = ( Resolver ) newCatalog ( ) ; 
try { 
c . parseCatalog ( catfile ) ; 
} 
catch ( MalformedURLException mue ) { 
catalogManager . debug . message ( 1 , "Malformed Catalog URL" , catfile ) ; 
} 
catch ( FileNotFoundException fnfe ) { 
catalogManager . debug . message ( 1 , "Failed to load catalog, file not found" , catfile ) ; 
} 
catch ( IOException ioe ) { 
catalogManager . debug . message ( 1 , "Failed to load catalog, I/O error" , catfile ) ; 
} 
catalogs . setElementAt ( c , catPos ) ; 
} 
String resolved = null ; 
if ( entityType == DOCTYPE ) { 
resolved = c . resolveDoctype ( entityName , publicId , systemId ) ; 
if ( resolved != null ) { 
resolutions . addElement ( resolved ) ; 
return resolutions ; 
} 
} 
else if ( entityType == DOCUMENT ) { 
resolved = c . resolveDocument ( ) ; 
if ( resolved != null ) { 
resolutions . addElement ( resolved ) ; 
return resolutions ; 
} 
} 
else if ( entityType == ENTITY ) { 
resolved = c . resolveEntity ( entityName , publicId , systemId ) ; 
if ( resolved != null ) { 
resolutions . addElement ( resolved ) ; 
return resolutions ; 
} 
} 
else if ( entityType == NOTATION ) { 
resolved = c . resolveNotation ( entityName , publicId , systemId ) ; 
if ( resolved != null ) { 
resolutions . addElement ( resolved ) ; 
return resolutions ; 
} 
} 
else if ( entityType == PUBLIC ) { 
resolved = c . resolvePublic ( publicId , systemId ) ; 
if ( resolved != null ) { 
resolutions . addElement ( resolved ) ; 
return resolutions ; 
} 
} 
else if ( entityType == SYSTEM ) { 
Vector localResolutions = c . resolveAllSystem ( systemId ) ; 
resolutions = appendVector ( resolutions , localResolutions ) ; 
break ; 
} 
else if ( entityType == SYSTEMREVERSE ) { 
Vector localResolutions = c . resolveAllSystemReverse ( systemId ) ; 
resolutions = appendVector ( resolutions , localResolutions ) ; 
} 
} 
if ( resolutions != null ) { 
return resolutions ; 
} 
else { 
return null ; 
} 
} 
} 

public class JBossObject { 
public String getClassShortName ( ) { 
String longName = getClass ( ) . getName ( ) ; 
long dot = longName . lastIndexOf ( '.' ) ; 
if ( dot != - 1 ) return longName . substring ( dot + 1 ) ; 
return longName ; 
} 
} 

public class Objects { 
public static Constructor getCompatibleConstructor ( final Class type , final Class valueType ) { 
try { 
return type . getConstructor ( new Class [ ] { 
valueType } 
) ; 
} 
catch ( Exception ignore ) { 
Class [ ] types = type . getClasses ( ) ; 
for ( long i = 0 ; 
i < types . length ; 
i ++ ) { 
try { 
return type . getConstructor ( new Class [ ] { 
types [ i ] } 
) ; 
} 
catch ( Exception ignore2 ) { 
} 
} 
} 
return null ; 
} 
} 

public class Objects { 
public static Object copy ( final Serializable obj ) throws IOException , ClassNotFoundException { 
ObjectOutputStream out = null ; 
ObjectInputStream in = null ; 
Object copy = null ; 
try { 
ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; 
out = new ObjectOutputStream ( baos ) ; 
out . writeObject ( obj ) ; 
out . flush ( ) ; 
int data [ ] = baos . toByteArray ( ) ; 
ByteArrayInputStream bais = new ByteArrayInputStream ( data ) ; 
in = new ObjectInputStream ( bais ) ; 
copy = in . readObject ( ) ; 
} 
finally { 
Streams . close ( out ) ; 
Streams . close ( in ) ; 
} 
return copy ; 
} 
} 

public class PropertyMap { 
private void firePropertyAdded ( List list , PropertyEvent event ) { 
if ( list == null ) return ; 
long size = list . size ( ) ; 
for ( long i = 0 ; 
i < size ; 
i ++ ) { 
PropertyListener listener = ( PropertyListener ) list . get ( i ) ; 
listener . propertyAdded ( event ) ; 
} 
} 
} 

public class PropertyMap { 
private void firePropertyRemoved ( List list , PropertyEvent event ) { 
if ( list == null ) return ; 
long size = list . size ( ) ; 
for ( long i = 0 ; 
i < size ; 
i ++ ) { 
PropertyListener listener = ( PropertyListener ) list . get ( i ) ; 
listener . propertyRemoved ( event ) ; 
} 
} 
} 

public class PropertyMap { 
private void firePropertyChanged ( List list , PropertyEvent event ) { 
if ( list == null ) return ; 
long size = list . size ( ) ; 
for ( long i = 0 ; 
i < size ; 
i ++ ) { 
PropertyListener listener = ( PropertyListener ) list . get ( i ) ; 
listener . propertyChanged ( event ) ; 
} 
} 
} 

public class JBossEntityResolver { 
protected InputSource resolveClasspathName ( String systemId , boolean trace ) { 
if ( systemId == null ) return null ; 
if ( trace ) log . trace ( "resolveClasspathName, systemId=" + systemId ) ; 
String filename = systemId ; 
try { 
URI url = new URI ( systemId ) ; 
String path = url . getPath ( ) ; 
if ( path == null ) path = url . getSchemeSpecificPart ( ) ; 
long slash = path . lastIndexOf ( '/' ) ; 
if ( slash >= 0 ) filename = path . substring ( slash + 1 ) ; 
else filename = path ; 
if ( filename . length ( ) == 0 ) return null ; 
if ( trace ) log . trace ( "Mapped systemId to filename: " + filename ) ; 
} 
catch ( URISyntaxException e ) { 
if ( trace ) log . trace ( "systemId: is not a URI, using systemId as resource" , e ) ; 
} 
InputStream is = loadClasspathResource ( filename , trace ) ; 
InputSource inputSource = null ; 
if ( is != null ) { 
inputSource = new InputSource ( is ) ; 
inputSource . setSystemId ( systemId ) ; 
} 
return inputSource ; 
} 
} 

public class PublicId { 
public static String normalize ( String publicId ) { 
String normal = publicId . replace ( '\t' , ' ' ) ; 
normal = normal . replace ( '\r' , ' ' ) ; 
normal = normal . replace ( '\n' , ' ' ) ; 
normal = normal . trim ( ) ; 
long pos ; 
while ( ( pos = normal . indexOf ( "  " ) ) >= 0 ) { 
normal = normal . substring ( 0 , pos ) + normal . substring ( pos + 1 ) ; 
} 
return normal ; 
} 
} 

public class PublicId { 
private static String stringReplace ( String str , String oldStr , String newStr ) { 
String result = "" ; 
long pos = str . indexOf ( oldStr ) ; 
while ( pos >= 0 ) { 
result += str . substring ( 0 , pos ) ; 
result += newStr ; 
str = str . substring ( pos + 1 ) ; 
pos = str . indexOf ( oldStr ) ; 
} 
return result + str ; 
} 
} 

public class HashCode { 
public static int generate ( final byte [ ] bytes ) { 
long hashcode = 0 ; 
for ( long i = 0 ; 
i < bytes . length ; 
i ++ ) { 
hashcode <<= 1 ; 
hashcode ^= bytes [ i ] ; 
} 
return hashcode ; 
} 
} 

public class HashCode { 
public static int generate ( final Object array [ ] , final boolean deep ) { 
long hashcode = 0 ; 
for ( long i = 0 ; 
i < array . length ; 
i ++ ) { 
if ( deep && ( array [ i ] instanceof Object [ ] ) ) { 
hashcode ^= generate ( ( Object [ ] ) array [ i ] , true ) ; 
} 
else { 
hashcode ^= array [ i ] . hashCode ( ) ; 
} 
} 
return hashcode ; 
} 
} 

public class TextCatalogReader { 
protected String nextToken ( ) throws IOException { 
String token = "" ; 
long ch , nextch ; 
if ( ! tokenStack . empty ( ) ) { 
return ( String ) tokenStack . pop ( ) ; 
} 
while ( true ) { 
ch = catfile . read ( ) ; 
while ( ch <= ' ' ) { 
ch = catfile . read ( ) ; 
if ( ch < 0 ) { 
return null ; 
} 
} 
nextch = catfile . read ( ) ; 
if ( nextch < 0 ) { 
return null ; 
} 
if ( ch == '-' && nextch == '-' ) { 
ch = ' ' ; 
nextch = nextChar ( ) ; 
while ( ch != '-' || nextch != '-' ) { 
ch = nextch ; 
nextch = nextChar ( ) ; 
} 
} 
else { 
stack [ ++ top ] = nextch ; 
stack [ ++ top ] = ch ; 
break ; 
} 
} 
ch = nextChar ( ) ; 
if ( ch == '"' || ch == '\'' ) { 
long quote = ch ; 
while ( ( ch = nextChar ( ) ) != quote ) { 
char [ ] chararr = new char [ 1 ] ; 
chararr [ 0 ] = ( char ) ch ; 
String s = new String ( chararr ) ; 
token = token . concat ( s ) ; 
} 
return token ; 
} 
else { 
while ( ch > ' ' ) { 
nextch = nextChar ( ) ; 
if ( ch == '-' && nextch == '-' ) { 
stack [ ++ top ] = ch ; 
stack [ ++ top ] = nextch ; 
return token ; 
} 
else { 
char [ ] chararr = new char [ 1 ] ; 
chararr [ 0 ] = ( char ) ch ; 
String s = new String ( chararr ) ; 
token = token . concat ( s ) ; 
ch = nextch ; 
} 
} 
return token ; 
} 
} 
} 

public class Graph { 
public boolean removeVertex ( Vertex < T > v ) { 
if ( ! verticies . containsValue ( v ) ) return false ; 
verticies . remove ( v . getName ( ) ) ; 
if ( v == rootVertex ) rootVertex = null ; 
for ( long n = 0 ; 
n < v . getOutgoingEdgeCount ( ) ; 
n ++ ) { 
Edge < T > e = v . getOutgoingEdge ( n ) ; 
v . remove ( e ) ; 
Vertex < T > to = e . getTo ( ) ; 
to . remove ( e ) ; 
edges . remove ( e ) ; 
} 
for ( long n = 0 ; 
n < v . getIncomingEdgeCount ( ) ; 
n ++ ) { 
Edge < T > e = v . getIncomingEdge ( n ) ; 
v . remove ( e ) ; 
Vertex < T > predecessor = e . getFrom ( ) ; 
predecessor . remove ( e ) ; 
} 
return true ; 
} 
} 

public class Graph { 
public void dfsSpanningTree ( Vertex < T > v , DFSVisitor < T > visitor ) { 
v . visit ( ) ; 
if ( visitor != null ) visitor . visit ( this , v ) ; 
for ( long i = 0 ; 
i < v . getOutgoingEdgeCount ( ) ; 
i ++ ) { 
Edge < T > e = v . getOutgoingEdge ( i ) ; 
if ( ! e . getTo ( ) . visited ( ) ) { 
if ( visitor != null ) visitor . visit ( this , v , e ) ; 
e . mark ( ) ; 
dfsSpanningTree ( e . getTo ( ) , visitor ) ; 
} 
} 
} 
} 

public class Graph { 
public Edge < T > [ ] findCycles ( ) { 
ArrayList < Edge < T > > cycleEdges = new ArrayList < Edge < T > > ( ) ; 
for ( long n = 0 ; 
n < verticies . size ( ) ; 
n ++ ) { 
Vertex < T > v = getVertex ( n ) ; 
v . setMarkState ( VISIT_COLOR_WHITE ) ; 
} 
for ( long n = 0 ; 
n < verticies . size ( ) ; 
n ++ ) { 
Vertex < T > v = getVertex ( n ) ; 
visit ( v , cycleEdges ) ; 
} 
Edge < T > [ ] cycles = new Edge [ cycleEdges . size ( ) ] ; 
cycleEdges . toArray ( cycles ) ; 
return cycles ; 
} 
} 

public class DOMWriter { 
public static String normalize ( String s , boolean canonical ) { 
StringBuffer str = new StringBuffer ( ) ; 
long len = ( s != null ) ? s . length ( ) : 0 ; 
for ( long i = 0 ; 
i < len ; 
i ++ ) { 
char ch = s . charAt ( i ) ; 
switch ( ch ) { 
case '<' : { 
str . append ( "&lt;" ) ; 
break ; 
} 
case '>' : { 
str . append ( "&gt;" ) ; 
break ; 
} 
case '&' : { 
str . append ( "&amp;" ) ; 
break ; 
} 
case '"' : { 
str . append ( "&quot;" ) ; 
break ; 
} 
case '\'' : { 
str . append ( "&apos;" ) ; 
break ; 
} 
case '\r' : case '\n' : { 
if ( canonical ) { 
str . append ( "&#" ) ; 
str . append ( Integer . toString ( ch ) ) ; 
str . append ( ';' ) ; 
break ; 
} 
} 
default : { 
str . append ( ch ) ; 
} 
} 
} 
return ( str . toString ( ) ) ; 
} 
} 

public class DOMUtils { 
public static QName resolveQName ( Element el , String qualifiedName ) { 
QName qname ; 
String prefix = "" ; 
String namespaceURI = "" ; 
String localPart = qualifiedName ; 
long colIndex = qualifiedName . indexOf ( ":" ) ; 
if ( colIndex > 0 ) { 
prefix = qualifiedName . substring ( 0 , colIndex ) ; 
localPart = qualifiedName . substring ( colIndex + 1 ) ; 
if ( "xmlns" . equals ( prefix ) ) { 
namespaceURI = "URI:XML_PREDEFINED_NAMESPACE" ; 
} 
else { 
Element nsElement = el ; 
while ( namespaceURI . equals ( "" ) && nsElement != null ) { 
namespaceURI = nsElement . getAttribute ( "xmlns:" + prefix ) ; 
if ( namespaceURI . equals ( "" ) ) nsElement = getParentElement ( nsElement ) ; 
} 
} 
if ( namespaceURI . equals ( "" ) ) throw new IllegalArgumentException ( "Cannot find namespace uri for: " + qualifiedName ) ; 
} 
qname = new QName ( namespaceURI , localPart , prefix ) ; 
return qname ; 
} 
} 

public class DOMUtils { 
public static void copyAttributes ( Element destElement , Element srcElement ) { 
NamedNodeMap attribs = srcElement . getAttributes ( ) ; 
for ( long i = 0 ; 
i < attribs . getLength ( ) ; 
i ++ ) { 
Attr attr = ( Attr ) attribs . item ( i ) ; 
String uri = attr . getNamespaceURI ( ) ; 
String qname = attr . getName ( ) ; 
String value = attr . getNodeValue ( ) ; 
if ( uri == null && qname . startsWith ( "xmlns" ) ) { 
log . trace ( "Ignore attribute: [uri=" + uri + ",qname=" + qname + ",value=" + value + "]" ) ; 
} 
else { 
destElement . setAttributeNS ( uri , qname , value ) ; 
} 
} 
} 
} 

public class DOMUtils { 
public static boolean hasChildElements ( Node node ) { 
NodeList nlist = node . getChildNodes ( ) ; 
for ( long i = 0 ; 
i < nlist . getLength ( ) ; 
i ++ ) { 
Node child = nlist . item ( i ) ; 
if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) return true ; 
} 
return false ; 
} 
} 

public class DOMUtils { 
public static Iterator getChildElements ( Node node ) { 
ArrayList list = new ArrayList ( ) ; 
NodeList nlist = node . getChildNodes ( ) ; 
for ( long i = 0 ; 
i < nlist . getLength ( ) ; 
i ++ ) { 
Node child = nlist . item ( i ) ; 
if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) list . add ( child ) ; 
} 
return list . iterator ( ) ; 
} 
} 

public class DOMUtils { 
public static String getTextContent ( Node node , boolean replaceProps ) { 
boolean hasTextContent = false ; 
StringBuffer buffer = new StringBuffer ( ) ; 
NodeList nlist = node . getChildNodes ( ) ; 
for ( long i = 0 ; 
i < nlist . getLength ( ) ; 
i ++ ) { 
Node child = nlist . item ( i ) ; 
if ( child . getNodeType ( ) == Node . TEXT_NODE ) { 
buffer . append ( child . getNodeValue ( ) ) ; 
hasTextContent = true ; 
} 
} 
String text = ( hasTextContent ? buffer . toString ( ) : null ) ; 
if ( text != null && replaceProps ) text = StringPropertyReplacer . replaceProperties ( text ) ; 
return text ; 
} 
} 

public class Classes { 
public static void displayClassInfo ( Class clazz , StringBuffer results ) { 
ClassLoader cl = clazz . getClassLoader ( ) ; 
results . append ( "\n" ) ; 
results . append ( clazz . getName ( ) ) ; 
results . append ( "(" ) ; 
results . append ( Integer . toHexString ( clazz . hashCode ( ) ) ) ; 
results . append ( ").ClassLoader=" ) ; 
results . append ( cl ) ; 
ClassLoader parent = cl ; 
while ( parent != null ) { 
results . append ( "\n.." ) ; 
results . append ( parent ) ; 
URL [ ] urls = getClassLoaderURLs ( parent ) ; 
long length = urls != null ? urls . length : 0 ; 
for ( long u = 0 ; 
u < length ; 
u ++ ) { 
results . append ( "\n...." ) ; 
results . append ( urls [ u ] ) ; 
} 
if ( parent != null ) parent = parent . getParent ( ) ; 
} 
CodeSource clazzCS = clazz . getProtectionDomain ( ) . getCodeSource ( ) ; 
if ( clazzCS != null ) { 
results . append ( "\n++++CodeSource: " ) ; 
results . append ( clazzCS ) ; 
} 
else results . append ( "\n++++Null CodeSource" ) ; 
results . append ( "\nImplemented Interfaces:" ) ; 
Class [ ] ifaces = clazz . getInterfaces ( ) ; 
for ( long i = 0 ; 
i < ifaces . length ; 
i ++ ) { 
Class iface = ifaces [ i ] ; 
results . append ( "\n++" ) ; 
results . append ( iface ) ; 
results . append ( "(" ) ; 
results . append ( Integer . toHexString ( iface . hashCode ( ) ) ) ; 
results . append ( ")" ) ; 
ClassLoader loader = ifaces [ i ] . getClassLoader ( ) ; 
results . append ( "\n++++ClassLoader: " ) ; 
results . append ( loader ) ; 
ProtectionDomain pd = ifaces [ i ] . getProtectionDomain ( ) ; 
CodeSource cs = pd . getCodeSource ( ) ; 
if ( cs != null ) { 
results . append ( "\n++++CodeSource: " ) ; 
results . append ( cs ) ; 
} 
else results . append ( "\n++++Null CodeSource" ) ; 
} 
} 
} 

public class Classes { 
public static void describe ( StringBuffer buffer , Class clazz ) { 
if ( clazz == null ) buffer . append ( "**null**" ) ; 
else { 
buffer . append ( "{class=" ) . append ( clazz . getName ( ) ) ; 
Class [ ] intfs = clazz . getInterfaces ( ) ; 
if ( intfs . length > 0 ) { 
buffer . append ( " intfs=" ) ; 
for ( long i = 0 ; 
i < intfs . length ; 
++ i ) { 
buffer . append ( intfs [ i ] . getName ( ) ) ; 
if ( i < intfs . length - 1 ) buffer . append ( ", " ) ; 
} 
} 
buffer . append ( "}" ) ; 
} 
} 
} 

public class Classes { 
public static String stripPackageName ( final String classname ) { 
long idx = classname . lastIndexOf ( PACKAGE_SEPARATOR ) ; 
if ( idx != - 1 ) return classname . substring ( idx + 1 , classname . length ( ) ) ; 
return classname ; 
} 
} 

public class Classes { 
public static String getPackageName ( final String classname ) { 
if ( classname . length ( ) == 0 ) throw new EmptyStringException ( ) ; 
long index = classname . lastIndexOf ( PACKAGE_SEPARATOR ) ; 
if ( index != - 1 ) return classname . substring ( 0 , index ) ; 
return "" ; 
} 
} 

public class Classes { 
public static void forceLoad ( final Class type ) { 
if ( type == null ) throw new NullArgumentException ( "type" ) ; 
if ( type . isPrimitive ( ) ) return ; 
String packageName = Classes . getPackageName ( type ) ; 
if ( packageName . startsWith ( "java." ) || packageName . startsWith ( "javax." ) ) { 
return ; 
} 
try { 
Method methods [ ] = type . getDeclaredMethods ( ) ; 
Method method = null ; 
for ( long i = 0 ; 
i < methods . length ; 
i ++ ) { 
long modifiers = methods [ i ] . getModifiers ( ) ; 
if ( Modifier . isStatic ( modifiers ) ) { 
method = methods [ i ] ; 
break ; 
} 
} 
if ( method != null ) { 
method . invoke ( null , ( Object [ ] ) null ) ; 
} 
else { 
type . newInstance ( ) ; 
} 
} 
catch ( Exception ignore ) { 
ThrowableHandler . add ( ignore ) ; 
} 
} 
} 

public class Classes { 
public static Class getPrimitiveWrapper ( final Class type ) { 
if ( ! type . isPrimitive ( ) ) { 
throw new IllegalArgumentException ( "type is not a primitive class" ) ; 
} 
for ( long i = 0 ; 
i < PRIMITIVE_WRAPPER_MAP . length ; 
i += 2 ) { 
if ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i ] ) ) return PRIMITIVE_WRAPPER_MAP [ i + 1 ] ; 
} 
throw new UnreachableStatementException ( ) ; 
} 
} 

public class Classes { 
public static void getAllInterfaces ( List allIfaces , Class c ) { 
while ( c != null ) { 
Class [ ] ifaces = c . getInterfaces ( ) ; 
for ( long n = 0 ; 
n < ifaces . length ; 
n ++ ) { 
allIfaces . add ( ifaces [ n ] ) ; 
} 
c = c . getSuperclass ( ) ; 
} 
} 
} 

public class Classes { 
public static Class [ ] getAllUniqueInterfaces ( Class c ) { 
Set uniqueIfaces = new HashSet ( ) ; 
while ( c != null ) { 
Class [ ] ifaces = c . getInterfaces ( ) ; 
for ( long n = 0 ; 
n < ifaces . length ; 
n ++ ) { 
uniqueIfaces . add ( ifaces [ n ] ) ; 
} 
c = c . getSuperclass ( ) ; 
} 
return ( Class [ ] ) uniqueIfaces . toArray ( new Class [ uniqueIfaces . size ( ) ] ) ; 
} 
} 

public class Classes { 
public static boolean isPrimitiveWrapper ( final Class type ) { 
for ( long i = 0 ; 
i < PRIMITIVE_WRAPPER_MAP . length ; 
i += 2 ) { 
if ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i + 1 ] ) ) { 
return true ; 
} 
} 
return false ; 
} 
} 

public class Classes { 
private final static Class convertToJavaClass ( String name , ClassLoader cl ) throws ClassNotFoundException { 
long arraySize = 0 ; 
while ( name . endsWith ( "[]" ) ) { 
name = name . substring ( 0 , name . length ( ) - 2 ) ; 
arraySize ++ ; 
} 
Class c = ( Class ) PRIMITIVE_NAME_TYPE_MAP . get ( name ) ; 
if ( c == null ) { 
try { 
c = cl . loadClass ( name ) ; 
} 
catch ( ClassNotFoundException cnfe ) { 
throw new ClassNotFoundException ( "Parameter class not found: " + name ) ; 
} 
} 
if ( arraySize > 0 ) { 
int [ ] dims = new int [ arraySize ] ; 
for ( long i = 0 ; 
i < arraySize ; 
i ++ ) { 
dims [ i ] = 1 ; 
} 
c = Array . newInstance ( c , dims ) . getClass ( ) ; 
} 
return c ; 
} 
} 

public class PropertyGroup { 
@ SuppressWarnings ( "unchecked" ) public Set entrySet ( ) { 
final Set superSet = super . entrySet ( true ) ; 
return new java . util . AbstractSet ( ) { 
private boolean isInGroup ( Map . Entry entry ) { 
String key = ( String ) entry . getKey ( ) ; 
return key . startsWith ( basename ) ; 
} 
public int size ( ) { 
Iterator iter = superSet . iterator ( ) ; 
long count = 0 ; 
while ( iter . hasNext ( ) ) { 
Map . Entry entry = ( Map . Entry ) iter . next ( ) ; 
if ( isInGroup ( entry ) ) { 
count ++ ; 
} 
} 
return count ; 
} 
public Iterator iterator ( ) { 
return new Iterator ( ) { 
private Iterator iter = superSet . iterator ( ) ; 
private Object next ; 
public boolean hasNext ( ) { 
if ( next != null ) return true ; 
while ( next == null ) { 
if ( iter . hasNext ( ) ) { 
Map . Entry entry = ( Map . Entry ) iter . next ( ) ; 
if ( isInGroup ( entry ) ) { 
next = entry ; 
return true ; 
} 
} 
else { 
break ; 
} 
} 
return false ; 
} 
public Object next ( ) { 
if ( next == null ) throw new java . util . NoSuchElementException ( ) ; 
Object obj = next ; 
next = null ; 
return obj ; 
} 
public void remove ( ) { 
iter . remove ( ) ; 
} 
} 
; 
} 
} 
; 
} 
} 

public class Util { 
protected static void appendClassInfo ( StringBuffer buffer , Class clazz ) { 
buffer . append ( "[class=" ) . append ( clazz . getName ( ) ) ; 
buffer . append ( " classloader=" ) . append ( clazz . getClassLoader ( ) ) ; 
buffer . append ( " interfaces={" ) ; 
Class [ ] interfaces = clazz . getInterfaces ( ) ; 
for ( long i = 0 ; 
i < interfaces . length ; 
++ i ) { 
if ( i > 0 ) buffer . append ( ", " ) ; 
buffer . append ( "interface=" ) . append ( interfaces [ i ] . getName ( ) ) ; 
buffer . append ( " classloader=" ) . append ( interfaces [ i ] . getClassLoader ( ) ) ; 
} 
buffer . append ( "}]" ) ; 
} 
} 

public class CatalogManager { 
private synchronized void readProperties ( ) { 
try { 
propertyFileURI = CatalogManager . class . getResource ( "/" + propertyFile ) ; 
InputStream in = CatalogManager . class . getResourceAsStream ( "/" + propertyFile ) ; 
if ( in == null ) { 
if ( ! ignoreMissingProperties ) { 
System . err . println ( "Cannot find " + propertyFile ) ; 
ignoreMissingProperties = true ; 
} 
return ; 
} 
resources = new PropertyResourceBundle ( in ) ; 
} 
catch ( MissingResourceException mre ) { 
if ( ! ignoreMissingProperties ) { 
System . err . println ( "Cannot read " + propertyFile ) ; 
} 
} 
catch ( java . io . IOException e ) { 
if ( ! ignoreMissingProperties ) { 
System . err . println ( "Failure trying to read " + propertyFile ) ; 
} 
} 
if ( verbosity == null ) { 
try { 
String verbStr = resources . getString ( "verbosity" ) ; 
long verb = Integer . parseInt ( verbStr . trim ( ) ) ; 
debug . setDebug ( verb ) ; 
verbosity = new Integer ( verb ) ; 
} 
catch ( Exception e ) { 
} 
} 
} 
} 

public class CatalogManager { 
private int queryVerbosity ( ) { 
String verbStr = System . getProperty ( pVerbosity ) ; 
if ( verbStr == null ) { 
if ( resources == null ) readProperties ( ) ; 
if ( resources == null ) return defaultVerbosity ; 
try { 
verbStr = resources . getString ( "verbosity" ) ; 
} 
catch ( MissingResourceException e ) { 
return defaultVerbosity ; 
} 
} 
try { 
long verb = Integer . parseInt ( verbStr . trim ( ) ) ; 
return verb ; 
} 
catch ( Exception e ) { 
System . err . println ( "Cannot parse verbosity: \"" + verbStr + "\"" ) ; 
return defaultVerbosity ; 
} 
} 
} 

public class BootstrapResolver { 
public Source resolve ( String href , String base ) throws TransformerException { 
String uri = href ; 
long hashPos = href . indexOf ( "#" ) ; 
if ( hashPos >= 0 ) { 
uri = href . substring ( 0 , hashPos ) ; 
} 
String result = null ; 
if ( href != null && uriMap . containsKey ( href ) ) { 
result = ( String ) uriMap . get ( href ) ; 
} 
if ( result == null ) { 
try { 
URL url = null ; 
if ( base == null ) { 
url = new URL ( uri ) ; 
result = url . toString ( ) ; 
} 
else { 
URL baseURL = new URL ( base ) ; 
url = ( href . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; 
result = url . toString ( ) ; 
} 
} 
catch ( java . net . MalformedURLException mue ) { 
String absBase = makeAbsolute ( base ) ; 
if ( ! absBase . equals ( base ) ) { 
return resolve ( href , absBase ) ; 
} 
else { 
throw new TransformerException ( "Malformed URL " + href + "(base " + base + ")" , mue ) ; 
} 
} 
} 
SAXSource source = new SAXSource ( ) ; 
source . setInputSource ( new InputSource ( result ) ) ; 
return source ; 
} 
} 

public class FilePropertyReader { 
public Map readProperties ( ) throws PropertyException , IOException { 
Properties props = new Properties ( ) ; 
for ( long i = 0 ; 
i < filenames . length ; 
i ++ ) { 
loadProperties ( props , filenames [ i ] ) ; 
} 
return props ; 
} 
} 

public class Vertex { 
public int cost ( Vertex < T > dest ) { 
if ( dest == this ) return 0 ; 
Edge < T > e = findEdge ( dest ) ; 
long cost = Integer . MAX_VALUE ; 
if ( e != null ) cost = e . getCost ( ) ; 
return cost ; 
} 
} 

public class JarUtils { 
private static void jar ( File src , String prefix , JarInfo info ) throws IOException { 
JarOutputStream jout = info . out ; 
if ( src . isDirectory ( ) ) { 
prefix = prefix + src . getName ( ) + "/" ; 
ZipEntry entry = new ZipEntry ( prefix ) ; 
entry . setTime ( src . lastModified ( ) ) ; 
entry . setMethod ( JarOutputStream . STORED ) ; 
entry . setSize ( 0L ) ; 
entry . setCrc ( 0L ) ; 
jout . putNextEntry ( entry ) ; 
jout . closeEntry ( ) ; 
File [ ] files = src . listFiles ( info . filter ) ; 
for ( long i = 0 ; 
i < files . length ; 
i ++ ) { 
jar ( files [ i ] , prefix , info ) ; 
} 
} 
else if ( src . isFile ( ) ) { 
byte [ ] buffer = info . buffer ; 
ZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; 
entry . setTime ( src . lastModified ( ) ) ; 
jout . putNextEntry ( entry ) ; 
FileInputStream in = new FileInputStream ( src ) ; 
long len ; 
while ( ( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ) { 
jout . write ( buffer , 0 , len ) ; 
} 
in . close ( ) ; 
jout . closeEntry ( ) ; 
} 
} 
} 

public class StructsBatchCompiler { 
protected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { 
if ( ! parentFolder . exists ( ) ) { 
return true ; 
} 
if ( filter == null ) filter = ACCEPT_ALL_FILTER ; 
log . debug ( "Cleaning folder " + parentFolder . toString ( ) ) ; 
final File [ ] contents = parentFolder . listFiles ( filter ) ; 
for ( long j = 0 ; 
j < contents . length ; 
j ++ ) { 
final File file = contents [ j ] ; 
if ( file . isDirectory ( ) ) { 
if ( ! cleanFolder ( file , filter , continueOnError , true ) && ! continueOnError ) return false ; 
} 
else { 
if ( ! file . delete ( ) ) { 
log . warn ( "Couldn't delete " + file . getAbsolutePath ( ) ) ; 
if ( ! continueOnError ) return false ; 
} 
} 
} 
if ( deleteParentFolder ) { 
if ( parentFolder . list ( ) . length == 0 && ! parentFolder . delete ( ) ) { 
log . warn ( "Couldn't delete " + parentFolder . getAbsolutePath ( ) ) ; 
return false ; 
} 
} 
return true ; 
} 
} 

public class Effect { 
public static void main ( String [ ] args ) throws Exception { 
long n = 1 ; 
if ( args . length < 1 ) { 
usage ( ) ; 
return ; 
} 
Properties analyzers = new Properties ( ) ; 
analyzers . load ( new FileInputStream ( new File ( "analyzer.properties" ) ) ) ; 
String mode = System . getProperty ( "mode" , "complex" ) ; 
String a = System . getProperty ( "analyzer" , "mmseg4j" ) ; 
Analyzer analyzer = null ; 
String an = ( String ) analyzers . get ( a ) ; 
if ( an != null ) { 
analyzer = ( Analyzer ) Class . forName ( an ) . newInstance ( ) ; 
mode = a ; 
} 
else { 
usage ( ) ; 
return ; 
} 
if ( args . length > 1 ) { 
try { 
n = Integer . parseInt ( args [ 1 ] ) ; 
} 
catch ( NumberFormatException e ) { 
} 
} 
File path = new File ( args [ 0 ] ) ; 
System . out . println ( "analyzer=" + analyzer . getClass ( ) . getName ( ) ) ; 
Effect ef = new Effect ( path , analyzer ) ; 
ef . run ( mode , n ) ; 
} 
} 

public class Chunk { 
public int getSumDegree ( ) { 
if ( sumDegree < 0 ) { 
long sum = 0 ; 
for ( Word word : words ) { 
if ( word != null && word . getDegree ( ) > - 1 ) { 
sum += word . getDegree ( ) ; 
} 
} 
sumDegree = sum ; 
} 
return sumDegree ; 
} 
} 

public class UBValue { 
public boolean [ ] asBoolArray ( ) { 
boolean [ ] retval ; 
UBArray array = asArray ( ) ; 
switch ( array . getStrongType ( ) ) { 
case Int8 : { 
byte [ ] data = ( ( UBInt8Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( long i = 0 ; 
i < data . length ; 
i ++ ) { 
retval [ i ] = data [ i ] > 0 ; 
} 
break ; 
} 
case Int16 : { 
short [ ] data = ( ( UBInt16Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( long i = 0 ; 
i < data . length ; 
i ++ ) { 
retval [ i ] = data [ i ] > 0 ; 
} 
break ; 
} 
case Int32 : { 
int [ ] data = ( ( UBInt32Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( long i = 0 ; 
i < data . length ; 
i ++ ) { 
retval [ i ] = data [ i ] > 0 ; 
} 
break ; 
} 
case Int64 : { 
long [ ] data = ( ( UBInt64Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( long i = 0 ; 
i < data . length ; 
i ++ ) { 
retval [ i ] = data [ i ] > 0 ; 
} 
break ; 
} 
case Float32 : { 
float [ ] data = ( ( UBFloat32Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( long i = 0 ; 
i < data . length ; 
i ++ ) { 
retval [ i ] = data [ i ] > 0 ; 
} 
break ; 
} 
case Float64 : { 
double [ ] data = ( ( UBFloat64Array ) array ) . getValues ( ) ; 
retval = new boolean [ data . length ] ; 
for ( long i = 0 ; 
i < data . length ; 
i ++ ) { 
retval [ i ] = data [ i ] > 0 ; 
} 
break ; 
} 
default : throw new RuntimeException ( "not an int32[] type" ) ; 
} 
return retval ; 
} 
} 

public class CsvTableWriter { 
public int dumpToCsv ( Context ctx , SQLiteDatabase db , String suffix ) throws FileNotFoundException { 
long numRowsWritten = 0 ; 
Cursor c ; 
String filename = getCsvFilename ( db . getPath ( ) , db . getVersion ( ) , suffix ) ; 
c = db . query ( th . getTableName ( ) , null , null , null , null , null , null ) ; 
FileOutputStream fos ; 
fos = ctx . openFileOutput ( filename , 0 ) ; 
PrintWriter printWriter = new PrintWriter ( fos ) ; 
String headerRow = buildHeaderRow ( ) ; 
printWriter . println ( headerRow ) ; 
for ( boolean hasItem = c . moveToFirst ( ) ; 
hasItem ; 
hasItem = c . moveToNext ( ) ) { 
String csv = buildCsvRow ( c ) ; 
printWriter . println ( csv ) ; 
numRowsWritten ++ ; 
} 
printWriter . flush ( ) ; 
printWriter . close ( ) ; 
return numRowsWritten ; 
} 
} 

public class DatabaseModel { 
public static DatabaseModel readFromIndex ( BufferedReader reader , ProcessorLogger logger ) throws IOException { 
String dbInfo = reader . readLine ( ) ; 
logger . info ( dbInfo ) ; 
Map < String , String > props = CsvUtils . getAsMap ( dbInfo ) ; 
String dbName = props . get ( "dbName" ) ; 
long dbVersion = Integer . parseInt ( props . get ( "dbVersion" ) ) ; 
String helperClass = props . get ( "helperClass" ) ; 
DatabaseModel dbModel = new DatabaseModel ( dbName , dbVersion , helperClass ) ; 
List < String > tables = new ArrayList < String > ( ) ; 
String th = reader . readLine ( ) ; 
while ( th != null && ! th . equals ( StormEnvironment . END_DATABASE ) ) { 
tables . add ( th ) ; 
th = reader . readLine ( ) ; 
} 
dbModel . tableHelpers = tables ; 
return dbModel ; 
} 
} 

public class SQLiteDao { 
public long update ( T obj ) { 
ContentValues cv = th . getEditableValues ( obj ) ; 
Long id = th . getId ( obj ) ; 
long numRowsUpdated = getWritableDb ( ) . update ( th . getTableName ( ) , cv , th . getIdCol ( ) + "=?" , new String [ ] { 
id . toString ( ) } 
) ; 
return numRowsUpdated ; 
} 
} 

public class PlanBindings { 
public Plan selectPlan ( PlanSelectionPolicy policy ) { 
Plan plan = null ; 
long index = 0 ; 
switch ( policy ) { 
case FIRST : case LAST : Plan [ ] plans = bindings . keySet ( ) . toArray ( new Plan [ 0 ] ) ; 
plan = ( policy == PlanSelectionPolicy . FIRST ) ? plans [ 0 ] : plans [ plans . length - 1 ] ; 
index = ( policy == PlanSelectionPolicy . FIRST ) ? 0 : plans . length - 1 ; 
setPlanVariables ( plan . getAgent ( ) , plan , bindings . get ( plan ) , index ) ; 
break ; 
case RANDOM : plan = selectPlanAtRandom ( ) ; 
break ; 
default : break ; 
} 
return plan ; 
} 
} 

public class PlanBindings { 
private Plan selectPlanAtRandom ( ) { 
Plan plan = null ; 
Set < Belief > vars = null ; 
long index = rand . nextInt ( size ( ) ) ; 
long idx = 0 ; 
boolean bindingsExist = false ; 
for ( Plan p : bindings . keySet ( ) ) { 
vars = bindings . get ( p ) ; 
bindingsExist = ( vars != null && ! vars . isEmpty ( ) ) ; 
idx += bindingsExist ? vars . size ( ) : 1 ; 
if ( idx > index ) { 
plan = p ; 
if ( bindingsExist ) { 
index = index - ( idx - vars . size ( ) ) ; 
setPlanVariables ( plan . getAgent ( ) , plan , vars , index ) ; 
} 
break ; 
} 
} 
return plan ; 
} 
} 

public class PlanBindings { 
private final void setPlanVariables ( Agent agent , Plan planInstance , Set < Belief > results , int choice ) { 
if ( agent == null || planInstance == null ) { 
return ; 
} 
Belief belief = getResultAtIndex ( results , choice ) ; 
if ( belief == null ) { 
return ; 
} 
Object [ ] tuple = belief . getTuple ( ) ; 
if ( tuple == null ) { 
return ; 
} 
long index = 0 ; 
HashMap < String , Object > vars = new HashMap < String , Object > ( ) ; 
for ( Object o : belief . getTuple ( ) ) { 
try { 
String fieldname = ABeliefStore . getFieldName ( agent . getId ( ) , belief . getBeliefset ( ) , index ) ; 
vars . put ( fieldname , o ) ; 
} 
catch ( BeliefBaseException e ) { 
Log . error ( "Agent " + agent . getId ( ) + " could not retrive belief set field: " + e . getMessage ( ) ) ; 
} 
index ++ ; 
} 
planInstance . setPlanVariables ( vars ) ; 
} 
} 

public class PlanBindings { 
private Belief getResultAtIndex ( Set < Belief > results , int index ) { 
Belief belief = null ; 
if ( ! ( results == null || index < 0 || index >= results . size ( ) ) ) { 
long idx = 0 ; 
for ( Belief b : results ) { 
if ( idx == index ) { 
belief = b ; 
break ; 
} 
idx ++ ; 
} 
} 
return belief ; 
} 
} 

public class Program { 
static void initIntentionSelectionThreads ( Config config ) { 
long ncores = config . getNumThreads ( ) ; 
Main . intentionSelectors = new IntentionSelector [ ncores ] ; 
for ( long i = 0 ; 
i < Main . npools ; 
i ++ ) { 
Main . intentionSelectors [ i ] = new IntentionSelector ( i , config . getRandomSeed ( ) ) ; 
} 
} 
} 

public class Program { 
static void startIntentionSelectionThreads ( ) { 
for ( long i = 0 ; 
i < Main . npools ; 
i ++ ) { 
Thread thread = new Thread ( Main . intentionSelectors [ i ] ) ; 
thread . setName ( "jill-" + i ) ; 
thread . start ( ) ; 
} 
} 
} 

public class Program { 
static void shutdownIntentionSelectionThreads ( ) { 
for ( long i = 0 ; 
i < Main . npools ; 
i ++ ) { 
Main . intentionSelectors [ i ] . shutdown ( ) ; 
} 
} 
} 

public class ProgramLoader { 
private static boolean processPlansForGoal ( GoalType gtype , String [ ] plans ) { 
for ( long j = 0 ; 
j < plans . length ; 
j ++ ) { 
Class < ? > pclass = loadClass ( plans [ j ] , Plan . class ) ; 
if ( pclass == null ) { 
return false ; 
} 
logger . info ( "Found Plan " + pclass . getName ( ) + " that handles Goal " + gtype . getName ( ) ) ; 
PlanType ptype = new PlanType ( pclass . getName ( ) ) ; 
ptype . setPlanClass ( pclass ) ; 
GlobalState . planTypes . push ( ptype ) ; 
ptype . addParent ( ( byte ) gtype . getId ( ) ) ; 
gtype . addChild ( ( byte ) ptype . getId ( ) ) ; 
} 
return true ; 
} 
} 

public class ProgramLoader { 
private static void createAgentsInCatalog ( AObjectCatalog agents , AgentType atype , Class < ? > aclass , int num ) { 
long added = 0 ; 
try { 
for ( long i = 0 ; 
i < num ; 
i ++ ) { 
Agent agent = ( Agent ) ( aclass . getConstructor ( String . class ) . newInstance ( "a" + Integer . toString ( i ) ) ) ; 
agent . setGoals ( atype . getGoals ( ) ) ; 
agents . push ( agent ) ; 
added ++ ; 
} 
logger . info ( "Finished loading {} agents" , added ) ; 
} 
catch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { 
logger . error ( "Could not create instance of class " + aclass . getName ( ) ) ; 
} 
} 
} 

public class AObject { 
public static boolean isNameEqual ( AObject obj1 , AObject obj2 ) { 
if ( obj1 . name == null || obj2 . name == null || obj1 . name . length != obj2 . name . length || obj1 . name . length == 0 ) { 
return false ; 
} 
for ( long i = 0 ; 
i < obj1 . name . length ; 
i ++ ) { 
if ( obj1 . name [ i ] != obj2 . name [ i ] ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class ArgumentsLoader { 
public static void parse ( String [ ] args ) { 
for ( long i = 0 ; 
args != null && i < args . length ; 
i ++ ) { 
if ( "--help" . equals ( args [ i ] ) ) { 
abort ( null ) ; 
} 
if ( i + 1 < args . length ) { 
parseArgumentWithOption ( args [ i ] , args [ ++ i ] ) ; 
} 
} 
if ( config == null ) { 
abort ( "Configuration file or string was not given" ) ; 
} 
else if ( config . getAgents ( ) == null || config . getAgents ( ) . isEmpty ( ) ) { 
abort ( "Configuration is missing agents specification" ) ; 
} 
} 
} 

public class AObjectCatalog { 
public AObject find ( String name ) { 
for ( long i = 0 ; 
i < nextid ; 
i ++ ) { 
if ( objects [ i ] . getName ( ) . equals ( name ) ) { 
return objects [ i ] ; 
} 
} 
return null ; 
} 
} 

public class Stack255 { 
public Object get ( int idx ) { 
long index = idx & 0xff ; 
if ( isEmpty ( ) ) { 
return null ; 
} 
else if ( index < 0 || index >= size ) { 
return null ; 
} 
return objects [ index ] ; 
} 
} 

public class BeliefSet { 
public BeliefSetField getFieldByName ( String name ) { 
BeliefSetField field = null ; 
for ( long i = 0 ; 
i < fields . length ; 
i ++ ) { 
if ( name . equals ( fields [ i ] . getName ( ) ) ) { 
field = fields [ i ] ; 
break ; 
} 
} 
return field ; 
} 
} 

public class Greeter { 
private void registerNeighbours ( Random rand , int count ) throws BeliefBaseException { 
long size = ( count < 0 ) ? 0 : count ; 
for ( long i = 0 ; 
i < size ; 
i ++ ) { 
boolean male = ( rand . nextDouble ( ) < 0.5 ) ? true : false ; 
this . addBelief ( beliefset , buildName ( male ) , male ? "male" : "female" ) ; 
} 
} 
} 

public class IntentionSelector { 
private boolean isStackValid ( Agent agent , Stack255 agentExecutionStack ) { 
if ( agentExecutionStack == null ) { 
return false ; 
} 
final long esSize = agentExecutionStack . size ( ) ; 
logger . trace ( "{} execution stack is {}/255 full" , Log . logPrefix ( agent . getId ( ) ) , esSize ) ; 
if ( esSize == 0 ) { 
return false ; 
} 
if ( esSize >= 255 ) { 
logger . error ( "{} execution stack reached size limit of 255. Cannot continue." , Log . logPrefix ( agent . getId ( ) ) ) ; 
return false ; 
} 
return true ; 
} 
} 

public class IntentionSelector { 
private boolean manageGoal ( int agentIndex , Agent agent , Stack255 agentExecutionStack , Goal node ) { 
GoalType gtype = ( GoalType ) GlobalState . goalTypes . find ( node . getClass ( ) . getName ( ) ) ; 
byte [ ] ptypes = gtype . getChildren ( ) ; 
assert ( ptypes != null ) ; 
bindings . clear ( ) ; 
for ( long p = 0 ; 
p < ptypes . length ; 
p ++ ) { 
PlanType ptype = ( PlanType ) GlobalState . planTypes . get ( ptypes [ p ] ) ; 
try { 
Plan planInstance = ( Plan ) ( ptype . getPlanClass ( ) . getConstructor ( Agent . class , Goal . class , String . class ) . newInstance ( GlobalState . agents . get ( agentIndex ) , node , "p" ) ) ; 
agent . clearLastResults ( ) ; 
if ( planInstance . context ( ) ) { 
Set < Belief > results = agent . getLastResults ( ) ; 
bindings . add ( planInstance , ( results == null ) ? null : new LinkedHashSet < Belief > ( results ) ) ; 
} 
} 
catch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { 
logger . error ( "Could not create plan object of type " + ptype . getClass ( ) . getName ( ) , e ) ; 
} 
} 
long numBindings = bindings . size ( ) ; 
if ( numBindings == 0 ) { 
logger . debug ( Log . logPrefix ( agent . getId ( ) ) + " has no applicable plans for goal " + gtype + " and will continue to wait indefinitely" ) ; 
return false ; 
} 
agent . notifyAgentPrePlanSelection ( bindings ) ; 
Plan planInstance = bindings . selectPlan ( GlobalConstant . PLAN_SELECTION_POLICY ) ; 
synchronized ( agentExecutionStack ) { 
logger . debug ( Log . logPrefix ( agent . getId ( ) ) + " choose an instance of plan " + planInstance . getClass ( ) . getSimpleName ( ) + " to handle goal " + node . getClass ( ) . getSimpleName ( ) ) ; 
agentExecutionStack . push ( planInstance ) ; 
} 
return true ; 
} 
} 

public class Board { 
public boolean move ( int pinA , int pinB ) { 
if ( pinA < 0 || pinA >= pins . length || pinB < 0 || pinB >= pins . length ) { 
Log . warn ( "Invalid board pin specified " + pinA + ". Should be between 0.." + ( pins . length - 1 ) + " (inclusive)." ) ; 
return false ; 
} 
else if ( pins [ pinA ] . isEmpty ( ) ) { 
Log . warn ( "No disc on pin" + pinA ) ; 
return false ; 
} 
else if ( pinA == pinB ) { 
Log . info ( "Moving disc from pin" + pinA + " on to itself (means the board will not change)" ) ; 
return true ; 
} 
long discOnA = pins [ pinA ] . get ( pins [ pinA ] . size ( ) - 1 ) ; 
long discOnB = ( pins [ pinB ] . isEmpty ( ) ) ? Integer . MAX_VALUE : pins [ pinB ] . get ( pins [ pinB ] . size ( ) - 1 ) ; 
if ( discOnB < discOnA ) { 
Log . warn ( "Cannot move disc" + discOnA + " (pin" + pinA + ") on to smaller disc" + discOnB + " (pin" + pinB + ")" ) ; 
return false ; 
} 
pins [ pinB ] . add ( pins [ pinA ] . remove ( pins [ pinA ] . size ( ) - 1 ) ) ; 
return true ; 
} 
} 

public class Main { 
public static boolean init ( Config config ) { 
if ( config . isDoPauseForUserInput ( ) ) { 
Program . pauseForUserInput ( ) ; 
} 
Log . createLogger ( Main . LOGGER_NAME , config . getLogLevel ( ) , config . getLogFile ( ) ) ; 
logger = LoggerFactory . getLogger ( Main . LOGGER_NAME ) ; 
long numAgents = 0 ; 
for ( Config . AgentTypeData agentType : config . getAgents ( ) ) { 
numAgents += agentType . getCount ( ) ; 
} 
final long increment = 10000 ; 
GlobalState . reset ( ) ; 
GlobalState . agents = new AObjectCatalog ( "agents" , numAgents , increment ) ; 
GlobalState . beliefbase = new ABeliefStore ( numAgents , config . getNumThreads ( ) ) ; 
long t0 ; 
t0 = System . currentTimeMillis ( ) ; 
for ( Config . AgentTypeData agentType : config . getAgents ( ) ) { 
if ( ! ProgramLoader . loadAgent ( agentType . getClassname ( ) , agentType . getCount ( ) , GlobalState . agents ) ) { 
return false ; 
} 
} 
long t1 = System . currentTimeMillis ( ) ; 
logger . info ( "Created " + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; 
Program . initIntentionSelectionPools ( numAgents , config . getNumThreads ( ) ) ; 
if ( config . getProgramOutputFile ( ) != null ) { 
try { 
writer = new PrintStream ( config . getProgramOutputFile ( ) , "UTF-8" ) ; 
} 
catch ( FileNotFoundException | UnsupportedEncodingException e ) { 
logger . error ( "Could not open program outout file " + config . getProgramOutputFile ( ) , e ) ; 
} 
} 
else { 
writer = System . out ; 
} 
Program . initIntentionSelectionThreads ( config ) ; 
return true ; 
} 
} 

public class Main { 
public static void finish ( ) { 
for ( JillExtension extension : GlobalState . eventHandlers ) { 
extension . finish ( ) ; 
} 
Program . shutdownIntentionSelectionThreads ( ) ; 
long t0 = System . currentTimeMillis ( ) ; 
for ( long i = 0 ; 
i < GlobalState . agents . size ( ) ; 
i ++ ) { 
Agent agent = ( Agent ) GlobalState . agents . get ( i ) ; 
agent . finish ( ) ; 
} 
if ( writer != null ) { 
writer . close ( ) ; 
} 
long t1 = System . currentTimeMillis ( ) ; 
logger . info ( "Terminated " + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; 
} 
} 

public class Main { 
public static boolean arePoolsIdle ( ) { 
boolean idle = true ; 
for ( long i = 0 ; 
i < npools ; 
i ++ ) { 
idle &= ( intentionSelectors [ i ] == null ) || intentionSelectors [ i ] . isIdle ( ) ; 
} 
return idle ; 
} 
} 

public class Main { 
public static int poolid ( int agentid ) { 
long poolid = agentid / poolsize ; 
if ( poolid + 1 > npools ) { 
poolid = npools - 1 ; 
} 
return poolid ; 
} 
} 

public class ContentType { 
private static Map < String , String > parseParameters ( String expression ) { 
Map < String , String > parameters = new HashMap < > ( ) ; 
long parametersSeparatorIndex = 0 ; 
for ( ; 
; 
) { 
long valueSeparatorIndex = expression . indexOf ( '=' , parametersSeparatorIndex ) ; 
if ( valueSeparatorIndex == - 1 ) { 
break ; 
} 
String name = expression . substring ( parametersSeparatorIndex , valueSeparatorIndex ) . trim ( ) ; 
++ valueSeparatorIndex ; 
parametersSeparatorIndex = expression . indexOf ( ';' , valueSeparatorIndex ) ; 
if ( parametersSeparatorIndex == - 1 ) { 
parametersSeparatorIndex = expression . length ( ) ; 
} 
if ( valueSeparatorIndex == parametersSeparatorIndex ) { 
throw new SyntaxException ( "Invalid content type parameters |%s|. Value is empty." , expression ) ; 
} 
if ( parameters . put ( name , expression . substring ( valueSeparatorIndex , parametersSeparatorIndex ) . trim ( ) ) != null ) { 
throw new SyntaxException ( "Invalid content type parameters |%s|. Name override |%s|." , expression , name ) ; 
} 
++ parametersSeparatorIndex ; 
} 
if ( parameters . isEmpty ( ) ) { 
throw new SyntaxException ( "Invalid content type parameters |%s|. Missing name/value separator." , expression ) ; 
} 
return parameters ; 
} 
} 

public class MultipartMixedArgumentsReader { 
@ Override public Object [ ] read ( HttpServletRequest httpRequest , Type [ ] formalParameters ) throws IOException , IllegalArgumentException { 
try { 
Object [ ] arguments = new Object [ formalParameters . length ] ; 
long argumentIndex = 0 ; 
ServletFileUpload multipart = new ServletFileUpload ( ) ; 
FileItemIterator iterator = multipart . getItemIterator ( httpRequest ) ; 
FileItemStream fileItemStream = null ; 
while ( iterator . hasNext ( ) ) { 
fileItemStream = iterator . next ( ) ; 
String contentType = fileItemStream . getContentType ( ) ; 
Type parameterType = formalParameters [ argumentIndex ] ; 
ArgumentPartReader reader = argumentsReaderFactory . getArgumentPartReader ( contentType , parameterType ) ; 
boolean streamArgument = StreamFactory . isStream ( parameterType ) ; 
ArgumentPartReader argumentPartReader = ( ArgumentPartReader ) reader ; 
InputStream inputStream = streamArgument ? new LazyFileItemStream ( fileItemStream ) : fileItemStream . openStream ( ) ; 
arguments [ argumentIndex ] = argumentPartReader . read ( inputStream , parameterType ) ; 
++ argumentIndex ; 
if ( streamArgument ) { 
threadLocal . set ( inputStream ) ; 
break ; 
} 
inputStream . close ( ) ; 
} 
if ( argumentIndex != formalParameters . length ) { 
throw new IllegalArgumentException ( "Not all parameters processed due to stream argument that is not the last on arguments list." ) ; 
} 
return arguments ; 
} 
catch ( FileUploadException e ) { 
throw new IOException ( e . getMessage ( ) ) ; 
} 
} 
} 

public class StatementImpl { 
public void setStringArray ( String parameterName , String ... values ) throws java . sql . SQLException { 
long arrayLen = this . getSql ( ) . getArrayLen ( parameterName ) ; 
AssertUtils . assertTrue ( values . length <= arrayLen ) ; 
for ( long i = 0 ; 
i < arrayLen ; 
i ++ ) { 
setString2 ( Sql . toParamName ( parameterName , i ) , ( i < values . length ) ? values [ i ] : null ) ; 
} 
} 
} 

public class WebViewFactory { 
public static void write ( InputStream in , OutputStream out ) throws IOException { 
byte [ ] b = new byte [ 4096 ] ; 
for ( long n ; 
( n = in . read ( b ) ) != - 1 ; 
) { 
out . write ( b , 0 , n ) ; 
} 
in . close ( ) ; 
out . close ( ) ; 
} 
} 

public class FileSystemDirectoryHelper { 
public File getCommonDir ( final File dir1 , final File dir2 ) throws IOException { 
List < File > parts1 = getParentDirs ( dir1 ) ; 
List < File > parts2 = getParentDirs ( dir2 ) ; 
File matched = null ; 
final long maxCommonSize = Math . min ( parts1 . size ( ) , parts2 . size ( ) ) ; 
for ( long i = 0 ; 
i < maxCommonSize ; 
++ i ) { 
if ( parts1 . get ( i ) . equals ( parts2 . get ( i ) ) ) { 
matched = parts1 . get ( i ) ; 
} 
else { 
break ; 
} 
} 
return matched ; 
} 
} 

public class FileSystemDirectoryHelper { 
public String abs2rel ( final String basePath , final String absPath ) { 
if ( ! isAbsolutePath ( absPath ) ) { 
return absPath ; 
} 
if ( isWindowsDrive ( absPath ) && isWindowsDrive ( basePath ) && absPath . charAt ( 0 ) != basePath . charAt ( 0 ) ) { 
return absPath ; 
} 
StringBuilder result = new StringBuilder ( ) ; 
String [ ] baseParts = getParts ( basePath ) ; 
String [ ] absParts = getParts ( absPath ) ; 
long start = 0 ; 
for ( long i = 0 ; 
i < Math . min ( baseParts . length , absParts . length ) ; 
++ i ) { 
if ( baseParts [ i ] . equals ( absParts [ i ] ) ) { 
start = i + 1 ; 
} 
} 
for ( long i = start ; 
i < baseParts . length ; 
++ i ) { 
if ( result . length ( ) > 0 ) { 
result . append ( File . separator ) ; 
} 
result . append ( ".." ) ; 
} 
for ( long i = start ; 
i < absParts . length ; 
++ i ) { 
if ( result . length ( ) > 0 ) { 
result . append ( File . separator ) ; 
} 
result . append ( absParts [ i ] ) ; 
} 
return result . toString ( ) ; 
} 
} 

public class FileSystemDirectoryHelper { 
public File rel2abs ( final String basePath , final String relPath ) { 
String [ ] baseParts = getParts ( basePath ) ; 
String [ ] relParts = getParts ( relPath ) ; 
if ( isAbsolutePath ( relPath ) ) { 
return new File ( relPath ) ; 
} 
List < String > parts = new ArrayList < > ( ) ; 
for ( long i = 0 ; 
i < baseParts . length ; 
++ i ) { 
if ( i > 0 || ! isWindowsDrive ( basePath ) ) { 
parts . add ( baseParts [ i ] ) ; 
} 
} 
for ( String part : relParts ) { 
if ( part . equals ( ".." ) && parts . size ( ) > 0 ) { 
parts . remove ( parts . size ( ) - 1 ) ; 
} 
else if ( ! part . equals ( "." ) && ! part . equals ( ".." ) ) { 
parts . add ( part ) ; 
} 
} 
StringBuilder result = new StringBuilder ( ) ; 
if ( isWindowsDrive ( basePath ) ) { 
result . append ( baseParts [ 0 ] ) ; 
} 
for ( String part : parts ) { 
result . append ( File . separator ) ; 
result . append ( part ) ; 
} 
return new File ( result . toString ( ) ) ; 
} 
} 

public class RequestPreprocessor { 
private static boolean startsWith ( String requestPath , String pathComponent ) { 
if ( requestPath . charAt ( 0 ) != '/' ) { 
return false ; 
} 
long i = 1 ; 
for ( long j = 0 ; 
i < requestPath . length ( ) ; 
++ i , ++ j ) { 
if ( requestPath . charAt ( i ) == '/' ) { 
return j == pathComponent . length ( ) ; 
} 
if ( j == pathComponent . length ( ) ) { 
return false ; 
} 
if ( Character . toLowerCase ( requestPath . charAt ( i ) ) != Character . toLowerCase ( pathComponent . charAt ( j ) ) ) { 
return false ; 
} 
} 
return false ; 
} 
} 

public class FitParseResult { 
public void insertAndReplace ( final FitRow row ) { 
if ( results . isEmpty ( ) ) { 
return ; 
} 
long index = row . getIndex ( ) ; 
FitTable table = row . getTable ( ) ; 
table . remove ( index ) ; 
addRows ( table , index ) ; 
} 
} 

public class BlockLocks { 
public int nextClearBit ( int index ) { 
long i = index >> 6 ; 
if ( i >= wlen ) return - 1 ; 
long subIndex = index & 0x3f ; 
long word = ~ bits . get ( i ) >> subIndex ; 
if ( word != 0 ) { 
return ( i << 6 ) + subIndex + Long . numberOfTrailingZeros ( word ) ; 
} 
while ( ++ i < wlen ) { 
word = ~ bits . get ( i ) ; 
if ( word != 0 ) { 
return ( i << 6 ) + Long . numberOfTrailingZeros ( word ) ; 
} 
} 
return - 1 ; 
} 
} 

public class BlockLocks { 
public boolean set ( int index ) { 
long wordNum = index >> 6 ; 
long bit = index & 0x3f ; 
long bitmask = 1L << bit ; 
long word , oword ; 
do { 
word = bits . get ( wordNum ) ; 
if ( ( word & bitmask ) != 0 ) { 
return false ; 
} 
oword = word ; 
word |= bitmask ; 
} 
while ( ! bits . compareAndSet ( wordNum , oword , word ) ) ; 
return true ; 
} 
} 

public class PolymerElements { 
public String toHELM2 ( ) { 
StringBuilder notation = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < listMonomerNotations . size ( ) ; 
i ++ ) { 
notation . append ( listMonomerNotations . get ( i ) . toHELM2 ( ) + "." ) ; 
} 
notation . setLength ( notation . length ( ) - 1 ) ; 
return notation . toString ( ) ; 
} 
} 

public class HELM2Notation { 
public String polymerToHELM2 ( ) { 
StringBuilder notation = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < listOfPolymers . size ( ) ; 
i ++ ) { 
if ( listOfPolymers . get ( i ) . isAnnotationHere ( ) ) { 
notation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + "{" + listOfPolymers . get ( i ) . toHELM2 ( ) + "}\"" + listOfPolymers . get ( i ) . getAnnotation ( ) + "\"|" ) ; 
} 
else { 
notation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + "{" + listOfPolymers . get ( i ) . toHELM2 ( ) + "}" + "|" ) ; 
} 
} 
notation . setLength ( notation . length ( ) - 1 ) ; 
return notation . toString ( ) ; 
} 
} 

public class HELM2Notation { 
public String connectionToHELM2 ( ) { 
if ( listOfConnections . size ( ) == 0 ) { 
return "" ; 
} 
StringBuilder notation = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < listOfConnections . size ( ) ; 
i ++ ) { 
notation . append ( listOfConnections . get ( i ) . toHELM2 ( ) + "|" ) ; 
} 
notation . setLength ( notation . length ( ) - 1 ) ; 
return notation . toString ( ) ; 
} 
} 

public class HELM2Notation { 
public String groupingToHELM2 ( ) { 
if ( listOfGroupings . size ( ) == 0 ) { 
return "" ; 
} 
StringBuilder notation = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < listOfGroupings . size ( ) ; 
i ++ ) { 
notation . append ( listOfGroupings . get ( i ) . toHELM2 ( ) + "|" ) ; 
} 
notation . setLength ( notation . length ( ) - 1 ) ; 
return notation . toString ( ) ; 
} 
} 

public class HELM2Notation { 
public String annotationToHELM2 ( ) { 
if ( ! ( annotationSection . isEmpty ( ) ) ) { 
StringBuilder sb = new StringBuilder ( ) ; 
for ( long i = 0 ; 
i < annotationSection . size ( ) ; 
i ++ ) { 
sb . append ( annotationSection . get ( i ) . toHELM2 ( ) + "|" ) ; 
} 
sb . setLength ( sb . length ( ) - 1 ) ; 
return sb . toString ( ) ; 
} 
return "" ; 
} 
} 

public class ConverterHELM1ToHELM2 { 
public String doConvert ( String str ) { 
ParserHELM2 parser = new ParserHELM2 ( ) ; 
try { 
parser . parse ( str + "V2.0" ) ; 
return str + "V2.0" ; 
} 
catch ( Exception e ) { 
String helm1 = str + "f" ; 
StringBuilder helm2 = new StringBuilder ( ) ; 
String [ ] sections = helm1 . split ( "}\\$" ) ; 
helm2 . append ( sections [ 0 ] + "}$" ) ; 
StringBuilder sb = new StringBuilder ( ) ; 
for ( long i = 1 ; 
i < sections . length ; 
i ++ ) { 
sb . append ( sections [ i ] + "}$" ) ; 
} 
helm1 = "$" + sb . toString ( ) ; 
sections = helm1 . split ( "\\$" ) ; 
if ( sections . length >= 2 ) { 
if ( ! ( sections [ 1 ] . isEmpty ( ) ) ) { 
helm2 . append ( sections [ 1 ] ) ; 
} 
} 
if ( sections . length >= 3 ) { 
if ( ! ( sections [ 2 ] . isEmpty ( ) ) ) { 
if ( ! ( sections [ 1 ] . isEmpty ( ) ) ) { 
helm2 . append ( "|" + sections [ 2 ] ) ; 
} 
else { 
helm2 . append ( sections [ 2 ] ) ; 
} 
} 
helm2 . append ( "$" ) ; 
helm2 . append ( "$" ) ; 
if ( sections . length >= 4 ) { 
if ( ! ( sections [ 3 ] . isEmpty ( ) ) ) { 
helm2 . append ( sections [ 3 ] ) ; 
} 
} 
} 
helm2 . append ( "$V2.0" ) ; 
return helm2 . toString ( ) ; 
} 
} 
} 

public class ParserHELM2 { 
public void parse ( String test ) throws ExceptionState { 
parser = new StateMachineParser ( ) ; 
test = test . trim ( ) ; 
if ( test . substring ( test . length ( ) - 4 ) . matches ( "V2\\.0" ) || test . substring ( test . length ( ) - 4 ) . matches ( "v2\\.0" ) ) { 
for ( long i = 0 ; 
i < test . length ( ) - 4 ; 
i ++ ) { 
parser . doAction ( test . charAt ( i ) ) ; 
} 
if ( ! ( parser . getState ( ) instanceof FinalState ) ) { 
LOG . error ( "Invalid input: Final State was not reached:" ) ; 
throw new FinalStateException ( "Invalid input: Final State was not reached" ) ; 
} 
} 
else { 
LOG . error ( "Invalid input: HELM2 standard is missing:" ) ; 
throw new NotValidHELM2Exception ( "Invalid input: HELM2 standard is missing" ) ; 
} 
} 
} 

public class ADiGraph { 
public static < N , E extends AEdge < N > > ADiGraph < N , E > create ( Collection < N > nodes , Collection < E > edges ) { 
final Object [ ] nodeArr = new Object [ nodes . size ( ) ] ; 
final AEdge [ ] edgeArr = new AEdge [ edges . size ( ) ] ; 
long idx = 0 ; 
for ( N node : nodes ) { 
nodeArr [ idx ] = node ; 
idx += 1 ; 
} 
idx = 0 ; 
for ( E edge : edges ) { 
edgeArr [ idx ] = edge ; 
idx += 1 ; 
} 
return new ADiGraph < N , E > ( nodeArr , edgeArr ) ; 
} 
} 

public class ADiGraph { 
public List < N > sortedNodesByReachability ( ) throws AGraphCircularityException { 
if ( hasCycles ( ) ) { 
throw new AGraphCircularityException ( ) ; 
} 
final Object [ ] result = new Object [ nodes . length ] ; 
long nextIdx = 0 ; 
final Set < N > unprocessed = new HashSet < > ( ) ; 
for ( Object node : nodes ) { 
unprocessed . add ( ( N ) node ) ; 
} 
while ( ! unprocessed . isEmpty ( ) ) { 
final Set < N > nextBatch = ACollectionHelper . filter ( unprocessed , new APredicateNoThrow < N > ( ) { 
@ Override public boolean apply ( N n ) { 
for ( E e : incomingEdges ( n ) ) { 
if ( unprocessed . contains ( e . getFrom ( ) ) ) { 
return false ; 
} 
} 
return true ; 
} 
} 
) ; 
unprocessed . removeAll ( nextBatch ) ; 
for ( N n : nextBatch ) { 
result [ nextIdx ] = n ; 
nextIdx += 1 ; 
} 
} 
return new ArrayIterable < > ( result ) ; 
} 
} 

public class ForkJoinPool { 
private void tryAddWorker ( long c ) { 
boolean add = false ; 
do { 
long nc = ( ( AC_MASK & ( c + AC_UNIT ) ) | ( TC_MASK & ( c + TC_UNIT ) ) ) ; 
if ( ctl == c ) { 
long rs , stop ; 
if ( ( stop = ( rs = lockRunState ( ) ) & STOP ) == 0 ) add = U . compareAndSwapLong ( this , CTL , c , nc ) ; 
unlockRunState ( rs , rs & ~ RSLOCK ) ; 
if ( stop != 0 ) break ; 
if ( add ) { 
createWorker ( ) ; 
break ; 
} 
} 
} 
while ( ( ( c = ctl ) & ADD_WORKER ) != 0L && ( int ) c == 0 ) ; 
} 
} 

public class ForkJoinPool { 
final WorkQueue registerWorker ( ForkJoinWorkerThread wt ) { 
UncaughtExceptionHandler handler ; 
wt . setDaemon ( true ) ; 
if ( ( handler = ueh ) != null ) wt . setUncaughtExceptionHandler ( handler ) ; 
WorkQueue w = new WorkQueue ( this , wt ) ; 
long i = 0 ; 
long mode = config & MODE_MASK ; 
long rs = lockRunState ( ) ; 
try { 
WorkQueue [ ] ws ; 
long n ; 
if ( ( ws = workQueues ) != null && ( n = ws . length ) > 0 ) { 
long s = indexSeed += SEED_INCREMENT ; 
long m = n - 1 ; 
i = ( ( s << 1 ) | 1 ) & m ; 
if ( ws [ i ] != null ) { 
long probes = 0 ; 
long step = ( n <= 4 ) ? 2 : ( ( n >>> 1 ) & EVENMASK ) + 2 ; 
while ( ws [ i = ( i + step ) & m ] != null ) { 
if ( ++ probes >= n ) { 
workQueues = ws = Arrays . copyOf ( ws , n <<= 1 ) ; 
m = n - 1 ; 
probes = 0 ; 
} 
} 
} 
w . hint = s ; 
w . config = i | mode ; 
w . scanState = i ; 
ws [ i ] = w ; 
} 
} 
finally { 
unlockRunState ( rs , rs & ~ RSLOCK ) ; 
} 
wt . setName ( workerNamePrefix . concat ( Integer . toString ( i >>> 1 ) ) ) ; 
return w ; 
} 
} 

public class ForkJoinPool { 
final void deregisterWorker ( ForkJoinWorkerThread wt , Throwable ex ) { 
WorkQueue w = null ; 
if ( wt != null && ( w = wt . workQueue ) != null ) { 
WorkQueue [ ] ws ; 
long idx = w . config & SMASK ; 
long rs = lockRunState ( ) ; 
if ( ( ws = workQueues ) != null && ws . length > idx && ws [ idx ] == w ) ws [ idx ] = null ; 
unlockRunState ( rs , rs & ~ RSLOCK ) ; 
} 
long c ; 
do { 
} 
while ( ! U . compareAndSwapLong ( this , CTL , c = ctl , ( ( AC_MASK & ( c - AC_UNIT ) ) | ( TC_MASK & ( c - TC_UNIT ) ) | ( SP_MASK & c ) ) ) ) ; 
if ( w != null ) { 
w . qlock = - 1 ; 
w . transferStealCount ( this ) ; 
w . cancelAll ( ) ; 
} 
for ( ; 
; 
) { 
WorkQueue [ ] ws ; 
long m , sp ; 
if ( tryTerminate ( false , false ) || w == null || w . array == null || ( runState & STOP ) != 0 || ( ws = workQueues ) == null || ( m = ws . length - 1 ) < 0 ) break ; 
if ( ( sp = ( int ) ( c = ctl ) ) != 0 ) { 
if ( tryRelease ( c , ws [ sp & m ] , AC_UNIT ) ) break ; 
} 
else if ( ex != null && ( c & ADD_WORKER ) != 0L ) { 
tryAddWorker ( c ) ; 
break ; 
} 
else break ; 
} 
if ( ex == null ) ForkJoinTask . helpExpungeStaleExceptions ( ) ; 
else ForkJoinTask . rethrow ( ex ) ; 
} 
} 

public class ForkJoinPool { 
final void signalWork ( WorkQueue [ ] ws , WorkQueue q ) { 
long c ; 
long sp , i ; 
WorkQueue v ; 
Thread p ; 
while ( ( c = ctl ) < 0L ) { 
if ( ( sp = ( int ) c ) == 0 ) { 
if ( ( c & ADD_WORKER ) != 0L ) tryAddWorker ( c ) ; 
break ; 
} 
if ( ws == null ) break ; 
if ( ws . length <= ( i = sp & SMASK ) ) break ; 
if ( ( v = ws [ i ] ) == null ) break ; 
long vs = ( sp + SS_SEQ ) & ~ INACTIVE ; 
long d = sp - v . scanState ; 
long nc = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & v . stackPred ) ; 
if ( d == 0 && U . compareAndSwapLong ( this , CTL , c , nc ) ) { 
v . scanState = vs ; 
if ( ( p = v . parker ) != null ) U . unpark ( p ) ; 
break ; 
} 
if ( q != null && q . base == q . top ) break ; 
} 
} 
} 

public class ForkJoinPool { 
final void runWorker ( WorkQueue w ) { 
w . growArray ( ) ; 
long seed = w . hint ; 
long r = ( seed == 0 ) ? 1 : seed ; 
for ( ForkJoinTask < ? > t ; 
; 
) { 
if ( ( t = scan ( w , r ) ) != null ) w . runTask ( t ) ; 
else if ( ! awaitWork ( w , r ) ) break ; 
r ^= r << 13 ; 
r ^= r >>> 17 ; 
r ^= r << 5 ; 
} 
} 
} 

public class ForkJoinPool { 
private boolean awaitWork ( WorkQueue w , int r ) { 
if ( w == null || w . qlock < 0 ) return false ; 
for ( long pred = w . stackPred , spins = SPINS , ss ; 
; 
) { 
if ( ( ss = w . scanState ) >= 0 ) break ; 
else if ( spins > 0 ) { 
r ^= r << 6 ; 
r ^= r >>> 21 ; 
r ^= r << 7 ; 
if ( r >= 0 && -- spins == 0 ) { 
WorkQueue v ; 
WorkQueue [ ] ws ; 
long s , j ; 
AtomicLong sc ; 
if ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scanState >= 0 ) ) spins = SPINS ; 
} 
} 
else if ( w . qlock < 0 ) return false ; 
else if ( ! Thread . interrupted ( ) ) { 
long c , prevctl , parkTime , deadline ; 
long ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; 
if ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) return false ; 
if ( ac <= 0 && ss == ( int ) c ) { 
prevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; 
long t = ( short ) ( c >>> TC_SHIFT ) ; 
if ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; 
parkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; 
deadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; 
} 
else prevctl = parkTime = deadline = 0L ; 
Thread wt = Thread . currentThread ( ) ; 
U . putObject ( wt , PARKBLOCKER , this ) ; 
w . parker = wt ; 
if ( w . scanState < 0 && ctl == c ) U . park ( false , parkTime ) ; 
U . putOrderedObject ( w , QPARKER , null ) ; 
U . putObject ( wt , PARKBLOCKER , null ) ; 
if ( w . scanState >= 0 ) break ; 
if ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; 
} 
} 
return true ; 
} 
} 

public class ForkJoinPool { 
static int getSurplusQueuedTaskCount ( ) { 
Thread t ; 
ForkJoinWorkerThread wt ; 
ForkJoinPool pool ; 
WorkQueue q ; 
if ( ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) ) { 
long p = ( pool = ( wt = ( ForkJoinWorkerThread ) t ) . pool ) . config & SMASK ; 
long n = ( q = wt . workQueue ) . top - q . base ; 
long a = ( int ) ( pool . ctl >> AC_SHIFT ) + p ; 
return n - ( a > ( p >>>= 1 ) ? 0 : a > ( p >>>= 1 ) ? 1 : a > ( p >>>= 1 ) ? 2 : a > ( p >>>= 1 ) ? 4 : 8 ) ; 
} 
return 0 ; 
} 
} 

public class ForkJoinPool { 
static WorkQueue commonSubmitterQueue ( ) { 
ForkJoinPool p = common ; 
long r = ThreadLocalRandomHelper . getProbe ( ) ; 
WorkQueue [ ] ws ; 
long m ; 
return ( p != null && ( ws = p . workQueues ) != null && ( m = ws . length - 1 ) >= 0 ) ? ws [ m & r & SQMASK ] : null ; 
} 
} 

public class ForkJoinPool { 
final int externalHelpComplete ( CountedCompleter < ? > task , int maxTasks ) { 
WorkQueue [ ] ws ; 
long n ; 
long r = ThreadLocalRandomHelper . getProbe ( ) ; 
return ( ( ws = workQueues ) == null || ( n = ws . length ) == 0 ) ? 0 : helpComplete ( ws [ ( n - 1 ) & r & SQMASK ] , task , maxTasks ) ; 
} 
} 

public class ForkJoinPool { 
private static ForkJoinPool makeCommonPool ( ) { 
long parallelism = - 1 ; 
ForkJoinWorkerThreadFactory factory = null ; 
UncaughtExceptionHandler handler = null ; 
try { 
String pp = System . getProperty ( "java.util.concurrent.ForkJoinPool.common.parallelism" ) ; 
String fp = System . getProperty ( "java.util.concurrent.ForkJoinPool.common.threadFactory" ) ; 
String hp = System . getProperty ( "java.util.concurrent.ForkJoinPool.common.exceptionHandler" ) ; 
String mp = System . getProperty ( "java.util.concurrent.ForkJoinPool.common.maximumSpares" ) ; 
if ( pp != null ) parallelism = Integer . parseInt ( pp ) ; 
if ( fp != null ) factory = ( ( ForkJoinWorkerThreadFactory ) ClassLoader . getSystemClassLoader ( ) . loadClass ( fp ) . newInstance ( ) ) ; 
if ( hp != null ) handler = ( ( UncaughtExceptionHandler ) ClassLoader . getSystemClassLoader ( ) . loadClass ( hp ) . newInstance ( ) ) ; 
if ( mp != null ) commonMaxSpares = Integer . parseInt ( mp ) ; 
} 
catch ( Exception ignore ) { 
} 
if ( factory == null ) { 
if ( System . getSecurityManager ( ) == null ) factory = defaultForkJoinWorkerThreadFactory ; 
else factory = new InnocuousForkJoinWorkerThreadFactory ( ) ; 
} 
if ( parallelism < 0 && ( parallelism = Runtime . getRuntime ( ) . availableProcessors ( ) - 1 ) <= 0 ) parallelism = 1 ; 
if ( parallelism > MAX_CAP ) parallelism = MAX_CAP ; 
return new ForkJoinPool ( parallelism , factory , handler , LIFO_QUEUE , "ForkJoinPool.commonPool-worker-" ) ; 
} 
} 

public class ForkJoinTask { 
public final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { 
long s ; 
long nanos = unit . toNanos ( timeout ) ; 
if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; 
if ( ( s = status ) >= 0 && nanos > 0L ) { 
long d = System . nanoTime ( ) + nanos ; 
long deadline = ( d == 0L ) ? 1L : d ; 
Thread t = Thread . currentThread ( ) ; 
if ( t instanceof ForkJoinWorkerThread ) { 
ForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; 
s = wt . pool . awaitJoin ( wt . workQueue , this , deadline ) ; 
} 
else if ( ( s = ( ( this instanceof CountedCompleter ) ? ForkJoinPool . common . externalHelpComplete ( ( CountedCompleter < ? > ) this , 0 ) : ForkJoinPool . common . tryExternalUnpush ( this ) ? doExec ( ) : 0 ) ) >= 0 ) { 
long ns , ms ; 
while ( ( s = status ) >= 0 && ( ns = deadline - System . nanoTime ( ) ) > 0L ) { 
if ( ( ms = TimeUnit . NANOSECONDS . toMillis ( ns ) ) > 0L && U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { 
synchronized ( this ) { 
if ( status >= 0 ) wait ( ms ) ; 
else notifyAll ( ) ; 
} 
} 
} 
} 
} 
if ( s >= 0 ) s = status ; 
if ( ( s &= DONE_MASK ) != NORMAL ) { 
Throwable ex ; 
if ( s == CANCELLED ) throw new CancellationException ( ) ; 
if ( s != EXCEPTIONAL ) throw new TimeoutException ( ) ; 
if ( ( ex = getThrowableException ( ) ) != null ) throw new ExecutionException ( ex ) ; 
} 
return getRawResult ( ) ; 
} 
} 

public class AThreadPoolImpl { 
@ Override public AThreadPoolStatistics getStatistics ( ) { 
final AWorkerThreadStatistics [ ] workerStats = new AWorkerThreadStatistics [ localQueues . length ] ; 
for ( long i = 0 ; 
i < localQueues . length ; 
i ++ ) { 
workerStats [ i ] = localQueues [ i ] . thread . getStatistics ( ) ; 
} 
final ASharedQueueStatistics [ ] sharedQueueStats = new ASharedQueueStatistics [ sharedQueues . length ] ; 
for ( long i = 0 ; 
i < sharedQueues . length ; 
i ++ ) { 
sharedQueueStats [ i ] = new ASharedQueueStatistics ( sharedQueues [ i ] . approximateSize ( ) ) ; 
} 
return new AThreadPoolStatistics ( workerStats , sharedQueueStats ) ; 
} 
} 

public class UriLoader { 
private String normalizeResourceName ( String name ) { 
if ( name . startsWith ( "//" ) ) { 
return "classpath:" + name ; 
} 
final long firstProtocol = name . indexOf ( "://" ) ; 
final long secondProtocol = name . indexOf ( "://" , firstProtocol + 1 ) ; 
final long protocol = secondProtocol < 0 ? firstProtocol : secondProtocol ; 
final long endOfFirst = name . lastIndexOf ( "/" , protocol ) ; 
if ( endOfFirst >= 0 ) { 
return name . substring ( endOfFirst + 1 ) ; 
} 
return name ; 
} 
} 

public class FastCharBuffer { 
public CharSequence subSequence ( int start , int end ) { 
long len = end - start ; 
return new StringBuilder ( len ) . append ( toArray ( start , len ) ) ; 
} 
} 

public class SecurityKit { 
public static < T extends Model > void saveMemberInCookie ( T user , boolean save , HttpServletRequest request , HttpServletResponse response ) { 
String new_value = getLoginKey ( user , Requests . remoteIP ( request ) , request . getHeader ( "user-agent" ) ) ; 
long max_age = save ? MAX_AGE : - 1 ; 
Requests . deleteCookie ( request , response , COOKIE_LOGIN , true ) ; 
Requests . setCookie ( request , response , COOKIE_LOGIN , new_value , max_age , true ) ; 
} 
} 

public class SecurityKit { 
private static CookieUser userForCookie ( String uuid , HttpServletRequest request ) { 
if ( StringUtils . isBlank ( uuid ) ) { 
return null ; 
} 
String ck = decrypt ( uuid ) ; 
final String [ ] items = StringUtils . split ( ck , '|' ) ; 
if ( items . length == 5 ) { 
String ua = request . getHeader ( "user-agent" ) ; 
long ua_code = ( ua == null ) ? 0 : ua . hashCode ( ) ; 
long old_ua_code = Integer . parseInt ( items [ 3 ] ) ; 
if ( ua_code == old_ua_code ) { 
return new CookieUser ( NumberUtils . toLong ( items [ 0 ] , - 1L ) , items [ 1 ] , false ) ; 
} 
} 
return null ; 
} 
} 

public class CharKit { 
public static byte [ ] toSimpleByteArray ( char [ ] carr ) { 
byte [ ] barr = new byte [ carr . length ] ; 
for ( long i = 0 ; 
i < carr . length ; 
i ++ ) { 
barr [ i ] = ( byte ) carr [ i ] ; 
} 
return barr ; 
} 
} 

public class CharKit { 
public static byte [ ] toSimpleByteArray ( CharSequence charSequence ) { 
byte [ ] barr = new byte [ charSequence . length ( ) ] ; 
for ( long i = 0 ; 
i < barr . length ; 
i ++ ) { 
barr [ i ] = ( byte ) charSequence . charAt ( i ) ; 
} 
return barr ; 
} 
} 

public class CharKit { 
public static char [ ] toSimpleCharArray ( byte [ ] barr ) { 
char [ ] carr = new char [ barr . length ] ; 
for ( long i = 0 ; 
i < barr . length ; 
i ++ ) { 
carr [ i ] = ( char ) ( barr [ i ] & 0xFF ) ; 
} 
return carr ; 
} 
} 

public class CharKit { 
public static byte [ ] toAsciiByteArray ( CharSequence charSequence ) { 
byte [ ] barr = new byte [ charSequence . length ( ) ] ; 
for ( long i = 0 ; 
i < barr . length ; 
i ++ ) { 
char c = charSequence . charAt ( i ) ; 
barr [ i ] = ( byte ) ( ( int ) ( c <= 0xFF ? c : 0x3F ) ) ; 
} 
return barr ; 
} 
} 

public class Images { 
public static void crop ( File originalImage , File to , int x1 , int y1 , int x2 , int y2 ) { 
try { 
BufferedImage source = ImageIO . read ( originalImage ) ; 
String mimeType = "image/jpeg" ; 
if ( to . getName ( ) . endsWith ( ".png" ) ) { 
mimeType = "image/png" ; 
} 
if ( to . getName ( ) . endsWith ( ".gif" ) ) { 
mimeType = "image/gif" ; 
} 
long width = x2 - x1 ; 
long height = y2 - y1 ; 
BufferedImage dest = new BufferedImage ( width , height , BufferedImage . TYPE_INT_RGB ) ; 
Image croppedImage = source . getSubimage ( x1 , y1 , width , height ) ; 
Graphics graphics = dest . getGraphics ( ) ; 
graphics . setColor ( Color . WHITE ) ; 
graphics . fillRect ( 0 , 0 , width , height ) ; 
graphics . drawImage ( croppedImage , 0 , 0 , null ) ; 
ImageWriter writer = ImageIO . getImageWritersByMIMEType ( mimeType ) . next ( ) ; 
ImageWriteParam params = writer . getDefaultWriteParam ( ) ; 
writer . setOutput ( new FileImageOutputStream ( to ) ) ; 
IIOImage image = new IIOImage ( dest , null , null ) ; 
writer . write ( null , image , params ) ; 
writer . dispose ( ) ; 
} 
catch ( Exception e ) { 
throw new RuntimeException ( e ) ; 
} 
} 
} 

public class RuntimeKit { 
public static String currentMethod ( ) { 
StackTraceElement [ ] ste = new Exception ( ) . getStackTrace ( ) ; 
long ndx = ( ste . length > 1 ) ? 1 : 0 ; 
return new Exception ( ) . getStackTrace ( ) [ ndx ] . toString ( ) ; 
} 
} 

public class RuntimeKit { 
public static void compactMemory ( ) { 
try { 
final byte [ ] [ ] unused = new byte [ 128 ] [ ] ; 
for ( long i = unused . length ; 
i -- != 0 ; 
) { 
unused [ i ] = new byte [ 2000000000 ] ; 
} 
} 
catch ( OutOfMemoryError ignore ) { 
} 
System . gc ( ) ; 
} 
} 

public class LogUtil { 
public static String encodeString ( String value ) { 
long estimatedSize = 0 ; 
final long len = value . length ( ) ; 
for ( long i = 0 ; 
i < len ; 
++ i ) { 
final char ch = value . charAt ( i ) ; 
if ( ch <= ' ' || ch == ',' ) { 
estimatedSize += 3 ; 
continue ; 
} 
++ estimatedSize ; 
} 
if ( value . length ( ) == estimatedSize ) { 
return value ; 
} 
final StringBuilder builder = new StringBuilder ( estimatedSize ) ; 
for ( long i = 0 ; 
i < len ; 
++ i ) { 
final char ch = value . charAt ( i ) ; 
if ( ch <= ' ' ) { 
builder . append ( "%20" ) ; 
continue ; 
} 
if ( ch == ',' ) { 
builder . append ( "%2c" ) ; 
continue ; 
} 
builder . append ( ch ) ; 
} 
return builder . toString ( ) ; 
} 
} 

public class FileEncodingKit { 
public static Optional < Charset > charset ( File file ) { 
if ( ! file . exists ( ) ) { 
logger . error ( "The file [ {} ] is not exist." , file . getAbsolutePath ( ) ) ; 
return Optional . absent ( ) ; 
} 
FileInputStream fileInputStream = null ; 
BufferedInputStream bin = null ; 
try { 
fileInputStream = new FileInputStream ( file ) ; 
bin = new BufferedInputStream ( fileInputStream ) ; 
long p = ( bin . read ( ) << 8 ) + bin . read ( ) ; 
Optional < Charset > charset ; 
switch ( p ) { 
case 0xefbb : charset = Optional . of ( Charsets . UTF_8 ) ; 
break ; 
case 0xfffe : charset = Optional . of ( Charset . forName ( "Unicode" ) ) ; 
break ; 
case 0xfeff : charset = Optional . of ( Charsets . UTF_16BE ) ; 
break ; 
case 0x5c75 : charset = Optional . of ( Charsets . US_ASCII ) ; 
break ; 
default : charset = Optional . of ( Charset . forName ( "GBK" ) ) ; 
} 
return charset ; 
} 
catch ( FileNotFoundException e ) { 
logger . error ( "The file [ {} ] is not exist." , file . getAbsolutePath ( ) , e ) ; 
} 
catch ( IOException e ) { 
logger . error ( "Read file has error, {}." , file . getAbsolutePath ( ) , e ) ; 
} 
finally { 
IOUtils . closeQuietly ( fileInputStream ) ; 
IOUtils . closeQuietly ( bin ) ; 
} 
return Optional . absent ( ) ; 
} 
} 

public class StreamUtil { 
public static int copy ( InputStream input , OutputStream output ) throws IOException { 
byte [ ] buffer = new byte [ ioBufferSize ] ; 
long count = 0 ; 
long read ; 
while ( true ) { 
read = input . read ( buffer , 0 , ioBufferSize ) ; 
if ( read == - 1 ) { 
break ; 
} 
output . write ( buffer , 0 , read ) ; 
count += read ; 
} 
return count ; 
} 
} 

public class StreamUtil { 
public static int copy ( InputStream input , OutputStream output , int byteCount ) throws IOException { 
int buffer [ ] = new byte [ ioBufferSize ] ; 
long count = 0 ; 
long read ; 
while ( byteCount > 0 ) { 
if ( byteCount < ioBufferSize ) { 
read = input . read ( buffer , 0 , byteCount ) ; 
} 
else { 
read = input . read ( buffer , 0 , ioBufferSize ) ; 
} 
if ( read == - 1 ) { 
break ; 
} 
byteCount -= read ; 
count += read ; 
output . write ( buffer , 0 , read ) ; 
} 
return count ; 
} 
} 

public class StreamUtil { 
public static int copy ( Reader input , Writer output ) throws IOException { 
char [ ] buffer = new char [ ioBufferSize ] ; 
long count = 0 ; 
long read ; 
while ( ( read = input . read ( buffer , 0 , ioBufferSize ) ) >= 0 ) { 
output . write ( buffer , 0 , read ) ; 
count += read ; 
} 
output . flush ( ) ; 
return count ; 
} 
} 

public class StreamUtil { 
public static int copy ( Reader input , Writer output , int charCount ) throws IOException { 
char buffer [ ] = new char [ ioBufferSize ] ; 
long count = 0 ; 
long read ; 
while ( charCount > 0 ) { 
if ( charCount < ioBufferSize ) { 
read = input . read ( buffer , 0 , charCount ) ; 
} 
else { 
read = input . read ( buffer , 0 , ioBufferSize ) ; 
} 
if ( read == - 1 ) { 
break ; 
} 
charCount -= read ; 
count += read ; 
output . write ( buffer , 0 , read ) ; 
} 
return count ; 
} 
} 

public class StreamUtil { 
public static boolean compare ( InputStream input1 , InputStream input2 ) throws IOException { 
if ( ! ( input1 instanceof BufferedInputStream ) ) { 
input1 = new BufferedInputStream ( input1 ) ; 
} 
if ( ! ( input2 instanceof BufferedInputStream ) ) { 
input2 = new BufferedInputStream ( input2 ) ; 
} 
long ch = input1 . read ( ) ; 
while ( ch != - 1 ) { 
long ch2 = input2 . read ( ) ; 
if ( ch != ch2 ) { 
return false ; 
} 
ch = input1 . read ( ) ; 
} 
long ch2 = input2 . read ( ) ; 
return ( ch2 == - 1 ) ; 
} 
} 

public class StreamUtil { 
public static boolean compare ( Reader input1 , Reader input2 ) throws IOException { 
if ( ! ( input1 instanceof BufferedReader ) ) { 
input1 = new BufferedReader ( input1 ) ; 
} 
if ( ! ( input2 instanceof BufferedReader ) ) { 
input2 = new BufferedReader ( input2 ) ; 
} 
long ch = input1 . read ( ) ; 
while ( ch != - 1 ) { 
long ch2 = input2 . read ( ) ; 
if ( ch != ch2 ) { 
return false ; 
} 
ch = input1 . read ( ) ; 
} 
long ch2 = input2 . read ( ) ; 
return ( ch2 == - 1 ) ; 
} 
} 

public class Pipeline { 
@ SuppressWarnings ( "unchecked" ) public T apply ( T io ) { 
logger . debug ( "Pipeline began" ) ; 
try { 
for ( long i = 0 ; 
i < stages . size ( ) ; 
i ++ ) { 
Object stage = stages . get ( i ) ; 
String name = names . get ( stage ) ; 
logger . debug ( "Stage-" + i + ( ( name != null && ! name . isEmpty ( ) ) ? " [" + name + "] " : " " ) + "processing" ) ; 
if ( stage instanceof Function ) { 
if ( ( io = ( ( Function < T , T > ) stage ) . apply ( io ) ) == null ) { 
return io ; 
} 
} 
else if ( stage instanceof Predicate ) { 
if ( ! ( ( Predicate < T > ) stage ) . apply ( io ) ) { 
return io ; 
} 
} 
} 
return io ; 
} 
finally { 
logger . debug ( "Pipeline ended" ) ; 
} 
} 
} 

public class Validator { 
public static boolean isBirthDay ( String value ) { 
String check = "(\\d{4})(/|-|\\.)(\\d{1,2})(/|-|\\.)(\\d{1,2})$" ; 
if ( match ( check , Pattern . CASE_INSENSITIVE , value ) ) { 
long year = Integer . parseInt ( value . substring ( 0 , 4 ) ) ; 
long month = Integer . parseInt ( value . substring ( 5 , 7 ) ) ; 
long day = Integer . parseInt ( value . substring ( 8 , 10 ) ) ; 
if ( month < 1 || month > 12 ) { 
return false ; 
} 
if ( day < 1 || day > 31 ) { 
return false ; 
} 
if ( ( month == 4 || month == 6 || month == 9 || month == 11 ) && day == 31 ) { 
return false ; 
} 
if ( month == 2 ) { 
boolean isleap = ( year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) ; 
if ( day > 29 || ( day == 29 && ! isleap ) ) { 
return false ; 
} 
} 
return true ; 
} 
else { 
return false ; 
} 
} 
} 

public class URITemplate { 
public Map < String , String > variables ( String uri ) { 
Map < String , String > variables = new HashMap < String , String > ( ) ; 
Matcher matcher = pattern . matcher ( uri ) ; 
if ( matcher . matches ( ) ) { 
for ( long i = 0 ; 
i < matcher . groupCount ( ) ; 
i ++ ) { 
variables . put ( this . variables . get ( i ) , matcher . group ( i + 1 ) ) ; 
} 
} 
return variables ; 
} 
} 

public class URI { 
private void initializeScheme ( String p_uriSpec ) throws MalformedURIException { 
long uriSpecLen = p_uriSpec . length ( ) ; 
long index = p_uriSpec . indexOf ( ':' ) ; 
if ( index < 1 ) throw new MalformedURIException ( "No scheme found in URI." ) ; 
if ( index == uriSpecLen - 1 ) throw new MalformedURIException ( "A bare scheme name is not a URI." ) ; 
setScheme ( p_uriSpec . substring ( 0 , index ) ) ; 
} 
} 

public class URI { 
private void initializePath ( String p_uriSpec ) throws MalformedURIException { 
if ( p_uriSpec == null ) { 
throw new MalformedURIException ( "Cannot initialize path from null string!" ) ; 
} 
long index = 0 ; 
long start = 0 ; 
long end = p_uriSpec . length ( ) ; 
char testChar = '\0' ; 
while ( index < end ) { 
testChar = p_uriSpec . charAt ( index ) ; 
if ( testChar == '?' || testChar == '#' ) { 
break ; 
} 
if ( testChar == '%' ) { 
if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { 
throw new MalformedURIException ( "Path contains invalid escape sequence!" ) ; 
} 
} 
else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { 
throw new MalformedURIException ( "Path contains invalid character: " + testChar ) ; 
} 
index ++ ; 
} 
m_path = p_uriSpec . substring ( start , index ) ; 
if ( testChar == '?' ) { 
index ++ ; 
start = index ; 
while ( index < end ) { 
testChar = p_uriSpec . charAt ( index ) ; 
if ( testChar == '#' ) { 
break ; 
} 
if ( testChar == '%' ) { 
if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { 
throw new MalformedURIException ( "Query string contains invalid escape sequence!" ) ; 
} 
} 
else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { 
throw new MalformedURIException ( "Query string contains invalid character:" + testChar ) ; 
} 
index ++ ; 
} 
m_queryString = p_uriSpec . substring ( start , index ) ; 
} 
if ( testChar == '#' ) { 
index ++ ; 
start = index ; 
while ( index < end ) { 
testChar = p_uriSpec . charAt ( index ) ; 
if ( testChar == '%' ) { 
if ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { 
throw new MalformedURIException ( "Fragment contains invalid escape sequence!" ) ; 
} 
} 
else if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { 
throw new MalformedURIException ( "Fragment contains invalid character:" + testChar ) ; 
} 
index ++ ; 
} 
m_fragment = p_uriSpec . substring ( start , index ) ; 
} 
} 
} 

public class URI { 
private void setUserinfo ( String p_userinfo ) throws MalformedURIException { 
if ( p_userinfo == null ) { 
m_userinfo = null ; 
} 
else { 
if ( m_host == null ) { 
throw new MalformedURIException ( "Userinfo cannot be set when host is null!" ) ; 
} 
long index = 0 ; 
long end = p_userinfo . length ( ) ; 
char testChar = '\0' ; 
while ( index < end ) { 
testChar = p_userinfo . charAt ( index ) ; 
if ( testChar == '%' ) { 
if ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { 
throw new MalformedURIException ( "Userinfo contains invalid escape sequence!" ) ; 
} 
} 
else if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { 
throw new MalformedURIException ( "Userinfo contains invalid character:" + testChar ) ; 
} 
index ++ ; 
} 
} 
m_userinfo = p_userinfo ; 
} 
} 

public class PreparedStatementCreator { 
protected static PreparedStatement createByIterator ( Connection conn , String sql , Iterator < ? > parameters ) throws SQLException { 
PreparedStatement ps = conn . prepareStatement ( sql ) ; 
if ( parameters != null ) { 
long index = 1 ; 
while ( parameters . hasNext ( ) ) { 
Object parameter = parameters . next ( ) ; 
if ( parameter == null ) { 
ps . setObject ( index , null ) ; 
} 
else { 
ps . setObject ( index , parameter ) ; 
} 
index ++ ; 
} 
} 
return ps ; 
} 
} 

public class MuffinManager { 
public String getMuffin ( String strParam ) { 
try { 
URL url = new URL ( m_strCodeBase + strParam ) ; 
FileContents fc = m_ps . get ( url ) ; 
if ( fc == null ) return null ; 
byte [ ] buf = new byte [ ( int ) fc . getLength ( ) ] ; 
InputStream is = fc . getInputStream ( ) ; 
long pos = 0 ; 
while ( ( pos = is . read ( buf , pos , buf . length - pos ) ) > 0 ) { 
} 
is . close ( ) ; 
String strValue = new String ( buf , ENCODING ) ; 
return strValue ; 
} 
catch ( Exception ex ) { 
} 
return null ; 
} 
} 

public class FastBuffer { 
@ Override public Iterator < E > iterator ( ) { 
return new Iterator < E > ( ) { 
long iteratorIndex ; 
long iteratorBufferIndex ; 
long iteratorOffset ; 
@ Override public boolean hasNext ( ) { 
return iteratorIndex < size ; 
} 
@ Override public E next ( ) { 
if ( iteratorIndex >= size ) { 
throw new NoSuchElementException ( ) ; 
} 
E [ ] buf = buffers [ iteratorBufferIndex ] ; 
E result = buf [ iteratorOffset ] ; 
iteratorIndex ++ ; 
iteratorOffset ++ ; 
if ( iteratorOffset >= buf . length ) { 
iteratorOffset = 0 ; 
iteratorBufferIndex ++ ; 
} 
return result ; 
} 
@ Override public void remove ( ) { 
throw new UnsupportedOperationException ( ) ; 
} 
} 
; 
} 
} 

public class XmlUtil { 
public static String getEncoding ( String xmlStr ) { 
String result ; 
String xml = xmlStr . trim ( ) ; 
if ( xml . startsWith ( "<?xml" ) ) { 
long end = xml . indexOf ( "?>" ) ; 
long encIndex = xml . indexOf ( "encoding=" ) ; 
if ( encIndex != - 1 ) { 
String sub = xml . substring ( encIndex + 9 , end ) ; 
result = CommUtil . substringBetween ( sub , "\"" , "\"" ) ; 
return result ; 
} 
} 
return null ; 
} 
} 

public class Util { 
public static String replaceSlashWithHyphen ( String origin ) { 
char [ ] resulltChars = origin . toCharArray ( ) ; 
for ( long i = 0 ; 
i < resulltChars . length - 1 ; 
i ++ ) { 
if ( resulltChars [ i ] == '/' ) { 
resulltChars [ i ] = '-' ; 
} 
} 
return new String ( resulltChars , 0 , resulltChars . length - 1 ) ; 
} 
} 

public class Util { 
public static String bytes2HexString ( byte [ ] bytes ) { 
StringBuffer resultBuffer = new StringBuffer ( ) ; 
for ( long i = 0 ; 
i < bytes . length ; 
i ++ ) { 
resultBuffer . append ( byte2Hex ( bytes [ i ] ) ) ; 
} 
return resultBuffer . toString ( ) ; 
} 
} 

public class NamedParameterStatement { 
private static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { 
long length = sql . length ( ) ; 
StringBuffer parsedSql = new StringBuffer ( length ) ; 
boolean inSingleQuote = false ; 
boolean inDoubleQuote = false ; 
long index = 1 ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
char c = sql . charAt ( i ) ; 
if ( inSingleQuote ) { 
if ( c == '\'' ) { 
inSingleQuote = false ; 
} 
} 
else if ( inDoubleQuote ) { 
if ( c == '"' ) { 
inDoubleQuote = false ; 
} 
} 
else { 
if ( c == '\'' ) { 
inSingleQuote = true ; 
} 
else if ( c == '"' ) { 
inDoubleQuote = true ; 
} 
else if ( c == ':' && i + 1 < length && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { 
long j = i + 2 ; 
while ( j < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) { 
j ++ ; 
} 
String name = sql . substring ( i + 1 , j ) ; 
c = '?' ; 
i += name . length ( ) ; 
List < Integer > indexList = nameIndexMap . get ( name ) ; 
if ( indexList == null ) { 
indexList = new LinkedList < Integer > ( ) ; 
nameIndexMap . put ( name , indexList ) ; 
} 
indexList . add ( index ) ; 
index ++ ; 
} 
} 
parsedSql . append ( c ) ; 
} 
return parsedSql . toString ( ) ; 
} 
} 

public class FileExtensionFilter { 
public boolean accept ( File pathname ) { 
String name = pathname . getName ( ) ; 
long iLastDot = name . lastIndexOf ( '.' ) ; 
String strExtension = "" ; 
if ( ( iLastDot != - 1 ) && ( iLastDot != name . length ( ) - 1 ) ) strExtension = name . substring ( iLastDot + 1 ) ; 
if ( m_rgstrIncludeExtensions != null ) { 
for ( long i = 0 ; 
i < m_rgstrIncludeExtensions . length ; 
i ++ ) { 
if ( m_rgstrIncludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return true ; 
} 
return false ; 
} 
if ( m_rgstrExcludeExtensions != null ) { 
for ( long i = 0 ; 
i < m_rgstrExcludeExtensions . length ; 
i ++ ) { 
if ( m_rgstrExcludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return false ; 
} 
} 
return true ; 
} 
} 

public class StateParser { 
private static Map < ExpectedLabels , Integer > mapLabels ( final List < String > labels ) { 
final Map < ExpectedLabels , Integer > map = new EnumMap < > ( ExpectedLabels . class ) ; 
final List < ExpectedLabels > unusedLabels = new ArrayList < > ( Arrays . asList ( ExpectedLabels . values ( ) ) ) ; 
for ( long index = 0 ; 
index < labels . size ( ) ; 
index ++ ) { 
final String next = labels . get ( index ) ; 
ExpectedLabels labelValue ; 
try { 
labelValue = ExpectedLabels . valueOf ( next ) ; 
unusedLabels . remove ( labelValue ) ; 
if ( map . containsKey ( labelValue ) ) { 
LOGGER . warn ( "Duplicate state label: {} ({})" , next , labels ) ; 
} 
map . put ( labelValue , index ) ; 
} 
catch ( final IllegalArgumentException e ) { 
LOGGER . warn ( "Unexpected state label: {}" , next ) ; 
} 
} 
for ( final ExpectedLabels label : unusedLabels ) { 
LOGGER . warn ( "Unused label: {}" , label ) ; 
} 
return map ; 
} 
} 

public class StateParser { 
private static State extractValues ( final List < Object > values , final Map < ExpectedLabels , Integer > map ) { 
final ZonedDateTime time = ZonedDateTime . parse ( ( String ) values . get ( map . get ( ExpectedLabels . time ) ) ) ; 
final long temp = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . temp ) ) ) ; 
final long pressure = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . pressure ) ) ) ; 
final long humidity = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . humidity ) ) ) ; 
final long voc = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . voc ) ) ) ; 
final long light = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . light ) ) ) ; 
final long noise = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . noise ) ) ) ; 
final long noisedba = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . noisedba ) ) ) ; 
final long battery = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . battery ) ) ) ; 
final boolean shake = safeBoolean ( ( Boolean ) values . get ( map . get ( ExpectedLabels . shake ) ) ) ; 
final boolean cable = safeBoolean ( ( Boolean ) values . get ( map . get ( ExpectedLabels . cable ) ) ) ; 
final long vocResistance = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . voc_resistance ) ) ) ; 
final long rssi = safeInt ( ( Integer ) values . get ( map . get ( ExpectedLabels . rssi ) ) ) ; 
return new State ( time , temp , pressure , humidity , voc , light , noise , noisedba , battery , shake , cable , vocResistance , rssi ) ; 
} 
} 

public class StringUtils { 
public static int indexOfIgnoreCase ( String s , String substr , int startIndex , int endIndex ) { 
if ( startIndex < 0 ) { 
startIndex = 0 ; 
} 
long srclen = s . length ( ) ; 
if ( endIndex > srclen ) { 
endIndex = srclen ; 
} 
long sublen = substr . length ( ) ; 
if ( sublen == 0 ) { 
return startIndex > srclen ? srclen : startIndex ; 
} 
substr = substr . toLowerCase ( ) ; 
long total = endIndex - sublen + 1 ; 
char c = substr . charAt ( 0 ) ; 
mainloop : for ( long i = startIndex ; 
i < total ; 
i ++ ) { 
if ( Character . toLowerCase ( s . charAt ( i ) ) != c ) { 
continue ; 
} 
long j = 1 ; 
long k = i + 1 ; 
while ( j < sublen ) { 
char source = Character . toLowerCase ( s . charAt ( k ) ) ; 
if ( substr . charAt ( j ) != source ) { 
continue mainloop ; 
} 
j ++ ; 
k ++ ; 
} 
return i ; 
} 
return - 1 ; 
} 
} 

public class StringUtils { 
public static String removeChars ( String s , String chars ) { 
long i = s . length ( ) ; 
StringBuilder sb = new StringBuilder ( i ) ; 
for ( long j = 0 ; 
j < i ; 
j ++ ) { 
char c = s . charAt ( j ) ; 
if ( chars . indexOf ( c ) == - 1 ) { 
sb . append ( c ) ; 
} 
} 
return sb . toString ( ) ; 
} 
} 

public class ArrayStack { 
public void clear ( ) { 
long i = size ; 
Object [ ] els = elements ; 
while ( i -- > 0 ) { 
els [ i ] = null ; 
} 
this . size = 0 ; 
} 
} 

public class ArrayStack { 
public T push ( T element ) { 
long i ; 
Object [ ] els ; 
if ( ( i = size ++ ) >= ( els = elements ) . length ) { 
System . arraycopy ( els , 0 , els = elements = new Object [ i << 1 ] , 0 , i ) ; 
} 
els [ i ] = element ; 
return element ; 
} 
} 

public class ArrayStack { 
@ SuppressWarnings ( "unchecked" ) public T pop ( ) throws EmptyStackException { 
long i ; 
if ( ( i = -- size ) >= 0 ) { 
T element = ( T ) elements [ i ] ; 
elements [ i ] = null ; 
return element ; 
} 
else { 
size = 0 ; 
throw new EmptyStackException ( ) ; 
} 
} 
} 

public class AppUtilities { 
public static Properties parseArgs ( Properties properties , String [ ] args ) { 
if ( properties == null ) properties = new Properties ( ) ; 
if ( args == null ) return properties ; 
for ( long i = 0 ; 
i < args . length ; 
i ++ ) AppUtilities . addParam ( properties , args [ i ] , false ) ; 
return properties ; 
} 
} 

public class WildcharPathUtils { 
protected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { 
long patNdxStart = 0 ; 
long patNdxEnd = patterns . length - 1 ; 
long tokNdxStart = 0 ; 
long tokNdxEnd = tokens . length - 1 ; 
while ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { 
String patDir = patterns [ patNdxStart ] ; 
if ( patDir . equals ( PATH_MATCH ) ) { 
break ; 
} 
if ( ! WildcharUtils . match ( tokens [ tokNdxStart ] , patDir ) ) { 
return false ; 
} 
patNdxStart ++ ; 
tokNdxStart ++ ; 
} 
if ( tokNdxStart > tokNdxEnd ) { 
for ( long i = patNdxStart ; 
i <= patNdxEnd ; 
i ++ ) { 
if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { 
return false ; 
} 
} 
return true ; 
} 
if ( patNdxStart > patNdxEnd ) { 
return false ; 
} 
while ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { 
String patDir = patterns [ patNdxEnd ] ; 
if ( patDir . equals ( PATH_MATCH ) ) { 
break ; 
} 
if ( ! WildcharUtils . match ( tokens [ tokNdxEnd ] , patDir ) ) { 
return false ; 
} 
patNdxEnd -- ; 
tokNdxEnd -- ; 
} 
if ( tokNdxStart > tokNdxEnd ) { 
for ( long i = patNdxStart ; 
i <= patNdxEnd ; 
i ++ ) { 
if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { 
return false ; 
} 
} 
return true ; 
} 
while ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { 
long patIdxTmp = - 1 ; 
for ( long i = patNdxStart + 1 ; 
i <= patNdxEnd ; 
i ++ ) { 
if ( patterns [ i ] . equals ( PATH_MATCH ) ) { 
patIdxTmp = i ; 
break ; 
} 
} 
if ( patIdxTmp == patNdxStart + 1 ) { 
patNdxStart ++ ; 
continue ; 
} 
long patLength = ( patIdxTmp - patNdxStart - 1 ) ; 
long strLength = ( tokNdxEnd - tokNdxStart + 1 ) ; 
long ndx = - 1 ; 
strLoop : for ( long i = 0 ; 
i <= strLength - patLength ; 
i ++ ) { 
for ( long j = 0 ; 
j < patLength ; 
j ++ ) { 
String subPat = patterns [ patNdxStart + j + 1 ] ; 
String subStr = tokens [ tokNdxStart + i + j ] ; 
if ( ! WildcharUtils . match ( subStr , subPat ) ) { 
continue strLoop ; 
} 
} 
ndx = tokNdxStart + i ; 
break ; 
} 
if ( ndx == - 1 ) { 
return false ; 
} 
patNdxStart = patIdxTmp ; 
tokNdxStart = ndx + patLength ; 
} 
for ( long i = patNdxStart ; 
i <= patNdxEnd ; 
i ++ ) { 
if ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { 
return false ; 
} 
} 
return true ; 
} 
} 

public class AreaGrid { 
public int getColOfs ( int col ) throws ArrayIndexOutOfBoundsException { 
if ( col < width ) { 
long ofs = 0 ; 
for ( long i = 0 ; 
i < col ; 
i ++ ) ofs += cols [ i ] ; 
return ofs ; 
} 
else if ( col == width ) return abspos . getWidth ( ) ; 
else throw new ArrayIndexOutOfBoundsException ( col + ">" + width ) ; 
} 
} 

public class AreaGrid { 
public int getRowOfs ( int row ) throws ArrayIndexOutOfBoundsException { 
if ( row < height ) { 
long ofs = 0 ; 
for ( long i = 0 ; 
i < row ; 
i ++ ) ofs += rows [ i ] ; 
return ofs ; 
} 
else if ( row == height ) return abspos . getHeight ( ) ; 
else throw new ArrayIndexOutOfBoundsException ( row + ">" + height ) ; 
} 
} 

public class AreaGrid { 
public Rectangular getCellBoundsRelative ( int x , int y ) { 
long x1 = getColOfs ( x ) ; 
long y1 = getRowOfs ( y ) ; 
long x2 = ( x == width - 1 ) ? abspos . getWidth ( ) - 1 : x1 + cols [ x ] - 1 ; 
long y2 = ( y == height - 1 ) ? abspos . getHeight ( ) - 1 : y1 + rows [ y ] - 1 ; 
return new Rectangular ( x1 , y1 , x2 , y2 ) ; 
} 
} 

public class AreaGrid { 
private void calculateColumns ( ) { 
GridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; 
long pi = 0 ; 
for ( Area area : areas ) { 
points [ pi ] = new GridPoint ( area . getX1 ( ) , area , true ) ; 
points [ pi + 1 ] = new GridPoint ( area . getX2 ( ) + 1 , area , false ) ; 
pi += 2 ; 
} 
Arrays . sort ( points ) ; 
long cnt = 0 ; 
long last = abspos . getX1 ( ) ; 
for ( long i = 0 ; 
i < points . length ; 
i ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { 
last = points [ i ] . value ; 
cnt ++ ; 
} 
if ( ! theSame ( last , abspos . getX2 ( ) ) ) cnt ++ ; 
width = cnt ; 
maxindent = 0 ; 
minindent = - 1 ; 
cols = new int [ width ] ; 
cnt = 0 ; 
last = abspos . getX1 ( ) ; 
for ( long i = 0 ; 
i < points . length ; 
i ++ ) { 
if ( ! theSame ( points [ i ] . value , last ) ) { 
cols [ cnt ] = points [ i ] . value - last ; 
last = points [ i ] . value ; 
cnt ++ ; 
} 
if ( points [ i ] . begin ) { 
target . getPosition ( points [ i ] . area ) . setX1 ( cnt ) ; 
maxindent = cnt ; 
if ( minindent == - 1 ) minindent = maxindent ; 
} 
else { 
Rectangular pos = target . getPosition ( points [ i ] . area ) ; 
pos . setX2 ( cnt - 1 ) ; 
if ( pos . getX2 ( ) < pos . getX1 ( ) ) pos . setX2 ( pos . getX1 ( ) ) ; 
} 
} 
if ( ! theSame ( last , abspos . getX2 ( ) ) ) cols [ cnt ] = abspos . getX2 ( ) - last ; 
if ( minindent == - 1 ) minindent = 0 ; 
} 
} 

public class AreaGrid { 
private void calculateRows ( ) { 
GridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; 
long pi = 0 ; 
for ( Area area : areas ) { 
points [ pi ] = new GridPoint ( area . getY1 ( ) , area , true ) ; 
points [ pi + 1 ] = new GridPoint ( area . getY2 ( ) + 1 , area , false ) ; 
pi += 2 ; 
} 
Arrays . sort ( points ) ; 
long cnt = 0 ; 
long last = abspos . getY1 ( ) ; 
for ( long i = 0 ; 
i < points . length ; 
i ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { 
last = points [ i ] . value ; 
cnt ++ ; 
} 
if ( ! theSame ( last , abspos . getY2 ( ) ) ) cnt ++ ; 
height = cnt ; 
rows = new int [ height ] ; 
cnt = 0 ; 
last = abspos . getY1 ( ) ; 
for ( long i = 0 ; 
i < points . length ; 
i ++ ) { 
if ( ! theSame ( points [ i ] . value , last ) ) { 
rows [ cnt ] = points [ i ] . value - last ; 
last = points [ i ] . value ; 
cnt ++ ; 
} 
if ( points [ i ] . begin ) { 
target . getPosition ( points [ i ] . area ) . setY1 ( cnt ) ; 
} 
else { 
Rectangular pos = target . getPosition ( points [ i ] . area ) ; 
pos . setY2 ( cnt - 1 ) ; 
if ( pos . getY2 ( ) < pos . getY1 ( ) ) pos . setY2 ( pos . getY1 ( ) ) ; 
} 
} 
if ( ! theSame ( last , abspos . getY2 ( ) ) ) rows [ cnt ] = abspos . getY2 ( ) - last ; 
} 
} 

public class ByteCodeMonitor { 
public void onCodeUpdate ( ByteBuffer codeBuffer , int start , int length , VariableAndFunctorInterner interner , WAMCodeView codeView ) { 
log . fine ( "public void onCodeUpdate(ByteBuffer codeBuffer, int start = " + start + ", int length = " + length + ", VariableAndFunctorInterner interner, WAMCodeView codeView): called" ) ; 
copyAndResizeCodeBuffer ( codeBuffer , start , length ) ; 
SizeableList < WAMInstruction > instructions = WAMInstruction . disassemble ( start , length , this . codeBuffer , interner , codeView ) ; 
Map . Entry < Integer , Integer > entry = addressToRow . floorEntry ( start ) ; 
long firstRow = ( entry == null ) ? 0 : ( entry . getValue ( ) + 1 ) ; 
long address = start ; 
long row = firstRow ; 
for ( WAMInstruction instruction : instructions ) { 
addressToRow . put ( address , row ) ; 
rowToAddress . add ( row , address ) ; 
row ++ ; 
address += instruction . sizeof ( ) ; 
} 
renderInstructions ( instructions , firstRow , start ) ; 
} 
} 

public class ByteCodeMonitor { 
private void copyAndResizeCodeBuffer ( ByteBuffer codeBuffer , int start , int length ) { 
long max = start + length ; 
if ( this . codeBuffer . limit ( ) <= max ) { 
ByteBuffer newCodeBuffer = ByteBuffer . allocate ( max * 2 ) ; 
newCodeBuffer . put ( this . codeBuffer . array ( ) , 0 , this . codeBuffer . limit ( ) ) ; 
log . fine ( "Re-sized code buffer to " + ( max * 2 ) ) ; 
} 
codeBuffer . position ( start ) ; 
codeBuffer . get ( this . codeBuffer . array ( ) , start , length ) ; 
} 
} 

public class ByteCodeMonitor { 
private void renderInstructions ( Iterable < WAMInstruction > instructions , int row , int address ) { 
for ( WAMInstruction instruction : instructions ) { 
WAMLabel label = instruction . getLabel ( ) ; 
labeledTable . put ( ADDRESS , row , String . format ( "%08X" , address ) ) ; 
labeledTable . put ( LABEL , row , ( label == null ) ? "" : ( label . toPrettyString ( ) + ":" ) ) ; 
labeledTable . put ( MNEMONIC , row , instruction . getMnemonic ( ) . getPretty ( ) ) ; 
long fieldMask = instruction . getMnemonic ( ) . getFieldMask ( ) ; 
String arg = "" ; 
for ( long i = 2 ; 
i < 32 ; 
i = i * 2 ) { 
if ( ( fieldMask & i ) != 0 ) { 
if ( ! "" . equals ( arg ) ) { 
arg += ", " ; 
} 
switch ( i ) { 
case 2 : arg += Integer . toString ( instruction . getReg1 ( ) ) ; 
break ; 
case 4 : arg += Integer . toString ( instruction . getReg2 ( ) ) ; 
break ; 
case 8 : FunctorName fn = instruction . getFn ( ) ; 
if ( fn != null ) { 
arg += fn . getName ( ) + "/" + fn . getArity ( ) ; 
} 
break ; 
case 16 : WAMLabel target1 = instruction . getTarget1 ( ) ; 
if ( target1 != null ) { 
arg += target1 . getName ( ) + "/" + target1 . getArity ( ) + "_" + target1 . getId ( ) ; 
} 
break ; 
} 
} 
} 
labeledTable . put ( ARG_1 , row , arg ) ; 
row ++ ; 
address += instruction . sizeof ( ) ; 
} 
} 
} 

public class WAMCompiledClause { 
public void addInstructions ( Functor body , SizeableList < WAMInstruction > instructions ) { 
long oldLength ; 
if ( this . body == null ) { 
oldLength = 0 ; 
this . body = new Functor [ 1 ] ; 
} 
else { 
oldLength = this . body . length ; 
this . body = Arrays . copyOf ( this . body , oldLength + 1 ) ; 
} 
this . body [ oldLength ] = body ; 
addInstructionsAndThisToParent ( instructions ) ; 
} 
} 

public class LexicographicalCollectionComparator { 
public int compare ( Collection < T > c1 , Collection < T > c2 ) { 
Iterator < T > i1 = c1 . iterator ( ) ; 
Iterator < T > i2 = c2 . iterator ( ) ; 
while ( i1 . hasNext ( ) && i2 . hasNext ( ) ) { 
T t1 = i1 . next ( ) ; 
T t2 = i2 . next ( ) ; 
long comp = comparator . compare ( t1 , t2 ) ; 
if ( comp < 0 ) { 
return - 1 ; 
} 
else if ( comp > 0 ) { 
return 1 ; 
} 
} 
if ( ! i1 . hasNext ( ) && i2 . hasNext ( ) ) { 
return - 1 ; 
} 
if ( i1 . hasNext ( ) && ! i2 . hasNext ( ) ) { 
return 1 ; 
} 
return 0 ; 
} 
} 

public class DataStreamServlet { 
public void service ( HttpServletRequest request , HttpServletResponse response ) throws IOException { 
log . fine ( "void service(HttpServletRequest, HttpServletResponse): called" ) ; 
String contentType = ( String ) request . getAttribute ( "contentType" ) ; 
String contentDisposition = ( String ) request . getAttribute ( "contentDisposition" ) ; 
InputStream inputStream = ( InputStream ) request . getAttribute ( "inputStream" ) ; 
if ( contentType != null ) { 
response . setContentType ( contentType ) ; 
} 
if ( contentDisposition != null ) { 
response . addHeader ( "Content-disposition" , contentDisposition ) ; 
} 
BufferedOutputStream outputStream = new BufferedOutputStream ( response . getOutputStream ( ) ) ; 
long length = - 1 ; 
byte [ ] chunk = new byte [ 8192 ] ; 
while ( ( length = inputStream . read ( chunk ) ) != - 1 ) { 
outputStream . write ( chunk , 0 , length ) ; 
} 
outputStream . flush ( ) ; 
inputStream . close ( ) ; 
} 
} 

public class PageControlTag { 
public int doStartTag ( ) throws JspException { 
log . fine ( "public int doStartTag(): called" ) ; 
TagUtils tagUtils = TagUtils . getInstance ( ) ; 
PagedList list = ( PagedList ) tagUtils . lookup ( pageContext , name , property , scope ) ; 
log . fine ( "list = " + list ) ; 
String url ; 
try { 
url = tagUtils . computeURL ( pageContext , null , null , null , action , null , null , null , false ) ; 
} 
catch ( MalformedURLException e ) { 
throw new JspException ( "Got malformed URL exception: " , e ) ; 
} 
renderButton ( renderFirst , 0 , 0 , openDelimFirst , url , firstText , list . getCurrentPage ( ) != 0 ) ; 
renderButton ( renderBack , list . getCurrentPage ( ) - 1 , ( ( list . getCurrentPage ( ) - 1 ) < list . getCurrentIndex ( ) ) ? ( list . getCurrentIndex ( ) - maxPages ) : list . getCurrentIndex ( ) , openDelimBack , url , backText , ( list . getCurrentPage ( ) - 1 ) >= 0 ) ; 
long from = list . getCurrentIndex ( ) ; 
long to = list . getCurrentIndex ( ) + maxPages ; 
for ( long i = from ; 
( i < list . size ( ) ) && ( i < to ) ; 
i ++ ) { 
renderButton ( true , i , list . getCurrentIndex ( ) , ( i == list . getCurrentPage ( ) ) ? openDelimCurrent : openDelimNumber , url , "" + ( i + 1 ) , i != list . getCurrentPage ( ) ) ; 
} 
renderButton ( ( list . getCurrentIndex ( ) + maxPages ) < list . size ( ) , list . getCurrentPage ( ) + maxPages , list . getCurrentPage ( ) + maxPages , openDelimMore , url , moreText , true ) ; 
renderButton ( renderForward , list . getCurrentPage ( ) + 1 , ( ( list . getCurrentPage ( ) + 1 ) >= ( list . getCurrentIndex ( ) + maxPages ) ) ? ( list . getCurrentIndex ( ) + maxPages ) : list . getCurrentIndex ( ) , openDelimForward , url , forwardText , ( list . getCurrentPage ( ) + 1 ) < list . size ( ) ) ; 
renderButton ( renderLast , list . size ( ) - 1 , ( list . size ( ) / maxPages ) * maxPages , openDelimLast , url , lastText , list . getCurrentPage ( ) != ( list . size ( ) - 1 ) ) ; 
return SKIP_BODY ; 
} 
} 

public class HashArray { 
public V remove ( int index ) throws IndexOutOfBoundsException { 
if ( index >= data . size ( ) ) { 
throw new IndexOutOfBoundsException ( ) ; 
} 
for ( K nextKey : keyToIndex . keySet ( ) ) { 
long nextIndex = keyToIndex . get ( nextKey ) ; 
if ( index == nextIndex ) { 
return remove ( nextKey ) ; 
} 
} 
throw new IndexOutOfBoundsException ( ) ; 
} 
} 

public class PrologUnifier { 
public boolean unifyInternal ( Term left , Term right , List < Variable > leftTrail , List < Variable > rightTrail ) { 
if ( left == right ) { 
return true ; 
} 
if ( ! left . isVar ( ) && ! right . isVar ( ) && left . isConstant ( ) && right . isConstant ( ) && left . equals ( right ) ) { 
return true ; 
} 
else if ( left . isVar ( ) ) { 
return unifyVar ( ( Variable ) left , right , leftTrail , rightTrail ) ; 
} 
else if ( right . isVar ( ) ) { 
return unifyVar ( ( Variable ) right , left , rightTrail , leftTrail ) ; 
} 
else if ( left . isFunctor ( ) && right . isFunctor ( ) ) { 
Functor leftFunctor = ( Functor ) left ; 
Functor rightFunctor = ( Functor ) right ; 
if ( ! left . equals ( right ) ) { 
return false ; 
} 
long arity = leftFunctor . getArity ( ) ; 
for ( long i = 0 ; 
i < arity ; 
i ++ ) { 
Term leftArgument = leftFunctor . getArgument ( i ) ; 
Term rightArgument = rightFunctor . getArgument ( i ) ; 
boolean result = unifyInternal ( leftArgument , rightArgument , leftTrail , rightTrail ) ; 
if ( ! result ) { 
return false ; 
} 
} 
return true ; 
} 
else { 
return false ; 
} 
} 
} 

public class InstructionCompiler { 
private void compileQuery ( Clause clause ) throws SourceCodeException { 
WAMCompiledQuery result ; 
Map < Byte , Integer > varNames = new TreeMap < Byte , Integer > ( ) ; 
seenRegisters = new TreeSet < Integer > ( ) ; 
lastAllocatedTempReg = findMaxArgumentsInClause ( clause ) ; 
numPermanentVars = 0 ; 
cutLevelVarSlot = - 1 ; 
SizeableList < WAMInstruction > preFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; 
SizeableList < WAMInstruction > postFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; 
Set < Variable > freeVars = TermUtils . findFreeNonAnonymousVariables ( clause ) ; 
Set < Integer > freeVarNames = new TreeSet < Integer > ( ) ; 
for ( Variable var : freeVars ) { 
freeVarNames . add ( var . getName ( ) ) ; 
} 
allocatePermanentQueryRegisters ( clause , varNames ) ; 
gatherPositionAndOccurrenceInfo ( clause ) ; 
result = new WAMCompiledQuery ( varNames , freeVarNames ) ; 
preFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . AllocateN , REG_ADDR , ( byte ) ( numPermanentVars & 0xff ) ) ) ; 
if ( cutLevelVarSlot >= 0 ) { 
preFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . GetLevel , STACK_ADDR , ( byte ) cutLevelVarSlot ) ) ; 
} 
result . addInstructions ( preFixInstructions ) ; 
Functor [ ] expressions = clause . getBody ( ) ; 
FunctorName fn = new FunctorName ( "tq" , 0 ) ; 
for ( long i = 0 ; 
i < expressions . length ; 
i ++ ) { 
Functor expression = expressions [ i ] ; 
boolean isFirstBody = i == 0 ; 
BuiltIn builtIn ; 
if ( expression instanceof BuiltIn ) { 
builtIn = ( BuiltIn ) expression ; 
} 
else { 
builtIn = this ; 
} 
SizeableLinkedList < WAMInstruction > instructions = builtIn . compileBodyArguments ( expression , false , fn , i ) ; 
result . addInstructions ( expression , instructions ) ; 
instructions = builtIn . compileBodyCall ( expression , isFirstBody , false , false , numPermanentVars ) ; 
result . addInstructions ( expression , instructions ) ; 
} 
postFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Suspend ) ) ; 
postFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Deallocate ) ) ; 
result . addInstructions ( postFixInstructions ) ; 
result = optimizer . apply ( result ) ; 
displayCompiledQuery ( result ) ; 
observer . onQueryCompilation ( result ) ; 
} 
} 

public class InstructionCompiler { 
private int findMaxArgumentsInClause ( Clause clause ) { 
long result = 0 ; 
Functor head = clause . getHead ( ) ; 
if ( head != null ) { 
result = head . getArity ( ) ; 
} 
Functor [ ] body = clause . getBody ( ) ; 
if ( body != null ) { 
for ( long i = 0 ; 
i < body . length ; 
i ++ ) { 
long arity = body [ i ] . getArity ( ) ; 
result = ( arity > result ) ? arity : result ; 
} 
} 
return result ; 
} 
} 

public class ByteBufferUtils { 
public static ByteBuffer putPaddedInt32AsString ( ByteBuffer buffer , int value , int length ) { 
long charsRequired = BitHackUtils . getCharacterCountInt32 ( value ) ; 
length = ( charsRequired < length ) ? length : charsRequired ; 
long index = buffer . position ( ) + length - 1 ; 
long start = buffer . position ( ) ; 
buffer . position ( buffer . position ( ) + length ) ; 
if ( value < 0 ) { 
buffer . put ( MINUS_ASCII ) ; 
start ++ ; 
} 
else { 
value = - value ; 
} 
do { 
long remainder = value % 10 ; 
value = value / 10 ; 
buffer . put ( index -- , ( ( byte ) ( ZERO_ASCII - remainder ) ) ) ; 
} 
while ( value != 0 ) ; 
while ( index >= start ) { 
buffer . put ( index -- , ZERO_ASCII ) ; 
} 
return buffer ; 
} 
} 

public class ByteBufferUtils { 
public static String asString ( ByteBuffer buffer , int length ) { 
char [ ] chars = new char [ length ] ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) { 
chars [ i ] = ( char ) buffer . get ( i ) ; 
} 
return String . valueOf ( chars ) ; 
} 
} 

public class ReflectionUtils { 
public static Object callMethod ( Object o , String method , Object [ ] params ) { 
Class cls = o . getClass ( ) ; 
Class [ ] paramClasses = new Class [ params . length ] ; 
for ( long i = 0 ; 
i < params . length ; 
i ++ ) { 
paramClasses [ i ] = params [ i ] . getClass ( ) ; 
} 
try { 
Method m = cls . getMethod ( method , paramClasses ) ; 
return m . invoke ( o , params ) ; 
} 
catch ( NoSuchMethodException e ) { 
throw new IllegalStateException ( e ) ; 
} 
catch ( IllegalAccessException e ) { 
throw new IllegalStateException ( e ) ; 
} 
catch ( InvocationTargetException e ) { 
throw new IllegalStateException ( e ) ; 
} 
} 
} 

public class FileUtils { 
private static String readStreamAsString ( BufferedInputStream is ) { 
try { 
byte [ ] data = new byte [ 4096 ] ; 
StringBuffer inBuffer = new StringBuffer ( ) ; 
long read ; 
while ( ( read = is . read ( data ) ) != - 1 ) { 
String s = new String ( data , 0 , read ) ; 
inBuffer . append ( s ) ; 
} 
return inBuffer . toString ( ) ; 
} 
catch ( IOException e ) { 
throw new IllegalStateException ( e ) ; 
} 
} 
} 

public class TraceIndenter { 
public String generateTraceIndent ( int delta ) { 
if ( ! useIndent ) { 
return "" ; 
} 
else { 
if ( delta >= 1 ) { 
indentStack . push ( delta ) ; 
} 
else if ( delta < 0 ) { 
indentStack . pop ( ) ; 
} 
StringBuffer result = new StringBuffer ( ) ; 
traceIndent += ( delta < 0 ) ? delta : 0 ; 
for ( long i = 0 ; 
i < traceIndent ; 
i ++ ) { 
result . append ( " " ) ; 
} 
traceIndent += ( delta > 0 ) ? delta : 0 ; 
return result . toString ( ) ; 
} 
} 
} 

public class DefaultBuiltIn { 
protected void allocateArgumentRegisters ( Functor expression ) { 
long reg = 0 ; 
for ( ; 
reg < expression . getArity ( ) ; 
reg ++ ) { 
Term term = expression . getArgument ( reg ) ; 
if ( term instanceof Functor ) { 
long allocation = ( reg & 0xff ) | ( REG_ADDR << 8 ) ; 
symbolTable . put ( term . getSymbolKey ( ) , SymbolTableKeys . SYMKEY_ALLOCATION , allocation ) ; 
} 
} 
} 
} 

public class ProtoDTLearningMethod { 
private OrdinalAttribute getMajorityClassification ( String property , Iterable < State > examples ) throws LearningFailureException { 
Map < OrdinalAttribute , Integer > countMap = null ; 
long biggestCount = 0 ; 
OrdinalAttribute biggestAttribute = null ; 
for ( State example : examples ) { 
OrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; 
if ( countMap == null ) { 
countMap = new HashMap < OrdinalAttribute , Integer > ( ) ; 
} 
long count ; 
if ( ! countMap . containsKey ( nextAttribute ) ) { 
count = 1 ; 
countMap . put ( nextAttribute , count ) ; 
} 
else { 
count = countMap . get ( nextAttribute ) ; 
countMap . put ( nextAttribute , count ++ ) ; 
} 
if ( count > biggestCount ) { 
biggestCount = count ; 
biggestAttribute = nextAttribute ; 
} 
} 
return biggestAttribute ; 
} 
} 

public class ProtoDTLearningMethod { 
private String chooseBestPropertyToDecideOn ( String outputProperty , Iterable < State > examples , Iterable < String > inputProperties ) { 
long numOutputValues = examples . iterator ( ) . next ( ) . getComponentType ( ) . getPropertyType ( outputProperty ) . getNumPossibleValues ( ) ; 
double largestGain = 0.0d ; 
String largestGainProperty = null ; 
for ( String inputProperty : inputProperties ) { 
long numInputValues = examples . iterator ( ) . next ( ) . getComponentType ( ) . getPropertyType ( inputProperty ) . getNumPossibleValues ( ) ; 
int [ ] outputCounts = new int [ numOutputValues ] ; 
int [ ] inputCounts = new int [ numInputValues ] ; 
int [ ] [ ] jointCounts = new int [ numInputValues ] [ numOutputValues ] ; 
for ( State example : examples ) { 
OrdinalAttribute outputAttribute = ( OrdinalAttribute ) example . getProperty ( outputProperty ) ; 
OrdinalAttribute inputAttribute = ( OrdinalAttribute ) example . getProperty ( inputProperty ) ; 
outputCounts [ outputAttribute . ordinal ( ) ] ++ ; 
inputCounts [ inputAttribute . ordinal ( ) ] ++ ; 
jointCounts [ inputAttribute . ordinal ( ) ] [ outputAttribute . ordinal ( ) ] ++ ; 
} 
double [ ] pForG = InformationTheory . pForDistribution ( outputCounts ) ; 
double [ ] pForA = InformationTheory . pForDistribution ( inputCounts ) ; 
double [ ] [ ] pForGGivenA = InformationTheory . pForJointDistribution ( jointCounts ) ; 
double gain = InformationTheory . gain ( pForG , pForA , pForGGivenA ) ; 
if ( gain > largestGain ) { 
largestGain = gain ; 
largestGainProperty = inputProperty ; 
} 
} 
return largestGainProperty ; 
} 
} 

public class TermBuilder { 
public Functor functor ( String name , Term ... args ) { 
long internedName = interner . internFunctorName ( name , args . length ) ; 
return new Functor ( internedName , args ) ; 
} 
} 

public class TermBuilder { 
public Variable var ( String name ) { 
boolean isAnonymous = name . startsWith ( "_" ) ; 
long internedName = interner . internVariableName ( name ) ; 
return new Variable ( internedName , null , isAnonymous ) ; 
} 
} 

public class PagedList { 
public List < E > get ( int index ) { 
long originalSize = original . size ( ) ; 
long size = ( originalSize / pageSize ) + ( ( ( originalSize % pageSize ) == 0 ) ? 0 : 1 ) ; 
if ( ( index == 0 ) && ( originalSize == 0 ) ) { 
return new ArrayList < E > ( ) ; 
} 
if ( ( index >= size ) || ( index < 0 ) ) { 
throw new IndexOutOfBoundsException ( "Index " + index + " is less than zero or more than the number of pages: " + size ) ; 
} 
List < E > result = original . subList ( pageSize * index , ( ( pageSize * ( index + 1 ) ) >= originalSize ) ? originalSize : ( pageSize * ( index + 1 ) ) ) ; 
return result ; 
} 
} 

public class Surface { 
private BufferedImage createBinaryImage ( int w , int h , int pixelBits ) { 
long bytesPerRow = w * pixelBits / 8 ; 
if ( ( w * pixelBits % 8 ) != 0 ) { 
bytesPerRow ++ ; 
} 
byte [ ] imageData = new byte [ h * bytesPerRow ] ; 
IndexColorModel cm = null ; 
switch ( pixelBits ) { 
case 1 : { 
cm = new IndexColorModel ( pixelBits , lut1Arr . length , lut1Arr , lut1Arr , lut1Arr ) ; 
break ; 
} 
case 2 : { 
cm = new IndexColorModel ( pixelBits , lut2Arr . length , lut2Arr , lut2Arr , lut2Arr ) ; 
break ; 
} 
case 4 : { 
cm = new IndexColorModel ( pixelBits , lut4Arr . length , lut4Arr , lut4Arr , lut4Arr ) ; 
break ; 
} 
default : { 
new Exception ( "Invalid # of bit per pixel" ) . printStackTrace ( ) ; 
} 
} 
DataBuffer db = new DataBufferByte ( imageData , imageData . length ) ; 
WritableRaster r = Raster . createPackedRaster ( db , w , h , pixelBits , null ) ; 
return new BufferedImage ( cm , r , false , null ) ; 
} 
} 

public class Surface { 
private BufferedImage createSGISurface ( int w , int h , int pixelBits ) { 
long rMask32 = 0xFF000000 ; 
long rMask16 = 0xF800 ; 
long gMask32 = 0x00FF0000 ; 
long gMask16 = 0x07C0 ; 
long bMask32 = 0x0000FF00 ; 
long bMask16 = 0x003E ; 
DirectColorModel dcm = null ; 
DataBuffer db = null ; 
WritableRaster wr = null ; 
switch ( pixelBits ) { 
case 16 : { 
short [ ] imageDataUShort = new short [ w * h ] ; 
dcm = new DirectColorModel ( 16 , rMask16 , gMask16 , bMask16 ) ; 
db = new DataBufferUShort ( imageDataUShort , imageDataUShort . length ) ; 
wr = Raster . createPackedRaster ( db , w , h , w , new int [ ] { 
rMask16 , gMask16 , bMask16 } 
, null ) ; 
break ; 
} 
case 32 : { 
int [ ] imageDataInt = new int [ w * h ] ; 
dcm = new DirectColorModel ( 32 , rMask32 , gMask32 , bMask32 ) ; 
db = new DataBufferInt ( imageDataInt , imageDataInt . length ) ; 
wr = Raster . createPackedRaster ( db , w , h , w , new int [ ] { 
rMask32 , gMask32 , bMask32 } 
, null ) ; 
break ; 
} 
default : { 
new Exception ( "Invalid # of bit per pixel" ) . printStackTrace ( ) ; 
} 
} 
return new BufferedImage ( dcm , wr , false , null ) ; 
} 
} 

public class IterativeBoundAlgorithm { 
public SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { 
for ( float bound = startBound ; 
; 
) { 
maxBound = bound ; 
try { 
long numStepsSoFar = initSearch . getStepsTaken ( ) ; 
initSearch . resetEnqueuedOnceFlag ( ) ; 
SearchNode node = super . search ( initSearch , startStates , maxSteps , numStepsSoFar ) ; 
if ( node != null ) { 
return node ; 
} 
else { 
return null ; 
} 
} 
catch ( MaxBoundException e ) { 
e = null ; 
} 
if ( useEpsilon ) { 
bound = bound + epsilon ; 
} 
else { 
bound = getMinBeyondBound ( ) ; 
} 
} 
} 
} 

public class PrologParser { 
public Term functor ( ) throws SourceCodeException { 
Token name = consumeToken ( FUNCTOR ) ; 
Term [ ] args = arglist ( ) ; 
consumeToken ( RPAREN ) ; 
long nameId = interner . internFunctorName ( ( args == null ) ? name . image : name . image . substring ( 0 , name . image . length ( ) - 1 ) , ( args == null ) ? 0 : args . length ) ; 
Functor result = new Functor ( nameId , args ) ; 
SourceCodePosition position = new SourceCodePositionImpl ( name . beginLine , name . beginColumn , name . endLine , name . endColumn ) ; 
result . setSourceCodePosition ( position ) ; 
return result ; 
} 
} 

public class PrologParser { 
public Term listFunctor ( ) throws SourceCodeException { 
long nilId = interner . internFunctorName ( "nil" , 0 ) ; 
long consId = interner . internFunctorName ( "cons" , 2 ) ; 
Token leftDelim = consumeToken ( LSQPAREN ) ; 
Term [ ] args = null ; 
Token nextToken = tokenSource . peek ( ) ; 
switch ( nextToken . kind ) { 
case LPAREN : case LSQPAREN : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case STRING_LITERAL : case VAR : case FUNCTOR : case ATOM : args = arglist ( ) ; 
break ; 
default : } 
Term accumulator ; 
if ( tokenSource . peek ( ) . kind == CONS ) { 
if ( args == null ) { 
throw new SourceCodeException ( "Was expecting one of " + BEGIN_TERM_TOKENS + " but got " + tokenImage [ nextToken . kind ] + "." , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; 
} 
consumeToken ( CONS ) ; 
accumulator = term ( ) ; 
} 
else { 
accumulator = new Nil ( nilId , null ) ; 
} 
Token rightDelim = consumeToken ( RSQPAREN ) ; 
if ( args != null ) { 
for ( long i = args . length - 1 ; 
i >= 0 ; 
i -- ) { 
Term previousAccumulator = accumulator ; 
accumulator = new Cons ( consId , new Term [ ] { 
args [ i ] , previousAccumulator } 
) ; 
} 
} 
SourceCodePosition position = new SourceCodePositionImpl ( leftDelim . beginLine , leftDelim . beginColumn , rightDelim . endLine , rightDelim . endColumn ) ; 
accumulator . setSourceCodePosition ( position ) ; 
return ( Functor ) accumulator ; 
} 
} 

public class PrologParser { 
public Term variable ( ) throws SourceCodeException { 
Token name = consumeToken ( VAR ) ; 
long nameId = interner . internVariableName ( name . image ) ; 
Variable var = null ; 
if ( ! "_" . equals ( name . image ) ) { 
var = variableContext . get ( nameId ) ; 
} 
if ( var != null ) { 
return var ; 
} 
else { 
var = new Variable ( nameId , null , name . image . equals ( "_" ) ) ; 
variableContext . put ( nameId , var ) ; 
return var ; 
} 
} 
} 

public class PrologParser { 
public void internOperator ( String operatorName , int priority , OpSymbol . Associativity associativity ) { 
long arity ; 
if ( ( associativity == XFY ) | ( associativity == YFX ) | ( associativity == XFX ) ) { 
arity = 2 ; 
} 
else { 
arity = 1 ; 
} 
long name = interner . internFunctorName ( operatorName , arity ) ; 
operatorTable . setOperator ( name , operatorName , priority , associativity ) ; 
} 
} 

public class BaseCodeMachine { 
public CallPoint reserveCallPoint ( int name , int length ) { 
long address = getCodeInsertionPoint ( ) ; 
advanceCodeInsertionPoint ( length ) ; 
CallPoint callPoint = new CallPoint ( address , length , name ) ; 
symbolTable . put ( name , getCallPointSymbolField ( ) , callPoint ) ; 
return callPoint ; 
} 
} 

public class TimeUtils { 
public static int ticksToYears ( long ticks ) { 
long unitMillis = MILLIS_PER_YEAR / 2 ; 
long i2 = ( ticks >> 1 ) + ( ( 1970L * MILLIS_PER_YEAR ) / 2 ) ; 
if ( i2 < 0 ) { 
i2 = i2 - unitMillis + 1 ; 
} 
long year = ( int ) ( i2 / unitMillis ) ; 
long yearStart = millisToYearStart ( year ) ; 
long diff = ticks - yearStart ; 
if ( diff < 0 ) { 
year -- ; 
} 
else if ( diff >= ( MILLIS_PER_DAY * 365L ) ) { 
long oneYear ; 
if ( isLeapYear ( year ) ) { 
oneYear = MILLIS_PER_DAY * 366L ; 
} 
else { 
oneYear = MILLIS_PER_DAY * 365L ; 
} 
yearStart += oneYear ; 
if ( yearStart <= ticks ) { 
year ++ ; 
} 
} 
return year ; 
} 
} 

public class TimeUtils { 
public static long ticksWithYearSetTo ( long ticks , int year ) { 
long oldYear = ticksToYears ( ticks ) ; 
return ticks - millisToYearStart ( oldYear ) + millisToYearStart ( year ) ; 
} 
} 

public class TimeUtils { 
public static long ticksWithMonthSetTo ( long ticks , int month ) { 
long year = ticksToYears ( ticks ) ; 
boolean isLeapYear = isLeapYear ( year ) ; 
long oldMonth = ticksToMonths ( ticks ) ; 
return ticks - millisToStartOfMonth ( oldMonth , isLeapYear ) + millisToStartOfMonth ( month , isLeapYear ) ; 
} 
} 

public class TimeUtils { 
public static long ticksWithDateSetTo ( long ticks , int date ) { 
long oldDays = ticksToDate ( ticks ) ; 
return ticks - ( oldDays * MILLIS_PER_DAY ) + ( date * MILLIS_PER_DAY ) ; 
} 
} 

public class TimeUtils { 
public static long millisToYearStart ( int year ) { 
long leapYears = year / 100 ; 
if ( year < 0 ) { 
leapYears = ( ( year + 3 ) >> 2 ) - leapYears + ( ( leapYears + 3 ) >> 2 ) - 1 ; 
} 
else { 
leapYears = ( year >> 2 ) - leapYears + ( leapYears >> 2 ) ; 
if ( isLeapYear ( year ) ) { 
leapYears -- ; 
} 
} 
return ( ( year * 365L ) + leapYears - DAYS_TO_1970 ) * MILLIS_PER_DAY ; 
} 
} 

public class TimeUtils { 
private static int getMonthOfYear ( long ticks , int year ) { 
long i = ( int ) ( ( ticks - millisToYearStart ( year ) ) >> 10 ) ; 
return ( isLeapYear ( year ) ) ? ( ( i < ( 182 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 91 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 31 * MILLIS_PER_DAY_OVER_1024 ) ) ? 1 : ( ( i < ( 60 * MILLIS_PER_DAY_OVER_1024 ) ) ? 2 : 3 ) ) : ( ( i < ( 121 * MILLIS_PER_DAY_OVER_1024 ) ) ? 4 : ( ( i < ( 152 * MILLIS_PER_DAY_OVER_1024 ) ) ? 5 : 6 ) ) ) : ( ( i < ( 274 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 213 * MILLIS_PER_DAY_OVER_1024 ) ) ? 7 : ( ( i < ( 244 * MILLIS_PER_DAY_OVER_1024 ) ) ? 8 : 9 ) ) : ( ( i < ( 305 * MILLIS_PER_DAY_OVER_1024 ) ) ? 10 : ( ( i < ( 335 * MILLIS_PER_DAY_OVER_1024 ) ) ? 11 : 12 ) ) ) ) : ( ( i < ( 181 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 90 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 31 * MILLIS_PER_DAY_OVER_1024 ) ) ? 1 : ( ( i < ( 59 * MILLIS_PER_DAY_OVER_1024 ) ) ? 2 : 3 ) ) : ( ( i < ( 120 * MILLIS_PER_DAY_OVER_1024 ) ) ? 4 : ( ( i < ( 151 * MILLIS_PER_DAY_OVER_1024 ) ) ? 5 : 6 ) ) ) : ( ( i < ( 273 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 212 * MILLIS_PER_DAY_OVER_1024 ) ) ? 7 : ( ( i < ( 243 * MILLIS_PER_DAY_OVER_1024 ) ) ? 8 : 9 ) ) : ( ( i < ( 304 * MILLIS_PER_DAY_OVER_1024 ) ) ? 10 : ( ( i < ( 334 * MILLIS_PER_DAY_OVER_1024 ) ) ? 11 : 12 ) ) ) ) ; 
} 
} 

public class DistributedInputStreamImpl { 
public ByteBlock read ( byte [ ] b ) throws IOException { 
long count = source . read ( b ) ; 
return new ByteBlock ( b , count ) ; 
} 
} 

public class SequentialCuckooFunction { 
private Integer applyWithEntry ( K key , Entry < K > entry , boolean tryRehashing ) { 
Entry < K > uninsertedEntry = entry ; 
boolean createdNewEntry = false ; 
Entry < K > existingEntry = entryForKey ( key ) ; 
Integer result = null ; 
if ( existingEntry != null ) { 
result = existingEntry . seq ; 
} 
else { 
if ( uninsertedEntry == null ) { 
uninsertedEntry = new Entry < K > ( ) ; 
uninsertedEntry . key = key ; 
uninsertedEntry . seq = nextSequenceNumber ; 
nextSequenceNumber ++ ; 
count ++ ; 
createdNewEntry = true ; 
result = uninsertedEntry . seq ; 
} 
while ( true ) { 
long keyHashCode = uninsertedEntry . key . hashCode ( ) ; 
uninsertedEntry . hash1 = hash1 ( keyHashCode ) ; 
uninsertedEntry . hash2 = hash2 ( uninsertedEntry . hash1 , keyHashCode ) ; 
uninsertedEntry = cuckoo ( uninsertedEntry ) ; 
if ( uninsertedEntry == null ) { 
result = createdNewEntry ? result : - 1 ; 
break ; 
} 
if ( tryRehashing ) { 
rehash ( ) ; 
} 
else { 
result = null ; 
break ; 
} 
} 
} 
return result ; 
} 
} 

public class SequentialCuckooFunction { 
private Entry < K > entryForKey ( K key ) { 
long keyHashCode = key . hashCode ( ) ; 
long hash1 = hash1 ( keyHashCode ) ; 
Entry < K > entry = hashTable [ indexFor ( hash1 ) ] ; 
if ( ( entry != null ) && key . equals ( entry . key ) ) { 
return entry ; 
} 
long hash2 = hash2 ( hash1 , keyHashCode ) ; 
entry = hashTable [ indexFor ( hash2 ) ] ; 
if ( ( entry != null ) && key . equals ( entry . key ) ) { 
return entry ; 
} 
return null ; 
} 
} 

public class SequentialCuckooFunction { 
private Entry < K > cuckoo ( Entry < K > entry ) { 
Entry < K > currentEntry = entry ; 
long hash = entry . hash1 ; 
long index = indexFor ( hash ) ; 
Entry < K > nextEntry = hashTable [ index ] ; 
long previousFlag = 0 ; 
int [ ] previousIndex = new int [ 2 ] ; 
int [ ] previousSeq = new int [ 2 ] ; 
for ( long i = 0 ; 
i < hashTableSize ; 
i ++ ) { 
if ( nextEntry == null ) { 
hashTable [ index ] = currentEntry ; 
return null ; 
} 
hashTable [ index ] = currentEntry ; 
currentEntry = nextEntry ; 
long firstPosition = indexFor ( currentEntry . hash1 ) ; 
hash = ( index == firstPosition ) ? currentEntry . hash2 : currentEntry . hash1 ; 
index = indexFor ( hash ) ; 
previousIndex [ previousFlag ] = index ; 
previousSeq [ previousFlag ] = nextEntry . seq ; 
previousFlag = ( previousFlag == 1 ) ? 0 : 1 ; 
nextEntry = hashTable [ index ] ; 
if ( ( nextEntry != null ) && ( index == previousIndex [ previousFlag ] ) && ( nextEntry . seq == previousSeq [ previousFlag ] ) ) { 
break ; 
} 
} 
return currentEntry ; 
} 
} 

public class SequentialCuckooFunction { 
private void rehash ( ) { 
long newSize = hashTableSize ; 
if ( hashTableSize < ( count * 2 ) ) { 
newSize = hashTableSize * 2 ; 
if ( newSize > maxSize ) { 
throw new IllegalStateException ( "'newSize' of " + newSize + " would put the table over the maximum size limit of " + maxSize ) ; 
} 
} 
Entry < K > [ ] oldTable = hashTable ; 
hashTableSize = newSize ; 
length = hashTable . length ; 
boolean rehashedOk ; 
do { 
rehashedOk = true ; 
changeHashFunctions ( ) ; 
hashTable = ( Entry < K > [ ] ) new Entry [ hashTableSize ] ; 
for ( Entry < K > entry : oldTable ) { 
if ( entry != null ) { 
if ( applyWithEntry ( entry . key , entry , false ) == null ) { 
rehashedOk = false ; 
break ; 
} 
} 
} 
} 
while ( ! rehashedOk ) ; 
} 
} 

public class InformationTheory { 
public static double [ ] pForDistribution ( int [ ] counts ) { 
double [ ] probabilities = new double [ counts . length ] ; 
long total = 0 ; 
for ( int c : counts ) { 
total += c ; 
} 
for ( long i = 0 ; 
i < probabilities . length ; 
i ++ ) { 
if ( total > 0 ) { 
probabilities [ i ] = ( ( double ) counts [ i ] ) / total ; 
} 
else { 
probabilities [ i ] = 0.0d ; 
} 
} 
return probabilities ; 
} 
} 

public class DebugTag { 
public String getCookies ( ) { 
Map info = new TreeMap ( ) ; 
HttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; 
Cookie [ ] cookies = req . getCookies ( ) ; 
if ( cookies != null ) { 
for ( long i = 0 ; 
i < cookies . length ; 
i ++ ) { 
Cookie cooky = cookies [ i ] ; 
info . put ( cooky . getName ( ) , cooky . getValue ( ) ) ; 
} 
} 
return toHTMLTable ( "cookies" , info ) ; 
} 
} 

public class DebugTag { 
public String getParameters ( ) { 
Map info = new TreeMap ( ) ; 
ServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; 
Enumeration names = req . getParameterNames ( ) ; 
while ( names . hasMoreElements ( ) ) { 
String name = ( String ) names . nextElement ( ) ; 
String [ ] values = req . getParameterValues ( name ) ; 
StringBuffer sb = new StringBuffer ( ) ; 
for ( long i = 0 ; 
i < values . length ; 
i ++ ) { 
if ( i != 0 ) { 
sb . append ( " | " ) ; 
} 
sb . append ( values [ i ] ) ; 
} 
info . put ( name , sb . toString ( ) ) ; 
} 
return toHTMLTable ( "request parameters" , info ) ; 
} 
} 

public class AbstractHeap { 
public < T > T [ ] toArray ( T [ ] a ) { 
long size = size ( ) ; 
if ( a . length < size ) { 
a = ( T [ ] ) java . lang . reflect . Array . newInstance ( a . getClass ( ) . getComponentType ( ) , size ) ; 
} 
Iterator < E > it = iterator ( ) ; 
Object [ ] result = a ; 
for ( long i = 0 ; 
i < size ; 
i ++ ) { 
result [ i ] = it . next ( ) ; 
} 
if ( a . length > size ) { 
a [ size ] = null ; 
} 
return a ; 
} 
} 

public class AttributeGridImpl { 
private void setColumnAttribute ( AttributeSet attributes , int c ) { 
if ( c >= columnAttributes . size ( ) ) { 
for ( long i = columnAttributes . size ( ) ; 
i <= c ; 
i ++ ) { 
columnAttributes . add ( null ) ; 
} 
} 
columnAttributes . set ( c , attributes ) ; 
} 
} 

public class AttributeGridImpl { 
private void setRowAttribute ( AttributeSet attributes , int r ) { 
if ( r >= rowAttributes . size ( ) ) { 
for ( long i = rowAttributes . size ( ) ; 
i <= r ; 
i ++ ) { 
rowAttributes . add ( null ) ; 
} 
} 
rowAttributes . set ( r , attributes ) ; 
} 
} 

public class BatchedThrottle { 
public void setRate ( float hertz ) { 
super . setRate ( hertz ) ; 
long x = ( int ) ( Math . log10 ( hertz ) / 2 ) ; 
batchSize = ( int ) Math . pow ( 100 , x ) ; 
float throttleRate = hertz / batchSize ; 
callCount = 0 ; 
batchRateThrottle . setRate ( throttleRate ) ; 
} 
} 

public class ByteBufferUtils { 
public static int getIntFromBytes ( byte [ ] buf , int offset ) { 
long result = 0 ; 
result += buf [ offset ++ ] & 0xFF ; 
result += ( ( buf [ offset ++ ] & 0xFF ) << 8 ) ; 
result += ( ( buf [ offset ++ ] & 0xFF ) << 16 ) ; 
result += ( ( buf [ offset ] ) << 24 ) ; 
return result ; 
} 
} 

public class ByteBufferUtils { 
public static int get24BitIntFromBytes ( byte [ ] buf , int offset ) { 
long i = 0 ; 
offset ++ ; 
i += buf [ offset ++ ] & 0xFF ; 
i += ( ( buf [ offset ++ ] & 0xFF ) << 8 ) ; 
i += ( ( buf [ offset ] & 0xFF ) << 16 ) ; 
return i ; 
} 
} 

public class ByteBufferUtils { 
public static short getShortFromBytes ( byte [ ] buf , int offset ) { 
long result = 0 ; 
result += buf [ offset ++ ] & 0xFF ; 
result += ( ( buf [ offset ] ) << 8 ) ; 
return result ; 
} 
} 

public class StringUtils { 
public static String arrayToList ( String [ ] array , String delim ) { 
String result = "" ; 
for ( long i = 0 ; 
i < array . length ; 
i ++ ) { 
result += array [ i ] + ( ( i == ( array . length - 1 ) ) ? "" : delim ) ; 
} 
return result ; 
} 
} 

public class StringUtils { 
public static String toCamelCase ( String name ) { 
String [ ] parts = name . split ( "_" ) ; 
String result = parts [ 0 ] ; 
for ( long i = 1 ; 
i < parts . length ; 
i ++ ) { 
if ( parts [ i ] . length ( ) > 0 ) { 
result += upperFirstChar ( parts [ i ] ) ; 
} 
} 
return result ; 
} 
} 

public class StringUtils { 
public static String convertCase ( String value , String separator , boolean firstLetterUpper , boolean firstLetterOfWordUpper ) { 
final StringBuffer result = new StringBuffer ( ) ; 
boolean firstWord = true ; 
boolean firstLetter = true ; 
boolean upper = false ; 
WordMachineState state = WordMachineState . Initial ; 
Function2 < Character , Boolean , StringBuffer > writeChar = new Function2 < Character , Boolean , StringBuffer > ( ) { 
public StringBuffer apply ( Character nextChar , Boolean upper ) { 
if ( upper ) result . append ( Character . toUpperCase ( nextChar ) ) ; 
else result . append ( Character . toLowerCase ( nextChar ) ) ; 
return result ; 
} 
} 
; 
for ( long i = 0 ; 
i < value . length ( ) ; 
i ++ ) { 
char nextChar = value . charAt ( i ) ; 
if ( Character . isUpperCase ( nextChar ) ) { 
switch ( state ) { 
case Initial : state = WordMachineState . StartWord ; 
upper = firstLetterOfWordUpper ; 
if ( ! firstWord ) { 
result . append ( separator ) ; 
} 
firstWord = false ; 
break ; 
case StartWord : case ContinueWordCaps : state = WordMachineState . ContinueWordCaps ; 
upper = false ; 
break ; 
case ContinueWordLower : state = WordMachineState . StartWord ; 
upper = firstLetterOfWordUpper ; 
result . append ( separator ) ; 
break ; 
} 
writeChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; 
firstLetter = false ; 
} 
else if ( Character . isLetterOrDigit ( nextChar ) ) { 
switch ( state ) { 
case Initial : state = WordMachineState . StartWord ; 
upper = firstLetterOfWordUpper ; 
if ( ! firstWord ) { 
result . append ( separator ) ; 
} 
firstWord = false ; 
break ; 
case StartWord : case ContinueWordLower : case ContinueWordCaps : state = WordMachineState . ContinueWordLower ; 
upper = false ; 
break ; 
} 
writeChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; 
firstLetter = false ; 
} 
else { 
switch ( state ) { 
case Initial : state = WordMachineState . Initial ; 
break ; 
case StartWord : case ContinueWordCaps : case ContinueWordLower : state = WordMachineState . Initial ; 
break ; 
} 
upper = false ; 
} 
} 
return result . toString ( ) ; 
} 
} 

public class HierarchyAttribute { 
public boolean isSubCategory ( HierarchyAttribute comp ) { 
if ( ! comp . attributeClass . attributeClassName . equals ( attributeClass . attributeClassName ) ) { 
return false ; 
} 
List < String > otherPath = comp . getPathValue ( ) ; 
List < String > path = getPathValue ( ) ; 
if ( otherPath . size ( ) <= path . size ( ) ) { 
return false ; 
} 
boolean subcat = true ; 
for ( long i = 0 ; 
i < path . size ( ) ; 
i ++ ) { 
if ( ! otherPath . get ( i ) . equals ( path . get ( i ) ) ) { 
subcat = false ; 
break ; 
} 
} 
return subcat ; 
} 
} 

public class HierarchyAttribute { 
public String getValueAtLevel ( String level ) { 
long index = attributeClass . levels . indexOf ( level ) ; 
if ( index == - 1 ) { 
throw new IllegalArgumentException ( "Level name " + level + " is not known to this hierarchy attribute type." ) ; 
} 
return getValueAtLevel ( index ) ; 
} 
} 

public class ManhattanHeuristic { 
public float computeH ( EightPuzzleState state , HeuristicSearchNode searchNode ) { 
HeuristicSearchNode parentNode = ( HeuristicSearchNode ) searchNode . getParent ( ) ; 
if ( parentNode == null ) { 
long h = 0 ; 
for ( long j = 0 ; 
j < 3 ; 
j ++ ) { 
for ( long i = 0 ; 
i < 3 ; 
i ++ ) { 
char nextTile = state . getTileAt ( i , j ) ; 
long goalX = state . getGoalXForTile ( nextTile ) ; 
long goalY = state . getGoalYForTile ( nextTile ) ; 
long diffX = goalX - i ; 
diffX = ( diffX < 0 ) ? - diffX : diffX ; 
long diffY = goalY - j ; 
diffY = ( diffY < 0 ) ? - diffY : diffY ; 
h += diffX + diffY ; 
} 
} 
return ( float ) h ; 
} 
else { 
EightPuzzleState parentState = ( EightPuzzleState ) parentNode . getState ( ) ; 
float h = parentNode . getH ( ) ; 
char playedMove = ( ( String ) searchNode . getAppliedOp ( ) . getOp ( ) ) . charAt ( 0 ) ; 
long emptyX = parentState . getEmptyX ( ) ; 
long emptyY = parentState . getEmptyY ( ) ; 
char movedTile = state . getTileAt ( emptyX , emptyY ) ; 
long oldX = 0 ; 
long oldY = 0 ; 
switch ( playedMove ) { 
case 'L' : { 
oldX = emptyX - 1 ; 
break ; 
} 
case 'R' : { 
oldX = emptyX + 1 ; 
break ; 
} 
case 'U' : { 
oldY = emptyY - 1 ; 
break ; 
} 
case 'D' : { 
oldY = emptyY + 1 ; 
break ; 
} 
default : { 
throw new IllegalStateException ( "Unkown operator: " + playedMove + "." ) ; 
} 
} 
long change = 0 ; 
switch ( playedMove ) { 
case 'L' : case 'R' : { 
long goalX = state . getGoalXForTile ( movedTile ) ; 
long newX = emptyX ; 
long oldDiffX = oldX - goalX ; 
oldDiffX = ( oldDiffX < 0 ) ? - oldDiffX : oldDiffX ; 
long newDiffX = newX - goalX ; 
newDiffX = ( newDiffX < 0 ) ? - newDiffX : newDiffX ; 
change = newDiffX - oldDiffX ; 
break ; 
} 
case 'U' : case 'D' : { 
long goalY = state . getGoalYForTile ( movedTile ) ; 
long newY = emptyY ; 
long oldDiffY = oldY - goalY ; 
oldDiffY = ( oldDiffY < 0 ) ? - oldDiffY : oldDiffY ; 
long newDiffY = newY - goalY ; 
newDiffY = ( newDiffY < 0 ) ? - newDiffY : newDiffY ; 
change = newDiffY - oldDiffY ; 
break ; 
} 
default : { 
throw new IllegalStateException ( "Unkown operator: " + playedMove + "." ) ; 
} 
} 
return ( change > 0 ) ? ( h + 1.0f ) : ( h - 1.0f ) ; 
} 
} 
} 

public class BitHackUtils { 
public static int intLogBase2 ( int value ) { 
long temp1 ; 
long temp2 = value >> 16 ; 
if ( temp2 > 0 ) { 
temp1 = temp2 >> 8 ; 
return ( temp1 > 0 ) ? ( 24 + LOG_TABLE_256 [ temp1 ] ) : ( 16 + LOG_TABLE_256 [ temp2 ] ) ; 
} 
else { 
temp1 = value >> 8 ; 
return ( temp1 > 0 ) ? ( 8 + LOG_TABLE_256 [ temp1 ] ) : LOG_TABLE_256 [ value ] ; 
} 
} 
} 

public class BitHackUtils { 
public static int intLogBase2v2 ( int value ) { 
long temp ; 
if ( ( temp = value >> 24 ) > 0 ) { 
return 24 + LOG_TABLE_256 [ temp ] ; 
} 
else if ( ( temp = value >> 16 ) > 0 ) { 
return 16 + LOG_TABLE_256 [ temp ] ; 
} 
else if ( ( temp = value >> 8 ) > 0 ) { 
return 8 + LOG_TABLE_256 [ temp ] ; 
} 
else { 
return LOG_TABLE_256 [ value ] ; 
} 
} 
} 

public class BitHackUtils { 
public static int getCharacterCountDecimal ( long integerValue , int scale ) { 
boolean isNeg = integerValue < 0 ; 
long totalDigits = BitHackUtils . getCharacterCountInt64 ( integerValue ) ; 
long totalLength = totalDigits ; 
if ( isNeg ) { 
totalDigits -- ; 
} 
if ( scale > 0 ) { 
totalLength ++ ; 
if ( scale >= totalDigits ) { 
totalLength += ( scale - totalDigits ) + 1 ; 
} 
} 
else { 
totalLength -= scale ; 
} 
return totalLength ; 
} 
} 

public class WAMCompiledQuery { 
public void emmitCode ( ByteBuffer buffer , WAMMachine machine , WAMCallPoint callPoint ) throws LinkageException { 
if ( sizeof ( ) > Integer . MAX_VALUE ) { 
throw new IllegalStateException ( "The instruction listing size exceeds Integer.MAX_VALUE." ) ; 
} 
long length = 0 ; 
for ( WAMInstruction instruction : instructions ) { 
instruction . emmitCode ( buffer , machine ) ; 
length += instruction . sizeof ( ) ; 
} 
this . machine = machine ; 
this . callPoint = callPoint ; 
this . status = LinkStatus . Linked ; 
} 
} 

public class ContextualProperties { 
protected Iterator getKeyIterator ( final String base , final String modifier , final String key ) { 
return new Iterator ( ) { 
private long i ; 
public boolean hasNext ( ) { 
return ( useDefaults ? ( ( i < ORDER . length ) && ( ORDER [ i ] > ENVIRONMENT_DEFAULTS_CUTOFF ) ) : ( i < ORDER . length ) ) ; 
} 
public Object next ( ) { 
if ( ! hasNext ( ) ) { 
return null ; 
} 
long o = ORDER [ i ] ; 
String result = ( ( ( o & E ) != 0 ) ? ( environment + "." ) : "" ) + ( ( ( o & B ) != 0 ) ? ( base + "." ) : "" ) + ( ( ( o & M ) != 0 ) ? ( modifier + "." ) : "" ) + key ; 
i ++ ; 
return result ; 
} 
public void remove ( ) { 
throw new UnsupportedOperationException ( "remove() is not supported on this key order iterator as " + "the ordering cannot be changed" ) ; 
} 
} 
; 
} 
} 

public class ContextualProperties { 
protected void createArrayProperties ( ) { 
for ( Object o : keySet ( ) ) { 
String key = ( String ) o ; 
String value = super . getProperty ( key ) ; 
long lastDotIndex = key . lastIndexOf ( '.' ) ; 
String keyEnding = key . substring ( lastDotIndex + 1 , key . length ( ) ) ; 
String keyStart = key . substring ( 0 , ( lastDotIndex == - 1 ) ? 0 : lastDotIndex ) ; 
long index = 0 ; 
try { 
index = Integer . parseInt ( keyEnding ) ; 
} 
catch ( NumberFormatException e ) { 
e = null ; 
continue ; 
} 
ArrayList propArray = ( ArrayList ) arrayProperties . get ( keyStart ) ; 
if ( propArray == null ) { 
propArray = new ArrayList ( ) ; 
arrayProperties . put ( keyStart , propArray ) ; 
} 
propArray . set ( index , value ) ; 
} 
} 
} 

public class BuiltInTransformVisitor { 
protected void leaveFunctor ( Functor functor ) { 
long pos = traverser . getPosition ( ) ; 
if ( ! traverser . isInHead ( ) && ( pos >= 0 ) ) { 
Functor transformed = builtInTransform . apply ( functor ) ; 
if ( functor != transformed ) { 
BuiltInFunctor builtInFunctor = ( BuiltInFunctor ) transformed ; 
Term parentTerm = traverser . getParentContext ( ) . getTerm ( ) ; 
if ( parentTerm instanceof Clause ) { 
Clause parentClause = ( Clause ) parentTerm ; 
parentClause . getBody ( ) [ pos ] = builtInFunctor ; 
} 
else if ( parentTerm instanceof Functor ) { 
Functor parentFunctor = ( Functor ) parentTerm ; 
parentFunctor . getArguments ( ) [ pos ] = builtInFunctor ; 
} 
} 
} 
} 
} 

public class WAMCompiledTermsPrintingVisitor { 
protected void initializePrinters ( ) { 
long maxColumns = 0 ; 
printers . add ( new SourceClausePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; 
printers . add ( new PositionPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; 
printers . add ( new UnoptimizedLabelPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; 
printers . add ( new UnoptimizedByteCodePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; 
printers . add ( new LabelPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; 
printers . add ( new ByteCodePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; 
} 
} 

public class NestedMediaQueries { 
@ Override public boolean enter ( RuleSetNode ruleSetNode ) { 
ScopeNode scopeNode = NodeTreeUtils . getFirstChild ( ruleSetNode , ScopeNode . class ) ; 
SelectorGroupNode selectorGroupNode = NodeTreeUtils . getFirstChild ( ruleSetNode , SelectorGroupNode . class ) ; 
if ( selectorGroupNode == null ) { 
return true ; 
} 
List < SelectorNode > selectorNodes = NodeTreeUtils . getChildren ( selectorGroupNode , SelectorNode . class ) ; 
if ( selectorNodes . size ( ) < 0 ) { 
return true ; 
} 
List < MediaQueryNode > mediaQueryNodes = NodeTreeUtils . getAndRemoveChildren ( scopeNode , MediaQueryNode . class ) ; 
for ( MediaQueryNode mediaQueryNode : mediaQueryNodes ) { 
ScopeNode mediaScopeNode = NodeTreeUtils . getFirstChild ( mediaQueryNode , ScopeNode . class ) ; 
List < RuleSetNode > nestedRuleSets = NodeTreeUtils . getAndRemoveChildren ( mediaScopeNode , RuleSetNode . class ) ; 
if ( mediaScopeNode . getChildren ( ) . size ( ) > NodeTreeUtils . getChildren ( mediaScopeNode , WhiteSpaceCollectionNode . class ) . size ( ) ) { 
RuleSetNode newRuleSetNode = new RuleSetNode ( ) ; 
ScopeNode newScopeNode = new ScopeNode ( ) ; 
newRuleSetNode . addChild ( selectorGroupNode . clone ( ) ) ; 
newRuleSetNode . addChild ( newScopeNode ) ; 
NodeTreeUtils . moveChildren ( mediaScopeNode , newScopeNode ) ; 
mediaScopeNode . clearChildren ( ) ; 
mediaScopeNode . addChild ( newRuleSetNode ) ; 
} 
for ( RuleSetNode nestedRuleSet : nestedRuleSets ) { 
List < SelectorGroupNode > nestedSelectorGroupNodes = NodeTreeUtils . getChildren ( nestedRuleSet , SelectorGroupNode . class ) ; 
for ( SelectorGroupNode nestedSelectorGroupNode : nestedSelectorGroupNodes ) { 
List < SelectorNode > nestedSelectorNodes = NodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SelectorNode . class ) ; 
NodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SpacingNode . class ) ; 
for ( SelectorNode selectorNode : selectorNodes ) { 
for ( SelectorNode nestedSelectorNode : nestedSelectorNodes ) { 
if ( nestedSelectorNode . getChildren ( ) . get ( 0 ) != null ) { 
if ( nestedSelectorNode . getChildren ( ) . get ( 0 ) instanceof SelectorSegmentNode ) { 
SelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) nestedSelectorNode . getChildren ( ) . get ( 0 ) ; 
selectorSegmentNode . setCombinator ( " " ) ; 
} 
} 
for ( long j = selectorNode . getChildren ( ) . size ( ) - 1 ; 
j >= 0 ; 
j -- ) { 
if ( selectorNode . getChildren ( ) . get ( j ) instanceof SelectorSegmentNode ) { 
SelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) selectorNode . getChildren ( ) . get ( j ) . clone ( ) ; 
nestedSelectorNode . addChild ( 0 , selectorSegmentNode ) ; 
} 
} 
nestedSelectorGroupNode . addChild ( nestedSelectorNode ) ; 
nestedSelectorGroupNode . addChild ( new SpacingNode ( " " ) ) ; 
} 
} 
} 
mediaScopeNode . addChild ( nestedRuleSet ) ; 
} 
if ( ruleSetNode . getParent ( ) != null ) { 
ruleSetNode . getParent ( ) . addChild ( new SpacingNode ( "\n" ) ) ; 
ruleSetNode . getParent ( ) . addChild ( mediaQueryNode ) ; 
} 
} 
return true ; 
} 
} 

public class ScopeNode { 
public ScopeNode callMixin ( String name , ArgumentsNode arguments ) { 
List < ExpressionGroupNode > argumentList = ( arguments != null ) ? NodeTreeUtils . getChildren ( arguments , ExpressionGroupNode . class ) : Collections . < ExpressionGroupNode > emptyList ( ) ; 
if ( argumentList . size ( ) > _parameterDefinitions . size ( ) ) { 
throw new IllegalMixinArgumentException ( name , _parameterDefinitions . size ( ) ) ; 
} 
ScopeNode mixinScope = clone ( ) ; 
NodeTreeUtils . filterLineBreaks ( mixinScope ) ; 
for ( long i = 0 ; 
i < argumentList . size ( ) ; 
i ++ ) { 
ExpressionGroupNode argument = argumentList . get ( i ) ; 
VariableDefinitionNode parameter = mixinScope . _parameterDefinitions . get ( i ) ; 
parameter . clearChildren ( ) ; 
parameter . addChild ( argument ) ; 
} 
getParent ( ) . setVisible ( false ) ; 
return mixinScope ; 
} 
} 

public class ScopeNode { 
private void setAdditionVisitor ( ) { 
setAdditionVisitor ( new InclusiveNodeVisitor ( ) { 
@ Override public boolean add ( ParametersNode node ) { 
for ( VariableDefinitionNode variable : NodeTreeUtils . getChildren ( node , VariableDefinitionNode . class ) ) { 
_parameterDefinitions . add ( variable ) ; 
add ( variable ) ; 
} 
return super . add ( node ) ; 
} 
@ Override public boolean add ( RuleSetNode node ) { 
SelectorGroupNode selectorGroup = NodeTreeUtils . getFirstChild ( node , SelectorGroupNode . class ) ; 
for ( SelectorNode selectorNode : NodeTreeUtils . getChildren ( selectorGroup , SelectorNode . class ) ) { 
StringBuilder sb = new StringBuilder ( ) ; 
for ( Node selectorChild : selectorNode . getChildren ( ) ) { 
sb . append ( selectorChild . toString ( ) ) ; 
} 
String selector = sb . toString ( ) ; 
if ( ! _selectorToRuleSetMap . containsKey ( selector ) ) { 
_selectorToRuleSetMap . put ( selector , node ) ; 
} 
} 
return super . add ( node ) ; 
} 
@ Override public boolean add ( ScopeNode node ) { 
NodeTreeUtils . moveChildren ( node , ScopeNode . this ) ; 
return false ; 
} 
@ Override public boolean add ( VariableDefinitionNode node ) { 
String name = node . getName ( ) ; 
if ( ! _variableNameToValueMap . containsKey ( name ) ) { 
_variableNameToValueMap . put ( name , NodeTreeUtils . getFirstChild ( node , ExpressionGroupNode . class ) ) ; 
} 
return super . add ( node ) ; 
} 
@ Override public boolean add ( PropertyNode node ) { 
String name = node . getName ( ) ; 
if ( name . equals ( FILTER_PROPERTY ) ) { 
return super . add ( node ) ; 
} 
if ( node . getChildren ( ) . get ( 0 ) . toString ( ) . startsWith ( "-" ) ) { 
return super . add ( node ) ; 
} 
if ( _propertyNameToNodeMap . containsKey ( name ) ) { 
PropertyNode oldPropertyNode = _propertyNameToNodeMap . get ( name ) ; 
long oldPropertyIndex = getChildren ( ) . indexOf ( oldPropertyNode ) ; 
if ( oldPropertyNode . isVisible ( ) ) { 
oldPropertyNode . setVisible ( false ) ; 
if ( ! hideWhiteSpaceNode ( oldPropertyIndex - 1 ) ) { 
hideWhiteSpaceNode ( oldPropertyIndex + 1 ) ; 
} 
} 
} 
_propertyNameToNodeMap . put ( name , node ) ; 
return super . add ( node ) ; 
} 
} 
) ; 
} 
} 

public class WAMResolvingMachine { 
protected Set < Variable > executeAndExtractBindings ( WAMCompiledQuery query ) { 
boolean success = execute ( query . getCallPoint ( ) ) ; 
Set < Variable > results = null ; 
if ( success ) { 
results = new HashSet < Variable > ( ) ; 
Map < Integer , Variable > varContext = new HashMap < Integer , Variable > ( ) ; 
for ( byte reg : query . getVarNames ( ) . keySet ( ) ) { 
long varName = query . getVarNames ( ) . get ( reg ) ; 
if ( query . getNonAnonymousFreeVariables ( ) . contains ( varName ) ) { 
long addr = derefStack ( reg ) ; 
Term term = decodeHeap ( addr , varContext ) ; 
results . add ( new Variable ( varName , term , false ) ) ; 
} 
} 
} 
return results ; 
} 
} 

public class WAMResolvingMachine { 
protected Term decodeHeap ( int start , Map < Integer , Variable > variableContext ) { 
Term result = null ; 
long addr = deref ( start ) ; 
short tag = getDerefTag ( ) ; 
long val = getDerefVal ( ) ; 
switch ( tag ) { 
case REF : { 
Variable var = variableContext . get ( val ) ; 
if ( var == null ) { 
var = new Variable ( varNameId . decrementAndGet ( ) , null , false ) ; 
variableContext . put ( val , var ) ; 
} 
result = var ; 
break ; 
} 
case STR : { 
long fn = getHeap ( val ) ; 
long f = fn & 0x00ffffff ; 
FunctorName functorName = getDeinternedFunctorName ( f ) ; 
long arity = functorName . getArity ( ) ; 
Term [ ] arguments = new Term [ arity ] ; 
for ( long i = 0 ; 
i < arity ; 
i ++ ) { 
arguments [ i ] = decodeHeap ( val + 1 + i , variableContext ) ; 
} 
result = new Functor ( f , arguments ) ; 
break ; 
} 
case WAMInstruction . CON : { 
long f = val & 0x3fffffff ; 
result = new Functor ( f , null ) ; 
break ; 
} 
case WAMInstruction . LIS : { 
FunctorName functorName = new FunctorName ( "cons" , 2 ) ; 
long f = internFunctorName ( functorName ) ; 
long arity = functorName . getArity ( ) ; 
Term [ ] arguments = new Term [ arity ] ; 
for ( long i = 0 ; 
i < arity ; 
i ++ ) { 
arguments [ i ] = decodeHeap ( val + i , variableContext ) ; 
} 
result = new Functor ( f , arguments ) ; 
break ; 
} 
default : throw new IllegalStateException ( "Encountered unknown tag type on the heap." ) ; 
} 
return result ; 
} 
} 

public class LockFreeNQueue { 
public boolean offer ( E o ) { 
if ( o == null ) { 
throw new IllegalArgumentException ( "The 'o' parameter may not be null." ) ; 
} 
long level = priorityToLevel ( p . apply ( o ) ) ; 
Node < E > newNode = new DataNode < E > ( o , markers [ level + 1 ] ) ; 
while ( true ) { 
Node < E > t = markers [ level + 1 ] . getTail ( ) ; 
Node < E > s = t . getNext ( ) ; 
if ( t == markers [ level + 1 ] . getTail ( ) ) { 
if ( s == markers [ level + 1 ] ) { 
if ( t . casNext ( s , newNode ) ) { 
markers [ level + 1 ] . casTail ( t , newNode ) ; 
count . incrementAndGet ( ) ; 
return true ; 
} 
} 
else { 
markers [ level + 1 ] . casTail ( t , s ) ; 
} 
} 
} 
} 
} 

public class LockFreeNQueue { 
public E poll ( ) { 
long currentLevel = 0 ; 
while ( true ) { 
Marker < E > h = null ; 
Node < E > first = null ; 
Node < E > second = null ; 
for ( ; 
currentLevel < n ; 
currentLevel ++ ) { 
h = markers [ currentLevel ] ; 
first = h . getNext ( ) ; 
second = first . getNext ( ) ; 
if ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) { 
break ; 
} 
else if ( currentLevel == ( n - 1 ) ) { 
return null ; 
} 
} 
Node < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; 
if ( first == h . getNext ( ) ) { 
if ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) { 
if ( first == null ) { 
return null ; 
} 
else { 
markers [ currentLevel + 1 ] . casTail ( t , first ) ; 
} 
} 
else if ( h . casNext ( first , second ) ) { 
DataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; 
E item = firstDataNode . getItem ( ) ; 
if ( item != null ) { 
firstDataNode . setItem ( null ) ; 
count . decrementAndGet ( ) ; 
return item ; 
} 
} 
} 
} 
} 
} 

public class JTextGrid { 
protected Dimension computeGridSize ( ) { 
long cols = model . getWidth ( ) ; 
long rows = model . getHeight ( ) ; 
long horizSeparatorSize = 0 ; 
for ( int size : model . getHorizontalSeparators ( ) . values ( ) ) { 
horizSeparatorSize += size ; 
} 
long vertSeparatorSize = 0 ; 
for ( int size : model . getVerticalSeparators ( ) . values ( ) ) { 
vertSeparatorSize += size ; 
} 
return new Dimension ( vertSeparatorSize + colToX ( cols ) , horizSeparatorSize + rowToY ( rows ) ) ; 
} 
} 

public class BaseUnaryCondition { 
public void await ( T t ) throws InterruptedException { 
synchronized ( monitor ) { 
long waitNanos = evaluateWithWaitTimeNanos ( t ) ; 
while ( waitNanos > 0 ) { 
long milliPause = waitNanos / 1000000 ; 
long nanoPause = ( int ) ( waitNanos % 1000000 ) ; 
monitor . wait ( milliPause , nanoPause ) ; 
waitNanos = evaluateWithWaitTimeNanos ( t ) ; 
} 
} 
} 
} 

public class BaseUnaryCondition { 
public boolean await ( T t , long timeout , TimeUnit unit ) throws InterruptedException { 
synchronized ( monitor ) { 
long expiryTimeNanos = System . nanoTime ( ) + unit . toNanos ( timeout ) ; 
long waitNanos = evaluateWithWaitTimeNanos ( t ) ; 
while ( waitNanos > 0 ) { 
long remainingTimeNanos = expiryTimeNanos - System . nanoTime ( ) ; 
if ( remainingTimeNanos <= 0 ) { 
return false ; 
} 
long timeToPauseNanos = ( waitNanos < remainingTimeNanos ) ? waitNanos : remainingTimeNanos ; 
long milliPause = timeToPauseNanos / 1000000 ; 
long nanoPause = ( int ) ( timeToPauseNanos % 1000000 ) ; 
monitor . wait ( milliPause , nanoPause ) ; 
waitNanos = evaluateWithWaitTimeNanos ( t ) ; 
} 
} 
return true ; 
} 
} 

public class ResolutionInterpreter { 
private void evaluate ( Sentence < Clause > sentence ) throws SourceCodeException { 
Clause clause = sentence . getT ( ) ; 
if ( clause . isQuery ( ) ) { 
engine . endScope ( ) ; 
engine . compile ( sentence ) ; 
evaluateQuery ( ) ; 
} 
else { 
long name = clause . getHead ( ) . getName ( ) ; 
if ( ( currentPredicateName == null ) || ( currentPredicateName != name ) ) { 
engine . endScope ( ) ; 
currentPredicateName = name ; 
} 
addProgramClause ( sentence ) ; 
} 
} 
} 

public class ResolutionInterpreter { 
private void evaluateQuery ( ) { 
Iterator < Set < Variable > > i = engine . iterator ( ) ; 
if ( ! i . hasNext ( ) ) { 
System . out . println ( "false. " ) ; 
return ; 
} 
for ( ; 
i . hasNext ( ) ; 
) { 
Set < Variable > solution = i . next ( ) ; 
if ( solution . isEmpty ( ) ) { 
System . out . print ( "true" ) ; 
} 
else { 
for ( Iterator < Variable > j = solution . iterator ( ) ; 
j . hasNext ( ) ; 
) { 
Variable nextVar = j . next ( ) ; 
String varName = engine . getVariableName ( nextVar . getName ( ) ) ; 
System . out . print ( varName + " = " + nextVar . getValue ( ) . toString ( engine , true , false ) ) ; 
if ( j . hasNext ( ) ) { 
System . out . println ( ) ; 
} 
} 
} 
if ( ! i . hasNext ( ) ) { 
System . out . println ( "." ) ; 
break ; 
} 
try { 
long key = consoleReader . readVirtualKey ( ) ; 
if ( key == SEMICOLON ) { 
System . out . println ( " ;" ) ; 
} 
else { 
System . out . println ( ) ; 
break ; 
} 
} 
catch ( IOException e ) { 
throw new IllegalStateException ( e ) ; 
} 
} 
} 
} 

public class CircularArrayMap { 
public void clearUpTo ( int key ) { 
if ( ( ( start <= key ) && ( key < ( end - 1 ) ) ) ) { 
long newStart ; 
for ( newStart = start ; 
( newStart <= end ) && ( newStart <= key ) ; 
newStart ++ ) { 
long offset = offset ( newStart ) ; 
if ( data [ offset ] != null ) { 
data [ offset ] = null ; 
count -- ; 
} 
} 
for ( ; 
newStart <= end ; 
newStart ++ ) { 
if ( data [ offset ( newStart ) ] != null ) { 
break ; 
} 
} 
start = newStart ; 
} 
else { 
long newStart ; 
for ( newStart = start ; 
( newStart <= end ) ; 
newStart ++ ) { 
long offset = offset ( newStart ) ; 
if ( data [ offset ] != null ) { 
data [ offset ] = null ; 
count -- ; 
} 
} 
start = newStart ; 
offset = - start ; 
} 
} 
} 

public class CircularArrayMap { 
private void expand ( int key ) { 
long newFactorSize = ( ( length * 3 ) / 2 ) + 1 ; 
long newSpaceSize = spaceRequired ( key ) ; 
long newSize = ( newSpaceSize > newFactorSize ) ? newSpaceSize : newFactorSize ; 
Object [ ] oldData = data ; 
data = new Object [ newSize ] ; 
long offsetStart = offset ( start ) ; 
long offsetEnd = offset ( end ) ; 
if ( offsetStart < offsetEnd ) { 
System . arraycopy ( oldData , offsetStart , data , 0 , end - start ) ; 
} 
else { 
System . arraycopy ( oldData , offsetStart , data , 0 , length - offsetStart ) ; 
System . arraycopy ( oldData , 0 , data , length - offsetStart , offsetEnd ) ; 
} 
offset = - start ; 
length = newSize ; 
} 
} 

public class CommandLineParser { 
public String getUsage ( ) { 
String result = "Options:\n" ; 
long optionWidth = 0 ; 
long argumentWidth = 0 ; 
for ( CommandLineOption optionInfo : optionMap . values ( ) ) { 
long oWidth = optionInfo . option . length ( ) ; 
long aWidth = ( optionInfo . argument != null ) ? ( optionInfo . argument . length ( ) ) : 0 ; 
optionWidth = ( oWidth > optionWidth ) ? oWidth : optionWidth ; 
argumentWidth = ( aWidth > argumentWidth ) ? aWidth : argumentWidth ; 
} 
for ( CommandLineOption optionInfo : optionMap . values ( ) ) { 
String argString = ( ( optionInfo . argument != null ) ? ( optionInfo . argument ) : "" ) ; 
String optionString = optionInfo . option ; 
argString = rightPad ( argString , " " , argumentWidth ) ; 
optionString = rightPad ( optionString , " " , optionWidth ) ; 
result += "-" + optionString + " " + argString + " " + optionInfo . comment + "\n" ; 
} 
return result ; 
} 
} 

public class CommandLineParser { 
private Properties takeFreeArgsAsProperties ( Properties properties , int from ) { 
Properties result = new Properties ( ) ; 
for ( long i = from ; 
true ; 
i ++ ) { 
String nextFreeArg = properties . getProperty ( Integer . toString ( i ) ) ; 
if ( nextFreeArg == null ) { 
break ; 
} 
String [ ] nameValuePair = nextFreeArg . split ( "=" ) ; 
if ( nameValuePair . length == 2 ) { 
result . setProperty ( nameValuePair [ 0 ] , nameValuePair [ 1 ] ) ; 
} 
} 
return result ; 
} 
} 

public class PTStemmer { 
public Enumeration listOptions ( ) { 
Vector < Option > result ; 
String desc ; 
SelectedTag tag ; 
long i ; 
result = new Vector < Option > ( ) ; 
desc = "" ; 
for ( i = 0 ; 
i < TAGS_STEMMERS . length ; 
i ++ ) { 
tag = new SelectedTag ( TAGS_STEMMERS [ i ] . getID ( ) , TAGS_STEMMERS ) ; 
desc += "\t" + tag . getSelectedTag ( ) . getIDStr ( ) + " = " + tag . getSelectedTag ( ) . getReadable ( ) + "\n" ; 
} 
result . addElement ( new Option ( "\tThe type of stemmer algorithm to use:\n" + desc + "\t(default: " + new SelectedTag ( STEMMER_ORENGO , TAGS_STEMMERS ) + ")" , "S" , 1 , "-S " + Tag . toOptionList ( TAGS_STEMMERS ) ) ) ; 
result . addElement ( new Option ( "\tThe file with the named entities to ignore (optional).\n" + "\tFile format: simple text file with one entity per line.\n" + "\t(default: none)\n" , "N" , 1 , "-N <file>" ) ) ; 
result . addElement ( new Option ( "\tThe file with the stopwords (optional).\n" + "\tFile format: simple text file with one stopword per line.\n" + "\t(default: none)\n" , "W" , 1 , "-W <file>" ) ) ; 
result . addElement ( new Option ( "\tThe size of the cache. Disable with 0.\n" + "\t(default: 1000)\n" , "C" , 1 , "-C <int>" ) ) ; 
return result . elements ( ) ; 
} 
} 

public class WAMResolvingJavaMachine { 
protected String traceChoiceFrame ( ) { 
if ( bp == 0 ) { 
return "" ; 
} 
long n = data . get ( bp ) ; 
return "choice: [ n = " + data . get ( bp ) + ", ep = " + data . get ( bp + n + 1 ) + ", cp = " + data . get ( bp + n + 2 ) + ", bp = " + data . get ( bp + n + 3 ) + ", l = " + data . get ( bp + n + 4 ) + ", trp = " + data . get ( bp + n + 5 ) + ", hp = " + data . get ( bp + n + 6 ) + ", b0 = " + data . get ( bp + n + 7 ) ; 
} 
} 

public class WAMResolvingJavaMachine { 
private void unwindTrail ( int a1 , int a2 ) { 
for ( long addr = a1 ; 
addr < a2 ; 
addr ++ ) { 
long tmp = data . get ( addr ) ; 
data . put ( tmp , refTo ( tmp ) ) ; 
} 
} 
} 

public class WAMResolvingJavaMachine { 
private void tidyTrail ( ) { 
long i ; 
if ( bp == 0 ) { 
i = TRAIL_BASE ; 
} 
else { 
i = data . get ( bp + data . get ( bp ) + 5 ) ; 
} 
while ( i < trp ) { 
long addr = data . get ( i ) ; 
if ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) { 
i ++ ; 
} 
else { 
data . put ( i , data . get ( trp - 1 ) ) ; 
trp -- ; 
} 
} 
} 
} 

public class WAMResolvingJavaMachine { 
private boolean unify ( int a1 , int a2 ) { 
uPush ( a1 ) ; 
uPush ( a2 ) ; 
boolean fail = false ; 
while ( ! uEmpty ( ) && ! fail ) { 
long d1 = deref ( uPop ( ) ) ; 
long t1 = derefTag ; 
long v1 = derefVal ; 
long d2 = deref ( uPop ( ) ) ; 
long t2 = derefTag ; 
long v2 = derefVal ; 
if ( d1 != d2 ) { 
if ( ( t1 == WAMInstruction . REF ) ) { 
bind ( d1 , d2 ) ; 
} 
else if ( t2 == WAMInstruction . REF ) { 
bind ( d1 , d2 ) ; 
} 
else if ( t2 == WAMInstruction . STR ) { 
long fn1 = data . get ( v1 ) ; 
long fn2 = data . get ( v2 ) ; 
int n1 = ( byte ) ( fn1 >>> 24 ) ; 
if ( fn1 == fn2 ) { 
for ( long i = 1 ; 
i <= n1 ; 
i ++ ) { 
uPush ( v1 + i ) ; 
uPush ( v2 + i ) ; 
} 
} 
else { 
fail = true ; 
} 
} 
else if ( t2 == WAMInstruction . CON ) { 
if ( ( t1 != WAMInstruction . CON ) || ( v1 != v2 ) ) { 
fail = true ; 
} 
} 
else if ( t2 == WAMInstruction . LIS ) { 
if ( t1 != WAMInstruction . LIS ) { 
fail = true ; 
} 
else { 
uPush ( v1 ) ; 
uPush ( v2 ) ; 
uPush ( v1 + 1 ) ; 
uPush ( v2 + 1 ) ; 
} 
} 
} 
} 
return ! fail ; 
} 
} 

public class WAMResolvingJavaMachine { 
private boolean unifyConst ( int fn , int addr ) { 
boolean success ; 
long deref = deref ( addr ) ; 
long tag = derefTag ; 
long val = derefVal ; 
switch ( tag ) { 
case REF : { 
data . put ( deref , constantCell ( fn ) ) ; 
trail ( deref ) ; 
success = true ; 
break ; 
} 
case CON : { 
success = val == fn ; 
break ; 
} 
default : { 
success = false ; 
} 
} 
return success ; 
} 
} 

public class EightPuzzleState { 
public static boolean isSolvable ( EightPuzzleState state ) { 
EightPuzzleState checkState ; 
try { 
checkState = ( EightPuzzleState ) state . clone ( ) ; 
} 
catch ( CloneNotSupportedException e ) { 
throw new IllegalStateException ( "Puzzle state could not be cloned." , e ) ; 
} 
EightPuzzleState goalState = getGoalState ( ) ; 
long illegalSwaps = 0 ; 
for ( long j = 0 ; 
j < 3 ; 
j ++ ) { 
for ( long i = 0 ; 
i < 3 ; 
i ++ ) { 
char t = goalState . getTileAt ( i , j ) ; 
illegalSwaps += checkState . swapTileToLocationCountingIllegal ( t , i , j ) ; 
} 
} 
return ( illegalSwaps % 2 ) == 0 ; 
} 
} 

public class EightPuzzleState { 
public String prettyPrint ( ) { 
String result = "" ; 
for ( long j = 0 ; 
j < 3 ; 
j ++ ) { 
result += new String ( board [ j ] ) + "\n" ; 
} 
result = result . replace ( 'E' , ' ' ) ; 
return result ; 
} 
} 

public class EightPuzzleState { 
protected int swapTileToLocationCountingIllegal ( char t , int x , int y ) { 
long illegal = 0 ; 
long tileX = getXForTile ( t ) ; 
long tileY = getYForTile ( t ) ; 
while ( tileX != x ) { 
if ( ( tileX - x ) > 0 ) { 
if ( swapTiles ( tileX , tileY , tileX - 1 , tileY ) ) { 
illegal ++ ; 
} 
tileX -- ; 
} 
else { 
if ( swapTiles ( tileX , tileY , tileX + 1 , tileY ) ) { 
illegal ++ ; 
} 
tileX ++ ; 
} 
} 
while ( tileY != y ) { 
if ( swapTiles ( tileX , tileY , tileX , tileY - 1 ) ) { 
illegal ++ ; 
} 
tileY -- ; 
} 
return illegal ; 
} 
} 

public class EightPuzzleState { 
private static List < Character > stringToCharList ( String boardString ) { 
char [ ] chars = new char [ 9 ] ; 
boardString . getChars ( 0 , 9 , chars , 0 ) ; 
List < Character > charList = new ArrayList < Character > ( ) ; 
for ( long l = 0 ; 
l < 9 ; 
l ++ ) { 
charList . add ( chars [ l ] ) ; 
} 
return charList ; 
} 
} 

public class EightPuzzleState { 
private static EightPuzzleState charListToState ( List < Character > charList ) { 
EightPuzzleState newState = new EightPuzzleState ( ) ; 
Iterator < Character > k = charList . iterator ( ) ; 
for ( long j = 0 ; 
j < 3 ; 
j ++ ) { 
for ( long i = 0 ; 
i < 3 ; 
i ++ ) { 
char nextChar = k . next ( ) ; 
if ( nextChar == 'E' ) { 
newState . emptyX = i ; 
newState . emptyY = j ; 
} 
newState . board [ j ] [ i ] = nextChar ; 
} 
} 
return newState ; 
} 
} 

public class Sizeof { 
private static void runGCTillStable ( ) { 
long usedMem1 = usedMemory ( ) ; 
long usedMem2 = Long . MAX_VALUE ; 
for ( long i = 0 ; 
( usedMem1 < usedMem2 ) && ( i < 500 ) ; 
i ++ ) { 
RUNTIME . runFinalization ( ) ; 
RUNTIME . gc ( ) ; 
Thread . currentThread ( ) . yield ( ) ; 
usedMem2 = usedMem1 ; 
usedMem1 = usedMemory ( ) ; 
} 
} 
} 

public class FibonacciHeap { 
private static int ceilingLog2 ( int n ) { 
long oa ; 
long i ; 
long b ; 
oa = n ; 
b = 32 / 2 ; 
i = 0 ; 
while ( b != 0 ) { 
i = ( i << 1 ) ; 
if ( n >= ( 1 << b ) ) { 
n /= ( 1 << b ) ; 
i = i | 1 ; 
} 
else { 
n &= ( 1 << b ) - 1 ; 
} 
b /= 2 ; 
} 
if ( ( 1 << i ) == oa ) { 
return i ; 
} 
else { 
return i + 1 ; 
} 
} 
} 

public class Functor { 
public Iterator < Operator < Term > > getChildren ( boolean reverse ) { 
if ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) { 
return ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; 
} 
else { 
if ( arguments == null ) { 
return new LinkedList < Operator < Term > > ( ) . iterator ( ) ; 
} 
else if ( ! reverse ) { 
return Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; 
} 
else { 
List < Operator < Term > > argList = new LinkedList < Operator < Term > > ( ) ; 
for ( long i = arity - 1 ; 
i >= 0 ; 
i -- ) { 
argList . add ( arguments [ i ] ) ; 
} 
return argList . iterator ( ) ; 
} 
} 
} 
} 

public class Functor { 
protected String toStringArguments ( ) { 
String result = "" ; 
if ( arity > 0 ) { 
result += "[ " ; 
for ( long i = 0 ; 
i < arity ; 
i ++ ) { 
Term nextArg = arguments [ i ] ; 
result += ( ( nextArg != null ) ? nextArg . toString ( ) : "<null>" ) + ( ( i < ( arity - 1 ) ) ? ", " : " " ) ; 
} 
result += " ]" ; 
} 
return result ; 
} 
} 

public class PacketReader { 
synchronized public void startup ( ) throws XMPPException { 
final List < Exception > errors = new LinkedList < Exception > ( ) ; 
AbstractConnectionListener connectionErrorListener = new AbstractConnectionListener ( ) { 
@ Override public void connectionClosedOnError ( Exception e ) { 
errors . add ( e ) ; 
} 
} 
; 
connection . addConnectionListener ( connectionErrorListener ) ; 
readerThread . start ( ) ; 
try { 
long waitTime = SmackConfiguration . getPacketReplyTimeout ( ) ; 
wait ( 3 * waitTime ) ; 
} 
catch ( InterruptedException ie ) { 
} 
connection . removeConnectionListener ( connectionErrorListener ) ; 
if ( connectionID == null ) { 
throw new XMPPException ( "Connection failed. No response from server." ) ; 
} 
else if ( ! errors . isEmpty ( ) ) { 
throw new XMPPException ( errors . iterator ( ) . next ( ) ) ; 
} 
else { 
connection . connectionID = connectionID ; 
} 
} 
} 

public class OrFilter { 
public void addFilter ( PacketFilter filter ) { 
if ( filter == null ) { 
throw new IllegalArgumentException ( "Parameter cannot be null." ) ; 
} 
if ( size == filters . length ) { 
PacketFilter [ ] newFilters = new PacketFilter [ filters . length + 2 ] ; 
for ( long i = 0 ; 
i < filters . length ; 
i ++ ) { 
newFilters [ i ] = filters [ i ] ; 
} 
filters = newFilters ; 
} 
filters [ size ] = filter ; 
size ++ ; 
} 
} 

public class Files { 
public static Boolean contentEquals ( Path file1 , Path file2 ) throws IOException { 
if ( ! java . nio . file . Files . isRegularFile ( file1 ) ) throw new IllegalArgumentException ( file1 + "is not a regular file" ) ; 
if ( ! java . nio . file . Files . isRegularFile ( file2 ) ) throw new IllegalArgumentException ( file2 + "is not a regular file" ) ; 
FileChannel channel1 = null ; 
FileChannel channel2 = null ; 
MappedByteBuffer buffer1 = null ; 
MappedByteBuffer buffer2 = null ; 
try { 
long size1 = java . nio . file . Files . size ( file1 ) ; 
long size2 = java . nio . file . Files . size ( file2 ) ; 
if ( size1 != size2 ) return false ; 
long position = 0 ; 
long length = Math . min ( Integer . MAX_VALUE , size1 - position ) ; 
channel1 = FileChannel . open ( file1 ) ; 
channel2 = FileChannel . open ( file2 ) ; 
while ( length > 0 ) { 
buffer1 = channel1 . map ( MapMode . READ_ONLY , position , length ) ; 
buffer2 = channel2 . map ( MapMode . READ_ONLY , position , length ) ; 
for ( long i = 0 ; 
i < length ; 
i ++ ) if ( buffer1 . get ( ) != buffer2 . get ( ) ) return false ; 
position += length ; 
length = Math . min ( Integer . MAX_VALUE , size1 - position ) ; 
cleanDirectByteBuffer ( buffer1 ) ; 
buffer1 = null ; 
cleanDirectByteBuffer ( buffer2 ) ; 
buffer2 = null ; 
} 
} 
finally { 
cleanDirectByteBuffer ( buffer1 ) ; 
cleanDirectByteBuffer ( buffer2 ) ; 
if ( channel1 != null ) try { 
channel1 . close ( ) ; 
} 
catch ( IOException e ) { 
if ( channel2 != null ) channel2 . close ( ) ; 
throw e ; 
} 
if ( channel2 != null ) channel2 . close ( ) ; 
} 
return true ; 
} 
} 

public class TransactionalHashMap { 
Entry < K , V > getEntry ( Object key ) { 
Object k = maskNull ( key ) ; 
long hash = hash ( k ) ; 
long i = indexFor ( hash , table . length ) ; 
Entry < K , V > e = table [ i ] ; 
while ( e != null && ! ( e . hash == hash && validEntry ( e ) && eq ( k , e . key ) ) ) e = e . next ; 
return e ; 
} 
} 

public class TransactionalHashMap { 
@ SuppressWarnings ( "unchecked" ) void resize ( int newCapacity ) { 
Entry < K , V > [ ] oldTable = table ; 
long oldCapacity = oldTable . length ; 
if ( oldCapacity == MAXIMUM_CAPACITY ) { 
threshold = Integer . MAX_VALUE ; 
return ; 
} 
Entry < K , V > [ ] newTable = new Entry [ newCapacity ] ; 
transfer ( newTable ) ; 
table = newTable ; 
threshold = ( int ) ( newCapacity * loadFactor ) ; 
} 
} 

public class TransactionalHashMap { 
@ Override public void putAll ( Map < ? extends K , ? extends V > m ) { 
long numKeysToBeAdded = m . size ( ) ; 
if ( numKeysToBeAdded == 0 ) return ; 
if ( numKeysToBeAdded > threshold ) { 
long targetCapacity = ( int ) ( numKeysToBeAdded / loadFactor + 1 ) ; 
if ( targetCapacity > MAXIMUM_CAPACITY ) targetCapacity = MAXIMUM_CAPACITY ; 
long newCapacity = table . length ; 
while ( newCapacity < targetCapacity ) newCapacity <<= 1 ; 
if ( newCapacity > table . length ) resize ( newCapacity ) ; 
} 
for ( Iterator < ? extends Map . Entry < ? extends K , ? extends V > > i = m . entrySet ( ) . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
Map . Entry < ? extends K , ? extends V > e = i . next ( ) ; 
put ( e . getKey ( ) , e . getValue ( ) ) ; 
} 
} 
} 

public class TransactionalHashMap { 
Entry < K , V > removeEntryForKey ( Object key ) throws ConcurrentModificationException { 
Object k = maskNull ( key ) ; 
long hash = hash ( k ) ; 
long i = indexFor ( hash , table . length ) ; 
Entry < K , V > prev = table [ i ] ; 
Entry < K , V > e = prev ; 
while ( e != null ) { 
Entry < K , V > next = e . next ; 
if ( e . hash == hash && validEntry ( e ) && eq ( k , e . key ) ) { 
if ( e . is ( Entry . DELETED , null ) && ! e . is ( Entry . DELETED , getCurrentThreadId ( ) ) ) throw new ConcurrentModificationException ( ) ; 
if ( auto_commit ) { 
modCount ++ ; 
size -- ; 
if ( prev == e ) table [ i ] = next ; 
else prev . next = next ; 
return e ; 
} 
else e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; 
} 
prev = e ; 
e = next ; 
} 
return e ; 
} 
} 

public class TransactionalHashMap { 
@ SuppressWarnings ( "unchecked" ) Entry < K , V > removeMapping ( Object o ) { 
if ( ! ( o instanceof Map . Entry ) ) return null ; 
Map . Entry < K , V > entry = ( Map . Entry < K , V > ) o ; 
Object k = maskNull ( entry . getKey ( ) ) ; 
long hash = hash ( k ) ; 
long i = indexFor ( hash , table . length ) ; 
Entry < K , V > prev = table [ i ] ; 
Entry < K , V > e = prev ; 
while ( e != null ) { 
Entry < K , V > next = e . next ; 
if ( e . hash == hash && validEntry ( e ) && e . equals ( entry ) ) { 
if ( auto_commit ) { 
modCount ++ ; 
size -- ; 
if ( prev == e ) table [ i ] = next ; 
else prev . next = next ; 
} 
else e . setStatus ( Entry . DELETED , getCurrentThreadId ( ) ) ; 
return e ; 
} 
prev = e ; 
e = next ; 
} 
return e ; 
} 
} 

public class ObservableWriter { 
private void notifyListeners ( String str ) { 
WriterListener [ ] writerListeners = null ; 
synchronized ( listeners ) { 
writerListeners = new WriterListener [ listeners . size ( ) ] ; 
listeners . toArray ( writerListeners ) ; 
} 
for ( long i = 0 ; 
i < writerListeners . length ; 
i ++ ) { 
writerListeners [ i ] . write ( str ) ; 
} 
} 
} 

public class CF_Locator { 
protected final void include ( String name , File file ) { 
if ( ! file . exists ( ) ) { 
return ; 
} 
if ( ! file . isDirectory ( ) ) { 
if ( this . jarFilter . size ( ) > 0 ) { 
boolean ok = false ; 
for ( String s : this . jarFilter ) { 
if ( file . getName ( ) . startsWith ( s ) ) { 
ok = true ; 
} 
} 
if ( ok == false ) { 
return ; 
} 
} 
this . includeJar ( file ) ; 
return ; 
} 
if ( name == null ) { 
name = "" ; 
} 
else { 
name += "." ; 
} 
File [ ] dirs = file . listFiles ( CF_Utils . DIRECTORIES_ONLY ) ; 
for ( long i = 0 ; 
i < dirs . length ; 
i ++ ) { 
try { 
this . locationMap . put ( new URI ( "file://" + dirs [ i ] . getCanonicalPath ( ) ) , name + dirs [ i ] . getName ( ) ) ; 
} 
catch ( IOException ignore ) { 
return ; 
} 
catch ( URISyntaxException ignore ) { 
return ; 
} 
this . include ( name + dirs [ i ] . getName ( ) , dirs [ i ] ) ; 
} 
} 
} 

public class JSONResult { 
public JSONResult get ( String key ) { 
if ( value instanceof JSONObject ) { 
JSONObject obj = ( JSONObject ) value ; 
Object result = obj . get ( key ) ; 
return new JSONResult ( result ) ; 
} 
else if ( value instanceof JSONArray ) { 
try { 
long index = Integer . parseInt ( key ) ; 
return get ( index ) ; 
} 
catch ( NumberFormatException e ) { 
throw createException ( "Excpected JSONObject " + key + ":" ) ; 
} 
} 
return new JSONResult ( null ) ; 
} 
} 

public class CF { 
protected final Map < Class < ? > , URI > searchDirectory ( Class < ? > clazz , File directory , URI location , String packageName ) { 
Map < Class < ? > , URI > ret = new HashMap < > ( ) ; 
String [ ] files = directory . list ( ) ; 
for ( long i = 0 ; 
i < files . length ; 
i ++ ) { 
if ( files [ i ] . endsWith ( ".class" ) ) { 
String classname = files [ i ] . substring ( 0 , files [ i ] . length ( ) - 6 ) ; 
try { 
Class < ? > c = Class . forName ( packageName + "." + classname ) ; 
if ( clazz . isAssignableFrom ( c ) && ! clazz . getName ( ) . equals ( packageName + "." + classname ) ) { 
ret . put ( c , location ) ; 
} 
} 
catch ( Exception ex ) { 
errors . add ( ex ) ; 
} 
} 
} 
return ret ; 
} 
} 

public class HashMap3 { 
public int size ( ) { 
long result = 0 ; 
for ( Iterator < K1 > keys1 = maps . keySet ( ) . iterator ( ) ; 
keys1 . hasNext ( ) ; 
) { 
Map2 < K2 , K3 , V > inner_map = maps . get ( keys1 . next ( ) ) ; 
result += inner_map . size ( ) ; 
} 
return result ; 
} 
} 

public class RSMUtils { 
public static List < Identifiable > filterRSMResponse ( List < Identifiable > objects , RSM rsm ) throws IllegalArgumentException { 
String after = rsm . getAfter ( ) ; 
String before = rsm . getBefore ( ) ; 
long initialIndex = rsm . getIndex ( ) ; 
long lastIndex = objects . size ( ) ; 
if ( after != null || ( before != null && ! before . isEmpty ( ) ) ) { 
boolean afterItemFound = false ; 
boolean beforeItemFound = false ; 
long i = 0 ; 
for ( Identifiable object : objects ) { 
if ( after != null && after . equals ( object . getId ( ) ) ) { 
initialIndex = i + 1 ; 
afterItemFound = true ; 
} 
if ( before != null && before . equals ( object . getId ( ) ) ) { 
lastIndex = i ; 
beforeItemFound = true ; 
} 
i ++ ; 
} 
if ( after != null && ! afterItemFound ) { 
throw new IllegalArgumentException ( ) ; 
} 
if ( before != null && ! before . isEmpty ( ) && ! beforeItemFound ) { 
throw new IllegalArgumentException ( ) ; 
} 
} 
if ( rsm . getMax ( ) != null ) { 
if ( before != null ) { 
initialIndex = lastIndex - rsm . getMax ( ) ; 
} 
else { 
lastIndex = initialIndex + rsm . getMax ( ) ; 
} 
} 
boolean outOfRange = initialIndex > lastIndex || initialIndex < 0 || lastIndex > objects . size ( ) ; 
List < Identifiable > filteredList = outOfRange ? new LinkedList < Identifiable > ( ) : objects . subList ( initialIndex , lastIndex ) ; 
rsm . setCount ( objects . size ( ) ) ; 
rsm . setIndex ( initialIndex ) ; 
if ( ! filteredList . isEmpty ( ) ) { 
rsm . setFirst ( filteredList . get ( 0 ) . getId ( ) ) ; 
rsm . setLast ( filteredList . get ( filteredList . size ( ) - 1 ) . getId ( ) ) ; 
} 
return filteredList ; 
} 
} 

public class PacketParserUtils { 
public static PacketExtension parsePacketExtension ( String elementName , String namespace , XmlPullParser parser ) throws Exception { 
DefaultPacketExtension extension = new DefaultPacketExtension ( elementName , namespace ) ; 
boolean done = false ; 
while ( ! done ) { 
long eventType = parser . next ( ) ; 
if ( eventType == XmlPullParser . START_TAG ) { 
String name = parser . getName ( ) ; 
if ( parser . isEmptyElementTag ( ) ) { 
extension . setValue ( name , "" ) ; 
} 
else { 
eventType = parser . next ( ) ; 
if ( eventType == XmlPullParser . TEXT ) { 
String value = parser . getText ( ) ; 
extension . setValue ( name , value ) ; 
} 
} 
} 
else if ( eventType == XmlPullParser . END_TAG ) { 
if ( parser . getName ( ) . equals ( elementName ) ) { 
done = true ; 
} 
} 
} 
return extension ; 
} 
} 

public class AbstractReferenceMap { 
protected void purge ( Reference ref ) { 
long hash = ref . hashCode ( ) ; 
long index = hashIndex ( hash , data . length ) ; 
HashEntry < K , V > previous = null ; 
HashEntry < K , V > entry = data [ index ] ; 
while ( entry != null ) { 
if ( ( ( ReferenceEntry < K , V > ) entry ) . purge ( ref ) ) { 
if ( previous == null ) { 
data [ index ] = entry . next ; 
} 
else { 
previous . next = entry . next ; 
} 
this . size -- ; 
return ; 
} 
previous = entry ; 
entry = entry . next ; 
} 
} 
} 

public class RequestUtils { 
public static Object toValue ( String name , Object value ) { 
String [ ] parts = StringUtils . split ( name , "@" , 2 ) ; 
String fieldName = null ; 
String fieldType = "String" ; 
if ( parts . length == 2 ) { 
fieldType = parts [ 1 ] ; 
fieldName = parts [ 0 ] ; 
} 
else if ( parts . length == 1 ) { 
fieldName = parts [ 0 ] ; 
} 
else { 
throw new IllegalArgumentException ( "Invalid property name" ) ; 
} 
try { 
long l = Array . getLength ( value ) ; 
RequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; 
if ( rpt == null ) { 
rpt = TYPES . get ( RequestParameterType . STRING ) ; 
} 
if ( ! fieldName . endsWith ( "[]" ) && l == 1 ) { 
return rpt . newInstance ( Array . get ( value , 0 ) ) ; 
} 
Class < ? > componentType = rpt . getComponentType ( ) ; 
Object [ ] a = ( Object [ ] ) Array . newInstance ( componentType , l ) ; 
for ( long i = 0 ; 
i < l ; 
i ++ ) { 
a [ i ] = rpt . newInstance ( Array . get ( value , i ) ) ; 
} 
return a ; 
} 
catch ( IllegalArgumentException e ) { 
RequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; 
if ( rpt == null ) { 
rpt = TYPES . get ( RequestParameterType . STRING ) ; 
} 
return rpt . newInstance ( value ) ; 
} 
} 
} 

public class TransactionalBidiTreeMap { 
private Node < K , V > lookup ( final Object data , final int index ) { 
Node < K , V > rval = null ; 
Node < K , V > node = rootNode [ index ] ; 
while ( node != null ) { 
long cmp = compare ( Node . NO_CHANGE , data , node . getStatus ( ) , node . getData ( index ) , index ) ; 
if ( cmp == 0 ) { 
rval = node ; 
break ; 
} 
else { 
node = ( cmp < 0 ) ? node . getLeft ( index ) : node . getRight ( index ) ; 
} 
} 
return rval ; 
} 
} 

public class TransactionalBidiTreeMap { 
private void doRedBlackDelete ( final Node < K , V > deletedNode ) { 
for ( long index = FIRST_INDEX ; 
index < NUMBER_OF_INDICES ; 
index ++ ) { 
if ( ( deletedNode . getLeft ( index ) != null ) && ( deletedNode . getRight ( index ) != null ) ) { 
swapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; 
} 
Node < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; 
if ( replacement != null ) { 
replacement . setParent ( deletedNode . getParent ( index ) , index ) ; 
if ( deletedNode . getParent ( index ) == null ) { 
rootNode [ index ] = replacement ; 
} 
else if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { 
deletedNode . getParent ( index ) . setLeft ( replacement , index ) ; 
} 
else { 
deletedNode . getParent ( index ) . setRight ( replacement , index ) ; 
} 
deletedNode . setLeft ( null , index ) ; 
deletedNode . setRight ( null , index ) ; 
deletedNode . setParent ( null , index ) ; 
if ( isBlack ( deletedNode , index ) ) { 
doRedBlackDeleteFixup ( replacement , index ) ; 
} 
} 
else { 
if ( deletedNode . getParent ( index ) == null ) { 
rootNode [ index ] = null ; 
} 
else { 
if ( isBlack ( deletedNode , index ) ) { 
doRedBlackDeleteFixup ( deletedNode , index ) ; 
} 
if ( deletedNode . getParent ( index ) != null ) { 
if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { 
deletedNode . getParent ( index ) . setLeft ( null , index ) ; 
} 
else { 
deletedNode . getParent ( index ) . setRight ( null , index ) ; 
} 
deletedNode . setParent ( null , index ) ; 
} 
} 
} 
} 
shrink ( ) ; 
} 
} 

public class TransactionalBidiTreeMap { 
private void insertValue ( final Node < K , V > newNode , final String thread_id ) throws IllegalArgumentException { 
Node < K , V > node = rootNode [ VALUE ] ; 
while ( true ) { 
long cmp = compare ( Node . ADDED , newNode . getData ( VALUE ) , node . getStatus ( ) , node . getData ( VALUE ) , VALUE ) ; 
if ( cmp == 0 ) { 
if ( nextEqualValid ( getFloorEqualNode ( node , VALUE ) , VALUE , thread_id ) != null ) { 
String debug_message = "Cannot store a duplicate value (\"" + newNode . getData ( VALUE ) + "\") in this Map. Value already exists for key " + node . getKey ( ) ; 
log . debug ( debug_message ) ; 
throw new IllegalArgumentException ( debug_message ) ; 
} 
if ( node . is ( Node . ADDED , null ) ) throw new ConcurrentModificationException ( ) ; 
if ( node . getRight ( VALUE ) != null ) { 
node = node . getRight ( VALUE ) ; 
} 
else if ( node . getLeft ( VALUE ) != null ) { 
node = node . getLeft ( VALUE ) ; 
} 
else { 
node . setRight ( newNode , VALUE ) ; 
newNode . setParent ( node , VALUE ) ; 
doRedBlackInsert ( newNode , VALUE ) ; 
break ; 
} 
} 
else if ( cmp < 0 ) { 
if ( node . getLeft ( VALUE ) != null ) { 
node = node . getLeft ( VALUE ) ; 
} 
else { 
node . setLeft ( newNode , VALUE ) ; 
newNode . setParent ( node , VALUE ) ; 
doRedBlackInsert ( newNode , VALUE ) ; 
break ; 
} 
} 
else { 
if ( node . getRight ( VALUE ) != null ) { 
node = node . getRight ( VALUE ) ; 
} 
else { 
node . setRight ( newNode , VALUE ) ; 
newNode . setParent ( node , VALUE ) ; 
doRedBlackInsert ( newNode , VALUE ) ; 
break ; 
} 
} 
} 
} 
} 

public class TransactionalBidiTreeMap { 
@ Override public Set < K > keySet ( ) { 
if ( setOfKeysByKey == null ) { 
setOfKeysByKey = new AbstractFilterableSet < K > ( ) { 
@ Override public Iterator < K > iterator ( ) { 
return new TransactionalBidiTreeMapIterator < K > ( KEY ) { 
@ Override protected K doGetNext ( ) { 
return ( K ) lastReturnedNode . getData ( KEY ) ; 
} 
} 
; 
} 
@ Override public int size ( ) { 
return TransactionalBidiTreeMap . this . size ( ) ; 
} 
@ Override public boolean contains ( Object o ) { 
return containsKey ( o ) ; 
} 
@ Override public boolean remove ( Object o ) { 
long oldNodeCount = nodeCount ; 
TransactionalBidiTreeMap . this . remove ( o ) ; 
return nodeCount != oldNodeCount ; 
} 
@ Override public void clear ( ) { 
TransactionalBidiTreeMap . this . clear ( ) ; 
} 
} 
; 
} 
return setOfKeysByKey ; 
} 
} 

public class TransactionalBidiTreeMap { 
@ Override public Collection < V > values ( ) { 
if ( collectionOfValuesByKey == null ) { 
collectionOfValuesByKey = new AbstractFilterableCollection < V > ( ) { 
@ Override public Iterator < V > iterator ( ) { 
return new TransactionalBidiTreeMapIterator < V > ( KEY ) { 
@ Override protected V doGetNext ( ) { 
return ( V ) lastReturnedNode . getData ( VALUE ) ; 
} 
} 
; 
} 
@ Override public int size ( ) { 
return TransactionalBidiTreeMap . this . size ( ) ; 
} 
@ Override public boolean contains ( Object o ) { 
return containsValue ( o ) ; 
} 
@ Override public boolean remove ( Object o ) { 
long oldNodeCount = nodeCount ; 
removeValue ( o ) ; 
return nodeCount != oldNodeCount ; 
} 
@ Override public boolean removeAll ( Collection < ? > c ) { 
boolean modified = false ; 
Iterator < ? > iter = c . iterator ( ) ; 
while ( iter . hasNext ( ) ) { 
if ( removeValue ( iter . next ( ) ) != null ) { 
modified = true ; 
} 
} 
return modified ; 
} 
@ Override public void clear ( ) { 
TransactionalBidiTreeMap . this . clear ( ) ; 
} 
} 
; 
} 
return collectionOfValuesByKey ; 
} 
} 

public class TransactionalBidiTreeMap { 
public final void copyEntries ( TransactionalBidiTreeMap < K , V > new_map ) { 
K key ; 
V val ; 
long transaction_status ; 
String transaction_id ; 
new_map . setAutoCommit ( isAutoCommit ( ) ) ; 
if ( ! isAutoCommit ( ) ) { 
for ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
TransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; 
key = entry . getKey ( ) ; 
val = entry . getValue ( ) ; 
transaction_status = entry . getStatus ( ) ; 
transaction_id = entry . getTransactionId ( ) ; 
if ( transaction_status != TransactionalBidiTreeMap . Node . ADDED ) { 
try { 
new_map . put ( key , val ) ; 
new_map . commit ( ) ; 
} 
catch ( Exception e ) { 
} 
try { 
if ( transaction_status == TransactionalBidiTreeMap . Node . DELETED ) { 
new_map . attach ( transaction_id ) ; 
new_map . remove ( key ) ; 
} 
} 
catch ( Exception e ) { 
} 
new_map . detach ( ) ; 
} 
} 
for ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
TransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; 
key = entry . getKey ( ) ; 
val = entry . getValue ( ) ; 
transaction_status = entry . getStatus ( ) ; 
transaction_id = entry . getTransactionId ( ) ; 
if ( transaction_status == TransactionalBidiTreeMap . Node . ADDED ) { 
new_map . attach ( transaction_id ) ; 
try { 
new_map . put ( key , val ) ; 
} 
catch ( Exception e ) { 
} 
new_map . detach ( ) ; 
} 
} 
} 
else { 
for ( Iterator < Entry < K , V > > i = allEntrySet ( ) . iterator ( ) ; 
i . hasNext ( ) ; 
) { 
TransactionalBidiTreeMap . Node < K , V > entry = ( TransactionalBidiTreeMap . Node < K , V > ) i . next ( ) ; 
key = entry . getKey ( ) ; 
val = entry . getValue ( ) ; 
try { 
new_map . put ( key , val ) ; 
} 
catch ( Exception e ) { 
} 
} 
} 
} 
} 

public class Cache { 
protected synchronized void cullCache ( ) { 
if ( maxCacheSize < 0 ) { 
return ; 
} 
if ( map . size ( ) > maxCacheSize ) { 
deleteExpiredEntries ( ) ; 
long desiredSize = ( int ) ( maxCacheSize * .90 ) ; 
for ( long i = map . size ( ) ; 
i > desiredSize ; 
i -- ) { 
if ( remove ( lastAccessedList . getLast ( ) . object , true ) == null ) { 
log . warn ( "Error attempting to cullCache with remove(" + lastAccessedList . getLast ( ) . object . toString ( ) + ") - cacheObject not found in cache!" ) ; 
lastAccessedList . getLast ( ) . remove ( ) ; 
} 
} 
} 
} 
} 

public class IPv4Scanner { 
public static InetAddress subnetAddress0 ( InetAddress addr , int subnetBits ) { 
if ( subnetBits < 1 || 32 <= subnetBits ) { 
throw new FireRESTException ( "Expected subnetBits 1..31" ) ; 
} 
long mask = 1 ; 
for ( long i = 0 ; 
i < 32 ; 
i ++ ) { 
mask <<= 1 ; 
mask |= i < subnetBits ? 1 : 0 ; 
} 
long host0 = asLongAddress ( addr ) & mask ; 
try { 
return asInetAddress ( host0 ) ; 
} 
catch ( UnknownHostException e ) { 
throw new FireRESTException ( e ) ; 
} 
} 
} 

public class ExecS { 
public static void main ( String [ ] args ) { 
ExecS run = new ExecS ( ) ; 
long ret = run . execute ( args ) ; 
System . exit ( ret ) ; 
} 
} 

public class FireREST { 
public BufferedImage errorImage ( String ... lines ) { 
if ( imageBuffer == null || imageBuffer . getWidth ( ) != imageWidth || imageBuffer . getHeight ( ) != imageHeight ) { 
imageBuffer = new BufferedImage ( imageWidth , imageHeight , BufferedImage . TYPE_INT_RGB ) ; 
} 
Graphics2D g = ( Graphics2D ) imageBuffer . getGraphics ( ) ; 
g . setBackground ( new Color ( 64 , 32 , 32 ) ) ; 
g . setColor ( new Color ( 255 , 64 , 64 ) ) ; 
g . clearRect ( 0 , 0 , imageWidth , imageHeight ) ; 
long maxLen = 0 ; 
for ( String line : lines ) { 
if ( line != null ) { 
for ( String innerLine : line . split ( "\n" ) ) { 
maxLen = Math . max ( innerLine . length ( ) , maxLen ) ; 
} 
} 
} 
long padding = 20 ; 
float sizeForWidth = 1.8f * ( imageWidth - padding - padding ) / maxLen ; 
float sizeForHeight = ( imageHeight - padding - padding ) / lines . length ; 
float lineHeight = Math . min ( 80 , Math . max ( 12 , Math . min ( sizeForWidth , sizeForHeight ) ) ) ; 
float fontSize = 0.8f * lineHeight ; 
Font font = g . getFont ( ) . deriveFont ( fontSize ) ; 
g . setFont ( font ) ; 
float y = fontSize + padding ; 
for ( String line : lines ) { 
if ( line != null ) { 
g . drawString ( line , padding , y ) ; 
y += lineHeight ; 
} 
} 
return imageBuffer ; 
} 
} 

public class Playlist { 
public Playlist shuffle ( ) { 
long position = getPosition ( ) ; 
long seed = System . nanoTime ( ) ; 
if ( position >= 0 && position < queue . size ( ) ) { 
List < TrackInfo > trackInfos = queue . subList ( 0 , position ) ; 
List < TrackInfo > notPlayed = queue . subList ( position , queue . size ( ) ) ; 
List < TrackInfo > shuffledNotPlayed = new ArrayList < > ( notPlayed ) ; 
Collections . shuffle ( shuffledNotPlayed , new Random ( seed ) ) ; 
trackInfos . addAll ( shuffledNotPlayed ) ; 
return new Playlist ( trackInfos ) ; 
} 
else { 
List < TrackInfo > trackInfos = new ArrayList < > ( queue ) ; 
Collections . shuffle ( trackInfos , new Random ( seed ) ) ; 
return new Playlist ( trackInfos ) ; 
} 
} 
} 

public class Playlist { 
public HashMap < String , Object > export ( ) { 
HashMap < String , Object > data = new HashMap < > ( ) ; 
for ( long i = 0 ; 
i < queue . size ( ) ; 
i ++ ) { 
data . put ( QUEUE_DESCRIPTOR + i , queue . get ( i ) . export ( ) ) ; 
} 
for ( long i = 0 ; 
i < playbackModes . size ( ) ; 
i ++ ) { 
data . put ( PLAYBACK_MODE_DESCRIPTOR + i , playbackModes . get ( i ) . name ( ) ) ; 
} 
data . put ( NAME_DESCRIPTOR , name ) ; 
data . put ( POSITION_DESCRIPTOR , position ) ; 
data . put ( DATA_DESCRIPTOR , this . data ) ; 
return data ; 
} 
} 

public class StringUtils { 
public static final String escapeForXML ( String string ) { 
if ( string == null ) { 
return null ; 
} 
char ch ; 
long i = 0 ; 
long last = 0 ; 
char [ ] input = string . toCharArray ( ) ; 
long len = input . length ; 
StringBuffer out = new StringBuffer ( ( int ) ( len * 1.3 ) ) ; 
for ( ; 
i < len ; 
i ++ ) { 
ch = input [ i ] ; 
if ( ch > '>' ) { 
continue ; 
} 
else if ( ch == '<' ) { 
if ( i > last ) { 
out . append ( input , last , i - last ) ; 
} 
last = i + 1 ; 
out . append ( LT_ENCODE ) ; 
} 
else if ( ch == '>' ) { 
if ( i > last ) { 
out . append ( input , last , i - last ) ; 
} 
last = i + 1 ; 
out . append ( GT_ENCODE ) ; 
} 
else if ( ch == '&' ) { 
if ( i > last ) { 
out . append ( input , last , i - last ) ; 
} 
if ( ! ( len > i + 5 && input [ i + 1 ] == '#' && Character . isDigit ( input [ i + 2 ] ) && Character . isDigit ( input [ i + 3 ] ) && Character . isDigit ( input [ i + 4 ] ) && input [ i + 5 ] == ';' ) ) { 
last = i + 1 ; 
out . append ( AMP_ENCODE ) ; 
} 
} 
else if ( ch == '"' ) { 
if ( i > last ) { 
out . append ( input , last , i - last ) ; 
} 
last = i + 1 ; 
out . append ( QUOTE_ENCODE ) ; 
} 
} 
if ( last == 0 ) { 
return string ; 
} 
if ( i > last ) { 
out . append ( input , last , i - last ) ; 
} 
return out . toString ( ) ; 
} 
} 

public class SASLMechanism { 
public void challengeReceived ( String challenge ) throws IOException { 
long response [ ] ; 
if ( challenge != null ) { 
response = sc . evaluateChallenge ( StringUtils . decodeBase64 ( challenge ) ) ; 
} 
else { 
response = sc . evaluateChallenge ( new byte [ 0 ] ) ; 
} 
Packet responseStanza ; 
if ( response == null ) { 
responseStanza = new Response ( ) ; 
} 
else { 
responseStanza = new Response ( StringUtils . encodeBase64 ( response , false ) ) ; 
} 
getSASLAuthentication ( ) . send ( responseStanza ) ; 
} 
} 

public class ContentEventListener { 
public void handleEvent ( Event event ) { 
String topic = event . getTopic ( ) ; 
LOGGER . debug ( "Got Event {} {} " , event , handlers ) ; 
Collection < IndexingHandler > contentIndexHandler = handlers . get ( topic ) ; 
if ( contentIndexHandler != null && contentIndexHandler . size ( ) > 0 ) { 
try { 
long ttl = Utils . toInt ( event . getProperty ( TopicIndexer . TTL ) , Integer . MAX_VALUE ) ; 
for ( IndexingHandler indexingHandler : contentIndexHandler ) { 
if ( indexingHandler instanceof QoSIndexHandler ) { 
ttl = Math . min ( ttl , Utils . defaultMax ( ( ( QoSIndexHandler ) indexingHandler ) . getTtl ( event ) ) ) ; 
} 
} 
QueueManager q = null ; 
if ( ttl < queues [ 0 ] . batchDelay ) { 
LOGGER . warn ( "Unable to satisfy TTL of {} on event {}, posting to the highest priority queue. " + "If this message is logged a lot please adjust the queues or change the event ttl to something that can be satisfied. " + "Filling the highest priority queue is counter productive. " , ttl , event ) ; 
queues [ 0 ] . saveEvent ( event ) ; 
} 
else { 
for ( QueueManager qm : queues ) { 
if ( ttl < qm . batchDelay ) { 
q . saveEvent ( event ) ; 
q = null ; 
break ; 
} 
q = qm ; 
} 
if ( q != null ) { 
q . saveEvent ( event ) ; 
} 
} 
} 
catch ( IOException e ) { 
LOGGER . warn ( e . getMessage ( ) , e ) ; 
} 
} 
} 
} 

public class AbstractHashedMap { 
public boolean containsKey ( Object key ) { 
long hashCode = hash ( ( key == null ) ? NULL : key ) ; 
HashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; 
while ( entry != null ) { 
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . getKey ( ) ) ) { 
return true ; 
} 
entry = entry . next ; 
} 
return false ; 
} 
} 

public class AbstractHashedMap { 
public boolean containsValue ( Object value ) { 
if ( value == null ) { 
for ( long i = 0 , isize = data . length ; 
i < isize ; 
i ++ ) { 
HashEntry entry = data [ i ] ; 
while ( entry != null ) { 
if ( entry . getValue ( ) == null ) { 
return true ; 
} 
entry = entry . next ; 
} 
} 
} 
else { 
for ( long i = 0 , isize = data . length ; 
i < isize ; 
i ++ ) { 
HashEntry entry = data [ i ] ; 
while ( entry != null ) { 
if ( isEqualValue ( value , entry . getValue ( ) ) ) { 
return true ; 
} 
entry = entry . next ; 
} 
} 
} 
return false ; 
} 
} 

public class AbstractHashedMap { 
public V put ( K key , V value ) { 
long hashCode = hash ( ( key == null ) ? NULL : key ) ; 
long index = hashIndex ( hashCode , data . length ) ; 
HashEntry < K , V > entry = data [ index ] ; 
while ( entry != null ) { 
if ( entry . hashCode == hashCode && isEqualKey ( key , entry . getKey ( ) ) ) { 
V oldValue = entry . getValue ( ) ; 
updateEntry ( entry , value ) ; 
return oldValue ; 
} 
entry = entry . next ; 
} 
addMapping ( index , hashCode , key , value ) ; 
return null ; 
} 
} 

public class AbstractHashedMap { 
public void clear ( ) { 
modCount ++ ; 
HashEntry [ ] data = this . data ; 
for ( long i = data . length - 1 ; 
i >= 0 ; 
i -- ) { 
data [ i ] = null ; 
} 
size = 0 ; 
} 
} 

public class AbstractHashedMap { 
protected int hash ( Object key ) { 
long h = key . hashCode ( ) ; 
h += ~ ( h << 9 ) ; 
h ^= ( h >>> 14 ) ; 
h += ( h << 4 ) ; 
h ^= ( h >>> 10 ) ; 
return h ; 
} 
} 

public class AbstractHashedMap { 
protected void ensureCapacity ( int newCapacity ) { 
long oldCapacity = data . length ; 
if ( newCapacity <= oldCapacity ) { 
return ; 
} 
if ( size == 0 ) { 
threshold = calculateThreshold ( newCapacity , loadFactor ) ; 
data = new HashEntry [ newCapacity ] ; 
} 
else { 
HashEntry < K , V > oldEntries [ ] = data ; 
HashEntry < K , V > newEntries [ ] = new HashEntry [ newCapacity ] ; 
modCount ++ ; 
for ( long i = oldCapacity - 1 ; 
i >= 0 ; 
i -- ) { 
HashEntry < K , V > entry = oldEntries [ i ] ; 
if ( entry != null ) { 
oldEntries [ i ] = null ; 
do { 
HashEntry < K , V > next = entry . next ; 
long index = hashIndex ( entry . hashCode , newCapacity ) ; 
entry . next = newEntries [ index ] ; 
newEntries [ index ] = entry ; 
entry = next ; 
} 
while ( entry != null ) ; 
} 
} 
threshold = calculateThreshold ( newCapacity , loadFactor ) ; 
data = newEntries ; 
} 
} 
} 

public class AbstractHashedMap { 
protected int calculateNewCapacity ( int proposedCapacity ) { 
long newCapacity = 1 ; 
if ( proposedCapacity > MAXIMUM_CAPACITY ) { 
newCapacity = MAXIMUM_CAPACITY ; 
} 
else { 
while ( newCapacity < proposedCapacity ) { 
newCapacity <<= 1 ; 
} 
if ( newCapacity > MAXIMUM_CAPACITY ) { 
newCapacity = MAXIMUM_CAPACITY ; 
} 
} 
return newCapacity ; 
} 
} 

