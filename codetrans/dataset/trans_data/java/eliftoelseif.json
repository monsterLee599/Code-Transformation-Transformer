{"38": "public class LinkedArrayList { \npublic void add ( Object o ) { \nif ( size == 0 ) { \nhead = new Object [ capacityHint + 1 ] ; \ntail = head ; \nhead [ 0 ] = o ; \nindexInTail = 1 ; \nsize = 1 ; \n} \nelse { \nif ( indexInTail == capacityHint ) { \nObject [ ] t = new Object [ capacityHint + 1 ] ; \nt [ 0 ] = o ; \ntail [ capacityHint ] = t ; \ntail = t ; \nindexInTail = 1 ; \nsize ++ ; \n} \nelse { \ntail [ indexInTail ] = o ; \nindexInTail ++ ; \nsize ++ ; \n} \n} \n} \n} \n"}
{"67": "public class HttpServiceMethod { \nstatic < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { \nboolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; \nboolean continuationWantsResponse = false ; \nboolean continuationBodyNullable = false ; \nAnnotation [ ] annotations = method . getAnnotations ( ) ; \nType adapterType ; \nif ( isKotlinSuspendFunction ) { \nType [ ] parameterTypes = method . getGenericParameterTypes ( ) ; \nType responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; \nif ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) { \nresponseType = Utils . getParameterUpperBound ( 0 , ( ParameterizedType ) responseType ) ; \ncontinuationWantsResponse = true ; \n} \nelse { \n} \nadapterType = new Utils . ParameterizedTypeImpl ( null , Call . class , responseType ) ; \nannotations = SkipCallbackExecutorImpl . ensurePresent ( annotations ) ; \n} \nelse { \nadapterType = method . getGenericReturnType ( ) ; \n} \nCallAdapter < ResponseT , ReturnT > callAdapter = createCallAdapter ( retrofit , method , adapterType , annotations ) ; \nType responseType = callAdapter . responseType ( ) ; \nif ( responseType == okhttp3 . Response . class ) { \nthrow methodError ( method , \"'\" + getRawType ( responseType ) . getName ( ) + \"' is not a valid response body type. Did you mean ResponseBody?\" ) ; \n} \nif ( responseType == Response . class ) { \nthrow methodError ( method , \"Response must include generic type (e.g., Response<String>)\" ) ; \n} \nif ( requestFactory . httpMethod . equals ( \"HEAD\" ) && ! Void . class . equals ( responseType ) ) { \nthrow methodError ( method , \"HEAD method must use Void as response type.\" ) ; \n} \nConverter < ResponseBody , ResponseT > responseConverter = createResponseConverter ( retrofit , method , responseType ) ; \nokhttp3 . Call . Factory callFactory = retrofit . callFactory ; \nif ( ! isKotlinSuspendFunction ) { \nreturn new CallAdapted < > ( requestFactory , callFactory , responseConverter , callAdapter ) ; \n} \nelse { \nif ( continuationWantsResponse ) { \nreturn ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForResponse < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter ) ; \n} \nelse { \nreturn ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForBody < > ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter , continuationBodyNullable ) ; \n} \n} \n} \n} \n"}
{"115": "public class SpringSecurityAuthenticationSource { \npublic String getPrincipal ( ) { \nAuthentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; \nif ( authentication == null ) { \nlog . warn ( \"No Authentication object set in SecurityContext - returning empty String as Principal\" ) ; \nreturn \"\" ; \n} \nObject principal = authentication . getPrincipal ( ) ; \nif ( principal instanceof LdapUserDetails ) { \nLdapUserDetails details = ( LdapUserDetails ) principal ; \nreturn details . getDn ( ) ; \n} \nelse { \nif ( authentication instanceof AnonymousAuthenticationToken ) { \nif ( log . isDebugEnabled ( ) ) { \nlog . debug ( \"Anonymous Authentication, returning empty String as Principal\" ) ; \n} \nreturn \"\" ; \n} \nelse { \nthrow new IllegalArgumentException ( \"The principal property of the authentication object\" + \"needs to be an LdapUserDetails.\" ) ; \n} \n} \n} \n} \n"}
{"123": "public class UserDetailsServiceFactoryBean { \nprivate UserDetailsService getUserDetailsService ( ) { \nMap < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; \nif ( beans . size ( ) == 0 ) { \nbeans = getBeansOfType ( UserDetailsService . class ) ; \n} \nif ( beans . size ( ) == 0 ) { \nthrow new ApplicationContextException ( \"No UserDetailsService registered.\" ) ; \n} \nelse { \nif ( beans . size ( ) > 1 ) { \nthrow new ApplicationContextException ( \"More than one UserDetailsService registered. Please \" + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\" ) ; \n} \n} \nreturn ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; \n} \n} \n"}
{"141": "public class MapBasedAttributes2GrantedAuthoritiesMapper { \nprivate void addGrantedAuthorityCollection ( Collection < GrantedAuthority > result , Object value ) { \nif ( value == null ) { \nreturn ; \n} \nif ( value instanceof Collection < ? > ) { \naddGrantedAuthorityCollection ( result , ( Collection < ? > ) value ) ; \n} \nelse { \nif ( value instanceof Object [ ] ) { \naddGrantedAuthorityCollection ( result , ( Object [ ] ) value ) ; \n} \nelse { \nif ( value instanceof String ) { \naddGrantedAuthorityCollection ( result , ( String ) value ) ; \n} \nelse { \nif ( value instanceof GrantedAuthority ) { \nresult . add ( ( GrantedAuthority ) value ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Invalid object type: \" + value . getClass ( ) . getName ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"206": "public class XFrameOptionsHeaderWriter { \npublic void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { \nif ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { \nString allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; \nif ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { \nif ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { \nresponse . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; \n} \n} \nelse { \nif ( allowFromValue != null ) { \nif ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { \nresponse . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + \" \" + allowFromValue ) ; \n} \n} \n} \n} \nelse { \nresponse . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; \n} \n} \n} \n"}
{"236": "public class ResponsePrinter { \npublic static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { \nfinal StringBuilder builder = new StringBuilder ( ) ; \nif ( logDetail == ALL || logDetail == STATUS ) { \nbuilder . append ( responseOptions . statusLine ( ) ) ; \n} \nif ( logDetail == ALL || logDetail == HEADERS ) { \nfinal Headers headers = responseOptions . headers ( ) ; \nif ( headers . exist ( ) ) { \nappendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; \n} \n} \nelse { \nif ( logDetail == COOKIES ) { \nfinal Cookies cookies = responseOptions . detailedCookies ( ) ; \nif ( cookies . exist ( ) ) { \nappendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; \n} \n} \n} \nif ( logDetail == ALL || logDetail == BODY ) { \nString responseBodyToAppend ; \nif ( shouldPrettyPrint ) { \nresponseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; \n} \nelse { \nresponseBodyToAppend = responseBody . asString ( ) ; \n} \nif ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { \nbuilder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; \n} \nbuilder . append ( responseBodyToAppend ) ; \n} \nString response = builder . toString ( ) ; \nstream . println ( response ) ; \nreturn response ; \n} \n} \n"}
{"295": "public class JsonPath { \npublic int getInt ( String path ) { \nObject value = get ( path ) ; \nif ( value instanceof Integer ) { \nreturn ( Integer ) value ; \n} \nelse { \nif ( value instanceof Short ) { \nreturn ( ( Short ) value ) . intValue ( ) ; \n} \nelse { \nif ( value instanceof Long ) { \nreturn ( ( Long ) value ) . intValue ( ) ; \n} \nelse { \nreturn ObjectConverter . convertObjectTo ( value , Integer . class ) ; \n} \n} \n} \n} \n} \n"}
{"296": "public class JsonPath { \npublic byte getByte ( String path ) { \nObject value = get ( path ) ; \nif ( value instanceof Byte ) { \nreturn ( Byte ) value ; \n} \nelse { \nif ( value instanceof Long ) { \nreturn ( ( Long ) value ) . byteValue ( ) ; \n} \nelse { \nif ( value instanceof Integer ) { \nreturn ( ( Integer ) value ) . byteValue ( ) ; \n} \nelse { \nreturn ObjectConverter . convertObjectTo ( value , Byte . class ) ; \n} \n} \n} \n} \n} \n"}
{"297": "public class JsonPath { \npublic short getShort ( String path ) { \nObject value = get ( path ) ; \nif ( value instanceof Short ) { \nreturn ( Short ) value ; \n} \nelse { \nif ( value instanceof Long ) { \nreturn ( ( Long ) value ) . shortValue ( ) ; \n} \nelse { \nif ( value instanceof Integer ) { \nreturn ( ( Integer ) value ) . shortValue ( ) ; \n} \nelse { \nreturn ObjectConverter . convertObjectTo ( value , Short . class ) ; \n} \n} \n} \n} \n} \n"}
{"300": "public class JsonPath { \npublic long getLong ( String path ) { \nObject value = get ( path ) ; \nif ( value instanceof Long ) { \nreturn ( Long ) value ; \n} \nelse { \nif ( value instanceof Short ) { \nreturn ( ( Short ) value ) . longValue ( ) ; \n} \nelse { \nif ( value instanceof Integer ) { \nreturn ( ( Integer ) value ) . longValue ( ) ; \n} \nelse { \nreturn ObjectConverter . convertObjectTo ( value , Long . class ) ; \n} \n} \n} \n} \n} \n"}
{"315": "public class InjectorImpl { \nprivate boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { \nboolean bindingFailed = false ; \nSet < Dependency < ? > > deps = getInternalDependencies ( binding ) ; \nfor ( Dependency dep : deps ) { \nKey < ? > depKey = dep . getKey ( ) ; \nInjectionPoint ip = dep . getInjectionPoint ( ) ; \nif ( encountered . add ( depKey ) ) { \nBindingImpl depBinding = jitBindings . get ( depKey ) ; \nif ( depBinding != null ) { \nboolean failed = cleanup ( depBinding , encountered ) ; \nif ( depBinding instanceof ConstructorBindingImpl ) { \nConstructorBindingImpl ctorBinding = ( ConstructorBindingImpl ) depBinding ; \nip = ctorBinding . getInternalConstructor ( ) ; \nif ( ! ctorBinding . isInitialized ( ) ) { \nfailed = true ; \n} \n} \nif ( failed ) { \nremoveFailedJitBinding ( depBinding , ip ) ; \nbindingFailed = true ; \n} \n} \nelse { \nif ( state . getExplicitBinding ( depKey ) == null ) { \nbindingFailed = true ; \n} \n} \n} \n} \nreturn bindingFailed ; \n} \n} \n"}
{"317": "public class InjectorImpl { \n@ SuppressWarnings ( \"unchecked\" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { \nif ( binding instanceof ConstructorBindingImpl ) { \nreturn ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; \n} \nelse { \nif ( binding instanceof HasDependencies ) { \nreturn ( ( HasDependencies ) binding ) . getDependencies ( ) ; \n} \nelse { \nreturn ImmutableSet . of ( ) ; \n} \n} \n} \n} \n"}
{"339": "public class ServletUtils { \nstatic String normalizePath ( String path ) { \nStringBuilder sb = new StringBuilder ( path . length ( ) ) ; \nint queryStart = path . indexOf ( '?' ) ; \nString query = null ; \nif ( queryStart != - 1 ) { \nquery = path . substring ( queryStart ) ; \npath = path . substring ( 0 , queryStart ) ; \n} \nList < String > segments = new ArrayList < > ( ) ; \nfor ( String segment : SLASH_SPLITTER . split ( path ) ) { \nString normalized = UrlEscapers . urlPathSegmentEscaper ( ) . escape ( lenientDecode ( segment , UTF_8 , false ) ) ; \nif ( \".\" . equals ( normalized ) ) { \n} \nelse { \nif ( \"..\" . equals ( normalized ) ) { \nif ( segments . size ( ) > 1 ) { \nsegments . remove ( segments . size ( ) - 1 ) ; \n} \n} \nelse { \nsegments . add ( normalized ) ; \n} \n} \n} \nSLASH_JOINER . appendTo ( sb , segments ) ; \nif ( query != null ) { \nsb . append ( query ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"344": "public class Annotations { \npublic static String nameOf ( Key < ? > key ) { \nAnnotation annotation = key . getAnnotation ( ) ; \nClass < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; \nif ( annotation != null && ! isMarker ( annotationType ) ) { \nreturn key . getAnnotation ( ) . toString ( ) ; \n} \nelse { \nif ( key . getAnnotationType ( ) != null ) { \nreturn \"@\" + key . getAnnotationType ( ) . getName ( ) ; \n} \nelse { \nreturn \"\" ; \n} \n} \n} \n} \n"}
{"361": "public class FactoryProvider2 { \n@ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { \nif ( methodHandleByMethod . containsKey ( method ) ) { \nreturn methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; \n} \nif ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { \nif ( \"equals\" . equals ( method . getName ( ) ) ) { \nreturn proxy == args [ 0 ] ; \n} \nelse { \nif ( \"hashCode\" . equals ( method . getName ( ) ) ) { \nreturn System . identityHashCode ( proxy ) ; \n} \nelse { \nreturn method . invoke ( this , args ) ; \n} \n} \n} \nAssistData data = assistDataByMethod . get ( method ) ; \ncheckState ( data != null , \"No data for method: %s\" , method ) ; \nProvider < ? > provider ; \nif ( data . cachedBinding != null ) { \nprovider = data . cachedBinding . getProvider ( ) ; \n} \nelse { \nprovider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; \n} \ntry { \nint p = 0 ; \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . set ( args [ p ++ ] ) ; \n} \nreturn provider . get ( ) ; \n} \ncatch ( ProvisionException e ) { \nif ( e . getErrorMessages ( ) . size ( ) == 1 ) { \nMessage onlyError = getOnlyElement ( e . getErrorMessages ( ) ) ; \nThrowable cause = onlyError . getCause ( ) ; \nif ( cause != null && canRethrow ( method , cause ) ) { \nthrow cause ; \n} \n} \nthrow e ; \n} \nfinally { \nfor ( ThreadLocalProvider tlp : data . providers ) { \ntlp . remove ( ) ; \n} \n} \n} \n} \n"}
{"383": "public class DependencyAndSource { \npublic String getBindingSource ( ) { \nif ( source instanceof Class ) { \nreturn StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; \n} \nelse { \nif ( source instanceof Member ) { \nreturn StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; \n} \nelse { \nreturn source . toString ( ) ; \n} \n} \n} \n} \n"}
{"399": "public class FutureTaskUtil { \npublic static void launderThrowable ( Throwable t ) { \nif ( t instanceof RuntimeException ) { \nthrow ( RuntimeException ) t ; \n} \nelse { \nif ( t instanceof Error ) { \nthrow ( Error ) t ; \n} \nelse { \nthrow new IllegalStateException ( \"Not unchecked!\" , t ) ; \n} \n} \n} \n} \n"}
{"475": "public class Draft_6455 { \nprivate void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { \nif ( curop != Opcode . CONTINUOUS ) { \nprocessFrameIsNotFin ( frame ) ; \n} \nelse { \nif ( frame . isFin ( ) ) { \nprocessFrameIsFin ( webSocketImpl , frame ) ; \n} \nelse { \nif ( currentContinuousFrame == null ) { \nlog . error ( \"Protocol error: Continuous frame sequence was not started.\" ) ; \nthrow new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , \"Continuous frame sequence was not started.\" ) ; \n} \n} \n} \nif ( curop == Opcode . TEXT && ! Charsetfunctions . isValidUTF8 ( frame . getPayloadData ( ) ) ) { \nlog . error ( \"Protocol error: Payload is not UTF8\" ) ; \nthrow new InvalidDataException ( CloseFrame . NO_UTF8 ) ; \n} \nif ( curop == Opcode . CONTINUOUS && currentContinuousFrame != null ) { \naddToBufferList ( frame . getPayloadData ( ) ) ; \n} \n} \n} \n"}
{"479": "public class Draft_6455 { \nprivate void processFrameIsFin ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { \nif ( currentContinuousFrame == null ) { \nlog . trace ( \"Protocol error: Previous continuous frame sequence not completed.\" ) ; \nthrow new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , \"Continuous frame sequence was not started.\" ) ; \n} \naddToBufferList ( frame . getPayloadData ( ) ) ; \ncheckBufferLimit ( ) ; \nif ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { \n( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; \n( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; \ntry { \nwebSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; \n} \ncatch ( RuntimeException e ) { \nlogRuntimeException ( webSocketImpl , e ) ; \n} \n} \nelse { \nif ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { \n( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; \n( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; \ntry { \nwebSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; \n} \ncatch ( RuntimeException e ) { \nlogRuntimeException ( webSocketImpl , e ) ; \n} \n} \n} \ncurrentContinuousFrame = null ; \nclearBufferList ( ) ; \n} \n} \n"}
{"487": "public class WebSocketImpl { \npublic void decode ( ByteBuffer socketBuffer ) { \nassert ( socketBuffer . hasRemaining ( ) ) ; \nlog . trace ( \"process({}): ({})\" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? \"too big to display\" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; \nif ( readyState != ReadyState . NOT_YET_CONNECTED ) { \nif ( readyState == ReadyState . OPEN ) { \ndecodeFrames ( socketBuffer ) ; \n} \n} \nelse { \nif ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { \nassert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ; \nif ( socketBuffer . hasRemaining ( ) ) { \ndecodeFrames ( socketBuffer ) ; \n} \nelse { \nif ( tmpHandshakeBytes . hasRemaining ( ) ) { \ndecodeFrames ( tmpHandshakeBytes ) ; \n} \n} \n} \n} \n} \n} \n"}
{"494": "public class WebSocketClient { \nprivate int getPort ( ) { \nint port = uri . getPort ( ) ; \nif ( port == - 1 ) { \nString scheme = uri . getScheme ( ) ; \nif ( \"wss\" . equals ( scheme ) ) { \nreturn WebSocketImpl . DEFAULT_WSS_PORT ; \n} \nelse { \nif ( \"ws\" . equals ( scheme ) ) { \nreturn WebSocketImpl . DEFAULT_PORT ; \n} \nelse { \nthrow new IllegalArgumentException ( \"unknown scheme: \" + scheme ) ; \n} \n} \n} \nreturn port ; \n} \n} \n"}
{"552": "public class DefaultHttpErrorHandler { \n@ Override public CompletionStage < Result > onClientError ( RequestHeader request , int statusCode , String message ) { \nif ( statusCode == 400 ) { \nreturn onBadRequest ( request , message ) ; \n} \nelse { \nif ( statusCode == 403 ) { \nreturn onForbidden ( request , message ) ; \n} \nelse { \nif ( statusCode == 404 ) { \nreturn onNotFound ( request , message ) ; \n} \nelse { \nif ( statusCode >= 400 && statusCode < 500 ) { \nreturn onOtherClientError ( request , statusCode , message ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"onClientError invoked with non client error status code \" + statusCode + \": \" + message ) ; \n} \n} \n} \n} \n} \n} \n"}
{"637": "public class Formatters { \npublic < T > String print ( TypeDescriptor desc , T t ) { \nif ( t == null ) { \nreturn \"\" ; \n} \nif ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) { \nreturn ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; \n} \nelse { \nif ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { \nreturn conversion . convert ( t , String . class ) ; \n} \nelse { \nreturn t . toString ( ) ; \n} \n} \n} \n} \n"}
{"638": "public class Formatters { \nprivate Formatters registerOptional ( ) { \nconversion . addConverter ( new GenericConverter ( ) { \npublic Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { \nif ( sourceType . getObjectType ( ) . equals ( String . class ) ) { \nObject element = conversion . convert ( source , sourceType , targetType . elementTypeDescriptor ( source ) ) ; \nreturn Optional . ofNullable ( element ) ; \n} \nelse { \nif ( targetType . getObjectType ( ) . equals ( String . class ) ) { \nif ( source == null ) return \"\" ; \nOptional < ? > opt = ( Optional ) source ; \nreturn opt . map ( o -> conversion . convert ( source , sourceType . getElementTypeDescriptor ( ) , targetType ) ) . orElse ( \"\" ) ; \n} \n} \nreturn null ; \n} \npublic Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { \nSet < ConvertiblePair > result = new HashSet < > ( ) ; \nresult . add ( new ConvertiblePair ( Optional . class , String . class ) ) ; \nresult . add ( new ConvertiblePair ( String . class , Optional . class ) ) ; \nreturn result ; \n} \n} \n) ; \nreturn this ; \n} \n} \n"}
{"646": "public class WebSocket { \npublic static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > in ) { \nreturn new MappedWebSocketAcceptor < > ( Scala . partialFunction ( message -> { \ntry { \nif ( message instanceof Message . Binary ) { \nreturn F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; \n} \nelse { \nif ( message instanceof Message . Text ) { \nreturn F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nreturn F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; \n} \nthrow Scala . noMatch ( ) ; \n} \n) , outMessage -> { \ntry { \nreturn new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n) ; \n} \n} \n"}
{"650": "public class MemberUtils { \nprivate static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { \nfinal Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; \nfinal boolean isVarArgs = executable . isVarArgs ( ) ; \nfloat totalCost = 0.0f ; \nfinal long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; \nif ( srcArgs . length < normalArgsLen ) { \nreturn Float . MAX_VALUE ; \n} \nfor ( int i = 0 ; \ni < normalArgsLen ; \ni ++ ) { \ntotalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; \n} \nif ( isVarArgs ) { \nfinal boolean noVarArgsPassed = srcArgs . length < destArgs . length ; \nfinal boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; \nfinal float varArgsCost = 0.001f ; \nfinal Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; \nif ( noVarArgsPassed ) { \ntotalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; \n} \nelse { \nif ( explicitArrayForVarags ) { \nfinal Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; \ntotalCost += getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; \n} \nelse { \nfor ( int i = destArgs . length - 1 ; \ni < srcArgs . length ; \ni ++ ) { \nfinal Class < ? > srcClass = srcArgs [ i ] ; \ntotalCost += getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; \n} \n} \n} \n} \nreturn totalCost ; \n} \n} \n"}
{"659": "public class CodeEmitter { \npublic void cast_numeric ( Type from , Type to ) { \nif ( from != to ) { \nif ( from == Type . DOUBLE_TYPE ) { \nif ( to == Type . FLOAT_TYPE ) { \nmv . visitInsn ( Constants . D2F ) ; \n} \nelse { \nif ( to == Type . LONG_TYPE ) { \nmv . visitInsn ( Constants . D2L ) ; \n} \nelse { \nmv . visitInsn ( Constants . D2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \n} \n} \nelse { \nif ( from == Type . FLOAT_TYPE ) { \nif ( to == Type . DOUBLE_TYPE ) { \nmv . visitInsn ( Constants . F2D ) ; \n} \nelse { \nif ( to == Type . LONG_TYPE ) { \nmv . visitInsn ( Constants . F2L ) ; \n} \nelse { \nmv . visitInsn ( Constants . F2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \n} \n} \nelse { \nif ( from == Type . LONG_TYPE ) { \nif ( to == Type . DOUBLE_TYPE ) { \nmv . visitInsn ( Constants . L2D ) ; \n} \nelse { \nif ( to == Type . FLOAT_TYPE ) { \nmv . visitInsn ( Constants . L2F ) ; \n} \nelse { \nmv . visitInsn ( Constants . L2I ) ; \ncast_numeric ( Type . INT_TYPE , to ) ; \n} \n} \n} \nelse { \nif ( to == Type . BYTE_TYPE ) { \nmv . visitInsn ( Constants . I2B ) ; \n} \nelse { \nif ( to == Type . CHAR_TYPE ) { \nmv . visitInsn ( Constants . I2C ) ; \n} \nelse { \nif ( to == Type . DOUBLE_TYPE ) { \nmv . visitInsn ( Constants . I2D ) ; \n} \nelse { \nif ( to == Type . FLOAT_TYPE ) { \nmv . visitInsn ( Constants . I2F ) ; \n} \nelse { \nif ( to == Type . LONG_TYPE ) { \nmv . visitInsn ( Constants . I2L ) ; \n} \nelse { \nif ( to == Type . SHORT_TYPE ) { \nmv . visitInsn ( Constants . I2S ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"699": "public class Handler { \nstatic Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { \nif ( firstHandler == null ) { \nreturn null ; \n} \nelse { \nfirstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; \n} \nint handlerStart = firstHandler . startPc . bytecodeOffset ; \nint handlerEnd = firstHandler . endPc . bytecodeOffset ; \nint rangeStart = start . bytecodeOffset ; \nint rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; \nif ( rangeStart >= handlerEnd || rangeEnd <= handlerStart ) { \nreturn firstHandler ; \n} \nif ( rangeStart <= handlerStart ) { \nif ( rangeEnd >= handlerEnd ) { \nreturn firstHandler . nextHandler ; \n} \nelse { \nreturn new Handler ( firstHandler , end , firstHandler . endPc ) ; \n} \n} \nelse { \nif ( rangeEnd >= handlerEnd ) { \nreturn new Handler ( firstHandler , firstHandler . startPc , start ) ; \n} \nelse { \nfirstHandler . nextHandler = new Handler ( firstHandler , end , firstHandler . endPc ) ; \nreturn new Handler ( firstHandler , firstHandler . startPc , start ) ; \n} \n} \n} \n} \n"}
{"743": "public class ClassScanner { \nprotected void scanJarFile ( final File file ) { \nfinal ZipFile zipFile ; \ntry { \nzipFile = new ZipFile ( file ) ; \n} \ncatch ( IOException ioex ) { \nif ( ! ignoreException ) { \nthrow new FindFileException ( \"Invalid zip: \" + file . getName ( ) , ioex ) ; \n} \nreturn ; \n} \nfinal Enumeration entries = zipFile . entries ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nfinal ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; \nfinal String zipEntryName = zipEntry . getName ( ) ; \ntry { \nif ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { \nfinal String entryName = prepareEntryName ( zipEntryName , true ) ; \nfinal ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; \ntry { \nscanEntry ( classPathEntry ) ; \n} \nfinally { \nclassPathEntry . closeInputStream ( ) ; \n} \n} \nelse { \nif ( includeResources ) { \nfinal String entryName = prepareEntryName ( zipEntryName , false ) ; \nfinal ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; \ntry { \nscanEntry ( classPathEntry ) ; \n} \nfinally { \nclassPathEntry . closeInputStream ( ) ; \n} \n} \n} \n} \ncatch ( RuntimeException rex ) { \nif ( ! ignoreException ) { \nZipUtil . close ( zipFile ) ; \nthrow rex ; \n} \n} \n} \nZipUtil . close ( zipFile ) ; \n} \n} \n"}
{"744": "public class ClassScanner { \nprotected void scanClassPath ( final File root ) { \nString rootPath = root . getAbsolutePath ( ) ; \nif ( ! rootPath . endsWith ( File . separator ) ) { \nrootPath += File . separatorChar ; \n} \nfinal FindFile ff = FindFile . create ( ) . includeDirs ( false ) . recursive ( true ) . searchPath ( rootPath ) ; \nFile file ; \nwhile ( ( file = ff . nextFile ( ) ) != null ) { \nfinal String filePath = file . getAbsolutePath ( ) ; \ntry { \nif ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { \nscanClassFile ( filePath , rootPath , file , true ) ; \n} \nelse { \nif ( includeResources ) { \nscanClassFile ( filePath , rootPath , file , false ) ; \n} \n} \n} \ncatch ( RuntimeException rex ) { \nif ( ! ignoreException ) { \nthrow rex ; \n} \n} \n} \n} \n} \n"}
{"747": "public class ClassScanner { \npublic void start ( ) { \nif ( detectEntriesMode ) { \nrulesEntries . detectMode ( ) ; \n} \nfilesToScan . forEach ( file -> { \nfinal String path = file . getAbsolutePath ( ) ; \nif ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { \nif ( ! acceptJar ( file ) ) { \nreturn ; \n} \nscanJarFile ( file ) ; \n} \nelse { \nif ( file . isDirectory ( ) ) { \nscanClassPath ( file ) ; \n} \n} \n} \n) ; \n} \n} \n"}
{"777": "public class ProxettaAsmUtil { \npublic static void pushInt ( final MethodVisitor mv , final int value ) { \nif ( value <= 5 ) { \nmv . visitInsn ( ICONST_0 + value ) ; \n} \nelse { \nif ( value <= Byte . MAX_VALUE ) { \nmv . visitIntInsn ( BIPUSH , value ) ; \n} \nelse { \nmv . visitIntInsn ( SIPUSH , value ) ; \n} \n} \n} \n} \n"}
{"892": "public class Buffer { \npublic void writeTo ( final Writer writer ) throws IOException { \nfor ( Object o : list ) { \nif ( o instanceof FastByteBuffer ) { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nbyte [ ] array = fastByteBuffer . toArray ( ) ; \nwriter . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; \n} \nelse { \nif ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \ntry { \nStreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \n} \n} \n} \n} \n"}
{"893": "public class Buffer { \npublic void writeTo ( final OutputStream out ) throws IOException { \nfor ( Object o : list ) { \nif ( o instanceof FastByteBuffer ) { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nout . write ( fastByteBuffer . toArray ( ) ) ; \n} \nelse { \nif ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \ntry { \nStreamUtil . copy ( inputStream , out ) ; \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \n} \n} \n} \n} \n"}
{"894": "public class Buffer { \npublic void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { \nfinal int size = size ( ) ; \nfinal int callbackSize = progressListener . callbackSize ( size ) ; \nint count = 0 ; \nint step = 0 ; \nprogressListener . transferred ( count ) ; \nfor ( Object o : list ) { \nif ( o instanceof FastByteBuffer ) { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nbyte [ ] bytes = fastByteBuffer . toArray ( ) ; \nint offset = 0 ; \nwhile ( offset < bytes . length ) { \nint chunk = callbackSize - step ; \nif ( offset + chunk > bytes . length ) { \nchunk = bytes . length - offset ; \n} \nout . write ( bytes , offset , chunk ) ; \noffset += chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nelse { \nif ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \nint remaining = uploadable . getSize ( ) ; \ntry { \nwhile ( remaining > 0 ) { \nint chunk = callbackSize - step ; \nif ( chunk > remaining ) { \nchunk = remaining ; \n} \nStreamUtil . copy ( inputStream , out , chunk ) ; \nremaining -= chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( step >= callbackSize ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \n} \n} \nif ( step != 0 ) { \nprogressListener . transferred ( count ) ; \n} \n} \n} \n"}
{"947": "public class Threefish { \nprivate void keySchedule ( final int s ) { \nfor ( int i = 0 ; \ni < nw ; \ni ++ ) { \nksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; \nif ( i == nw - 3 ) { \nksd [ i ] += t [ s % TWEAK_VALUES ] ; \n} \nelse { \nif ( i == nw - 2 ) { \nksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; \n} \nelse { \nif ( i == nw - 1 ) { \nksd [ i ] += s ; \n} \n} \n} \n} \n} \n} \n"}
{"997": "public class Type { \nprivate void appendDescriptor ( final StringBuilder stringBuilder ) { \nif ( sort == OBJECT ) { \nstringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; \n} \nelse { \nif ( sort == INTERNAL ) { \nstringBuilder . append ( 'L' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ';' ) ; \n} \nelse { \nstringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; \n} \n} \n} \n} \n"}
{"1001": "public class JtxTransaction { \nprotected void commitOrRollback ( boolean doCommit ) { \nif ( log . isDebugEnabled ( ) ) { \nif ( doCommit ) { \nlog . debug ( \"Commit JTX\" ) ; \n} \nelse { \nlog . debug ( \"Rollback JTX\" ) ; \n} \n} \nboolean forcedRollback = false ; \nif ( ! isNoTransaction ( ) ) { \nif ( isRollbackOnly ( ) ) { \nif ( doCommit ) { \ndoCommit = false ; \nforcedRollback = true ; \n} \n} \nelse { \nif ( ! isActive ( ) ) { \nif ( isCompleted ( ) ) { \nthrow new JtxException ( \"TX is already completed, commit or rollback should be called once per TX\" ) ; \n} \nthrow new JtxException ( \"No active TX to \" + ( doCommit ? \"commit\" : \"rollback\" ) ) ; \n} \n} \n} \nif ( doCommit ) { \ncommitAllResources ( ) ; \n} \nelse { \nrollbackAllResources ( forcedRollback ) ; \n} \n} \n} \n"}
{"1037": "public class Format { \npublic static String toPrettyString ( final Object value ) { \nif ( value == null ) { \nreturn StringPool . NULL ; \n} \nfinal Class < ? > type = value . getClass ( ) ; \nif ( type . isArray ( ) ) { \nfinal Class componentType = type . getComponentType ( ) ; \nif ( componentType . isPrimitive ( ) ) { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nif ( componentType == int . class ) { \nsb . append ( ArraysUtil . toString ( ( int [ ] ) value ) ) ; \n} \nelse { \nif ( componentType == long . class ) { \nsb . append ( ArraysUtil . toString ( ( long [ ] ) value ) ) ; \n} \nelse { \nif ( componentType == double . class ) { \nsb . append ( ArraysUtil . toString ( ( double [ ] ) value ) ) ; \n} \nelse { \nif ( componentType == float . class ) { \nsb . append ( ArraysUtil . toString ( ( float [ ] ) value ) ) ; \n} \nelse { \nif ( componentType == boolean . class ) { \nsb . append ( ArraysUtil . toString ( ( boolean [ ] ) value ) ) ; \n} \nelse { \nif ( componentType == short . class ) { \nsb . append ( ArraysUtil . toString ( ( short [ ] ) value ) ) ; \n} \nelse { \nif ( componentType == byte . class ) { \nsb . append ( ArraysUtil . toString ( ( byte [ ] ) value ) ) ; \n} \nelse { \nthrow new IllegalArgumentException ( ) ; \n} \n} \n} \n} \n} \n} \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \nelse { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nfinal Object [ ] array = ( Object [ ] ) value ; \nfor ( int i = 0 ; \ni < array . length ; \ni ++ ) { \nif ( i > 0 ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( array [ i ] ) ) ; \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \n} \nelse { \nif ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '{' ) ; \nint i = 0 ; \nfor ( final Object o : iterable ) { \nif ( i > 0 ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( o ) ) ; \ni ++ ; \n} \nsb . append ( '}' ) ; \nreturn sb . toString ( ) ; \n} \n} \nreturn value . toString ( ) ; \n} \n} \n"}
{"1038": "public class Format { \npublic static String toCamelCase ( final String input , final boolean firstCharUppercase , final char separator ) { \nfinal int length = input . length ( ) ; \nfinal StringBuilder sb = new StringBuilder ( length ) ; \nboolean upperCase = firstCharUppercase ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nfinal char ch = input . charAt ( i ) ; \nif ( ch == separator ) { \nupperCase = true ; \n} \nelse { \nif ( upperCase ) { \nsb . append ( Character . toUpperCase ( ch ) ) ; \nupperCase = false ; \n} \nelse { \nsb . append ( ch ) ; \n} \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1039": "public class Format { \npublic static String formatParagraph ( final String src , final int len , final boolean breakOnWhitespace ) { \nStringBuilder str = new StringBuilder ( ) ; \nint total = src . length ( ) ; \nint from = 0 ; \nwhile ( from < total ) { \nint to = from + len ; \nif ( to >= total ) { \nto = total ; \n} \nelse { \nif ( breakOnWhitespace ) { \nint ndx = StringUtil . lastIndexOfWhitespace ( src , to - 1 , from ) ; \nif ( ndx != - 1 ) { \nto = ndx + 1 ; \n} \n} \n} \nint cutFrom = StringUtil . indexOfNonWhitespace ( src , from , to ) ; \nif ( cutFrom != - 1 ) { \nint cutTo = StringUtil . lastIndexOfNonWhitespace ( src , to - 1 , from ) + 1 ; \nstr . append ( src , cutFrom , cutTo ) ; \n} \nstr . append ( '\\n' ) ; \nfrom = to ; \n} \nreturn str . toString ( ) ; \n} \n} \n"}
{"1074": "public class StringUtil { \npublic static String [ ] toStringArray ( final Object value ) { \nif ( value == null ) { \nreturn new String [ 0 ] ; \n} \nClass < ? > type = value . getClass ( ) ; \nif ( ! type . isArray ( ) ) { \nreturn new String [ ] { \nvalue . toString ( ) } \n; \n} \nClass componentType = type . getComponentType ( ) ; \nif ( componentType . isPrimitive ( ) ) { \nif ( componentType == int . class ) { \nreturn ArraysUtil . toStringArray ( ( int [ ] ) value ) ; \n} \nelse { \nif ( componentType == long . class ) { \nreturn ArraysUtil . toStringArray ( ( long [ ] ) value ) ; \n} \nelse { \nif ( componentType == double . class ) { \nreturn ArraysUtil . toStringArray ( ( double [ ] ) value ) ; \n} \nelse { \nif ( componentType == float . class ) { \nreturn ArraysUtil . toStringArray ( ( float [ ] ) value ) ; \n} \nelse { \nif ( componentType == boolean . class ) { \nreturn ArraysUtil . toStringArray ( ( boolean [ ] ) value ) ; \n} \nelse { \nif ( componentType == short . class ) { \nreturn ArraysUtil . toStringArray ( ( short [ ] ) value ) ; \n} \nelse { \nif ( componentType == byte . class ) { \nreturn ArraysUtil . toStringArray ( ( byte [ ] ) value ) ; \n} \nelse { \nthrow new IllegalArgumentException ( ) ; \n} \n} \n} \n} \n} \n} \n} \n} \nelse { \nreturn ArraysUtil . toStringArray ( ( Object [ ] ) value ) ; \n} \n} \n} \n"}
{"1166": "public class StringBand { \npublic void setIndex ( final int newIndex ) { \nif ( newIndex < 0 ) { \nthrow new ArrayIndexOutOfBoundsException ( newIndex ) ; \n} \nif ( newIndex > array . length ) { \nString [ ] newArray = new String [ newIndex ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , index ) ; \narray = newArray ; \n} \nif ( newIndex > index ) { \nfor ( int i = index ; \ni < newIndex ; \ni ++ ) { \narray [ i ] = StringPool . EMPTY ; \n} \n} \nelse { \nif ( newIndex < index ) { \nfor ( int i = newIndex ; \ni < index ; \ni ++ ) { \narray [ i ] = null ; \n} \n} \n} \nindex = newIndex ; \nlength = calculateLength ( ) ; \n} \n} \n"}
{"1191": "public class ColumnsSelectChunk { \nprotected void appendAlias ( final StringBuilder query , final DbEntityDescriptor ded , final DbEntityColumnDescriptor dec ) { \nfinal ColumnAliasType columnAliasType = templateData . getColumnAliasType ( ) ; \nif ( columnAliasType == null || columnAliasType == ColumnAliasType . TABLE_REFERENCE ) { \nfinal String tableName = ded . getTableName ( ) ; \nfinal String columnName = dec . getColumnNameForQuery ( ) ; \ntemplateData . registerColumnDataForTableRef ( tableRef , tableName ) ; \nquery . append ( tableRef ) . append ( columnAliasSeparator ) . append ( columnName ) ; \n} \nelse { \nif ( columnAliasType == ColumnAliasType . COLUMN_CODE ) { \nfinal String tableName = ded . getTableName ( ) ; \nfinal String columnName = dec . getColumnName ( ) ; \nfinal String code = templateData . registerColumnDataForColumnCode ( tableName , columnName ) ; \nquery . append ( code ) ; \n} \nelse { \nif ( columnAliasType == ColumnAliasType . TABLE_NAME ) { \nfinal String tableName = ded . getTableNameForQuery ( ) ; \nfinal String columnName = dec . getColumnNameForQuery ( ) ; \nquery . append ( tableName ) . append ( columnAliasSeparator ) . append ( columnName ) ; \n} \n} \n} \n} \n} \n"}
{"1210": "public class WorkData { \npublic void init ( String name , final String superName , final String suffix , final String reqProxyClassName ) { \nint lastSlash = name . lastIndexOf ( '/' ) ; \nthis . targetPackage = lastSlash == - 1 ? StringPool . EMPTY : name . substring ( 0 , lastSlash ) . replace ( '/' , '.' ) ; \nthis . targetClassname = name . substring ( lastSlash + 1 ) ; \nthis . nextSupername = superName ; \nthis . superName = name ; \nif ( reqProxyClassName != null ) { \nif ( reqProxyClassName . startsWith ( DOT ) ) { \nname = name . substring ( 0 , lastSlash ) + '/' + reqProxyClassName . substring ( 1 ) ; \n} \nelse { \nif ( reqProxyClassName . endsWith ( DOT ) ) { \nname = reqProxyClassName . replace ( '.' , '/' ) + this . targetClassname ; \n} \nelse { \nname = reqProxyClassName . replace ( '.' , '/' ) ; \n} \n} \n} \nif ( suffix != null ) { \nname += suffix ; \n} \nthis . thisReference = name ; \nthis . superReference = this . superName ; \n} \n} \n"}
{"1213": "public class PropsParser { \nprotected void add ( final String section , final String key , final StringBuilder value , final boolean trim , final Operator operator ) { \nif ( key == null ) { \nreturn ; \n} \nString fullKey = key ; \nif ( section != null ) { \nif ( fullKey . length ( ) != 0 ) { \nfullKey = section + '.' + fullKey ; \n} \nelse { \nfullKey = section ; \n} \n} \nString v = value . toString ( ) ; \nif ( trim ) { \nif ( valueTrimLeft && valueTrimRight ) { \nv = v . trim ( ) ; \n} \nelse { \nif ( valueTrimLeft ) { \nv = StringUtil . trimLeft ( v ) ; \n} \nelse { \nv = StringUtil . trimRight ( v ) ; \n} \n} \n} \nif ( v . length ( ) == 0 && skipEmptyProps ) { \nreturn ; \n} \nextractProfilesAndAdd ( fullKey , v , operator ) ; \n} \n} \n"}
{"1225": "public class CollectionConverter { \n@ SuppressWarnings ( \"AutoBoxing\" ) protected Collection < T > convertPrimitiveArrayToCollection ( final Object value , final Class primitiveComponentType ) { \nCollection < T > result = null ; \nif ( primitiveComponentType == int . class ) { \nint [ ] array = ( int [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( int a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nif ( primitiveComponentType == long . class ) { \nlong [ ] array = ( long [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( long a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nif ( primitiveComponentType == float . class ) { \nfloat [ ] array = ( float [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( float a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nif ( primitiveComponentType == double . class ) { \ndouble [ ] array = ( double [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( double a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nif ( primitiveComponentType == short . class ) { \nshort [ ] array = ( short [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( short a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nif ( primitiveComponentType == byte . class ) { \nbyte [ ] array = ( byte [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( byte a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nif ( primitiveComponentType == char . class ) { \nchar [ ] array = ( char [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( char a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \nelse { \nif ( primitiveComponentType == boolean . class ) { \nboolean [ ] array = ( boolean [ ] ) value ; \nresult = createCollection ( array . length ) ; \nfor ( boolean a : array ) { \nresult . add ( convertType ( a ) ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"1277": "public class ExceptionUtil { \npublic static Throwable unwrapThrowable ( final Throwable wrappedThrowable ) { \nThrowable unwrapped = wrappedThrowable ; \nwhile ( true ) { \nif ( unwrapped instanceof InvocationTargetException ) { \nunwrapped = ( ( InvocationTargetException ) unwrapped ) . getTargetException ( ) ; \n} \nelse { \nif ( unwrapped instanceof UndeclaredThrowableException ) { \nunwrapped = ( ( UndeclaredThrowableException ) unwrapped ) . getUndeclaredThrowable ( ) ; \n} \nelse { \nreturn unwrapped ; \n} \n} \n} \n} \n} \n"}
{"1278": "public class AutomagicMadvocConfigurator { \nprotected void registerAsConsumer ( final ClassScanner classScanner ) { \nclassScanner . registerEntryConsumer ( classPathEntry -> { \nfinal String entryName = classPathEntry . name ( ) ; \nif ( entryName . endsWith ( actionClassSuffix ) ) { \ntry { \nacceptActionClass ( classPathEntry . loadClass ( ) ) ; \n} \ncatch ( Exception ex ) { \nlog . debug ( \"Invalid Madvoc action, ignoring: \" + entryName ) ; \n} \n} \nelse { \nif ( classPathEntry . isTypeSignatureInUse ( MADVOC_COMPONENT_ANNOTATION ) ) { \ntry { \nacceptMadvocComponentClass ( classPathEntry . loadClass ( ) ) ; \n} \ncatch ( Exception ex ) { \nlog . debug ( \"Invalid Madvoc component ignoring: {}\" + entryName ) ; \n} \n} \n} \n} \n) ; \n} \n} \n"}
{"1322": "public class MapToBean { \npublic Object map2bean ( final Map map , Class targetType ) { \nObject target = null ; \nString className = ( String ) map . get ( classMetadataName ) ; \nif ( className == null ) { \nif ( targetType == null ) { \ntarget = map ; \n} \n} \nelse { \ncheckClassName ( jsonParser . classnameWhitelist , className ) ; \ntry { \ntargetType = ClassLoaderUtil . loadClass ( className ) ; \n} \ncatch ( ClassNotFoundException cnfex ) { \nthrow new JsonException ( cnfex ) ; \n} \n} \nif ( target == null ) { \ntarget = jsonParser . newObjectInstance ( targetType ) ; \n} \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( target . getClass ( ) ) ; \nboolean targetIsMap = target instanceof Map ; \nfor ( Object key : map . keySet ( ) ) { \nString keyName = key . toString ( ) ; \nif ( classMetadataName != null ) { \nif ( keyName . equals ( classMetadataName ) ) { \ncontinue ; \n} \n} \nPropertyDescriptor pd = cd . getPropertyDescriptor ( keyName , declared ) ; \nif ( ! targetIsMap && pd == null ) { \ncontinue ; \n} \nObject value = map . get ( key ) ; \nClass propertyType = pd == null ? null : pd . getType ( ) ; \nClass componentType = pd == null ? null : pd . resolveComponentType ( true ) ; \nif ( value != null ) { \nif ( value instanceof List ) { \nif ( componentType != null && componentType != String . class ) { \nvalue = generifyList ( ( List ) value , componentType ) ; \n} \n} \nelse { \nif ( value instanceof Map ) { \nif ( ! ClassUtil . isTypeOf ( propertyType , Map . class ) ) { \nvalue = map2bean ( ( Map ) value , propertyType ) ; \n} \nelse { \nClass keyType = pd == null ? null : pd . resolveKeyType ( true ) ; \nif ( keyType != String . class || componentType != String . class ) { \nvalue = generifyMap ( ( Map ) value , keyType , componentType ) ; \n} \n} \n} \n} \n} \nif ( targetIsMap ) { \n( ( Map ) target ) . put ( keyName , value ) ; \n} \nelse { \ntry { \nsetValue ( target , pd , value ) ; \n} \ncatch ( Exception ignore ) { \nignore . printStackTrace ( ) ; \n} \n} \n} \nreturn target ; \n} \n} \n"}
{"1409": "public class Cli { \npublic void printUsage ( final String commandName ) { \nfinal StringBuilder usage = new StringBuilder ( commandName ) ; \nfor ( final Option option : options ) { \nif ( option . shortName != null ) { \nusage . append ( \" [-\" ) . append ( option . shortName ) . append ( \"]\" ) ; \n} \nelse { \nif ( option . longName != null ) { \nusage . append ( \" [--\" ) . append ( option . longName ) . append ( \"]\" ) ; \n} \n} \n} \nfor ( final Param param : params ) { \nusage . append ( \" \" ) . append ( param . label ) ; \n} \nSystem . out . println ( usage ) ; \n} \n} \n"}
{"1428": "public class TemplateParser { \npublic void parse ( final DbSqlBuilder sqlBuilder , final String template ) { \nint length = template . length ( ) ; \nint last = 0 ; \nwhile ( true ) { \nint mark = template . indexOf ( '$' , last ) ; \nif ( mark == - 1 ) { \nif ( last < length ) { \nsqlBuilder . appendRaw ( template . substring ( last ) ) ; \n} \nbreak ; \n} \nint escapesCount = countEscapes ( template , mark ) ; \nif ( escapesCount > 0 ) { \nboolean isEscaped = escapesCount % 2 != 0 ; \nint escapesToAdd = escapesCount >> 1 ; \nsqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + '$' ) ; \nif ( isEscaped ) { \nlast = mark + 1 ; \ncontinue ; \n} \n} \nelse { \nsqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; \n} \nint end ; \nif ( template . startsWith ( MACRO_TABLE , mark ) ) { \nmark += MACRO_TABLE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonTable ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nif ( template . startsWith ( MACRO_COLUMN , mark ) ) { \nmark += MACRO_COLUMN . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonColumn ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nif ( template . startsWith ( MACRO_MATCH , mark ) ) { \nmark += MACRO_MATCH . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonMatch ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nif ( template . startsWith ( MACRO_VALUE , mark ) ) { \nmark += MACRO_VALUE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonValue ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nmark ++ ; \nend = mark ; \nwhile ( end < length ) { \nif ( ! isReferenceChar ( template , end ) ) { \nbreak ; \n} \nend ++ ; \n} \nonReference ( sqlBuilder , template . substring ( mark , end ) ) ; \nend -- ; \n} \n} \n} \n} \nend ++ ; \nlast = end ; \n} \n} \n} \n"}
{"1444": "public class JsonParser { \nprivate void skipObject ( ) { \nint bracketCount = 1 ; \nboolean insideString = false ; \nwhile ( ndx < total ) { \nfinal char c = input [ ndx ] ; \nif ( insideString ) { \nif ( c == '\\\"' && notPrecededByEvenNumberOfBackslashes ( ) ) { \ninsideString = false ; \n} \n} \nelse { \nif ( c == '\\\"' ) { \ninsideString = true ; \n} \nelse { \nif ( c == '{' ) { \nbracketCount ++ ; \n} \nelse { \nif ( c == '}' ) { \nbracketCount -- ; \nif ( bracketCount == 0 ) { \nndx ++ ; \nreturn ; \n} \n} \n} \n} \n} \nndx ++ ; \n} \n} \n} \n"}
{"1449": "public class JsonParser { \nprotected Number parseNumber ( ) { \nfinal int startIndex = ndx ; \nchar c = input [ ndx ] ; \nboolean isDouble = false ; \nboolean isExp = false ; \nif ( c == '-' ) { \nndx ++ ; \n} \nwhile ( true ) { \nif ( isEOF ( ) ) { \nbreak ; \n} \nc = input [ ndx ] ; \nif ( c >= '0' && c <= '9' ) { \nndx ++ ; \ncontinue ; \n} \nif ( c <= 32 ) { \nbreak ; \n} \nif ( c == ',' || c == '}' || c == ']' ) { \nbreak ; \n} \nif ( c == '.' ) { \nisDouble = true ; \n} \nelse { \nif ( c == 'e' || c == 'E' ) { \nisExp = true ; \n} \n} \nndx ++ ; \n} \nfinal String value = new String ( input , startIndex , ndx - startIndex ) ; \nif ( isDouble ) { \nreturn Double . valueOf ( value ) ; \n} \nlong longNumber ; \nif ( isExp ) { \nlongNumber = Double . valueOf ( value ) . longValue ( ) ; \n} \nelse { \nif ( value . length ( ) >= 19 ) { \nBigInteger bigInteger = new BigInteger ( value ) ; \nif ( isGreaterThanLong ( bigInteger ) ) { \nreturn bigInteger ; \n} \nlongNumber = bigInteger . longValue ( ) ; \n} \nelse { \nlongNumber = Long . parseLong ( value ) ; \n} \n} \nif ( ( longNumber >= Integer . MIN_VALUE ) && ( longNumber <= Integer . MAX_VALUE ) ) { \nreturn ( int ) longNumber ; \n} \nreturn longNumber ; \n} \n} \n"}
{"1504": "public class MethodWriter { \nprivate void endCurrentBasicBlockWithNoSuccessor ( ) { \nif ( compute == COMPUTE_ALL_FRAMES ) { \nLabel nextBasicBlock = new Label ( ) ; \nnextBasicBlock . frame = new Frame ( nextBasicBlock ) ; \nnextBasicBlock . resolve ( code . data , code . length ) ; \nlastBasicBlock . nextBasicBlock = nextBasicBlock ; \nlastBasicBlock = nextBasicBlock ; \ncurrentBasicBlock = null ; \n} \nelse { \nif ( compute == COMPUTE_MAX_STACK_AND_LOCAL ) { \ncurrentBasicBlock . outputStackMax = ( short ) maxRelativeStackSize ; \ncurrentBasicBlock = null ; \n} \n} \n} \n} \n"}
{"1510": "public class BeanVisitor { \nprotected String [ ] getAllBeanPropertyNames ( final Class type , final boolean declared ) { \nClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( type ) ; \nPropertyDescriptor [ ] propertyDescriptors = classDescriptor . getAllPropertyDescriptors ( ) ; \nArrayList < String > names = new ArrayList < > ( propertyDescriptors . length ) ; \nfor ( PropertyDescriptor propertyDescriptor : propertyDescriptors ) { \nMethodDescriptor getter = propertyDescriptor . getReadMethodDescriptor ( ) ; \nif ( getter != null ) { \nif ( getter . matchDeclared ( declared ) ) { \nnames . add ( propertyDescriptor . getName ( ) ) ; \n} \n} \nelse { \nif ( includeFields ) { \nFieldDescriptor field = propertyDescriptor . getFieldDescriptor ( ) ; \nif ( field != null ) { \nif ( field . matchDeclared ( declared ) ) { \nnames . add ( field . getName ( ) ) ; \n} \n} \n} \n} \n} \nreturn names . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"1588": "public class Targets { \nprotected Target [ ] makeTargets ( final Target actionTarget , final MethodParam [ ] methodParams ) { \nif ( methodParams == null ) { \nreturn new Target [ ] { \nactionTarget } \n; \n} \nfinal Target [ ] target = new Target [ methodParams . length + 1 ] ; \ntarget [ 0 ] = actionTarget ; \nfinal Object action = actionTarget . value ( ) ; \nfor ( int i = 0 ; \ni < methodParams . length ; \ni ++ ) { \nfinal MethodParam methodParam = methodParams [ i ] ; \nfinal Class paramType = methodParam . type ( ) ; \nfinal Target paramTarget ; \nif ( methodParam . annotationType ( ) == null ) { \nfinal ScopeData newScopeData = methodParam . scopeData ( ) . inspector ( ) . inspectClassScopesWithCache ( paramType ) ; \nparamTarget = Target . ofValue ( createActionMethodArgument ( paramType , action ) , newScopeData ) ; \n} \nelse { \nif ( methodParam . annotationType ( ) == Out . class ) { \nparamTarget = Target . ofMethodParam ( methodParam , createActionMethodArgument ( paramType , action ) ) ; \n} \nelse { \nparamTarget = Target . ofMethodParam ( methodParam , type -> createActionMethodArgument ( type , action ) ) ; \n} \n} \ntarget [ i + 1 ] = paramTarget ; \n} \nreturn target ; \n} \n} \n"}
{"1612": "public class Frame { \nstatic int getAbstractTypeFromApiFormat ( final SymbolTable symbolTable , final Object type ) { \nif ( type instanceof Integer ) { \nreturn CONSTANT_KIND | ( ( Integer ) type ) . intValue ( ) ; \n} \nelse { \nif ( type instanceof String ) { \nString descriptor = Type . getObjectType ( ( String ) type ) . getDescriptor ( ) ; \nreturn getAbstractTypeFromDescriptor ( symbolTable , descriptor , 0 ) ; \n} \nelse { \nreturn UNINITIALIZED_KIND | symbolTable . addUninitializedType ( \"\" , ( ( Label ) type ) . bytecodeOffset ) ; \n} \n} \n} \n} \n"}
{"1620": "public class Frame { \nprivate void pop ( final String descriptor ) { \nchar firstDescriptorChar = descriptor . charAt ( 0 ) ; \nif ( firstDescriptorChar == '(' ) { \npop ( ( Type . getArgumentsAndReturnSizes ( descriptor ) >> 2 ) - 1 ) ; \n} \nelse { \nif ( firstDescriptorChar == 'J' || firstDescriptorChar == 'D' ) { \npop ( 2 ) ; \n} \nelse { \npop ( 1 ) ; \n} \n} \n} \n} \n"}
{"1622": "public class Frame { \nprivate int getInitializedType ( final SymbolTable symbolTable , final int abstractType ) { \nif ( abstractType == UNINITIALIZED_THIS || ( abstractType & ( DIM_MASK | KIND_MASK ) ) == UNINITIALIZED_KIND ) { \nfor ( int i = 0 ; \ni < initializationCount ; \n++ i ) { \nint initializedType = initializations [ i ] ; \nint dim = initializedType & DIM_MASK ; \nint kind = initializedType & KIND_MASK ; \nint value = initializedType & VALUE_MASK ; \nif ( kind == LOCAL_KIND ) { \ninitializedType = dim + inputLocals [ value ] ; \n} \nelse { \nif ( kind == STACK_KIND ) { \ninitializedType = dim + inputStack [ inputStack . length - value ] ; \n} \n} \nif ( abstractType == initializedType ) { \nif ( abstractType == UNINITIALIZED_THIS ) { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; \n} \nelse { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; \n} \n} \n} \n} \nreturn abstractType ; \n} \n} \n"}
{"1671": "public class PropertyDescriptor { \npublic Class getType ( ) { \nif ( type == null ) { \nif ( fieldDescriptor != null ) { \ntype = fieldDescriptor . getRawType ( ) ; \n} \nelse { \nif ( readMethodDescriptor != null ) { \ntype = getGetter ( true ) . getGetterRawType ( ) ; \n} \nelse { \nif ( writeMethodDescriptor != null ) { \ntype = getSetter ( true ) . getSetterRawType ( ) ; \n} \n} \n} \n} \nreturn type ; \n} \n} \n"}
{"1678": "public class ExtendedURLClassLoader { \nprotected Loading resolveLoading ( final boolean parentFirstStrategy , final String className ) { \nboolean withParent = true ; \nboolean withLoader = true ; \nif ( parentFirstStrategy ) { \nif ( isMatchingRules ( className , loaderOnlyRules ) ) { \nwithParent = false ; \n} \nelse { \nif ( isMatchingRules ( className , parentOnlyRules ) ) { \nwithLoader = false ; \n} \n} \n} \nelse { \nif ( isMatchingRules ( className , parentOnlyRules ) ) { \nwithLoader = false ; \n} \nelse { \nif ( isMatchingRules ( className , loaderOnlyRules ) ) { \nwithParent = false ; \n} \n} \n} \nreturn new Loading ( withParent , withLoader ) ; \n} \n} \n"}
{"1683": "public class ScopeDataInspector { \npublic Class < ? extends Annotation > detectAnnotationType ( final Annotation [ ] annotations ) { \nfor ( final Annotation annotation : annotations ) { \nif ( annotation instanceof In ) { \nreturn annotation . annotationType ( ) ; \n} \nelse { \nif ( annotation instanceof Out ) { \nreturn annotation . annotationType ( ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"1723": "public class DefaultClassLoaderStrategy { \nprotected Class loadArrayClassByComponentType ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { \nint ndx = className . indexOf ( '[' ) ; \nint multi = StringUtil . count ( className , '[' ) ; \nString componentTypeName = className . substring ( 0 , ndx ) ; \nClass componentType = loadClass ( componentTypeName , classLoader ) ; \nif ( multi == 1 ) { \nreturn Array . newInstance ( componentType , 0 ) . getClass ( ) ; \n} \nint [ ] multiSizes ; \nif ( multi == 2 ) { \nmultiSizes = new int [ ] { \n0 , 0 } \n; \n} \nelse { \nif ( multi == 3 ) { \nmultiSizes = new int [ ] { \n0 , 0 , 0 } \n; \n} \nelse { \nmultiSizes = ( int [ ] ) Array . newInstance ( int . class , multi ) ; \n} \n} \nreturn Array . newInstance ( componentType , multiSizes ) . getClass ( ) ; \n} \n} \n"}
{"1733": "public class DbOomQuery { \nprotected String preprocessSql ( String sqlString ) { \nif ( sqlString . charAt ( 0 ) == '{' ) { \nreturn sqlString ; \n} \nif ( ! CharUtil . isAlpha ( sqlString . charAt ( 0 ) ) ) { \nsqlString = sqlString . substring ( 1 ) ; \n} \nelse { \nif ( sqlString . indexOf ( ' ' ) != - 1 ) { \nreturn sqlString ; \n} \n} \nfinal String sqlFromMap = dbOom . queryMap ( ) . getQuery ( sqlString ) ; \nif ( sqlFromMap != null ) { \nsqlString = sqlFromMap . trim ( ) ; \n} \nreturn sqlString ; \n} \n} \n"}
{"1776": "public class Vtor { \nprotected boolean matchProfiles ( final String [ ] checkProfiles ) { \nif ( ( checkProfiles != null ) && ( checkProfiles . length == 1 ) && checkProfiles [ 0 ] . equals ( ALL_PROFILES ) ) { \nreturn true ; \n} \nif ( enabledProfiles == null || enabledProfiles . isEmpty ( ) ) { \nif ( validateAllProfilesByDefault ) { \nreturn true ; \n} \nif ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) { \nreturn true ; \n} \nfor ( String profile : checkProfiles ) { \nif ( StringUtil . isEmpty ( profile ) ) { \nreturn true ; \n} \nif ( profile . equals ( DEFAULT_PROFILE ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nif ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) { \nreturn enabledProfiles . contains ( DEFAULT_PROFILE ) ; \n} \nboolean result = false ; \nfor ( String profile : checkProfiles ) { \nboolean b = true ; \nboolean must = false ; \nif ( StringUtil . isEmpty ( profile ) ) { \nprofile = DEFAULT_PROFILE ; \n} \nelse { \nif ( profile . charAt ( 0 ) == '-' ) { \nprofile = profile . substring ( 1 ) ; \nb = false ; \n} \nelse { \nif ( profile . charAt ( 0 ) == '+' ) { \nprofile = profile . substring ( 1 ) ; \nmust = true ; \n} \n} \n} \nif ( enabledProfiles . contains ( profile ) ) { \nif ( ! b ) { \nreturn false ; \n} \nresult = true ; \n} \nelse { \nif ( must ) { \nreturn false ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"1792": "public class SignatureReader { \nprivate static int parseType ( final String signature , final int startOffset , final SignatureVisitor signatureVisitor ) { \nint offset = startOffset ; \nchar currentChar = signature . charAt ( offset ++ ) ; \nswitch ( currentChar ) { \ncase 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : case 'F' : case 'J' : case 'D' : case 'V' : signatureVisitor . visitBaseType ( currentChar ) ; \nreturn offset ; \ncase '[' : return parseType ( signature , offset , signatureVisitor . visitArrayType ( ) ) ; \ncase 'T' : int endOffset = signature . indexOf ( ';' , offset ) ; \nsignatureVisitor . visitTypeVariable ( signature . substring ( offset , endOffset ) ) ; \nreturn endOffset + 1 ; \ncase 'L' : int start = offset ; \nboolean visited = false ; \nboolean inner = false ; \nwhile ( true ) { \ncurrentChar = signature . charAt ( offset ++ ) ; \nif ( currentChar == '.' || currentChar == ';' ) { \nif ( ! visited ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( inner ) { \nsignatureVisitor . visitInnerClassType ( name ) ; \n} \nelse { \nsignatureVisitor . visitClassType ( name ) ; \n} \n} \nif ( currentChar == ';' ) { \nsignatureVisitor . visitEnd ( ) ; \nbreak ; \n} \nstart = offset ; \nvisited = false ; \ninner = true ; \n} \nelse { \nif ( currentChar == '<' ) { \nString name = signature . substring ( start , offset - 1 ) ; \nif ( inner ) { \nsignatureVisitor . visitInnerClassType ( name ) ; \n} \nelse { \nsignatureVisitor . visitClassType ( name ) ; \n} \nvisited = true ; \nwhile ( ( currentChar = signature . charAt ( offset ) ) != '>' ) { \nswitch ( currentChar ) { \ncase '*' : ++ offset ; \nsignatureVisitor . visitTypeArgument ( ) ; \nbreak ; \ncase '+' : case '-' : offset = parseType ( signature , offset + 1 , signatureVisitor . visitTypeArgument ( currentChar ) ) ; \nbreak ; \ndefault : offset = parseType ( signature , offset , signatureVisitor . visitTypeArgument ( '=' ) ) ; \nbreak ; \n} \n} \n} \n} \n} \nreturn offset ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \n} \n} \n"}
{"1803": "public class CsvUtil { \npublic static String [ ] toStringArray ( final String line ) { \nList < String > row = new ArrayList < > ( ) ; \nboolean inQuotedField = false ; \nint fieldStart = 0 ; \nfinal int len = line . length ( ) ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar c = line . charAt ( i ) ; \nif ( c == FIELD_SEPARATOR ) { \nif ( ! inQuotedField ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 1 ; \n} \n} \nelse { \nif ( c == FIELD_QUOTE ) { \nif ( inQuotedField ) { \nif ( i + 1 == len || line . charAt ( i + 1 ) == FIELD_SEPARATOR ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 2 ; \ni ++ ; \ninQuotedField = false ; \n} \n} \nelse { \nif ( fieldStart == i ) { \ninQuotedField = true ; \nfieldStart ++ ; \n} \n} \n} \n} \n} \nif ( len > 0 && fieldStart <= len ) { \naddField ( row , line , fieldStart , len , inQuotedField ) ; \n} \nreturn row . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"1858": "public class PublicationImage { \nvoid addDestination ( final int transportIndex , final ReceiveDestinationUdpTransport transport ) { \nimageConnections = ArrayUtil . ensureCapacity ( imageConnections , transportIndex + 1 ) ; \nif ( transport . isMulticast ( ) ) { \nimageConnections [ transportIndex ] = new ImageConnection ( cachedNanoClock . nanoTime ( ) , transport . udpChannel ( ) . remoteControl ( ) ) ; \n} \nelse { \nif ( transport . hasExplicitControl ( ) ) { \nimageConnections [ transportIndex ] = new ImageConnection ( cachedNanoClock . nanoTime ( ) , transport . explicitControlAddress ( ) ) ; \n} \n} \n} \n} \n"}
{"1867": "public class NetworkPublication { \nfinal int updatePublisherLimit ( ) { \nint workCount = 0 ; \nfinal long senderPosition = this . senderPosition . getVolatile ( ) ; \nif ( hasReceivers || ( spiesSimulateConnection && spyPositions . length > 0 ) ) { \nlong minConsumerPosition = senderPosition ; \nfor ( final ReadablePosition spyPosition : spyPositions ) { \nminConsumerPosition = Math . min ( minConsumerPosition , spyPosition . getVolatile ( ) ) ; \n} \nfinal long proposedPublisherLimit = minConsumerPosition + termWindowLength ; \nif ( publisherLimit . proposeMaxOrdered ( proposedPublisherLimit ) ) { \ncleanBuffer ( proposedPublisherLimit ) ; \nworkCount = 1 ; \n} \n} \nelse { \nif ( publisherLimit . get ( ) > senderPosition ) { \npublisherLimit . setOrdered ( senderPosition ) ; \n} \n} \nreturn workCount ; \n} \n} \n"}
{"1879": "public class UdpChannelTransport { \npublic void openDatagramChannel ( final AtomicCounter statusIndicator ) { \ntry { \nsendDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; \nreceiveDatagramChannel = sendDatagramChannel ; \nif ( udpChannel . isMulticast ( ) ) { \nif ( null != connectAddress ) { \nreceiveDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; \n} \nreceiveDatagramChannel . setOption ( StandardSocketOptions . SO_REUSEADDR , true ) ; \nreceiveDatagramChannel . bind ( new InetSocketAddress ( endPointAddress . getPort ( ) ) ) ; \nreceiveDatagramChannel . join ( endPointAddress . getAddress ( ) , udpChannel . localInterface ( ) ) ; \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_IF , udpChannel . localInterface ( ) ) ; \nif ( udpChannel . isHasMulticastTtl ( ) ) { \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , udpChannel . multicastTtl ( ) ) ; \nmulticastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; \n} \nelse { \nif ( context . socketMulticastTtl ( ) != 0 ) { \nsendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , context . socketMulticastTtl ( ) ) ; \nmulticastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; \n} \n} \n} \nelse { \nsendDatagramChannel . bind ( bindAddress ) ; \n} \nif ( null != connectAddress ) { \nsendDatagramChannel . connect ( connectAddress ) ; \n} \nif ( 0 != context . socketSndbufLength ( ) ) { \nsendDatagramChannel . setOption ( SO_SNDBUF , context . socketSndbufLength ( ) ) ; \n} \nif ( 0 != context . socketRcvbufLength ( ) ) { \nreceiveDatagramChannel . setOption ( SO_RCVBUF , context . socketRcvbufLength ( ) ) ; \n} \nsendDatagramChannel . configureBlocking ( false ) ; \nreceiveDatagramChannel . configureBlocking ( false ) ; \n} \ncatch ( final IOException ex ) { \nif ( null != statusIndicator ) { \nstatusIndicator . setOrdered ( ChannelEndpointStatus . ERRORED ) ; \n} \nCloseHelper . quietClose ( sendDatagramChannel ) ; \nif ( receiveDatagramChannel != sendDatagramChannel ) { \nCloseHelper . quietClose ( receiveDatagramChannel ) ; \n} \nsendDatagramChannel = null ; \nreceiveDatagramChannel = null ; \nthrow new AeronException ( \"channel error - \" + ex . getMessage ( ) + \" (at \" + ex . getStackTrace ( ) [ 0 ] . toString ( ) + \"): \" + udpChannel . originalUriString ( ) , ex ) ; \n} \n} \n} \n"}
{"1881": "public class UdpChannelTransport { \npublic boolean isValidFrame ( final UnsafeBuffer buffer , final int length ) { \nboolean isFrameValid = true ; \nif ( frameVersion ( buffer , 0 ) != HeaderFlyweight . CURRENT_VERSION ) { \nisFrameValid = false ; \ninvalidPackets . increment ( ) ; \n} \nelse { \nif ( length < HeaderFlyweight . MIN_HEADER_LENGTH ) { \nisFrameValid = false ; \ninvalidPackets . increment ( ) ; \n} \n} \nreturn isFrameValid ; \n} \n} \n"}
{"1884": "public class RetransmitHandler { \npublic void processTimeouts ( final long nowNs , final RetransmitSender retransmitSender ) { \nif ( activeRetransmitsMap . size ( ) > 0 ) { \nfor ( final RetransmitAction action : retransmitActionPool ) { \nif ( DELAYED == action . state && ( action . expireNs - nowNs < 0 ) ) { \nretransmitSender . resend ( action . termId , action . termOffset , action . length ) ; \naction . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; \n} \nelse { \nif ( LINGERING == action . state && ( action . expireNs - nowNs < 0 ) ) { \naction . cancel ( ) ; \nactiveRetransmitsMap . remove ( action . termId , action . termOffset ) ; \n} \n} \n} \n} \n} \n} \n"}
{"1976": "public class CapacityByteArrayOutputStream { \nprivate void addSlab ( int minimumSize ) { \nint nextSlabSize ; \nif ( bytesUsed == 0 ) { \nnextSlabSize = initialSlabSize ; \n} \nelse { \nif ( bytesUsed > maxCapacityHint / 5 ) { \nnextSlabSize = maxCapacityHint / 5 ; \n} \nelse { \nnextSlabSize = bytesUsed ; \n} \n} \nif ( nextSlabSize < minimumSize ) { \nLOG . debug ( \"slab size {} too small for value of size {}. Bumping up slab size\" , nextSlabSize , minimumSize ) ; \nnextSlabSize = minimumSize ; \n} \nLOG . debug ( \"used {} slabs, adding new slab of size {}\" , slabs . size ( ) , nextSlabSize ) ; \nthis . currentSlab = allocator . allocate ( nextSlabSize ) ; \nthis . slabs . add ( currentSlab ) ; \nthis . bytesAllocated += nextSlabSize ; \nthis . currentSlabIndex = 0 ; \n} \n} \n"}
{"2009": "public class Schemas { \npublic static boolean nullOk ( Schema schema ) { \nif ( Schema . Type . NULL == schema . getType ( ) ) { \nreturn true ; \n} \nelse { \nif ( Schema . Type . UNION == schema . getType ( ) ) { \nfor ( Schema possible : schema . getTypes ( ) ) { \nif ( nullOk ( possible ) ) { \nreturn true ; \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"2025": "public class AvroSchemaConverter { \npublic static Schema getNonNull ( Schema schema ) { \nif ( schema . getType ( ) . equals ( Schema . Type . UNION ) ) { \nList < Schema > schemas = schema . getTypes ( ) ; \nif ( schemas . size ( ) == 2 ) { \nif ( schemas . get ( 0 ) . getType ( ) . equals ( Schema . Type . NULL ) ) { \nreturn schemas . get ( 1 ) ; \n} \nelse { \nif ( schemas . get ( 1 ) . getType ( ) . equals ( Schema . Type . NULL ) ) { \nreturn schemas . get ( 0 ) ; \n} \nelse { \nreturn schema ; \n} \n} \n} \nelse { \nreturn schema ; \n} \n} \nelse { \nreturn schema ; \n} \n} \n} \n"}
{"2083": "public class PipelineBeanCreator { \npublic StageBean createStageBean ( boolean forExecution , StageLibraryTask library , StageConfiguration stageConf , boolean validateAnnotations , boolean errorStage , boolean pipelineLifecycleStage , Map < String , Object > constants , InterceptorCreatorContextBuilder interceptorContextBuilder , List < Issue > errors ) { \nIssueCreator issueCreator = IssueCreator . getStage ( stageConf . getInstanceName ( ) ) ; \nStageBean bean = null ; \nStageDefinition stageDef = library . getStage ( stageConf . getLibrary ( ) , stageConf . getStageName ( ) , forExecution ) ; \nif ( stageDef != null ) { \nif ( validateAnnotations ) { \nif ( pipelineLifecycleStage ) { \nif ( ! stageDef . isPipelineLifecycleStage ( ) ) { \nerrors . add ( issueCreator . create ( CreationError . CREATION_018 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; \n} \n} \nelse { \nif ( stageDef . isErrorStage ( ) != errorStage ) { \nif ( stageDef . isErrorStage ( ) ) { \nerrors . add ( issueCreator . create ( CreationError . CREATION_007 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; \n} \nelse { \nerrors . add ( issueCreator . create ( CreationError . CREATION_008 , stageDef . getLibraryLabel ( ) , stageDef . getLabel ( ) , stageConf . getStageVersion ( ) ) ) ; \n} \n} \n} \n} \nbean = createStage ( library , stageDef , library , stageConf , serviceClass -> library . getServiceDefinition ( serviceClass , true ) , interceptorContextBuilder , constants , errors ) ; \n} \nelse { \nerrors . add ( issueCreator . create ( CreationError . CREATION_006 , stageConf . getLibrary ( ) , stageConf . getStageName ( ) , stageConf . getStageVersion ( ) ) ) ; \n} \nreturn bean ; \n} \n} \n"}
{"2090": "public class RecordWriter { \npublic long getLength ( ) throws IOException { \nlong length = - 1 ; \nif ( generator != null ) { \nlength = textOutputStream . getByteCount ( ) ; \n} \nelse { \nif ( seqWriter != null ) { \nlength = seqWriter . getLength ( ) ; \n} \n} \nreturn length ; \n} \n} \n"}
{"2114": "public class ProtobufTypeUtil { \nprivate static DynamicMessage sdcFieldToProtobufMsg ( Record record , Field field , String fieldPath , Descriptors . Descriptor desc , Map < String , Set < Descriptors . FieldDescriptor > > messageTypeToExtensionMap , Map < String , Object > defaultValueMap ) throws DataGeneratorException { \nif ( field == null ) { \nreturn null ; \n} \nDynamicMessage . Builder builder = DynamicMessage . newBuilder ( desc ) ; \nList < Descriptors . FieldDescriptor > fields = new ArrayList < > ( ) ; \nfields . addAll ( desc . getFields ( ) ) ; \nif ( messageTypeToExtensionMap . containsKey ( desc . getFullName ( ) ) ) { \nfields . addAll ( messageTypeToExtensionMap . get ( desc . getFullName ( ) ) ) ; \n} \nMap < String , Field > valueAsMap = field . getValueAsMap ( ) ; \nfor ( Descriptors . FieldDescriptor f : fields ) { \nField mapField = valueAsMap . get ( f . getName ( ) ) ; \nif ( f . isMapField ( ) ) { \nhandleMapField ( record , mapField , fieldPath , messageTypeToExtensionMap , defaultValueMap , f , builder ) ; \n} \nelse { \nif ( f . isRepeated ( ) ) { \nif ( mapField != null ) { \nhandleRepeatedField ( record , mapField , fieldPath , messageTypeToExtensionMap , defaultValueMap , f , builder ) ; \n} \n} \nelse { \nhandleNonRepeatedField ( record , valueAsMap , fieldPath , messageTypeToExtensionMap , defaultValueMap , desc , f , builder ) ; \n} \n} \n} \ntry { \nhandleUnknownFields ( record , fieldPath , builder ) ; \n} \ncatch ( IOException e ) { \nthrow new DataGeneratorException ( Errors . PROTOBUF_05 , e . toString ( ) , e ) ; \n} \nreturn builder . build ( ) ; \n} \n} \n"}
{"2122": "public class HttpProcessor { \nprivate Record parseResponse ( InputStream response ) throws StageException { \nRecord record = null ; \nif ( conf . httpMethod == HttpMethod . HEAD ) { \nrecord = getContext ( ) . createRecord ( \"\" ) ; \nrecord . set ( Field . create ( new HashMap ( ) ) ) ; \n} \nelse { \nif ( response != null ) { \ntry ( DataParser parser = parserFactory . getParser ( \"\" , response , \"0\" ) ) { \nrecord = parser . parse ( ) ; \nif ( conf . dataFormat == DataFormat . TEXT ) { \nrecord . set ( record . get ( \"/text\" ) ) ; \n} \n} \ncatch ( IOException | DataParserException e ) { \nerrorRecordHandler . onError ( Errors . HTTP_00 , e . toString ( ) , e ) ; \n} \n} \n} \nreturn record ; \n} \n} \n"}
{"2123": "public class HttpProcessor { \nprivate void addResponseHeaders ( Record record , Response response ) throws StageException { \nif ( conf . headerOutputLocation == HeaderOutputLocation . NONE ) { \nreturn ; \n} \nRecord . Header header = record . getHeader ( ) ; \nif ( conf . headerOutputLocation == HeaderOutputLocation . FIELD ) { \nwriteResponseHeaderToField ( record , response ) ; \n} \nelse { \nif ( conf . headerOutputLocation == HeaderOutputLocation . HEADER ) { \nwriteResponseHeaderToRecordHeader ( response , header ) ; \n} \n} \n} \n} \n"}
{"2129": "public class HttpClientSource { \nprivate void incrementSourceOffset ( HttpSourceOffset sourceOffset , int increment ) { \nif ( conf . pagination . mode == PaginationMode . BY_PAGE ) { \nsourceOffset . incrementStartAt ( 1 ) ; \n} \nelse { \nif ( conf . pagination . mode == PaginationMode . BY_OFFSET ) { \nsourceOffset . incrementStartAt ( increment ) ; \n} \n} \n} \n} \n"}
{"2133": "public class HttpClientSource { \nprivate Optional < String > processResponse ( long start , int maxRecords , BatchMaker batchMaker ) throws StageException { \nOptional < String > newSourceOffset = Optional . empty ( ) ; \nif ( getResponse ( ) == null ) { \nreturn newSourceOffset ; \n} \nint status = getResponse ( ) . getStatus ( ) ; \nif ( status < 200 || status >= 300 ) { \nlastRequestCompletedTime = System . currentTimeMillis ( ) ; \nString reason = getResponse ( ) . getStatusInfo ( ) . getReasonPhrase ( ) ; \nString respString = getResponse ( ) . readEntity ( String . class ) ; \ngetResponse ( ) . close ( ) ; \nsetResponse ( null ) ; \nfinal String errorMsg = reason + \" : \" + respString ; \nLOG . warn ( Errors . HTTP_01 . getMessage ( ) , status , errorMsg ) ; \nerrorRecordHandler . onError ( Errors . HTTP_01 , status , errorMsg ) ; \nreturn newSourceOffset ; \n} \nif ( conf . pagination . mode == PaginationMode . LINK_HEADER ) { \nnext = getResponse ( ) . getLink ( \"next\" ) ; \nif ( next == null ) { \nhaveMorePages = false ; \n} \n} \nif ( getResponse ( ) . hasEntity ( ) ) { \nnewSourceOffset = Optional . of ( parseResponse ( start , maxRecords , batchMaker ) ) ; \n} \nelse { \nif ( conf . httpMethod . getLabel ( ) == \"HEAD\" ) { \nnewSourceOffset = Optional . of ( parseHeadersOnly ( batchMaker ) ) ; \n} \n} \nreturn newSourceOffset ; \n} \n} \n"}
{"2174": "public class SyslogDecoder { \npublic static long parseRfc3164Time ( String ts ) throws OnRecordErrorException { \nLocalDateTime now = LocalDateTime . now ( ) ; \nint year = now . getYear ( ) ; \nts = TWO_SPACES . matcher ( ts ) . replaceFirst ( \" \" ) ; \nLocalDateTime date ; \ntry { \nMonthDay monthDay = MonthDay . parse ( ts , rfc3164Format ) ; \nLocalTime time = LocalTime . parse ( ts , rfc3164Format ) ; \ndate = now ; \ndate = date . with ( ChronoField . MILLI_OF_SECOND , 0 ) ; \ndate = date . withMonth ( monthDay . getMonthValue ( ) ) . withDayOfMonth ( monthDay . getDayOfMonth ( ) ) ; \ndate = date . withHour ( time . getHour ( ) ) . withMinute ( time . getMinute ( ) ) . withSecond ( time . getSecond ( ) ) ; \n} \ncatch ( DateTimeParseException e ) { \nthrow new OnRecordErrorException ( Errors . SYSLOG_10 , ts , e ) ; \n} \nLocalDateTime fixed = date ; \nif ( fixed . isAfter ( now ) && fixed . minusMonths ( 1 ) . isAfter ( now ) ) { \nfixed = date . withYear ( year - 1 ) ; \n} \nelse { \nif ( fixed . isBefore ( now ) && fixed . plusMonths ( 11 ) . isBefore ( now ) ) { \nfixed = date . withYear ( year + 1 ) ; \n} \n} \ndate = fixed ; \nreturn date . toInstant ( ZoneOffset . UTC ) . toEpochMilli ( ) ; \n} \n} \n"}
{"2221": "public class FieldHasherProcessor { \nprivate Set < String > validateAndExtractFieldsToHash ( Record record , Set < String > fieldsDontExist , Set < String > fieldsWithListOrMapType , Set < String > fieldsWithNull , Collection < String > matchingFieldsPath ) { \nSet < String > validFieldsToHashForThisConfig = new HashSet < String > ( ) ; \nfor ( String matchingFieldPath : matchingFieldsPath ) { \nif ( record . has ( matchingFieldPath ) ) { \nField field = record . get ( matchingFieldPath ) ; \nif ( UNSUPPORTED_FIELD_TYPES . contains ( field . getType ( ) ) ) { \nfieldsWithListOrMapType . add ( matchingFieldPath ) ; \n} \nelse { \nif ( field . getValue ( ) == null ) { \nfieldsWithNull . add ( matchingFieldPath ) ; \n} \nelse { \nvalidFieldsToHashForThisConfig . add ( matchingFieldPath ) ; \n} \n} \n} \nelse { \nfieldsDontExist . add ( matchingFieldPath ) ; \n} \n} \nreturn validFieldsToHashForThisConfig ; \n} \n} \n"}
{"2235": "public class HttpClientCommon { \nprivate void configureAuthAndBuildClient ( ClientBuilder clientBuilder , List < Stage . ConfigIssue > issues ) { \nif ( jerseyClientConfig . authType == AuthenticationType . OAUTH ) { \nString consumerKey = jerseyClientConfig . oauth . resolveConsumerKey ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString consumerSecret = jerseyClientConfig . oauth . resolveConsumerSecret ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString token = jerseyClientConfig . oauth . resolveToken ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nString tokenSecret = jerseyClientConfig . oauth . resolveTokenSecret ( context , \"CREDENTIALS\" , \"conf.oauth.\" , issues ) ; \nif ( issues . isEmpty ( ) ) { \nauthToken = JerseyClientUtil . configureOAuth1 ( consumerKey , consumerSecret , token , tokenSecret , clientBuilder ) ; \n} \n} \nelse { \nif ( jerseyClientConfig . authType . isOneOf ( AuthenticationType . DIGEST , AuthenticationType . BASIC , AuthenticationType . UNIVERSAL ) ) { \nString username = jerseyClientConfig . basicAuth . resolveUsername ( context , \"CREDENTIALS\" , \"conf.basicAuth.\" , issues ) ; \nString password = jerseyClientConfig . basicAuth . resolvePassword ( context , \"CREDENTIALS\" , \"conf.basicAuth.\" , issues ) ; \nif ( issues . isEmpty ( ) ) { \nJerseyClientUtil . configurePasswordAuth ( jerseyClientConfig . authType , username , password , clientBuilder ) ; \n} \n} \n} \ntry { \nbuildNewAuthenticatedClient ( issues , false ) ; \nclientInitialized = true ; \n} \ncatch ( StageException e ) { \nExceptionUtils . throwUndeclared ( e ) ; \n} \n} \n} \n"}
{"2283": "public class BigQueryDelegate { \npublic TableResult runQuery ( QueryJobConfiguration queryConfig , long timeout , long pageSize ) throws StageException { \ncheckArgument ( timeout >= 1000 , \"Timeout must be at least one second.\" ) ; \nInstant maxTime = Instant . now ( ) . plusMillis ( timeout ) ; \nJobId jobId = JobId . of ( UUID . randomUUID ( ) . toString ( ) ) ; \nJobInfo jobInfo = JobInfo . newBuilder ( queryConfig ) . setJobId ( jobId ) . build ( ) ; \nJob queryJob = bigquery . create ( jobInfo ) ; \nif ( queryJob == null ) { \nLOG . error ( \"Job no longer exists: {}\" , jobInfo ) ; \nthrow new RuntimeException ( \"Job no longer exists: \" + jobInfo ) ; \n} \nelse { \nif ( queryJob . getStatus ( ) . getError ( ) != null ) { \nBigQueryError error = queryJob . getStatus ( ) . getError ( ) ; \nLOG . error ( \"Query Job execution error: {}\" , error ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , error ) ; \n} \n} \nwhile ( ! queryJob . isDone ( ) ) { \nif ( Instant . now ( clock ) . isAfter ( maxTime ) || ! ThreadUtil . sleep ( 100 ) ) { \nif ( bigquery . cancel ( queryJob . getJobId ( ) ) ) { \nLOG . info ( \"Job {} cancelled successfully.\" , queryJob . getJobId ( ) ) ; \n} \nelse { \nLOG . warn ( \"Job {} not found\" , queryJob . getJobId ( ) ) ; \n} \nthrow new StageException ( Errors . BIGQUERY_00 ) ; \n} \n} \nif ( queryJob . getStatus ( ) . getError ( ) != null ) { \nString errorMsg = queryJob . getStatus ( ) . getError ( ) . toString ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nTableResult result = null ; \ntry { \nresult = queryJob . getQueryResults ( QueryResultsOption . pageSize ( pageSize ) ) ; \n} \ncatch ( InterruptedException e ) { \nString errorMsg = e . getMessage ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nreturn result ; \n} \n} \n"}
{"2284": "public class BigQueryDelegate { \npublic LinkedHashMap < String , Field > fieldsToMap ( List < com . google . cloud . bigquery . Field > schema , List < FieldValue > values ) { \ncheckState ( schema . size ( ) == values . size ( ) , \"Schema '{}' and Values '{}' sizes do not match.\" , schema . size ( ) , values . size ( ) ) ; \nLinkedHashMap < String , Field > root = new LinkedHashMap < > ( ) ; \nfor ( int i = 0 ; \ni < values . size ( ) ; \ni ++ ) { \nFieldValue value = values . get ( i ) ; \ncom . google . cloud . bigquery . Field field = schema . get ( i ) ; \nif ( value . getAttribute ( ) . equals ( FieldValue . Attribute . PRIMITIVE ) ) { \nroot . put ( field . getName ( ) , fromPrimitiveField ( field , value ) ) ; \n} \nelse { \nif ( value . getAttribute ( ) . equals ( FieldValue . Attribute . RECORD ) ) { \nroot . put ( field . getName ( ) , Field . create ( fieldsToMap ( field . getSubFields ( ) , value . getRecordValue ( ) ) ) ) ; \n} \nelse { \nif ( value . getAttribute ( ) . equals ( FieldValue . Attribute . REPEATED ) ) { \nroot . put ( field . getName ( ) , Field . create ( fromRepeatedField ( field , value . getRepeatedValue ( ) ) ) ) ; \n} \n} \n} \n} \nreturn root ; \n} \n} \n"}
{"2286": "public class KineticaTableUtils { \nprivate void validateTableAcceptsInserts ( ) throws GPUdbException { \nfor ( String s : tableDescription ) { \nif ( s . equalsIgnoreCase ( \"COLLECTION\" ) ) { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a Collection\" ) ; \n} \nelse { \nif ( s . equalsIgnoreCase ( \"VIEW\" ) ) { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a View\" ) ; \n} \nelse { \nif ( s . equalsIgnoreCase ( \"JOIN\" ) ) { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a Join Table\" ) ; \n} \nelse { \nif ( s . equalsIgnoreCase ( \"RESULT_TABLE\" ) ) { \nthrow new GPUdbException ( \"Error: table \" + tableName + \" is a Result Table\" ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"2291": "public class KineticaTableUtils { \nprivate Class < ? > getClassForType ( String typeName ) throws GPUdbException { \ntypeName = typeName . replace ( \" \" , \"\" ) ; \nif ( typeName . equalsIgnoreCase ( STRING_TYPE_NAME ) ) { \nreturn String . class ; \n} \nelse { \nif ( typeName . equalsIgnoreCase ( LONG_TYPE_NAME ) ) { \nreturn Long . class ; \n} \nelse { \nif ( typeName . equalsIgnoreCase ( INTEGER_TYPE_NAME ) ) { \nreturn Integer . class ; \n} \nelse { \nif ( typeName . equalsIgnoreCase ( FLOAT_TYPE_NAME ) ) { \nreturn Float . class ; \n} \nelse { \nif ( typeName . equalsIgnoreCase ( DOUBLE_TYPE_NAME ) ) { \nreturn Double . class ; \n} \nelse { \nif ( typeName . equalsIgnoreCase ( BYTES_TYPE_NAME ) ) { \nreturn ByteBuffer . class ; \n} \nelse { \nthrow new GPUdbException ( \"Error: unknown type '\" + typeName + \"' in table schema\" ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"2308": "public class LoginManager { \npublic void release ( ) { \nsynchronized ( LoginManager . class ) { \nif ( refCount == 0 ) throw new IllegalStateException ( \"release called on LoginManager with refCount == 0\" ) ; \nelse { \nif ( refCount == 1 ) { \nCACHED_INSTANCES . remove ( loginType ) ; \nlogin . shutdown ( ) ; \n} \n} \n-- refCount ; \n} \n} \n} \n"}
{"2314": "public class CassandraTarget { \n@ SuppressWarnings ( \"unchecked\" ) private BoundStatement recordToBoundStatement ( Record record ) throws StageException { \nImmutableList . Builder < Object > values = new ImmutableList . Builder < > ( ) ; \nSortedSet < String > columnsPresent = Sets . newTreeSet ( columnMappings . keySet ( ) ) ; \nfor ( Map . Entry < String , String > mapping : columnMappings . entrySet ( ) ) { \nString columnName = mapping . getKey ( ) ; \nString fieldPath = mapping . getValue ( ) ; \nif ( ! record . has ( fieldPath ) || record . get ( fieldPath ) . getValue ( ) == null ) { \ncolumnsPresent . remove ( columnName ) ; \ncontinue ; \n} \nfinal Object value = record . get ( fieldPath ) . getValue ( ) ; \nif ( value instanceof List ) { \nList < Object > unpackedList = new ArrayList < > ( ) ; \nfor ( Field item : ( List < Field > ) value ) { \nunpackedList . add ( item . getValue ( ) ) ; \n} \nvalues . add ( unpackedList ) ; \n} \nelse { \nif ( value instanceof Map ) { \nMap < Object , Object > unpackedMap = new HashMap < > ( ) ; \nfor ( Map . Entry < String , Field > entry : ( ( Map < String , Field > ) value ) . entrySet ( ) ) { \nunpackedMap . put ( entry . getKey ( ) , entry . getValue ( ) . getValue ( ) ) ; \n} \nvalues . add ( unpackedMap ) ; \n} \nelse { \nvalues . add ( value ) ; \n} \n} \n} \nPreparedStatement stmt = statementCache . getUnchecked ( columnsPresent ) ; \nObject [ ] valuesArray = values . build ( ) . toArray ( ) ; \nBoundStatement boundStmt = null ; \ntry { \nboundStmt = stmt . bind ( valuesArray ) ; \n} \ncatch ( CodecNotFoundException | InvalidTypeException | NullPointerException e ) { \nerrorRecordHandler . onError ( new OnRecordErrorException ( record , Errors . CASSANDRA_06 , record . getHeader ( ) . getSourceId ( ) , e . toString ( ) , e ) ) ; \n} \nreturn boundStmt ; \n} \n} \n"}
{"2317": "public class MultithreadedTableProvider { \nprivate void handlePartitioningTurnedOffOrOn ( SortedSetMultimap < TableContext , TableRuntimeContext > reconstructedPartitions ) { \nfor ( TableContext tableContext : reconstructedPartitions . keySet ( ) ) { \nfinal SortedSet < TableRuntimeContext > partitions = reconstructedPartitions . get ( tableContext ) ; \nfinal TableRuntimeContext lastPartition = partitions . last ( ) ; \nfinal TableContext sourceTableContext = lastPartition . getSourceTableContext ( ) ; \nUtils . checkState ( sourceTableContext . equals ( tableContext ) , String . format ( \"Source table context for %s should match TableContext map key of %s\" , lastPartition . getDescription ( ) , tableContext . getQualifiedName ( ) ) ) ; \nfinal boolean partitioningTurnedOff = lastPartition . isPartitioned ( ) && sourceTableContext . getPartitioningMode ( ) == PartitioningMode . DISABLED ; \nfinal boolean partitioningTurnedOn = ! lastPartition . isPartitioned ( ) && sourceTableContext . isPartitionable ( ) && sourceTableContext . getPartitioningMode ( ) != PartitioningMode . DISABLED ; \nif ( ! partitioningTurnedOff && ! partitioningTurnedOn ) { \ncontinue ; \n} \nfinal Map < String , String > nextStartingOffsets = new HashMap < > ( ) ; \nfinal Map < String , String > nextMaxOffsets = new HashMap < > ( ) ; \nfinal int newPartitionSequence = lastPartition . getPartitionSequence ( ) > 0 ? lastPartition . getPartitionSequence ( ) + 1 : 1 ; \nif ( partitioningTurnedOff ) { \nLOG . info ( \"Table {} has switched from partitioned to non-partitioned; partition sequence {} will be the last (with\" + \" no max offsets)\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStartOffset = lastPartition . generateNextPartitionOffset ( col , off ) ; \nnextStartingOffsets . put ( col , basedOnStartOffset ) ; \n} \n) ; \n} \nelse { \nif ( partitioningTurnedOn ) { \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStoredOffset = lastPartition . getInitialStoredOffsets ( ) . get ( col ) ; \nnextStartingOffsets . put ( col , basedOnStoredOffset ) ; \n} \n) ; \nnextStartingOffsets . forEach ( ( col , off ) -> nextMaxOffsets . put ( col , lastPartition . generateNextPartitionOffset ( col , off ) ) ) ; \nif ( ! reconstructedPartitions . remove ( sourceTableContext , lastPartition ) ) { \nthrow new IllegalStateException ( String . format ( \"Failed to remove partition %s for table %s in switching partitioning from off to on\" , lastPartition . getDescription ( ) , sourceTableContext . getQualifiedName ( ) ) ) ; \n} \nLOG . info ( \"Table {} has switched from non-partitioned to partitioned; using last stored offsets as the starting\" + \" offsets for the new partition {}\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \n} \n} \nfinal TableRuntimeContext nextPartition = new TableRuntimeContext ( sourceTableContext , lastPartition . isUsingNonIncrementalLoad ( ) , ( lastPartition . isPartitioned ( ) && ! partitioningTurnedOff ) || partitioningTurnedOn , newPartitionSequence , nextStartingOffsets , nextMaxOffsets ) ; \nreconstructedPartitions . put ( sourceTableContext , nextPartition ) ; \n} \n} \n} \n"}
{"2407": "public class ConfigValueExtractor { \nprivate Object extractAsRuntime ( Field field , String valueStr ) { \nif ( field . getType ( ) == Byte . TYPE || field . getType ( ) == Byte . class || field . getType ( ) == Short . TYPE || field . getType ( ) == Short . class || field . getType ( ) == Integer . TYPE || field . getType ( ) == Integer . class || field . getType ( ) == Long . TYPE || field . getType ( ) == Long . class || field . getType ( ) == Float . TYPE || field . getType ( ) == Float . class || field . getType ( ) == Double . TYPE || field . getType ( ) == Double . class ) { \nreturn extractAsNumber ( field , valueStr ) ; \n} \nelse { \nif ( String . class . isAssignableFrom ( field . getType ( ) ) ) { \nreturn valueStr ; \n} \n} \nthrow new IllegalArgumentException ( Utils . format ( \"Invalid type for RUNTIME type: {}\" , field . getType ( ) ) ) ; \n} \n} \n"}
{"2444": "public class HTTPSession { \npublic long getBodySize ( ) { \nif ( this . headers . containsKey ( \"content-length\" ) ) { \nreturn Long . parseLong ( this . headers . get ( \"content-length\" ) ) ; \n} \nelse { \nif ( this . splitbyte < this . rlen ) { \nreturn this . rlen - this . splitbyte ; \n} \n} \nreturn 0 ; \n} \n} \n"}
{"2451": "public class Response { \npublic void send ( OutputStream outputStream ) { \nSimpleDateFormat gmtFrmt = new SimpleDateFormat ( \"E, d MMM yyyy HH:mm:ss 'GMT'\" , Locale . US ) ; \ngmtFrmt . setTimeZone ( TimeZone . getTimeZone ( \"GMT\" ) ) ; \ntry { \nif ( this . status == null ) { \nthrow new Error ( \"sendResponse(): Status can't be null.\" ) ; \n} \nPrintWriter pw = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( outputStream , new ContentType ( this . mimeType ) . getEncoding ( ) ) ) , false ) ; \npw . append ( \"HTTP/1.1 \" ) . append ( this . status . getDescription ( ) ) . append ( \" \\r\\n\" ) ; \nif ( this . mimeType != null ) { \nprintHeader ( pw , \"Content-Type\" , this . mimeType ) ; \n} \nif ( getHeader ( \"date\" ) == null ) { \nprintHeader ( pw , \"Date\" , gmtFrmt . format ( new Date ( ) ) ) ; \n} \nfor ( Entry < String , String > entry : this . header . entrySet ( ) ) { \nprintHeader ( pw , entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nfor ( String cookieHeader : this . cookieHeaders ) { \nprintHeader ( pw , \"Set-Cookie\" , cookieHeader ) ; \n} \nif ( getHeader ( \"connection\" ) == null ) { \nprintHeader ( pw , \"Connection\" , ( this . keepAlive ? \"keep-alive\" : \"close\" ) ) ; \n} \nif ( getHeader ( \"content-length\" ) != null ) { \nsetUseGzip ( false ) ; \n} \nif ( useGzipWhenAccepted ( ) ) { \nprintHeader ( pw , \"Content-Encoding\" , \"gzip\" ) ; \nsetChunkedTransfer ( true ) ; \n} \nlong pending = this . data != null ? this . contentLength : 0 ; \nif ( this . requestMethod != Method . HEAD && this . chunkedTransfer ) { \nprintHeader ( pw , \"Transfer-Encoding\" , \"chunked\" ) ; \n} \nelse { \nif ( ! useGzipWhenAccepted ( ) ) { \npending = sendContentLengthHeaderIfNotAlreadyPresent ( pw , pending ) ; \n} \n} \npw . append ( \"\\r\\n\" ) ; \npw . flush ( ) ; \nsendBodyWithCorrectTransferAndEncoding ( outputStream , pending ) ; \noutputStream . flush ( ) ; \nNanoHTTPD . safeClose ( this . data ) ; \n} \ncatch ( IOException ioe ) { \nNanoHTTPD . LOG . log ( Level . SEVERE , \"Could not send response to the client\" , ioe ) ; \n} \n} \n} \n"}
{"2483": "public class EjbInjectionSource { \nprivate void resolve ( ) { \nif ( ! resolved ) { \nsynchronized ( this ) { \nif ( ! resolved ) { \nfinal Set < ViewDescription > views = getViews ( ) ; \nfinal Set < EJBViewDescription > ejbsForViewName = new HashSet < EJBViewDescription > ( ) ; \nfor ( final ViewDescription view : views ) { \nif ( view instanceof EJBViewDescription ) { \nfinal MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; \nif ( viewType == MethodIntf . SERVICE_ENDPOINT || viewType == MethodIntf . MESSAGE_ENDPOINT ) { \ncontinue ; \n} \nejbsForViewName . add ( ( EJBViewDescription ) view ) ; \n} \n} \nif ( ejbsForViewName . isEmpty ( ) ) { \nif ( beanName == null ) { \nerror = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , bindingName ) ; \n} \nelse { \nerror = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , beanName , bindingName ) ; \n} \n} \nelse { \nif ( ejbsForViewName . size ( ) > 1 ) { \nif ( beanName == null ) { \nerror = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , bindingName , ejbsForViewName ) ; \n} \nelse { \nerror = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , beanName , bindingName , ejbsForViewName ) ; \n} \n} \nelse { \nfinal EJBViewDescription description = ejbsForViewName . iterator ( ) . next ( ) ; \nfinal EJBViewDescription ejbViewDescription = ( EJBViewDescription ) description ; \nif ( ejbViewDescription . getMethodIntf ( ) == MethodIntf . REMOTE || ejbViewDescription . getMethodIntf ( ) == MethodIntf . HOME ) { \nfinal EJBComponentDescription componentDescription = ( EJBComponentDescription ) description . getComponentDescription ( ) ; \nfinal EEModuleDescription moduleDescription = componentDescription . getModuleDescription ( ) ; \nfinal String earApplicationName = moduleDescription . getEarApplicationName ( ) ; \nfinal Value < ClassLoader > viewClassLoader = new Value < ClassLoader > ( ) { \n@ Override public ClassLoader getValue ( ) throws IllegalStateException , IllegalArgumentException { \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nreturn module != null ? module . getClassLoader ( ) : null ; \n} \n} \n; \nremoteFactory = new RemoteViewManagedReferenceFactory ( earApplicationName , moduleDescription . getModuleName ( ) , moduleDescription . getDistinctName ( ) , componentDescription . getComponentName ( ) , description . getViewClassName ( ) , componentDescription . isStateful ( ) , viewClassLoader , appclient ) ; \n} \nfinal ServiceName serviceName = description . getServiceName ( ) ; \nresolvedViewName = serviceName ; \n} \n} \nresolved = true ; \n} \n} \n} \n} \n} \n"}
{"2502": "public class WebMetaDataModifier { \nprivate void configureEndpoints ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { \nfinal String transportClassName = this . getTransportClassName ( dep ) ; \nWSLogger . ROOT_LOGGER . trace ( \"Modifying servlets\" ) ; \nfinal Set < String > epNames = new HashSet < String > ( ) ; \nfor ( Endpoint ep : dep . getService ( ) . getEndpoints ( ) ) { \nepNames . add ( ep . getTargetBeanName ( ) ) ; \n} \nfor ( final ServletMetaData servletMD : jbossWebMD . getServlets ( ) ) { \nfinal String endpointClassName = ASHelper . getEndpointClassName ( servletMD ) ; \nif ( endpointClassName != null && endpointClassName . length ( ) > 0 ) { \nif ( epNames . contains ( endpointClassName ) ) { \nservletMD . setServletClass ( WSFServlet . class . getName ( ) ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting transport class: %s for endpoint: %s\" , transportClassName , endpointClassName ) ; \nfinal List < ParamValueMetaData > initParams = WebMetaDataHelper . getServletInitParams ( servletMD ) ; \nWebMetaDataHelper . newParamValue ( WSFServlet . STACK_SERVLET_DELEGATE_CLASS , transportClassName , initParams ) ; \nWebMetaDataHelper . newParamValue ( Endpoint . SEPID_DOMAIN_ENDPOINT , endpointClassName , initParams ) ; \n} \nelse { \nif ( endpointClassName . startsWith ( \"org.apache.cxf\" ) ) { \nthrow WSLogger . ROOT_LOGGER . invalidWSServlet ( endpointClassName ) ; \n} \n} \n} \n} \n} \n} \n"}
{"2574": "public class AbstractDeploymentDescriptorBindingsProcessor { \nprotected Class < ? > processInjectionTargets ( final ResourceInjectionTarget resourceInjectionTarget , InjectionSource injectionSource , ClassLoader classLoader , DeploymentReflectionIndex deploymentReflectionIndex , ResourceInjectionMetaData entry , Class < ? > classType ) throws DeploymentUnitProcessingException { \nif ( entry . getInjectionTargets ( ) != null ) { \nfor ( ResourceInjectionTargetMetaData injectionTarget : entry . getInjectionTargets ( ) ) { \nfinal String injectionTargetClassName = injectionTarget . getInjectionTargetClass ( ) ; \nfinal String injectionTargetName = injectionTarget . getInjectionTargetName ( ) ; \nfinal AccessibleObject fieldOrMethod = getInjectionTarget ( injectionTargetClassName , injectionTargetName , classLoader , deploymentReflectionIndex ) ; \nfinal Class < ? > injectionTargetType = fieldOrMethod instanceof Field ? ( ( Field ) fieldOrMethod ) . getType ( ) : ( ( Method ) fieldOrMethod ) . getParameterTypes ( ) [ 0 ] ; \nfinal String memberName = fieldOrMethod instanceof Field ? ( ( Field ) fieldOrMethod ) . getName ( ) : ( ( Method ) fieldOrMethod ) . getName ( ) ; \nif ( classType != null ) { \nif ( ! injectionTargetType . isAssignableFrom ( classType ) ) { \nboolean ok = false ; \nif ( classType . isPrimitive ( ) ) { \nif ( BOXED_TYPES . get ( classType ) . equals ( injectionTargetType ) ) { \nok = true ; \n} \n} \nelse { \nif ( injectionTargetType . isPrimitive ( ) ) { \nif ( BOXED_TYPES . get ( injectionTargetType ) . equals ( classType ) ) { \nok = true ; \n} \n} \n} \nif ( ! ok ) { \nthrow EeLogger . ROOT_LOGGER . invalidInjectionTarget ( injectionTarget . getInjectionTargetName ( ) , injectionTarget . getInjectionTargetClass ( ) , classType ) ; \n} \nclassType = injectionTargetType ; \n} \n} \nelse { \nclassType = injectionTargetType ; \n} \nfinal InjectionTarget injectionTargetDescription = fieldOrMethod instanceof Field ? new FieldInjectionTarget ( injectionTargetClassName , memberName , classType . getName ( ) ) : new MethodInjectionTarget ( injectionTargetClassName , memberName , classType . getName ( ) ) ; \nfinal ResourceInjectionConfiguration injectionConfiguration = new ResourceInjectionConfiguration ( injectionTargetDescription , injectionSource ) ; \nresourceInjectionTarget . addResourceInjection ( injectionConfiguration ) ; \n} \n} \nreturn classType ; \n} \n} \n"}
{"2578": "public class WarJACCService { \nstatic int getPatternType ( String urlPattern ) { \nint type = EXACT ; \nif ( urlPattern . startsWith ( \"*.\" ) ) type = EXTENSION ; \nelse { \nif ( urlPattern . startsWith ( \"/\" ) && urlPattern . endsWith ( \"/*\" ) ) type = PREFIX ; \nelse { \nif ( urlPattern . equals ( \"/\" ) ) type = DEFAULT ; \n} \n} \nreturn type ; \n} \n} \n"}
{"2592": "public class WarStructureDeploymentProcessor { \nprivate List < ResourceRoot > createResourceRoots ( final VirtualFile deploymentRoot , final DeploymentUnit deploymentUnit ) throws IOException , DeploymentUnitProcessingException { \nfinal List < ResourceRoot > entries = new ArrayList < ResourceRoot > ( ) ; \nfinal VirtualFile webinfClasses = deploymentRoot . getChild ( WEB_INF_CLASSES ) ; \nif ( webinfClasses . exists ( ) ) { \nfinal ResourceRoot webInfClassesRoot = new ResourceRoot ( webinfClasses . getName ( ) , webinfClasses , null ) ; \nModuleRootMarker . mark ( webInfClassesRoot ) ; \nentries . add ( webInfClassesRoot ) ; \n} \nMap < String , MountedDeploymentOverlay > overlays = deploymentUnit . getAttachment ( Attachments . DEPLOYMENT_OVERLAY_LOCATIONS ) ; \nfinal VirtualFile webinfLib = deploymentRoot . getChild ( WEB_INF_LIB ) ; \nif ( webinfLib . exists ( ) ) { \nfinal List < VirtualFile > archives = webinfLib . getChildren ( DEFAULT_WEB_INF_LIB_FILTER ) ; \nfor ( final VirtualFile archive : archives ) { \ntry { \nString relativeName = archive . getPathNameRelativeTo ( deploymentRoot ) ; \nMountedDeploymentOverlay overlay = overlays . get ( relativeName ) ; \nCloseable closable = null ; \nif ( overlay != null ) { \noverlay . remountAsZip ( false ) ; \n} \nelse { \nif ( archive . isFile ( ) ) { \nclosable = VFS . mountZip ( archive , archive , TempFileProviderService . provider ( ) ) ; \n} \nelse { \nclosable = null ; \n} \n} \nfinal ResourceRoot webInfArchiveRoot = new ResourceRoot ( archive . getName ( ) , archive , new MountHandle ( closable ) ) ; \nModuleRootMarker . mark ( webInfArchiveRoot ) ; \nentries . add ( webInfArchiveRoot ) ; \n} \ncatch ( IOException e ) { \nthrow new DeploymentUnitProcessingException ( UndertowLogger . ROOT_LOGGER . failToProcessWebInfLib ( archive ) , e ) ; \n} \n} \n} \nreturn entries ; \n} \n} \n"}
{"2594": "public class Configuration { \npublic static boolean needClassFileTransformer ( PersistenceUnitMetadata pu ) { \nboolean result = true ; \nString provider = pu . getPersistenceProviderClassName ( ) ; \nif ( pu . getProperties ( ) . containsKey ( Configuration . JPA_CONTAINER_CLASS_TRANSFORMER ) ) { \nresult = Boolean . parseBoolean ( pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_CLASS_TRANSFORMER ) ) ; \n} \nelse { \nif ( isHibernateProvider ( provider ) ) { \nresult = ( Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_USE_CLASS_ENHANCER ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_DIRTY_TRACKING ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_LAZY_INITIALIZATION ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_ASSOCIATION_MANAGEMENT ) ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"2597": "public class Configuration { \npublic static boolean skipMixedSynchronizationTypeCheck ( EntityManagerFactory emf , Map targetEntityManagerProperties ) { \nboolean result = false ; \nif ( targetEntityManagerProperties != null && targetEntityManagerProperties . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) { \nresult = Boolean . parseBoolean ( ( String ) targetEntityManagerProperties . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; \n} \nelse { \nif ( emf . getProperties ( ) != null && emf . getProperties ( ) . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) { \nresult = Boolean . parseBoolean ( ( String ) emf . getProperties ( ) . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"2599": "public class CorbaUtils { \nprivate static ORB initAppletORB ( Object applet , Properties orbProp ) { \ntry { \nClass < ? > appletClass = Class . forName ( \"java.applet.Applet\" , true , null ) ; \nif ( ! appletClass . isInstance ( applet ) ) { \nthrow new ClassCastException ( applet . getClass ( ) . getName ( ) ) ; \n} \nMethod method = ORB . class . getMethod ( \"init\" , appletClass , Properties . class ) ; \nreturn ( ORB ) method . invoke ( null , applet , orbProp ) ; \n} \ncatch ( ClassNotFoundException e ) { \nthrow new ClassCastException ( applet . getClass ( ) . getName ( ) ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new AssertionError ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nThrowable cause = e . getCause ( ) ; \nif ( cause instanceof RuntimeException ) { \nthrow ( RuntimeException ) cause ; \n} \nelse { \nif ( cause instanceof Error ) { \nthrow ( Error ) cause ; \n} \n} \nthrow new AssertionError ( e ) ; \n} \ncatch ( IllegalAccessException iae ) { \nthrow new AssertionError ( iae ) ; \n} \n} \n} \n"}
{"2611": "public class DatabaseTimerPersistence { \nprivate String identifyDialect ( String name ) { \nString unified = null ; \nif ( name != null ) { \nif ( name . toLowerCase ( ) . contains ( \"postgres\" ) ) { \nunified = \"postgresql\" ; \n} \nelse { \nif ( name . toLowerCase ( ) . contains ( \"mysql\" ) ) { \nunified = \"mysql\" ; \n} \nelse { \nif ( name . toLowerCase ( ) . contains ( \"mariadb\" ) ) { \nunified = \"mariadb\" ; \n} \nelse { \nif ( name . toLowerCase ( ) . contains ( \"db2\" ) ) { \nunified = \"db2\" ; \n} \nelse { \nif ( name . toLowerCase ( ) . contains ( \"hsql\" ) || name . toLowerCase ( ) . contains ( \"hypersonic\" ) ) { \nunified = \"hsql\" ; \n} \nelse { \nif ( name . toLowerCase ( ) . contains ( \"h2\" ) ) { \nunified = \"h2\" ; \n} \nelse { \nif ( name . toLowerCase ( ) . contains ( \"oracle\" ) ) { \nunified = \"oracle\" ; \n} \nelse { \nif ( name . toLowerCase ( ) . contains ( \"microsoft\" ) ) { \nunified = \"mssql\" ; \n} \nelse { \nif ( name . toLowerCase ( ) . contains ( \"jconnect\" ) ) { \nunified = \"sybase\" ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \nEjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Check dialect for '%s', result is '%s'\" , name , unified ) ; \nreturn unified ; \n} \n} \n"}
{"2627": "public class JSFComponentProcessor { \nprivate void processXmlManagedBeans ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder className = null ; \nint indent = 0 ; \nboolean managedBean = false ; \nboolean managedBeanClass = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN ) ) { \nmanagedBean = true ; \n} \n} \nelse { \nif ( indent == 3 && managedBean ) { \nif ( parser . getLocalName ( ) . equals ( MANAGED_BEAN_CLASS ) ) { \nmanagedBeanClass = true ; \nclassName = new StringBuilder ( ) ; \n} \n} \n} \n} \nelse { \nif ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nmanagedBeanClass = false ; \nif ( indent == 1 ) { \nmanagedBean = false ; \n} \nif ( className != null ) { \nmanagedBeanClasses . add ( className . toString ( ) . trim ( ) ) ; \nclassName = null ; \n} \n} \nelse { \nif ( managedBeanClass && event == XMLStreamConstants . CHARACTERS ) { \nclassName . append ( parser . getText ( ) ) ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . managedBeansConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2628": "public class JSFComponentProcessor { \nprivate void processPhaseListeners ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { \nfor ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { \nInputStream is = null ; \ntry { \nis = facesConfig . openStream ( ) ; \nfinal XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; \ninputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; \nXMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; \nStringBuilder phaseListenerName = null ; \nint indent = 0 ; \nboolean lifecycle = false ; \nboolean phaseListener = false ; \nwhile ( true ) { \nint event = parser . next ( ) ; \nif ( event == XMLStreamConstants . END_DOCUMENT ) { \nparser . close ( ) ; \nbreak ; \n} \nif ( event == XMLStreamConstants . START_ELEMENT ) { \nindent ++ ; \nif ( indent == 2 ) { \nif ( parser . getLocalName ( ) . equals ( LIFECYCLE ) ) { \nlifecycle = true ; \n} \n} \nelse { \nif ( indent == 3 && lifecycle ) { \nif ( parser . getLocalName ( ) . equals ( PHASE_LISTENER ) ) { \nphaseListener = true ; \nphaseListenerName = new StringBuilder ( ) ; \n} \n} \n} \n} \nelse { \nif ( event == XMLStreamConstants . END_ELEMENT ) { \nindent -- ; \nphaseListener = false ; \nif ( indent == 1 ) { \nlifecycle = false ; \n} \nif ( phaseListenerName != null ) { \nmanagedBeanClasses . add ( phaseListenerName . toString ( ) . trim ( ) ) ; \nphaseListenerName = null ; \n} \n} \nelse { \nif ( phaseListener && event == XMLStreamConstants . CHARACTERS ) { \nphaseListenerName . append ( parser . getText ( ) ) ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nJSFLogger . ROOT_LOGGER . phaseListenersConfigParseFailed ( facesConfig ) ; \n} \nfinally { \ntry { \nif ( is != null ) { \nis . close ( ) ; \n} \n} \ncatch ( IOException e ) { \n} \n} \n} \n} \n} \n"}
{"2630": "public class Util { \npublic static void insertAnyPrimitive ( Any any , Object primitive ) { \nClass type = primitive . getClass ( ) ; \nif ( type == Boolean . class ) any . insert_boolean ( ( ( Boolean ) primitive ) . booleanValue ( ) ) ; \nelse { \nif ( type == Character . class ) any . insert_wchar ( ( ( Character ) primitive ) . charValue ( ) ) ; \nelse { \nif ( type == Byte . class ) any . insert_octet ( ( ( Byte ) primitive ) . byteValue ( ) ) ; \nelse { \nif ( type == Short . class ) any . insert_short ( ( ( Short ) primitive ) . shortValue ( ) ) ; \nelse { \nif ( type == Integer . class ) any . insert_long ( ( ( Integer ) primitive ) . intValue ( ) ) ; \nelse { \nif ( type == Long . class ) any . insert_longlong ( ( ( Long ) primitive ) . longValue ( ) ) ; \nelse { \nif ( type == Float . class ) any . insert_float ( ( ( Float ) primitive ) . floatValue ( ) ) ; \nelse { \nif ( type == Double . class ) any . insert_double ( ( ( Double ) primitive ) . doubleValue ( ) ) ; \nelse throw IIOPLogger . ROOT_LOGGER . notAPrimitive ( type . getName ( ) ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"2639": "public class ManagementUtil { \nstatic ModelNode convertSecurityRole ( final ModelNode camelCase ) { \nfinal ModelNode result = new ModelNode ( ) ; \nresult . setEmptyList ( ) ; \nif ( camelCase . isDefined ( ) ) { \nfor ( ModelNode role : camelCase . asList ( ) ) { \nfinal ModelNode roleNode = result . add ( ) ; \nfor ( Property prop : role . asPropertyList ( ) ) { \nString key = prop . getName ( ) ; \nif ( \"createDurableQueue\" . equals ( key ) ) { \nkey = SecurityRoleDefinition . CREATE_DURABLE_QUEUE . getName ( ) ; \n} \nelse { \nif ( \"deleteDurableQueue\" . equals ( key ) ) { \nkey = SecurityRoleDefinition . DELETE_DURABLE_QUEUE . getName ( ) ; \n} \nelse { \nif ( \"createNonDurableQueue\" . equals ( key ) ) { \nkey = SecurityRoleDefinition . CREATE_NON_DURABLE_QUEUE . getName ( ) ; \n} \nelse { \nif ( \"deleteNonDurableQueue\" . equals ( key ) ) { \nkey = SecurityRoleDefinition . DELETE_NON_DURABLE_QUEUE . getName ( ) ; \n} \n} \n} \n} \nroleNode . get ( key ) . set ( prop . getValue ( ) ) ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"2684": "public class WSServerConfigAttributeHandler { \nprivate boolean updateServerConfig ( String attributeName , String value , boolean isRevert ) throws OperationFailedException , DisabledOperationException { \nfinal ServerConfigImpl config = ( ServerConfigImpl ) ServerConfigFactoryImpl . getConfig ( ) ; \ntry { \nif ( MODIFY_WSDL_ADDRESS . equals ( attributeName ) ) { \nfinal boolean modifyWSDLAddress = value != null && Boolean . parseBoolean ( value ) ; \nconfig . setModifySOAPAddress ( modifyWSDLAddress , isRevert ) ; \n} \nelse { \nif ( WSDL_HOST . equals ( attributeName ) ) { \nfinal String host = value != null ? value : null ; \ntry { \nconfig . setWebServiceHost ( host , isRevert ) ; \n} \ncatch ( final UnknownHostException e ) { \nthrow new OperationFailedException ( e . getMessage ( ) , e ) ; \n} \n} \nelse { \nif ( WSDL_PORT . equals ( attributeName ) ) { \nfinal int port = value != null ? Integer . parseInt ( value ) : - 1 ; \nconfig . setWebServicePort ( port , isRevert ) ; \n} \nelse { \nif ( WSDL_SECURE_PORT . equals ( attributeName ) ) { \nfinal int securePort = value != null ? Integer . parseInt ( value ) : - 1 ; \nconfig . setWebServiceSecurePort ( securePort , isRevert ) ; \n} \nelse { \nif ( WSDL_PATH_REWRITE_RULE . equals ( attributeName ) ) { \nfinal String path = value != null ? value : null ; \nconfig . setWebServicePathRewriteRule ( path , isRevert ) ; \n} \nelse { \nif ( WSDL_URI_SCHEME . equals ( attributeName ) ) { \nif ( value == null || value . equals ( \"http\" ) || value . equals ( \"https\" ) ) { \nconfig . setWebServiceUriScheme ( value , isRevert ) ; \n} \nelse { \nthrow new IllegalArgumentException ( attributeName + \" = \" + value ) ; \n} \n} \nelse { \nif ( STATISTICS_ENABLED . equals ( attributeName ) ) { \nfinal boolean enabled = value != null ? Boolean . parseBoolean ( value ) : false ; \nconfig . setStatisticsEnabled ( enabled ) ; \n} \nelse { \nthrow new IllegalArgumentException ( attributeName ) ; \n} \n} \n} \n} \n} \n} \n} \n} \ncatch ( DisabledOperationException doe ) { \nif ( ! isRevert ) { \nreturn false ; \n} \nelse { \nthrow doe ; \n} \n} \nreturn true ; \n} \n} \n"}
{"2703": "public class CNNameParser { \nprivate static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { \nint len = str . length ( ) ; \nVector components = new Vector ( 10 ) ; \nchar [ ] id = new char [ len ] ; \nchar [ ] kind = new char [ len ] ; \nint idCount , kindCount ; \nboolean idMode ; \nfor ( int i = 0 ; \ni < len ; \n) { \nidCount = kindCount = 0 ; \nidMode = true ; \nwhile ( i < len ) { \nif ( str . charAt ( i ) == compSeparator ) { \nbreak ; \n} \nelse { \nif ( str . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; \n} \nelse { \nif ( isMeta ( str . charAt ( i + 1 ) ) ) { \n++ i ; \nif ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; \n} \n} \n} \nelse { \nif ( idMode && str . charAt ( i ) == kindSeparator ) { \n++ i ; \nidMode = false ; \n} \nelse { \nif ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \n} \n} \n} \ncomponents . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; \nif ( i < len ) { \n++ i ; \n} \n} \nreturn components ; \n} \n} \n"}
{"2704": "public class CNNameParser { \nprivate static NameComponent parseComponent ( String compStr ) throws InvalidNameException { \nNameComponent comp = new NameComponent ( ) ; \nint kindSep = - 1 ; \nint len = compStr . length ( ) ; \nint j = 0 ; \nchar [ ] newStr = new char [ len ] ; \nboolean escaped = false ; \nfor ( int i = 0 ; \ni < len && kindSep < 0 ; \ni ++ ) { \nif ( escaped ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse { \nif ( compStr . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \nelse { \nif ( isMeta ( compStr . charAt ( i + 1 ) ) ) { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \n} \n} \nelse { \nif ( compStr . charAt ( i ) == kindSeparator ) { \nkindSep = i ; \n} \nelse { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \n} \n} \n} \n} \ncomp . id = new String ( newStr , 0 , j ) ; \nif ( kindSep < 0 ) { \ncomp . kind = \"\" ; \n} \nelse { \nj = 0 ; \nescaped = false ; \nfor ( int i = kindSep + 1 ; \ni < len ; \ni ++ ) { \nif ( escaped ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse { \nif ( compStr . charAt ( i ) == escapeChar ) { \nif ( i + 1 >= len ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \nelse { \nif ( isMeta ( compStr . charAt ( i + 1 ) ) ) { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \n} \n} \nelse { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \n} \n} \n} \ncomp . kind = new String ( newStr , 0 , j ) ; \n} \nreturn comp ; \n} \n} \n"}
{"2708": "public class GetDataSourceClassInfoOperationHandler { \nprivate static boolean isTypeMatched ( Class < ? > clz ) { \nif ( clz . equals ( String . class ) ) { \nreturn true ; \n} \nelse { \nif ( clz . equals ( byte . class ) || clz . equals ( Byte . class ) ) { \nreturn true ; \n} \nelse { \nif ( clz . equals ( short . class ) || clz . equals ( Short . class ) ) { \nreturn true ; \n} \nelse { \nif ( clz . equals ( int . class ) || clz . equals ( Integer . class ) ) { \nreturn true ; \n} \nelse { \nif ( clz . equals ( long . class ) || clz . equals ( Long . class ) ) { \nreturn true ; \n} \nelse { \nif ( clz . equals ( float . class ) || clz . equals ( Float . class ) ) { \nreturn true ; \n} \nelse { \nif ( clz . equals ( double . class ) || clz . equals ( Double . class ) ) { \nreturn true ; \n} \nelse { \nif ( clz . equals ( boolean . class ) || clz . equals ( Boolean . class ) ) { \nreturn true ; \n} \nelse { \nif ( clz . equals ( char . class ) || clz . equals ( Character . class ) ) { \nreturn true ; \n} \nelse { \nif ( clz . equals ( InetAddress . class ) ) { \nreturn true ; \n} \nelse { \nif ( clz . equals ( Class . class ) ) { \nreturn true ; \n} \nelse { \nif ( clz . equals ( Properties . class ) ) { \nreturn true ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"2711": "public class BeanUtils { \npublic static Object instantiateBean ( BeanMetaDataConfig beanConfig , BeanInfo beanInfo , DeploymentReflectionIndex index , Module module ) throws Throwable { \nJoinpoint instantiateJoinpoint = null ; \nValueConfig [ ] parameters = new ValueConfig [ 0 ] ; \nString [ ] types = Configurator . NO_PARAMS_TYPES ; \nConstructorConfig ctorConfig = beanConfig . getConstructor ( ) ; \nif ( ctorConfig != null ) { \nparameters = ctorConfig . getParameters ( ) ; \ntypes = Configurator . getTypes ( parameters ) ; \nString factoryClass = ctorConfig . getFactoryClass ( ) ; \nFactoryConfig factory = ctorConfig . getFactory ( ) ; \nif ( factoryClass != null || factory != null ) { \nString factoryMethod = ctorConfig . getFactoryMethod ( ) ; \nif ( factoryMethod == null ) throw PojoLogger . ROOT_LOGGER . missingFactoryMethod ( beanConfig ) ; \nif ( factoryClass != null ) { \nClass < ? > factoryClazz = Class . forName ( factoryClass , false , module . getClassLoader ( ) ) ; \nMethod method = Configurator . findMethod ( index , factoryClazz , factoryMethod , types , true , true , true ) ; \nMethodJoinpoint mj = new MethodJoinpoint ( method ) ; \nmj . setTarget ( new ImmediateValue < Object > ( null ) ) ; \nmj . setParameters ( parameters ) ; \ninstantiateJoinpoint = mj ; \n} \nelse { \nif ( factory != null ) { \nReflectionJoinpoint rj = new ReflectionJoinpoint ( factory . getBeanInfo ( ) , factoryMethod , types ) ; \nrj . setTarget ( new ImmediateValue < Object > ( factory . getValue ( null ) ) ) ; \nrj . setParameters ( parameters ) ; \ninstantiateJoinpoint = rj ; \n} \n} \n} \n} \nif ( instantiateJoinpoint == null ) { \nif ( beanInfo == null ) throw new StartException ( PojoLogger . ROOT_LOGGER . missingBeanInfo ( beanConfig ) ) ; \nConstructor ctor = ( types . length == 0 ) ? beanInfo . getConstructor ( ) : beanInfo . findConstructor ( types ) ; \nConstructorJoinpoint constructorJoinpoint = new ConstructorJoinpoint ( ctor ) ; \nconstructorJoinpoint . setParameters ( parameters ) ; \ninstantiateJoinpoint = constructorJoinpoint ; \n} \nreturn instantiateJoinpoint . dispatch ( ) ; \n} \n} \n"}
{"2720": "public class DescriptorUtils { \npublic static String validateDescriptor ( String descriptor ) { \nif ( descriptor . length ( ) == 0 ) { \nthrow EeLogger . ROOT_LOGGER . cannotBeEmpty ( \"descriptors\" ) ; \n} \nif ( descriptor . length ( ) > 1 ) { \nif ( descriptor . startsWith ( \"L\" ) ) { \nif ( ! descriptor . endsWith ( \";\" ) ) { \nthrow EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \n} \n} \nelse { \nif ( descriptor . startsWith ( \"[\" ) ) { \n} \nelse { \nthrow EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \n} \n} \n} \nelse { \nchar type = descriptor . charAt ( 0 ) ; \nswitch ( type ) { \ncase 'I' : case 'Z' : case 'S' : case 'B' : case 'F' : case 'D' : case 'V' : case 'J' : case 'C' : break ; \ndefault : throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \n} \n} \nreturn descriptor ; \n} \n} \n"}
{"2724": "public class ServiceDeploymentParsingProcessor { \npublic void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal VirtualFile deploymentRoot = phaseContext . getDeploymentUnit ( ) . getAttachment ( Attachments . DEPLOYMENT_ROOT ) . getRoot ( ) ; \nif ( deploymentRoot == null || ! deploymentRoot . exists ( ) ) return ; \nVirtualFile serviceXmlFile = null ; \nif ( deploymentRoot . isDirectory ( ) ) { \nserviceXmlFile = deploymentRoot . getChild ( SERVICE_DESCRIPTOR_PATH ) ; \n} \nelse { \nif ( deploymentRoot . getName ( ) . toLowerCase ( Locale . ENGLISH ) . endsWith ( SERVICE_DESCRIPTOR_SUFFIX ) ) { \nserviceXmlFile = deploymentRoot ; \n} \n} \nif ( serviceXmlFile == null || ! serviceXmlFile . exists ( ) ) return ; \nfinal XMLMapper xmlMapper = XMLMapper . Factory . create ( ) ; \nfinal JBossServiceXmlDescriptorParser jBossServiceXmlDescriptorParser = new JBossServiceXmlDescriptorParser ( JBossDescriptorPropertyReplacement . propertyReplacer ( phaseContext . getDeploymentUnit ( ) ) ) ; \nxmlMapper . registerRootElement ( new QName ( \"urn:jboss:service:7.0\" , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nxmlMapper . registerRootElement ( new QName ( null , \"server\" ) , jBossServiceXmlDescriptorParser ) ; \nInputStream xmlStream = null ; \ntry { \nxmlStream = serviceXmlFile . openStream ( ) ; \nfinal XMLStreamReader reader = inputFactory . createXMLStreamReader ( xmlStream ) ; \nfinal ParseResult < JBossServiceXmlDescriptor > result = new ParseResult < JBossServiceXmlDescriptor > ( ) ; \nxmlMapper . parseDocument ( result , reader ) ; \nfinal JBossServiceXmlDescriptor xmlDescriptor = result . getResult ( ) ; \nif ( xmlDescriptor != null ) phaseContext . getDeploymentUnit ( ) . putAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; \nelse throw SarLogger . ROOT_LOGGER . failedXmlParsing ( serviceXmlFile ) ; \n} \ncatch ( Exception e ) { \nthrow SarLogger . ROOT_LOGGER . failedXmlParsing ( e , serviceXmlFile ) ; \n} \nfinally { \nVFSUtils . safeClose ( xmlStream ) ; \n} \n} \n} \n"}
{"2733": "public class PersistenceUnitServiceHandler { \nprivate static void addPuService ( final DeploymentPhaseContext phaseContext , final ArrayList < PersistenceUnitMetadataHolder > puList , final boolean startEarly , final Platform platform ) throws DeploymentUnitProcessingException { \nif ( puList . size ( ) > 0 ) { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nfinal EEModuleDescription eeModuleDescription = deploymentUnit . getAttachment ( org . jboss . as . ee . component . Attachments . EE_MODULE_DESCRIPTION ) ; \nfinal ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; \nfinal ModuleClassLoader classLoader = module . getClassLoader ( ) ; \nfor ( PersistenceUnitMetadataHolder holder : puList ) { \nsetAnnotationIndexes ( holder , deploymentUnit ) ; \nfor ( PersistenceUnitMetadata pu : holder . getPersistenceUnits ( ) ) { \nString jpaContainerManaged = pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_MANAGED ) ; \nboolean deployPU = ( jpaContainerManaged == null ? true : Boolean . parseBoolean ( jpaContainerManaged ) ) ; \nif ( deployPU ) { \nfinal PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = getPersistenceProviderDeploymentHolder ( deploymentUnit ) ; \nfinal PersistenceProvider provider = lookupProvider ( pu , persistenceProviderDeploymentHolder , deploymentUnit ) ; \nfinal PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor ( pu , persistenceProviderDeploymentHolder , deploymentUnit , provider , platform ) ; \nfinal boolean twoPhaseBootStrapCapable = ( adaptor instanceof TwoPhaseBootstrapCapable ) && Configuration . allowTwoPhaseBootstrap ( pu ) ; \nif ( startEarly ) { \nif ( twoPhaseBootStrapCapable ) { \ndeployPersistenceUnitPhaseOne ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , adaptor ) ; \n} \nelse { \nif ( false == Configuration . needClassFileTransformer ( pu ) ) { \nROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is configured to not need class transformer to be set, no class rewriting will be allowed\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) ) ; \n} \nelse { \nfinal boolean allowCdiBeanManagerAccess = false ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \n} \n} \nelse { \nif ( twoPhaseBootStrapCapable ) { \ndeployPersistenceUnitPhaseTwo ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor ) ; \n} \nelse { \nif ( false == Configuration . needClassFileTransformer ( pu ) ) { \nfinal boolean allowCdiBeanManagerAccess = true ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \n} \n} \n} \nelse { \nROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is not container managed (%s is set to false)\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) , Configuration . JPA_CONTAINER_MANAGED ) ; \n} \n} \n} \n} \n} \n} \n"}
{"2751": "public class ContainerAnalysis { \nprotected String attributeReadName ( String name ) { \nif ( name . startsWith ( \"get\" ) ) name = name . substring ( 3 ) ; \nelse { \nif ( name . startsWith ( \"is\" ) ) name = name . substring ( 2 ) ; \nelse throw IIOPLogger . ROOT_LOGGER . notAnAccessor ( name ) ; \n} \nreturn name ; \n} \n} \n"}
{"2765": "public class JMSServerControlHandler { \nprivate String inferDestinationName ( String address ) { \nif ( address . startsWith ( JMS_QUEUE_PREFIX ) ) { \nreturn address . substring ( JMS_QUEUE_PREFIX . length ( ) ) ; \n} \nelse { \nif ( address . startsWith ( JMS_TOPIC_PREFIX ) ) { \nreturn address . substring ( JMS_TOPIC_PREFIX . length ( ) ) ; \n} \nelse { \nreturn address ; \n} \n} \n} \n} \n"}
{"2805": "public class ValueConfig { \npublic Object getValue ( Type type ) { \nif ( type == null || ( type instanceof Class ) ) { \nreturn getClassValue ( ( Class ) type ) ; \n} \nelse { \nif ( type instanceof ParameterizedType ) { \nParameterizedType pt = ( ParameterizedType ) type ; \nreturn getPtValue ( pt ) ; \n} \nelse { \nthrow PojoLogger . ROOT_LOGGER . unknownType ( type ) ; \n} \n} \n} \n} \n"}
{"2806": "public class ComponentDescription { \npublic ServiceName getContextServiceName ( ) { \nif ( contextServiceName != null ) return contextServiceName ; \nif ( getNamingMode ( ) == ComponentNamingMode . CREATE ) { \nreturn ContextNames . contextServiceNameOfComponent ( getApplicationName ( ) , getModuleName ( ) , getComponentName ( ) ) ; \n} \nelse { \nif ( getNamingMode ( ) == ComponentNamingMode . USE_MODULE ) { \nreturn ContextNames . contextServiceNameOfModule ( getApplicationName ( ) , getModuleName ( ) ) ; \n} \nelse { \nthrow new IllegalStateException ( ) ; \n} \n} \n} \n} \n"}
{"2824": "public class ContextNames { \npublic static BindInfo bindInfoFor ( final String jndiName ) { \nString bindName ; \nif ( jndiName . startsWith ( \"java:\" ) ) { \nbindName = jndiName . substring ( 5 ) ; \n} \nelse { \nif ( ! jndiName . startsWith ( \"jboss\" ) && ! jndiName . startsWith ( \"global\" ) && ! jndiName . startsWith ( \"/\" ) ) { \nbindName = \"/\" + jndiName ; \n} \nelse { \nbindName = jndiName ; \n} \n} \nfinal ServiceName parentContextName ; \nif ( bindName . startsWith ( \"jboss/exported/\" ) ) { \nparentContextName = EXPORTED_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 15 ) ; \n} \nelse { \nif ( bindName . startsWith ( \"jboss/\" ) ) { \nparentContextName = JBOSS_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 6 ) ; \n} \nelse { \nif ( bindName . startsWith ( \"global/\" ) ) { \nparentContextName = GLOBAL_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 7 ) ; \n} \nelse { \nif ( bindName . startsWith ( \"/\" ) ) { \nparentContextName = JAVA_CONTEXT_SERVICE_NAME ; \nbindName = bindName . substring ( 1 ) ; \n} \nelse { \nthrow NamingLogger . ROOT_LOGGER . illegalContextInName ( jndiName ) ; \n} \n} \n} \n} \nreturn new BindInfo ( parentContextName , bindName ) ; \n} \n} \n"}
{"2848": "public class InterfaceRepository { \nprivate ModuleDefImpl ensurePackageExists ( LocalContainer c , String previous , String remainder ) throws IRConstructionException { \nif ( \"\" . equals ( remainder ) ) return ( ModuleDefImpl ) c ; \nint idx = remainder . indexOf ( '.' ) ; \nString base ; \nif ( idx == - 1 ) base = remainder ; \nelse base = remainder . substring ( 0 , idx ) ; \nbase = Util . javaToIDLName ( base ) ; \nif ( previous . equals ( \"\" ) ) previous = base ; \nelse previous = previous + \"/\" + base ; \nif ( idx == - 1 ) remainder = \"\" ; \nelse remainder = remainder . substring ( idx + 1 ) ; \nLocalContainer next = null ; \nLocalContained contained = ( LocalContained ) c . _lookup ( base ) ; \nif ( contained instanceof LocalContainer ) next = ( LocalContainer ) contained ; \nelse { \nif ( contained != null ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; \n} \nif ( next == null ) { \nString id = \"IDL:\" + previous + \":1.0\" ; \nModuleDefImpl m = new ModuleDefImpl ( id , base , \"1.0\" , c , impl ) ; \nc . add ( base , m ) ; \nif ( idx == - 1 ) return m ; \nnext = ( LocalContainer ) c . _lookup ( base ) ; \n} \nelse { \nif ( next . def_kind ( ) != DefinitionKind . dk_Module ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; \n} \nreturn ensurePackageExists ( next , previous , remainder ) ; \n} \n} \n"}
{"2851": "public class InterfaceRepository { \nprivate void addClass ( Class cls ) throws RMIIIOPViolationException , IRConstructionException { \nif ( cls . isPrimitive ( ) ) return ; \nif ( cls . isArray ( ) ) { \naddArray ( cls ) ; \n} \nelse { \nif ( cls . isInterface ( ) ) { \nif ( ! RmiIdlUtil . isAbstractValueType ( cls ) ) { \nInterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; \naddInterface ( ia ) ; \n} \nelse { \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \naddValue ( va ) ; \n} \n} \nelse { \nif ( Exception . class . isAssignableFrom ( cls ) ) { \nExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; \naddException ( ea ) ; \n} \nelse { \nValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; \naddValue ( va ) ; \n} \n} \n} \n} \n} \n"}
{"2865": "public class Configurator { \npublic static Class < ? > toClass ( Type type ) { \nif ( type instanceof Class ) { \nreturn ( Class ) type ; \n} \nelse { \nif ( type instanceof ParameterizedType ) { \nParameterizedType pt = ( ParameterizedType ) type ; \nreturn toClass ( pt . getRawType ( ) ) ; \n} \nelse { \nthrow PojoLogger . ROOT_LOGGER . unknownType ( type ) ; \n} \n} \n} \n} \n"}
{"2874": "public class EjbIIOPService { \npublic org . omg . CORBA . Object referenceForLocator ( final EJBLocator < ? > locator ) { \nfinal EJBComponent ejbComponent = ejbComponentInjectedValue . getValue ( ) ; \ntry { \nfinal String earApplicationName = ejbComponent . getEarApplicationName ( ) == null ? \"\" : ejbComponent . getEarApplicationName ( ) ; \nif ( locator . getBeanName ( ) . equals ( ejbComponent . getComponentName ( ) ) && locator . getAppName ( ) . equals ( earApplicationName ) && locator . getModuleName ( ) . equals ( ejbComponent . getModuleName ( ) ) && locator . getDistinctName ( ) . equals ( ejbComponent . getDistinctName ( ) ) ) { \nif ( locator instanceof EJBHomeLocator ) { \nreturn ( org . omg . CORBA . Object ) ejbHome ; \n} \nelse { \nif ( locator instanceof StatelessEJBLocator ) { \nreturn beanReferenceFactory . createReference ( beanRepositoryIds [ 0 ] ) ; \n} \nelse { \nif ( locator instanceof StatefulEJBLocator ) { \nfinal Marshaller marshaller = factory . createMarshaller ( configuration ) ; \nfinal ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; \nmarshaller . start ( new OutputStreamByteOutput ( stream ) ) ; \nmarshaller . writeObject ( ( ( StatefulEJBLocator < ? > ) locator ) . getSessionId ( ) ) ; \nmarshaller . finish ( ) ; \nreturn beanReferenceFactory . createReferenceWithId ( stream . toByteArray ( ) , beanRepositoryIds [ 0 ] ) ; \n} \nelse { \nif ( locator instanceof EntityEJBLocator ) { \nfinal Marshaller marshaller = factory . createMarshaller ( configuration ) ; \nfinal ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; \nmarshaller . start ( new OutputStreamByteOutput ( stream ) ) ; \nmarshaller . writeObject ( ( ( EntityEJBLocator < ? > ) locator ) . getPrimaryKey ( ) ) ; \nmarshaller . finish ( ) ; \nreturn beanReferenceFactory . createReferenceWithId ( stream . toByteArray ( ) , beanRepositoryIds [ 0 ] ) ; \n} \n} \n} \n} \nthrow EjbLogger . ROOT_LOGGER . unknownEJBLocatorType ( locator ) ; \n} \nelse { \nthrow EjbLogger . ROOT_LOGGER . incorrectEJBLocatorForBean ( locator , ejbComponent . getComponentName ( ) ) ; \n} \n} \ncatch ( Exception e ) { \nthrow EjbLogger . ROOT_LOGGER . couldNotCreateCorbaObject ( e , locator ) ; \n} \n} \n} \n"}
{"2907": "public class CancellationFlag { \npublic boolean cancel ( boolean setFlag ) { \nfinal AtomicInteger stateRef = this . stateRef ; \nint oldVal , newVal ; \ndo { \noldVal = stateRef . get ( ) ; \nif ( oldVal == ST_WAITING ) { \nnewVal = ST_CANCELLED ; \n} \nelse { \nif ( oldVal == ST_CANCELLED ) { \nif ( ! setFlag ) { \nreturn true ; \n} \nnewVal = ST_CANCELLED_FLAG_SET ; \n} \nelse { \nif ( oldVal == ST_CANCELLED_FLAG_SET ) { \nreturn true ; \n} \nelse { \nif ( oldVal == ST_STARTED ) { \nif ( ! setFlag ) { \nreturn false ; \n} \nnewVal = ST_STARTED_FLAG_SET ; \n} \nelse { \nassert oldVal == ST_STARTED_FLAG_SET ; \nreturn false ; \n} \n} \n} \n} \n} \nwhile ( ! stateRef . compareAndSet ( oldVal , newVal ) ) ; \nreturn newVal == ST_CANCELLED || newVal == ST_CANCELLED_FLAG_SET ; \n} \n} \n"}
{"2908": "public class CancellationFlag { \npublic boolean runIfNotCancelled ( ) { \nfinal AtomicInteger stateRef = this . stateRef ; \nint oldVal ; \ndo { \noldVal = stateRef . get ( ) ; \nif ( oldVal == ST_CANCELLED || oldVal == ST_CANCELLED_FLAG_SET ) { \nreturn false ; \n} \nelse { \nif ( oldVal != ST_WAITING ) { \nthrow Assert . unreachableCode ( ) ; \n} \n} \n} \nwhile ( ! stateRef . compareAndSet ( oldVal , ST_STARTED ) ) ; \nreturn true ; \n} \n} \n"}
{"2912": "public class OReflectionHelper { \nprivate static List < Class < ? > > findClasses ( final File iDirectory , String iPackageName , ClassLoader iClassLoader ) throws ClassNotFoundException { \nfinal List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; \nif ( ! iDirectory . exists ( ) ) return classes ; \niPackageName += \".\" + iDirectory . getName ( ) ; \nString className ; \nfinal File [ ] files = iDirectory . listFiles ( ) ; \nif ( files != null ) for ( File file : files ) { \nif ( file . isDirectory ( ) ) { \nif ( file . getName ( ) . contains ( \".\" ) ) continue ; \nclasses . addAll ( findClasses ( file , iPackageName , iClassLoader ) ) ; \n} \nelse { \nif ( file . getName ( ) . endsWith ( CLASS_EXTENSION ) ) { \nclassName = file . getName ( ) . substring ( 0 , file . getName ( ) . length ( ) - CLASS_EXTENSION . length ( ) ) ; \nclasses . add ( Class . forName ( iPackageName + '.' + className , true , iClassLoader ) ) ; \n} \n} \n} \nreturn classes ; \n} \n} \n"}
{"2914": "public class OReflectionHelper { \npublic static Class < ? > getGenericMultivalueType ( final Field p ) { \nif ( p . getType ( ) instanceof Class < ? > ) { \nfinal Type genericType = p . getGenericType ( ) ; \nif ( genericType != null && genericType instanceof ParameterizedType ) { \nfinal ParameterizedType pt = ( ParameterizedType ) genericType ; \nif ( pt . getActualTypeArguments ( ) != null && pt . getActualTypeArguments ( ) . length > 0 ) { \nif ( ( ( Class < ? > ) pt . getRawType ( ) ) . isAssignableFrom ( Map . class ) ) { \nif ( pt . getActualTypeArguments ( ) [ 1 ] instanceof Class < ? > ) { \nreturn ( Class < ? > ) pt . getActualTypeArguments ( ) [ 1 ] ; \n} \nelse { \nif ( pt . getActualTypeArguments ( ) [ 1 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 1 ] ) . getRawType ( ) ; \n} \n} \nelse { \nif ( pt . getActualTypeArguments ( ) [ 0 ] instanceof Class < ? > ) { \nreturn ( Class < ? > ) pt . getActualTypeArguments ( ) [ 0 ] ; \n} \nelse { \nif ( pt . getActualTypeArguments ( ) [ 0 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 0 ] ) . getRawType ( ) ; \n} \n} \n} \n} \nelse { \nif ( p . getType ( ) . isArray ( ) ) return p . getType ( ) . getComponentType ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2933": "public class OUser { \npublic boolean isRuleDefined ( final ORule . ResourceGeneric resourceGeneric , String resourceSpecific ) { \nfor ( ORole r : roles ) if ( r == null ) OLogManager . instance ( ) . warn ( this , \"User '%s' has a null role, bypass it. Consider to fix this user roles before to continue\" , getName ( ) ) ; \nelse { \nif ( r . hasRule ( resourceGeneric , resourceSpecific ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"2947": "public class ODistributedStorage { \nprotected boolean executeOnlyLocally ( final String localNodeName , final ODistributedConfiguration dbCfg , final OCommandExecutor exec , final Collection < String > involvedClusters , final Collection < String > nodes ) { \nboolean executeLocally = false ; \nif ( exec . isIdempotent ( ) ) { \nfinal int availableNodes = nodes . size ( ) ; \nint maxReadQuorum ; \nif ( involvedClusters . isEmpty ( ) ) maxReadQuorum = dbCfg . getReadQuorum ( null , availableNodes , localNodeName ) ; \nelse { \nmaxReadQuorum = 0 ; \nfor ( String cl : involvedClusters ) maxReadQuorum = Math . max ( maxReadQuorum , dbCfg . getReadQuorum ( cl , availableNodes , localNodeName ) ) ; \n} \nif ( nodes . contains ( localNodeName ) && maxReadQuorum <= 1 ) executeLocally = true ; \n} \nreturn executeLocally ; \n} \npublic boolean isLocalEnv ( ) { \nreturn localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal . INSTANCE . isRunModeDistributed ( ) ; \n} \npublic OStorageOperationResult < ORawBuffer > readRecord ( final ORecordId iRecordId , final String iFetchPlan , final boolean iIgnoreCache , final boolean prefetchRecords , final ORecordCallback < ORawBuffer > iCallback ) { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( iRecordId ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( iRecordId ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \n} \n) ; \n} \nfinal OReadRecordTask task = ( ( OReadRecordTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordTask . FACTORYID ) ) . init ( iRecordId ) ; \nfinal ODistributedResponse response = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) ; \nfinal Object dResult = response != null ? response . getPayload ( ) : null ; \nif ( dResult instanceof ONeedRetryException ) throw ( ONeedRetryException ) dResult ; \nelse { \nif ( dResult instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) dResult ) ; \n} \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) dResult ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , iRecordId ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < ORawBuffer > readRecordIfVersionIsNotLatest ( final ORecordId rid , final String fetchPlan , final boolean ignoreCache , final int recordVersion ) throws ORecordNotFoundException { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( rid ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( rid ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \n} \n) ; \n} \nfinal OReadRecordIfNotLatestTask task = ( OReadRecordIfNotLatestTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordIfNotLatestTask . FACTORYID ) ; \ntask . init ( rid , recordVersion ) ; \nfinal Object result = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) . getPayload ( ) ; \nif ( result instanceof ONeedRetryException ) throw ( ONeedRetryException ) result ; \nelse { \nif ( result instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) result ) ; \n} \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) result ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , rid ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < Boolean > deleteRecord ( final ORecordId iRecordId , final int iVersion , final int iMode , final ORecordCallback < Boolean > iCallback ) { \nreturn wrapped . deleteRecord ( iRecordId , iVersion , iMode , iCallback ) ; \n} \n} \n"}
{"2953": "public class OIndexFullText { \n@ Override public OIndexFullText put ( Object key , final OIdentifiable singleValue ) { \nif ( key == null ) { \nreturn this ; \n} \nkey = getCollatingValue ( key ) ; \nfinal Set < String > words = splitIntoWords ( key . toString ( ) ) ; \nfor ( final String word : words ) { \nacquireSharedLock ( ) ; \ntry { \nif ( apiVersion == 0 ) { \ndoPutV0 ( singleValue , word ) ; \n} \nelse { \nif ( apiVersion == 1 ) { \ndoPutV1 ( singleValue , word ) ; \n} \nelse { \nthrow new IllegalStateException ( \"Invalid API version, \" + apiVersion ) ; \n} \n} \n} \nfinally { \nreleaseSharedLock ( ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"2954": "public class OIndexFullText { \n@ Override public boolean remove ( Object key , final OIdentifiable value ) { \nif ( key == null ) { \nreturn false ; \n} \nkey = getCollatingValue ( key ) ; \nfinal Set < String > words = splitIntoWords ( key . toString ( ) ) ; \nfinal OModifiableBoolean removed = new OModifiableBoolean ( false ) ; \nfor ( final String word : words ) { \nacquireSharedLock ( ) ; \ntry { \nif ( apiVersion == 0 ) { \nremoveV0 ( value , removed , word ) ; \n} \nelse { \nif ( apiVersion == 1 ) { \nremoveV1 ( value , removed , word ) ; \n} \nelse { \nthrow new IllegalStateException ( \"Invalid API version, \" + apiVersion ) ; \n} \n} \n} \nfinally { \nreleaseSharedLock ( ) ; \n} \n} \nreturn removed . getValue ( ) ; \n} \n} \n"}
{"2962": "public class OStorageRemote { \nprotected String addHost ( String host ) { \nif ( host . startsWith ( LOCALHOST ) ) host = LOCAL_IP + host . substring ( \"localhost\" . length ( ) ) ; \nif ( host . contains ( \"/\" ) ) host = host . substring ( 0 , host . indexOf ( \"/\" ) ) ; \nif ( ! host . contains ( \":\" ) ) host += \":\" + ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \nelse { \nif ( host . split ( \":\" ) . length < 2 || host . split ( \":\" ) [ 1 ] . trim ( ) . length ( ) == 0 ) host += ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \n} \nsynchronized ( serverURLs ) { \nif ( ! serverURLs . contains ( host ) ) { \nserverURLs . add ( host ) ; \nOLogManager . instance ( ) . debug ( this , \"Registered the new available server '%s'\" , host ) ; \n} \n} \nreturn host ; \n} \n} \n"}
{"2964": "public class OLazyCollectionUtil { \nprotected static OObjectDatabaseTx getDatabase ( ) { \nODatabaseInternal < ? > databaseOwner = ODatabaseRecordThreadLocal . instance ( ) . get ( ) . getDatabaseOwner ( ) ; \nif ( databaseOwner instanceof OObjectDatabaseTx ) { \nreturn ( OObjectDatabaseTx ) databaseOwner ; \n} \nelse { \nif ( databaseOwner instanceof ODatabaseDocumentInternal ) { \nreturn new OObjectDatabaseTx ( ( ODatabaseDocumentInternal ) databaseOwner ) ; \n} \n} \nthrow new IllegalStateException ( \"Current database not of expected type\" ) ; \n} \n} \n"}
{"2971": "public class OTransactionAbstract { \n@ Override public void close ( ) { \nfor ( Map . Entry < ORID , LockedRecordMetadata > lock : locks . entrySet ( ) ) { \ntry { \nfinal LockedRecordMetadata lockedRecordMetadata = lock . getValue ( ) ; \nif ( lockedRecordMetadata . strategy . equals ( OStorage . LOCKING_STRATEGY . EXCLUSIVE_LOCK ) ) { \n( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ) . releaseWriteLock ( lock . getKey ( ) ) ; \n} \nelse { \nif ( lockedRecordMetadata . strategy . equals ( OStorage . LOCKING_STRATEGY . SHARED_LOCK ) ) { \n( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ) . releaseReadLock ( lock . getKey ( ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . debug ( this , \"Error on releasing lock against record \" + lock . getKey ( ) , e ) ; \n} \n} \nlocks . clear ( ) ; \n} \n} \n"}
{"2979": "public class ONative { \npublic int getOpenFilesLimit ( boolean verbose , int recommended , int defLimit ) { \nif ( Platform . isLinux ( ) ) { \nfinal OCLibrary . Rlimit rlimit = new OCLibrary . Rlimit ( ) ; \nfinal int result = C_LIBRARY . getrlimit ( OCLibrary . RLIMIT_NOFILE , rlimit ) ; \nif ( result == 0 && rlimit . rlim_cur > 0 ) { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Detected limit of amount of simultaneously open files is %d, \" + \" limit of open files for disk cache will be set to %d\" , rlimit . rlim_cur , rlimit . rlim_cur / 2 - 512 ) ; \n} \nif ( rlimit . rlim_cur < recommended ) { \nOLogManager . instance ( ) . warnNoDb ( this , \"Value of limit of simultaneously open files is too small, recommended value is %d\" , recommended ) ; \n} \nreturn ( int ) rlimit . rlim_cur / 2 - 512 ; \n} \nelse { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Can not detect value of limit of open files.\" ) ; \n} \n} \n} \nelse { \nif ( Platform . isWindows ( ) ) { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Windows OS is detected, %d limit of open files will be set for the disk cache.\" , recommended ) ; \n} \nreturn recommended ; \n} \n} \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Default limit of open files (%d) will be used.\" , defLimit ) ; \n} \nreturn defLimit ; \n} \n} \n"}
{"2988": "public class OMatchStatement { \n@ Override public < RET extends OCommandExecutor > RET parse ( OCommandRequest iRequest ) { \nfinal OCommandRequestText textRequest = ( OCommandRequestText ) iRequest ; \nif ( iRequest instanceof OSQLSynchQuery ) { \nrequest = ( OSQLSynchQuery < ODocument > ) iRequest ; \n} \nelse { \nif ( iRequest instanceof OSQLAsynchQuery ) { \nrequest = ( OSQLAsynchQuery < ODocument > ) iRequest ; \n} \nelse { \nrequest = new OSQLSynchQuery < ODocument > ( textRequest . getText ( ) ) ; \nif ( textRequest . getResultListener ( ) != null ) { \nrequest . setResultListener ( textRequest . getResultListener ( ) ) ; \n} \n} \n} \nString queryText = textRequest . getText ( ) ; \nfinal InputStream is = new ByteArrayInputStream ( queryText . getBytes ( ) ) ; \nOrientSql osql = null ; \ntry { \nODatabaseDocumentInternal db = getDatabase ( ) ; \nif ( db == null ) { \nosql = new OrientSql ( is ) ; \n} \nelse { \nosql = new OrientSql ( is , db . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \n} \n} \ncatch ( UnsupportedEncodingException e ) { \nOLogManager . instance ( ) . warn ( this , \"Invalid charset for database \" + getDatabase ( ) + \" \" + getDatabase ( ) . getStorage ( ) . getConfiguration ( ) . getCharset ( ) ) ; \nosql = new OrientSql ( is ) ; \n} \ntry { \nOMatchStatement result = ( OMatchStatement ) osql . parse ( ) ; \nthis . matchExpressions = result . matchExpressions ; \nthis . notMatchExpressions = result . notMatchExpressions ; \nthis . returnItems = result . returnItems ; \nthis . returnAliases = result . returnAliases ; \nthis . limit = result . limit ; \n} \ncatch ( ParseException e ) { \nOCommandSQLParsingException ex = new OCommandSQLParsingException ( e , queryText ) ; \nOErrorCode . QUERY_PARSE_ERROR . throwException ( ex . getMessage ( ) , ex ) ; \n} \nbuildPatterns ( ) ; \npattern . validate ( ) ; \nreturn ( RET ) this ; \n} \n} \n"}
{"2990": "public class OMatchStatement { \nprivate void updateScheduleStartingAt ( PatternNode startNode , Set < PatternNode > visitedNodes , Set < PatternEdge > visitedEdges , Map < String , Set < String > > remainingDependencies , List < EdgeTraversal > resultingSchedule ) { \nvisitedNodes . add ( startNode ) ; \nfor ( Set < String > dependencies : remainingDependencies . values ( ) ) { \ndependencies . remove ( startNode . alias ) ; \n} \nMap < PatternEdge , Boolean > edges = new LinkedHashMap < PatternEdge , Boolean > ( ) ; \nfor ( PatternEdge outEdge : startNode . out ) { \nedges . put ( outEdge , true ) ; \n} \nfor ( PatternEdge inEdge : startNode . in ) { \nedges . put ( inEdge , false ) ; \n} \nfor ( Map . Entry < PatternEdge , Boolean > edgeData : edges . entrySet ( ) ) { \nPatternEdge edge = edgeData . getKey ( ) ; \nboolean isOutbound = edgeData . getValue ( ) ; \nPatternNode neighboringNode = isOutbound ? edge . in : edge . out ; \nif ( ! remainingDependencies . get ( neighboringNode . alias ) . isEmpty ( ) ) { \ncontinue ; \n} \nif ( visitedNodes . contains ( neighboringNode ) ) { \nif ( ! visitedEdges . contains ( edge ) ) { \nboolean traversalDirection ; \nif ( startNode . optional || edge . item . isBidirectional ( ) ) { \ntraversalDirection = ! isOutbound ; \n} \nelse { \ntraversalDirection = isOutbound ; \n} \nvisitedEdges . add ( edge ) ; \nresultingSchedule . add ( new EdgeTraversal ( edge , traversalDirection ) ) ; \n} \n} \nelse { \nif ( ! startNode . optional ) { \nif ( visitedEdges . contains ( edge ) ) { \nthrow new AssertionError ( \"The edge was visited, but the neighboring vertex was not: \" + edge + \" \" + neighboringNode ) ; \n} \nvisitedEdges . add ( edge ) ; \nresultingSchedule . add ( new EdgeTraversal ( edge , isOutbound ) ) ; \nupdateScheduleStartingAt ( neighboringNode , visitedNodes , visitedEdges , remainingDependencies , resultingSchedule ) ; \n} \n} \n} \n} \n} \n"}
{"2999": "public class OSecurityManager { \npublic boolean checkPassword ( final String iPassword , final String iHash ) { \nif ( iHash . startsWith ( HASH_ALGORITHM_PREFIX ) ) { \nfinal String s = iHash . substring ( HASH_ALGORITHM_PREFIX . length ( ) ) ; \nreturn createSHA256 ( iPassword ) . equals ( s ) ; \n} \nelse { \nif ( iHash . startsWith ( PBKDF2_ALGORITHM_PREFIX ) ) { \nfinal String s = iHash . substring ( PBKDF2_ALGORITHM_PREFIX . length ( ) ) ; \nreturn checkPasswordWithSalt ( iPassword , s , PBKDF2_ALGORITHM ) ; \n} \nelse { \nif ( iHash . startsWith ( PBKDF2_SHA256_ALGORITHM_PREFIX ) ) { \nfinal String s = iHash . substring ( PBKDF2_SHA256_ALGORITHM_PREFIX . length ( ) ) ; \nreturn checkPasswordWithSalt ( iPassword , s , PBKDF2_SHA256_ALGORITHM ) ; \n} \n} \n} \nreturn MessageDigest . isEqual ( digestSHA256 ( iPassword ) , digestSHA256 ( iHash ) ) ; \n} \n} \n"}
{"3000": "public class OSecurityManager { \npublic String createHash ( final String iInput , final String iAlgorithm , final boolean iIncludeAlgorithm ) { \nif ( iInput == null ) throw new IllegalArgumentException ( \"Input string is null\" ) ; \nif ( iAlgorithm == null ) throw new IllegalArgumentException ( \"Algorithm is null\" ) ; \nfinal StringBuilder buffer = new StringBuilder ( 128 ) ; \nfinal String algorithm = validateAlgorithm ( iAlgorithm ) ; \nif ( iIncludeAlgorithm ) { \nbuffer . append ( '{' ) ; \nbuffer . append ( algorithm ) ; \nbuffer . append ( '}' ) ; \n} \nfinal String transformed ; \nif ( HASH_ALGORITHM . equalsIgnoreCase ( algorithm ) ) { \ntransformed = createSHA256 ( iInput ) ; \n} \nelse { \nif ( PBKDF2_ALGORITHM . equalsIgnoreCase ( algorithm ) ) { \ntransformed = createHashWithSalt ( iInput , OGlobalConfiguration . SECURITY_USER_PASSWORD_SALT_ITERATIONS . getValueAsInteger ( ) , algorithm ) ; \n} \nelse { \nif ( PBKDF2_SHA256_ALGORITHM . equalsIgnoreCase ( algorithm ) ) { \ntransformed = createHashWithSalt ( iInput , OGlobalConfiguration . SECURITY_USER_PASSWORD_SALT_ITERATIONS . getValueAsInteger ( ) , algorithm ) ; \n} \nelse throw new IllegalArgumentException ( \"Algorithm '\" + algorithm + \"' is not supported\" ) ; \n} \n} \nbuffer . append ( transformed ) ; \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"3008": "public class OAtomicOperation { \nprivate static boolean checkChangesFilledUpTo ( final FileChanges changesContainer , final long pageIndex ) { \nif ( changesContainer == null ) { \nreturn true ; \n} \nelse { \nif ( changesContainer . isNew || changesContainer . maxNewPageIndex > - 2 ) { \nreturn pageIndex < changesContainer . maxNewPageIndex + 1 ; \n} \nelse return ! changesContainer . truncate ; \n} \n} \n} \n"}
{"3009": "public class OCommandExecutorSQLAbstract { \nprotected boolean parseTimeout ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_TIMEOUT ) ) return false ; \nString word = parserNextWord ( true ) ; \ntry { \ntimeoutMs = Long . parseLong ( word ) ; \n} \ncatch ( NumberFormatException ignore ) { \nthrowParsingException ( \"Invalid \" + KEYWORD_TIMEOUT + \" value set to '\" + word + \"' but it should be a valid long. Example: \" + KEYWORD_TIMEOUT + \" 3000\" ) ; \n} \nif ( timeoutMs < 0 ) throwParsingException ( \"Invalid \" + KEYWORD_TIMEOUT + \": value set minor than ZERO. Example: \" + KEYWORD_TIMEOUT + \" 10000\" ) ; \nword = parserNextWord ( true ) ; \nif ( word != null ) if ( word . equals ( TIMEOUT_STRATEGY . EXCEPTION . toString ( ) ) ) timeoutStrategy = TIMEOUT_STRATEGY . EXCEPTION ; \nelse { \nif ( word . equals ( TIMEOUT_STRATEGY . RETURN . toString ( ) ) ) timeoutStrategy = TIMEOUT_STRATEGY . RETURN ; \nelse parserGoBack ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"3018": "public class OCommandExecutorSQLDelete { \npublic boolean result ( final Object iRecord ) { \nfinal ORecordAbstract record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; \nif ( record instanceof ODocument && compiledFilter != null && ! Boolean . TRUE . equals ( this . compiledFilter . evaluate ( record , ( ODocument ) record , getContext ( ) ) ) ) { \nreturn true ; \n} \ntry { \nif ( record . getIdentity ( ) . isValid ( ) ) { \nif ( returning . equalsIgnoreCase ( \"BEFORE\" ) ) allDeletedRecords . add ( record ) ; \nif ( ! unsafe && record instanceof ODocument ) { \nfinal OClass cls = ( ( ODocument ) record ) . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( cls . isSubClassOf ( \"V\" ) ) throw new OCommandExecutionException ( \"'DELETE' command cannot delete vertices. Use 'DELETE VERTEX' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \nelse { \nif ( cls . isSubClassOf ( \"E\" ) ) throw new OCommandExecutionException ( \"'DELETE' command cannot delete edges. Use 'DELETE EDGE' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \n} \nrecord . delete ( ) ; \nrecordCount ++ ; \nreturn true ; \n} \nreturn false ; \n} \nfinally { \nif ( lockStrategy . equalsIgnoreCase ( \"RECORD\" ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) ) . releaseWriteLock ( record . getIdentity ( ) ) ; \n} \n} \n} \n"}
{"3032": "public class ORidBag { \npublic boolean tryMerge ( final ORidBag otherValue , boolean iMergeSingleItemsOfMultiValueFields ) { \nif ( ! isEmbedded ( ) && ! otherValue . isEmbedded ( ) ) { \nfinal OSBTreeRidBag thisTree = ( OSBTreeRidBag ) delegate ; \nfinal OSBTreeRidBag otherTree = ( OSBTreeRidBag ) otherValue . delegate ; \nif ( thisTree . getCollectionPointer ( ) . equals ( otherTree . getCollectionPointer ( ) ) ) { \nthisTree . mergeChanges ( otherTree ) ; \nuuid = otherValue . uuid ; \nreturn true ; \n} \n} \nelse { \nif ( iMergeSingleItemsOfMultiValueFields ) { \nfinal Iterator < OIdentifiable > iter = otherValue . rawIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nfinal OIdentifiable value = iter . next ( ) ; \nif ( value != null ) { \nfinal Iterator < OIdentifiable > localIter = rawIterator ( ) ; \nboolean found = false ; \nwhile ( localIter . hasNext ( ) ) { \nfinal OIdentifiable v = localIter . next ( ) ; \nif ( value . equals ( v ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) add ( value ) ; \n} \n} \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3061": "public class OSessionStoragePerformanceStatistic { \npublic void stopWALRecordTimer ( boolean isStartRecord , boolean isStopRecord ) { \nfinal long endTs = nanoTimer . getNano ( ) ; \nfinal long timeDiff = ( endTs - timeStamps . pop ( ) ) ; \nif ( walCountersHolder == null ) walCountersHolder = new WALCountersHolder ( ) ; \nwalCountersHolder . logRecordCount ++ ; \nwalCountersHolder . logRecordTime += timeDiff ; \nif ( isStartRecord ) { \nwalCountersHolder . startRecordCount ++ ; \nwalCountersHolder . startRecordTime += timeDiff ; \n} \nelse { \nif ( isStopRecord ) { \nwalCountersHolder . stopRecordCount ++ ; \nwalCountersHolder . stopRecordTime += timeDiff ; \n} \n} \nmakeSnapshotIfNeeded ( endTs ) ; \n} \n} \n"}
{"3073": "public class OTransactionRealAbstract { \npublic List < ORecordOperation > getNewRecordEntriesByClass ( final OClass iClass , final boolean iPolymorphic ) { \nfinal List < ORecordOperation > result = new ArrayList < ORecordOperation > ( ) ; \nif ( iClass == null ) for ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) result . add ( entry ) ; \n} \nelse { \nfor ( ORecordOperation entry : allEntries . values ( ) ) { \nif ( entry . type == ORecordOperation . CREATED ) if ( entry . getRecord ( ) != null && entry . getRecord ( ) instanceof ODocument ) { \nif ( iPolymorphic ) { \nif ( iClass . isSuperClassOf ( ( ( ODocument ) entry . getRecord ( ) ) . getSchemaClass ( ) ) ) result . add ( entry ) ; \n} \nelse { \nif ( iClass . getName ( ) . equals ( ( ( ODocument ) entry . getRecord ( ) ) . getClassName ( ) ) ) result . add ( entry ) ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"3080": "public class OWALSegmentCache { \nvoid writePage ( ByteBuffer page , long pageIndex ) throws IOException { \nsynchronized ( lockObject ) { \nlastAccessTime = System . nanoTime ( ) ; \nif ( pageIndex >= firstCachedPage && pageIndex <= firstCachedPage + pageCache . size ( ) ) { \nif ( pageIndex < firstCachedPage + pageCache . size ( ) ) { \npageCache . set ( ( int ) ( pageIndex - firstCachedPage ) , page ) ; \n} \nelse { \npageCache . add ( page ) ; \n} \n} \nelse { \nif ( pageCache . isEmpty ( ) ) { \npageCache . add ( page ) ; \nfirstCachedPage = pageIndex ; \n} \n} \nlastWrittenPage = page ; \nlastWrittenPageIndex = pageIndex ; \nif ( pageCache . size ( ) * OWALPage . PAGE_SIZE >= bufferSize + OWALPage . PAGE_SIZE ) { \nflushAllBufferPagesExceptLastOne ( ) ; \n} \n} \n} \n} \n"}
{"3101": "public class ODistributedConfiguration { \npublic int getDataCenterWriteQuorum ( final String dataCenter ) { \nfinal ODocument dc = getDataCenterConfiguration ( dataCenter ) ; \nObject wq = dc . field ( WRITE_QUORUM ) ; \nif ( wq instanceof String ) { \nif ( wq . toString ( ) . equalsIgnoreCase ( ODistributedConfiguration . QUORUM_MAJORITY ) ) { \nfinal List < String > servers = dc . field ( SERVERS ) ; \nwq = servers . size ( ) / 2 + 1 ; \n} \nelse { \nif ( wq . toString ( ) . equalsIgnoreCase ( ODistributedConfiguration . QUORUM_ALL ) ) { \nfinal List < String > servers = dc . field ( SERVERS ) ; \nwq = servers . size ( ) ; \n} \n} \n} \nreturn ( Integer ) wq ; \n} \n} \n"}
{"3113": "public class OrientBaseGraph { \n@ Override public OrientEdge addEdge ( final Object id , Vertex outVertex , Vertex inVertex , final String label ) { \nmakeActive ( ) ; \nString className = null ; \nString clusterName = null ; \nif ( id != null ) { \nif ( id instanceof String ) { \nfinal String [ ] args = ( ( String ) id ) . split ( \",\" ) ; \nfor ( String s : args ) { \nif ( s . startsWith ( CLASS_PREFIX ) ) className = s . substring ( CLASS_PREFIX . length ( ) ) ; \nelse { \nif ( s . startsWith ( CLUSTER_PREFIX ) ) clusterName = s . substring ( CLUSTER_PREFIX . length ( ) ) ; \n} \n} \n} \n} \nfinal Object [ ] fields = isSaveOriginalIds ( ) && id != null ? new Object [ ] { \nOrientElement . DEF_ORIGINAL_ID_FIELDNAME , id } \n: null ; \nif ( outVertex instanceof PartitionVertex ) outVertex = ( ( PartitionVertex ) outVertex ) . getBaseVertex ( ) ; \nif ( inVertex instanceof PartitionVertex ) inVertex = ( ( PartitionVertex ) inVertex ) . getBaseVertex ( ) ; \nreturn ( ( OrientVertex ) outVertex ) . addEdge ( label , ( OrientVertex ) inVertex , className , clusterName , fields ) ; \n} \n} \n"}
{"3114": "public class OrientBaseGraph { \npublic OrientVertex getVertex ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) throw ExceptionFactory . vertexIdCanNotBeNull ( ) ; \nif ( id instanceof OrientVertex ) return ( OrientVertex ) id ; \nelse { \nif ( id instanceof ODocument ) return getVertexInstance ( ( OIdentifiable ) id ) ; \n} \nsetCurrentGraphInThreadLocal ( ) ; \nORID rid ; \nif ( id instanceof OIdentifiable ) rid = ( ( OIdentifiable ) id ) . getIdentity ( ) ; \nelse { \ntry { \nrid = new ORecordId ( id . toString ( ) ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \n} \nif ( ! rid . isValid ( ) ) return null ; \nfinal ORecord rec = rid . getRecord ( ) ; \nif ( rec == null || ! ( rec instanceof ODocument ) ) return null ; \nfinal OClass cls = ( ( ODocument ) rec ) . getSchemaClass ( ) ; \nif ( cls != null && cls . isEdgeType ( ) ) throw new IllegalArgumentException ( \"Cannot retrieve a vertex with the RID \" + rid + \" because it is an edge\" ) ; \nreturn getVertexInstance ( rec ) ; \n} \n} \n"}
{"3117": "public class OrientBaseGraph { \npublic OrientEdge getEdge ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) throw ExceptionFactory . edgeIdCanNotBeNull ( ) ; \nif ( id instanceof OrientEdge ) return ( OrientEdge ) id ; \nelse { \nif ( id instanceof ODocument ) return new OrientEdge ( this , ( OIdentifiable ) id ) ; \n} \nfinal OIdentifiable rec ; \nif ( id instanceof OIdentifiable ) rec = ( OIdentifiable ) id ; \nelse { \nfinal String str = id . toString ( ) ; \nint pos = str . indexOf ( \"->\" ) ; \nif ( pos > - 1 ) { \nfinal String from = str . substring ( 0 , pos ) ; \nfinal String to = str . substring ( pos + 2 ) ; \nreturn getEdgeInstance ( new ORecordId ( from ) , new ORecordId ( to ) , null ) ; \n} \ntry { \nrec = new ORecordId ( str ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \n} \nfinal ODocument doc = rec . getRecord ( ) ; \nif ( doc == null ) return null ; \nfinal OClass cls = doc . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( cls . isVertexType ( ) ) throw new IllegalArgumentException ( \"Cannot retrieve an edge with the RID \" + id + \" because it is a vertex\" ) ; \nif ( ! cls . isEdgeType ( ) ) throw new IllegalArgumentException ( \"Class '\" + doc . getClassName ( ) + \"' is not an edge class\" ) ; \n} \nreturn new OrientEdge ( this , rec ) ; \n} \n} \n"}
{"3119": "public class OrientBaseGraph { \npublic void shutdown ( boolean closeDb , boolean commitTx ) { \nmakeActive ( ) ; \ntry { \nif ( ! isClosed ( ) ) { \nif ( commitTx ) { \nfinal OStorage storage = getDatabase ( ) . getStorage ( ) . getUnderlying ( ) ; \nif ( storage instanceof OAbstractPaginatedStorage ) { \nif ( ( ( OAbstractPaginatedStorage ) storage ) . getWALInstance ( ) != null ) getDatabase ( ) . commit ( ) ; \n} \nelse { \ngetDatabase ( ) . commit ( ) ; \n} \n} \nelse { \nif ( closeDb ) { \ngetDatabase ( ) . rollback ( ) ; \n} \n} \n} \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( RuntimeException e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \nthrow e ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \nthrow OException . wrapException ( new ODatabaseException ( \"Error during context close for db \" + url ) , e ) ; \n} \nfinally { \ntry { \nif ( closeDb ) { \ngetDatabase ( ) . close ( ) ; \nif ( getDatabase ( ) . isPooled ( ) ) { \ndatabase = null ; \n} \n} \npollGraphFromStack ( closeDb ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during context close for db \" + url , e ) ; \n} \n} \nurl = null ; \nusername = null ; \npassword = null ; \nif ( ! closeDb ) getDatabase ( ) . activateOnCurrentThread ( ) ; \n} \n} \n"}
{"3128": "public class OrientBaseGraph { \n@ SuppressWarnings ( { \n\"rawtypes\" } \n) @ Override public < T extends Element > void createKeyIndex ( final String key , final Class < T > elementClass , final Parameter ... indexParameters ) { \nmakeActive ( ) ; \nif ( elementClass == null ) throw ExceptionFactory . classForElementCannotBeNull ( ) ; \nexecuteOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nString indexType = OClass . INDEX_TYPE . NOTUNIQUE . name ( ) ; \nOType keyType = OType . STRING ; \nString className = null ; \nString collate = null ; \nODocument metadata = null ; \nfinal String ancestorClassName = getClassName ( elementClass ) ; \nfor ( Parameter < ? , ? > p : indexParameters ) { \nif ( p . getKey ( ) . equals ( \"type\" ) ) indexType = p . getValue ( ) . toString ( ) . toUpperCase ( Locale . ENGLISH ) ; \nelse { \nif ( p . getKey ( ) . equals ( \"keytype\" ) ) keyType = OType . valueOf ( p . getValue ( ) . toString ( ) . toUpperCase ( Locale . ENGLISH ) ) ; \nelse { \nif ( p . getKey ( ) . equals ( \"class\" ) ) className = p . getValue ( ) . toString ( ) ; \nelse { \nif ( p . getKey ( ) . equals ( \"collate\" ) ) collate = p . getValue ( ) . toString ( ) ; \nelse { \nif ( p . getKey ( ) . toString ( ) . startsWith ( \"metadata.\" ) ) { \nif ( metadata == null ) metadata = new ODocument ( ) ; \nmetadata . field ( p . getKey ( ) . toString ( ) . substring ( \"metadata.\" . length ( ) ) , p . getValue ( ) ) ; \n} \n} \n} \n} \n} \n} \nif ( className == null ) className = ancestorClassName ; \nfinal ODatabaseDocument db = getRawGraph ( ) ; \nfinal OSchema schema = db . getMetadata ( ) . getSchema ( ) ; \nfinal OClass cls = schema . getOrCreateClass ( className , schema . getClass ( ancestorClassName ) ) ; \nfinal OProperty property = cls . getProperty ( key ) ; \nif ( property != null ) keyType = property . getType ( ) ; \nOPropertyIndexDefinition indexDefinition = new OPropertyIndexDefinition ( className , key , keyType ) ; \nif ( collate != null ) indexDefinition . setCollate ( collate ) ; \ndb . getMetadata ( ) . getIndexManager ( ) . createIndex ( className + \".\" + key , indexType , indexDefinition , cls . getPolymorphicClusterIds ( ) , null , metadata ) ; \nreturn null ; \n} \n} \n, \"create key index on '\" , elementClass . getSimpleName ( ) , \".\" , key , \"'\" ) ; \n} \n} \n"}
{"3149": "public class ODistributedResponseManagerImpl { \nprivate boolean computeQuorumResponse ( boolean reachedTimeout ) { \nif ( quorumResponse != null ) return true ; \nif ( groupResponsesByResult ) { \nfor ( List < ODistributedResponse > group : responseGroups ) { \nif ( group . size ( ) >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( ODistributedResponse r : group ) { \nif ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { \nfinal Object payload = r . getPayload ( ) ; \nif ( payload instanceof Throwable ) { \nif ( payload instanceof ODistributedRecordLockedException ) break ; \nif ( payload instanceof OConcurrentCreateException ) break ; \n} \nelse { \nif ( ++ responsesForQuorum >= quorum ) { \nsetQuorumResponse ( r ) ; \nreturn true ; \n} \n} \n} \n} \n} \n} \n} \nelse { \nif ( receivedResponses >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { \nif ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && ++ responsesForQuorum >= quorum ) { \nODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; \nif ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; \nreturn true ; \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3185": "public class OSymmetricKey { \npublic static OSymmetricKey fromConfig ( final OSymmetricKeyConfig keyConfig ) { \nif ( keyConfig . usesKeyString ( ) ) { \nreturn fromString ( keyConfig . getKeyAlgorithm ( ) , keyConfig . getKeyString ( ) ) ; \n} \nelse { \nif ( keyConfig . usesKeyFile ( ) ) { \nreturn fromFile ( keyConfig . getKeyAlgorithm ( ) , keyConfig . getKeyFile ( ) ) ; \n} \nelse { \nif ( keyConfig . usesKeystore ( ) ) { \nreturn fromKeystore ( keyConfig . getKeystoreFile ( ) , keyConfig . getKeystorePassword ( ) , keyConfig . getKeystoreKeyAlias ( ) , keyConfig . getKeystoreKeyPassword ( ) ) ; \n} \nelse { \nthrow new OSecurityException ( \"OSymmetricKey(OSymmetricKeyConfig) Invalid configuration\" ) ; \n} \n} \n} \n} \n} \n"}
{"3191": "public class OBasicCommandContext { \npublic OCommandContext setChild ( final OCommandContext iContext ) { \nif ( iContext == null ) { \nif ( child != null ) { \nchild . setParent ( null ) ; \nchild = null ; \n} \n} \nelse { \nif ( child != iContext ) { \nchild = iContext ; \niContext . setParent ( this ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"3195": "public class ODocumentHelper { \n@ SuppressWarnings ( \"unchecked\" ) public static Object getMapEntry ( final Map < String , ? > iMap , final Object iKey ) { \nif ( iMap == null || iKey == null ) return null ; \nif ( iKey instanceof String ) { \nString iName = ( String ) iKey ; \nint pos = iName . indexOf ( '.' ) ; \nif ( pos > - 1 ) iName = iName . substring ( 0 , pos ) ; \nfinal Object value = iMap . get ( iName ) ; \nif ( value == null ) return null ; \nif ( pos > - 1 ) { \nfinal String restFieldName = iName . substring ( pos + 1 ) ; \nif ( value instanceof ODocument ) return getFieldValue ( value , restFieldName ) ; \nelse { \nif ( value instanceof Map < ? , ? > ) return getMapEntry ( ( Map < String , ? > ) value , restFieldName ) ; \n} \n} \nreturn value ; \n} \nelse return iMap . get ( iKey ) ; \n} \n} \n"}
{"3207": "public class OrientVertex { \n@ Override public Iterable < Vertex > getVertices ( final Direction iDirection , final String ... iLabels ) { \nsetCurrentGraphInThreadLocal ( ) ; \nOrientBaseGraph . getEdgeClassNames ( getGraph ( ) , iLabels ) ; \nOrientBaseGraph . encodeClassNames ( iLabels ) ; \nfinal ODocument doc = getRecord ( ) ; \nfinal OMultiCollectionIterator < Vertex > iterable = new OMultiCollectionIterator < Vertex > ( ) ; \nfor ( OTriple < String , Direction , String > connectionField : getConnectionFields ( iDirection , iLabels ) ) { \nString fieldName = connectionField . getKey ( ) ; \nOPair < Direction , String > connection = connectionField . getValue ( ) ; \nfinal Object fieldValue = doc . rawField ( fieldName ) ; \nif ( fieldValue != null ) if ( fieldValue instanceof OIdentifiable ) { \naddSingleVertex ( doc , iterable , fieldName , connection , fieldValue , iLabels ) ; \n} \nelse { \nif ( fieldValue instanceof Collection < ? > ) { \nCollection < ? > coll = ( Collection < ? > ) fieldValue ; \nif ( coll . size ( ) == 1 ) { \nif ( coll instanceof ORecordLazyMultiValue ) addSingleVertex ( doc , iterable , fieldName , connection , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) . next ( ) , iLabels ) ; \nelse { \nif ( coll instanceof List < ? > ) addSingleVertex ( doc , iterable , fieldName , connection , ( ( List < ? > ) coll ) . get ( 0 ) , iLabels ) ; \nelse addSingleVertex ( doc , iterable , fieldName , connection , coll . iterator ( ) . next ( ) , iLabels ) ; \n} \n} \nelse { \nif ( coll instanceof ORecordLazyMultiValue ) iterable . add ( new OrientVertexIterator ( this , coll , ( ( ORecordLazyMultiValue ) coll ) . rawIterator ( ) , connection , iLabels , coll . size ( ) ) ) ; \nelse iterable . add ( new OrientVertexIterator ( this , coll , coll . iterator ( ) , connection , iLabels , - 1 ) ) ; \n} \n} \nelse { \nif ( fieldValue instanceof ORidBag ) { \niterable . add ( new OrientVertexIterator ( this , fieldValue , ( ( ORidBag ) fieldValue ) . rawIterator ( ) , connection , iLabels , - 1 ) ) ; \n} \n} \n} \n} \nreturn iterable ; \n} \n} \n"}
{"3211": "public class OrientVertex { \npublic String getConnectionClass ( final Direction iDirection , final String iFieldName ) { \nif ( iDirection == Direction . OUT ) { \nif ( iFieldName . length ( ) > CONNECTION_OUT_PREFIX . length ( ) ) return iFieldName . substring ( CONNECTION_OUT_PREFIX . length ( ) ) ; \n} \nelse { \nif ( iDirection == Direction . IN ) { \nif ( iFieldName . length ( ) > CONNECTION_IN_PREFIX . length ( ) ) return iFieldName . substring ( CONNECTION_IN_PREFIX . length ( ) ) ; \n} \n} \nreturn OrientEdgeType . CLASS_NAME ; \n} \n} \n"}
{"3212": "public class OrientVertex { \nprotected OPair < Direction , String > getConnection ( final Direction iDirection , final String iFieldName , String ... iClassNames ) { \nif ( iClassNames != null && iClassNames . length == 1 && iClassNames [ 0 ] . equalsIgnoreCase ( \"E\" ) ) iClassNames = null ; \nfinal OrientBaseGraph graph = getGraph ( ) ; \nif ( iDirection == Direction . OUT || iDirection == Direction . BOTH ) { \nif ( settings . isUseVertexFieldsForEdgeLabels ( ) ) { \nif ( iFieldName . startsWith ( CONNECTION_OUT_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . OUT , iFieldName ) ; \nif ( iClassNames == null || iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) { \nfor ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . OUT , connClass ) ; \n} \n} \n} \n} \nelse { \nif ( iFieldName . equals ( OrientBaseGraph . CONNECTION_OUT ) ) return new OPair < Direction , String > ( Direction . OUT , null ) ; \n} \n} \nif ( iDirection == Direction . IN || iDirection == Direction . BOTH ) { \nif ( settings . isUseVertexFieldsForEdgeLabels ( ) ) { \nif ( iFieldName . startsWith ( CONNECTION_IN_PREFIX ) ) { \nString connClass = getConnectionClass ( Direction . IN , iFieldName ) ; \nif ( iClassNames == null || iClassNames . length == 0 ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; \nOrientEdgeType edgeType = graph . getEdgeType ( connClass ) ; \nif ( edgeType != null ) { \nfor ( String clsName : iClassNames ) { \nif ( edgeType . isSubClassOf ( clsName ) ) return new OPair < Direction , String > ( Direction . IN , connClass ) ; \n} \n} \n} \n} \nelse { \nif ( iFieldName . equals ( OrientBaseGraph . CONNECTION_IN ) ) return new OPair < Direction , String > ( Direction . IN , null ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"3229": "public class OCommandExecutorSQLCreateIndex { \n@ SuppressWarnings ( \"rawtypes\" ) public Object execute ( final Map < Object , Object > iArgs ) { \nif ( indexName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal OIndex < ? > idx ; \nList < OCollate > collatesList = null ; \nif ( collates != null ) { \ncollatesList = new ArrayList < OCollate > ( ) ; \nfor ( String collate : collates ) { \nif ( collate != null ) { \nfinal OCollate col = OSQLEngine . getCollate ( collate ) ; \ncollatesList . add ( col ) ; \n} \nelse collatesList . add ( null ) ; \n} \n} \nif ( fields == null || fields . length == 0 ) { \nOIndexFactory factory = OIndexes . getFactory ( indexType . toString ( ) , null ) ; \nif ( keyTypes != null ) idx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new OSimpleKeyIndexDefinition ( keyTypes , collatesList ) , null , null , metadataDoc , engine ) ; \nelse { \nif ( serializerKeyId != 0 ) { \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . toString ( ) , new ORuntimeKeyIndexDefinition ( serializerKeyId ) , null , null , metadataDoc , engine ) ; \n} \nelse { \nthrow new ODatabaseException ( \"Impossible to create an index without specify the key type or the associated property\" ) ; \n} \n} \n} \nelse { \nif ( ( keyTypes == null || keyTypes . length == 0 ) && collates == null ) { \nidx = oClass . createIndex ( indexName , indexType . toString ( ) , null , metadataDoc , engine , fields ) ; \n} \nelse { \nfinal List < OType > fieldTypeList ; \nif ( keyTypes == null ) { \nfor ( final String fieldName : fields ) { \nif ( ! fieldName . equals ( \"@rid\" ) && ! oClass . existsProperty ( fieldName ) ) throw new OIndexException ( \"Index with name : '\" + indexName + \"' cannot be created on class : '\" + oClass . getName ( ) + \"' because field: '\" + fieldName + \"' is absent in class definition.\" ) ; \n} \nfieldTypeList = ( ( OClassImpl ) oClass ) . extractFieldTypes ( fields ) ; \n} \nelse fieldTypeList = Arrays . asList ( keyTypes ) ; \nfinal OIndexDefinition idxDef = OIndexDefinitionFactory . createIndexDefinition ( oClass , Arrays . asList ( fields ) , fieldTypeList , collatesList , indexType . toString ( ) , null ) ; \nidx = database . getMetadata ( ) . getIndexManager ( ) . createIndex ( indexName , indexType . name ( ) , idxDef , oClass . getPolymorphicClusterIds ( ) , null , metadataDoc , engine ) ; \n} \n} \nif ( idx != null ) return idx . getSize ( ) ; \nreturn null ; \n} \n} \n"}
{"3249": "public class OClosableLinkedContainer { \npublic OClosableEntry < K , V > acquire ( K key ) throws InterruptedException { \ncheckOpenFilesLimit ( ) ; \nfinal OClosableEntry < K , V > entry = data . get ( key ) ; \nif ( entry == null ) return null ; \nboolean logOpen = false ; \nentry . acquireStateLock ( ) ; \ntry { \nif ( entry . isRetired ( ) || entry . isDead ( ) ) { \nreturn null ; \n} \nelse { \nif ( entry . isClosed ( ) ) { \nentry . makeAcquiredFromClosed ( entry . get ( ) ) ; \nlogOpen = true ; \n} \nelse { \nif ( entry . isOpen ( ) ) { \nentry . makeAcquiredFromOpen ( ) ; \n} \nelse { \nentry . incrementAcquired ( ) ; \n} \n} \n} \n} \nfinally { \nentry . releaseStateLock ( ) ; \n} \nif ( logOpen ) { \nlogOpen ( entry ) ; \n} \nelse { \nlogAcquire ( entry ) ; \n} \nassert entry . get ( ) . isOpen ( ) ; \nreturn entry ; \n} \n} \n"}
{"3269": "public class OReadersWriterSpinLock { \npublic boolean tryAcquireReadLock ( long timeout ) { \nfinal OModifiableInteger lHolds = lockHolds . get ( ) ; \nfinal int holds = lHolds . intValue ( ) ; \nif ( holds > 0 ) { \nlHolds . increment ( ) ; \nreturn true ; \n} \nelse { \nif ( holds < 0 ) { \nreturn true ; \n} \n} \ndistributedCounter . increment ( ) ; \nWNode wNode = tail . get ( ) ; \nfinal long start = System . nanoTime ( ) ; \nwhile ( wNode . locked ) { \ndistributedCounter . decrement ( ) ; \nwhile ( wNode . locked && wNode == tail . get ( ) ) { \nwNode . waitingReaders . put ( Thread . currentThread ( ) , Boolean . TRUE ) ; \nif ( wNode . locked && wNode == tail . get ( ) ) { \nfinal long parkTimeout = timeout - ( System . nanoTime ( ) - start ) ; \nif ( parkTimeout > 0 ) { \nLockSupport . parkNanos ( this , parkTimeout ) ; \n} \nelse { \nreturn false ; \n} \n} \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \nreturn false ; \n} \n} \ndistributedCounter . increment ( ) ; \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \ndistributedCounter . decrement ( ) ; \nreturn false ; \n} \n} \nlHolds . increment ( ) ; \nassert lHolds . intValue ( ) == 1 ; \nreturn true ; \n} \n} \n"}
{"3270": "public class OrientEdge { \n@ Override public OrientVertex getVertex ( final Direction direction ) { \nfinal OrientBaseGraph graph = setCurrentGraphInThreadLocal ( ) ; \nif ( direction . equals ( Direction . OUT ) ) return graph . getVertex ( getOutVertex ( ) ) ; \nelse { \nif ( direction . equals ( Direction . IN ) ) return graph . getVertex ( getInVertex ( ) ) ; \nelse throw ExceptionFactory . bothIsNotSupported ( ) ; \n} \n} \n} \n"}
{"3280": "public class OCommandExecutorSQLInsert { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( newRecords == null && content == null && subQuery == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal OCommandParameters commandParameters = new OCommandParameters ( iArgs ) ; \nif ( indexName != null ) { \nif ( newRecords == null ) throw new OCommandExecutionException ( \"No key/value found\" ) ; \nfinal OIndex < ? > index = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) . getIndex ( indexName ) ; \nif ( index == null ) throw new OCommandExecutionException ( \"Target index '\" + indexName + \"' not found\" ) ; \nMap < String , Object > result = new HashMap < String , Object > ( ) ; \nfor ( Map < String , Object > candidate : newRecords ) { \nObject indexKey = getIndexKeyValue ( commandParameters , candidate ) ; \nOIdentifiable indexValue = getIndexValue ( commandParameters , candidate ) ; \nif ( index instanceof OIndexMultiValues ) { \nfinal Collection < ORID > rids = ( ( OIndexMultiValues ) index ) . get ( indexKey ) ; \nif ( ! rids . contains ( indexValue . getIdentity ( ) ) ) { \nindex . put ( indexKey , indexValue ) ; \n} \n} \nelse { \nindex . put ( indexKey , indexValue ) ; \n} \nresult . put ( KEYWORD_KEY , indexKey ) ; \nresult . put ( KEYWORD_RID , indexValue ) ; \n} \nreturn prepareReturnItem ( new ODocument ( result ) ) ; \n} \nelse { \nfinal List < ODocument > docs = new ArrayList < ODocument > ( ) ; \nif ( newRecords != null ) { \nfor ( Map < String , Object > candidate : newRecords ) { \nfinal ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; \nOSQLHelper . bindParameters ( doc , candidate , commandParameters , context ) ; \nsaveRecord ( doc ) ; \ndocs . add ( doc ) ; \n} \nif ( docs . size ( ) == 1 ) return prepareReturnItem ( docs . get ( 0 ) ) ; \nelse return prepareReturnResult ( docs ) ; \n} \nelse { \nif ( content != null ) { \nfinal ODocument doc = className != null ? new ODocument ( className ) : new ODocument ( ) ; \ndoc . merge ( content , true , false ) ; \nsaveRecord ( doc ) ; \nreturn prepareReturnItem ( doc ) ; \n} \nelse { \nif ( subQuery != null ) { \nsubQuery . execute ( ) ; \nif ( queryResult != null ) return prepareReturnResult ( queryResult ) ; \nreturn saved . longValue ( ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"3285": "public class ODistributedWorker { \npublic void initDatabaseInstance ( ) { \nif ( database == null ) { \nfor ( int retry = 0 ; \nretry < 100 ; \n++ retry ) { \ntry { \ndatabase = distributed . getDatabaseInstance ( ) ; \nbreak ; \n} \ncatch ( OStorageException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \ncatch ( OConfigurationException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \n} \nif ( database == null ) { \nODistributedServerLog . info ( this , manager . getLocalNodeName ( ) , null , DIRECTION . NONE , \"Database '%s' not present, shutting down database manager\" , databaseName ) ; \ndistributed . shutdown ( ) ; \nthrow new ODistributedException ( \"Cannot open database '\" + databaseName + \"'\" ) ; \n} \n} \nelse { \nif ( database . isClosed ( ) ) { \ndatabase . activateOnCurrentThread ( ) ; \ndatabase . close ( ) ; \ndatabase = distributed . getDatabaseInstance ( ) ; \n} \n} \n} \n} \n"}
{"3289": "public class OHttpNetworkCommandManager { \npublic void registerCommand ( final OServerCommand iServerCommandInstance ) { \nfor ( String name : iServerCommandInstance . getNames ( ) ) if ( OStringSerializerHelper . contains ( name , '{' ) ) { \nrestCommands . put ( name , iServerCommandInstance ) ; \n} \nelse { \nif ( OStringSerializerHelper . contains ( name , '*' ) ) wildcardCommands . put ( name , iServerCommandInstance ) ; \nelse exactCommands . put ( name , iServerCommandInstance ) ; \n} \niServerCommandInstance . configure ( server ) ; \n} \n} \n"}
{"3292": "public class OFilterAnalyzer { \nprivate OIndexSearchResult createIndexedProperty ( final OSQLFilterCondition iCondition , final Object iItem , OCommandContext ctx ) { \nif ( iItem == null || ! ( iItem instanceof OSQLFilterItemField ) ) { \nreturn null ; \n} \nif ( iCondition . getLeft ( ) instanceof OSQLFilterItemField && iCondition . getRight ( ) instanceof OSQLFilterItemField ) { \nreturn null ; \n} \nfinal OSQLFilterItemField item = ( OSQLFilterItemField ) iItem ; \nif ( item . hasChainOperators ( ) && ! item . isFieldChain ( ) ) { \nreturn null ; \n} \nboolean inverted = iCondition . getRight ( ) == iItem ; \nfinal Object origValue = inverted ? iCondition . getLeft ( ) : iCondition . getRight ( ) ; \nOQueryOperator operator = iCondition . getOperator ( ) ; \nif ( inverted ) { \nif ( operator instanceof OQueryOperatorIn ) { \noperator = new OQueryOperatorContains ( ) ; \n} \nelse { \nif ( operator instanceof OQueryOperatorContains ) { \noperator = new OQueryOperatorIn ( ) ; \n} \nelse { \nif ( operator instanceof OQueryOperatorMajor ) { \noperator = new OQueryOperatorMinor ( ) ; \n} \nelse { \nif ( operator instanceof OQueryOperatorMinor ) { \noperator = new OQueryOperatorMajor ( ) ; \n} \nelse { \nif ( operator instanceof OQueryOperatorMajorEquals ) { \noperator = new OQueryOperatorMinorEquals ( ) ; \n} \nelse { \nif ( operator instanceof OQueryOperatorMinorEquals ) { \noperator = new OQueryOperatorMajorEquals ( ) ; \n} \n} \n} \n} \n} \n} \n} \nif ( iCondition . getOperator ( ) instanceof OQueryOperatorBetween || operator instanceof OQueryOperatorIn ) { \nreturn new OIndexSearchResult ( operator , item . getFieldChain ( ) , origValue ) ; \n} \nfinal Object value = OSQLHelper . getValue ( origValue , null , ctx ) ; \nreturn new OIndexSearchResult ( operator , item . getFieldChain ( ) , value ) ; \n} \n} \n"}
{"3309": "public class OCommandExecutorSQLSelect { \n@ Override public Set < String > getInvolvedClusters ( ) { \nfinal Set < String > clusters = new HashSet < String > ( ) ; \nif ( parsedTarget != null ) { \nfinal ODatabaseDocument db = getDatabase ( ) ; \nif ( parsedTarget . getTargetQuery ( ) != null && parsedTarget . getTargetRecords ( ) instanceof OCommandExecutorSQLResultsetDelegate ) { \nfinal Set < String > clIds = ( ( OCommandExecutorSQLResultsetDelegate ) parsedTarget . getTargetRecords ( ) ) . getInvolvedClusters ( ) ; \nfor ( String c : clIds ) { \nif ( checkClusterAccess ( db , c ) ) { \nclusters . add ( c ) ; \n} \n} \n} \nelse { \nif ( parsedTarget . getTargetRecords ( ) != null ) { \nfor ( OIdentifiable identifiable : parsedTarget . getTargetRecords ( ) ) { \nfinal String c = db . getClusterNameById ( identifiable . getIdentity ( ) . getClusterId ( ) ) . toLowerCase ( Locale . ENGLISH ) ; \nif ( checkClusterAccess ( db , c ) ) { \nclusters . add ( c ) ; \n} \n} \n} \n} \nif ( parsedTarget . getTargetClasses ( ) != null ) { \nreturn getInvolvedClustersOfClasses ( parsedTarget . getTargetClasses ( ) . values ( ) ) ; \n} \nif ( parsedTarget . getTargetClusters ( ) != null ) { \nreturn getInvolvedClustersOfClusters ( parsedTarget . getTargetClusters ( ) . keySet ( ) ) ; \n} \nif ( parsedTarget . getTargetIndex ( ) != null ) { \nreturn getInvolvedClustersOfIndex ( parsedTarget . getTargetIndex ( ) ) ; \n} \n} \nreturn clusters ; \n} \n} \n"}
{"3327": "public class ODatabaseDocumentAbstract { \npublic ORecordHook . RESULT callbackHooks ( final ORecordHook . TYPE type , final OIdentifiable id ) { \nif ( id == null || hooks . isEmpty ( ) || id . getIdentity ( ) . getClusterId ( ) == 0 ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \nfinal ORecordHook . SCOPE scope = ORecordHook . SCOPE . typeToScope ( type ) ; \nfinal int scopeOrdinal = scope . ordinal ( ) ; \nfinal ORID identity = id . getIdentity ( ) . copy ( ) ; \nif ( ! pushInHook ( identity ) ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \ntry { \nfinal ORecord rec = id . getRecord ( ) ; \nif ( rec == null ) return ORecordHook . RESULT . RECORD_NOT_CHANGED ; \nfinal OScenarioThreadLocal . RUN_MODE runMode = OScenarioThreadLocal . INSTANCE . getRunMode ( ) ; \nboolean recordChanged = false ; \nfor ( ORecordHook hook : hooksByScope [ scopeOrdinal ] ) { \nswitch ( runMode ) { \ncase DEFAULT : if ( getStorage ( ) . isDistributed ( ) && hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . TARGET_NODE ) continue ; \nbreak ; \ncase RUNNING_DISTRIBUTED : if ( hook . getDistributedExecutionMode ( ) == ORecordHook . DISTRIBUTED_EXECUTION_MODE . SOURCE_NODE ) continue ; \n} \nfinal ORecordHook . RESULT res = hook . onTrigger ( type , rec ) ; \nif ( res == ORecordHook . RESULT . RECORD_CHANGED ) recordChanged = true ; \nelse { \nif ( res == ORecordHook . RESULT . SKIP_IO ) return res ; \nelse { \nif ( res == ORecordHook . RESULT . SKIP ) return res ; \nelse { \nif ( res == ORecordHook . RESULT . RECORD_REPLACED ) return res ; \n} \n} \n} \n} \nreturn recordChanged ? ORecordHook . RESULT . RECORD_CHANGED : ORecordHook . RESULT . RECORD_NOT_CHANGED ; \n} \nfinally { \npopInHook ( identity ) ; \n} \n} \n} \n"}
{"3339": "public class OCommandExecutorSQLDropClass { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( className == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal ODatabaseDocument database = getDatabase ( ) ; \nif ( ifExists && ! database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ) { \nreturn true ; \n} \nfinal OClass cls = database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; \nif ( cls == null ) { \nreturn null ; \n} \nfinal long records = cls . count ( true ) ; \nif ( records > 0 && ! unsafe ) { \nif ( cls . isSubClassOf ( \"V\" ) ) { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to avoid broken edges in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \nelse { \nif ( cls . isSubClassOf ( \"E\" ) ) { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Edges. Use 'DELETE EDGE' command first to avoid broken vertices in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \n} \ndatabase . getMetadata ( ) . getSchema ( ) . dropClass ( className ) ; \nif ( records > 0 && unsafe ) { \nif ( cls . isSubClassOf ( \"V\" ) ) { \nif ( unsafe ) OLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d vertices using UNSAFE mode. Database could contain broken edges\" , className , records ) ; \n} \nelse { \nif ( cls . isSubClassOf ( \"E\" ) ) { \nOLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d edges using UNSAFE mode. Database could contain broken vertices\" , className , records ) ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"3347": "public class FastBufferedInputStream { \npublic int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { \nByteArrays . ensureOffsetLength ( array , off , len ) ; \nif ( len == 0 ) return 0 ; \nif ( noMoreCharacters ( ) ) return - 1 ; \nint i , k = 0 , remaining = len , read = 0 ; \nfor ( ; \n; \n) { \nfor ( i = 0 ; \ni < avail && i < remaining && ( k = buffer [ pos + i ] ) != '\\n' && k != '\\r' ; \ni ++ ) ; \nSystem . arraycopy ( buffer , pos , array , off + read , i ) ; \npos += i ; \navail -= i ; \nread += i ; \nremaining -= i ; \nif ( remaining == 0 ) { \nreadBytes += read ; \nreturn read ; \n} \nif ( avail > 0 ) { \nif ( k == '\\n' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . LF ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \nelse { \narray [ off + read ++ ] = '\\n' ; \nremaining -- ; \n} \n} \nelse { \nif ( k == '\\r' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . CR_LF ) ) { \nif ( avail > 0 ) { \nif ( buffer [ pos ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \nelse { \nif ( noMoreCharacters ( ) ) { \nif ( ! terminators . contains ( LineTerminator . CR ) ) { \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \nreadBytes += read ; \n} \nelse readBytes += read + 1 ; \nreturn read ; \n} \nif ( buffer [ 0 ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \n} \nif ( terminators . contains ( LineTerminator . CR ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \n} \n} \n} \nelse { \nif ( noMoreCharacters ( ) ) { \nreadBytes += read ; \nreturn read ; \n} \n} \n} \n} \n} \n"}
{"3358": "public class FastBufferedOutputStream { \n@ Override public void position ( final long newPosition ) throws IOException { \nflush ( ) ; \nif ( repositionableStream != null ) repositionableStream . position ( newPosition ) ; \nelse { \nif ( fileChannel != null ) fileChannel . position ( newPosition ) ; \nelse throw new UnsupportedOperationException ( \"position() can only be called if the underlying byte stream implements the RepositionableStream interface or if the getChannel() method of the underlying byte stream exists and returns a FileChannel\" ) ; \n} \n} \n} \n"}
{"3387": "public class HollowAPIGenerator { \nprotected void generateFilesForHollowSchemas ( File directory ) throws IOException { \nfor ( HollowSchema schema : dataset . getSchemas ( ) ) { \nString type = schema . getName ( ) ; \nif ( config . isUseHollowPrimitiveTypes ( ) && HollowCodeGenerationUtils . isPrimitiveType ( type ) ) continue ; \ngenerateFile ( directory , getStaticAPIGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowObjectGenerator ( schema ) ) ; \ngenerateFile ( directory , getHollowFactoryGenerator ( schema ) ) ; \nif ( schema . getSchemaType ( ) == SchemaType . OBJECT ) { \nHollowObjectSchema objSchema = ( HollowObjectSchema ) schema ; \ngenerateFile ( directory , new HollowObjectDelegateInterfaceGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateCachedImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowObjectDelegateLookupImplGenerator ( packageName , objSchema , ergonomicShortcuts , dataset , config ) ) ; \ngenerateFile ( directory , new HollowDataAccessorGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \nif ( ! config . isReservePrimaryKeyIndexForTypeWithPrimaryKey ( ) ) { \ngenerateFile ( directory , new LegacyHollowPrimaryKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \n} \nelse { \nif ( ( objSchema ) . getPrimaryKey ( ) != null ) { \ngenerateFile ( directory , new HollowPrimaryKeyIndexGenerator ( dataset , packageName , apiClassname , objSchema , config ) ) ; \ngenerateFile ( directory , new HollowUniqueKeyIndexGenerator ( packageName , apiClassname , objSchema , dataset , config ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"3429": "public class HashCodes { \npublic static int hashTableSize ( int numElements ) throws IllegalArgumentException { \nif ( numElements < 0 ) { \nthrow new IllegalArgumentException ( \"cannot be negative; numElements=\" + numElements ) ; \n} \nelse { \nif ( numElements > HASH_TABLE_MAX_SIZE ) { \nthrow new IllegalArgumentException ( \"exceeds maximum number of buckets; numElements=\" + numElements ) ; \n} \n} \nif ( numElements == 0 ) return 1 ; \nif ( numElements < 3 ) return numElements * 2 ; \nint sizeAfterLoadFactor = ( int ) ( ( long ) numElements * 10 / 7 ) ; \nint bits = 32 - Integer . numberOfLeadingZeros ( sizeAfterLoadFactor - 1 ) ; \nreturn 1 << bits ; \n} \n} \n"}
{"3449": "public class PullToRefreshBase { \nprivate void pullEvent ( ) { \nfinal int newScrollValue ; \nfinal int itemDimension ; \nfinal float initialMotionValue , lastMotionValue ; \nswitch ( getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : initialMotionValue = mInitialMotionX ; \nlastMotionValue = mLastMotionX ; \nbreak ; \ncase VERTICAL : default : initialMotionValue = mInitialMotionY ; \nlastMotionValue = mLastMotionY ; \nbreak ; \n} \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getFooterSize ( ) ; \nbreak ; \ncase PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getHeaderSize ( ) ; \nbreak ; \n} \nsetHeaderScroll ( newScrollValue ) ; \nif ( newScrollValue != 0 && ! isRefreshing ( ) ) { \nfloat scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : mFooterLayout . onPull ( scale ) ; \nbreak ; \ncase PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; \nbreak ; \n} \nif ( mState != State . PULL_TO_REFRESH && itemDimension >= Math . abs ( newScrollValue ) ) { \nsetState ( State . PULL_TO_REFRESH ) ; \n} \nelse { \nif ( mState == State . PULL_TO_REFRESH && itemDimension < Math . abs ( newScrollValue ) ) { \nsetState ( State . RELEASE_TO_REFRESH ) ; \n} \n} \n} \n} \n} \n"}
{"3450": "public class OverscrollHelper { \npublic static void overScrollBy ( final PullToRefreshBase < ? > view , final int deltaX , final int scrollX , final int deltaY , final int scrollY , final int scrollRange , final int fuzzyThreshold , final float scaleFactor , final boolean isTouchEvent ) { \nfinal int deltaValue , currentScrollValue , scrollValue ; \nswitch ( view . getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : deltaValue = deltaX ; \nscrollValue = scrollX ; \ncurrentScrollValue = view . getScrollX ( ) ; \nbreak ; \ncase VERTICAL : default : deltaValue = deltaY ; \nscrollValue = scrollY ; \ncurrentScrollValue = view . getScrollY ( ) ; \nbreak ; \n} \nif ( view . isPullToRefreshOverScrollEnabled ( ) && ! view . isRefreshing ( ) ) { \nfinal Mode mode = view . getMode ( ) ; \nif ( mode . permitsPullToRefresh ( ) && ! isTouchEvent && deltaValue != 0 ) { \nfinal int newScrollValue = ( deltaValue + scrollValue ) ; \nif ( PullToRefreshBase . DEBUG ) { \nLog . d ( LOG_TAG , \"OverScroll. DeltaX: \" + deltaX + \", ScrollX: \" + scrollX + \", DeltaY: \" + deltaY + \", ScrollY: \" + scrollY + \", NewY: \" + newScrollValue + \", ScrollRange: \" + scrollRange + \", CurrentScroll: \" + currentScrollValue ) ; \n} \nif ( newScrollValue < ( 0 - fuzzyThreshold ) ) { \nif ( mode . showHeaderLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue ) ) ) ; \n} \n} \nelse { \nif ( newScrollValue > ( scrollRange + fuzzyThreshold ) ) { \nif ( mode . showFooterLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue - scrollRange ) ) ) ; \n} \n} \nelse { \nif ( Math . abs ( newScrollValue ) <= fuzzyThreshold || Math . abs ( newScrollValue - scrollRange ) <= fuzzyThreshold ) { \nview . setState ( State . RESET ) ; \n} \n} \n} \n} \nelse { \nif ( isTouchEvent && State . OVERSCROLLING == view . getState ( ) ) { \nview . setState ( State . RESET ) ; \n} \n} \n} \n} \n} \n"}
{"3482": "public class ServiceUrlUtil { \nprivate static boolean portsMatch ( ServicePort servicePort , IntOrString intOrString ) { \nif ( intOrString != null ) { \nInteger port = servicePort . getPort ( ) ; \nInteger intVal = intOrString . getIntVal ( ) ; \nString strVal = intOrString . getStrVal ( ) ; \nif ( intVal != null ) { \nif ( port != null ) { \nreturn port . intValue ( ) == intVal . intValue ( ) ; \n} \nelse { \n} \n} \nelse { \nif ( strVal != null ) { \nreturn Objects . equal ( strVal , servicePort . getName ( ) ) ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3491": "public class KubernetesHelper { \n@ SuppressWarnings ( \"unchecked\" ) public static List < HasMetadata > toItemList ( Object entity ) throws IOException { \nif ( entity instanceof List ) { \nreturn ( List < HasMetadata > ) entity ; \n} \nelse { \nif ( entity instanceof HasMetadata [ ] ) { \nHasMetadata [ ] array = ( HasMetadata [ ] ) entity ; \nreturn Arrays . asList ( array ) ; \n} \nelse { \nif ( entity instanceof KubernetesList ) { \nKubernetesList config = ( KubernetesList ) entity ; \nreturn config . getItems ( ) ; \n} \nelse { \nif ( entity instanceof Template ) { \nTemplate objects = ( Template ) entity ; \nreturn objects . getObjects ( ) ; \n} \nelse { \nList < HasMetadata > answer = new ArrayList < > ( ) ; \nif ( entity instanceof HasMetadata ) { \nanswer . add ( ( HasMetadata ) entity ) ; \n} \nreturn answer ; \n} \n} \n} \n} \n} \n} \n"}
{"3497": "public class KubernetesResourceUtil { \nprivate static Map < String , Object > readAndEnrichFragment ( PlatformMode platformMode , ResourceVersioning apiVersions , File file , String appName ) throws IOException { \nPattern pattern = Pattern . compile ( FILENAME_PATTERN , Pattern . CASE_INSENSITIVE ) ; \nMatcher matcher = pattern . matcher ( file . getName ( ) ) ; \nif ( ! matcher . matches ( ) ) { \nthrow new IllegalArgumentException ( String . format ( \"Resource file name '%s' does not match pattern <name>-<type>.(yaml|yml|json)\" , file . getName ( ) ) ) ; \n} \nString name = matcher . group ( \"name\" ) ; \nString type = matcher . group ( \"type\" ) ; \nString ext = matcher . group ( \"ext\" ) . toLowerCase ( ) ; \nString kind ; \nMap < String , Object > fragment = readFragment ( file , ext ) ; \nif ( type != null ) { \nkind = getAndValidateKindFromType ( file , type ) ; \n} \nelse { \nkind = FILENAME_TO_KIND_MAPPER . get ( name . toLowerCase ( ) ) ; \nif ( kind != null ) { \nname = null ; \n} \n} \naddKind ( fragment , kind , file . getName ( ) ) ; \nString apiVersion = apiVersions . getCoreVersion ( ) ; \nif ( Objects . equals ( kind , \"Ingress\" ) ) { \napiVersion = apiVersions . getExtensionsVersion ( ) ; \n} \nelse { \nif ( Objects . equals ( kind , \"StatefulSet\" ) || Objects . equals ( kind , \"Deployment\" ) ) { \napiVersion = apiVersions . getAppsVersion ( ) ; \n} \nelse { \nif ( Objects . equals ( kind , \"Job\" ) ) { \napiVersion = apiVersions . getJobVersion ( ) ; \n} \nelse { \nif ( Objects . equals ( kind , \"DeploymentConfig\" ) && platformMode == PlatformMode . openshift ) { \napiVersion = apiVersions . getOpenshiftV1version ( ) ; \n} \n} \n} \n} \naddIfNotExistent ( fragment , \"apiVersion\" , apiVersion ) ; \nMap < String , Object > metaMap = getMetadata ( fragment ) ; \naddIfNotExistent ( metaMap , \"name\" , StringUtils . isNotBlank ( name ) ? name : appName ) ; \nreturn fragment ; \n} \n} \n"}
{"3502": "public class AbstractPortsExtractor { \nprivate Map < String , String > readConfig ( File f ) throws IOException { \nMap < String , String > map ; \nif ( f . getName ( ) . endsWith ( JSON_EXTENSION ) ) { \nmap = flatten ( JSON_MAPPER . readValue ( f , Map . class ) ) ; \n} \nelse { \nif ( f . getName ( ) . endsWith ( YAML_EXTENSION ) || f . getName ( ) . endsWith ( YML_EXTENSION ) ) { \nmap = flatten ( YAML_MAPPER . readValue ( f , Map . class ) ) ; \n} \nelse { \nif ( f . getName ( ) . endsWith ( PROPERTIES_EXTENSION ) ) { \nProperties properties = new Properties ( ) ; \nproperties . load ( new FileInputStream ( f ) ) ; \nmap = propertiesToMap ( properties ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Can't read configuration from: [\" + f . getName ( ) + \"]. Unknown file extension.\" ) ; \n} \n} \n} \nreturn map ; \n} \n} \n"}
{"3554": "public class BaseGenerator { \nprotected void addFrom ( BuildImageConfiguration . Builder builder ) { \nString fromMode = getConfigWithFallback ( Config . fromMode , \"fabric8.generator.fromMode\" , getFromModeDefault ( context . getRuntimeMode ( ) ) ) ; \nString from = getConfigWithFallback ( Config . from , \"fabric8.generator.from\" , null ) ; \nif ( \"docker\" . equalsIgnoreCase ( fromMode ) ) { \nString fromImage = from ; \nif ( fromImage == null ) { \nfromImage = fromSelector != null ? fromSelector . getFrom ( ) : null ; \n} \nbuilder . from ( fromImage ) ; \nlog . info ( \"Using Docker image %s as base / builder\" , fromImage ) ; \n} \nelse { \nif ( \"istag\" . equalsIgnoreCase ( fromMode ) ) { \nMap < String , String > fromExt = new HashMap < > ( ) ; \nif ( from != null ) { \nImageName iName = new ImageName ( from ) ; \nString tag = iName . getTag ( ) ; \nif ( StringUtils . isBlank ( tag ) ) { \ntag = \"latest\" ; \n} \nfromExt . put ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) , iName . getSimpleName ( ) + \":\" + tag ) ; \nif ( iName . getUser ( ) != null ) { \nfromExt . put ( OpenShiftBuildStrategy . SourceStrategy . namespace . key ( ) , iName . getUser ( ) ) ; \n} \nfromExt . put ( OpenShiftBuildStrategy . SourceStrategy . kind . key ( ) , \"ImageStreamTag\" ) ; \n} \nelse { \nfromExt = fromSelector != null ? fromSelector . getImageStreamTagFromExt ( ) : null ; \n} \nif ( fromExt != null ) { \nString namespace = fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . namespace . key ( ) ) ; \nif ( namespace != null ) { \nlog . info ( \"Using ImageStreamTag '%s' from namespace '%s' as builder image\" , fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) ) , namespace ) ; \n} \nelse { \nlog . info ( \"Using ImageStreamTag '%s' as builder image\" , fromExt . get ( OpenShiftBuildStrategy . SourceStrategy . name . key ( ) ) ) ; \n} \nbuilder . fromExt ( fromExt ) ; \n} \n} \nelse { \nthrow new IllegalArgumentException ( String . format ( \"Invalid 'fromMode' in generator configuration for '%s'\" , getName ( ) ) ) ; \n} \n} \n} \n} \n"}
{"3559": "public class AbstractLiveEnricher { \nprotected String getExternalServiceURL ( String serviceName , String protocol ) { \nif ( ! isOnline ( ) ) { \ngetLog ( ) . info ( \"Not looking for service \" + serviceName + \" as we are in offline mode\" ) ; \nreturn null ; \n} \nelse { \ntry { \nKubernetesClient kubernetes = getKubernetes ( ) ; \nString ns = kubernetes . getNamespace ( ) ; \nif ( StringUtils . isBlank ( ns ) ) { \nns = getNamespace ( ) ; \n} \nService service = kubernetes . services ( ) . inNamespace ( ns ) . withName ( serviceName ) . get ( ) ; \nreturn service != null ? ServiceUrlUtil . getServiceURL ( kubernetes , serviceName , ns , protocol , true ) : null ; \n} \ncatch ( Throwable e ) { \nThrowable cause = e ; \nboolean notFound = false ; \nboolean connectError = false ; \nStack < Throwable > stack = unfoldExceptions ( e ) ; \nwhile ( ! stack . isEmpty ( ) ) { \nThrowable t = stack . pop ( ) ; \nif ( t instanceof ConnectException || \"No route to host\" . equals ( t . getMessage ( ) ) ) { \ngetLog ( ) . warn ( \"Cannot connect to Kubernetes to find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \nelse { \nif ( t instanceof IllegalArgumentException || t . getMessage ( ) != null && t . getMessage ( ) . matches ( \"^No.*found.*$\" ) ) { \ngetLog ( ) . warn ( \"%s\" , cause . getMessage ( ) ) ; \nreturn null ; \n} \n} \n; \n} \ngetLog ( ) . warn ( \"Cannot find URL for service %s : %s\" , serviceName , cause . getMessage ( ) ) ; \nreturn null ; \n} \n} \n} \n} \n"}
{"3582": "public class LocalPayment { \npublic static void startPayment ( final BraintreeFragment fragment , final LocalPaymentRequest request , final BraintreeResponseListener < LocalPaymentRequest > listener ) { \nif ( request == null ) { \nfragment . postCallback ( new BraintreeException ( \"A LocalPaymentRequest is required.\" ) ) ; \nreturn ; \n} \nelse { \nif ( request . getApprovalUrl ( ) != null || request . getPaymentId ( ) != null ) { \nfragment . postCallback ( new BraintreeException ( \"LocalPaymentRequest is invalid, \" + \"appovalUrl and paymentId should not be set.\" ) ) ; \nreturn ; \n} \nelse { \nif ( request . getPaymentType ( ) == null || request . getAmount ( ) == null ) { \nfragment . postCallback ( new BraintreeException ( \"LocalPaymentRequest is invalid, \" + \"paymentType and amount are required.\" ) ) ; \nreturn ; \n} \nelse { \nif ( listener == null ) { \nfragment . postCallback ( new BraintreeException ( \"BraintreeResponseListener<LocalPaymentRequest> \" + \"is required.\" ) ) ; \nreturn ; \n} \n} \n} \n} \nfragment . waitForConfiguration ( new ConfigurationListener ( ) { \n@ Override public void onConfigurationFetched ( Configuration configuration ) { \nif ( ! configuration . getPayPal ( ) . isEnabled ( ) ) { \nfragment . postCallback ( new ConfigurationException ( \"Local payments are not enabled for this merchant.\" ) ) ; \nreturn ; \n} \nsMerchantAccountId = request . getMerchantAccountId ( ) ; \nsPaymentType = request . getPaymentType ( ) ; \nString returnUrl = fragment . getReturnUrlScheme ( ) + \"://\" + LOCAL_PAYMENT_SUCCESSS ; \nString cancel = fragment . getReturnUrlScheme ( ) + \"://\" + LOCAL_PAYMENT_CANCEL ; \nfragment . sendAnalyticsEvent ( paymentTypeForAnalytics ( ) + \".local-payment.start-payment.selected\" ) ; \nfragment . getHttpClient ( ) . post ( \"/v1/paypal_hermes/create_payment_resource\" , request . build ( returnUrl , cancel ) , new HttpResponseCallback ( ) { \n@ Override public void success ( String responseBody ) { \ntry { \nJSONObject responseJson = new JSONObject ( responseBody ) ; \nrequest . approvalUrl ( responseJson . getJSONObject ( \"paymentResource\" ) . getString ( \"redirectUrl\" ) ) ; \nrequest . paymentId ( responseJson . getJSONObject ( \"paymentResource\" ) . getString ( \"paymentToken\" ) ) ; \nfragment . sendAnalyticsEvent ( paymentTypeForAnalytics ( ) + \".local-payment.create.succeeded\" ) ; \nlistener . onResponse ( request ) ; \n} \ncatch ( JSONException jsonException ) { \nfailure ( jsonException ) ; \n} \n} \n@ Override public void failure ( Exception exception ) { \nfragment . sendAnalyticsEvent ( paymentTypeForAnalytics ( ) + \".local-payment.webswitch.initiate.failed\" ) ; \nfragment . postCallback ( exception ) ; \n} \n} \n) ; \n} \n} \n) ; \n} \n} \n"}
{"3621": "public class AACDecoderConfig { \npublic static AACDecoderConfig parseMP4DecoderSpecificInfo ( byte [ ] data ) throws AACException { \nfinal IBitStream _in = BitStream . createBitStream ( data ) ; \nfinal AACDecoderConfig config = new AACDecoderConfig ( ) ; \ntry { \nconfig . profile = readProfile ( _in ) ; \nint sf = _in . readBits ( 4 ) ; \nif ( sf == 0xF ) config . sampleFrequency = SampleFrequency . forFrequency ( _in . readBits ( 24 ) ) ; \nelse config . sampleFrequency = SampleFrequency . forInt ( sf ) ; \nconfig . channelConfiguration = ChannelConfiguration . forInt ( _in . readBits ( 4 ) ) ; \nProfile cp = config . profile ; \nif ( AAC_SBR == cp ) { \nconfig . extProfile = cp ; \nconfig . sbrPresent = true ; \nsf = _in . readBits ( 4 ) ; \nconfig . downSampledSBR = config . sampleFrequency . getIndex ( ) == sf ; \nconfig . sampleFrequency = SampleFrequency . forInt ( sf ) ; \nconfig . profile = readProfile ( _in ) ; \n} \nelse { \nif ( AAC_MAIN == cp || AAC_LC == cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) { \nconfig . frameLengthFlag = _in . readBool ( ) ; \nif ( config . frameLengthFlag ) throw new AACException ( \"config uses 960-sample frames, not yet supported\" ) ; \nconfig . dependsOnCoreCoder = _in . readBool ( ) ; \nif ( config . dependsOnCoreCoder ) config . coreCoderDelay = _in . readBits ( 14 ) ; \nelse config . coreCoderDelay = 0 ; \nconfig . extensionFlag = _in . readBool ( ) ; \nif ( config . extensionFlag ) { \nif ( cp . isErrorResilientProfile ( ) ) { \nconfig . sectionDataResilience = _in . readBool ( ) ; \nconfig . scalefactorResilience = _in . readBool ( ) ; \nconfig . spectralDataResilience = _in . readBool ( ) ; \n} \n_in . skipBit ( ) ; \n} \nif ( config . channelConfiguration == ChannelConfiguration . CHANNEL_CONFIG_NONE ) { \n_in . skipBits ( 3 ) ; \nPCE pce = new PCE ( ) ; \npce . decode ( _in ) ; \nconfig . profile = pce . getProfile ( ) ; \nconfig . sampleFrequency = pce . getSampleFrequency ( ) ; \nconfig . channelConfiguration = ChannelConfiguration . forInt ( pce . getChannelCount ( ) ) ; \n} \nif ( _in . getBitsLeft ( ) > 10 ) readSyncExtension ( _in , config ) ; \n} \nelse { \nthrow new AACException ( \"profile not supported: \" + cp . getIndex ( ) ) ; \n} \n} \nreturn config ; \n} \nfinally { \n_in . destroy ( ) ; \n} \n} \n} \n"}
{"3647": "public class DataConvert { \npublic static int [ ] fromByte ( byte [ ] b , int depth , boolean isBe ) { \nif ( depth == 24 ) if ( isBe ) return from24BE ( b ) ; \nelse return from24LE ( b ) ; \nelse { \nif ( depth == 16 ) if ( isBe ) return from16BE ( b ) ; \nelse return from16LE ( b ) ; \n} \nthrow new NotSupportedException ( \"Conversion from \" + depth + \"bit \" + ( isBe ? \"big endian\" : \"little endian\" ) + \" is not supported.\" ) ; \n} \n} \n"}
{"3648": "public class DataConvert { \npublic static byte [ ] toByte ( int [ ] ia , int depth , boolean isBe ) { \nif ( depth == 24 ) if ( isBe ) return to24BE ( ia ) ; \nelse return to24LE ( ia ) ; \nelse { \nif ( depth == 16 ) if ( isBe ) return to16BE ( ia ) ; \nelse return to16LE ( ia ) ; \n} \nthrow new NotSupportedException ( \"Conversion to \" + depth + \"bit \" + ( isBe ? \"big endian\" : \"little endian\" ) + \" is not supported.\" ) ; \n} \n} \n"}
{"3654": "public class SliceGroupMapBuilder { \npublic static int [ ] buildBoxOutMap ( int picWidthInMbs , int picHeightInMbs , boolean changeDirection , int numberOfMbsInBox ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nfor ( int i = 0 ; \ni < picSizeInMbs ; \ni ++ ) groups [ i ] = 1 ; \nint x = ( picWidthInMbs - changeDirectionInt ) / 2 ; \nint y = ( picHeightInMbs - changeDirectionInt ) / 2 ; \nint leftBound = x ; \nint topBound = y ; \nint rightBound = x ; \nint bottomBound = y ; \nint xDir = changeDirectionInt - 1 ; \nint yDir = changeDirectionInt ; \nboolean mapUnitVacant = false ; \nfor ( int k = 0 ; \nk < numberOfMbsInBox ; \nk += ( mapUnitVacant ? 1 : 0 ) ) { \nint mbAddr = y * picWidthInMbs + x ; \nmapUnitVacant = ( groups [ mbAddr ] == 1 ) ; \nif ( mapUnitVacant ) { \ngroups [ mbAddr ] = 0 ; \n} \nif ( xDir == - 1 && x == leftBound ) { \nleftBound = Max ( leftBound - 1 , 0 ) ; \nx = leftBound ; \nxDir = 0 ; \nyDir = 2 * changeDirectionInt - 1 ; \n} \nelse { \nif ( xDir == 1 && x == rightBound ) { \nrightBound = Min ( rightBound + 1 , picWidthInMbs - 1 ) ; \nx = rightBound ; \nxDir = 0 ; \nyDir = 1 - 2 * changeDirectionInt ; \n} \nelse { \nif ( yDir == - 1 && y == topBound ) { \ntopBound = Max ( topBound - 1 , 0 ) ; \ny = topBound ; \nxDir = 1 - 2 * changeDirectionInt ; \nyDir = 0 ; \n} \nelse { \nif ( yDir == 1 && y == bottomBound ) { \nbottomBound = Min ( bottomBound + 1 , picHeightInMbs - 1 ) ; \ny = bottomBound ; \nxDir = 2 * changeDirectionInt - 1 ; \nyDir = 0 ; \n} \nelse { \nx += xDir ; \ny += yDir ; \n} \n} \n} \n} \n} \nreturn groups ; \n} \n} \n"}
{"3658": "public class MBlockDecoderUtils { \npublic static int calcMVPredictionMedian ( int a , int b , int c , int d , boolean aAvb , boolean bAvb , boolean cAvb , boolean dAvb , int ref , int comp ) { \nif ( ! cAvb ) { \nc = d ; \ncAvb = dAvb ; \n} \nif ( aAvb && ! bAvb && ! cAvb ) { \nb = c = a ; \nbAvb = cAvb = aAvb ; \n} \na = aAvb ? a : NULL_VECTOR ; \nb = bAvb ? b : NULL_VECTOR ; \nc = cAvb ? c : NULL_VECTOR ; \nif ( mvRef ( a ) == ref && mvRef ( b ) != ref && mvRef ( c ) != ref ) return mvC ( a , comp ) ; \nelse { \nif ( mvRef ( b ) == ref && mvRef ( a ) != ref && mvRef ( c ) != ref ) return mvC ( b , comp ) ; \nelse { \nif ( mvRef ( c ) == ref && mvRef ( a ) != ref && mvRef ( b ) != ref ) return mvC ( c , comp ) ; \n} \n} \nreturn mvC ( a , comp ) + mvC ( b , comp ) + mvC ( c , comp ) - min ( mvC ( a , comp ) , mvC ( b , comp ) , mvC ( c , comp ) ) - max ( mvC ( a , comp ) , mvC ( b , comp ) , mvC ( c , comp ) ) ; \n} \n} \n"}
{"3668": "public class JNILibrary { \nprivate boolean unpackLibrary ( String path ) { \nboolean retval = false ; \ntry { \nfinal Enumeration < URL > c = JNILibrary . class . getClassLoader ( ) . getResources ( path ) ; \nwhile ( c . hasMoreElements ( ) ) { \nfinal URL url = c . nextElement ( ) ; \nlog . trace ( \"path: {}; url: {}\" , path , url ) ; \nif ( url == null ) return false ; \nboolean unpacked = false ; \nFile lib ; \nif ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"file\" ) ) { \ntry { \nlib = new File ( new URI ( url . toString ( ) ) ) ; \n} \ncatch ( URISyntaxException e ) { \nlib = new File ( url . getPath ( ) ) ; \n} \nif ( ! lib . exists ( ) ) { \nlog . error ( \"Unpacked library not unpacked correctedly;  url: {}\" , url ) ; \ncontinue ; \n} \n} \nelse { \nif ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"jar\" ) ) { \nInputStream stream = url . openStream ( ) ; \nif ( stream == null ) { \nlog . error ( \"could not get stream for resource: {}\" , url . getPath ( ) ) ; \ncontinue ; \n} \nFileOutputStream out = null ; \ntry { \nFile dir = getTmpDir ( ) ; \nlib = File . createTempFile ( \"humble\" , JNIEnv . getEnv ( ) . getOSFamily ( ) == JNIEnv . OSFamily . WINDOWS ? \".dll\" : null , dir ) ; \nlib . deleteOnExit ( ) ; \nout = new FileOutputStream ( lib ) ; \nint bytesRead = 0 ; \nfinal byte [ ] buffer = new byte [ 2048 ] ; \nwhile ( ( bytesRead = stream . read ( buffer , 0 , buffer . length ) ) > 0 ) { \nout . write ( buffer , 0 , bytesRead ) ; \n} \nunpacked = true ; \n} \ncatch ( IOException e ) { \nlog . error ( \"could not create temp file: {}\" , e ) ; \ncontinue ; \n} \nfinally { \ntry { \nstream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \nif ( out != null ) try { \nout . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \ntry { \ndoJNILoad ( lib . getAbsolutePath ( ) ) ; \nretval = true ; \nbreak ; \n} \ncatch ( UnsatisfiedLinkError e ) { \n} \nfinally { \nif ( unpacked ) { \ndeleteUnpackedFile ( lib . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \n} \n} \ncatch ( IOException e1 ) { \nretval = false ; \n} \nreturn retval ; \n} \n} \n"}
{"3702": "public class JNIEnv { \npublic static CPUArch getCPUArch ( String javaCPU ) { \nfinal CPUArch javaArch ; \nfinal String javaCPUArch = javaCPU != null ? javaCPU . toLowerCase ( ) : \"\" ; \nif ( javaCPUArch . startsWith ( \"x86_64\" ) || javaCPUArch . startsWith ( \"amd64\" ) || javaCPUArch . startsWith ( \"ia64\" ) ) { \njavaArch = CPUArch . X86_64 ; \n} \nelse { \nif ( javaCPUArch . startsWith ( \"ppc64\" ) || javaCPUArch . startsWith ( \"powerpc64\" ) ) { \njavaArch = CPUArch . PPC64 ; \n} \nelse { \nif ( javaCPUArch . startsWith ( \"ppc\" ) || javaCPUArch . startsWith ( \"powerpc\" ) ) { \njavaArch = CPUArch . PPC ; \n} \nelse { \nif ( javaCPUArch . contains ( \"86\" ) ) { \njavaArch = CPUArch . X86 ; \n} \nelse { \njavaArch = CPUArch . UNKNOWN ; \n} \n} \n} \n} \nreturn javaArch ; \n} \n} \n"}
{"3703": "public class JNIEnv { \npublic static CPUArch getCPUArchFromGNUString ( String gnuString ) { \nfinal String nativeCpu = gnuString . toLowerCase ( ) ; \nfinal CPUArch nativeArch ; \nif ( nativeCpu . startsWith ( \"x86_64\" ) || nativeCpu . startsWith ( \"amd64\" ) || nativeCpu . startsWith ( \"ia64\" ) ) nativeArch = CPUArch . X86_64 ; \nelse { \nif ( nativeCpu . startsWith ( \"ppc64\" ) || nativeCpu . startsWith ( \"powerpc64\" ) ) nativeArch = CPUArch . PPC64 ; \nelse { \nif ( nativeCpu . startsWith ( \"ppc\" ) || nativeCpu . startsWith ( \"powerpc\" ) ) nativeArch = CPUArch . PPC ; \nelse { \nif ( nativeCpu . contains ( \"86\" ) ) nativeArch = CPUArch . X86 ; \nelse nativeArch = CPUArch . UNKNOWN ; \n} \n} \n} \nreturn nativeArch ; \n} \n} \n"}
{"3704": "public class JNIEnv { \npublic static OSFamily getOSFamily ( String osName ) { \nfinal OSFamily retval ; \nif ( osName != null && osName . length ( ) > 0 ) { \nif ( osName . startsWith ( \"Windows\" ) ) retval = OSFamily . WINDOWS ; \nelse { \nif ( osName . startsWith ( \"Mac\" ) ) retval = OSFamily . MAC ; \nelse { \nif ( osName . startsWith ( \"Linux\" ) ) retval = OSFamily . LINUX ; \nelse retval = OSFamily . UNKNOWN ; \n} \n} \n} \nelse retval = OSFamily . UNKNOWN ; \nreturn retval ; \n} \n} \n"}
{"3705": "public class JNIEnv { \npublic static OSFamily getOSFamilyFromGNUString ( String gnuString ) { \nfinal String nativeOs = ( gnuString != null ? gnuString . toLowerCase ( ) : \"\" ) ; \nfinal OSFamily retval ; \nif ( nativeOs . startsWith ( \"mingw\" ) || nativeOs . startsWith ( \"cygwin\" ) ) retval = OSFamily . WINDOWS ; \nelse { \nif ( nativeOs . startsWith ( \"darwin\" ) ) retval = OSFamily . MAC ; \nelse { \nif ( nativeOs . startsWith ( \"linux\" ) ) retval = OSFamily . LINUX ; \nelse retval = OSFamily . UNKNOWN ; \n} \n} \nreturn retval ; \n} \n} \n"}
{"3727": "public class FSTBytezEncoder { \npublic void writePrimitiveArray ( Object array , int off , int len ) throws IOException { \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \nif ( componentType == byte . class ) { \nwriteRawBytes ( ( byte [ ] ) array , off , len ) ; \n} \nelse { \nif ( componentType == char . class ) { \nwriteFCharArr ( ( char [ ] ) array , off , len ) ; \n} \nelse { \nif ( componentType == short . class ) { \nwriteFShortArr ( ( short [ ] ) array , off , len ) ; \n} \nelse { \nif ( componentType == int . class ) { \nwriteFIntArr ( ( int [ ] ) array , off , len ) ; \n} \nelse { \nif ( componentType == double . class ) { \nwriteFDoubleArr ( ( double [ ] ) array , off , len ) ; \n} \nelse { \nif ( componentType == float . class ) { \nwriteFFloatArr ( ( float [ ] ) array , off , len ) ; \n} \nelse { \nif ( componentType == long . class ) { \nwriteFLongArr ( ( long [ ] ) array , off , len ) ; \n} \nelse { \nif ( componentType == boolean . class ) { \nwriteFBooleanArr ( ( boolean [ ] ) array , off , len ) ; \n} \nelse { \nthrow new RuntimeException ( \"expected primitive array\" ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"3750": "public class MBOut { \npublic void writeIntPacked ( long data ) { \nif ( data <= Byte . MAX_VALUE && data >= Byte . MIN_VALUE ) writeInt ( MinBin . INT_8 , data ) ; \nelse { \nif ( data <= Short . MAX_VALUE && data >= Short . MIN_VALUE ) writeInt ( MinBin . INT_16 , data ) ; \nelse { \nif ( data <= Integer . MAX_VALUE && data >= Integer . MIN_VALUE ) writeInt ( MinBin . INT_32 , data ) ; \nelse { \nif ( data <= Long . MAX_VALUE && data >= Long . MIN_VALUE ) writeInt ( MinBin . INT_64 , data ) ; \n} \n} \n} \n} \n} \n"}
{"3751": "public class MBOut { \npublic void writeArray ( Object primitiveArray , int start , int len ) { \nbyte type = MinBin . ARRAY_MASK ; \nClass < ? > componentType = primitiveArray . getClass ( ) . getComponentType ( ) ; \nif ( componentType == boolean . class ) type |= MinBin . INT_8 ; \nelse { \nif ( componentType == byte . class ) type |= MinBin . INT_8 ; \nelse { \nif ( componentType == short . class ) type |= MinBin . INT_16 ; \nelse { \nif ( componentType == char . class ) type |= MinBin . INT_16 | MinBin . UNSIGN_MASK ; \nelse { \nif ( componentType == int . class ) type |= MinBin . INT_32 ; \nelse { \nif ( componentType == long . class ) type |= MinBin . INT_64 ; \nelse throw new RuntimeException ( \"unsupported type \" + componentType . getName ( ) ) ; \n} \n} \n} \n} \n} \nwriteOut ( type ) ; \nwriteIntPacked ( len ) ; \nswitch ( type ) { \ncase MinBin . INT_8 | MinBin . ARRAY_MASK : { \nif ( componentType == boolean . class ) { \nboolean [ ] arr = ( boolean [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ? 1 : 0 ) ; \n} \n} \nelse { \nbyte [ ] arr = ( byte [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \n} \nbreak ; \ncase MinBin . CHAR | MinBin . ARRAY_MASK : { \nchar [ ] charArr = ( char [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , charArr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_32 | MinBin . ARRAY_MASK : { \nint [ ] arr = ( int [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_64 | MinBin . ARRAY_MASK : { \nlong [ ] arr = ( long [ ] ) primitiveArray ; \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ndefault : { \nfor ( int i = start ; \ni < start + len ; \ni ++ ) { \nif ( componentType == boolean . class ) writeRawInt ( type , Array . getBoolean ( primitiveArray , i ) ? 1 : 0 ) ; \nelse writeRawInt ( type , Array . getLong ( primitiveArray , i ) ) ; \n} \n} \n} \n} \n} \n"}
{"3762": "public class FSTObjectRegistry { \npublic int registerObjectForWrite ( Object o , int streamPosition , FSTClazzInfo clzInfo , int reUseType [ ] ) { \nif ( disabled ) { \nreturn Integer . MIN_VALUE ; \n} \nif ( clzInfo == null ) { \n} \nelse { \nif ( clzInfo . isFlat ( ) ) { \nreturn Integer . MIN_VALUE ; \n} \n} \nint handle = objects . putOrGet ( o , streamPosition ) ; \nif ( handle >= 0 ) { \nreUseType [ 0 ] = 0 ; \nreturn handle ; \n} \nreturn Integer . MIN_VALUE ; \n} \n} \n"}
{"3772": "public class ReflectionUtils { \npublic static void printThreadInfo ( PrintWriter stream , String title ) { \nfinal int STACK_DEPTH = 20 ; \nboolean contention = threadBean . isThreadContentionMonitoringEnabled ( ) ; \nlong [ ] threadIds = threadBean . getAllThreadIds ( ) ; \nstream . println ( \"Process Thread Dump: \" + title ) ; \nstream . println ( threadIds . length + \" active threads\" ) ; \nfor ( long tid : threadIds ) { \nThreadInfo info = threadBean . getThreadInfo ( tid , STACK_DEPTH ) ; \nif ( info == null ) { \nstream . println ( \"  Inactive\" ) ; \ncontinue ; \n} \nstream . println ( \"Thread \" + getTaskName ( info . getThreadId ( ) , info . getThreadName ( ) ) + \":\" ) ; \nThread . State state = info . getThreadState ( ) ; \nstream . println ( \"  State: \" + state ) ; \nstream . println ( \"  Blocked count: \" + info . getBlockedCount ( ) ) ; \nstream . println ( \"  Waited count: \" + info . getWaitedCount ( ) ) ; \nif ( contention ) { \nstream . println ( \"  Blocked time: \" + info . getBlockedTime ( ) ) ; \nstream . println ( \"  Waited time: \" + info . getWaitedTime ( ) ) ; \n} \nif ( state == Thread . State . WAITING ) { \nstream . println ( \"  Waiting on \" + info . getLockName ( ) ) ; \n} \nelse { \nif ( state == Thread . State . BLOCKED ) { \nstream . println ( \"  Blocked on \" + info . getLockName ( ) ) ; \nstream . println ( \"  Blocked by \" + getTaskName ( info . getLockOwnerId ( ) , info . getLockOwnerName ( ) ) ) ; \n} \n} \nstream . println ( \"  Stack:\" ) ; \nfor ( StackTraceElement frame : info . getStackTrace ( ) ) { \nstream . println ( \"    \" + frame . toString ( ) ) ; \n} \n} \nstream . flush ( ) ; \n} \n} \n"}
{"3776": "public class BaseBroadcastOp { \npublic List < long [ ] > calculateOutputShape ( ) { \nList < long [ ] > ret = new ArrayList < > ( ) ; \nif ( larg ( ) . getShape ( ) != null && rarg ( ) . getShape ( ) != null ) ret . add ( Shape . broadcastOutputShape ( larg ( ) . getShape ( ) , rarg ( ) . getShape ( ) ) ) ; \nelse { \nif ( larg ( ) . getShape ( ) != null ) ret . add ( larg ( ) . getShape ( ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3861": "public class JCublasNDArrayFactory { \n@ Override public INDArray createFromNpyPointer ( Pointer pointer ) { \nPointer dataPointer = nativeOps . dataPointForNumpy ( pointer ) ; \nint dataBufferElementSize = nativeOps . elementSizeForNpyArray ( pointer ) ; \nDataBuffer data = null ; \nPointer shapeBufferPointer = nativeOps . shapeBufferForNumpy ( pointer ) ; \nint length = nativeOps . lengthForShapeBufferPointer ( shapeBufferPointer ) ; \nshapeBufferPointer . capacity ( 4 * length ) ; \nshapeBufferPointer . limit ( 4 * length ) ; \nshapeBufferPointer . position ( 0 ) ; \nval intPointer = new LongPointer ( shapeBufferPointer ) ; \nDataBuffer shapeBuffer = Nd4j . createBuffer ( shapeBufferPointer , DataBuffer . Type . LONG , length , LongRawIndexer . create ( intPointer ) ) ; \ndataPointer . position ( 0 ) ; \ndataPointer . limit ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; \ndataPointer . capacity ( dataBufferElementSize * Shape . length ( shapeBuffer ) ) ; \nif ( dataBufferElementSize == ( Float . SIZE / 8 ) ) { \ndata = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . FLOAT , Shape . length ( shapeBuffer ) , FloatIndexer . create ( new FloatPointer ( dataPointer ) ) ) ; \n} \nelse { \nif ( dataBufferElementSize == ( Double . SIZE / 8 ) ) { \ndata = Nd4j . createBuffer ( dataPointer , DataBuffer . Type . DOUBLE , Shape . length ( shapeBuffer ) , DoubleIndexer . create ( new DoublePointer ( dataPointer ) ) ) ; \n} \n} \nINDArray ret = Nd4j . create ( data , Shape . shape ( shapeBuffer ) , Shape . strideArr ( shapeBuffer ) , Shape . offset ( shapeBuffer ) , Shape . order ( shapeBuffer ) ) ; \nreturn ret ; \n} \n} \n"}
{"3866": "public class CudaGridExecutioner { \n@ Override public Op exec ( Op op ) { \ncheckForCompression ( op ) ; \ninvokeWatchdog ( op ) ; \nif ( op instanceof Accumulation ) { \nexec ( ( Accumulation ) op , new int [ ] { \nInteger . MAX_VALUE } \n) ; \n} \nelse { \nif ( op instanceof IndexAccumulation ) { \nexec ( ( IndexAccumulation ) op , new int [ ] { \nInteger . MAX_VALUE } \n) ; \n} \nelse { \nif ( op instanceof ScalarOp || op instanceof TransformOp ) { \nprocessAsGridOp ( op ) ; \n} \nelse { \nif ( op instanceof BroadcastOp ) { \ninvoke ( ( BroadcastOp ) op ) ; \n} \nelse { \npushToGrid ( new OpDescriptor ( op ) ) ; \n} \n} \n} \n} \nreturn op ; \n} \n} \n"}
{"3883": "public class OpProfiler { \nprotected String getOpClass ( Op op ) { \nif ( op instanceof ScalarOp ) { \nreturn \"ScalarOp\" ; \n} \nelse { \nif ( op instanceof MetaOp ) { \nreturn \"MetaOp\" ; \n} \nelse { \nif ( op instanceof GridOp ) { \nreturn \"GridOp\" ; \n} \nelse { \nif ( op instanceof BroadcastOp ) { \nreturn \"BroadcastOp\" ; \n} \nelse { \nif ( op instanceof RandomOp ) { \nreturn \"RandomOp\" ; \n} \nelse { \nif ( op instanceof Accumulation ) { \nreturn \"AccumulationOp\" ; \n} \nelse { \nif ( op instanceof TransformOp ) { \nif ( op . y ( ) == null ) { \nreturn \"TransformOp\" ; \n} \nelse return \"PairWiseTransformOp\" ; \n} \nelse { \nif ( op instanceof IndexAccumulation ) { \nreturn \"IndexAccumulationOp\" ; \n} \nelse { \nif ( op instanceof CustomOp ) { \nreturn \"CustomOp\" ; \n} \nelse return \"Unknown Op calls\" ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"3899": "public class BigDecimalMath { \nstatic public BigDecimal exp ( BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nfinal BigDecimal invx = exp ( x . negate ( ) ) ; \nMathContext mc = new MathContext ( invx . precision ( ) ) ; \nreturn BigDecimal . ONE . divide ( invx , mc ) ; \n} \nelse { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; \n} \nelse { \nfinal double xDbl = x . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nif ( Math . pow ( xDbl , TAYLOR_NTERM ) < TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl ) { \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; \nfor ( int i = 1 ; \ni <= TAYLOR_NTERM ; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; \nxpowi = xpowi . multiply ( x ) ; \nfinal BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( c ) ; \nif ( Math . abs ( xpowi . doubleValue ( ) ) < i && Math . abs ( c . doubleValue ( ) ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nint exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; \nBigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; \nBigDecimal expxby10 = exp ( xby10 ) ; \nMathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; \nwhile ( exSc > 0 ) { \nint exsub = Math . min ( 8 , exSc ) ; \nexSc -= exsub ; \nMathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; \nint pex = 1 ; \nwhile ( exsub -- > 0 ) { \npex *= 10 ; \n} \nexpxby10 = expxby10 . pow ( pex , mctmp ) ; \n} \nreturn expxby10 . round ( mc ) ; \n} \n} \n} \n} \n} \n"}
{"3901": "public class BigDecimalMath { \nstatic public BigDecimal pow ( final BigDecimal x , final BigDecimal y ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nthrow new ArithmeticException ( \"Cannot power negative \" + x . toString ( ) ) ; \n} \nelse { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal logx = log ( x ) ; \nBigDecimal ylogx = y . multiply ( logx ) ; \nBigDecimal resul = exp ( ylogx ) ; \ndouble errR = Math . abs ( logx . doubleValue ( ) * y . ulp ( ) . doubleValue ( ) / 2. ) + Math . abs ( y . doubleValue ( ) * x . ulp ( ) . doubleValue ( ) / 2. / x . doubleValue ( ) ) ; \nMathContext mcR = new MathContext ( err2prec ( 1.0 , errR ) ) ; \nreturn resul . round ( mcR ) ; \n} \n} \n} \n} \n"}
{"3903": "public class BigDecimalMath { \nstatic public BigDecimal sin ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn sin ( x . negate ( ) ) . negate ( ) ; \n} \nelse { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal res = mod2pi ( x ) ; \ndouble errpi = 0.5 * Math . abs ( x . ulp ( ) . doubleValue ( ) ) ; \nint val = 2 + err2prec ( FastMath . PI , errpi ) ; \nMathContext mc = new MathContext ( val ) ; \nBigDecimal p = pi ( mc ) ; \nmc = new MathContext ( x . precision ( ) ) ; \nif ( res . compareTo ( p ) > 0 ) { \nreturn sin ( subtractRound ( res , p ) ) . negate ( ) ; \n} \nelse { \nif ( res . multiply ( new BigDecimal ( 2 ) ) . compareTo ( p ) > 0 ) { \nreturn sin ( subtractRound ( p , res ) ) ; \n} \nelse { \nif ( res . multiply ( new BigDecimal ( 4 ) ) . compareTo ( p ) > 0 ) { \nreturn cos ( subtractRound ( p . divide ( new BigDecimal ( 2 ) ) , res ) ) ; \n} \nelse { \nBigDecimal resul = res ; \nBigDecimal xpowi = res ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = res . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( res . precision ( ) / Math . log10 ( 1.0 / res . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( res . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( res ) . multiply ( res ) . negate ( ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nmc = new MathContext ( res . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"3904": "public class BigDecimalMath { \nstatic public BigDecimal tan ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn tan ( x . negate ( ) ) . negate ( ) ; \n} \nelse { \nBigDecimal res = modpi ( x ) ; \nfinal double xDbl = res . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) / 2. ; \nfinal double eps = xUlpDbl / 2. / Math . pow ( Math . cos ( xDbl ) , 2. ) ; \nif ( xDbl > 0.8 ) { \nBigDecimal co = cot ( x ) ; \nMathContext mc = new MathContext ( err2prec ( 1. / co . doubleValue ( ) , eps ) ) ; \nreturn BigDecimal . ONE . divide ( co , mc ) ; \n} \nelse { \nfinal BigDecimal xhighpr = scalePrec ( res , 2 ) ; \nfinal BigDecimal xhighprSq = multiplyRound ( xhighpr , xhighpr ) ; \nBigDecimal result = xhighpr . plus ( ) ; \nBigDecimal xpowi = xhighpr ; \nBernoulli b = new Bernoulli ( ) ; \nBigInteger fourn = BigInteger . valueOf ( 4 ) ; \nBigInteger fac = BigInteger . valueOf ( 2 ) ; \nfor ( int i = 2 ; \n; \ni ++ ) { \nRational f = b . at ( 2 * i ) . abs ( ) ; \nfourn = fourn . shiftLeft ( 2 ) ; \nfac = fac . multiply ( BigInteger . valueOf ( 2 * i ) ) . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nf = f . multiply ( fourn ) . multiply ( fourn . subtract ( BigInteger . ONE ) ) . divide ( fac ) ; \nxpowi = multiplyRound ( xpowi , xhighprSq ) ; \nBigDecimal c = multiplyRound ( xpowi , f ) ; \nresult = result . add ( c ) ; \nif ( Math . abs ( c . doubleValue ( ) ) < 0.1 * eps ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( result . doubleValue ( ) , eps ) ) ; \nreturn result . round ( mc ) ; \n} \n} \n} \n} \n} \n"}
{"3905": "public class BigDecimalMath { \nstatic public BigDecimal cosh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn cos ( x . negate ( ) ) ; \n} \nelse { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ONE ; \n} \nelse { \nif ( x . doubleValue ( ) > 1.5 ) { \nreturn hypot ( 1 , sinh ( x ) ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = 0.5 * x . ulp ( ) . doubleValue ( ) * x . doubleValue ( ) ; \nint k = ( int ) ( Math . log ( xUlpDbl ) / Math . log ( x . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( resul . doubleValue ( ) , xUlpDbl ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n} \n"}
{"3906": "public class BigDecimalMath { \nstatic public BigDecimal sinh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn sinh ( x . negate ( ) ) . negate ( ) ; \n} \nelse { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nif ( x . doubleValue ( ) > 2.4 ) { \nBigDecimal two = new BigDecimal ( 2 ) ; \nBigDecimal xhalf = x . divide ( two ) ; \nBigDecimal resul = sinh ( xhalf ) . multiply ( cosh ( xhalf ) ) . multiply ( two ) ; \ndouble eps = Math . tanh ( x . doubleValue ( ) ) ; \nMathContext mc = new MathContext ( err2prec ( 0.5 * x . ulp ( ) . doubleValue ( ) / eps ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = xhighpr ; \nBigDecimal xpowi = xhighpr ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( x . precision ( ) / Math . log10 ( 1.0 / xhighpr . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( x . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( corr . abs ( ) . doubleValue ( ) < 0.5 * xUlpDbl ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( x . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n} \n"}
{"3907": "public class BigDecimalMath { \nstatic public BigDecimal tanh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn tanh ( x . negate ( ) ) . negate ( ) ; \n} \nelse { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal exp2x = exp ( xhighpr . multiply ( new BigDecimal ( - 2 ) ) ) ; \ndouble eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . pow ( Math . cosh ( x . doubleValue ( ) ) , 2.0 ) ; \nMathContext mc = new MathContext ( err2prec ( Math . tanh ( x . doubleValue ( ) ) , eps ) ) ; \nreturn BigDecimal . ONE . subtract ( exp2x ) . divide ( BigDecimal . ONE . add ( exp2x ) , mc ) ; \n} \n} \n} \n} \n"}
{"3909": "public class BigDecimalMath { \nstatic public BigDecimal acosh ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ONE ) < 0 ) { \nthrow new ArithmeticException ( \"Out of range argument cosh \" + x . toString ( ) ) ; \n} \nelse { \nif ( x . compareTo ( BigDecimal . ONE ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal logx = log ( sqrt ( xhighpr . pow ( 2 ) . subtract ( BigDecimal . ONE ) ) . add ( xhighpr ) ) ; \ndouble xDbl = x . doubleValue ( ) ; \ndouble eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . sqrt ( xDbl * xDbl - 1. ) ; \nMathContext mc = new MathContext ( err2prec ( logx . doubleValue ( ) , eps ) ) ; \nreturn logx . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3910": "public class BigDecimalMath { \nstatic public BigDecimal Gamma ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) < 0 ) { \nreturn divideRound ( Gamma ( x . add ( BigDecimal . ONE ) ) , x ) ; \n} \nelse { \nif ( x . doubleValue ( ) > 1.5 ) { \nint n = ( int ) ( x . doubleValue ( ) - 0.5 ) ; \nBigDecimal xmin1 = x . subtract ( new BigDecimal ( n ) ) ; \nreturn multiplyRound ( Gamma ( xmin1 ) , pochhammer ( xmin1 , n ) ) ; \n} \nelse { \nBigDecimal z = x . subtract ( BigDecimal . ONE ) ; \nz = scalePrec ( z , 2 ) ; \nMathContext mcloc = new MathContext ( z . precision ( ) ) ; \ndouble eps = x . ulp ( ) . doubleValue ( ) / x . doubleValue ( ) ; \nBigDecimal resul = log ( scalePrec ( x , 2 ) ) . negate ( ) ; \nif ( x . compareTo ( BigDecimal . ONE ) != 0 ) { \nBigDecimal gammCompl = BigDecimal . ONE . subtract ( gamma ( mcloc ) ) ; \nresul = resul . add ( multiplyRound ( z , gammCompl ) ) ; \nfor ( int n = 2 ; \n; \nn ++ ) { \nBigDecimal c = divideRound ( z . pow ( n , mcloc ) , n ) ; \nMathContext m = new MathContext ( err2prec ( n * z . ulp ( ) . doubleValue ( ) / 2. / z . doubleValue ( ) ) ) ; \nc = c . round ( m ) ; \nif ( eps / 100. / c . doubleValue ( ) < 0.01 ) { \nm = new MathContext ( err2prec ( eps / 100. / c . doubleValue ( ) ) ) ; \n} \nelse { \nm = new MathContext ( 2 ) ; \n} \nBigDecimal zetm1 = zeta ( n , m ) . subtract ( BigDecimal . ONE ) ; \nc = multiplyRound ( c , zetm1 ) ; \nif ( n % 2 == 0 ) { \nresul = resul . add ( c ) ; \n} \nelse { \nresul = resul . subtract ( c ) ; \n} \nif ( Math . abs ( c . doubleValue ( ) ) < eps ) { \nbreak ; \n} \n} \n} \ndouble psi = 0.5772156649 ; \ndouble zdbl = z . doubleValue ( ) ; \nfor ( int n = 1 ; \nn < 5 ; \nn ++ ) { \npsi += zdbl / n / ( n + zdbl ) ; \n} \neps = psi * x . ulp ( ) . doubleValue ( ) / 2. ; \nmcloc = new MathContext ( err2prec ( eps ) ) ; \nreturn exp ( resul ) . round ( mcloc ) ; \n} \n} \n} \n} \n"}
{"3915": "public class SameDiff { \npublic void putFunctionForId ( String id , DifferentialFunction function ) { \nif ( functionInstancesById . containsKey ( id ) ) { \nthrow new ND4JIllegalStateException ( \"Function by id already exists!\" ) ; \n} \nelse { \nif ( function instanceof SDVariable ) { \nthrow new ND4JIllegalStateException ( \"Function must not be a variable!\" ) ; \n} \n} \nfunctionInstancesById . put ( id , function ) ; \n} \n} \n"}
{"3937": "public class SameDiff { \npublic INDArray execBackwardAndEndResult ( ) { \nList < DifferentialFunction > backwards = execBackwards ( ) . getRight ( ) ; \nDifferentialFunction df = backwards . get ( backwards . size ( ) - 1 ) ; \nif ( df instanceof Op ) { \nreturn ( ( Op ) df ) . z ( ) ; \n} \nelse { \nif ( df instanceof DynamicCustomOp ) { \nreturn ( ( DynamicCustomOp ) df ) . getOutputArgument ( 0 ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n} \n"}
{"3939": "public class CudaMemoryManager { \n@ Override public Pointer allocate ( long bytes , MemoryKind kind , boolean initialize ) { \nAtomicAllocator allocator = AtomicAllocator . getInstance ( ) ; \nif ( kind == MemoryKind . HOST ) { \nPointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocHost ( bytes , 0 ) ; \nif ( ptr == null ) throw new RuntimeException ( \"Failed to allocate \" + bytes + \" bytes from HOST memory\" ) ; \nif ( initialize ) Pointer . memset ( ptr , 0 , bytes ) ; \nreturn ptr ; \n} \nelse { \nif ( kind == MemoryKind . DEVICE ) { \nPointer ptr = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . mallocDevice ( bytes , null , 0 ) ; \nif ( ptr == null ) throw new RuntimeException ( \"Failed to allocate \" + bytes + \" bytes from DEVICE [\" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) + \"] memory\" ) ; \nif ( initialize ) { \nCudaContext context = ( CudaContext ) AtomicAllocator . getInstance ( ) . getDeviceContext ( ) . getContext ( ) ; \nint i = NativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . memsetAsync ( ptr , 0 , bytes , 0 , context . getSpecialStream ( ) ) ; \nif ( i == 0 ) throw new ND4JIllegalStateException ( \"memset failed on device_\" + Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) ) ; \ncontext . getSpecialStream ( ) . synchronize ( ) ; \n} \nreturn ptr ; \n} \nelse throw new RuntimeException ( \"Unknown MemoryKind requested: \" + kind ) ; \n} \n} \n} \n"}
{"3951": "public class NativeOpExecutioner { \nprivate void invoke ( ScalarOp op , int [ ] dimension ) { \ndimension = Shape . normalizeAxis ( op . x ( ) . rank ( ) , dimension ) ; \nPair < DataBuffer , DataBuffer > tadBuffers = tadManager . getTADOnlyShapeInfo ( op . x ( ) , dimension ) ; \nPointer hostTadShapeInfo = tadBuffers . getFirst ( ) . addressPointer ( ) ; \nPointer hostTadOffsets = tadBuffers . getSecond ( ) . addressPointer ( ) ; \nPointer devTadShapeInfoZ = null ; \nPointer devTadOffsetsZ = null ; \nPair < DataBuffer , DataBuffer > tadBuffersZ = tadManager . getTADOnlyShapeInfo ( op . z ( ) , dimension ) ; \ndevTadShapeInfoZ = tadBuffersZ . getFirst ( ) . addressPointer ( ) ; \ndevTadOffsetsZ = tadBuffersZ . getSecond ( ) . addressPointer ( ) ; \nif ( extraz . get ( ) == null ) extraz . set ( new PointerPointer ( 32 ) ) ; \nPointerPointer dummy = extraz . get ( ) . put ( hostTadShapeInfo , hostTadOffsets , devTadShapeInfoZ , devTadOffsetsZ ) ; \nif ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . FLOAT ) { \nloop . execScalarFloat ( dummy , op . opNum ( ) , ( FloatPointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( FloatPointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( FloatPointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; \n} \nelse { \nif ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) { \nloop . execScalarDouble ( dummy , op . opNum ( ) , ( DoublePointer ) op . x ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . x ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . z ( ) . data ( ) . addressPointer ( ) , ( LongPointer ) op . z ( ) . shapeInfoDataBuffer ( ) . addressPointer ( ) , ( DoublePointer ) op . y ( ) . data ( ) . addressPointer ( ) , ( DoublePointer ) getPointerForExtraArgs ( op ) , ( IntPointer ) Nd4j . getConstantHandler ( ) . getConstantBuffer ( dimension ) . addressPointer ( ) , dimension . length ) ; \n} \n} \n} \n} \n"}
{"3966": "public class NDArrayIndex { \npublic static INDArrayIndex [ ] create ( INDArray index ) { \nif ( index . isMatrix ( ) ) { \nif ( index . rows ( ) > Integer . MAX_VALUE ) throw new ND4JArraySizeException ( ) ; \nNDArrayIndex [ ] ret = new NDArrayIndex [ ( int ) index . rows ( ) ] ; \nfor ( int i = 0 ; \ni < index . rows ( ) ; \ni ++ ) { \nINDArray row = index . getRow ( i ) ; \nval nums = new long [ ( int ) index . getRow ( i ) . columns ( ) ] ; \nfor ( int j = 0 ; \nj < row . columns ( ) ; \nj ++ ) { \nnums [ j ] = ( int ) row . getFloat ( j ) ; \n} \nNDArrayIndex idx = new NDArrayIndex ( nums ) ; \nret [ i ] = idx ; \n} \nreturn ret ; \n} \nelse { \nif ( index . isVector ( ) ) { \nlong [ ] indices = NDArrayUtil . toLongs ( index ) ; \nreturn new NDArrayIndex [ ] { \nnew NDArrayIndex ( indices ) } \n; \n} \n} \nthrow new IllegalArgumentException ( \"Passed in ndarray must be a matrix or a vector\" ) ; \n} \n} \n"}
{"3971": "public class BaseGraphMapper { \n@ Override public SameDiff importGraph ( GRAPH_TYPE tfGraph ) { \nSameDiff diff = SameDiff . create ( ) ; \nImportState < GRAPH_TYPE , TENSOR_TYPE > importState = new ImportState < > ( ) ; \nimportState . setSameDiff ( diff ) ; \nimportState . setGraph ( tfGraph ) ; \nval variablesForGraph = variablesForGraph ( tfGraph ) ; \nimportState . setVariables ( variablesForGraph ) ; \nfor ( Map . Entry < String , TENSOR_TYPE > entry : variablesForGraph . entrySet ( ) ) { \nif ( dataTypeForTensor ( entry . getValue ( ) ) == DataBuffer . Type . UNKNOWN ) { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , null , new ZeroInitScheme ( 'c' ) ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nif ( var . getShape ( ) != null ) importState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , var . getShape ( ) ) ; \n} \ncontinue ; \n} \nval arr = getNDArrayFromTensor ( entry . getKey ( ) , entry . getValue ( ) , tfGraph ) ; \nif ( arr != null ) { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , arr ) ; \ndiff . associateArrayWithVariable ( arr , var ) ; \n} \nelse { \nif ( getShapeFromTensor ( entry . getValue ( ) ) == null ) { \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , null , new ZeroInitScheme ( 'c' ) ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nval originalShape = getShapeFromTensor ( entry . getValue ( ) ) ; \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nif ( var . getShape ( ) != null ) importState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , originalShape ) ; \n} \n} \nelse { \nval originalShape = getShapeFromTensor ( entry . getValue ( ) ) ; \nval var = importState . getSameDiff ( ) . var ( entry . getKey ( ) , originalShape ) ; \nif ( isPlaceHolder ( entry . getValue ( ) ) ) { \nimportState . getSameDiff ( ) . addAsPlaceHolder ( var . getVarName ( ) ) ; \nimportState . getSameDiff ( ) . setOriginalPlaceHolderShape ( var . getVarName ( ) , originalShape ) ; \n} \n} \n} \n} \nval tfNodesList = getNodeList ( tfGraph ) ; \nfor ( NODE_TYPE tfNode : tfNodesList ) { \nif ( ! opsToIgnore ( ) . contains ( getOpType ( tfNode ) ) || isOpIgnoreException ( tfNode ) ) mapNodeType ( tfNode , importState ) ; \n} \nreturn diff ; \n} \n} \n"}
{"3984": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray subi ( INDArray other , INDArray result ) { \nIComplexNDArray cOther = ( IComplexNDArray ) other ; \nIComplexNDArray cResult = ( IComplexNDArray ) result ; \nif ( other . isScalar ( ) ) return subi ( cOther . getComplex ( 0 ) , result ) ; \nif ( result == this ) Nd4j . getBlasWrapper ( ) . axpy ( Nd4j . NEG_UNIT , cOther , cResult ) ; \nelse { \nif ( result == other ) { \nif ( data . dataType ( ) == ( DataBuffer . Type . DOUBLE ) ) { \nNd4j . getBlasWrapper ( ) . scal ( Nd4j . NEG_UNIT . asDouble ( ) , cResult ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \nelse { \nNd4j . getBlasWrapper ( ) . scal ( Nd4j . NEG_UNIT . asFloat ( ) , cResult ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \n} \nelse { \nNd4j . getBlasWrapper ( ) . copy ( this , result ) ; \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . NEG_UNIT , cOther , cResult ) ; \n} \n} \nreturn cResult ; \n} \n} \n"}
{"3985": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray addi ( INDArray other , INDArray result ) { \nIComplexNDArray cOther = ( IComplexNDArray ) other ; \nIComplexNDArray cResult = ( IComplexNDArray ) result ; \nif ( cOther . isScalar ( ) ) { \nreturn cResult . addi ( cOther . getComplex ( 0 ) , result ) ; \n} \nif ( isScalar ( ) ) { \nreturn cOther . addi ( getComplex ( 0 ) , result ) ; \n} \nif ( result == this ) { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , cOther , cResult ) ; \n} \nelse { \nif ( result == other ) { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \nelse { \nINDArray resultLinear = result . linearView ( ) ; \nINDArray otherLinear = other . linearView ( ) ; \nINDArray linear = linearView ( ) ; \nfor ( int i = 0 ; \ni < resultLinear . length ( ) ; \ni ++ ) { \nresultLinear . putScalar ( i , otherLinear . getDouble ( i ) + linear . getDouble ( i ) ) ; \n} \n} \n} \nreturn ( IComplexNDArray ) result ; \n} \n} \n"}
{"3993": "public class DistributedSgDotMessage { \n@ Override public void processMessage ( ) { \nSkipGramRequestMessage sgrm = new SkipGramRequestMessage ( w1 , w2 , rowsB , codes , negSamples , alpha , 119 ) ; \nif ( negSamples > 0 ) { \nint negatives [ ] = Arrays . copyOfRange ( rowsB , codes . length , rowsB . length ) ; \nsgrm . setNegatives ( negatives ) ; \n} \nsgrm . setTaskId ( this . taskId ) ; \nsgrm . setOriginatorId ( this . getOriginatorId ( ) ) ; \nSkipGramTrainer sgt = ( SkipGramTrainer ) trainer ; \nsgt . pickTraining ( sgrm ) ; \nint resultLength = codes . length + ( negSamples > 0 ? ( negSamples + 1 ) : 0 ) ; \nINDArray result = Nd4j . createUninitialized ( resultLength , 1 ) ; \nint e = 0 ; \nfor ( ; \ne < codes . length ; \ne ++ ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1 ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nfor ( ; \ne < resultLength ; \ne ++ ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1_NEGATIVE ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nif ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . AVERAGING ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) 1 , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . putMessage ( dot ) ; \n} \nelse { \nif ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . SHARDED ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) voidConfiguration . getNumberOfShards ( ) , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . sendMessage ( dot ) ; \n} \n} \n} \n} \n"}
{"4020": "public class GenericTypeReflector { \nstatic boolean isMissingTypeParameters ( Type type ) { \nif ( type instanceof Class ) { \nfor ( Class < ? > clazz = ( Class < ? > ) type ; \nclazz != null ; \nclazz = clazz . getEnclosingClass ( ) ) { \nif ( clazz . getTypeParameters ( ) . length != 0 ) return true ; \n} \nreturn false ; \n} \nelse { \nif ( type instanceof ParameterizedType ) { \nreturn false ; \n} \nelse { \nthrow new AssertionError ( \"Unexpected type \" + type . getClass ( ) ) ; \n} \n} \n} \n} \n"}
{"4021": "public class GenericTypeReflector { \npublic static boolean isSuperType ( Type superType , Type subType ) { \nif ( superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType ) { \nClass < ? > superClass = erase ( superType ) ; \nType mappedSubType = getExactSuperType ( capture ( subType ) , superClass ) ; \nif ( mappedSubType == null ) { \nreturn false ; \n} \nelse { \nif ( superType instanceof Class < ? > ) { \nreturn true ; \n} \nelse { \nif ( mappedSubType instanceof Class < ? > ) { \nreturn true ; \n} \nelse { \nif ( mappedSubType instanceof GenericArrayType ) { \nType superComponentType = getArrayComponentType ( superType ) ; \nassert superComponentType != null ; \nType mappedSubComponentType = getArrayComponentType ( mappedSubType ) ; \nassert mappedSubComponentType != null ; \nreturn isSuperType ( superComponentType , mappedSubComponentType ) ; \n} \nelse { \nassert mappedSubType instanceof ParameterizedType ; \nParameterizedType pMappedSubType = ( ParameterizedType ) mappedSubType ; \nassert pMappedSubType . getRawType ( ) == superClass ; \nParameterizedType pSuperType = ( ParameterizedType ) superType ; \nType [ ] superTypeArgs = pSuperType . getActualTypeArguments ( ) ; \nType [ ] subTypeArgs = pMappedSubType . getActualTypeArguments ( ) ; \nassert superTypeArgs . length == subTypeArgs . length ; \nfor ( int i = 0 ; \ni < superTypeArgs . length ; \ni ++ ) { \nif ( ! contains ( superTypeArgs [ i ] , subTypeArgs [ i ] ) ) { \nreturn false ; \n} \n} \nreturn pSuperType . getOwnerType ( ) == null || isSuperType ( pSuperType . getOwnerType ( ) , pMappedSubType . getOwnerType ( ) ) ; \n} \n} \n} \n} \n} \nelse { \nif ( superType instanceof CaptureType ) { \nif ( superType . equals ( subType ) ) return true ; \nfor ( Type lowerBound : ( ( CaptureType ) superType ) . getLowerBounds ( ) ) { \nif ( isSuperType ( lowerBound , subType ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nelse { \nif ( superType instanceof GenericArrayType ) { \nreturn isArraySupertype ( superType , subType ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented: \" + superType . getClass ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"4022": "public class GenericTypeReflector { \nprivate static Type [ ] getExactDirectSuperTypes ( Type type ) { \nif ( type instanceof ParameterizedType || type instanceof Class ) { \nClass < ? > clazz ; \nif ( type instanceof ParameterizedType ) { \nclazz = ( Class < ? > ) ( ( ParameterizedType ) type ) . getRawType ( ) ; \n} \nelse { \nclazz = ( Class < ? > ) type ; \nif ( clazz . isArray ( ) ) return getArrayExactDirectSuperTypes ( clazz ) ; \n} \nType [ ] superInterfaces = clazz . getGenericInterfaces ( ) ; \nType superClass = clazz . getGenericSuperclass ( ) ; \nif ( superClass == null && superInterfaces . length == 0 && clazz . isInterface ( ) ) { \nreturn new Type [ ] { \nObject . class } \n; \n} \nType [ ] result ; \nint resultIndex ; \nif ( superClass == null ) { \nresult = new Type [ superInterfaces . length ] ; \nresultIndex = 0 ; \n} \nelse { \nresult = new Type [ superInterfaces . length + 1 ] ; \nresultIndex = 1 ; \nresult [ 0 ] = mapTypeParameters ( superClass , type ) ; \n} \nfor ( Type superInterface : superInterfaces ) { \nresult [ resultIndex ++ ] = mapTypeParameters ( superInterface , type ) ; \n} \nreturn result ; \n} \nelse { \nif ( type instanceof TypeVariable ) { \nTypeVariable < ? > tv = ( TypeVariable < ? > ) type ; \nreturn tv . getBounds ( ) ; \n} \nelse { \nif ( type instanceof WildcardType ) { \nreturn ( ( WildcardType ) type ) . getUpperBounds ( ) ; \n} \nelse { \nif ( type instanceof CaptureType ) { \nreturn ( ( CaptureType ) type ) . getUpperBounds ( ) ; \n} \nelse { \nif ( type instanceof GenericArrayType ) { \nreturn getArrayExactDirectSuperTypes ( type ) ; \n} \nelse { \nif ( type == null ) { \nthrow new NullPointerException ( ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented type: \" + type ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"4026": "public class ClassPopulator { \nprivate Boolean getIndexInstruction ( Class < P > clazz ) { \nIndex ind = clazz . getAnnotation ( Index . class ) ; \nUnindex unind = clazz . getAnnotation ( Unindex . class ) ; \nif ( ind != null && unind != null ) throw new IllegalStateException ( \"You cannot have @Index and @Unindex on the same class: \" + clazz ) ; \nif ( ind != null ) return true ; \nelse { \nif ( unind != null ) return false ; \nelse return null ; \n} \n} \n} \n"}
{"4046": "public class KeyMetadata { \nprivate void findKeyFields ( Class < ? > inspect , CreateContext ctx , Path path ) { \nif ( inspect == Object . class ) return ; \nfindKeyFields ( inspect . getSuperclass ( ) , ctx , path ) ; \nfor ( Field field : inspect . getDeclaredFields ( ) ) { \nif ( field . getAnnotation ( Id . class ) != null ) { \nif ( this . idMeta != null ) throw new IllegalStateException ( \"Multiple @Id fields in the class hierarchy of \" + clazz . getName ( ) ) ; \nif ( ( field . getType ( ) != Long . class ) && ( field . getType ( ) != long . class ) && ( field . getType ( ) != String . class ) ) throw new IllegalStateException ( \"@Id field '\" + field . getName ( ) + \"' in \" + inspect . getName ( ) + \" must be of type Long, long, or String\" ) ; \nProperty prop = new FieldProperty ( ctx . getFactory ( ) , clazz , field ) ; \nTranslator < Object , Object > translator = ctx . getTranslator ( new TypeKey < > ( prop ) , ctx , path . extend ( prop . getName ( ) ) ) ; \nthis . idMeta = new PropertyPopulator < > ( prop , translator ) ; \n} \nelse { \nif ( field . getAnnotation ( Parent . class ) != null ) { \nif ( this . parentMeta != null ) throw new IllegalStateException ( \"Multiple @Parent fields in the class hierarchy of \" + clazz . getName ( ) ) ; \nif ( ! isAllowedParentFieldType ( field . getType ( ) ) ) throw new IllegalStateException ( \"@Parent fields must be Ref<?>, Key<?>, or datastore Key. Illegal parent: \" + field ) ; \nProperty prop = new FieldProperty ( ctx . getFactory ( ) , clazz , field ) ; \nTranslator < Object , Object > translator = ctx . getTranslator ( new TypeKey < > ( prop ) , ctx , path . extend ( prop . getName ( ) ) ) ; \nthis . parentMeta = new PropertyPopulator < > ( prop , translator ) ; \n} \n} \n} \n} \n} \n"}
{"4060": "public class Keys { \npublic com . google . cloud . datastore . Key createRawAny ( final com . google . cloud . datastore . Key parent , final String kind , final Object id ) { \nif ( id instanceof String ) return createRaw ( parent , kind , ( String ) id ) ; \nelse { \nif ( id instanceof Long ) return createRaw ( parent , kind , ( Long ) id ) ; \nelse throw new IllegalArgumentException ( \"id '\" + id + \"' must be String or Long\" ) ; \n} \n} \n} \n"}
{"4083": "public class FutureHelper { \npublic static void unwrapAndThrow ( Throwable ex ) { \nif ( ex instanceof RuntimeException ) throw ( RuntimeException ) ex ; \nelse { \nif ( ex instanceof Error ) throw ( Error ) ex ; \nelse { \nif ( ex instanceof ExecutionException ) unwrapAndThrow ( ex . getCause ( ) ) ; \nelse throw new UndeclaredThrowableException ( ex ) ; \n} \n} \n} \n} \n"}
{"4100": "public class OpenRtbUtils { \npublic static Iterable < Imp > impsWith ( BidRequest request , Predicate < Imp > impFilter ) { \ncheckNotNull ( impFilter ) ; \nList < Imp > imps = request . getImpList ( ) ; \nif ( imps . isEmpty ( ) || impFilter == IMP_ALL ) { \nreturn imps ; \n} \nelse { \nif ( impFilter == IMP_NONE ) { \nreturn ImmutableList . of ( ) ; \n} \n} \nboolean included = impFilter . test ( imps . get ( 0 ) ) ; \nint size = imps . size ( ) , i ; \nfor ( i = 1 ; \ni < size ; \n++ i ) { \nif ( impFilter . test ( imps . get ( i ) ) != included ) { \nbreak ; \n} \n} \nif ( i == size ) { \nreturn included ? imps : ImmutableList . < Imp > of ( ) ; \n} \nint headingSize = i ; \nreturn new FluentIterable < Imp > ( ) { \n@ Override public Iterator < Imp > iterator ( ) { \nIterator < Imp > unfiltered = imps . iterator ( ) ; \nreturn new AbstractIterator < Imp > ( ) { \nprivate int heading = 0 ; \n@ Override protected Imp computeNext ( ) { \nwhile ( unfiltered . hasNext ( ) ) { \nImp imp = unfiltered . next ( ) ; \nif ( ( heading ++ < headingSize ) ? included : impFilter . test ( imp ) ) { \nreturn imp ; \n} \n} \nreturn endOfData ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"4101": "public class AbstractOpenRtbJsonReader { \nprotected final < EB extends ExtendableBuilder < ? , EB > > void readExtensions ( EB msg , JsonParser par ) throws IOException { \n@ SuppressWarnings ( \"unchecked\" ) Set < OpenRtbJsonExtReader < EB > > extReaders = factory . getReaders ( ( Class < EB > ) msg . getClass ( ) ) ; \nif ( extReaders . isEmpty ( ) ) { \npar . skipChildren ( ) ; \nreturn ; \n} \nstartObject ( par ) ; \nJsonToken tokLast = par . getCurrentToken ( ) ; \nJsonLocation locLast = par . getCurrentLocation ( ) ; \nwhile ( true ) { \nboolean extRead = false ; \nfor ( OpenRtbJsonExtReader < EB > extReader : extReaders ) { \nif ( extReader . filter ( par ) ) { \nextReader . read ( msg , par ) ; \nJsonToken tokNew = par . getCurrentToken ( ) ; \nJsonLocation locNew = par . getCurrentLocation ( ) ; \nboolean advanced = tokNew != tokLast || ! locNew . equals ( locLast ) ; \nextRead |= advanced ; \nif ( ! endObject ( par ) ) { \nreturn ; \n} \nelse { \nif ( advanced && par . getCurrentToken ( ) != JsonToken . FIELD_NAME ) { \ntokLast = par . nextToken ( ) ; \nlocLast = par . getCurrentLocation ( ) ; \n} \nelse { \ntokLast = tokNew ; \nlocLast = locNew ; \n} \n} \n} \n} \nif ( ! endObject ( par ) ) { \nreturn ; \n} \nif ( ! extRead ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Extension field not consumed by any reader, skipping: {} @{}:{}\" , par . getCurrentName ( ) , locLast . getLineNr ( ) , locLast . getCharOffset ( ) ) ; \n} \npar . nextToken ( ) ; \npar . skipChildren ( ) ; \ntokLast = par . nextToken ( ) ; \nlocLast = par . getCurrentLocation ( ) ; \n} \n} \n} \n} \n"}
{"4147": "public class BasicURLNormalizer { \nprivate String processQueryElements ( String urlToFilter ) { \ntry { \nURL url = new URL ( urlToFilter ) ; \nString query = url . getQuery ( ) ; \nString path = url . getPath ( ) ; \nif ( path . contains ( \";\" ) ) { \nString [ ] pathElements = path . split ( \"/\" ) ; \nString last = pathElements [ pathElements . length - 1 ] ; \nint semicolon = last . indexOf ( \";\" ) ; \nif ( semicolon != - 1 ) { \npathElements [ pathElements . length - 1 ] = last . substring ( 0 , semicolon ) ; \nString params = last . substring ( semicolon + 1 ) . replaceAll ( \";\" , \"&\" ) ; \nif ( query == null ) { \nquery = params ; \n} \nelse { \nquery += \"&\" + params ; \n} \nStringBuilder newPath = new StringBuilder ( ) ; \nfor ( String p : pathElements ) { \nif ( StringUtils . isNotBlank ( p ) ) { \nnewPath . append ( \"/\" ) . append ( p ) ; \n} \n} \npath = newPath . toString ( ) ; \n} \n} \nif ( StringUtils . isEmpty ( query ) ) { \nreturn urlToFilter ; \n} \nList < NameValuePair > pairs = URLEncodedUtils . parse ( query , StandardCharsets . UTF_8 ) ; \nIterator < NameValuePair > pairsIterator = pairs . iterator ( ) ; \nwhile ( pairsIterator . hasNext ( ) ) { \nNameValuePair param = pairsIterator . next ( ) ; \nif ( queryElementsToRemove . contains ( param . getName ( ) ) ) { \npairsIterator . remove ( ) ; \n} \nelse { \nif ( removeHashes && param . getValue ( ) != null ) { \nMatcher m = thirtytwobithash . matcher ( param . getValue ( ) ) ; \nif ( m . matches ( ) ) { \npairsIterator . remove ( ) ; \n} \n} \n} \n} \nStringBuilder newFile = new StringBuilder ( ) ; \nif ( StringUtils . isNotBlank ( path ) ) { \nnewFile . append ( path ) ; \n} \nif ( ! pairs . isEmpty ( ) ) { \nCollections . sort ( pairs , comp ) ; \nString newQueryString = URLEncodedUtils . format ( pairs , StandardCharsets . UTF_8 ) ; \nnewFile . append ( '?' ) . append ( newQueryString ) ; \n} \nif ( url . getRef ( ) != null ) { \nnewFile . append ( '#' ) . append ( url . getRef ( ) ) ; \n} \nreturn new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , newFile . toString ( ) ) . toString ( ) ; \n} \ncatch ( MalformedURLException e ) { \nLOG . warn ( \"Invalid urlToFilter {}. {}\" , urlToFilter , e ) ; \nreturn null ; \n} \n} \n} \n"}
{"4153": "public class DOMBuilder { \nprotected void append ( Node newNode ) throws org . xml . sax . SAXException { \nNode currentNode = m_currentNode ; \nif ( null != currentNode ) { \ncurrentNode . appendChild ( newNode ) ; \n} \nelse { \nif ( null != m_docFrag ) { \nm_docFrag . appendChild ( newNode ) ; \n} \nelse { \nboolean ok = true ; \nshort type = newNode . getNodeType ( ) ; \nif ( type == Node . TEXT_NODE ) { \nString data = newNode . getNodeValue ( ) ; \nif ( ( null != data ) && ( data . trim ( ) . length ( ) > 0 ) ) { \nthrow new org . xml . sax . SAXException ( \"Warning: can't output text before document element!  Ignoring...\" ) ; \n} \nok = false ; \n} \nelse { \nif ( type == Node . ELEMENT_NODE ) { \nif ( m_doc . getDocumentElement ( ) != null ) { \nthrow new org . xml . sax . SAXException ( \"Can't have more than one root on a DOM!\" ) ; \n} \n} \n} \nif ( ok ) { \nm_doc . appendChild ( newNode ) ; \n} \n} \n} \n} \n} \n"}
{"4157": "public class DOMBuilder { \npublic void cdata ( char ch [ ] , int start , int length ) { \nif ( isOutsideDocElem ( ) && XMLCharacterRecognizer . isWhiteSpace ( ch , start , length ) ) { \nreturn ; \n} \nString s = new String ( ch , start , length ) ; \nNode n = m_currentNode . getLastChild ( ) ; \nif ( n instanceof CDATASection ) { \n( ( CDATASection ) n ) . appendData ( s ) ; \n} \nelse { \nif ( n instanceof Comment ) { \n( ( Comment ) n ) . appendData ( s ) ; \n} \n} \n} \n} \n"}
{"4171": "public class WheelView { \nprivate void update ( float deltaTime ) { \nfloat vel = mAngularVelocity ; \nfloat velSqr = vel * vel ; \nif ( vel > 0f ) { \nmAngularVelocity -= velSqr * VELOCITY_FRICTION_COEFFICIENT + CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity < 0f ) mAngularVelocity = 0f ; \n} \nelse { \nif ( vel < 0f ) { \nmAngularVelocity -= velSqr * - VELOCITY_FRICTION_COEFFICIENT - CONSTANT_FRICTION_COEFFICIENT ; \nif ( mAngularVelocity > 0f ) mAngularVelocity = 0f ; \n} \n} \nif ( mAngularVelocity != 0f ) { \naddAngle ( mAngularVelocity * deltaTime ) ; \n} \nelse { \nmRequiresUpdate = false ; \n} \n} \n} \n"}
{"4208": "public class FeatureDatasetFactoryManager { \nstatic public FeatureDataset open ( FeatureType wantFeatureType , String location , ucar . nc2 . util . CancelTask task , Formatter errlog ) throws IOException { \nif ( location . startsWith ( DataFactory . SCHEME ) ) { \nDataFactory . Result result = new DataFactory ( ) . openFeatureDataset ( wantFeatureType , location , task ) ; \nerrlog . format ( \"%s\" , result . errLog ) ; \nif ( ! featureTypeOk ( wantFeatureType , result . featureType ) ) { \nerrlog . format ( \"wanted %s but dataset is of type %s%n\" , wantFeatureType , result . featureType ) ; \nresult . close ( ) ; \nreturn null ; \n} \nreturn result . featureDataset ; \n} \nelse { \nif ( location . startsWith ( CdmrFeatureDataset . SCHEME ) ) { \nOptional < FeatureDataset > opt = CdmrFeatureDataset . factory ( wantFeatureType , location ) ; \nif ( opt . isPresent ( ) ) return opt . get ( ) ; \nerrlog . format ( \"%s\" , opt . getErrorMessage ( ) ) ; \nreturn null ; \n} \nelse { \nif ( location . startsWith ( ucar . nc2 . ft . point . collection . CompositeDatasetFactory . SCHEME ) ) { \nString spec = location . substring ( CompositeDatasetFactory . SCHEME . length ( ) ) ; \nMFileCollectionManager dcm = MFileCollectionManager . open ( spec , spec , null , errlog ) ; \nreturn CompositeDatasetFactory . factory ( location , wantFeatureType , dcm , errlog ) ; \n} \n} \n} \nDatasetUrl durl = DatasetUrl . findDatasetUrl ( location ) ; \nif ( durl . serviceType == null ) { \nOptional < FeatureDatasetCoverage > opt = CoverageDatasetFactory . openGrib ( location ) ; \nif ( opt . isPresent ( ) ) { \nreturn opt . get ( ) ; \n} \nelse { \nif ( ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NOT_GRIB_FILE ) && ! opt . getErrorMessage ( ) . startsWith ( CoverageDatasetFactory . NO_GRIB_CLASS ) ) { \nerrlog . format ( \"%s%n\" , opt . getErrorMessage ( ) ) ; \nreturn null ; \n} \n} \n} \nNetcdfDataset ncd = NetcdfDataset . acquireDataset ( durl , true , task ) ; \nFeatureDataset fd = wrap ( wantFeatureType , ncd , task , errlog ) ; \nif ( fd == null ) ncd . close ( ) ; \nreturn fd ; \n} \n} \n"}
{"4245": "public class McIDASLookup { \npublic final String getLevelName ( GridRecord gr ) { \nif ( cust != null ) { \nString result = cust . getLevelNameShort ( gr . getLevelType1 ( ) ) ; \nif ( result != null ) return result ; \n} \nString levelUnit = getLevelUnit ( gr ) ; \nif ( levelUnit != null ) { \nint level1 = ( int ) gr . getLevel1 ( ) ; \nint level2 = ( int ) gr . getLevel2 ( ) ; \nif ( levelUnit . equalsIgnoreCase ( \"hPa\" ) ) { \nreturn \"pressure\" ; \n} \nelse { \nif ( level1 == 1013 ) { \nreturn \"mean sea level\" ; \n} \nelse { \nif ( level1 == 0 ) { \nreturn \"tropopause\" ; \n} \nelse { \nif ( level1 == 1001 ) { \nreturn \"surface\" ; \n} \nelse { \nif ( level2 != 0 ) { \nreturn \"layer\" ; \n} \n} \n} \n} \n} \n} \nreturn \"\" ; \n} \n} \n"}
{"4249": "public class McIDASLookup { \npublic final boolean isVerticalCoordinate ( GridRecord gr ) { \nif ( cust != null ) { \nreturn cust . isVerticalCoordinate ( gr . getLevelType1 ( ) ) ; \n} \nint type = gr . getLevelType1 ( ) ; \nif ( ( ( McIDASGridRecord ) gr ) . hasGribInfo ( ) ) { \nif ( type == 20 ) { \nreturn true ; \n} \nif ( type == 100 ) { \nreturn true ; \n} \nif ( type == 101 ) { \nreturn true ; \n} \nif ( ( type >= 103 ) && ( type <= 128 ) ) { \nreturn true ; \n} \nif ( type == 141 ) { \nreturn true ; \n} \nif ( type == 160 ) { \nreturn true ; \n} \n} \nelse { \nif ( getLevelUnit ( gr ) . equals ( \"hPa\" ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4251": "public class CoordTransBuilder { \nstatic public CoordinateTransform makeCoordinateTransform ( NetcdfDataset ds , AttributeContainer ctv , Formatter parseInfo , Formatter errInfo ) { \nString transform_name = ctv . findAttValueIgnoreCase ( \"transform_name\" , null ) ; \nif ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( \"Projection_Name\" , null ) ; \nif ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( CF . GRID_MAPPING_NAME , null ) ; \nif ( null == transform_name ) transform_name = ctv . findAttValueIgnoreCase ( CF . STANDARD_NAME , null ) ; \nif ( null == transform_name ) { \nparseInfo . format ( \"**Failed to find Coordinate Transform name from Variable= %s%n\" , ctv ) ; \nreturn null ; \n} \ntransform_name = transform_name . trim ( ) ; \nClass builderClass = null ; \nfor ( Transform transform : transformList ) { \nif ( transform . transName . equals ( transform_name ) ) { \nbuilderClass = transform . transClass ; \nbreak ; \n} \n} \nif ( null == builderClass ) { \nparseInfo . format ( \"**Failed to find CoordTransBuilder name= %s from Variable= %s%n\" , transform_name , ctv ) ; \nreturn null ; \n} \nObject builderObject ; \ntry { \nbuilderObject = builderClass . newInstance ( ) ; \n} \ncatch ( InstantiationException | IllegalAccessException e ) { \nlog . error ( \"Cant create new instance \" + builderClass . getName ( ) , e ) ; \nreturn null ; \n} \nif ( null == builderObject ) { \nparseInfo . format ( \"**Failed to build CoordTransBuilder object from class= %s for Variable= %s%n\" , builderClass . getName ( ) , ctv ) ; \nreturn null ; \n} \nCoordinateTransform ct ; \nif ( builderObject instanceof VertTransformBuilderIF ) { \nVertTransformBuilderIF vertBuilder = ( VertTransformBuilderIF ) builderObject ; \nvertBuilder . setErrorBuffer ( errInfo ) ; \nct = vertBuilder . makeCoordinateTransform ( ds , ctv ) ; \n} \nelse { \nif ( builderObject instanceof HorizTransformBuilderIF ) { \nHorizTransformBuilderIF horizBuilder = ( HorizTransformBuilderIF ) builderObject ; \nhorizBuilder . setErrorBuffer ( errInfo ) ; \nString units = AbstractTransformBuilder . getGeoCoordinateUnits ( ds , ctv ) ; \nct = horizBuilder . makeCoordinateTransform ( ctv , units ) ; \n} \nelse { \nlog . error ( \"Illegals class \" + builderClass . getName ( ) ) ; \nreturn null ; \n} \n} \nif ( ct != null ) { \nparseInfo . format ( \" Made Coordinate transform %s from variable %s: %s%n\" , transform_name , ctv . getName ( ) , builderObject . getClass ( ) . getName ( ) ) ; \n} \nreturn ct ; \n} \n} \n"}
{"4274": "public class GempakGridReader { \npublic int getGridPackingType ( int gridNumber ) throws IOException { \nint irow = 1 ; \nif ( ( gridNumber < 1 ) || ( gridNumber > dmLabel . kcol ) ) { \nlogWarning ( \"bad grid number \" + gridNumber ) ; \nreturn - 9 ; \n} \nint iprt = getPartNumber ( \"GRID\" ) ; \nif ( iprt == 0 ) { \nlogWarning ( \"couldn't find part: GRID\" ) ; \nreturn - 10 ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( part . ktyprt != MDGRID ) { \nlogWarning ( \"Not a valid type: \" + GempakUtil . getDataType ( part . ktyprt ) ) ; \nreturn - 21 ; \n} \nint ilenhd = part . klnhdr ; \nint ipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( gridNumber - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nint istart = DM_RINT ( ipoint ) ; \nif ( istart == 0 ) { \nreturn - 15 ; \n} \nint length = DM_RINT ( istart ) ; \nint isword = istart + 1 ; \nif ( length <= ilenhd ) { \nlogWarning ( \"length (\" + length + \") is less than header length (\" + ilenhd + \")\" ) ; \nreturn - 15 ; \n} \nelse { \nif ( Math . abs ( length ) > 10000000 ) { \nlogWarning ( \"length is huge: \" + length ) ; \nreturn - 34 ; \n} \n} \nint [ ] header = new int [ ilenhd ] ; \nDM_RINT ( isword , header ) ; \nisword += ilenhd ; \nreturn DM_RINT ( isword ) ; \n} \n} \n"}
{"4276": "public class GempakGridReader { \npublic float [ ] DM_RPKG ( int isword , int nword , int decimalScale ) throws IOException { \nfloat [ ] data ; \nint ipktyp = DM_RINT ( isword ) ; \nint iiword = isword + 1 ; \nint lendat = nword - 1 ; \nif ( ipktyp == MDGNON ) { \ndata = new float [ lendat ] ; \nDM_RFLT ( iiword , data ) ; \nreturn data ; \n} \nint iiw ; \nint irw ; \nif ( ipktyp == MDGDIF ) { \niiw = 4 ; \nirw = 3 ; \n} \nelse { \nif ( ipktyp == MDGRB2 ) { \niiw = 4 ; \nirw = 1 ; \n} \nelse { \niiw = 3 ; \nirw = 2 ; \n} \n} \nint [ ] iarray = new int [ iiw ] ; \nfloat [ ] rarray = new float [ irw ] ; \nDM_RINT ( iiword , iarray ) ; \niiword = iiword + iiw ; \nlendat = lendat - iiw ; \nDM_RFLT ( iiword , rarray ) ; \niiword = iiword + irw ; \nlendat = lendat - irw ; \nif ( ipktyp == MDGRB2 ) { \ndata = unpackGrib2Data ( iiword , lendat , iarray , rarray ) ; \nreturn data ; \n} \nint nbits = iarray [ 0 ] ; \nint misflg = iarray [ 1 ] ; \nboolean miss = misflg != 0 ; \nint kxky = iarray [ 2 ] ; \nint kx = 0 ; \nif ( iiw == 4 ) { \nkx = iarray [ 3 ] ; \n} \nfloat ref = rarray [ 0 ] ; \nfloat scale = rarray [ 1 ] ; \nfloat difmin = 0 ; \nif ( irw == 3 ) { \ndifmin = rarray [ 2 ] ; \n} \ndata = unpackData ( iiword , lendat , ipktyp , kxky , nbits , ref , scale , miss , difmin , kx , decimalScale ) ; \nreturn data ; \n} \n} \n"}
{"4277": "public class GempakGridReader { \nprivate synchronized float [ ] unpackData ( int iiword , int nword , int ipktyp , int kxky , int nbits , float ref , float scale , boolean miss , float difmin , int kx , int decimalScale ) throws IOException { \nif ( ipktyp == MDGGRB ) { \nif ( ! useDP ) { \nreturn unpackGrib1Data ( iiword , nword , kxky , nbits , ref , scale , miss , decimalScale ) ; \n} \nelse { \nif ( nword * 32 < kxky * nbits ) { \nnword ++ ; \n} \nint [ ] ksgrid = new int [ nword ] ; \nDM_RINT ( iiword , ksgrid ) ; \nreturn DP_UGRB ( ksgrid , kxky , nbits , ref , scale , miss , decimalScale ) ; \n} \n} \nelse { \nif ( ipktyp == MDGNMC ) { \nreturn null ; \n} \nelse { \nif ( ipktyp == MDGDIF ) { \nreturn null ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4282": "public class GempakGridReader { \nprivate void getNextByte ( ) throws IOException { \nif ( ! needToSwap ) { \nbitBuf = rf . read ( ) ; \n} \nelse { \nif ( next == 3 ) { \nbitBuf = ch3 ; \n} \nelse { \nif ( next == 2 ) { \nbitBuf = ch2 ; \n} \nelse { \nif ( next == 1 ) { \nbitBuf = ch1 ; \n} \nelse { \nch1 = rf . read ( ) ; \nch2 = rf . read ( ) ; \nch3 = rf . read ( ) ; \nch4 = rf . read ( ) ; \nbitBuf = ch4 ; \nnext = 4 ; \n} \n} \n} \nnext -- ; \n} \n} \n} \n"}
{"4339": "public class Format { \npublic static void tab ( StringBuffer sbuff , int tabStop , boolean alwaysOne ) { \nint len = sbuff . length ( ) ; \nif ( tabStop > len ) { \nsbuff . setLength ( tabStop ) ; \nfor ( int i = len ; \ni < tabStop ; \ni ++ ) { \nsbuff . setCharAt ( i , ' ' ) ; \n} \n} \nelse { \nif ( alwaysOne ) { \nsbuff . setLength ( len + 1 ) ; \nsbuff . setCharAt ( len , ' ' ) ; \n} \n} \n} \n} \n"}
{"4343": "public class Format { \npublic static String formatByteSize ( double size ) { \nString unit = null ; \nif ( size > 1.0e15 ) { \nunit = \"Pbytes\" ; \nsize *= 1.0e-15 ; \n} \nelse { \nif ( size > 1.0e12 ) { \nunit = \"Tbytes\" ; \nsize *= 1.0e-12 ; \n} \nelse { \nif ( size > 1.0e9 ) { \nunit = \"Gbytes\" ; \nsize *= 1.0e-9 ; \n} \nelse { \nif ( size > 1.0e6 ) { \nunit = \"Mbytes\" ; \nsize *= 1.0e-6 ; \n} \nelse { \nif ( size > 1.0e3 ) { \nunit = \"Kbytes\" ; \nsize *= 1.0e-3 ; \n} \nelse { \nunit = \"bytes\" ; \n} \n} \n} \n} \n} \nreturn Format . d ( size , 4 ) + \" \" + unit ; \n} \n} \n"}
{"4348": "public class Slice { \npublic String toConstraintString ( ) throws DapException { \nassert this . first != UNDEFINED && this . stride != UNDEFINED && this . stop != UNDEFINED ; \nif ( ( this . stop - this . first ) == 0 ) { \nreturn String . format ( \"[0]\" ) ; \n} \nelse { \nif ( this . stride == 1 ) { \nif ( ( this . stop - this . first ) == 1 ) return String . format ( \"[%d]\" , this . first ) ; \nelse return String . format ( \"[%d:%d]\" , this . first , this . stop - 1 ) ; \n} \nelse return String . format ( \"[%d:%d:%d]\" , this . first , this . stride , this . stop - 1 ) ; \n} \n} \n} \n"}
{"4352": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 ) { \nint stop = buf0 . limit ( ) ; \nint size = stop + 8 ; \nint savepos = buf0 . position ( ) ; \nassert savepos == 0 ; \nbyte [ ] bytes = new byte [ size ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . get ( bytes , 0 , stop ) ; \nbuf0 . position ( savepos ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \nbuf . position ( 0 ) ; \nbuf . limit ( size ) ; \nint i = 0 ; \ntry { \nfor ( i = 0 ; \nbuf . position ( ) < stop ; \ni ++ ) { \nsavepos = buf . position ( ) ; \nint iv = buf . getInt ( ) ; \nbuf . position ( savepos ) ; \nlong lv = buf . getLong ( ) ; \nbuf . position ( savepos ) ; \nshort sv = buf . getShort ( ) ; \nbuf . position ( savepos ) ; \nbyte b = buf . get ( ) ; \nint ub = ( ( int ) b ) & 0x000000FF ; \nlong uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; \nint usv = ( ( int ) sv ) & 0xFFFF ; \nint ib = ( int ) b ; \nchar c = ( char ) ub ; \nString s = Character . toString ( c ) ; \nif ( c == '\\r' ) s = \"\\\\r\" ; \nelse { \nif ( c == '\\n' ) s = \"\\\\n\" ; \nelse { \nif ( c < ' ' || c >= 0x7f ) s = \"?\" ; \n} \n} \nSystem . err . printf ( \"[%03d] %02x %03d %4d '%s'\" , i , ub , ub , ib , s ) ; \nSystem . err . printf ( \"\\t%12d 0x%08x\" , iv , uiv ) ; \nSystem . err . printf ( \"\\t%5d\\t0x%04x\" , sv , usv ) ; \nSystem . err . println ( ) ; \nSystem . err . flush ( ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"failure:\" + e ) ; \n} \nfinally { \nSystem . err . flush ( ) ; \nSystem . err . flush ( ) ; \n} \n} \n} \n"}
{"4422": "public class CoordSysBuilder { \nstatic public List < String > breakupConventionNames ( String convAttValue ) { \nList < String > names = new ArrayList < > ( ) ; \nif ( ( convAttValue . indexOf ( ',' ) > 0 ) || ( convAttValue . indexOf ( ';' ) > 0 ) ) { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \",;\" ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \nelse { \nif ( ( convAttValue . indexOf ( '/' ) > 0 ) ) { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \"/\" ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \nelse { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \" \" ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \n} \nreturn names ; \n} \n} \n"}
{"4449": "public class Grib2Tables { \npublic double getForecastTimeIntervalSizeInHours ( Grib2Pds pds ) { \nGrib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; \nint timeUnitOrg = pds . getTimeUnit ( ) ; \nint range = 0 ; \nfor ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { \nif ( ti . timeRangeUnit == 255 ) continue ; \nif ( ( ti . timeRangeUnit != timeUnitOrg ) || ( ti . timeIncrementUnit != timeUnitOrg && ti . timeIncrementUnit != 255 && ti . timeIncrement != 0 ) ) { \nlogger . warn ( \"TimeInterval(2) has different units timeUnit org=\" + timeUnitOrg + \" TimeInterval=\" + ti . timeIncrementUnit ) ; \nthrow new RuntimeException ( \"TimeInterval(2) has different units\" ) ; \n} \nrange += ti . timeRangeLength ; \nif ( ti . timeIncrementUnit != 255 ) range += ti . timeIncrement ; \n} \nCalendarPeriod timeUnitPeriod = Grib2Utils . getCalendarPeriod ( convertTimeUnit ( timeUnitOrg ) ) ; \nif ( timeUnitPeriod == null ) return GribNumbers . UNDEFINEDD ; \nif ( timeUnitPeriod . equals ( CalendarPeriod . Hour ) ) return range ; \ndouble fac ; \nif ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Month ) { \nfac = 30.0 * 24.0 ; \n} \nelse { \nif ( timeUnitPeriod . getField ( ) == CalendarPeriod . Field . Year ) { \nfac = 365.0 * 24.0 ; \n} \nelse { \nfac = CalendarPeriod . Hour . getConvertFactor ( timeUnitPeriod ) ; \n} \n} \nreturn fac * range ; \n} \n} \n"}
{"4510": "public class Debug { \nstatic public boolean isSet ( String flagName ) { \nif ( store == null ) return false ; \nNamePart np = partit ( flagName ) ; \nif ( debug ) { \ntry { \nif ( ( np . storeName . length ( ) > 0 ) && ! store . nodeExists ( np . storeName ) ) System . out . println ( \"Debug.isSet create node = \" + flagName + \" \" + np ) ; \nelse { \nif ( null == store . node ( np . storeName ) . get ( np . keyName , null ) ) System . out . println ( \"Debug.isSet create flag = \" + flagName + \" \" + np ) ; \n} \n} \ncatch ( BackingStoreException e ) { \n} \n} \nboolean value = store . node ( np . storeName ) . getBoolean ( np . keyName , false ) ; \nstore . node ( np . storeName ) . putBoolean ( np . keyName , value ) ; \nreturn value ; \n} \n} \n"}
{"4525": "public class DODSNetcdfFile { \nNamePieces parseName ( String name ) { \nNamePieces pieces = new NamePieces ( ) ; \nint dotpos = name . lastIndexOf ( '.' ) ; \nint slashpos = name . lastIndexOf ( '/' ) ; \nif ( slashpos < 0 && dotpos < 0 ) { \npieces . name = name ; \n} \nelse { \nif ( slashpos >= 0 && dotpos < 0 ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse { \nif ( slashpos < 0 && dotpos >= 0 ) { \npieces . var = name . substring ( 0 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \nelse { \nif ( slashpos > dotpos ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . var = name . substring ( slashpos + 1 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \n} \n} \n} \nif ( pieces . prefix != null && pieces . prefix . length ( ) == 0 ) pieces . prefix = null ; \nif ( pieces . var != null && pieces . var . length ( ) == 0 ) pieces . var = null ; \nif ( pieces . name . length ( ) == 0 ) pieces . name = null ; \nreturn pieces ; \n} \n} \n"}
{"4529": "public class DODSNetcdfFile { \nList < Dimension > constructDimensions ( Group group , opendap . dap . DArray dodsArray ) { \nif ( group == null ) group = rootGroup ; \nList < Dimension > dims = new ArrayList < Dimension > ( ) ; \nEnumeration enumerate = dodsArray . getDimensions ( ) ; \nwhile ( enumerate . hasMoreElements ( ) ) { \nopendap . dap . DArrayDimension dad = ( opendap . dap . DArrayDimension ) enumerate . nextElement ( ) ; \nString name = dad . getEncodedName ( ) ; \nif ( name != null ) name = StringUtil2 . unescape ( name ) ; \nDimension myd ; \nif ( name == null ) { \nmyd = new Dimension ( null , dad . getSize ( ) , false ) ; \n} \nelse { \nif ( RC . getUseGroups ( ) ) { \nif ( name . indexOf ( '/' ) >= 0 ) { \ngroup = group . makeRelativeGroup ( this , name , true ) ; \nname = name . substring ( name . lastIndexOf ( '/' ) + 1 ) ; \n} \n} \nmyd = group . findDimension ( name ) ; \nif ( myd == null ) { \nmyd = new Dimension ( name , dad . getSize ( ) ) ; \ngroup . addDimension ( myd ) ; \n} \nelse { \nif ( myd . getLength ( ) != dad . getSize ( ) ) { \nmyd = new Dimension ( name , dad . getSize ( ) , false ) ; \n} \n} \n} \ndims . add ( myd ) ; \n} \nreturn dims ; \n} \n} \n"}
{"4532": "public class Resource { \npublic static ImageIcon getIcon ( String fullIconName , boolean errMsg ) { \nImageIcon icon = null ; \njava . net . URL iconR = cl . getResource ( fullIconName ) ; \nif ( debugIcon ) { \nSystem . out . println ( \"classLoader \" + cl . getClassLoader ( ) ) ; \nSystem . out . println ( \"  Resource.getIcon on \" + fullIconName + \" = \" + iconR ) ; \n} \nif ( iconR != null ) icon = new ImageIcon ( iconR ) ; \nif ( ( icon == null ) && errMsg ) System . out . println ( \"  ERROR: Resource.getIcon failed on \" + fullIconName ) ; \nelse { \nif ( debugIcon ) System . out . println ( \"  Resource.getIcon ok on \" + fullIconName ) ; \n} \nreturn icon ; \n} \n} \n"}
{"4538": "public class IospHelper { \nstatic public Object makePrimitiveArray ( int size , DataType dataType ) { \nObject arr = null ; \nif ( ( dataType . getPrimitiveClassType ( ) == byte . class ) || ( dataType == DataType . CHAR ) || ( dataType == DataType . OPAQUE ) || ( dataType == DataType . STRUCTURE ) ) { \narr = new byte [ size ] ; \n} \nelse { \nif ( dataType . getPrimitiveClassType ( ) == short . class ) { \narr = new short [ size ] ; \n} \nelse { \nif ( dataType . getPrimitiveClassType ( ) == int . class ) { \narr = new int [ size ] ; \n} \nelse { \nif ( dataType . getPrimitiveClassType ( ) == long . class ) { \narr = new long [ size ] ; \n} \nelse { \nif ( dataType == DataType . FLOAT ) { \narr = new float [ size ] ; \n} \nelse { \nif ( dataType == DataType . DOUBLE ) { \narr = new double [ size ] ; \n} \nelse { \nif ( dataType == DataType . STRING ) { \narr = new String [ size ] ; \n} \n} \n} \n} \n} \n} \n} \nreturn arr ; \n} \n} \n"}
{"4554": "public class Aggregation { \nprotected void makeDatasets ( CancelTask cancelTask ) throws IOException { \ndatasets = new ArrayList < > ( ) ; \nfor ( MFile cd : datasetManager . getFilesSorted ( ) ) { \ndatasets . add ( makeDataset ( cd ) ) ; \n} \nCollections . sort ( datasets ) ; \nfor ( Aggregation . Dataset dataset : explicitDatasets ) { \ndatasets . add ( dataset ) ; \n} \nfor ( Iterator < Dataset > datasetsIter = datasets . iterator ( ) ; \ndatasetsIter . hasNext ( ) ; \n) { \nDataset dataset = datasetsIter . next ( ) ; \nPath datasetPath ; \nif ( dataset . getMFile ( ) instanceof MFileOS ) { \ndatasetPath = ( ( MFileOS ) dataset . getMFile ( ) ) . getFile ( ) . toPath ( ) ; \n} \nelse { \nif ( dataset . getMFile ( ) instanceof MFileOS7 ) { \ndatasetPath = ( ( MFileOS7 ) dataset . getMFile ( ) ) . getNioPath ( ) ; \n} \nelse { \ncontinue ; \n} \n} \nif ( ! Files . isReadable ( datasetPath ) ) { \nlogger . warn ( \"Aggregation member isn't readable (permissions issue?). Skipping: \" + datasetPath ) ; \ndatasetsIter . remove ( ) ; \n} \n} \nSet < String > dset = new HashSet < > ( 2 * datasets . size ( ) ) ; \nfor ( Aggregation . Dataset dataset : datasets ) { \nif ( dset . contains ( dataset . cacheLocation ) ) logger . warn ( \"Duplicate dataset in aggregation = \" + dataset . cacheLocation ) ; \ndset . add ( dataset . cacheLocation ) ; \n} \nif ( datasets . size ( ) == 0 ) { \nthrow new IllegalStateException ( \"There are no datasets in the aggregation \" + datasetManager ) ; \n} \n} \n} \n"}
{"4555": "public class Aggregation { \nprotected Dataset getTypicalDataset ( ) throws IOException { \nList < Dataset > nestedDatasets = getDatasets ( ) ; \nint n = nestedDatasets . size ( ) ; \nif ( n == 0 ) throw new FileNotFoundException ( \"No datasets in this aggregation\" ) ; \nint select ; \nif ( typicalDatasetMode == TypicalDataset . LATEST ) select = n - 1 ; \nelse { \nif ( typicalDatasetMode == TypicalDataset . PENULTIMATE ) select = ( n < 2 ) ? 0 : n - 2 ; \nelse { \nif ( typicalDatasetMode == TypicalDataset . FIRST ) select = 0 ; \nelse { \nif ( r == null ) r = new Random ( ) ; \nselect = ( n < 2 ) ? 0 : r . nextInt ( n ) ; \n} \n} \n} \nreturn nestedDatasets . get ( select ) ; \n} \n} \n"}
{"4562": "public class DatasetFilter { \nprivate boolean match ( InvDataset dataset ) { \nif ( this . getParentDatasetSource ( ) . isCollection ( dataset ) && ! this . applyToCollectionDatasets ) return ( false ) ; \nif ( ( ! this . getParentDatasetSource ( ) . isCollection ( dataset ) ) && ! this . applyToAtomicDatasets ) return ( false ) ; \nif ( this . matchPatternTarget == null ) { \nif ( this . getParentDatasetSource ( ) . isCollection ( dataset ) ) { \nthis . setMatchPatternTarget ( \"name\" ) ; \n} \nelse { \nthis . setMatchPatternTarget ( \"urlPath\" ) ; \n} \n} \nif ( this . type == DatasetFilter . Type . REGULAR_EXPRESSION ) { \nboolean isMatch ; \nif ( this . getMatchPatternTarget ( ) . equals ( \"name\" ) ) { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( dataset . getName ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nelse { \nif ( this . getMatchPatternTarget ( ) . equals ( \"urlPath\" ) ) { \njava . util . regex . Matcher matcher = this . regExpPattern . matcher ( ( ( InvDatasetImpl ) dataset ) . getUrlPath ( ) ) ; \nisMatch = matcher . find ( ) ; \n} \nelse { \nisMatch = false ; \n} \n} \nreturn ( isMatch ) ; \n} \nelse { \nSystem . err . println ( \"WARNING -- DatasetFilter.accept(): unsupported type\" + \" <\" + this . type . toString ( ) + \">.\" ) ; \nreturn ( false ) ; \n} \n} \n} \n"}
{"4582": "public class GEOSTransform { \npublic double [ ] earthToSat ( double geographic_lon , double geographic_lat ) { \ngeographic_lat = geographic_lat * DEG_TO_RAD ; \ngeographic_lon = geographic_lon * DEG_TO_RAD ; \ndouble geocentric_lat = Math . atan ( ( ( r_pol * r_pol ) / ( r_eq * r_eq ) ) * Math . tan ( geographic_lat ) ) ; \ndouble r_earth = r_pol / Math . sqrt ( 1.0 - ( ( r_eq * r_eq - r_pol * r_pol ) / ( r_eq * r_eq ) ) * Math . cos ( geocentric_lat ) * Math . cos ( geocentric_lat ) ) ; \ndouble r_1 = h - r_earth * Math . cos ( geocentric_lat ) * Math . cos ( geographic_lon - sub_lon ) ; \ndouble r_2 = - r_earth * Math . cos ( geocentric_lat ) * Math . sin ( geographic_lon - sub_lon ) ; \ndouble r_3 = r_earth * Math . sin ( geocentric_lat ) ; \nif ( r_1 > h ) { \nreturn new double [ ] { \nDouble . NaN , Double . NaN } \n; \n} \ndouble lamda_sat = Double . NaN ; \ndouble theta_sat = Double . NaN ; \nif ( scan_geom . equals ( GEOS ) ) { \nlamda_sat = Math . atan ( - r_2 / r_1 ) ; \ntheta_sat = Math . asin ( r_3 / Math . sqrt ( r_1 * r_1 + r_2 * r_2 + r_3 * r_3 ) ) ; \n} \nelse { \nif ( scan_geom . equals ( GOES ) ) { \nlamda_sat = Math . asin ( - r_2 / Math . sqrt ( r_1 * r_1 + r_2 * r_2 + r_3 * r_3 ) ) ; \ntheta_sat = Math . atan ( r_3 / r_1 ) ; \n} \n} \nreturn new double [ ] { \nlamda_sat , theta_sat } \n; \n} \n} \n"}
{"4588": "public class CFPointObWriter { \npublic static void writePointObsDataset ( PointObsDataset pobsDataset , String fileOut ) throws IOException { \nString altUnits = null ; \nDataIterator iterOne = pobsDataset . getDataIterator ( - 1 ) ; \nwhile ( iterOne . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iterOne . nextData ( ) ; \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \naltUnits = Double . isNaN ( loc . getAltitude ( ) ) ? null : \"meters\" ; \nbreak ; \n} \nList < VariableSimpleIF > vars = pobsDataset . getDataVariables ( ) ; \nList < PointObVar > nvars = new ArrayList < PointObVar > ( vars . size ( ) ) ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nint ndoubles = vars . size ( ) ; \ndouble [ ] dvals = new double [ ndoubles ] ; \nfor ( VariableSimpleIF v : vars ) { \nif ( v . getDataType ( ) . isString ( ) ) nvars . add ( new PointObVar ( v ) ) ; \n} \nString [ ] svals = new String [ vars . size ( ) - ndoubles ] ; \nFileOutputStream fos = new FileOutputStream ( fileOut ) ; \nDataOutputStream out = new DataOutputStream ( fos ) ; \nCFPointObWriter writer = new CFPointObWriter ( out , pobsDataset . getGlobalAttributes ( ) , altUnits , nvars , - 1 ) ; \nDataIterator iter = pobsDataset . getDataIterator ( 1000 * 1000 ) ; \nwhile ( iter . hasNext ( ) ) { \nPointObsDatatype pobsData = ( PointObsDatatype ) iter . nextData ( ) ; \nStructureData sdata = pobsData . getData ( ) ; \nint dcount = 0 ; \nint scount = 0 ; \nfor ( PointObVar v : nvars ) { \nif ( v . getDataType ( ) . isNumeric ( ) ) { \nArray data = sdata . getArray ( v . getName ( ) ) ; \ndata . resetLocalIterator ( ) ; \nif ( data . hasNext ( ) ) dvals [ dcount ++ ] = data . nextDouble ( ) ; \n} \nelse { \nif ( v . getDataType ( ) . isString ( ) ) { \nArrayChar data = ( ArrayChar ) sdata . getArray ( v . getName ( ) ) ; \nsvals [ scount ++ ] = data . getString ( ) ; \n} \n} \n} \nucar . unidata . geoloc . EarthLocation loc = pobsData . getLocation ( ) ; \nwriter . addPoint ( loc . getLatitude ( ) , loc . getLongitude ( ) , loc . getAltitude ( ) , pobsData . getObservationTimeAsDate ( ) , dvals , svals ) ; \n} \nwriter . finish ( ) ; \n} \n} \n"}
{"4592": "public class InvDataset { \npublic String getUniqueID ( ) { \nString authority = getAuthority ( ) ; \nif ( ( authority != null ) && ( getID ( ) != null ) ) return authority + \":\" + getID ( ) ; \nelse { \nif ( getID ( ) != null ) return getID ( ) ; \nelse return null ; \n} \n} \n} \n"}
{"4610": "public class GempakStationFileIOSP { \nprivate Array get1DArray ( DataType type , int len ) { \nArray varArray = null ; \nif ( type . equals ( DataType . FLOAT ) ) { \nvarArray = new ArrayFloat . D1 ( len ) ; \n} \nelse { \nif ( type . equals ( DataType . DOUBLE ) ) { \nvarArray = new ArrayDouble . D1 ( len ) ; \n} \nelse { \nif ( type . equals ( DataType . INT ) ) { \nvarArray = new ArrayInt . D1 ( len , false ) ; \n} \n} \n} \nreturn varArray ; \n} \n} \n"}
{"4614": "public class ChunkInputStream { \npublic String readDMR ( ) throws DapException { \ntry { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to read DMR twice\" ) ; \nbyte [ ] dmr8 = null ; \nif ( requestmode == RequestMode . DMR ) { \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nint c ; \nwhile ( ( c = input . read ( ) ) >= 0 ) { \nbaos . write ( c ) ; \n} \nbaos . close ( ) ; \ndmr8 = baos . toByteArray ( ) ; \n} \nelse { \nif ( requestmode == RequestMode . DAP ) { \nif ( ! readHeader ( input ) ) throw new DapException ( \"Malformed chunk count\" ) ; \ndmr8 = new byte [ this . chunksize ] ; \nint red = read ( dmr8 , 0 , this . chunksize ) ; \nif ( red < this . chunksize ) throw new DapException ( \"Short chunk\" ) ; \n} \nelse assert false : \"Internal error\" ; \n} \nString dmr = new String ( dmr8 , DapUtil . UTF8 ) ; \ndmr = dmr . trim ( ) ; \nif ( dmr . endsWith ( \"\\r\\n\" ) ) { \n} \nelse { \nif ( dmr . endsWith ( \"\\n\" ) ) dmr = dmr . substring ( 0 , dmr . length ( ) - 2 ) + \"\\r\\n\" ; \nelse dmr = dmr + \"\\r\\n\" ; \n} \nthis . remoteorder = ( flags & DapUtil . CHUNK_LITTLE_ENDIAN ) == 0 ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nthis . nochecksum = ( flags & DapUtil . CHUNK_NOCHECKSUM ) != 0 ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) state = State . ERROR ; \nelse { \nif ( ( flags & DapUtil . CHUNK_END ) != 0 ) state = State . END ; \nelse state = State . DATA ; \n} \nreturn dmr ; \n} \ncatch ( IOException ioe ) { \nthrow new DapException ( ioe . getMessage ( ) ) ; \n} \n} \n} \n"}
{"4620": "public class DatasetConstructor { \nstatic private void transferGroup ( NetcdfFile ds , NetcdfDataset targetDs , Group src , Group targetGroup , ReplaceVariableCheck replaceCheck ) { \nboolean unlimitedOK = true ; \ntransferGroupAttributes ( src , targetGroup ) ; \nfor ( Dimension d : src . getDimensions ( ) ) { \nif ( null == targetGroup . findDimensionLocal ( d . getShortName ( ) ) ) { \nDimension newd = new Dimension ( d . getShortName ( ) , d . getLength ( ) , d . isShared ( ) , unlimitedOK && d . isUnlimited ( ) , d . isVariableLength ( ) ) ; \ntargetGroup . addDimension ( newd ) ; \n} \n} \nfor ( Variable v : src . getVariables ( ) ) { \nVariable targetV = targetGroup . findVariable ( v . getShortName ( ) ) ; \nVariableEnhanced targetVe = ( VariableEnhanced ) targetV ; \nboolean replace = ( replaceCheck != null ) && replaceCheck . replace ( v ) ; \nif ( replace || ( null == targetV ) ) { \nif ( ( v instanceof Structure ) && ! ( v instanceof StructureDS ) ) { \nv = new StructureDS ( targetGroup , ( Structure ) v ) ; \n} \nelse { \nif ( ! ( v instanceof VariableDS ) ) { \nv = new VariableDS ( targetGroup , v , false ) ; \n} \n} \nif ( null != targetV ) targetGroup . remove ( targetV ) ; \ntargetGroup . addVariable ( v ) ; \nv . resetDimensions ( ) ; \n} \nelse { \nif ( ! targetV . hasCachedData ( ) && ( targetVe . getOriginalVariable ( ) == null ) ) { \ntargetVe . setOriginalVariable ( v ) ; \n} \n} \n} \nfor ( Group srcNested : src . getGroups ( ) ) { \nGroup nested = targetGroup . findGroup ( srcNested . getShortName ( ) ) ; \nif ( null == nested ) { \nnested = new Group ( ds , targetGroup , srcNested . getShortName ( ) ) ; \ntargetGroup . addGroup ( nested ) ; \n} \ntransferGroup ( ds , targetDs , srcNested , nested , replaceCheck ) ; \n} \n} \n} \n"}
{"4622": "public class IgraPor { \n@ Override public void open ( RandomAccessFile raff , NetcdfFile ncfile , CancelTask cancelTask ) throws IOException { \nsuper . open ( raff , ncfile , cancelTask ) ; \nint pos = location . lastIndexOf ( \".\" ) ; \nString ext = location . substring ( pos ) ; \nFile file = new File ( location ) ; \nFile stnFile = getStnFile ( location ) ; \nif ( stnFile == null ) throw new FileNotFoundException ( \"Station File does not exist=\" + location ) ; \nif ( ext . equals ( IDX_EXT ) ) { \nstnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \n} \nelse { \nif ( ext . equals ( DAT_EXT ) ) { \nstnRaf = RandomAccessFile . acquire ( stnFile . getPath ( ) ) ; \ndataRaf = raff ; \nString name = file . getName ( ) ; \nstationId = name . substring ( 0 , name . length ( ) - DAT_EXT . length ( ) ) ; \n} \nelse { \nstnRaf = raff ; \ndataDir = new File ( file . getParentFile ( ) , DAT_DIR ) ; \n} \n} \nNcmlConstructor ncmlc = new NcmlConstructor ( ) ; \nif ( ! ncmlc . populateFromResource ( \"resources/nj22/iosp/igra-por.ncml\" , ncfile ) ) { \nthrow new IllegalStateException ( ncmlc . getErrlog ( ) . toString ( ) ) ; \n} \nncfile . finish ( ) ; \nstnVinfo = setVinfo ( stnRaf , ncfile , stnPattern , \"station\" ) ; \nseriesVinfo = setVinfo ( stnRaf , ncfile , dataHeaderPattern , \"station.time_series\" ) ; \nprofileVinfo = setVinfo ( stnRaf , ncfile , dataPattern , \"station.time_series.levels\" ) ; \nStructureMembers . Member m = stnVinfo . sm . findMember ( STNID ) ; \nStructureDataRegexp . VinfoField f = ( StructureDataRegexp . VinfoField ) m . getDataObject ( ) ; \nstn_fldno = f . fldno ; \n} \n} \n"}
{"4628": "public class Cosmic1Convention { \npublic static double [ ] ECFtoLLA ( double x , double y , double z , double a , double b ) { \ndouble longitude = Math . atan2 ( y , x ) ; \ndouble ePrimeSquared = ( a * a - b * b ) / ( b * b ) ; \ndouble p = Math . sqrt ( x * x + y * y ) ; \ndouble theta = Math . atan ( ( z * a ) / ( p * b ) ) ; \ndouble sineTheta = Math . sin ( theta ) ; \ndouble cosTheta = Math . cos ( theta ) ; \ndouble f = 1 / 298.257223563 ; \ndouble e2 = 2 * f - f * f ; \ndouble top = z + ePrimeSquared * b * sineTheta * sineTheta * sineTheta ; \ndouble bottom = p - e2 * a * cosTheta * cosTheta * cosTheta ; \ndouble geodeticLat = Math . atan ( top / bottom ) ; \ndouble sineLat = Math . sin ( geodeticLat ) ; \ndouble N = a / Math . sqrt ( 1 - e2 * sineLat * sineLat ) ; \ndouble altitude = ( p / Math . cos ( geodeticLat ) ) - N ; \nif ( longitude > Math . PI ) { \nlongitude -= 2 * Math . PI ; \n} \nelse { \nif ( longitude < - Math . PI ) { \nlongitude += 2 * Math . PI ; \n} \n} \nreturn new double [ ] { \ngeodeticLat , longitude , altitude } \n; \n} \n} \n"}
{"4629": "public class Util { \npublic static String cleanUnit ( String unit ) { \nif ( unit == null ) return null ; \nif ( unit . equalsIgnoreCase ( \"Proportion\" ) || unit . equalsIgnoreCase ( \"Numeric\" ) ) unit = \"\" ; \nelse { \nif ( unit . equalsIgnoreCase ( \"-\" ) ) { \nunit = \"\" ; \n} \nelse { \nif ( unit . startsWith ( \"degree\" ) && unit . endsWith ( \"true\" ) ) { \nunit = unit . replace ( ' ' , '_' ) ; \n} \nelse { \nif ( ! unit . contains ( \" table \" ) ) { \nif ( unit . startsWith ( \"/\" ) ) unit = \"1\" + unit ; \nunit = unit . trim ( ) ; \nunit = StringUtil2 . remove ( unit , \"**\" ) ; \nStringBuilder sb = new StringBuilder ( unit ) ; \nStringUtil2 . remove ( sb , \"^[]\" ) ; \nStringUtil2 . replace ( sb , ' ' , \".\" ) ; \nStringUtil2 . replace ( sb , '*' , \".\" ) ; \nunit = sb . toString ( ) ; \n} \n} \n} \n} \nreturn unit ; \n} \n} \n"}
{"4634": "public class DodsV { \nvoid parseDAS ( DAS das ) throws IOException { \nEnumeration tableNames = das . getNames ( ) ; \nwhile ( tableNames . hasMoreElements ( ) ) { \nString tableName = ( String ) tableNames . nextElement ( ) ; \nAttributeTable attTable = das . getAttributeTableN ( tableName ) ; \nif ( tableName . equals ( \"NC_GLOBAL\" ) || tableName . equals ( \"HDF_GLOBAL\" ) ) { \naddAttributeTable ( this , attTable , tableName , true ) ; \n} \nelse { \nif ( tableName . equals ( \"DODS_EXTRA\" ) || tableName . equals ( \"EXTRA_DIMENSION\" ) ) { \ncontinue ; \n} \nelse { \nDodsV dodsV = findDodsV ( tableName , false ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \ndodsV = findTableDotDelimited ( tableName ) ; \nif ( dodsV != null ) { \naddAttributeTable ( dodsV , attTable , tableName , true ) ; \n} \nelse { \nif ( debugAttributes ) System . out . println ( \"DODSNetcdf getAttributes CANT find <\" + tableName + \"> add to globals\" ) ; \naddAttributeTable ( this , attTable , tableName , false ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"4642": "public class Variable { \npublic Section getShapeAsSection ( ) { \nif ( shapeAsSection == null ) { \ntry { \nList < Range > list = new ArrayList < > ( ) ; \nfor ( Dimension d : dimensions ) { \nint len = d . getLength ( ) ; \nif ( len > 0 ) list . add ( new Range ( d . getShortName ( ) , 0 , len - 1 ) ) ; \nelse { \nif ( len == 0 ) list . add ( Range . EMPTY ) ; \nelse { \nassert d . isVariableLength ( ) ; \nlist . add ( Range . VLEN ) ; \n} \n} \n} \nshapeAsSection = new Section ( list ) . makeImmutable ( ) ; \n} \ncatch ( InvalidRangeException e ) { \nlog . error ( \"Bad shape in variable \" + getFullName ( ) , e ) ; \nthrow new IllegalStateException ( e . getMessage ( ) ) ; \n} \n} \nreturn shapeAsSection ; \n} \n} \n"}
{"4646": "public class Variable { \npublic String readScalarString ( ) throws IOException { \nArray data = getScalarData ( ) ; \nif ( dataType == DataType . STRING ) return ( String ) data . getObject ( Index . scalarIndexImmutable ) ; \nelse { \nif ( dataType == DataType . CHAR ) { \nArrayChar dataC = ( ArrayChar ) data ; \nreturn dataC . getString ( ) ; \n} \nelse throw new IllegalArgumentException ( \"readScalarString not STRING or CHAR \" + getFullName ( ) ) ; \n} \n} \n} \n"}
{"4659": "public class AbstractRadialAdapter { \nprotected void setBoundingBox ( ) { \nLatLonRect largestBB = null ; \nfor ( Object o : csHash . values ( ) ) { \nRadialCoordSys sys = ( RadialCoordSys ) o ; \nsys . setOrigin ( origin ) ; \nLatLonRect bb = sys . getBoundingBox ( ) ; \nif ( largestBB == null ) largestBB = bb ; \nelse { \nif ( bb != null ) largestBB . extend ( bb ) ; \n} \n} \nboundingBox = largestBB ; \n} \n} \n"}
{"4666": "public class CDMDSP { \nprotected void builddimrefs ( DapVariable dapvar , List < Dimension > cdmdims ) throws DapException { \nif ( cdmdims == null || cdmdims . size ( ) == 0 ) return ; \nfor ( Dimension cdmdim : cdmdims ) { \nDapDimension dapdim = null ; \nif ( cdmdim . isShared ( ) ) { \nDimension declareddim = finddimdecl ( cdmdim ) ; \nif ( declareddim == null ) throw new DapException ( \"Unprocessed cdm dimension: \" + cdmdim ) ; \ndapdim = ( DapDimension ) this . nodemap . get ( declareddim ) ; \nassert dapdim != null ; \n} \nelse { \nif ( cdmdim . isVariableLength ( ) ) { \ncontinue ; \n} \nelse { \ndapdim = builddim ( cdmdim ) ; \n} \n} \nassert ( dapdim != null ) : \"Internal error\" ; \ndapvar . addDimension ( dapdim ) ; \n} \n} \n} \n"}
{"4701": "public class DConnect2 { \nprivate void openConnection ( String urlString , Command command ) throws IOException , DAP2Exception { \nInputStream is = null ; \ntry { \ntry ( HTTPMethod method = HTTPFactory . Get ( _session , urlString ) ) { \nif ( acceptCompress ) method . setCompression ( \"deflate,gzip\" ) ; \nif ( allowSessions ) method . setUseSessions ( true ) ; \nint statusCode ; \nfor ( ; \n; \n) { \nstatusCode = method . execute ( ) ; \nif ( statusCode != HttpStatus . SC_SERVICE_UNAVAILABLE ) break ; \nThread . sleep ( 5000 ) ; \nSystem . err . println ( \"Service Unavailable\" ) ; \n} \nif ( statusCode == HttpStatus . SC_NOT_FOUND ) { \nthrow new DAP2Exception ( DAP2Exception . NO_SUCH_FILE , method . getStatusText ( ) + \": \" + urlString ) ; \n} \nif ( statusCode == HttpStatus . SC_UNAUTHORIZED || statusCode == HttpStatus . SC_FORBIDDEN ) { \nthrow new InvalidCredentialsException ( method . getStatusText ( ) ) ; \n} \nif ( statusCode != HttpStatus . SC_OK ) { \nthrow new DAP2Exception ( \"Method failed:\" + method . getStatusText ( ) + \" on URL= \" + urlString ) ; \n} \nis = method . getResponseAsStream ( ) ; \nHeader header = method . getResponseHeader ( \"Content-Description\" ) ; \nif ( header != null && ( header . getValue ( ) . equals ( \"dods-error\" ) || header . getValue ( ) . equals ( \"dods_error\" ) ) ) { \nDAP2Exception ds = new DAP2Exception ( ) ; \nds . parse ( is ) ; \nthrow ds ; \n} \nver = new ServerVersion ( method ) ; \ncheckHeaders ( method ) ; \nHeader h = method . getResponseHeader ( \"content-encoding\" ) ; \nString encoding = ( h == null ) ? null : h . getValue ( ) ; \nif ( encoding != null && encoding . equals ( \"deflate\" ) ) { \nis = new BufferedInputStream ( new InflaterInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"deflate %s%n\" , urlString ) ; \n} \nelse { \nif ( encoding != null && encoding . equals ( \"gzip\" ) ) { \nis = new BufferedInputStream ( new GZIPInputStream ( is ) , 1000 ) ; \nif ( showCompress ) System . out . printf ( \"gzip %s%n\" , urlString ) ; \n} \nelse { \nif ( showCompress ) System . out . printf ( \"none %s%n\" , urlString ) ; \n} \n} \ncommand . process ( is ) ; \n} \n} \ncatch ( IOException | DAP2Exception e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nUtil . check ( e ) ; \nthrow new DAP2Exception ( e ) ; \n} \n} \n} \n"}
{"4702": "public class DConnect2 { \npublic DAS getDAS ( ) throws IOException , DAP2Exception { \nDASCommand command = new DASCommand ( ) ; \nif ( filePath != null ) { \nFile daspath = new File ( filePath + \".das\" ) ; \nif ( daspath . canRead ( ) ) { \ntry ( FileInputStream is = new FileInputStream ( daspath ) ) { \ncommand . process ( is ) ; \n} \n} \n} \nelse { \nif ( stream != null ) { \ncommand . process ( stream ) ; \n} \nelse { \ntry { \nopenConnection ( urlString + \".das\" + getCompleteCE ( projString , selString ) , command ) ; \n} \ncatch ( DAP2Exception de ) { \n} \n} \n} \nreturn command . das ; \n} \n} \n"}
{"4703": "public class DConnect2 { \npublic DDS getDDS ( String CE ) throws IOException , ParseException , DAP2Exception { \nDDSCommand command = new DDSCommand ( ) ; \ncommand . setURL ( CE == null || CE . length ( ) == 0 ? urlString : urlString + \"?\" + CE ) ; \nif ( filePath != null ) { \ntry ( FileInputStream is = new FileInputStream ( filePath + \".dds\" ) ) { \ncommand . process ( is ) ; \n} \n} \nelse { \nif ( stream != null ) { \ncommand . process ( stream ) ; \n} \nelse { \nopenConnection ( urlString + \".dds\" + ( getCompleteCE ( CE ) ) , command ) ; \n} \n} \nreturn command . dds ; \n} \n} \n"}
{"4704": "public class DConnect2 { \nprivate String getCompleteCE ( String CE ) { \nString localProjString = null ; \nString localSelString = null ; \nif ( CE == null ) return \"\" ; \nif ( CE . startsWith ( \"?\" ) ) CE = CE . substring ( 1 ) ; \nint selIndex = CE . indexOf ( '&' ) ; \nif ( selIndex == 0 ) { \nlocalProjString = \"\" ; \nlocalSelString = CE ; \n} \nelse { \nif ( selIndex > 0 ) { \nlocalSelString = CE . substring ( selIndex ) ; \nlocalProjString = CE . substring ( 0 , selIndex ) ; \n} \nelse { \nlocalProjString = CE ; \nlocalSelString = \"\" ; \n} \n} \nString ce = projString ; \nif ( ! localProjString . equals ( \"\" ) ) { \nif ( ! ce . equals ( \"\" ) && localProjString . indexOf ( ',' ) != 0 ) ce += \",\" ; \nce += localProjString ; \n} \nif ( ! selString . equals ( \"\" ) ) { \nif ( selString . indexOf ( '&' ) != 0 ) ce += \"&\" ; \nce += selString ; \n} \nif ( ! localSelString . equals ( \"\" ) ) { \nif ( localSelString . indexOf ( '&' ) != 0 ) ce += \"&\" ; \nce += localSelString ; \n} \nif ( ce . length ( ) > 0 ) ce = \"?\" + ce ; \nif ( false ) { \nDAPNode . log . debug ( \"projString: '\" + projString + \"'\" ) ; \nDAPNode . log . debug ( \"localProjString: '\" + localProjString + \"'\" ) ; \nDAPNode . log . debug ( \"selString: '\" + selString + \"'\" ) ; \nDAPNode . log . debug ( \"localSelString: '\" + localSelString + \"'\" ) ; \nDAPNode . log . debug ( \"Complete CE: \" + ce ) ; \n} \nreturn ce ; \n} \n} \n"}
{"4705": "public class Sinusoidal { \n@ Override public LatLonPoint projToLatLon ( ProjectionPoint world , LatLonPointImpl result ) { \ndouble fromX = world . getX ( ) - falseEasting ; \ndouble fromY = world . getY ( ) - falseNorthing ; \ndouble toLat_r = fromY / earthRadius ; \ndouble toLon_r ; \nif ( Misc . nearlyEquals ( Math . abs ( toLat_r ) , PI_OVER_2 , 1e-10 ) ) { \ntoLat_r = toLat_r < 0 ? - PI_OVER_2 : + PI_OVER_2 ; \ntoLon_r = Math . toRadians ( centMeridian ) ; \n} \nelse { \nif ( Math . abs ( toLat_r ) < PI_OVER_2 ) { \ntoLon_r = Math . toRadians ( centMeridian ) + fromX / ( earthRadius * Math . cos ( toLat_r ) ) ; \n} \nelse { \nreturn INVALID ; \n} \n} \nif ( Misc . nearlyEquals ( Math . abs ( toLon_r ) , PI , 1e-10 ) ) { \ntoLon_r = toLon_r < 0 ? - PI : + PI ; \n} \nelse { \nif ( Math . abs ( toLon_r ) > PI ) { \nreturn INVALID ; \n} \n} \nresult . setLatitude ( Math . toDegrees ( toLat_r ) ) ; \nresult . setLongitude ( Math . toDegrees ( toLon_r ) ) ; \nreturn result ; \n} \n} \n"}
{"4713": "public class Escape { \nprivate static String xunescapeString ( String in , char escape , boolean spaceplus ) { \ntry { \nif ( in == null ) return null ; \nbyte [ ] utf8 = in . getBytes ( utf8Charset ) ; \nbyte escape8 = ( byte ) escape ; \nbyte [ ] out = new byte [ utf8 . length ] ; \nint index8 = 0 ; \nfor ( int i = 0 ; \ni < utf8 . length ; \n) { \nbyte b = utf8 [ i ++ ] ; \nif ( b == plus && spaceplus ) { \nout [ index8 ++ ] = blank ; \n} \nelse { \nif ( b == escape8 ) { \nif ( i + 2 <= utf8 . length ) { \nb = ( byte ) ( fromHex ( utf8 [ i ] ) << 4 | fromHex ( utf8 [ i + 1 ] ) ) ; \ni += 2 ; \n} \n} \n} \nout [ index8 ++ ] = b ; \n} \nreturn new String ( out , 0 , index8 , utf8Charset ) ; \n} \ncatch ( Exception e ) { \nreturn in ; \n} \n} \n} \n"}
{"4734": "public class GridCoordSys { \nvoid addToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( dontUseVertical ) { \nreturn ; \n} \nif ( g == null ) { \ng = ncfile . getRootGroup ( ) ; \n} \nString dims = \"time\" ; \nif ( ! dontUseVertical ) { \ndims = dims + \" \" + verticalName ; \n} \nif ( hcs . isLatLon ( ) ) { \ndims = dims + \" lat lon\" ; \n} \nelse { \ndims = dims + \" y x\" ; \n} \nint nlevs = levels . size ( ) ; \nVariable v = new Variable ( ncfile , g , null , verticalName ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , lookup . getLevelDescription ( record ) ) ) ; \nv . addAttribute ( new Attribute ( \"units\" , lookup . getLevelUnit ( record ) ) ) ; \nif ( positive != null ) { \nv . addAttribute ( new Attribute ( \"positive\" , positive ) ) ; \n} \nif ( units != null ) { \nAxisType axisType ; \nif ( SimpleUnit . isCompatible ( \"millibar\" , units ) ) { \naxisType = AxisType . Pressure ; \n} \nelse { \nif ( SimpleUnit . isCompatible ( \"m\" , units ) ) { \naxisType = AxisType . Height ; \n} \nelse { \naxisType = AxisType . GeoZ ; \n} \n} \nv . addAttribute ( new Attribute ( \"grid_level_type\" , Integer . toString ( record . getLevelType1 ( ) ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; \nif ( ! hcs . isLatLon ( ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . Transforms , hcs . getGridName ( ) ) ) ; \n} \n} \ndouble [ ] data = new double [ nlevs ] ; \nfor ( int i = 0 ; \ni < levels . size ( ) ; \ni ++ ) { \nDouble d = ( Double ) levels . get ( i ) ; \ndata [ i ] = d . doubleValue ( ) ; \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nnlevs } \n, data ) ; \nv . setDimensions ( verticalName ) ; \nv . setCachedData ( dataArray , false ) ; \nncfile . addVariable ( g , v ) ; \nif ( record . getLevelType1 ( ) == 109 ) { \nfindCoordinateTransform ( g , \"Pressure\" , record . getLevelType1 ( ) ) ; \n} \n} \n} \n"}
{"4758": "public class DataDescriptor { \nint countBits ( ) { \nint total_nbits = 0 ; \ntotal_nbytesCDM = 0 ; \nfor ( DataDescriptor dd : subKeys ) { \nif ( dd . subKeys != null ) { \ntotal_nbits += dd . countBits ( ) ; \ntotal_nbytesCDM += dd . total_nbytesCDM ; \n} \nelse { \nif ( dd . f == 0 ) { \ntotal_nbits += dd . bitWidth ; \ntotal_nbytesCDM += dd . getByteWidthCDM ( ) ; \n} \n} \n} \nif ( replication > 1 ) { \ntotal_nbits *= replication ; \ntotal_nbytesCDM *= replication ; \n} \nreturn total_nbits ; \n} \n} \n"}
{"4815": "public class DMRPrinter { \nstatic boolean isSpecial ( DapAttribute attr ) { \nif ( attr . getParent ( ) . getSort ( ) == DapSort . DATASET ) { \nfor ( String s : GROUPSPECIAL ) { \nif ( s . equals ( attr . getShortName ( ) ) ) return true ; \n} \n} \nelse { \nif ( attr . getParent ( ) . getSort ( ) == DapSort . VARIABLE ) { \nfor ( String s : VARSPECIAL ) { \nif ( s . equals ( attr . getShortName ( ) ) ) return true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"4820": "public class AreaReader { \nprivate int getCalType ( String calName ) { \nint calTypeOut = Calibrator . CAL_NONE ; \nif ( calName . trim ( ) . equals ( \"ALB\" ) ) { \ncalTypeOut = Calibrator . CAL_ALB ; \n} \nelse { \nif ( calName . trim ( ) . equals ( \"BRIT\" ) ) { \ncalTypeOut = Calibrator . CAL_BRIT ; \n} \nelse { \nif ( calName . trim ( ) . equals ( \"RAD\" ) ) { \ncalTypeOut = Calibrator . CAL_RAD ; \n} \nelse { \nif ( calName . trim ( ) . equals ( \"RAW\" ) ) { \ncalTypeOut = Calibrator . CAL_RAW ; \n} \nelse { \nif ( calName . trim ( ) . equals ( \"TEMP\" ) ) { \ncalTypeOut = Calibrator . CAL_TEMP ; \n} \n} \n} \n} \n} \nreturn calTypeOut ; \n} \n} \n"}
{"4827": "public class CoordSysEvaluator { \nstatic private CoordinateSystem findBestCoordinateSystem ( NetcdfDataset ds ) { \nCoordinateSystem use = null ; \nfor ( CoordinateSystem cs : ds . getCoordinateSystems ( ) ) { \nif ( use == null ) use = cs ; \nelse { \nif ( cs . getCoordinateAxes ( ) . size ( ) > use . getCoordinateAxes ( ) . size ( ) ) use = cs ; \n} \n} \nreturn use ; \n} \n} \n"}
{"4836": "public class StructureDataA { \npublic String [ ] getJavaArrayString ( StructureMembers . Member m ) { \nif ( m . getDataType ( ) == DataType . STRING ) { \nArray data = getArray ( m ) ; \nint n = m . getSize ( ) ; \nString [ ] result = new String [ n ] ; \nfor ( int i = 0 ; \ni < result . length ; \ni ++ ) result [ i ] = ( String ) data . getObject ( i ) ; \nreturn result ; \n} \nelse { \nif ( m . getDataType ( ) == DataType . CHAR ) { \nArrayChar data = ( ArrayChar ) getArray ( m ) ; \nArrayChar . StringIterator iter = data . getStringIterator ( ) ; \nString [ ] result = new String [ iter . getNumElems ( ) ] ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) result [ count ++ ] = iter . next ( ) ; \nreturn result ; \n} \n} \nthrow new IllegalArgumentException ( \"getJavaArrayString: not String DataType :\" + m . getDataType ( ) ) ; \n} \n} \n"}
{"4866": "public class H4iosp { \nprivate ucar . ma2 . ArrayStructure readStructureData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException , InvalidRangeException { \nH4header . Vinfo vinfo = ( H4header . Vinfo ) s . getSPobject ( ) ; \nvinfo . setLayoutInfo ( ) ; \nint recsize = vinfo . elemSize ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nH4header . Minfo minfo = ( H4header . Minfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( minfo . offset ) ; \n} \nmembers . setStructureSize ( recsize ) ; \nArrayStructureBB structureArray = new ArrayStructureBB ( members , section . getShape ( ) ) ; \nbyte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; \nif ( ! vinfo . isLinked && ! vinfo . isCompressed ) { \nLayout layout = new LayoutRegular ( vinfo . start , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( raf , layout , DataType . STRUCTURE , result , - 1 , true ) ; \n} \nelse { \nif ( vinfo . isLinked && ! vinfo . isCompressed ) { \nInputStream is = new LinkedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse { \nif ( ! vinfo . isLinked && vinfo . isCompressed ) { \nInputStream is = getCompressedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse { \nif ( vinfo . isLinked && vinfo . isCompressed ) { \nInputStream is = getLinkedCompressedInputStream ( vinfo ) ; \nPositioningDataInputStream dataSource = new PositioningDataInputStream ( is ) ; \nLayout layout = new LayoutRegular ( 0 , recsize , s . getShape ( ) , section ) ; \nIospHelper . readData ( dataSource , layout , DataType . STRUCTURE , result ) ; \n} \nelse { \nthrow new IllegalStateException ( ) ; \n} \n} \n} \n} \nreturn structureArray ; \n} \n} \n"}
{"4875": "public class GempakUtil { \npublic static String LV_CCRD ( int ivcord ) { \nString vcoord = \"\" ; \nif ( ( ivcord >= 0 ) && ( ivcord < vertCoords . length ) ) { \nvcoord = vertCoords [ ivcord ] ; \n} \nelse { \nif ( ivcord > 100 ) { \nvcoord = ST_ITOC ( ivcord ) ; \n} \n} \nreturn vcoord ; \n} \n} \n"}
{"4898": "public class DatasetUrl { \nstatic private ServiceType checkIfDap4 ( String location ) throws IOException { \nif ( location . endsWith ( \".dap\" ) ) location = location . substring ( 0 , location . length ( ) - \".dap\" . length ( ) ) ; \nelse { \nif ( location . endsWith ( \".dmr\" ) ) location = location . substring ( 0 , location . length ( ) - \".dmr\" . length ( ) ) ; \nelse { \nif ( location . endsWith ( \".dmr.xml\" ) ) location = location . substring ( 0 , location . length ( ) - \".dmr.xml\" . length ( ) ) ; \nelse { \nif ( location . endsWith ( \".dsr\" ) ) location = location . substring ( 0 , location . length ( ) - \".dsr\" . length ( ) ) ; \n} \n} \n} \ntry ( HTTPMethod method = HTTPFactory . Get ( location + \".dmr.xml\" ) ) { \nint status = method . execute ( ) ; \nif ( status == 200 ) { \nHeader h = method . getResponseHeader ( \"Content-Type\" ) ; \nif ( ( h != null ) && ( h . getValue ( ) != null ) ) { \nString v = h . getValue ( ) ; \nif ( v . startsWith ( \"application/vnd.opendap.org\" ) ) return ServiceType . DAP4 ; \n} \n} \nif ( status == HttpStatus . SC_UNAUTHORIZED || status == HttpStatus . SC_FORBIDDEN ) throw new IOException ( \"Unauthorized to open dataset \" + location ) ; \nreturn null ; \n} \n} \n} \n"}
{"4931": "public class HTTPSession { \nsynchronized protected void setAuthenticationAndProxy ( HttpClientBuilder cb ) throws HTTPException { \ncb . setSSLSocketFactory ( ( SSLConnectionSocketFactory ) authcontrols . get ( AuthProp . SSLFACTORY ) ) ; \nAuthScope bestMatch = HTTPAuthUtil . bestmatch ( scope , localcreds . keySet ( ) ) ; \nCredentialsProvider cp = null ; \nif ( bestMatch != null ) { \ncp = localcreds . get ( bestMatch ) ; \n} \nelse { \nbestMatch = HTTPAuthUtil . bestmatch ( scope , globalcredfactories . keySet ( ) ) ; \nif ( bestMatch != null ) { \nHTTPProviderFactory factory = globalcredfactories . get ( bestMatch ) ; \ncp = factory . getProvider ( bestMatch ) ; \n} \n} \nCredentials proxycreds = null ; \nAuthScope proxyscope = null ; \nString user = ( String ) authcontrols . get ( AuthProp . PROXYUSER ) ; \nString pwd = ( String ) authcontrols . get ( AuthProp . PROXYPWD ) ; \nHttpHost httpproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPPROXY ) ; \nHttpHost httpsproxy = ( HttpHost ) authcontrols . get ( AuthProp . HTTPSPROXY ) ; \nif ( user != null && ( httpproxy != null || httpsproxy != null ) ) { \nif ( httpproxy != null ) proxyscope = HTTPAuthUtil . hostToAuthScope ( httpproxy ) ; \nelse proxyscope = HTTPAuthUtil . hostToAuthScope ( httpsproxy ) ; \nproxycreds = new UsernamePasswordCredentials ( user , pwd ) ; \n} \nif ( cp == null && proxycreds != null && proxyscope != null ) { \ncp = new BasicCredentialsProvider ( ) ; \ncp . setCredentials ( proxyscope , proxycreds ) ; \n} \nelse { \nif ( cp != null && proxycreds != null && proxyscope != null ) { \ncp . setCredentials ( proxyscope , proxycreds ) ; \n} \n} \nif ( cp != null ) this . sessioncontext . setCredentialsProvider ( cp ) ; \n} \n} \n"}
{"4937": "public class Index { \nIndex section ( List < Range > ranges ) throws InvalidRangeException { \nif ( ranges . size ( ) != rank ) throw new InvalidRangeException ( \"Bad ranges [] length\" ) ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) continue ; \nif ( r == Range . VLEN ) continue ; \nif ( ( r . first ( ) < 0 ) || ( r . first ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range starting value at index \" + ii + \" == \" + r . first ( ) ) ; \nif ( ( r . last ( ) < 0 ) || ( r . last ( ) >= shape [ ii ] ) ) throw new InvalidRangeException ( \"Bad range ending value at index \" + ii + \" == \" + r . last ( ) ) ; \n} \nint reducedRank = rank ; \nfor ( Range r : ranges ) { \nif ( ( r != null ) && ( r . length ( ) == 1 ) ) reducedRank -- ; \n} \nIndex newindex = Index . factory ( reducedRank ) ; \nnewindex . offset = offset ; \nint newDim = 0 ; \nfor ( int ii = 0 ; \nii < rank ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) { \nnewindex . shape [ newDim ] = shape [ ii ] ; \nnewindex . stride [ newDim ] = stride [ ii ] ; \nnewDim ++ ; \n} \nelse { \nif ( r . length ( ) != 1 ) { \nnewindex . shape [ newDim ] = r . length ( ) ; \nnewindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; \nnewindex . offset += stride [ ii ] * r . first ( ) ; \nnewDim ++ ; \n} \nelse { \nnewindex . offset += stride [ ii ] * r . first ( ) ; \n} \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator && ( newindex . size == size ) ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4947": "public class CoordinateTimeIntv { \npublic String getTimeIntervalName ( ) { \nint firstValue = - 1 ; \nfor ( TimeCoordIntvValue tinv : timeIntervals ) { \nint value = ( tinv . getBounds2 ( ) - tinv . getBounds1 ( ) ) ; \nif ( firstValue < 0 ) firstValue = value ; \nelse { \nif ( value != firstValue ) return MIXED_INTERVALS ; \n} \n} \nfirstValue = ( firstValue * timeUnit . getValue ( ) ) ; \nreturn firstValue + \"_\" + timeUnit . getField ( ) . toString ( ) ; \n} \n} \n"}
{"4957": "public class IndentWriter { \npublic void indent ( int n ) { \ndepth += n ; \nif ( depth < 0 ) depth = 0 ; \nelse { \nif ( depth > MAXDEPTH ) depth = MAXDEPTH ; \n} \n} \n} \n"}
{"4958": "public class IndentWriter { \npublic void setIndent ( int n ) { \ndepth = n ; \nif ( depth < 0 ) depth = 0 ; \nelse { \nif ( depth > MAXDEPTH ) depth = MAXDEPTH ; \n} \n} \n} \n"}
{"4959": "public class GribIndex { \npublic static GribIndex readOrCreateIndexFromSingleFile ( boolean isGrib1 , MFile mfile , CollectionUpdateType force , org . slf4j . Logger logger ) throws IOException { \nGribIndex index = isGrib1 ? new Grib1Index ( ) : new Grib2Index ( ) ; \nif ( ! index . readIndex ( mfile . getPath ( ) , mfile . getLastModified ( ) , force ) ) { \nindex . makeIndex ( mfile . getPath ( ) , null ) ; \nlogger . debug ( \"  Index written: {} == {} records\" , mfile . getName ( ) + GBX9_IDX , index . getNRecords ( ) ) ; \n} \nelse { \nif ( debug ) { \nlogger . debug ( \"  Index read: {} == {} records\" , mfile . getName ( ) + GBX9_IDX , index . getNRecords ( ) ) ; \n} \n} \nreturn index ; \n} \n} \n"}
{"4960": "public class MFileCollectionManager { \npublic void addDirectoryScan ( String dirName , String suffix , String regexpPatternString , String subdirsS , String olderS , Object auxInfo ) { \nCompositeMFileFilter filters = new CompositeMFileFilter ( ) ; \nif ( null != regexpPatternString ) filters . addIncludeFilter ( new RegExpMatchOnName ( regexpPatternString ) ) ; \nelse { \nif ( suffix != null ) filters . addIncludeFilter ( new WildcardMatchOnPath ( \"*\" + suffix + \"$\" ) ) ; \n} \nif ( olderS != null ) { \ntry { \nTimeDuration tu = new TimeDuration ( olderS ) ; \nfilters . addAndFilter ( new LastModifiedLimit ( ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ) ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( collectionName + \": Invalid time unit for olderThan = {}\" , olderS ) ; \n} \n} \nboolean wantSubdirs = true ; \nif ( ( subdirsS != null ) && subdirsS . equalsIgnoreCase ( \"false\" ) ) wantSubdirs = false ; \nCollectionConfig mc = new CollectionConfig ( dirName , dirName , wantSubdirs , filters , auxInfo ) ; \nStringBuilder sb = new StringBuilder ( dirName ) ; \nif ( wantSubdirs ) sb . append ( \"**/\" ) ; \nif ( null != regexpPatternString ) sb . append ( regexpPatternString ) ; \nelse { \nif ( suffix != null ) sb . append ( suffix ) ; \nelse sb . append ( \"noFilter\" ) ; \n} \ncollectionName = sb . toString ( ) ; \nscanList . add ( mc ) ; \n} \n} \n"}
{"4967": "public class MultiSlice { \n@ Override public String toConstraintString ( ) throws DapException { \nassert this . first != UNDEFINED && this . stride != UNDEFINED && this . stop != UNDEFINED ; \nStringBuilder buf = new StringBuilder ( ) ; \nbuf . append ( \"[\" ) ; \nboolean first = true ; \nfor ( Slice sub : this . subslices ) { \nif ( ! first ) buf . append ( \",\" ) ; \nfirst = false ; \nif ( ( sub . stop - sub . first ) == 0 ) { \nbuf . append ( \"0\" ) ; \n} \nelse { \nif ( sub . stride == 1 ) { \nif ( ( sub . stop - sub . first ) == 1 ) buf . append ( sub . first ) ; \nelse buf . append ( String . format ( \"%d:%d\" , sub . first , sub . stop - 1 ) ) ; \n} \nelse buf . append ( String . format ( \"%d:%d:%d\" , sub . first , sub . stride , sub . stop - 1 ) ) ; \n} \n} \nbuf . append ( \"]\" ) ; \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4969": "public class StructureDS { \n@ Override public Array reallyRead ( Variable client , CancelTask cancelTask ) throws IOException { \nArray result ; \nif ( hasCachedData ( ) ) result = super . reallyRead ( client , cancelTask ) ; \nelse { \nif ( orgVar != null ) result = orgVar . read ( ) ; \nelse { \nthrow new IllegalStateException ( \"StructureDS has no way to get data\" ) ; \n} \n} \nreturn convert ( result , null ) ; \n} \n} \n"}
{"4970": "public class StructureDS { \n@ Override public Array reallyRead ( Variable client , Section section , CancelTask cancelTask ) throws IOException , InvalidRangeException { \nif ( section . computeSize ( ) == getSize ( ) ) return _read ( ) ; \nArray result ; \nif ( hasCachedData ( ) ) result = super . reallyRead ( client , section , cancelTask ) ; \nelse { \nif ( orgVar != null ) result = orgVar . read ( section ) ; \nelse { \nthrow new IllegalStateException ( \"StructureDS has no way to get data\" ) ; \n} \n} \nreturn convert ( result , section ) ; \n} \n} \n"}
{"4971": "public class StructureDS { \nprivate boolean convertNeeded ( StructureMembers smData ) { \nfor ( Variable v : getVariables ( ) ) { \nif ( v instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v ; \nif ( vds . needConvert ( ) ) return true ; \n} \nelse { \nif ( v instanceof StructureDS ) { \nStructureDS nested = ( StructureDS ) v ; \nif ( nested . convertNeeded ( null ) ) return true ; \n} \n} \nif ( ( smData != null ) && ! varHasData ( v , smData ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"4972": "public class StructureDS { \nprotected ArrayStructure convert ( Array data , Section section ) throws IOException { \nArrayStructure orgAS = ( ArrayStructure ) data ; \nif ( ! convertNeeded ( orgAS . getStructureMembers ( ) ) ) { \nconvertMemberInfo ( orgAS . getStructureMembers ( ) ) ; \nreturn orgAS ; \n} \nArrayStructure newAS = ArrayStructureMA . factoryMA ( orgAS ) ; \nfor ( StructureMembers . Member m : newAS . getMembers ( ) ) { \nVariableEnhanced v2 = ( VariableEnhanced ) findVariable ( m . getName ( ) ) ; \nif ( ( v2 == null ) && ( orgVar != null ) ) v2 = findVariableFromOrgName ( m . getName ( ) ) ; \nif ( v2 == null ) continue ; \nif ( v2 instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v2 ; \nif ( vds . needConvert ( ) ) { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = vds . convert ( mdata , vds . getEnhanceMode ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \nelse { \nif ( v2 instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v2 ; \nif ( innerStruct . convertNeeded ( null ) ) { \nif ( innerStruct . getDataType ( ) == DataType . SEQUENCE ) { \nArrayObject . D1 seqArray = ( ArrayObject . D1 ) newAS . extractMemberArray ( m ) ; \nArrayObject . D1 newSeq = ( ArrayObject . D1 ) Array . factory ( DataType . SEQUENCE , new int [ ] { \n( int ) seqArray . getSize ( ) } \n) ; \nm . setDataArray ( newSeq ) ; \nfor ( int i = 0 ; \ni < seqArray . getSize ( ) ; \ni ++ ) { \nArraySequence innerSeq = ( ArraySequence ) seqArray . get ( i ) ; \nnewSeq . set ( i , new SequenceConverter ( innerStruct , innerSeq ) ) ; \n} \n} \nelse { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = innerStruct . convert ( mdata , null ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \n} \nStructureMembers sm = newAS . getStructureMembers ( ) ; \nconvertMemberInfo ( sm ) ; \nfor ( Variable v : getVariables ( ) ) { \nif ( ! varHasData ( v , sm ) ) { \ntry { \nVariable completeVar = getParentGroup ( ) . findVariable ( v . getShortName ( ) ) ; \nArray mdata = completeVar . read ( section ) ; \nStructureMembers . Member m = sm . addMember ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) , v . getShape ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \ncatch ( InvalidRangeException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \nreturn newAS ; \n} \n} \n"}
{"4981": "public class GempakSoundingIOSP { \nprivate void addVerticalCoordAttribute ( Variable v ) { \nGempakSoundingFileReader gsfr = ( GempakSoundingFileReader ) gemreader ; \nint vertType = gsfr . getVerticalCoordinate ( ) ; \nString pName = v . getFullName ( ) ; \nif ( gemreader . getFileSubType ( ) . equals ( GempakSoundingFileReader . MERGED ) ) { \nif ( ( vertType == GempakSoundingFileReader . PRES_COORD ) && pName . equals ( \"PRES\" ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \n} \nelse { \nif ( ( vertType == GempakSoundingFileReader . HGHT_COORD ) && ( pName . equals ( \"HGHT\" ) || pName . equals ( \"MHGT\" ) || pName . equals ( \"DHGT\" ) ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Height . name ( ) ) ) ; \n} \n} \n} \nelse { \nif ( pName . equals ( \"PRES\" ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , AxisType . Pressure . name ( ) ) ) ; \n} \n} \n} \n} \n"}
{"4992": "public class GMLFeatureWriter { \npublic String writeFeature ( SimpleGeometry geom ) { \nif ( geom instanceof Point ) return writePoint ( ( Point ) geom ) ; \nelse { \nif ( geom instanceof Line ) return writeLine ( ( Line ) geom ) ; \nelse { \nif ( geom instanceof Polygon ) return writePolygon ( ( Polygon ) geom ) ; \nelse return null ; \n} \n} \n} \n} \n"}
{"4998": "public class DOM4Parser { \nprotected void parseresponse ( Node root ) throws ParseException { \nString elemname = root . getNodeName ( ) ; \nif ( elemname . equalsIgnoreCase ( \"Error\" ) ) { \nparseerror ( root ) ; \n} \nelse { \nif ( elemname . equalsIgnoreCase ( \"Dataset\" ) ) { \nparsedataset ( root ) ; \n} \nelse throw new ParseException ( \"Unexpected response root: \" + elemname ) ; \n} \n} \n} \n"}
{"5003": "public class ArrayStructureMA { \nstatic public ArrayStructureMA factoryMA ( Structure from , int [ ] shape ) throws IOException { \nStructureMembers sm = from . makeStructureMembers ( ) ; \nfor ( Variable v : from . getVariables ( ) ) { \nArray data ; \nif ( v instanceof Sequence ) { \ndata = Array . factory ( DataType . SEQUENCE , shape ) ; \n} \nelse { \nif ( v instanceof Structure ) data = ArrayStructureMA . factoryMA ( ( Structure ) v , combine ( shape , v . getShape ( ) ) ) ; \nelse data = Array . factory ( v . getDataType ( ) , combine ( shape , v . getShape ( ) ) ) ; \n} \nStructureMembers . Member m = sm . findMember ( v . getShortName ( ) ) ; \nm . setDataArray ( data ) ; \n} \nreturn new ArrayStructureMA ( sm , shape ) ; \n} \n} \n"}
{"5007": "public class CECompiler { \npublic void compilefilter ( DapVariable var , DapSequence seq , CEAST expr ) throws DapException { \nif ( expr == null ) return ; \nif ( expr . sort == CEAST . Sort . SEGMENT ) { \nif ( expr . subnodes != null ) throw new DapException ( \"compilefilter: Non-simple segment:\" + expr . name ) ; \nDapVariable field = seq . findByName ( expr . name ) ; \nif ( field == null ) throw new DapException ( \"compilefilter: Unknown filter variable:\" + expr . name ) ; \nexpr . field = field ; \n} \nelse { \nif ( expr . sort == CEAST . Sort . EXPR ) { \nif ( expr . lhs != null ) compilefilter ( var , seq , expr . lhs ) ; \nif ( expr . rhs != null ) compilefilter ( var , seq , expr . rhs ) ; \nif ( expr . lhs != null && expr . rhs != null ) { \nboolean leftvar = ( expr . lhs . sort == CEAST . Sort . SEGMENT ) ; \nboolean rightvar = ( expr . rhs . sort == CEAST . Sort . SEGMENT ) ; \nif ( rightvar && ! leftvar ) { \nCEAST tmp = expr . lhs ; \nexpr . lhs = expr . rhs ; \nexpr . rhs = tmp ; \nswitch ( expr . op ) { \ncase LT : expr . op = CEAST . Operator . GT ; \nbreak ; \ncase LE : expr . op = CEAST . Operator . GE ; \nbreak ; \ncase GT : expr . op = CEAST . Operator . LT ; \nbreak ; \ncase GE : expr . op = CEAST . Operator . LE ; \nbreak ; \ndefault : break ; \n} \n} \n} \n} \nelse { \nif ( expr . sort == CEAST . Sort . CONSTANT ) { \nreturn ; \n} \nelse throw new DapException ( \"compilefilter: Unexpected node type:\" + expr . sort ) ; \n} \n} \n} \n} \n"}
{"5011": "public class LatLonRect { \npublic void extend ( LatLonPoint p ) { \nif ( contains ( p ) ) return ; \ndouble lat = p . getLatitude ( ) ; \ndouble lon = p . getLongitude ( ) ; \nif ( lat > upperRight . getLatitude ( ) ) { \nupperRight . setLatitude ( lat ) ; \n} \nif ( lat < lowerLeft . getLatitude ( ) ) { \nlowerLeft . setLatitude ( lat ) ; \n} \nif ( allLongitude ) { \n} \nelse { \nif ( crossDateline ) { \ndouble d1 = lon - upperRight . getLongitude ( ) ; \ndouble d2 = lowerLeft . getLongitude ( ) - lon ; \nif ( ( d1 > 0.0 ) && ( d2 > 0.0 ) ) { \nif ( d1 > d2 ) { \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \n} \nelse { \nif ( lon > upperRight . getLongitude ( ) ) { \nif ( lon - upperRight . getLongitude ( ) > lowerLeft . getLongitude ( ) - lon + 360 ) { \ncrossDateline = true ; \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \nelse { \nif ( lon < lowerLeft . getLongitude ( ) ) { \nif ( lowerLeft . getLongitude ( ) - lon > lon + 360.0 - upperRight . getLongitude ( ) ) { \ncrossDateline = true ; \nupperRight . setLongitude ( lon ) ; \n} \nelse { \nlowerLeft . setLongitude ( lon ) ; \n} \n} \n} \n} \n} \nwidth = upperRight . getLongitude ( ) - lowerLeft . getLongitude ( ) ; \nlon0 = ( upperRight . getLongitude ( ) + lowerLeft . getLongitude ( ) ) / 2 ; \nif ( crossDateline ) { \nwidth += 360 ; \nlon0 -= 180 ; \n} \nthis . allLongitude = this . allLongitude || ( this . width >= 360.0 ) ; \n} \n} \n"}
{"5018": "public class MAMath { \npublic static void copy ( Array result , Array a ) throws IllegalArgumentException { \nClass classType = a . getElementType ( ) ; \nif ( classType == double . class ) { \ncopyDouble ( result , a ) ; \n} \nelse { \nif ( classType == float . class ) { \ncopyFloat ( result , a ) ; \n} \nelse { \nif ( classType == long . class ) { \ncopyLong ( result , a ) ; \n} \nelse { \nif ( classType == int . class ) { \ncopyInt ( result , a ) ; \n} \nelse { \nif ( classType == short . class ) { \ncopyShort ( result , a ) ; \n} \nelse { \nif ( classType == char . class ) { \ncopyChar ( result , a ) ; \n} \nelse { \nif ( classType == byte . class ) { \ncopyByte ( result , a ) ; \n} \nelse { \nif ( classType == boolean . class ) { \ncopyBoolean ( result , a ) ; \n} \nelse copyObject ( result , a ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"5028": "public class EscapeStrings { \nstatic public String backslashEscape ( String x , String reservedChars ) { \nif ( x == null ) { \nreturn null ; \n} \nelse { \nif ( reservedChars == null ) { \nreturn x ; \n} \n} \nboolean ok = true ; \nfor ( int pos = 0 ; \npos < x . length ( ) ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) >= 0 ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int pos = 0 ; \npos < sb . length ( ) ; \npos ++ ) { \nchar c = sb . charAt ( pos ) ; \nif ( reservedChars . indexOf ( c ) < 0 ) { \ncontinue ; \n} \nsb . setCharAt ( pos , '\\\\' ) ; \npos ++ ; \nsb . insert ( pos , c ) ; \npos ++ ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5033": "public class Nc4Cursor { \nprotected Object readAtomicScalar ( VarNotes vi , TypeNotes ti ) throws DapException { \nDapVariable atomvar = ( DapVariable ) getTemplate ( ) ; \nNc4prototypes nc4 = ( ( Nc4DSP ) this . dsp ) . getJNI ( ) ; \nint ret ; \nDapType basetype = ti . getType ( ) ; \nObject result = null ; \nif ( basetype . isFixedSize ( ) ) { \nlong memsize = ( ( DapType ) ti . get ( ) ) . getSize ( ) ; \nNc4Pointer mem = Nc4Pointer . allocate ( memsize ) ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; \nsetMemory ( mem ) ; \nresult = getatomicdata ( ti . getType ( ) , 1 , mem . size , mem ) ; \n} \nelse { \nif ( basetype . isStringType ( ) ) { \nString [ ] s = new String [ 1 ] ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var_string ( vi . gid , vi . id , s ) ) ; \nresult = s ; \n} \nelse { \nif ( basetype . isOpaqueType ( ) ) { \nNc4Pointer mem = Nc4Pointer . allocate ( ti . getSize ( ) ) ; \nreadcheck ( nc4 , ret = nc4 . nc_get_var ( vi . gid , vi . id , mem . p ) ) ; \nsetMemory ( mem ) ; \nByteBuffer [ ] buf = new ByteBuffer [ 1 ] ; \nbuf [ 0 ] = mem . p . getByteBuffer ( 0 , ti . getSize ( ) ) ; \nresult = buf ; \n} \nelse throw new DapException ( \"Unexpected atomic type: \" + basetype ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"5061": "public class Dimension { \nprotected Factor [ ] mult ( final Dimension that ) { \nfinal Factor [ ] factors1 = _factors ; \nfinal Factor [ ] factors2 = that . _factors ; \nint i1 = 0 ; \nint i2 = 0 ; \nint k = 0 ; \nFactor [ ] newFactors = new Factor [ factors1 . length + factors2 . length ] ; \nfor ( ; \n; \n) { \nif ( i1 == factors1 . length ) { \nfinal int n = factors2 . length - i2 ; \nSystem . arraycopy ( factors2 , i2 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nif ( i2 == factors2 . length ) { \nfinal int n = factors1 . length - i1 ; \nSystem . arraycopy ( factors1 , i1 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nfinal Factor f1 = factors1 [ i1 ] ; \nfinal Factor f2 = factors2 [ i2 ] ; \nfinal int comp = f1 . getID ( ) . compareTo ( f2 . getID ( ) ) ; \nif ( comp < 0 ) { \nnewFactors [ k ++ ] = f1 ; \ni1 ++ ; \n} \nelse { \nif ( comp == 0 ) { \nfinal int exponent = f1 . getExponent ( ) + f2 . getExponent ( ) ; \nif ( exponent != 0 ) { \nnewFactors [ k ++ ] = new Factor ( f1 , exponent ) ; \n} \ni1 ++ ; \ni2 ++ ; \n} \nelse { \nnewFactors [ k ++ ] = f2 ; \ni2 ++ ; \n} \n} \n} \nif ( k < newFactors . length ) { \nfinal Factor [ ] tmp = new Factor [ k ] ; \nSystem . arraycopy ( newFactors , 0 , tmp , 0 , k ) ; \nnewFactors = tmp ; \n} \nreturn newFactors ; \n} \n} \n"}
{"5084": "public class GisFeatureRenderer { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nif ( shapeList != null ) return shapeList . iterator ( ) ; \nif ( Debug . isSet ( \"projection/LatLonShift\" ) ) System . out . println ( \"projection/LatLonShift GisFeatureRenderer.getShapes called\" ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nList featList = getFeatures ( ) ; \nshapeList = new ArrayList ( featList . size ( ) ) ; \nIterator iter = featList . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) iter . next ( ) ; \nShape shape ; \nif ( dataProject == null ) shape = feature . getShape ( ) ; \nelse { \nif ( dataProject . isLatLon ( ) ) { \nshape = feature . getProjectedShape ( displayProject ) ; \n} \nelse { \nif ( dataProject == displayProject ) { \nshape = feature . getShape ( ) ; \n} \nelse { \nshape = feature . getProjectedShape ( dataProject , displayProject ) ; \n} \n} \n} \nshapeList . add ( shape ) ; \n} \nreturn shapeList . iterator ( ) ; \n} \n} \n"}
{"5087": "public class HeaderInputStream { \nprivate void getMoreBytes ( ) throws IOException { \ncurrentOffset = 0 ; \nint bytesRead = 0 ; \nint lookingFor = 0 ; \nfor ( ; \nbytesRead < lineBuf . length ; \nbytesRead ++ ) { \nint c = in . read ( ) ; \nif ( c == - 1 ) break ; \nlineBuf [ bytesRead ] = ( byte ) c ; \nif ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { \nlookingFor ++ ; \nif ( lookingFor == endSequence . length ) { \nendFound = true ; \nbreak ; \n} \n} \nelse { \nif ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) { \nlookingFor = 1 ; \n} \nelse { \nlookingFor = 0 ; \n} \n} \n} \nbytesRemaining = bytesRead ; \n} \n} \n"}
{"5097": "public class NcDDS { \nprivate BaseType createVariable ( NetcdfFile ncfile , Variable v ) { \nBaseType bt ; \nif ( v . getRank ( ) == 0 ) bt = createScalarVariable ( ncfile , v ) ; \nelse { \nif ( v . getDataType ( ) == DataType . CHAR ) { \nif ( v . getRank ( ) > 1 ) bt = new NcSDCharArray ( v ) ; \nelse bt = new NcSDString ( v ) ; \n} \nelse { \nif ( v . getDataType ( ) == DataType . STRING ) { \nif ( v . getRank ( ) == 0 ) bt = new NcSDString ( v ) ; \nelse bt = new NcSDArray ( v , new NcSDString ( v ) ) ; \n} \nelse bt = createArray ( ncfile , v ) ; \n} \n} \nreturn bt ; \n} \n} \n"}
{"5117": "public class GradsDataDescriptorFile { \nprivate List < String > getFileNames ( ) throws IOException { \nif ( fileNames == null ) { \nfileNames = new ArrayList < > ( ) ; \ntimeStepsPerFile = tDim . getSize ( ) ; \nif ( ! isTemplate ( ) ) { \nfileNames . add ( getFullPath ( getDataFile ( ) ) ) ; \n} \nelse { \nlong start = System . currentTimeMillis ( ) ; \nList < String > fileSet = new ArrayList < > ( ) ; \nString template = getDataFile ( ) ; \nif ( GradsTimeDimension . hasTimeTemplate ( template ) ) { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TIME_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nelse { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nif ( templateType == ENS_TEMPLATE ) { \nfor ( int e = 0 ; \ne < eDim . getSize ( ) ; \ne ++ ) { \nfileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; \n} \n} \nelse { \nif ( ( templateType == TIME_TEMPLATE ) || ( templateType == ENS_TIME_TEMPLATE ) ) { \nint numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; \nfor ( int t = 0 ; \nt < tDim . getSize ( ) ; \nt ++ ) { \nfor ( int e = 0 ; \ne < numens ; \ne ++ ) { \nString file = getFileName ( e , t ) ; \nif ( ! fileSet . contains ( file ) ) { \nfileSet . add ( file ) ; \n} \n} \n} \ntimeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; \n} \n} \nfileNames . addAll ( fileSet ) ; \n} \nfor ( String file : fileNames ) { \nFile f = new File ( file ) ; \nif ( ! f . exists ( ) ) { \nlog . error ( \"File: \" + f + \" does not exist\" ) ; \nthrow new IOException ( \"File: \" + f + \" does not exist\" ) ; \n} \n} \n} \nreturn fileNames ; \n} \n} \n"}
{"5122": "public class Nidsheader { \nint readWMO ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint pos = 0 ; \nraf . seek ( pos ) ; \nint readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nint rc = raf . read ( b ) ; \nif ( rc != readLen ) { \nreturn 0 ; \n} \nint iarr2_1 = bytesToInt ( b [ 0 ] , b [ 1 ] , false ) ; \nint iarr2_16 = bytesToInt ( b [ 30 ] , b [ 31 ] , false ) ; \nint iarr2_10 = bytesToInt ( b [ 18 ] , b [ 19 ] , false ) ; \nint iarr2_7 = bytesToInt ( b [ 12 ] , b [ 13 ] , false ) ; \nif ( ( iarr2_1 == iarr2_16 ) && ( ( iarr2_1 >= 16 ) && ( iarr2_1 <= 299 ) ) && ( iarr2_10 == - 1 ) && ( iarr2_7 < 10000 ) ) { \nnoHeader = true ; \nreturn 1 ; \n} \nString pib = new String ( b , CDM . utf8Charset ) ; \nif ( pib . indexOf ( \"SDUS\" ) != - 1 ) { \nnoHeader = false ; \nreturn 1 ; \n} \nelse { \nif ( raf . getLocation ( ) . indexOf ( \".nids\" ) != - 1 ) { \nnoHeader = true ; \nreturn 1 ; \n} \nelse return 0 ; \n} \n} \n} \n"}
{"5137": "public class Nidsheader { \nprotected Object convert ( byte [ ] barray , DataType dataType , int nelems , int byteOrder ) { \nif ( dataType == DataType . BYTE ) { \nreturn barray ; \n} \nif ( dataType == DataType . CHAR ) { \nreturn IospHelper . convertByteToChar ( barray ) ; \n} \nByteBuffer bbuff = ByteBuffer . wrap ( barray ) ; \nif ( byteOrder >= 0 ) bbuff . order ( byteOrder == ucar . unidata . io . RandomAccessFile . LITTLE_ENDIAN ? ByteOrder . LITTLE_ENDIAN : ByteOrder . BIG_ENDIAN ) ; \nif ( dataType == DataType . SHORT ) { \nShortBuffer tbuff = bbuff . asShortBuffer ( ) ; \nshort [ ] pa = new short [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse { \nif ( dataType == DataType . INT ) { \nIntBuffer tbuff = bbuff . asIntBuffer ( ) ; \nint [ ] pa = new int [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse { \nif ( dataType == DataType . FLOAT ) { \nFloatBuffer tbuff = bbuff . asFloatBuffer ( ) ; \nfloat [ ] pa = new float [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse { \nif ( dataType == DataType . DOUBLE ) { \nDoubleBuffer tbuff = bbuff . asDoubleBuffer ( ) ; \ndouble [ ] pa = new double [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \n} \n} \n} \nthrow new IllegalStateException ( ) ; \n} \n} \n"}
{"5161": "public class Escape { \nstatic public List < String > backslashsplit ( String s , char sep ) { \nList < String > path = new ArrayList < String > ( ) ; \nint len = s . length ( ) ; \nStringBuilder piece = new StringBuilder ( ) ; \nint i = 0 ; \nfor ( ; \ni <= len - 1 ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c == '\\\\' && i < ( len - 1 ) ) { \npiece . append ( c ) ; \npiece . append ( s . charAt ( ++ i ) ) ; \n} \nelse { \nif ( c == sep ) { \npath . add ( piece . toString ( ) ) ; \npiece . setLength ( 0 ) ; \n} \nelse piece . append ( c ) ; \n} \n} \npath . add ( piece . toString ( ) ) ; \nreturn path ; \n} \n} \n"}
{"5163": "public class LogCategorizer { \nstatic public String getServiceSpecial ( String path ) { \nString ss = null ; \nif ( path . startsWith ( \"/dqcServlet\" ) ) ss = \"dqcServlet\" ; \nelse { \nif ( path . startsWith ( \"/cdmvalidator\" ) ) ss = \"cdmvalidator\" ; \n} \nreturn ss ; \n} \n} \n"}
{"5181": "public class ConfigCatalogInitialization { \nprivate void processDatasets ( long catId , ReadMode readMode , String dirPath , List < Dataset > datasets , Set < String > idMap ) throws IOException { \nif ( exceedLimit ) return ; \nfor ( Dataset ds : datasets ) { \nif ( datasetTracker . trackDataset ( catId , ds , callback ) ) countDatasets ++ ; \nif ( maxDatasetsProcess > 0 && countDatasets > maxDatasetsProcess ) exceedLimit = true ; \nString id = ds . getID ( ) ; \nif ( id != null ) { \nif ( idMap . contains ( id ) ) { \nlogCatalogInit . error ( ERROR + \"Duplicate id on  '\" + ds . getName ( ) + \"' id= '\" + id + \"'\" ) ; \n} \nelse { \nidMap . add ( id ) ; \n} \n} \nif ( ( ds instanceof DatasetScan ) || ( ds instanceof FeatureCollectionRef ) ) continue ; \nif ( ds instanceof CatalogScan ) continue ; \nif ( ds instanceof CatalogRef ) { \nCatalogRef catref = ( CatalogRef ) ds ; \nString href = catref . getXlinkHref ( ) ; \nif ( ! href . startsWith ( \"http:\" ) ) { \nif ( href . startsWith ( \"./\" ) ) { \nhref = href . substring ( 2 ) ; \n} \nString path ; \nString contextPathPlus = this . contextPath + \"/\" ; \nif ( href . startsWith ( contextPathPlus ) ) { \npath = href . substring ( contextPathPlus . length ( ) ) ; \n} \nelse { \nif ( href . startsWith ( \"/\" ) ) { \nlogCatalogInit . error ( ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" + \"Parent catalog info: Name=\\\"\" + catref . getParentCatalog ( ) . getName ( ) + \"\\\"; Base URI=\\\"\" + catref . getParentCatalog ( ) . getUriString ( ) + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\" ) ; \ncontinue ; \n} \nelse { \npath = dirPath + href ; \n} \n} \nCatalogExt ext = catalogTracker . get ( path ) ; \nlong lastRead = ( ext == null ) ? 0 : ext . getLastRead ( ) ; \ncheckCatalogToRead ( readMode , path , false , lastRead ) ; \n} \n} \nelse { \nprocessDatasets ( catId , readMode , dirPath , ds . getDatasetsLocal ( ) , idMap ) ; \n} \n} \n} \n} \n"}
{"5195": "public class VlenIO { \npublic int writeChars ( String s , int start , int length ) throws IOException { \nfinal int end = start + length ; \nint count = 0 ; \nfor ( int i = start ; \ni < end ; \ni ++ ) { \nfinal int code = ( int ) s . charAt ( i ) ; \nif ( code >= 0x01 && code <= 0x7F ) { \nwriteByte ( ( byte ) code ) ; \ncount ++ ; \n} \nelse { \nif ( ( ( code >= 0x80 ) && ( code <= 0x7FF ) ) || code == 0 ) { \nwriteByte ( ( byte ) ( 0xC0 | ( code >> 6 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 2 ; \n} \nelse { \nwriteByte ( ( byte ) ( 0xE0 | ( code >>> 12 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( ( code >> 6 ) & 0x3F ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 3 ; \n} \n} \n} \nreturn count ; \n} \n} \n"}
{"5196": "public class VlenIO { \npublic void readChars ( char [ ] buffer , int start , int length ) throws IOException { \nfinal int end = start + length ; \nfor ( int i = start ; \ni < end ; \ni ++ ) { \nbyte b = readByte ( ) ; \nif ( ( b & 0x80 ) == 0 ) buffer [ i ] = ( char ) ( b & 0x7F ) ; \nelse { \nif ( ( b & 0xE0 ) != 0xE0 ) { \nbuffer [ i ] = ( char ) ( ( ( b & 0x1F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \nelse buffer [ i ] = ( char ) ( ( ( b & 0x0F ) << 12 ) | ( ( readByte ( ) & 0x3F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \n} \n} \n} \n"}
{"5238": "public class ParsedSectionSpec { \nprivate static ParsedSectionSpec parseVariableSelector ( Object parent , String selector ) throws InvalidRangeException { \nString varNameEsc , indexSelect = null ; \nint pos1 = EscapeStrings . indexOf ( selector , '(' ) ; \nif ( pos1 < 0 ) { \nvarNameEsc = selector ; \n} \nelse { \nvarNameEsc = selector . substring ( 0 , pos1 ) ; \nint pos2 = selector . indexOf ( ')' , pos1 + 1 ) ; \nindexSelect = selector . substring ( pos1 , pos2 ) ; \n} \nif ( debugSelector ) System . out . println ( \" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\" ) ; \nVariable v = null ; \nif ( parent instanceof NetcdfFile ) { \nNetcdfFile ncfile = ( NetcdfFile ) parent ; \nv = ncfile . findVariable ( varNameEsc ) ; \n} \nelse { \nif ( parent instanceof Structure ) { \nStructure s = ( Structure ) parent ; \nv = s . findVariable ( NetcdfFile . makeNameUnescaped ( varNameEsc ) ) ; \n} \n} \nif ( v == null ) throw new IllegalArgumentException ( \" cant find variable: \" + varNameEsc + \" in selector=\" + selector ) ; \nif ( v . getDataType ( ) == DataType . SEQUENCE ) indexSelect = null ; \nSection section ; \nif ( indexSelect != null ) { \nsection = new Section ( indexSelect ) ; \nsection = Section . fill ( section , v . getShape ( ) ) ; \n} \nelse { \nsection = v . getShapeAsSection ( ) ; \n} \nreturn new ParsedSectionSpec ( v , section ) ; \n} \n} \n"}
{"5243": "public class CFpointObs { \nprotected boolean identifyEncodingStation ( NetcdfDataset ds , EncodingInfo info , CF . FeatureType ftype , Formatter errlog ) { \nDimension obsDim = null ; \nif ( info . time . getRank ( ) > 0 ) obsDim = info . time . getDimension ( info . time . getRank ( ) - 1 ) ; \nelse { \nif ( info . time . getParentStructure ( ) != null ) { \nStructure parent = info . time . getParentStructure ( ) ; \nobsDim = parent . getDimension ( parent . getRank ( ) - 1 ) ; \n} \n} \nif ( obsDim == null ) { \nerrlog . format ( \"CFpointObs: must have a non-scalar Time coordinate%n\" ) ; \nreturn false ; \n} \nif ( info . lat . getRank ( ) == 0 ) { \ninfo . set ( Encoding . single , null , obsDim ) ; \nreturn true ; \n} \nDimension stnDim = info . lat . getDimension ( 0 ) ; \nif ( obsDim == stnDim ) { \ninfo . set ( Encoding . flat , null , obsDim ) ; \nreturn true ; \n} \nif ( identifyRaggeds ( ds , info , stnDim , obsDim , errlog ) ) return true ; \nif ( info . lat . getRank ( ) == 1 ) { \ninfo . set ( Encoding . multidim , stnDim , obsDim ) ; \nreturn true ; \n} \nerrlog . format ( \"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\" , ftype ) ; \nreturn false ; \n} \n} \n"}
{"5247": "public class ProgressMonitor { \npublic void start ( java . awt . Component top , String taskName , int progressMaxCount ) { \npm = new javax . swing . ProgressMonitor ( top , taskName , \"\" , 0 , progressMaxCount ) ; \npm . setMillisToDecideToPopup ( millisToDecideToPopup ) ; \npm . setMillisToPopup ( millisToPopup ) ; \ntaskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nsecs ++ ; \nif ( pm . isCanceled ( ) ) { \ntask . cancel ( ) ; \n} \nelse { \nString note = task . getNote ( ) ; \npm . setNote ( note == null ? secs + \" secs\" : note ) ; \nint progress = task . getProgress ( ) ; \npm . setProgress ( progress <= 0 ? secs : progress ) ; \n} \nif ( task . isDone ( ) ) { \ntimer . stop ( ) ; \npm . close ( ) ; \nif ( task . isError ( ) ) { \njavax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \n} \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse { \nif ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse { \nif ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \n} \n} \n} \n} \n} \n; \ntimer = new javax . swing . Timer ( 1000 , watcher ) ; \ntimer . start ( ) ; \n} \n} \n"}
{"5282": "public class N3raf { \nprotected long readData ( Layout index , DataType dataType , WritableByteChannel out ) throws java . io . IOException { \nlong count = 0 ; \nif ( dataType . getPrimitiveClassType ( ) == byte . class || dataType == DataType . CHAR ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , chunk . getNelems ( ) ) ; \n} \n} \nelse { \nif ( dataType . getPrimitiveClassType ( ) == short . class ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 2 * chunk . getNelems ( ) ) ; \n} \n} \nelse { \nif ( dataType . getPrimitiveClassType ( ) == int . class || ( dataType == DataType . FLOAT ) ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 4 * chunk . getNelems ( ) ) ; \n} \n} \nelse { \nif ( ( dataType == DataType . DOUBLE ) || dataType . getPrimitiveClassType ( ) == long . class ) { \nwhile ( index . hasNext ( ) ) { \nLayout . Chunk chunk = index . next ( ) ; \ncount += raf . readToByteChannel ( out , chunk . getSrcPos ( ) , 8 * chunk . getNelems ( ) ) ; \n} \n} \n} \n} \n} \nreturn count ; \n} \n} \n"}
{"5332": "public class FeatureDatasetCapabilitiesWriter { \npublic Document makeStationCollectionDocument ( LatLonRect bb , String [ ] names ) throws IOException { \nList < DsgFeatureCollection > list = fdp . getPointFeatureCollectionList ( ) ; \nDsgFeatureCollection fc = list . get ( 0 ) ; \nif ( ! ( fc instanceof StationTimeSeriesFeatureCollection ) ) { \nthrow new UnsupportedOperationException ( fc . getClass ( ) . getName ( ) + \" not a StationTimeSeriesFeatureCollection\" ) ; \n} \nStationTimeSeriesFeatureCollection sobs = ( StationTimeSeriesFeatureCollection ) fc ; \nElement rootElem = new Element ( \"stationCollection\" ) ; \nDocument doc = new Document ( rootElem ) ; \nList < StationFeature > stations ; \nif ( bb != null ) stations = sobs . getStationFeatures ( bb ) ; \nelse { \nif ( names != null ) stations = sobs . getStationFeatures ( Arrays . asList ( names ) ) ; \nelse stations = sobs . getStationFeatures ( ) ; \n} \nfor ( Station s : stations ) { \nElement sElem = new Element ( \"station\" ) ; \nsElem . setAttribute ( \"name\" , s . getName ( ) ) ; \nif ( s . getWmoId ( ) != null ) sElem . setAttribute ( \"wmo_id\" , s . getWmoId ( ) ) ; \nif ( ( s . getDescription ( ) != null ) && ( s . getDescription ( ) . length ( ) > 0 ) ) sElem . addContent ( new Element ( \"description\" ) . addContent ( s . getDescription ( ) ) ) ; \nsElem . addContent ( new Element ( \"longitude\" ) . addContent ( Double . toString ( s . getLongitude ( ) ) ) ) ; \nsElem . addContent ( new Element ( \"latitide\" ) . addContent ( Double . toString ( s . getLatitude ( ) ) ) ) ; \nif ( ! Double . isNaN ( s . getAltitude ( ) ) ) sElem . addContent ( new Element ( \"altitude\" ) . addContent ( Double . toString ( s . getAltitude ( ) ) ) ) ; \nrootElem . addContent ( sElem ) ; \n} \nreturn doc ; \n} \n} \n"}
{"5371": "public class StringUtil2 { \nstatic public String makeValidCdmObjectName ( String name ) { \nname = name . trim ( ) ; \nboolean ok = true ; \nfor ( int i = 0 ; \ni < name . length ( ) ; \ni ++ ) { \nint c = name . charAt ( i ) ; \nif ( c < 0x20 ) ok = false ; \nif ( c == '/' ) ok = false ; \nif ( c == ' ' ) ok = false ; \nif ( ! ok ) break ; \n} \nif ( ok ) return name ; \nStringBuilder sbuff = new StringBuilder ( name . length ( ) ) ; \nfor ( int i = 0 , len = name . length ( ) ; \ni < len ; \ni ++ ) { \nint c = name . charAt ( i ) ; \nif ( ( c == '/' ) || ( c == ' ' ) ) sbuff . append ( '_' ) ; \nelse { \nif ( c >= 0x20 ) sbuff . append ( ( char ) c ) ; \n} \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"5406": "public class GradsUtil { \npublic static double [ ] getGaussianLatitudes ( String type , int start , int num ) throws IllegalArgumentException { \ndouble [ ] baseArray = null ; \nstart -- ; \nif ( type . equalsIgnoreCase ( GAUST62 ) ) { \nbaseArray = gltst62 ; \n} \nelse { \nif ( type . equalsIgnoreCase ( GAUSR15 ) ) { \nbaseArray = glts15 ; \n} \nelse { \nif ( type . equalsIgnoreCase ( GAUSR20 ) ) { \nbaseArray = glts20 ; \n} \nelse { \nif ( type . equalsIgnoreCase ( GAUSR30 ) ) { \nbaseArray = glts30 ; \n} \nelse { \nif ( type . equalsIgnoreCase ( GAUSR40 ) ) { \nbaseArray = glats ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Unsupported type: \" + type ) ; \n} \n} \n} \n} \n} \nif ( start + num > baseArray . length ) { \nthrow new IllegalArgumentException ( \"Maximum \" + baseArray . length + \" latitudes exceeded\" ) ; \n} \ndouble [ ] retVals = new double [ num ] ; \nfor ( int i = 0 ; \ni < num ; \ni ++ ) { \nretVals [ i ] = baseArray [ start + i ] ; \n} \nreturn retVals ; \n} \n} \n"}
{"5434": "public class GribCdmIndex { \npublic static boolean updateGribCollection ( FeatureCollectionConfig config , CollectionUpdateType updateType , Logger logger ) throws IOException { \nif ( logger == null ) logger = classLogger ; \nlong start = System . currentTimeMillis ( ) ; \nFormatter errlog = new Formatter ( ) ; \nCollectionSpecParser specp = config . getCollectionSpecParser ( errlog ) ; \nPath rootPath = Paths . get ( specp . getRootDir ( ) ) ; \nboolean isGrib1 = config . type == FeatureCollectionType . GRIB1 ; \nboolean changed ; \nif ( config . ptype == FeatureCollectionConfig . PartitionType . none || config . ptype == FeatureCollectionConfig . PartitionType . all ) { \ntry ( CollectionAbstract dcm = new CollectionPathMatcher ( config , specp , logger ) ) { \nchanged = updateGribCollection ( isGrib1 , dcm , updateType , FeatureCollectionConfig . PartitionType . none , logger , errlog ) ; \n} \n} \nelse { \nif ( config . ptype == FeatureCollectionConfig . PartitionType . timePeriod ) { \ntry ( TimePartition tp = new TimePartition ( config , specp , logger ) ) { \nchanged = updateTimePartition ( isGrib1 , tp , updateType , logger ) ; \n} \n} \nelse { \nif ( specp . wantSubdirs ( ) ) { \ntry ( DirectoryPartition dpart = new DirectoryPartition ( config , rootPath , true , new GribCdmIndex ( logger ) , NCX_SUFFIX , logger ) ) { \ndpart . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , config ) ; \nchanged = updateDirectoryCollectionRecurse ( isGrib1 , dpart , config , updateType , logger ) ; \n} \n} \nelse { \nchanged = updateLeafCollection ( isGrib1 , config , updateType , true , logger , rootPath ) ; \n} \n} \n} \nlong took = System . currentTimeMillis ( ) - start ; \nlogger . info ( \"updateGribCollection {} changed {} took {} msecs\" , config . collectionName , changed , took ) ; \nreturn changed ; \n} \n} \n"}
{"5449": "public class GisFeatureRendererMulti { \nprivate ArrayList makeShapes ( Iterator featList ) { \nShape shape ; \nArrayList shapeList = new ArrayList ( ) ; \nProjectionImpl dataProject = getDataProjection ( ) ; \nif ( Debug . isSet ( \"GisFeature/MapDraw\" ) ) { \nSystem . out . println ( \"GisFeature/MapDraw: makeShapes with \" + displayProject ) ; \n} \nwhile ( featList . hasNext ( ) ) { \nAbstractGisFeature feature = ( AbstractGisFeature ) featList . next ( ) ; \nif ( dataProject . isLatLon ( ) ) shape = feature . getProjectedShape ( displayProject ) ; \nelse { \nif ( dataProject == displayProject ) shape = feature . getShape ( ) ; \nelse shape = feature . getProjectedShape ( dataProject , displayProject ) ; \n} \nshapeList . add ( shape ) ; \n} \nreturn shapeList ; \n} \n} \n"}
{"5451": "public class StopButton { \npublic boolean startProgressMonitorTask ( ProgressMonitorTask pmt ) { \nif ( busy ) return false ; \nbusy = true ; \nthis . task = pmt ; \nisCancelled = false ; \ncount = 0 ; \nsetIcon ( icon [ 0 ] ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nif ( isCancelled && ! task . isCancel ( ) ) { \ntask . cancel ( ) ; \nif ( debug ) System . out . println ( \" task.cancel\" ) ; \nreturn ; \n} \nelse { \ncount ++ ; \nsetIcon ( icon [ count % 2 ] ) ; \nif ( debug ) System . out . println ( \" stop count=\" + count ) ; \n} \nif ( task . isDone ( ) ) { \nif ( myTimer != null ) myTimer . stop ( ) ; \nmyTimer = null ; \nif ( task . isError ( ) ) javax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse { \nif ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse { \nif ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \n} \n} \nbusy = false ; \n} \n} \n} \n; \nmyTimer = new javax . swing . Timer ( 1000 , watcher ) ; \nmyTimer . start ( ) ; \nThread taskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nreturn true ; \n} \n} \n"}
{"5457": "public class ArrayStructure { \npublic Object getScalarObject ( int recno , StructureMembers . Member m ) { \nDataType dataType = m . getDataType ( ) ; \nif ( dataType == DataType . DOUBLE ) { \nreturn getScalarDouble ( recno , m ) ; \n} \nelse { \nif ( dataType == DataType . FLOAT ) { \nreturn getScalarFloat ( recno , m ) ; \n} \nelse { \nif ( dataType . getPrimitiveClassType ( ) == byte . class ) { \nreturn getScalarByte ( recno , m ) ; \n} \nelse { \nif ( dataType . getPrimitiveClassType ( ) == short . class ) { \nreturn getScalarShort ( recno , m ) ; \n} \nelse { \nif ( dataType . getPrimitiveClassType ( ) == int . class ) { \nreturn getScalarInt ( recno , m ) ; \n} \nelse { \nif ( dataType . getPrimitiveClassType ( ) == long . class ) { \nreturn getScalarLong ( recno , m ) ; \n} \nelse { \nif ( dataType == DataType . CHAR ) { \nreturn getScalarString ( recno , m ) ; \n} \nelse { \nif ( dataType == DataType . STRING ) { \nreturn getScalarString ( recno , m ) ; \n} \nelse { \nif ( dataType == DataType . STRUCTURE ) { \nreturn getScalarStructure ( recno , m ) ; \n} \nelse { \nif ( dataType == DataType . OPAQUE ) { \nArrayObject data = ( ArrayObject ) m . getDataArray ( ) ; \nreturn data . getObject ( recno * m . getSize ( ) ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \nthrow new RuntimeException ( \"Dont have implementation for \" + dataType ) ; \n} \n} \n"}
{"5491": "public class DDSXMLParser { \nprivate void parseBase ( Element e , String indent ) throws DASException , NoSuchTypeException , BadSemanticsException { \nparseLevel ++ ; \nString type = e . getName ( ) ; \nif ( type . equals ( \"Attribute\" ) ) { \n} \nelse { \nif ( type . equals ( \"Alias\" ) ) { \n} \nelse { \nif ( type . equals ( \"dataBLOB\" ) ) { \norg . jdom2 . Attribute hrefAttr = e . getAttribute ( \"href\" ) ; \nString contentID = hrefAttr . getValue ( ) ; \nif ( _Debug ) System . out . println ( \"Found dataBLOB element. contentID=\\\"\" + contentID + \"\\\"\" ) ; \ndds . setBlobContentID ( contentID ) ; \n} \nelse { \nif ( _Debug ) System . out . println ( \"Parsing new BaseType element. Parse level: \" + parseLevel ) ; \nif ( _Debug ) showXMLElement ( e , indent ) ; \nBaseType bt = newBaseType ( e ) ; \nparentDC . addVariable ( bt ) ; \nif ( bt instanceof DConstructor ) { \nDConstructor myParentDC = parentDC ; \nparentDC = ( DConstructor ) bt ; \ntry { \nif ( bt instanceof DGrid ) { \nparseGrid ( e , indent ) ; \n} \nelse { \nfor ( Element child : e . getChildren ( ) ) { \nparseBase ( child , indent + \"    \" ) ; \n} \n} \n} \nfinally { \nparentDC = myParentDC ; \n} \n} \nelse { \nif ( bt instanceof DArray ) { \nif ( _Debug ) System . out . println ( \"Parsing Array instance.  Array name: '\" + bt . getClearName ( ) + \"'\" ) ; \nparseArray ( e , ( DArray ) bt , indent ) ; \n} \n} \n} \n} \n} \nparseLevel -- ; \n} \n} \n"}
{"5495": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { \nList < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; \nIterator < DataDescriptor > dkIter = keys . iterator ( ) ; \nwhile ( dkIter . hasNext ( ) ) { \nDataDescriptor dk = dkIter . next ( ) ; \nif ( dk . f == 1 ) { \ndk . subKeys = new ArrayList < DataDescriptor > ( ) ; \ndk . replication = dk . y ; \nif ( dk . replication == 0 ) { \nroot . isVarLength = true ; \nDataDescriptor replication = dkIter . next ( ) ; \nif ( replication . y == 0 ) dk . replicationCountSize = 1 ; \nelse { \nif ( replication . y == 1 ) dk . replicationCountSize = 8 ; \nelse { \nif ( replication . y == 2 ) dk . replicationCountSize = 16 ; \nelse { \nif ( replication . y == 11 ) dk . repetitionCountSize = 8 ; \nelse { \nif ( replication . y == 12 ) dk . repetitionCountSize = 16 ; \nelse log . error ( \"Unknown replication type= \" + replication ) ; \n} \n} \n} \n} \n} \nfor ( int j = 0 ; \nj < dk . x && dkIter . hasNext ( ) ; \nj ++ ) { \ndk . subKeys . add ( dkIter . next ( ) ) ; \n} \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \nelse { \nif ( ( dk . f == 3 ) && ( dk . subKeys != null ) ) { \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \n} \ntree . add ( dk ) ; \n} \nreturn tree ; \n} \n} \n"}
{"5509": "public class Attribute { \nprotected void writeCDL ( Formatter f , boolean strict , String parentname ) { \nif ( strict && ( isString ( ) || this . getEnumType ( ) != null ) ) f . format ( \"string \" ) ; \nif ( strict && parentname != null ) f . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; \nf . format ( \":\" ) ; \nf . format ( \"%s\" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; \nif ( isString ( ) ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nString val = getStringValue ( i ) ; \nif ( val != null ) f . format ( \"\\\"%s\\\"\" , encodeString ( val ) ) ; \n} \n} \nelse { \nif ( getEnumType ( ) != null ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nEnumTypedef en = getEnumType ( ) ; \nString econst = getStringValue ( i ) ; \nInteger ecint = en . lookupEnumInt ( econst ) ; \nif ( ecint == null ) throw new ForbiddenConversionException ( \"Illegal enum constant: \" + econst ) ; \nf . format ( \"\\\"%s\\\"\" , encodeString ( econst ) ) ; \n} \n} \nelse { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ni < getLength ( ) ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nNumber number = getNumericValue ( i ) ; \nif ( dataType . isUnsigned ( ) ) { \nnumber = DataType . widenNumber ( number ) ; \n} \nf . format ( \"%s\" , number ) ; \nif ( dataType . isUnsigned ( ) ) { \nf . format ( \"U\" ) ; \n} \nif ( dataType == DataType . FLOAT ) f . format ( \"f\" ) ; \nelse { \nif ( dataType == DataType . SHORT || dataType == DataType . USHORT ) { \nf . format ( \"S\" ) ; \n} \nelse { \nif ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) { \nf . format ( \"B\" ) ; \n} \nelse { \nif ( dataType == DataType . LONG || dataType == DataType . ULONG ) { \nf . format ( \"L\" ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"5511": "public class Attribute { \npublic void setValues ( List values ) { \nif ( values == null || values . size ( ) == 0 ) throw new IllegalArgumentException ( \"Cannot determine attribute's type\" ) ; \nint n = values . size ( ) ; \nClass c = values . get ( 0 ) . getClass ( ) ; \nObject pa ; \nif ( c == String . class ) { \nString [ ] va = new String [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( String ) values . get ( i ) ; \n} \nelse { \nif ( c == Integer . class ) { \nint [ ] va = new int [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Integer ) values . get ( i ) ; \n} \nelse { \nif ( c == Double . class ) { \ndouble [ ] va = new double [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Double ) values . get ( i ) ; \n} \nelse { \nif ( c == Float . class ) { \nfloat [ ] va = new float [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Float ) values . get ( i ) ; \n} \nelse { \nif ( c == Short . class ) { \nshort [ ] va = new short [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Short ) values . get ( i ) ; \n} \nelse { \nif ( c == Byte . class ) { \nbyte [ ] va = new byte [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Byte ) values . get ( i ) ; \n} \nelse { \nif ( c == Long . class ) { \nlong [ ] va = new long [ n ] ; \npa = va ; \nfor ( int i = 0 ; \ni < n ; \ni ++ ) va [ i ] = ( Long ) values . get ( i ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Unknown type for Attribute = \" + c . getName ( ) ) ; \n} \n} \n} \n} \n} \n} \n} \nsetValues ( Array . factory ( this . dataType , new int [ ] { \nn } \n, pa ) ) ; \n} \n} \n"}
{"5518": "public class ToolsUI { \nprivate void jumptoThreddsDatatype ( DataFactory . Result threddsData ) { \nif ( threddsData . fatalError ) { \nJOptionPane . showMessageDialog ( this , \"Cant open dataset=\" + threddsData . errLog ) ; \ntry { \nthreddsData . close ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn ; \n} \nif ( threddsData . featureType . isCoverageFeatureType ( ) ) { \nif ( threddsData . featureDataset instanceof FeatureDatasetCoverage ) { \nmakeComponent ( ftTabPane , \"Coverages\" ) ; \ncoveragePanel . setDataset ( threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( coveragePanel ) ; \n} \nelse { \nif ( threddsData . featureDataset instanceof GridDataset ) { \nmakeComponent ( ftTabPane , \"Grids\" ) ; \ngridPanel . setDataset ( ( GridDataset ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( gridPanel ) ; \n} \n} \n} \nelse { \nif ( threddsData . featureType == FeatureType . IMAGE ) { \nmakeComponent ( ftTabPane , \"Images\" ) ; \nimagePanel . setImageLocation ( threddsData . imageURL ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( imagePanel ) ; \n} \nelse { \nif ( threddsData . featureType == FeatureType . RADIAL ) { \nmakeComponent ( ftTabPane , \"Radial\" ) ; \nradialPanel . setDataset ( ( RadialDatasetSweep ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( radialPanel ) ; \n} \nelse { \nif ( threddsData . featureType . isPointFeatureType ( ) ) { \nmakeComponent ( ftTabPane , \"PointFeature\" ) ; \npointFeaturePanel . setPointFeatureDataset ( ( PointDatasetImpl ) threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( pointFeaturePanel ) ; \n} \nelse { \nif ( threddsData . featureType == FeatureType . STATION_RADIAL ) { \nmakeComponent ( ftTabPane , \"StationRadial\" ) ; \nstationRadialPanel . setStationRadialDataset ( threddsData . featureDataset ) ; \ntabbedPane . setSelectedComponent ( ftTabPane ) ; \nftTabPane . setSelectedComponent ( stationRadialPanel ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"5565": "public class CatalogCrawler { \npublic void crawlDirectDatasets ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \nreturn ; \n} \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nList < InvDataset > leaves = new ArrayList < InvDataset > ( ) ; \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasAccess ( ) ) leaves . add ( dds ) ; \n} \nif ( leaves . size ( ) > 0 ) { \nif ( type == Type . first_direct ) { \nInvDataset dds = leaves . get ( 0 ) ; \nlisten . getDataset ( dds , context ) ; \n} \nelse { \nif ( type == Type . random_direct ) { \nlisten . getDataset ( chooseRandom ( leaves ) , context ) ; \n} \nelse { \nif ( type == Type . random_direct_middle ) { \nlisten . getDataset ( chooseRandomNotFirstOrLast ( leaves ) , context ) ; \n} \nelse { \nfor ( InvDataset dds : leaves ) { \nlisten . getDataset ( dds , context ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \n} \n} \n} \n} \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasNestedDatasets ( ) ) crawlDirectDatasets ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nif ( ds instanceof InvCatalogRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n"}
{"5573": "public class RandomAccessFile { \npublic int read ( ) throws IOException { \nif ( filePosition < dataEnd ) { \nint pos = ( int ) ( filePosition - bufferStart ) ; \nfilePosition ++ ; \nreturn ( buffer [ pos ] & 0xff ) ; \n} \nelse { \nif ( endOfFile ) { \nreturn - 1 ; \n} \nelse { \nseek ( filePosition ) ; \nreturn read ( ) ; \n} \n} \n} \n} \n"}
{"5610": "public class GridCoordSys { \n@ Override public int [ ] findXYindexFromCoord ( double x_coord , double y_coord , int [ ] result ) { \nif ( result == null ) result = new int [ 2 ] ; \nif ( ( horizXaxis instanceof CoordinateAxis1D ) && ( horizYaxis instanceof CoordinateAxis1D ) ) { \nresult [ 0 ] = ( ( CoordinateAxis1D ) horizXaxis ) . findCoordElement ( x_coord ) ; \nresult [ 1 ] = ( ( CoordinateAxis1D ) horizYaxis ) . findCoordElement ( y_coord ) ; \nreturn result ; \n} \nelse { \nif ( ( horizXaxis instanceof CoordinateAxis2D ) && ( horizYaxis instanceof CoordinateAxis2D ) ) { \nif ( g2d == null ) g2d = new GridCoordinate2D ( ( CoordinateAxis2D ) horizYaxis , ( CoordinateAxis2D ) horizXaxis ) ; \nint [ ] result2 = new int [ 2 ] ; \nboolean found = g2d . findCoordElement ( y_coord , x_coord , result2 ) ; \nif ( found ) { \nresult [ 0 ] = result2 [ 1 ] ; \nresult [ 1 ] = result2 [ 0 ] ; \n} \nelse { \nresult [ 0 ] = - 1 ; \nresult [ 1 ] = - 1 ; \n} \nreturn result ; \n} \n} \nthrow new IllegalStateException ( \"GridCoordSystem.findXYindexFromCoord\" ) ; \n} \n} \n"}
{"5611": "public class GridCoordSys { \n@ Override public int [ ] findXYindexFromCoordBounded ( double x_coord , double y_coord , int [ ] result ) { \nif ( result == null ) result = new int [ 2 ] ; \nif ( ( horizXaxis instanceof CoordinateAxis1D ) && ( horizYaxis instanceof CoordinateAxis1D ) ) { \nresult [ 0 ] = ( ( CoordinateAxis1D ) horizXaxis ) . findCoordElementBounded ( x_coord ) ; \nresult [ 1 ] = ( ( CoordinateAxis1D ) horizYaxis ) . findCoordElementBounded ( y_coord ) ; \nreturn result ; \n} \nelse { \nif ( ( horizXaxis instanceof CoordinateAxis2D ) && ( horizYaxis instanceof CoordinateAxis2D ) ) { \nif ( g2d == null ) g2d = new GridCoordinate2D ( ( CoordinateAxis2D ) horizYaxis , ( CoordinateAxis2D ) horizXaxis ) ; \nint [ ] result2 = new int [ 2 ] ; \ng2d . findCoordElement ( y_coord , x_coord , result2 ) ; \nresult [ 0 ] = result2 [ 1 ] ; \nresult [ 1 ] = result2 [ 0 ] ; \nreturn result ; \n} \n} \nthrow new IllegalStateException ( \"GridCoordSystem.findXYindexFromCoord\" ) ; \n} \n} \n"}
{"5614": "public class MyTextField { \nprotected int getItemPos ( ) { \nif ( nitems < 1 ) return - arrow_size ; \nelse { \nif ( nitems == 1 ) return b . width / 2 ; \n} \nint item = table . getSelectedRowIndex ( ) ; \nint eff_width = b . width - 2 * arrow_size ; \nint pixel = ( item * eff_width ) / ( nitems - 1 ) ; \nreturn pixel + arrow_size ; \n} \n} \n"}
{"5621": "public class CalendarPeriod { \npublic static CalendarPeriod of ( String udunit ) { \nint value ; \nString units ; \nString [ ] split = StringUtil2 . splitString ( udunit ) ; \nif ( split . length == 1 ) { \nvalue = 1 ; \nunits = split [ 0 ] ; \n} \nelse { \nif ( split . length == 2 ) { \ntry { \nvalue = Integer . parseInt ( split [ 0 ] ) ; \n} \ncatch ( Throwable t ) { \nreturn null ; \n} \nunits = split [ 1 ] ; \n} \nelse return null ; \n} \nCalendarPeriod . Field unit = CalendarPeriod . fromUnitString ( units ) ; \nreturn CalendarPeriod . of ( value , unit ) ; \n} \n} \n"}
{"5624": "public class CalendarPeriod { \npublic double getValueInMillisecs ( ) { \nif ( field == CalendarPeriod . Field . Month ) return 30.0 * 24.0 * 60.0 * 60.0 * 1000.0 * value ; \nelse { \nif ( field == CalendarPeriod . Field . Year ) return 365.0 * 24.0 * 60.0 * 60.0 * 1000.0 * value ; \nelse return millisecs ( ) ; \n} \n} \n} \n"}
{"5642": "public class ThreddsMetadataExtractor { \npublic ThreddsMetadata extract ( Dataset threddsDataset ) throws IOException { \nThreddsMetadata metadata = new ThreddsMetadata ( ) ; \nMap < String , Object > flds = metadata . getFlds ( ) ; \ntry ( DataFactory . Result result = new DataFactory ( ) . openFeatureDataset ( threddsDataset , null ) ) { \nif ( result . fatalError ) { \nlogger . warn ( \" openFeatureDataset failed, errs=%s%n\" , result . errLog ) ; \nreturn null ; \n} \nif ( result . featureType . isCoverageFeatureType ( ) ) { \nGridDataset gridDataset = ( GridDataset ) result . featureDataset ; \nflds . put ( Dataset . GeospatialCoverage , extractGeospatial ( gridDataset ) ) ; \nCalendarDateRange tc = extractCalendarDateRange ( gridDataset ) ; \nif ( tc != null ) flds . put ( Dataset . TimeCoverage , tc ) ; \nThreddsMetadata . VariableGroup vars = extractVariables ( threddsDataset . getDataFormatName ( ) , gridDataset ) ; \nif ( vars != null ) flds . put ( Dataset . VariableGroups , vars ) ; \n} \nelse { \nif ( result . featureType . isPointFeatureType ( ) ) { \nPointDatasetImpl pobsDataset = ( PointDatasetImpl ) result . featureDataset ; \nLatLonRect llbb = pobsDataset . getBoundingBox ( ) ; \nif ( null != llbb ) flds . put ( Dataset . GeospatialCoverage , new ThreddsMetadata . GeospatialCoverage ( llbb , null , 0.0 , 0.0 ) ) ; \nCalendarDateRange tc = extractCalendarDateRange ( pobsDataset ) ; \nif ( tc != null ) flds . put ( Dataset . TimeCoverage , tc ) ; \nThreddsMetadata . VariableGroup vars = extractVariables ( pobsDataset ) ; \nif ( vars != null ) flds . put ( Dataset . VariableGroups , vars ) ; \n} \n} \n} \ncatch ( IOException ioe ) { \nlogger . error ( \"Error opening dataset \" + threddsDataset . getName ( ) , ioe ) ; \n} \nreturn metadata ; \n} \n} \n"}
{"5647": "public class ConvertD2N { \npublic Array convertTopVariable ( ucar . nc2 . Variable v , List < Range > section , DodsV dataV ) throws IOException , DAP2Exception { \nArray data = convert ( dataV ) ; \nif ( ( dataV . darray != null ) && ( dataV . bt instanceof DString ) ) { \nif ( v . getDataType ( ) == DataType . STRING ) return convertStringArray ( data , v ) ; \nelse { \nif ( v . getDataType ( ) == DataType . CHAR ) return convertStringArrayToChar ( dataV . darray , v , section ) ; \nelse { \nString mess = \"DODSVariable convertArray String invalid dataType= \" + v . getDataType ( ) ; \nlogger . error ( mess ) ; \nthrow new IllegalArgumentException ( mess ) ; \n} \n} \n} \nif ( ( dataV . bt instanceof DString ) && ( v . getDataType ( ) == DataType . CHAR ) ) { \nreturn convertStringToChar ( data , v ) ; \n} \nreturn data ; \n} \n} \n"}
{"5648": "public class ConvertD2N { \npublic Array convert ( DodsV dataV ) throws IOException , DAP2Exception { \nif ( dataV . darray == null ) { \nif ( dataV . bt instanceof DStructure ) { \nArrayStructure structArray = makeArrayStructure ( dataV ) ; \niconvertDataStructure ( ( DStructure ) dataV . bt , structArray . getStructureMembers ( ) ) ; \nreturn structArray ; \n} \nelse { \nif ( dataV . bt instanceof DGrid ) { \nthrow new IllegalStateException ( \"DGrid without a darray\" ) ; \n} \nelse { \nif ( dataV . bt instanceof DSequence ) { \nArrayStructure structArray = makeArrayStructure ( dataV ) ; \niconvertDataSequenceArray ( ( DSequence ) dataV . bt , structArray . getStructureMembers ( ) ) ; \nreturn structArray ; \n} \nelse { \nDataType dtype = dataV . getDataType ( ) ; \nArray scalarData = Array . factory ( dtype , new int [ 0 ] ) ; \nIndexIterator scalarIndex = scalarData . getIndexIterator ( ) ; \niconvertDataPrimitiveScalar ( dataV . bt , scalarIndex ) ; \nreturn scalarData ; \n} \n} \n} \n} \nif ( dataV . darray != null ) { \nif ( dataV . bt instanceof DStructure ) { \nArrayStructure structArray = makeArrayStructure ( dataV ) ; \niconvertDataStructureArray ( dataV . darray , structArray . getStructureMembers ( ) ) ; \nreturn structArray ; \n} \nelse { \nif ( dataV . bt instanceof DString ) { \nreturn convertStringArray ( dataV . darray ) ; \n} \nelse { \nopendap . dap . PrimitiveVector pv = dataV . darray . getPrimitiveVector ( ) ; \nObject storage = pv . getInternalStorage ( ) ; \nDataType dtype = dataV . getDataType ( ) ; \nreturn Array . factory ( dtype , makeShape ( dataV . darray ) , storage ) ; \n} \n} \n} \nString mess = \"Unknown baseType \" + dataV . bt . getClass ( ) . getName ( ) + \" name=\" + dataV . getEncodedName ( ) ; \nlogger . error ( mess ) ; \nthrow new IllegalStateException ( mess ) ; \n} \n} \n"}
{"5691": "public class CoordinateAxis { \nstatic public CoordinateAxis factory ( NetcdfDataset ncd , VariableDS vds ) { \nif ( ( vds . getRank ( ) == 0 ) || ( vds . getRank ( ) == 1 ) || ( vds . getRank ( ) == 2 && vds . getDataType ( ) == DataType . CHAR ) ) { \nreturn new CoordinateAxis1D ( ncd , vds ) ; \n} \nelse { \nif ( vds . getRank ( ) == 2 ) return new CoordinateAxis2D ( ncd , vds ) ; \nelse return new CoordinateAxis ( ncd , vds ) ; \n} \n} \n} \n"}
{"5698": "public class JTableSorted { \npublic void incrSelected ( boolean increment ) { \nif ( list . size ( ) == 0 ) return ; \nint curr = jtable . getSelectedRow ( ) ; \nif ( increment && ( curr < list . size ( ) - 1 ) ) setSelected ( curr + 1 ) ; \nelse { \nif ( ! increment && ( curr > 0 ) ) setSelected ( curr - 1 ) ; \n} \n} \n} \n"}
{"5750": "public class AbstractCursor { \n@ Override public int fieldIndex ( String name ) throws DapException { \nDapStructure ds ; \nif ( getTemplate ( ) . getSort ( ) . isCompound ( ) ) ds = ( DapStructure ) getTemplate ( ) ; \nelse { \nif ( getTemplate ( ) . getSort ( ) . isVar ( ) && ( ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) . getSort ( ) . isCompound ( ) ) ) ds = ( DapStructure ) ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) ; \nelse throw new DapException ( \"Attempt to get field name on non-compound object\" ) ; \n} \nint i = ds . indexByName ( name ) ; \nif ( i < 0 ) throw new DapException ( \"Unknown field name: \" + name ) ; \nreturn i ; \n} \n} \n"}
{"5782": "public class NetcdfFile { \npublic Object sendIospMessage ( Object message ) { \nif ( null == message ) return null ; \nif ( message == IOSP_MESSAGE_ADD_RECORD_STRUCTURE ) { \nVariable v = rootGroup . findVariable ( \"record\" ) ; \nboolean gotit = ( v != null ) && ( v instanceof Structure ) ; \nreturn gotit || makeRecordStructure ( ) ; \n} \nelse { \nif ( message == IOSP_MESSAGE_REMOVE_RECORD_STRUCTURE ) { \nVariable v = rootGroup . findVariable ( \"record\" ) ; \nboolean gotit = ( v != null ) && ( v instanceof Structure ) ; \nif ( gotit ) { \nrootGroup . remove ( v ) ; \nvariables . remove ( v ) ; \nremoveRecordStructure ( ) ; \n} \nreturn ( gotit ) ; \n} \n} \nif ( spi != null ) return spi . sendIospMessage ( message ) ; \nreturn null ; \n} \n} \n"}
{"5808": "public class StringValidateEncodeUtils { \n@ SuppressWarnings ( { \n\"UnnecessaryContinue\" } \n) public static boolean descendOnlyFilePath ( String path ) { \nString [ ] pathSegments = path . split ( \"/\" ) ; \nint i = 0 ; \nfor ( int indxOrigSegs = 0 ; \nindxOrigSegs < pathSegments . length ; \nindxOrigSegs ++ ) { \nString s = pathSegments [ indxOrigSegs ] ; \nif ( s . equals ( \".\" ) ) continue ; \nelse { \nif ( s . equals ( \"..\" ) ) { \nif ( i == 0 ) return false ; \ni -- ; \n} \nelse { \ni ++ ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"5811": "public class GridDefRecord { \npublic static boolean compare ( GridDefRecord local , GridDefRecord other ) { \njava . util . Set < String > keys = local . getKeys ( ) ; \njava . util . Set < String > okeys = other . getKeys ( ) ; \nif ( keys . size ( ) != okeys . size ( ) ) return false ; \nfor ( String key : keys ) { \nif ( key . equals ( WIND_FLAG ) || key . equals ( RESOLUTION ) || key . equals ( VECTOR_COMPONENT_FLAG ) || key . equals ( GDS_KEY ) ) continue ; \nString val = local . getParam ( key ) ; \nString oval = other . getParam ( key ) ; \nif ( val . matches ( \"^[0-9]+\\\\.[0-9]*\" ) ) { \ndouble d = local . getDouble ( key ) ; \ndouble od = other . getDouble ( key ) ; \nif ( ! Misc . nearlyEquals ( d , od ) ) return false ; \n} \nelse { \nif ( val . matches ( \"^[0-9]+\" ) ) { \nif ( ! val . equals ( oval ) ) return false ; \n} \nelse { \nif ( ! val . equals ( oval ) ) return false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"5821": "public class Cinrad2Record { \npublic float getAzimuth ( ) { \nif ( message_type != 1 ) return - 1.0f ; \nif ( Cinrad2IOServiceProvider . isSC ) return 360.0f * azimuth_ang / 65536.0f ; \nelse { \nif ( Cinrad2IOServiceProvider . isCC ) return 360.0f * azimuth_ang / 512.0f ; \nelse { \nif ( Cinrad2IOServiceProvider . isCC20 ) return azimuth_ang * 0.01f ; \n} \n} \nreturn 180.0f * azimuth_ang / 32768.0f ; \n} \n} \n"}
{"5822": "public class Cinrad2Record { \npublic float getElevation ( ) { \nif ( message_type != 1 ) return - 1.0f ; \nif ( Cinrad2IOServiceProvider . isSC ) return 120.0f * elevation_ang / 65536.0f ; \nelse { \nif ( Cinrad2IOServiceProvider . isCC ) return elevation_ang * 0.01f ; \nelse { \nif ( Cinrad2IOServiceProvider . isCC20 ) return elevation_ang * 0.01f ; \n} \n} \nreturn 180.0f * elevation_ang / 32768.0f ; \n} \n} \n"}
{"5834": "public class Structure { \npublic StructureData readStructure ( int index ) throws IOException , ucar . ma2 . InvalidRangeException { \nSection section = null ; \nif ( getRank ( ) == 1 ) { \nsection = new Section ( ) . appendRange ( index , index ) ; \n} \nelse { \nif ( getRank ( ) > 1 ) { \nIndex ii = Index . factory ( shape ) ; \nii . setCurrentCounter ( index ) ; \nint [ ] origin = ii . getCurrentCounter ( ) ; \nsection = new Section ( ) ; \nfor ( int anOrigin : origin ) section . appendRange ( anOrigin , anOrigin ) ; \n} \n} \nArray dataArray = read ( section ) ; \nArrayStructure data = ( ArrayStructure ) dataArray ; \nreturn data . getStructureData ( 0 ) ; \n} \n} \n"}
{"5864": "public class ListTransformation { \nprivate void initListEvents ( ) { \nthis . listChangeListener = new ListChangeListener < SourceType > ( ) { \n@ Override public void onChanged ( Change < ? extends SourceType > listEvent ) { \nList < TargetType > deleteStaging = new ArrayList < > ( ) ; \nwhile ( listEvent . next ( ) ) { \nif ( listEvent . wasUpdated ( ) ) { \nprocessUpdateEvent ( listEvent ) ; \n} \nelse { \nif ( listEvent . wasReplaced ( ) ) { \nprocessReplaceEvent ( listEvent , deleteStaging ) ; \n} \nelse { \nif ( listEvent . wasAdded ( ) ) { \nprocessAddEvent ( listEvent ) ; \n} \nelse { \nif ( listEvent . wasRemoved ( ) ) { \nprocessRemoveEvent ( listEvent , deleteStaging ) ; \n} \n} \n} \n} \n} \nprocessStagingLists ( deleteStaging ) ; \n} \n} \n; \nmodelListProperty ( ) . addListener ( new WeakListChangeListener < > ( listChangeListener ) ) ; \n} \n} \n"}
{"5890": "public class UserConnection { \npublic TResult query ( UserQuery query ) { \nCursor cursor = null ; \nString [ ] selectionArgs = query . getSelectionArgs ( ) ; \nString sql = query . getSql ( ) ; \nif ( sql != null ) { \ncursor = database . rawQuery ( sql , selectionArgs ) ; \n} \nelse { \nString table = query . getTable ( ) ; \nString [ ] columns = query . getColumns ( ) ; \nString selection = query . getSelection ( ) ; \nString groupBy = query . getGroupBy ( ) ; \nString having = query . getHaving ( ) ; \nString orderBy = query . getOrderBy ( ) ; \nString [ ] columnsAs = query . getColumnsAs ( ) ; \nString limit = query . getLimit ( ) ; \nif ( columnsAs != null && limit != null ) { \ncursor = database . query ( table , columns , columnsAs , selection , selectionArgs , groupBy , having , orderBy , limit ) ; \n} \nelse { \nif ( columnsAs != null ) { \ncursor = database . query ( table , columns , columnsAs , selection , selectionArgs , groupBy , having , orderBy ) ; \n} \nelse { \nif ( limit != null ) { \ncursor = database . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy , limit ) ; \n} \nelse { \ncursor = database . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy ) ; \n} \n} \n} \n} \nTResult result = handleCursor ( cursor , query ) ; \nreturn result ; \n} \n} \n"}
{"5931": "public class TileGenerator { \nprivate void adjustBounds ( BoundingBox boundingBox , int zoom ) { \nif ( googleTiles ) { \nadjustGoogleBounds ( ) ; \n} \nelse { \nif ( projection . isUnit ( Units . DEGREES ) ) { \nadjustGeoPackageBoundsWGS84 ( boundingBox , zoom ) ; \n} \nelse { \nadjustGeoPackageBounds ( boundingBox , zoom ) ; \n} \n} \n} \n} \n"}
{"5999": "public class FeatureTiles { \npublic Bitmap drawTileQueryIndex ( int x , int y , int zoom ) { \nBoundingBox webMercatorBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; \nBitmap bitmap = null ; \nFeatureIndexResults results = queryIndexedFeatures ( webMercatorBoundingBox ) ; \ntry { \nlong tileCount = results . count ( ) ; \nif ( tileCount > 0 ) { \nif ( maxFeaturesPerTile == null || tileCount <= maxFeaturesPerTile . longValue ( ) ) { \nbitmap = drawTile ( zoom , webMercatorBoundingBox , results ) ; \n} \nelse { \nif ( maxFeaturesTileDraw != null ) { \nbitmap = maxFeaturesTileDraw . drawTile ( tileWidth , tileHeight , tileCount , results ) ; \n} \n} \n} \n} \nfinally { \nresults . close ( ) ; \n} \nreturn bitmap ; \n} \n} \n"}
{"6004": "public class FeatureTiles { \npublic Bitmap drawTileQueryAll ( int x , int y , int zoom ) { \nBoundingBox boundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; \nBitmap bitmap = null ; \nFeatureCursor cursor = featureDao . queryForAll ( ) ; \ntry { \nint totalCount = cursor . getCount ( ) ; \nif ( totalCount > 0 ) { \nif ( maxFeaturesPerTile == null || totalCount <= maxFeaturesPerTile ) { \nbitmap = drawTile ( zoom , boundingBox , cursor ) ; \n} \nelse { \nif ( maxFeaturesTileDraw != null ) { \nbitmap = maxFeaturesTileDraw . drawUnindexedTile ( tileWidth , tileHeight , totalCount , cursor ) ; \n} \n} \n} \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn bitmap ; \n} \n} \n"}
{"6063": "public class CoverageDataPngImage { \npublic byte [ ] getImageBytes ( ) { \nbyte [ ] bytes = null ; \nif ( imageBytes != null ) { \nbytes = imageBytes ; \n} \nelse { \nif ( outputStream != null ) { \nbytes = outputStream . toByteArray ( ) ; \n} \n} \nreturn bytes ; \n} \n} \n"}
{"6163": "public class ConverterUtil { \npublic static < E > void startConverters ( Converter < E > head ) { \nConverter < E > c = head ; \nwhile ( c != null ) { \nif ( c instanceof CompositeConverter ) { \nCompositeConverter < E > cc = ( CompositeConverter < E > ) c ; \nConverter < E > childConverter = cc . childConverter ; \nstartConverters ( childConverter ) ; \ncc . start ( ) ; \n} \nelse { \nif ( c instanceof DynamicConverter ) { \nDynamicConverter < E > dc = ( DynamicConverter < E > ) c ; \ndc . start ( ) ; \n} \n} \nc = c . getNext ( ) ; \n} \n} \n} \n"}
{"6171": "public class FileNamePattern { \npublic String toRegexForFixedDate ( Date date ) { \nStringBuilder buf = new StringBuilder ( ) ; \nConverter < Object > p = headTokenConverter ; \nwhile ( p != null ) { \nif ( p instanceof LiteralConverter ) { \nbuf . append ( p . convert ( null ) ) ; \n} \nelse { \nif ( p instanceof IntegerTokenConverter ) { \nbuf . append ( FileFinder . regexEscapePath ( \"(\\\\d+)\" ) ) ; \n} \nelse { \nif ( p instanceof DateTokenConverter ) { \nDateTokenConverter < Object > dtc = ( DateTokenConverter < Object > ) p ; \nif ( dtc . isPrimary ( ) ) { \nbuf . append ( p . convert ( date ) ) ; \n} \nelse { \nbuf . append ( FileFinder . regexEscapePath ( dtc . toRegex ( ) ) ) ; \n} \n} \n} \n} \np = p . getNext ( ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6174": "public class ContextSelectorStaticBinder { \npublic void init ( LoggerContext defaultLoggerContext , Object key ) throws ClassNotFoundException , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { \nif ( this . key == null ) { \nthis . key = key ; \n} \nelse { \nif ( this . key != key ) { \nthrow new IllegalAccessException ( \"Only certain classes can access this method.\" ) ; \n} \n} \nString contextSelectorStr = OptionHelper . getSystemProperty ( ClassicConstants . LOGBACK_CONTEXT_SELECTOR ) ; \nif ( contextSelectorStr == null ) { \ncontextSelector = new DefaultContextSelector ( defaultLoggerContext ) ; \n} \nelse { \nif ( contextSelectorStr . equals ( \"JNDI\" ) ) { \nthrow new RuntimeException ( \"JNDI not supported\" ) ; \n} \nelse { \ncontextSelector = dynamicalContextSelector ( defaultLoggerContext , contextSelectorStr ) ; \n} \n} \n} \n} \n"}
{"6182": "public class ReconfigureOnChangeFilter { \nprivate void updateMaskIfNecessary ( long now ) { \nfinal long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck ; \nlastMaskCheck = now ; \nif ( timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && ( mask < MAX_MASK ) ) { \nmask = ( mask << 1 ) | 1 ; \n} \nelse { \nif ( timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD ) { \nmask = mask >>> 2 ; \n} \n} \n} \n} \n"}
{"6188": "public class LocationUtil { \npublic static URL urlForResource ( String location ) throws MalformedURLException , FileNotFoundException { \nif ( location == null ) { \nthrow new NullPointerException ( \"location is required\" ) ; \n} \nURL url = null ; \nif ( ! location . matches ( SCHEME_PATTERN ) ) { \nurl = Loader . getResourceBySelfClassLoader ( location ) ; \n} \nelse { \nif ( location . startsWith ( CLASSPATH_SCHEME ) ) { \nString path = location . substring ( CLASSPATH_SCHEME . length ( ) ) ; \nif ( path . startsWith ( \"/\" ) ) { \npath = path . substring ( 1 ) ; \n} \nif ( path . length ( ) == 0 ) { \nthrow new MalformedURLException ( \"path is required\" ) ; \n} \nurl = Loader . getResourceBySelfClassLoader ( path ) ; \n} \nelse { \nurl = new URL ( location ) ; \n} \n} \nif ( url == null ) { \nthrow new FileNotFoundException ( location ) ; \n} \nreturn url ; \n} \n} \n"}
{"6215": "public class Introspector { \nstatic public PropertyDescriptor [ ] getPropertyDescriptors ( Class < ? > clazz ) { \nfinal String SETTER_PREFIX = \"set\" ; \nfinal String GETTER_PREFIX = \"get\" ; \nfinal int LEN_PREFIX = SETTER_PREFIX . length ( ) ; \nMap < String , PropertyDescriptor > map = new HashMap < String , PropertyDescriptor > ( ) ; \nfor ( Method m : clazz . getMethods ( ) ) { \nPropertyDescriptor pd = null ; \nString mName = m . getName ( ) ; \nboolean isGet = mName . startsWith ( GETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; \nboolean isSet = mName . startsWith ( SETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; \nif ( isGet || isSet ) { \nString propName = decapitalize ( mName . substring ( LEN_PREFIX ) ) ; \npd = map . get ( propName ) ; \nif ( pd == null ) { \npd = new PropertyDescriptor ( propName ) ; \nmap . put ( propName , pd ) ; \n} \nClass < ? > [ ] parmTypes = m . getParameterTypes ( ) ; \nif ( isSet ) { \nif ( parmTypes . length == 1 ) { \npd . setWriteMethod ( m ) ; \npd . setPropertyType ( parmTypes [ 0 ] ) ; \n} \n} \nelse { \nif ( isGet ) { \nif ( parmTypes . length == 0 ) { \npd . setReadMethod ( m ) ; \nif ( pd . getPropertyType ( ) == null ) { \npd . setPropertyType ( m . getReturnType ( ) ) ; \n} \n} \n} \n} \n} \n} \nreturn map . values ( ) . toArray ( new PropertyDescriptor [ 0 ] ) ; \n} \n} \n"}
{"6248": "public class PropertyAction { \npublic void begin ( InterpretationContext ec , String localName , Attributes attributes ) { \nif ( \"substitutionProperty\" . equals ( localName ) ) { \naddWarn ( \"[substitutionProperty] element has been deprecated. Please use the [property] element instead.\" ) ; \n} \nString name = attributes . getValue ( NAME_ATTRIBUTE ) ; \nString value = attributes . getValue ( VALUE_ATTRIBUTE ) ; \nString scopeStr = attributes . getValue ( SCOPE_ATTRIBUTE ) ; \nScope scope = ActionUtil . stringToScope ( scopeStr ) ; \nif ( checkFileAttributeSanity ( attributes ) ) { \nString file = attributes . getValue ( FILE_ATTRIBUTE ) ; \nfile = ec . subst ( file ) ; \ntry { \nFileInputStream istream = new FileInputStream ( file ) ; \nloadAndSetProperties ( ec , istream , scope ) ; \n} \ncatch ( FileNotFoundException e ) { \naddError ( \"Could not find properties file [\" + file + \"].\" ) ; \n} \ncatch ( IOException e1 ) { \naddError ( \"Could not read properties file [\" + file + \"].\" , e1 ) ; \n} \n} \nelse { \nif ( checkResourceAttributeSanity ( attributes ) ) { \nString resource = attributes . getValue ( RESOURCE_ATTRIBUTE ) ; \nresource = ec . subst ( resource ) ; \nURL resourceURL = Loader . getResourceBySelfClassLoader ( resource ) ; \nif ( resourceURL == null ) { \naddError ( \"Could not find resource [\" + resource + \"].\" ) ; \n} \nelse { \ntry { \nInputStream istream = resourceURL . openStream ( ) ; \nloadAndSetProperties ( ec , istream , scope ) ; \n} \ncatch ( IOException e ) { \naddError ( \"Could not read resource file [\" + resource + \"].\" , e ) ; \n} \n} \n} \nelse { \nif ( checkValueNameAttributesSanity ( attributes ) ) { \nvalue = RegularEscapeUtil . basicEscape ( value ) ; \nvalue = value . trim ( ) ; \nvalue = ec . subst ( value ) ; \nActionUtil . setProperty ( ec , name , value , scope ) ; \n} \nelse { \naddError ( INVALID_ATTRIBUTES ) ; \n} \n} \n} \n} \n} \n"}
{"6259": "public class RollingPolicyBase { \nprotected void determineCompressionMode ( ) { \nif ( fileNamePatternStr . endsWith ( \".gz\" ) ) { \naddInfo ( \"Will use gz compression\" ) ; \ncompressionMode = CompressionMode . GZ ; \n} \nelse { \nif ( fileNamePatternStr . endsWith ( \".zip\" ) ) { \naddInfo ( \"Will use zip compression\" ) ; \ncompressionMode = CompressionMode . ZIP ; \n} \nelse { \naddInfo ( \"No compression will be used\" ) ; \ncompressionMode = CompressionMode . NONE ; \n} \n} \n} \n} \n"}
{"6286": "public class SyslogAppenderBase { \nstatic public int facilityStringToint ( String facilityStr ) { \nif ( \"KERN\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_KERN ; \n} \nelse { \nif ( \"USER\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_USER ; \n} \nelse { \nif ( \"MAIL\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_MAIL ; \n} \nelse { \nif ( \"DAEMON\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_DAEMON ; \n} \nelse { \nif ( \"AUTH\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_AUTH ; \n} \nelse { \nif ( \"SYSLOG\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_SYSLOG ; \n} \nelse { \nif ( \"LPR\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_LPR ; \n} \nelse { \nif ( \"NEWS\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_NEWS ; \n} \nelse { \nif ( \"UUCP\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_UUCP ; \n} \nelse { \nif ( \"CRON\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_CRON ; \n} \nelse { \nif ( \"AUTHPRIV\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_AUTHPRIV ; \n} \nelse { \nif ( \"FTP\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_FTP ; \n} \nelse { \nif ( \"NTP\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_NTP ; \n} \nelse { \nif ( \"AUDIT\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_AUDIT ; \n} \nelse { \nif ( \"ALERT\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_ALERT ; \n} \nelse { \nif ( \"CLOCK\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_CLOCK ; \n} \nelse { \nif ( \"LOCAL0\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_LOCAL0 ; \n} \nelse { \nif ( \"LOCAL1\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_LOCAL1 ; \n} \nelse { \nif ( \"LOCAL2\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_LOCAL2 ; \n} \nelse { \nif ( \"LOCAL3\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_LOCAL3 ; \n} \nelse { \nif ( \"LOCAL4\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_LOCAL4 ; \n} \nelse { \nif ( \"LOCAL5\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_LOCAL5 ; \n} \nelse { \nif ( \"LOCAL6\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_LOCAL6 ; \n} \nelse { \nif ( \"LOCAL7\" . equalsIgnoreCase ( facilityStr ) ) { \nreturn SyslogConstants . LOG_LOCAL7 ; \n} \nelse { \nthrow new IllegalArgumentException ( facilityStr + \" is not a valid syslog facility string\" ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"6306": "public class AlgoliaException { \npublic boolean isTransient ( ) { \nThrowable cause = getCause ( ) ; \nif ( cause == null ) { \nreturn isServerError ( statusCode ) ; \n} \nelse { \nif ( cause instanceof AlgoliaException ) { \nreturn ( ( AlgoliaException ) cause ) . isTransient ( ) ; \n} \nelse { \nif ( cause instanceof IOException ) { \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n} \n} \n"}
{"6332": "public class JsonProtocol { \nprivate static byte hexVal ( byte ch ) throws IOException { \nif ( ( ch >= '0' ) && ( ch <= '9' ) ) { \nreturn ( byte ) ( ( char ) ch - '0' ) ; \n} \nelse { \nif ( ( ch >= 'a' ) && ( ch <= 'f' ) ) { \nreturn ( byte ) ( ( char ) ch - 'a' + 10 ) ; \n} \nelse { \nthrow new ProtocolException ( \"Expected hex character\" ) ; \n} \n} \n} \n} \n"}
{"6333": "public class JsonProtocol { \nprivate void writeJsonString ( byte [ ] b ) throws IOException { \ncontext . write ( ) ; \ntransport . write ( QUOTE ) ; \nint len = b . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nif ( ( b [ i ] & 0x00FF ) >= 0x30 ) { \nif ( b [ i ] == BACKSLASH [ 0 ] ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( BACKSLASH ) ; \n} \nelse { \ntransport . write ( b , i , 1 ) ; \n} \n} \nelse { \ntmpbuf [ 0 ] = JSON_CHAR_TABLE [ b [ i ] ] ; \nif ( tmpbuf [ 0 ] == 1 ) { \ntransport . write ( b , i , 1 ) ; \n} \nelse { \nif ( tmpbuf [ 0 ] > 1 ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( tmpbuf , 0 , 1 ) ; \n} \nelse { \ntransport . write ( ESCSEQ ) ; \ntmpbuf [ 0 ] = hexChar ( ( byte ) ( b [ i ] >> 4 ) ) ; \ntmpbuf [ 1 ] = hexChar ( b [ i ] ) ; \ntransport . write ( tmpbuf , 0 , 2 ) ; \n} \n} \n} \n} \ntransport . write ( QUOTE ) ; \n} \n} \n"}
{"6336": "public class JsonProtocol { \nprivate ByteString readJsonString ( boolean skipContext ) throws IOException { \nBuffer buffer = new Buffer ( ) ; \nArrayList < Character > codeunits = new ArrayList < > ( ) ; \nif ( ! skipContext ) { \ncontext . read ( ) ; \n} \nreadJsonSyntaxChar ( QUOTE ) ; \nwhile ( true ) { \nbyte ch = reader . read ( ) ; \nif ( ch == QUOTE [ 0 ] ) { \nbreak ; \n} \nif ( ch == ESCSEQ [ 0 ] ) { \nch = reader . read ( ) ; \nif ( ch == ESCSEQ [ 1 ] ) { \ntransport . read ( tmpbuf , 0 , 4 ) ; \nshort cu = ( short ) ( ( ( short ) hexVal ( tmpbuf [ 0 ] ) << 12 ) + ( ( short ) hexVal ( tmpbuf [ 1 ] ) << 8 ) + ( ( short ) hexVal ( tmpbuf [ 2 ] ) << 4 ) + ( short ) hexVal ( tmpbuf [ 3 ] ) ) ; \ntry { \nif ( Character . isHighSurrogate ( ( char ) cu ) ) { \nif ( codeunits . size ( ) > 0 ) { \nthrow new ProtocolException ( \"Expected low surrogate char\" ) ; \n} \ncodeunits . add ( ( char ) cu ) ; \n} \nelse { \nif ( Character . isLowSurrogate ( ( char ) cu ) ) { \nif ( codeunits . size ( ) == 0 ) { \nthrow new ProtocolException ( \"Expected high surrogate char\" ) ; \n} \ncodeunits . add ( ( char ) cu ) ; \nbuffer . write ( new String ( new int [ ] { \ncodeunits . get ( 0 ) , codeunits . get ( 1 ) } \n, 0 , 2 ) . getBytes ( \"UTF-8\" ) ) ; \ncodeunits . clear ( ) ; \n} \nelse { \nbuffer . write ( new String ( new int [ ] { \ncu } \n, 0 , 1 ) . getBytes ( \"UTF-8\" ) ) ; \n} \n} \ncontinue ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \ncatch ( IOException ex ) { \nthrow new ProtocolException ( \"Invalid unicode sequence\" ) ; \n} \n} \nelse { \nint off = ESCAPE_CHARS . indexOf ( ch ) ; \nif ( off == - 1 ) { \nthrow new ProtocolException ( \"Expected control char\" ) ; \n} \nch = ESCAPE_CHAR_VALS [ off ] ; \n} \n} \nbuffer . write ( new byte [ ] { \nch } \n) ; \n} \nreturn buffer . readByteString ( ) ; \n} \n} \n"}
{"6342": "public class ClientBase { \nfinal Object invokeRequest ( MethodCall < ? > call ) throws Exception { \nboolean isOneWay = call . callTypeId == TMessageType . ONEWAY ; \nint sid = seqId . incrementAndGet ( ) ; \nprotocol . writeMessageBegin ( call . name , call . callTypeId , sid ) ; \ncall . send ( protocol ) ; \nprotocol . writeMessageEnd ( ) ; \nprotocol . flush ( ) ; \nif ( isOneWay ) { \nreturn null ; \n} \nMessageMetadata metadata = protocol . readMessageBegin ( ) ; \nif ( metadata . seqId != sid ) { \nthrow new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , \"Unrecognized sequence ID\" ) ; \n} \nif ( metadata . type == TMessageType . EXCEPTION ) { \nThriftException e = ThriftException . read ( protocol ) ; \nprotocol . readMessageEnd ( ) ; \nthrow new ServerException ( e ) ; \n} \nelse { \nif ( metadata . type != TMessageType . REPLY ) { \nthrow new ThriftException ( ThriftException . Kind . INVALID_MESSAGE_TYPE , \"Invalid message type: \" + metadata . type ) ; \n} \n} \nif ( metadata . seqId != seqId . get ( ) ) { \nthrow new ThriftException ( ThriftException . Kind . BAD_SEQUENCE_ID , \"Out-of-order response\" ) ; \n} \nif ( ! metadata . name . equals ( call . name ) ) { \nthrow new ThriftException ( ThriftException . Kind . WRONG_METHOD_NAME , \"Unexpected method name in reply; expected \" + call . name + \" but received \" + metadata . name ) ; \n} \ntry { \nObject result = call . receive ( protocol , metadata ) ; \nprotocol . readMessageEnd ( ) ; \nreturn result ; \n} \ncatch ( Exception e ) { \nif ( e instanceof Struct ) { \nprotocol . readMessageEnd ( ) ; \n} \nthrow e ; \n} \n} \n} \n"}
{"6353": "public class PropertyBehavior { \npublic void setIsKeepAllAlive ( boolean isKeepAllAlive ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyKeepAllAlive = false ; \nif ( isDAVElement ( child , \"keepalive\" ) ) isAlreadyKeepAllAlive = \"*\" . equals ( getFirstText ( child ) ) ; \nif ( isKeepAllAlive ) { \nif ( ! isAlreadyKeepAllAlive ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"keepalive\" , \"*\" ) ; \n} \n} \nelse { \nif ( isAlreadyKeepAllAlive ) root . removeChild ( child ) ; \n} \n} \n} \n"}
{"6354": "public class PropertyBehavior { \npublic void setIsOmit ( boolean isOmit ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyOmit = isDAVElement ( child , \"omit\" ) ; \nif ( isOmit ) { \nif ( ! isAlreadyOmit ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"omit\" ) ; \n} \n} \nelse { \nif ( isAlreadyOmit ) root . removeChild ( child ) ; \n} \n} \n} \n"}
{"6376": "public class GraphicalVertex { \npublic void addConnection ( Connection conn ) { \nif ( conn == null || conn . getSource ( ) == conn . getTarget ( ) ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( conn . getSource ( ) == this ) { \nsourceConnections . add ( conn ) ; \nfirePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; \n} \nelse { \nif ( conn . getTarget ( ) == this ) { \ntargetConnections . add ( conn ) ; \nfirePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; \n} \n} \n} \n} \n"}
{"6378": "public class GraphicalVertex { \npublic void removeConnection ( Connection conn ) { \nif ( conn == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( conn . getSource ( ) == this ) { \nsourceConnections . remove ( conn ) ; \nfirePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; \n} \nelse { \nif ( conn . getTarget ( ) == this ) { \ntargetConnections . remove ( conn ) ; \nfirePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; \n} \n} \n} \n} \n"}
{"6380": "public class GraphicalVertex { \npublic void setPropertyValue ( Object propertyId , Object value ) { \nif ( XPOS_PROP . equals ( propertyId ) ) { \nint x = Integer . parseInt ( ( String ) value ) ; \nsetLocation ( new Point ( x , location . y ) ) ; \n} \nelse { \nif ( YPOS_PROP . equals ( propertyId ) ) { \nint y = Integer . parseInt ( ( String ) value ) ; \nsetLocation ( new Point ( location . x , y ) ) ; \n} \nelse { \nif ( HEIGHT_PROP . equals ( propertyId ) ) { \nint height = Integer . parseInt ( ( String ) value ) ; \nsetSize ( new Dimension ( size . width , height ) ) ; \n} \nelse { \nif ( WIDTH_PROP . equals ( propertyId ) ) { \nint width = Integer . parseInt ( ( String ) value ) ; \nsetSize ( new Dimension ( width , size . height ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"6403": "public class CompletionContext { \nprivate void determineDialect ( String backText ) { \ndialect = null ; \nboolean mvel = MVEL_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; \nboolean java = JAVA_DIALECT_PATTERN . matcher ( backText ) . matches ( ) ; \nif ( mvel ) { \ndialect = MVEL_DIALECT ; \n} \nelse { \nif ( java ) { \ndialect = JAVA_DIALECT ; \n} \n} \n} \n} \n"}
{"6420": "public class DSLRuleCompletionProcessor { \npublic String getLastNonDashLine ( String backText ) { \nBufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; \nString last = \"\" ; \nString line = null ; \ntry { \nwhile ( ( line = breader . readLine ( ) ) != null ) { \nline = line . trim ( ) ; \nif ( line . length ( ) > 0 && ! line . startsWith ( \"-\" ) ) { \nlast = line ; \n} \n} \n} \ncatch ( IOException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \nif ( last . indexOf ( \"(\" ) > - 1 && ! last . endsWith ( \")\" ) ) { \nlast = last . substring ( 0 , last . indexOf ( \"(\" ) ) ; \n} \nelse { \nif ( last . indexOf ( \"(\" ) > - 1 && last . endsWith ( \")\" ) ) { \nlast = \"\" ; \n} \n} \nreturn last ; \n} \n} \n"}
{"6488": "public class PropFind { \npublic void setIsAllProp ( boolean isAllProp ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyAllProp = isDAVElement ( child , \"allprop\" ) ; \nif ( isAllProp ) { \nif ( ! isAlreadyAllProp ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"allprop\" ) ; \n} \n} \nelse { \nif ( isAlreadyAllProp ) root . removeChild ( child ) ; \n} \n} \n} \n"}
{"6489": "public class PropFind { \npublic void setIsPropName ( boolean isPropName ) { \nElement child = getFirstChild ( root , childNames ) ; \nboolean isAlreadyPropName = isDAVElement ( child , \"propname\" ) ; \nif ( isPropName ) { \nif ( ! isAlreadyPropName ) { \nif ( child != null ) root . removeChild ( child ) ; \nappendChild ( root , \"propname\" ) ; \n} \n} \nelse { \nif ( isAlreadyPropName ) root . removeChild ( child ) ; \n} \n} \n} \n"}
{"6495": "public class DroolsBuilder { \nprotected void markParseErrors ( List < DroolsBuildMarker > markers , List < BaseKnowledgeBuilderResultImpl > parserErrors ) { \nfor ( Iterator < BaseKnowledgeBuilderResultImpl > iter = parserErrors . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nObject error = iter . next ( ) ; \nif ( error instanceof ParserError ) { \nParserError err = ( ParserError ) error ; \nmarkers . add ( new DroolsBuildMarker ( err . getMessage ( ) , err . getRow ( ) ) ) ; \n} \nelse { \nif ( error instanceof KnowledgeBuilderResult ) { \nKnowledgeBuilderResult res = ( KnowledgeBuilderResult ) error ; \nint [ ] errorLines = res . getLines ( ) ; \nmarkers . add ( new DroolsBuildMarker ( res . getMessage ( ) , errorLines != null && errorLines . length > 0 ? errorLines [ 0 ] : - 1 ) ) ; \n} \nelse { \nif ( error instanceof ExpanderException ) { \nExpanderException exc = ( ExpanderException ) error ; \nmarkers . add ( new DroolsBuildMarker ( exc . getMessage ( ) , - 1 ) ) ; \n} \nelse { \nmarkers . add ( new DroolsBuildMarker ( error . toString ( ) ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"6522": "public class NewDroolsProjectWizard { \nprivate void createRuleSampleLauncher ( IJavaProject project ) throws JavaModelException , IOException { \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( version . getMajor ( ) == 4 ) { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_4.java.template\" , \"DroolsTest.java\" ) ; \n} \nelse { \nif ( version . getMajor ( ) == 5 ) { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_5.java.template\" , \"DroolsTest.java\" ) ; \n} \nelse { \nif ( version . getMajor ( ) >= 6 ) { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_6.java.template\" , \"DroolsTest.java\" ) ; \n} \n} \n} \n} \n} \n"}
{"6524": "public class NewDroolsProjectWizard { \nprivate void createRuleFlow ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( version . getMajor ( ) == 4 ) { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.rf.template\" , \"src/main/rules\" , \"ruleflow.rf\" ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.rfm.template\" , \"src/main/rules\" , \"ruleflow.rfm\" ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow_4.drl.template\" , \"src/main/rules\" , \"ruleflow.drl\" ) ; \n} \nelse { \nif ( version . getMajor ( ) == 5 && version . getMinor ( ) == 0 ) { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/ruleflow.rf.template\" , \"src/main/rules\" , \"ruleflow.rf\" ) ; \n} \nelse { \nif ( version . getMajor ( ) == 5 ) { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/sample.bpmn.template\" , \"src/main/rules\" , \"sample.bpmn\" ) ; \n} \nelse { \nFileUtils . createFolder ( project , \"src/main/resources/com/sample/process\" , monitor ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/sample.bpmn.template\" , \"src/main/resources/com/sample/process\" , \"sample.bpmn\" ) ; \n} \n} \n} \n} \n} \n"}
{"6525": "public class NewDroolsProjectWizard { \nprivate void createRuleFlowSampleLauncher ( IJavaProject project ) throws JavaModelException , IOException { \nString s ; \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( version . getMajor ( ) == 4 ) { \ns = \"org/drools/eclipse/wizard/project/RuleFlowLauncherSample_4.java.template\" ; \n} \nelse { \nif ( version . getMajor ( ) == 5 && version . getMinor ( ) == 0 ) { \ns = \"org/drools/eclipse/wizard/project/RuleFlowLauncherSample.java.template\" ; \n} \nelse { \nif ( version . getMajor ( ) == 5 ) { \ns = \"org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_5.java.template\" ; \n} \nelse { \ns = \"org/drools/eclipse/wizard/project/ProcessLauncherSample_bpmn_6.java.template\" ; \n} \n} \n} \ncreateProjectJavaFile ( project , s , \"ProcessTest.java\" ) ; \n} \n} \n"}
{"6536": "public class ExportImageDialog { \nprivate void initializeControls ( ) { \nif ( originalFile != null ) { \nresourceGroup . setContainerFullPath ( originalFile . getParent ( ) . getFullPath ( ) ) ; \nString fileName = originalFile . getName ( ) ; \nint index = fileName . lastIndexOf ( \".\" ) ; \nif ( index != - 1 ) { \nfileName = fileName . substring ( 0 , index ) ; \n} \nfileName += \"-image.png\" ; \nresourceGroup . setResource ( fileName ) ; \n} \nelse { \nif ( originalName != null ) { \nresourceGroup . setResource ( originalName ) ; \n} \n} \nsetDialogComplete ( validatePage ( ) ) ; \n} \n} \n"}
{"6555": "public class OgnlRuntime { \npublic static final Class getArgClass ( Object arg ) { \nif ( arg == null ) return null ; \nClass c = arg . getClass ( ) ; \nif ( c == Boolean . class ) return Boolean . TYPE ; \nelse { \nif ( c . getSuperclass ( ) == Number . class ) { \nif ( c == Integer . class ) return Integer . TYPE ; \nif ( c == Double . class ) return Double . TYPE ; \nif ( c == Byte . class ) return Byte . TYPE ; \nif ( c == Long . class ) return Long . TYPE ; \nif ( c == Float . class ) return Float . TYPE ; \nif ( c == Short . class ) return Short . TYPE ; \n} \nelse { \nif ( c == Character . class ) return Character . TYPE ; \n} \n} \nreturn c ; \n} \n} \n"}
{"6556": "public class OgnlRuntime { \npublic static final boolean isMoreSpecific ( Class [ ] classes1 , Class [ ] classes2 ) { \nfor ( int index = 0 , count = classes1 . length ; \nindex < count ; \n++ index ) { \nClass c1 = classes1 [ index ] , c2 = classes2 [ index ] ; \nif ( c1 == c2 ) continue ; \nelse { \nif ( c1 . isPrimitive ( ) ) return true ; \nelse { \nif ( c1 . isAssignableFrom ( c2 ) ) return false ; \nelse { \nif ( c2 . isAssignableFrom ( c1 ) ) return true ; \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"6573": "public class OgnlOps { \npublic static int getNumericType ( int t1 , int t2 , boolean canBeNonNumeric ) { \nif ( t1 == t2 ) return t1 ; \nif ( canBeNonNumeric && ( t1 == NONNUMERIC || t2 == NONNUMERIC || t1 == CHAR || t2 == CHAR ) ) return NONNUMERIC ; \nif ( t1 == NONNUMERIC ) t1 = DOUBLE ; \nif ( t2 == NONNUMERIC ) t2 = DOUBLE ; \nif ( t1 >= MIN_REAL_TYPE ) { \nif ( t2 >= MIN_REAL_TYPE ) return Math . max ( t1 , t2 ) ; \nif ( t2 < INT ) return t1 ; \nif ( t2 == BIGINT ) return BIGDEC ; \nreturn Math . max ( DOUBLE , t1 ) ; \n} \nelse { \nif ( t2 >= MIN_REAL_TYPE ) { \nif ( t1 < INT ) return t2 ; \nif ( t1 == BIGINT ) return BIGDEC ; \nreturn Math . max ( DOUBLE , t2 ) ; \n} \nelse return Math . max ( t1 , t2 ) ; \n} \n} \n} \n"}
{"6587": "public class FileWatchServices { \npublic static String getDefaultWatchServiceId ( ) { \nString result = \"polling\" ; \nString osName = System . getProperty ( \"os.name\" ) ; \nif ( osName != null ) { \nosName = osName . toLowerCase ( Locale . ENGLISH ) ; \nif ( osName . contains ( \"windows\" ) || osName . contains ( \"linux\" ) ) { \nresult = isAtLeastJava7 ( ) ? \"jdk7\" : \"jnotify\" ; \n} \nelse { \nif ( osName . contains ( \"mac\" ) ) { \nresult = \"jnotify\" ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"6598": "public class DirectoryChooserFragment { \nprivate void changeDirectory ( final File dir ) { \nif ( dir == null ) { \ndebug ( \"Could not change folder: dir was null\" ) ; \n} \nelse { \nif ( ! dir . isDirectory ( ) ) { \ndebug ( \"Could not change folder: dir is no directory\" ) ; \n} \nelse { \nfinal File [ ] contents = dir . listFiles ( ) ; \nif ( contents != null ) { \nint numDirectories = 0 ; \nfor ( final File f : contents ) { \nif ( f . isDirectory ( ) ) { \nnumDirectories ++ ; \n} \n} \nmFilesInDir = new File [ numDirectories ] ; \nmFilenames . clear ( ) ; \nfor ( int i = 0 , counter = 0 ; \ni < numDirectories ; \ncounter ++ ) { \nif ( contents [ counter ] . isDirectory ( ) ) { \nmFilesInDir [ i ] = contents [ counter ] ; \nmFilenames . add ( contents [ counter ] . getName ( ) ) ; \ni ++ ; \n} \n} \nArrays . sort ( mFilesInDir ) ; \nCollections . sort ( mFilenames ) ; \nmSelectedDir = dir ; \nmTxtvSelectedFolder . setText ( dir . getAbsolutePath ( ) ) ; \nmListDirectoriesAdapter . notifyDataSetChanged ( ) ; \nmFileObserver = createFileObserver ( dir . getAbsolutePath ( ) ) ; \nmFileObserver . startWatching ( ) ; \ndebug ( \"Changed directory to %s\" , dir . getAbsolutePath ( ) ) ; \n} \nelse { \ndebug ( \"Could not change folder: contents of dir were null\" ) ; \n} \n} \n} \nrefreshButtonState ( ) ; \n} \n} \n"}
{"6602": "public class DirectoryChooserFragment { \nprivate int createFolder ( ) { \nif ( mNewDirectoryName != null && mSelectedDir != null && mSelectedDir . canWrite ( ) ) { \nfinal File newDir = new File ( mSelectedDir , mNewDirectoryName ) ; \nif ( newDir . exists ( ) ) { \nreturn R . string . create_folder_error_already_exists ; \n} \nelse { \nfinal boolean result = newDir . mkdir ( ) ; \nif ( result ) { \nreturn R . string . create_folder_success ; \n} \nelse { \nreturn R . string . create_folder_error ; \n} \n} \n} \nelse { \nif ( mSelectedDir != null && ! mSelectedDir . canWrite ( ) ) { \nreturn R . string . create_folder_error_no_write_access ; \n} \nelse { \nreturn R . string . create_folder_error ; \n} \n} \n} \n} \n"}
{"6605": "public class ConverterHtmlToSpanned { \nprivate void startList ( boolean isOrderedList , Attributes attributes ) { \nboolean isIndentation = isIndentation ( attributes ) ; \nParagraphType newType = isIndentation && isOrderedList ? ParagraphType . INDENTATION_OL : isIndentation && ! isOrderedList ? ParagraphType . INDENTATION_UL : isOrderedList ? ParagraphType . NUMBERING : ParagraphType . BULLET ; \nAccumulatedParagraphStyle currentStyle = mParagraphStyles . isEmpty ( ) ? null : mParagraphStyles . peek ( ) ; \nif ( currentStyle == null ) { \nAccumulatedParagraphStyle newStyle = new AccumulatedParagraphStyle ( newType , 1 , 1 ) ; \nmParagraphStyles . push ( newStyle ) ; \n} \nelse { \nif ( currentStyle . getType ( ) == newType ) { \ncurrentStyle . setAbsoluteIndent ( currentStyle . getAbsoluteIndent ( ) + 1 ) ; \ncurrentStyle . setRelativeIndent ( currentStyle . getRelativeIndent ( ) + 1 ) ; \n} \nelse { \nAccumulatedParagraphStyle newStyle = new AccumulatedParagraphStyle ( newType , currentStyle . getAbsoluteIndent ( ) + 1 , 1 ) ; \nmParagraphStyles . push ( newStyle ) ; \n} \n} \n} \n} \n"}
{"6607": "public class HighlightView { \nvoid handleMotion ( int edge , float dx , float dy ) { \nRect r = computeLayout ( ) ; \nif ( edge == GROW_NONE ) { \nreturn ; \n} \nelse { \nif ( edge == MOVE ) { \nmoveBy ( dx * ( mCropRect . width ( ) / r . width ( ) ) , dy * ( mCropRect . height ( ) / r . height ( ) ) ) ; \n} \nelse { \nif ( ( ( GROW_LEFT_EDGE | GROW_RIGHT_EDGE ) & edge ) == 0 ) { \ndx = 0 ; \n} \nif ( ( ( GROW_TOP_EDGE | GROW_BOTTOM_EDGE ) & edge ) == 0 ) { \ndy = 0 ; \n} \nfloat xDelta = dx * ( mCropRect . width ( ) / r . width ( ) ) ; \nfloat yDelta = dy * ( mCropRect . height ( ) / r . height ( ) ) ; \ngrowBy ( ( ( ( edge & GROW_LEFT_EDGE ) != 0 ) ? - 1 : 1 ) * xDelta , ( ( ( edge & GROW_TOP_EDGE ) != 0 ) ? - 1 : 1 ) * yDelta ) ; \n} \n} \n} \n} \n"}
{"6625": "public class ByteArrayOutputStream { \n@ Override public void write ( byte [ ] b , int off , int len ) { \nif ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nelse { \nif ( len == 0 ) { \nreturn ; \n} \n} \nsynchronized ( this ) { \nint newcount = count + len ; \nint remaining = len ; \nint inBufferPos = count - filledBufferSum ; \nwhile ( remaining > 0 ) { \nint part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; \nSystem . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; \nremaining -= part ; \nif ( remaining > 0 ) { \nneedNewBuffer ( newcount ) ; \ninBufferPos = 0 ; \n} \n} \ncount = newcount ; \n} \n} \n} \n"}
{"6659": "public class Parser { \nprivate String expandEntities ( String src ) { \nint refStart = - 1 ; \nint len = src . length ( ) ; \nchar [ ] dst = new char [ len ] ; \nint dstlen = 0 ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nchar ch = src . charAt ( i ) ; \ndst [ dstlen ++ ] = ch ; \nif ( ch == '&' && refStart == - 1 ) { \nrefStart = dstlen ; \n} \nelse { \nif ( refStart == - 1 ) { \n} \nelse { \nif ( Character . isLetter ( ch ) || Character . isDigit ( ch ) || ch == '#' ) { \n} \nelse { \nif ( ch == ';' ) { \nint ent = lookupEntity ( dst , refStart , dstlen - refStart - 1 ) ; \nif ( ent > 0xFFFF ) { \nent -= 0x10000 ; \ndst [ refStart - 1 ] = ( char ) ( ( ent >> 10 ) + 0xD800 ) ; \ndst [ refStart ] = ( char ) ( ( ent & 0x3FF ) + 0xDC00 ) ; \ndstlen = refStart + 1 ; \n} \nelse { \nif ( ent != 0 ) { \ndst [ refStart - 1 ] = ( char ) ent ; \ndstlen = refStart ; \n} \n} \nrefStart = - 1 ; \n} \nelse { \nrefStart = - 1 ; \n} \n} \n} \n} \n} \nreturn new String ( dst , 0 , dstlen ) ; \n} \n} \n"}
{"6667": "public class Parser { \nprivate static String [ ] split ( String val ) throws IllegalArgumentException { \nval = val . trim ( ) ; \nif ( val . length ( ) == 0 ) { \nreturn new String [ 0 ] ; \n} \nelse { \nArrayList < String > l = new ArrayList < String > ( ) ; \nint s = 0 ; \nint e = 0 ; \nboolean sq = false ; \nboolean dq = false ; \nchar lastc = 0 ; \nint len = val . length ( ) ; \nfor ( e = 0 ; \ne < len ; \ne ++ ) { \nchar c = val . charAt ( e ) ; \nif ( ! dq && c == '\\'' && lastc != '\\\\' ) { \nsq = ! sq ; \nif ( s < 0 ) s = e ; \n} \nelse { \nif ( ! sq && c == '\\\"' && lastc != '\\\\' ) { \ndq = ! dq ; \nif ( s < 0 ) s = e ; \n} \nelse { \nif ( ! sq && ! dq ) { \nif ( Character . isWhitespace ( c ) ) { \nif ( s >= 0 ) l . add ( val . substring ( s , e ) ) ; \ns = - 1 ; \n} \nelse { \nif ( s < 0 && c != ' ' ) { \ns = e ; \n} \n} \n} \n} \n} \nlastc = c ; \n} \nl . add ( val . substring ( s , e ) ) ; \nreturn ( String [ ] ) l . toArray ( new String [ 0 ] ) ; \n} \n} \n} \n"}
{"6669": "public class Parser { \nprivate String makeName ( char [ ] buff , int offset , int length ) { \nStringBuffer dst = new StringBuffer ( length + 2 ) ; \nboolean seenColon = false ; \nboolean start = true ; \nfor ( ; \nlength -- > 0 ; \noffset ++ ) { \nchar ch = buff [ offset ] ; \nif ( Character . isLetter ( ch ) || ch == '_' ) { \nstart = false ; \ndst . append ( ch ) ; \n} \nelse { \nif ( Character . isDigit ( ch ) || ch == '-' || ch == '.' ) { \nif ( start ) dst . append ( '_' ) ; \nstart = false ; \ndst . append ( ch ) ; \n} \nelse { \nif ( ch == ':' && ! seenColon ) { \nseenColon = true ; \nif ( start ) dst . append ( '_' ) ; \nstart = true ; \ndst . append ( translateColons ? '_' : ch ) ; \n} \n} \n} \n} \nint dstLength = dst . length ( ) ; \nif ( dstLength == 0 || dst . charAt ( dstLength - 1 ) == ':' ) dst . append ( '_' ) ; \nreturn dst . toString ( ) . intern ( ) ; \n} \n} \n"}
{"6739": "public class PreProcessorExecutor { \nprivate String runInParallel ( final List < Resource > resources , final ProcessingCriteria criteria ) throws IOException { \nLOG . debug ( \"Running preProcessing in Parallel\" ) ; \nfinal StringBuffer result = new StringBuffer ( ) ; \nfinal List < Callable < String > > callables = new ArrayList < Callable < String > > ( ) ; \nfor ( final Resource resource : resources ) { \ncallables . add ( new Callable < String > ( ) { \npublic String call ( ) throws Exception { \nLOG . debug ( \"Callable started for resource: {} ...\" , resource ) ; \nreturn applyPreProcessors ( resource , criteria ) ; \n} \n} \n) ; \n} \nfinal ExecutorService exec = getExecutorService ( ) ; \nfinal List < Future < String > > futures = new ArrayList < Future < String > > ( ) ; \nfor ( final Callable < String > callable : callables ) { \nfinal Callable < String > decoratedCallable = new ContextPropagatingCallable < String > ( callable ) ; \nfutures . add ( exec . submit ( decoratedCallable ) ) ; \n} \nfor ( final Future < String > future : futures ) { \ntry { \nresult . append ( future . get ( ) ) ; \n} \ncatch ( final Exception e ) { \nfinal Throwable cause = e . getCause ( ) ; \nif ( cause instanceof WroRuntimeException ) { \nthrow ( WroRuntimeException ) cause ; \n} \nelse { \nif ( cause instanceof IOException ) { \nthrow ( IOException ) cause ; \n} \nelse { \nthrow new WroRuntimeException ( \"Problem during parallel pre processing\" , e ) ; \n} \n} \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"6819": "public class ElkTimer { \npublic void log ( Logger logger , LogLevel priority ) { \nif ( LoggerWrap . isEnabledFor ( logger , priority ) ) { \nString timerLabel ; \nif ( threadId != 0 ) { \ntimerLabel = name + \" (thread \" + threadId + \")\" ; \n} \nelse { \nif ( threadCount > 1 ) { \ntimerLabel = name + \" (over \" + threadCount + \" threads)\" ; \n} \nelse { \ntimerLabel = name ; \n} \n} \nif ( todoFlags == RECORD_NONE ) { \nLoggerWrap . log ( logger , priority , \"Timer \" + timerLabel + \" recorded \" + measurements + \" run(s), no times taken\" ) ; \n} \nelse { \nString labels = \"\" ; \nString values = \"\" ; \nString separator ; \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"CPU\" ; \nvalues += totalCpuTime / 1000000 ; \nseparator = \"/\" ; \n} \nelse { \nseparator = \"\" ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += separator + \"Wall\" ; \nvalues += separator + totalWallTime / 1000000 ; \n} \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"/CPU avg\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / measurements / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall avg\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / measurements / 1000000 ; \n} \nif ( threadCount > 1 ) { \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"/CPU per thread\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / threadCount / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall per thread\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / threadCount / 1000000 ; \n} \n} \nLoggerWrap . log ( logger , priority , \"Time for \" + timerLabel + \" for \" + measurements + \" run(s) \" + labels + \" (ms): \" + values ) ; \n} \nif ( isRunning ) { \nlogger . warn ( \"Timer \" + timerLabel + \" logged while it was still running\" ) ; \n} \n} \n} \n} \n"}
{"6869": "public class ArraySlicedSet { \npublic boolean add ( int s , E e ) { \nif ( e == null ) throw new NullPointerException ( ) ; \nint mask = ( 1 << s ) ; \nint oldMask = addMask ( logs , data , masks , e , mask ) ; \nint newMask = oldMask | mask ; \nif ( newMask == oldMask ) return false ; \nelse { \nif ( oldMask == 0 && ++ occupied == LinearProbing . getUpperSize ( data . length ) ) enlarge ( ) ; \n} \nsizes [ s ] ++ ; \nreturn true ; \n} \n} \n"}
{"6879": "public class XhtmlResourceMessageConverter { \nprivate void writeResource ( XhtmlWriter writer , Object object ) { \nif ( object == null ) { \nreturn ; \n} \ntry { \nif ( object instanceof Resource ) { \nResource < ? > resource = ( Resource < ? > ) object ; \nwriter . beginListItem ( ) ; \nwriteResource ( writer , resource . getContent ( ) ) ; \nwriter . writeLinks ( resource . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \nelse { \nif ( object instanceof Resources ) { \nResources < ? > resources = ( Resources < ? > ) object ; \nwriter . beginListItem ( ) ; \nwriter . beginUnorderedList ( ) ; \nCollection < ? > content = resources . getContent ( ) ; \nwriteResource ( writer , content ) ; \nwriter . endUnorderedList ( ) ; \nwriter . writeLinks ( resources . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \nelse { \nif ( object instanceof ResourceSupport ) { \nResourceSupport resource = ( ResourceSupport ) object ; \nwriter . beginListItem ( ) ; \nwriteObject ( writer , resource ) ; \nwriter . writeLinks ( resource . getLinks ( ) ) ; \nwriter . endListItem ( ) ; \n} \nelse { \nif ( object instanceof Collection ) { \nCollection < ? > collection = ( Collection < ? > ) object ; \nfor ( Object item : collection ) { \nwriteResource ( writer , item ) ; \n} \n} \nelse { \nwriteObject ( writer , object ) ; \n} \n} \n} \n} \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( \"failed to transform object \" + object , ex ) ; \n} \n} \n} \n"}
{"6897": "public class SpringActionInputParameter { \npublic boolean isRequired ( ) { \nboolean ret ; \nif ( isRequestBody ( ) ) { \nret = requestBody . required ( ) ; \n} \nelse { \nif ( isRequestParam ( ) ) { \nret = ! ( isDefined ( requestParam . defaultValue ( ) ) || ! requestParam . required ( ) ) ; \n} \nelse { \nif ( isRequestHeader ( ) ) { \nret = ! ( isDefined ( requestHeader . defaultValue ( ) ) || ! requestHeader . required ( ) ) ; \n} \nelse { \nret = true ; \n} \n} \n} \nreturn ret ; \n} \n} \n"}
{"6898": "public class SpringActionInputParameter { \npublic String getDefaultValue ( ) { \nString ret ; \nif ( isRequestParam ( ) ) { \nret = isDefined ( requestParam . defaultValue ( ) ) ? requestParam . defaultValue ( ) : null ; \n} \nelse { \nif ( isRequestHeader ( ) ) { \nret = ! ( ValueConstants . DEFAULT_NONE . equals ( requestHeader . defaultValue ( ) ) ) ? requestHeader . defaultValue ( ) : null ; \n} \nelse { \nret = null ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"6901": "public class LdContextFactory { \npublic String getVocab ( MixinSource mixinSource , Object bean , Class < ? > mixInClass ) { \nif ( proxyUnwrapper != null ) { \nbean = proxyUnwrapper . unwrapProxy ( bean ) ; \n} \nString classVocab = bean == null ? null : vocabFromClassOrPackage ( bean . getClass ( ) ) ; \nfinal Vocab mixinVocab = findAnnotation ( mixInClass , Vocab . class ) ; \nObject nestedContextProviderFromMixin = getNestedContextProviderFromMixin ( mixinSource , bean , mixInClass ) ; \nString contextProviderVocab = null ; \nif ( nestedContextProviderFromMixin != null ) { \ncontextProviderVocab = getVocab ( mixinSource , nestedContextProviderFromMixin , null ) ; \n} \nString vocab ; \nif ( mixinVocab != null ) { \nvocab = mixinVocab . value ( ) ; \n} \nelse { \nif ( classVocab != null ) { \nvocab = classVocab ; \n} \nelse { \nif ( contextProviderVocab != null ) { \nvocab = contextProviderVocab ; \n} \nelse { \nvocab = HTTP_SCHEMA_ORG ; \n} \n} \n} \nreturn vocab ; \n} \n} \n"}
{"6902": "public class PartialUriTemplateComponents { \npublic String getQuery ( ) { \nStringBuilder query = new StringBuilder ( ) ; \nif ( queryTail . length ( ) > 0 ) { \nif ( queryHead . length ( ) == 0 ) { \nquery . append ( \"{?\" ) . append ( queryTail ) . append ( \"}\" ) ; \n} \nelse { \nif ( queryHead . length ( ) > 0 ) { \nquery . append ( queryHead ) . append ( \"{&\" ) . append ( queryTail ) . append ( \"}\" ) ; \n} \n} \n} \nelse { \nquery . append ( queryHead ) ; \n} \nreturn query . toString ( ) ; \n} \n} \n"}
{"6918": "public class Xform { \n@ SuppressWarnings ( \"unchecked\" ) private static < H > H _fold ( Iterable source , Operation [ ] ops , int opIdx , H ident , Fn2 reducer ) { \nObject ret = ident ; \nsourceLoop : for ( Object o : source ) { \nfor ( int j = opIdx ; \nj < ops . length ; \nj ++ ) { \nOperation op = ops [ j ] ; \nif ( ( op . filter != null ) && ! op . filter . apply ( o ) ) { \ncontinue sourceLoop ; \n} \nif ( op . map != null ) { \no = op . map . apply ( o ) ; \nif ( o == TERMINATE ) { \nreturn ( H ) ret ; \n} \n} \nelse { \nif ( op . flatMap != null ) { \nret = _fold ( op . flatMap . apply ( o ) , ops , j + 1 , ( H ) ret , reducer ) ; \ncontinue sourceLoop ; \n} \n} \n} \nret = reducer . apply ( ret , o ) ; \n} \nreturn ( H ) ret ; \n} \n} \n"}
{"6922": "public class OneOf3 { \n@ SuppressWarnings ( \"unchecked\" ) public < R > R match ( Fn1 < A , R > fa , Fn1 < B , R > fb , Fn1 < C , R > fc ) { \nif ( sel == 0 ) { \nreturn fa . apply ( ( A ) item ) ; \n} \nelse { \nif ( sel == 1 ) { \nreturn fb . apply ( ( B ) item ) ; \n} \nelse { \nreturn fc . apply ( ( C ) item ) ; \n} \n} \n} \n} \n"}
{"6989": "public class DeploymentManager { \npublic void uninstallDeployableUnit ( DeployableUnit du ) throws Exception { \nupdateDeployedComponents ( ) ; \nif ( ! du . isInstalled ( ) ) { \nif ( waitingForInstallDUs . remove ( du ) ) { \nlogger . info ( du . getDeploymentInfoShortName ( ) + \" wasn't deployed. Removing from waiting list.\" ) ; \n} \n} \nelse { \nif ( ! du . areComponentsStillPresent ( ) ) { \nlogger . info ( du . getDeploymentInfoShortName ( ) + \" components already removed. Removing DU info.\" ) ; \nprocessInternalUndeploy ( du ) ; \n} \nelse { \nif ( du . isReadyToUninstall ( ) ) { \nsciAction ( du . getUninstallActions ( ) , du ) ; \nprocessInternalUndeploy ( du ) ; \n} \nelse { \nif ( ! waitingForUninstallDUs . contains ( du ) ) { \nwaitingForUninstallDUs . add ( du ) ; \nlogger . warn ( \"Unable to UNINSTALL \" + du . getDeploymentInfoShortName ( ) + \" right now. Waiting for dependents to be removed.\" ) ; \n} \nthrow new DependencyException ( \"Unable to undeploy \" + du . getDeploymentInfoShortName ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"7036": "public class SLEESubDeployer { \npublic boolean accepts ( URL deployableUnitURL , String deployableUnitName ) { \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nURL url = du . getUrl ( ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method accepts called for \" + url + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \ntry { \nString fullPath = url . getFile ( ) ; \nString fileName = fullPath . substring ( fullPath . lastIndexOf ( '/' ) + 1 , fullPath . length ( ) ) ; \nif ( toAccept . containsKey ( fileName ) ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Accepting \" + url . toString ( ) + \".\" ) ; \n} \nreturn true ; \n} \nelse { \nif ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nif ( du . getEntry ( \"META-INF/deployable-unit.xml\" ) != null ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Accepting \" + url . toString ( ) + \".\" ) ; \n} \nreturn true ; \n} \n} \nfinally { \nif ( duJarFile != null ) { \ntry { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \n} \n} \ncatch ( Exception ignore ) { \n} \nreturn false ; \n} \n} \n"}
{"7037": "public class SLEESubDeployer { \npublic void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nURL url = deployableUnitURL ; \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method init called for \" + deployableUnitURL + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \nString fullPath = du . getFullPath ( ) ; \nString fileName = du . getFileName ( ) ; \ntry { \nDeployableUnitWrapper duWrapper = null ; \nif ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) { \nDeployableComponent dc = new DeployableComponent ( du , url , fileName , sleeContainerDeployer ) ; \nDeployableUnit deployerDU = deployableUnits . get ( duWrapper . getFileName ( ) ) ; \nfor ( DeployableComponent subDC : dc . getSubComponents ( ) ) { \ndeployerDU . addComponent ( subDC ) ; \n} \n} \nelse { \nif ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nduJarFile = new JarFile ( fullPath ) ; \nJarEntry duXmlEntry = duJarFile . getJarEntry ( \"META-INF/deployable-unit.xml\" ) ; \nif ( duXmlEntry != null ) { \nDeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; \nDeployableUnitDescriptorFactory dudf = sleeContainerDeployer . getSleeContainer ( ) . getComponentManagement ( ) . getDeployableUnitManagement ( ) . getDeployableUnitDescriptorFactory ( ) ; \nDeployableUnitDescriptor duDesc = dudf . parse ( duJarFile . getInputStream ( duXmlEntry ) ) ; \nwhile ( deployableUnits . containsKey ( fileName ) ) { \nThread . sleep ( getWaitTimeBetweenOperations ( ) ) ; \n} \ndeployableUnits . put ( fileName , deployerDU ) ; \nfor ( String componentJarName : duDesc . getJarEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = componentJarName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = componentJarName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \ncomponentJarName = componentJarName . substring ( beginIndex , componentJarName . length ( ) ) ; \ntoAccept . put ( componentJarName , du ) ; \n} \nfor ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { \nint beginIndex ; \nif ( ( beginIndex = serviceXMLName . lastIndexOf ( '/' ) ) == - 1 ) beginIndex = serviceXMLName . lastIndexOf ( '\\\\' ) ; \nbeginIndex ++ ; \nserviceXMLName = serviceXMLName . substring ( beginIndex , serviceXMLName . length ( ) ) ; \ntoAccept . put ( serviceXMLName , du ) ; \n} \n} \n} \nfinally { \nif ( duJarFile != null ) { \ntry { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"Deployment of \" + fileName + \" failed. \" , e ) ; \nreturn ; \n} \n} \n} \n"}
{"7039": "public class SLEESubDeployer { \npublic void stop ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"stop( deployableUnitURL = : \" + deployableUnitURL + \" )\" ) ; \n} \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nDeployableUnit realDU = null ; \nString fileName = du . getFileName ( ) ; \nif ( ( realDU = deployableUnits . get ( du . getFileName ( ) ) ) != null ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Got DU: \" + realDU . getDeploymentInfoShortName ( ) ) ; \n} \nif ( ! isInUndeployList ( fileName ) ) { \naddToUndeployList ( fileName ) ; \n} \ntry { \nsleeContainerDeployer . getDeploymentManager ( ) . uninstallDeployableUnit ( realDU ) ; \ndeployableUnits . remove ( fileName ) ; \nremoveFromUndeployList ( fileName ) ; \n} \ncatch ( DependencyException e ) { \n} \ncatch ( Exception e ) { \nThrowable cause = e . getCause ( ) ; \nif ( cause instanceof InvalidStateException ) { \nlogger . warn ( cause . getLocalizedMessage ( ) + \"... WAITING ...\" ) ; \n} \nelse { \nif ( e instanceof DeploymentException ) { \nthrow new IllegalStateException ( e . getLocalizedMessage ( ) , e ) ; \n} \nelse { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7060": "public class AccessorOperation { \nprotected Object convert ( String optArg ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , InstantiationException , IllegalAccessException , InvocationTargetException , CommandException { \nif ( fieldClass . isPrimitive ( ) ) { \nif ( fieldClass . equals ( int . class ) ) { \nreturn new Integer ( optArg ) ; \n} \nelse { \nif ( fieldClass . equals ( long . class ) ) { \nreturn new Long ( optArg ) ; \n} \nelse { \nif ( fieldClass . equals ( int . class ) ) { \nreturn new Integer ( optArg ) ; \n} \nelse { \nif ( fieldClass . equals ( byte . class ) ) { \nreturn new Byte ( optArg ) ; \n} \nelse { \nif ( fieldClass . equals ( short . class ) ) { \nreturn new Short ( optArg ) ; \n} \nelse { \nif ( fieldClass . equals ( float . class ) ) { \nreturn new Float ( optArg ) ; \n} \nelse { \nif ( fieldClass . equals ( double . class ) ) { \nreturn new Double ( optArg ) ; \n} \nelse { \nif ( fieldClass . equals ( boolean . class ) ) { \nreturn new Boolean ( optArg ) ; \n} \nelse { \nif ( fieldClass . equals ( char . class ) ) { \nreturn new Character ( optArg . charAt ( 0 ) ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \nthrow new CommandException ( \"Unpredicted place. Please report.\" ) ; \n} \nelse { \nif ( isClassNumber ( ) ) { \nConstructor < ? > con = fieldClass . getConstructor ( String . class ) ; \nreturn con . newInstance ( optArg ) ; \n} \n} \nreturn optArg ; \n} \n} \n"}
{"7074": "public class ConcreteActivityContextInterfaceGenerator { \nprivate void generateConcreteMethods ( Map interfaceMethods ) { \nif ( interfaceMethods == null ) return ; \nIterator it = interfaceMethods . values ( ) . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nCtMethod interfaceMethod = ( CtMethod ) it . next ( ) ; \nif ( interfaceMethod != null && ( interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( javax . slee . ActivityContextInterface . class . getName ( ) ) || interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( ActivityContextInterfaceExt . class . getName ( ) ) ) ) continue ; \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( interfaceMethod , concreteActivityContextInterface , null ) ; \nString fieldName = interfaceMethod . getName ( ) . substring ( 3 ) ; \nfieldName = fieldName . substring ( 0 , 1 ) . toLowerCase ( ) + fieldName . substring ( 1 ) ; \nString concreteMethodBody = null ; \nif ( interfaceMethod . getName ( ) . startsWith ( \"get\" ) ) { \nconcreteMethodBody = \"{ return ($r)getFieldValue(\\\"\" + fieldName + \"\\\",\" + concreteMethod . getReturnType ( ) . getName ( ) + \".class); }\" ; \n} \nelse { \nif ( interfaceMethod . getName ( ) . startsWith ( \"set\" ) ) { \nconcreteMethodBody = \"{ setFieldValue(\\\"\" + fieldName + \"\\\",$1); }\" ; \n} \nelse { \nthrow new SLEEException ( \"unexpected method name <\" + interfaceMethod . getName ( ) + \"> to implement in sbb aci interface\" ) ; \n} \n} \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + interfaceMethod . getName ( ) + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nconcreteActivityContextInterface . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception cce ) { \nthrow new SLEEException ( \"Cannot compile method \" + interfaceMethod . getName ( ) , cce ) ; \n} \n} \n} \n} \n"}
{"7107": "public class CompositeQueryExpression { \nprotected final void add ( QueryExpression expr ) throws NullPointerException , IllegalArgumentException { \nif ( expr == null ) throw new NullPointerException ( \"expr is null\" ) ; \nif ( expr instanceof CompositeQueryExpression ) { \n( ( CompositeQueryExpression ) expr ) . checkForCycles ( this ) ; \n} \nelse { \nif ( expr instanceof Not ) { \n( ( Not ) expr ) . checkForCycles ( this ) ; \n} \n} \nexprs . add ( expr ) ; \n} \n} \n"}
{"7114": "public class SbbActivityContextInterfaceImpl { \npublic Object getFieldValue ( String fieldName , Class < ? > returnType ) { \nString realFieldName = getRealFieldName ( fieldName ) ; \nObject value = aciImpl . getActivityContext ( ) . getDataAttribute ( realFieldName ) ; \nif ( value == null ) { \nif ( returnType . isPrimitive ( ) ) { \nif ( returnType . equals ( Integer . TYPE ) ) { \nreturn Integer . valueOf ( 0 ) ; \n} \nelse { \nif ( returnType . equals ( Boolean . TYPE ) ) { \nreturn Boolean . FALSE ; \n} \nelse { \nif ( returnType . equals ( Long . TYPE ) ) { \nreturn Long . valueOf ( 0 ) ; \n} \nelse { \nif ( returnType . equals ( Double . TYPE ) ) { \nreturn Double . valueOf ( 0 ) ; \n} \nelse { \nif ( returnType . equals ( Float . TYPE ) ) { \nreturn Float . valueOf ( 0 ) ; \n} \n} \n} \n} \n} \n} \n} \nreturn value ; \n} \n} \n"}
{"7123": "public class ClassGeneratorUtils { \npublic static void addAnnotation ( String annotation , LinkedHashMap < String , Object > memberValues , Object toAnnotate ) { \nif ( toAnnotate instanceof CtClass ) { \nCtClass classToAnnotate = ( CtClass ) toAnnotate ; \nClassFile cf = classToAnnotate . getClassFile ( ) ; \nConstPool cp = cf . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) cf . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) { \nattr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \n} \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) { \naddMemberValuesToAnnotation ( a , cp , memberValues ) ; \n} \nattr . addAnnotation ( a ) ; \ncf . addAttribute ( attr ) ; \n} \nelse { \nif ( toAnnotate instanceof CtMethod ) { \nCtMethod methodToAnnotate = ( CtMethod ) toAnnotate ; \nMethodInfo mi = methodToAnnotate . getMethodInfo ( ) ; \nConstPool cp = mi . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) mi . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) { \nattr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \n} \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) { \naddMemberValuesToAnnotation ( a , cp , memberValues ) ; \n} \nattr . addAnnotation ( a ) ; \nmi . addAttribute ( attr ) ; \n} \nelse { \nif ( toAnnotate instanceof CtField ) { \nCtField fieldToAnnotate = ( CtField ) toAnnotate ; \nFieldInfo fi = fieldToAnnotate . getFieldInfo ( ) ; \nConstPool cp = fi . getConstPool ( ) ; \nAnnotationsAttribute attr = ( AnnotationsAttribute ) fi . getAttribute ( AnnotationsAttribute . visibleTag ) ; \nif ( attr == null ) { \nattr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; \n} \nAnnotation a = new Annotation ( annotation , cp ) ; \nif ( memberValues != null ) { \naddMemberValuesToAnnotation ( a , cp , memberValues ) ; \n} \nattr . addAnnotation ( a ) ; \nfi . addAttribute ( attr ) ; \n} \nelse { \nthrow new UnsupportedOperationException ( \"Unknown object type: \" + toAnnotate . getClass ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"7135": "public class DeployableUnitBuilderImpl { \nprivate void checkDependencies ( SleeComponent sleeComponent , DeployableUnitImpl deployableUnit ) throws DependencyException { \nfor ( ComponentID componentID : sleeComponent . getDependenciesSet ( ) ) { \nif ( componentID instanceof EventTypeID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( EventTypeID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse { \nif ( componentID instanceof LibraryID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( LibraryID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse { \nif ( componentID instanceof ProfileSpecificationID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ProfileSpecificationID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse { \nif ( componentID instanceof ResourceAdaptorID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse { \nif ( componentID instanceof ResourceAdaptorTypeID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorTypeID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse { \nif ( componentID instanceof SbbID ) { \nif ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( SbbID ) componentID ) == null ) { \nthrow new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \nelse { \nif ( componentID instanceof ServiceID ) { \nthrow new SLEEException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on a service component \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"7153": "public class TracerImpl { \nprivate void assignLog4JLevel ( Level log4jLevel ) { \nif ( log4jLevel == null ) { \nreturn ; \n} \nif ( log4jLevel == Level . DEBUG ) { \nlevel = TraceLevel . FINE ; \n} \nelse { \nif ( log4jLevel == Level . INFO ) { \nlevel = TraceLevel . INFO ; \n} \nelse { \nif ( log4jLevel == Level . WARN ) { \nlevel = TraceLevel . WARNING ; \n} \nelse { \nif ( log4jLevel == Level . ERROR ) { \nlevel = TraceLevel . SEVERE ; \n} \nelse { \nif ( log4jLevel == Level . TRACE ) { \nlevel = TraceLevel . FINEST ; \n} \nelse { \nif ( log4jLevel == Level . OFF ) { \nlevel = TraceLevel . OFF ; \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"7170": "public class SleeContainer { \nprivate void validateStateTransition ( SleeState oldState , SleeState newState ) throws InvalidStateException { \nif ( oldState == SleeState . STOPPED ) { \nif ( newState == SleeState . STARTING ) { \nreturn ; \n} \n} \nelse { \nif ( oldState == SleeState . STARTING ) { \nif ( newState == SleeState . RUNNING || newState == SleeState . STOPPING ) { \nreturn ; \n} \n} \nelse { \nif ( oldState == SleeState . RUNNING ) { \nif ( newState == SleeState . STOPPING ) { \nreturn ; \n} \n} \nelse { \nif ( oldState == SleeState . STOPPING ) { \nif ( newState == SleeState . STOPPED ) { \nreturn ; \n} \n} \n} \n} \n} \nthrow new InvalidStateException ( \"illegal slee state transition: \" + oldState + \" -> \" + newState ) ; \n} \n} \n"}
{"7178": "public class RegionRequest { \npublic Rectangle resolve ( Dimension imageDims ) throws ResolvingException { \nif ( square ) { \nif ( imageDims . width > imageDims . height ) { \nreturn new Rectangle ( ( imageDims . width - imageDims . height ) / 2 , 0 , imageDims . height , imageDims . height ) ; \n} \nelse { \nif ( imageDims . height > imageDims . width ) { \nreturn new Rectangle ( 0 , ( imageDims . height - imageDims . width ) / 2 , imageDims . width , imageDims . width ) ; \n} \n} \n} \nif ( absoluteBox == null && relativeBox == null ) { \nreturn new Rectangle ( 0 , 0 , imageDims . width , imageDims . height ) ; \n} \nRectangle rect ; \nif ( isRelative ( ) ) { \nrect = new Rectangle ( ( int ) Math . round ( relativeBox . x . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . y . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) , ( int ) Math . round ( relativeBox . w . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . h . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) ) ; \n} \nelse { \nrect = absoluteBox ; \n} \nif ( rect . x >= imageDims . width || rect . y >= imageDims . height ) { \nthrow new ResolvingException ( \"X and Y must be smaller than the native width/height\" ) ; \n} \nif ( rect . x + rect . width > imageDims . width ) { \nrect . width = imageDims . width - rect . x ; \n} \nif ( rect . y + rect . height > imageDims . height ) { \nrect . height = imageDims . height - rect . y ; \n} \nreturn rect ; \n} \n} \n"}
{"7185": "public class ImageApiProfile { \npublic ImageApiProfile merge ( ImageApiProfile other ) { \nImageApiProfile merged = new ImageApiProfile ( ) ; \nstreamNotNull ( this . features ) . forEach ( merged :: addFeature ) ; \nstreamNotNull ( other . features ) . forEach ( merged :: addFeature ) ; \nstreamNotNull ( this . formats ) . forEach ( merged :: addFormat ) ; \nstreamNotNull ( other . formats ) . forEach ( merged :: addFormat ) ; \nstreamNotNull ( this . qualities ) . forEach ( merged :: addQuality ) ; \nstreamNotNull ( other . qualities ) . forEach ( merged :: addQuality ) ; \nif ( this . maxWidth != null && other . maxWidth == null ) { \nmerged . maxWidth = this . maxWidth ; \n} \nelse { \nif ( this . maxWidth == null && other . maxWidth != null ) { \nmerged . maxWidth = other . maxWidth ; \n} \nelse { \nif ( this . maxWidth != null ) { \nmerged . maxWidth = Math . min ( this . maxWidth , other . maxWidth ) ; \n} \n} \n} \nif ( this . maxHeight != null && other . maxHeight == null ) { \nmerged . maxHeight = this . maxHeight ; \n} \nelse { \nif ( this . maxHeight == null && other . maxHeight != null ) { \nmerged . maxHeight = other . maxHeight ; \n} \nelse { \nif ( this . maxHeight != null ) { \nmerged . maxHeight = Math . min ( this . maxHeight , other . maxHeight ) ; \n} \n} \n} \nif ( this . maxArea != null && other . maxArea == null ) { \nmerged . maxArea = this . maxArea ; \n} \nelse { \nif ( this . maxArea == null && other . maxArea != null ) { \nmerged . maxArea = other . maxArea ; \n} \nelse { \nif ( this . maxArea != null ) { \nmerged . maxArea = Math . min ( this . maxArea , other . maxArea ) ; \n} \n} \n} \nreturn merged ; \n} \n} \n"}
{"7187": "public class SizeRequest { \n@ JsonCreator public static SizeRequest fromString ( String str ) throws ResolvingException { \nif ( str . equals ( \"full\" ) ) { \nreturn new SizeRequest ( ) ; \n} \nif ( str . equals ( \"max\" ) ) { \nreturn new SizeRequest ( true ) ; \n} \nMatcher matcher = PARSE_PAT . matcher ( str ) ; \nif ( ! matcher . matches ( ) ) { \nthrow new ResolvingException ( \"Bad format: \" + str ) ; \n} \nif ( matcher . group ( 1 ) != null ) { \nif ( matcher . group ( 1 ) . equals ( \"!\" ) ) { \nreturn new SizeRequest ( Integer . valueOf ( matcher . group ( 2 ) ) , Integer . valueOf ( matcher . group ( 3 ) ) , true ) ; \n} \nelse { \nif ( matcher . group ( 1 ) . equals ( \"pct:\" ) ) { \nreturn new SizeRequest ( new BigDecimal ( matcher . group ( 4 ) ) ) ; \n} \n} \n} \nInteger width = null ; \nInteger height = null ; \nif ( matcher . group ( 2 ) != null ) { \nwidth = Integer . parseInt ( matcher . group ( 2 ) ) ; \n} \nif ( matcher . group ( 3 ) != null ) { \nheight = Integer . parseInt ( matcher . group ( 3 ) ) ; \n} \nreturn new SizeRequest ( width , height ) ; \n} \n} \n"}
{"7190": "public class AbstractDevice { \npublic boolean handlePopBox ( String deviceBrand ) { \npushHandleGps2Device ( ) ; \nCommandLine exeCommand = null ; \nif ( deviceBrand . contains ( \"HTC\" ) ) { \nexeCommand = adbCommand ( \"shell\" , \"uiautomator\" , \"runtest\" , \"/data/local/tmp/handlePopBox.jar\" , \"-c\" , \"com.test.device.gps.HTCGPSTest\" ) ; \n} \nelse { \nif ( deviceBrand . contains ( \"Meizu\" ) ) { \nexeCommand = adbCommand ( \"shell\" , \"uiautomator\" , \"runtest\" , \"/data/local/tmp/handlePopBox.jar\" , \"-c\" , \"com.test.device.gps.MeizuGPSTest\" ) ; \n} \n} \nString output = executeCommandQuietly ( exeCommand ) ; \nlog . debug ( \"run test {}\" , output ) ; \ntry { \nThread . sleep ( 1000 ) ; \n} \ncatch ( InterruptedException ie ) { \nthrow new RuntimeException ( ie ) ; \n} \nreturn output . contains ( \"OK\" ) ; \n} \n} \n"}
{"7205": "public class BitVectorUtil { \npublic static void appendBitStrings ( BitVector bv , String [ ] bs ) { \nfor ( String s : bs ) { \nif ( s . length ( ) != 8 ) throw new RuntimeException ( \"The length of bit string must be 8  while \" + s . length ( ) ) ; \nfor ( char c : s . toCharArray ( ) ) { \nif ( c == '0' ) bv . append0 ( ) ; \nelse { \nif ( c == '1' ) bv . append1 ( ) ; \nelse throw new RuntimeException ( \"invalid char '\" + c + \"' for bit string.\" ) ; \n} \n} \n} \n} \n} \n"}
{"7229": "public class RecursiveDescentPropertyValidator { \nprivate void ifPropertyBlankRemove ( Map < String , Object > properties , String property ) { \nObject object = properties . get ( property ) ; \nif ( object == null ) { \nproperties . remove ( property ) ; \n} \nelse { \nif ( object instanceof String ) { \nString string = ( String ) object ; \nif ( \"\" . equals ( string . trim ( ) ) ) { \nproperties . remove ( property ) ; \n} \n} \n} \n} \n} \n"}
{"7282": "public class Str { \npublic static String num ( Number count ) { \nif ( count == null ) { \nreturn \"\" ; \n} \nif ( count instanceof Double || count instanceof BigDecimal ) { \nString s = count . toString ( ) ; \nif ( idx ( s , 1 ) == '.' && s . length ( ) > 7 ) { \ns = slc ( s , 0 , 5 ) ; \nreturn s ; \n} \nelse { \nreturn s ; \n} \n} \nelse { \nif ( count instanceof Integer || count instanceof Long || count instanceof Short || count instanceof BigInteger ) { \nString s = count . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nCharBuf buf = CharBuf . create ( s . length ( ) ) ; \nint index = 0 ; \nfor ( char c : s . toCharArray ( ) ) { \nindex ++ ; \nbuf . add ( c ) ; \nif ( index % 3 == 0 ) { \nbuf . add ( ',' ) ; \n} \n} \nif ( buf . lastChar ( ) == ',' ) { \nbuf . removeLastChar ( ) ; \n} \ns = buf . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nreturn s ; \n} \n} \nreturn count . toString ( ) ; \n} \n} \n"}
{"7294": "public class MapperComplex { \nprivate void setFieldValueFromMap ( final Object parentObject , final FieldAccess field , final Map mapInner ) { \nClass < ? > fieldClassType = field . type ( ) ; \nObject value = null ; \nif ( ! Typ . isMap ( fieldClassType ) ) { \nif ( ! fieldClassType . isInterface ( ) && ! Typ . isAbstract ( fieldClassType ) ) { \nvalue = fromMap ( mapInner , field . type ( ) ) ; \n} \nelse { \nObject oClassName = mapInner . get ( \"class\" ) ; \nif ( oClassName != null ) { \nvalue = fromMap ( mapInner , Reflection . loadClass ( oClassName . toString ( ) ) ) ; \n} \nelse { \nvalue = null ; \n} \n} \n} \nelse { \nif ( Typ . isMap ( fieldClassType ) ) { \nClass keyType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 0 ] ; \nClass valueType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 1 ] ; \nSet < Map . Entry > set = mapInner . entrySet ( ) ; \nMap newMap = new LinkedHashMap ( ) ; \nfor ( Map . Entry entry : set ) { \nObject evalue = entry . getValue ( ) ; \nObject key = entry . getKey ( ) ; \nif ( evalue instanceof ValueContainer ) { \nevalue = ( ( ValueContainer ) evalue ) . toValue ( ) ; \n} \nkey = Conversions . coerce ( keyType , key ) ; \nevalue = Conversions . coerce ( valueType , evalue ) ; \nnewMap . put ( key , evalue ) ; \n} \nvalue = newMap ; \n} \n} \nfield . setValue ( parentObject , value ) ; \n} \n} \n"}
{"7297": "public class Lists { \n@ Universal public static < V > List < V > deepCopy ( List < V > list ) { \nif ( list instanceof LinkedList ) { \nreturn deepCopyToList ( list , new LinkedList < V > ( ) ) ; \n} \nelse { \nif ( list instanceof CopyOnWriteArrayList ) { \nreturn deepCopyToList ( list , new CopyOnWriteArrayList < V > ( ) ) ; \n} \nelse { \nreturn deepCopy ( ( Collection ) list ) ; \n} \n} \n} \n} \n"}
{"7304": "public class CacheEntry { \nprivate final int compareTime ( CacheEntry other ) { \nif ( time > other . time ) { \nreturn 1 ; \n} \nelse { \nif ( time < other . time ) { \nreturn - 1 ; \n} \nelse { \nif ( time == other . time ) { \nreturn 0 ; \n} \n} \n} \ndie ( ) ; \nreturn 0 ; \n} \n} \n"}
{"7317": "public class LongRangeValidator { \nprivate void dynamicallyInitIfNeeded ( Object value ) { \nif ( ! isInitialized ( ) ) { \nif ( value instanceof Integer ) { \ninit ( new Integer ( min . intValue ( ) ) , new Integer ( max . intValue ( ) ) ) ; \n} \nelse { \nif ( value instanceof Byte ) { \ninit ( new Byte ( min . byteValue ( ) ) , new Byte ( max . byteValue ( ) ) ) ; \n} \nelse { \nif ( value instanceof Short ) { \ninit ( new Short ( min . shortValue ( ) ) , new Short ( max . shortValue ( ) ) ) ; \n} \nelse { \ninit ( min , max ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7349": "public class BeanUtils { \npublic static Object getPropByPath ( Object item , String ... path ) { \nObject o = item ; \nfor ( int index = 0 ; \nindex < path . length ; \nindex ++ ) { \nString propName = path [ index ] ; \nif ( o == null ) { \nreturn null ; \n} \nelse { \nif ( o . getClass ( ) . isArray ( ) || o instanceof Collection ) { \no = getCollectionProp ( o , propName , index , path ) ; \nbreak ; \n} \nelse { \no = getProp ( o , propName ) ; \n} \n} \n} \nreturn Conversions . unifyListOrArray ( o ) ; \n} \n} \n"}
{"7357": "public class MessageSpecification { \npublic void init ( ) { \nif ( name == null && parent == null ) { \nthis . setDetailMessage ( \"{\" + this . getClass ( ) . getName ( ) + DETAIL_KEY + \"}\" ) ; \nthis . setSummaryMessage ( \"{\" + this . getClass ( ) . getName ( ) + SUMMARY_KEY + \"}\" ) ; \n} \nelse { \nif ( name != null && parent == null ) { \nthis . setDetailMessage ( \"{\" + \"message.\" + getName ( ) + DETAIL_KEY + \"}\" ) ; \nthis . setSummaryMessage ( \"{\" + \"message.\" + getName ( ) + SUMMARY_KEY + \"}\" ) ; \n} \nelse { \nif ( parent != null ) { \nthis . setDetailMessage ( \"{\" + \"message.\" + parent + DETAIL_KEY + \"}\" ) ; \nthis . setSummaryMessage ( \"{\" + \"message.\" + parent + SUMMARY_KEY + \"}\" ) ; \n} \n} \n} \n} \n} \n"}
{"7358": "public class MessageSpecification { \npublic String createMessage ( String key , List < String > argKeys , Object ... args ) { \nString message = getMessage ( key ) ; \nObject [ ] actualArgs ; \nif ( args . length > 0 ) { \nactualArgs = args ; \n} \nelse { \nif ( argKeys != null ) { \nactualArgs = keysToValues ( argKeys ) ; \n} \nelse { \nactualArgs = new Object [ ] { \n} \n; \n} \n} \nreturn doCreateMessage ( message , actualArgs ) ; \n} \n} \n"}
{"7374": "public class CouchDbDesign { \npublic DesignDocument getFromDesk ( String id ) { \nassertNotEmpty ( id , \"id\" ) ; \nfinal DesignDocument dd = new DesignDocument ( ) ; \nfinal String rootPath = format ( \"%s/%s/\" , DESIGN_DOCS_DIR , id ) ; \nfinal List < String > elements = listResources ( rootPath ) ; \nif ( elements == null ) { \nthrow new IllegalArgumentException ( \"Design docs directory cannot be empty.\" ) ; \n} \nMap < String , MapReduce > views = null ; \nif ( elements . contains ( VIEWS ) ) { \nviews = new HashMap < String , MapReduce > ( ) ; \nfinal String viewsPath = format ( \"%s%s/\" , rootPath , VIEWS ) ; \nfor ( String viewDirName : listResources ( viewsPath ) ) { \nfinal MapReduce mr = new MapReduce ( ) ; \nfinal String viewPath = format ( \"%s%s/\" , viewsPath , viewDirName ) ; \nfinal List < String > dirList = listResources ( viewPath ) ; \nfor ( String fileName : dirList ) { \nfinal String def = readFile ( format ( \"/%s%s\" , viewPath , fileName ) ) ; \nif ( MAP_JS . equals ( fileName ) ) mr . setMap ( def ) ; \nelse { \nif ( REDUCE_JS . equals ( fileName ) ) mr . setReduce ( def ) ; \n} \n} \nviews . put ( viewDirName , mr ) ; \n} \n} \ndd . setId ( DESIGN_PREFIX + id ) ; \ndd . setLanguage ( JAVASCRIPT ) ; \ndd . setViews ( views ) ; \ndd . setFilters ( populateMap ( rootPath , elements , FILTERS ) ) ; \ndd . setShows ( populateMap ( rootPath , elements , SHOWS ) ) ; \ndd . setLists ( populateMap ( rootPath , elements , LISTS ) ) ; \ndd . setUpdates ( populateMap ( rootPath , elements , UPDATES ) ) ; \ndd . setValidateDocUpdate ( readContent ( elements , rootPath , VALIDATE_DOC ) ) ; \ndd . setRewrites ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , REWRITES ) , JsonArray . class ) ) ; \ndd . setFulltext ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , FULLTEXT ) , JsonObject . class ) ) ; \ndd . setIndexes ( dbc . getGson ( ) . fromJson ( readContent ( elements , rootPath , INDEXES ) , JsonObject . class ) ) ; \nreturn dd ; \n} \n} \n"}
{"7398": "public class TokenAuthenticator { \nprivate boolean isQuery ( HttpServerExchange serverExchange ) { \nif ( serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"GET\" ) || serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"HEAD\" ) ) { \nreturn true ; \n} \nelse { \nif ( serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"POST\" ) ) { \nif ( postQuery != null && postQuery . matcher ( serverExchange . getRelativePath ( ) ) . find ( ) ) { \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \nelse { \nreturn false ; \n} \n} \n} \n} \n"}
{"7413": "public class MockJedis { \n@ Override public ScanResult < String > scan ( String cursor , ScanParams params ) { \nCollection < byte [ ] > rawParams = params . getParams ( ) ; \nboolean isKey = true ; \nString match = null ; \nboolean foundMatchKey = false ; \nfor ( byte [ ] raw : rawParams ) { \nif ( isKey ) { \nString key = new String ( raw ) ; \nif ( key . equals ( new String ( MATCH . raw ) ) ) { \nfoundMatchKey = true ; \n} \n} \nelse { \nif ( foundMatchKey ) { \nmatch = new String ( raw ) ; \nbreak ; \n} \n} \nisKey = ! isKey ; \n} \nreturn new ScanResult < String > ( \"0\" , new ArrayList < String > ( keys ( match ) ) ) ; \n} \n} \n"}
{"7479": "public class DistancePointTriangle3D_F64 { \npublic void closestPoint ( Point3D_F64 P , Point3D_F64 closestPt ) { \nGeometryMath_F64 . sub ( B , P , D ) ; \na = E0 . dot ( E0 ) ; \nb = E0 . dot ( E1 ) ; \nc = E1 . dot ( E1 ) ; \nd = E0 . dot ( D ) ; \ne = E1 . dot ( D ) ; \ndouble det = a * c - b * b ; \ns = b * e - c * d ; \nt = b * d - a * e ; \nif ( s + t <= det ) { \nif ( s < 0 ) { \nif ( t < 0 ) { \nregion4 ( ) ; \n} \nelse { \nregion3 ( ) ; \n} \n} \nelse { \nif ( t < 0 ) { \nregion5 ( ) ; \n} \nelse { \nregion0 ( det ) ; \n} \n} \n} \nelse { \nif ( s < 0 ) { \nregion2 ( ) ; \n} \nelse { \nif ( t < 0 ) { \nregion6 ( ) ; \n} \nelse { \nregion1 ( ) ; \n} \n} \n} \nclosestPt . x = B . x + s * E0 . x + t * E1 . x ; \nclosestPt . y = B . y + s * E0 . y + t * E1 . y ; \nclosestPt . z = B . z + s * E0 . z + t * E1 . z ; \n} \n} \n"}
{"7486": "public class UtilPolygons2D_F64 { \npublic static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { \nrectangle . p0 . set ( polygon . get ( 0 ) ) ; \nrectangle . p1 . set ( polygon . get ( 0 ) ) ; \nfor ( int i = 0 ; \ni < polygon . size ( ) ; \ni ++ ) { \nPoint2D_F64 p = polygon . get ( i ) ; \nif ( p . x < rectangle . p0 . x ) { \nrectangle . p0 . x = p . x ; \n} \nelse { \nif ( p . x > rectangle . p1 . x ) { \nrectangle . p1 . x = p . x ; \n} \n} \nif ( p . y < rectangle . p0 . y ) { \nrectangle . p0 . y = p . y ; \n} \nelse { \nif ( p . y > rectangle . p1 . y ) { \nrectangle . p1 . y = p . y ; \n} \n} \n} \n} \n} \n"}
{"7503": "public class ConvertRotation3D_F64 { \npublic static Quaternion_F64 matrixToQuaternion ( DMatrixRMaj R , Quaternion_F64 quat ) { \nif ( quat == null ) quat = new Quaternion_F64 ( ) ; \ndouble m00 = R . unsafe_get ( 0 , 0 ) ; \ndouble m01 = R . unsafe_get ( 0 , 1 ) ; \ndouble m02 = R . unsafe_get ( 0 , 2 ) ; \ndouble m10 = R . unsafe_get ( 1 , 0 ) ; \ndouble m11 = R . unsafe_get ( 1 , 1 ) ; \ndouble m12 = R . unsafe_get ( 1 , 2 ) ; \ndouble m20 = R . unsafe_get ( 2 , 0 ) ; \ndouble m21 = R . unsafe_get ( 2 , 1 ) ; \ndouble m22 = R . unsafe_get ( 2 , 2 ) ; \ndouble trace = m00 + m11 + m22 ; \nif ( trace > 0 ) { \ndouble S = Math . sqrt ( trace + 1.0 ) * 2 ; \nquat . w = 0.25 * S ; \nquat . x = ( m21 - m12 ) / S ; \nquat . y = ( m02 - m20 ) / S ; \nquat . z = ( m10 - m01 ) / S ; \n} \nelse { \nif ( ( m00 > m11 ) & ( m00 > m22 ) ) { \ndouble S = Math . sqrt ( 1.0 + m00 - m11 - m22 ) * 2 ; \nquat . w = ( m21 - m12 ) / S ; \nquat . x = 0.25 * S ; \nquat . y = ( m01 + m10 ) / S ; \nquat . z = ( m02 + m20 ) / S ; \n} \nelse { \nif ( m11 > m22 ) { \ndouble S = Math . sqrt ( 1.0 + m11 - m00 - m22 ) * 2 ; \nquat . w = ( m02 - m20 ) / S ; \nquat . x = ( m01 + m10 ) / S ; \nquat . y = 0.25 * S ; \nquat . z = ( m12 + m21 ) / S ; \n} \nelse { \ndouble S = Math . sqrt ( 1.0 + m22 - m00 - m11 ) * 2 ; \nquat . w = ( m10 - m01 ) / S ; \nquat . x = ( m02 + m20 ) / S ; \nquat . y = ( m12 + m21 ) / S ; \nquat . z = 0.25 * S ; \n} \n} \n} \nreturn quat ; \n} \n} \n"}
{"7524": "public class GeometryMath_F64 { \npublic static DMatrixRMaj toMatrix ( GeoTuple3D_F64 in , DMatrixRMaj out ) { \nif ( out == null ) out = new DMatrixRMaj ( 3 , 1 ) ; \nelse { \nif ( out . getNumElements ( ) != 3 ) throw new IllegalArgumentException ( \"Vector with 3 elements expected\" ) ; \n} \nout . data [ 0 ] = in . x ; \nout . data [ 1 ] = in . y ; \nout . data [ 2 ] = in . z ; \nreturn out ; \n} \n} \n"}
{"7545": "public class ClosestPoint3D_F64 { \npublic static Point3D_F64 closestPoint ( LineSegment3D_F64 line , Point3D_F64 pt , Point3D_F64 ret ) { \nif ( ret == null ) { \nret = new Point3D_F64 ( ) ; \n} \ndouble dx = pt . x - line . a . x ; \ndouble dy = pt . y - line . a . y ; \ndouble dz = pt . z - line . a . z ; \ndouble slope_x = line . b . x - line . a . x ; \ndouble slope_y = line . b . y - line . a . y ; \ndouble slope_z = line . b . z - line . a . z ; \ndouble n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; \ndouble d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; \nif ( d <= 0 ) { \nret . set ( line . a ) ; \n} \nelse { \nif ( d >= n ) { \nret . set ( line . b ) ; \n} \nelse { \nret . x = line . a . x + d * slope_x / n ; \nret . y = line . a . y + d * slope_y / n ; \nret . z = line . a . z + d * slope_z / n ; \n} \n} \nreturn ret ; \n} \n} \n"}
{"7550": "public class UtilLine2D_F64 { \npublic static double acuteAngle ( LineGeneral2D_F64 a , LineGeneral2D_F64 b ) { \ndouble la = Math . sqrt ( a . A * a . A + a . B * a . B ) ; \ndouble lb = Math . sqrt ( b . A * b . A + b . B * b . B ) ; \ndouble value = ( a . A * b . A + a . B * b . B ) / ( la * lb ) ; \nif ( value < - 1.0 ) value = - 1.0 ; \nelse { \nif ( value > 1.0 ) value = 1.0 ; \n} \nreturn Math . acos ( value ) ; \n} \n} \n"}
{"7568": "public class UtilLine3D_F64 { \npublic static double computeT ( LineParametric3D_F64 line , Point3D_F64 pointOnLine ) { \ndouble dx = pointOnLine . x - line . p . x ; \ndouble dy = pointOnLine . y - line . p . y ; \ndouble dz = pointOnLine . z - line . p . z ; \ndouble adx = Math . abs ( dx ) ; \ndouble ady = Math . abs ( dy ) ; \ndouble adz = Math . abs ( dz ) ; \ndouble t ; \nif ( adx > ady ) { \nif ( adx > adz ) { \nt = dx / line . slope . x ; \n} \nelse { \nt = dz / line . slope . z ; \n} \n} \nelse { \nif ( ady > adz ) { \nt = dy / line . slope . y ; \n} \nelse { \nt = dz / line . slope . z ; \n} \n} \nreturn t ; \n} \n} \n"}
{"7587": "public class Distance3D_F64 { \npublic static double distance ( LineSegment3D_F64 l , Point3D_F64 p ) { \ndouble dx = p . x - l . a . x ; \ndouble dy = p . y - l . a . y ; \ndouble dz = p . z - l . a . z ; \ndouble cc = dx * dx + dy * dy + dz * dz ; \ndouble slope_x = l . b . x - l . a . x ; \ndouble slope_y = l . b . y - l . a . y ; \ndouble slope_z = l . b . z - l . a . z ; \ndouble n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; \ndouble d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; \nif ( d <= 0 ) return p . distance ( l . a ) ; \nelse { \nif ( d >= n ) return p . distance ( l . b ) ; \n} \ndouble distanceSq = cc - d * d ; \nif ( distanceSq < 0 ) { \nreturn 0 ; \n} \nelse { \nreturn Math . sqrt ( distanceSq ) ; \n} \n} \n} \n"}
{"7600": "public class ClosestPoint2D_F64 { \npublic static Point2D_F64 closestPoint ( LineSegment2D_F64 line , Point2D_F64 p , Point2D_F64 output ) { \nif ( output == null ) output = new Point2D_F64 ( ) ; \ndouble slopeX = line . b . x - line . a . x ; \ndouble slopeY = line . b . y - line . a . y ; \ndouble t = slopeX * ( p . x - line . a . x ) + slopeY * ( p . y - line . a . y ) ; \nt /= slopeX * slopeX + slopeY * slopeY ; \nif ( t < 0 ) t = 0 ; \nelse { \nif ( t > 1 ) t = 1 ; \n} \noutput . x = line . a . x + slopeX * t ; \noutput . y = line . a . y + slopeY * t ; \nreturn output ; \n} \n} \n"}
{"7633": "public class InstallFeatureUtil { \nprivate Set < String > getServerXmlFeatures ( Set < String > origResult , File serverFile , List < File > parsedXmls ) { \nSet < String > result = origResult ; \nList < File > updatedParsedXmls = parsedXmls != null ? parsedXmls : new ArrayList < File > ( ) ; \nFile canonicalServerFile ; \ntry { \ncanonicalServerFile = serverFile . getCanonicalFile ( ) ; \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be accessed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nupdatedParsedXmls . add ( canonicalServerFile ) ; \nif ( canonicalServerFile . exists ( ) ) { \ntry { \nDocument doc = new XmlDocument ( ) { \npublic Document getDocument ( File file ) throws IOException , ParserConfigurationException , SAXException { \ncreateDocument ( file ) ; \nreturn doc ; \n} \n} \n. getDocument ( canonicalServerFile ) ; \nElement root = doc . getDocumentElement ( ) ; \nNodeList nodes = root . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nodes . getLength ( ) ; \ni ++ ) { \nif ( nodes . item ( i ) instanceof Element ) { \nElement child = ( Element ) nodes . item ( i ) ; \nif ( \"featureManager\" . equals ( child . getNodeName ( ) ) ) { \nif ( result == null ) { \nresult = new HashSet < String > ( ) ; \n} \nresult . addAll ( parseFeatureManagerNode ( child ) ) ; \n} \nelse { \nif ( \"include\" . equals ( child . getNodeName ( ) ) ) { \nresult = parseIncludeNode ( result , canonicalServerFile , child , updatedParsedXmls ) ; \n} \n} \n} \n} \n} \ncatch ( IOException | ParserConfigurationException | SAXException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be parsed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7643": "public class InstallFeatureUtil { \nprivate static boolean isReplacementJar ( File file1 , File file2 ) { \nif ( file1 == null ) { \nreturn true ; \n} \nelse { \nif ( file2 == null ) { \nreturn false ; \n} \nelse { \nString version1 = extractVersion ( file1 . getName ( ) ) ; \nString version2 = extractVersion ( file2 . getName ( ) ) ; \nreturn compare ( version1 , version2 ) < 0 ; \n} \n} \n} \n} \n"}
{"7645": "public class InstallFeatureUtil { \nprivate static int compare ( String version1 , String version2 ) { \nif ( version1 == null && version2 == null ) { \nreturn 0 ; \n} \nelse { \nif ( version1 == null && version2 != null ) { \nreturn - 1 ; \n} \nelse { \nif ( version1 != null && version2 == null ) { \nreturn 1 ; \n} \n} \n} \nString [ ] components1 = version1 . split ( \"\\\\.\" ) ; \nString [ ] components2 = version2 . split ( \"\\\\.\" ) ; \nfor ( int i = 0 ; \ni < components1 . length && i < components2 . length ; \ni ++ ) { \nint comparison ; \ntry { \ncomparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; \n} \ncatch ( NumberFormatException e ) { \ncomparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; \n} \nif ( comparison != 0 ) { \nreturn comparison ; \n} \n} \nreturn components1 . length - components2 . length ; \n} \n} \n"}
{"7648": "public class LibertyProperty { \nprivate static LibertyPropertyI getArquillianProperty ( String key , Class < ? > cls ) throws ArquillianConfigurationException { \ntry { \nif ( cls == LibertyManagedObject . LibertyManagedProperty . class ) { \nreturn LibertyManagedObject . LibertyManagedProperty . valueOf ( key ) ; \n} \nelse { \nif ( cls == LibertyRemoteObject . LibertyRemoteProperty . class ) { \nreturn LibertyRemoteObject . LibertyRemoteProperty . valueOf ( key ) ; \n} \n} \n} \ncatch ( IllegalArgumentException e ) { \nthrow new ArquillianConfigurationException ( \"Property \\\"\" + key + \"\\\" in arquillianProperties does not exist. You probably have a typo.\" ) ; \n} \nthrow new ArquillianConfigurationException ( \"This should never happen.\" ) ; \n} \n} \n"}
{"7673": "public class JerseyUtil { \npublic static void registerGuiceBound ( Injector injector , final JerseyEnvironment environment ) { \nwhile ( injector != null ) { \nfor ( Key < ? > key : injector . getBindings ( ) . keySet ( ) ) { \nType type = key . getTypeLiteral ( ) . getType ( ) ; \nif ( type instanceof Class ) { \nClass < ? > c = ( Class ) type ; \nif ( isProviderClass ( c ) ) { \nlogger . info ( \"Registering {} as a provider class\" , c . getName ( ) ) ; \nenvironment . register ( c ) ; \n} \nelse { \nif ( isRootResourceClass ( c ) ) { \nif ( Resource . isAcceptable ( c ) ) { \nlogger . info ( \"Registering {} as a root resource class\" , c . getName ( ) ) ; \nenvironment . register ( c ) ; \n} \nelse { \nlogger . warn ( \"Class {} was not registered as a resource. Bind a concrete implementation instead.\" , c . getName ( ) ) ; \n} \n} \n} \n} \n} \ninjector = injector . getParent ( ) ; \n} \n} \n} \n"}
{"7685": "public class RobeExceptionMapper { \n@ Override public Response toResponse ( Exception e ) { \nString id = System . nanoTime ( ) + \"\" ; \nLOGGER . error ( id , e ) ; \nif ( e instanceof RobeRuntimeException ) { \nreturn ( ( RobeRuntimeException ) e ) . getResponse ( id ) ; \n} \nelse { \nif ( e instanceof ConstraintViolationException ) { \nConstraintViolationException exception = ( ConstraintViolationException ) e ; \nRobeMessage [ ] errors = new RobeMessage [ exception . getConstraintViolations ( ) . size ( ) ] ; \nint i = 0 ; \nfor ( ConstraintViolation error : exception . getConstraintViolations ( ) ) { \nerrors [ i ++ ] = new RobeMessage . Builder ( ) . message ( error . getMessage ( ) ) . status ( 422 ) . id ( id ) . build ( ) ; \n} \nreturn Response . status ( 422 ) . entity ( errors ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse { \nif ( e instanceof WebApplicationException ) { \nWebApplicationException we = ( WebApplicationException ) e ; \nRobeMessage error = new RobeMessage . Builder ( ) . id ( id ) . message ( we . getMessage ( ) ) . status ( we . getResponse ( ) . getStatus ( ) ) . build ( ) ; \nreturn Response . fromResponse ( we . getResponse ( ) ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \nelse { \nif ( e . getClass ( ) . getName ( ) . equals ( \"org.hibernate.exception.ConstraintViolationException\" ) ) { \nif ( e . getCause ( ) != null && e . getCause ( ) . getMessage ( ) != null ) { \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getCause ( ) . getMessage ( ) . split ( \"for\" ) [ 0 ] ) . status ( Response . Status . CONFLICT . getStatusCode ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . CONFLICT ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \n} \nRobeMessage error = new RobeMessage . Builder ( ) . message ( e . getMessage ( ) ) . id ( id ) . build ( ) ; \nreturn Response . status ( Response . Status . INTERNAL_SERVER_ERROR ) . entity ( error ) . type ( MediaType . APPLICATION_JSON ) . build ( ) ; \n} \n} \n} \n} \n} \n"}
{"7691": "public class AbstractAuthResource { \npublic void changePassword ( T user , String currentPassword , String newPassword , String newPassword2 ) throws AuthenticationException { \nverifyPassword ( user , currentPassword ) ; \nif ( ! newPassword . equals ( newPassword2 ) ) { \nthrow new AuthenticationException ( user . getUsername ( ) + \": New password and re-type password must be same\" ) ; \n} \nelse { \nif ( newPassword . equals ( currentPassword ) ) { \nthrow new AuthenticationException ( user . getUsername ( ) + \": New password and old password must be different\" ) ; \n} \n} \nverifyPasswordStrength ( currentPassword , newPassword , user ) ; \nOptional < ? extends UserEntry > optional = userStore . changePassword ( user . getUsername ( ) , newPassword ) ; \nif ( ! optional . isPresent ( ) ) { \nthrow new AuthenticationException ( user . getUsername ( ) + \": Can't update UserEntry Password\" ) ; \n} \n} \n} \n"}
{"7696": "public class SearchFactory { \n@ Override public SearchModel provide ( ) { \nSearchModel searchModel = new SearchModel ( ) ; \nsearchModel . setResponse ( response ) ; \nString method = getMethod ( ) ; \nif ( \"GET\" . equals ( method ) ) { \nMultivaluedMap < String , String > queryParameters = getUriInfo ( ) . getQueryParameters ( ) ; \nfor ( Map . Entry < String , List < String > > param : queryParameters . entrySet ( ) ) { \nif ( param . getValue ( ) . get ( 0 ) == null ) continue ; \nif ( \"_q\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setQ ( param . getValue ( ) . get ( 0 ) ) ; \n} \nelse { \nif ( \"_limit\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setLimit ( Integer . parseInt ( param . getValue ( ) . get ( 0 ) ) ) ; \n} \nelse { \nif ( \"_offset\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setOffset ( Integer . parseInt ( param . getValue ( ) . get ( 0 ) ) ) ; \n} \nelse { \nif ( \"_fields\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setFields ( param . getValue ( ) . get ( 0 ) . split ( \",\" ) ) ; \n} \nelse { \nif ( \"_sort\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setSort ( param . getValue ( ) . get ( 0 ) . split ( \",\" ) ) ; \n} \nelse { \nif ( \"_filter\" . equalsIgnoreCase ( param . getKey ( ) ) ) { \nsearchModel . setFilterExpression ( param . getValue ( ) . get ( 0 ) ) ; \n} \n} \n} \n} \n} \n} \n} \n} \nreturn searchModel ; \n} \n} \n"}
{"7742": "public class LocationForecastHelper { \npublic Optional < MeteoExtrasForecast > findNearestForecast ( ZonedDateTime dateTime ) { \nZonedDateTime dt = toZeroMSN ( dateTime . withZoneSameInstant ( METZONE ) ) ; \nPointForecast chosenForecast = null ; \nfor ( Forecast forecast : getLocationForecast ( ) . getForecasts ( ) ) { \nif ( forecast instanceof PointForecast ) { \nPointForecast pointForecast = ( PointForecast ) forecast ; \nif ( isDateMatch ( dt , cloneZonedDateTime ( pointForecast . getFrom ( ) ) ) ) { \nchosenForecast = pointForecast ; \nbreak ; \n} \nelse { \nif ( chosenForecast == null ) { \nchosenForecast = pointForecast ; \n} \nelse { \nif ( isNearerDate ( pointForecast . getFrom ( ) , dt , chosenForecast . getFrom ( ) ) ) { \nchosenForecast = pointForecast ; \n} \n} \n} \n} \n} \nif ( chosenForecast == null ) { \nreturn Optional . empty ( ) ; \n} \nreturn Optional . of ( new MeteoExtrasForecast ( chosenForecast , getIndexer ( ) . getWidestFitPeriodForecast ( chosenForecast . getFrom ( ) ) . orElse ( null ) ) ) ; \n} \n} \n"}
{"7751": "public class SunriseDate { \npublic boolean isSun ( ZonedDateTime currentDate ) { \nif ( getSun ( ) . getNeverRise ( ) ) { \nreturn false ; \n} \nelse { \nif ( getSun ( ) . getNeverSet ( ) ) { \nreturn true ; \n} \n} \nreturn timeWithinPeriod ( currentDate ) ; \n} \n} \n"}
{"7753": "public class MeteoForecastIndexer { \nOptional < PeriodForecast > getBestFitPeriodForecast ( ZonedDateTime from , ZonedDateTime to ) { \nif ( from == null || to == null ) { \nreturn Optional . empty ( ) ; \n} \nZonedDateTime requestFrom = toZeroMSN ( from ) ; \nZonedDateTime requestTo = toZeroMSN ( to ) ; \nList < PeriodForecast > forecastsList = dayIndex . get ( new DayIndexKey ( requestFrom ) ) ; \nif ( forecastsList == null ) { \nreturn Optional . empty ( ) ; \n} \nPeriodForecast chosenForecast = null ; \nlong score = 0 ; \nlong tmpScore = 0 ; \nfor ( PeriodForecast forecast : forecastsList ) { \nZonedDateTime actualFrom = cloneZonedDateTime ( forecast . getFrom ( ) ) ; \nZonedDateTime actualTo = cloneZonedDateTime ( forecast . getTo ( ) ) ; \nif ( requestFrom . equals ( actualFrom ) && requestTo . equals ( actualTo ) ) { \nreturn Optional . of ( forecast ) ; \n} \nelse { \nif ( ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualFrom ) ) || ( requestFrom . isAfter ( actualTo ) && requestTo . isAfter ( actualTo ) ) || actualTo . isEqual ( actualFrom ) ) { \ncontinue ; \n} \nelse { \nif ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualTo ) ) { \ntmpScore = hoursBetween ( requestTo , actualFrom ) ; \n} \nelse { \nif ( ( actualFrom . isBefore ( requestFrom ) || actualFrom . isEqual ( requestFrom ) ) && actualTo . isBefore ( requestTo ) ) { \ntmpScore = hoursBetween ( actualTo , requestFrom ) ; \n} \nelse { \nif ( actualFrom . isAfter ( requestFrom ) && ( actualTo . isBefore ( requestTo ) || actualTo . isEqual ( requestTo ) ) ) { \ntmpScore = hoursBetween ( actualTo , actualFrom ) ; \n} \nelse { \nif ( actualFrom . isBefore ( requestFrom ) && actualTo . isAfter ( requestTo ) ) { \ntmpScore = hoursBetween ( requestTo , requestFrom ) ; \n} \nelse { \nDateTimeFormatter formatter = DateTimeFormatter . ofPattern ( \"yyyy-MM-dd:HH:mm\" ) ; \nlog . warn ( \"Unhandled forecast Requested period:\" + requestFrom . format ( formatter ) + \"--\" + requestTo . format ( formatter ) + \", Actual period: \" + actualFrom . format ( formatter ) + \"--\" + actualTo . format ( formatter ) ) ; \n} \n} \n} \n} \n} \n} \ntmpScore = Math . abs ( tmpScore ) ; \nif ( ( score == 0 && tmpScore > 0 ) || tmpScore > score ) { \nscore = tmpScore ; \nchosenForecast = forecast ; \n} \n} \nreturn Optional . ofNullable ( chosenForecast ) ; \n} \n} \n"}
{"7756": "public class Application { \nprivate void updateDB ( ) throws SQLException , LiquibaseException { \nSystem . out . println ( \"About to perform DB update.\" ) ; \ntry ( BasicDataSource dataSource = new BasicDataSource ( ) ) { \ndataSource . setUrl ( fullConnectionString ) ; \ndataSource . setUsername ( username ) ; \ndataSource . setPassword ( password ) ; \ntry ( java . sql . Connection c = dataSource . getConnection ( ) ) { \nDatabase database = DatabaseFactory . getInstance ( ) . findCorrectDatabaseImplementation ( new JdbcConnection ( c ) ) ; \nLiquibase liquibase = null ; \nClassLoaderResourceAccessor accessor = new ClassLoaderResourceAccessor ( ) ; \ntry { \nif ( accessor . getResourcesAsStream ( \"changelog-master.xml\" ) != null ) { \nliquibase = new Liquibase ( \"changelog-master.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \n} \nelse { \nif ( accessor . getResourcesAsStream ( \"changelog.xml\" ) != null ) { \nliquibase = new Liquibase ( \"changelog.xml\" , new ClassLoaderResourceAccessor ( ) , database ) ; \n} \nelse { \nString errorMessage = \"No liquibase changelog-master.xml or changelog.xml could be located\" ; \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , errorMessage , this ) ; \nthrow new RuntimeException ( errorMessage ) ; \n} \n} \n} \ncatch ( final IOException ioe ) { \nLogger . getLogger ( Application . class . getName ( ) ) . log ( Level . SEVERE , ioe . getMessage ( ) , ioe ) ; \n} \nliquibase . getLog ( ) . setLogLevel ( logLevel ) ; \nliquibase . update ( new Contexts ( ) ) ; \nSystem . out . println ( \"DB update finished.\" ) ; \n} \n} \n} \n} \n"}
{"7782": "public class Compiler { \nprivate Subre parse ( int stopper , int type , State initState , State finalState ) throws RegexException { \nState left ; \nState right ; \nSubre branches ; \nSubre branch ; \nSubre t ; \nint firstbranch ; \nassert stopper == ')' || stopper == EOS ; \nbranches = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; \nbranch = branches ; \nfirstbranch = 1 ; \ndo { \nif ( 0 == firstbranch ) { \nbranch . right = new Subre ( '|' , Subre . LONGER , initState , finalState ) ; \nbranch = branch . right ; \n} \nfirstbranch = 0 ; \nleft = nfa . newstate ( ) ; \nright = nfa . newstate ( ) ; \nnfa . emptyarc ( initState , left ) ; \nnfa . emptyarc ( right , finalState ) ; \nbranch . left = parsebranch ( stopper , type , left , right , false ) ; \nbranch . flags |= up ( branch . flags | branch . left . flags ) ; \nif ( ( branch . flags & ~ branches . flags ) != 0 ) { \nfor ( t = branches ; \nt != branch ; \nt = t . right ) { \nt . flags |= branch . flags ; \n} \n} \n} \nwhile ( eat ( '|' ) ) ; \nassert see ( stopper ) || see ( EOS ) ; \nif ( ! see ( stopper ) ) { \nassert stopper == ')' && see ( EOS ) ; \nthrow new RegexException ( \"Unbalanced parentheses.\" ) ; \n} \nif ( branch == branches ) { \nassert branch . right == null ; \nt = branch . left ; \nbranch . left = null ; \nbranches = t ; \n} \nelse { \nif ( ! messy ( branches . flags ) ) { \nbranches . left = null ; \nbranches . right = null ; \nbranches . op = '=' ; \n} \n} \nreturn branches ; \n} \n} \n"}
{"7795": "public class ColorMap { \nvoid okcolors ( Nfa nfa ) { \nColorDesc cd ; \nColorDesc scd ; \nArc a ; \nshort sco ; \nfor ( short co = 0 ; \nco < colorDescs . size ( ) ; \nco ++ ) { \ncd = colorDescs . get ( co ) ; \nif ( cd == null ) { \ncontinue ; \n} \nsco = cd . sub ; \nif ( sco == Constants . NOSUB ) { \n} \nelse { \nif ( sco == co ) { \n} \nelse { \nif ( cd . getNChars ( ) == 0 ) { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nwhile ( ( a = cd . arcs ) != null ) { \nassert a . co == co ; \ncd . arcs = a . colorchain ; \na . setColor ( sco ) ; \na . colorchain = scd . arcs ; \nscd . arcs = a ; \n} \nfreecolor ( co ) ; \n} \nelse { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert scd . getNChars ( ) > 0 ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nfor ( a = cd . arcs ; \na != null ; \na = a . colorchain ) { \nassert a . co == co ; \nnfa . newarc ( a . type , sco , a . from , a . to ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"7799": "public class Lex { \nvoid lexstart ( ) throws RegexException { \nprefixes ( ) ; \nif ( 0 != ( v . cflags & Flags . REG_QUOTE ) ) { \nassert 0 == ( v . cflags & ( Flags . REG_ADVANCED | Flags . REG_EXPANDED | Flags . REG_NEWLINE ) ) ; \nintocon ( L_Q ) ; \n} \nelse { \nif ( 0 != ( v . cflags & Flags . REG_EXTENDED ) ) { \nassert 0 == ( v . cflags & Flags . REG_QUOTE ) ; \nintocon ( L_ERE ) ; \n} \nelse { \nassert 0 == ( v . cflags & ( Flags . REG_QUOTE | Flags . REG_ADVF ) ) ; \nintocon ( L_BRE ) ; \n} \n} \nv . nexttype = Compiler . EMPTY ; \nnext ( ) ; \n} \n} \n"}
{"7831": "public class Nfa { \nboolean unempty ( Arc a ) { \nState from = a . from ; \nState to = a . to ; \nboolean usefrom ; \nassert a . type == Compiler . EMPTY ; \nassert from != pre && to != post ; \nif ( from == to ) { \nfreearc ( a ) ; \nreturn true ; \n} \nusefrom = true ; \nif ( from . nouts > to . nins ) { \nusefrom = false ; \n} \nelse { \nif ( from . nouts == to . nins ) { \nif ( from . nins > to . nouts ) { \nusefrom = false ; \n} \n} \n} \nfreearc ( a ) ; \nif ( usefrom ) { \nif ( from . nouts == 0 ) { \nmoveins ( from , to ) ; \nfreestate ( from ) ; \n} \nelse { \ncopyins ( from , to ) ; \n} \n} \nelse { \nif ( to . nins == 0 ) { \nmoveouts ( to , from ) ; \nfreestate ( to ) ; \n} \nelse { \ncopyouts ( to , from ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7859": "public class DefaultBookmarksComparator { \nprotected int compareFolders ( final Entry e1 , final Entry e2 ) { \nfinal boolean f1 = e1 instanceof Folder ; \nfinal boolean f2 = e2 instanceof Folder ; \nif ( f1 && ! f2 ) { \nreturn - 1 ; \n} \nelse { \nif ( ! f1 && f2 ) { \nreturn 1 ; \n} \nelse { \nreturn 0 ; \n} \n} \n} \n} \n"}
{"7887": "public class ImplicitTagLibraryInfo { \nprivate void parseImplicitTld ( JspCompilationContext ctxt , String path ) throws JasperException { \nInputStream is = null ; \nTreeNode tld = null ; \ntry { \nURL uri = ctxt . getResource ( path ) ; \nif ( uri == null ) { \nreturn ; \n} \nis = uri . openStream ( ) ; \ntld = new ParserUtils ( ) . parseXMLDocument ( IMPLICIT_TLD , is , ctxt . getOptions ( ) . isValidationEnabled ( ) ) ; \n} \ncatch ( Exception ex ) { \nthrow new JasperException ( ex ) ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Throwable t ) { \n} \n} \n} \nthis . jspversion = tld . findAttribute ( \"version\" ) ; \nIterator list = tld . findChildren ( ) ; \nwhile ( list . hasNext ( ) ) { \nTreeNode element = ( TreeNode ) list . next ( ) ; \nString tname = element . getName ( ) ; \nif ( \"tlibversion\" . equals ( tname ) || \"tlib-version\" . equals ( tname ) ) { \nthis . tlibversion = element . getBody ( ) ; \n} \nelse { \nif ( \"jspversion\" . equals ( tname ) || \"jsp-version\" . equals ( tname ) ) { \nthis . jspversion = element . getBody ( ) ; \n} \nelse { \nif ( ! \"shortname\" . equals ( tname ) && ! \"short-name\" . equals ( tname ) ) { \nerr . jspError ( \"jsp.error.implicitTld.additionalElements\" , path , tname ) ; \n} \n} \n} \n} \nDouble jspVersionDouble = Double . valueOf ( this . jspversion ) ; \nif ( Double . compare ( jspVersionDouble , Constants . JSP_VERSION_2_0 ) < 0 ) { \nerr . jspError ( \"jsp.error.implicitTld.jspVersion\" , path , this . jspversion ) ; \n} \n} \n} \n"}
{"7893": "public class UnzipServlet { \nprotected static List < MavenVersionedArtifact > getMavenArtifacts ( final String channelId , final Supplier < Collection < ArtifactInformation > > artifactsSupplier , final String groupId , final String artifactId , final boolean snapshot , final Predicate < ComparableVersion > versionFilter ) { \nfinal List < MavenVersionedArtifact > arts = new ArrayList < > ( ) ; \nfor ( final ArtifactInformation ai : artifactsSupplier . get ( ) ) { \nif ( ! isZip ( ai ) ) { \ncontinue ; \n} \nfinal String mvnGroupId = ai . getMetaData ( ) . get ( MK_GROUP_ID ) ; \nfinal String mvnArtifactId = ai . getMetaData ( ) . get ( MK_ARTIFACT_ID ) ; \nfinal String classifier = ai . getMetaData ( ) . get ( MK_CLASSIFIER ) ; \nfinal String mvnVersion = ai . getMetaData ( ) . get ( MK_VERSION ) ; \nfinal String mvnSnapshotVersion = ai . getMetaData ( ) . get ( MK_SNAPSHOT_VERSION ) ; \nif ( mvnGroupId == null || mvnArtifactId == null || mvnVersion == null ) { \ncontinue ; \n} \nif ( classifier != null && ! classifier . isEmpty ( ) ) { \ncontinue ; \n} \nif ( ! mvnGroupId . equals ( groupId ) || ! mvnArtifactId . equals ( artifactId ) ) { \ncontinue ; \n} \nif ( ! snapshot && ( mvnSnapshotVersion != null || mvnVersion . endsWith ( \"-SNAPSHOT\" ) ) ) { \ncontinue ; \n} \nfinal ComparableVersion v = parseVersion ( mvnVersion ) ; \nfinal ComparableVersion sv = parseVersion ( mvnSnapshotVersion ) ; \nif ( v == null ) { \ncontinue ; \n} \nif ( versionFilter == null ) { \narts . add ( new MavenVersionedArtifact ( sv != null ? sv : v , channelId , ai ) ) ; \n} \nelse { \nif ( versionFilter . test ( v ) ) { \narts . add ( new MavenVersionedArtifact ( sv != null ? sv : v , channelId , ai ) ) ; \n} \nelse { \nif ( sv != null && versionFilter . test ( sv ) ) { \narts . add ( new MavenVersionedArtifact ( sv , channelId , ai ) ) ; \n} \n} \n} \n} \nreturn arts ; \n} \n} \n"}
{"7919": "public class Parser { \nprivate String parseQuoted ( String tx ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint size = tx . length ( ) ; \nint i = 0 ; \nwhile ( i < size ) { \nchar ch = tx . charAt ( i ) ; \nif ( ch == '&' ) { \nif ( i + 5 < size && tx . charAt ( i + 1 ) == 'a' && tx . charAt ( i + 2 ) == 'p' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 's' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\\'' ) ; \ni += 6 ; \n} \nelse { \nif ( i + 5 < size && tx . charAt ( i + 1 ) == 'q' && tx . charAt ( i + 2 ) == 'u' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 't' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\"' ) ; \ni += 6 ; \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \n} \n} \nelse { \nif ( ch == '\\\\' && i + 1 < size ) { \nch = tx . charAt ( i + 1 ) ; \nif ( ch == '\\\\' || ch == '\\\"' || ch == '\\'' || ch == '>' ) { \nbuf . append ( ch ) ; \ni += 2 ; \n} \nelse { \nbuf . append ( '\\\\' ) ; \n++ i ; \n} \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"7921": "public class Parser { \nprivate boolean parseJspAttributeAndBody ( Node parent , String tag , String bodyType ) throws JasperException { \nboolean result = false ; \nif ( reader . matchesOptionalSpacesFollowedBy ( \"<jsp:attribute\" ) ) { \nparseNamedAttributes ( parent ) ; \nresult = true ; \n} \nif ( reader . matchesOptionalSpacesFollowedBy ( \"<jsp:body\" ) ) { \nparseJspBody ( parent , bodyType ) ; \nreader . skipSpaces ( ) ; \nif ( ! reader . matchesETag ( tag ) ) { \nerr . jspError ( reader . mark ( ) , \"jsp.error.unterminated\" , \"&lt;\" + tag ) ; \n} \nresult = true ; \n} \nelse { \nif ( result && ! reader . matchesETag ( tag ) ) { \nerr . jspError ( reader . mark ( ) , \"jsp.error.jspbody.required\" , \"&lt;\" + tag ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7958": "public class TagFileProcessor { \npublic void removeProtoTypeFiles ( String classFileName ) { \nIterator < Compiler > iter = tempVector . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nCompiler c = iter . next ( ) ; \nif ( classFileName == null ) { \nc . removeGeneratedClassFiles ( ) ; \n} \nelse { \nif ( classFileName . equals ( c . getCompilationContext ( ) . getClassFileName ( ) ) ) { \nc . removeGeneratedClassFiles ( ) ; \ntempVector . remove ( c ) ; \nreturn ; \n} \n} \n} \n} \n} \n"}
{"7968": "public class JspReader { \nMark skipUntilIgnoreEsc ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nint prev = 'x' ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , prev = ch , ch = nextChar ( ) ) { \nif ( ch == '\\\\' && prev == '\\\\' ) { \nch = 0 ; \n} \nelse { \nif ( ch == limit . charAt ( 0 ) && prev != '\\\\' ) { \nfor ( int i = 1 ; \ni < limlen ; \ni ++ ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse continue skip ; \n} \nreturn ret ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"7984": "public class BasicArrayCache { \npublic byte [ ] getByteArray ( int size , boolean fillWithZeros ) { \nbyte [ ] array = getArray ( byteArrayCache , size ) ; \nif ( array == null ) array = new byte [ size ] ; \nelse { \nif ( fillWithZeros ) Arrays . fill ( array , ( byte ) 0x00 ) ; \n} \nreturn array ; \n} \n} \n"}
{"7985": "public class BasicArrayCache { \npublic int [ ] getIntArray ( int size , boolean fillWithZeros ) { \nint [ ] array = getArray ( intArrayCache , size ) ; \nif ( array == null ) array = new int [ size ] ; \nelse { \nif ( fillWithZeros ) Arrays . fill ( array , 0 ) ; \n} \nreturn array ; \n} \n} \n"}
{"7996": "public class JspCServletContext { \npublic Set < String > getResourcePaths ( String path ) { \nSet < String > thePaths = new HashSet < String > ( ) ; \nif ( ! path . endsWith ( \"/\" ) ) path += \"/\" ; \nString basePath = getRealPath ( path ) ; \nif ( basePath == null ) return ( thePaths ) ; \nFile theBaseDir = new File ( basePath ) ; \nif ( ! theBaseDir . exists ( ) || ! theBaseDir . isDirectory ( ) ) return ( thePaths ) ; \nString theFiles [ ] = theBaseDir . list ( ) ; \nfor ( int i = 0 ; \ni < theFiles . length ; \ni ++ ) { \nFile testFile = new File ( basePath + File . separator + theFiles [ i ] ) ; \nif ( testFile . isFile ( ) ) thePaths . add ( path + theFiles [ i ] ) ; \nelse { \nif ( testFile . isDirectory ( ) ) thePaths . add ( path + theFiles [ i ] + \"/\" ) ; \n} \n} \nreturn ( thePaths ) ; \n} \n} \n"}
{"8023": "public class Generator { \nstatic String quote ( char c ) { \nStringBuilder b = new StringBuilder ( ) ; \nb . append ( '\\'' ) ; \nif ( c == '\\'' ) b . append ( '\\\\' ) . append ( '\\'' ) ; \nelse { \nif ( c == '\\\\' ) b . append ( '\\\\' ) . append ( '\\\\' ) ; \nelse { \nif ( c == '\\n' ) b . append ( '\\\\' ) . append ( 'n' ) ; \nelse { \nif ( c == '\\r' ) b . append ( '\\\\' ) . append ( 'r' ) ; \nelse b . append ( c ) ; \n} \n} \n} \nb . append ( '\\'' ) ; \nreturn b . toString ( ) ; \n} \n} \n"}
{"8044": "public class JspUtil { \npublic static String escapeXml ( String s ) { \nif ( s == null ) return null ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ni < s . length ( ) ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c == '<' ) { \nsb . append ( \"&lt;\" ) ; \n} \nelse { \nif ( c == '>' ) { \nsb . append ( \"&gt;\" ) ; \n} \nelse { \nif ( c == '\\'' ) { \nsb . append ( \"&apos;\" ) ; \n} \nelse { \nif ( c == '&' ) { \nsb . append ( \"&amp;\" ) ; \n} \nelse { \nif ( c == '\"' ) { \nsb . append ( \"&quot;\" ) ; \n} \nelse { \nsb . append ( c ) ; \n} \n} \n} \n} \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8049": "public class JspUtil { \npublic static final String makeJavaIdentifier ( String identifier ) { \nStringBuilder modifiedIdentifier = new StringBuilder ( identifier . length ( ) ) ; \nif ( ! Character . isJavaIdentifierStart ( identifier . charAt ( 0 ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nfor ( int i = 0 ; \ni < identifier . length ( ) ; \ni ++ ) { \nchar ch = identifier . charAt ( i ) ; \nif ( Character . isJavaIdentifierPart ( ch ) && ch != '_' ) { \nmodifiedIdentifier . append ( ch ) ; \n} \nelse { \nif ( ch == '.' ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nelse { \nmodifiedIdentifier . append ( mangleChar ( ch ) ) ; \n} \n} \n} \nif ( isJavaKeyword ( modifiedIdentifier . toString ( ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nreturn modifiedIdentifier . toString ( ) ; \n} \n} \n"}
{"8093": "public class Granularity { \npublic static Granularity granularityFromPointsInInterval ( String tenantid , long from , long to , int points , String algorithm , long assumedIntervalMillis , Clock ttlComparisonClock ) { \nif ( from >= to ) { \nthrow new RuntimeException ( \"Invalid interval specified for fromPointsInInterval\" ) ; \n} \ndouble requestedDuration = to - from ; \nif ( algorithm . startsWith ( \"GEOMETRIC\" ) ) return granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; \nelse { \nif ( algorithm . startsWith ( \"LINEAR\" ) ) return granularityFromPointsLinear ( requestedDuration , points , assumedIntervalMillis ) ; \nelse { \nif ( algorithm . startsWith ( \"LESSTHANEQUAL\" ) ) return granularityFromPointsLessThanEqual ( requestedDuration , points , assumedIntervalMillis ) ; \n} \n} \nreturn granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; \n} \n} \n"}
{"8118": "public class Serializers { \npublic static < T > AbstractSerializer < T > serializerFor ( Class < T > type ) { \nif ( type == null ) throw new RuntimeException ( \"serializable type cannot be null\" , new SerializationException ( \"serializable type cannot be null\" ) ) ; \nelse { \nif ( type . equals ( String . class ) ) throw new RuntimeException ( \"We don't serialize strings anymore\" , new SerializationException ( \"We don't serialize strings anymore\" ) ) ; \n} \nif ( type . equals ( BasicRollup . class ) ) return ( AbstractSerializer < T > ) basicRollupInstance ; \nelse { \nif ( type . equals ( BluefloodTimerRollup . class ) ) return ( AbstractSerializer < T > ) timerRollupInstance ; \nelse { \nif ( type . equals ( BluefloodCounterRollup . class ) ) return ( AbstractSerializer < T > ) counterRollupInstance ; \nelse { \nif ( type . equals ( BluefloodGaugeRollup . class ) ) return ( AbstractSerializer < T > ) gaugeRollupInstance ; \nelse { \nif ( type . equals ( BluefloodSetRollup . class ) ) return ( AbstractSerializer < T > ) setRollupInstance ; \nelse { \nif ( type . equals ( SimpleNumber . class ) ) return ( AbstractSerializer < T > ) fullInstance ; \nelse { \nif ( type . equals ( Integer . class ) ) return ( AbstractSerializer < T > ) fullInstance ; \nelse { \nif ( type . equals ( Long . class ) ) return ( AbstractSerializer < T > ) fullInstance ; \nelse { \nif ( type . equals ( Double . class ) ) return ( AbstractSerializer < T > ) fullInstance ; \nelse { \nif ( type . equals ( Float . class ) ) return ( AbstractSerializer < T > ) fullInstance ; \nelse { \nif ( type . equals ( byte [ ] . class ) ) return ( AbstractSerializer < T > ) fullInstance ; \nelse { \nif ( type . equals ( Object . class ) ) return ( AbstractSerializer < T > ) fullInstance ; \nelse return ( AbstractSerializer < T > ) fullInstance ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"8208": "public class CsvRecord { \nprotected final void set ( int pos , String value ) { \nvalue = StringUtils . trimToNull ( value ) ; \nif ( value != null ) this . values . put ( pos , value ) ; \nelse { \nif ( this . values . containsKey ( pos ) ) this . values . remove ( pos ) ; \n} \n} \n} \n"}
{"8366": "public class CmdLineParser { \npublic final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { \nVector otherArgs = new Vector ( ) ; \nint position = 0 ; \nthis . values = new Hashtable ( 10 ) ; \nwhile ( position < argv . length ) { \nString curArg = argv [ position ] ; \nif ( curArg . startsWith ( \"-\" ) ) { \nif ( curArg . equals ( \"--\" ) ) { \nposition += 1 ; \nbreak ; \n} \nString valueArg = null ; \nif ( curArg . startsWith ( \"--\" ) ) { \nint equalsPos = curArg . indexOf ( \"=\" ) ; \nif ( equalsPos != - 1 ) { \nvalueArg = curArg . substring ( equalsPos + 1 ) ; \ncurArg = curArg . substring ( 0 , equalsPos ) ; \n} \n} \nelse { \nif ( curArg . length ( ) > 2 ) { \nfor ( int i = 1 ; \ni < curArg . length ( ) ; \ni ++ ) { \nOption opt = ( Option ) this . options . get ( \"-\" + curArg . charAt ( i ) ) ; \nif ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; \nif ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; \naddValue ( opt , opt . getValue ( null , locale ) ) ; \n} \nposition ++ ; \ncontinue ; \n} \n} \nOption opt = ( Option ) this . options . get ( curArg ) ; \nif ( opt == null ) { \nthrow new UnknownOptionException ( curArg ) ; \n} \nObject value = null ; \nif ( opt . wantsValue ( ) ) { \nif ( valueArg == null ) { \nposition += 1 ; \nif ( position < argv . length ) { \nvalueArg = argv [ position ] ; \n} \n} \nvalue = opt . getValue ( valueArg , locale ) ; \n} \nelse { \nvalue = opt . getValue ( null , locale ) ; \n} \naddValue ( opt , value ) ; \nposition += 1 ; \n} \nelse { \notherArgs . addElement ( curArg ) ; \nposition += 1 ; \n} \n} \nfor ( ; \nposition < argv . length ; \n++ position ) { \notherArgs . addElement ( argv [ position ] ) ; \n} \nthis . remainingArgs = new String [ otherArgs . size ( ) ] ; \notherArgs . copyInto ( remainingArgs ) ; \n} \n} \n"}
{"8389": "public class HorizontalPicker { \nprivate int getTextColor ( int item ) { \nint scrollX = getScrollX ( ) ; \nint color = textColor . getDefaultColor ( ) ; \nint itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; \nif ( scrollX > itemWithPadding * item - itemWithPadding / 2 && scrollX < itemWithPadding * ( item + 1 ) - itemWithPadding / 2 ) { \nint position = scrollX - itemWithPadding / 2 ; \ncolor = getColor ( position , item ) ; \n} \nelse { \nif ( item == pressedItem ) { \ncolor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed } \n, color ) ; \n} \n} \nreturn color ; \n} \n} \n"}
{"8393": "public class HorizontalPicker { \nprivate int getInBoundsX ( int x ) { \nif ( x < 0 ) { \nx = 0 ; \n} \nelse { \nif ( x > ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) ) { \nx = ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) ; \n} \n} \nreturn x ; \n} \n} \n"}
{"8456": "public class UnitConverter { \npublic static TimeUnit extractTimeUnitFromString ( String timeString ) { \ntimeString = timeString . toLowerCase ( ) ; \nif ( timeString . contains ( \"minute\" ) ) { \nreturn TimeUnit . MINUTES ; \n} \nelse { \nif ( timeString . contains ( \"microsecond\" ) ) { \nreturn TimeUnit . MICROSECONDS ; \n} \nelse { \nif ( timeString . contains ( \"millisecond\" ) ) { \nreturn TimeUnit . MILLISECONDS ; \n} \nelse { \nif ( timeString . contains ( \"second\" ) ) { \nreturn TimeUnit . SECONDS ; \n} \nelse { \nif ( timeString . contains ( \"hour\" ) ) { \nreturn TimeUnit . HOURS ; \n} \nelse { \nif ( timeString . toLowerCase ( ) . contains ( \"day\" ) ) { \nreturn TimeUnit . DAYS ; \n} \nelse return null ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"8488": "public class SafeSerializationHelper { \npublic static void safeEncodeValue ( final StringBuilder encoder , @ Nullable final Object value ) { \nif ( value == null ) { \nencoder . append ( \"null\" ) ; \n} \nelse { \nif ( value instanceof Map ) { \nsafeEncodeMap ( encoder , ( Map < ? , ? > ) value ) ; \n} \nelse { \nif ( value instanceof List ) { \nsafeEncodeList ( encoder , ( List < ? > ) value ) ; \n} \nelse { \nif ( value . getClass ( ) . isArray ( ) ) { \nsafeEncodeArray ( encoder , value ) ; \n} \nelse { \nif ( value instanceof LogValueMapFactory . LogValueMap ) { \nsafeEncodeLogValueMap ( encoder , ( LogValueMapFactory . LogValueMap ) value ) ; \n} \nelse { \nif ( value instanceof Throwable ) { \nsafeEncodeThrowable ( encoder , ( Throwable ) value ) ; \n} \nelse { \nif ( StenoSerializationHelper . isSimpleType ( value ) ) { \nif ( value instanceof Boolean ) { \nencoder . append ( BooleanNode . valueOf ( ( Boolean ) value ) . toString ( ) ) ; \n} \nelse { \nif ( value instanceof Double ) { \nencoder . append ( DoubleNode . valueOf ( ( Double ) value ) . toString ( ) ) ; \n} \nelse { \nif ( value instanceof Float ) { \nencoder . append ( FloatNode . valueOf ( ( Float ) value ) . toString ( ) ) ; \n} \nelse { \nif ( value instanceof Long ) { \nencoder . append ( LongNode . valueOf ( ( Long ) value ) . toString ( ) ) ; \n} \nelse { \nif ( value instanceof Integer ) { \nencoder . append ( IntNode . valueOf ( ( Integer ) value ) . toString ( ) ) ; \n} \nelse { \nencoder . append ( new TextNode ( value . toString ( ) ) . toString ( ) ) ; \n} \n} \n} \n} \n} \n} \nelse { \nsafeEncodeValue ( encoder , LogReferenceOnly . of ( value ) . toLogValue ( ) ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"8539": "public class ColorUtility { \nstatic String getBgColorFromCell ( final Workbook wb , final Cell poiCell , final CellStyle cellStyle ) { \nString style = \"\" ; \nif ( poiCell instanceof HSSFCell ) { \nint bkColorIndex = cellStyle . getFillForegroundColor ( ) ; \nHSSFColor color = HSSFColor . getIndexHash ( ) . get ( bkColorIndex ) ; \nif ( color != null ) { \nHSSFPalette palette = ( ( HSSFWorkbook ) wb ) . getCustomPalette ( ) ; \nHSSFColor color2 = palette . getColor ( bkColorIndex ) ; \nif ( ! color . getHexString ( ) . equalsIgnoreCase ( color2 . getHexString ( ) ) ) { \ncolor = color2 ; \n} \nstyle = \"background-color:rgb(\" + FacesUtility . strJoin ( color . getTriplet ( ) , \",\" ) + \");\" ; \n} \n} \nelse { \nif ( poiCell instanceof XSSFCell ) { \nXSSFColor color = ( ( XSSFCell ) poiCell ) . getCellStyle ( ) . getFillForegroundColorColor ( ) ; \nif ( color != null ) { \nstyle = \"background-color:rgb(\" + FacesUtility . strJoin ( getTripletFromXSSFColor ( color ) , \",\" ) + \");\" ; \n} \n} \n} \nreturn style ; \n} \n} \n"}
{"8552": "public class ChartHelper { \npublic final void setSeriesStyle ( final JFreeChart chart , final int seriesIndex , final String style ) { \nif ( chart != null && style != null ) { \nBasicStroke stroke = ChartUtility . toStroke ( style ) ; \nPlot plot = chart . getPlot ( ) ; \nif ( plot instanceof CategoryPlot ) { \nCategoryPlot categoryPlot = chart . getCategoryPlot ( ) ; \nCategoryItemRenderer cir = categoryPlot . getRenderer ( ) ; \ntry { \ncir . setSeriesStroke ( seriesIndex , stroke ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \nelse { \nif ( plot instanceof XYPlot ) { \nXYPlot xyPlot = chart . getXYPlot ( ) ; \nXYItemRenderer xyir = xyPlot . getRenderer ( ) ; \ntry { \nxyir . setSeriesStroke ( seriesIndex , stroke ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; \n} \n} \nelse { \nLOG . log ( Level . FINE , \"setSeriesColor() unsupported plot: {}\" , plot . toString ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"8594": "public class ConfigurationHandler { \nprivate List < ConfigCommand > buildCommandList ( final Sheet sheet , final int sheetRightCol , final Cell cell , final List < ConfigCommand > cList , final CellAttributesMap cellAttributesMap ) { \nComment comment = cell . getCellComment ( ) ; \nString text = comment . getString ( ) . getString ( ) ; \nString [ ] commentLines = text . split ( \"\\\\n\" ) ; \nStringBuilder newComment = new StringBuilder ( ) ; \nboolean changed = false ; \nfor ( String commentLine : commentLines ) { \nString line = commentLine . trim ( ) ; \nif ( ParserUtility . isCommandString ( line ) ) { \nprocessCommandLine ( sheet , cell , line , cList , sheetRightCol ) ; \nchanged = true ; \n} \nelse { \nif ( ParserUtility . isEmptyMethodString ( line ) || ParserUtility . isMethodString ( line ) ) { \nprocessMethodLine ( cell , line , cellAttributesMap ) ; \nchanged = true ; \n} \nelse { \nif ( newComment . length ( ) > 0 ) { \nnewComment . append ( \"\\\\n\" + commentLine ) ; \n} \nelse { \nnewComment . append ( commentLine ) ; \n} \n} \n} \n} \nif ( ! changed ) { \nmoveCommentToMap ( cell , text , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; \n} \nelse { \nif ( newComment . length ( ) > 0 ) { \nmoveCommentToMap ( cell , newComment . toString ( ) , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; \nCreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; \nRichTextString str = factory . createRichTextString ( newComment . toString ( ) ) ; \ncomment . setString ( str ) ; \n} \nelse { \ncell . removeCellComment ( ) ; \n} \n} \nreturn cList ; \n} \n} \n"}
{"8595": "public class ConfigurationHandler { \nprivate void processMethodLine ( final Cell cell , final String line , final CellAttributesMap cellAttributesMap ) { \nif ( ParserUtility . isWidgetMethodString ( line ) ) { \nParserUtility . parseWidgetAttributes ( cell , line , cellAttributesMap ) ; \n} \nelse { \nif ( ParserUtility . isValidateMethodString ( line ) ) { \nParserUtility . parseValidateAttributes ( cell , line , cellAttributesMap ) ; \n} \nelse { \nmoveCommentToMap ( cell , line , cellAttributesMap . getTemplateCommentMap ( ) , false ) ; \n} \n} \n} \n} \n"}
{"8630": "public class CellUtility { \n@ SuppressWarnings ( \"deprecation\" ) public static Cell setCellValue ( final Cell c , final String value ) { \ntry { \nif ( value . length ( ) == 0 ) { \nc . setCellType ( CellType . BLANK ) ; \n} \nelse { \nif ( WebSheetUtility . isNumeric ( value ) ) { \nsetCellValueNumber ( c , value ) ; \n} \nelse { \nif ( WebSheetUtility . isDate ( value ) ) { \nsetCellValueDate ( c , value ) ; \n} \nelse { \nif ( c . getCellTypeEnum ( ) == CellType . BOOLEAN ) { \nsetCellValueBoolean ( c , value ) ; \n} \nelse { \nsetCellValueString ( c , value ) ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \" error in setCellValue of CellUtility = \" + e . getLocalizedMessage ( ) , e ) ; \nsetCellValueString ( c , value ) ; \n} \nreturn c ; \n} \n} \n"}
{"8663": "public class ChartUtility { \npublic static BasicStroke toStroke ( final String style ) { \nBasicStroke result = null ; \nif ( style != null ) { \nfloat lineWidth = STROKE_DEFAULT_LINE_WIDTH ; \nfloat [ ] dash = { \nSTROKE_DEFAULT_DASH_WIDTH } \n; \nfloat [ ] dot = { \nlineWidth } \n; \nif ( style . equalsIgnoreCase ( STYLE_LINE ) ) { \nresult = new BasicStroke ( lineWidth ) ; \n} \nelse { \nif ( style . equalsIgnoreCase ( STYLE_DASH ) ) { \nresult = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_DASH , dash , STROKE_DEFAULT_DASHPHASE ) ; \n} \nelse { \nif ( style . equalsIgnoreCase ( STYLE_DOT ) ) { \nresult = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_DOT , dot , STROKE_DEFAULT_DASHPHASE ) ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"8714": "public class FacesUtility { \npublic static boolean evalInputType ( final String input , final String type ) { \nScanner scanner = new Scanner ( input ) ; \nboolean ireturn = false ; \nif ( \"Integer\" . equalsIgnoreCase ( type ) ) { \nireturn = scanner . hasNextInt ( ) ; \n} \nelse { \nif ( \"Double\" . equalsIgnoreCase ( type ) ) { \nireturn = scanner . hasNextDouble ( ) ; \n} \nelse { \nif ( \"Boolean\" . equalsIgnoreCase ( type ) ) { \nireturn = scanner . hasNextBoolean ( ) ; \n} \nelse { \nif ( \"Byte\" . equalsIgnoreCase ( type ) ) { \nireturn = scanner . hasNextByte ( ) ; \n} \nelse { \nif ( type . toLowerCase ( ) . startsWith ( \"text\" ) ) { \nireturn = true ; \n} \n} \n} \n} \n} \nscanner . close ( ) ; \nreturn ireturn ; \n} \n} \n"}
{"8731": "public class ParserUtility { \nprivate static int findPairBracketPosition ( final String str , final int startPos ) { \nint bracketNum = 0 ; \nfor ( int i = startPos ; \ni < str . length ( ) ; \ni ++ ) { \nchar current = str . charAt ( i ) ; \nif ( current == TieConstants . EL_START_BRACKET ) { \nbracketNum ++ ; \n} \nelse { \nif ( current == TieConstants . EL_END ) { \nbracketNum -- ; \nif ( bracketNum <= 0 ) { \nreturn i ; \n} \n} \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8750": "public class WebSheetUtility { \nprivate static boolean shouldContinue ( final char c , final ShouldContinueParameter para ) { \nif ( c == '.' && ! para . isDecimalHit ( ) ) { \npara . setDecimalHit ( true ) ; \nif ( para . isCommaHit ( ) && para . getSinceLastComma ( ) != 3 ) { \nreturn false ; \n} \nreturn true ; \n} \nelse { \nif ( c == ',' && ! para . isDecimalHit ( ) ) { \nif ( para . isCommaHit ( ) ) { \nif ( para . getSinceLastComma ( ) != 3 ) { \nreturn false ; \n} \npara . setSinceLastComma ( 0 ) ; \n} \npara . setCommaHit ( true ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8870": "public class ImagesManager { \nprivate void startImageLoaderTask ( final ImageConsumer consumer , final ImageRequest request ) { \nfinal String key = request . getKey ( ) ; \nif ( debug ) { \nLog . d ( TAG , \"Key \" + key ) ; \n} \nImageLoader loader = currentLoads . get ( key ) ; \nif ( loader != null ) { \nfinal boolean added = loader . addTarget ( consumer ) ; \nif ( ! added ) { \nloader = null ; \n} \n} \nif ( loader == null ) { \nif ( debug ) { \nLog . d ( TAG , \"Start a new task\" ) ; \n} \nloader = new ImageLoader ( request , this ) ; \nif ( ! loader . addTarget ( consumer ) ) { \nthrow new IllegalStateException ( \"Cannot add target to the new loader\" ) ; \n} \ncurrentLoads . put ( key , loader ) ; \nif ( debug ) { \nLog . d ( TAG , \"Current loaders count: \" + currentLoads . size ( ) ) ; \n} \nfinal Executor executor = getImageTaskExecutor ( ) ; \nexecutor . execute ( loader . future ) ; \n} \nelse { \nif ( debug ) { \nLog . d ( TAG , \"Joined to the existing task \" + key ) ; \n} \n} \n} \n} \n"}
{"8936": "public class ObjectSizing { \nprivate void sizePartitionedRegion ( Region < ? , ? > region , int numEntries ) { \nRegion < ? , ? > primaryDataSet = PartitionRegionHelper . getLocalData ( region ) ; \nint regionSize = primaryDataSet . size ( ) ; \nif ( numEntries == 0 ) { \nnumEntries = primaryDataSet . size ( ) ; \n} \nelse { \nif ( numEntries > regionSize ) { \nnumEntries = regionSize ; \n} \n} \nint count = 0 ; \nfor ( Iterator < ? > i = primaryDataSet . entrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) { \nbreak ; \n} \nEntrySnapshot entry = ( EntrySnapshot ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8937": "public class ObjectSizing { \nprivate void sizeReplicatedOrLocalRegion ( Region < ? , ? > region , int numEntries ) { \nSet < ? > entries = region . entrySet ( ) ; \nint regionSize = entries . size ( ) ; \nif ( numEntries == 0 ) { \nnumEntries = entries . size ( ) ; \n} \nelse { \nif ( numEntries > regionSize ) { \nnumEntries = regionSize ; \n} \n} \nint count = 0 ; \nfor ( Iterator < ? > i = entries . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) { \nbreak ; \n} \nLocalRegion . NonTXEntry entry = ( LocalRegion . NonTXEntry ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8963": "public class RegionDiffDirector { \npublic void constructComparison ( Map < ? , BigInteger > sourceChecksumMap , Map < ? , BigInteger > targetMap ) { \nif ( sourceChecksumMap == null ) { \nif ( targetMap != null && ! targetMap . isEmpty ( ) ) { \nthis . keysRemovedFromSource . addAll ( targetMap . keySet ( ) ) ; \n} \nreturn ; \n} \nif ( targetMap == null ) { \nthis . keysMissingOnTarget . addAll ( sourceChecksumMap . keySet ( ) ) ; \nreturn ; \n} \nBigInteger targetBi = null ; \nBigInteger sourceBi = null ; \nfor ( Map . Entry < ? , BigInteger > entrySource : sourceChecksumMap . entrySet ( ) ) { \ntargetBi = targetMap . get ( entrySource . getKey ( ) ) ; \nsourceBi = sourceChecksumMap . get ( entrySource . getKey ( ) ) ; \nif ( targetBi == null ) { \nkeysMissingOnTarget . add ( entrySource . getKey ( ) ) ; \n} \nelse { \nif ( ! targetBi . equals ( sourceBi ) ) { \nkeysDifferentOnTarget . add ( entrySource . getKey ( ) ) ; \n} \n} \n} \nSet < ? > sourceKeySet = sourceChecksumMap . keySet ( ) ; \nfor ( Map . Entry < ? , ? > targetEntry : targetMap . entrySet ( ) ) { \nif ( ! sourceKeySet . contains ( targetEntry . getKey ( ) ) ) { \nkeysRemovedFromSource . add ( targetEntry . getKey ( ) ) ; \n} \n} \n} \n} \n"}
{"8983": "public class ShillelaghUtil { \n@ SuppressWarnings ( \"unchecked\" ) public static < T > T createInstance ( Class < T > clazz ) { \nif ( clazz . isInterface ( ) ) { \nif ( clazz == List . class ) { \nreturn ( T ) new ArrayList ( ) ; \n} \nelse { \nif ( clazz == Map . class ) { \nreturn ( T ) new HashMap ( ) ; \n} \n} \nthrow new UnsupportedOperationException ( \"Interface types can not be instantiated.\" ) ; \n} \nObjectInstantiator instantiator = OBJENESIS . getInstantiatorOf ( clazz ) ; \nreturn ( T ) instantiator . newInstance ( ) ; \n} \n} \n"}
{"8985": "public class ShillelaghProcessor { \nprivate void checkForFields ( TableObject tableObject , Element columnElement ) { \nColumn columnAnnotation = columnElement . getAnnotation ( Column . class ) ; \nif ( columnAnnotation == null ) return ; \nfinal Element typeElement = typeUtils . asElement ( columnElement . asType ( ) ) ; \nfinal String type = typeElement == null ? columnElement . asType ( ) . toString ( ) : elementUtils . getBinaryName ( ( TypeElement ) typeElement ) . toString ( ) ; \nTableColumn tableColumn = new TableColumn ( columnElement , type , columnAnnotation . name ( ) ) ; \nif ( tableColumn . isBlob ( ) && ! tableColumn . isByteArray ( ) ) { \nString columnType = columnElement . asType ( ) . toString ( ) ; \nlogger . d ( \"Column Element Type: \" + columnType ) ; \nif ( ! checkForSuperType ( columnElement , Serializable . class ) && ! columnType . equals ( \"java.lang.Byte[]\" ) && ! columnType . startsWith ( \"java.util.Map\" ) && ! columnType . startsWith ( \"java.util.List\" ) ) { \nlogger . e ( String . format ( \"%s in %s is not Serializable and will not be able to be converted to a byte array\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \n} \n} \nelse { \nif ( tableColumn . isOneToMany ( ) ) { \nTypeMirror typeMirror = ( ( DeclaredType ) columnElement . asType ( ) ) . getTypeArguments ( ) . get ( 0 ) ; \nif ( typeUtils . asElement ( typeMirror ) . getAnnotation ( Table . class ) == null ) { \nlogger . e ( \"One to many relationship in class %s where %s is not annotated with @Table\" , tableObject . getTableName ( ) , tableColumn . getColumnName ( ) ) ; \n} \noneToManyCache . put ( typeMirror . toString ( ) , tableObject ) ; \nTypeElement childColumnElement = elementUtils . getTypeElement ( typeMirror . toString ( ) ) ; \ntableColumn . setType ( getClassName ( childColumnElement , getPackageName ( childColumnElement ) ) ) ; \n} \nelse { \nif ( tableColumn . getSqlType ( ) == SqliteType . UNKNOWN ) { \n@ SuppressWarnings ( \"ConstantConditions\" ) Table annotation = typeElement . getAnnotation ( Table . class ) ; \nif ( annotation == null ) { \nlogger . e ( String . format ( \"%s in %s needs to be marked as a blob or should be \" + \"annotated with @Table\" , columnElement . toString ( ) , tableObject . getTableName ( ) ) ) ; \n} \ntableColumn . setOneToOne ( true ) ; \n} \n} \n} \ntableObject . addColumn ( tableColumn ) ; \n} \n} \n"}
{"9067": "public class IEEE754 { \npublic void print ( @ Nonnull final PrintStream aPW ) { \naPW . println ( \"------------------------------\" ) ; \nif ( isDouble ( ) ) aPW . println ( \"double value = \" + doubleValue ( ) ) ; \nelse aPW . println ( \"float value = \" + floatValue ( ) ) ; \naPW . print ( \"sign=\" + signBit ( ) ) ; \naPW . print ( \", exponent=\" + exponentBits ( ) + \" (biased=\" + biasedExponent ( ) ) ; \nif ( isZero ( ) ) aPW . println ( \", zero)\" ) ; \nelse { \nif ( isExponentReserved ( ) ) aPW . println ( \", reserved)\" ) ; \nelse { \nif ( isDenormalized ( ) ) aPW . println ( \", denormalized, use \" + unbiasedExponent ( ) + \")\" ) ; \nelse aPW . println ( \", normalized, unbiased=\" + unbiasedExponent ( ) + \")\" ) ; \n} \n} \naPW . println ( \"significand=\" + significandBits ( ) ) ; \n} \n} \n"}
{"9188": "public class ABaseClientWS { \nprivate ResponseHandler < String > getJsonResponseHandler ( final String urlCalledParam ) { \nResponseHandler < String > responseHandler = new ResponseHandler < String > ( ) { \npublic String handleResponse ( final HttpResponse responseParam ) throws IOException { \nint status = responseParam . getStatusLine ( ) . getStatusCode ( ) ; \nif ( status == 404 ) { \nthrow new FluidClientException ( \"Endpoint for Service not found. URL [\" + urlCalledParam + \"].\" , FluidClientException . ErrorCode . CONNECT_ERROR ) ; \n} \nelse { \nif ( status >= 200 && status < 300 ) { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; \nreturn responseJsonString ; \n} \nelse { \nif ( status == 400 ) { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; \nreturn responseJsonString ; \n} \nelse { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseString = ( entity != null ) ? EntityUtils . toString ( entity ) : null ; \nthrow new FluidClientException ( \"Unexpected response status: \" + status + \". \" + responseParam . getStatusLine ( ) . getReasonPhrase ( ) + \". \\nResponse Text [\" + responseString + \"]\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \n} \n} \n} \n} \n; \nreturn responseHandler ; \n} \n} \n"}
{"9196": "public class WebSocketClient { \n@ OnMessage public void onMessage ( String messageParam ) { \nboolean handlerFoundForMsg = false ; \nfor ( IMessageResponseHandler handler : new ArrayList < > ( this . messageHandlers . values ( ) ) ) { \nObject qualifyObj = handler . doesHandlerQualifyForProcessing ( messageParam ) ; \nif ( qualifyObj instanceof Error ) { \nhandler . handleMessage ( qualifyObj ) ; \n} \nelse { \nif ( qualifyObj instanceof JSONObject ) { \nhandler . handleMessage ( qualifyObj ) ; \nhandlerFoundForMsg = true ; \nbreak ; \n} \n} \n} \nif ( ! handlerFoundForMsg ) { \nthrow new FluidClientException ( \"No handler found for message;\\n\" + messageParam , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \n} \n} \n"}
{"9228": "public class ConvertTypeOfObject { \n@ Override public T convert ( final Object value ) { \nif ( value == null ) { \nreturn null ; \n} \nelse { \nif ( isIterable ( ) && Iterable . class . isAssignableFrom ( value . getClass ( ) ) ) { \nreturn convertIterable ( value ) ; \n} \nelse { \nif ( reflectedKlass . assignableFromObject ( value ) ) { \nreturn ( T ) value ; \n} \nelse { \nif ( reflectedKlass . canBeUnboxed ( value . getClass ( ) ) ) { \nreturn ( T ) value ; \n} \nelse { \nif ( reflectedKlass . canBeBoxed ( value . getClass ( ) ) ) { \nreturn ( T ) value ; \n} \n} \n} \n} \n} \nFluentClass < ? > klassToCreate ; \nif ( reflectedKlass . isPrimitive ( ) ) { \nklassToCreate = reflectedKlass . boxedType ( ) ; \n} \nelse { \nklassToCreate = reflectedKlass ; \n} \nreturn ( T ) convertValueTo ( value , klassToCreate ) ; \n} \n} \n"}
{"9256": "public class WeakTypeCache { \n@ SuppressWarnings ( { \n\"unchecked\" , \"cast\" } \n) public T get ( Type type ) { \nif ( type == null ) throw new IllegalArgumentException ( \"Null type\" ) ; \nif ( type instanceof ParameterizedType ) return getParameterizedType ( ( ParameterizedType ) type ) ; \nelse { \nif ( type instanceof Class ) return getClass ( ( Class < ? > ) type ) ; \nelse { \nif ( type instanceof TypeVariable ) return ( T ) getTypeVariable ( ( TypeVariable ) type ) ; \nelse { \nif ( type instanceof GenericArrayType ) return getGenericArrayType ( ( GenericArrayType ) type ) ; \nelse { \nif ( type instanceof WildcardType ) return getWildcardType ( ( WildcardType ) type ) ; \nelse throw new UnsupportedOperationException ( \"Unknown type: \" + type + \" class=\" + type . getClass ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"9271": "public class BlockingMode { \npublic static final BlockingMode toBlockingMode ( String name ) { \nBlockingMode mode = null ; \nif ( name == null ) { \nmode = null ; \n} \nelse { \nif ( name . equalsIgnoreCase ( \"run\" ) ) { \nmode = RUN ; \n} \nelse { \nif ( name . equalsIgnoreCase ( \"wait\" ) ) { \nmode = WAIT ; \n} \nelse { \nif ( name . equalsIgnoreCase ( \"discard\" ) ) { \nmode = DISCARD ; \n} \nelse { \nif ( name . equalsIgnoreCase ( \"discardOldest\" ) ) { \nmode = DISCARD_OLDEST ; \n} \nelse { \nif ( name . equalsIgnoreCase ( \"abort\" ) ) { \nmode = ABORT ; \n} \n} \n} \n} \n} \n} \nreturn mode ; \n} \n} \n"}
{"9287": "public class Catalog { \nprotected synchronized String resolveSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \n} \nelse { \nif ( entityType == DOCUMENT ) { \nresolved = c . resolveDocument ( ) ; \n} \nelse { \nif ( entityType == ENTITY ) { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \n} \nelse { \nif ( entityType == NOTATION ) { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \n} \nelse { \nif ( entityType == PUBLIC ) { \nresolved = c . resolvePublic ( publicId , systemId ) ; \n} \nelse { \nif ( entityType == SYSTEM ) { \nresolved = c . resolveSystem ( systemId ) ; \n} \nelse { \nif ( entityType == URI ) { \nresolved = c . resolveURI ( systemId ) ; \n} \n} \n} \n} \n} \n} \n} \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9337": "public class XmlHelper { \npublic static String getElementContent ( Element element , String defaultStr ) throws Exception { \nif ( element == null ) return defaultStr ; \nNodeList children = element . getChildNodes ( ) ; \nString result = \"\" ; \nfor ( int i = 0 ; \ni < children . getLength ( ) ; \ni ++ ) { \nif ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { \nresult += children . item ( i ) . getNodeValue ( ) ; \n} \nelse { \nif ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { \n} \n} \n} \nreturn result . trim ( ) ; \n} \n} \n"}
{"9344": "public class Resolver { \npublic String resolveSystem ( String systemId ) throws MalformedURLException , IOException { \nString resolved = super . resolveSystem ( systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == RESOLVER ) { \nresolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nelse { \nif ( e . getEntryType ( ) == SYSTEMSUFFIX ) { \nString suffix = e . getEntryArg ( 0 ) ; \nString result = e . getEntryArg ( 1 ) ; \nif ( suffix . length ( ) <= systemId . length ( ) && systemId . substring ( systemId . length ( ) - suffix . length ( ) ) . equals ( suffix ) ) { \nreturn result ; \n} \n} \n} \n} \nreturn resolveSubordinateCatalogs ( Catalog . SYSTEM , null , null , systemId ) ; \n} \n} \n"}
{"9348": "public class Resolver { \nprotected Resolver queryResolver ( String resolver , String command , String arg1 , String arg2 ) { \nString RFC2483 = resolver + \"?command=\" + command + \"&format=tr9401&uri=\" + arg1 + \"&uri2=\" + arg2 ; \ntry { \nURL url = new URL ( RFC2483 ) ; \nURLConnection urlCon = url . openConnection ( ) ; \nurlCon . setUseCaches ( false ) ; \nResolver r = ( Resolver ) newCatalog ( ) ; \nString cType = urlCon . getContentType ( ) ; \nif ( cType . indexOf ( \";\" ) > 0 ) { \ncType = cType . substring ( 0 , cType . indexOf ( \";\" ) ) ; \n} \nr . parseCatalog ( cType , urlCon . getInputStream ( ) ) ; \nreturn r ; \n} \ncatch ( CatalogException cex ) { \nif ( cex . getExceptionType ( ) == CatalogException . UNPARSEABLE ) { \ncatalogManager . debug . message ( 1 , \"Unparseable catalog: \" + RFC2483 ) ; \n} \nelse { \nif ( cex . getExceptionType ( ) == CatalogException . UNKNOWN_FORMAT ) { \ncatalogManager . debug . message ( 1 , \"Unknown catalog format: \" + RFC2483 ) ; \n} \n} \nreturn null ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed resolver URL: \" + RFC2483 ) ; \nreturn null ; \n} \ncatch ( IOException ie ) { \ncatalogManager . debug . message ( 1 , \"I/O Exception opening resolver: \" + RFC2483 ) ; \nreturn null ; \n} \n} \n} \n"}
{"9354": "public class Resolver { \nprivate synchronized Vector resolveAllSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nVector resolutions = new Vector ( ) ; \nfor ( int catPos = 0 ; \ncatPos < catalogs . size ( ) ; \ncatPos ++ ) { \nResolver c = null ; \ntry { \nc = ( Resolver ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = ( Resolver ) newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse { \nif ( entityType == DOCUMENT ) { \nresolved = c . resolveDocument ( ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse { \nif ( entityType == ENTITY ) { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse { \nif ( entityType == NOTATION ) { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse { \nif ( entityType == PUBLIC ) { \nresolved = c . resolvePublic ( publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse { \nif ( entityType == SYSTEM ) { \nVector localResolutions = c . resolveAllSystem ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \nbreak ; \n} \nelse { \nif ( entityType == SYSTEMREVERSE ) { \nVector localResolutions = c . resolveAllSystemReverse ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \n} \n} \n} \n} \n} \n} \n} \n} \nif ( resolutions != null ) { \nreturn resolutions ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"9356": "public class SAXCatalogReader { \npublic void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { \nif ( parserFactory == null && parserClass == null ) { \ndebug . message ( 1 , \"Cannot read SAX catalog without a parser\" ) ; \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ndebug = catalog . getCatalogManager ( ) . debug ; \nEntityResolver bResolver = catalog . getCatalogManager ( ) . getBootstrapResolver ( ) ; \nthis . catalog = catalog ; \ntry { \nif ( parserFactory != null ) { \nSAXParser parser = parserFactory . newSAXParser ( ) ; \nSAXParserHandler spHandler = new SAXParserHandler ( ) ; \nspHandler . setContentHandler ( this ) ; \nif ( bResolver != null ) { \nspHandler . setEntityResolver ( bResolver ) ; \n} \nparser . parse ( new InputSource ( is ) , spHandler ) ; \n} \nelse { \nParser parser = ( Parser ) Class . forName ( parserClass ) . newInstance ( ) ; \nparser . setDocumentHandler ( this ) ; \nif ( bResolver != null ) { \nparser . setEntityResolver ( bResolver ) ; \n} \nparser . parse ( new InputSource ( is ) ) ; \n} \n} \ncatch ( ClassNotFoundException cnfe ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( IllegalAccessException iae ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( InstantiationException ie ) { \nthrow new CatalogException ( CatalogException . UNPARSEABLE ) ; \n} \ncatch ( ParserConfigurationException pce ) { \nthrow new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; \n} \ncatch ( SAXException se ) { \nException e = se . getException ( ) ; \nUnknownHostException uhe = new UnknownHostException ( ) ; \nFileNotFoundException fnfe = new FileNotFoundException ( ) ; \nif ( e != null ) { \nif ( e . getClass ( ) == uhe . getClass ( ) ) { \nthrow new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; \n} \nelse { \nif ( e . getClass ( ) == fnfe . getClass ( ) ) { \nthrow new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; \n} \n} \n} \nthrow new CatalogException ( se ) ; \n} \n} \n} \n"}
{"9471": "public class BootstrapResolver { \npublic InputSource resolveEntity ( String publicId , String systemId ) { \nString resolved = null ; \nif ( systemId != null && systemMap . containsKey ( systemId ) ) { \nresolved = ( String ) systemMap . get ( systemId ) ; \n} \nelse { \nif ( publicId != null && publicMap . containsKey ( publicId ) ) { \nresolved = ( String ) publicMap . get ( publicId ) ; \n} \n} \nif ( resolved != null ) { \ntry { \nInputSource iSource = new InputSource ( resolved ) ; \niSource . setPublicId ( publicId ) ; \nURL url = new URL ( resolved ) ; \nInputStream iStream = url . openStream ( ) ; \niSource . setByteStream ( iStream ) ; \nreturn iSource ; \n} \ncatch ( Exception e ) { \nreturn null ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9483": "public class Vertex { \npublic boolean addEdge ( Edge < T > e ) { \nif ( e . getFrom ( ) == this ) outgoingEdges . add ( e ) ; \nelse { \nif ( e . getTo ( ) == this ) incomingEdges . add ( e ) ; \nelse return false ; \n} \nreturn true ; \n} \n} \n"}
{"9486": "public class Vertex { \npublic boolean hasEdge ( Edge < T > e ) { \nif ( e . getFrom ( ) == this ) return outgoingEdges . contains ( e ) ; \nelse { \nif ( e . getTo ( ) == this ) return incomingEdges . contains ( e ) ; \nelse return false ; \n} \n} \n} \n"}
{"9487": "public class Vertex { \npublic boolean remove ( Edge < T > e ) { \nif ( e . getFrom ( ) == this ) outgoingEdges . remove ( e ) ; \nelse { \nif ( e . getTo ( ) == this ) incomingEdges . remove ( e ) ; \nelse return false ; \n} \nreturn true ; \n} \n} \n"}
{"9491": "public class JarUtils { \nprivate static void jar ( File src , String prefix , JarInfo info ) throws IOException { \nJarOutputStream jout = info . out ; \nif ( src . isDirectory ( ) ) { \nprefix = prefix + src . getName ( ) + \"/\" ; \nZipEntry entry = new ZipEntry ( prefix ) ; \nentry . setTime ( src . lastModified ( ) ) ; \nentry . setMethod ( JarOutputStream . STORED ) ; \nentry . setSize ( 0L ) ; \nentry . setCrc ( 0L ) ; \njout . putNextEntry ( entry ) ; \njout . closeEntry ( ) ; \nFile [ ] files = src . listFiles ( info . filter ) ; \nfor ( int i = 0 ; \ni < files . length ; \ni ++ ) { \njar ( files [ i ] , prefix , info ) ; \n} \n} \nelse { \nif ( src . isFile ( ) ) { \nbyte [ ] buffer = info . buffer ; \nZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; \nentry . setTime ( src . lastModified ( ) ) ; \njout . putNextEntry ( entry ) ; \nFileInputStream in = new FileInputStream ( src ) ; \nint len ; \nwhile ( ( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ) { \njout . write ( buffer , 0 , len ) ; \n} \nin . close ( ) ; \njout . closeEntry ( ) ; \n} \n} \n} \n} \n"}
{"9535": "public class StringUtils { \npublic static String join ( final List < String > list ) { \nif ( list == null ) { \nreturn null ; \n} \nelse { \nif ( list . size ( ) == 0 ) { \nreturn \"\" ; \n} \nelse { \nif ( list . size ( ) == 1 ) { \nreturn list . get ( 0 ) ; \n} \n} \n} \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( String item : list ) { \nif ( builder . length ( ) > 0 ) { \nbuilder . append ( \", \" ) ; \n} \nbuilder . append ( item ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"9536": "public class StringUtils { \npublic static String join ( final String [ ] list ) { \nif ( list == null ) { \nreturn null ; \n} \nelse { \nif ( list . length == 0 ) { \nreturn \"\" ; \n} \nelse { \nif ( list . length == 1 ) { \nreturn list [ 0 ] ; \n} \n} \n} \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( String item : list ) { \nif ( builder . length ( ) > 0 ) { \nbuilder . append ( \", \" ) ; \n} \nbuilder . append ( item ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"9581": "public class ArgumentsLoader { \npublic static void parse ( String [ ] args ) { \nfor ( int i = 0 ; \nargs != null && i < args . length ; \ni ++ ) { \nif ( \"--help\" . equals ( args [ i ] ) ) { \nabort ( null ) ; \n} \nif ( i + 1 < args . length ) { \nparseArgumentWithOption ( args [ i ] , args [ ++ i ] ) ; \n} \n} \nif ( config == null ) { \nabort ( \"Configuration file or string was not given\" ) ; \n} \nelse { \nif ( config . getAgents ( ) == null || config . getAgents ( ) . isEmpty ( ) ) { \nabort ( \"Configuration is missing agents specification\" ) ; \n} \n} \n} \n} \n"}
{"9587": "public class Stack255 { \npublic Object get ( int idx ) { \nint index = idx & 0xff ; \nif ( isEmpty ( ) ) { \nreturn null ; \n} \nelse { \nif ( index < 0 || index >= size ) { \nreturn null ; \n} \n} \nreturn objects [ index ] ; \n} \n} \n"}
{"9605": "public class IntentionSelector { \npublic void run ( ) { \nSet < Integer > toRemove = new HashSet < Integer > ( ) ; \ndo { \nboolean idle = true ; \nremoveInactiveAgents ( ) ; \naddActiveAgents ( ) ; \nfor ( Integer i : activeAgents ) { \nAgent agent = ( Agent ) GlobalState . agents . get ( i ) ; \nStack255 agentExecutionStack = ( Stack255 ) ( agent ) . getExecutionStack ( ) ; \nif ( ! isStackValid ( agent , agentExecutionStack ) ) { \ntoRemove . add ( i ) ; \ncontinue ; \n} \nidle = false ; \nObject node = ( Object ) agentExecutionStack . get ( ( byte ) ( agentExecutionStack . size ( ) - 1 ) ) ; \nif ( node instanceof Plan ) { \nmanagePlan ( i , agentExecutionStack , ( Plan ) node , toRemove ) ; \n} \nelse { \nif ( node instanceof Goal ) { \nmanageGoal ( i , agent , agentExecutionStack , ( Goal ) node ) ; \n} \n} \nagent . nextActiveStack ( ) ; \n} \nremoveFinishedAgents ( toRemove ) ; \nif ( idle ) { \nwaitOnExternalMessage ( ) ; \nif ( shutdown ) { \nbreak ; \n} \n} \n} \nwhile ( true ) ; \nlogger . debug ( \"Pool {} is exiting\" , poolid ) ; \n} \n} \n"}
{"9611": "public class Board { \npublic boolean move ( int pinA , int pinB ) { \nif ( pinA < 0 || pinA >= pins . length || pinB < 0 || pinB >= pins . length ) { \nLog . warn ( \"Invalid board pin specified \" + pinA + \". Should be between 0..\" + ( pins . length - 1 ) + \" (inclusive).\" ) ; \nreturn false ; \n} \nelse { \nif ( pins [ pinA ] . isEmpty ( ) ) { \nLog . warn ( \"No disc on pin\" + pinA ) ; \nreturn false ; \n} \nelse { \nif ( pinA == pinB ) { \nLog . info ( \"Moving disc from pin\" + pinA + \" on to itself (means the board will not change)\" ) ; \nreturn true ; \n} \n} \n} \nint discOnA = pins [ pinA ] . get ( pins [ pinA ] . size ( ) - 1 ) ; \nint discOnB = ( pins [ pinB ] . isEmpty ( ) ) ? Integer . MAX_VALUE : pins [ pinB ] . get ( pins [ pinB ] . size ( ) - 1 ) ; \nif ( discOnB < discOnA ) { \nLog . warn ( \"Cannot move disc\" + discOnA + \" (pin\" + pinA + \") on to smaller disc\" + discOnB + \" (pin\" + pinB + \")\" ) ; \nreturn false ; \n} \npins [ pinB ] . add ( pins [ pinA ] . remove ( pins [ pinA ] . size ( ) - 1 ) ) ; \nreturn true ; \n} \n} \n"}
{"9701": "public class FileSystemDirectoryHelper { \npublic File rel2abs ( final String basePath , final String relPath ) { \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] relParts = getParts ( relPath ) ; \nif ( isAbsolutePath ( relPath ) ) { \nreturn new File ( relPath ) ; \n} \nList < String > parts = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \ni < baseParts . length ; \n++ i ) { \nif ( i > 0 || ! isWindowsDrive ( basePath ) ) { \nparts . add ( baseParts [ i ] ) ; \n} \n} \nfor ( String part : relParts ) { \nif ( part . equals ( \"..\" ) && parts . size ( ) > 0 ) { \nparts . remove ( parts . size ( ) - 1 ) ; \n} \nelse { \nif ( ! part . equals ( \".\" ) && ! part . equals ( \"..\" ) ) { \nparts . add ( part ) ; \n} \n} \n} \nStringBuilder result = new StringBuilder ( ) ; \nif ( isWindowsDrive ( basePath ) ) { \nresult . append ( baseParts [ 0 ] ) ; \n} \nfor ( String part : parts ) { \nresult . append ( File . separator ) ; \nresult . append ( part ) ; \n} \nreturn new File ( result . toString ( ) ) ; \n} \n} \n"}
{"9887": "public class StartHELM2Parser { \npublic static void main ( String [ ] args ) throws ParseException , ExceptionState , IOException { \nOptions options = new Options ( ) ; \noptions . addOption ( \"inputHELM\" , true , \"HELM1 or HELM2 string in a file\" ) ; \noptions . addOption ( \"output\" , true , \"output can be in JSON- or HELM2-format\" ) ; \noptions . addOption ( \"translate\" , false , \"translate HELM1 to HELM2\" ) ; \nCommandLineParser parameter = new DefaultParser ( ) ; \ntry { \nCommandLine cmd = parameter . parse ( options , args ) ; \nString filename = cmd . getOptionValue ( \"inputHELM\" ) ; \nParserHELM2 parser = new ParserHELM2 ( ) ; \nFileReader in = new FileReader ( filename ) ; \nBufferedReader br = new BufferedReader ( in ) ; \nString line ; \nString helm ; \ntry { \nwhile ( ( line = br . readLine ( ) ) != null ) { \nhelm = line ; \nif ( cmd . hasOption ( \"translate\" ) ) { \nConverterHELM1ToHELM2 converter = new ConverterHELM1ToHELM2 ( ) ; \nhelm = converter . doConvert ( helm ) ; \nLOG . info ( \"HELM1 is translated to HELM2\" ) ; \n} \nparser . parse ( helm ) ; \nString output = \"\" ; \nif ( cmd . getOptionValue ( \"output\" ) . equals ( \"HELM2\" ) ) { \noutput = parser . getHELM2Notation ( ) . toHELM2 ( ) ; \n} \nelse { \nif ( cmd . getOptionValue ( \"output\" ) . equals ( \"JSON\" ) ) { \noutput = parser . getJSON ( ) ; \n} \n} \nSystem . out . println ( output ) ; \n} \n} \nfinally { \nbr . close ( ) ; \n} \n} \ncatch ( NullPointerException e ) { \nSystem . out . println ( \"Please call the program with the following arguments: \" + \"\\n\" + \"-inputHELM  <\" + options . getOption ( \"inputHELM\" ) . getDescription ( ) + \">\\n\" + \"-output <\" + options . getOption ( \"output\" ) . getDescription ( ) + \">\\n-translate(optional) <\" + options . getOption ( \"translate\" ) . getDescription ( ) + \">\" ) ; \n} \ncatch ( ParseException exp ) { \nSystem . out . println ( \"Unexpected exception: \" + exp . getMessage ( ) ) ; \n} \n} \n} \n"}
{"9908": "public class ValidationMethod { \npublic static MonomerNotation decideWhichMonomerNotation ( String str , String type ) throws NotationException { \nMonomerNotation mon ; \nif ( str . startsWith ( \"(\" ) && str . endsWith ( \")\" ) ) { \nString str2 = str . substring ( 1 , str . length ( ) - 1 ) ; \nPattern patternAND = Pattern . compile ( \"\\\\+\" ) ; \nPattern patternOR = Pattern . compile ( \",\" ) ; \nif ( patternAND . matcher ( str ) . find ( ) ) { \nmon = new MonomerNotationGroupMixture ( str2 , type ) ; \n} \nelse { \nif ( patternOR . matcher ( str ) . find ( ) ) { \nmon = new MonomerNotationGroupOr ( str2 , type ) ; \n} \nelse { \nif ( str . contains ( \".\" ) ) { \nmon = new MonomerNotationList ( str2 , type ) ; \n} \nelse { \nif ( type == \"RNA\" ) { \nmon = new MonomerNotationUnitRNA ( str2 , type ) ; \n} \nelse { \nif ( str2 . length ( ) > 1 ) { \nif ( ! ( str2 . startsWith ( \"[\" ) && str2 . endsWith ( \"]\" ) ) ) { \nthrow new NotationException ( \"Monomers have to be in brackets: \" + str ) ; \n} \n} \nmon = new MonomerNotationUnit ( str2 , type ) ; \n} \n} \n} \n} \n} \nelse { \nif ( type == \"RNA\" ) { \nmon = new MonomerNotationUnitRNA ( str , type ) ; \n} \nelse { \nif ( type != \"BLOB\" ) { \nif ( str . length ( ) > 1 ) { \nif ( ! ( str . startsWith ( \"[\" ) && str . endsWith ( \"]\" ) ) ) { \nthrow new NotationException ( \"Monomers have to be in brackets: \" + str ) ; \n} \n} \nmon = new MonomerNotationUnit ( str , type ) ; \n} \nelse { \nmon = new MonomerNotationUnit ( str , type ) ; \n} \n} \n} \nreturn mon ; \n} \n} \n"}
{"9910": "public class ValidationMethod { \npublic static HELMEntity decideWhichEntity ( String str ) throws NotationException { \nHELMEntity item ; \nif ( str . toUpperCase ( ) . matches ( \"PEPTIDE[1-9][0-9]*\" ) ) { \nitem = new PeptideEntity ( str . toUpperCase ( ) ) ; \n} \nelse { \nif ( str . toUpperCase ( ) . matches ( \"RNA[1-9][0-9]*\" ) ) { \nitem = new RNAEntity ( str . toUpperCase ( ) ) ; \n} \nelse { \nif ( str . toUpperCase ( ) . matches ( \"BLOB[1-9][0-9]*\" ) ) { \nitem = new BlobEntity ( str . toUpperCase ( ) ) ; \n} \nelse { \nif ( str . toUpperCase ( ) . matches ( \"CHEM[1-9][0-9]*\" ) ) { \nitem = new ChemEntity ( str . toUpperCase ( ) ) ; \n} \nelse { \nif ( str . toUpperCase ( ) . matches ( \"G[1-9][0-9]*\" ) ) { \nitem = new GroupEntity ( str . toUpperCase ( ) ) ; \n} \nelse { \nthrow new NotationException ( \"ID is wrong: \" + str ) ; \n} \n} \n} \n} \n} \nreturn item ; \n} \n} \n"}
{"9923": "public class API { \npublic void return_ ( final Integer request_type , final String name , final String pattern , final byte [ ] response_info , final byte [ ] response , final Integer timeout , final byte [ ] trans_id , final OtpErlangPid pid ) throws ReturnAsyncException , ReturnSyncException , InvalidInputException { \nif ( request_type == API . ASYNC ) return_async ( name , pattern , response_info , response , timeout , trans_id , pid ) ; \nelse { \nif ( request_type == API . SYNC ) return_sync ( name , pattern , response_info , response , timeout , trans_id , pid ) ; \nelse throw new InvalidInputException ( ) ; \n} \n} \n} \n"}
{"9932": "public class ForkJoinPool { \nfinal void deregisterWorker ( ForkJoinWorkerThread wt , Throwable ex ) { \nWorkQueue w = null ; \nif ( wt != null && ( w = wt . workQueue ) != null ) { \nWorkQueue [ ] ws ; \nint idx = w . config & SMASK ; \nint rs = lockRunState ( ) ; \nif ( ( ws = workQueues ) != null && ws . length > idx && ws [ idx ] == w ) ws [ idx ] = null ; \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nlong c ; \ndo { \n} \nwhile ( ! U . compareAndSwapLong ( this , CTL , c = ctl , ( ( AC_MASK & ( c - AC_UNIT ) ) | ( TC_MASK & ( c - TC_UNIT ) ) | ( SP_MASK & c ) ) ) ) ; \nif ( w != null ) { \nw . qlock = - 1 ; \nw . transferStealCount ( this ) ; \nw . cancelAll ( ) ; \n} \nfor ( ; \n; \n) { \nWorkQueue [ ] ws ; \nint m , sp ; \nif ( tryTerminate ( false , false ) || w == null || w . array == null || ( runState & STOP ) != 0 || ( ws = workQueues ) == null || ( m = ws . length - 1 ) < 0 ) break ; \nif ( ( sp = ( int ) ( c = ctl ) ) != 0 ) { \nif ( tryRelease ( c , ws [ sp & m ] , AC_UNIT ) ) break ; \n} \nelse { \nif ( ex != null && ( c & ADD_WORKER ) != 0L ) { \ntryAddWorker ( c ) ; \nbreak ; \n} \nelse break ; \n} \n} \nif ( ex == null ) ForkJoinTask . helpExpungeStaleExceptions ( ) ; \nelse ForkJoinTask . rethrow ( ex ) ; \n} \n} \n"}
{"9934": "public class ForkJoinPool { \nfinal void runWorker ( WorkQueue w ) { \nw . growArray ( ) ; \nint seed = w . hint ; \nint r = ( seed == 0 ) ? 1 : seed ; \nfor ( ForkJoinTask < ? > t ; \n; \n) { \nif ( ( t = scan ( w , r ) ) != null ) w . runTask ( t ) ; \nelse { \nif ( ! awaitWork ( w , r ) ) break ; \n} \nr ^= r << 13 ; \nr ^= r >>> 17 ; \nr ^= r << 5 ; \n} \n} \n} \n"}
{"9935": "public class ForkJoinPool { \nprivate boolean awaitWork ( WorkQueue w , int r ) { \nif ( w == null || w . qlock < 0 ) return false ; \nfor ( int pred = w . stackPred , spins = SPINS , ss ; \n; \n) { \nif ( ( ss = w . scanState ) >= 0 ) break ; \nelse { \nif ( spins > 0 ) { \nr ^= r << 6 ; \nr ^= r >>> 21 ; \nr ^= r << 7 ; \nif ( r >= 0 && -- spins == 0 ) { \nWorkQueue v ; \nWorkQueue [ ] ws ; \nint s , j ; \nAtomicLong sc ; \nif ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scanState >= 0 ) ) spins = SPINS ; \n} \n} \nelse { \nif ( w . qlock < 0 ) return false ; \nelse { \nif ( ! Thread . interrupted ( ) ) { \nlong c , prevctl , parkTime , deadline ; \nint ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; \nif ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) return false ; \nif ( ac <= 0 && ss == ( int ) c ) { \nprevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; \nint t = ( short ) ( c >>> TC_SHIFT ) ; \nif ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \nparkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; \ndeadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; \n} \nelse prevctl = parkTime = deadline = 0L ; \nThread wt = Thread . currentThread ( ) ; \nU . putObject ( wt , PARKBLOCKER , this ) ; \nw . parker = wt ; \nif ( w . scanState < 0 && ctl == c ) U . park ( false , parkTime ) ; \nU . putOrderedObject ( w , QPARKER , null ) ; \nU . putObject ( wt , PARKBLOCKER , null ) ; \nif ( w . scanState >= 0 ) break ; \nif ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \n} \n} \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"9941": "public class ForkJoinTask { \npublic final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nint s ; \nlong nanos = unit . toNanos ( timeout ) ; \nif ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; \nif ( ( s = status ) >= 0 && nanos > 0L ) { \nlong d = System . nanoTime ( ) + nanos ; \nlong deadline = ( d == 0L ) ? 1L : d ; \nThread t = Thread . currentThread ( ) ; \nif ( t instanceof ForkJoinWorkerThread ) { \nForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; \ns = wt . pool . awaitJoin ( wt . workQueue , this , deadline ) ; \n} \nelse { \nif ( ( s = ( ( this instanceof CountedCompleter ) ? ForkJoinPool . common . externalHelpComplete ( ( CountedCompleter < ? > ) this , 0 ) : ForkJoinPool . common . tryExternalUnpush ( this ) ? doExec ( ) : 0 ) ) >= 0 ) { \nlong ns , ms ; \nwhile ( ( s = status ) >= 0 && ( ns = deadline - System . nanoTime ( ) ) > 0L ) { \nif ( ( ms = TimeUnit . NANOSECONDS . toMillis ( ns ) ) > 0L && U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { \nsynchronized ( this ) { \nif ( status >= 0 ) wait ( ms ) ; \nelse notifyAll ( ) ; \n} \n} \n} \n} \n} \n} \nif ( s >= 0 ) s = status ; \nif ( ( s &= DONE_MASK ) != NORMAL ) { \nThrowable ex ; \nif ( s == CANCELLED ) throw new CancellationException ( ) ; \nif ( s != EXCEPTIONAL ) throw new TimeoutException ( ) ; \nif ( ( ex = getThrowableException ( ) ) != null ) throw new ExecutionException ( ex ) ; \n} \nreturn getRawResult ( ) ; \n} \n} \n"}
{"9995": "public class Controller { \nprotected String parsePath ( String currentActionPath , String url ) { \nif ( url . startsWith ( SLASH ) ) { \nreturn url . split ( \"\\\\?\" ) [ 0 ] ; \n} \nelse { \nif ( ! url . contains ( SLASH ) ) { \nreturn SLASH + currentActionPath . split ( SLASH ) [ 1 ] + SLASH + url . split ( \"\\\\?\" ) [ 0 ] ; \n} \nelse { \nif ( url . contains ( \"http:\" ) || url . contains ( \"https:\" ) ) { \nreturn null ; \n} \n} \n} \nreturn currentActionPath + SLASH + url . split ( \"\\\\?\" ) [ 0 ] ; \n} \n} \n"}
{"10015": "public class Pipeline { \n@ SuppressWarnings ( \"unchecked\" ) public T apply ( T io ) { \nlogger . debug ( \"Pipeline began\" ) ; \ntry { \nfor ( int i = 0 ; \ni < stages . size ( ) ; \ni ++ ) { \nObject stage = stages . get ( i ) ; \nString name = names . get ( stage ) ; \nlogger . debug ( \"Stage-\" + i + ( ( name != null && ! name . isEmpty ( ) ) ? \" [\" + name + \"] \" : \" \" ) + \"processing\" ) ; \nif ( stage instanceof Function ) { \nif ( ( io = ( ( Function < T , T > ) stage ) . apply ( io ) ) == null ) { \nreturn io ; \n} \n} \nelse { \nif ( stage instanceof Predicate ) { \nif ( ! ( ( Predicate < T > ) stage ) . apply ( io ) ) { \nreturn io ; \n} \n} \n} \n} \nreturn io ; \n} \nfinally { \nlogger . debug ( \"Pipeline ended\" ) ; \n} \n} \n} \n"}
{"10056": "public class AbstractRequest { \nprotected Object builtin ( Type type ) { \nClass < ? > rawType = Types . getRawType ( type ) ; \nif ( rawType . equals ( WebContext . class ) ) { \nreturn context ; \n} \nelse { \nif ( rawType . equals ( HttpServletRequest . class ) ) { \nreturn context . request ( ) ; \n} \nelse { \nif ( rawType . equals ( HttpServletResponse . class ) ) { \nreturn context . response ( ) ; \n} \nelse { \nif ( rawType . equals ( HttpSession . class ) ) { \nreturn context . session ( ) ; \n} \nelse { \nif ( rawType . equals ( ServletContext . class ) ) { \nreturn context . application ( ) ; \n} \nelse { \nreturn this ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"10057": "public class AbstractRequest { \nprotected Object primitive ( Type type ) { \nClass < ? > rawType = Types . getRawType ( type ) ; \nif ( rawType . equals ( Boolean . TYPE ) ) { \nreturn ( boolean ) false ; \n} \nelse { \nif ( rawType . equals ( Character . TYPE ) ) { \nreturn ( char ) 0 ; \n} \nelse { \nif ( rawType . equals ( Byte . TYPE ) ) { \nreturn ( byte ) 0 ; \n} \nelse { \nif ( rawType . equals ( Double . TYPE ) ) { \nreturn ( double ) 0.0 ; \n} \nelse { \nif ( rawType . equals ( Float . TYPE ) ) { \nreturn ( float ) 0.0 ; \n} \nelse { \nif ( rawType . equals ( Integer . TYPE ) ) { \nreturn ( int ) 0 ; \n} \nelse { \nreturn ( short ) 0 ; \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"10059": "public class AbstractRequest { \nprotected Object convertUserDefinedValueType ( Object object , Class < ? > type ) { \nif ( type . isAssignableFrom ( object . getClass ( ) ) ) { \nreturn object ; \n} \nelse { \nif ( object instanceof String ) { \ntry { \nConstructor < ? > constructor = type . getConstructor ( String . class ) ; \nreturn constructor . newInstance ( object ) ; \n} \ncatch ( Exception e ) { \nlogger . debug ( \"Cannot invoke [public \" + type . getName ( ) + \"(String.class)] constrcutor on [\" + type + \"]\" , e ) ; \n} \ntry { \nreturn type . getMethod ( \"valueOf\" , String . class ) . invoke ( null , object ) ; \n} \ncatch ( Exception e1 ) { \nlogger . debug ( \"Cannot invoke [public static \" + type . getName ( ) + \".valueOf(String.class)]\" + \"method on [\" + type + \"]\" , e1 ) ; \n} \n} \nelse { \nlogger . warn ( \"Parameter [\" + object + \"] cannot be converted to [\" + type + \"]\" ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"10068": "public class RequestPermission { \nprivate static boolean allValuesGranted ( Object [ ] values , HashMap < Permission , Result > resultMap ) { \nif ( values instanceof Permission [ ] ) { \nSet < Permission > valueSet = new HashSet < > ( Arrays . asList ( ( Permission [ ] ) values ) ) ; \nif ( resultMap . keySet ( ) . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . GRANTED != resultMap . get ( ( Permission ) value ) ) { \nmLog . i ( TAG , \"denied - \" + value . toString ( ) ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \nelse { \nif ( values instanceof String [ ] ) { \nSet < String > valueSet = new HashSet < > ( Arrays . asList ( ( String [ ] ) values ) ) ; \nSet < String > permission = new HashSet < > ( ) ; \nfor ( Permission perm : resultMap . keySet ( ) ) { \npermission . add ( perm . toString ( ) ) ; \n} \nif ( permission . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . GRANTED != resultMap . get ( Permission . get ( String . valueOf ( value ) ) ) ) { \nmLog . i ( TAG , \"denied - \" + value ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10069": "public class RequestPermission { \nprivate static boolean anyValueDenied ( Object [ ] values , HashMap < Permission , Result > resultMap ) { \nif ( values instanceof Permission [ ] ) { \nSet < Permission > valueSet = new LinkedHashSet < > ( Arrays . asList ( ( Permission [ ] ) values ) ) ; \nif ( resultMap . keySet ( ) . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . DENIED == resultMap . get ( ( Permission ) value ) ) { \nmLog . i ( TAG , \"denied - \" + value . toString ( ) ) ; \nreturn true ; \n} \n} \n} \n} \nelse { \nif ( values instanceof String [ ] ) { \nSet < String > valueSet = new HashSet < > ( Arrays . asList ( ( String [ ] ) values ) ) ; \nSet < String > permissionSet = new HashSet < > ( ) ; \nfor ( Permission perm : resultMap . keySet ( ) ) { \npermissionSet . add ( perm . toString ( ) ) ; \n} \nif ( permissionSet . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . DENIED == resultMap . get ( Permission . get ( ( String ) value ) ) ) { \nmLog . i ( TAG , \"denied - \" + value ) ; \nreturn true ; \n} \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10101": "public class URI { \nprivate void initializePath ( String p_uriSpec ) throws MalformedURIException { \nif ( p_uriSpec == null ) { \nthrow new MalformedURIException ( \"Cannot initialize path from null string!\" ) ; \n} \nint index = 0 ; \nint start = 0 ; \nint end = p_uriSpec . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '?' || testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Path contains invalid escape sequence!\" ) ; \n} \n} \nelse { \nif ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character: \" + testChar ) ; \n} \n} \nindex ++ ; \n} \nm_path = p_uriSpec . substring ( start , index ) ; \nif ( testChar == '?' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid escape sequence!\" ) ; \n} \n} \nelse { \nif ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid character:\" + testChar ) ; \n} \n} \nindex ++ ; \n} \nm_queryString = p_uriSpec . substring ( start , index ) ; \n} \nif ( testChar == '#' ) { \nindex ++ ; \nstart = index ; \nwhile ( index < end ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid escape sequence!\" ) ; \n} \n} \nelse { \nif ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid character:\" + testChar ) ; \n} \n} \nindex ++ ; \n} \nm_fragment = p_uriSpec . substring ( start , index ) ; \n} \n} \n} \n"}
{"10103": "public class URI { \nprivate void setUserinfo ( String p_userinfo ) throws MalformedURIException { \nif ( p_userinfo == null ) { \nm_userinfo = null ; \n} \nelse { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Userinfo cannot be set when host is null!\" ) ; \n} \nint index = 0 ; \nint end = p_userinfo . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( index < end ) { \ntestChar = p_userinfo . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( index + 2 >= end || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid escape sequence!\" ) ; \n} \n} \nelse { \nif ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid character:\" + testChar ) ; \n} \n} \nindex ++ ; \n} \n} \nm_userinfo = p_userinfo ; \n} \n} \n"}
{"10104": "public class URI { \nprivate void setHost ( String p_host ) throws MalformedURIException { \nif ( p_host == null || p_host . length ( ) == 0 ) { \nm_host = p_host ; \nm_userinfo = null ; \nm_port = null ; \nn_port = - 1 ; \n} \nelse { \nif ( ! isWellFormedAddress ( p_host ) ) { \nthrow new MalformedURIException ( \"Host is not a well formed address!\" ) ; \n} \n} \nm_host = p_host ; \n} \n} \n"}
{"10105": "public class URI { \nprivate void setPort ( int p_port ) throws MalformedURIException { \nif ( p_port >= 0 && p_port <= 65535 ) { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Port cannot be set when host is null!\" ) ; \n} \n} \nelse { \nif ( p_port != - 1 ) { \nthrow new MalformedURIException ( \"Invalid port number!\" ) ; \n} \n} \nn_port = p_port ; \n} \n} \n"}
{"10106": "public class URI { \nprivate void appendPath ( String p_addToPath ) throws MalformedURIException { \nif ( p_addToPath == null || p_addToPath . length ( ) == 0 ) { \nreturn ; \n} \nif ( ! isURIString ( p_addToPath ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character!\" ) ; \n} \nif ( m_path == null || m_path . length ( ) == 0 ) { \nif ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = p_addToPath ; \n} \nelse { \nm_path = \"/\" + p_addToPath ; \n} \n} \nelse { \nif ( m_path . endsWith ( \"/\" ) ) { \nif ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = m_path . concat ( p_addToPath . substring ( 1 ) ) ; \n} \nelse { \nm_path = m_path . concat ( p_addToPath ) ; \n} \n} \nelse { \nif ( p_addToPath . startsWith ( \"/\" ) ) { \nm_path = m_path . concat ( p_addToPath ) ; \n} \nelse { \nm_path = m_path . concat ( \"/\" + p_addToPath ) ; \n} \n} \n} \n} \n} \n"}
{"10107": "public class URI { \nprivate void setQueryString ( String p_queryString ) throws MalformedURIException { \nif ( p_queryString == null ) { \nm_queryString = null ; \n} \nelse { \nif ( ! isGenericURI ( ) ) { \nthrow new MalformedURIException ( \"Query string can only be set for a generic URI!\" ) ; \n} \nelse { \nif ( getPath ( ) == null ) { \nthrow new MalformedURIException ( \"Query string cannot be set when path is null!\" ) ; \n} \nelse { \nif ( ! isURIString ( p_queryString ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid character!\" ) ; \n} \nelse { \nm_queryString = p_queryString ; \n} \n} \n} \n} \n} \n} \n"}
{"10108": "public class URI { \npublic void setFragment ( String p_fragment ) throws MalformedURIException { \nif ( p_fragment == null ) { \nm_fragment = null ; \n} \nelse { \nif ( ! isGenericURI ( ) ) { \nthrow new MalformedURIException ( \"Fragment can only be set for a generic URI!\" ) ; \n} \nelse { \nif ( getPath ( ) == null ) { \nthrow new MalformedURIException ( \"Fragment cannot be set when path is null!\" ) ; \n} \nelse { \nif ( ! isURIString ( p_fragment ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid character!\" ) ; \n} \nelse { \nm_fragment = p_fragment ; \n} \n} \n} \n} \n} \n} \n"}
{"10142": "public class NamedParameterStatement { \nprivate static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { \nint length = sql . length ( ) ; \nStringBuffer parsedSql = new StringBuffer ( length ) ; \nboolean inSingleQuote = false ; \nboolean inDoubleQuote = false ; \nint index = 1 ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nchar c = sql . charAt ( i ) ; \nif ( inSingleQuote ) { \nif ( c == '\\'' ) { \ninSingleQuote = false ; \n} \n} \nelse { \nif ( inDoubleQuote ) { \nif ( c == '\"' ) { \ninDoubleQuote = false ; \n} \n} \nelse { \nif ( c == '\\'' ) { \ninSingleQuote = true ; \n} \nelse { \nif ( c == '\"' ) { \ninDoubleQuote = true ; \n} \nelse { \nif ( c == ':' && i + 1 < length && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { \nint j = i + 2 ; \nwhile ( j < length && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) { \nj ++ ; \n} \nString name = sql . substring ( i + 1 , j ) ; \nc = '?' ; \ni += name . length ( ) ; \nList < Integer > indexList = nameIndexMap . get ( name ) ; \nif ( indexList == null ) { \nindexList = new LinkedList < Integer > ( ) ; \nnameIndexMap . put ( name , indexList ) ; \n} \nindexList . add ( index ) ; \nindex ++ ; \n} \n} \n} \n} \n} \nparsedSql . append ( c ) ; \n} \nreturn parsedSql . toString ( ) ; \n} \n} \n"}
{"10162": "public class PasswordLoginModule { \n@ SuppressWarnings ( \"PMD.ConfusingTernary\" ) private void initAudit ( final CommonProperties commonProps ) { \ntry { \nfinal String auditClassName = commonProps . getAuditClassName ( ) ; \nif ( ! commonProps . isAuditEnabled ( ) ) { \nfinal String error = \"Auditing has been disabled in the JAAS configuration\" ; \nLOG . info ( error ) ; \n} \nelse { \nif ( auditClassName == null ) { \nfinal String error = \"Auditing has been enabled in the JAAS configuration, but no audit class has been configured\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse { \nif ( commonProps . isAuditSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton audit class instance of '\" + auditClassName + \"' from the audit factory\" ) ; \nthis . audit = AuditFactory . getSingleton ( auditClassName , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton audit class instance of '\" + auditClassName + \"' from the audit factory\" ) ; \nthis . audit = AuditFactory . getInstance ( auditClassName , commonProps ) ; \n} \n} \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The audit class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10163": "public class PasswordLoginModule { \n@ SuppressWarnings ( \"PMD.ConfusingTernary\" ) private void initMessageQueue ( final CommonProperties commonProps ) { \ntry { \nfinal String messageClassName = commonProps . getMessageQueueClassName ( ) ; \nif ( ! commonProps . isMessageQueueEnabled ( ) ) { \nfinal String error = \"Message queue has been disabled in the JAAS configuration\" ; \nLOG . info ( error ) ; \n} \nelse { \nif ( messageClassName == null ) { \nfinal String error = \"Message queue has been enabled in the JAAS configuration, \" + \"but no message queue class has been configured\" ; \nLOG . error ( error ) ; \nthrow new IllegalStateException ( error ) ; \n} \nelse { \nif ( commonProps . isMessageQueueSingleton ( ) ) { \nLOG . debug ( \"Requesting singleton message class instance of '\" + messageClassName + \"' from the message factory\" ) ; \nthis . messageQ = MessageQFactory . getSingleton ( messageClassName , commonProps ) ; \n} \nelse { \nLOG . debug ( \"Requesting non-singleton message class instance of '\" + messageClassName + \"' from the message factory\" ) ; \nthis . messageQ = MessageQFactory . getInstance ( messageClassName , commonProps ) ; \n} \n} \n} \n} \ncatch ( FactoryException e ) { \nfinal String error = \"The message class cannot be instantiated. This is most likely a configuration\" + \" problem. Is the configured class available in the classpath?\" ; \nLOG . error ( error , e ) ; \nthrow new IllegalStateException ( error , e ) ; \n} \n} \n} \n"}
{"10182": "public class AreaGrid { \npublic int getColOfs ( int col ) throws ArrayIndexOutOfBoundsException { \nif ( col < width ) { \nint ofs = 0 ; \nfor ( int i = 0 ; \ni < col ; \ni ++ ) ofs += cols [ i ] ; \nreturn ofs ; \n} \nelse { \nif ( col == width ) return abspos . getWidth ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( col + \">\" + width ) ; \n} \n} \n} \n"}
{"10183": "public class AreaGrid { \npublic int getRowOfs ( int row ) throws ArrayIndexOutOfBoundsException { \nif ( row < height ) { \nint ofs = 0 ; \nfor ( int i = 0 ; \ni < row ; \ni ++ ) ofs += rows [ i ] ; \nreturn ofs ; \n} \nelse { \nif ( row == height ) return abspos . getHeight ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( row + \">\" + height ) ; \n} \n} \n} \n"}
{"10187": "public class JdbcLogSupport { \nprotected Throwable unwrapThrowable ( Throwable t ) { \nThrowable e = t ; \nwhile ( true ) { \nif ( e instanceof InvocationTargetException ) { \ne = ( ( InvocationTargetException ) t ) . getTargetException ( ) ; \n} \nelse { \nif ( t instanceof UndeclaredThrowableException ) { \ne = ( ( UndeclaredThrowableException ) t ) . getUndeclaredThrowable ( ) ; \n} \nelse { \nreturn e ; \n} \n} \n} \n} \n} \n"}
{"10199": "public class ButtonPanel { \npublic void propertyChange ( PropertyChangeEvent event ) { \nif ( event . getSource ( ) instanceof WorkPanelState ) { \nString state = ( ( WorkPanelState ) event . getSource ( ) ) . getState ( ) ; \nif ( state . equals ( WorkPanelState . NOT_SAVED ) ) { \ncancelButton . setEnabled ( true ) ; \napplyButton . setEnabled ( true ) ; \n} \nelse { \nif ( state . equals ( WorkPanelState . READY ) ) { \ncancelButton . setEnabled ( false ) ; \napplyButton . setEnabled ( false ) ; \n} \nelse { \nif ( state . equals ( WorkPanelState . NOT_INITIALIZED ) ) { \nokButton . setEnabled ( false ) ; \ncancelButton . setEnabled ( false ) ; \napplyButton . setEnabled ( false ) ; \n} \n} \n} \n} \n} \n} \n"}
{"10202": "public class BigDecimalTypeImpl { \npublic static Type createInstance ( String name , int precision , int scale , String min , String max ) { \nsynchronized ( DECIMAL_TYPES ) { \nBigDecimalTypeImpl newType = new BigDecimalTypeImpl ( name , precision , scale , min , max ) ; \nBigDecimalTypeImpl oldType = DECIMAL_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse { \nif ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nDECIMAL_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n} \n"}
{"10205": "public class LexicographicalCollectionComparator { \npublic int compare ( Collection < T > c1 , Collection < T > c2 ) { \nIterator < T > i1 = c1 . iterator ( ) ; \nIterator < T > i2 = c2 . iterator ( ) ; \nwhile ( i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nT t1 = i1 . next ( ) ; \nT t2 = i2 . next ( ) ; \nint comp = comparator . compare ( t1 , t2 ) ; \nif ( comp < 0 ) { \nreturn - 1 ; \n} \nelse { \nif ( comp > 0 ) { \nreturn 1 ; \n} \n} \n} \nif ( ! i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nreturn - 1 ; \n} \nif ( i1 . hasNext ( ) && ! i2 . hasNext ( ) ) { \nreturn 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"10217": "public class PropertyIntrospectorBase { \nprotected void setProperty ( Object callee , String property , Object value ) { \nif ( ! initialized ) { \ninitialize ( callee ) ; \n} \nMethod [ ] setterMethods = setters . get ( property ) ; \nif ( ( setterMethods == null ) || ( setterMethods . length == 0 ) ) { \nthrow new IllegalArgumentException ( \"No setter method for the property \" + property + \" exists.\" ) ; \n} \nMethod setterMethod = null ; \nClass valueType = ( value == null ) ? null : value . getClass ( ) ; \nif ( value == null ) { \nsetterMethod = setterMethods [ 0 ] ; \n} \nelse { \nfor ( Method method : setterMethods ) { \nClass argType = method . getParameterTypes ( ) [ 0 ] ; \nif ( argType . isAssignableFrom ( valueType ) ) { \nsetterMethod = method ; \nbreak ; \n} \nelse { \nif ( argType . isPrimitive ( ) && ! valueType . isPrimitive ( ) && isAssignableFromPrimitive ( valueType , argType ) ) { \nsetterMethod = method ; \nbreak ; \n} \nelse { \nif ( valueType . isPrimitive ( ) && ! argType . isPrimitive ( ) && isAssignableFromPrimitive ( argType , valueType ) ) { \nsetterMethod = method ; \nbreak ; \n} \n} \n} \n} \nif ( setterMethod == null ) { \nClass calleeType = ( callee == null ) ? null : callee . getClass ( ) ; \nthrow new IllegalArgumentException ( \"No setter method for property \" + property + \", of type, \" + calleeType + \" will accept the type of value specified, \" + valueType + \".\" ) ; \n} \n} \ntry { \nObject [ ] args = new Object [ ] { \nvalue } \n; \nsetterMethod . invoke ( callee , args ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalArgumentException ( \"The setter method for the property \" + property + \" threw an invocation target exception.\" , e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( \"The setter method for the property \" + property + \" cannot be accessed.\" , e ) ; \n} \n} \n} \n"}
{"10219": "public class PropertyIntrospectorBase { \nprivate boolean isAssignableFromPrimitive ( Class wrapperType , Class primitiveType ) { \nboolean result = false ; \nif ( primitiveType . equals ( boolean . class ) && wrapperType . equals ( Boolean . class ) ) { \nresult = true ; \n} \nelse { \nif ( primitiveType . equals ( byte . class ) && wrapperType . equals ( Byte . class ) ) { \nresult = true ; \n} \nelse { \nif ( primitiveType . equals ( char . class ) && wrapperType . equals ( Character . class ) ) { \nresult = true ; \n} \nelse { \nif ( primitiveType . equals ( short . class ) && wrapperType . equals ( Short . class ) ) { \nresult = true ; \n} \nelse { \nif ( primitiveType . equals ( int . class ) && wrapperType . equals ( Integer . class ) ) { \nresult = true ; \n} \nelse { \nif ( primitiveType . equals ( long . class ) && wrapperType . equals ( Long . class ) ) { \nresult = true ; \n} \nelse { \nif ( primitiveType . equals ( float . class ) && wrapperType . equals ( Float . class ) ) { \nresult = true ; \n} \nelse { \nif ( primitiveType . equals ( double . class ) && wrapperType . equals ( Double . class ) ) { \nresult = true ; \n} \nelse { \nresult = false ; \n} \n} \n} \n} \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"10220": "public class PropertyIntrospectorBase { \nprivate void initialize ( Object callee ) { \nMap < String , List < Method > > settersTemp = new HashMap < String , List < Method > > ( ) ; \nMethod [ ] methods = callee . getClass ( ) . getMethods ( ) ; \nfor ( Method nextMethod : methods ) { \nString methodName = nextMethod . getName ( ) ; \nif ( methodName . startsWith ( \"get\" ) && ( methodName . length ( ) >= 4 ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 0 ) ) { \nString propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; \ngetters . put ( propertyName , nextMethod ) ; \n} \nelse { \nif ( methodName . startsWith ( \"set\" ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 1 ) ) { \nString propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; \nList < Method > setterMethodsForName = settersTemp . get ( propertyName ) ; \nif ( setterMethodsForName == null ) { \nsetterMethodsForName = new ArrayList < Method > ( ) ; \nsettersTemp . put ( propertyName , setterMethodsForName ) ; \n} \nsetterMethodsForName . add ( nextMethod ) ; \n} \n} \n} \nfor ( Map . Entry < String , List < Method > > entries : settersTemp . entrySet ( ) ) { \nString nextPropertyName = entries . getKey ( ) ; \nList < Method > nextMethodList = entries . getValue ( ) ; \nMethod [ ] methodArray = nextMethodList . toArray ( new Method [ nextMethodList . size ( ) ] ) ; \nsetters . put ( nextPropertyName , methodArray ) ; \n} \ninitialized = true ; \n} \n} \n"}
{"10224": "public class PrologUnifier { \npublic boolean unifyInternal ( Term left , Term right , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( left == right ) { \nreturn true ; \n} \nif ( ! left . isVar ( ) && ! right . isVar ( ) && left . isConstant ( ) && right . isConstant ( ) && left . equals ( right ) ) { \nreturn true ; \n} \nelse { \nif ( left . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) left , right , leftTrail , rightTrail ) ; \n} \nelse { \nif ( right . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) right , left , rightTrail , leftTrail ) ; \n} \nelse { \nif ( left . isFunctor ( ) && right . isFunctor ( ) ) { \nFunctor leftFunctor = ( Functor ) left ; \nFunctor rightFunctor = ( Functor ) right ; \nif ( ! left . equals ( right ) ) { \nreturn false ; \n} \nint arity = leftFunctor . getArity ( ) ; \nfor ( int i = 0 ; \ni < arity ; \ni ++ ) { \nTerm leftArgument = leftFunctor . getArgument ( i ) ; \nTerm rightArgument = rightFunctor . getArgument ( i ) ; \nboolean result = unifyInternal ( leftArgument , rightArgument , leftTrail , rightTrail ) ; \nif ( ! result ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n} \n} \n} \n"}
{"10225": "public class PrologUnifier { \nprotected boolean unifyVar ( Variable leftVar , Term rightTerm , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( leftVar . isBound ( ) ) { \nreturn unifyInternal ( leftVar . getValue ( ) , rightTerm , leftTrail , rightTrail ) ; \n} \nelse { \nif ( rightTerm . isVar ( ) && ( ( Variable ) rightTerm ) . isBound ( ) ) { \nreturn unifyInternal ( leftVar , rightTerm . getValue ( ) , leftTrail , rightTrail ) ; \n} \nelse { \nleftVar . setSubstitution ( rightTerm ) ; \nleftTrail . add ( leftVar . getStorageCell ( leftVar ) ) ; \nreturn true ; \n} \n} \n} \n} \n"}
{"10236": "public class LojixTermReader { \nprivate void read ( Term term ) { \nif ( term . isNumber ( ) ) { \nNumericType numericType = ( NumericType ) term ; \nif ( numericType . isInteger ( ) ) { \nIntLiteral jplInteger = ( IntLiteral ) term ; \ngetContentHandler ( ) . startIntegerTerm ( jplInteger . longValue ( ) ) ; \n} \nelse { \nif ( numericType . isFloat ( ) ) { \nFloatLiteral jplFloat = ( FloatLiteral ) term ; \ngetContentHandler ( ) . startFloatTerm ( jplFloat . doubleValue ( ) ) ; \n} \n} \n} \nelse { \nif ( term . isVar ( ) ) { \nVariable var = ( Variable ) term ; \ngetContentHandler ( ) . startVariable ( interner . getVariableName ( var . getName ( ) ) ) ; \n} \nelse { \nif ( term . isAtom ( ) ) { \nFunctor atom = ( Functor ) term ; \ngetContentHandler ( ) . startAtom ( interner . getFunctorName ( atom . getName ( ) ) ) ; \n} \nelse { \nif ( term . isCompound ( ) ) { \nFunctor functor = ( Functor ) term ; \ngetContentHandler ( ) . startCompound ( ) ; \ngetContentHandler ( ) . startAtom ( interner . getFunctorName ( functor . getName ( ) ) ) ; \nfor ( com . thesett . aima . logic . fol . Term child : functor . getArguments ( ) ) { \nread ( child ) ; \n} \ngetContentHandler ( ) . endCompound ( ) ; \n} \nelse { \nthrow new IllegalStateException ( \"Unrecognized Lojix term: \" + term ) ; \n} \n} \n} \n} \n} \n} \n"}
{"10254": "public class IntRangeType { \npublic static Type createInstance ( String name , int min , int max ) { \nif ( min > max ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( INT_RANGE_TYPES ) { \nIntRangeType newType = new IntRangeType ( name , min , max ) ; \nIntRangeType oldType = INT_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse { \nif ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nINT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n} \n"}
{"10264": "public class TraceIndenter { \npublic String generateTraceIndent ( int delta ) { \nif ( ! useIndent ) { \nreturn \"\" ; \n} \nelse { \nif ( delta >= 1 ) { \nindentStack . push ( delta ) ; \n} \nelse { \nif ( delta < 0 ) { \nindentStack . pop ( ) ; \n} \n} \nStringBuffer result = new StringBuffer ( ) ; \ntraceIndent += ( delta < 0 ) ? delta : 0 ; \nfor ( int i = 0 ; \ni < traceIndent ; \ni ++ ) { \nresult . append ( \" \" ) ; \n} \ntraceIndent += ( delta > 0 ) ? delta : 0 ; \nreturn result . toString ( ) ; \n} \n} \n} \n"}
{"10268": "public class ProtoDTLearningMethod { \nprivate boolean allHaveSameClassification ( String property , Iterable < State > examples ) { \nOrdinalAttribute firstAttribute = null ; \nboolean success = true ; \nfor ( State example : examples ) { \nOrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; \nif ( firstAttribute == null ) { \nfirstAttribute = nextAttribute ; \n} \nelse { \nif ( ! nextAttribute . equals ( firstAttribute ) ) { \nsuccess = false ; \nbreak ; \n} \n} \n} \nif ( success ) { \nallClassification = firstAttribute ; \n} \nreturn success ; \n} \n} \n"}
{"10276": "public class Surface { \nprotected BufferedImage createBufferedImage ( int w , int h , int imgType ) { \nBufferedImage bi = null ; \nif ( imgType == 0 ) { \nbi = ( BufferedImage ) createImage ( w , h ) ; \n} \nelse { \nif ( ( imgType > 0 ) && ( imgType < 14 ) ) { \nbi = new BufferedImage ( w , h , imgType ) ; \n} \nelse { \nif ( imgType == 14 ) { \nbi = createBinaryImage ( w , h , 2 ) ; \n} \nelse { \nif ( imgType == 15 ) { \nbi = createBinaryImage ( w , h , 4 ) ; \n} \nelse { \nif ( imgType == 16 ) { \nbi = createSGISurface ( w , h , 32 ) ; \n} \nelse { \nif ( imgType == 17 ) { \nbi = createSGISurface ( w , h , 16 ) ; \n} \n} \n} \n} \n} \n} \nbiw = w ; \nbih = h ; \nreturn bi ; \n} \n} \n"}
{"10303": "public class TimeUtils { \npublic static int ticksToYears ( long ticks ) { \nlong unitMillis = MILLIS_PER_YEAR / 2 ; \nlong i2 = ( ticks >> 1 ) + ( ( 1970L * MILLIS_PER_YEAR ) / 2 ) ; \nif ( i2 < 0 ) { \ni2 = i2 - unitMillis + 1 ; \n} \nint year = ( int ) ( i2 / unitMillis ) ; \nlong yearStart = millisToYearStart ( year ) ; \nlong diff = ticks - yearStart ; \nif ( diff < 0 ) { \nyear -- ; \n} \nelse { \nif ( diff >= ( MILLIS_PER_DAY * 365L ) ) { \nlong oneYear ; \nif ( isLeapYear ( year ) ) { \noneYear = MILLIS_PER_DAY * 366L ; \n} \nelse { \noneYear = MILLIS_PER_DAY * 365L ; \n} \nyearStart += oneYear ; \nif ( yearStart <= ticks ) { \nyear ++ ; \n} \n} \n} \nreturn year ; \n} \n} \n"}
{"10317": "public class WorkPanel { \npublic void actionPerformed ( ActionEvent event ) { \nString action = event . getActionCommand ( ) ; \nif ( \"OK\" . equals ( action ) ) { \nif ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { \nsaveWork ( ) ; \n} \n} \nelse { \nif ( \"Cancel\" . equals ( action ) ) { \nif ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { \ndiscardWork ( ) ; \n} \n} \nelse { \nif ( \"Apply\" . equals ( action ) ) { \nif ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { \nsaveWork ( ) ; \n} \n} \n} \n} \n} \n} \n"}
{"10352": "public class WorkFlowButtonsPanel { \npublic void propertyChange ( PropertyChangeEvent event ) { \nObject source = event . getSource ( ) ; \nObject oldValue = event . getOldValue ( ) ; \nString propertyName = event . getPropertyName ( ) ; \nif ( source instanceof WorkFlowScreenState ) { \nWorkFlowScreenState wfsState = ( WorkFlowScreenState ) source ; \nupdateButtonsForScreen ( wfsState ) ; \n} \nif ( source instanceof WorkFlowState ) { \nWorkFlowState wfState = ( WorkFlowState ) source ; \nif ( \"currentScreenState\" . equals ( propertyName ) ) { \nWorkFlowScreenState newScreenState = wfState . getCurrentScreenState ( ) ; \nWorkFlowScreenState oldScreenState = ( WorkFlowScreenState ) oldValue ; \nif ( oldScreenState != null ) { \noldScreenState . removePropertyChangeListener ( this ) ; \n} \nif ( newScreenState != null ) { \nnewScreenState . addPropertyChangeListener ( this ) ; \n} \nupdateButtonsForScreen ( newScreenState ) ; \n} \nelse { \nif ( \"state\" . equals ( propertyName ) ) { \nupdateButtonsForWorkFlow ( wfState ) ; \n} \n} \n} \n} \n} \n"}
{"10363": "public class TimeRangeType { \npublic static Type createInstance ( String name , TimeOnly min , TimeOnly max ) { \nif ( ( min != null ) && ( max != null ) && ( min . compareTo ( max ) > 0 ) ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( INT_RANGE_TYPES ) { \nTimeRangeType newType = new TimeRangeType ( name , min , max ) ; \nTimeRangeType oldType = INT_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse { \nif ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nINT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n} \n"}
{"10364": "public class StringPatternType { \npublic static Type createInstance ( String name , int maxLength , String pattern ) { \nsynchronized ( STRING_PATTERN_TYPES ) { \nStringPatternType newType = new StringPatternType ( name , maxLength , pattern ) ; \nStringPatternType oldType = STRING_PATTERN_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse { \nif ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nSTRING_PATTERN_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n} \n"}
{"10391": "public class StringUtils { \npublic static String convertCase ( String value , String separator , boolean firstLetterUpper , boolean firstLetterOfWordUpper ) { \nfinal StringBuffer result = new StringBuffer ( ) ; \nboolean firstWord = true ; \nboolean firstLetter = true ; \nboolean upper = false ; \nWordMachineState state = WordMachineState . Initial ; \nFunction2 < Character , Boolean , StringBuffer > writeChar = new Function2 < Character , Boolean , StringBuffer > ( ) { \npublic StringBuffer apply ( Character nextChar , Boolean upper ) { \nif ( upper ) result . append ( Character . toUpperCase ( nextChar ) ) ; \nelse result . append ( Character . toLowerCase ( nextChar ) ) ; \nreturn result ; \n} \n} \n; \nfor ( int i = 0 ; \ni < value . length ( ) ; \ni ++ ) { \nchar nextChar = value . charAt ( i ) ; \nif ( Character . isUpperCase ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordCaps : state = WordMachineState . ContinueWordCaps ; \nupper = false ; \nbreak ; \ncase ContinueWordLower : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nresult . append ( separator ) ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse { \nif ( Character . isLetterOrDigit ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordLower : case ContinueWordCaps : state = WordMachineState . ContinueWordLower ; \nupper = false ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse { \nswitch ( state ) { \ncase Initial : state = WordMachineState . Initial ; \nbreak ; \ncase StartWord : case ContinueWordCaps : case ContinueWordLower : state = WordMachineState . Initial ; \nbreak ; \n} \nupper = false ; \n} \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"10407": "public class ProtoDTMachine { \npublic Map < String , OrdinalAttribute > classify ( State state ) throws ClassifyingFailureException { \nDecisionTree currentNode = dt ; \nwhile ( true ) { \nDecisionTreeElement element = currentNode . getElement ( ) ; \nif ( element instanceof Decision ) { \nDecision decision = ( Decision ) element ; \ncurrentNode = decision . decide ( state ) ; \n} \nelse { \nif ( element instanceof Assignment ) { \nAssignment assignment = ( Assignment ) element ; \nMap < String , OrdinalAttribute > assignmentMap = new HashMap < String , OrdinalAttribute > ( ) ; \nassignmentMap . put ( assignment . getPropertyName ( ) , assignment . getAttribute ( ) ) ; \nreturn assignmentMap ; \n} \nelse { \nthrow new ClassifyingFailureException ( \"A node which is not a decision was encountered.\" , null ) ; \n} \n} \n} \n} \n} \n"}
{"10411": "public class BitHackUtils { \npublic static int intLogBase2v2 ( int value ) { \nint temp ; \nif ( ( temp = value >> 24 ) > 0 ) { \nreturn 24 + LOG_TABLE_256 [ temp ] ; \n} \nelse { \nif ( ( temp = value >> 16 ) > 0 ) { \nreturn 16 + LOG_TABLE_256 [ temp ] ; \n} \nelse { \nif ( ( temp = value >> 8 ) > 0 ) { \nreturn 8 + LOG_TABLE_256 [ temp ] ; \n} \nelse { \nreturn LOG_TABLE_256 [ value ] ; \n} \n} \n} \n} \n} \n"}
{"10416": "public class BitHackUtils { \npublic static int getCharacterCountInt32 ( int value ) { \nif ( value >= 0 ) { \nreturn getCharacterCountUInt32 ( value ) ; \n} \nelse { \nif ( value == Integer . MIN_VALUE ) { \nreturn getCharacterCountUInt32 ( Integer . MAX_VALUE ) + 1 ; \n} \nelse { \nreturn getCharacterCountUInt32 ( - value ) + 1 ; \n} \n} \n} \n} \n"}
{"10417": "public class BitHackUtils { \npublic static int getCharacterCountInt64 ( long value ) { \nif ( value >= 0 ) { \nreturn getCharacterCountUInt64 ( value ) ; \n} \nelse { \nif ( value == Long . MIN_VALUE ) { \nreturn getCharacterCountUInt64 ( Long . MAX_VALUE ) + 1 ; \n} \nelse { \nreturn getCharacterCountUInt64 ( - value ) + 1 ; \n} \n} \n} \n} \n"}
{"10433": "public class BuiltInTransformVisitor { \nprotected void leaveFunctor ( Functor functor ) { \nint pos = traverser . getPosition ( ) ; \nif ( ! traverser . isInHead ( ) && ( pos >= 0 ) ) { \nFunctor transformed = builtInTransform . apply ( functor ) ; \nif ( functor != transformed ) { \nBuiltInFunctor builtInFunctor = ( BuiltInFunctor ) transformed ; \nTerm parentTerm = traverser . getParentContext ( ) . getTerm ( ) ; \nif ( parentTerm instanceof Clause ) { \nClause parentClause = ( Clause ) parentTerm ; \nparentClause . getBody ( ) [ pos ] = builtInFunctor ; \n} \nelse { \nif ( parentTerm instanceof Functor ) { \nFunctor parentFunctor = ( Functor ) parentTerm ; \nparentFunctor . getArguments ( ) [ pos ] = builtInFunctor ; \n} \n} \n} \n} \n} \n} \n"}
{"10470": "public class LockFreeNQueue { \npublic E poll ( ) { \nint currentLevel = 0 ; \nwhile ( true ) { \nMarker < E > h = null ; \nNode < E > first = null ; \nNode < E > second = null ; \nfor ( ; \ncurrentLevel < n ; \ncurrentLevel ++ ) { \nh = markers [ currentLevel ] ; \nfirst = h . getNext ( ) ; \nsecond = first . getNext ( ) ; \nif ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nbreak ; \n} \nelse { \nif ( currentLevel == ( n - 1 ) ) { \nreturn null ; \n} \n} \n} \nNode < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; \nif ( first == h . getNext ( ) ) { \nif ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nif ( first == null ) { \nreturn null ; \n} \nelse { \nmarkers [ currentLevel + 1 ] . casTail ( t , first ) ; \n} \n} \nelse { \nif ( h . casNext ( first , second ) ) { \nDataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; \nE item = firstDataNode . getItem ( ) ; \nif ( item != null ) { \nfirstDataNode . setItem ( null ) ; \ncount . decrementAndGet ( ) ; \nreturn item ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"10488": "public class DoubleRangeType { \npublic static Type createInstance ( String name , double min , double max ) { \nif ( min > max ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( DOUBLE_RANGE_TYPES ) { \nDoubleRangeType newType = new DoubleRangeType ( name , min , max ) ; \nDoubleRangeType oldType = DOUBLE_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse { \nif ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nDOUBLE_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n} \n"}
{"10498": "public class DateRangeType { \npublic static Type createInstance ( String name , DateOnly from , DateOnly to ) { \nif ( ( from != null ) && ( to != null ) && ( from . compareTo ( to ) > 0 ) ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( DATE_RANGE_TYPES ) { \nDateRangeType newType = new DateRangeType ( name , from , to ) ; \nDateRangeType oldType = DATE_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse { \nif ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nDATE_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n} \n"}
{"10511": "public class TypeConverter { \npublic static MultiTypeData getMultiTypeData ( String s ) { \nMultiTypeData result = new MultiTypeData ( ) ; \nresult . typeFlags = STRING ; \nresult . stringValue = s ; \nresult . nativeType = STRING ; \nif ( \"true\" . equals ( s ) ) { \nresult . booleanValue = true ; \nresult . typeFlags |= BOOLEAN ; \n} \nelse { \nif ( \"false\" . equals ( s ) ) { \nresult . booleanValue = false ; \nresult . typeFlags |= BOOLEAN ; \n} \n} \ntry { \nresult . intValue = Integer . parseInt ( s ) ; \nresult . typeFlags |= INT ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags &= ( Integer . MAX_VALUE - INT ) ; \n} \ntry { \nresult . byteValue = Byte . parseByte ( s ) ; \nresult . typeFlags |= BYTE ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags = ( Integer . MAX_VALUE - BYTE ) ; \n} \nif ( s . length ( ) == 1 ) { \nresult . charValue = s . charAt ( 0 ) ; \nresult . typeFlags |= CHAR ; \n} \ntry { \nresult . shortValue = Short . parseShort ( s ) ; \nresult . typeFlags |= SHORT ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags = ( Integer . MAX_VALUE - SHORT ) ; \n} \ntry { \nresult . longValue = Long . parseLong ( s ) ; \nresult . typeFlags |= LONG ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags = ( Integer . MAX_VALUE - LONG ) ; \n} \ntry { \nresult . floatValue = Float . parseFloat ( s ) ; \nresult . typeFlags |= FLOAT ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags = ( Integer . MAX_VALUE - FLOAT ) ; \n} \ntry { \nresult . doubleValue = Double . parseDouble ( s ) ; \nresult . typeFlags |= DOUBLE ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \nresult . typeFlags = ( Integer . MAX_VALUE - DOUBLE ) ; \n} \nreturn result ; \n} \n} \n"}
{"10513": "public class TypeConverter { \npublic static Object convert ( MultiTypeData d , Class c ) { \nif ( ( ( d . typeFlags & BOOLEAN ) != 0 ) && ( Boolean . TYPE . equals ( c ) || Boolean . class . equals ( c ) ) ) { \nreturn d . booleanValue ; \n} \nelse { \nif ( ( ( d . typeFlags & INT ) != 0 ) && ( Integer . TYPE . equals ( c ) || Integer . class . equals ( c ) ) ) { \nreturn d . intValue ; \n} \nelse { \nif ( ( ( d . typeFlags & CHAR ) != 0 ) && ( Character . TYPE . equals ( c ) || Character . class . equals ( c ) ) ) { \nreturn d . charValue ; \n} \nelse { \nif ( ( ( d . typeFlags & BYTE ) != 0 ) && ( Byte . TYPE . equals ( c ) || Byte . class . equals ( c ) ) ) { \nreturn d . byteValue ; \n} \nelse { \nif ( ( ( d . typeFlags & SHORT ) != 0 ) && ( Short . TYPE . equals ( c ) || Short . class . equals ( c ) ) ) { \nreturn d . shortValue ; \n} \nelse { \nif ( ( ( d . typeFlags & LONG ) != 0 ) && ( Long . TYPE . equals ( c ) || Long . class . equals ( c ) ) ) { \nreturn d . longValue ; \n} \nelse { \nif ( ( ( d . typeFlags & FLOAT ) != 0 ) && ( Float . TYPE . equals ( c ) || Float . class . equals ( c ) ) ) { \nreturn d . floatValue ; \n} \nelse { \nif ( ( ( d . typeFlags & DOUBLE ) != 0 ) && ( Double . TYPE . equals ( c ) || Double . class . equals ( c ) ) ) { \nreturn d . doubleValue ; \n} \nelse { \nif ( ( ( d . typeFlags & STRING ) != 0 ) && String . class . equals ( c ) ) { \nreturn d . stringValue ; \n} \nelse { \nif ( ( ( d . typeFlags & OBJECT ) != 0 ) && d . objectValue . getClass ( ) . equals ( c ) ) { \nreturn d . objectValue ; \n} \nelse { \nthrow new ClassCastException ( \"The multi data type, \" + d + \", cannot be converted to the class, \" + c + \".\" ) ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"10536": "public class PTStemmer { \nprotected synchronized ptstemmer . Stemmer getActualStemmer ( ) throws PTStemmerException { \nif ( m_ActualStemmer == null ) { \nif ( m_Stemmer == STEMMER_ORENGO ) m_ActualStemmer = new OrengoStemmer ( ) ; \nelse { \nif ( m_Stemmer == STEMMER_PORTER ) m_ActualStemmer = new PorterStemmer ( ) ; \nelse { \nif ( m_Stemmer == STEMMER_SAVOY ) m_ActualStemmer = new SavoyStemmer ( ) ; \nelse throw new IllegalStateException ( \"Unhandled stemmer type: \" + m_Stemmer ) ; \n} \n} \nif ( ! m_NamedEntities . isDirectory ( ) ) m_ActualStemmer . ignore ( PTStemmerUtilities . fileToSet ( m_NamedEntities . getAbsolutePath ( ) ) ) ; \nif ( ! m_Stopwords . isDirectory ( ) ) m_ActualStemmer . ignore ( PTStemmerUtilities . fileToSet ( m_Stopwords . getAbsolutePath ( ) ) ) ; \nif ( m_Cache > 0 ) m_ActualStemmer . enableCaching ( m_Cache ) ; \nelse m_ActualStemmer . disableCaching ( ) ; \n} \nreturn m_ActualStemmer ; \n} \n} \n"}
{"10539": "public class FloatRangeType { \npublic static Type createInstance ( String name , float min , float max ) { \nif ( min > max ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( FLOAT_RANGE_TYPES ) { \nFloatRangeType newType = new FloatRangeType ( name , min , max ) ; \nFloatRangeType oldType = FLOAT_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse { \nif ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nFLOAT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n} \n"}
{"10544": "public class WAMResolvingJavaMachine { \nprivate int nextStackFrame ( ) { \nif ( ep == bp ) { \nreturn STACK_BASE ; \n} \nelse { \nif ( ep > bp ) { \nreturn ep + data . get ( ep + 2 ) + 3 ; \n} \nelse { \nreturn bp + data . get ( bp ) + 8 ; \n} \n} \n} \n} \n"}
{"10549": "public class WAMResolvingJavaMachine { \nprivate boolean unify ( int a1 , int a2 ) { \nuPush ( a1 ) ; \nuPush ( a2 ) ; \nboolean fail = false ; \nwhile ( ! uEmpty ( ) && ! fail ) { \nint d1 = deref ( uPop ( ) ) ; \nint t1 = derefTag ; \nint v1 = derefVal ; \nint d2 = deref ( uPop ( ) ) ; \nint t2 = derefTag ; \nint v2 = derefVal ; \nif ( d1 != d2 ) { \nif ( ( t1 == WAMInstruction . REF ) ) { \nbind ( d1 , d2 ) ; \n} \nelse { \nif ( t2 == WAMInstruction . REF ) { \nbind ( d1 , d2 ) ; \n} \nelse { \nif ( t2 == WAMInstruction . STR ) { \nint fn1 = data . get ( v1 ) ; \nint fn2 = data . get ( v2 ) ; \nbyte n1 = ( byte ) ( fn1 >>> 24 ) ; \nif ( fn1 == fn2 ) { \nfor ( int i = 1 ; \ni <= n1 ; \ni ++ ) { \nuPush ( v1 + i ) ; \nuPush ( v2 + i ) ; \n} \n} \nelse { \nfail = true ; \n} \n} \nelse { \nif ( t2 == WAMInstruction . CON ) { \nif ( ( t1 != WAMInstruction . CON ) || ( v1 != v2 ) ) { \nfail = true ; \n} \n} \nelse { \nif ( t2 == WAMInstruction . LIS ) { \nif ( t1 != WAMInstruction . LIS ) { \nfail = true ; \n} \nelse { \nuPush ( v1 ) ; \nuPush ( v2 ) ; \nuPush ( v1 + 1 ) ; \nuPush ( v2 + 1 ) ; \n} \n} \n} \n} \n} \n} \n} \n} \nreturn ! fail ; \n} \n} \n"}
{"10558": "public class EightPuzzleState { \nprotected boolean swapTiles ( int x1 , int y1 , int x2 , int y2 ) { \nboolean swappedEmpty = false ; \nchar tile1 = board [ y1 ] [ x1 ] ; \nchar tile2 = board [ y2 ] [ x2 ] ; \nboard [ y1 ] [ x1 ] = tile2 ; \nboard [ y2 ] [ x2 ] = tile1 ; \nif ( tile1 == 'E' ) { \nemptyX = x2 ; \nemptyY = y2 ; \nswappedEmpty = true ; \n} \nelse { \nif ( tile2 == 'E' ) { \nemptyX = x1 ; \nemptyY = y1 ; \nswappedEmpty = true ; \n} \n} \nreturn ! swappedEmpty ; \n} \n} \n"}
{"10562": "public class LoggingToLog4JHandler { \nprivate org . apache . log4j . Level toLog4j ( Level level ) { \nif ( Level . SEVERE == level ) { \nreturn org . apache . log4j . Level . ERROR ; \n} \nelse { \nif ( Level . WARNING == level ) { \nreturn org . apache . log4j . Level . WARN ; \n} \nelse { \nif ( Level . INFO == level ) { \nreturn org . apache . log4j . Level . INFO ; \n} \nelse { \nif ( Level . FINE == level ) { \nreturn org . apache . log4j . Level . DEBUG ; \n} \nelse { \nif ( Level . FINER == level ) { \nreturn org . apache . log4j . Level . TRACE ; \n} \nelse { \nif ( Level . OFF == level ) { \nreturn org . apache . log4j . Level . OFF ; \n} \n} \n} \n} \n} \n} \nreturn org . apache . log4j . Level . OFF ; \n} \n} \n"}
{"10565": "public class WrapperQueue { \nprivate void incrementSizeAndCount ( E record ) { \nif ( atomicallyCounted ) { \ncount . incrementAndGet ( ) ; \n} \nif ( sizeable && ( record instanceof Sizeable ) ) { \ndataSize . addAndGet ( ( ( Sizeable ) record ) . sizeof ( ) ) ; \n} \nelse { \nif ( sizeable ) { \ndataSize . incrementAndGet ( ) ; \n} \n} \n} \n} \n"}
{"10566": "public class WrapperQueue { \nprivate void decrementSizeAndCount ( E record ) { \nif ( atomicallyCounted ) { \ncount . decrementAndGet ( ) ; \n} \nif ( sizeable && ( record instanceof Sizeable ) ) { \nlong recordSize = - ( ( Sizeable ) record ) . sizeof ( ) ; \nlong oldSize = dataSize . getAndAdd ( recordSize ) ; \nlong newSize = oldSize + recordSize ; \nsignalOnSizeThresholdCrossing ( oldSize , newSize ) ; \n} \nelse { \nif ( sizeable ) { \nlong oldSize = dataSize . getAndDecrement ( ) ; \nlong newSize = oldSize - 1 ; \nsignalOnSizeThresholdCrossing ( oldSize , newSize ) ; \n} \n} \n} \n} \n"}
{"10567": "public class WrapperQueue { \nprivate void signalOnSizeThresholdCrossing ( long oldSize , long newSize ) { \nif ( signalable != null ) { \nif ( ( oldSize >= lowWaterSizeThreshold ) && ( newSize < lowWaterSizeThreshold ) ) { \nsignalable . signalAll ( ) ; \n} \nelse { \nif ( ( oldSize >= highWaterSizeThreshold ) && ( newSize < highWaterSizeThreshold ) ) { \nsignalable . signal ( ) ; \n} \n} \n} \n} \n} \n"}
{"10576": "public class TextTableImpl { \npublic void setMaxRowHeight ( int row , int height ) { \nInteger previousValue = maxRowSizes . get ( row ) ; \nif ( previousValue == null ) { \nmaxRowSizes . put ( row , height ) ; \n} \nelse { \nif ( previousValue < height ) { \nmaxRowSizes . put ( row , height ) ; \n} \n} \n} \n} \n"}
{"10577": "public class TextTableImpl { \nprivate void updateMaxColumnWidth ( int column , int width ) { \nInteger previousValue = maxColumnSizes . get ( column ) ; \nif ( previousValue == null ) { \nmaxColumnSizes . put ( column , width ) ; \n} \nelse { \nif ( previousValue < width ) { \nmaxColumnSizes . put ( column , width ) ; \n} \n} \n} \n} \n"}
{"10599": "public class BeanMemento { \npublic static void restoreValues ( Object ob , Map < String , Object > values ) throws NoSuchFieldException { \nClass obClass = ob . getClass ( ) ; \nfor ( String propName : values . keySet ( ) ) { \nObject nextValue = values . get ( propName ) ; \nObject paramValue ; \nClass paramType ; \nif ( nextValue == null ) { \nparamValue = null ; \nparamType = null ; \n} \nelse { \nif ( nextValue instanceof TypeConverter . MultiTypeData ) { \nTypeConverter . MultiTypeData multiValue = ( TypeConverter . MultiTypeData ) nextValue ; \nSet < Class > setterTypes = ReflectionUtils . findMatchingSetters ( ob . getClass ( ) , propName ) ; \nparamType = TypeConverter . bestMatchingConversion ( multiValue , setterTypes ) ; \nparamValue = TypeConverter . convert ( multiValue , paramType ) ; \n} \nelse { \nparamValue = nextValue ; \nparamType = nextValue . getClass ( ) ; \n} \n} \nMethod setterMethod ; \ntry { \nString upperPropertyName = Character . toUpperCase ( propName . charAt ( 0 ) ) + propName . substring ( 1 ) ; \nsetterMethod = obClass . getMethod ( \"set\" + upperPropertyName , paramType ) ; \nObject [ ] params = new Object [ ] { \nparamValue } \n; \nsetterMethod . invoke ( ob , params ) ; \n} \ncatch ( NoSuchMethodException e ) { \n} \ncatch ( IllegalAccessException e ) { \n} \ncatch ( InvocationTargetException e ) { \n} \n} \n} \n} \n"}
{"10619": "public class Functor { \npublic Iterator < Operator < Term > > getChildren ( boolean reverse ) { \nif ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) { \nreturn ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; \n} \nelse { \nif ( arguments == null ) { \nreturn new LinkedList < Operator < Term > > ( ) . iterator ( ) ; \n} \nelse { \nif ( ! reverse ) { \nreturn Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; \n} \nelse { \nList < Operator < Term > > argList = new LinkedList < Operator < Term > > ( ) ; \nfor ( int i = arity - 1 ; \ni >= 0 ; \ni -- ) { \nargList . add ( arguments [ i ] ) ; \n} \nreturn argList . iterator ( ) ; \n} \n} \n} \n} \n} \n"}
{"10625": "public class JavaType { \nprivate void setBasicType ( Class c ) { \nif ( Boolean . class . equals ( c ) ) { \ntype = BasicTypes . BOOLEAN ; \n} \nelse { \nif ( Character . class . equals ( c ) ) { \ntype = BasicTypes . CHARACTER ; \n} \nelse { \nif ( Byte . class . equals ( c ) ) { \ntype = BasicTypes . BYTE ; \n} \nelse { \nif ( Short . class . equals ( c ) ) { \ntype = BasicTypes . SHORT ; \n} \nelse { \nif ( Integer . class . equals ( c ) ) { \ntype = BasicTypes . INTEGER ; \n} \nelse { \nif ( Long . class . equals ( c ) ) { \ntype = BasicTypes . LONG ; \n} \nelse { \nif ( Float . class . equals ( c ) ) { \ntype = BasicTypes . FLOAT ; \n} \nelse { \nif ( Double . class . equals ( c ) ) { \ntype = BasicTypes . DOUBLE ; \n} \nelse { \ntype = BasicTypes . OTHER ; \n} \n} \n} \n} \n} \n} \n} \n} \n} \n} \n"}
{"10630": "public class SocketReadThread { \nprivate void readStream ( ) throws Exception { \nwhile ( ! shutdown ) { \nElement doc = reader . parseDocument ( ) . getRootElement ( ) ; \nif ( doc == null ) { \nreturn ; \n} \nPacket packet ; \nString tag = doc . getName ( ) ; \nif ( \"message\" . equals ( tag ) ) { \npacket = new Message ( doc ) ; \n} \nelse { \nif ( \"presence\" . equals ( tag ) ) { \npacket = new Presence ( doc ) ; \n} \nelse { \nif ( \"iq\" . equals ( tag ) ) { \npacket = getIQ ( doc ) ; \n} \nelse { \nthrow new XmlPullParserException ( \"Unknown packet type was read: \" + tag ) ; \n} \n} \n} \ncomponent . processPacket ( packet ) ; \n} \n} \n} \n"}
{"10635": "public class Player { \n@ Override public void renderFinalOutput ( List < T > data , EventModel eventModel ) { \nif ( StartMusicRequest . verify ( eventModel , capabilities , this , activators ) ) { \nif ( isOutputRunning ( ) ) { \nplayerError ( PlayerError . ERROR_ALREADY_PLAYING , eventModel . getSource ( ) ) ; \n} \nelse { \nhandleEventRequest ( eventModel ) ; \n} \n} \nelse { \nif ( eventModel . getListResourceContainer ( ) . providesResource ( Collections . singletonList ( MusicUsageResource . ID ) ) ) { \nif ( isOutputRunning ( ) ) { \neventModel . getListResourceContainer ( ) . provideResource ( MusicUsageResource . ID ) . forEach ( resourceModel -> playerError ( PlayerError . ERROR_ALREADY_PLAYING , resourceModel . getProvider ( ) ) ) ; \n} \nelse { \nhandleResourceRequest ( eventModel ) ; \n} \n} \nelse { \nhandleCommands ( eventModel ) ; \n} \n} \n} \n} \n"}
{"10640": "public class PacketReader { \nsynchronized public void startup ( ) throws XMPPException { \nfinal List < Exception > errors = new LinkedList < Exception > ( ) ; \nAbstractConnectionListener connectionErrorListener = new AbstractConnectionListener ( ) { \n@ Override public void connectionClosedOnError ( Exception e ) { \nerrors . add ( e ) ; \n} \n} \n; \nconnection . addConnectionListener ( connectionErrorListener ) ; \nreaderThread . start ( ) ; \ntry { \nint waitTime = SmackConfiguration . getPacketReplyTimeout ( ) ; \nwait ( 3 * waitTime ) ; \n} \ncatch ( InterruptedException ie ) { \n} \nconnection . removeConnectionListener ( connectionErrorListener ) ; \nif ( connectionID == null ) { \nthrow new XMPPException ( \"Connection failed. No response from server.\" ) ; \n} \nelse { \nif ( ! errors . isEmpty ( ) ) { \nthrow new XMPPException ( errors . iterator ( ) . next ( ) ) ; \n} \nelse { \nconnection . connectionID = connectionID ; \n} \n} \n} \n} \n"}
{"10649": "public class InternalContent { \npublic void setProperty ( String key , Object value ) { \nif ( readOnly ) { \nreturn ; \n} \nif ( value == null ) { \nthrow new IllegalArgumentException ( \"value must not be null\" ) ; \n} \nObject o = content . get ( key ) ; \nif ( ! value . equals ( o ) ) { \nupdatedContent . put ( key , value ) ; \nupdated = true ; \n} \nelse { \nif ( updatedContent . containsKey ( key ) && ! value . equals ( updatedContent . get ( key ) ) ) { \nupdatedContent . put ( key , value ) ; \nupdated = true ; \n} \n} \n} \n} \n"}
{"10691": "public class StorageClientUtils { \n@ SuppressWarnings ( \"unchecked\" ) public static < K , V > Map < K , V > getFilterMap ( Map < K , V > source , Map < K , V > modified , Set < K > include , Set < K > exclude , boolean includingRemoveProperties ) { \nif ( ( modified == null || modified . size ( ) == 0 ) && ( include == null ) && ( exclude == null || exclude . size ( ) == 0 ) ) { \nif ( source instanceof ImmutableMap ) { \nreturn source ; \n} \nelse { \nreturn ImmutableMap . copyOf ( source ) ; \n} \n} \nBuilder < K , V > filteredMap = new ImmutableMap . Builder < K , V > ( ) ; \nfor ( Entry < K , V > e : source . entrySet ( ) ) { \nK k = e . getKey ( ) ; \nif ( include == null || include . contains ( k ) ) { \nif ( exclude == null || ! exclude . contains ( k ) ) { \nif ( modified != null && modified . containsKey ( k ) ) { \nV o = modified . get ( k ) ; \nif ( o instanceof Map ) { \nfilteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) o , null , null , exclude , includingRemoveProperties ) ) ; \n} \nelse { \nif ( includingRemoveProperties ) { \nfilteredMap . put ( k , o ) ; \n} \nelse { \nif ( ! ( o instanceof RemoveProperty ) ) { \nfilteredMap . put ( k , o ) ; \n} \n} \n} \n} \nelse { \nObject o = e . getValue ( ) ; \nif ( o instanceof Map ) { \nfilteredMap . put ( k , ( V ) getFilterMap ( ( Map < K , V > ) e . getValue ( ) , null , null , exclude , includingRemoveProperties ) ) ; \n} \nelse { \nfilteredMap . put ( k , e . getValue ( ) ) ; \n} \n} \n} \n} \n} \nif ( modified != null ) { \nfor ( Entry < K , V > e : modified . entrySet ( ) ) { \nK k = e . getKey ( ) ; \nif ( ! source . containsKey ( k ) ) { \nV v = e . getValue ( ) ; \nif ( ! ( v instanceof RemoveProperty ) && v != null ) { \nfilteredMap . put ( k , v ) ; \n} \n} \n} \n} \nreturn filteredMap . build ( ) ; \n} \n} \n"}
{"10762": "public class JSONResult { \npublic JSONResult get ( int index ) { \nif ( value instanceof JSONArray ) { \nJSONArray array = ( JSONArray ) value ; \nObject result = array . get ( index ) ; \nreturn new JSONResult ( result ) ; \n} \nelse { \nif ( value instanceof JSONObject ) { \nreturn get ( String . valueOf ( index ) ) ; \n} \n} \nreturn new JSONResult ( null ) ; \n} \n} \n"}
{"10763": "public class JSONResult { \npublic JSONResult get ( String key ) { \nif ( value instanceof JSONObject ) { \nJSONObject obj = ( JSONObject ) value ; \nObject result = obj . get ( key ) ; \nreturn new JSONResult ( result ) ; \n} \nelse { \nif ( value instanceof JSONArray ) { \ntry { \nint index = Integer . parseInt ( key ) ; \nreturn get ( index ) ; \n} \ncatch ( NumberFormatException e ) { \nthrow createException ( \"Excpected JSONObject \" + key + \":\" ) ; \n} \n} \n} \nreturn new JSONResult ( null ) ; \n} \n} \n"}
{"10773": "public class CF { \npublic Set < Class < ? > > getSubclasses ( String fqcn ) { \nif ( fqcn == null ) { \nreturn new HashSet < Class < ? > > ( ) ; \n} \nelse { \nif ( StringUtils . startsWith ( fqcn , \".\" ) || StringUtils . endsWith ( fqcn , \".\" ) ) { \nreturn new HashSet < Class < ? > > ( ) ; \n} \n} \nClass < ? > clazz = null ; \ntry { \nclazz = Class . forName ( fqcn ) ; \n} \ncatch ( ClassNotFoundException ex ) { \nthis . clear ( ) ; \nthis . errors . add ( ex ) ; \nreturn new HashSet < Class < ? > > ( ) ; \n} \nreturn getSubclasses ( clazz ) ; \n} \n} \n"}
{"10794": "public class UserRoster { \npublic void createEntry ( String user , String name , String [ ] groups ) throws XMPPException { \nif ( ! connection . isAuthenticated ( ) ) { \nthrow new IllegalStateException ( \"Not logged in to server.\" ) ; \n} \nif ( connection . isAnonymous ( ) ) { \nthrow new IllegalStateException ( \"Anonymous users can't have a roster.\" ) ; \n} \nRoster rosterPacket = new Roster ( ) ; \nrosterPacket . setType ( IQ . Type . set ) ; \nrosterPacket . addItem ( new JID ( user ) , name , null , null , Arrays . asList ( groups ) ) ; \nPacketCollector collector = connection . createPacketCollector ( new PacketIDFilter ( rosterPacket . getID ( ) ) ) ; \nconnection . sendPacket ( rosterPacket ) ; \nIQ response = ( IQ ) collector . nextResult ( SmackConfiguration . getPacketReplyTimeout ( ) ) ; \ncollector . cancel ( ) ; \nif ( response == null ) { \nthrow new XMPPException ( \"No response from the server.\" ) ; \n} \nelse { \nif ( response . getType ( ) == IQ . Type . error ) { \nthrow new XMPPException ( response . getError ( ) ) ; \n} \n} \nPresence presencePacket = new Presence ( Presence . Type . subscribe ) ; \npresencePacket . setTo ( user ) ; \nconnection . sendPacket ( presencePacket ) ; \n} \n} \n"}
{"10809": "public class PacketParserUtils { \npublic static PacketExtension parsePacketExtension ( String elementName , String namespace , XmlPullParser parser ) throws Exception { \nDefaultPacketExtension extension = new DefaultPacketExtension ( elementName , namespace ) ; \nboolean done = false ; \nwhile ( ! done ) { \nint eventType = parser . next ( ) ; \nif ( eventType == XmlPullParser . START_TAG ) { \nString name = parser . getName ( ) ; \nif ( parser . isEmptyElementTag ( ) ) { \nextension . setValue ( name , \"\" ) ; \n} \nelse { \neventType = parser . next ( ) ; \nif ( eventType == XmlPullParser . TEXT ) { \nString value = parser . getText ( ) ; \nextension . setValue ( name , value ) ; \n} \n} \n} \nelse { \nif ( eventType == XmlPullParser . END_TAG ) { \nif ( parser . getName ( ) . equals ( elementName ) ) { \ndone = true ; \n} \n} \n} \n} \nreturn extension ; \n} \n} \n"}
{"10822": "public class PresenceConstant { \n@ Override public boolean controlEvents ( EventModel eventModel ) { \nif ( level . compareTo ( PresenceIndicatorLevel . WEAK ) >= 0 ) { \nreturn present ; \n} \nelse { \nif ( level . compareTo ( PresenceIndicatorLevel . WEAK ) < 0 && mostVague . get ( ) ) { \nreturn present ; \n} \nelse { \nreturn true ; \n} \n} \n} \n} \n"}
{"10844": "public class RequestUtils { \npublic static Object toValue ( String name , Object value ) { \nString [ ] parts = StringUtils . split ( name , \"@\" , 2 ) ; \nString fieldName = null ; \nString fieldType = \"String\" ; \nif ( parts . length == 2 ) { \nfieldType = parts [ 1 ] ; \nfieldName = parts [ 0 ] ; \n} \nelse { \nif ( parts . length == 1 ) { \nfieldName = parts [ 0 ] ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Invalid property name\" ) ; \n} \n} \ntry { \nint l = Array . getLength ( value ) ; \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nif ( ! fieldName . endsWith ( \"[]\" ) && l == 1 ) { \nreturn rpt . newInstance ( Array . get ( value , 0 ) ) ; \n} \nClass < ? > componentType = rpt . getComponentType ( ) ; \nObject [ ] a = ( Object [ ] ) Array . newInstance ( componentType , l ) ; \nfor ( int i = 0 ; \ni < l ; \ni ++ ) { \na [ i ] = rpt . newInstance ( Array . get ( value , i ) ) ; \n} \nreturn a ; \n} \ncatch ( IllegalArgumentException e ) { \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nreturn rpt . newInstance ( value ) ; \n} \n} \n} \n"}
{"10855": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > nextGreater ( final Node < K , V > node , final int index ) { \nNode < K , V > rval ; \nif ( node == null ) { \nrval = null ; \n} \nelse { \nif ( node . getRight ( index ) != null ) { \nrval = leastNode ( node . getRight ( index ) , index ) ; \n} \nelse { \nNode < K , V > parent = node . getParent ( index ) ; \nNode < K , V > child = node ; \nwhile ( ( parent != null ) && ( child == parent . getRight ( index ) ) ) { \nchild = parent ; \nparent = parent . getParent ( index ) ; \n} \nrval = parent ; \n} \n} \nreturn rval ; \n} \n} \n"}
{"10865": "public class TransactionalBidiTreeMap { \nprivate void rotateLeft ( final Node < K , V > node , final int index ) { \nNode < K , V > rightChild = node . getRight ( index ) ; \nnode . setRight ( rightChild . getLeft ( index ) , index ) ; \nif ( rightChild . getLeft ( index ) != null ) { \nrightChild . getLeft ( index ) . setParent ( node , index ) ; \n} \nrightChild . setParent ( node . getParent ( index ) , index ) ; \nif ( node . getParent ( index ) == null ) { \nrootNode [ index ] = rightChild ; \n} \nelse { \nif ( node . getParent ( index ) . getLeft ( index ) == node ) { \nnode . getParent ( index ) . setLeft ( rightChild , index ) ; \n} \nelse { \nnode . getParent ( index ) . setRight ( rightChild , index ) ; \n} \n} \nrightChild . setLeft ( node , index ) ; \nnode . setParent ( rightChild , index ) ; \n} \n} \n"}
{"10866": "public class TransactionalBidiTreeMap { \nprivate void rotateRight ( final Node < K , V > node , final int index ) { \nNode < K , V > leftChild = node . getLeft ( index ) ; \nnode . setLeft ( leftChild . getRight ( index ) , index ) ; \nif ( leftChild . getRight ( index ) != null ) { \nleftChild . getRight ( index ) . setParent ( node , index ) ; \n} \nleftChild . setParent ( node . getParent ( index ) , index ) ; \nif ( node . getParent ( index ) == null ) { \nrootNode [ index ] = leftChild ; \n} \nelse { \nif ( node . getParent ( index ) . getRight ( index ) == node ) { \nnode . getParent ( index ) . setRight ( leftChild , index ) ; \n} \nelse { \nnode . getParent ( index ) . setLeft ( leftChild , index ) ; \n} \n} \nleftChild . setRight ( node , index ) ; \nnode . setParent ( leftChild , index ) ; \n} \n} \n"}
{"10868": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackDelete ( final Node < K , V > deletedNode ) { \nfor ( int index = FIRST_INDEX ; \nindex < NUMBER_OF_INDICES ; \nindex ++ ) { \nif ( ( deletedNode . getLeft ( index ) != null ) && ( deletedNode . getRight ( index ) != null ) ) { \nswapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; \n} \nNode < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; \nif ( replacement != null ) { \nreplacement . setParent ( deletedNode . getParent ( index ) , index ) ; \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = replacement ; \n} \nelse { \nif ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( replacement , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( replacement , index ) ; \n} \n} \ndeletedNode . setLeft ( null , index ) ; \ndeletedNode . setRight ( null , index ) ; \ndeletedNode . setParent ( null , index ) ; \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( replacement , index ) ; \n} \n} \nelse { \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = null ; \n} \nelse { \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( deletedNode , index ) ; \n} \nif ( deletedNode . getParent ( index ) != null ) { \nif ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( null , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( null , index ) ; \n} \ndeletedNode . setParent ( null , index ) ; \n} \n} \n} \n} \nshrink ( ) ; \n} \n} \n"}
{"10870": "public class TransactionalBidiTreeMap { \nprivate void insertValue ( final Node < K , V > newNode , final String thread_id ) throws IllegalArgumentException { \nNode < K , V > node = rootNode [ VALUE ] ; \nwhile ( true ) { \nint cmp = compare ( Node . ADDED , newNode . getData ( VALUE ) , node . getStatus ( ) , node . getData ( VALUE ) , VALUE ) ; \nif ( cmp == 0 ) { \nif ( nextEqualValid ( getFloorEqualNode ( node , VALUE ) , VALUE , thread_id ) != null ) { \nString debug_message = \"Cannot store a duplicate value (\\\"\" + newNode . getData ( VALUE ) + \"\\\") in this Map. Value already exists for key \" + node . getKey ( ) ; \nlog . debug ( debug_message ) ; \nthrow new IllegalArgumentException ( debug_message ) ; \n} \nif ( node . is ( Node . ADDED , null ) ) throw new ConcurrentModificationException ( ) ; \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse { \nif ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \n} \nelse { \nif ( cmp < 0 ) { \nif ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setLeft ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse { \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \n} \n} \n} \n} \n"}
{"10891": "public class ExecS { \nprotected int executeApplication ( Object svc , String [ ] args , String orig ) { \nif ( svc != null && ( svc instanceof ExecS_Application ) ) { \nif ( svc instanceof Gen_RunScripts ) { \n( ( Gen_RunScripts ) svc ) . setClassMap ( this . classmap ) ; \n} \nif ( svc instanceof Gen_ExecJarScripts ) { \n( ( Gen_ExecJarScripts ) svc ) . setClassMap ( this . classmap ) ; \n} \nreturn ( ( ExecS_Application ) svc ) . executeApplication ( ArrayUtils . remove ( args , 0 ) ) ; \n} \nelse { \nif ( svc == null ) { \nSystem . err . println ( \"could not create object for class or application name <\" + orig + \">\" ) ; \nreturn - 1 ; \n} \nelse { \nif ( ! ( svc instanceof ExecS_Application ) ) { \nSystem . err . println ( \"given class or application name <\" + orig + \"> is not instance of \" + ExecS_Application . class . getName ( ) ) ; \nreturn - 2 ; \n} \nelse { \nSystem . err . println ( \"unexpected error processing for class or application name <\" + orig + \">\" ) ; \nreturn - 3 ; \n} \n} \n} \n} \n} \n"}
{"10925": "public class StringUtils { \npublic static final String escapeForXML ( String string ) { \nif ( string == null ) { \nreturn null ; \n} \nchar ch ; \nint i = 0 ; \nint last = 0 ; \nchar [ ] input = string . toCharArray ( ) ; \nint len = input . length ; \nStringBuffer out = new StringBuffer ( ( int ) ( len * 1.3 ) ) ; \nfor ( ; \ni < len ; \ni ++ ) { \nch = input [ i ] ; \nif ( ch > '>' ) { \ncontinue ; \n} \nelse { \nif ( ch == '<' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( LT_ENCODE ) ; \n} \nelse { \nif ( ch == '>' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( GT_ENCODE ) ; \n} \nelse { \nif ( ch == '&' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nif ( ! ( len > i + 5 && input [ i + 1 ] == '#' && Character . isDigit ( input [ i + 2 ] ) && Character . isDigit ( input [ i + 3 ] ) && Character . isDigit ( input [ i + 4 ] ) && input [ i + 5 ] == ';' ) ) { \nlast = i + 1 ; \nout . append ( AMP_ENCODE ) ; \n} \n} \nelse { \nif ( ch == '\"' ) { \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( QUOTE_ENCODE ) ; \n} \n} \n} \n} \n} \n} \nif ( last == 0 ) { \nreturn string ; \n} \nif ( i > last ) { \nout . append ( input , last , i - last ) ; \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"10931": "public class Authorizable { \npublic void setProperty ( String name , Object value ) { \nif ( ! readOnly && ! FILTER_PROPERTIES . contains ( name ) ) { \nObject cv = authorizableMap . get ( name ) ; \nif ( value == null ) { \nif ( cv != null && ! ( cv instanceof RemoveProperty ) ) { \nmodifiedMap . put ( name , new RemoveProperty ( ) ) ; \n} \n} \nelse { \nif ( ! value . equals ( cv ) ) { \nmodifiedMap . put ( name , value ) ; \n} \nelse { \nif ( modifiedMap . containsKey ( name ) && ! value . equals ( modifiedMap . get ( name ) ) ) { \nmodifiedMap . put ( name , value ) ; \n} \n} \n} \n} \n} \n} \n"}
{"10937": "public class PresenceNonConstant { \n@ Override public void eventFired ( EventModel event ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) || event . containsDescriptor ( PresenceEvent . ID ) ) { \nif ( event . containsDescriptor ( LeavingEvent . ID ) ) { \nif ( event . containsDescriptor ( LeavingEvent . GENERAL_DESCRIPTOR ) ) { \npresent = false ; \nstrictPresent = false ; \n} \nelse { \nif ( event . containsDescriptor ( LeavingEvent . STRICT_DESCRIPTOR ) ) { \nnonStrictAvailable ( ) . thenAccept ( available -> { \nif ( ! available ) present = false ; \nstrictPresent = false ; \n} \n) ; \n} \n} \n} \nelse { \npresent = true ; \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) strictPresent = true ; \n} \nif ( event . containsDescriptor ( PresenceEvent . STRICT_DESCRIPTOR ) ) lastSeen = LocalDateTime . now ( ) ; \n} \n} \n} \n"}
