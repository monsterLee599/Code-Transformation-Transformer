{"6": "public class FlowableScalarXMap { \n@ SuppressWarnings ( \"unchecked\" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { \nif ( source instanceof Callable ) { \nT t ; \ntry { \nt = ( ( Callable < T > ) source ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptySubscription . error ( ex , subscriber ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( t == null ) { \nEmptySubscription . complete ( subscriber ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nPublisher < ? extends R > r ; \ntry { \nr = ObjectHelper . requireNonNull ( mapper . apply ( t ) , \"The mapper returned a null Publisher\" ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptySubscription . error ( ex , subscriber ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nif ( r instanceof Callable ) { \nR u ; \ntry { \nu = ( ( Callable < R > ) r ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptySubscription . error ( ex , subscriber ) ; \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \nif ( u == null ) { \nEmptySubscription . complete ( subscriber ) ; \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \nsubscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; \n} \nelse { \nr . subscribe ( subscriber ) ; \n} \n{ \nboolean return_variable_5 = true ; \nreturn return_variable_5 ; \n} \n} \n{ \nboolean return_variable_6 = false ; \nreturn return_variable_6 ; \n} \n} \n} \n"}
{"23": "public class BlockingMultiObserver { \npublic boolean blockingAwait ( long timeout , TimeUnit unit ) { \nif ( getCount ( ) != 0 ) { \ntry { \nBlockingHelper . verifyNonBlocking ( ) ; \nif ( ! await ( timeout , unit ) ) { \ndispose ( ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \ncatch ( InterruptedException ex ) { \ndispose ( ) ; \nthrow ExceptionHelper . wrapOrThrow ( ex ) ; \n} \n} \nThrowable ex = error ; \nif ( ex != null ) { \nthrow ExceptionHelper . wrapOrThrow ( ex ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"30": "public class EndConsumerHelper { \npublic static boolean validate ( Disposable upstream , Disposable next , Class < ? > observer ) { \nObjectHelper . requireNonNull ( next , \"next is null\" ) ; \nif ( upstream != null ) { \nnext . dispose ( ) ; \nif ( upstream != DisposableHelper . DISPOSED ) { \nreportDoubleSubscription ( observer ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"31": "public class EndConsumerHelper { \npublic static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable next , Class < ? > observer ) { \nObjectHelper . requireNonNull ( next , \"next is null\" ) ; \nif ( ! upstream . compareAndSet ( null , next ) ) { \nnext . dispose ( ) ; \nif ( upstream . get ( ) != DisposableHelper . DISPOSED ) { \nreportDoubleSubscription ( observer ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"32": "public class EndConsumerHelper { \npublic static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { \nObjectHelper . requireNonNull ( next , \"next is null\" ) ; \nif ( upstream != null ) { \nnext . cancel ( ) ; \nif ( upstream != SubscriptionHelper . CANCELLED ) { \nreportDoubleSubscription ( subscriber ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"33": "public class EndConsumerHelper { \npublic static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { \nObjectHelper . requireNonNull ( next , \"next is null\" ) ; \nif ( ! upstream . compareAndSet ( null , next ) ) { \nnext . cancel ( ) ; \nif ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { \nreportDoubleSubscription ( subscriber ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"47": "public class CompositeDisposable { \npublic int size ( ) { \nif ( disposed ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nsynchronized ( this ) { \nif ( disposed ) { \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \nOpenHashSet < Disposable > set = resources ; \nreturn set != null ? set . size ( ) : 0 ; \n} \n} \n} \n"}
{"48": "public class ObservableScalarXMap { \n@ SuppressWarnings ( \"unchecked\" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { \nif ( source instanceof Callable ) { \nT t ; \ntry { \nt = ( ( Callable < T > ) source ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptyDisposable . error ( ex , observer ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( t == null ) { \nEmptyDisposable . complete ( observer ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nObservableSource < ? extends R > r ; \ntry { \nr = ObjectHelper . requireNonNull ( mapper . apply ( t ) , \"The mapper returned a null ObservableSource\" ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptyDisposable . error ( ex , observer ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nif ( r instanceof Callable ) { \nR u ; \ntry { \nu = ( ( Callable < R > ) r ) . call ( ) ; \n} \ncatch ( Throwable ex ) { \nExceptions . throwIfFatal ( ex ) ; \nEmptyDisposable . error ( ex , observer ) ; \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \nif ( u == null ) { \nEmptyDisposable . complete ( observer ) ; \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \nScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; \nobserver . onSubscribe ( sd ) ; \nsd . run ( ) ; \n} \nelse { \nr . subscribe ( observer ) ; \n} \n{ \nboolean return_variable_5 = true ; \nreturn return_variable_5 ; \n} \n} \n{ \nboolean return_variable_6 = false ; \nreturn return_variable_6 ; \n} \n} \n} \n"}
{"50": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Subscriber < ? super U > subscriber ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nwhile ( a != null ) { \nfor ( int i = 0 ; \ni < c ; \ni ++ ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , subscriber ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"51": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Observer < ? super U > observer ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nwhile ( a != null ) { \nfor ( int i = 0 ; \ni < c ; \ni ++ ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , observer ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"54": "public class MulticastProcessor { \npublic boolean offer ( T t ) { \nif ( once . get ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nObjectHelper . requireNonNull ( t , \"offer called with null. Null values are generally not allowed in 2.x operators and sources.\" ) ; \nif ( fusionMode == QueueSubscription . NONE ) { \nif ( queue . offer ( t ) ) { \ndrain ( ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"64": "public class PublishSubject { \nboolean add ( PublishDisposable < T > ps ) { \nfor ( ; \n; \n) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nint n = a . length ; \n@ SuppressWarnings ( \"unchecked\" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , n ) ; \nb [ n ] = ps ; \nif ( subscribers . compareAndSet ( a , b ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n} \n"}
{"77": "public class SpringSecurityCoreVersion { \nprivate static boolean disableChecks ( String springVersion , String springSecurityVersion ) { \nif ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nreturn Boolean . getBoolean ( DISABLE_CHECKS ) ; \n} \n} \n"}
{"101": "public class AbstractPreAuthenticatedProcessingFilter { \nprotected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { \nObject principal = getPreAuthenticatedPrincipal ( request ) ; \nif ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Pre-authenticated principal has changed to \" + principal + \" and will be reauthenticated\" ) ; \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"127": "public class CasAuthenticationFilter { \nprivate boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { \nif ( serviceTicketRequest ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfinal boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"proxyTicketRequest = \" + result ) ; \n} \nreturn result ; \n} \n} \n"}
{"156": "public class AbstractAuthorizeTag { \npublic boolean authorizeUsingAccessExpression ( ) throws IOException { \nif ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nSecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; \nExpression accessExpression ; \ntry { \naccessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; \n} \ncatch ( ParseException e ) { \nIOException ioException = new IOException ( ) ; \nioException . initCause ( e ) ; \nthrow ioException ; \n} \nreturn ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; \n} \n} \n"}
{"190": "public class StandardPasswordEncoder { \nprivate boolean matches ( byte [ ] expected , byte [ ] actual ) { \nif ( expected . length != actual . length ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nint result = 0 ; \nfor ( int i = 0 ; \ni < expected . length ; \ni ++ ) { \nresult |= expected [ i ] ^ actual [ i ] ; \n} \nreturn result == 0 ; \n} \n} \n"}
{"194": "public class UrlUtils { \npublic static boolean isAbsoluteUrl ( String url ) { \nif ( url == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfinal Pattern ABSOLUTE_URL = Pattern . compile ( \"\\\\A[a-z0-9.+-]+://.*\" , Pattern . CASE_INSENSITIVE ) ; \nreturn ABSOLUTE_URL . matcher ( url ) . matches ( ) ; \n} \n} \n"}
{"322": "public class InjectionPoint { \nprivate static boolean checkForMisplacedBindingAnnotations ( Member member , Errors errors ) { \nAnnotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; \nif ( misplacedBindingAnnotation == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( member instanceof Method ) { \ntry { \nif ( member . getDeclaringClass ( ) . getDeclaredField ( member . getName ( ) ) != null ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \ncatch ( NoSuchFieldException ignore ) { \n} \n} \nerrors . misplacedBindingAnnotation ( member , misplacedBindingAnnotation ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"323": "public class InjectionPoint { \nprivate static boolean overrides ( Method a , Method b ) { \nint modifiers = b . getModifiers ( ) ; \nif ( Modifier . isPublic ( modifiers ) || Modifier . isProtected ( modifiers ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( Modifier . isPrivate ( modifiers ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nreturn a . getDeclaringClass ( ) . getPackage ( ) . equals ( b . getDeclaringClass ( ) . getPackage ( ) ) ; \n} \n} \n"}
{"330": "public class BytecodeGen { \nprivate static boolean hasSameVersionOfCglib ( ClassLoader classLoader ) { \nClass < ? > fc = net . sf . cglib . reflect . FastClass . class ; \ntry { \nreturn classLoader . loadClass ( fc . getName ( ) ) == fc ; \n} \ncatch ( ClassNotFoundException e ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"331": "public class BytecodeGen { \nprivate static boolean isPubliclyCallable ( Member member ) { \nif ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nClass < ? > [ ] parameterTypes ; \nif ( member instanceof Constructor ) { \nparameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; \n} \nelse { \nMethod method = ( Method ) member ; \nif ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nparameterTypes = method . getParameterTypes ( ) ; \n} \nfor ( Class < ? > type : parameterTypes ) { \nif ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"348": "public class Struts2Factory { \nprivate static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { \nfor ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { \nif ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"355": "public class FactoryProvider2 { \nprivate boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { \nCollection < Message > messages = ce . getErrorMessages ( ) ; \nif ( messages . size ( ) == 1 ) { \nMessage msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; \nreturn msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; \n} \nelse { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"356": "public class FactoryProvider2 { \nprivate boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { \nList < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; \nAnnotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; \nint p = 0 ; \nList < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; \nfor ( TypeLiteral < ? > param : params ) { \nKey < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; \nconstructorKeys . add ( paramKey ) ; \n} \nfor ( Key < ? > key : paramList ) { \nif ( ! constructorKeys . remove ( key ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \nfor ( Key < ? > key : constructorKeys ) { \nif ( key . getAnnotationType ( ) == Assisted . class ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"359": "public class FactoryProvider2 { \nprivate boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { \nSet < Dependency < ? > > badDeps = null ; \nfor ( Dependency < ? > dep : dependencies ) { \nif ( isInjectorOrAssistedProvider ( dep ) ) { \nif ( badDeps == null ) { \nbadDeps = Sets . newHashSet ( ) ; \n} \nbadDeps . add ( dep ) ; \n} \n} \nif ( badDeps != null && ! badDeps . isEmpty ( ) ) { \nlogger . log ( Level . WARNING , \"AssistedInject factory {0} will be slow \" + \"because {1} has assisted Provider dependencies or injects the Injector. \" + \"Stop injecting @Assisted Provider<T> (instead use @Assisted T) \" + \"or Injector to speed things up. (It will be a ~6500% speed bump!)  \" + \"The exact offending deps are: {2}\" , new Object [ ] { \nfactoryType , implementation , badDeps } \n) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"436": "public class RemotingContext { \npublic boolean isRequestTimeout ( ) { \nif ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"467": "public class SocketChannelIOHelper { \npublic static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { \nif ( ws == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nByteBuffer buffer = ws . outQueue . peek ( ) ; \nWrappedByteChannel c = null ; \nif ( buffer == null ) { \nif ( sockchannel instanceof WrappedByteChannel ) { \nc = ( WrappedByteChannel ) sockchannel ; \nif ( c . isNeedWrite ( ) ) { \nc . writeMore ( ) ; \n} \n} \n} \nelse { \ndo { \nsockchannel . write ( buffer ) ; \nif ( buffer . remaining ( ) > 0 ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nelse { \nws . outQueue . poll ( ) ; \nbuffer = ws . outQueue . peek ( ) ; \n} \n} \nwhile ( buffer != null ) ; \n} \nif ( ws . outQueue . isEmpty ( ) && ws . isFlushAndClose ( ) && ws . getDraft ( ) != null && ws . getDraft ( ) . getRole ( ) != null && ws . getDraft ( ) . getRole ( ) == Role . SERVER ) { \nws . closeConnection ( ) ; \n} \nreturn c == null || ! ( ( WrappedByteChannel ) sockchannel ) . isNeedWrite ( ) ; \n} \n} \n"}
{"508": "public class WebSocketServer { \nprivate boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { \nWebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; \nByteBuffer buf = takeBuffer ( ) ; \nif ( conn . getChannel ( ) == null ) { \nkey . cancel ( ) ; \nhandleIOException ( key , conn , new IOException ( ) ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \ntry { \nif ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { \nif ( buf . hasRemaining ( ) ) { \nconn . inQueue . put ( buf ) ; \nqueue ( conn ) ; \ni . remove ( ) ; \nif ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { \niqueue . add ( conn ) ; \n} \n} \nelse { \npushBuffer ( buf ) ; \n} \n} \nelse { \npushBuffer ( buf ) ; \n} \n} \ncatch ( IOException e ) { \npushBuffer ( buf ) ; \nthrow e ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"510": "public class WebSocketServer { \nprivate boolean doSetupSelectorAndServerThread ( ) { \nselectorthread . setName ( \"WebSocketSelector-\" + selectorthread . getId ( ) ) ; \ntry { \nserver = ServerSocketChannel . open ( ) ; \nserver . configureBlocking ( false ) ; \nServerSocket socket = server . socket ( ) ; \nsocket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; \nsocket . setReuseAddress ( isReuseAddr ( ) ) ; \nsocket . bind ( address ) ; \nselector = Selector . open ( ) ; \nserver . register ( selector , server . validOps ( ) ) ; \nstartConnectionLostTimer ( ) ; \nfor ( WebSocketWorker ex : decoders ) { \nex . start ( ) ; \n} \nonStart ( ) ; \n} \ncatch ( IOException ex ) { \nhandleFatal ( null , ex ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"511": "public class WebSocketServer { \nprivate boolean doEnsureSingleThread ( ) { \nsynchronized ( this ) { \nif ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + \" can only be started once.\" ) ; \nselectorthread = Thread . currentThread ( ) ; \nif ( isclosed . get ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"593": "public class ClassUtils { \npublic static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { \nif ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( classArray == null ) { \nclassArray = EMPTY_CLASS_ARRAY ; \n} \nif ( toClassArray == null ) { \ntoClassArray = EMPTY_CLASS_ARRAY ; \n} \nfor ( int i = 0 ; \ni < classArray . length ; \ni ++ ) { \nif ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"648": "public class MemberUtils { \nstatic boolean setAccessibleWorkaround ( final AccessibleObject o ) { \nif ( o == null || o . isAccessible ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfinal Member m = ( Member ) o ; \nif ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { \ntry { \no . setAccessible ( true ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \ncatch ( final SecurityException e ) { \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"718": "public class ValueJsonSerializer { \n@ Override public final boolean serialize ( final JsonContext jsonContext , final T value ) { \nif ( jsonContext . pushValue ( value ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nserializeValue ( jsonContext , value ) ; \njsonContext . popValue ( ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"755": "public class CsrfShield { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { \nSet < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; \nif ( ( tokenSet == null ) && ( tokenValue == null ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( ( tokenSet == null ) || ( tokenValue == null ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nboolean found = false ; \nIterator < Token > it = tokenSet . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nToken t = it . next ( ) ; \nif ( t . isExpired ( ) ) { \nit . remove ( ) ; \ncontinue ; \n} \nif ( t . getValue ( ) . equals ( tokenValue ) ) { \nit . remove ( ) ; \nfound = true ; \n} \n} \nreturn found ; \n} \n} \n"}
{"758": "public class BeanCopy { \n@ Override protected boolean visitProperty ( String name , final Object value ) { \nif ( isTargetMap ) { \nname = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; \n} \nbeanUtil . setProperty ( destination , name , value ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"791": "public class EmailUtil { \npublic static boolean isEmptyFlags ( Flags flags ) { \nif ( flags == null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nFlags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; \nif ( systemFlags != null && systemFlags . length > 0 ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nString [ ] userFlags = flags . getUserFlags ( ) ; \nif ( userFlags != null && userFlags . length > 0 ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"801": "public class ServletUtil { \npublic boolean isGetParameter ( final HttpServletRequest request , String name ) { \nname = URLCoder . encodeQueryParam ( name ) + '=' ; \nString query = request . getQueryString ( ) ; \nString [ ] nameValuePairs = StringUtil . splitc ( query , '&' ) ; \nfor ( String nameValuePair : nameValuePairs ) { \nif ( nameValuePair . startsWith ( name ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"821": "public class BCrypt { \npublic static boolean checkpw ( String plaintext , String hashed ) { \nbyte [ ] hashed_bytes ; \nbyte [ ] try_bytes ; \ntry { \nString try_pw = hashpw ( plaintext , hashed ) ; \nhashed_bytes = hashed . getBytes ( \"UTF-8\" ) ; \ntry_bytes = try_pw . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( hashed_bytes . length != try_bytes . length ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nbyte ret = 0 ; \nfor ( int i = 0 ; \ni < try_bytes . length ; \ni ++ ) { \nret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; \n} \nreturn ret == 0 ; \n} \n} \n"}
{"929": "public class SystemUtil { \npublic static boolean getBoolean ( final String name , final boolean defaultValue ) { \nString value = get ( name ) ; \nif ( value == null ) { \nreturn defaultValue ; \n} \nvalue = value . trim ( ) . toLowerCase ( ) ; \nswitch ( value ) { \ncase \"true\" : case \"yes\" : case \"1\" : case \"on\" : { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \ncase \"false\" : case \"no\" : case \"0\" : case \"off\" : { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \ndefault : return defaultValue ; \n} \n} \n} \n"}
{"998": "public class Type { \npublic int getSize ( ) { \nswitch ( sort ) { \ncase VOID : { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \ncase BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : { \nint return_variable_1 = 1 ; \nreturn return_variable_1 ; \n} \ncase LONG : case DOUBLE : { \nint return_variable_2 = 2 ; \nreturn return_variable_2 ; \n} \ndefault : throw new AssertionError ( ) ; \n} \n} \n} \n"}
{"1010": "public class Attribute { \npublic boolean isContaining ( final String include ) { \nif ( value == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( splits == null ) { \nsplits = StringUtil . splitc ( value , ' ' ) ; \n} \nfor ( String s : splits ) { \nif ( s . equals ( include ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"1029": "public class JtxTransactionManager { \npublic int totalThreadTransactions ( ) { \nArrayList < JtxTransaction > txList = txStack . get ( ) ; \nif ( txList == null ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nreturn txList . size ( ) ; \n} \n} \n"}
{"1030": "public class JtxTransactionManager { \npublic int totalThreadTransactionsWithStatus ( final JtxStatus status ) { \nArrayList < JtxTransaction > txlist = txStack . get ( ) ; \nif ( txlist == null ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nint count = 0 ; \nfor ( JtxTransaction tx : txlist ) { \nif ( tx . getStatus ( ) == status ) { \ncount ++ ; \n} \n} \nreturn count ; \n} \n} \n"}
{"1072": "public class StringUtil { \npublic static boolean isAllEmpty ( final String ... strings ) { \nfor ( String string : strings ) { \nif ( ! isEmpty ( string ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1073": "public class StringUtil { \npublic static boolean isAllBlank ( final String ... strings ) { \nfor ( String string : strings ) { \nif ( ! isBlank ( string ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1078": "public class StringUtil { \npublic static boolean startsWithIgnoreCase ( final String src , final String subS , final int startIndex ) { \nString sub = subS . toLowerCase ( ) ; \nint sublen = sub . length ( ) ; \nif ( startIndex + sublen > src . length ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nint j = 0 ; \nint i = startIndex ; \nwhile ( j < sublen ) { \nchar source = Character . toLowerCase ( src . charAt ( i ) ) ; \nif ( sub . charAt ( j ) != source ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nj ++ ; \ni ++ ; \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"1079": "public class StringUtil { \npublic static boolean endsWithChar ( final String s , final char c ) { \nif ( s . length ( ) == 0 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nreturn s . charAt ( s . length ( ) - 1 ) == c ; \n} \n} \n"}
{"1080": "public class StringUtil { \npublic static int countIgnoreCase ( final String source , final String sub ) { \nint count = 0 ; \nint j = 0 ; \nint sublen = sub . length ( ) ; \nif ( sublen == 0 ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nwhile ( true ) { \nint i = indexOfIgnoreCase ( source , sub , j ) ; \nif ( i == - 1 ) { \nbreak ; \n} \ncount ++ ; \nj = i + sublen ; \n} \nreturn count ; \n} \n} \n"}
{"1081": "public class StringUtil { \npublic static boolean equalsIgnoreCase ( final String [ ] as , final String [ ] as1 ) { \nif ( as . length != as1 . length ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfor ( int i = 0 ; \ni < as . length ; \ni ++ ) { \nif ( ! as [ i ] . equalsIgnoreCase ( as1 [ i ] ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"1095": "public class StringUtil { \npublic static boolean isCharAtEqual ( final String string , final int index , final char charToCompare ) { \nif ( ( index < 0 ) || ( index >= string . length ( ) ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nreturn string . charAt ( index ) == charToCompare ; \n} \n} \n"}
{"1114": "public class StringUtil { \npublic static char detectQuoteChar ( final String str ) { \nif ( str . length ( ) < 2 ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nfinal char c = str . charAt ( 0 ) ; \nif ( c != str . charAt ( str . length ( ) - 1 ) ) { \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \nif ( c == '\\'' || c == '\"' || c == '`' ) { \nreturn c ; \n} \n{ \nint return_variable_2 = 0 ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"1148": "public class CSSellyLexer { \nprivate boolean zzRefill ( ) { \nif ( zzBuffer == null ) { \nzzBuffer = zzChars ; \nzzEndRead += zzChars . length ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1173": "public class DirWatcher { \nprotected boolean acceptFile ( final File file ) { \nif ( ! file . isFile ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nString fileName = file . getName ( ) ; \nif ( ignoreDotFiles ) { \nif ( fileName . startsWith ( StringPool . DOT ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \nif ( patterns == null ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nreturn Wildcard . matchOne ( fileName , patterns ) != - 1 ; \n} \n} \n"}
{"1230": "public class Label { \nfinal boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { \nthis . flags |= FLAG_RESOLVED ; \nthis . bytecodeOffset = bytecodeOffset ; \nif ( forwardReferences == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nboolean hasAsmInstructions = false ; \nfor ( int i = forwardReferences [ 0 ] ; \ni > 0 ; \ni -= 2 ) { \nfinal int sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; \nfinal int reference = forwardReferences [ i ] ; \nfinal int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; \nint handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; \nif ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) { \nif ( relativeOffset < Short . MIN_VALUE || relativeOffset > Short . MAX_VALUE ) { \nint opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; \nif ( opcode < Opcodes . IFNULL ) { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; \n} \nelse { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; \n} \nhasAsmInstructions = true ; \n} \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \nelse { \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 24 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 16 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \n} \nreturn hasAsmInstructions ; \n} \n} \n"}
{"1267": "public class StringKeyedMapAdapter { \n@ Override public Set < Entry < String , Object > > entrySet ( ) { \nif ( entries == null ) { \nentries = new HashSet < > ( ) ; \nIterator < String > iterator = getAttributeNames ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nfinal String key = iterator . next ( ) ; \nfinal Object value = getAttribute ( key ) ; \nentries . add ( new Entry < String , Object > ( ) { \n@ Override public boolean equals ( final Object obj ) { \nif ( obj == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( this . getClass ( ) != obj . getClass ( ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nEntry entry = ( Entry ) obj ; \nreturn ( ( key == null ) ? ( entry . getKey ( ) == null ) : key . equals ( entry . getKey ( ) ) ) && ( ( value == null ) ? ( entry . getValue ( ) == null ) : value . equals ( entry . getValue ( ) ) ) ; \n} \n@ Override public int hashCode ( ) { \nreturn ( ( key == null ) ? 0 : key . hashCode ( ) ) ^ ( ( value == null ) ? 0 : value . hashCode ( ) ) ; \n} \n@ Override public String getKey ( ) { \nreturn key ; \n} \n@ Override public Object getValue ( ) { \nreturn value ; \n} \n@ Override public Object setValue ( final Object obj ) { \nsetAttribute ( key , obj ) ; \nreturn value ; \n} \n} \n) ; \n} \n} \nreturn entries ; \n} \n} \n"}
{"1318": "public class ThreadLocalScope { \n@ Override public boolean accept ( final Scope referenceScope ) { \nClass < ? extends Scope > refScopeType = referenceScope . getClass ( ) ; \nif ( refScopeType == ProtoScope . class ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( refScopeType == SingletonScope . class ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nif ( refScopeType == ThreadLocalScope . class ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"1356": "public class MultiComparator { \n@ Override public int compare ( final T o1 , final T o2 ) { \nfor ( Comparator < T > comparator : comparators ) { \nint result = comparator . compare ( o1 , o2 ) ; \nif ( result != 0 ) { \nreturn result ; \n} \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"1375": "public class CoreConnectionPool { \nprivate boolean isConnectionValid ( final ConnectionData connectionData , final long now ) { \nif ( ! validateConnection ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( now < connectionData . lastUsed + validationTimeout ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nConnection conn = connectionData . connection ; \nif ( validationQuery == null ) { \ntry { \nreturn ! conn . isClosed ( ) ; \n} \ncatch ( SQLException sex ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \nboolean valid = true ; \nStatement st = null ; \ntry { \nst = conn . createStatement ( ) ; \nst . execute ( validationQuery ) ; \n} \ncatch ( SQLException sex ) { \nvalid = false ; \n} \nfinally { \nif ( st != null ) { \ntry { \nst . close ( ) ; \n} \ncatch ( SQLException ignore ) { \n} \n} \n} \nreturn valid ; \n} \n} \n"}
{"1406": "public class FileUtil { \npublic static boolean isBinary ( final File file ) throws IOException { \nbyte [ ] bytes = readBytes ( file , 128 ) ; \nfor ( byte b : bytes ) { \nif ( b < 32 && b != 9 && b != 10 && b != 13 ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1413": "public class LoopIterator { \npublic boolean next ( ) { \nif ( ! looping ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( last ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( count == 0 ) { \nvalue = start ; \nfirst = true ; \n} \nelse { \nvalue += step ; \nfirst = false ; \n} \ncount ++ ; \nlast = isLastIteration ( value + step ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"1416": "public class Scanner { \npublic final boolean matchUpperCase ( final char [ ] uppercaseTarget ) { \nif ( ndx + uppercaseTarget . length > total ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nint j = ndx ; \nfor ( int i = 0 ; \ni < uppercaseTarget . length ; \ni ++ , j ++ ) { \nfinal char c = CharUtil . toUpperAscii ( input [ j ] ) ; \nif ( c != uppercaseTarget [ i ] ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"1466": "public class ClassUtil { \npublic static boolean compareParameters ( final Class [ ] first , final Class [ ] second ) { \nif ( first . length != second . length ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfor ( int i = 0 ; \ni < first . length ; \ni ++ ) { \nif ( first [ i ] != second [ i ] ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"1491": "public class DbListIterator { \nprivate boolean moveToNext ( ) { \nif ( last ) { \nif ( closeOnEnd ) { \nquery . close ( ) ; \n} \nelse { \nquery . closeResultSet ( resultSetMapper . getResultSet ( ) ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nwhile ( true ) { \nif ( ! resultSetMapper . next ( ) ) { \nlast = true ; \nreturn entityAwareMode ; \n} \nObject [ ] objects = resultSetMapper . parseObjects ( types ) ; \nObject row = query . resolveRowResults ( objects ) ; \nnewElement = ( T ) row ; \nif ( entityAwareMode ) { \nif ( count == 0 && previousElement == null ) { \npreviousElement = newElement ; \ncontinue ; \n} \nif ( previousElement != null && newElement != null ) { \nboolean equals ; \nif ( newElement . getClass ( ) . isArray ( ) ) { \nequals = Arrays . equals ( ( Object [ ] ) previousElement , ( Object [ ] ) newElement ) ; \n} \nelse { \nequals = previousElement . equals ( newElement ) ; \n} \nif ( equals ) { \ncontinue ; \n} \n} \n} \nbreak ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1529": "public class JsonContext { \npublic boolean matchIgnoredPropertyTypes ( final Class propertyType , final boolean excludeMaps , final boolean include ) { \nif ( ! include ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( propertyType != null ) { \nif ( ! jsonSerializer . deep ) { \nClassDescriptor propertyTypeClassDescriptor = ClassIntrospector . get ( ) . lookup ( propertyType ) ; \nif ( propertyTypeClassDescriptor . isArray ( ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( propertyTypeClassDescriptor . isCollection ( ) ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nif ( excludeMaps ) { \nif ( propertyTypeClassDescriptor . isMap ( ) ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n} \nif ( jsonSerializer . excludedTypes != null ) { \nfor ( Class excludedType : jsonSerializer . excludedTypes ) { \nif ( ClassUtil . isTypeOf ( propertyType , excludedType ) ) { \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \n} \n} \nfinal String propertyTypeName = propertyType . getName ( ) ; \nif ( jsonSerializer . excludedTypeNames != null ) { \nfor ( String excludedTypeName : jsonSerializer . excludedTypeNames ) { \nif ( Wildcard . match ( propertyTypeName , excludedTypeName ) ) { \n{ \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \n} \n} \n} \n{ \nboolean return_variable_6 = true ; \nreturn return_variable_6 ; \n} \n} \n} \n"}
{"1547": "public class CssSelector { \n@ Override public boolean accept ( final Node node ) { \nif ( ! matchElement ( node ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nint totalSelectors = selectorsCount ( ) ; \nfor ( int i = 0 ; \ni < totalSelectors ; \ni ++ ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase ATTRIBUTE : if ( ! ( ( AttributeSelector ) selector ) . accept ( node ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( node ) ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nbreak ; \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( node ) ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \nbreak ; \n} \n} \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"1548": "public class CssSelector { \nprotected boolean matchElement ( final Node node ) { \nif ( node . getNodeType ( ) != Node . NodeType . ELEMENT ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nString element = getElement ( ) ; \nString nodeName = node . getNodeName ( ) ; \nreturn element . equals ( StringPool . STAR ) || element . equals ( nodeName ) ; \n} \n} \n"}
{"1549": "public class CssSelector { \npublic boolean accept ( final List < Node > currentResults , final Node node , final int index ) { \nint totalSelectors = selectorsCount ( ) ; \nfor ( int i = 0 ; \ni < totalSelectors ; \ni ++ ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( currentResults , node , index ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( currentResults , node , index ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nbreak ; \ndefault : } \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"1563": "public class Node { \npublic boolean check ( ) { \nif ( childNodes == null ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nint siblingElementIndex = 0 ; \nfor ( int i = 0 , childNodesSize = childNodes . size ( ) ; \ni < childNodesSize ; \ni ++ ) { \nNode childNode = childNodes . get ( i ) ; \nif ( childNode . siblingIndex != i ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( childNode . getNodeType ( ) == NodeType . ELEMENT ) { \nif ( childNode . siblingElementIndex != siblingElementIndex ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nsiblingElementIndex ++ ; \n} \n} \nif ( childElementNodesCount != siblingElementIndex ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \nif ( childElementNodes != null ) { \nif ( childElementNodes . length != childElementNodesCount ) { \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \nint childCount = getChildNodesCount ( ) ; \nfor ( int i = 0 ; \ni < childCount ; \ni ++ ) { \nNode child = getChild ( i ) ; \nif ( child . siblingElementIndex >= 0 ) { \nif ( childElementNodes [ child . siblingElementIndex ] != child ) { \n{ \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \n} \n} \n} \nif ( siblingNameIndex != - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \nfor ( int i = 0 , siblingsSize = siblings . size ( ) ; \ni < siblingsSize ; \ni ++ ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nif ( sibling . siblingNameIndex != index ++ ) { \n{ \nboolean return_variable_6 = false ; \nreturn return_variable_6 ; \n} \n} \n} \n} \n} \nfor ( Node childNode : childNodes ) { \nif ( ! childNode . check ( ) ) { \n{ \nboolean return_variable_7 = false ; \nreturn return_variable_7 ; \n} \n} \n} \n{ \nboolean return_variable_8 = true ; \nreturn return_variable_8 ; \n} \n} \n} \n"}
{"1604": "public class CharSequenceUtil { \npublic static boolean equalsOne ( final char c , final CharSequence match ) { \nfor ( int i = 0 ; \ni < match . length ( ) ; \ni ++ ) { \nchar aMatch = match . charAt ( i ) ; \nif ( c == aMatch ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1613": "public class Frame { \nprivate static int getAbstractTypeFromDescriptor ( final SymbolTable symbolTable , final String buffer , final int offset ) { \nString internalName ; \nswitch ( buffer . charAt ( offset ) ) { \ncase 'V' : { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \ncase 'Z' : case 'C' : case 'B' : case 'S' : case 'I' : return INTEGER ; \ncase 'F' : return FLOAT ; \ncase 'J' : return LONG ; \ncase 'D' : return DOUBLE ; \ncase 'L' : internalName = buffer . substring ( offset + 1 , buffer . length ( ) - 1 ) ; \nreturn REFERENCE_KIND | symbolTable . addType ( internalName ) ; \ncase '[' : int elementDescriptorOffset = offset + 1 ; \nwhile ( buffer . charAt ( elementDescriptorOffset ) == '[' ) { \n++ elementDescriptorOffset ; \n} \nint typeValue ; \nswitch ( buffer . charAt ( elementDescriptorOffset ) ) { \ncase 'Z' : typeValue = BOOLEAN ; \nbreak ; \ncase 'C' : typeValue = CHAR ; \nbreak ; \ncase 'B' : typeValue = BYTE ; \nbreak ; \ncase 'S' : typeValue = SHORT ; \nbreak ; \ncase 'I' : typeValue = INTEGER ; \nbreak ; \ncase 'F' : typeValue = FLOAT ; \nbreak ; \ncase 'J' : typeValue = LONG ; \nbreak ; \ncase 'D' : typeValue = DOUBLE ; \nbreak ; \ncase 'L' : internalName = buffer . substring ( elementDescriptorOffset + 1 , buffer . length ( ) - 1 ) ; \ntypeValue = REFERENCE_KIND | symbolTable . addType ( internalName ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \nreturn ( ( elementDescriptorOffset - offset ) << DIM_SHIFT ) | typeValue ; \ndefault : throw new IllegalArgumentException ( ) ; \n} \n} \n} \n"}
{"1638": "public class PageData { \npublic static int calcFirstItemIndexOfPage ( int page , final int pageSize , final int total ) { \nif ( total == 0 ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nif ( page < 1 ) { \npage = 1 ; \n} \nint first = ( page - 1 ) * pageSize ; \nif ( first >= total ) { \nfirst = ( ( total - 1 ) / pageSize ) * pageSize ; \n} \nreturn first ; \n} \n} \n"}
{"1640": "public class PseudoFunctionExpression { \npublic boolean match ( final int value ) { \nif ( a == 0 ) { \nreturn value == b ; \n} \nif ( a > 0 ) { \nif ( value < b ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nreturn ( value - b ) % a == 0 ; \n} \nif ( value > b ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nreturn ( b - value ) % ( - a ) == 0 ; \n} \n} \n"}
{"1677": "public class Wildcard { \nprivate static boolean match ( final CharSequence string , final CharSequence pattern , int sNdx , int pNdx ) { \nint pLen = pattern . length ( ) ; \nif ( pLen == 1 ) { \nif ( pattern . charAt ( 0 ) == '*' ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \nint sLen = string . length ( ) ; \nboolean nextIsNotWildcard = false ; \nwhile ( true ) { \nif ( ( sNdx >= sLen ) ) { \nwhile ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == '*' ) ) { \npNdx ++ ; \n} \nreturn pNdx >= pLen ; \n} \nif ( pNdx >= pLen ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nchar p = pattern . charAt ( pNdx ) ; \nif ( ! nextIsNotWildcard ) { \nif ( p == '\\\\' ) { \npNdx ++ ; \nnextIsNotWildcard = true ; \ncontinue ; \n} \nif ( p == '?' ) { \nsNdx ++ ; \npNdx ++ ; \ncontinue ; \n} \nif ( p == '*' ) { \nchar pNext = 0 ; \nif ( pNdx + 1 < pLen ) { \npNext = pattern . charAt ( pNdx + 1 ) ; \n} \nif ( pNext == '*' ) { \npNdx ++ ; \ncontinue ; \n} \nint i ; \npNdx ++ ; \nfor ( i = string . length ( ) ; \ni >= sNdx ; \ni -- ) { \nif ( match ( string , pattern , i , pNdx ) ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \nelse { \nnextIsNotWildcard = false ; \n} \nif ( p != string . charAt ( sNdx ) ) { \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \nsNdx ++ ; \npNdx ++ ; \n} \n} \n} \n"}
{"1712": "public class NetUtil { \npublic static boolean validateAgaintIPAdressV4Format ( final String input ) { \nif ( input == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nint hitDots = 0 ; \nchar [ ] data = input . toCharArray ( ) ; \nfor ( int i = 0 ; \ni < data . length ; \ni ++ ) { \nchar c = data [ i ] ; \nint b = 0 ; \ndo { \nif ( c < '0' || c > '9' ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nb = ( b * 10 + c ) - 48 ; \nif ( ++ i >= data . length ) { \nbreak ; \n} \nc = data [ i ] ; \n} \nwhile ( c != '.' ) ; \nif ( b > 255 ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nhitDots ++ ; \n} \nreturn hitDots == 4 ; \n} \n} \n"}
{"1748": "public class DispatcherUtil { \npublic static boolean include ( final ServletRequest request , final ServletResponse response , final String page ) throws IOException , ServletException { \nRequestDispatcher dispatcher = request . getRequestDispatcher ( page ) ; \nif ( dispatcher != null ) { \ndispatcher . include ( request , response ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1771": "public class GzipFilter { \nprotected boolean isGzipEligible ( final HttpServletRequest request ) { \nif ( requestParameterName . length ( ) != 0 ) { \nString forceGzipString = request . getParameter ( requestParameterName ) ; \nif ( forceGzipString != null ) { \nreturn Converter . get ( ) . toBooleanValue ( forceGzipString , false ) ; \n} \n} \nString uri = request . getRequestURI ( ) ; \nif ( uri == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nuri = uri . toLowerCase ( ) ; \nboolean result = false ; \nif ( matches == null ) { \nif ( extensions == null ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nString extension = FileNameUtil . getExtension ( uri ) ; \nif ( extension . length ( ) > 0 ) { \nextension = extension . toLowerCase ( ) ; \nif ( StringUtil . equalsOne ( extension , extensions ) != - 1 ) { \nresult = true ; \n} \n} \n} \nelse { \nif ( wildcards ) { \nresult = Wildcard . matchPathOne ( uri , matches ) != - 1 ; \n} \nelse { \nfor ( String match : matches ) { \nif ( uri . contains ( match ) ) { \nresult = true ; \nbreak ; \n} \n} \n} \n} \nif ( ( result ) && ( excludes != null ) ) { \nif ( wildcards ) { \nif ( Wildcard . matchPathOne ( uri , excludes ) != - 1 ) { \nresult = false ; \n} \n} \nelse { \nfor ( String exclude : excludes ) { \nif ( uri . contains ( exclude ) ) { \nresult = false ; \nbreak ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"1776": "public class Vtor { \nprotected boolean matchProfiles ( final String [ ] checkProfiles ) { \nif ( ( checkProfiles != null ) && ( checkProfiles . length == 1 ) && checkProfiles [ 0 ] . equals ( ALL_PROFILES ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( enabledProfiles == null || enabledProfiles . isEmpty ( ) ) { \nif ( validateAllProfilesByDefault ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nif ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nfor ( String profile : checkProfiles ) { \nif ( StringUtil . isEmpty ( profile ) ) { \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \nif ( profile . equals ( DEFAULT_PROFILE ) ) { \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \n} \n{ \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \nif ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) { \nreturn enabledProfiles . contains ( DEFAULT_PROFILE ) ; \n} \nboolean result = false ; \nfor ( String profile : checkProfiles ) { \nboolean b = true ; \nboolean must = false ; \nif ( StringUtil . isEmpty ( profile ) ) { \nprofile = DEFAULT_PROFILE ; \n} \nelse if ( profile . charAt ( 0 ) == '-' ) { \nprofile = profile . substring ( 1 ) ; \nb = false ; \n} \nelse if ( profile . charAt ( 0 ) == '+' ) { \nprofile = profile . substring ( 1 ) ; \nmust = true ; \n} \nif ( enabledProfiles . contains ( profile ) ) { \nif ( ! b ) { \n{ \nboolean return_variable_6 = false ; \nreturn return_variable_6 ; \n} \n} \nresult = true ; \n} \nelse { \nif ( must ) { \n{ \nboolean return_variable_7 = false ; \nreturn return_variable_7 ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"1855": "public class UdpChannel { \npublic boolean matchesTag ( final UdpChannel udpChannel ) { \nif ( ! hasTag || ! udpChannel . hasTag ( ) || tag != udpChannel . tag ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( udpChannel . remoteData ( ) . getAddress ( ) . isAnyLocalAddress ( ) && udpChannel . remoteData ( ) . getPort ( ) == 0 && udpChannel . localData ( ) . getAddress ( ) . isAnyLocalAddress ( ) && udpChannel . localData ( ) . getPort ( ) == 0 ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nthrow new IllegalArgumentException ( \"matching tag has set endpoint or control address\" ) ; \n} \n} \n"}
{"1900": "public class ClusterMember { \npublic static boolean hasActiveQuorum ( final ClusterMember [ ] clusterMembers , final long nowMs , final long timeoutMs ) { \nint threshold = quorumThreshold ( clusterMembers . length ) ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( member . isLeader ( ) || nowMs <= ( member . timeOfLastAppendPositionMs ( ) + timeoutMs ) ) { \nif ( -- threshold <= 0 ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1903": "public class ClusterMember { \npublic static boolean haveVotersReachedPosition ( final ClusterMember [ ] clusterMembers , final long position , final long leadershipTermId ) { \nfor ( final ClusterMember member : clusterMembers ) { \nif ( member . vote != null && ( member . logPosition < position || member . leadershipTermId != leadershipTermId ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1904": "public class ClusterMember { \npublic static boolean hasWonVoteOnFullCount ( final ClusterMember [ ] members , final long candidateTermId ) { \nint votes = 0 ; \nfor ( final ClusterMember member : members ) { \nif ( null == member . vote || member . candidateTermId != candidateTermId ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nvotes += member . vote ? 1 : 0 ; \n} \nreturn votes >= ClusterMember . quorumThreshold ( members . length ) ; \n} \n} \n"}
{"1909": "public class ClusterMember { \npublic static boolean isUnanimousCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { \nfor ( final ClusterMember member : clusterMembers ) { \nif ( NULL_POSITION == member . logPosition || compareLog ( candidate , member ) < 0 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1911": "public class ClusterMember { \npublic static boolean isNotDuplicateEndpoints ( final ClusterMember [ ] members , final String memberEndpoints ) { \nfor ( final ClusterMember member : members ) { \nif ( member . endpointsDetail ( ) . equals ( memberEndpoints ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1916": "public class CommonContext { \npublic static boolean isDriverActive ( final File directory , final long driverTimeoutMs , final Consumer < String > logger ) { \nfinal File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; \nif ( cncFile . exists ( ) && cncFile . length ( ) > 0 ) { \nlogger . accept ( \"INFO: Aeron CnC file exists: \" + cncFile ) ; \nfinal MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , \"CnC file\" ) ; \ntry { \nreturn isDriverActive ( driverTimeoutMs , logger , cncByteBuffer ) ; \n} \nfinally { \nIoUtil . unmap ( cncByteBuffer ) ; \n} \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"1918": "public class CommonContext { \npublic static boolean isDriverActive ( final long driverTimeoutMs , final Consumer < String > logger , final ByteBuffer cncByteBuffer ) { \nif ( null == cncByteBuffer ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfinal UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; \nfinal long startTimeMs = System . currentTimeMillis ( ) ; \nint cncVersion ; \nwhile ( 0 == ( cncVersion = cncMetaDataBuffer . getIntVolatile ( CncFileDescriptor . cncVersionOffset ( 0 ) ) ) ) { \nif ( System . currentTimeMillis ( ) > ( startTimeMs + driverTimeoutMs ) ) { \nthrow new DriverTimeoutException ( \"CnC file is created but not initialised.\" ) ; \n} \nsleep ( 1 ) ; \n} \nif ( CNC_VERSION != cncVersion ) { \nthrow new AeronException ( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion ) ; \n} \nfinal ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; \nfinal long timestamp = toDriverBuffer . consumerHeartbeatTime ( ) ; \nfinal long now = System . currentTimeMillis ( ) ; \nfinal long timestampAge = now - timestamp ; \nlogger . accept ( \"INFO: Aeron toDriver consumer heartbeat is (ms): \" + timestampAge ) ; \nreturn timestampAge <= driverTimeoutMs ; \n} \n} \n"}
{"1919": "public class CommonContext { \npublic static boolean requestDriverTermination ( final File directory , final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { \nfinal File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; \nif ( cncFile . exists ( ) && cncFile . length ( ) > 0 ) { \nfinal MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , \"CnC file\" ) ; \ntry { \nfinal UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; \nfinal int cncVersion = cncMetaDataBuffer . getIntVolatile ( cncVersionOffset ( 0 ) ) ; \nif ( CncFileDescriptor . CNC_VERSION != cncVersion ) { \nthrow new AeronException ( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion ) ; \n} \nfinal ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; \nfinal long clientId = toDriverBuffer . nextCorrelationId ( ) ; \nfinal DriverProxy driverProxy = new DriverProxy ( toDriverBuffer , clientId ) ; \nreturn driverProxy . terminateDriver ( tokenBuffer , tokenOffset , tokenLength ) ; \n} \nfinally { \nIoUtil . unmap ( cncByteBuffer ) ; \n} \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"1929": "public class RecordingPos { \npublic static boolean isActive ( final CountersReader countersReader , final int counterId , final long recordingId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nif ( countersReader . getCounterState ( counterId ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( counterId ) ; \nreturn buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"1941": "public class LogBufferUnblocker { \npublic static boolean unblock ( final UnsafeBuffer [ ] termBuffers , final UnsafeBuffer logMetaDataBuffer , final long blockedPosition , final int termLength ) { \nfinal int positionBitsToShift = LogBufferDescriptor . positionBitsToShift ( termLength ) ; \nfinal int blockedTermCount = ( int ) ( blockedPosition >> positionBitsToShift ) ; \nfinal int blockedOffset = ( int ) blockedPosition & ( termLength - 1 ) ; \nfinal int activeTermCount = activeTermCount ( logMetaDataBuffer ) ; \nif ( activeTermCount == ( blockedTermCount - 1 ) && blockedOffset == 0 ) { \nfinal int currentTermId = termId ( rawTailVolatile ( logMetaDataBuffer , indexByTermCount ( activeTermCount ) ) ) ; \nreturn rotateLog ( logMetaDataBuffer , activeTermCount , currentTermId ) ; \n} \nfinal int blockedIndex = indexByTermCount ( blockedTermCount ) ; \nfinal long rawTail = rawTailVolatile ( logMetaDataBuffer , blockedIndex ) ; \nfinal int termId = termId ( rawTail ) ; \nfinal int tailOffset = termOffset ( rawTail , termLength ) ; \nfinal UnsafeBuffer termBuffer = termBuffers [ blockedIndex ] ; \nswitch ( TermUnblocker . unblock ( logMetaDataBuffer , termBuffer , blockedOffset , tailOffset , termId ) ) { \ncase UNBLOCKED_TO_END : rotateLog ( logMetaDataBuffer , blockedTermCount , termId ) ; \ncase UNBLOCKED : { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"1959": "public class RecoveryState { \npublic static boolean hasReplay ( final CountersReader counters , final int counterId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nif ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( counterId ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { \nreturn buffer . getInt ( recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET ) == 1 ; \n} \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"2009": "public class Schemas { \npublic static boolean nullOk ( Schema schema ) { \nif ( Schema . Type . NULL == schema . getType ( ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse if ( Schema . Type . UNION == schema . getType ( ) ) { \nfor ( Schema possible : schema . getTypes ( ) ) { \nif ( nullOk ( possible ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"2093": "public class ThreadHealthReporter { \npublic boolean reportHealth ( String threadName , int scheduledDelay , long timestamp ) { \nThreadHealthReport threadHealthReport = new ThreadHealthReport ( threadName , scheduledDelay , timestamp ) ; \nif ( threadToGaugeMap . containsKey ( threadName ) ) { \nthreadToGaugeMap . get ( threadName ) . setThreadHealthReport ( threadHealthReport ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2094": "public class ThreadHealthReporter { \npublic boolean register ( String threadName ) { \nif ( threadToGaugeMap . containsKey ( threadName ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nThreadHealthReportGauge threadHealthReportGauge = new ThreadHealthReportGauge ( ) ; \nMetricsConfigurator . createGauge ( metrics , getHealthGaugeName ( threadName ) , threadHealthReportGauge , name , rev ) ; \nthreadToGaugeMap . put ( threadName , threadHealthReportGauge ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2103": "public class SystemPackage { \nprivate static boolean isSystemClass ( String name , List < String > packageList ) { \nboolean result = false ; \nif ( packageList != null ) { \nString canonicalName = ClassLoaderUtil . canonicalizeClassOrResource ( name ) ; \nfor ( String c : packageList ) { \nboolean shouldInclude = true ; \nif ( c . startsWith ( \"-\" ) ) { \nc = c . substring ( 1 ) ; \nshouldInclude = false ; \n} \nif ( canonicalName . startsWith ( c ) ) { \nif ( c . endsWith ( \".\" ) || canonicalName . length ( ) == c . length ( ) || canonicalName . length ( ) > c . length ( ) && canonicalName . charAt ( c . length ( ) ) == '$' ) { \nif ( shouldInclude ) { \nresult = true ; \n} \nelse { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"2104": "public class XEvictingQueue { \n@ Override public boolean add ( E e ) { \ncheckNotNull ( e ) ; \nif ( maxSize == 0 ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( size ( ) == maxSize ) { \ndelegate . remove ( ) ; \n} \ndelegate . add ( e ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2177": "public class SolrTarget { \nprivate boolean checkRecordContainsSolrFields ( Map < String , Field > recordFieldMap , Record record , List < String > solrFieldsMap , Errors errorToThrow ) throws StageException { \nList < String > fieldsFound = new ArrayList < > ( ) ; \nrecordFieldMap . keySet ( ) . forEach ( recordFieldKey -> { \nif ( solrFieldsMap . contains ( recordFieldKey ) ) { \nfieldsFound . add ( recordFieldKey ) ; \n} \n} \n) ; \nif ( solrFieldsMap . size ( ) != fieldsFound . size ( ) ) { \nSet < String > missingFields = new HashSet < > ( ) ; \nsolrFieldsMap . forEach ( requiredField -> { \nif ( ! fieldsFound . contains ( requiredField ) ) { \nmissingFields . add ( requiredField ) ; \n} \n} \n) ; \nhandleError ( record , errorToThrow , Joiner . on ( \",\" ) . join ( missingFields ) ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2219": "public class SpoolDirUtil { \npublic static boolean compareFiles ( WrappedFileSystem fs , WrappedFile f1 , WrappedFile f2 ) { \nif ( ! fs . exists ( f2 ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ntry { \nlong mtime1 = fs . getLastModifiedTime ( f1 ) ; \nlong mtime2 = fs . getLastModifiedTime ( f2 ) ; \nlong ctime1 = fs . getChangedTime ( f1 ) ; \nlong ctime2 = fs . getChangedTime ( f2 ) ; \nlong time1 = Math . max ( mtime1 , ctime1 ) ; \nlong time2 = Math . max ( mtime2 , ctime2 ) ; \nint compares = Long . compare ( time1 , time2 ) ; \nif ( compares != 0 ) { \nreturn compares > 0 ; \n} \n} \ncatch ( IOException ex ) { \nLOG . error ( \"Failed to get ctime: '{}'\" , f1 . getFileName ( ) , ex ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nreturn f1 . getAbsolutePath ( ) . compareTo ( f2 . getAbsolutePath ( ) ) > 0 ; \n} \n} \n"}
{"2279": "public class ForceSource { \nprivate boolean checkConditionExpressions ( SOQLParser . ConditionExpressionsContext conditionExpressions , String fieldName ) { \nfor ( SOQLParser . ConditionExpressionContext ce : conditionExpressions . conditionExpression ( ) ) { \nif ( ( ce . conditionExpressions ( ) != null && checkConditionExpressions ( ce . conditionExpressions ( ) , fieldName ) ) || ( ce . fieldExpression ( ) != null && ce . fieldExpression ( ) . fieldElement ( ) . getText ( ) . equalsIgnoreCase ( fieldName ) ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2288": "public class KineticaTableUtils { \nprivate boolean typeIsNullable ( JSONObject field ) throws GPUdbException { \nif ( field . get ( \"type\" ) instanceof JSONArray ) { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \nfor ( int j = 0 ; \nj < columnTypes . length ( ) ; \nj ++ ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ct . equals ( \"null\" ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2332": "public class LocalFileSystem { \npublic int compare ( WrappedFile path1 , WrappedFile path2 , boolean useLastModified ) { \ntry { \nif ( useLastModified && ! exists ( path2 ) ) { \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \nreturn getComparator ( useLastModified ) . compare ( path1 , path2 ) ; \n} \ncatch ( RuntimeException ex ) { \nThrowable cause = ex . getCause ( ) ; \nif ( cause != null && cause instanceof NoSuchFileException ) { \nLOG . debug ( \"Starting file may have already been archived.\" , cause ) ; \n{ \nint return_variable_1 = 1 ; \nreturn return_variable_1 ; \n} \n} \nLOG . warn ( \"Error while comparing files\" , ex ) ; \nthrow ex ; \n} \n} \n} \n"}
{"2342": "public class OracleCDCSource { \nprivate boolean refreshSchema ( BigDecimal scnDecimal , SchemaAndTable schemaAndTable ) throws SQLException { \ntry { \nif ( ! tableSchemaLastUpdate . containsKey ( schemaAndTable ) || scnDecimal . compareTo ( tableSchemaLastUpdate . get ( schemaAndTable ) ) > 0 ) { \nif ( containerized ) { \ntry ( Statement switchToPdb = connection . createStatement ( ) ) { \nswitchToPdb . execute ( \"ALTER SESSION SET CONTAINER = \" + configBean . pdb ) ; \n} \n} \ntableSchemas . put ( schemaAndTable , getTableSchema ( schemaAndTable ) ) ; \ntableSchemaLastUpdate . put ( schemaAndTable , scnDecimal ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nfinally { \nalterSession ( ) ; \n} \n} \n} \n"}
{"2370": "public class LiveDirectoryScanner { \npublic long getPendingFiles ( LiveFile current ) throws IOException { \nif ( current == null || rollMode . isCurrentAcceptable ( current . getPath ( ) . getFileName ( ) . toString ( ) ) ) { \nreturn findToBeProcessedMatchingFiles ( current != null ? current . refresh ( ) : null ) . size ( ) ; \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"2416": "public class PipeRunner { \npublic boolean onRecordErrorStopPipeline ( ) { \nfor ( Pipe pipe : pipes ) { \nStageContext stageContext = pipe . getStage ( ) . getContext ( ) ; \nif ( stageContext . getOnErrorRecord ( ) == OnRecordError . STOP_PIPELINE ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2434": "public class RecordWriterManager { \npublic boolean shouldRoll ( RecordWriter writer , Record record ) { \nif ( rollIfHeader && record . getHeader ( ) . getAttribute ( rollHeaderName ) != null ) { \nLOG . debug ( \"Path[{}] - will be rolled because of roll attribute '{}' set to '{}' in the record : '{}'\" , writer . getPath ( ) , rollHeaderName , record . getHeader ( ) . getAttribute ( rollHeaderName ) , record . getHeader ( ) . getSourceId ( ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2443": "public class HTTPSession { \nprivate int findHeaderEnd ( final byte [ ] buf , int rlen ) { \nint splitbyte = 0 ; \nwhile ( splitbyte + 1 < rlen ) { \nif ( buf [ splitbyte ] == '\\r' && buf [ splitbyte + 1 ] == '\\n' && splitbyte + 3 < rlen && buf [ splitbyte + 2 ] == '\\r' && buf [ splitbyte + 3 ] == '\\n' ) { \nreturn splitbyte + 4 ; \n} \nif ( buf [ splitbyte ] == '\\n' && buf [ splitbyte + 1 ] == '\\n' ) { \nreturn splitbyte + 2 ; \n} \nsplitbyte ++ ; \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"2444": "public class HTTPSession { \npublic long getBodySize ( ) { \nif ( this . headers . containsKey ( \"content-length\" ) ) { \nreturn Long . parseLong ( this . headers . get ( \"content-length\" ) ) ; \n} \nelse if ( this . splitbyte < this . rlen ) { \nreturn this . rlen - this . splitbyte ; \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"2528": "public class AbstractInvocationHandler { \nprivate boolean matches ( final Method seiMethod , final Method viewMethod ) { \nif ( ! seiMethod . getName ( ) . equals ( viewMethod . getName ( ) ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfinal Class < ? > [ ] sourceParams = seiMethod . getParameterTypes ( ) ; \nfinal Class < ? > [ ] targetParams = viewMethod . getParameterTypes ( ) ; \nif ( sourceParams . length != targetParams . length ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nfor ( int i = 0 ; \ni < sourceParams . length ; \ni ++ ) { \nif ( ! sourceParams [ i ] . equals ( targetParams [ i ] ) ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"2579": "public class JMSConnectionFactoryDefinitionInjectionSource { \nstatic boolean targetsPooledConnectionFactory ( String server , String resourceAdapter , ServiceRegistry serviceRegistry ) { \nif ( resourceAdapter == null || resourceAdapter . isEmpty ( ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nServiceName activeMQServiceName = MessagingServices . getActiveMQServiceName ( server ) ; \nServiceName pcfName = JMSServices . getPooledConnectionFactoryBaseServiceName ( activeMQServiceName ) . append ( resourceAdapter ) ; \nreturn serviceRegistry . getServiceNames ( ) . contains ( pcfName ) ; \n} \n} \n"}
{"2580": "public class JMSConnectionFactoryDefinitionInjectionSource { \nstatic boolean targetsExternalPooledConnectionFactory ( String resourceAdapter , ServiceRegistry serviceRegistry ) { \nif ( resourceAdapter == null || resourceAdapter . isEmpty ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nServiceName pcfName = JMSServices . getPooledConnectionFactoryBaseServiceName ( MessagingServices . getActiveMQServiceName ( \"\" ) ) . append ( resourceAdapter ) ; \nreturn serviceRegistry . getServiceNames ( ) . contains ( pcfName ) ; \n} \n} \n"}
{"2632": "public class Util { \nprivate static boolean isReservedIDLKeyword ( String s ) { \nfor ( int i = 0 ; \ni < reservedIDLKeywords . length ; \n++ i ) if ( reservedIDLKeywords [ i ] . equals ( s ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2684": "public class WSServerConfigAttributeHandler { \nprivate boolean updateServerConfig ( String attributeName , String value , boolean isRevert ) throws OperationFailedException , DisabledOperationException { \nfinal ServerConfigImpl config = ( ServerConfigImpl ) ServerConfigFactoryImpl . getConfig ( ) ; \ntry { \nif ( MODIFY_WSDL_ADDRESS . equals ( attributeName ) ) { \nfinal boolean modifyWSDLAddress = value != null && Boolean . parseBoolean ( value ) ; \nconfig . setModifySOAPAddress ( modifyWSDLAddress , isRevert ) ; \n} \nelse if ( WSDL_HOST . equals ( attributeName ) ) { \nfinal String host = value != null ? value : null ; \ntry { \nconfig . setWebServiceHost ( host , isRevert ) ; \n} \ncatch ( final UnknownHostException e ) { \nthrow new OperationFailedException ( e . getMessage ( ) , e ) ; \n} \n} \nelse if ( WSDL_PORT . equals ( attributeName ) ) { \nfinal int port = value != null ? Integer . parseInt ( value ) : - 1 ; \nconfig . setWebServicePort ( port , isRevert ) ; \n} \nelse if ( WSDL_SECURE_PORT . equals ( attributeName ) ) { \nfinal int securePort = value != null ? Integer . parseInt ( value ) : - 1 ; \nconfig . setWebServiceSecurePort ( securePort , isRevert ) ; \n} \nelse if ( WSDL_PATH_REWRITE_RULE . equals ( attributeName ) ) { \nfinal String path = value != null ? value : null ; \nconfig . setWebServicePathRewriteRule ( path , isRevert ) ; \n} \nelse if ( WSDL_URI_SCHEME . equals ( attributeName ) ) { \nif ( value == null || value . equals ( \"http\" ) || value . equals ( \"https\" ) ) { \nconfig . setWebServiceUriScheme ( value , isRevert ) ; \n} \nelse { \nthrow new IllegalArgumentException ( attributeName + \" = \" + value ) ; \n} \n} \nelse if ( STATISTICS_ENABLED . equals ( attributeName ) ) { \nfinal boolean enabled = value != null ? Boolean . parseBoolean ( value ) : false ; \nconfig . setStatisticsEnabled ( enabled ) ; \n} \nelse { \nthrow new IllegalArgumentException ( attributeName ) ; \n} \n} \ncatch ( DisabledOperationException doe ) { \nif ( ! isRevert ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse { \nthrow doe ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2685": "public class RmiIdlUtil { \npublic static boolean isAllFieldsPublic ( Class c ) { \ntry { \nfinal Field [ ] list = c . getFields ( ) ; \nfor ( int i = 0 ; \ni < list . length ; \ni ++ ) if ( ! Modifier . isPublic ( list [ i ] . getModifiers ( ) ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Exception e ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"2693": "public class EJBComponentDescription { \nprotected void addRemoteTransactionsDependency ( ) { \nthis . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { \n@ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration componentConfiguration ) throws DeploymentUnitProcessingException { \nif ( this . hasRemoteView ( ( EJBComponentDescription ) description ) ) { \ncomponentConfiguration . getCreateDependencies ( ) . add ( ( sb , cs ) -> sb . requires ( TxnServices . JBOSS_TXN_REMOTE_TRANSACTION_SERVICE ) ) ; \n} \n} \nprivate boolean hasRemoteView ( final EJBComponentDescription ejbComponentDescription ) { \nfinal Set < ViewDescription > views = ejbComponentDescription . getViews ( ) ; \nfor ( final ViewDescription view : views ) { \nif ( ! ( view instanceof EJBViewDescription ) ) { \ncontinue ; \n} \nfinal MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; \nif ( viewType == MethodIntf . REMOTE || viewType == MethodIntf . HOME ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n) ; \n} \n} \n"}
{"2695": "public class ApplicableMethodInformation { \npublic boolean isMethodLevel ( MethodIntf methodIntf , Method method , MethodIntf defaultMethodIntf ) { \nassert methodIntf != null : \"methodIntf is null\" ; \nassert method != null : \"method is null\" ; \nMethod classMethod = resolveRealMethod ( method ) ; \nString [ ] methodParams = MethodInfoHelper . getCanonicalParameterTypes ( classMethod ) ; \nfinal String methodName = classMethod . getName ( ) ; \nfinal String className = classMethod . getDeclaringClass ( ) . getName ( ) ; \nArrayKey methodParamsKey = new ArrayKey ( ( Object [ ] ) methodParams ) ; \nT attr = get ( get ( get ( perViewStyle3 , methodIntf ) , methodName ) , methodParamsKey ) ; \nif ( attr != null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nattr = get ( get ( perViewStyle2 , methodIntf ) , methodName ) ; \nif ( attr != null ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nattr = get ( perViewStyle1 , methodIntf ) ; \nif ( attr != null ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nattr = get ( get ( get ( style3 , className ) , methodName ) , methodParamsKey ) ; \nif ( attr != null ) { \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \nattr = get ( style2 , methodName ) ; \nif ( attr != null ) { \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \nattr = get ( style1 , className ) ; \nif ( attr != null ) { \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \nif ( defaultMethodIntf == null ) { \n{ \nboolean return_variable_6 = false ; \nreturn return_variable_6 ; \n} \n} \nelse { \nreturn isMethodLevel ( defaultMethodIntf , method , null ) ; \n} \n} \n} \n"}
{"2708": "public class GetDataSourceClassInfoOperationHandler { \nprivate static boolean isTypeMatched ( Class < ? > clz ) { \nif ( clz . equals ( String . class ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse if ( clz . equals ( byte . class ) || clz . equals ( Byte . class ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nelse if ( clz . equals ( short . class ) || clz . equals ( Short . class ) ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nelse if ( clz . equals ( int . class ) || clz . equals ( Integer . class ) ) { \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \nelse if ( clz . equals ( long . class ) || clz . equals ( Long . class ) ) { \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \nelse if ( clz . equals ( float . class ) || clz . equals ( Float . class ) ) { \n{ \nboolean return_variable_5 = true ; \nreturn return_variable_5 ; \n} \n} \nelse if ( clz . equals ( double . class ) || clz . equals ( Double . class ) ) { \n{ \nboolean return_variable_6 = true ; \nreturn return_variable_6 ; \n} \n} \nelse if ( clz . equals ( boolean . class ) || clz . equals ( Boolean . class ) ) { \n{ \nboolean return_variable_7 = true ; \nreturn return_variable_7 ; \n} \n} \nelse if ( clz . equals ( char . class ) || clz . equals ( Character . class ) ) { \n{ \nboolean return_variable_8 = true ; \nreturn return_variable_8 ; \n} \n} \nelse if ( clz . equals ( InetAddress . class ) ) { \n{ \nboolean return_variable_9 = true ; \nreturn return_variable_9 ; \n} \n} \nelse if ( clz . equals ( Class . class ) ) { \n{ \nboolean return_variable_10 = true ; \nreturn return_variable_10 ; \n} \n} \nelse if ( clz . equals ( Properties . class ) ) { \n{ \nboolean return_variable_11 = true ; \nreturn return_variable_11 ; \n} \n} \n{ \nboolean return_variable_12 = false ; \nreturn return_variable_12 ; \n} \n} \n} \n"}
{"2748": "public class ContainerAnalysis { \nprotected boolean isAccessor ( Method m ) { \nClass returnType = m . getReturnType ( ) ; \nString name = m . getName ( ) ; \nif ( ! ( name . startsWith ( \"get\" ) && name . length ( ) > \"get\" . length ( ) ) ) if ( ! ( name . startsWith ( \"is\" ) && name . length ( ) > \"is\" . length ( ) ) || ! ( returnType == Boolean . TYPE ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( returnType == Void . TYPE ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( m . getParameterTypes ( ) . length != 0 ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nreturn hasNonAppExceptions ( m ) ; \n} \n} \n"}
{"2749": "public class ContainerAnalysis { \nprotected boolean isMutator ( Method m ) { \nString name = m . getName ( ) ; \nif ( ! ( name . startsWith ( \"set\" ) && name . length ( ) > \"set\" . length ( ) ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( m . getReturnType ( ) != Void . TYPE ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( m . getParameterTypes ( ) . length != 1 ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nreturn hasNonAppExceptions ( m ) ; \n} \n} \n"}
{"2750": "public class ContainerAnalysis { \nprotected boolean hasNonAppExceptions ( Method m ) { \nClass [ ] ex = m . getExceptionTypes ( ) ; \nfor ( int i = 0 ; \ni < ex . length ; \n++ i ) if ( ! java . rmi . RemoteException . class . isAssignableFrom ( ex [ i ] ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2856": "public class WeldSubsystemAdd { \nprivate boolean checkJtsEnabled ( final OperationContext context ) { \ntry { \nfinal ModelNode jtsNode = context . readResourceFromRoot ( PathAddress . pathAddress ( \"subsystem\" , \"transactions\" ) , false ) . getModel ( ) . get ( \"jts\" ) ; \nreturn jtsNode . isDefined ( ) ? jtsNode . asBoolean ( ) : false ; \n} \ncatch ( NoSuchResourceException ex ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"2905": "public class MigrateOperation { \nprivate boolean parameterIsAllowed ( String name , String resourceType ) { \nswitch ( resourceType ) { \ncase REMOTE_ACCEPTOR : case HTTP_ACCEPTOR : case REMOTE_CONNECTOR : case HTTP_CONNECTOR : if ( \"use-nio\" . equals ( name ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \ndefault : { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n"}
{"2907": "public class CancellationFlag { \npublic boolean cancel ( boolean setFlag ) { \nfinal AtomicInteger stateRef = this . stateRef ; \nint oldVal , newVal ; \ndo { \noldVal = stateRef . get ( ) ; \nif ( oldVal == ST_WAITING ) { \nnewVal = ST_CANCELLED ; \n} \nelse if ( oldVal == ST_CANCELLED ) { \nif ( ! setFlag ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nnewVal = ST_CANCELLED_FLAG_SET ; \n} \nelse if ( oldVal == ST_CANCELLED_FLAG_SET ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nelse if ( oldVal == ST_STARTED ) { \nif ( ! setFlag ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nnewVal = ST_STARTED_FLAG_SET ; \n} \nelse { \nassert oldVal == ST_STARTED_FLAG_SET ; \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \nwhile ( ! stateRef . compareAndSet ( oldVal , newVal ) ) ; \nreturn newVal == ST_CANCELLED || newVal == ST_CANCELLED_FLAG_SET ; \n} \n} \n"}
{"2908": "public class CancellationFlag { \npublic boolean runIfNotCancelled ( ) { \nfinal AtomicInteger stateRef = this . stateRef ; \nint oldVal ; \ndo { \noldVal = stateRef . get ( ) ; \nif ( oldVal == ST_CANCELLED || oldVal == ST_CANCELLED_FLAG_SET ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse if ( oldVal != ST_WAITING ) { \nthrow Assert . unreachableCode ( ) ; \n} \n} \nwhile ( ! stateRef . compareAndSet ( oldVal , ST_STARTED ) ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2910": "public class OBaseExpression { \npublic boolean canExecuteIndexedFunctionWithoutIndex ( OFromClause target , OCommandContext context , OBinaryCompareOperator operator , Object right ) { \nif ( this . identifier == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nreturn identifier . canExecuteIndexedFunctionWithoutIndex ( target , context , operator , right ) ; \n} \n} \n"}
{"2915": "public class OQueryOperatorContainsText { \n@ Override public Object evaluateRecord ( final OIdentifiable iRecord , ODocument iCurrentResult , final OSQLFilterCondition iCondition , final Object iLeft , final Object iRight , OCommandContext iContext , final ODocumentSerializer serializer ) { \nif ( iLeft == null || iRight == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nreturn iLeft . toString ( ) . indexOf ( iRight . toString ( ) ) > - 1 ; \n} \n} \n"}
{"2924": "public class OSelectExecutionPlanner { \nprivate boolean handleClassWithIndexForSortOnly ( OSelectExecutionPlan plan , OIdentifier queryTarget , Set < String > filterClusters , QueryPlanningInfo info , OCommandContext ctx , boolean profilingEnabled ) { \nOSchema schema = getSchemaFromContext ( ctx ) ; \nOClass clazz = schema . getClass ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nclazz = schema . getView ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nthrow new OCommandExecutionException ( \"Class not found: \" + queryTarget ) ; \n} \n} \nfor ( OIndex idx : clazz . getIndexes ( ) . stream ( ) . filter ( i -> i . supportsOrderedIterations ( ) ) . filter ( i -> i . getDefinition ( ) != null ) . collect ( Collectors . toList ( ) ) ) { \nList < String > indexFields = idx . getDefinition ( ) . getFields ( ) ; \nif ( indexFields . size ( ) < info . orderBy . getItems ( ) . size ( ) ) { \ncontinue ; \n} \nboolean indexFound = true ; \nString orderType = null ; \nfor ( int i = 0 ; \ni < info . orderBy . getItems ( ) . size ( ) ; \ni ++ ) { \nOOrderByItem orderItem = info . orderBy . getItems ( ) . get ( i ) ; \nif ( orderItem . getCollate ( ) != null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nString indexField = indexFields . get ( i ) ; \nif ( i == 0 ) { \norderType = orderItem . getType ( ) ; \n} \nelse { \nif ( orderType == null || ! orderType . equals ( orderItem . getType ( ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( ! ( indexField . equals ( orderItem . getAlias ( ) ) || isInOriginalProjection ( indexField , orderItem . getAlias ( ) ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( indexFound && orderType != null ) { \nplan . chain ( new FetchFromIndexValuesStep ( idx , orderType . equals ( OOrderByItem . ASC ) , ctx , profilingEnabled ) ) ; \nint [ ] filterClusterIds = null ; \nif ( filterClusters != null ) { \nfilterClusterIds = filterClusters . stream ( ) . map ( name -> ctx . getDatabase ( ) . getClusterIdByName ( name ) ) . mapToInt ( i -> i ) . toArray ( ) ; \n} \nplan . chain ( new GetValueFromIndexEntryStep ( ctx , filterClusterIds , profilingEnabled ) ) ; \nif ( info . serverToClusters . size ( ) == 1 ) { \ninfo . orderApplied = true ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"2925": "public class OSelectExecutionPlanner { \nprivate boolean isDiamondHierarchy ( OClass clazz ) { \nSet < OClass > traversed = new HashSet < > ( ) ; \nList < OClass > stack = new ArrayList < > ( ) ; \nstack . add ( clazz ) ; \nwhile ( ! stack . isEmpty ( ) ) { \nOClass current = stack . remove ( 0 ) ; \ntraversed . add ( current ) ; \nfor ( OClass sub : current . getSubclasses ( ) ) { \nif ( traversed . contains ( sub ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nstack . add ( sub ) ; \ntraversed . add ( sub ) ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2927": "public class OSelectExecutionPlanner { \nprivate boolean requiresMultipleIndexLookups ( OAndBlock keyCondition ) { \nfor ( OBooleanExpression oBooleanExpression : keyCondition . getSubBlocks ( ) ) { \nif ( ! ( oBooleanExpression instanceof OBinaryCondition ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2933": "public class OUser { \npublic boolean isRuleDefined ( final ORule . ResourceGeneric resourceGeneric , String resourceSpecific ) { \nfor ( ORole r : roles ) if ( r == null ) OLogManager . instance ( ) . warn ( this , \"User '%s' has a null role, bypass it. Consider to fix this user roles before to continue\" , getName ( ) ) ; \nelse if ( r . hasRule ( resourceGeneric , resourceSpecific ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2954": "public class OIndexFullText { \n@ Override public boolean remove ( Object key , final OIdentifiable value ) { \nif ( key == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nkey = getCollatingValue ( key ) ; \nfinal Set < String > words = splitIntoWords ( key . toString ( ) ) ; \nfinal OModifiableBoolean removed = new OModifiableBoolean ( false ) ; \nfor ( final String word : words ) { \nacquireSharedLock ( ) ; \ntry { \nif ( apiVersion == 0 ) { \nremoveV0 ( value , removed , word ) ; \n} \nelse if ( apiVersion == 1 ) { \nremoveV1 ( value , removed , word ) ; \n} \nelse { \nthrow new IllegalStateException ( \"Invalid API version, \" + apiVersion ) ; \n} \n} \nfinally { \nreleaseSharedLock ( ) ; \n} \n} \nreturn removed . getValue ( ) ; \n} \n} \n"}
{"2968": "public class OClientConnectionManager { \npublic boolean disconnect ( final int iChannelId ) { \nOLogManager . instance ( ) . debug ( this , \"Disconnecting connection with id=%d\" , iChannelId ) ; \nfinal OClientConnection connection = connections . remove ( iChannelId ) ; \nif ( connection != null ) { \nOServerPluginHelper . invokeHandlerCallbackOnClientDisconnection ( server , connection ) ; \nconnection . close ( ) ; \nremoveConnectionFromSession ( connection ) ; \nfor ( Entry < Integer , OClientConnection > entry : connections . entrySet ( ) ) { \nif ( entry . getValue ( ) . getProtocol ( ) . equals ( connection . getProtocol ( ) ) ) { \nOLogManager . instance ( ) . debug ( this , \"Disconnected connection with id=%d but are present other active channels\" , iChannelId ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \nOLogManager . instance ( ) . debug ( this , \"Disconnected connection with id=%d, no other active channels found\" , iChannelId ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nOLogManager . instance ( ) . debug ( this , \"Cannot find connection with id=%d\" , iChannelId ) ; \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"2970": "public class OEmbeddedRidBag { \npublic boolean swap ( int index , OIdentifiable newValue ) { \nEntriesIterator iter = ( EntriesIterator ) rawIterator ( ) ; \nint currIndex = 0 ; \nwhile ( iter . hasNext ( ) ) { \niter . next ( ) ; \nif ( index == currIndex ) { \niter . swapValueOnCurrent ( newValue ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncurrIndex ++ ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"2980": "public class OMathExpression { \npublic boolean allowsIndexedFunctionExecutionOnTarget ( OFromClause target , OCommandContext context , OBinaryCompareOperator operator , Object right ) { \nif ( this . childExpressions . size ( ) != 1 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nreturn this . childExpressions . get ( 0 ) . allowsIndexedFunctionExecutionOnTarget ( target , context , operator , right ) ; \n} \n} \n"}
{"2985": "public class OQueryTargetOperator { \n@ Override public Object evaluateRecord ( final OIdentifiable iRecord , ODocument iCurrentResult , final OSQLFilterCondition iCondition , final Object iLeft , final Object iRight , OCommandContext iContext , final ODocumentSerializer serializer ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"2997": "public class OCommandExecutorSQLDropCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( clusterName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocumentInternal database = getDatabase ( ) ; \nfinal int clusterId = database . getStorage ( ) . getClusterIdByName ( clusterName ) ; \nfor ( OClass iClass : database . getMetadata ( ) . getSchema ( ) . getClasses ( ) ) { \nfor ( int i : iClass . getClusterIds ( ) ) { \nif ( i == clusterId ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \ndatabase . getMetadata ( ) . getCommandCache ( ) . invalidateResultsOfCluster ( clusterName ) ; \ndatabase . dropCluster ( clusterId , true ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3001": "public class OSecurityManager { \nprivate static boolean isAlgorithmSupported ( final String algorithm ) { \nif ( Runtime . class . getPackage ( ) != null && Runtime . class . getPackage ( ) . getImplementationVersion ( ) != null ) { \nif ( Runtime . class . getPackage ( ) . getImplementationVersion ( ) . startsWith ( \"1.7\" ) ) { \nif ( algorithm != null && algorithm . equals ( PBKDF2_SHA256_ALGORITHM ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3008": "public class OAtomicOperation { \nprivate static boolean checkChangesFilledUpTo ( final FileChanges changesContainer , final long pageIndex ) { \nif ( changesContainer == null ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse if ( changesContainer . isNew || changesContainer . maxNewPageIndex > - 2 ) { \nreturn pageIndex < changesContainer . maxNewPageIndex + 1 ; \n} \nelse return ! changesContainer . truncate ; \n} \n} \n"}
{"3009": "public class OCommandExecutorSQLAbstract { \nprotected boolean parseTimeout ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_TIMEOUT ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nString word = parserNextWord ( true ) ; \ntry { \ntimeoutMs = Long . parseLong ( word ) ; \n} \ncatch ( NumberFormatException ignore ) { \nthrowParsingException ( \"Invalid \" + KEYWORD_TIMEOUT + \" value set to '\" + word + \"' but it should be a valid long. Example: \" + KEYWORD_TIMEOUT + \" 3000\" ) ; \n} \nif ( timeoutMs < 0 ) throwParsingException ( \"Invalid \" + KEYWORD_TIMEOUT + \": value set minor than ZERO. Example: \" + KEYWORD_TIMEOUT + \" 10000\" ) ; \nword = parserNextWord ( true ) ; \nif ( word != null ) if ( word . equals ( TIMEOUT_STRATEGY . EXCEPTION . toString ( ) ) ) timeoutStrategy = TIMEOUT_STRATEGY . EXCEPTION ; \nelse if ( word . equals ( TIMEOUT_STRATEGY . RETURN . toString ( ) ) ) timeoutStrategy = TIMEOUT_STRATEGY . RETURN ; \nelse parserGoBack ( ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3018": "public class OCommandExecutorSQLDelete { \npublic boolean result ( final Object iRecord ) { \nfinal ORecordAbstract record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; \nif ( record instanceof ODocument && compiledFilter != null && ! Boolean . TRUE . equals ( this . compiledFilter . evaluate ( record , ( ODocument ) record , getContext ( ) ) ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ntry { \nif ( record . getIdentity ( ) . isValid ( ) ) { \nif ( returning . equalsIgnoreCase ( \"BEFORE\" ) ) allDeletedRecords . add ( record ) ; \nif ( ! unsafe && record instanceof ODocument ) { \nfinal OClass cls = ( ( ODocument ) record ) . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( cls . isSubClassOf ( \"V\" ) ) throw new OCommandExecutionException ( \"'DELETE' command cannot delete vertices. Use 'DELETE VERTEX' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \nelse if ( cls . isSubClassOf ( \"E\" ) ) throw new OCommandExecutionException ( \"'DELETE' command cannot delete edges. Use 'DELETE EDGE' command instead, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \nrecord . delete ( ) ; \nrecordCount ++ ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nfinally { \nif ( lockStrategy . equalsIgnoreCase ( \"RECORD\" ) ) ( ( OAbstractPaginatedStorage ) getDatabase ( ) . getStorage ( ) ) . releaseWriteLock ( record . getIdentity ( ) ) ; \n} \n} \n} \n"}
{"3032": "public class ORidBag { \npublic boolean tryMerge ( final ORidBag otherValue , boolean iMergeSingleItemsOfMultiValueFields ) { \nif ( ! isEmbedded ( ) && ! otherValue . isEmbedded ( ) ) { \nfinal OSBTreeRidBag thisTree = ( OSBTreeRidBag ) delegate ; \nfinal OSBTreeRidBag otherTree = ( OSBTreeRidBag ) otherValue . delegate ; \nif ( thisTree . getCollectionPointer ( ) . equals ( otherTree . getCollectionPointer ( ) ) ) { \nthisTree . mergeChanges ( otherTree ) ; \nuuid = otherValue . uuid ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \nelse if ( iMergeSingleItemsOfMultiValueFields ) { \nfinal Iterator < OIdentifiable > iter = otherValue . rawIterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nfinal OIdentifiable value = iter . next ( ) ; \nif ( value != null ) { \nfinal Iterator < OIdentifiable > localIter = rawIterator ( ) ; \nboolean found = false ; \nwhile ( localIter . hasNext ( ) ) { \nfinal OIdentifiable v = localIter . next ( ) ; \nif ( value . equals ( v ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) add ( value ) ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"3077": "public class OCommandExecutorSQLUpdate { \n@ SuppressWarnings ( \"unchecked\" ) public boolean result ( final Object iRecord ) { \nfinal ODocument record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; \nif ( isUpdateEdge ( ) && ! isRecordInstanceOf ( iRecord , \"E\" ) ) { \nthrow new OCommandExecutionException ( \"Using UPDATE EDGE on a record that is not an instance of E\" ) ; \n} \nif ( compiledFilter != null ) { \nif ( ! ( Boolean ) compiledFilter . evaluate ( record , null , context ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nparameters . reset ( ) ; \nreturnHandler . beforeUpdate ( record ) ; \nboolean updated = handleContent ( record ) ; \nupdated |= handleMerge ( record ) ; \nupdated |= handleSetEntries ( record ) ; \nupdated |= handleIncrementEntries ( record ) ; \nupdated |= handleAddEntries ( record ) ; \nupdated |= handlePutEntries ( record ) ; \nupdated |= handleRemoveEntries ( record ) ; \nif ( updated ) { \nhandleUpdateEdge ( record ) ; \nrecord . setDirty ( ) ; \nrecord . save ( ) ; \nreturnHandler . afterUpdate ( record ) ; \nthis . updated = true ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3078": "public class OFunctionCall { \npublic boolean canExecuteIndexedFunctionWithoutIndex ( OFromClause target , OCommandContext context , OBinaryCompareOperator operator , Object right ) { \nOSQLFunction function = OSQLEngine . getInstance ( ) . getFunction ( name . getStringValue ( ) ) ; \nif ( function instanceof OIndexableSQLFunction ) { \nreturn ( ( OIndexableSQLFunction ) function ) . canExecuteInline ( target , operator , right , context , this . getParams ( ) . toArray ( new OExpression [ ] { \n} \n) ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"3084": "public class ODistributedConfiguration { \npublic boolean isReplicationActive ( final String iClusterName , final String iLocalNode ) { \nfinal Collection < String > servers = getClusterConfiguration ( iClusterName ) . field ( SERVERS ) ; \nif ( servers != null && ! servers . isEmpty ( ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3087": "public class ODistributedConfiguration { \npublic Boolean isReadYourWrites ( final String iClusterName ) { \nObject value = getClusterConfiguration ( iClusterName ) . field ( READ_YOUR_WRITES ) ; \nif ( value == null ) { \nvalue = configuration . field ( READ_YOUR_WRITES ) ; \nif ( value == null ) { \nOLogManager . instance ( ) . warn ( this , \"%s setting not found for cluster=%s in distributed-config.json\" , READ_YOUR_WRITES , iClusterName ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \nreturn ( Boolean ) value ; \n} \n} \n"}
{"3090": "public class ODistributedConfiguration { \npublic boolean isServerContainingAllClusters ( final String server , Collection < String > clusters ) { \nif ( clusters == null || clusters . isEmpty ( ) ) clusters = DEFAULT_CLUSTER_NAME ; \nfor ( String cluster : clusters ) { \nfinal List < String > serverList = getClusterConfiguration ( cluster ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nif ( ! serverList . contains ( server ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3091": "public class ODistributedConfiguration { \npublic boolean isServerContainingCluster ( final String server , String cluster ) { \nif ( cluster == null ) cluster = ALL_WILDCARD ; \nfinal List < String > serverList = getClusterConfiguration ( cluster ) . field ( SERVERS ) ; \nif ( serverList != null ) { \nreturn serverList . contains ( server ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"3102": "public class ODistributedConfiguration { \npublic boolean isSharded ( ) { \nfinal ODocument allCluster = getClusterConfiguration ( ALL_WILDCARD ) ; \nif ( allCluster != null ) { \nfinal List < String > allServers = allCluster . field ( SERVERS ) ; \nif ( allServers != null && ! allServers . isEmpty ( ) ) { \nfor ( String cl : getClusterNames ( ) ) { \nfinal List < String > servers = getServers ( cl , null ) ; \nif ( servers != null && ! servers . isEmpty ( ) && ! allServers . containsAll ( servers ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3149": "public class ODistributedResponseManagerImpl { \nprivate boolean computeQuorumResponse ( boolean reachedTimeout ) { \nif ( quorumResponse != null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( groupResponsesByResult ) { \nfor ( List < ODistributedResponse > group : responseGroups ) { \nif ( group . size ( ) >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( ODistributedResponse r : group ) { \nif ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { \nfinal Object payload = r . getPayload ( ) ; \nif ( payload instanceof Throwable ) { \nif ( payload instanceof ODistributedRecordLockedException ) break ; \nif ( payload instanceof OConcurrentCreateException ) break ; \n} \nelse if ( ++ responsesForQuorum >= quorum ) { \nsetQuorumResponse ( r ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n} \n} \n} \nelse { \nif ( receivedResponses >= quorum ) { \nint responsesForQuorum = 0 ; \nfor ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { \nif ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && ++ responsesForQuorum >= quorum ) { \nODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; \nif ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"3158": "public class OOrderByOptimizer { \nboolean canBeUsedByOrderByAfterFilter ( OIndex < ? > index , List < String > equalsFilterFields , List < OPair < String , String > > orderedFields ) { \nif ( orderedFields . isEmpty ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( ! index . supportsOrderedIterations ( ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nfinal OIndexDefinition definition = index . getDefinition ( ) ; \nfinal List < String > indexFields = definition . getFields ( ) ; \nint endIndex = Math . min ( indexFields . size ( ) , equalsFilterFields . size ( ) ) ; \nfinal String firstOrder = orderedFields . get ( 0 ) . getValue ( ) ; \nfor ( int i = 0 ; \ni < endIndex ; \ni ++ ) { \nfinal String equalsFieldName = equalsFilterFields . get ( i ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! equalsFieldName . equals ( indexFieldName ) ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nendIndex = Math . min ( indexFields . size ( ) , orderedFields . size ( ) + equalsFilterFields . size ( ) ) ; \nif ( endIndex == equalsFilterFields . size ( ) ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \nfor ( int i = equalsFilterFields . size ( ) ; \ni < endIndex ; \ni ++ ) { \nint fieldOrderInOrderByClause = i - equalsFilterFields . size ( ) ; \nfinal OPair < String , String > pair = orderedFields . get ( fieldOrderInOrderByClause ) ; \nif ( ! firstOrder . equals ( pair . getValue ( ) ) ) { \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \nfinal String orderFieldName = pair . getKey ( ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! orderFieldName . equals ( indexFieldName ) ) { \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \n{ \nboolean return_variable_6 = true ; \nreturn return_variable_6 ; \n} \n} \n} \n"}
{"3236": "public class OSystemUserAuthenticator { \npublic boolean isAuthorized ( final String username , final String resource ) { \nif ( username == null || resource == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \ntry { \nif ( getServer ( ) != null ) { \nOUser user = getServer ( ) . getSecurity ( ) . getSystemUser ( username , null ) ; \nif ( user != null && user . getAccountStatus ( ) == OSecurityUser . STATUSES . ACTIVE ) { \nORole role = null ; \nORule . ResourceGeneric rg = ORule . mapLegacyResourceToGenericResource ( resource ) ; \nif ( rg != null ) { \nString specificResource = ORule . mapLegacyResourceToSpecificResource ( resource ) ; \nif ( specificResource == null || specificResource . equals ( \"*\" ) ) { \nspecificResource = null ; \n} \nrole = user . checkIfAllowed ( rg , specificResource , ORole . PERMISSION_EXECUTE ) ; \n} \nreturn role != null ; \n} \n} \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"isAuthorized()\" , ex ) ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3252": "public class OClosableLinkedContainer { \npublic boolean close ( K key ) { \nemptyBuffers ( ) ; \nfinal OClosableEntry < K , V > entry = data . get ( key ) ; \nif ( entry == null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( entry . makeClosed ( ) ) { \ncountClosedFiles ( ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"3258": "public class OLiveQueryClientListener { \npublic boolean onEvent ( OLiveQueryPushRequest pushRequest ) { \nODatabaseDocumentInternal old = ODatabaseRecordThreadLocal . instance ( ) . getIfDefined ( ) ; \ntry { \ndatabase . activateOnCurrentThread ( ) ; \nif ( pushRequest . getStatus ( ) == OLiveQueryPushRequest . ERROR ) { \nonError ( pushRequest . getErrorCode ( ) . newException ( pushRequest . getErrorMessage ( ) , null ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \nfor ( OLiveQueryResult result : pushRequest . getEvents ( ) ) { \nswitch ( result . getEventType ( ) ) { \ncase OLiveQueryResult . CREATE_EVENT : listener . onCreate ( database , result . getCurrentValue ( ) ) ; \nbreak ; \ncase OLiveQueryResult . UPDATE_EVENT : listener . onUpdate ( database , result . getOldValue ( ) , result . getCurrentValue ( ) ) ; \nbreak ; \ncase OLiveQueryResult . DELETE_EVENT : listener . onDelete ( database , result . getCurrentValue ( ) ) ; \nbreak ; \n} \n} \nif ( pushRequest . getStatus ( ) == OLiveQueryPushRequest . END ) { \nonEnd ( ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nfinally { \nODatabaseRecordThreadLocal . instance ( ) . set ( old ) ; \n} \n} \n} \n"}
{"3269": "public class OReadersWriterSpinLock { \npublic boolean tryAcquireReadLock ( long timeout ) { \nfinal OModifiableInteger lHolds = lockHolds . get ( ) ; \nfinal int holds = lHolds . intValue ( ) ; \nif ( holds > 0 ) { \nlHolds . increment ( ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse if ( holds < 0 ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \ndistributedCounter . increment ( ) ; \nWNode wNode = tail . get ( ) ; \nfinal long start = System . nanoTime ( ) ; \nwhile ( wNode . locked ) { \ndistributedCounter . decrement ( ) ; \nwhile ( wNode . locked && wNode == tail . get ( ) ) { \nwNode . waitingReaders . put ( Thread . currentThread ( ) , Boolean . TRUE ) ; \nif ( wNode . locked && wNode == tail . get ( ) ) { \nfinal long parkTimeout = timeout - ( System . nanoTime ( ) - start ) ; \nif ( parkTimeout > 0 ) { \nLockSupport . parkNanos ( this , parkTimeout ) ; \n} \nelse { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \ndistributedCounter . increment ( ) ; \nwNode = tail . get ( ) ; \nif ( System . nanoTime ( ) - start > timeout ) { \ndistributedCounter . decrement ( ) ; \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \n} \nlHolds . increment ( ) ; \nassert lHolds . intValue ( ) == 1 ; \n{ \nboolean return_variable_5 = true ; \nreturn return_variable_5 ; \n} \n} \n} \n"}
{"3278": "public class OCommandExecutorSQLTraverse { \nprotected boolean parseStrategy ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_STRATEGY ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfinal String strategyWord = parserNextWord ( true ) ; \ntry { \ntraverse . setStrategy ( OTraverse . STRATEGY . valueOf ( strategyWord . toUpperCase ( Locale . ENGLISH ) ) ) ; \n} \ncatch ( IllegalArgumentException ignore ) { \nthrowParsingException ( \"Invalid \" + KEYWORD_STRATEGY + \". Use one between \" + Arrays . toString ( OTraverse . STRATEGY . values ( ) ) ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3281": "public class ODatabaseRepair { \nprotected boolean fixLink ( final Object fieldValue ) { \nif ( fieldValue instanceof OIdentifiable ) { \nfinal ORID id = ( ( OIdentifiable ) fieldValue ) . getIdentity ( ) ; \nif ( id . getClusterId ( ) == 0 && id . getClusterPosition ( ) == 0 ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( id . isValid ( ) ) if ( id . isPersistent ( ) ) { \nfinal ORecord connected = ( ( OIdentifiable ) fieldValue ) . getRecord ( ) ; \nif ( connected == null ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nelse { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"3305": "public class ODistributedAbstractPlugin { \npublic boolean installClustersOfClass ( final ODatabaseInternal iDatabase , final OClass iClass , OModifiableDistributedConfiguration cfg ) { \nfinal String databaseName = iDatabase . getName ( ) ; \nif ( iClass . isAbstract ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \ngetMessageService ( ) . registerDatabase ( databaseName , cfg ) ; \nreturn executeInDistributedDatabaseLock ( databaseName , 20000 , cfg , new OCallable < Boolean , OModifiableDistributedConfiguration > ( ) { \n@ Override public Boolean call ( final OModifiableDistributedConfiguration lastCfg ) { \nfinal Set < String > availableNodes = getAvailableNodeNames ( iDatabase . getName ( ) ) ; \nfinal List < String > cluster2Create = clusterAssignmentStrategy . assignClusterOwnershipOfClass ( iDatabase , lastCfg , iClass , availableNodes , true ) ; \nfinal Map < OClass , List < String > > cluster2CreateMap = new HashMap < OClass , List < String > > ( 1 ) ; \ncluster2CreateMap . put ( iClass , cluster2Create ) ; \ncreateClusters ( iDatabase , cluster2CreateMap , lastCfg ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n) ; \n} \n} \n"}
{"3310": "public class OCommandExecutorSQLSelect { \n@ Override protected boolean handleResult ( final OIdentifiable iRecord , final OCommandContext iContext ) { \nlastRecord = iRecord ; \nif ( ( orderedFields . isEmpty ( ) || fullySortedByIndex || isRidOnlySort ( ) ) && skip > 0 && this . unwindFields == null && this . expandTarget == null ) { \nlastRecord = null ; \nskip -- ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( ! addResult ( lastRecord , iContext ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nreturn continueSearching ( ) ; \n} \n} \n"}
{"3313": "public class OCommandExecutorSQLSelect { \nprotected boolean parseFetchplan ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_FETCHPLAN ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nparserSkipWhiteSpaces ( ) ; \nint start = parserGetCurrentPosition ( ) ; \nparserNextWord ( true ) ; \nint end = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nint position = parserGetCurrentPosition ( ) ; \nwhile ( ! parserIsEnded ( ) ) { \nfinal String word = OIOUtils . getStringContent ( parserNextWord ( true ) ) ; \nif ( ! OPatternConst . PATTERN_FETCH_PLAN . matcher ( word ) . matches ( ) ) { \nbreak ; \n} \nend = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nposition = parserGetCurrentPosition ( ) ; \n} \nparserSetCurrentPosition ( position ) ; \nif ( end < 0 ) { \nfetchPlan = OIOUtils . getStringContent ( parserText . substring ( start ) ) ; \n} \nelse { \nfetchPlan = OIOUtils . getStringContent ( parserText . substring ( start , end ) ) ; \n} \nrequest . setFetchPlan ( fetchPlan ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3314": "public class OCommandExecutorSQLSelect { \nprotected boolean parseNoCache ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_NOCACHE ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nnoCache = true ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3315": "public class OCommandExecutorSQLSelect { \nprivate boolean optimizeSort ( OClass iSchemaClass ) { \nOIndexCursor cursor = getOptimizedSortCursor ( iSchemaClass ) ; \nif ( cursor != null ) { \nfetchValuesFromIndexCursor ( cursor ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3337": "public class OBaseParser { \nprotected boolean parserOptionalKeyword ( final String ... iWords ) { \nparserNextWord ( true , \" \\r\\n,\" ) ; \nif ( parserLastWord . length ( ) == 0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nboolean found = iWords . length == 0 ; \nfor ( String w : iWords ) { \nif ( parserLastWord . toString ( ) . equals ( w ) ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) throwSyntaxErrorException ( \"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\" + Arrays . toString ( iWords ) + \"'\" ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3338": "public class OBaseParser { \nprivate boolean parserCheckSeparator ( final char c , final String iSeparatorChars ) { \nfor ( int sepIndex = 0 ; \nsepIndex < iSeparatorChars . length ( ) ; \n++ sepIndex ) { \nif ( iSeparatorChars . charAt ( sepIndex ) == c ) { \nparserLastSeparator = c ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3339": "public class OCommandExecutorSQLDropClass { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( className == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal ODatabaseDocument database = getDatabase ( ) ; \nif ( ifExists && ! database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nfinal OClass cls = database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; \nif ( cls == null ) { \nreturn null ; \n} \nfinal long records = cls . count ( true ) ; \nif ( records > 0 && ! unsafe ) { \nif ( cls . isSubClassOf ( \"V\" ) ) { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to avoid broken edges in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \nelse if ( cls . isSubClassOf ( \"E\" ) ) { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Edges. Use 'DELETE EDGE' command first to avoid broken vertices in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \ndatabase . getMetadata ( ) . getSchema ( ) . dropClass ( className ) ; \nif ( records > 0 && unsafe ) { \nif ( cls . isSubClassOf ( \"V\" ) ) { \nif ( unsafe ) OLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d vertices using UNSAFE mode. Database could contain broken edges\" , className , records ) ; \n} \nelse if ( cls . isSubClassOf ( \"E\" ) ) { \nOLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d edges using UNSAFE mode. Database could contain broken vertices\" , className , records ) ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3344": "public class AccessTokenContextRelay { \npublic boolean copyToken ( ) { \nif ( context . getAccessToken ( ) == null ) { \nAuthentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; \nif ( authentication != null ) { \nObject details = authentication . getDetails ( ) ; \nif ( details instanceof OAuth2AuthenticationDetails ) { \nOAuth2AuthenticationDetails holder = ( OAuth2AuthenticationDetails ) details ; \nString token = holder . getTokenValue ( ) ; \nDefaultOAuth2AccessToken accessToken = new DefaultOAuth2AccessToken ( token ) ; \nString tokenType = holder . getTokenType ( ) ; \nif ( tokenType != null ) { \naccessToken . setTokenType ( tokenType ) ; \n} \ncontext . setAccessToken ( accessToken ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3345": "public class FastBufferedInputStream { \nprotected boolean noMoreCharacters ( ) throws IOException { \nif ( avail == 0 ) { \navail = is . read ( buffer ) ; \nif ( avail <= 0 ) { \navail = 0 ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \npos = 0 ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3347": "public class FastBufferedInputStream { \npublic int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { \nByteArrays . ensureOffsetLength ( array , off , len ) ; \nif ( len == 0 ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nif ( noMoreCharacters ( ) ) return - 1 ; \nint i , k = 0 , remaining = len , read = 0 ; \nfor ( ; \n; \n) { \nfor ( i = 0 ; \ni < avail && i < remaining && ( k = buffer [ pos + i ] ) != '\\n' && k != '\\r' ; \ni ++ ) ; \nSystem . arraycopy ( buffer , pos , array , off + read , i ) ; \npos += i ; \navail -= i ; \nread += i ; \nremaining -= i ; \nif ( remaining == 0 ) { \nreadBytes += read ; \nreturn read ; \n} \nif ( avail > 0 ) { \nif ( k == '\\n' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . LF ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \nelse { \narray [ off + read ++ ] = '\\n' ; \nremaining -- ; \n} \n} \nelse if ( k == '\\r' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . CR_LF ) ) { \nif ( avail > 0 ) { \nif ( buffer [ pos ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \nelse { \nif ( noMoreCharacters ( ) ) { \nif ( ! terminators . contains ( LineTerminator . CR ) ) { \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \nreadBytes += read ; \n} \nelse readBytes += read + 1 ; \nreturn read ; \n} \nif ( buffer [ 0 ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \n} \nif ( terminators . contains ( LineTerminator . CR ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \n} \n} \nelse if ( noMoreCharacters ( ) ) { \nreadBytes += read ; \nreturn read ; \n} \n} \n} \n} \n"}
{"3377": "public class SegmentedByteArray { \npublic boolean rangeEquals ( long rangeStart , SegmentedByteArray compareTo , long cmpStart , int length ) { \nfor ( int i = 0 ; \ni < length ; \ni ++ ) if ( get ( rangeStart + i ) != compareTo . get ( cmpStart + i ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3385": "public class HollowAPIGenerator { \nprotected static boolean hasCollectionsInDataSet ( HollowDataset dataset ) { \nfor ( HollowSchema schema : dataset . getSchemas ( ) ) { \nif ( ( schema instanceof HollowListSchema ) || ( schema instanceof HollowSetSchema ) || ( schema instanceof HollowMapSchema ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3388": "public class HollowPrimaryKeyValueDeriver { \npublic boolean keyMatches ( int ordinal , Object ... keys ) { \nif ( keys . length != fieldPathIndexes . length ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfor ( int i = 0 ; \ni < keys . length ; \ni ++ ) { \nif ( ! keyMatches ( keys [ i ] , ordinal , i ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"3400": "public class GrowingSegmentedLongArray { \npublic long get ( long index ) { \nint segmentIndex = ( int ) ( index >> log2OfSegmentSize ) ; \nif ( segmentIndex >= segments . length || segments [ segmentIndex ] == null ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nint longInSegment = ( int ) ( index & bitmask ) ; \nreturn segments [ segmentIndex ] [ longInSegment ] ; \n} \n} \n"}
{"3422": "public class ByteArrayOrdinalMap { \nprivate boolean compare ( ByteDataBuffer serializedRepresentation , long key ) { \nlong position = key & POINTER_MASK ; \nint sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; \nif ( sizeOfData != serializedRepresentation . length ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nposition += VarInt . sizeOfVInt ( sizeOfData ) ; \nfor ( int i = 0 ; \ni < sizeOfData ; \ni ++ ) { \nif ( serializedRepresentation . get ( i ) != byteData . get ( position ++ ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"3426": "public class HollowIndexerValueTraverser { \npublic boolean isMatchEqual ( int matchIdx , HollowIndexerValueTraverser otherTraverser , int otherMatchIdx ) { \nfor ( int i = 0 ; \ni < getNumFieldPaths ( ) ; \ni ++ ) { \nif ( ! HollowReadFieldUtils . fieldsAreEqual ( ( HollowObjectTypeDataAccess ) fieldTypeDataAccess [ i ] , fieldMatchLists [ i ] . get ( matchIdx ) , fieldSchemaPosition [ i ] , ( HollowObjectTypeDataAccess ) otherTraverser . fieldTypeDataAccess [ i ] , otherTraverser . fieldMatchLists [ i ] . get ( otherMatchIdx ) , otherTraverser . fieldSchemaPosition [ i ] ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3429": "public class HashCodes { \npublic static int hashTableSize ( int numElements ) throws IllegalArgumentException { \nif ( numElements < 0 ) { \nthrow new IllegalArgumentException ( \"cannot be negative; numElements=\" + numElements ) ; \n} \nelse if ( numElements > HASH_TABLE_MAX_SIZE ) { \nthrow new IllegalArgumentException ( \"exceeds maximum number of buckets; numElements=\" + numElements ) ; \n} \nif ( numElements == 0 ) { \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \nif ( numElements < 3 ) return numElements * 2 ; \nint sizeAfterLoadFactor = ( int ) ( ( long ) numElements * 10 / 7 ) ; \nint bits = 32 - Integer . numberOfLeadingZeros ( sizeAfterLoadFactor - 1 ) ; \nreturn 1 << bits ; \n} \n} \n"}
{"3482": "public class ServiceUrlUtil { \nprivate static boolean portsMatch ( ServicePort servicePort , IntOrString intOrString ) { \nif ( intOrString != null ) { \nInteger port = servicePort . getPort ( ) ; \nInteger intVal = intOrString . getIntVal ( ) ; \nString strVal = intOrString . getStrVal ( ) ; \nif ( intVal != null ) { \nif ( port != null ) { \nreturn port . intValue ( ) == intVal . intValue ( ) ; \n} \nelse { \n} \n} \nelse if ( strVal != null ) { \nreturn Objects . equal ( strVal , servicePort . getName ( ) ) ; \n} \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"3493": "public class KubernetesHelper { \npublic static boolean isPodReady ( Pod pod ) { \nif ( ! isPodRunning ( pod ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nPodStatus podStatus = pod . getStatus ( ) ; \nif ( podStatus == null ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nList < PodCondition > conditions = podStatus . getConditions ( ) ; \nif ( conditions == null || conditions . isEmpty ( ) ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nfor ( PodCondition condition : conditions ) { \nif ( \"ready\" . equalsIgnoreCase ( condition . getType ( ) ) ) { \nreturn Boolean . parseBoolean ( condition . getStatus ( ) ) ; \n} \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"3496": "public class MavenUtil { \npublic static boolean hasResource ( MavenProject project , String ... paths ) { \nURLClassLoader compileClassLoader = getCompileClassLoader ( project ) ; \nfor ( String path : paths ) { \ntry { \nif ( compileClassLoader . getResource ( path ) != null ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \ncatch ( Throwable e ) { \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3501": "public class KubernetesResourceUtil { \nprivate static boolean isLocalCustomisation ( PodSpec podSpec ) { \nList < Container > containers = podSpec . getContainers ( ) != null ? podSpec . getContainers ( ) : Collections . < Container > emptyList ( ) ; \nfor ( Container container : containers ) { \nif ( StringUtils . isNotBlank ( container . getImage ( ) ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3508": "public class VersionUtil { \npublic static int compareVersions ( String v1 , String v2 ) { \nString [ ] components1 = split ( v1 ) ; \nString [ ] components2 = split ( v2 ) ; \nint diff ; \nint length = Math . min ( components1 . length , components2 . length ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) { \nString s1 = components1 [ i ] ; \nString s2 = components2 [ i ] ; \nInteger i1 = tryParseInteger ( s1 ) ; \nInteger i2 = tryParseInteger ( s2 ) ; \nif ( i1 != null && i2 != null ) { \ndiff = i1 . compareTo ( i2 ) ; \n} \nelse { \ndiff = s1 . compareTo ( s2 ) ; \n} \nif ( diff != 0 ) { \nreturn diff ; \n} \n} \ndiff = Integer . compare ( components1 . length , components2 . length ) ; \nif ( diff == 0 ) { \nif ( v1 == v2 ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n; \nreturn v1 != null ? v1 . compareTo ( v2 ) : - 1 ; \n} \nreturn diff ; \n} \n} \n"}
{"3517": "public class BaseEnricher { \nprotected boolean isOpenShiftMode ( ) { \nProperties properties = getContext ( ) . getConfiguration ( ) . getProperties ( ) ; \nif ( properties != null ) { \nreturn RuntimeMode . isOpenShiftMode ( properties ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"3522": "public class ApplyService { \npublic boolean applyNamespace ( Namespace entity ) { \nString namespace = getOrCreateMetadata ( entity ) . getName ( ) ; \nlog . info ( \"Using namespace: \" + namespace ) ; \nString name = getName ( entity ) ; \nObjects . requireNonNull ( name , \"No name for \" + entity ) ; \nNamespace old = kubernetesClient . namespaces ( ) . withName ( name ) . get ( ) ; \nif ( ! isRunning ( old ) ) { \ntry { \nObject answer = kubernetesClient . namespaces ( ) . create ( entity ) ; \nlogGeneratedEntity ( \"Created namespace: \" , namespace , entity , answer ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Exception e ) { \nonApplyError ( \"Failed to create namespace: \" + name + \" due \" + e . getMessage ( ) , e ) ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3524": "public class ApplyService { \npublic boolean applyProjectRequest ( ProjectRequest entity ) { \nString namespace = getOrCreateMetadata ( entity ) . getName ( ) ; \nlog . info ( \"Using project: \" + namespace ) ; \nString name = getName ( entity ) ; \nObjects . requireNonNull ( name , \"No name for \" + entity ) ; \nOpenShiftClient openshiftClient = getOpenShiftClient ( ) ; \nif ( openshiftClient == null ) { \nlog . warn ( \"Cannot check for Project \" + namespace + \" as not running against OpenShift!\" ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nboolean exists = checkNamespace ( name ) ; \nif ( ! exists ) { \ntry { \nObject answer = openshiftClient . projectrequests ( ) . create ( entity ) ; \nlogGeneratedEntity ( \"Created ProjectRequest: \" , namespace , entity , answer ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \ncatch ( Exception e ) { \nonApplyError ( \"Failed to create ProjectRequest: \" + name + \" due \" + e . getMessage ( ) , e ) ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"3534": "public class ApplyMojo { \nprivate boolean serviceHasIngressRule ( List < Ingress > ingresses , Service service ) { \nString serviceName = KubernetesHelper . getName ( service ) ; \nfor ( Ingress ingress : ingresses ) { \nIngressSpec spec = ingress . getSpec ( ) ; \nif ( spec == null ) { \nbreak ; \n} \nList < IngressRule > rules = spec . getRules ( ) ; \nif ( rules == null ) { \nbreak ; \n} \nfor ( IngressRule rule : rules ) { \nHTTPIngressRuleValue http = rule . getHttp ( ) ; \nif ( http == null ) { \nbreak ; \n} \nList < HTTPIngressPath > paths = http . getPaths ( ) ; \nif ( paths == null ) { \nbreak ; \n} \nfor ( HTTPIngressPath path : paths ) { \nIngressBackend backend = path . getBackend ( ) ; \nif ( backend == null ) { \nbreak ; \n} \nif ( Objects . equals ( serviceName , backend . getServiceName ( ) ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3574": "public class SignatureVerification { \n@ SuppressLint ( \"PackageManagerGetSignatures\" ) public static boolean isSignatureValid ( Context context , String packageName , String certificateSubject , String certificateIssuer , int publicKeyHashCode ) { \nif ( ! sEnableSignatureVerification ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nPackageManager packageManager = context . getPackageManager ( ) ; \nSignature [ ] signatures ; \ntry { \nsignatures = packageManager . getPackageInfo ( packageName , PackageManager . GET_SIGNATURES ) . signatures ; \n} \ncatch ( NameNotFoundException e ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nInputStream certStream = null ; \nboolean validated = ( signatures . length != 0 ) ; \nfor ( Signature signature : signatures ) { \ntry { \ncertStream = new ByteArrayInputStream ( signature . toByteArray ( ) ) ; \nX509Certificate x509Cert = ( X509Certificate ) CertificateFactory . getInstance ( \"X509\" ) . generateCertificate ( certStream ) ; \nString subject = x509Cert . getSubjectX500Principal ( ) . getName ( ) ; \nString issuer = x509Cert . getIssuerX500Principal ( ) . getName ( ) ; \nint actualPublicKeyHashCode = x509Cert . getPublicKey ( ) . hashCode ( ) ; \nvalidated &= ( certificateSubject . equals ( subject ) && certificateIssuer . equals ( issuer ) && publicKeyHashCode == actualPublicKeyHashCode ) ; \nif ( ! validated ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \ncatch ( CertificateException e ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \nfinally { \ntry { \nif ( certStream != null ) { \ncertStream . close ( ) ; \n} \n} \ncatch ( IOException ignored ) { \n} \n} \n} \nreturn validated ; \n} \n} \n"}
{"3602": "public class InplaceMP4Editor { \npublic boolean modify ( File file , MP4Edit edit ) throws IOException { \nSeekableByteChannel fi = null ; \ntry { \nfi = NIOUtils . rwChannel ( file ) ; \nList < Tuple . _2 < Atom , ByteBuffer > > fragments = doTheFix ( fi , edit ) ; \nif ( fragments == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfor ( Tuple . _2 < Atom , ByteBuffer > fragment : fragments ) { \nreplaceBox ( fi , fragment . v0 , fragment . v1 ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nfinally { \nNIOUtils . closeQuietly ( fi ) ; \n} \n} \n} \n"}
{"3603": "public class InplaceMP4Editor { \npublic boolean copy ( File src , File dst , MP4Edit edit ) throws IOException { \nSeekableByteChannel fi = null ; \nSeekableByteChannel fo = null ; \ntry { \nfi = NIOUtils . readableChannel ( src ) ; \nfo = NIOUtils . writableChannel ( dst ) ; \nList < Tuple . _2 < Atom , ByteBuffer > > fragments = doTheFix ( fi , edit ) ; \nif ( fragments == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nList < _2 < Long , ByteBuffer > > fragOffsets = Tuple . _2map0 ( fragments , new Tuple . Mapper < Atom , Long > ( ) { \npublic Long map ( Atom t ) { \nreturn t . getOffset ( ) ; \n} \n} \n) ; \nMap < Long , ByteBuffer > rewrite = Tuple . asMap ( fragOffsets ) ; \nfor ( Atom atom : MP4Util . getRootAtoms ( fi ) ) { \nByteBuffer byteBuffer = rewrite . get ( atom . getOffset ( ) ) ; \nif ( byteBuffer != null ) fo . write ( byteBuffer ) ; \nelse atom . copy ( fi , fo ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nfinally { \nNIOUtils . closeQuietly ( fi ) ; \nNIOUtils . closeQuietly ( fo ) ; \n} \n} \n} \n"}
{"3615": "public class ColorSpace { \npublic boolean matches ( ColorSpace inputColor ) { \nif ( inputColor == this ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( inputColor == ANY || this == ANY ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nif ( ( inputColor == ANY_INTERLEAVED || this == ANY_INTERLEAVED || inputColor == ANY_PLANAR || this == ANY_PLANAR ) && inputColor . planar == this . planar ) { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"3630": "public class EbmlUtil { \npublic static int ebmlLength ( long v ) { \nif ( v == 0 ) { \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \nint length = 8 ; \nwhile ( length > 0 && ( v & ebmlLengthMasks [ length ] ) == 0 ) length -- ; \nreturn length ; \n} \n} \n"}
{"3632": "public class FLVReader { \npublic boolean repositionFile ( ) throws IOException { \nint payloadSize = 0 ; \nfor ( int i = 0 ; \ni < REPOSITION_BUFFER_READS ; \ni ++ ) { \nwhile ( readBuf . hasRemaining ( ) ) { \npayloadSize = ( ( payloadSize & 0xffff ) << 8 ) | ( readBuf . get ( ) & 0xff ) ; \nint pointerPos = readBuf . position ( ) + 7 + payloadSize ; \nif ( readBuf . position ( ) >= 8 && pointerPos < readBuf . limit ( ) - 4 && readBuf . getInt ( pointerPos ) - payloadSize == 11 ) { \nreadBuf . position ( readBuf . position ( ) - 8 ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \ninitialRead ( ch ) ; \nif ( ! readBuf . hasRemaining ( ) ) break ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3634": "public class MDecoder { \npublic int decodeBinBypass ( ) { \ncode <<= 1 ; \n-- nBitsPending ; \nif ( nBitsPending <= 0 ) readOneByte ( ) ; \nint tmp = code - ( range << 8 ) ; \nif ( tmp < 0 ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nelse { \ncode = tmp ; \n{ \nint return_variable_1 = 1 ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"3646": "public class GainControl { \nprivate int getGainChangePointID ( int lngain ) { \nfor ( int i = 0 ; \ni < ID_GAIN ; \ni ++ ) { \nif ( lngain == LN_GAIN [ i ] ) return i ; \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"3664": "public class JNIMemoryManager { \nfinal boolean addReference ( final JNIReference ref ) { \nboolean gotNonblockingLock = false ; \ngotNonblockingLock = mSpinLock . compareAndSet ( false , true ) ; \nif ( gotNonblockingLock ) { \nfinal int slot = mNextAvailableReferenceSlot ++ ; \nif ( slot < mMaxValidReference ) { \nmValidReferences [ slot ] = ref ; \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never be unlocked here\" ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( ! mLock . tryLock ( ) ) { \ngotNonblockingLock = false ; \nmSpinLock . compareAndSet ( true , false ) ; \n} \n} \nif ( ! gotNonblockingLock ) { \nmLock . lock ( ) ; \nwhile ( ! mSpinLock . compareAndSet ( false , true ) ) ; \n} \ntry { \nint slot = mNextAvailableReferenceSlot ++ ; \nif ( slot >= mMaxValidReference ) { \nsweepAndCollect ( ) ; \nslot = mNextAvailableReferenceSlot ++ ; \n} \nmValidReferences [ slot ] = ref ; \n} \nfinally { \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never ever be unlocked here\" ; \nmLock . unlock ( ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3668": "public class JNILibrary { \nprivate boolean unpackLibrary ( String path ) { \nboolean retval = false ; \ntry { \nfinal Enumeration < URL > c = JNILibrary . class . getClassLoader ( ) . getResources ( path ) ; \nwhile ( c . hasMoreElements ( ) ) { \nfinal URL url = c . nextElement ( ) ; \nlog . trace ( \"path: {}; url: {}\" , path , url ) ; \nif ( url == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nboolean unpacked = false ; \nFile lib ; \nif ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"file\" ) ) { \ntry { \nlib = new File ( new URI ( url . toString ( ) ) ) ; \n} \ncatch ( URISyntaxException e ) { \nlib = new File ( url . getPath ( ) ) ; \n} \nif ( ! lib . exists ( ) ) { \nlog . error ( \"Unpacked library not unpacked correctedly;  url: {}\" , url ) ; \ncontinue ; \n} \n} \nelse if ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"jar\" ) ) { \nInputStream stream = url . openStream ( ) ; \nif ( stream == null ) { \nlog . error ( \"could not get stream for resource: {}\" , url . getPath ( ) ) ; \ncontinue ; \n} \nFileOutputStream out = null ; \ntry { \nFile dir = getTmpDir ( ) ; \nlib = File . createTempFile ( \"humble\" , JNIEnv . getEnv ( ) . getOSFamily ( ) == JNIEnv . OSFamily . WINDOWS ? \".dll\" : null , dir ) ; \nlib . deleteOnExit ( ) ; \nout = new FileOutputStream ( lib ) ; \nint bytesRead = 0 ; \nfinal byte [ ] buffer = new byte [ 2048 ] ; \nwhile ( ( bytesRead = stream . read ( buffer , 0 , buffer . length ) ) > 0 ) { \nout . write ( buffer , 0 , bytesRead ) ; \n} \nunpacked = true ; \n} \ncatch ( IOException e ) { \nlog . error ( \"could not create temp file: {}\" , e ) ; \ncontinue ; \n} \nfinally { \ntry { \nstream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \nif ( out != null ) try { \nout . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \ntry { \ndoJNILoad ( lib . getAbsolutePath ( ) ) ; \nretval = true ; \nbreak ; \n} \ncatch ( UnsatisfiedLinkError e ) { \n} \nfinally { \nif ( unpacked ) { \ndeleteUnpackedFile ( lib . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \n} \ncatch ( IOException e1 ) { \nretval = false ; \n} \nreturn retval ; \n} \n} \n"}
{"3733": "public class FSTClazzLineageInfo { \npublic static int getSpecificity ( final Class < ? > clazz ) { \nif ( clazz == null ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nfinal LineageInfo lineageInfo = FSTClazzLineageInfo . getLineageInfo ( clazz ) ; \nreturn lineageInfo == null ? 0 : lineageInfo . specificity ; \n} \n} \n"}
{"3773": "public class CheckSocket { \npublic static boolean remotePortTaken ( String node , int port , int timeout ) { \nSocket s = null ; \ntry { \ns = new Socket ( ) ; \ns . setReuseAddress ( true ) ; \nSocketAddress sa = new InetSocketAddress ( node , port ) ; \ns . connect ( sa , timeout * 1000 ) ; \n} \ncatch ( IOException e ) { \nif ( e . getMessage ( ) . equals ( \"Connection refused\" ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( e instanceof SocketTimeoutException || e instanceof UnknownHostException ) { \nthrow e ; \n} \n} \nfinally { \nif ( s != null ) { \nif ( s . isConnected ( ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nelse { \n} \ntry { \ns . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n"}
{"3778": "public class BooleanIndexing { \npublic static boolean and ( final INDArray n , final Condition cond ) { \nif ( cond instanceof BaseCondition ) { \nlong val = ( long ) Nd4j . getExecutioner ( ) . exec ( new MatchCondition ( n , cond ) , Integer . MAX_VALUE ) . getDouble ( 0 ) ; \nif ( val == n . lengthLong ( ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nelse { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nelse { \nboolean ret = true ; \nfinal AtomicBoolean a = new AtomicBoolean ( ret ) ; \nShape . iterate ( n , new CoordinateFunction ( ) { \n@ Override public void process ( long [ ] ... coord ) { \nif ( a . get ( ) ) a . compareAndSet ( true , a . get ( ) && cond . apply ( n . getDouble ( coord [ 0 ] ) ) ) ; \n} \n} \n) ; \nreturn a . get ( ) ; \n} \n} \n} \n"}
{"3835": "public class Shape { \npublic static boolean isVector ( DataBuffer shapeInfo ) { \nint rank = Shape . rank ( shapeInfo ) ; \nif ( rank > 2 || rank < 1 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nelse { \nint len = Shape . length ( shapeInfo ) ; \nDataBuffer shape = Shape . shapeOf ( shapeInfo ) ; \nreturn shape . getInt ( 0 ) == len || shape . getInt ( 1 ) == len ; \n} \n} \n} \n"}
{"3858": "public class Paths { \npublic static boolean nameExistsInPath ( String name ) { \nString path = System . getenv ( PATH_ENV_VARIABLE ) ; \nString [ ] dirs = path . split ( File . pathSeparator ) ; \nfor ( String dir : dirs ) { \nFile dirFile = new File ( dir ) ; \nif ( ! dirFile . exists ( ) ) continue ; \nif ( dirFile . isFile ( ) && dirFile . getName ( ) . equals ( name ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nelse { \nIterator < File > files = FileUtils . iterateFiles ( dirFile , null , false ) ; \nwhile ( files . hasNext ( ) ) { \nFile curr = files . next ( ) ; \nif ( curr . getName ( ) . equals ( name ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"3869": "public class CudaAffinityManager { \n@ Override public Integer getDeviceForThread ( long threadId ) { \nif ( getNumberOfDevices ( ) == 1 ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nInteger aff = affinityMap . get ( threadId ) ; \nif ( aff == null ) { \nInteger deviceId = getNextDevice ( threadId ) ; \naffinityMap . put ( threadId , deviceId ) ; \naffiliated . set ( new AtomicBoolean ( false ) ) ; \nif ( threadId == Thread . currentThread ( ) . getId ( ) ) { \nNativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . setDevice ( new CudaPointer ( deviceId ) ) ; \naffiliated . get ( ) . set ( true ) ; \n} \nreturn deviceId ; \n} \nelse { \nif ( threadId == Thread . currentThread ( ) . getId ( ) ) { \nif ( affiliated . get ( ) == null ) affiliated . set ( new AtomicBoolean ( false ) ) ; \nif ( ! affiliated . get ( ) . get ( ) ) { \nNativeOpsHolder . getInstance ( ) . getDeviceNativeOps ( ) . setDevice ( new CudaPointer ( aff ) ) ; \naffiliated . get ( ) . set ( true ) ; \nreturn aff ; \n} \n} \nreturn aff ; \n} \n} \n} \n"}
{"3924": "public class SameDiff { \npublic boolean hasArgs ( DifferentialFunction function ) { \nval vertexIdArgs = incomingArgsReverse . get ( function . getOwnName ( ) ) ; \nif ( vertexIdArgs != null ) { \nval args = incomingArgs . get ( vertexIdArgs ) ; \nif ( args != null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"3940": "public class DataTypeUtil { \npublic static int lengthForDtype ( DataBuffer . Type type ) { \nswitch ( type ) { \ncase DOUBLE : { \nint return_variable_0 = 8 ; \nreturn return_variable_0 ; \n} \ncase FLOAT : { \nint return_variable_1 = 4 ; \nreturn return_variable_1 ; \n} \ncase INT : { \nint return_variable_2 = 4 ; \nreturn return_variable_2 ; \n} \ncase HALF : { \nint return_variable_3 = 2 ; \nreturn return_variable_3 ; \n} \ncase LONG : { \nint return_variable_4 = 8 ; \nreturn return_variable_4 ; \n} \ncase COMPRESSED : default : throw new IllegalArgumentException ( \"Illegal opType for length\" ) ; \n} \n} \n} \n"}
{"3955": "public class AtomicState { \npublic boolean tryRequestToe ( ) { \nscheduleToe ( ) ; \nif ( isToeWaiting . get ( ) || getCurrentState ( ) == AccessState . TOE ) { \ndiscardScheduledToe ( ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse { \ndiscardScheduledToe ( ) ; \nrequestToe ( ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"3968": "public class DifferentialFunction { \npublic boolean hasPlaceHolderInputs ( ) { \nval args = args ( ) ; \nfor ( val arg : args ) if ( sameDiff . hasPlaceHolderVariables ( arg ( ) . getVarName ( ) ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4020": "public class GenericTypeReflector { \nstatic boolean isMissingTypeParameters ( Type type ) { \nif ( type instanceof Class ) { \nfor ( Class < ? > clazz = ( Class < ? > ) type ; \nclazz != null ; \nclazz = clazz . getEnclosingClass ( ) ) { \nif ( clazz . getTypeParameters ( ) . length != 0 ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nelse if ( type instanceof ParameterizedType ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nelse { \nthrow new AssertionError ( \"Unexpected type \" + type . getClass ( ) ) ; \n} \n} \n} \n"}
{"4021": "public class GenericTypeReflector { \npublic static boolean isSuperType ( Type superType , Type subType ) { \nif ( superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType ) { \nClass < ? > superClass = erase ( superType ) ; \nType mappedSubType = getExactSuperType ( capture ( subType ) , superClass ) ; \nif ( mappedSubType == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse if ( superType instanceof Class < ? > ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nelse if ( mappedSubType instanceof Class < ? > ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nelse if ( mappedSubType instanceof GenericArrayType ) { \nType superComponentType = getArrayComponentType ( superType ) ; \nassert superComponentType != null ; \nType mappedSubComponentType = getArrayComponentType ( mappedSubType ) ; \nassert mappedSubComponentType != null ; \nreturn isSuperType ( superComponentType , mappedSubComponentType ) ; \n} \nelse { \nassert mappedSubType instanceof ParameterizedType ; \nParameterizedType pMappedSubType = ( ParameterizedType ) mappedSubType ; \nassert pMappedSubType . getRawType ( ) == superClass ; \nParameterizedType pSuperType = ( ParameterizedType ) superType ; \nType [ ] superTypeArgs = pSuperType . getActualTypeArguments ( ) ; \nType [ ] subTypeArgs = pMappedSubType . getActualTypeArguments ( ) ; \nassert superTypeArgs . length == subTypeArgs . length ; \nfor ( int i = 0 ; \ni < superTypeArgs . length ; \ni ++ ) { \nif ( ! contains ( superTypeArgs [ i ] , subTypeArgs [ i ] ) ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \nreturn pSuperType . getOwnerType ( ) == null || isSuperType ( pSuperType . getOwnerType ( ) , pMappedSubType . getOwnerType ( ) ) ; \n} \n} \nelse if ( superType instanceof CaptureType ) { \nif ( superType . equals ( subType ) ) { \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \nfor ( Type lowerBound : ( ( CaptureType ) superType ) . getLowerBounds ( ) ) { \nif ( isSuperType ( lowerBound , subType ) ) { \n{ \nboolean return_variable_5 = true ; \nreturn return_variable_5 ; \n} \n} \n} \n{ \nboolean return_variable_6 = false ; \nreturn return_variable_6 ; \n} \n} \nelse if ( superType instanceof GenericArrayType ) { \nreturn isArraySupertype ( superType , subType ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented: \" + superType . getClass ( ) ) ; \n} \n} \n} \n"}
{"4026": "public class ClassPopulator { \nprivate Boolean getIndexInstruction ( Class < P > clazz ) { \nIndex ind = clazz . getAnnotation ( Index . class ) ; \nUnindex unind = clazz . getAnnotation ( Unindex . class ) ; \nif ( ind != null && unind != null ) throw new IllegalStateException ( \"You cannot have @Index and @Unindex on the same class: \" + clazz ) ; \nif ( ind != null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nelse if ( unind != null ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nelse return null ; \n} \n} \n"}
{"4027": "public class ClassPopulator { \nprivate boolean isOfInterest ( Method method ) { \nfor ( Annotation [ ] annos : method . getParameterAnnotations ( ) ) if ( TypeUtils . getAnnotation ( annos , AlsoLoad . class ) != null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4030": "public class Round { \npublic < T > Result < T > get ( final Key < T > key ) { \nassert ! isExecuted ( ) ; \nSessionValue < T > sv = getSession ( ) . get ( key ) ; \nif ( sv == null ) { \nlog . trace ( \"Adding to round (session miss): {}\" , key ) ; \nthis . pending . add ( key . getRaw ( ) ) ; \nResult < T > result = new ResultCache < T > ( ) { \n@ Override @ SuppressWarnings ( \"unchecked\" ) public T nowUncached ( ) { \nloadEngine . execute ( ) ; \nreturn ( T ) translated . now ( ) . get ( key ) ; \n} \n@ Override public String toString ( ) { \nreturn \"(Fetch result for \" + key + \")\" ; \n} \n} \n; \nsv = new SessionValue < > ( result , getLoadArrangement ( ) ) ; \ngetSession ( ) . add ( key , sv ) ; \n} \nelse { \nlog . trace ( \"Adding to round (session hit): {}\" , key ) ; \nif ( sv . loadWith ( getLoadArrangement ( ) ) ) { \nlog . trace ( \"New load group arrangement, checking for upgrades: {}\" , getLoadArrangement ( ) ) ; \nT thing = sv . getResult ( ) . now ( ) ; \nif ( thing != null ) { \nSaveContext saveCtx = new SaveContext ( ) { \n@ Override public boolean skipLifecycle ( ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n@ Override public com . google . cloud . datastore . Key saveRef ( Ref < ? > value , LoadConditions loadConditions ) { \ncom . google . cloud . datastore . Key key = super . saveRef ( value , loadConditions ) ; \nif ( loadEngine . shouldLoad ( loadConditions ) ) { \nlog . trace ( \"Upgrading key {}\" , key ) ; \nloadEngine . load ( value . key ( ) ) ; \n} \nreturn key ; \n} \n} \n; \nloadEngine . ofy . factory ( ) . getMetadataForEntity ( thing ) . save ( thing , saveCtx ) ; \n} \n} \n} \nreturn sv . getResult ( ) ; \n} \n} \n"}
{"4051": "public class TypeFactory { \nprivate static boolean couldHaveCommonSubtype ( Type type1 , Type type2 ) { \nClass < ? > erased1 = GenericTypeReflector . erase ( type1 ) ; \nClass < ? > erased2 = GenericTypeReflector . erase ( type2 ) ; \nif ( ! erased1 . isInterface ( ) && ! erased2 . isInterface ( ) ) { \nif ( ! erased1 . isAssignableFrom ( erased2 ) && ! erased2 . isAssignableFrom ( erased1 ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4067": "public class FieldProperty { \nprivate boolean matches ( Object onPojo , If < ? , ? > [ ] conditions ) { \nif ( conditions == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nObject value = this . get ( onPojo ) ; \nfor ( If < ? , ? > condition : conditions ) { \n@ SuppressWarnings ( \"unchecked\" ) If < Object , Object > cond = ( If < Object , Object > ) condition ; \nif ( cond . matchesValue ( value ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nif ( cond . matchesPojo ( onPojo ) ) { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"4093": "public class AbstractOpenRtbJsonWriter { \nprotected final boolean writeContentCategory ( String cat , JsonGenerator gen ) throws IOException { \nif ( ! factory . isStrict ( ) || OpenRtbUtils . categoryFromName ( cat ) != null ) { \ngen . writeString ( cat ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"4135": "public class SiteMapParserBolt { \nprivate final boolean sniff ( byte [ ] content ) { \nbyte [ ] beginning = content ; \nif ( content . length > maxOffsetGuess && maxOffsetGuess > 0 ) { \nbeginning = Arrays . copyOfRange ( content , 0 , maxOffsetGuess ) ; \n} \nint position = Bytes . indexOf ( beginning , clue ) ; \nif ( position != - 1 ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4139": "public class CookieConverter { \npublic static boolean checkDomainMatchToUrl ( String cookieDomain , String urlHostName ) { \ntry { \nif ( cookieDomain . startsWith ( \".\" ) ) { \ncookieDomain = cookieDomain . substring ( 1 ) ; \n} \nString [ ] domainTokens = cookieDomain . split ( \"\\\\.\" ) ; \nString [ ] hostTokens = urlHostName . split ( \"\\\\.\" ) ; \nint tokenDif = hostTokens . length - domainTokens . length ; \nif ( tokenDif < 0 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfor ( int i = domainTokens . length - 1 ; \ni >= 0 ; \ni -- ) { \nif ( ! domainTokens [ i ] . equalsIgnoreCase ( hostTokens [ i + tokenDif ] ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \ncatch ( Exception e ) { \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n} \n"}
{"4144": "public class Rules { \npublic boolean filter ( String url , Metadata metadata ) throws MalformedURLException { \nURL u = new URL ( url ) ; \nString hostname = u . getHost ( ) ; \nif ( checkScope ( hostNameRules . get ( hostname ) , u ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nString [ ] domainParts = hostname . split ( \"\\\\.\" ) ; \nString domain = null ; \nfor ( int i = domainParts . length - 1 ; \ni >= 0 ; \ni -- ) { \ndomain = domainParts [ i ] + ( domain == null ? \"\" : \".\" + domain ) ; \nif ( checkScope ( domainRules . get ( domain ) , u ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \nfor ( MDScope scope : metadataRules ) { \nString [ ] vals = metadata . getValues ( scope . getKey ( ) ) ; \nif ( vals == null ) { \ncontinue ; \n} \nfor ( String v : vals ) { \nif ( v . equalsIgnoreCase ( scope . getValue ( ) ) ) { \nFastURLFilter . LOG . debug ( \"Filtering {} matching metadata {}:{}\" , url , scope . getKey ( ) , scope . getValue ( ) ) ; \nif ( checkScope ( scope , u ) ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n} \nif ( checkScope ( globalRules , u ) ) { \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"4151": "public class AbstractQueryingSpout { \nprivate boolean triggerQueries ( ) { \nif ( timeLastQueryReceived != 0 && maxDelayBetweenQueries > 0 ) { \nlong difference = System . currentTimeMillis ( ) - timeLastQueryReceived ; \nif ( difference > maxDelayBetweenQueries ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4189": "public class DateRange { \npublic boolean included ( Date d ) { \nif ( isEmpty ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( getStart ( ) . after ( d ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( getEnd ( ) . before ( d ) ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"4210": "public class FeatureDatasetFactoryManager { \nstatic public boolean featureTypeOk ( FeatureType want , FeatureType facType ) { \nif ( want == null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( want == facType ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nif ( want == FeatureType . ANY_POINT ) { \nreturn facType . isPointFeatureType ( ) ; \n} \nif ( facType == FeatureType . ANY_POINT ) { \nreturn want . isPointFeatureType ( ) ; \n} \nif ( want == FeatureType . COVERAGE ) { \nreturn facType . isCoverageFeatureType ( ) ; \n} \nif ( want == FeatureType . GRID ) { \nreturn facType . isCoverageFeatureType ( ) ; \n} \nif ( want == FeatureType . SIMPLE_GEOMETRY ) { \nreturn facType . isCoverageFeatureType ( ) ; \n} \nif ( want == FeatureType . UGRID ) { \nreturn facType . isUnstructuredGridFeatureType ( ) ; \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"4228": "public class NOWRadheader { \nint readTop ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint pos = 0 ; \nraf . seek ( pos ) ; \nint readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nint rc = raf . read ( b ) ; \nif ( rc != readLen ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nif ( ( convertunsignedByte2Short ( b [ 0 ] ) != 0x00 ) || ( convertunsignedByte2Short ( b [ 1 ] ) != 0xF0 ) || ( convertunsignedByte2Short ( b [ 2 ] ) != 0x09 ) ) { \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \nString pidd = new String ( b , 15 , 5 , CDM . utf8Charset ) ; \nif ( pidd . contains ( \"NOWRA\" ) || pidd . contains ( \"USRAD\" ) || pidd . contains ( \"NEX\" ) ) { \n{ \nint return_variable_2 = 1 ; \nreturn return_variable_2 ; \n} \n} \nelse { \n{ \nint return_variable_3 = 0 ; \nreturn return_variable_3 ; \n} \n} \n} \n} \n"}
{"4240": "public class GradsTimeDimension { \npublic static boolean hasTimeTemplate ( String template ) { \nfor ( int i = 0 ; \ni < timeTemplates . length ; \ni ++ ) { \nif ( template . indexOf ( timeTemplates [ i ] ) >= 0 ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4249": "public class McIDASLookup { \npublic final boolean isVerticalCoordinate ( GridRecord gr ) { \nif ( cust != null ) { \nreturn cust . isVerticalCoordinate ( gr . getLevelType1 ( ) ) ; \n} \nint type = gr . getLevelType1 ( ) ; \nif ( ( ( McIDASGridRecord ) gr ) . hasGribInfo ( ) ) { \nif ( type == 20 ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( type == 100 ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nif ( type == 101 ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nif ( ( type >= 103 ) && ( type <= 128 ) ) { \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \nif ( type == 141 ) { \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \nif ( type == 160 ) { \n{ \nboolean return_variable_5 = true ; \nreturn return_variable_5 ; \n} \n} \n} \nelse if ( getLevelUnit ( gr ) . equals ( \"hPa\" ) ) { \n{ \nboolean return_variable_6 = true ; \nreturn return_variable_6 ; \n} \n} \n{ \nboolean return_variable_7 = false ; \nreturn return_variable_7 ; \n} \n} \n} \n"}
{"4250": "public class McIDASLookup { \npublic boolean isLayer ( GridRecord gr ) { \nif ( cust != null ) { \nreturn cust . isLayer ( gr . getLevelType1 ( ) ) ; \n} \nif ( gr . getLevel2 ( ) == 0 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4294": "public class CDMUtil { \nstatic public boolean containsVLEN ( List < Dimension > dimset ) { \nif ( dimset == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfor ( Dimension dim : dimset ) { \nif ( dim . isVariableLength ( ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"4311": "public class Level2Record { \npublic int getGateCount ( int datatype ) { \nswitch ( datatype ) { \ncase REFLECTIVITY : return ( ( int ) reflect_gate_count ) ; \ncase VELOCITY_HI : case VELOCITY_LOW : case SPECTRUM_WIDTH : return ( ( int ) doppler_gate_count ) ; \ncase REFLECTIVITY_HIGH : return ( ( int ) reflectHR_gate_count ) ; \ncase VELOCITY_HIGH : return ( ( int ) velocityHR_gate_count ) ; \ncase SPECTRUM_WIDTH_HIGH : return ( ( int ) spectrumHR_gate_count ) ; \ncase DIFF_REFLECTIVITY_HIGH : return ( ( int ) zdrHR_gate_count ) ; \ncase DIFF_PHASE : return ( ( int ) phiHR_gate_count ) ; \ncase CORRELATION_COEFFICIENT : return ( ( int ) rhoHR_gate_count ) ; \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"4319": "public class CalendarDateUnit { \npublic double makeOffsetFromRefDate ( CalendarDate date ) { \nif ( isCalendarField ) { \nif ( date . equals ( baseDate ) ) { \ndouble return_variable_0 = 0.0 ; \nreturn return_variable_0 ; \n} \nreturn date . getDifference ( baseDate , periodField ) ; \n} \nelse { \nlong msecs = date . getDifferenceInMsecs ( baseDate ) ; \nreturn msecs / period . getValueInMillisecs ( ) ; \n} \n} \n} \n"}
{"4322": "public class SigmetIOServiceProvider { \npublic boolean isValidFile ( ucar . unidata . io . RandomAccessFile raf ) { \ntry { \nraf . order ( RandomAccessFile . LITTLE_ENDIAN ) ; \nraf . seek ( 0 ) ; \nshort [ ] data = new short [ 13 ] ; \nraf . readShort ( data , 0 , 13 ) ; \nreturn ( data [ 0 ] == ( short ) 27 && data [ 6 ] == ( short ) 26 && data [ 12 ] == ( short ) 15 ) ; \n} \ncatch ( IOException ioe ) { \nSystem . out . println ( \"In isValidFile(): \" + ioe . toString ( ) ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"4376": "public class GridHorizCoordSys { \nprivate boolean makeProjection ( NetcdfFile ncfile , int projType ) { \nswitch ( projType ) { \ncase GridTableLookup . RotatedLatLon : makeRotatedLatLon ( ncfile ) ; \nbreak ; \ncase GridTableLookup . PolarStereographic : makePS ( ) ; \nbreak ; \ncase GridTableLookup . LambertConformal : makeLC ( ) ; \nbreak ; \ncase GridTableLookup . Mercator : makeMercator ( ) ; \nbreak ; \ncase GridTableLookup . Orthographic : makeMSGgeostationary ( ) ; \nbreak ; \ncase GridTableLookup . Curvilinear : makeCurvilinearAxis ( ncfile ) ; \nbreak ; \ndefault : throw new UnsupportedOperationException ( \"unknown projection = \" + gds . getInt ( GridDefRecord . GRID_TYPE ) ) ; \n} \nVariable v = new Variable ( ncfile , g , null , grid_name ) ; \nv . setDataType ( DataType . CHAR ) ; \nv . setDimensions ( \"\" ) ; \nchar [ ] data = new char [ ] { \n'd' } \n; \nArray dataArray = Array . factory ( DataType . CHAR , new int [ 0 ] , data ) ; \nv . setCachedData ( dataArray , false ) ; \nfor ( Attribute att : attributes ) v . addAttribute ( att ) ; \nv . addAttribute ( new Attribute ( GridCF . EARTH_SHAPE , shape_name ) ) ; \ndouble radius_spherical_earth = gds . getDouble ( GridDefRecord . RADIUS_SPHERICAL_EARTH ) ; \nif ( Double . isNaN ( radius_spherical_earth ) ) radius_spherical_earth = gds . getDouble ( \"radius_spherical_earth\" ) ; \nif ( ! Double . isNaN ( radius_spherical_earth ) ) { \nif ( radius_spherical_earth < 10000.00 ) radius_spherical_earth *= 1000.0 ; \nv . addAttribute ( new Attribute ( GridCF . EARTH_RADIUS , radius_spherical_earth ) ) ; \n} \nelse { \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( \"major_axis_earth\" ) ; \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \nif ( ! Double . isNaN ( major_axis ) && ! Double . isNaN ( minor_axis ) ) { \nv . addAttribute ( new Attribute ( GridCF . SEMI_MAJOR_AXIS , major_axis ) ) ; \nv . addAttribute ( new Attribute ( GridCF . SEMI_MINOR_AXIS , minor_axis ) ) ; \n} \n} \naddGDSparams ( v ) ; \nncfile . addVariable ( g , v ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"4408": "public class NetcdfDataset { \npublic boolean enhanceNeeded ( Set < Enhance > want ) throws IOException { \nif ( want == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfor ( Enhance mode : want ) { \nif ( ! this . enhanceMode . contains ( mode ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"4420": "public class NsslRadarMosaicConvention { \npublic static boolean isMine ( NetcdfFile ncfile ) { \nString cs = ncfile . findAttValueIgnoreCase ( null , CDM . CONVENTIONS , null ) ; \nif ( cs != null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nString s = ncfile . findAttValueIgnoreCase ( null , \"DataType\" , null ) ; \nif ( ( s == null ) || ! ( s . equalsIgnoreCase ( \"LatLonGrid\" ) || s . equalsIgnoreCase ( \"LatLonHeightGrid\" ) ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( ( null == ncfile . findGlobalAttribute ( \"Latitude\" ) ) || ( null == ncfile . findGlobalAttribute ( \"Longitude\" ) ) || ( null == ncfile . findGlobalAttribute ( \"LatGridSpacing\" ) ) || ( null == ncfile . findGlobalAttribute ( \"LonGridSpacing\" ) ) || ( null == ncfile . findGlobalAttribute ( \"Time\" ) ) ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nreturn ! ( null == ncfile . findDimension ( \"Lat\" ) || null == ncfile . findDimension ( \"Lon\" ) ) ; \n} \n} \n"}
{"4429": "public class CoordSysBuilder { \nprotected boolean isCoordinateAxisForVariable ( Variable axis , VariableEnhanced v ) { \nList < Dimension > varDims = v . getDimensionsAll ( ) ; \nList < Dimension > axisDims = axis . getDimensionsAll ( ) ; \nint checkDims = axisDims . size ( ) ; \nif ( axis . getDataType ( ) == DataType . CHAR ) checkDims -- ; \nfor ( int i = 0 ; \ni < checkDims ; \ni ++ ) { \nDimension axisDim = axisDims . get ( i ) ; \nif ( ! varDims . contains ( axisDim ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4433": "public class InvCatalogImpl { \nprivate boolean mark ( DatasetFilter filter , InvDatasetImpl ds ) { \nif ( ds instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) ds ; \nif ( ! catRef . isRead ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nboolean allMarked = true ; \nfor ( InvDataset nested : ds . getDatasets ( ) ) { \nallMarked &= mark ( filter , ( InvDatasetImpl ) nested ) ; \n} \nif ( ! allMarked ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( filter . accept ( ds ) >= 0 ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nds . setMark ( true ) ; \nif ( debugFilter ) System . out . println ( \" mark \" + ds . getName ( ) ) ; \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"4442": "public class TimeParamsValidator { \nprivate boolean hasValidDateRange ( String time_start , String time_end , String time_duration ) { \nif ( ( null == time_start ) && ( null == time_end ) && ( null == time_duration ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( ( null != time_start ) && ( null != time_end ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nif ( ( null != time_start ) && ( null != time_duration ) ) { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \nif ( ( null != time_end ) && ( null != time_duration ) ) { \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"4443": "public class SliceIterator { \n@ Override public boolean hasNext ( ) { \nswitch ( state ) { \ncase INITIAL : return ( slice . getFirst ( ) < slice . getStop ( ) ) ; \ncase STARTED : return ( this . index < slice . getLast ( ) ) ; \ncase DONE : } \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"4446": "public class DSPRegistry { \nsynchronized public boolean registered ( Class < ? extends DSP > klass ) { \nfor ( Registration r : registry ) { \nif ( r . dspclass == klass ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4510": "public class Debug { \nstatic public boolean isSet ( String flagName ) { \nif ( store == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nNamePart np = partit ( flagName ) ; \nif ( debug ) { \ntry { \nif ( ( np . storeName . length ( ) > 0 ) && ! store . nodeExists ( np . storeName ) ) System . out . println ( \"Debug.isSet create node = \" + flagName + \" \" + np ) ; \nelse if ( null == store . node ( np . storeName ) . get ( np . keyName , null ) ) System . out . println ( \"Debug.isSet create flag = \" + flagName + \" \" + np ) ; \n} \ncatch ( BackingStoreException e ) { \n} \n} \nboolean value = store . node ( np . storeName ) . getBoolean ( np . keyName , false ) ; \nstore . node ( np . storeName ) . putBoolean ( np . keyName , value ) ; \nreturn value ; \n} \n} \n"}
{"4520": "public class Field { \nprotected boolean accept ( StringBuffer buff ) { \nif ( ! validate ( buff ) ) { \nvalidate ( buff ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( acceptIfDifferent ( getEditValue ( ) ) ) { \nsetStoreValue ( validValue ) ; \nsendEvent ( ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4526": "public class DODSNetcdfFile { \nprivate boolean isGroup ( DStructure dstruct ) { \nBaseType parent = ( BaseType ) dstruct . getParent ( ) ; \nif ( parent == null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( parent instanceof DStructure ) return isGroup ( ( DStructure ) parent ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4534": "public class Resource { \npublic static Cursor makeCursor ( String name ) { \nImage image = getImage ( name ) ; \nif ( null == image ) return null ; \nCursor cursor ; \ntry { \nToolkit tk = Toolkit . getDefaultToolkit ( ) ; \nif ( debug ) { \nImageObserver obs = new ImageObserver ( ) { \npublic boolean imageUpdate ( Image image , int flags , int x , int y , int width , int height ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n; \nSystem . out . println ( \" bestCursorSize = \" + tk . getBestCursorSize ( image . getWidth ( obs ) , image . getHeight ( obs ) ) ) ; \nSystem . out . println ( \" getMaximumCursorColors = \" + tk . getMaximumCursorColors ( ) ) ; \n} \ncursor = tk . createCustomCursor ( image , new Point ( 17 , 17 ) , name ) ; \n} \ncatch ( IndexOutOfBoundsException e ) { \nSystem . out . println ( \"NavigatedPanel createCustomCursor failed \" + e ) ; \nreturn null ; \n} \nreturn cursor ; \n} \n} \n"}
{"4567": "public class HdfEos { \nstatic public boolean amendFromODL ( NetcdfFile ncfile , Group eosGroup ) throws IOException { \nString smeta = getStructMetadata ( eosGroup ) ; \nif ( smeta == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nHdfEos fixer = new HdfEos ( ) ; \nfixer . fixAttributes ( ncfile . getRootGroup ( ) ) ; \nfixer . amendFromODL ( ncfile , smeta ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4589": "public class CFPointObWriter { \npublic static boolean rewritePointFeatureDataset ( String fileIn , String fileOut , boolean inMemory ) throws IOException { \nSystem . out . println ( \"Rewrite2 .nc files from \" + fileIn + \" to \" + fileOut + \" inMemory= \" + inMemory ) ; \nlong start = System . currentTimeMillis ( ) ; \nNetcdfFile ncfile = inMemory ? NetcdfFile . openInMemory ( fileIn ) : NetcdfFile . open ( fileIn ) ; \nNetcdfDataset ncd = new NetcdfDataset ( ncfile ) ; \nFormatter errlog = new Formatter ( ) ; \nFeatureDataset fd = FeatureDatasetFactoryManager . wrap ( FeatureType . ANY_POINT , ncd , null , errlog ) ; \nif ( fd == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( fd instanceof FeatureDatasetPoint ) { \nwritePointFeatureCollection ( ( FeatureDatasetPoint ) fd , fileOut ) ; \nfd . close ( ) ; \nlong took = System . currentTimeMillis ( ) - start ; \nSystem . out . println ( \" that took \" + ( took - start ) + \" msecs\" ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"4617": "public class ChunkInputStream { \nboolean readHeader ( InputStream input ) throws IOException { \nbyte [ ] bytehdr = new byte [ 4 ] ; \nint red = input . read ( bytehdr ) ; \nif ( red == - 1 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( red < 4 ) throw new IOException ( \"Short binary chunk count\" ) ; \nthis . flags = ( ( int ) bytehdr [ 0 ] ) & 0xFF ; \nbytehdr [ 0 ] = 0 ; \nByteBuffer buf = ByteBuffer . wrap ( bytehdr ) . order ( ByteOrder . BIG_ENDIAN ) ; \nthis . chunksize = buf . getInt ( ) ; \nthis . avail = this . chunksize ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4631": "public class Util { \npublic static boolean isUnitless ( String unit ) { \nif ( unit == null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nString munge = unit . toLowerCase ( ) . trim ( ) ; \nmunge = StringUtil2 . remove ( munge , '(' ) ; \nreturn munge . length ( ) == 0 || munge . startsWith ( \"numeric\" ) || munge . startsWith ( \"non-dim\" ) || munge . startsWith ( \"see\" ) || munge . startsWith ( \"proportion\" ) || munge . startsWith ( \"code\" ) || munge . startsWith ( \"0=\" ) || munge . equals ( \"1\" ) ; \n} \n} \n"}
{"4662": "public class SynDSP { \npublic boolean dspMatch ( String path , DapContext context ) { \nfor ( String ext : SYNEXTENSIONS ) { \nif ( path . endsWith ( ext ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4683": "public class NCdumpW { \npublic static boolean print ( String command , Writer out , ucar . nc2 . util . CancelTask ct ) throws IOException { \nString filename ; \nStringTokenizer stoke = new StringTokenizer ( command ) ; \nif ( stoke . hasMoreTokens ( ) ) filename = stoke . nextToken ( ) ; \nelse { \nout . write ( usage ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \ntry ( NetcdfFile nc = NetcdfDataset . openFile ( filename , ct ) ) { \nint pos = command . indexOf ( filename ) ; \ncommand = command . substring ( pos + filename . length ( ) ) ; \nreturn print ( nc , command , out , ct ) ; \n} \ncatch ( java . io . FileNotFoundException e ) { \nout . write ( \"file not found= \" ) ; \nout . write ( filename ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nfinally { \nout . close ( ) ; \n} \n} \n} \n"}
{"4684": "public class NCdumpW { \npublic static boolean print ( NetcdfFile nc , String command , Writer out , ucar . nc2 . util . CancelTask ct ) throws IOException { \nWantValues showValues = WantValues . none ; \nboolean ncml = false ; \nboolean strict = false ; \nString varNames = null ; \nString trueDataset = null ; \nString fakeDataset = null ; \nif ( command != null ) { \nStringTokenizer stoke = new StringTokenizer ( command ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString toke = stoke . nextToken ( ) ; \nif ( toke . equalsIgnoreCase ( \"-help\" ) ) { \nout . write ( usage ) ; \nout . write ( '\\n' ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( toke . equalsIgnoreCase ( \"-vall\" ) ) showValues = WantValues . all ; \nif ( toke . equalsIgnoreCase ( \"-c\" ) && ( showValues == WantValues . none ) ) showValues = WantValues . coordsOnly ; \nif ( toke . equalsIgnoreCase ( \"-ncml\" ) ) ncml = true ; \nif ( toke . equalsIgnoreCase ( \"-cdl\" ) || toke . equalsIgnoreCase ( \"-strict\" ) ) strict = true ; \nif ( toke . equalsIgnoreCase ( \"-v\" ) && stoke . hasMoreTokens ( ) ) varNames = stoke . nextToken ( ) ; \nif ( toke . equalsIgnoreCase ( \"-datasetname\" ) && stoke . hasMoreTokens ( ) ) { \nfakeDataset = stoke . nextToken ( ) ; \nif ( fakeDataset . length ( ) == 0 ) fakeDataset = null ; \nif ( fakeDataset != null ) { \ntrueDataset = nc . getLocation ( ) ; \nnc . setLocation ( fakeDataset ) ; \n} \n} \n} \n} \nboolean ok = print ( nc , out , showValues , ncml , strict , varNames , ct ) ; \nif ( trueDataset != null && fakeDataset != null ) nc . setLocation ( trueDataset ) ; \nreturn ok ; \n} \n} \n"}
{"4692": "public class AbstractTransformBuilder { \nprotected boolean addParameter ( CoordinateTransform rs , String paramName , NetcdfFile ds , String varNameEscaped ) { \nif ( null == ( ds . findVariable ( varNameEscaped ) ) ) { \nif ( null != errBuffer ) errBuffer . format ( \"CoordTransBuilder %s: no Variable named %s%n\" , getTransformName ( ) , varNameEscaped ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nrs . addParameter ( new Parameter ( paramName , varNameEscaped ) ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4695": "public class GempakLookup { \npublic final boolean isPositiveUp ( GridRecord gr ) { \nint type = gr . getLevelType1 ( ) ; \nif ( ( type == 1 ) || ( type == 5 ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4752": "public class SourcePicture { \npublic boolean stopLoadingExcept ( URL exemptionURL ) { \nif ( imageUrl == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( pictureStatusCode != LOADING ) { \nTools . log ( \"SourcePicture.stopLoadingExcept: called but pointless since image is not LOADING: \" + imageUrl . toString ( ) ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( ! exemptionURL . toString ( ) . equals ( imageUrl . toString ( ) ) ) { \nTools . log ( \"SourcePicture.stopLoadingExcept: called with Url \" + exemptionURL . toString ( ) + \" --> stopping loading of \" + imageUrl . toString ( ) ) ; \nstopLoading ( ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nelse { \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"4759": "public class DataDescriptor { \npublic boolean equals2 ( Object o ) { \nif ( this == o ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( o == null || getClass ( ) != o . getClass ( ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nDataDescriptor that = ( DataDescriptor ) o ; \nif ( fxy != that . fxy ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nif ( replication != that . replication ) { \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \nif ( type != that . type ) { \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \nif ( subKeys != null ? ! subKeys . equals ( that . subKeys ) : that . subKeys != null ) { \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n{ \nboolean return_variable_6 = true ; \nreturn return_variable_6 ; \n} \n} \n} \n"}
{"4760": "public class DbaseFile { \nprivate int loadHeader ( ) { \nif ( headerLoaded ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nBufferedInputStream bs = new BufferedInputStream ( s ) ; \nds = new DataInputStream ( bs ) ; \nHeader = new byte [ 32 ] ; \nds . readFully ( Header ) ; \nif ( Header [ 0 ] == '<' ) { \nclose ( ds ) ; \nreturn - 1 ; \n} \nfiletype = Header [ 0 ] ; \nnrecords = Swap . swapInt ( Header , 4 ) ; \nnbytesheader = Swap . swapShort ( Header , 8 ) ; \nnfields = ( nbytesheader / 32 ) - 1 ; \nif ( nfields < 1 ) { \nSystem . out . println ( \"nfields = \" + nfields ) ; \nSystem . out . println ( \"nbytesheader = \" + nbytesheader ) ; \nreturn - 1 ; \n} \nFieldDesc = new DbaseFieldDesc [ nfields ] ; \ndata = new DbaseData [ nfields ] ; \nfor ( int i = 0 ; \ni < nfields ; \ni ++ ) { \nFieldDesc [ i ] = new DbaseFieldDesc ( ds , filetype ) ; \ndata [ i ] = new DbaseData ( FieldDesc [ i ] , nrecords ) ; \n} \nds . readByte ( ) ; \nheaderLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4761": "public class DbaseFile { \nprivate int loadData ( ) { \nif ( ! headerLoaded ) return - 1 ; \nif ( dataLoaded ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nfor ( int i = 0 ; \ni < nrecords ; \ni ++ ) { \nbyte recbyte = ds . readByte ( ) ; \nif ( recbyte == 0x20 ) { \nfor ( int j = 0 ; \nj < nfields ; \nj ++ ) { \ndata [ j ] . readRowN ( ds , i ) ; \n} \n} \nelse { \nnrecords -- ; \ni -- ; \n} \n} \ndataLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nfinally { \nclose ( s ) ; \n} \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4815": "public class DMRPrinter { \nstatic boolean isSpecial ( DapAttribute attr ) { \nif ( attr . getParent ( ) . getSort ( ) == DapSort . DATASET ) { \nfor ( String s : GROUPSPECIAL ) { \nif ( s . equals ( attr . getShortName ( ) ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \nelse if ( attr . getParent ( ) . getSort ( ) == DapSort . VARIABLE ) { \nfor ( String s : VARSPECIAL ) { \nif ( s . equals ( attr . getShortName ( ) ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"4817": "public class AreaReader { \npublic static boolean isValidFile ( RandomAccessFile raf ) { \nString fileName = raf . getLocation ( ) ; \nAreaFile af = null ; \ntry { \naf = new AreaFile ( fileName ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( AreaFileException e ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nfinally { \nif ( af != null ) af . close ( ) ; \n} \n} \n} \n"}
{"4865": "public class DqcFactory { \npublic boolean writeXML ( QueryCapability dqc , String filename ) { \ntry { \nBufferedOutputStream os = new BufferedOutputStream ( new FileOutputStream ( filename ) ) ; \nwriteXML ( dqc , os ) ; \nos . close ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4883": "public class LibTypeFcns { \nstatic public int size ( DapType type ) { \nswitch ( type . getTypeSort ( ) ) { \ncase Char : case UInt8 : case Int8 : { \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \ncase Int16 : case UInt16 : { \nint return_variable_1 = 2 ; \nreturn return_variable_1 ; \n} \ncase Int32 : case UInt32 : case Float32 : { \nint return_variable_2 = 4 ; \nreturn return_variable_2 ; \n} \ncase Int64 : case UInt64 : case Float64 : { \nint return_variable_3 = 8 ; \nreturn return_variable_3 ; \n} \ncase Enum : return size ( ( ( DapEnumeration ) type ) . getBaseType ( ) ) ; \ndefault : break ; \n} \n{ \nint return_variable_4 = 0 ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"4888": "public class SpatialGrid { \npublic boolean markIfClear ( Rectangle2D rect , Object o ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( debugMark ) System . out . println ( \"markIfClear \" + rect + \" \" + indexX + \" \" + indexY ) ; \nif ( ( indexX < 0 ) || ( indexX >= countX ) || ( indexY < 0 ) || ( indexY >= countY ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( null != findIntersection ( rect ) ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \ngwant . used = true ; \ngwant . objectBB = rect ; \ngwant . o = o ; \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"4912": "public class DapUtil { \nstatic public boolean isContiguous ( List < Slice > slices ) { \nfor ( Slice sl : slices ) { \nif ( sl . getStride ( ) != 1 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4913": "public class DapUtil { \nstatic public boolean isSinglePoint ( List < Slice > slices ) { \nfor ( Slice sl : slices ) { \nif ( sl . getCount ( ) != 1 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"4961": "public class MFileCollectionManager { \n@ Override public boolean isScanNeeded ( ) { \nif ( recheck == null ) { \nlogger . debug ( \"{}: scan not needed, recheck null\" , collectionName ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( ! hasScans ( ) ) { \nlogger . debug ( \"{}: scan not needed, no scanners\" , collectionName ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nsynchronized ( this ) { \nif ( map == null && ! isStatic ( ) ) { \nlogger . debug ( \"{}: scan needed, never scanned\" , collectionName ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \nDate now = new Date ( ) ; \nDate lastCheckedDate = new Date ( getLastScanned ( ) ) ; \nDate need = recheck . add ( lastCheckedDate ) ; \nif ( now . before ( need ) ) { \nlogger . debug ( \"{}: scan not needed, last scanned={}, now={}\" , collectionName , lastCheckedDate , now ) ; \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"4962": "public class MFileCollectionManager { \nprivate boolean scanFirstTime ( ) throws IOException { \nMap < String , MFile > newMap = new HashMap < > ( ) ; \nif ( ! hasScans ( ) ) { \nmap = newMap ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nreallyScan ( newMap ) ; \nif ( olderThanInMsecs > 0 ) { \nlong olderThan = System . currentTimeMillis ( ) - olderThanInMsecs ; \nIterator < MFile > iter = newMap . values ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nMFile newFile = iter . next ( ) ; \nString path = newFile . getPath ( ) ; \nif ( newFile . getLastModified ( ) > olderThan ) { \niter . remove ( ) ; \nlogger . debug ( \"{}: scan found new Dataset but its too recently modified = {}\" , collectionName , path ) ; \n} \n} \n} \nmap = newMap ; \nthis . lastScanned = System . currentTimeMillis ( ) ; \nthis . lastChanged . set ( this . lastScanned ) ; \nlogger . debug ( \"{} : initial scan found n datasets = {} \" , collectionName , map . keySet ( ) . size ( ) ) ; \nreturn map . keySet ( ) . size ( ) > 0 ; \n} \n} \n"}
{"4971": "public class StructureDS { \nprivate boolean convertNeeded ( StructureMembers smData ) { \nfor ( Variable v : getVariables ( ) ) { \nif ( v instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v ; \nif ( vds . needConvert ( ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse if ( v instanceof StructureDS ) { \nStructureDS nested = ( StructureDS ) v ; \nif ( nested . convertNeeded ( null ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nif ( ( smData != null ) && ! varHasData ( v , smData ) ) { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"4975": "public class StructureDS { \nprivate boolean varHasData ( Variable v , StructureMembers sm ) { \nif ( sm . findMember ( v . getShortName ( ) ) != null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nwhile ( v instanceof VariableEnhanced ) { \nVariableEnhanced ve = ( VariableEnhanced ) v ; \nif ( sm . findMember ( ve . getOriginalName ( ) ) != null ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nv = ve . getOriginalVariable ( ) ; \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"5016": "public class MAMath { \npublic static boolean conformable ( int [ ] shapeA , int [ ] shapeB ) { \nif ( reducedRank ( shapeA ) != reducedRank ( shapeB ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nint rankB = shapeB . length ; \nint dimB = 0 ; \nfor ( int aShapeA : shapeA ) { \nif ( aShapeA == 1 ) continue ; \nwhile ( dimB < rankB ) if ( shapeB [ dimB ] == 1 ) dimB ++ ; \nelse break ; \nif ( aShapeA != shapeB [ dimB ] ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \ndimB ++ ; \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"5064": "public class Dimension { \npublic final boolean isDimensionless ( ) { \nfor ( int i = _factors . length ; \n-- i >= 0 ; \n) { \nif ( ! _factors [ i ] . isDimensionless ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5067": "public class Grib1ParamTables { \npublic static boolean addParameterTableLookup ( String lookupFilename ) throws IOException { \nLookup lookup = new Lookup ( ) ; \nif ( ! lookup . readLookupTable ( lookupFilename ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nsynchronized ( lock ) { \nstandardLookup . tables . addAll ( standardTablesStart , lookup . tables ) ; \nstandardTablesStart += lookup . tables . size ( ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5086": "public class BufrSplitter { \nprivate boolean readBuffer ( InputStream is , byte [ ] dest , int start , int want ) throws IOException { \nint done = 0 ; \nwhile ( done < want ) { \nint got = is . read ( dest , start + done , want - done ) ; \nif ( got < 0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \ndone += got ; \n} \nif ( showRead ) System . out . println ( \"Read buffer at \" + bytesRead + \" len=\" + done ) ; \nbytesRead += done ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5088": "public class HeaderInputStream { \npublic int read ( byte b [ ] , int off , int len ) throws IOException { \nif ( len <= 0 ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nint c = read ( ) ; \nif ( c == - 1 ) return - 1 ; \nb [ off ] = ( byte ) c ; \nint i = 1 ; \ntry { \nfor ( ; \ni < len ; \ni ++ ) { \nc = read ( ) ; \nif ( c == - 1 ) { \nbreak ; \n} \nb [ off + i ] = ( byte ) c ; \n} \n} \ncatch ( IOException e ) { \n} \nreturn i ; \n} \n} \n"}
{"5113": "public class MultiOdometer { \n@ Override public boolean hasNext ( ) { \nif ( this . current >= odomset . size ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nOdometer ocurrent = odomset . get ( this . current ) ; \nif ( ocurrent . hasNext ( ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nthis . current ++ ; \nreturn hasNext ( ) ; \n} \n} \n"}
{"5122": "public class Nidsheader { \nint readWMO ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint pos = 0 ; \nraf . seek ( pos ) ; \nint readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nint rc = raf . read ( b ) ; \nif ( rc != readLen ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nint iarr2_1 = bytesToInt ( b [ 0 ] , b [ 1 ] , false ) ; \nint iarr2_16 = bytesToInt ( b [ 30 ] , b [ 31 ] , false ) ; \nint iarr2_10 = bytesToInt ( b [ 18 ] , b [ 19 ] , false ) ; \nint iarr2_7 = bytesToInt ( b [ 12 ] , b [ 13 ] , false ) ; \nif ( ( iarr2_1 == iarr2_16 ) && ( ( iarr2_1 >= 16 ) && ( iarr2_1 <= 299 ) ) && ( iarr2_10 == - 1 ) && ( iarr2_7 < 10000 ) ) { \nnoHeader = true ; \n{ \nint return_variable_1 = 1 ; \nreturn return_variable_1 ; \n} \n} \nString pib = new String ( b , CDM . utf8Charset ) ; \nif ( pib . indexOf ( \"SDUS\" ) != - 1 ) { \nnoHeader = false ; \n{ \nint return_variable_2 = 1 ; \nreturn return_variable_2 ; \n} \n} \nelse if ( raf . getLocation ( ) . indexOf ( \".nids\" ) != - 1 ) { \nnoHeader = true ; \n{ \nint return_variable_3 = 1 ; \nreturn return_variable_3 ; \n} \n} \nelse { \nint return_variable_4 = 0 ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"5124": "public class Nidsheader { \nint pcode_12n13n14 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ , String structName , int code ) { \nint vlen = 0 ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nvlen = vlen + dlen [ i ] ; \n} \nArrayList dims = new ArrayList ( ) ; \nDimension sDim = new Dimension ( \"graphicSymbolSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , structName ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"special graphic symbol for code \" + code ) ) ; \nVariable i0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \ni0 . setDimensions ( ( String ) null ) ; \ni0 . setDataType ( DataType . FLOAT ) ; \ni0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( i0 ) ; \nVariable j0 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nj0 . setDimensions ( ( String ) null ) ; \nj0 . setDataType ( DataType . FLOAT ) ; \nj0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( j0 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , code , 0 ) ) ; \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"5125": "public class Nidsheader { \nint pcode_25 ( int [ ] pos , int hoff , int len , boolean isZ ) { \nArrayList dims = new ArrayList ( ) ; \nDimension sDim = new Dimension ( \"circleSize\" , len ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , \"circleStruct\" ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"Circle Packet\" ) ) ; \nVariable ii0 = new Variable ( ncfile , null , dist , \"x_center\" ) ; \nii0 . setDimensions ( ( String ) null ) ; \nii0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii0 ) ; \nVariable ii1 = new Variable ( ncfile , null , dist , \"y_center\" ) ; \nii1 . setDimensions ( ( String ) null ) ; \nii1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii1 ) ; \nVariable jj0 = new Variable ( ncfile , null , dist , \"radius\" ) ; \njj0 . setDimensions ( ( String ) null ) ; \njj0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj0 ) ; \nint [ ] pos1 = new int [ len ] ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , null , 25 , 0 ) ) ; \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"5127": "public class Nidsheader { \nint pcode_5 ( int [ ] pos , int hoff , int len , boolean isZ ) { \nArrayList dims = new ArrayList ( ) ; \nDimension sDim = new Dimension ( \"windBarbSize\" , len ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , \"vectorArrow\" ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"Vector Arrow Data\" ) ) ; \nVariable i0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \ni0 . setDimensions ( ( String ) null ) ; \ni0 . setDataType ( DataType . SHORT ) ; \ni0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( i0 ) ; \nVariable j0 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nj0 . setDimensions ( ( String ) null ) ; \nj0 . setDataType ( DataType . SHORT ) ; \nj0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( j0 ) ; \nVariable direct = new Variable ( ncfile , null , dist , \"direction\" ) ; \ndirect . setDimensions ( ( String ) null ) ; \ndirect . setDataType ( DataType . SHORT ) ; \ndirect . addAttribute ( new Attribute ( CDM . UNITS , \"degree\" ) ) ; \ndist . addMemberVariable ( direct ) ; \nVariable speed = new Variable ( ncfile , null , dist , \"arrowLength\" ) ; \nspeed . setDimensions ( ( String ) null ) ; \nspeed . setDataType ( DataType . SHORT ) ; \nspeed . addAttribute ( new Attribute ( CDM . UNITS , \"pixels\" ) ) ; \ndist . addMemberVariable ( speed ) ; \nVariable speed1 = new Variable ( ncfile , null , dist , \"arrowHeadLength\" ) ; \nspeed1 . setDimensions ( ( String ) null ) ; \nspeed1 . setDataType ( DataType . SHORT ) ; \nspeed1 . addAttribute ( new Attribute ( CDM . UNITS , \"pixels\" ) ) ; \ndist . addMemberVariable ( speed1 ) ; \nint [ ] pos1 = new int [ len ] ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , null , 4 , 0 ) ) ; \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"5128": "public class Nidsheader { \nint pcode_128 ( int [ ] pos , int [ ] size , int code , int hoff , int len , String structName , String abbre , boolean isZ ) { \nArrayList dims = new ArrayList ( ) ; \nDimension sDim = new Dimension ( \"textStringSize\" + abbre + code , len ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , structName + abbre ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"text and special symbol for code \" + code ) ) ; \nif ( code == 8 ) { \nVariable strVal = new Variable ( ncfile , null , dist , \"strValue\" ) ; \nstrVal . setDimensions ( ( String ) null ) ; \nstrVal . setDataType ( DataType . SHORT ) ; \nstrVal . addAttribute ( new Attribute ( CDM . UNITS , \"\" ) ) ; \ndist . addMemberVariable ( strVal ) ; \n} \nVariable i0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \ni0 . setDimensions ( ( String ) null ) ; \ni0 . setDataType ( DataType . SHORT ) ; \ni0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( i0 ) ; \nVariable j0 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nj0 . setDimensions ( ( String ) null ) ; \nj0 . setDataType ( DataType . SHORT ) ; \nj0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( j0 ) ; \nVariable tstr = new Variable ( ncfile , null , dist , \"textString\" ) ; \ntstr . setDimensions ( ( String ) null ) ; \ntstr . setDataType ( DataType . STRING ) ; \ntstr . addAttribute ( new Attribute ( CDM . UNITS , \"\" ) ) ; \ndist . addMemberVariable ( tstr ) ; \nint [ ] pos1 = new int [ len ] ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , size , code , 0 ) ) ; \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"5129": "public class Nidsheader { \nint pcode_10n9 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ ) { \nArrayList dims = new ArrayList ( ) ; \nVariable v ; \nint vlen = 0 ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nvlen = vlen + dlen [ i ] ; \n} \nDimension sDim = new Dimension ( \"unlinkedVectorSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , \"unlinkedVectorStruct\" ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"Unlinked Vector Packet\" ) ) ; \nv = new Variable ( ncfile , null , null , \"iValue\" ) ; \nv . setDataType ( DataType . SHORT ) ; \nv . setDimensions ( ( String ) null ) ; \ndist . addMemberVariable ( v ) ; \nVariable ii0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \nii0 . setDimensions ( ( String ) null ) ; \nii0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii0 ) ; \nVariable ii1 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nii1 . setDimensions ( ( String ) null ) ; \nii1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii1 ) ; \nVariable jj0 = new Variable ( ncfile , null , dist , \"x_end\" ) ; \njj0 . setDimensions ( ( String ) null ) ; \njj0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj0 ) ; \nVariable jj1 = new Variable ( ncfile , null , dist , \"y_end\" ) ; \njj1 . setDimensions ( ( String ) null ) ; \njj1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj1 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , 10 , 0 ) ) ; \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"5141": "public class Rubberband { \npublic boolean anchor ( Point p ) { \nfirstStretch = true ; \nanchorPt . x = p . x ; \nanchorPt . y = p . y ; \nstretchedPt . x = lastPt . x = anchorPt . x ; \nstretchedPt . y = lastPt . y = anchorPt . y ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"5154": "public class GribNumbers { \npublic static float float4 ( int a , int b , int c , int d ) { \nint sgn , mant , exp ; \nmant = b << 16 | c << 8 | d ; \nif ( mant == 0 ) { \n{ \ndouble return_variable_0 = 0.0f ; \nreturn return_variable_0 ; \n} \n} \nsgn = - ( ( ( a & 128 ) >> 6 ) - 1 ) ; \nexp = ( a & 127 ) - 64 ; \nreturn ( float ) ( sgn * Math . pow ( 16.0 , exp - 6 ) * mant ) ; \n} \n} \n"}
{"5172": "public class DateType { \npublic boolean before ( Date d ) { \nif ( isPresent ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nreturn date . isBefore ( CalendarDate . of ( d ) ) ; \n} \n} \n"}
{"5173": "public class DateType { \npublic boolean before ( DateType d ) { \nif ( d . isPresent ( ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( isPresent ( ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nreturn date . isBefore ( d . getCalendarDate ( ) ) ; \n} \n} \n"}
{"5174": "public class DateType { \npublic boolean after ( Date d ) { \nif ( isPresent ( ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nreturn date . isAfter ( CalendarDate . of ( d ) ) ; \n} \n} \n"}
{"5233": "public class NCheader { \nstatic boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { \nif ( b1 == b2 ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( b1 == null || b2 == null ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( b1 . length < len || b2 . length < len ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nif ( b1 [ i ] != b2 [ i ] ) { \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"5240": "public class GeoGridCoordinate2D { \nprivate boolean box9 ( double wantLat , double wantLon , int [ ] rectIndex ) { \nint row = rectIndex [ 0 ] ; \nint minrow = Math . max ( row - 1 , 0 ) ; \nint maxrow = Math . min ( row + 1 , nrows ) ; \nint col = rectIndex [ 1 ] ; \nint mincol = Math . max ( col - 1 , 0 ) ; \nint maxcol = Math . min ( col + 1 , ncols ) ; \nif ( debug ) System . out . printf ( \"%n   box9:\" ) ; \nfor ( int i = minrow ; \ni <= maxrow ; \ni ++ ) for ( int j = mincol ; \nj <= maxcol ; \nj ++ ) { \nrectIndex [ 0 ] = i ; \nrectIndex [ 1 ] = j ; \nif ( contains ( wantLat , wantLon , rectIndex ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5243": "public class CFpointObs { \nprotected boolean identifyEncodingStation ( NetcdfDataset ds , EncodingInfo info , CF . FeatureType ftype , Formatter errlog ) { \nDimension obsDim = null ; \nif ( info . time . getRank ( ) > 0 ) obsDim = info . time . getDimension ( info . time . getRank ( ) - 1 ) ; \nelse if ( info . time . getParentStructure ( ) != null ) { \nStructure parent = info . time . getParentStructure ( ) ; \nobsDim = parent . getDimension ( parent . getRank ( ) - 1 ) ; \n} \nif ( obsDim == null ) { \nerrlog . format ( \"CFpointObs: must have a non-scalar Time coordinate%n\" ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( info . lat . getRank ( ) == 0 ) { \ninfo . set ( Encoding . single , null , obsDim ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nDimension stnDim = info . lat . getDimension ( 0 ) ; \nif ( obsDim == stnDim ) { \ninfo . set ( Encoding . flat , null , obsDim ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nif ( identifyRaggeds ( ds , info , stnDim , obsDim , errlog ) ) { \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \nif ( info . lat . getRank ( ) == 1 ) { \ninfo . set ( Encoding . multidim , stnDim , obsDim ) ; \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \nerrlog . format ( \"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\" , ftype ) ; \n{ \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \n} \n"}
{"5244": "public class CFpointObs { \nprotected String matchAxisTypeAndDimension ( NetcdfDataset ds , AxisType type , final Dimension outer ) { \nVariable var = CoordSysEvaluator . findCoordByType ( ds , type , new CoordSysEvaluator . Predicate ( ) { \npublic boolean match ( CoordinateAxis axis ) { \nif ( ( outer == null ) && ( axis . getRank ( ) == 0 ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( ( outer != null ) && ( axis . getRank ( ) == 1 ) && ( outer . equals ( axis . getDimension ( 0 ) ) ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nif ( axis . getParentStructure ( ) != null ) { \nStructure parent = axis . getParentStructure ( ) ; \nif ( ( outer != null ) && ( parent . getRank ( ) == 1 ) && ( outer . equals ( parent . getDimension ( 0 ) ) ) ) { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n) ; \nif ( var == null ) return null ; \nreturn var . getFullName ( ) ; \n} \n} \n"}
{"5252": "public class LastModifiedLimitFilter { \npublic boolean accept ( CrawlableDataset dataset ) { \nDate lastModDate = dataset . lastModified ( ) ; \nif ( lastModDate != null ) { \nlong now = System . currentTimeMillis ( ) ; \nif ( now - lastModDate . getTime ( ) > lastModifiedLimitInMillis ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5258": "public class BitCounterCompressed { \npublic int ncounters ( ) { \nif ( nested == null ) { \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \nelse { \nint ncounters = 0 ; \nfor ( BitCounterCompressed [ ] counters : nested ) { \nif ( counters == null ) continue ; \nfor ( BitCounterCompressed counter : counters ) if ( counter != null ) ncounters += counter . ncounters ( ) ; \n} \nreturn ncounters ; \n} \n} \n} \n"}
{"5278": "public class Range { \npublic boolean contains ( int want ) { \nif ( want < first ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( want > last ( ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( stride == 1 ) { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \nreturn ( want - first ) % stride == 0 ; \n} \n} \n"}
{"5294": "public class FysatHeader { \nboolean readPIB ( RandomAccessFile raf ) throws IOException { \nthis . firstHeader = new AwxFileFirstHeader ( ) ; \nint pos = 0 ; \nraf . seek ( pos ) ; \nbyte [ ] buf = new byte [ FY_AWX_PIB_LEN ] ; \nint count = raf . read ( buf ) ; \nEndianByteBuffer byteBuffer ; \nif ( count == FY_AWX_PIB_LEN ) { \nbyteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; \nthis . firstHeader . fillHeader ( byteBuffer ) ; \n} \nelse { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( ! ( ( this . firstHeader . fileName . endsWith ( \".AWX\" ) || this . firstHeader . fileName . endsWith ( \".awx\" ) ) && this . firstHeader . firstHeaderLength == FY_AWX_PIB_LEN ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nbuf = new byte [ this . firstHeader . secondHeaderLength ] ; \nraf . readFully ( buf ) ; \nbyteBuffer = new EndianByteBuffer ( buf , this . firstHeader . byteOrder ) ; \nswitch ( this . firstHeader . typeOfProduct ) { \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_UNDEFINED : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GEOSAT_IMAGE : secondHeader = new AwxFileGeoSatelliteSecondHeader ( ) ; \nsecondHeader . fillHeader ( byteBuffer ) ; \nbreak ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_POLARSAT_IMAGE : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRID : secondHeader = new AwxFileGridProductSecondHeader ( ) ; \nsecondHeader . fillHeader ( byteBuffer ) ; \nbreak ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_DISCREET : throw new UnsupportedDatasetException ( ) ; \ncase AwxFileFirstHeader . AWX_PRODUCT_TYPE_GRAPH_ANALIYSIS : throw new UnsupportedDatasetException ( ) ; \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"5302": "public class InvDatasetImpl { \npublic boolean replaceDataset ( InvDatasetImpl remove , InvDatasetImpl add ) { \nfor ( int i = 0 ; \ni < datasets . size ( ) ; \ni ++ ) { \nInvDataset dataset = datasets . get ( i ) ; \nif ( dataset . equals ( remove ) ) { \ndatasets . set ( i , add ) ; \nInvCatalogImpl cat = ( InvCatalogImpl ) getParentCatalog ( ) ; \nif ( cat != null ) { \ncat . removeDatasetByID ( remove ) ; \ncat . addDatasetByID ( add ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5316": "public class CrawlableDatasetAmazonS3 { \n@ Override public long length ( ) { \nS3ObjectSummary objectSummary = objectSummaryCache . getIfPresent ( s3uri ) ; \nif ( objectSummary != null ) { \nreturn objectSummary . getSize ( ) ; \n} \nObjectMetadata metadata = threddsS3Client . getObjectMetadata ( s3uri ) ; \nif ( metadata != null ) { \nreturn metadata . getContentLength ( ) ; \n} \nelse { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"5327": "public class HtmlWriting { \npublic int writeDirectory ( HttpServletResponse res , File dir , String path ) throws IOException { \nif ( dir == null ) { \nres . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nif ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { \nres . sendError ( HttpServletResponse . SC_NOT_FOUND ) ; \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \nString dirHtmlString = getDirectory ( path , dir ) ; \nthredds . servlet . ServletUtil . setResponseContentLength ( res , dirHtmlString ) ; \nres . setContentType ( ContentType . html . getContentHeader ( ) ) ; \nPrintWriter writer = res . getWriter ( ) ; \nwriter . write ( dirHtmlString ) ; \nwriter . flush ( ) ; \nreturn dirHtmlString . length ( ) ; \n} \n} \n"}
{"5400": "public class NwsMetDevTables { \n@ Override public double getForecastTimeIntervalSizeInHours ( Grib2Pds pds ) { \nGrib2Pds . PdsInterval pdsIntv = ( Grib2Pds . PdsInterval ) pds ; \nboolean needOverride = false ; \nfor ( Grib2Pds . TimeInterval ti : pdsIntv . getTimeIntervals ( ) ) { \nneedOverride = ( ti . timeRangeUnit == 255 ) ; \n} \nif ( ! needOverride ) return super . getForecastTimeIntervalSizeInHours ( pds ) ; \n{ \ndouble return_variable_0 = 12.0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"5405": "public class McIDASGridServiceProvider { \npublic boolean sync ( ) { \ntry { \nif ( ! mcGridReader . init ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nGridIndex index = mcGridReader . getGridIndex ( ) ; \nncfile . empty ( ) ; \nopen ( index , null ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \ncatch ( IOException ioe ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n"}
{"5411": "public class CSMConvention { \nprotected boolean addParameter2 ( CoordinateTransform rs , String paramName , NetcdfFile ds , AttributeContainer v , String attName , boolean readData ) { \nString varName ; \nif ( null == ( varName = v . findAttValueIgnoreCase ( attName , null ) ) ) { \nparseInfo . format ( \"CSMConvention No Attribute named %s%n\" , attName ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nvarName = varName . trim ( ) ; \nVariable dataVar ; \nif ( null == ( dataVar = ds . findVariable ( varName ) ) ) { \nparseInfo . format ( \"CSMConvention No Variable named %s%n\" , varName ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( readData ) { \nArray data ; \ntry { \ndata = dataVar . read ( ) ; \n} \ncatch ( IOException e ) { \nparseInfo . format ( \"CSMConvention failed on read of %s err= %s%n\" , varName , e . getMessage ( ) ) ; \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \ndouble [ ] vals = ( double [ ] ) data . get1DJavaArray ( DataType . DOUBLE ) ; \nrs . addParameter ( new Parameter ( paramName , vals ) ) ; \n} \nelse rs . addParameter ( new Parameter ( paramName , varName ) ) ; \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"5416": "public class Group { \npublic boolean addDimensionIfNotExists ( Dimension dim ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( ! dim . isShared ( ) ) { \nthrow new IllegalArgumentException ( \"Dimensions added to a group must be shared.\" ) ; \n} \nif ( findDimensionLocal ( dim . getShortName ( ) ) != null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \ndimensions . add ( dim ) ; \ndim . setGroup ( this ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5420": "public class Group { \npublic boolean removeDimension ( String dimName ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nfor ( int i = 0 ; \ni < dimensions . size ( ) ; \ni ++ ) { \nDimension d = dimensions . get ( i ) ; \nif ( dimName . equals ( d . getShortName ( ) ) ) { \ndimensions . remove ( d ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5439": "public class RC { \nstatic boolean urlMatch ( URL pattern , URL url ) { \nint relation ; \nif ( pattern == null ) return ( url == null ) ; \nif ( ! ( url . getHost ( ) . endsWith ( pattern . getHost ( ) ) ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( ! ( url . getPath ( ) . startsWith ( pattern . getPath ( ) ) ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( pattern . getPort ( ) > 0 && pattern . getPort ( ) != url . getPort ( ) ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"5443": "public class RC { \npublic boolean load ( String abspath ) { \nabspath = abspath . replace ( '\\\\' , '/' ) ; \nFile rcFile = new File ( abspath ) ; \nif ( ! rcFile . exists ( ) || ! rcFile . canRead ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \ntry ( BufferedReader rdr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( rcFile ) , CDM . UTF8 ) ) ) { \nfor ( int lineno = 1 ; \n; \nlineno ++ ) { \nURL url = null ; \nString line = rdr . readLine ( ) ; \nif ( line == null ) break ; \nline = line . trim ( ) ; \nif ( line . length ( ) == 0 ) continue ; \nif ( line . charAt ( 0 ) == '#' ) continue ; \nif ( line . charAt ( 0 ) == LTAG ) { \nint rindex = line . indexOf ( RTAG ) ; \nif ( rindex < 0 ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \nString surl = line . substring ( 1 , rindex ) ; \ntry { \nurl = new URL ( surl ) ; \n} \ncatch ( MalformedURLException mue ) { \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \n} \nline = line . substring ( rindex + 1 ) ; \nline = line . trim ( ) ; \n} \nString [ ] pieces = line . split ( \"\\\\s*=\\\\s*\" ) ; \nassert ( pieces . length == 1 || pieces . length == 2 ) ; \nString value = \"1\" ; \nif ( pieces . length == 2 ) value = pieces [ 1 ] . trim ( ) ; \nTriple triple = new Triple ( pieces [ 0 ] . trim ( ) , value , url ) ; \nList < Triple > list = triplestore . get ( triple . key ) ; \nif ( list == null ) list = new ArrayList < Triple > ( ) ; \nTriple prev = addtriple ( list , triple ) ; \ntriplestore . put ( triple . key , list ) ; \n} \n} \ncatch ( FileNotFoundException fe ) { \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \ncatch ( IOException ioe ) { \nif ( showlog ) log . error ( \"File \" + abspath + \": IO exception: \" + ioe . getMessage ( ) ) ; \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"5451": "public class StopButton { \npublic boolean startProgressMonitorTask ( ProgressMonitorTask pmt ) { \nif ( busy ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nbusy = true ; \nthis . task = pmt ; \nisCancelled = false ; \ncount = 0 ; \nsetIcon ( icon [ 0 ] ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nif ( isCancelled && ! task . isCancel ( ) ) { \ntask . cancel ( ) ; \nif ( debug ) System . out . println ( \" task.cancel\" ) ; \nreturn ; \n} \nelse { \ncount ++ ; \nsetIcon ( icon [ count % 2 ] ) ; \nif ( debug ) System . out . println ( \" stop count=\" + count ) ; \n} \nif ( task . isDone ( ) ) { \nif ( myTimer != null ) myTimer . stop ( ) ; \nmyTimer = null ; \nif ( task . isError ( ) ) javax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \nbusy = false ; \n} \n} \n} \n; \nmyTimer = new javax . swing . Timer ( 1000 , watcher ) ; \nmyTimer . start ( ) ; \nThread taskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5452": "public class GribPartitionBuilder { \nprivate boolean needsUpdate ( CollectionUpdateType ff , File collectionIndexFile ) throws IOException { \nlong collectionLastModified = collectionIndexFile . lastModified ( ) ; \nSet < String > newFileSet = new HashSet < > ( ) ; \nfor ( MCollection dcm : partitionManager . makePartitions ( CollectionUpdateType . test ) ) { \nString partitionIndexFilename = StringUtil2 . replace ( dcm . getIndexFilename ( GribCdmIndex . NCX_SUFFIX ) , '\\\\' , \"/\" ) ; \nFile partitionIndexFile = GribIndexCache . getExistingFileOrCache ( partitionIndexFilename ) ; \nif ( partitionIndexFile == null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( collectionLastModified < partitionIndexFile . lastModified ( ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nnewFileSet . add ( partitionIndexFilename ) ; \n} \nif ( ff == CollectionUpdateType . testIndexOnly ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nGribCdmIndex reader = new GribCdmIndex ( logger ) ; \nList < MFile > oldFiles = new ArrayList < > ( ) ; \nreader . readMFiles ( collectionIndexFile . toPath ( ) , oldFiles ) ; \nSet < String > oldFileSet = new HashSet < > ( ) ; \nfor ( MFile oldFile : oldFiles ) { \nif ( ! newFileSet . contains ( oldFile . getPath ( ) ) ) { \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \noldFileSet . add ( oldFile . getPath ( ) ) ; \n} \nfor ( String newFilename : newFileSet ) { \nif ( ! oldFileSet . contains ( newFilename ) ) { \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \n{ \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \n} \n"}
{"5477": "public class Grib2Iosp { \n@ Override public boolean isValidFile ( RandomAccessFile raf ) throws IOException { \nif ( raf instanceof HTTPRandomAccessFile ) { \nif ( raf . length ( ) > raf . getBufferSize ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse { \nGribCdmIndex . GribCollectionType type = GribCdmIndex . getType ( raf ) ; \nif ( type == GribCdmIndex . GribCollectionType . GRIB2 ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nif ( type == GribCdmIndex . GribCollectionType . Partition2 ) { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nreturn Grib2RecordScanner . isValidFile ( raf ) ; \n} \n} \n"}
{"5499": "public class Universal { \n@ Override public boolean references ( DapNode node ) { \nswitch ( node . getSort ( ) ) { \ncase DIMENSION : case ENUMERATION : case VARIABLE : case GROUP : case DATASET : { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \ndefault : break ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5502": "public class AggregationTiled { \nprivate boolean isTiled ( Variable v ) { \nfor ( Dimension d : v . getDimensions ( ) ) { \nfor ( Range r : section . getRanges ( ) ) { \nif ( d . getShortName ( ) . equals ( r . getName ( ) ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5526": "public class CoordinateSystem { \npublic boolean isGeoXY ( ) { \nif ( ( xAxis == null ) || ( yAxis == null ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nreturn null != getProjection ( ) && ! ( projection instanceof LatLonProjection ) ; \n} \n} \n"}
{"5527": "public class CoordinateSystem { \npublic boolean isRegular ( ) { \nfor ( CoordinateAxis axis : coordAxes ) { \nif ( ! ( axis instanceof CoordinateAxis1D ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( ! ( ( CoordinateAxis1D ) axis ) . isRegular ( ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"5528": "public class CoordinateSystem { \npublic static boolean isSubset ( Collection < Dimension > subset , Collection < Dimension > set ) { \nfor ( Dimension d : subset ) { \nif ( ! ( set . contains ( d ) ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5529": "public class CoordinateSystem { \npublic boolean containsAxes ( List < CoordinateAxis > wantAxes ) { \nfor ( CoordinateAxis ca : wantAxes ) { \nif ( ! containsAxis ( ca . getFullName ( ) ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5530": "public class CoordinateSystem { \npublic boolean containsAxis ( String axisName ) { \nfor ( CoordinateAxis ca : coordAxes ) { \nif ( ca . getFullName ( ) . equals ( axisName ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5531": "public class CoordinateSystem { \npublic boolean containsDomain ( List < Dimension > wantDimensions ) { \nfor ( Dimension d : wantDimensions ) { \nif ( ! domain . contains ( d ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5532": "public class CoordinateSystem { \npublic boolean containsAxisTypes ( List < AxisType > wantAxes ) { \nfor ( AxisType wantAxisType : wantAxes ) { \nif ( ! containsAxisType ( wantAxisType ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5533": "public class CoordinateSystem { \npublic boolean containsAxisType ( AxisType wantAxisType ) { \nfor ( CoordinateAxis ca : coordAxes ) { \nif ( ca . getAxisType ( ) == wantAxisType ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5543": "public class NestedTable { \nprivate boolean isCoordinate ( Variable v ) { \nif ( v == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nString name = v . getShortName ( ) ; \nreturn ( latVE != null && latVE . axisName . equals ( name ) ) || ( lonVE != null && lonVE . axisName . equals ( name ) ) || ( altVE != null && altVE . axisName . equals ( name ) ) || ( stnAltVE != null && stnAltVE . axisName . equals ( name ) ) || ( timeVE != null && timeVE . axisName . equals ( name ) ) || ( nomTimeVE != null && nomTimeVE . axisName . equals ( name ) ) ; \n} \n} \n"}
{"5553": "public class SimpleUnit { \nstatic public boolean isDateUnit ( ucar . units . Unit uu ) { \nboolean ok = uu . isCompatible ( dateReferenceUnit ) ; \nif ( ! ok ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \ntry { \nuu . getConverterTo ( dateReferenceUnit ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \ncatch ( ConversionException e ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n"}
{"5557": "public class SimpleUnit { \npublic boolean isUnknownUnit ( ) { \nucar . units . Unit uu = getUnit ( ) ; \nif ( uu instanceof ucar . units . UnknownUnit ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nif ( uu instanceof ucar . units . DerivedUnit ) return isUnknownUnit ( ( ucar . units . DerivedUnit ) uu ) ; \nif ( uu instanceof ucar . units . ScaledUnit ) { \nucar . units . ScaledUnit scu = ( ucar . units . ScaledUnit ) uu ; \nUnit u = scu . getUnit ( ) ; \nif ( u instanceof ucar . units . UnknownUnit ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nif ( u instanceof ucar . units . DerivedUnit ) return isUnknownUnit ( ( ucar . units . DerivedUnit ) u ) ; \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"5591": "public class RandomAccessFile { \npublic boolean searchForward ( KMPMatch match , int maxBytes ) throws IOException { \nlong start = getFilePointer ( ) ; \nlong last = ( maxBytes < 0 ) ? length ( ) : Math . min ( length ( ) , start + maxBytes ) ; \nlong needToScan = last - start ; \nint bytesAvailable = ( int ) ( dataEnd - filePosition ) ; \nif ( bytesAvailable < 1 ) { \nseek ( filePosition ) ; \nbytesAvailable = ( int ) ( dataEnd - filePosition ) ; \n} \nint bufStart = ( int ) ( filePosition - bufferStart ) ; \nint scanBytes = ( int ) Math . min ( bytesAvailable , needToScan ) ; \nint pos = match . indexOf ( buffer , bufStart , scanBytes ) ; \nif ( pos >= 0 ) { \nseek ( bufferStart + pos ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nint matchLen = match . getMatchLength ( ) ; \nneedToScan -= scanBytes - matchLen ; \nwhile ( needToScan > matchLen ) { \nreadBuffer ( dataEnd - matchLen ) ; \nscanBytes = ( int ) Math . min ( buffer . length , needToScan ) ; \npos = match . indexOf ( buffer , 0 , scanBytes ) ; \nif ( pos > 0 ) { \nseek ( bufferStart + pos ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nneedToScan -= scanBytes - matchLen ; \n} \nseek ( last ) ; \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"5594": "public class DirectoryBuilder { \npublic boolean findIndex ( ) throws IOException { \nPath indexPath = Paths . get ( dir . toString ( ) , partitionName + suffix ) ; \nif ( Files . exists ( indexPath ) ) { \nthis . index = indexPath ; \nBasicFileAttributes attr = Files . readAttributes ( indexPath , BasicFileAttributes . class ) ; \nthis . indexLastModified = attr . lastModifiedTime ( ) ; \nthis . indexSize = attr . size ( ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5603": "public class FileCache { \n@ Override public boolean release ( FileCacheable ncfile ) throws IOException { \nif ( ncfile == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( disabled . get ( ) ) { \nncfile . setFileCache ( null ) ; \nncfile . close ( ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nCacheElement . CacheFile file = files . get ( ncfile ) ; \nif ( file != null ) { \nif ( ! file . isLocked . get ( ) ) { \ncacheLog . warn ( \"FileCache \" + name + \" release \" + ncfile . getLocation ( ) + \" not locked; hash= \" + ncfile . hashCode ( ) ) ; \n} \nfile . lastAccessed = System . currentTimeMillis ( ) ; \nfile . countAccessed ++ ; \nfile . isLocked . set ( false ) ; \nfile . ncfile . release ( ) ; \nif ( cacheLog . isDebugEnabled ( ) ) cacheLog . debug ( \"FileCache \" + name + \" release \" + ncfile . getLocation ( ) + \"; hash= \" + ncfile . hashCode ( ) ) ; \nif ( debugPrint ) System . out . printf ( \"  FileCache %s release %s lock=%s count=%d%n\" , name , ncfile . getLocation ( ) , file . isLocked . get ( ) , countLocked ( ) ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"5608": "public class GridCoordSys { \n@ Override public boolean isGlobalLon ( ) { \nif ( ! isLatLon ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( ! ( horizXaxis instanceof CoordinateAxis1D ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nCoordinateAxis1D lon = ( CoordinateAxis1D ) horizXaxis ; \ndouble first = lon . getCoordEdge ( 0 ) ; \ndouble last = lon . getCoordEdge ( ( int ) lon . getSize ( ) ) ; \ndouble min = Math . min ( first , last ) ; \ndouble max = Math . max ( first , last ) ; \nreturn ( max - min ) >= 360 ; \n} \n} \n"}
{"5609": "public class GridCoordSys { \n@ Override public boolean isZPositive ( ) { \nif ( vertZaxis == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( vertZaxis . getPositive ( ) != null ) { \nreturn vertZaxis . getPositive ( ) . equalsIgnoreCase ( ucar . nc2 . constants . CF . POSITIVE_UP ) ; \n} \nif ( vertZaxis . getAxisType ( ) == AxisType . Height ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nreturn vertZaxis . getAxisType ( ) != AxisType . Pressure ; \n} \n} \n"}
{"5615": "public class MyTextField { \nprotected int getItem ( int pixel ) { \nif ( nitems < 2 ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nint eff_width = b . width - 2 * arrow_size ; \ndouble fitem = ( ( double ) ( pixel - arrow_size ) * ( nitems - 1 ) ) / eff_width ; \nint item = ( int ) ( fitem + .5 ) ; \nitem = Math . max ( Math . min ( item , nitems - 1 ) , 0 ) ; \nreturn item ; \n} \n} \n"}
{"5625": "public class CalendarPeriod { \npublic int getOffset ( CalendarDate start , CalendarDate end ) { \nif ( start . equals ( end ) ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nlong start_millis = start . getDateTime ( ) . getMillis ( ) ; \nlong end_millis = end . getDateTime ( ) . getMillis ( ) ; \nPeriod p ; \nif ( start_millis < end_millis ) p = new Period ( start_millis , end_millis + 5000 , getPeriodType ( ) ) ; \nelse p = new Period ( start_millis + 5000 , end_millis , getPeriodType ( ) ) ; \nreturn p . get ( getDurationFieldType ( ) ) ; \n} \n} \n"}
{"5626": "public class GempakGridServiceProvider { \npublic boolean sync ( ) throws IOException { \nif ( ( gemreader . getInitFileSize ( ) < raf . length ( ) ) && extendIndex ) { \ngemreader . init ( true ) ; \nGridIndex index = gemreader . getGridIndex ( ) ; \nncfile . empty ( ) ; \nopen ( index , null ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5684": "public class GempakSoundingFileReader { \nprivate boolean checkForValidGroup ( String partToCheck , String [ ] params ) { \nDMPart part = getPart ( partToCheck ) ; \nif ( part == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nint i = 0 ; \nfor ( DMParam parm : part . params ) { \nif ( ! ( parm . kprmnm . equals ( params [ i ++ ] ) ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"5716": "public class MessageScanner { \nstatic public boolean isValidFile ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nraf . seek ( 0 ) ; \nif ( ! raf . searchForward ( matcher , 40 * 1000 ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nraf . skipBytes ( 4 ) ; \nBufrIndicatorSection is = new BufrIndicatorSection ( raf ) ; \nif ( is . getBufrEdition ( ) > 4 ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nreturn ! ( is . getBufrLength ( ) > raf . length ( ) ) ; \n} \n} \n"}
{"5718": "public class DbaseData { \nint readRowN ( DataInputStream ds , int n ) { \nif ( n > nrec ) return - 1 ; \ntry { \nds . readFully ( field , 0 , desc . FieldLength ) ; \n} \ncatch ( java . io . IOException e ) { \nreturn - 1 ; \n} \nswitch ( desc . Type ) { \ncase 'C' : case 'D' : character [ n ] = new String ( field , CDM . utf8Charset ) ; \nbreak ; \ncase 'N' : numeric [ n ] = Double . valueOf ( new String ( field , CDM . utf8Charset ) ) ; \nbreak ; \ncase 'F' : if ( desc . FieldLength == 4 ) { \nnumeric [ n ] = ( double ) Swap . swapFloat ( field , 0 ) ; \n} \nelse { \nnumeric [ n ] = Swap . swapDouble ( field , 0 ) ; \n} \nbreak ; \ncase 'L' : switch ( field [ 0 ] ) { \ncase 't' : case 'T' : case 'Y' : case 'y' : logical [ n ] = true ; \nbreak ; \ndefault : logical [ n ] = false ; \nbreak ; \n} \ndefault : return - 1 ; \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"5749": "public class Grib1SectionGridDefinition { \npublic final boolean isThin ( ) { \nif ( rawData == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nint octet5 = getOctet ( 5 ) ; \nint nv = getOctet ( 4 ) ; \nreturn ( octet5 != 255 ) && ( nv == 0 || nv == 255 ) ; \n} \n} \n"}
{"5761": "public class NetcdfFile { \nstatic public boolean iospRegistered ( Class iospClass ) { \nfor ( IOServiceProvider spi : registeredProviders ) { \nif ( spi . getClass ( ) == iospClass ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5762": "public class NetcdfFile { \nstatic public boolean iospDeRegister ( Class iospClass ) { \nfor ( int i = 0 ; \ni < registeredProviders . size ( ) ; \ni ++ ) { \nIOServiceProvider spi = registeredProviders . get ( i ) ; \nif ( spi . getClass ( ) == iospClass ) { \nregisteredProviders . remove ( i ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5791": "public class CompositeMFileFilter { \nprivate boolean include ( MFile mfile ) { \nif ( includeFilters == null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nfor ( MFileFilter filter : includeFilters ) { \nif ( filter . accept ( mfile ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"5792": "public class CompositeMFileFilter { \nprivate boolean exclude ( MFile mfile ) { \nif ( excludeFilters == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfor ( MFileFilter filter : excludeFilters ) { \nif ( filter . accept ( mfile ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"5793": "public class CompositeMFileFilter { \nprivate boolean andFilter ( MFile mfile ) { \nif ( andFilters == null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nfor ( MFileFilter filter : andFilters ) { \nif ( ! filter . accept ( mfile ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"5797": "public class Attribute { \nprivate static final boolean checkByte ( String s ) throws AttributeBadValueException { \ntry { \nshort val = Short . parseShort ( s ) ; \nif ( DebugValueChecking ) { \nlog . debug ( \"Attribute.checkByte() - string: '\" + s + \"'   value: \" + val ) ; \n} \nif ( val > 0xFF || val < 0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nelse { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \ncatch ( NumberFormatException e ) { \nthrow new AttributeBadValueException ( \"`\" + s + \"' is not a Byte value.\" ) ; \n} \n} \n} \n"}
{"5798": "public class Attribute { \nprivate static final boolean checkShort ( String s ) { \ntry { \nshort val = Short . parseShort ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkShort() - string: '\" + s + \"'   value: \" + val ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( NumberFormatException e ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"5799": "public class Attribute { \nprivate static final boolean checkInt ( String s ) { \ntry { \nint val = Integer . parseInt ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkInt() - string: '\" + s + \"'   value: \" + val ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( NumberFormatException e ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"5800": "public class Attribute { \nprivate static final boolean checkUInt ( String s ) { \ntry { \nlong val = Long . parseLong ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkUInt() - string: '\" + s + \"'   value: \" + val ) ; \n} \nif ( val > 0xFFFFFFFFL ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nelse { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \ncatch ( NumberFormatException e ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n"}
{"5801": "public class Attribute { \nprivate static final boolean checkFloat ( String s ) { \ntry { \nfloat val = Float . parseFloat ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkFloat() - string: '\" + s + \"'   value: \" + val ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( NumberFormatException e ) { \nif ( s . equalsIgnoreCase ( \"nan\" ) || s . equalsIgnoreCase ( \"inf\" ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n"}
{"5802": "public class Attribute { \nprivate static final boolean checkDouble ( String s ) { \ntry { \ndouble val = Double . parseDouble ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkDouble() - string: '\" + s + \"'   value: \" + val ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( NumberFormatException e ) { \nif ( s . equalsIgnoreCase ( \"nan\" ) || s . equalsIgnoreCase ( \"inf\" ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n"}
{"5805": "public class StringValidateEncodeUtils { \n@ SuppressWarnings ( { \n\"SimplifiableIfStatement\" } \n) public static boolean validBooleanString ( String boolString ) { \nif ( boolString == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nMatcher m = VALID_CHARACTERS_FOR_BOOLEAN_STRING_PATTERN . matcher ( boolString ) ; \nif ( ! m . matches ( ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nreturn boolString . equalsIgnoreCase ( \"true\" ) || boolString . equalsIgnoreCase ( \"false\" ) ; \n} \n} \n"}
{"5806": "public class StringValidateEncodeUtils { \npublic static boolean validAlphanumericString ( String alphNumString ) { \nif ( alphNumString == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nMatcher m = VALID_CHARACTERS_FOR_ALPHANUMERIC_STRING_PATTERN . matcher ( alphNumString ) ; \nreturn m . matches ( ) ; \n} \n} \n"}
{"5807": "public class StringValidateEncodeUtils { \npublic static boolean validAlphanumericStringConstrainedSet ( String alphNumString , String [ ] constrainedSet , boolean ignoreCase ) { \nif ( alphNumString == null || constrainedSet == null || constrainedSet . length == 0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nMatcher m = VALID_CHARACTERS_FOR_ALPHANUMERIC_STRING_PATTERN . matcher ( alphNumString ) ; \nif ( ! m . matches ( ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nfor ( String s : constrainedSet ) { \nif ( ignoreCase ? alphNumString . equalsIgnoreCase ( s ) : alphNumString . equals ( s ) ) { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"5808": "public class StringValidateEncodeUtils { \n@ SuppressWarnings ( { \n\"UnnecessaryContinue\" } \n) public static boolean descendOnlyFilePath ( String path ) { \nString [ ] pathSegments = path . split ( \"/\" ) ; \nint i = 0 ; \nfor ( int indxOrigSegs = 0 ; \nindxOrigSegs < pathSegments . length ; \nindxOrigSegs ++ ) { \nString s = pathSegments [ indxOrigSegs ] ; \nif ( s . equals ( \".\" ) ) continue ; \nelse if ( s . equals ( \"..\" ) ) { \nif ( i == 0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \ni -- ; \n} \nelse { \ni ++ ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"5811": "public class GridDefRecord { \npublic static boolean compare ( GridDefRecord local , GridDefRecord other ) { \njava . util . Set < String > keys = local . getKeys ( ) ; \njava . util . Set < String > okeys = other . getKeys ( ) ; \nif ( keys . size ( ) != okeys . size ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfor ( String key : keys ) { \nif ( key . equals ( WIND_FLAG ) || key . equals ( RESOLUTION ) || key . equals ( VECTOR_COMPONENT_FLAG ) || key . equals ( GDS_KEY ) ) continue ; \nString val = local . getParam ( key ) ; \nString oval = other . getParam ( key ) ; \nif ( val . matches ( \"^[0-9]+\\\\.[0-9]*\" ) ) { \ndouble d = local . getDouble ( key ) ; \ndouble od = other . getDouble ( key ) ; \nif ( ! Misc . nearlyEquals ( d , od ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nelse if ( val . matches ( \"^[0-9]+\" ) ) { \nif ( ! val . equals ( oval ) ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nelse { \nif ( ! val . equals ( oval ) ) { \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"5844": "public class ImageFactoryRandom { \npublic boolean delete ( ) { \nif ( nextFile == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfileList . remove ( nextFile ) ; \nFile f = new File ( \"C:/tmp/deleted/\" + nextFile . getName ( ) ) ; \nreturn nextFile . renameTo ( f ) ; \n} \n} \n"}
{"5847": "public class H5Group { \nboolean isChildOf ( H5Group that ) { \nif ( parent == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( parent == that ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nreturn parent . isChildOf ( that ) ; \n} \n} \n"}
{"6068": "public class DefaultFeatureTiles { \nprivate boolean drawLinePath ( FeatureTileCanvas canvas , Path path , FeatureStyle featureStyle ) { \nCanvas lineCanvas = canvas . getLineCanvas ( ) ; \nPaint pathPaint = getLinePaint ( featureStyle ) ; \nlineCanvas . drawPath ( path , pathPaint ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"6069": "public class DefaultFeatureTiles { \nprivate boolean drawPolygonPath ( FeatureTileCanvas canvas , Path path , FeatureStyle featureStyle ) { \nCanvas polygonCanvas = canvas . getPolygonCanvas ( ) ; \nPaint fillPaint = getPolygonFillPaint ( featureStyle ) ; \nif ( fillPaint != null ) { \npath . setFillType ( Path . FillType . EVEN_ODD ) ; \npolygonCanvas . drawPath ( path , fillPaint ) ; \n} \nPaint pathPaint = getPolygonPaint ( featureStyle ) ; \npolygonCanvas . drawPath ( path , pathPaint ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"6189": "public class EnsureExceptionHandling { \npublic boolean chainHandlesThrowable ( Converter < ILoggingEvent > head ) { \nConverter < ILoggingEvent > c = head ; \nwhile ( c != null ) { \nif ( c instanceof ThrowableHandlingConverter ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nc = c . getNext ( ) ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6199": "public class RenameUtil { \nBoolean areOnDifferentVolumes ( File srcFile , File targetFile ) throws RolloverFailure { \nif ( ! EnvUtil . isJDK7OrHigher ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nFile parentOfTarget = targetFile . getAbsoluteFile ( ) . getParentFile ( ) ; \nif ( parentOfTarget == null ) { \naddWarn ( \"Parent of target file [\" + targetFile + \"] is null\" ) ; \nreturn null ; \n} \nif ( ! parentOfTarget . exists ( ) ) { \naddWarn ( \"Parent of target file [\" + targetFile + \"] does not exist\" ) ; \nreturn null ; \n} \ntry { \nboolean onSameFileStore = FileStoreUtil . areOnSameFileStore ( srcFile , parentOfTarget ) ; \nreturn ! onSameFileStore ; \n} \ncatch ( RolloverFailure rf ) { \naddWarn ( \"Error while checking file store equality\" , rf ) ; \nreturn null ; \n} \n} \n} \n"}
{"6205": "public class CallerData { \nprivate static boolean isInFrameworkSpaceList ( String currentClass , List < String > frameworkPackageList ) { \nif ( frameworkPackageList == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfor ( String s : frameworkPackageList ) { \nif ( currentClass . startsWith ( s ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"6207": "public class BasicStatusManager { \npublic boolean add ( StatusListener listener ) { \nsynchronized ( statusListenerListLock ) { \nif ( listener instanceof OnConsoleStatusListener ) { \nboolean alreadyPresent = checkForPresence ( statusListenerList , listener . getClass ( ) ) ; \nif ( alreadyPresent ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \nstatusListenerList . add ( listener ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6229": "public class AppenderAttachableImpl { \npublic boolean detachAppender ( Appender < E > appender ) { \nif ( appender == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nboolean result ; \nresult = appenderList . remove ( appender ) ; \nreturn result ; \n} \n} \n"}
{"6230": "public class AppenderAttachableImpl { \npublic boolean detachAppender ( String name ) { \nif ( name == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nboolean removed = false ; \nfor ( Appender < E > a : appenderList ) { \nif ( name . equals ( ( a ) . getName ( ) ) ) { \nremoved = appenderList . remove ( a ) ; \nbreak ; \n} \n} \nreturn removed ; \n} \n} \n"}
{"6233": "public class Logger { \npublic boolean detachAppender ( Appender < ILoggingEvent > appender ) { \nif ( aai == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nreturn aai . detachAppender ( appender ) ; \n} \n} \n"}
{"6238": "public class FileUtil { \nstatic public boolean createMissingParentDirectories ( File file ) { \nFile parent = file . getParentFile ( ) ; \nif ( parent == null ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nparent . mkdirs ( ) ; \nreturn parent . exists ( ) ; \n} \n} \n"}
{"6250": "public class OnMarkerEvaluator { \npublic boolean evaluate ( ILoggingEvent event ) throws NullPointerException , EvaluationException { \nMarker eventsMarker = event . getMarker ( ) ; \nif ( eventsMarker == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfor ( String markerStr : markerList ) { \nif ( eventsMarker . contains ( markerStr ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"6268": "public class StatusUtil { \nstatic public boolean contextHasStatusListener ( Context context ) { \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nList < StatusListener > listeners = sm . getCopyOfStatusListenerList ( ) ; \nif ( listeners == null || listeners . size ( ) == 0 ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nelse { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"6297": "public class ElementSelector { \npublic int getPrefixMatchLength ( ElementPath p ) { \nif ( p == null ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nint lSize = this . partList . size ( ) ; \nint rSize = p . partList . size ( ) ; \nif ( ( lSize == 0 ) || ( rSize == 0 ) ) { \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \nint minLen = ( lSize <= rSize ) ? lSize : rSize ; \nint match = 0 ; \nfor ( int i = 0 ; \ni < minLen ; \ni ++ ) { \nString l = this . partList . get ( i ) ; \nString r = p . partList . get ( i ) ; \nif ( equalityCheck ( l , r ) ) { \nmatch ++ ; \n} \nelse { \nbreak ; \n} \n} \nreturn match ; \n} \n} \n"}
{"6300": "public class PropertySetter { \nprivate boolean isUnequivocallyInstantiable ( Class < ? > clazz ) { \nif ( clazz . isInterface ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nObject o ; \ntry { \no = clazz . getDeclaredConstructor ( ) . newInstance ( ) ; \nif ( o != null ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nelse { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \ncatch ( InstantiationException e ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \ncatch ( IllegalAccessException e ) { \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \ncatch ( NoSuchMethodException e ) { \n{ \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \ncatch ( InvocationTargetException e ) { \n{ \nboolean return_variable_6 = false ; \nreturn return_variable_6 ; \n} \n} \n} \n} \n"}
{"6305": "public class ServerSocketReceiver { \nprotected boolean shouldStart ( ) { \nServerSocket serverSocket = null ; \ntry { \nserverSocket = getServerSocketFactory ( ) . createServerSocket ( getPort ( ) , getBacklog ( ) , getInetAddress ( ) ) ; \nServerListener < RemoteAppenderClient > listener = createServerListener ( serverSocket ) ; \nrunner = createServerRunner ( listener , getContext ( ) . getScheduledExecutorService ( ) ) ; \nrunner . setContext ( getContext ( ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Exception ex ) { \naddError ( \"server startup error: \" + ex , ex ) ; \nCloseUtil . closeQuietly ( serverSocket ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"6306": "public class AlgoliaException { \npublic boolean isTransient ( ) { \nThrowable cause = getCause ( ) ; \nif ( cause == null ) { \nreturn isServerError ( statusCode ) ; \n} \nelse if ( cause instanceof AlgoliaException ) { \nreturn ( ( AlgoliaException ) cause ) . isTransient ( ) ; \n} \nelse if ( cause instanceof IOException ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"6371": "public class RuleCompletionProcessor { \nprivate boolean isSubtypeOf ( String class1 , String class2 ) { \nif ( class1 == null || class2 == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nclass1 = convertToNonPrimitiveClass ( class1 ) ; \nclass2 = convertToNonPrimitiveClass ( class2 ) ; \nClassTypeResolver resolver = new ClassTypeResolver ( getUniqueImports ( ) , ProjectClassLoader . getProjectClassLoader ( getEditor ( ) ) ) ; \ntry { \nClass < ? > clazz1 = resolver . resolveType ( class1 ) ; \nClass < ? > clazz2 = resolver . resolveType ( class2 ) ; \nif ( clazz1 == null || clazz2 == null ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nreturn clazz2 . isAssignableFrom ( clazz1 ) ; \n} \ncatch ( ClassNotFoundException exc ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n"}
{"6372": "public class RuleCompletionProcessor { \npublic static boolean containsProposal ( final Collection < ICompletionProposal > proposals , String newProposal ) { \nfor ( ICompletionProposal prop : proposals ) { \nString displayString = prop . getDisplayString ( ) ; \nString [ ] existings = displayString . split ( \" \" ) ; \nif ( existings . length == 0 ) { \ncontinue ; \n} \nString [ ] newProposals = newProposal . split ( \" \" ) ; \nif ( newProposals . length == 0 ) { \ncontinue ; \n} \nif ( existings [ 0 ] . equals ( newProposals [ 0 ] ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6384": "public class ReteGraph { \npublic boolean addChild ( BaseVertex vertex ) { \nif ( vertex != null && vertices . add ( vertex ) ) { \nfirePropertyChange ( PROP_CHILD_ADDED , null , vertex ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6385": "public class ReteGraph { \npublic boolean removeChild ( BaseVertex vertex ) { \nif ( vertex != null && vertices . remove ( vertex ) ) { \nfirePropertyChange ( PROP_CHILD_REMOVED , null , vertex ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6434": "public class Status { \npublic boolean sameAs ( Object obj ) { \nif ( obj == null || ! ( obj instanceof Status ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nStatus other = ( Status ) obj ; \nif ( other . code != code || ! other . message . equals ( message ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nreturn other . extendedStatus . equals ( extendedStatus ) ; \n} \n} \n"}
{"6484": "public class AbstractResourceHandle { \nprotected boolean propertyHasChild ( QualifiedName propertyName , QualifiedName childName ) throws DAVException { \nPropertyStatus propertyStat = getProperty ( propertyName ) ; \nif ( propertyStat . getStatusCode ( ) == IResponse . SC_NOT_FOUND ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nexamineStatusCode ( propertyStat . getStatusCode ( ) , propertyStat . getStatusMessage ( ) ) ; \ntry { \nreturn ElementEditor . hasChild ( propertyStat . getProperty ( ) , childName ) ; \n} \ncatch ( MalformedElementException exception ) { \nthrow new SystemException ( exception ) ; \n} \n} \n} \n"}
{"6535": "public class Row { \npublic void optimize ( ) { \nfinal List < BaseVertex > sorted = new ArrayList < BaseVertex > ( this . vertices ) ; \nCollections . sort ( sorted , new Comparator < BaseVertex > ( ) { \npublic int compare ( final BaseVertex v1 , final BaseVertex v2 ) { \nint v1OutDegree = v1 . getSourceConnections ( ) . size ( ) ; \nint v2OutDegree = v2 . getSourceConnections ( ) . size ( ) ; \nif ( v1OutDegree < v2OutDegree ) { \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \nif ( v1OutDegree > v2OutDegree ) { \nreturn - 1 ; \n} \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \n} \n) ; \nfinal LinkedList < BaseVertex > optimized = new LinkedList < BaseVertex > ( ) ; \nboolean front = false ; \nfor ( final Iterator < BaseVertex > vertexIter = sorted . iterator ( ) ; \nvertexIter . hasNext ( ) ; \n) { \nfinal BaseVertex vertex = vertexIter . next ( ) ; \nif ( front ) { \noptimized . addFirst ( vertex ) ; \n} \nelse { \noptimized . addLast ( vertex ) ; \n} \nfront = ! front ; \n} \nthis . vertices = optimized ; \n} \n} \n"}
{"6537": "public class ExportImageDialog { \nprivate boolean validatePage ( ) { \nif ( ! resourceGroup . areAllValuesValid ( ) ) { \nif ( ! resourceGroup . getResource ( ) . equals ( \"\" ) ) { \nsetErrorMessage ( resourceGroup . getProblemMessage ( ) ) ; \n} \nelse { \nsetErrorMessage ( null ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nString resourceName = resourceGroup . getResource ( ) ; \nIWorkspace workspace = ResourcesPlugin . getWorkspace ( ) ; \nIPath fullPath = resourceGroup . getContainerFullPath ( ) ; \nif ( fullPath != null ) { \nString projectName = fullPath . segment ( 0 ) ; \nIStatus isValidProjectName = workspace . validateName ( projectName , IResource . PROJECT ) ; \nif ( isValidProjectName . isOK ( ) ) { \nIProject project = workspace . getRoot ( ) . getProject ( projectName ) ; \nif ( ! project . isOpen ( ) ) { \nsetErrorMessage ( IDEWorkbenchMessages . SaveAsDialog_closedProjectMessage ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \nIStatus result = workspace . validateName ( resourceName , IResource . FILE ) ; \nif ( ! result . isOK ( ) ) { \nsetErrorMessage ( result . getMessage ( ) ) ; \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nsetErrorMessage ( null ) ; \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"6544": "public class HttpOathOtpLoginModule { \nboolean verify_otp ( String userName , String otp ) { \ntry { \nString authString = userName + \":\" + otp ; \nString authStringEnc = Base64 . encodeBase64URLSafeString ( authString . getBytes ( ) ) ; \nBufferedReader in = attemptAuthentication ( authStringEnc ) ; \nString inputLine ; \nwhile ( ( inputLine = in . readLine ( ) ) != null ) { \nif ( inputLine . contains ( expectedOutput ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n} \ncatch ( Exception ex ) { \nlog . error ( \"Failed verifying OATH OTP :\" , ex ) ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6547": "public class YubicoClient { \npublic static boolean isValidOTPFormat ( String otp ) { \nif ( otp == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nint len = otp . length ( ) ; \nfor ( char c : otp . toCharArray ( ) ) { \nif ( c < 0x20 || c > 0x7E ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \nreturn OTP_MIN_LEN <= len && len <= OTP_MAX_LEN ; \n} \n} \n"}
{"6556": "public class OgnlRuntime { \npublic static final boolean isMoreSpecific ( Class [ ] classes1 , Class [ ] classes2 ) { \nfor ( int index = 0 , count = classes1 . length ; \nindex < count ; \n++ index ) { \nClass c1 = classes1 [ index ] , c2 = classes2 [ index ] ; \nif ( c1 == c2 ) continue ; \nelse if ( c1 . isPrimitive ( ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nelse if ( c1 . isAssignableFrom ( c2 ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nelse if ( c2 . isAssignableFrom ( c1 ) ) { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"6565": "public class OgnlOps { \npublic static long longValue ( Object value ) throws NumberFormatException { \nif ( value == null ) { \nint return_variable_0 = 0L ; \nreturn return_variable_0 ; \n} \nClass c = value . getClass ( ) ; \nif ( c . getSuperclass ( ) == Number . class ) return ( ( Number ) value ) . longValue ( ) ; \nif ( c == Boolean . class ) return ( ( Boolean ) value ) . booleanValue ( ) ? 1 : 0 ; \nif ( c == Character . class ) return ( ( Character ) value ) . charValue ( ) ; \nreturn Long . parseLong ( stringValue ( value , true ) ) ; \n} \n} \n"}
{"6566": "public class OgnlOps { \npublic static double doubleValue ( Object value ) throws NumberFormatException { \nif ( value == null ) { \ndouble return_variable_0 = 0.0 ; \nreturn return_variable_0 ; \n} \nClass c = value . getClass ( ) ; \nif ( c . getSuperclass ( ) == Number . class ) return ( ( Number ) value ) . doubleValue ( ) ; \nif ( c == Boolean . class ) return ( ( Boolean ) value ) . booleanValue ( ) ? 1 : 0 ; \nif ( c == Character . class ) return ( ( Character ) value ) . charValue ( ) ; \nString s = stringValue ( value , true ) ; \nreturn ( s . length ( ) == 0 ) ? 0.0 : Double . parseDouble ( s ) ; \n} \n} \n"}
{"6641": "public class Schema { \npublic int getEntity ( String name ) { \nInteger ch = ( Integer ) theEntities . get ( name ) ; \nif ( ch == null ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nreturn ch . intValue ( ) ; \n} \n} \n"}
{"6650": "public class BitmapManager { \npublic synchronized boolean canThreadDecoding ( Thread t ) { \nThreadStatus status = mThreadStatus . get ( t ) ; \nif ( status == null ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nreturn ( status . mState != State . CANCEL ) ; \n} \n} \n"}
{"6660": "public class Parser { \nprivate int lookupEntity ( char [ ] buff , int offset , int length ) { \nint result = 0 ; \nif ( length < 1 ) return result ; \nif ( buff [ offset ] == '#' ) { \nif ( length > 1 && ( buff [ offset + 1 ] == 'x' || buff [ offset + 1 ] == 'X' ) ) { \ntry { \nreturn Integer . parseInt ( new String ( buff , offset + 2 , length - 2 ) , 16 ) ; \n} \ncatch ( NumberFormatException e ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \ntry { \nreturn Integer . parseInt ( new String ( buff , offset + 1 , length - 1 ) , 10 ) ; \n} \ncatch ( NumberFormatException e ) { \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \n} \nreturn theSchema . getEntity ( new String ( buff , offset , length ) ) ; \n} \n} \n"}
{"6675": "public class ImageViewTouchBase { \nprotected float maxZoom ( ) { \nif ( mBitmapDisplayed . getBitmap ( ) == null ) { \n{ \ndouble return_variable_0 = 1F ; \nreturn return_variable_0 ; \n} \n} \nfloat fw = ( float ) mBitmapDisplayed . getWidth ( ) / ( float ) mThisWidth ; \nfloat fh = ( float ) mBitmapDisplayed . getHeight ( ) / ( float ) mThisHeight ; \nfloat max = Math . max ( fw , fh ) * 4 ; \nreturn max ; \n} \n} \n"}
{"6680": "public class FileHelper { \npublic static boolean pickDirectory ( Activity activity , File startPath , int requestCode ) { \nPackageManager packageMgr = activity . getPackageManager ( ) ; \nfor ( String [ ] intent : PICK_DIRECTORY_INTENTS ) { \nString intentAction = intent [ 0 ] ; \nString uriPrefix = intent [ 1 ] ; \nIntent startIntent = new Intent ( intentAction ) . putExtra ( \"org.openintents.extra.TITLE\" , activity . getString ( R . string . save_as ) ) . setData ( Uri . parse ( uriPrefix + startPath . getPath ( ) ) ) ; \ntry { \nif ( startIntent . resolveActivity ( packageMgr ) != null ) { \nactivity . startActivityForResult ( startIntent , requestCode ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \ncatch ( ActivityNotFoundException e ) { \nshowNoFilePickerError ( activity , e ) ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6685": "public class HTMLWriter { \nprivate boolean booleanAttribute ( String localName , String qName , String value ) { \nString name = localName ; \nif ( name == null ) { \nint i = qName . indexOf ( ':' ) ; \nif ( i != - 1 ) name = qName . substring ( i + 1 , qName . length ( ) ) ; \n} \nif ( ! name . equals ( value ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfor ( int j = 0 ; \nj < booleans . length ; \nj ++ ) { \nif ( name . equals ( booleans [ j ] ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"6692": "public class AwsKinesisTransactionStore { \nprivate boolean waitTheMinimalDurationToExecuteTheNextProvisioningRequest ( ) { \nif ( m_lastGetShardIteratorRequestTime != null ) { \nlong delay = m_durationBetweenRequests . get ( ) - ( System . currentTimeMillis ( ) - m_lastGetShardIteratorRequestTime ) ; \nif ( delay > 0 ) { \ntry { \nThread . sleep ( delay ) ; \n} \ncatch ( InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \nm_lastGetShardIteratorRequestTime = System . currentTimeMillis ( ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6797": "public class WroUtil { \npublic static boolean matchesUrl ( final HttpServletRequest request , final String path ) { \nfinal Pattern pattern = Pattern . compile ( \".*\" + path + \"[/]?\" , Pattern . CASE_INSENSITIVE ) ; \nif ( request . getRequestURI ( ) != null ) { \nfinal Matcher m = pattern . matcher ( request . getRequestURI ( ) ) ; \nreturn m . matches ( ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"6811": "public class Group { \npublic final boolean hasResourcesOfType ( final ResourceType resourceType ) { \nnotNull ( resourceType , \"ResourceType cannot be null!\" ) ; \nfor ( final Resource resource : resources ) { \nif ( resourceType . equals ( resource . getType ( ) ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6827": "public class ClassExpressionSaturationFactory { \nprivate static boolean updateIfSmaller ( AtomicInteger counter , int value ) { \nfor ( ; \n; \n) { \nint snapshotCoutner = counter . get ( ) ; \nif ( snapshotCoutner >= value ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( counter . compareAndSet ( snapshotCoutner , value ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"6836": "public class AbstractReasonerStage { \n@ Override public boolean preExecute ( ) { \nif ( isInitialized_ ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nLOGGER_ . trace ( \"{}: initialized\" , this ) ; \nthis . workerNo = reasoner . getNumberOfWorkers ( ) ; \nreturn isInitialized_ = true ; \n} \n} \n"}
{"6844": "public class LinearProbing { \nstatic < E > boolean contains ( E [ ] d , Object o ) { \nint pos = getPosition ( d , o ) ; \nif ( d [ pos ] == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6845": "public class LinearProbing { \nstatic < E > boolean add ( E [ ] d , E e ) { \nint pos = getPosition ( d , e ) ; \nif ( d [ pos ] == null ) { \nd [ pos ] = e ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6862": "public class ConcurrentComputationWithInputs { \npublic synchronized boolean submit ( I input ) throws InterruptedException { \nif ( termination || isInterrupted ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nbuffer_ . put ( input ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6867": "public class Operations { \npublic static < T > Set < T > filter ( final Set < ? extends T > input , final Condition < ? super T > condition , final int size ) { \nreturn new Set < T > ( ) { \n@ Override public int size ( ) { \nreturn size ; \n} \n@ Override public boolean isEmpty ( ) { \nreturn size == 0 ; \n} \n@ Override @ SuppressWarnings ( \"unchecked\" ) public boolean contains ( Object o ) { \nif ( ! input . contains ( o ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nT elem = null ; \ntry { \nelem = ( T ) o ; \n} \ncatch ( ClassCastException cce ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nreturn condition . holds ( elem ) ; \n} \n@ Override public Iterator < T > iterator ( ) { \nreturn filter ( input , condition ) . iterator ( ) ; \n} \n@ Override public Object [ ] toArray ( ) { \nObject [ ] result = new Object [ size ] ; \nint i = 0 ; \nfor ( Object o : filter ( input , condition ) ) { \nresult [ i ++ ] = o ; \n} \nreturn result ; \n} \n@ Override public < S > S [ ] toArray ( S [ ] a ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean add ( T e ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean remove ( Object o ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean containsAll ( Collection < ? > c ) { \nfor ( Object o : c ) { \nif ( contains ( o ) ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n@ Override public boolean addAll ( Collection < ? extends T > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean retainAll ( Collection < ? > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public boolean removeAll ( Collection < ? > c ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n@ Override public void clear ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \n} \n"}
{"6869": "public class ArraySlicedSet { \npublic boolean add ( int s , E e ) { \nif ( e == null ) throw new NullPointerException ( ) ; \nint mask = ( 1 << s ) ; \nint oldMask = addMask ( logs , data , masks , e , mask ) ; \nint newMask = oldMask | mask ; \nif ( newMask == oldMask ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nelse if ( oldMask == 0 && ++ occupied == LinearProbing . getUpperSize ( data . length ) ) enlarge ( ) ; \nsizes [ s ] ++ ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6870": "public class ArraySlicedSet { \npublic boolean remove ( int s , Object o ) { \nif ( o == null ) throw new NullPointerException ( ) ; \nint mask = 1 << s ; \nint oldMask = removeMask ( logs , data , masks , o , mask ) ; \nint newMask = oldMask & ~ mask ; \nif ( newMask == oldMask ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( newMask == 0 && -- occupied == LinearProbing . getLowerSize ( data . length ) ) shrink ( ) ; \nsizes [ s ] -- ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6892": "public class Affordance { \n@ JsonIgnore public boolean hasUnsatisfiedRequiredVariables ( ) { \nfor ( ActionDescriptor actionDescriptor : actionDescriptors ) { \nMap < String , ActionInputParameter > requiredParameters = actionDescriptor . getRequiredParameters ( ) ; \nfor ( ActionInputParameter annotatedParameter : requiredParameters . values ( ) ) { \nif ( ! annotatedParameter . hasValue ( ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"6947": "public class UsageNotificationManagerMBeanImpl { \npublic boolean getNotificationsEnabled ( String paramName ) { \nBoolean areNotificationsEnabled = paramNames . get ( paramName ) ; \nif ( ! isSlee11 ) { \nif ( areNotificationsEnabled == null || areNotificationsEnabled . booleanValue ( ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \nelse { \nif ( areNotificationsEnabled != null && areNotificationsEnabled . booleanValue ( ) ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nelse { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n} \n} \n"}
{"6951": "public class ServiceManagementImpl { \npublic boolean isRAEntityLinkNameReferenced ( String raLinkName ) { \nif ( raLinkName == null ) { \nthrow new NullPointerException ( \"null ra link name\" ) ; \n} \nboolean b = false ; \ntry { \nb = transactionManager . requireTransaction ( ) ; \nfor ( ServiceID serviceID : componentRepositoryImpl . getServiceIDs ( ) ) { \nServiceComponent serviceComponent = componentRepositoryImpl . getComponentByID ( serviceID ) ; \nif ( serviceComponent . getServiceState ( ) != ServiceState . INACTIVE && serviceComponent . getResourceAdaptorEntityLinks ( componentRepositoryImpl ) . contains ( raLinkName ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nfinally { \ntry { \ntransactionManager . requireTransactionEnd ( b , false ) ; \n} \ncatch ( Throwable ex ) { \nthrow new SLEEException ( ex . getMessage ( ) , ex ) ; \n} \n} \n} \n} \n"}
{"6969": "public class ActivityContextCacheData { \npublic boolean attachSbbEntity ( SbbEntityID sbbEntityId ) { \nfinal Node node = getAttachedSbbsNode ( true ) ; \nif ( ! node . hasChild ( sbbEntityId ) ) { \nnode . addChild ( Fqn . fromElements ( sbbEntityId ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"6973": "public class ActivityContextCacheData { \npublic boolean attachTimer ( TimerID timerID ) { \nfinal Node node = getAttachedTimersNode ( true ) ; \nif ( ! node . hasChild ( timerID ) ) { \nnode . addChild ( Fqn . fromElements ( timerID ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"6992": "public class MobicentsLogFilter { \npublic boolean isLoggable ( LogRecord record ) { \nLogger logger = getLogger ( record ) ; \nif ( record . getThrown ( ) != null ) { \nlogWithThrowable ( logger , record ) ; \n} \nelse { \nlogWithoutThrowable ( logger , record ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"7023": "public class ProfileAbstractClassDecorator { \npublic boolean decorateAbstractClass ( ) throws DeploymentException { \nClassPool pool = component . getClassPool ( ) ; \nProfileAbstractClassDescriptor abstractClass = component . getDescriptor ( ) . getProfileAbstractClass ( ) ; \nif ( abstractClass == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nString abstractClassName = abstractClass . getProfileAbstractClassName ( ) ; \ntry { \nctClass = pool . get ( abstractClassName ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find Abstract Class: \" + abstractClassName , nfe ) ; \n} \ndecorateClassJNDIAddToEnvironmentCalls ( ) ; \nif ( isAbstractClassDecorated ) { \ntry { \nString deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nctClass . writeFile ( deployDir ) ; \nctClass . detach ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Modified Abstract Class \" + ctClass . getName ( ) + \" generated in the following path \" + deployDir ) ; \n} \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nfinally { \nctClass . defrost ( ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nelse { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n"}
{"7032": "public class AlarmMBeanImpl { \npublic boolean isSourceOwnerOfAlarm ( NotificationSourceWrapper notificationSource , String alarmID ) { \nAlarmPlaceHolder aph = this . alarmIdToAlarm . get ( alarmID ) ; \nif ( aph == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nreturn aph . getNotificationSource ( ) . getNotificationSource ( ) . equals ( notificationSource . getNotificationSource ( ) ) ; \n} \n} \n"}
{"7036": "public class SLEESubDeployer { \npublic boolean accepts ( URL deployableUnitURL , String deployableUnitName ) { \nDeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; \nURL url = du . getUrl ( ) ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Method accepts called for \" + url + \" [DU: \" + deployableUnitName + \"]\" ) ; \n} \ntry { \nString fullPath = url . getFile ( ) ; \nString fileName = fullPath . substring ( fullPath . lastIndexOf ( '/' ) + 1 , fullPath . length ( ) ) ; \nif ( toAccept . containsKey ( fileName ) ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Accepting \" + url . toString ( ) + \".\" ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse if ( fileName . endsWith ( \".jar\" ) ) { \nJarFile duJarFile = null ; \ntry { \nif ( du . getEntry ( \"META-INF/deployable-unit.xml\" ) != null ) { \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Accepting \" + url . toString ( ) + \".\" ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \nfinally { \nif ( duJarFile != null ) { \ntry { \nduJarFile . close ( ) ; \n} \ncatch ( IOException ignore ) { \n} \nfinally { \nduJarFile = null ; \n} \n} \n} \n} \n} \ncatch ( Exception ignore ) { \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"7063": "public class ChildRelationImpl { \npublic boolean contains ( Object object ) { \nif ( ! ( object instanceof SbbLocalObject ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfinal SbbLocalObjectImpl sbblocal = ( SbbLocalObjectImpl ) object ; \nfinal SbbEntityID sbbEntityId = sbblocal . getSbbEntityId ( ) ; \nif ( ! idBelongsToChildRelation ( sbbEntityId ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nreturn new SbbEntityCacheData ( sbbEntityId , sleeContainer . getCluster ( ) . getMobicentsCache ( ) ) . exists ( ) ; \n} \n} \n"}
{"7064": "public class ChildRelationImpl { \n@ SuppressWarnings ( \"rawtypes\" ) public boolean containsAll ( Collection c ) { \nif ( c == null ) throw new NullPointerException ( \"null collection!\" ) ; \nfor ( Iterator it = c . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nif ( ! contains ( it . next ( ) ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"containsAll : collection = \" + c + \" > all in child relation\" ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7079": "public class ActivityContextImpl { \npublic boolean attachTimer ( TimerID timerID ) { \nif ( cacheData . attachTimer ( timerID ) ) { \nif ( acReferencesHandler != null ) { \nacReferencesHandler . timerReferenceCreated ( ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"7087": "public class DeployableUnit { \npublic boolean hasDependenciesSatisfied ( boolean showMissing ) { \nif ( isSelfSufficient ( ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nCollection < String > externalDependencies = getExternalDependencies ( ) ; \nexternalDependencies . removeAll ( sleeContainerDeployer . getDeploymentManager ( ) . getDeployedComponents ( ) ) ; \nif ( ! externalDependencies . isEmpty ( ) ) { \nif ( showMissing ) { \nString missingDepList = \"\" ; \nfor ( String missingDep : externalDependencies ) missingDepList += \"\\r\\n +-- \" + missingDep ; \nlogger . info ( \"Missing dependencies for \" + this . diShortName + \":\" + missingDepList ) ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"7088": "public class DeployableUnit { \npublic boolean hasDuplicates ( ) { \nArrayList < String > duplicates = new ArrayList < String > ( ) ; \nfor ( String componentId : componentIDs ) { \nif ( sleeContainerDeployer . getDeploymentManager ( ) . getDeployedComponents ( ) . contains ( componentId ) ) { \nduplicates . add ( componentId ) ; \n} \n} \nif ( ! duplicates . isEmpty ( ) ) { \nlogger . warn ( \"The deployable unit '\" + this . diShortName + \"' contains components that are already deployed. The following are already installed:\" ) ; \nfor ( String dupComponent : duplicates ) { \nlogger . warn ( \" - \" + dupComponent ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7091": "public class DeployableUnit { \nprivate boolean hasReferringDU ( ) throws Exception { \nSleeContainer sC = SleeContainer . lookupFromJndi ( ) ; \nfor ( String componentIdString : this . getComponents ( ) ) { \nComponentIDPropertyEditor cidpe = new ComponentIDPropertyEditor ( ) ; \ncidpe . setAsText ( componentIdString ) ; \nComponentID componentId = ( ComponentID ) cidpe . getValue ( ) ; \nfor ( ComponentID referringComponentId : sC . getComponentRepository ( ) . getReferringComponents ( componentId ) ) { \nComponentIDPropertyEditor rcidpe = new ComponentIDPropertyEditor ( ) ; \nrcidpe . setValue ( referringComponentId ) ; \nString referringComponentIdString = rcidpe . getAsText ( ) ; \nif ( ! this . getComponents ( ) . contains ( referringComponentIdString ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7110": "public class SbbAbstractClassDecorator { \npublic boolean decorateAbstractSbb ( ) throws DeploymentException { \nClassPool pool = component . getClassPool ( ) ; \nString sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; \ntry { \nsbbAbstractClass = pool . get ( sbbAbstractClassName ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find Abstract Sbb Class: \" + sbbAbstractClassName , nfe ) ; \n} \nconcreteMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \ni < methods . length ; \ni ++ ) { \nint mods = methods [ i ] . getModifiers ( ) ; \nif ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) { \nconcreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; \n} \n} \ndecorateENCBindCalls ( ) ; \ndecorateNewThreadCalls ( ) ; \nif ( isAbstractSbbClassDecorated ) { \ntry { \nString deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nsbbAbstractClass . writeFile ( deployDir ) ; \nsbbAbstractClass . detach ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Modified Abstract Class \" + sbbAbstractClass . getName ( ) + \" generated in the following path \" + deployDir ) ; \n} \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nfinally { \nsbbAbstractClass . defrost ( ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"7138": "public class SleeManagementMBeanImpl { \npublic void start ( ) throws InvalidStateException , ManagementException { \ntry { \nfinal SleeStateChangeRequest startingRequest = new SleeStateChangeRequest ( ) { \n@ Override public void stateChanged ( SleeState oldState ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( generateMessageWithLogo ( \"starting\" ) ) ; \n} \nnotifyStateChange ( oldState , getNewState ( ) ) ; \n} \n@ Override public void requestCompleted ( ) { \nfinal SleeStateChangeRequest runningRequest = new SleeStateChangeRequest ( ) { \nprivate SleeState oldState ; \n@ Override public void stateChanged ( SleeState oldState ) { \nlogger . info ( generateMessageWithLogo ( \"started\" ) ) ; \nthis . oldState = oldState ; \n} \n@ Override public void requestCompleted ( ) { \nnotifyStateChange ( oldState , getNewState ( ) ) ; \n} \n@ Override public boolean isBlockingRequest ( ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n@ Override public SleeState getNewState ( ) { \nreturn SleeState . RUNNING ; \n} \n} \n; \ntry { \nsleeContainer . setSleeState ( runningRequest ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( \"Failed to set container in RUNNING state\" , e ) ; \ntry { \nstop ( false ) ; \n} \ncatch ( Throwable f ) { \nlogger . error ( \"Failed to set container in STOPPED state, after failure to set in RUNNING state\" , e ) ; \n} \n} \n} \n@ Override public boolean isBlockingRequest ( ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n@ Override public SleeState getNewState ( ) { \nreturn SleeState . STARTING ; \n} \n} \n; \nsleeContainer . setSleeState ( startingRequest ) ; \n} \ncatch ( InvalidStateException ex ) { \nthrow ex ; \n} \ncatch ( Exception ex ) { \nthrow new ManagementException ( ex . getMessage ( ) , ex ) ; \n} \n} \n} \n"}
{"7143": "public class AbstractProfileEvent { \nboolean isProfileClassVisible ( ) { \ntry { \nThread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( profileAfterAction . getClass ( ) . getName ( ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Throwable e ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"7234": "public class LevelDBKeyValueStore { \nprivate boolean openDB ( File file , Options options ) { \ntry { \ndatabase = JniDBFactory . factory . open ( file , options ) ; \nlogger . info ( \"Using JNI Level DB\" ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( IOException ex1 ) { \ntry { \ndatabase = Iq80DBFactory . factory . open ( file , options ) ; \nlogger . info ( \"Using Java Level DB\" ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \ncatch ( IOException ex2 ) { \nreturn Exceptions . handle ( Boolean . class , ex2 ) ; \n} \n} \n} \n} \n"}
{"7248": "public class ObjectFilter { \npublic static Criterion notIn ( final Object name , final Object ... values ) { \nreturn new Criterion < Object > ( name . toString ( ) , Operator . NOT_IN , values ) { \n@ Override public boolean resolve ( Object owner ) { \nObject fieldValue = fieldValue ( ) ; \nif ( value == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nreturn ! valueSet ( ) . contains ( fieldValue ) ; \n} \n} \n; \n} \n} \n"}
{"7251": "public class DoubleList { \npublic boolean addArray ( double ... integers ) { \nif ( end + integers . length >= values . length ) { \nvalues = grow ( values , ( values . length + integers . length ) * 2 ) ; \n} \nSystem . arraycopy ( integers , 0 , values , end , integers . length ) ; \nend += integers . length ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"7288": "public class Int { \npublic static boolean equalsOrDie ( int expected , int got ) { \nif ( expected != got ) { \nreturn die ( Boolean . class , \"Expected was\" , expected , \"but we got \" , got ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"7289": "public class Int { \npublic static boolean equalsOrDie ( int [ ] expected , int [ ] got ) { \nif ( expected . length != got . length ) { \ndie ( \"Lengths did not match, expected length\" , expected . length , \"but got\" , got . length ) ; \n} \nfor ( int index = 0 ; \nindex < expected . length ; \nindex ++ ) { \nif ( expected [ index ] != got [ index ] ) { \ndie ( \"value at index did not match index\" , index , \"expected value\" , expected [ index ] , \"but got\" , got [ index ] ) ; \n} \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"7299": "public class Fields { \npublic static boolean classHasStringField ( Class < ? > clz , String name ) { \nList < Field > fields = Reflection . getAllFields ( clz ) ; \nfor ( Field field : fields ) { \nif ( field . getType ( ) . equals ( Typ . string ) && field . getName ( ) . equals ( name ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7300": "public class Fields { \npublic static boolean classHasField ( Class < ? > clz , String name ) { \nList < Field > fields = Reflection . getAllFields ( clz ) ; \nfor ( Field field : fields ) { \nif ( field . getName ( ) . equals ( name ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7303": "public class CacheEntry { \n@ Override public final int compareTo ( CacheEntry other ) { \nswitch ( type ) { \ncase LFU : return compareToLFU ( other ) ; \ncase LRU : return compareToLRU ( other ) ; \ncase FIFO : return compareToFIFO ( other ) ; \ndefault : die ( ) ; \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"7304": "public class CacheEntry { \nprivate final int compareTime ( CacheEntry other ) { \nif ( time > other . time ) { \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \nelse if ( time < other . time ) { \nreturn - 1 ; \n} \nelse if ( time == other . time ) { \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \ndie ( ) ; \n{ \nint return_variable_2 = 0 ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"7319": "public class CollectorManager { \nprivate boolean determineIfWeShouldExit ( ) { \nboolean shouldStop = stop . get ( ) ; \nif ( ! shouldStop ) { \nThread . interrupted ( ) ; \n} \nelse { \nSystem . out . println ( \"Exiting processing loop as requested\" ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7328": "public class BatchFileWriter { \npublic boolean syncToDisk ( ) { \nif ( outputStream != null && dirty ) { \ntry { \nif ( outputStream instanceof FileChannel ) { \nFileChannel channel = ( FileChannel ) outputStream ; \nchannel . force ( true ) ; \n} \ndirty = false ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Exception ex ) { \ncleanupOutputStream ( ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \nelse { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n"}
{"7381": "public class CouchDbClientBase { \npublic boolean contains ( String id ) { \nassertNotEmpty ( id , \"id\" ) ; \nHttpResponse response = null ; \ntry { \nresponse = head ( buildUri ( getDBUri ( ) ) . pathEncoded ( id ) . build ( ) ) ; \n} \ncatch ( NoDocumentException e ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfinally { \nclose ( response ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7398": "public class TokenAuthenticator { \nprivate boolean isQuery ( HttpServerExchange serverExchange ) { \nif ( serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"GET\" ) || serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"HEAD\" ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse if ( serverExchange . getRequestMethod ( ) . toString ( ) . equalsIgnoreCase ( \"POST\" ) ) { \nif ( postQuery != null && postQuery . matcher ( serverExchange . getRelativePath ( ) ) . find ( ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nelse { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \nelse { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n} \n"}
{"7446": "public class Base64 { \nprivate static int removeWhiteSpace ( char [ ] data ) { \nif ( data == null ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nint newSize = 0 ; \nint len = data . length ; \nfor ( int i = 0 ; \ni < len ; \ni ++ ) { \nif ( ! isWhiteSpace ( data [ i ] ) ) { \ndata [ newSize ++ ] = data [ i ] ; \n} \n} \nreturn newSize ; \n} \n} \n"}
{"7452": "public class SSPToken { \npublic boolean hasExpired ( ) { \nlong now = System . currentTimeMillis ( ) ; \nif ( created + ( expiresIn * 1000 ) + TIMEOUT_BUFFER > now ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7501": "public class Intersection2D_F64 { \npublic static double intersectionArea ( Rectangle2D_F64 a , Rectangle2D_F64 b ) { \nif ( ! intersects ( a , b ) ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \ndouble x0 = Math . max ( a . p0 . x , b . p0 . x ) ; \ndouble x1 = Math . min ( a . p1 . x , b . p1 . x ) ; \ndouble y0 = Math . max ( a . p0 . y , b . p0 . y ) ; \ndouble y1 = Math . min ( a . p1 . y , b . p1 . y ) ; \nreturn ( x1 - x0 ) * ( y1 - y0 ) ; \n} \n} \n"}
{"7516": "public class FitPlane3D_F64 { \npublic boolean solvePoint ( List < Point3D_F64 > points , Point3D_F64 pointOnPlane , Vector3D_F64 outputNormal ) { \nfinal int N = points . size ( ) ; \nA . reshape ( N , 3 ) ; \nint index = 0 ; \nfor ( int i = 0 ; \ni < N ; \ni ++ ) { \nPoint3D_F64 p = points . get ( i ) ; \nA . data [ index ++ ] = p . x - pointOnPlane . x ; \nA . data [ index ++ ] = p . y - pointOnPlane . y ; \nA . data [ index ++ ] = p . z - pointOnPlane . z ; \n} \nif ( ! solverNull . process ( A , 1 , nullspace ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \noutputNormal . x = ( double ) nullspace . unsafe_get ( 0 , 0 ) ; \noutputNormal . y = ( double ) nullspace . unsafe_get ( 1 , 0 ) ; \noutputNormal . z = ( double ) nullspace . unsafe_get ( 2 , 0 ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7528": "public class Intersection3D_F64 { \npublic static boolean intersect ( PlaneGeneral3D_F64 a , PlaneGeneral3D_F64 b , LineParametric3D_F64 line ) { \nGeometryMath_F64 . cross ( a . A , a . B , a . C , b . A , b . B , b . C , line . slope ) ; \nif ( line . slope . normSq ( ) == 0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \ndouble n2 = a . A * a . A + a . B * a . B + a . C * a . C ; \ndouble closestX = a . A * a . D / n2 ; \ndouble closestY = a . B * a . D / n2 ; \ndouble closestZ = a . C * a . D / n2 ; \ndouble slopeX = a . B * line . slope . z - a . C * line . slope . y ; \ndouble slopeY = a . C * line . slope . x - a . A * line . slope . z ; \ndouble slopeZ = a . A * line . slope . y - a . B * line . slope . x ; \ndouble top = b . D - b . A * closestX - b . B * closestY - b . C * closestZ ; \ndouble bottom = b . A * slopeX + b . B * slopeY + b . C * slopeZ ; \ndouble d = top / bottom ; \nline . p . x = closestX + d * slopeX ; \nline . p . y = closestY + d * slopeY ; \nline . p . z = closestZ + d * slopeZ ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7529": "public class Intersection3D_F64 { \nprivate static boolean containedPlane ( Point3D_F64 T_v0 , Point3D_F64 output , Vector3D_F64 u , Vector3D_F64 v , Vector3D_F64 w0 ) { \ndouble uu , uv , vv , wu , wv , D ; \nuu = u . dot ( u ) ; \nuv = u . dot ( v ) ; \nvv = v . dot ( v ) ; \nw0 . minus ( output , T_v0 ) ; \nwu = w0 . dot ( u ) ; \nwv = w0 . dot ( v ) ; \nD = uv * uv - uu * vv ; \ndouble s , t ; \ns = ( uv * wv - vv * wu ) / D ; \nif ( s < 0.0 || s > 1.0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nt = ( uv * wu - uu * wv ) / D ; \nreturn ! ( t < 0.0 ) && ! ( ( s + t ) > 1.0 ) ; \n} \n} \n"}
{"7530": "public class Intersection3D_F64 { \npublic static boolean intersect ( LineParametric3D_F64 line , Sphere3D_F64 sphere , Point3D_F64 a , Point3D_F64 b ) { \ndouble r2 = sphere . radius * sphere . radius ; \ndouble PP = GeometryMath_F64 . dot ( line . p , line . p ) ; \ndouble PV = GeometryMath_F64 . dot ( line . p , line . slope ) ; \ndouble PX = GeometryMath_F64 . dot ( line . p , sphere . center ) ; \ndouble VV = GeometryMath_F64 . dot ( line . slope , line . slope ) ; \ndouble VX = GeometryMath_F64 . dot ( line . slope , sphere . center ) ; \ndouble XX = GeometryMath_F64 . dot ( sphere . center , sphere . center ) ; \ndouble A = VV ; \ndouble B = 2.0 * ( PV - VX ) ; \ndouble C = PP + XX - 2.0 * PX - r2 ; \ndouble inner = B * B - 4.0 * A * C ; \nif ( inner < 0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \ndouble sqrt = Math . sqrt ( inner ) ; \ndouble t0 = ( - B + sqrt ) / ( 2.0 * A ) ; \ndouble t1 = ( - B - sqrt ) / ( 2.0 * A ) ; \nline . setPointOnLine ( t0 , a ) ; \nline . setPointOnLine ( t1 , b ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7538": "public class SpecialEuclideanOps_F64 { \npublic static boolean isIdentical ( Se3_F64 a , Se3_F64 b , double tolT , double tolR ) { \nif ( Math . abs ( a . T . x - b . T . x ) > tolT ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( Math . abs ( a . T . y - b . T . y ) > tolT ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( Math . abs ( a . T . z - b . T . z ) > tolT ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nDMatrixRMaj D = new DMatrixRMaj ( 3 , 3 ) ; \nCommonOps_DDRM . multTransA ( a . R , b . R , D ) ; \nRodrigues_F64 rod = new Rodrigues_F64 ( ) ; \nConvertRotation3D_F64 . matrixToRodrigues ( D , rod ) ; \nreturn rod . theta <= tolR ; \n} \n} \n"}
{"7540": "public class UtilCircle2D_F64 { \npublic static boolean circle ( Point2D_F64 x0 , Point2D_F64 x1 , Point2D_F64 x2 , Circle2D_F64 circle ) { \ndouble xa = ( x0 . x + x1 . x ) / 2.0 ; \ndouble ya = ( x0 . y + x1 . y ) / 2.0 ; \ndouble xb = ( x1 . x + x2 . x ) / 2.0 ; \ndouble yb = ( x1 . y + x2 . y ) / 2.0 ; \ndouble m2 = x0 . x - x1 . x ; \ndouble m1 = x1 . y - x0 . y ; \ndouble n2 = x2 . x - x1 . x ; \ndouble n1 = x1 . y - x2 . y ; \ndouble bottom = m2 * n1 - n2 * m1 ; \nif ( bottom == 0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \ndouble alpha = ( - m2 * ( xb - xa ) + m1 * ( yb - ya ) ) / bottom ; \ncircle . center . x = xb + n1 * alpha ; \ncircle . center . y = yb + n2 * alpha ; \ncircle . radius = circle . center . distance ( x0 ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7549": "public class Quadrilateral_F64 { \npublic boolean isEquals ( Quadrilateral_F64 quad , double tol ) { \ntol *= tol ; \nif ( a . distance2 ( quad . a ) > tol ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( b . distance2 ( quad . b ) > tol ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( c . distance2 ( quad . c ) > tol ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nreturn d . distance2 ( quad . d ) <= tol ; \n} \n} \n"}
{"7565": "public class GeoTuple_F64 { \npublic boolean isIdentical ( T t , double tol ) { \nif ( t . getDimension ( ) != getDimension ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nint N = getDimension ( ) ; \nfor ( int i = 0 ; \ni < N ; \ni ++ ) { \ndouble diff = Math . abs ( getIdx ( i ) - t . getIdx ( i ) ) ; \nif ( diff > tol ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"7570": "public class ParabolaGeneral_F64 { \npublic boolean isEquivalent ( ParabolaGeneral_F64 parabola , double tol ) { \ndouble scale = relativeScale ( parabola ) ; \nif ( Math . abs ( A * scale - parabola . A ) > tol ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( Math . abs ( C * scale - parabola . C ) > tol ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nif ( Math . abs ( D * scale - parabola . D ) > tol ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nif ( Math . abs ( E * scale - parabola . E ) > tol ) { \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \nif ( Math . abs ( F * scale - parabola . F ) > tol ) { \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n{ \nboolean return_variable_5 = true ; \nreturn return_variable_5 ; \n} \n} \n} \n"}
{"7583": "public class TangentLinesTwoEllipses_F64 { \nboolean selectTangent ( Point2D_F64 a , Point2D_F64 previousTangent , EllipseRotated_F64 ellipse , Point2D_F64 tangent , boolean cross ) { \nif ( ! tangentLines ( a , ellipse , temp0 , temp1 ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \ntempLine . a = a ; \ntempLine . b = temp0 ; \nboolean crossed0 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; \ntempLine . b = temp1 ; \nboolean crossed1 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; \nif ( crossed0 == crossed1 ) throw new RuntimeException ( \"Well this didn't work\" ) ; \nif ( cross == crossed0 ) { \nsumDifference += previousTangent . distance2 ( temp0 ) ; \ntangent . set ( temp0 ) ; \n} \nelse { \nsumDifference += previousTangent . distance2 ( temp1 ) ; \ntangent . set ( temp1 ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7585": "public class Distance3D_F64 { \npublic static double distance ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 ) { \ndouble x = l0 . p . x - l1 . p . x ; \ndouble y = l0 . p . y - l1 . p . y ; \ndouble z = l0 . p . z - l1 . p . z ; \ndouble dv01v1 = MiscOps . dot ( x , y , z , l1 . slope ) ; \ndouble dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; \ndouble dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; \ndouble bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; \ndouble t0 ; \nif ( bottom == 0 ) { \nt0 = 0 ; \n} \nelse { \nt0 = ( dv01v1 * dv1v0 - MiscOps . dot ( x , y , z , l0 . slope ) * dv1v1 ) / bottom ; \n} \ndouble t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; \ndouble dx = ( l0 . p . x + t0 * l0 . slope . x ) - ( l1 . p . x + t1 * l1 . slope . x ) ; \ndouble dy = ( l0 . p . y + t0 * l0 . slope . y ) - ( l1 . p . y + t1 * l1 . slope . y ) ; \ndouble dz = ( l0 . p . z + t0 * l0 . slope . z ) - ( l1 . p . z + t1 * l1 . slope . z ) ; \ndouble distanceSq = dx * dx + dy * dy + dz * dz ; \nif ( distanceSq < 0 ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nelse return Math . sqrt ( distanceSq ) ; \n} \n} \n"}
{"7586": "public class Distance3D_F64 { \npublic static double distance ( LineParametric3D_F64 l , Point3D_F64 p ) { \ndouble x = l . p . x - p . x ; \ndouble y = l . p . y - p . y ; \ndouble z = l . p . z - p . z ; \ndouble cc = x * x + y * y + z * z ; \ndouble b = MiscOps . dot ( x , y , z , l . slope ) / l . slope . norm ( ) ; \ndouble distanceSq = cc - b * b ; \nif ( distanceSq < 0 ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nelse { \nreturn Math . sqrt ( distanceSq ) ; \n} \n} \n} \n"}
{"7587": "public class Distance3D_F64 { \npublic static double distance ( LineSegment3D_F64 l , Point3D_F64 p ) { \ndouble dx = p . x - l . a . x ; \ndouble dy = p . y - l . a . y ; \ndouble dz = p . z - l . a . z ; \ndouble cc = dx * dx + dy * dy + dz * dz ; \ndouble slope_x = l . b . x - l . a . x ; \ndouble slope_y = l . b . y - l . a . y ; \ndouble slope_z = l . b . z - l . a . z ; \ndouble n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; \ndouble d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; \nif ( d <= 0 ) return p . distance ( l . a ) ; \nelse if ( d >= n ) return p . distance ( l . b ) ; \ndouble distanceSq = cc - d * d ; \nif ( distanceSq < 0 ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nelse { \nreturn Math . sqrt ( distanceSq ) ; \n} \n} \n} \n"}
{"7591": "public class Distance2D_F64 { \npublic static double distanceSq ( LineSegment2D_F64 segmentA , LineSegment2D_F64 segmentB ) { \ndouble slopeAX = segmentA . slopeX ( ) ; \ndouble slopeAY = segmentA . slopeY ( ) ; \ndouble slopeBX = segmentB . slopeX ( ) ; \ndouble slopeBY = segmentB . slopeY ( ) ; \ndouble ta = slopeBX * ( segmentA . a . y - segmentB . a . y ) - slopeBY * ( segmentA . a . x - segmentB . a . x ) ; \ndouble bottom = slopeBY * slopeAX - slopeAY * slopeBX ; \nif ( bottom != 0 ) { \nta /= bottom ; \nif ( ta >= 0 && ta <= 1.0 ) { \ndouble tb = slopeAX * ( segmentB . a . y - segmentA . a . y ) - slopeAY * ( segmentB . a . x - segmentA . a . x ) ; \ntb /= slopeAY * slopeBX - slopeBY * slopeAX ; \nif ( tb >= 0 && tb <= 1.0 ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \ndouble closest = Double . MAX_VALUE ; \nclosest = Math . min ( closest , distanceSq ( segmentA , segmentB . a ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentA , segmentB . b ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentB , segmentA . a ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentB , segmentA . b ) ) ; \nreturn closest ; \n} \n} \n"}
{"7602": "public class FitPolynomialSolverTall_F64 { \npublic boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { \nint N = length / 2 ; \nint numCoefs = output . size ( ) ; \nA . reshape ( N , numCoefs ) ; \nb . reshape ( N , 1 ) ; \nx . reshape ( numCoefs , 1 ) ; \nint end = offset + length ; \nfor ( int i = offset , idxA = 0 ; \ni < end ; \ni += 2 ) { \ndouble x = data [ i ] ; \ndouble y = data [ i + 1 ] ; \ndouble pow = 1.0 ; \nfor ( int j = 0 ; \nj < numCoefs ; \nj ++ ) { \nA . data [ idxA ++ ] = pow ; \npow *= x ; \n} \nb . data [ i / 2 ] = y ; \n} \nif ( ! solver . setA ( A ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nsolver . solve ( b , x ) ; \nfor ( int i = 0 ; \ni < numCoefs ; \ni ++ ) { \noutput . set ( i , x . data [ i ] ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7605": "public class UtilVector3D_F64 { \npublic static boolean isIdentical ( Vector3D_F64 a , Vector3D_F64 b , double tol ) { \nif ( Math . abs ( a . x - b . x ) > tol ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( Math . abs ( a . y - b . y ) > tol ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nreturn Math . abs ( a . z - b . z ) <= tol ; \n} \n} \n"}
{"7643": "public class InstallFeatureUtil { \nprivate static boolean isReplacementJar ( File file1 , File file2 ) { \nif ( file1 == null ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse if ( file2 == null ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nelse { \nString version1 = extractVersion ( file1 . getName ( ) ) ; \nString version2 = extractVersion ( file2 . getName ( ) ) ; \nreturn compare ( version1 , version2 ) < 0 ; \n} \n} \n} \n"}
{"7645": "public class InstallFeatureUtil { \nprivate static int compare ( String version1 , String version2 ) { \nif ( version1 == null && version2 == null ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nelse if ( version1 == null && version2 != null ) { \nreturn - 1 ; \n} \nelse if ( version1 != null && version2 == null ) { \n{ \nint return_variable_1 = 1 ; \nreturn return_variable_1 ; \n} \n} \nString [ ] components1 = version1 . split ( \"\\\\.\" ) ; \nString [ ] components2 = version2 . split ( \"\\\\.\" ) ; \nfor ( int i = 0 ; \ni < components1 . length && i < components2 . length ; \ni ++ ) { \nint comparison ; \ntry { \ncomparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; \n} \ncatch ( NumberFormatException e ) { \ncomparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; \n} \nif ( comparison != 0 ) { \nreturn comparison ; \n} \n} \nreturn components1 . length - components2 . length ; \n} \n} \n"}
{"7647": "public class SpringBootUtil { \npublic static boolean isSpringBootUberJar ( File artifact ) { \nif ( artifact == null || ! artifact . exists ( ) || ! artifact . isFile ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \ntry ( JarFile jarFile = new JarFile ( artifact ) ) { \nManifest manifest = jarFile . getManifest ( ) ; \nif ( manifest != null ) { \nAttributes attributes = manifest . getMainAttributes ( ) ; \nif ( attributes . getValue ( BOOT_VERSION_ATTRIBUTE ) != null && attributes . getValue ( BOOT_START_CLASS_ATTRIBUTE ) != null ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nelse { \nEnumeration < JarEntry > entries = jarFile . entries ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nJarEntry entry = entries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nif ( ! entryName . startsWith ( \"org\" ) && ( entryName . matches ( BOOT_JAR_EXPRESSION ) || entryName . matches ( BOOT_WAR_EXPRESSION ) ) ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n} \n} \ncatch ( IOException e ) { \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"7717": "public class UTF8 { \npublic static boolean canDecode ( byte [ ] input , int off , int len ) { \ntry { \ndecode ( input , off , len ) ; \n} \ncatch ( IllegalArgumentException ex ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7719": "public class CharStreams { \npublic static boolean equal ( Reader in1 , Reader in2 ) throws IOException { \nif ( in1 == in2 ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( in1 == null || in2 == null ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nin1 = buffer ( in1 ) ; \nin2 = buffer ( in2 ) ; \nint c1 = in1 . read ( ) ; \nint c2 = in2 . read ( ) ; \nwhile ( c1 != - 1 && c2 != - 1 && c1 == c2 ) { \nc1 = in1 . read ( ) ; \nc2 = in2 . read ( ) ; \n} \nreturn in1 . read ( ) == - 1 && in2 . read ( ) == - 1 ; \n} \n} \n"}
{"7751": "public class SunriseDate { \npublic boolean isSun ( ZonedDateTime currentDate ) { \nif ( getSun ( ) . getNeverRise ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse if ( getSun ( ) . getNeverSet ( ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nreturn timeWithinPeriod ( currentDate ) ; \n} \n} \n"}
{"7774": "public class Runtime { \nprivate boolean cfindloop ( Dfa d , Dfa s , int [ ] coldp ) { \nint begin ; \nint end ; \nint cold ; \nint open ; \nint close ; \nint estart ; \nint estop ; \nboolean shorter = 0 != ( g . tree . flags & Subre . SHORTER ) ; \nboolean hitend [ ] = new boolean [ 1 ] ; \nboolean lookingAt = 0 != ( eflags & Flags . REG_LOOKING_AT ) ; \nassert d != null && s != null ; \nclose = 0 ; \ndo { \nint [ ] cold0 = new int [ 1 ] ; \nif ( lookingAt ) { \nclose = d . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = 0 ; \n} \nelse { \nclose = s . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = cold0 [ 0 ] ; \n} \nif ( close == - 1 ) { \nbreak ; \n} \nassert cold != - 1 ; \nopen = cold ; \ncold = - 1 ; \nfor ( begin = open ; \nbegin <= close ; \nbegin ++ ) { \nif ( begin > 0 && lookingAt ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nestart = begin ; \nestop = data . length ( ) ; \nfor ( ; \n; \n) { \nif ( shorter ) { \nend = d . shortest ( begin , estart , estop , null , hitend ) ; \n} \nelse { \nend = d . longest ( begin , estop , hitend ) ; \n} \nif ( hitend [ 0 ] && cold == - 1 ) { \ncold = begin ; \n} \nif ( end == - 1 ) { \nbreak ; \n} \nfor ( int x = 0 ; \nx < match . size ( ) ; \nx ++ ) { \nmatch . set ( x , null ) ; \n} \nint maxsubno = getMaxSubno ( g . tree , 0 ) ; \nmem = new int [ maxsubno + 1 ] ; \nboolean matched = cdissect ( g . tree , begin , end ) ; \nif ( matched ) { \nmatch . set ( 0 , new RegMatch ( begin , end ) ) ; \ncoldp [ 0 ] = cold ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nif ( shorter ? end == estop : end == begin ) { \ncoldp [ 0 ] = cold ; \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nif ( shorter ) { \nestart = end + 1 ; \n} \nelse { \nestop = end - 1 ; \n} \n} \n} \n} \nwhile ( close < data . length ( ) ) ; \ncoldp [ 0 ] = cold ; \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"7776": "public class Runtime { \nprivate boolean crevdissect ( RuntimeSubexpression t , int begin , int end ) { \nDfa d ; \nDfa d2 ; \nint mid ; \nassert t . op == '.' ; \nassert t . left != null && t . left . machine . states . length > 0 ; \nassert t . right != null && t . right . machine . states . length > 0 ; \nassert 0 != ( t . left . flags & Subre . SHORTER ) ; \nd = new Dfa ( this , t . left . machine ) ; \nd2 = new Dfa ( this , t . right . machine ) ; \nif ( mem [ t . retry ] == 0 ) { \nmid = d . shortest ( begin , begin , end , null , null ) ; \nif ( mid == - 1 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \n} \nelse { \nmid = begin + ( mem [ t . retry ] - 1 ) ; \n} \nfor ( ; \n; \n) { \nboolean cdmatch = cdissect ( t . left , begin , mid ) ; \nif ( cdmatch && d2 . longest ( mid , end , null ) == end && ( cdissect ( t . right , mid , end ) ) ) { \nbreak ; \n} \nif ( mid == end ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nmid = d . shortest ( begin , mid + 1 , end , null , null ) ; \nif ( mid == - 1 ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \nzapmem ( t . left ) ; \nzapmem ( t . right ) ; \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"7777": "public class Runtime { \nprivate boolean cbrdissect ( RuntimeSubexpression t , int begin , int end ) { \nint i ; \nint n = t . number ; \nint len ; \nint paren ; \nint p ; \nint stop ; \nint min = t . min ; \nint max = t . max ; \nassert t . op == 'b' ; \nassert n >= 0 ; \nif ( match . get ( n ) == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nparen = match . get ( n ) . start ; \nlen = match . get ( n ) . end - match . get ( n ) . start ; \nif ( 0 != mem [ t . retry ] ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nmem [ t . retry ] = 1 ; \nif ( len == 0 ) { \nreturn begin == end ; \n} \nassert end >= begin ; \nif ( ( end - begin ) < len ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nstop = end - len ; \ni = 0 ; \nfor ( p = begin ; \np <= stop && ( i < max || max == Compiler . INFINITY ) ; \np += len ) { \nif ( g . compare . compare ( data , paren , p , len ) != 0 ) { \nbreak ; \n} \ni ++ ; \n} \nif ( p != end ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \nreturn min <= i && ( i <= max || max == Compiler . INFINITY ) ; \n} \n} \n"}
{"7825": "public class Nfa { \nlong analyze ( ) { \nArc a ; \nArc aa ; \nif ( pre . outs == null ) { \nreturn Flags . REG_UIMPOSSIBLE ; \n} \nfor ( a = pre . outs ; \na != null ; \na = a . outchain ) { \nfor ( aa = a . to . outs ; \naa != null ; \naa = aa . outchain ) { \nif ( aa . to == post ) { \nreturn Flags . REG_UEMPTYMATCH ; \n} \n} \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"7831": "public class Nfa { \nboolean unempty ( Arc a ) { \nState from = a . from ; \nState to = a . to ; \nboolean usefrom ; \nassert a . type == Compiler . EMPTY ; \nassert from != pre && to != post ; \nif ( from == to ) { \nfreearc ( a ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nusefrom = true ; \nif ( from . nouts > to . nins ) { \nusefrom = false ; \n} \nelse if ( from . nouts == to . nins ) { \nif ( from . nins > to . nouts ) { \nusefrom = false ; \n} \n} \nfreearc ( a ) ; \nif ( usefrom ) { \nif ( from . nouts == 0 ) { \nmoveins ( from , to ) ; \nfreestate ( from ) ; \n} \nelse { \ncopyins ( from , to ) ; \n} \n} \nelse { \nif ( to . nins == 0 ) { \nmoveouts ( to , from ) ; \nfreestate ( to ) ; \n} \nelse { \ncopyouts ( to , from ) ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7859": "public class DefaultBookmarksComparator { \nprotected int compareFolders ( final Entry e1 , final Entry e2 ) { \nfinal boolean f1 = e1 instanceof Folder ; \nfinal boolean f2 = e2 instanceof Folder ; \nif ( f1 && ! f2 ) { \nreturn - 1 ; \n} \nelse if ( ! f1 && f2 ) { \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \nelse { \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"7861": "public class DefaultBookmarksComparator { \nprotected int compareBookmarks ( final Entry e1 , final Entry e2 ) { \nif ( e1 instanceof Bookmark && e2 instanceof Bookmark ) { \nfinal Bookmark b1 = ( Bookmark ) e1 ; \nfinal Bookmark b2 = ( Bookmark ) e2 ; \nreturn new CompareToBuilder ( ) . append ( b1 . getUrl ( ) , b2 . getUrl ( ) ) . append ( b1 . isNewWindow ( ) , b2 . isNewWindow ( ) ) . toComparison ( ) ; \n} \nelse { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"7880": "public class JSPContextFinder { \nprivate boolean checkClassLoader ( ClassLoader classloader ) { \nif ( classloader == null || classloader == getParent ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfor ( ClassLoader parent = classloader . getParent ( ) ; \nparent != null ; \nparent = parent . getParent ( ) ) if ( parent == this ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"7881": "public class JSPContextFinder { \nprivate boolean startLoading ( String name ) { \nSet classesAndResources = ( Set ) cycleDetector . get ( ) ; \nif ( classesAndResources != null && classesAndResources . contains ( name ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( classesAndResources == null ) { \nclassesAndResources = new HashSet ( 3 ) ; \ncycleDetector . set ( classesAndResources ) ; \n} \nclassesAndResources . add ( name ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7944": "public class AbstractChannelServiceServlet { \nprotected boolean isAuthenticated ( final By by , final HttpServletRequest request ) { \nfinal String [ ] authToks = parseAuthorization ( request ) ; \nif ( authToks == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfinal String deployKey = authToks [ 1 ] ; \nlogger . debug ( \"Deploy key: '{}'\" , deployKey ) ; \nfinal ChannelService service = getService ( request ) ; \nif ( service == null ) { \nlogger . info ( \"Called 'isAuthenticated' without service\" ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nreturn service . getChannelDeployKeyStrings ( by ) . orElse ( Collections . emptySet ( ) ) . contains ( deployKey ) ; \n} \n} \n"}
{"7947": "public class LZMAEncoder { \npublic boolean encodeForLZMA2 ( ) { \ntry { \nif ( ! lz . isStarted ( ) && ! encodeInit ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nwhile ( uncompressedSize <= LZMA2_UNCOMPRESSED_LIMIT && rc . getPendingSize ( ) <= LZMA2_COMPRESSED_LIMIT ) if ( ! encodeSymbol ( ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \ncatch ( IOException e ) { \nthrow new Error ( ) ; \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"7955": "public class XmlFiles { \npublic static boolean isXml ( final Path path ) throws IOException { \nfinal XmlToolsFactory xml = Activator . getXmlToolsFactory ( ) ; \nfinal XMLInputFactory xin = xml . newXMLInputFactory ( ) ; \ntry ( InputStream stream = new BufferedInputStream ( Files . newInputStream ( path ) ) ) { \ntry { \nfinal XMLStreamReader reader = xin . createXMLStreamReader ( stream ) ; \nreader . next ( ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( final XMLStreamException e ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n} \n"}
{"7965": "public class JspReader { \nboolean matches ( String string ) throws JasperException { \nMark mark = mark ( ) ; \nint ch = 0 ; \nint i = 0 ; \ndo { \nch = nextChar ( ) ; \nif ( ( ( char ) ch ) != string . charAt ( i ++ ) ) { \nreset ( mark ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \nwhile ( i < string . length ( ) ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"7971": "public class JspReader { \nprivate boolean popFile ( ) throws JasperException { \nif ( current == null || currFileId < 0 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nString fName = getFile ( currFileId ) ; \ncurrFileId = unregisterSourceFile ( fName ) ; \nif ( currFileId < - 1 ) { \nerr . jspError ( \"jsp.error.file.not.registered\" , fName ) ; \n} \nMark previous = current . popStream ( ) ; \nif ( previous != null ) { \nmaster = current . baseDir ; \ncurrent = previous ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"8007": "public class LZEncoder { \npublic boolean verifyMatches ( Matches matches ) { \nint lenLimit = Math . min ( getAvail ( ) , matchLenMax ) ; \nfor ( int i = 0 ; \ni < matches . count ; \n++ i ) if ( getMatchLen ( matches . dist [ i ] , lenLimit ) != matches . len [ i ] ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8022": "public class Compiler { \nprivate boolean systemJarInWebinf ( String path ) { \nif ( path . indexOf ( \"/WEB-INF/\" ) < 0 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nBoolean useMyFaces = ( Boolean ) ctxt . getServletContext ( ) . getAttribute ( \"com.sun.faces.useMyFaces\" ) ; \nif ( useMyFaces == null || ! useMyFaces ) { \nfor ( String jar : systemJsfJars ) { \nif ( path . indexOf ( jar ) > 0 ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n} \nfor ( String jar : systemJars ) { \nif ( path . indexOf ( jar ) > 0 ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"8037": "public class JspConfig { \npublic boolean isJspPage ( String uri ) throws JasperException { \ninit ( ) ; \nif ( jspProperties == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nString uriPath = null ; \nint index = uri . lastIndexOf ( '/' ) ; \nif ( index >= 0 ) { \nuriPath = uri . substring ( 0 , index + 1 ) ; \n} \nString uriExtension = null ; \nindex = uri . lastIndexOf ( '.' ) ; \nif ( index >= 0 ) { \nuriExtension = uri . substring ( index + 1 ) ; \n} \nfor ( JspPropertyGroup jpg : jspProperties ) { \nJspProperty jp = jpg . getJspProperty ( ) ; \nString extension = jpg . getExtension ( ) ; \nString path = jpg . getPath ( ) ; \nif ( extension == null ) { \nif ( uri . equals ( path ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \nelse { \nif ( ( path == null || path . equals ( uriPath ) ) && ( extension . equals ( \"*\" ) || extension . equals ( uriExtension ) ) ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"8051": "public class JspUtil { \npublic static boolean isJavaKeyword ( String key ) { \nint i = 0 ; \nint j = javaKeywords . length ; \nwhile ( i < j ) { \nint k = ( i + j ) / 2 ; \nint result = javaKeywords [ k ] . compareTo ( key ) ; \nif ( result == 0 ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( result < 0 ) { \ni = k + 1 ; \n} \nelse { \nj = k ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8057": "public class MetadataCache { \npublic boolean put ( Locator locator , String key , String value ) throws CacheException { \nif ( value == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nTimer . Context cachePutTimerContext = MetadataCache . cachePutTimer . time ( ) ; \nboolean dbWrite = false ; \ntry { \nCacheKey cacheKey = new CacheKey ( locator , key ) ; \nString oldValue = cache . getIfPresent ( cacheKey ) ; \ncache . put ( cacheKey , value ) ; \nif ( oldValue == null || ! oldValue . equals ( value ) ) { \ndbWrite = true ; \n} \nif ( dbWrite ) { \nupdatedMetricMeter . mark ( ) ; \nif ( ! batchedWrites ) { \ndatabasePut ( locator , key , value ) ; \n} \nelse { \ndatabaseLazyWrite ( locator , key ) ; \n} \n} \nreturn dbWrite ; \n} \nfinally { \ncachePutTimerContext . stop ( ) ; \n} \n} \n} \n"}
{"8083": "public class ConfigTtlProvider { \nprivate boolean put ( ImmutableTable . Builder < Granularity , RollupType , TimeValue > ttlMapBuilder , Configuration config , Granularity gran , RollupType rollupType , TtlConfig configKey ) { \nint value ; \ntry { \nvalue = config . getIntegerProperty ( configKey ) ; \nif ( value < 0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \ncatch ( NumberFormatException ex ) { \nlog . trace ( String . format ( \"No valid TTL config set for granularity: %s, rollup type: %s\" , gran . name ( ) , rollupType . name ( ) ) , ex ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nttlMapBuilder . put ( gran , rollupType , new TimeValue ( value , TimeUnit . DAYS ) ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"8087": "public class ZKShardLockManager { \nprivate void registerMetrics ( final ObjectName nameObj , MetricRegistry reg ) { \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Lock Disinterested Time Millis\" ) , new JmxAttributeGauge ( nameObj , \"LockDisinterestedTimeMillis\" ) ) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Min Lock Hold Time Millis\" ) , new JmxAttributeGauge ( nameObj , \"MinLockHoldTimeMillis\" ) ) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Seconds Since Last Scavenge\" ) , new JmxAttributeGauge ( nameObj , \"SecondsSinceLastScavenge\" ) ) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Zk Connection Status\" ) , new JmxAttributeGauge ( nameObj , \"ZkConnectionStatus\" ) { \n@ Override public Object getValue ( ) { \nObject val = super . getValue ( ) ; \nif ( val . equals ( \"connected\" ) ) { \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \n{ \nint return_variable_1 = 0 ; \nreturn return_variable_1 ; \n} \n} \n} \n) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Held Shards\" ) , new Gauge < Integer > ( ) { \n@ Override public Integer getValue ( ) { \nreturn getHeldShards ( ) . size ( ) ; \n} \n} \n) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Unheld Shards\" ) , new Gauge < Integer > ( ) { \n@ Override public Integer getValue ( ) { \nreturn getUnheldShards ( ) . size ( ) ; \n} \n} \n) ; \nreg . register ( MetricRegistry . name ( ZKShardLockManager . class , \"Error Shards\" ) , new Gauge < Integer > ( ) { \n@ Override public Integer getValue ( ) { \nreturn getErrorShards ( ) . size ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"8142": "public class ImmobilieBaseTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public Boolean getAdressdruck ( ) { \nif ( adressdruck == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse { \nreturn adressdruck ; \n} \n} \n} \n"}
{"8163": "public class NumberUtils { \npublic static boolean isNumeric ( String value , Locale locale ) { \nif ( value == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nint start = 0 ; \nfinal DecimalFormatSymbols symbols = ( locale != null ) ? DecimalFormatSymbols . getInstance ( locale ) : DecimalFormatSymbols . getInstance ( ) ; \nif ( value . startsWith ( \"+\" ) || value . startsWith ( \"-\" ) ) start ++ ; \nboolean fraction = false ; \nfor ( int i = start ; \ni < value . length ( ) ; \ni ++ ) { \nfinal char c = value . charAt ( i ) ; \nif ( c == symbols . getDecimalSeparator ( ) && ! fraction ) { \nfraction = true ; \ncontinue ; \n} \nif ( c == symbols . getGroupingSeparator ( ) && ! fraction ) { \ncontinue ; \n} \nif ( ! Character . isDigit ( c ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"8204": "public class XmlValidationHandler { \n@ Override public boolean handleEvent ( ValidationEvent event ) { \nif ( event == null ) throw new IllegalArgumentException ( \"No validation event was provided!\" ) ; \nint line = - 1 ; \nint col = - 1 ; \nif ( event . getLocator ( ) != null ) { \nline = event . getLocator ( ) . getLineNumber ( ) ; \ncol = event . getLocator ( ) . getColumnNumber ( ) ; \n} \nif ( ValidationEvent . FATAL_ERROR == event . getSeverity ( ) ) { \nLOGGER . warn ( \"fatal validation error\" ) ; \nif ( line > - 1 && col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( ValidationEvent . WARNING == event . getSeverity ( ) ) { \nLOGGER . warn ( \"validation warning\" ) ; \nif ( line > - 1 && col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \nelse { \nLOGGER . warn ( \"validation error\" ) ; \nif ( line > - 1 && col > - 1 ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8216": "public class VersteigerungsterminTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public Boolean getWiederholungstermin ( ) { \nif ( wiederholungstermin == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse { \nreturn wiederholungstermin ; \n} \n} \n} \n"}
{"8217": "public class VersteigerungsterminTyp { \n@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public Boolean getTeilungsversteigerung ( ) { \nif ( teilungsversteigerung == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse { \nreturn teilungsversteigerung ; \n} \n} \n} \n"}
{"8349": "public class ObjectUtils { \npublic static boolean isCompatibleWithThrowsClause ( Throwable ex , Class < ? > [ ] declaredExceptions ) { \nif ( ! isCheckedException ( ex ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( declaredExceptions != null ) { \nint i = 0 ; \nwhile ( i < declaredExceptions . length ) { \nif ( declaredExceptions [ i ] . isAssignableFrom ( ex . getClass ( ) ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \ni ++ ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"8353": "public class XmlValidationModeDetector { \nprivate boolean hasOpeningTag ( String content ) { \nif ( this . inComment ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nint openTagIndex = content . indexOf ( '<' ) ; \nreturn ( openTagIndex > - 1 && content . length ( ) > openTagIndex && Character . isLetter ( content . charAt ( openTagIndex + 1 ) ) ) ; \n} \n} \n"}
{"8383": "public class WeakReferenceMonitor { \nprivate static boolean keepMonitoringThreadAlive ( ) { \nsynchronized ( WeakReferenceMonitor . class ) { \nif ( ! trackedEntries . isEmpty ( ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \nlogger . debug ( \"No entries left to track - stopping reference monitor thread\" ) ; \nmonitoringThread = null ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n} \n"}
{"8413": "public class MdPageGeneratorMojo { \n@ SuppressWarnings ( \"UnusedReturnValue\" ) private boolean preprocessMarkdownFiles ( File inputDirectory ) throws MojoExecutionException { \ngetLog ( ) . debug ( \"Read files from: \" + inputDirectory ) ; \ntry { \nif ( ! inputDirectory . exists ( ) ) { \ngetLog ( ) . info ( \"There is no input folder for the project. Skipping.\" ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nint baseDepth = StringUtils . countMatches ( inputDirectory . getAbsolutePath ( ) , File . separator ) ; \nList < File > markdownFiles = getFilesAsArray ( FileUtils . iterateFiles ( inputDirectory , getInputFileExtensions ( ) , recursiveInput ) ) ; \nfor ( File file : markdownFiles ) { \ngetLog ( ) . debug ( \"File getName() \" + file . getName ( ) ) ; \ngetLog ( ) . debug ( \"File getAbsolutePath() \" + file . getAbsolutePath ( ) ) ; \ngetLog ( ) . debug ( \"File getPath() \" + file . getPath ( ) ) ; \nMarkdownDTO dto = new MarkdownDTO ( ) ; \ndto . markdownFile = file ; \ndto . folderDepth = StringUtils . countMatches ( file . getAbsolutePath ( ) , File . separator ) - ( baseDepth + 1 ) ; \nif ( alwaysUseDefaultTitle ) { \ndto . title = defaultTitle ; \n} \nelse { \nList < String > raw = FileUtils . readLines ( file , getInputEncoding ( ) ) ; \ndto . title = getTitle ( raw ) ; \n} \nif ( applyFiltering ) { \nfor ( String line : FileUtils . readLines ( file , getInputEncoding ( ) ) ) { \nif ( isVariableLine ( line ) ) { \nString key = line . replaceAll ( \"(^\\\\{)|(=.*)\" , \"\" ) ; \nString value = line . replaceAll ( \"(^\\\\{(.*?)=)|(}$)\" , \"\" ) ; \ngetLog ( ) . debug ( \"Substitute: '\" + key + \"' -> '\" + value + \"'\" ) ; \ndto . substitutes . put ( key , value ) ; \n} \n} \n} \nString inputFileExtension = FilenameUtils . getExtension ( file . getName ( ) ) ; \ndto . htmlFile = new File ( recursiveInput ? outputDirectory + File . separator + file . getParentFile ( ) . getPath ( ) . substring ( inputDirectory . getPath ( ) . length ( ) ) + File . separator + file . getName ( ) . replaceAll ( \".\" + inputFileExtension , \".html\" ) : outputDirectory + File . separator + file . getName ( ) . replaceAll ( \".\" + inputFileExtension , \".html\" ) ) ; \ngetLog ( ) . debug ( \"File htmlFile() \" + dto . htmlFile ) ; \nmarkdownDTOs . add ( dto ) ; \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Unable to load file \" + e . getMessage ( ) , e ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8465": "public class Selector { \npublic Selector overlapVerticallyWith ( final SlideElement element , final float minOverlapRatio ) { \ncheckNotNull ( element ) ; \nfinal Rectangle r1 = element . getBounds ( ) ; \nr1 . x = 0 ; \nr1 . width = 1 ; \nelements = Collections2 . filter ( elements , new Predicate < SlideElement > ( ) { \n@ Override public boolean apply ( SlideElement e ) { \nif ( e == element ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( r1 . height == 0 ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nRectangle r2 = e . getBounds ( ) ; \nr2 . x = 0 ; \nr2 . width = 1 ; \nRectangle intersection = r1 . intersection ( r2 ) ; \nfloat yOverlapRatio = 1f * intersection . height / r1 . height ; \nreturn yOverlapRatio > minOverlapRatio ; \n} \n} \n) ; \nreturn this ; \n} \n} \n"}
{"8509": "public class TieWebSheetBean { \npublic int loadWorkSheetByTabName ( final String tabName ) { \ntry { \nint sheetId = this . getHelper ( ) . getWebSheetLoader ( ) . findTabIndexWithName ( tabName ) ; \nif ( ( getSheetConfigMap ( ) != null ) && ( sheetId < getSheetConfigMap ( ) . size ( ) ) ) { \nthis . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( tabName ) ; \nsetActiveTabIndex ( sheetId ) ; \n} \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"loadWorkSheetByTabName failed. error = \" + ex . getMessage ( ) , ex ) ; \n} \nreturn - 1 ; \n} \n} \n"}
{"8575": "public class ConfigurationUtility { \npublic static boolean isStaticRow ( final ConfigRange sourceConfigRange , final int rowIndex ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( int i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nif ( ( rowIndex >= command . getConfigRange ( ) . getFirstRowAddr ( ) . getRow ( ) ) && ( rowIndex < ( command . getConfigRange ( ) . getLastRowPlusAddr ( ) . getRow ( ) ) ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8576": "public class ConfigurationUtility { \npublic static boolean isStaticRowRef ( final ConfigRange sourceConfigRange , final Row row ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( int i = 0 ; \ni < sourceConfigRange . getCommandList ( ) . size ( ) ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nint rowIndex = row . getRowNum ( ) ; \nif ( ( rowIndex >= command . getTopRow ( ) ) && ( rowIndex < ( command . getTopRow ( ) + command . getFinalLength ( ) ) ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8591": "public class ConfigurationHandler { \nprivate boolean hasEachCommandInTheList ( final List < ConfigCommand > commandList ) { \nif ( commandList != null ) { \nfor ( ConfigCommand command : commandList ) { \nif ( command . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_EACH ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8612": "public class CommandUtility { \npublic static boolean isRowAllowAdd ( final Row row , final SheetConfiguration sheetConfig ) { \nString fullName = ConfigurationUtility . getFullNameFromRow ( row ) ; \nif ( fullName != null ) { \nConfigRangeAttrs attrs = sheetConfig . getShiftMap ( ) . get ( fullName ) ; \nif ( ( attrs != null ) && ( attrs . isAllowAdd ( ) ) && ( row . getRowNum ( ) == attrs . getFirstRowRef ( ) . getRowIndex ( ) ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8618": "public class CommandUtility { \npublic static boolean evalBoolExpression ( final ExpressionEngine expEngine , final String pscript ) { \nObject result = null ; \nString script = \"( \" + pscript + \" )\" ; \nscript = script . toUpperCase ( ) . replace ( \"AND\" , \"&&\" ) ; \nscript = script . toUpperCase ( ) . replace ( \"OR\" , \"||\" ) ; \ntry { \nresult = expEngine . evaluate ( script ) ; \n} \ncatch ( Exception e ) { \nLOG . log ( Level . SEVERE , \"WebForm WebFormHelper evalBoolExpression script = \" + script + \"; error = \" + e . getLocalizedMessage ( ) , e ) ; \n} \nif ( result != null ) { \nreturn ( ( Boolean ) result ) . booleanValue ( ) ; \n} \nelse { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"8677": "public class CellHelper { \nprivate boolean isNeedRestore ( final String fullName , final String [ ] parts ) { \nif ( fullName == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( ( parent . getCurrent ( ) . getCurrentDataContextName ( ) != null ) && ( parent . getCurrent ( ) . getCurrentDataContextName ( ) . toLowerCase ( ) . startsWith ( fullName . toLowerCase ( ) ) ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nreturn ( ( parts != null ) && ( parts . length > 1 ) ) ; \n} \n} \n"}
{"8727": "public class ParserUtility { \npublic static boolean isCommandString ( final String str ) { \nif ( str == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nreturn str . startsWith ( TieConstants . COMMAND_PREFIX ) ; \n} \n} \n"}
{"8747": "public class WebSheetUtility { \npublic static boolean isDate ( final String s ) { \nPattern pattern = Pattern . compile ( DATE_REGEX_4_DIGIT_YEAR ) ; \nString [ ] terms = s . split ( \" \" ) ; \nMatcher matcher ; \nfor ( String term : terms ) { \nmatcher = pattern . matcher ( term ) ; \nif ( matcher . matches ( ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \npattern = Pattern . compile ( DATE_REGEX_2_DIGIT_YEAR ) ; \nterms = s . split ( \" \" ) ; \nfor ( String term : terms ) { \nmatcher = pattern . matcher ( term ) ; \nif ( matcher . matches ( ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"8749": "public class WebSheetUtility { \npublic static boolean isNumeric ( final String str ) { \nString s = str ; \nif ( s . startsWith ( \"-\" ) ) { \ns = s . substring ( 1 ) ; \n} \nchar c ; \nint i ; \nint sLen = s . length ( ) ; \nShouldContinueParameter sPara = new ShouldContinueParameter ( false , false , 0 ) ; \nfor ( i = 0 ; \ni < sLen ; \ni ++ ) { \nc = s . charAt ( i ) ; \nif ( c < '0' || c > '9' ) { \nif ( ! shouldContinue ( c , sPara ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \nelse { \nif ( sPara . isCommaHit ( ) ) { \nsPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8750": "public class WebSheetUtility { \nprivate static boolean shouldContinue ( final char c , final ShouldContinueParameter para ) { \nif ( c == '.' && ! para . isDecimalHit ( ) ) { \npara . setDecimalHit ( true ) ; \nif ( para . isCommaHit ( ) && para . getSinceLastComma ( ) != 3 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nelse if ( c == ',' && ! para . isDecimalHit ( ) ) { \nif ( para . isCommaHit ( ) ) { \nif ( para . getSinceLastComma ( ) != 3 ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \npara . setSinceLastComma ( 0 ) ; \n} \npara . setCommaHit ( true ) ; \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"8752": "public class WebSheetUtility { \npublic static int cellCompareTo ( final Cell thisCell , final Cell otherCell ) { \nint r = thisCell . getRowIndex ( ) - otherCell . getRowIndex ( ) ; \nif ( r != 0 ) { \nreturn r ; \n} \nr = thisCell . getColumnIndex ( ) - otherCell . getColumnIndex ( ) ; \nif ( r != 0 ) { \nreturn r ; \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"8759": "public class ValidationHandler { \npublic boolean validateWithRowColInCurrentPage ( final int row , final int col , boolean updateGui ) { \nboolean submitMode = parent . getSubmitMode ( ) ; \nboolean passEmptyCheck = ! submitMode ; \nint topRow = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nint leftCol = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \nboolean pass = true ; \nFacesRow fRow = CellUtility . getFacesRowFromBodyRow ( row , parent . getBodyRows ( ) , topRow ) ; \nif ( fRow == null ) { \nreturn pass ; \n} \nFacesCell cell = CellUtility . getFacesCellFromBodyRow ( row , col , parent . getBodyRows ( ) , topRow , leftCol ) ; \nif ( cell == null ) { \nreturn pass ; \n} \nCell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( row , col ) ; \nboolean oldStatus = cell . isInvalid ( ) ; \nString value = CellUtility . getCellValueWithoutFormat ( poiCell ) ; \nif ( value == null ) { \nvalue = \"\" ; \n} \nelse { \nvalue = value . trim ( ) ; \n} \nif ( passEmptyCheck && value . isEmpty ( ) ) { \nrefreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; \nreturn pass ; \n} \nif ( ( ( parent . isOnlyValidateInSubmitMode ( ) && submitMode ) || ! parent . isOnlyValidateInSubmitMode ( ) ) && ! validateByTieWebSheetValidationBean ( poiCell , topRow , leftCol , cell , value , updateGui ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; \nList < CellFormAttributes > cellAttributes = CellControlsUtility . findCellValidateAttributes ( parent . getCellAttributesMap ( ) . getCellValidateAttributes ( ) , fRow . getOriginRowIndex ( ) , poiCell ) ; \nif ( parent . isAdvancedContext ( ) && parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) != null && ! checkErrorMessageFromObjectInContext ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , updateGui ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( cellAttributes != null ) { \npass = validateAllRulesForSingleCell ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , cellAttributes , updateGui ) ; \n} \nif ( pass ) { \nrefreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; \n} \nreturn pass ; \n} \n} \n"}
{"8760": "public class ValidationHandler { \nprivate boolean validateByTieWebSheetValidationBean ( final Cell poiCell , final int topRow , final int leftCol , final FacesCell cell , final String value , boolean updateGui ) { \nif ( parent . getTieWebSheetValidationBean ( ) != null ) { \nString errormsg = null ; \nString fullName = ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) ; \nString saveAttr = SaveAttrsUtility . prepareContextAndAttrsForCell ( poiCell , fullName , parent . getCellHelper ( ) ) ; \nif ( saveAttr != null ) { \nint row = poiCell . getRowIndex ( ) ; \nint col = poiCell . getColumnIndex ( ) ; \nerrormsg = parent . getTieWebSheetValidationBean ( ) . validate ( parent . getSerialDataContext ( ) . getDataContext ( ) , saveAttr , ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) , poiCell . getSheet ( ) . getSheetName ( ) , row , col , value ) ; \nif ( ( errormsg != null ) && ( ! errormsg . isEmpty ( ) ) ) { \ncell . setErrormsg ( errormsg ) ; \nrefreshAfterStatusChanged ( false , true , row - topRow , col - leftCol , cell , updateGui ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8761": "public class ValidationHandler { \nprivate boolean checkErrorMessageFromObjectInContext ( final int formRow , final int formCol , final FacesCell cell , final Cell poiCell , final String value , final SheetConfiguration sheetConfig , boolean updateGui ) { \n@ SuppressWarnings ( \"unchecked\" ) HashMap < String , TieCell > tieCells = ( HashMap < String , TieCell > ) parent . getSerialDataContext ( ) . getDataContext ( ) . get ( \"tiecells\" ) ; \nif ( tieCells != null ) { \nTieCell tieCell = tieCells . get ( CellUtility . getSkeyFromPoiCell ( poiCell ) ) ; \nif ( tieCell != null && tieCell . getContextObject ( ) != null ) { \nString errorMethod = tieCell . getMethodStr ( ) + parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) ; \nString errorMessage = CellControlsUtility . getObjectPropertyValue ( tieCell . getContextObject ( ) , errorMethod , true ) ; \nif ( errorMessage != null && ! errorMessage . isEmpty ( ) ) { \ncell . setErrormsg ( errorMessage ) ; \nLOG . log ( Level . INFO , \"Validation failed for sheet {0} row {1} column {2} : {3}\" , new Object [ ] { \npoiCell . getSheet ( ) . getSheetName ( ) , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , errorMessage } \n) ; \nrefreshAfterStatusChanged ( false , true , formRow , formCol , cell , updateGui ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8762": "public class ValidationHandler { \nprivate boolean validateAllRulesForSingleCell ( final int formRow , final int formCol , final FacesCell cell , final Cell poiCell , final String value , final SheetConfiguration sheetConfig , final List < CellFormAttributes > cellAttributes , boolean updateGui ) { \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) ; \nfor ( CellFormAttributes attr : cellAttributes ) { \nboolean pass = doValidation ( value , attr , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , sheet1 ) ; \nif ( ! pass ) { \nString errmsg = attr . getMessage ( ) ; \nif ( errmsg == null ) { \nerrmsg = TieConstants . DEFALT_MSG_INVALID_INPUT ; \n} \ncell . setErrormsg ( errmsg ) ; \nLOG . log ( Level . INFO , \"Validation failed for sheet {0} row {1} column {2} : {3}\" , new Object [ ] { \npoiCell . getSheet ( ) . getSheetName ( ) , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , errmsg } \n) ; \nrefreshAfterStatusChanged ( false , true , formRow , formCol , cell , updateGui ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8771": "public class ValidationHandler { \npublic boolean preValidation ( ) { \nString currentTabName = parent . getCurrent ( ) . getCurrentTabName ( ) ; \nString tabName = null ; \nString firstInvalidTabName = null ; \nboolean reload = false ; \nfor ( Map . Entry < String , SheetConfiguration > entry : parent . getSheetConfigMap ( ) . entrySet ( ) ) { \ntabName = entry . getKey ( ) ; \nif ( reload || ( ! tabName . equals ( currentTabName ) ) ) { \nparent . getWebSheetLoader ( ) . prepareWorkShee ( tabName ) ; \nreload = true ; \n} \nif ( ! parent . getValidationHandler ( ) . validateCurrentPage ( ) && ( firstInvalidTabName == null ) ) { \nfirstInvalidTabName = tabName ; \n} \n} \nif ( firstInvalidTabName != null ) { \nif ( ! tabName . equals ( firstInvalidTabName ) ) { \nparent . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( firstInvalidTabName ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8800": "public class WebSheetLoader { \npublic final Boolean isUnsavedStatus ( ) { \nMap < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; \nBoolean flag = ( Boolean ) viewMap . get ( TieConstants . UNSAVEDSTATE ) ; \nif ( flag == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nreturn flag ; \n} \n} \n"}
{"8864": "public class ImagesManager { \npublic boolean clearCache ( final String url ) { \nmemCache . remove ( url ) ; \ntry { \nreturn imagesResponseCache . deleteGetEntry ( url ) ; \n} \ncatch ( final IOException e ) { \nLog . w ( TAG , \"Cannot clear disk cache for \" + url , e ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"8906": "public class Genericode10Helper { \npublic static boolean isKeyColumn ( @ Nonnull final ColumnSet aColumnSet , @ Nullable final String sColumnID ) { \nif ( sColumnID != null ) for ( final Key aKey : getAllKeys ( aColumnSet ) ) for ( final KeyColumnRef aColumnRef : aKey . getColumnRef ( ) ) if ( aColumnRef . getRef ( ) instanceof Column ) if ( ( ( Column ) aColumnRef . getRef ( ) ) . getId ( ) . equals ( sColumnID ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8948": "public class GemFireIO { \npublic static boolean isErrorAndSendException ( ResultSender < Object > resultSender , Object data ) { \nif ( data instanceof Throwable ) { \nThrowable e = ( Throwable ) data ; \nresultSender . sendException ( e ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8969": "public class GemFireMgmt { \npublic static int stopMembersOnHost ( String hostName ) { \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp queryExp = null ; \nValueExp [ ] values = null ; \ntry { \nInetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; \nInetAddress address = null ; \nif ( addresses != null ) { \nvalues = new ValueExp [ addresses . length ] ; \nfor ( int i = 0 ; \ni < addresses . length ; \ni ++ ) { \naddress = addresses [ i ] ; \nvalues [ i ] = Query . value ( address . getHostAddress ( ) ) ; \n} \n} \n} \ncatch ( UnknownHostException e ) { \nDebugger . println ( e . getMessage ( ) ) ; \n} \nif ( values != null ) { \nqueryExp = Query . or ( Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( \"Host\" ) , values ) ) ; \n} \nelse { \nqueryExp = Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) ; \n} \nSet < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; \nif ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nint memberCount = memberObjectNames . size ( ) ; \nMemberMXBean member = null ; \nCollection < String > locators = new ArrayList < String > ( ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nmember = GemFireJmxClient . getMember ( objectName . getKeyProperty ( \"member\" ) , SingletonGemFireJmx . getJmx ( ) ) ; \nif ( member . isLocator ( ) ) { \nlocators . add ( member . getName ( ) ) ; \n} \nelse { \nshutDownMember ( member . getName ( ) ) ; \n} \n} \nfor ( String locatorName : locators ) { \nshutDownMember ( locatorName ) ; \n} \nreturn memberCount ; \n} \n} \n"}
{"8975": "public class GfdImportFunction { \nprivate boolean importRegion ( Region < Object , Object > region ) throws Exception { \nFile file = DataOpsSecretary . determineFile ( ExportFileType . gfd , region . getName ( ) ) ; \nif ( ! file . exists ( ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nregion . getSnapshotService ( ) . load ( file , SnapshotFormat . GEMFIRE ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8976": "public class GemFireNetworking { \npublic static boolean checkRemoteLocatorsAndLocatorsMatch ( String remoteLocators , String locators ) { \nif ( remoteLocators == null || remoteLocators . length ( ) == 0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( remoteLocators . equalsIgnoreCase ( locators ) ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nString [ ] remoteLocatorsArray = remoteLocators . split ( \",\" ) ; \nif ( locators == null || locators . length ( ) == 0 ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nString [ ] locatorsArray = locators . split ( \",\" ) ; \nString remoteLocatorHost , locatorHost ; \nint remoteLocatorPort , locatorPort ; \nfor ( String remoteLocator : remoteLocatorsArray ) { \nif ( remoteLocator == null || remoteLocator . length ( ) == 0 ) continue ; \nfor ( String locator : locatorsArray ) { \nif ( locator == null || locator . length ( ) == 0 ) continue ; \ntry { \nremoteLocatorHost = parseLocatorHost ( remoteLocator ) ; \nlocatorHost = parseLocatorHost ( locator ) ; \nremoteLocatorPort = parseLocatorPort ( remoteLocator ) ; \nlocatorPort = parseLocatorPort ( locator ) ; \nif ( Networking . hostEquals ( remoteLocatorHost , locatorHost ) && remoteLocatorPort == locatorPort ) { \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \nelse { \n} \n} \ncatch ( NumberFormatException e ) { \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \ncatch ( IllegalArgumentException e ) { \nthrow new IllegalArgumentException ( \"remoteLocator:\" + remoteLocator + \" locator:\" + locator + \" ERROR:\" + e . getMessage ( ) , e ) ; \n} \n} \n} \n{ \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \n} \n"}
{"8980": "public class SqliteInteger { \nboolean isTypeOf ( TypeMirror typeMirror ) { \nif ( integerKinds . contains ( typeMirror . getKind ( ) ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( integerObjects . contains ( typeMirror . toString ( ) ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"8986": "public class ShillelaghProcessor { \nprivate boolean checkForSuperType ( Element element , Class type ) { \nList < ? extends TypeMirror > superTypes = typeUtils . directSupertypes ( element . asType ( ) ) ; \nfor ( TypeMirror superType : superTypes ) { \nif ( superType . toString ( ) . equals ( type . getName ( ) ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"8994": "public class SqliteReal { \nboolean isTypeOf ( TypeMirror typeMirror ) { \nif ( realKinds . contains ( typeMirror . getKind ( ) ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( realObjects . contains ( typeMirror . toString ( ) ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"9040": "public class InMemorySldServiceImpl { \npublic boolean validate ( RawSld sld ) throws SldException { \ntry { \nparseXml ( \"\" , sld . getXml ( ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( JiBXException e ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"9088": "public class AttrbuteFilterExpressionCollectionEvaluator { \nprotected boolean evaluate ( final UUID attributeDefinitionUuid , final AttributeFilterExpression attributeFilter , final Map < UUID , String > eventAttributes , final List < AttributeDefinition > attributeDefinitions ) throws ParseException { \nif ( LOG . isTraceEnabled ( ) ) { \nLOG . entry ( attributeDefinitionUuid , attributeFilter , eventAttributes , attributeDefinitions ) ; \n} \nfinal String attributeValue = eventAttributes . get ( attributeDefinitionUuid ) ; \nif ( attributeValue == null ) { \nif ( LOG . isTraceEnabled ( ) ) { \nLOG . trace ( \"An attributeValue was not specified for this attribute definition.\" ) ; \nLOG . exit ( false ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfinal AttributeDefinition attributeDefinition = getApplicableAttributeDefinition ( attributeDefinitionUuid , attributeDefinitions ) ; \nif ( attributeDefinition == null ) { \nif ( LOG . isTraceEnabled ( ) ) { \nLOG . trace ( \"The attributeDefinition did not exist.\" ) ; \nLOG . exit ( false ) ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nfinal Unit unit = attributeDefinition . getUnits ( ) ; \ntry { \nboolean result = unit . evaluate ( attributeFilter . getOperator ( ) , attributeValue , attributeFilter . getOperand ( ) ) ; \nif ( LOG . isTraceEnabled ( ) ) { \nLOG . exit ( result ) ; \n} \nreturn result ; \n} \ncatch ( ParseException e ) { \nif ( LOG . isTraceEnabled ( ) ) { \nLOG . throwing ( e ) ; \n} \nthrow e ; \n} \n} \n} \n"}
{"9189": "public class ABaseClientWS { \npublic boolean isConnectionValid ( ) { \ntry { \nthis . getJson ( false , WS . Path . Test . Version1 . testConnection ( ) ) ; \n} \ncatch ( FluidClientException flowJobExcept ) { \nif ( flowJobExcept . getErrorCode ( ) == FluidClientException . ErrorCode . CONNECT_ERROR ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nthrow flowJobExcept ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9234": "public class HeaderGridView { \npublic boolean removeFooterView ( View v ) { \nif ( mFooterViewInfos . size ( ) > 0 ) { \nboolean result = false ; \nif ( mAdapter != null && ( ( FooterViewGridAdapter ) mAdapter ) . removeFooter ( v ) ) { \nnotifiyChanged ( ) ; \nresult = true ; \n} \nremoveFixedViewInfo ( v , mFooterViewInfos ) ; \nreturn result ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"9264": "public class BasicTaskWrapper { \nprotected boolean taskAccepted ( ) { \ntry { \ntask . accepted ( getElapsedTime ( ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Throwable t ) { \nlog . warn ( \"Unexpected error during 'accepted' for task: \" + taskString , t ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"9265": "public class BasicTaskWrapper { \nprotected boolean taskRejected ( RuntimeException e ) { \ntry { \ntask . rejected ( getElapsedTime ( ) , e ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Throwable t ) { \nlog . warn ( \"Unexpected error during 'rejected' for task: \" + taskString , t ) ; \nif ( e != null ) log . warn ( \"Original reason for rejection of task: \" + taskString , e ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"9266": "public class BasicTaskWrapper { \nprotected boolean taskStarted ( ) { \ntry { \ntask . started ( getElapsedTime ( ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Throwable t ) { \nlog . warn ( \"Unexpected error during 'started' for task: \" + taskString , t ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"9267": "public class BasicTaskWrapper { \nprotected boolean taskCompleted ( Throwable throwable ) { \ntry { \ntask . completed ( getElapsedTime ( ) , throwable ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Throwable t ) { \nlog . warn ( \"Unexpected error during 'completed' for task: \" + taskString , t ) ; \nif ( throwable != null ) log . warn ( \"Original error during 'run' for task: \" + taskString , throwable ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"9268": "public class BasicTaskWrapper { \nprotected boolean taskStop ( ) { \ntry { \ntask . stop ( ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Throwable t ) { \nlog . warn ( \"Unexpected error during 'stop' for task: \" + taskString , t ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"9296": "public class TimerTask { \npublic int compareTo ( Object other ) { \nif ( other == this ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nTimerTask t = ( TimerTask ) other ; \nlong diff = getNextExecutionTime ( ) - t . getNextExecutionTime ( ) ; \nreturn ( int ) diff ; \n} \n} \n"}
{"9405": "public class Graph { \npublic boolean addVertex ( Vertex < T > v ) { \nif ( verticies . containsValue ( v ) == false ) { \nverticies . put ( v . getName ( ) , v ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9407": "public class Graph { \npublic boolean removeVertex ( Vertex < T > v ) { \nif ( ! verticies . containsValue ( v ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nverticies . remove ( v . getName ( ) ) ; \nif ( v == rootVertex ) rootVertex = null ; \nfor ( int n = 0 ; \nn < v . getOutgoingEdgeCount ( ) ; \nn ++ ) { \nEdge < T > e = v . getOutgoingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > to = e . getTo ( ) ; \nto . remove ( e ) ; \nedges . remove ( e ) ; \n} \nfor ( int n = 0 ; \nn < v . getIncomingEdgeCount ( ) ; \nn ++ ) { \nEdge < T > e = v . getIncomingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > predecessor = e . getFrom ( ) ; \npredecessor . remove ( e ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9419": "public class DOMUtils { \npublic static boolean hasChildElements ( Node node ) { \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( int i = 0 ; \ni < nlist . getLength ( ) ; \ni ++ ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9438": "public class Classes { \npublic static boolean isPrimitiveWrapper ( final Class type ) { \nfor ( int i = 0 ; \ni < PRIMITIVE_WRAPPER_MAP . length ; \ni += 2 ) { \nif ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i + 1 ] ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9446": "public class WeakSet { \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nIterator iter = set . iterator ( ) ; \nObject UNKNOWN = new Object ( ) ; \nObject next = UNKNOWN ; \npublic boolean hasNext ( ) { \nif ( next != UNKNOWN ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nwhile ( iter . hasNext ( ) ) { \nWeakObject weak = ( WeakObject ) iter . next ( ) ; \nObject obj = null ; \nif ( weak != null && ( obj = weak . get ( ) ) == null ) { \ncontinue ; \n} \nnext = obj ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \npublic Object next ( ) { \nif ( ( next == UNKNOWN ) && ! hasNext ( ) ) { \nthrow new NoSuchElementException ( ) ; \n} \nObject obj = next ; \nnext = UNKNOWN ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \n} \n} \n; \n} \n} \n"}
{"9448": "public class PropertyGroup { \n@ SuppressWarnings ( \"unchecked\" ) public Set entrySet ( ) { \nfinal Set superSet = super . entrySet ( true ) ; \nreturn new java . util . AbstractSet ( ) { \nprivate boolean isInGroup ( Map . Entry entry ) { \nString key = ( String ) entry . getKey ( ) ; \nreturn key . startsWith ( basename ) ; \n} \npublic int size ( ) { \nIterator iter = superSet . iterator ( ) ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \ncount ++ ; \n} \n} \nreturn count ; \n} \npublic Iterator iterator ( ) { \nreturn new Iterator ( ) { \nprivate Iterator iter = superSet . iterator ( ) ; \nprivate Object next ; \npublic boolean hasNext ( ) { \nif ( next != null ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \nwhile ( next == null ) { \nif ( iter . hasNext ( ) ) { \nMap . Entry entry = ( Map . Entry ) iter . next ( ) ; \nif ( isInGroup ( entry ) ) { \nnext = entry ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \nelse { \nbreak ; \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \npublic Object next ( ) { \nif ( next == null ) throw new java . util . NoSuchElementException ( ) ; \nObject obj = next ; \nnext = null ; \nreturn obj ; \n} \npublic void remove ( ) { \niter . remove ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"9451": "public class PropertyEditors { \npublic static final boolean isNull ( final String value , final boolean trim , final boolean empty ) { \nif ( disableIsNull ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( value == null ) { \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \nString trimmed = trim ? value . trim ( ) : value ; \nif ( empty && trimmed . length ( ) == 0 ) { \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \nreturn NULL . equalsIgnoreCase ( trimmed ) ; \n} \n} \n"}
{"9483": "public class Vertex { \npublic boolean addEdge ( Edge < T > e ) { \nif ( e . getFrom ( ) == this ) outgoingEdges . add ( e ) ; \nelse if ( e . getTo ( ) == this ) incomingEdges . add ( e ) ; \nelse { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9486": "public class Vertex { \npublic boolean hasEdge ( Edge < T > e ) { \nif ( e . getFrom ( ) == this ) return outgoingEdges . contains ( e ) ; \nelse if ( e . getTo ( ) == this ) return incomingEdges . contains ( e ) ; \nelse { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"9487": "public class Vertex { \npublic boolean remove ( Edge < T > e ) { \nif ( e . getFrom ( ) == this ) outgoingEdges . remove ( e ) ; \nelse if ( e . getTo ( ) == this ) incomingEdges . remove ( e ) ; \nelse { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9490": "public class Vertex { \npublic int cost ( Vertex < T > dest ) { \nif ( dest == this ) { \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \nEdge < T > e = findEdge ( dest ) ; \nint cost = Integer . MAX_VALUE ; \nif ( e != null ) cost = e . getCost ( ) ; \nreturn cost ; \n} \n} \n"}
{"9492": "public class CompoundIterator { \npublic boolean hasNext ( ) { \nfor ( ; \nindex < iters . length ; \nindex ++ ) { \nif ( iters [ index ] != null && iters [ index ] . hasNext ( ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9495": "public class StructsBatchCompiler { \nprotected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { \nif ( ! parentFolder . exists ( ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( filter == null ) filter = ACCEPT_ALL_FILTER ; \nlog . debug ( \"Cleaning folder \" + parentFolder . toString ( ) ) ; \nfinal File [ ] contents = parentFolder . listFiles ( filter ) ; \nfor ( int j = 0 ; \nj < contents . length ; \nj ++ ) { \nfinal File file = contents [ j ] ; \nif ( file . isDirectory ( ) ) { \nif ( ! cleanFolder ( file , filter , continueOnError , true ) && ! continueOnError ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nelse { \nif ( ! file . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + file . getAbsolutePath ( ) ) ; \nif ( ! continueOnError ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n} \nif ( deleteParentFolder ) { \nif ( parentFolder . list ( ) . length == 0 && ! parentFolder . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + parentFolder . getAbsolutePath ( ) ) ; \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"9521": "public class JdbcFixture { \n@ SuppressWarnings ( \"unchecked\" ) public boolean connectJdbcOnWithUrlAndDriverAndUsernameAndPassword ( String dataBaseId , String url , String driverClassName , String username , String password ) throws ReflectiveOperationException { \nSimpleDriverDataSource dataSource = new SimpleDriverDataSource ( ) ; \ndataSource . setUrl ( url ) ; \ndataSource . setDriverClass ( ( Class < Driver > ) Class . forName ( driverClassName ) ) ; \ndataSource . setUsername ( username ) ; \ndataSource . setPassword ( password ) ; \nthis . templateMap . put ( dataBaseId , new JdbcTemplate ( dataSource ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"9522": "public class JdbcFixture { \npublic boolean runInTheSql ( String database , final String sql ) { \ngetDatabaseJdbcTemplate ( database ) . update ( sql ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"9527": "public class TableHelper { \npublic boolean backup ( SQLiteDatabase db , Context ctx , String suffix ) { \ntry { \nnew CsvTableWriter ( this ) . dumpToCsv ( ctx , db , suffix ) ; \n} \ncatch ( SQLException e ) { \nif ( e . getMessage ( ) . contains ( \"no such table\" ) ) { \nLog . w ( TAG , \"Table \" + this . getTableName ( ) + \" doesn't exist. This is expected if the table is new in this db version.\" ) ; \n} \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9549": "public class SQLiteDao { \npublic int delete ( Long id ) { \nif ( id != null ) { \nreturn getWritableDb ( ) . delete ( th . getTableName ( ) , th . getIdCol ( ) + \"=?\" , new String [ ] { \nid . toString ( ) } \n) ; \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"9550": "public class SQLiteDao { \npublic long save ( T obj ) { \nif ( th . getId ( obj ) == 0 ) { \nreturn insert ( obj ) ; \n} \nlong updated = update ( obj ) ; \nif ( updated == 1 ) { \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"9574": "public class ProgramLoader { \npublic static boolean loadAgent ( String className , int num , AObjectCatalog agents ) { \nClass < ? > aclass = loadClass ( className , Agent . class ) ; \nif ( aclass == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nAgentType atype = new AgentType ( className ) ; \natype . setAgentClass ( aclass ) ; \nGlobalState . agentTypes . push ( atype ) ; \nString [ ] goals = getGoalsFromAgentInfoAnnotation ( aclass ) ; \nif ( goals . length == 0 ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nloadGoalPlanNodes ( atype , goals ) ; \ncompleteGoalPlanHierarchy ( ) ; \ncreateAgentsInCatalog ( agents , atype , aclass , num ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"9575": "public class ProgramLoader { \nprivate static boolean processPlansForGoal ( GoalType gtype , String [ ] plans ) { \nfor ( int j = 0 ; \nj < plans . length ; \nj ++ ) { \nClass < ? > pclass = loadClass ( plans [ j ] , Plan . class ) ; \nif ( pclass == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nlogger . info ( \"Found Plan \" + pclass . getName ( ) + \" that handles Goal \" + gtype . getName ( ) ) ; \nPlanType ptype = new PlanType ( pclass . getName ( ) ) ; \nptype . setPlanClass ( pclass ) ; \nGlobalState . planTypes . push ( ptype ) ; \nptype . addParent ( ( byte ) gtype . getId ( ) ) ; \ngtype . addChild ( ( byte ) ptype . getId ( ) ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9579": "public class AObject { \npublic static boolean isNameEqual ( AObject obj1 , AObject obj2 ) { \nif ( obj1 . name == null || obj2 . name == null || obj1 . name . length != obj2 . name . length || obj1 . name . length == 0 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfor ( int i = 0 ; \ni < obj1 . name . length ; \ni ++ ) { \nif ( obj1 . name [ i ] != obj2 . name [ i ] ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"9588": "public class Stack255 { \npublic boolean push ( Object obj ) { \nif ( isFull ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( size == objects . length ) { \ngrow ( ) ; \n} \nobjects [ size ++ ] = obj ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9591": "public class ABeliefStore { \nprivate static boolean match ( Belief belief , AQuery query ) { \nassert ( belief != null ) ; \nassert ( query != null ) ; \nif ( belief . getBeliefset ( ) != query . getBeliefset ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nswitch ( query . getOp ( ) ) { \ncase EQ : Object lhs = belief . getTuple ( ) [ query . getField ( ) ] ; \nObject rhs = query . getValue ( ) ; \nreturn \"*\" . equals ( rhs ) || lhs . equals ( rhs ) ; \ncase GT : case LT : default : break ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9595": "public class Agent { \npublic boolean send ( int id , Goal msg ) { \nAObject obj = agents . get ( id ) ; \nif ( obj == null ) { \nlogger . warn ( \"{} attempted to send a message to unknown agent id '{}'\" , Log . logPrefix ( getId ( ) ) , id ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nlogger . debug ( \"{} is sending message of type {} to agent {}\" , Log . logPrefix ( getId ( ) ) , msg . getClass ( ) . getSimpleName ( ) , id ) ; \n( ( Agent ) obj ) . post ( msg ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9596": "public class Agent { \npublic boolean send ( String name , Goal msg ) { \nAObject obj = agents . find ( name ) ; \nif ( obj == null ) { \nlogger . warn ( \"{} attempted to send a message to unknown agent '{}'\" , Log . logPrefix ( getId ( ) ) , name ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n( ( Agent ) obj ) . post ( msg ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9606": "public class IntentionSelector { \nprivate boolean isStackValid ( Agent agent , Stack255 agentExecutionStack ) { \nif ( agentExecutionStack == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfinal int esSize = agentExecutionStack . size ( ) ; \nlogger . trace ( \"{} execution stack is {}/255 full\" , Log . logPrefix ( agent . getId ( ) ) , esSize ) ; \nif ( esSize == 0 ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( esSize >= 255 ) { \nlogger . error ( \"{} execution stack reached size limit of 255. Cannot continue.\" , Log . logPrefix ( agent . getId ( ) ) ) ; \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"9608": "public class IntentionSelector { \nprivate boolean manageGoal ( int agentIndex , Agent agent , Stack255 agentExecutionStack , Goal node ) { \nGoalType gtype = ( GoalType ) GlobalState . goalTypes . find ( node . getClass ( ) . getName ( ) ) ; \nbyte [ ] ptypes = gtype . getChildren ( ) ; \nassert ( ptypes != null ) ; \nbindings . clear ( ) ; \nfor ( int p = 0 ; \np < ptypes . length ; \np ++ ) { \nPlanType ptype = ( PlanType ) GlobalState . planTypes . get ( ptypes [ p ] ) ; \ntry { \nPlan planInstance = ( Plan ) ( ptype . getPlanClass ( ) . getConstructor ( Agent . class , Goal . class , String . class ) . newInstance ( GlobalState . agents . get ( agentIndex ) , node , \"p\" ) ) ; \nagent . clearLastResults ( ) ; \nif ( planInstance . context ( ) ) { \nSet < Belief > results = agent . getLastResults ( ) ; \nbindings . add ( planInstance , ( results == null ) ? null : new LinkedHashSet < Belief > ( results ) ) ; \n} \n} \ncatch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nlogger . error ( \"Could not create plan object of type \" + ptype . getClass ( ) . getName ( ) , e ) ; \n} \n} \nint numBindings = bindings . size ( ) ; \nif ( numBindings == 0 ) { \nlogger . debug ( Log . logPrefix ( agent . getId ( ) ) + \" has no applicable plans for goal \" + gtype + \" and will continue to wait indefinitely\" ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nagent . notifyAgentPrePlanSelection ( bindings ) ; \nPlan planInstance = bindings . selectPlan ( GlobalConstant . PLAN_SELECTION_POLICY ) ; \nsynchronized ( agentExecutionStack ) { \nlogger . debug ( Log . logPrefix ( agent . getId ( ) ) + \" choose an instance of plan \" + planInstance . getClass ( ) . getSimpleName ( ) + \" to handle goal \" + node . getClass ( ) . getSimpleName ( ) ) ; \nagentExecutionStack . push ( planInstance ) ; \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9611": "public class Board { \npublic boolean move ( int pinA , int pinB ) { \nif ( pinA < 0 || pinA >= pins . length || pinB < 0 || pinB >= pins . length ) { \nLog . warn ( \"Invalid board pin specified \" + pinA + \". Should be between 0..\" + ( pins . length - 1 ) + \" (inclusive).\" ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse if ( pins [ pinA ] . isEmpty ( ) ) { \nLog . warn ( \"No disc on pin\" + pinA ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nelse if ( pinA == pinB ) { \nLog . info ( \"Moving disc from pin\" + pinA + \" on to itself (means the board will not change)\" ) ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nint discOnA = pins [ pinA ] . get ( pins [ pinA ] . size ( ) - 1 ) ; \nint discOnB = ( pins [ pinB ] . isEmpty ( ) ) ? Integer . MAX_VALUE : pins [ pinB ] . get ( pins [ pinB ] . size ( ) - 1 ) ; \nif ( discOnB < discOnA ) { \nLog . warn ( \"Cannot move disc\" + discOnA + \" (pin\" + pinA + \") on to smaller disc\" + discOnB + \" (pin\" + pinB + \")\" ) ; \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \npins [ pinB ] . add ( pins [ pinA ] . remove ( pins [ pinA ] . size ( ) - 1 ) ) ; \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"9612": "public class Main { \npublic static boolean init ( Config config ) { \nif ( config . isDoPauseForUserInput ( ) ) { \nProgram . pauseForUserInput ( ) ; \n} \nLog . createLogger ( Main . LOGGER_NAME , config . getLogLevel ( ) , config . getLogFile ( ) ) ; \nlogger = LoggerFactory . getLogger ( Main . LOGGER_NAME ) ; \nint numAgents = 0 ; \nfor ( Config . AgentTypeData agentType : config . getAgents ( ) ) { \nnumAgents += agentType . getCount ( ) ; \n} \nfinal int increment = 10000 ; \nGlobalState . reset ( ) ; \nGlobalState . agents = new AObjectCatalog ( \"agents\" , numAgents , increment ) ; \nGlobalState . beliefbase = new ABeliefStore ( numAgents , config . getNumThreads ( ) ) ; \nlong t0 ; \nt0 = System . currentTimeMillis ( ) ; \nfor ( Config . AgentTypeData agentType : config . getAgents ( ) ) { \nif ( ! ProgramLoader . loadAgent ( agentType . getClassname ( ) , agentType . getCount ( ) , GlobalState . agents ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Created \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \nProgram . initIntentionSelectionPools ( numAgents , config . getNumThreads ( ) ) ; \nif ( config . getProgramOutputFile ( ) != null ) { \ntry { \nwriter = new PrintStream ( config . getProgramOutputFile ( ) , \"UTF-8\" ) ; \n} \ncatch ( FileNotFoundException | UnsupportedEncodingException e ) { \nlogger . error ( \"Could not open program outout file \" + config . getProgramOutputFile ( ) , e ) ; \n} \n} \nelse { \nwriter = System . out ; \n} \nProgram . initIntentionSelectionThreads ( config ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9622": "public class PartialResponse { \npublic boolean isEndReached ( ) { \nif ( to == null || from == null ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( length == null ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nreturn to == length - 1 ; \n} \n} \n"}
{"9676": "public class CSVRecordReader { \n@ Override public final boolean nextRecord ( ) throws IOException { \nfinal String line = reader . readLine ( ) ; \nif ( line == null ) { \nparts = null ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfinal List < String > newParts = splitLine ( line ) ; \nparts = newParts . toArray ( new String [ newParts . size ( ) ] ) ; \npartIndex = 0 ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9724": "public class QueryParametersParser { \nprivate static boolean isObject ( Type [ ] formalParameters ) { \nif ( formalParameters . length != 1 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nfinal Type type = formalParameters [ 0 ] ; \nif ( ! ( type instanceof Class ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( Types . isPrimitive ( type ) ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nif ( Types . isArrayLike ( type ) ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \nif ( Types . isMap ( type ) ) { \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \nif ( ConverterRegistry . hasType ( type ) ) { \n{ \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \n{ \nboolean return_variable_6 = true ; \nreturn return_variable_6 ; \n} \n} \n} \n"}
{"9754": "public class TinyContainer { \n@ Override public boolean login ( String username , String password ) { \ntry { \ngetHttpServletRequest ( ) . login ( username , password ) ; \n} \ncatch ( ServletException e ) { \nlog . debug ( e ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9762": "public class RequestPreprocessor { \nprivate static boolean startsWith ( String requestPath , String pathComponent ) { \nif ( requestPath . charAt ( 0 ) != '/' ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nint i = 1 ; \nfor ( int j = 0 ; \ni < requestPath . length ( ) ; \n++ i , ++ j ) { \nif ( requestPath . charAt ( i ) == '/' ) { \nreturn j == pathComponent . length ( ) ; \n} \nif ( j == pathComponent . length ( ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( Character . toLowerCase ( requestPath . charAt ( i ) ) != Character . toLowerCase ( pathComponent . charAt ( j ) ) ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"9878": "public class BlockLocks { \npublic boolean set ( int index ) { \nint wordNum = index >> 6 ; \nint bit = index & 0x3f ; \nlong bitmask = 1L << bit ; \nlong word , oword ; \ndo { \nword = bits . get ( wordNum ) ; \nif ( ( word & bitmask ) != 0 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \noword = word ; \nword |= bitmask ; \n} \nwhile ( ! bits . compareAndSet ( wordNum , oword , word ) ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9883": "public class AnnotationsParser { \nprivate boolean checkBracketsParenthesis ( ) { \nLOG . debug ( \"Check of brackets in the annotation section:\" ) ; \nif ( bracketCounterOpen == bracketCounterClose && parenthesisCounterOpen == parenthesisCounterClose && curlyBracketCounterOpen == curlyBracketCounterClose ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9888": "public class StateMachineParser { \npublic boolean checkPolymerId ( String polymerId ) { \nLOG . debug ( \"Validation of polymerID: \" + polymerId ) ; \nString pattern = \"PEPTIDE[1-9][0-9]*|RNA[1-9][0-9]*|CHEM[1-9][0-9]*|BLOB[1-9][0-9]*\" ; \nPattern p = Pattern . compile ( pattern , Pattern . CASE_INSENSITIVE ) ; \nMatcher m = p . matcher ( polymerId ) ; \nif ( m . matches ( ) ) { \nLOG . debug ( \"PolymerID is valid: \" + polymerId ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nLOG . debug ( \"PolymerID is not valid: \" + polymerId ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9889": "public class StateMachineParser { \npublic boolean checkPolymeridConnection ( String polymerId ) { \nLOG . debug ( \"Validation of polymerID in the connection section:\" ) ; \nString ratio = \"(:[1-9][0-9]*(\\\\.[0-9]+)?)?\" ; \nString id = \"(PEPTIDE[1-9][0-9]*|RNA[1-9][0-9]*|CHEM[1-9][0-9]*|BLOB[1-9][0-9]*|G[1-9][0-9]*)\" ; \nString pattern = \"(\\\\(\" + id + ratio + \"(,\" + id + ratio + \")+\\\\)\" + ratio + \"|\" + id + ratio + \")\" ; \nPattern p = Pattern . compile ( pattern , Pattern . CASE_INSENSITIVE ) ; \nMatcher m = p . matcher ( polymerId ) ; \nif ( m . matches ( ) ) { \nLOG . debug ( \"PolymerID in the connection section is valid:\" ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nLOG . debug ( \"PolymerID in the connection section is not valid: \" + polymerId ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9890": "public class StateMachineParser { \npublic boolean checkDetailsConnections ( String d ) { \nLOG . debug ( \"Validation of connection's details:\" ) ; \nString group = \"\\\\((\\\\D|\\\\d)((,|\\\\+)(\\\\D|\\\\d))+\\\\)\" ; \nString partOne = \"([1-9][0-9]*|\\\\D|\\\\?|\" + group + \")\" ; \nString partTwo = \"(R[1-9][0-9]*+|\\\\?)\" ; \nString element = partOne + \":\" + partTwo ; \nString patternConnection = element + \"-\" + element ; \nString hydrogenBondPartner = partOne + \":pair\" ; \nString hydrogenBondPattern = hydrogenBondPartner + \"-\" + hydrogenBondPartner ; \nPattern pConnection = Pattern . compile ( patternConnection , Pattern . CASE_INSENSITIVE ) ; \nMatcher mConnection = pConnection . matcher ( d ) ; \nPattern pHydrogen = Pattern . compile ( hydrogenBondPattern , Pattern . CASE_INSENSITIVE ) ; \nMatcher mHydrogen = pHydrogen . matcher ( d ) ; \nif ( mConnection . matches ( ) || mHydrogen . matches ( ) ) { \nLOG . debug ( \"Connection's details are valid:\" ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nLOG . debug ( \"Connection's details are not valid: \" + d ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9891": "public class StateMachineParser { \npublic boolean checkGroupId ( String d ) { \nPattern p = Pattern . compile ( \"G[1-9][0-9]*\" , Pattern . CASE_INSENSITIVE ) ; \nMatcher m = p . matcher ( d ) ; \nLOG . debug ( \"Validation of groupID:\" ) ; \nif ( m . matches ( ) ) { \nLOG . debug ( \"GroupID is valid:\" ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nLOG . debug ( \"GroupID is not valid:\" ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9892": "public class StateMachineParser { \npublic boolean checkRepeating ( String str ) { \nString pattern = \"\\\\d+|\\\\d+-\\\\d+\" ; \nif ( str . matches ( pattern ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9893": "public class StateMachineParser { \npublic boolean isPeptideOrRna ( ) throws SimplePolymerSectionException { \nif ( polymerElements . size ( ) >= 1 ) { \nif ( polymerElements . get ( polymerElements . size ( ) - 1 ) . matches ( \"(PEPTIDE[1-9][0-9]*+|RNA[1-9][0-9]*)\" ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nelse { \nthrow new SimplePolymerSectionException ( \"No Polymer Id is found\" ) ; \n} \n} \n} \n"}
{"9919": "public class ADiGraph { \npublic List < N > sortedNodesByReachability ( ) throws AGraphCircularityException { \nif ( hasCycles ( ) ) { \nthrow new AGraphCircularityException ( ) ; \n} \nfinal Object [ ] result = new Object [ nodes . length ] ; \nint nextIdx = 0 ; \nfinal Set < N > unprocessed = new HashSet < > ( ) ; \nfor ( Object node : nodes ) { \nunprocessed . add ( ( N ) node ) ; \n} \nwhile ( ! unprocessed . isEmpty ( ) ) { \nfinal Set < N > nextBatch = ACollectionHelper . filter ( unprocessed , new APredicateNoThrow < N > ( ) { \n@ Override public boolean apply ( N n ) { \nfor ( E e : incomingEdges ( n ) ) { \nif ( unprocessed . contains ( e . getFrom ( ) ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n) ; \nunprocessed . removeAll ( nextBatch ) ; \nfor ( N n : nextBatch ) { \nresult [ nextIdx ] = n ; \nnextIdx += 1 ; \n} \n} \nreturn new ArrayIterable < > ( result ) ; \n} \n} \n"}
{"9925": "public class API { \npublic boolean poll ( final int timeout ) throws InvalidInputException , MessageDecodingException , TerminateException { \nif ( Boolean . TRUE == poll_request ( timeout , true ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9929": "public class ForkJoinPool { \nprivate boolean createWorker ( ) { \nForkJoinWorkerThreadFactory fac = factory ; \nThrowable ex = null ; \nForkJoinWorkerThread wt = null ; \ntry { \nif ( fac != null && ( wt = fac . newThread ( this ) ) != null ) { \nwt . start ( ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \ncatch ( Throwable rex ) { \nex = rex ; \n} \nderegisterWorker ( wt , ex ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9935": "public class ForkJoinPool { \nprivate boolean awaitWork ( WorkQueue w , int r ) { \nif ( w == null || w . qlock < 0 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nfor ( int pred = w . stackPred , spins = SPINS , ss ; \n; \n) { \nif ( ( ss = w . scanState ) >= 0 ) break ; \nelse if ( spins > 0 ) { \nr ^= r << 6 ; \nr ^= r >>> 21 ; \nr ^= r << 7 ; \nif ( r >= 0 && -- spins == 0 ) { \nWorkQueue v ; \nWorkQueue [ ] ws ; \nint s , j ; \nAtomicLong sc ; \nif ( pred != 0 && ( ws = workQueues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scanState >= 0 ) ) spins = SPINS ; \n} \n} \nelse if ( w . qlock < 0 ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nelse if ( ! Thread . interrupted ( ) ) { \nlong c , prevctl , parkTime , deadline ; \nint ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; \nif ( ( ac <= 0 && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \nif ( ac <= 0 && ss == ( int ) c ) { \nprevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; \nint t = ( short ) ( c >>> TC_SHIFT ) ; \nif ( t > 2 && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) { \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \nparkTime = IDLE_TIMEOUT * ( ( t >= 0 ) ? 1 : 1 - t ) ; \ndeadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; \n} \nelse prevctl = parkTime = deadline = 0L ; \nThread wt = Thread . currentThread ( ) ; \nU . putObject ( wt , PARKBLOCKER , this ) ; \nw . parker = wt ; \nif ( w . scanState < 0 && ctl == c ) U . park ( false , parkTime ) ; \nU . putOrderedObject ( w , QPARKER , null ) ; \nU . putObject ( wt , PARKBLOCKER , null ) ; \nif ( w . scanState >= 0 ) break ; \nif ( parkTime != 0L && ctl == c && deadline - System . nanoTime ( ) <= 0L && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) { \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \n} \n{ \nboolean return_variable_5 = true ; \nreturn return_variable_5 ; \n} \n} \n} \n"}
{"9936": "public class ForkJoinPool { \nstatic int getSurplusQueuedTaskCount ( ) { \nThread t ; \nForkJoinWorkerThread wt ; \nForkJoinPool pool ; \nWorkQueue q ; \nif ( ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) ) { \nint p = ( pool = ( wt = ( ForkJoinWorkerThread ) t ) . pool ) . config & SMASK ; \nint n = ( q = wt . workQueue ) . top - q . base ; \nint a = ( int ) ( pool . ctl >> AC_SHIFT ) + p ; \nreturn n - ( a > ( p >>>= 1 ) ? 0 : a > ( p >>>= 1 ) ? 1 : a > ( p >>>= 1 ) ? 2 : a > ( p >>>= 1 ) ? 4 : 8 ) ; \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"9946": "public class ACollectionHelper { \npublic static < T , E extends Throwable > boolean forAll ( Iterable < T > coll , APredicate < ? super T , E > pred ) throws E { \nfor ( T o : coll ) { \nif ( ! pred . apply ( o ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"9961": "public class EMail { \npublic static Future < Boolean > send ( Email email ) { \ntry { \nemail = buildMessage ( email ) ; \nif ( GojaConfig . getProperty ( \"mail.smtp\" , StringPool . EMPTY ) . equals ( \"mock\" ) && GojaConfig . getApplicationMode ( ) . isDev ( ) ) { \nMock . send ( email ) ; \nreturn new Future < Boolean > ( ) { \n@ Override public boolean cancel ( boolean mayInterruptIfRunning ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n@ Override public boolean isCancelled ( ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n@ Override public boolean isDone ( ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n@ Override public Boolean get ( ) throws InterruptedException , ExecutionException { \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n@ Override public Boolean get ( long timeout , final TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \n} \n; \n} \nemail . setMailSession ( getSession ( ) ) ; \nreturn sendMessage ( email ) ; \n} \ncatch ( EmailException ex ) { \nthrow new MailException ( \"Cannot send email\" , ex ) ; \n} \n} \n} \n"}
{"9962": "public class EMail { \npublic static Future < Boolean > sendMessage ( final Email msg ) { \nif ( asynchronousSend ) { \nreturn executor . submit ( new Callable < Boolean > ( ) { \npublic Boolean call ( ) { \ntry { \nmsg . setSentDate ( new Date ( ) ) ; \nmsg . send ( ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( Throwable e ) { \nMailException me = new MailException ( \"Error while sending email\" , e ) ; \nlogger . error ( \"The email has not been sent\" , me ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n) ; \n} \nelse { \nfinal StringBuffer result = new StringBuffer ( ) ; \ntry { \nmsg . setSentDate ( new Date ( ) ) ; \nmsg . send ( ) ; \n} \ncatch ( Throwable e ) { \nMailException me = new MailException ( \"Error while sending email\" , e ) ; \nlogger . error ( \"The email has not been sent\" , me ) ; \nresult . append ( \"oops\" ) ; \n} \nreturn new Future < Boolean > ( ) { \npublic boolean cancel ( boolean mayInterruptIfRunning ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \npublic boolean isCancelled ( ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \npublic boolean isDone ( ) { \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \npublic Boolean get ( ) throws InterruptedException , ExecutionException { \nreturn result . length ( ) == 0 ; \n} \npublic Boolean get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nreturn result . length ( ) == 0 ; \n} \n} \n; \n} \n} \n} \n"}
{"10013": "public class StreamUtil { \npublic static boolean compare ( InputStream input1 , InputStream input2 ) throws IOException { \nif ( ! ( input1 instanceof BufferedInputStream ) ) { \ninput1 = new BufferedInputStream ( input1 ) ; \n} \nif ( ! ( input2 instanceof BufferedInputStream ) ) { \ninput2 = new BufferedInputStream ( input2 ) ; \n} \nint ch = input1 . read ( ) ; \nwhile ( ch != - 1 ) { \nint ch2 = input2 . read ( ) ; \nif ( ch != ch2 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nch = input1 . read ( ) ; \n} \nint ch2 = input2 . read ( ) ; \nreturn ( ch2 == - 1 ) ; \n} \n} \n"}
{"10014": "public class StreamUtil { \npublic static boolean compare ( Reader input1 , Reader input2 ) throws IOException { \nif ( ! ( input1 instanceof BufferedReader ) ) { \ninput1 = new BufferedReader ( input1 ) ; \n} \nif ( ! ( input2 instanceof BufferedReader ) ) { \ninput2 = new BufferedReader ( input2 ) ; \n} \nint ch = input1 . read ( ) ; \nwhile ( ch != - 1 ) { \nint ch2 = input2 . read ( ) ; \nif ( ch != ch2 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nch = input1 . read ( ) ; \n} \nint ch2 = input2 . read ( ) ; \nreturn ( ch2 == - 1 ) ; \n} \n} \n"}
{"10025": "public class Validator { \npublic static boolean isBirthDay ( String value ) { \nString check = \"(\\\\d{4})(/|-|\\\\.)(\\\\d{1,2})(/|-|\\\\.)(\\\\d{1,2})$\" ; \nif ( match ( check , Pattern . CASE_INSENSITIVE , value ) ) { \nint year = Integer . parseInt ( value . substring ( 0 , 4 ) ) ; \nint month = Integer . parseInt ( value . substring ( 5 , 7 ) ) ; \nint day = Integer . parseInt ( value . substring ( 8 , 10 ) ) ; \nif ( month < 1 || month > 12 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( day < 1 || day > 31 ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( ( month == 4 || month == 6 || month == 9 || month == 11 ) && day == 31 ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nif ( month == 2 ) { \nboolean isleap = ( year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) ; \nif ( day > 29 || ( day == 29 && ! isleap ) ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \nelse { \n{ \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \n} \n} \n"}
{"10041": "public class XML { \npublic static boolean validSignature ( Document document , Key publicKey ) { \nNode signatureNode = document . getElementsByTagNameNS ( XMLSignature . XMLNS , \"Signature\" ) . item ( 0 ) ; \nKeySelector keySelector = KeySelector . singletonKeySelector ( publicKey ) ; \ntry { \nString providerName = System . getProperty ( \"jsr105Provider\" , \"org.jcp.xml.dsig.internal.dom.XMLDSigRI\" ) ; \nXMLSignatureFactory fac = XMLSignatureFactory . getInstance ( \"DOM\" , ( Provider ) Class . forName ( providerName ) . newInstance ( ) ) ; \nDOMValidateContext valContext = new DOMValidateContext ( keySelector , signatureNode ) ; \nXMLSignature signature = fac . unmarshalXMLSignature ( valContext ) ; \nreturn signature . validate ( valContext ) ; \n} \ncatch ( Exception e ) { \nlogger . warn ( \"Error validating an XML signature.\" , e ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"10043": "public class ClassKit { \npublic static boolean isCacheSafe ( Class < ? > clazz , ClassLoader classLoader ) { \nPreconditions . checkNotNull ( clazz , \"Class must not be null\" ) ; \ntry { \nClassLoader target = clazz . getClassLoader ( ) ; \nif ( target == null ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nClassLoader cur = classLoader ; \nif ( cur == target ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nwhile ( cur != null ) { \ncur = cur . getParent ( ) ; \nif ( cur == target ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \ncatch ( SecurityException ex ) { \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \n} \n} \n"}
{"10047": "public class ClassKit { \npublic static boolean isAssignable ( Class < ? > lhsType , Class < ? > rhsType ) { \nPreconditions . checkNotNull ( lhsType , \"Left-hand side type must not be null\" ) ; \nPreconditions . checkNotNull ( rhsType , \"Right-hand side type must not be null\" ) ; \nif ( lhsType . isAssignableFrom ( rhsType ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( lhsType . isPrimitive ( ) ) { \nClass < ? > resolvedPrimitive = primitiveWrapperTypeMap . get ( rhsType ) ; \nif ( resolvedPrimitive != null && lhsType . equals ( resolvedPrimitive ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \nelse { \nClass < ? > resolvedWrapper = primitiveTypeToWrapperMap . get ( rhsType ) ; \nif ( resolvedWrapper != null && lhsType . isAssignableFrom ( resolvedWrapper ) ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"10068": "public class RequestPermission { \nprivate static boolean allValuesGranted ( Object [ ] values , HashMap < Permission , Result > resultMap ) { \nif ( values instanceof Permission [ ] ) { \nSet < Permission > valueSet = new HashSet < > ( Arrays . asList ( ( Permission [ ] ) values ) ) ; \nif ( resultMap . keySet ( ) . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . GRANTED != resultMap . get ( ( Permission ) value ) ) { \nmLog . i ( TAG , \"denied - \" + value . toString ( ) ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \nelse if ( values instanceof String [ ] ) { \nSet < String > valueSet = new HashSet < > ( Arrays . asList ( ( String [ ] ) values ) ) ; \nSet < String > permission = new HashSet < > ( ) ; \nfor ( Permission perm : resultMap . keySet ( ) ) { \npermission . add ( perm . toString ( ) ) ; \n} \nif ( permission . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . GRANTED != resultMap . get ( Permission . get ( String . valueOf ( value ) ) ) ) { \nmLog . i ( TAG , \"denied - \" + value ) ; \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \n} \n"}
{"10069": "public class RequestPermission { \nprivate static boolean anyValueDenied ( Object [ ] values , HashMap < Permission , Result > resultMap ) { \nif ( values instanceof Permission [ ] ) { \nSet < Permission > valueSet = new LinkedHashSet < > ( Arrays . asList ( ( Permission [ ] ) values ) ) ; \nif ( resultMap . keySet ( ) . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . DENIED == resultMap . get ( ( Permission ) value ) ) { \nmLog . i ( TAG , \"denied - \" + value . toString ( ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n} \nelse if ( values instanceof String [ ] ) { \nSet < String > valueSet = new HashSet < > ( Arrays . asList ( ( String [ ] ) values ) ) ; \nSet < String > permissionSet = new HashSet < > ( ) ; \nfor ( Permission perm : resultMap . keySet ( ) ) { \npermissionSet . add ( perm . toString ( ) ) ; \n} \nif ( permissionSet . containsAll ( valueSet ) ) { \nfor ( Object value : values ) { \nif ( Result . DENIED == resultMap . get ( Permission . get ( ( String ) value ) ) ) { \nmLog . i ( TAG , \"denied - \" + value ) ; \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"10073": "public class ReflectionKit { \npublic static boolean declaresException ( Method method , Class < ? > exceptionType ) { \nPreconditions . checkNotNull ( method , \"Method must not be null\" ) ; \nClass < ? > [ ] declaredExceptions = method . getExceptionTypes ( ) ; \nfor ( Class < ? > declaredException : declaredExceptions ) { \nif ( declaredException . isAssignableFrom ( exceptionType ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"10076": "public class WildcharUtils { \npublic static boolean match ( String string , String pattern ) { \nif ( string . equals ( pattern ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nreturn match ( string , pattern , 0 , 0 ) ; \n} \n} \n"}
{"10079": "public class ProtobufSerializerUtils { \npublic static final boolean isProtbufEntity ( Class < ? > clazz ) { \nfinal ProtobufEntity protoBufEntity = getProtobufEntity ( clazz ) ; \nif ( protoBufEntity != null ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"10115": "public class MuffinManager { \npublic boolean setClipboardContents ( Transferable data ) { \nif ( data == null ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( ( clipboardWriteStatus & CLIPBOARD_DISABLED ) == CLIPBOARD_DISABLED ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nclipboardWriteStatus = CLIPBOARD_ENABLED ; \nif ( cs == null ) { \ntry { \ncs = ( ClipboardService ) ServiceManager . lookup ( \"javax.jnlp.ClipboardService\" ) ; \n} \ncatch ( UnavailableServiceException e ) { \ncs = null ; \n} \n} \nif ( cs != null ) { \ntry { \ncs . setContents ( data ) ; \nclipboardWriteStatus = CLIPBOARD_ENABLED ; \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"10146": "public class FileExtensionFilter { \npublic boolean accept ( File pathname ) { \nString name = pathname . getName ( ) ; \nint iLastDot = name . lastIndexOf ( '.' ) ; \nString strExtension = \"\" ; \nif ( ( iLastDot != - 1 ) && ( iLastDot != name . length ( ) - 1 ) ) strExtension = name . substring ( iLastDot + 1 ) ; \nif ( m_rgstrIncludeExtensions != null ) { \nfor ( int i = 0 ; \ni < m_rgstrIncludeExtensions . length ; \ni ++ ) { \nif ( m_rgstrIncludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( m_rgstrExcludeExtensions != null ) { \nfor ( int i = 0 ; \ni < m_rgstrExcludeExtensions . length ; \ni ++ ) { \nif ( m_rgstrExcludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) { \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"10152": "public class JmxAttributePoller { \nprotected boolean pollIndividually ( ) throws IOException { \nthis . concurrencyTestHooks . onStartPollIndividually ( ) ; \nList < SchedulerProcessExecutionSlip > processExecutionSlipList = new LinkedList < > ( ) ; \nfor ( final Object onePolledObject : this . polledObjects ) { \nif ( shutdownInd ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nSchedulerProcess process = new PollOneObjectSchedulerProcess ( onePolledObject ) ; \nSchedulerProcessExecutionSlip executionSlip = this . scheduler . startProcess ( process ) ; \nprocessExecutionSlipList . add ( executionSlip ) ; \n} \nfor ( SchedulerProcessExecutionSlip oneExecutionSlip : processExecutionSlipList ) { \ntry { \noneExecutionSlip . waitUntilComplete ( ) ; \nPollOneObjectSchedulerProcess process = ( PollOneObjectSchedulerProcess ) oneExecutionSlip . getSchedulerProcess ( ) ; \nException exc = process . getFailureException ( ) ; \nif ( exc != null ) { \nlog . warn ( \"failed to poll object\" , exc ) ; \nif ( exc instanceof IOException ) { \nthrow ( IOException ) exc ; \n} \n} \n} \ncatch ( InterruptedException intExc ) { \nlog . info ( \"interrupted while polling object\" ) ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"10174": "public class WildcharPathUtils { \nprotected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { \nint patNdxStart = 0 ; \nint patNdxEnd = patterns . length - 1 ; \nint tokNdxStart = 0 ; \nint tokNdxEnd = tokens . length - 1 ; \nwhile ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { \nString patDir = patterns [ patNdxStart ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxStart ] , patDir ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \npatNdxStart ++ ; \ntokNdxStart ++ ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \nif ( patNdxStart > patNdxEnd ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \nwhile ( patNdxStart <= patNdxEnd && tokNdxStart <= tokNdxEnd ) { \nString patDir = patterns [ patNdxEnd ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxEnd ] , patDir ) ) { \n{ \nboolean return_variable_4 = false ; \nreturn return_variable_4 ; \n} \n} \npatNdxEnd -- ; \ntokNdxEnd -- ; \n} \nif ( tokNdxStart > tokNdxEnd ) { \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \n{ \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \n} \n{ \nboolean return_variable_6 = true ; \nreturn return_variable_6 ; \n} \n} \nwhile ( ( patNdxStart != patNdxEnd ) && ( tokNdxStart <= tokNdxEnd ) ) { \nint patIdxTmp = - 1 ; \nfor ( int i = patNdxStart + 1 ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( patterns [ i ] . equals ( PATH_MATCH ) ) { \npatIdxTmp = i ; \nbreak ; \n} \n} \nif ( patIdxTmp == patNdxStart + 1 ) { \npatNdxStart ++ ; \ncontinue ; \n} \nint patLength = ( patIdxTmp - patNdxStart - 1 ) ; \nint strLength = ( tokNdxEnd - tokNdxStart + 1 ) ; \nint ndx = - 1 ; \nstrLoop : for ( int i = 0 ; \ni <= strLength - patLength ; \ni ++ ) { \nfor ( int j = 0 ; \nj < patLength ; \nj ++ ) { \nString subPat = patterns [ patNdxStart + j + 1 ] ; \nString subStr = tokens [ tokNdxStart + i + j ] ; \nif ( ! WildcharUtils . match ( subStr , subPat ) ) { \ncontinue strLoop ; \n} \n} \nndx = tokNdxStart + i ; \nbreak ; \n} \nif ( ndx == - 1 ) { \n{ \nboolean return_variable_7 = false ; \nreturn return_variable_7 ; \n} \n} \npatNdxStart = patIdxTmp ; \ntokNdxStart = ndx + patLength ; \n} \nfor ( int i = patNdxStart ; \ni <= patNdxEnd ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \n{ \nboolean return_variable_8 = false ; \nreturn return_variable_8 ; \n} \n} \n} \n{ \nboolean return_variable_9 = true ; \nreturn return_variable_9 ; \n} \n} \n} \n"}
{"10203": "public class FreeNonAnonymousVariablePredicate { \npublic boolean evaluate ( Term term ) { \nif ( term . isVar ( ) && ( term instanceof Variable ) ) { \nVariable var = ( Variable ) term ; \nreturn ! var . isBound ( ) && ! var . isAnonymous ( ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"10205": "public class LexicographicalCollectionComparator { \npublic int compare ( Collection < T > c1 , Collection < T > c2 ) { \nIterator < T > i1 = c1 . iterator ( ) ; \nIterator < T > i2 = c2 . iterator ( ) ; \nwhile ( i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nT t1 = i1 . next ( ) ; \nT t2 = i2 . next ( ) ; \nint comp = comparator . compare ( t1 , t2 ) ; \nif ( comp < 0 ) { \nreturn - 1 ; \n} \nelse if ( comp > 0 ) { \n{ \nint return_variable_0 = 1 ; \nreturn return_variable_0 ; \n} \n} \n} \nif ( ! i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nreturn - 1 ; \n} \nif ( i1 . hasNext ( ) && ! i2 . hasNext ( ) ) { \n{ \nint return_variable_1 = 1 ; \nreturn return_variable_1 ; \n} \n} \n{ \nint return_variable_2 = 0 ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"10224": "public class PrologUnifier { \npublic boolean unifyInternal ( Term left , Term right , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( left == right ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nif ( ! left . isVar ( ) && ! right . isVar ( ) && left . isConstant ( ) && right . isConstant ( ) && left . equals ( right ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nelse if ( left . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) left , right , leftTrail , rightTrail ) ; \n} \nelse if ( right . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) right , left , rightTrail , leftTrail ) ; \n} \nelse if ( left . isFunctor ( ) && right . isFunctor ( ) ) { \nFunctor leftFunctor = ( Functor ) left ; \nFunctor rightFunctor = ( Functor ) right ; \nif ( ! left . equals ( right ) ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nint arity = leftFunctor . getArity ( ) ; \nfor ( int i = 0 ; \ni < arity ; \ni ++ ) { \nTerm leftArgument = leftFunctor . getArgument ( i ) ; \nTerm rightArgument = rightFunctor . getArgument ( i ) ; \nboolean result = unifyInternal ( leftArgument , rightArgument , leftTrail , rightTrail ) ; \nif ( ! result ) { \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n{ \nboolean return_variable_4 = true ; \nreturn return_variable_4 ; \n} \n} \nelse { \n{ \nboolean return_variable_5 = false ; \nreturn return_variable_5 ; \n} \n} \n} \n} \n"}
{"10225": "public class PrologUnifier { \nprotected boolean unifyVar ( Variable leftVar , Term rightTerm , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( leftVar . isBound ( ) ) { \nreturn unifyInternal ( leftVar . getValue ( ) , rightTerm , leftTrail , rightTrail ) ; \n} \nelse if ( rightTerm . isVar ( ) && ( ( Variable ) rightTerm ) . isBound ( ) ) { \nreturn unifyInternal ( leftVar , rightTerm . getValue ( ) , leftTrail , rightTrail ) ; \n} \nelse { \nleftVar . setSubstitution ( rightTerm ) ; \nleftTrail . add ( leftVar . getStorageCell ( leftVar ) ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"10237": "public class ReflectionUtils { \npublic static boolean classExistsAndIsLoadable ( String className ) { \ntry { \nClass . forName ( className ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( ClassNotFoundException e ) { \ne = null ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"10238": "public class ReflectionUtils { \npublic static boolean isSubTypeOf ( Class parent , String className ) { \ntry { \nClass cls = Class . forName ( className ) ; \nreturn parent . isAssignableFrom ( cls ) ; \n} \ncatch ( ClassNotFoundException e ) { \ne = null ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"10239": "public class ReflectionUtils { \npublic static boolean isSubTypeOf ( String parent , String child ) { \ntry { \nreturn isSubTypeOf ( Class . forName ( parent ) , Class . forName ( child ) ) ; \n} \ncatch ( ClassNotFoundException e ) { \ne = null ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"10240": "public class ReflectionUtils { \npublic static boolean isSubTypeOf ( Class parentClass , Class childClass ) { \ntry { \nchildClass . asSubclass ( parentClass ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( ClassCastException e ) { \ne = null ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"10297": "public class PrologParser { \nprivate boolean peekAndConsume ( int kind ) { \nToken nextToken = tokenSource . peek ( ) ; \nif ( nextToken . kind == kind ) { \ntry { \nconsumeToken ( kind ) ; \n} \ncatch ( SourceCodeException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"10396": "public class HierarchyAttribute { \npublic boolean isSubCategory ( HierarchyAttribute comp ) { \nif ( ! comp . attributeClass . attributeClassName . equals ( attributeClass . attributeClassName ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nList < String > otherPath = comp . getPathValue ( ) ; \nList < String > path = getPathValue ( ) ; \nif ( otherPath . size ( ) <= path . size ( ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nboolean subcat = true ; \nfor ( int i = 0 ; \ni < path . size ( ) ; \ni ++ ) { \nif ( ! otherPath . get ( i ) . equals ( path . get ( i ) ) ) { \nsubcat = false ; \nbreak ; \n} \n} \nreturn subcat ; \n} \n} \n"}
{"10448": "public class NestedMediaQueries { \n@ Override public boolean enter ( RuleSetNode ruleSetNode ) { \nScopeNode scopeNode = NodeTreeUtils . getFirstChild ( ruleSetNode , ScopeNode . class ) ; \nSelectorGroupNode selectorGroupNode = NodeTreeUtils . getFirstChild ( ruleSetNode , SelectorGroupNode . class ) ; \nif ( selectorGroupNode == null ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nList < SelectorNode > selectorNodes = NodeTreeUtils . getChildren ( selectorGroupNode , SelectorNode . class ) ; \nif ( selectorNodes . size ( ) < 0 ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nList < MediaQueryNode > mediaQueryNodes = NodeTreeUtils . getAndRemoveChildren ( scopeNode , MediaQueryNode . class ) ; \nfor ( MediaQueryNode mediaQueryNode : mediaQueryNodes ) { \nScopeNode mediaScopeNode = NodeTreeUtils . getFirstChild ( mediaQueryNode , ScopeNode . class ) ; \nList < RuleSetNode > nestedRuleSets = NodeTreeUtils . getAndRemoveChildren ( mediaScopeNode , RuleSetNode . class ) ; \nif ( mediaScopeNode . getChildren ( ) . size ( ) > NodeTreeUtils . getChildren ( mediaScopeNode , WhiteSpaceCollectionNode . class ) . size ( ) ) { \nRuleSetNode newRuleSetNode = new RuleSetNode ( ) ; \nScopeNode newScopeNode = new ScopeNode ( ) ; \nnewRuleSetNode . addChild ( selectorGroupNode . clone ( ) ) ; \nnewRuleSetNode . addChild ( newScopeNode ) ; \nNodeTreeUtils . moveChildren ( mediaScopeNode , newScopeNode ) ; \nmediaScopeNode . clearChildren ( ) ; \nmediaScopeNode . addChild ( newRuleSetNode ) ; \n} \nfor ( RuleSetNode nestedRuleSet : nestedRuleSets ) { \nList < SelectorGroupNode > nestedSelectorGroupNodes = NodeTreeUtils . getChildren ( nestedRuleSet , SelectorGroupNode . class ) ; \nfor ( SelectorGroupNode nestedSelectorGroupNode : nestedSelectorGroupNodes ) { \nList < SelectorNode > nestedSelectorNodes = NodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SelectorNode . class ) ; \nNodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SpacingNode . class ) ; \nfor ( SelectorNode selectorNode : selectorNodes ) { \nfor ( SelectorNode nestedSelectorNode : nestedSelectorNodes ) { \nif ( nestedSelectorNode . getChildren ( ) . get ( 0 ) != null ) { \nif ( nestedSelectorNode . getChildren ( ) . get ( 0 ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) nestedSelectorNode . getChildren ( ) . get ( 0 ) ; \nselectorSegmentNode . setCombinator ( \" \" ) ; \n} \n} \nfor ( int j = selectorNode . getChildren ( ) . size ( ) - 1 ; \nj >= 0 ; \nj -- ) { \nif ( selectorNode . getChildren ( ) . get ( j ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) selectorNode . getChildren ( ) . get ( j ) . clone ( ) ; \nnestedSelectorNode . addChild ( 0 , selectorSegmentNode ) ; \n} \n} \nnestedSelectorGroupNode . addChild ( nestedSelectorNode ) ; \nnestedSelectorGroupNode . addChild ( new SpacingNode ( \" \" ) ) ; \n} \n} \n} \nmediaScopeNode . addChild ( nestedRuleSet ) ; \n} \nif ( ruleSetNode . getParent ( ) != null ) { \nruleSetNode . getParent ( ) . addChild ( new SpacingNode ( \"\\n\" ) ) ; \nruleSetNode . getParent ( ) . addChild ( mediaQueryNode ) ; \n} \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"10449": "public class BatchSynchQueueBase { \npublic boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { \nif ( e == null ) { \nthrow new IllegalArgumentException ( \"The 'e' parameter may not be null.\" ) ; \n} \nReentrantLock lock = this . lock ; \nlock . lockInterruptibly ( ) ; \nlong nanos = unit . toNanos ( timeout ) ; \ntry { \ndo { \nif ( insert ( e , false ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ntry { \nnanos = notFull . awaitNanos ( nanos ) ; \n} \ncatch ( InterruptedException ie ) { \nnotFull . signal ( ) ; \nthrow ie ; \n} \n} \nwhile ( nanos > 0 ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"10452": "public class BatchSynchQueueBase { \nprotected boolean insert ( E element , boolean unlockAndBlock ) { \nSynchRecordImpl < E > record = new SynchRecordImpl < E > ( element ) ; \nboolean result = buffer . offer ( record ) ; \nif ( result ) { \ncount ++ ; \nnotEmpty . signal ( ) ; \nif ( unlockAndBlock ) { \nlock . unlock ( ) ; \nrecord . waitForConsumer ( ) ; \n} \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"10458": "public class ScopeNode { \nprivate void setAdditionVisitor ( ) { \nsetAdditionVisitor ( new InclusiveNodeVisitor ( ) { \n@ Override public boolean add ( ParametersNode node ) { \nfor ( VariableDefinitionNode variable : NodeTreeUtils . getChildren ( node , VariableDefinitionNode . class ) ) { \n_parameterDefinitions . add ( variable ) ; \nadd ( variable ) ; \n} \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( RuleSetNode node ) { \nSelectorGroupNode selectorGroup = NodeTreeUtils . getFirstChild ( node , SelectorGroupNode . class ) ; \nfor ( SelectorNode selectorNode : NodeTreeUtils . getChildren ( selectorGroup , SelectorNode . class ) ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( Node selectorChild : selectorNode . getChildren ( ) ) { \nsb . append ( selectorChild . toString ( ) ) ; \n} \nString selector = sb . toString ( ) ; \nif ( ! _selectorToRuleSetMap . containsKey ( selector ) ) { \n_selectorToRuleSetMap . put ( selector , node ) ; \n} \n} \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( ScopeNode node ) { \nNodeTreeUtils . moveChildren ( node , ScopeNode . this ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n@ Override public boolean add ( VariableDefinitionNode node ) { \nString name = node . getName ( ) ; \nif ( ! _variableNameToValueMap . containsKey ( name ) ) { \n_variableNameToValueMap . put ( name , NodeTreeUtils . getFirstChild ( node , ExpressionGroupNode . class ) ) ; \n} \nreturn super . add ( node ) ; \n} \n@ Override public boolean add ( PropertyNode node ) { \nString name = node . getName ( ) ; \nif ( name . equals ( FILTER_PROPERTY ) ) { \nreturn super . add ( node ) ; \n} \nif ( node . getChildren ( ) . get ( 0 ) . toString ( ) . startsWith ( \"-\" ) ) { \nreturn super . add ( node ) ; \n} \nif ( _propertyNameToNodeMap . containsKey ( name ) ) { \nPropertyNode oldPropertyNode = _propertyNameToNodeMap . get ( name ) ; \nint oldPropertyIndex = getChildren ( ) . indexOf ( oldPropertyNode ) ; \nif ( oldPropertyNode . isVisible ( ) ) { \noldPropertyNode . setVisible ( false ) ; \nif ( ! hideWhiteSpaceNode ( oldPropertyIndex - 1 ) ) { \nhideWhiteSpaceNode ( oldPropertyIndex + 1 ) ; \n} \n} \n} \n_propertyNameToNodeMap . put ( name , node ) ; \nreturn super . add ( node ) ; \n} \n} \n) ; \n} \n} \n"}
{"10469": "public class LockFreeNQueue { \npublic boolean offer ( E o ) { \nif ( o == null ) { \nthrow new IllegalArgumentException ( \"The 'o' parameter may not be null.\" ) ; \n} \nint level = priorityToLevel ( p . apply ( o ) ) ; \nNode < E > newNode = new DataNode < E > ( o , markers [ level + 1 ] ) ; \nwhile ( true ) { \nNode < E > t = markers [ level + 1 ] . getTail ( ) ; \nNode < E > s = t . getNext ( ) ; \nif ( t == markers [ level + 1 ] . getTail ( ) ) { \nif ( s == markers [ level + 1 ] ) { \nif ( t . casNext ( s , newNode ) ) { \nmarkers [ level + 1 ] . casTail ( t , newNode ) ; \ncount . incrementAndGet ( ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \nelse { \nmarkers [ level + 1 ] . casTail ( t , s ) ; \n} \n} \n} \n} \n} \n"}
{"10495": "public class BaseUnaryCondition { \npublic boolean await ( T t , long timeout , TimeUnit unit ) throws InterruptedException { \nsynchronized ( monitor ) { \nlong expiryTimeNanos = System . nanoTime ( ) + unit . toNanos ( timeout ) ; \nlong waitNanos = evaluateWithWaitTimeNanos ( t ) ; \nwhile ( waitNanos > 0 ) { \nlong remainingTimeNanos = expiryTimeNanos - System . nanoTime ( ) ; \nif ( remainingTimeNanos <= 0 ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nlong timeToPauseNanos = ( waitNanos < remainingTimeNanos ) ? waitNanos : remainingTimeNanos ; \nlong milliPause = timeToPauseNanos / 1000000 ; \nint nanoPause = ( int ) ( timeToPauseNanos % 1000000 ) ; \nmonitor . wait ( milliPause , nanoPause ) ; \nwaitNanos = evaluateWithWaitTimeNanos ( t ) ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"10545": "public class WAMResolvingJavaMachine { \nprivate boolean backtrack ( ) { \nif ( bp == 0 ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nelse { \nb0 = data . get ( bp + data . get ( bp ) + 7 ) ; \nip = data . get ( bp + data . get ( bp ) + 4 ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"10589": "public class FibonacciHeap { \npublic boolean offer ( E o ) { \nNode newNode = new Node ( o ) ; \nif ( minNode != null ) { \nnewNode . next = minNode . next ; \nnewNode . prev = minNode ; \nminNode . next . prev = newNode ; \nminNode . next = newNode ; \nupdateMinimum ( newNode ) ; \n} \nelse { \nnewNode . next = newNode ; \nnewNode . prev = newNode ; \nminNode = newNode ; \n} \nsize ++ ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"10606": "public class Validation { \npublic static int toInteger ( String s ) { \ntry { \nreturn Integer . parseInt ( s ) ; \n} \ncatch ( NumberFormatException e ) { \ne = null ; \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"10608": "public class Validation { \npublic static boolean isDate ( String s ) { \nDateFormat dateFormatter = new SimpleDateFormat ( dateFormat ) ; \ntry { \ndateFormatter . parse ( s ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( ParseException e ) { \ne = null ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"10609": "public class Validation { \npublic static boolean isTime ( String s ) { \nDateFormat dateFormatter = new SimpleDateFormat ( timeFormat ) ; \ntry { \ndateFormatter . parse ( s ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( ParseException e ) { \ne = null ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"10610": "public class Validation { \npublic static boolean isDateTime ( String s ) { \nDateFormat dateFormatter = new SimpleDateFormat ( dateTimeFormat ) ; \ntry { \ndateFormatter . parse ( s ) ; \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \ncatch ( ParseException e ) { \ne = null ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n} \n"}
{"10614": "public class OptimizeInstructions { \npublic boolean isConstant ( WAMInstruction instruction ) { \nInteger name = instruction . getFunctorNameReg1 ( ) ; \nif ( name != null ) { \nFunctorName functorName = interner . getDeinternedFunctorName ( name ) ; \nif ( functorName . getArity ( ) == 0 ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"10615": "public class OptimizeInstructions { \nprivate boolean isVoidVariable ( WAMInstruction instruction ) { \nSymbolKey symbolKey = instruction . getSymbolKeyReg1 ( ) ; \nif ( symbolKey != null ) { \nInteger count = ( Integer ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_VAR_OCCURRENCE_COUNT ) ; \nBoolean nonArgPositionOnly = ( Boolean ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_VAR_NON_ARG ) ; \nInteger allocation = ( Integer ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_ALLOCATION ) ; \nboolean singleton = ( count != null ) && count . equals ( 1 ) ; \nboolean nonArgPosition = ( nonArgPositionOnly != null ) && TRUE . equals ( nonArgPositionOnly ) ; \nboolean permanent = ( allocation != null ) && ( ( byte ) ( ( allocation & 0xff00 ) >> 8 ) == WAMInstruction . STACK_ADDR ) ; \nif ( singleton && nonArgPosition && ! permanent ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"10616": "public class OptimizeInstructions { \nprivate boolean isNonArg ( WAMInstruction instruction ) { \nSymbolKey symbolKey = instruction . getSymbolKeyReg1 ( ) ; \nif ( symbolKey != null ) { \nBoolean nonArgPositionOnly = ( Boolean ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_FUNCTOR_NON_ARG ) ; \nif ( TRUE . equals ( nonArgPositionOnly ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"10661": "public class Files { \npublic static Boolean contentEquals ( Path file1 , Path file2 ) throws IOException { \nif ( ! java . nio . file . Files . isRegularFile ( file1 ) ) throw new IllegalArgumentException ( file1 + \"is not a regular file\" ) ; \nif ( ! java . nio . file . Files . isRegularFile ( file2 ) ) throw new IllegalArgumentException ( file2 + \"is not a regular file\" ) ; \nFileChannel channel1 = null ; \nFileChannel channel2 = null ; \nMappedByteBuffer buffer1 = null ; \nMappedByteBuffer buffer2 = null ; \ntry { \nlong size1 = java . nio . file . Files . size ( file1 ) ; \nlong size2 = java . nio . file . Files . size ( file2 ) ; \nif ( size1 != size2 ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nlong position = 0 ; \nlong length = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \nchannel1 = FileChannel . open ( file1 ) ; \nchannel2 = FileChannel . open ( file2 ) ; \nwhile ( length > 0 ) { \nbuffer1 = channel1 . map ( MapMode . READ_ONLY , position , length ) ; \nbuffer2 = channel2 . map ( MapMode . READ_ONLY , position , length ) ; \nfor ( int i = 0 ; \ni < length ; \ni ++ ) if ( buffer1 . get ( ) != buffer2 . get ( ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \nposition += length ; \nlength = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \ncleanDirectByteBuffer ( buffer1 ) ; \nbuffer1 = null ; \ncleanDirectByteBuffer ( buffer2 ) ; \nbuffer2 = null ; \n} \n} \nfinally { \ncleanDirectByteBuffer ( buffer1 ) ; \ncleanDirectByteBuffer ( buffer2 ) ; \nif ( channel1 != null ) try { \nchannel1 . close ( ) ; \n} \ncatch ( IOException e ) { \nif ( channel2 != null ) channel2 . close ( ) ; \nthrow e ; \n} \nif ( channel2 != null ) channel2 . close ( ) ; \n} \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
{"10700": "public class ExecS_CliParser { \npublic boolean hasOption ( Option option ) { \nif ( option == null ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nif ( this . usedOptions . contains ( option . getOpt ( ) ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nif ( this . usedOptions . contains ( option . getLongOpt ( ) ) ) { \n{ \nboolean return_variable_2 = true ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = false ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"10703": "public class ExecS_CliParser { \nstatic int doParse ( String [ ] args , ExecS_CliParser cli , String appName ) { \nException err = cli . parse ( args ) ; \nif ( err != null ) { \nSystem . err . println ( appName + \": error parsing command line -> \" + err . getMessage ( ) ) ; \nreturn - 1 ; \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"10740": "public class OutputExtensionArgument { \n@ Override public boolean canRun ( EventModel event ) { \nif ( event != null ) { \nreturn event . getListResourceContainer ( ) . providesResource ( getResourceIdWishList ( ) ) ; \n} \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"10756": "public class LaunchNakamura { \npublic static boolean exists ( String URLName ) { \ntry { \nHttpURLConnection . setFollowRedirects ( false ) ; \nHttpURLConnection con = ( HttpURLConnection ) new URL ( URLName ) . openConnection ( ) ; \ncon . setRequestMethod ( \"HEAD\" ) ; \nreturn ( con . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"10769": "public class CommandResource { \npublic static boolean verifyCapabilities ( String command , Capabilities capabilities ) { \nswitch ( command ) { \ncase PLAY : return capabilities . hasPlayPauseControl ( ) ; \ncase PAUSE : return capabilities . hasPlayPauseControl ( ) ; \ncase SELECT_TRACK : return capabilities . isAbleToSelectTrack ( ) ; \ncase NEXT : return capabilities . hasNextPrevious ( ) ; \ncase PREVIOUS : return capabilities . hasNextPrevious ( ) ; \ncase JUMP : return capabilities . isAbleToJump ( ) ; \ncase CHANGE_PLAYBACK : return capabilities . isPlaybackChangeable ( ) ; \ncase CHANGE_VOLUME : return capabilities . canChangeVolume ( ) ; \ncase STOP : { \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"10811": "public class StartMusicRequest { \npublic static boolean verify ( EventModel eventModel , Capabilities capabilities , Identifiable player , List < Identifiable > activators ) { \nif ( ! eventModel . containsDescriptor ( StartMusicRequest . ID ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nif ( ! capabilities . handlesPlayRequestFromOutside ( ) ) { \nif ( activators . stream ( ) . noneMatch ( identifiable -> identifiable . isOwner ( eventModel . getSource ( ) ) ) ) { \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nif ( ! PlaylistResource . getPlaylist ( eventModel ) . map ( playlist -> playlist . verify ( capabilities ) ) . orElse ( true ) ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nreturn SelectorResource . isTarget ( eventModel , player ) . orElse ( false ) ; \n} \n} \n"}
{"10822": "public class PresenceConstant { \n@ Override public boolean controlEvents ( EventModel eventModel ) { \nif ( level . compareTo ( PresenceIndicatorLevel . WEAK ) >= 0 ) { \nreturn present ; \n} \nelse if ( level . compareTo ( PresenceIndicatorLevel . WEAK ) < 0 && mostVague . get ( ) ) { \nreturn present ; \n} \nelse { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"10827": "public class Gen_RunScripts { \nprotected final int initOutputDir ( ) { \nString parent = System . getProperty ( \"user.dir\" ) ; \nString target = parent + File . separator + this . target ; \nFile targetDir = new File ( target ) ; \nFile parentDir = targetDir . getParentFile ( ) ; \nif ( targetDir . exists ( ) ) { \nif ( ! targetDir . isDirectory ( ) ) { \nSystem . err . println ( this . getAppName ( ) + \": target dir <\" + target + \"> exists but is not a directory, exiting\" ) ; \nreturn - 1 ; \n} \nif ( ! targetDir . canWrite ( ) ) { \nSystem . err . println ( this . getAppName ( ) + \": target dir <\" + target + \"> exists but but cannot write into it, exiting\" ) ; \nreturn - 1 ; \n} \n} \nelse { \nif ( ! parentDir . isDirectory ( ) ) { \nSystem . err . println ( this . getAppName ( ) + \": target dir parent <\" + parent + \"> exists but is not a directory, exiting\" ) ; \nreturn - 1 ; \n} \nif ( ! parentDir . canWrite ( ) ) { \nSystem . err . println ( this . getAppName ( ) + \": target dir parent <\" + parent + \"> exists but but cannot write into it, exiting\" ) ; \nreturn - 1 ; \n} \nif ( ! targetDir . mkdir ( ) ) { \nSystem . err . println ( this . getAppName ( ) + \": could not create target dir <\" + target + \">, exiting\" ) ; \nreturn - 1 ; \n} \n} \nthis . outputDir = target ; \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"10829": "public class Gen_RunScripts { \nprotected final int writeFile ( String fn , ST st ) { \ntry { \nFileWriter fs = new FileWriter ( fn ) ; \nBufferedWriter bw = new BufferedWriter ( fs ) ; \nbw . write ( st . render ( ) ) ; \nbw . close ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nreturn - 1 ; \n} \n{ \nint return_variable_0 = 0 ; \nreturn return_variable_0 ; \n} \n} \n} \n"}
{"10836": "public class StopMusic { \npublic static boolean verify ( EventModel eventModel , Identifiable player ) { \nif ( ! eventModel . containsDescriptor ( StopMusic . ID ) ) { \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \nreturn SelectorResource . isTarget ( eventModel , player ) . orElse ( true ) ; \n} \n} \n"}
{"10898": "public class Gen_ExecJarScripts { \npublic boolean writeFile ( File file , List < String > lines ) { \nif ( file . exists ( ) ) { \nfile . delete ( ) ; \n} \ntry { \nFileWriter out = new FileWriter ( file ) ; \nfor ( String s : lines ) { \nout . write ( s ) ; \nout . write ( System . getProperty ( \"line.separator\" ) ) ; \n} \nout . close ( ) ; \nfile . setExecutable ( true ) ; \n} \ncatch ( IOException ex ) { \nSystem . err . println ( this . getAppName ( ) + \": IO exception while writing to file - \" + file + \" with message: \" + ex . getMessage ( ) ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"10899": "public class Gen_ExecJarScripts { \nprotected boolean inExecJar ( ) { \nClass < Gen_ExecJarScripts > clazz = Gen_ExecJarScripts . class ; \nString className = clazz . getSimpleName ( ) + \".class\" ; \nString classPath = clazz . getResource ( className ) . toString ( ) ; \nif ( ! classPath . startsWith ( \"jar\" ) ) { \nSystem . err . println ( this . getAppName ( ) + \": not started in a jar, cannot proceed\" ) ; \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nString manifestPath = classPath . substring ( 0 , classPath . lastIndexOf ( \"!\" ) + 1 ) + \"/META-INF/MANIFEST.MF\" ; \nManifest manifest ; \ntry { \nmanifest = new Manifest ( new URL ( manifestPath ) . openStream ( ) ) ; \n} \ncatch ( IOException ex ) { \nSystem . err . println ( this . getAppName ( ) + \": exception while retrieving manifest: \" + ex . getMessage ( ) ) ; \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nAttributes attr = manifest . getMainAttributes ( ) ; \nif ( StringUtils . isBlank ( attr . getValue ( \"Main-Class\" ) ) ) { \nSystem . err . println ( this . getAppName ( ) + \": no main class in manifest, probably not an executable JAR, cannot continue\" ) ; \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"10923": "public class Playlist { \npublic boolean verify ( Capabilities capabilities ) { \nfor ( PlaybackMode playbackMode : playbackModes ) { \nswitch ( playbackMode ) { \ncase REPEAT : if ( ! capabilities . canRepeatPlayback ( ) ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \nelse { \nbreak ; \n} \ncase REPEAT_SONG : if ( ! capabilities . canRepeatPlaybackOfSong ( ) ) { \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \nelse { \nbreak ; \n} \ncase SHUFFLE : if ( ! capabilities . canShufflePlayback ( ) ) { \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \nelse { \nbreak ; \n} \n} \n} \n{ \nboolean return_variable_3 = true ; \nreturn return_variable_3 ; \n} \n} \n} \n"}
{"10938": "public class MusicUsageResource { \npublic static boolean isPermanent ( ResourceModel resourceModel ) { \nObject resource = resourceModel . getResource ( ) ; \ntry { \nreturn ( Boolean ) resource ; \n} \ncatch ( ClassCastException e ) { \n{ \nboolean return_variable_0 = false ; \nreturn return_variable_0 ; \n} \n} \n} \n} \n"}
{"10940": "public class AbstractHashedMap { \npublic boolean containsKey ( Object key ) { \nint hashCode = hash ( ( key == null ) ? NULL : key ) ; \nHashEntry entry = data [ hashIndex ( hashCode , data . length ) ] ; \nwhile ( entry != null ) { \nif ( entry . hashCode == hashCode && isEqualKey ( key , entry . getKey ( ) ) ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nentry = entry . next ; \n} \n{ \nboolean return_variable_1 = false ; \nreturn return_variable_1 ; \n} \n} \n} \n"}
{"10941": "public class AbstractHashedMap { \npublic boolean containsValue ( Object value ) { \nif ( value == null ) { \nfor ( int i = 0 , isize = data . length ; \ni < isize ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( entry . getValue ( ) == null ) { \n{ \nboolean return_variable_0 = true ; \nreturn return_variable_0 ; \n} \n} \nentry = entry . next ; \n} \n} \n} \nelse { \nfor ( int i = 0 , isize = data . length ; \ni < isize ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( isEqualValue ( value , entry . getValue ( ) ) ) { \n{ \nboolean return_variable_1 = true ; \nreturn return_variable_1 ; \n} \n} \nentry = entry . next ; \n} \n} \n} \n{ \nboolean return_variable_2 = false ; \nreturn return_variable_2 ; \n} \n} \n} \n"}
