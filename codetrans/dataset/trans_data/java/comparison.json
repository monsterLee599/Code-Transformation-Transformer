{"25": "public class QueueDrainHelper { \npublic static void request ( Subscription s , int prefetch ) { \ns . request ( 0 > prefetch ? Long . MAX_VALUE : prefetch ) ; \n} \n} \n"}
{"34": "public class BackpressureHelper { \npublic static long addCap ( long a , long b ) { \nlong u = a + b ; \nif ( 0L > u ) { \nreturn Long . MAX_VALUE ; \n} \nreturn u ; \n} \n} \n"}
{"44": "public class ExceptionHelper { \npublic static List < Throwable > flatten ( Throwable t ) { \nList < Throwable > list = new ArrayList < Throwable > ( ) ; \nArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; \ndeque . offer ( t ) ; \nwhile ( ! deque . isEmpty ( ) ) { \nThrowable e = deque . removeFirst ( ) ; \nif ( e instanceof CompositeException ) { \nCompositeException ce = ( CompositeException ) e ; \nList < Throwable > exceptions = ce . getExceptions ( ) ; \nfor ( int i = exceptions . size ( ) - 1 ; \n0 <= i ; \ni -- ) { \ndeque . offerFirst ( exceptions . get ( i ) ) ; \n} \n} \nelse { \nlist . add ( e ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"50": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Subscriber < ? super U > subscriber ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nwhile ( a != null ) { \nfor ( int i = 0 ; \nc > i ; \ni ++ ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , subscriber ) ) { \nreturn true ; \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"51": "public class AppendOnlyLinkedArrayList { \npublic < U > boolean accept ( Observer < ? super U > observer ) { \nObject [ ] a = head ; \nfinal int c = capacity ; \nwhile ( a != null ) { \nfor ( int i = 0 ; \nc > i ; \ni ++ ) { \nObject o = a [ i ] ; \nif ( o == null ) { \nbreak ; \n} \nif ( NotificationLite . acceptFull ( o , observer ) ) { \nreturn true ; \n} \n} \na = ( Object [ ] ) a [ c ] ; \n} \nreturn false ; \n} \n} \n"}
{"62": "public class PerfAsyncConsumer { \npublic PerfAsyncConsumer await ( int count ) { \nif ( 1000 >= count ) { \nwhile ( getCount ( ) != 0 ) { \n} \n} \nelse { \ntry { \nawait ( ) ; \n} \ncatch ( InterruptedException ex ) { \nthrow new RuntimeException ( ex ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"65": "public class PublishSubject { \n@ SuppressWarnings ( \"unchecked\" ) void remove ( PublishDisposable < T > ps ) { \nfor ( ; \n; \n) { \nPublishDisposable < T > [ ] a = subscribers . get ( ) ; \nif ( a == TERMINATED || a == EMPTY ) { \nreturn ; \n} \nint n = a . length ; \nint j = - 1 ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nif ( a [ i ] == ps ) { \nj = i ; \nbreak ; \n} \n} \nif ( 0 > j ) { \nreturn ; \n} \nPublishDisposable < T > [ ] b ; \nif ( n == 1 ) { \nb = EMPTY ; \n} \nelse { \nb = new PublishDisposable [ n - 1 ] ; \nSystem . arraycopy ( a , 0 , b , 0 , j ) ; \nSystem . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; \n} \nif ( subscribers . compareAndSet ( a , b ) ) { \nreturn ; \n} \n} \n} \n} \n"}
{"68": "public class NetworkBehavior { \npublic void setDelay ( long amount , TimeUnit unit ) { \nif ( 0 > amount ) { \nthrow new IllegalArgumentException ( \"Amount must be positive value.\" ) ; \n} \nthis . delayMs = unit . toMillis ( amount ) ; \n} \n} \n"}
{"76": "public class SpringSecurityCoreVersion { \nprivate static void performVersionChecks ( String minSpringVersion ) { \nif ( minSpringVersion == null ) { \nreturn ; \n} \nString springVersion = SpringVersion . getVersion ( ) ; \nString version = getVersion ( ) ; \nif ( disableChecks ( springVersion , version ) ) { \nreturn ; \n} \nlogger . info ( \"You are running with Spring Security Core \" + version ) ; \nif ( 0 > new ComparableVersion ( springVersion ) . compareTo ( new ComparableVersion ( minSpringVersion ) ) ) { \nlogger . warn ( \"**** You are advised to use Spring \" + minSpringVersion + \" or later with this version. You are running: \" + springVersion ) ; \n} \n} \n} \n"}
{"86": "public class SpringSecurityLdapTemplate { \npublic Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { \nObject [ ] encodedParams = new String [ params . length ] ; \nfor ( int i = 0 ; \nparams . length > i ; \ni ++ ) { \nencodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; \n} \nString formattedFilter = MessageFormat . format ( filter , encodedParams ) ; \nlogger . debug ( \"Using filter: \" + formattedFilter ) ; \nfinal HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; \nContextMapper roleMapper = new ContextMapper ( ) { \npublic Object mapFromContext ( Object ctx ) { \nDirContextAdapter adapter = ( DirContextAdapter ) ctx ; \nMap < String , List < String > > record = new HashMap < String , List < String > > ( ) ; \nif ( attributeNames == null || attributeNames . length == 0 ) { \ntry { \nfor ( NamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; \nae . hasMore ( ) ; \n) { \nAttribute attr = ( Attribute ) ae . next ( ) ; \nextractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; \n} \n} \ncatch ( NamingException x ) { \norg . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; \n} \n} \nelse { \nfor ( String attributeName : attributeNames ) { \nextractStringAttributeValues ( adapter , record , attributeName ) ; \n} \n} \nrecord . put ( DN_KEY , Arrays . asList ( getAdapterDN ( adapter ) ) ) ; \nset . add ( record ) ; \nreturn null ; \n} \n} \n; \nSearchControls ctls = new SearchControls ( ) ; \nctls . setSearchScope ( searchControls . getSearchScope ( ) ) ; \nctls . setReturningAttributes ( attributeNames != null && 0 < attributeNames . length ? attributeNames : null ) ; \nsearch ( base , formattedFilter , ctls , roleMapper ) ; \nreturn set ; \n} \n} \n"}
{"87": "public class SpringSecurityLdapTemplate { \npublic static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { \nfinal DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; \nfinal DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; \nfinal NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\" ) ; \n} \nSet < DirContextOperations > results = new HashSet < > ( ) ; \ntry { \nwhile ( resultsEnum . hasMore ( ) ) { \nSearchResult searchResult = resultsEnum . next ( ) ; \nDirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; \nAssert . notNull ( dca , \"No object returned by search, DirContext is not correctly configured\" ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Found DN: \" + dca . getDn ( ) ) ; \n} \nresults . add ( dca ) ; \n} \n} \ncatch ( PartialResultException e ) { \nLdapUtils . closeEnumeration ( resultsEnum ) ; \nlogger . info ( \"Ignoring PartialResultException\" ) ; \n} \nif ( results . size ( ) == 0 ) { \nthrow new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; \n} \nif ( 1 < results . size ( ) ) { \nthrow new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; \n} \nreturn results . iterator ( ) . next ( ) ; \n} \n} \n"}
{"89": "public class BasicLookupStrategy { \nprivate void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { \nAssert . notNull ( acls , \"ACLs are required\" ) ; \nAssert . notEmpty ( findNow , \"Items to find now required\" ) ; \nString sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; \nSet < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { \npublic void setValues ( PreparedStatement ps ) throws SQLException { \nint i = 0 ; \nfor ( Long toFind : findNow ) { \ni ++ ; \nps . setLong ( i , toFind ) ; \n} \n} \n} \n, new ProcessResultSet ( acls , sids ) ) ; \nif ( 0 < parentsToLookup . size ( ) ) { \nlookupPrimaryKeys ( acls , parentsToLookup , sids ) ; \n} \n} \n} \n"}
{"103": "public class OnCommittedResponseWrapper { \nprivate void checkContentLength ( long contentLengthToWrite ) { \nthis . contentWritten += contentLengthToWrite ; \nboolean isBodyFullyWritten = 0 < this . contentLength && this . contentLength <= this . contentWritten ; \nint bufferSize = getBufferSize ( ) ; \nboolean requiresFlush = 0 < bufferSize && bufferSize <= this . contentWritten ; \nif ( isBodyFullyWritten || requiresFlush ) { \ndoOnResponseCommitted ( ) ; \n} \n} \n} \n"}
{"110": "public class AbstractRememberMeServices { \nprotected String encodeCookie ( String [ ] cookieTokens ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ncookieTokens . length > i ; \ni ++ ) { \ntry { \nsb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \nif ( cookieTokens . length - 1 > i ) { \nsb . append ( DELIMITER ) ; \n} \n} \nString value = sb . toString ( ) ; \nsb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; \nwhile ( sb . charAt ( sb . length ( ) - 1 ) == '=' ) { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"111": "public class AbstractRememberMeServices { \nprotected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { \nString cookieValue = encodeCookie ( tokens ) ; \nCookie cookie = new Cookie ( cookieName , cookieValue ) ; \ncookie . setMaxAge ( maxAge ) ; \ncookie . setPath ( getCookiePath ( request ) ) ; \nif ( cookieDomain != null ) { \ncookie . setDomain ( cookieDomain ) ; \n} \nif ( 1 > maxAge ) { \ncookie . setVersion ( 1 ) ; \n} \nif ( useSecureCookie == null ) { \ncookie . setSecure ( request . isSecure ( ) ) ; \n} \nelse { \ncookie . setSecure ( useSecureCookie ) ; \n} \ncookie . setHttpOnly ( true ) ; \nresponse . addCookie ( cookie ) ; \n} \n} \n"}
{"123": "public class UserDetailsServiceFactoryBean { \nprivate UserDetailsService getUserDetailsService ( ) { \nMap < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; \nif ( beans . size ( ) == 0 ) { \nbeans = getBeansOfType ( UserDetailsService . class ) ; \n} \nif ( beans . size ( ) == 0 ) { \nthrow new ApplicationContextException ( \"No UserDetailsService registered.\" ) ; \n} \nelse if ( 1 < beans . size ( ) ) { \nthrow new ApplicationContextException ( \"More than one UserDetailsService registered. Please \" + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\" ) ; \n} \nreturn ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; \n} \n} \n"}
{"147": "public class UrlAuthorizationConfigurer { \nprivate static String [ ] hasAnyRole ( String ... roles ) { \nfor ( int i = 0 ; \nroles . length > i ; \ni ++ ) { \nroles [ i ] = \"ROLE_\" + roles [ i ] ; \n} \nreturn roles ; \n} \n} \n"}
{"148": "public class PersistentTokenBasedRememberMeServices { \nprotected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { \nif ( cookieTokens . length != 2 ) { \nthrow new InvalidCookieException ( \"Cookie token did not contain \" + 2 + \" tokens, but contained '\" + Arrays . asList ( cookieTokens ) + \"'\" ) ; \n} \nfinal String presentedSeries = cookieTokens [ 0 ] ; \nfinal String presentedToken = cookieTokens [ 1 ] ; \nPersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; \nif ( token == null ) { \nthrow new RememberMeAuthenticationException ( \"No persistent token found for series id: \" + presentedSeries ) ; \n} \nif ( ! presentedToken . equals ( token . getTokenValue ( ) ) ) { \ntokenRepository . removeUserTokens ( token . getUsername ( ) ) ; \nthrow new CookieTheftException ( messages . getMessage ( \"PersistentTokenBasedRememberMeServices.cookieStolen\" , \"Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.\" ) ) ; \n} \nif ( System . currentTimeMillis ( ) > token . getDate ( ) . getTime ( ) + getTokenValiditySeconds ( ) * 1000L ) { \nthrow new RememberMeAuthenticationException ( \"Remember-me login has expired\" ) ; \n} \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Refreshing persistent login token for user '\" + token . getUsername ( ) + \"', series '\" + token . getSeries ( ) + \"'\" ) ; \n} \nPersistentRememberMeToken newToken = new PersistentRememberMeToken ( token . getUsername ( ) , token . getSeries ( ) , generateTokenData ( ) , new Date ( ) ) ; \ntry { \ntokenRepository . updateToken ( newToken . getSeries ( ) , newToken . getTokenValue ( ) , newToken . getDate ( ) ) ; \naddCookie ( newToken , request , response ) ; \n} \ncatch ( Exception e ) { \nlogger . error ( \"Failed to update token: \" , e ) ; \nthrow new RememberMeAuthenticationException ( \"Autologin failed due to data access problem\" ) ; \n} \nreturn getUserDetailsService ( ) . loadUserByUsername ( token . getUsername ( ) ) ; \n} \n} \n"}
{"170": "public class AnnotationParameterNameDiscoverer { \nprivate < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { \nAnnotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; \nint parameterCount = parameterAnnotations . length ; \nString [ ] paramNames = new String [ parameterCount ] ; \nboolean found = false ; \nfor ( int i = 0 ; \nparameterCount > i ; \ni ++ ) { \nAnnotation [ ] annotations = parameterAnnotations [ i ] ; \nString parameterName = findParameterName ( annotations ) ; \nif ( parameterName != null ) { \nfound = true ; \nparamNames [ i ] = parameterName ; \n} \n} \nreturn found ? paramNames : null ; \n} \n} \n"}
{"183": "public class LdapShaPasswordEncoder { \nprivate String extractPrefix ( String encPass ) { \nif ( ! encPass . startsWith ( \"{\" ) ) { \nreturn null ; \n} \nint secondBrace = encPass . lastIndexOf ( '}' ) ; \nif ( 0 > secondBrace ) { \nthrow new IllegalArgumentException ( \"Couldn't find closing brace for SHA prefix\" ) ; \n} \nreturn encPass . substring ( 0 , secondBrace + 1 ) ; \n} \n} \n"}
{"190": "public class StandardPasswordEncoder { \nprivate boolean matches ( byte [ ] expected , byte [ ] actual ) { \nif ( expected . length != actual . length ) { \nreturn false ; \n} \nint result = 0 ; \nfor ( int i = 0 ; \nexpected . length > i ; \ni ++ ) { \nresult |= expected [ i ] ^ actual [ i ] ; \n} \nreturn result == 0 ; \n} \n} \n"}
{"214": "public class FastHttpDateFormat { \npublic static String getCurrentDate ( ) { \nlong now = System . currentTimeMillis ( ) ; \nif ( 1000 < ( now - currentDateGenerated ) ) { \nsynchronized ( format ) { \nif ( 1000 < ( now - currentDateGenerated ) ) { \ncurrentDateGenerated = now ; \ncurrentDate = format . format ( new Date ( now ) ) ; \n} \n} \n} \nreturn currentDate ; \n} \n} \n"}
{"215": "public class FastHttpDateFormat { \nprivate static Long internalParseDate ( String value , DateFormat [ ] formats ) { \nDate date = null ; \nfor ( int i = 0 ; \n( date == null ) && ( formats . length > i ) ; \ni ++ ) { \ntry { \ndate = formats [ i ] . parse ( value ) ; \n} \ncatch ( ParseException ignored ) { \n} \n} \nif ( date == null ) { \nreturn null ; \n} \nreturn new Long ( date . getTime ( ) ) ; \n} \n} \n"}
{"216": "public class FastHttpDateFormat { \n@ SuppressWarnings ( \"unchecked\" ) private static void updateCache ( HashMap cache , Object key , Object value ) { \nif ( value == null ) { \nreturn ; \n} \nif ( 1000 < cache . size ( ) ) { \ncache . clear ( ) ; \n} \ncache . put ( key , value ) ; \n} \n} \n"}
{"266": "public class ResponseBuilder { \npublic Response build ( ) { \nfinal int statusCode = restAssuredResponse . statusCode ( ) ; \nif ( 100 > statusCode || 600 <= statusCode ) { \nthrow new IllegalArgumentException ( format ( \"Status code must be greater than 100 and less than 600, was %d.\" , statusCode ) ) ; \n} \nif ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { \nrestAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; \n} \nrestAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; \nreturn restAssuredResponse ; \n} \n} \n"}
{"319": "public class SingleParameterInjector { \nstatic Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { \nif ( parameterInjectors == null ) { \nreturn NO_ARGUMENTS ; \n} \nint size = parameterInjectors . length ; \nObject [ ] parameters = new Object [ size ] ; \nfor ( int i = 0 ; \nsize > i ; \ni ++ ) { \nparameters [ i ] = parameterInjectors [ i ] . inject ( context ) ; \n} \nreturn parameters ; \n} \n} \n"}
{"326": "public class TypeLiteral { \nprivate List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { \nTypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; \nfor ( int t = 0 ; \ntypes . length > t ; \nt ++ ) { \nresult [ t ] = resolve ( types [ t ] ) ; \n} \nreturn ImmutableList . copyOf ( result ) ; \n} \n} \n"}
{"339": "public class ServletUtils { \nstatic String normalizePath ( String path ) { \nStringBuilder sb = new StringBuilder ( path . length ( ) ) ; \nint queryStart = path . indexOf ( '?' ) ; \nString query = null ; \nif ( queryStart != - 1 ) { \nquery = path . substring ( queryStart ) ; \npath = path . substring ( 0 , queryStart ) ; \n} \nList < String > segments = new ArrayList < > ( ) ; \nfor ( String segment : SLASH_SPLITTER . split ( path ) ) { \nString normalized = UrlEscapers . urlPathSegmentEscaper ( ) . escape ( lenientDecode ( segment , UTF_8 , false ) ) ; \nif ( \".\" . equals ( normalized ) ) { \n} \nelse if ( \"..\" . equals ( normalized ) ) { \nif ( 1 < segments . size ( ) ) { \nsegments . remove ( segments . size ( ) - 1 ) ; \n} \n} \nelse { \nsegments . add ( normalized ) ; \n} \n} \nSLASH_JOINER . appendTo ( sb , segments ) ; \nif ( query != null ) { \nsb . append ( query ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"352": "public class Message { \nprivate Object writeReplace ( ) throws ObjectStreamException { \nObject [ ] sourcesAsStrings = sources . toArray ( ) ; \nfor ( int i = 0 ; \nsourcesAsStrings . length > i ; \ni ++ ) { \nsourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; \n} \nreturn new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; \n} \n} \n"}
{"362": "public class Errors { \n< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( format ( \"No implementation for %s was bound.\" , key ) ) ; \nList < String > possibleMatches = new ArrayList < > ( ) ; \nTypeLiteral < T > type = key . getTypeLiteral ( ) ; \nList < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; \nif ( ! sameTypes . isEmpty ( ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nint howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; \nfor ( int i = 0 ; \nhowMany > i ; \n++ i ) { \nsb . append ( format ( \"%n    * %s\" , sameTypes . get ( i ) . getKey ( ) ) ) ; \n} \nint remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; \nif ( 0 < remaining ) { \nString plural = ( remaining == 1 ) ? \"\" : \"s\" ; \nsb . append ( format ( \"%n    %d more binding%s with other annotations.\" , remaining , plural ) ) ; \n} \n} \nelse { \nString want = type . toString ( ) ; \nMap < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; \nfor ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { \nString have = bindingKey . getTypeLiteral ( ) . toString ( ) ; \nif ( have . contains ( want ) || want . contains ( have ) ) { \nFormatter fmt = new Formatter ( ) ; \nMessages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; \nString match = String . format ( \"%s bound%s\" , convert ( bindingKey ) , fmt . toString ( ) ) ; \npossibleMatches . add ( match ) ; \nif ( MAX_RELATED_TYPES_REPORTED < possibleMatches . size ( ) ) { \nbreak ; \n} \n} \n} \nif ( ( 0 < possibleMatches . size ( ) ) && ( MAX_RELATED_TYPES_REPORTED >= possibleMatches . size ( ) ) ) { \nsb . append ( format ( \"%n  Did you mean?\" ) ) ; \nfor ( String possibleMatch : possibleMatches ) { \nsb . append ( format ( \"%n    %s\" , possibleMatch ) ) ; \n} \n} \n} \nif ( sameTypes . isEmpty ( ) && possibleMatches . isEmpty ( ) && key . getAnnotation ( ) == null && COMMON_AMBIGUOUS_TYPES . contains ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { \nsb . append ( format ( \"%nThe key seems very generic, did you forget an annotation?\" ) ) ; \n} \nreturn addMessage ( sb . toString ( ) ) ; \n} \n} \n"}
{"365": "public class FilterChainInvocation { \nprivate Filter findNextFilter ( HttpServletRequest request ) { \nwhile ( filterDefinitions . length > ++ index ) { \nFilter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; \nif ( filter != null ) { \nreturn filter ; \n} \n} \nreturn null ; \n} \n} \n"}
{"384": "public class Messages { \npublic static String formatMessages ( String heading , Collection < Message > errorMessages ) { \nFormatter fmt = new Formatter ( ) . format ( heading ) . format ( \":%n%n\" ) ; \nint index = 1 ; \nboolean displayCauses = getOnlyCause ( errorMessages ) == null ; \nMap < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; \nfor ( Message errorMessage : errorMessages ) { \nint thisIdx = index ++ ; \nfmt . format ( \"%s) %s%n\" , thisIdx , errorMessage . getMessage ( ) ) ; \nList < Object > dependencies = errorMessage . getSources ( ) ; \nfor ( int i = dependencies . size ( ) - 1 ; \n0 <= i ; \ni -- ) { \nObject source = dependencies . get ( i ) ; \nformatSource ( fmt , source ) ; \n} \nThrowable cause = errorMessage . getCause ( ) ; \nif ( displayCauses && cause != null ) { \nEquivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; \nif ( ! causes . containsKey ( causeEquivalence ) ) { \ncauses . put ( causeEquivalence , thisIdx ) ; \nfmt . format ( \"Caused by: %s\" , Throwables . getStackTraceAsString ( cause ) ) ; \n} \nelse { \nint causeIdx = causes . get ( causeEquivalence ) ; \nfmt . format ( \"Caused by: %s (same stack trace as error #%s)\" , cause . getClass ( ) . getName ( ) , causeIdx ) ; \n} \n} \nfmt . format ( \"%n\" ) ; \n} \nif ( errorMessages . size ( ) == 1 ) { \nfmt . format ( \"1 error\" ) ; \n} \nelse { \nfmt . format ( \"%s errors\" , errorMessages . size ( ) ) ; \n} \nreturn fmt . toString ( ) ; \n} \n} \n"}
{"404": "public class ProtocolCodeBasedDecoder { \nprotected ProtocolCode decodeProtocolCode ( ByteBuf in ) { \nif ( protocolCodeLength <= in . readableBytes ( ) ) { \nbyte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; \nin . readBytes ( protocolCodeBytes ) ; \nreturn ProtocolCode . fromBytes ( protocolCodeBytes ) ; \n} \nreturn null ; \n} \n} \n"}
{"406": "public class DefaultConnectionManager { \n@ Override public void scan ( ) { \nif ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { \nIterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nString poolKey = iter . next ( ) ; \nConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; \nif ( null != pool ) { \npool . scan ( ) ; \nif ( pool . isEmpty ( ) ) { \nif ( DEFAULT_EXPIRE_TIME < ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) ) { \niter . remove ( ) ; \nlogger . warn ( \"Remove expired pool task of poolKey {} which is empty.\" , poolKey ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"410": "public class DefaultConnectionManager { \nprivate void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { \nString poolKey = url . getUniqueKey ( ) ; \nif ( pool . isAsyncCreationDone ( ) && url . getConnNum ( ) > pool . size ( ) ) { \nFutureTask < Integer > task = this . healTasks . get ( poolKey ) ; \nif ( null == task ) { \ntask = new FutureTask < Integer > ( new HealConnectionCall ( url , pool ) ) ; \ntask = this . healTasks . putIfAbsent ( poolKey , task ) ; \nif ( null == task ) { \ntask = this . healTasks . get ( poolKey ) ; \ntask . run ( ) ; \n} \n} \ntry { \nint numAfterHeal = task . get ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"[NOTIFYME] - conn num after heal {}, expected {}, warmup {}\" , numAfterHeal , url . getConnNum ( ) , url . isConnWarmup ( ) ) ; \n} \n} \ncatch ( InterruptedException e ) { \nthis . healTasks . remove ( poolKey ) ; \nthrow e ; \n} \ncatch ( ExecutionException e ) { \nthis . healTasks . remove ( poolKey ) ; \nThrowable cause = e . getCause ( ) ; \nif ( cause instanceof RemotingException ) { \nthrow ( RemotingException ) cause ; \n} \nelse { \nFutureTaskUtil . launderThrowable ( cause ) ; \n} \n} \nthis . healTasks . remove ( poolKey ) ; \n} \n} \n} \n"}
{"411": "public class DefaultConnectionManager { \nprivate void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { \nfinal int actualNum = pool . size ( ) ; \nfinal int expectNum = url . getConnNum ( ) ; \nif ( expectNum > actualNum ) { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"actual num {}, expect num {}, task name {}\" , actualNum , expectNum , taskName ) ; \n} \nif ( url . isConnWarmup ( ) ) { \nfor ( int i = actualNum ; \nexpectNum > i ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \n} \nelse { \nif ( 0 > syncCreateNumWhenNotWarmup || url . getConnNum ( ) < syncCreateNumWhenNotWarmup ) { \nthrow new IllegalArgumentException ( \"sync create number when not warmup should be [0,\" + url . getConnNum ( ) + \"]\" ) ; \n} \nif ( 0 < syncCreateNumWhenNotWarmup ) { \nfor ( int i = 0 ; \nsyncCreateNumWhenNotWarmup > i ; \n++ i ) { \nConnection connection = create ( url ) ; \npool . add ( connection ) ; \n} \nif ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) { \nreturn ; \n} \n} \ninitializeExecutor ( ) ; \npool . markAsyncCreationStart ( ) ; \ntry { \nthis . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { \n@ Override public void run ( ) { \ntry { \nfor ( int i = pool . size ( ) ; \nurl . getConnNum ( ) > i ; \n++ i ) { \nConnection conn = null ; \ntry { \nconn = create ( url ) ; \n} \ncatch ( RemotingException e ) { \nlogger . error ( \"Exception occurred in async create connection thread for {}, taskName {}\" , url . getUniqueKey ( ) , taskName , e ) ; \n} \npool . add ( conn ) ; \n} \n} \nfinally { \npool . markAsyncCreationDone ( ) ; \n} \n} \n} \n) ; \n} \ncatch ( RejectedExecutionException e ) { \npool . markAsyncCreationDone ( ) ; \nthrow e ; \n} \n} \n} \n} \n} \n"}
{"426": "public class ProtocolSwitch { \npublic static byte toByte ( BitSet bs ) { \nint value = 0 ; \nfor ( int i = 0 ; \nbs . length ( ) > i ; \n++ i ) { \nif ( bs . get ( i ) ) { \nvalue += 1 << i ; \n} \n} \nif ( 7 < bs . length ( ) ) { \nthrow new IllegalArgumentException ( \"The byte value \" + value + \" generated according to bit set \" + bs + \" is out of range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \n} \nreturn ( byte ) value ; \n} \n} \n"}
{"427": "public class ProtocolSwitch { \npublic static BitSet toBitSet ( int value ) { \nif ( Byte . MAX_VALUE < value || Byte . MIN_VALUE > value ) { \nthrow new IllegalArgumentException ( \"The value \" + value + \" is out of byte range, should be limited between [\" + Byte . MIN_VALUE + \"] to [\" + Byte . MAX_VALUE + \"]\" ) ; \n} \nBitSet bs = new BitSet ( ) ; \nint index = 0 ; \nwhile ( value != 0 ) { \nif ( value % 2 != 0 ) { \nbs . set ( index ) ; \n} \n++ index ; \nvalue = ( byte ) ( value >> 1 ) ; \n} \nreturn bs ; \n} \n} \n"}
{"432": "public class ScheduledDisconnectStrategy { \n@ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { \ntry { \nif ( null != connPools && ! connPools . isEmpty ( ) ) { \nIterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nMap . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; \nString poolKey = entry . getKey ( ) ; \nConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; \nList < Connection > connections = pool . getAll ( ) ; \nMap < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; \nList < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; \nList < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; \nif ( CONNECTION_THRESHOLD < serviceOnConnections . size ( ) ) { \nConnection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; \nfreshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \nfreshSelectConnections . put ( poolKey , freshSelectConnect ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nelse { \nif ( freshSelectConnections . containsKey ( poolKey ) ) { \nConnection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; \ncloseFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; \n} \nif ( logger . isInfoEnabled ( ) ) { \nlogger . info ( \"the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}].\" , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; \n} \n} \nfor ( Connection offConn : serviceOffConnections ) { \nif ( offConn . isFine ( ) ) { \noffConn . close ( ) ; \n} \n} \n} \n} \n} \ncatch ( Exception e ) { \nlogger . error ( \"ScheduledDisconnectStrategy monitor error\" , e ) ; \n} \n} \n} \n"}
{"436": "public class RemotingContext { \npublic boolean isRequestTimeout ( ) { \nif ( 0 < this . timeout && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && this . timeout < ( System . currentTimeMillis ( ) - this . arriveTimestamp ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"438": "public class RandomSelectStrategy { \nprivate Connection randomGet ( List < Connection > conns ) { \nif ( null == conns || conns . isEmpty ( ) ) { \nreturn null ; \n} \nint size = conns . size ( ) ; \nint tries = 0 ; \nConnection result = null ; \nwhile ( ( result == null || ! result . isFine ( ) ) && MAX_TIMES > tries ++ ) { \nresult = conns . get ( this . random . nextInt ( size ) ) ; \n} \nif ( result != null && ! result . isFine ( ) ) { \nresult = null ; \n} \nreturn result ; \n} \n} \n"}
{"458": "public class ConnectionPool { \npublic Connection get ( ) { \nmarkAccess ( ) ; \nif ( null != this . conns ) { \nList < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; \nif ( 0 < snapshot . size ( ) ) { \nreturn this . strategy . select ( snapshot ) ; \n} \nelse { \nreturn null ; \n} \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"465": "public class RpcServer { \nprivate void initWriteBufferWaterMark ( ) { \nint lowWaterMark = this . netty_buffer_low_watermark ( ) ; \nint highWaterMark = this . netty_buffer_high_watermark ( ) ; \nif ( highWaterMark < lowWaterMark ) { \nthrow new IllegalArgumentException ( String . format ( \"[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)\" , highWaterMark , lowWaterMark ) ) ; \n} \nelse { \nlogger . warn ( \"[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes\" , lowWaterMark , highWaterMark ) ; \n} \nthis . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; \n} \n} \n"}
{"467": "public class SocketChannelIOHelper { \npublic static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { \nif ( ws == null ) { \nreturn false ; \n} \nByteBuffer buffer = ws . outQueue . peek ( ) ; \nWrappedByteChannel c = null ; \nif ( buffer == null ) { \nif ( sockchannel instanceof WrappedByteChannel ) { \nc = ( WrappedByteChannel ) sockchannel ; \nif ( c . isNeedWrite ( ) ) { \nc . writeMore ( ) ; \n} \n} \n} \nelse { \ndo { \nsockchannel . write ( buffer ) ; \nif ( 0 < buffer . remaining ( ) ) { \nreturn false ; \n} \nelse { \nws . outQueue . poll ( ) ; \nbuffer = ws . outQueue . peek ( ) ; \n} \n} \nwhile ( buffer != null ) ; \n} \nif ( ws . outQueue . isEmpty ( ) && ws . isFlushAndClose ( ) && ws . getDraft ( ) != null && ws . getDraft ( ) . getRole ( ) != null && ws . getDraft ( ) . getRole ( ) == Role . SERVER ) { \nws . closeConnection ( ) ; \n} \nreturn c == null || ! ( ( WrappedByteChannel ) sockchannel ) . isNeedWrite ( ) ; \n} \n} \n"}
{"472": "public class Draft_6455 { \nprivate void translateSingleFrameCheckLengthLimit ( long length ) throws LimitExceededException { \nif ( Integer . MAX_VALUE < length ) { \nlog . trace ( \"Limit exedeed: Payloadsize is to big...\" ) ; \nthrow new LimitExceededException ( \"Payloadsize is to big...\" ) ; \n} \nif ( maxFrameSize < length ) { \nlog . trace ( \"Payload limit reached. Allowed: {} Current: {}\" , maxFrameSize , length ) ; \nthrow new LimitExceededException ( \"Payload limit reached.\" , maxFrameSize ) ; \n} \nif ( 0 > length ) { \nlog . trace ( \"Limit underflow: Payloadsize is to little...\" ) ; \nthrow new LimitExceededException ( \"Payloadsize is to little...\" ) ; \n} \n} \n} \n"}
{"473": "public class Draft_6455 { \nprivate void translateSingleFrameCheckPacketSize ( int maxpacketsize , int realpacketsize ) throws IncompleteException { \nif ( realpacketsize > maxpacketsize ) { \nlog . trace ( \"Incomplete frame: maxpacketsize < realpacketsize\" ) ; \nthrow new IncompleteException ( realpacketsize ) ; \n} \n} \n} \n"}
{"482": "public class Draft_6455 { \nprivate void checkBufferLimit ( ) throws LimitExceededException { \nlong totalSize = getByteBufferListSize ( ) ; \nif ( maxFrameSize < totalSize ) { \nclearBufferList ( ) ; \nlog . trace ( \"Payload limit reached. Allowed: {} Current: {}\" , maxFrameSize , totalSize ) ; \nthrow new LimitExceededException ( maxFrameSize ) ; \n} \n} \n} \n"}
{"487": "public class WebSocketImpl { \npublic void decode ( ByteBuffer socketBuffer ) { \nassert ( socketBuffer . hasRemaining ( ) ) ; \nlog . trace ( \"process({}): ({})\" , socketBuffer . remaining ( ) , ( 1000 < socketBuffer . remaining ( ) ? \"too big to display\" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; \nif ( readyState != ReadyState . NOT_YET_CONNECTED ) { \nif ( readyState == ReadyState . OPEN ) { \ndecodeFrames ( socketBuffer ) ; \n} \n} \nelse { \nif ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { \nassert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ; \nif ( socketBuffer . hasRemaining ( ) ) { \ndecodeFrames ( socketBuffer ) ; \n} \nelse if ( tmpHandshakeBytes . hasRemaining ( ) ) { \ndecodeFrames ( tmpHandshakeBytes ) ; \n} \n} \n} \n} \n} \n"}
{"496": "public class AbstractWebSocket { \npublic void setConnectionLostTimeout ( int connectionLostTimeout ) { \nsynchronized ( syncConnectionLost ) { \nthis . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; \nif ( 0 >= this . connectionLostTimeout ) { \nlog . trace ( \"Connection lost timer stopped\" ) ; \ncancelConnectionLostTimer ( ) ; \nreturn ; \n} \nif ( this . websocketRunning ) { \nlog . trace ( \"Connection lost timer restarted\" ) ; \ntry { \nArrayList < WebSocket > connections = new ArrayList < WebSocket > ( getConnections ( ) ) ; \nWebSocketImpl webSocketImpl ; \nfor ( WebSocket conn : connections ) { \nif ( conn instanceof WebSocketImpl ) { \nwebSocketImpl = ( WebSocketImpl ) conn ; \nwebSocketImpl . updateLastPong ( ) ; \n} \n} \n} \ncatch ( Exception e ) { \nlog . error ( \"Exception during connection lost restart\" , e ) ; \n} \nrestartConnectionLostTimer ( ) ; \n} \n} \n} \n} \n"}
{"498": "public class AbstractWebSocket { \nprotected void startConnectionLostTimer ( ) { \nsynchronized ( syncConnectionLost ) { \nif ( 0 >= this . connectionLostTimeout ) { \nlog . trace ( \"Connection lost timer deactivated\" ) ; \nreturn ; \n} \nlog . trace ( \"Connection lost timer started\" ) ; \nthis . websocketRunning = true ; \nrestartConnectionLostTimer ( ) ; \n} \n} \n} \n"}
{"500": "public class AbstractWebSocket { \nprivate void executeConnectionLostDetection ( WebSocket webSocket , long minimumPongTime ) { \nif ( ! ( webSocket instanceof WebSocketImpl ) ) { \nreturn ; \n} \nWebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; \nif ( minimumPongTime > webSocketImpl . getLastPong ( ) ) { \nlog . trace ( \"Closing connection due to no pong received: {}\" , webSocketImpl ) ; \nwebSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\" ) ; \n} \nelse { \nif ( webSocketImpl . isOpen ( ) ) { \nwebSocketImpl . sendPing ( ) ; \n} \nelse { \nlog . trace ( \"Trying to ping a non open connection: {}\" , webSocketImpl ) ; \n} \n} \n} \n} \n"}
{"518": "public class ByteBufferUtils { \npublic static int transferByteBuffer ( ByteBuffer source , ByteBuffer dest ) { \nif ( source == null || dest == null ) { \nthrow new IllegalArgumentException ( ) ; \n} \nint fremain = source . remaining ( ) ; \nint toremain = dest . remaining ( ) ; \nif ( toremain < fremain ) { \nint limit = Math . min ( fremain , toremain ) ; \nsource . limit ( limit ) ; \ndest . put ( source ) ; \nreturn limit ; \n} \nelse { \ndest . put ( source ) ; \nreturn fremain ; \n} \n} \n} \n"}
{"551": "public class MethodUtils { \npublic static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { \ntry { \nfinal Method method = cls . getMethod ( methodName , parameterTypes ) ; \nMemberUtils . setAccessibleWorkaround ( method ) ; \nreturn method ; \n} \ncatch ( final NoSuchMethodException e ) { \n} \nMethod bestMatch = null ; \nfinal Method [ ] methods = cls . getMethods ( ) ; \nfor ( final Method method : methods ) { \nif ( method . getName ( ) . equals ( methodName ) && MemberUtils . isMatchingMethod ( method , parameterTypes ) ) { \nfinal Method accessibleMethod = getAccessibleMethod ( method ) ; \nif ( accessibleMethod != null && ( bestMatch == null || 0 > MemberUtils . compareMethodFit ( accessibleMethod , bestMatch , parameterTypes ) ) ) { \nbestMatch = accessibleMethod ; \n} \n} \n} \nif ( bestMatch != null ) { \nMemberUtils . setAccessibleWorkaround ( bestMatch ) ; \n} \nif ( bestMatch != null && bestMatch . isVarArgs ( ) && 0 < bestMatch . getParameterTypes ( ) . length && 0 < parameterTypes . length ) { \nfinal Class < ? > [ ] methodParameterTypes = bestMatch . getParameterTypes ( ) ; \nfinal Class < ? > methodParameterComponentType = methodParameterTypes [ methodParameterTypes . length - 1 ] . getComponentType ( ) ; \nfinal String methodParameterComponentTypeName = ClassUtils . primitiveToWrapper ( methodParameterComponentType ) . getName ( ) ; \nfinal String parameterTypeName = parameterTypes [ parameterTypes . length - 1 ] . getName ( ) ; \nfinal String parameterTypeSuperClassName = parameterTypes [ parameterTypes . length - 1 ] . getSuperclass ( ) . getName ( ) ; \nif ( ! methodParameterComponentTypeName . equals ( parameterTypeName ) && ! methodParameterComponentTypeName . equals ( parameterTypeSuperClassName ) ) { \nreturn null ; \n} \n} \nreturn bestMatch ; \n} \n} \n"}
{"552": "public class DefaultHttpErrorHandler { \n@ Override public CompletionStage < Result > onClientError ( RequestHeader request , int statusCode , String message ) { \nif ( statusCode == 400 ) { \nreturn onBadRequest ( request , message ) ; \n} \nelse if ( statusCode == 403 ) { \nreturn onForbidden ( request , message ) ; \n} \nelse if ( statusCode == 404 ) { \nreturn onNotFound ( request , message ) ; \n} \nelse if ( 400 <= statusCode && 500 > statusCode ) { \nreturn onOtherClientError ( request , statusCode , message ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"onClientError invoked with non client error status code \" + statusCode + \": \" + message ) ; \n} \n} \n} \n"}
{"561": "public class BuildDocHandlerFactory { \npublic static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { \nassert ( files . length == baseDirs . length ) ; \nFileRepository [ ] repositories = new FileRepository [ files . length ] ; \nList < JarFile > jarFiles = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \nfiles . length > i ; \ni ++ ) { \nFile file = files [ i ] ; \nString baseDir = baseDirs [ i ] ; \nif ( file . isDirectory ( ) ) { \nrepositories [ i ] = new FilesystemRepository ( file ) ; \n} \nelse { \nJarFile jarFile = new JarFile ( file ) ; \njarFiles . add ( jarFile ) ; \nrepositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; \n} \n} \nreturn new DocumentationHandler ( new AggregateFileRepository ( repositories ) , ( ) -> { \nfor ( JarFile jarFile : jarFiles ) { \njarFile . close ( ) ; \n} \n} \n) ; \n} \n} \n"}
{"575": "public class User { \nprivate User findById ( Long id ) { \nif ( 3 < id ) return null ; \nUser user = new User ( ) ; \nuser . id = id ; \nuser . name = \"User \" + String . valueOf ( id ) ; \nreturn user ; \n} \n} \n"}
{"588": "public class Paths { \npublic static String relative ( String startPath , String targetPath ) { \nif ( startPath . equals ( targetPath ) ) { \nreturn CURRENT_DIR ; \n} \nString [ ] start = toSegments ( canonical ( startPath ) ) ; \nString [ ] target = toSegments ( canonical ( targetPath ) ) ; \nif ( ! startPath . endsWith ( SEPARATOR ) ) start = Arrays . copyOfRange ( start , 0 , start . length - 1 ) ; \nString targetFile = \"\" ; \nif ( ! targetPath . endsWith ( SEPARATOR ) ) { \ntargetFile = target [ target . length - 1 ] ; \ntarget = Arrays . copyOfRange ( target , 0 , target . length - 1 ) ; \n} \nString [ ] common = commonPrefix ( start , target ) ; \nString [ ] parents = toParentDirs ( start . length - common . length ) ; \nint relativeStartIdx = common . length ; \nString [ ] relativeDirs = Arrays . copyOfRange ( target , relativeStartIdx , target . length ) ; \nString [ ] relativePath = Arrays . copyOf ( parents , parents . length + relativeDirs . length ) ; \nSystem . arraycopy ( relativeDirs , 0 , relativePath , parents . length , relativeDirs . length ) ; \nString trailingSep = \"\" ; \nif ( 0 < relativePath . length ) trailingSep = SEPARATOR ; \nreturn Arrays . stream ( relativePath ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep + targetFile ; \n} \n} \n"}
{"593": "public class ClassUtils { \npublic static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { \nif ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { \nreturn false ; \n} \nif ( classArray == null ) { \nclassArray = EMPTY_CLASS_ARRAY ; \n} \nif ( toClassArray == null ) { \ntoClassArray = EMPTY_CLASS_ARRAY ; \n} \nfor ( int i = 0 ; \nclassArray . length > i ; \ni ++ ) { \nif ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"641": "public class ServerCookieEncoder { \npublic String encode ( Cookie cookie ) { \nif ( cookie == null ) { \nthrow new NullPointerException ( \"cookie\" ) ; \n} \nfinal String name = cookie . name ( ) ; \nfinal String value = cookie . value ( ) != null ? cookie . value ( ) : \"\" ; \nvalidateCookie ( name , value ) ; \nStringBuilder buf = new StringBuilder ( ) ; \nif ( cookie . wrap ( ) ) { \naddQuoted ( buf , name , value ) ; \n} \nelse { \nadd ( buf , name , value ) ; \n} \nif ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { \nadd ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; \nDate expires = 0 >= cookie . maxAge ( ) ? new Date ( 0 ) : new Date ( cookie . maxAge ( ) * 1000L + System . currentTimeMillis ( ) ) ; \nadd ( buf , CookieHeaderNames . EXPIRES , HttpHeaderDateFormat . get ( ) . format ( expires ) ) ; \n} \nif ( cookie . sameSite ( ) != null ) { \nadd ( buf , CookieHeaderNames . SAMESITE , cookie . sameSite ( ) ) ; \n} \nif ( cookie . path ( ) != null ) { \nadd ( buf , CookieHeaderNames . PATH , cookie . path ( ) ) ; \n} \nif ( cookie . domain ( ) != null ) { \nadd ( buf , CookieHeaderNames . DOMAIN , cookie . domain ( ) ) ; \n} \nif ( cookie . isSecure ( ) ) { \nadd ( buf , CookieHeaderNames . SECURE ) ; \n} \nif ( cookie . isHttpOnly ( ) ) { \nadd ( buf , CookieHeaderNames . HTTPONLY ) ; \n} \nreturn stripTrailingSeparator ( buf ) ; \n} \n} \n"}
{"649": "public class MemberUtils { \nprivate static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { \nfloat cost = 0.0f ; \nClass < ? > cls = srcClass ; \nif ( ! cls . isPrimitive ( ) ) { \ncost += 0.1f ; \ncls = ClassUtils . wrapperToPrimitive ( cls ) ; \n} \nfor ( int i = 0 ; \ncls != destClass && ORDERED_PRIMITIVE_TYPES . length > i ; \ni ++ ) { \nif ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { \ncost += 0.1f ; \nif ( ORDERED_PRIMITIVE_TYPES . length - 1 > i ) { \ncls = ORDERED_PRIMITIVE_TYPES [ i + 1 ] ; \n} \n} \n} \nreturn cost ; \n} \n} \n"}
{"650": "public class MemberUtils { \nprivate static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { \nfinal Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; \nfinal boolean isVarArgs = executable . isVarArgs ( ) ; \nfloat totalCost = 0.0f ; \nfinal long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; \nif ( normalArgsLen > srcArgs . length ) { \nreturn Float . MAX_VALUE ; \n} \nfor ( int i = 0 ; \nnormalArgsLen > i ; \ni ++ ) { \ntotalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; \n} \nif ( isVarArgs ) { \nfinal boolean noVarArgsPassed = destArgs . length > srcArgs . length ; \nfinal boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; \nfinal float varArgsCost = 0.001f ; \nfinal Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; \nif ( noVarArgsPassed ) { \ntotalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; \n} \nelse if ( explicitArrayForVarags ) { \nfinal Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; \ntotalCost += getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; \n} \nelse { \nfor ( int i = destArgs . length - 1 ; \nsrcArgs . length > i ; \ni ++ ) { \nfinal Class < ? > srcClass = srcArgs [ i ] ; \ntotalCost += getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; \n} \n} \n} \nreturn totalCost ; \n} \n} \n"}
{"658": "public class MethodProxy { \npublic Object invoke ( Object obj , Object [ ] args ) throws Throwable { \ntry { \ninit ( ) ; \nFastClassInfo fci = fastClassInfo ; \nreturn fci . f1 . invoke ( fci . i1 , obj , args ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow e . getTargetException ( ) ; \n} \ncatch ( IllegalArgumentException e ) { \nif ( 0 > fastClassInfo . i1 ) throw new IllegalArgumentException ( \"Protected method: \" + sig1 ) ; \nthrow e ; \n} \n} \n} \n"}
{"674": "public class ReflectUtils { \npublic static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { \nMap map = new HashMap ( ) ; \nfor ( int i = 0 ; \nmethods . length > i ; \ni ++ ) { \nMethod method = methods [ i ] ; \nmap . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; \n} \nMethod [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; \nfor ( int i = 0 ; \nresult . length > i ; \ni ++ ) { \nresult [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; \nif ( result [ i ] == null ) { \n} \n} \nreturn result ; \n} \n} \n"}
{"690": "public class HttpRequest { \npublic HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { \nquery ( name1 , value1 == null ? null : value1 . toString ( ) ) ; \nfor ( int i = 0 ; \nparameters . length > i ; \ni += 2 ) { \nString name = parameters [ i ] . toString ( ) ; \nString value = parameters [ i + 1 ] . toString ( ) ; \nquery . add ( name , value ) ; \n} \nreturn this ; \n} \n} \n"}
{"699": "public class Handler { \nstatic Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { \nif ( firstHandler == null ) { \nreturn null ; \n} \nelse { \nfirstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; \n} \nint handlerStart = firstHandler . startPc . bytecodeOffset ; \nint handlerEnd = firstHandler . endPc . bytecodeOffset ; \nint rangeStart = start . bytecodeOffset ; \nint rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; \nif ( handlerEnd <= rangeStart || handlerStart >= rangeEnd ) { \nreturn firstHandler ; \n} \nif ( handlerStart >= rangeStart ) { \nif ( handlerEnd <= rangeEnd ) { \nreturn firstHandler . nextHandler ; \n} \nelse { \nreturn new Handler ( firstHandler , end , firstHandler . endPc ) ; \n} \n} \nelse if ( handlerEnd <= rangeEnd ) { \nreturn new Handler ( firstHandler , firstHandler . startPc , start ) ; \n} \nelse { \nfirstHandler . nextHandler = new Handler ( firstHandler , end , firstHandler . endPc ) ; \nreturn new Handler ( firstHandler , firstHandler . startPc , start ) ; \n} \n} \n} \n"}
{"720": "public class RequestScope { \nprotected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { \nfinal boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( \"GET\" ) ; \nfinal Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nString [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; \nparamValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; \nif ( paramValues != null ) { \nif ( encode ) { \nfor ( int j = 0 ; \nparamValues . length > j ; \nj ++ ) { \nfinal String p = paramValues [ j ] ; \nif ( p != null ) { \nfinal String encoding = madvocEncoding . getEncoding ( ) ; \nparamValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; \n} \n} \n} \nfinal Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n} \n) ; \n} \n} \n} \n"}
{"721": "public class RequestScope { \nprotected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { \nif ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { \nreturn ; \n} \nfinal MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; \nif ( ! multipartRequest . isMultipart ( ) ) { \nreturn ; \n} \nfinal Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; \nwhile ( paramNames . hasMoreElements ( ) ) { \nfinal String paramName = paramNames . nextElement ( ) ; \nif ( servletRequest . getAttribute ( paramName ) != null ) { \ncontinue ; \n} \ntargets . forEachTargetAndIn ( this , ( target , in ) -> { \nfinal String name = in . matchedName ( paramName ) ; \nif ( name != null ) { \nfinal FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; \nif ( ignoreInvalidUploadFiles ) { \nfor ( int j = 0 ; \nparamValues . length > j ; \nj ++ ) { \nfinal FileUpload paramValue = paramValues [ j ] ; \nif ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { \nparamValues [ j ] = null ; \n} \n} \n} \nfinal Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; \ntarget . writeValue ( name , value , true ) ; \n} \n} \n) ; \n} \n} \n} \n"}
{"723": "public class ColumnNamingStrategy { \npublic String convertColumnNameToPropertyName ( final String columnName ) { \nStringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; \nint len = columnName . length ( ) ; \nif ( splitCamelCase ) { \nboolean toUpper = false ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nchar c = columnName . charAt ( i ) ; \nif ( c == separatorChar ) { \ntoUpper = true ; \ncontinue ; \n} \nif ( toUpper ) { \npropertyName . append ( Character . toUpperCase ( c ) ) ; \ntoUpper = false ; \n} \nelse { \npropertyName . append ( Character . toLowerCase ( c ) ) ; \n} \n} \nreturn propertyName . toString ( ) ; \n} \nreturn columnName ; \n} \n} \n"}
{"731": "public class FileNameUtil { \nprivate static String doGetPath ( final String filename , final int separatorAdd ) { \nif ( filename == null ) { \nreturn null ; \n} \nint prefix = getPrefixLength ( filename ) ; \nif ( 0 > prefix ) { \nreturn null ; \n} \nint index = indexOfLastSeparator ( filename ) ; \nint endIndex = index + separatorAdd ; \nif ( filename . length ( ) <= prefix || 0 > index || endIndex <= prefix ) { \nreturn StringPool . EMPTY ; \n} \nreturn filename . substring ( prefix , endIndex ) ; \n} \n} \n"}
{"752": "public class Base64 { \npublic static byte [ ] decode ( final char [ ] arr ) { \nint length = arr . length ; \nif ( length == 0 ) { \nreturn new byte [ 0 ] ; \n} \nint sndx = 0 , endx = length - 1 ; \nint pad = arr [ endx ] == '=' ? ( arr [ endx - 1 ] == '=' ? 2 : 1 ) : 0 ; \nint cnt = endx - sndx + 1 ; \nint sepCnt = 76 < length ? ( arr [ 76 ] == '\\r' ? cnt / 78 : 0 ) << 1 : 0 ; \nint len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; \nbyte [ ] dest = new byte [ len ] ; \nint d = 0 ; \nfor ( int cc = 0 , eLen = ( len / 3 ) * 3 ; \neLen > d ; \n) { \nint i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; \ndest [ d ++ ] = ( byte ) ( i >> 16 ) ; \ndest [ d ++ ] = ( byte ) ( i >> 8 ) ; \ndest [ d ++ ] = ( byte ) i ; \nif ( 0 < sepCnt && ++ cc == 19 ) { \nsndx += 2 ; \ncc = 0 ; \n} \n} \nif ( len > d ) { \nint i = 0 ; \nfor ( int j = 0 ; \nendx - pad >= sndx ; \nj ++ ) { \ni |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; \n} \nfor ( int r = 16 ; \nlen > d ; \nr -= 8 ) { \ndest [ d ++ ] = ( byte ) ( i >> r ) ; \n} \n} \nreturn dest ; \n} \n} \n"}
{"754": "public class CsrfShield { \nprotected static void assureSize ( final Set < Token > tokenSet ) { \nif ( maxTokensPerSession > tokenSet . size ( ) ) { \nreturn ; \n} \nlong validUntilMin = Long . MAX_VALUE ; \nToken tokenToRemove = null ; \nIterator < Token > iterator = tokenSet . iterator ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nToken token = iterator . next ( ) ; \nif ( token . isExpired ( ) ) { \niterator . remove ( ) ; \ncontinue ; \n} \nif ( validUntilMin > token . validUntil ) { \nvalidUntilMin = token . validUntil ; \ntokenToRemove = token ; \n} \n} \nif ( ( tokenToRemove != null ) && ( maxTokensPerSession <= tokenSet . size ( ) ) ) { \ntokenSet . remove ( tokenToRemove ) ; \n} \n} \n} \n"}
{"765": "public class PetiteBeans { \npublic void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nConstructor constructor = null ; \nif ( paramTypes == null ) { \nCtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; \nif ( ctors != null && 0 < ctors . length ) { \nif ( 1 < ctors . length ) { \nthrow new PetiteException ( ctors . length + \" suitable constructor found as injection point for: \" + beanDefinition . type . getName ( ) ) ; \n} \nconstructor = ctors [ 0 ] . getConstructor ( ) ; \n} \n} \nelse { \nCtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , true ) ; \nif ( ctorDescriptor != null ) { \nconstructor = ctorDescriptor . getConstructor ( ) ; \n} \n} \nif ( constructor == null ) { \nthrow new PetiteException ( \"Constructor not found: \" + beanDefinition . type . getName ( ) ) ; \n} \nBeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; \nbeanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; \n} \n} \n"}
{"768": "public class PetiteBeans { \npublic void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nMethod method = null ; \nif ( arguments == null ) { \nMethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; \nif ( methods != null && 0 < methods . length ) { \nif ( 1 < methods . length ) { \nthrow new PetiteException ( methods . length + \" suitable methods found as injection points for: \" + beanDefinition . type . getName ( ) + '#' + methodName ) ; \n} \nmethod = methods [ 0 ] . getMethod ( ) ; \n} \n} \nelse { \nMethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; \nif ( md != null ) { \nmethod = md . getMethod ( ) ; \n} \n} \nif ( method == null ) { \nthrow new PetiteException ( \"Method not found: \" + beanDefinition . type . getName ( ) + '#' + methodName ) ; \n} \nBeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; \nMethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; \nbeanDefinition . addMethodInjectionPoint ( mip ) ; \n} \n} \n"}
{"769": "public class PetiteBeans { \npublic void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( initMethodNames == null ) { \ninitMethodNames = StringPool . EMPTY_ARRAY ; \n} \nint total = initMethodNames . length ; \nInitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; \nint i ; \nfor ( i = 0 ; \ninitMethodNames . length > i ; \ni ++ ) { \nMethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Init method not found: \" + beanDefinition . type . getName ( ) + '#' + initMethodNames [ i ] ) ; \n} \ninitMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; \n} \nbeanDefinition . addInitMethodPoints ( initMethodPoints ) ; \n} \n} \n"}
{"770": "public class PetiteBeans { \npublic void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { \nBeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; \nClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; \nif ( destroyMethodNames == null ) { \ndestroyMethodNames = StringPool . EMPTY_ARRAY ; \n} \nint total = destroyMethodNames . length ; \nDestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; \nint i ; \nfor ( i = 0 ; \ndestroyMethodNames . length > i ; \ni ++ ) { \nMethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; \nif ( md == null ) { \nthrow new PetiteException ( \"Destroy method not found: \" + beanDefinition . type . getName ( ) + '#' + destroyMethodNames [ i ] ) ; \n} \ndestroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; \n} \nbeanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; \n} \n} \n"}
{"776": "public class ProxettaAsmUtil { \npublic static int resolveJavaVersion ( final int version ) { \nfinal int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; \nfinal int platformVersion = javaVersionNumber - 8 + 52 ; \nreturn platformVersion < version ? version : platformVersion ; \n} \n} \n"}
{"777": "public class ProxettaAsmUtil { \npublic static void pushInt ( final MethodVisitor mv , final int value ) { \nif ( 5 >= value ) { \nmv . visitInsn ( ICONST_0 + value ) ; \n} \nelse if ( Byte . MAX_VALUE >= value ) { \nmv . visitIntInsn ( BIPUSH , value ) ; \n} \nelse { \nmv . visitIntInsn ( SIPUSH , value ) ; \n} \n} \n} \n"}
{"778": "public class ProxettaAsmUtil { \npublic static void checkArgumentIndex ( final MethodInfo methodInfo , final int argIndex ) { \nif ( ( 1 > argIndex ) || ( methodInfo . getArgumentsCount ( ) < argIndex ) ) { \nthrow new ProxettaException ( \"Invalid argument index: \" + argIndex ) ; \n} \n} \n} \n"}
{"781": "public class ProxettaAsmUtil { \npublic static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nmv . visitVarInsn ( ALOAD , 0 ) ; \nfor ( int i = 1 ; \nmethodInfo . getArgumentsCount ( ) >= i ; \ni ++ ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n} \n"}
{"782": "public class ProxettaAsmUtil { \npublic static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nfor ( int i = 0 ; \nmethodInfo . getArgumentsCount ( ) > i ; \ni ++ ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n} \n"}
{"783": "public class ProxettaAsmUtil { \npublic static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { \nfor ( int i = 1 ; \nmethodInfo . getArgumentsCount ( ) >= i ; \ni ++ ) { \nloadMethodArgument ( mv , methodInfo , i ) ; \n} \n} \n} \n"}
{"791": "public class EmailUtil { \npublic static boolean isEmptyFlags ( Flags flags ) { \nif ( flags == null ) return true ; \nFlags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; \nif ( systemFlags != null && 0 < systemFlags . length ) { \nreturn false ; \n} \nString [ ] userFlags = flags . getUserFlags ( ) ; \nif ( userFlags != null && 0 < userFlags . length ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"794": "public class ServletUtil { \npublic static void prepareDownload ( final HttpServletResponse response , final File file , final String mimeType ) { \nif ( ! file . exists ( ) ) { \nthrow new IllegalArgumentException ( \"File not found: \" + file ) ; \n} \nif ( Integer . MAX_VALUE < file . length ( ) ) { \nthrow new IllegalArgumentException ( \"File too big: \" + file ) ; \n} \nprepareResponse ( response , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; \n} \n} \n"}
{"795": "public class ServletUtil { \npublic static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { \nif ( ( mimeType == null ) && ( fileName != null ) ) { \nString extension = FileNameUtil . getExtension ( fileName ) ; \nmimeType = MimeTypes . getMimeType ( extension ) ; \n} \nif ( mimeType != null ) { \nresponse . setContentType ( mimeType ) ; \n} \nif ( 0 <= fileSize ) { \nresponse . setContentLength ( fileSize ) ; \n} \nif ( fileName != null ) { \nString name = FileNameUtil . getName ( fileName ) ; \nString encodedFileName = URLCoder . encode ( name ) ; \nresponse . setHeader ( CONTENT_DISPOSITION , \"attachment;filename=\\\"\" + name + \"\\\";filename*=utf8''\" + encodedFileName ) ; \n} \n} \n} \n"}
{"802": "public class ServletUtil { \npublic static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { \nif ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { \nint emptyCount = 0 ; \nint total = paramValues . length ; \nfor ( int i = 0 ; \nparamValues . length > i ; \ni ++ ) { \nString paramValue = paramValues [ i ] ; \nif ( paramValue == null ) { \nemptyCount ++ ; \ncontinue ; \n} \nif ( paramValue . length ( ) == 0 ) { \nemptyCount ++ ; \nif ( treatEmptyParamsAsNull ) { \nparamValue = null ; \n} \n} \nparamValues [ i ] = paramValue ; \n} \nif ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { \nreturn null ; \n} \n} \nreturn paramValues ; \n} \n} \n"}
{"809": "public class BeanData { \npublic Object newBeanInstance ( ) { \nif ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { \nthrow new PetiteException ( \"No constructor (annotated, single or default) founded as injection point for: \" + beanDefinition . type . getName ( ) ) ; \n} \nint paramNo = beanDefinition . ctor . references . length ; \nObject [ ] args = new Object [ paramNo ] ; \nif ( beanDefinition . wiringMode != WiringMode . NONE ) { \nfor ( int i = 0 ; \nparamNo > i ; \ni ++ ) { \nargs [ i ] = pc . getBean ( beanDefinition . ctor . references [ i ] ) ; \nif ( args [ i ] == null ) { \nif ( ( beanDefinition . wiringMode == WiringMode . STRICT ) ) { \nthrow new PetiteException ( \"Wiring constructor failed. References '\" + beanDefinition . ctor . references [ i ] + \"' not found for constructor: \" + beanDefinition . ctor . constructor ) ; \n} \n} \n} \n} \nfinal Object bean ; \ntry { \nbean = beanDefinition . ctor . constructor . newInstance ( args ) ; \n} \ncatch ( Exception ex ) { \nthrow new PetiteException ( \"Failed to create new bean instance '\" + beanDefinition . type . getName ( ) + \"' using constructor: \" + beanDefinition . ctor . constructor , ex ) ; \n} \nreturn bean ; \n} \n} \n"}
{"817": "public class PropsData { \npublic String resolveMacros ( String value , final String ... profiles ) { \nStringTemplateParser stringTemplateParser = new StringTemplateParser ( ) ; \nstringTemplateParser . setResolveEscapes ( false ) ; \nif ( ! ignoreMissingMacros ) { \nstringTemplateParser . setReplaceMissingKey ( false ) ; \n} \nelse { \nstringTemplateParser . setReplaceMissingKey ( true ) ; \nstringTemplateParser . setMissingKeyReplacement ( StringPool . EMPTY ) ; \n} \nfinal Function < String , String > macroResolver = macroName -> { \nString [ ] lookupProfiles = profiles ; \nint leftIndex = macroName . indexOf ( '<' ) ; \nif ( leftIndex != - 1 ) { \nint rightIndex = macroName . indexOf ( '>' ) ; \nString profiles1 = macroName . substring ( leftIndex + 1 , rightIndex ) ; \nmacroName = macroName . substring ( 0 , leftIndex ) . concat ( macroName . substring ( rightIndex + 1 ) ) ; \nlookupProfiles = StringUtil . splitc ( profiles1 , ',' ) ; \nStringUtil . trimAll ( lookupProfiles ) ; \n} \nreturn lookupValue ( macroName , lookupProfiles ) ; \n} \n; \nint loopCount = 0 ; \nwhile ( MAX_INNER_MACROS > loopCount ++ ) { \nfinal String newValue = stringTemplateParser . parse ( value , macroResolver ) ; \nif ( newValue . equals ( value ) ) { \nbreak ; \n} \nif ( skipEmptyProps ) { \nif ( newValue . length ( ) == 0 ) { \nreturn null ; \n} \n} \nvalue = newValue ; \n} \nreturn value ; \n} \n} \n"}
{"819": "public class BCrypt { \nprivate static int streamtoword ( byte [ ] data , int [ ] offp ) { \nint i ; \nint word = 0 ; \nint off = offp [ 0 ] ; \nfor ( i = 0 ; \n4 > i ; \ni ++ ) { \nword = ( word << 8 ) | ( data [ off ] & 0xff ) ; \noff = ( off + 1 ) % data . length ; \n} \noffp [ 0 ] = off ; \nreturn word ; \n} \n} \n"}
{"820": "public class BCrypt { \npublic static String hashpw ( String password , String salt ) { \nBCrypt B ; \nString real_salt ; \nbyte [ ] passwordb , saltb , hashed ; \nchar minor = ( char ) 0 ; \nint rounds , off ; \nStringBuffer rs = new StringBuffer ( ) ; \nif ( salt . charAt ( 0 ) != '$' || salt . charAt ( 1 ) != '2' ) { \nthrow new IllegalArgumentException ( \"Invalid salt version\" ) ; \n} \nif ( salt . charAt ( 2 ) == '$' ) { \noff = 3 ; \n} \nelse { \nminor = salt . charAt ( 2 ) ; \nif ( minor != 'a' || salt . charAt ( 3 ) != '$' ) { \nthrow new IllegalArgumentException ( \"Invalid salt revision\" ) ; \n} \noff = 4 ; \n} \nif ( '$' < salt . charAt ( off + 2 ) ) { \nthrow new IllegalArgumentException ( \"Missing salt rounds\" ) ; \n} \nrounds = Integer . parseInt ( salt . substring ( off , off + 2 ) ) ; \nreal_salt = salt . substring ( off + 3 , off + 25 ) ; \ntry { \npasswordb = ( password + ( 'a' <= minor ? \"\\000\" : \"\" ) ) . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \nthrow new AssertionError ( \"UTF-8 is not supported\" ) ; \n} \nsaltb = decode_base64 ( real_salt , BCRYPT_SALT_LEN ) ; \nB = new BCrypt ( ) ; \nhashed = B . crypt_raw ( passwordb , saltb , rounds , ( int [ ] ) bf_crypt_ciphertext . clone ( ) ) ; \nrs . append ( \"$2\" ) ; \nif ( 'a' <= minor ) { \nrs . append ( minor ) ; \n} \nrs . append ( '$' ) ; \nif ( 10 > rounds ) { \nrs . append ( '0' ) ; \n} \nif ( 30 < rounds ) { \nthrow new IllegalArgumentException ( \"rounds exceeds maximum (30)\" ) ; \n} \nrs . append ( rounds ) . append ( '$' ) . append ( encode_base64 ( saltb , saltb . length ) ) . append ( encode_base64 ( hashed , bf_crypt_ciphertext . length * 4 - 1 ) ) ; \nreturn rs . toString ( ) ; \n} \n} \n"}
{"821": "public class BCrypt { \npublic static boolean checkpw ( String plaintext , String hashed ) { \nbyte [ ] hashed_bytes ; \nbyte [ ] try_bytes ; \ntry { \nString try_pw = hashpw ( plaintext , hashed ) ; \nhashed_bytes = hashed . getBytes ( \"UTF-8\" ) ; \ntry_bytes = try_pw . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \nreturn false ; \n} \nif ( hashed_bytes . length != try_bytes . length ) { \nreturn false ; \n} \nbyte ret = 0 ; \nfor ( int i = 0 ; \ntry_bytes . length > i ; \ni ++ ) { \nret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; \n} \nreturn ret == 0 ; \n} \n} \n"}
{"832": "public class ActionMethodParser { \npublic ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { \nif ( actionHandler != null ) { \nreturn new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; \n} \nfinal ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ; \nfinal Class [ ] paramTypes = actionClassMethod . getParameterTypes ( ) ; \nfinal MethodParam [ ] params = new MethodParam [ paramTypes . length ] ; \nfinal Annotation [ ] [ ] paramAnns = actionClassMethod . getParameterAnnotations ( ) ; \nString [ ] methodParamNames = null ; \nfor ( int ndx = 0 ; \nparamTypes . length > ndx ; \nndx ++ ) { \nClass paramType = paramTypes [ ndx ] ; \nif ( methodParamNames == null ) { \nmethodParamNames = actionMethodParamNameResolver . resolveParamNames ( actionClassMethod ) ; \n} \nfinal String paramName = methodParamNames [ ndx ] ; \nfinal Annotation [ ] parameterAnnotations = paramAnns [ ndx ] ; \nfinal ScopeData paramsScopeData = scopeDataInspector . inspectMethodParameterScopes ( paramName , paramType , parameterAnnotations ) ; \nMapperFunction mapperFunction = null ; \nfor ( final Annotation annotation : parameterAnnotations ) { \nif ( annotation instanceof Mapper ) { \nmapperFunction = MapperFunctionInstances . get ( ) . lookup ( ( ( Mapper ) annotation ) . value ( ) ) ; \nbreak ; \n} \n} \nparams [ ndx ] = new MethodParam ( paramTypes [ ndx ] , paramName , scopeDataInspector . detectAnnotationType ( parameterAnnotations ) , paramsScopeData , mapperFunction ) ; \n} \nreturn new ActionRuntime ( null , actionClass , actionClassMethod , filters , interceptors , actionDefinition , actionResult , defaultActionResult , async , auth , scopeData , params ) ; \n} \n} \n"}
{"833": "public class DecoraResponseWrapper { \n@ Override protected void preResponseCommit ( ) { \nlong lastModified = lastModifiedData . getLastModified ( ) ; \nlong ifModifiedSince = request . getDateHeader ( \"If-Modified-Since\" ) ; \nif ( - 1 < lastModified && ! response . containsHeader ( \"Last-Modified\" ) ) { \nif ( ( lastModified / 1000 * 1000 ) > ifModifiedSince ) { \nresponse . setDateHeader ( \"Last-Modified\" , lastModified ) ; \n} \nelse { \nresponse . reset ( ) ; \nresponse . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; \n} \n} \n} \n} \n"}
{"845": "public class SymbolTable { \nprivate void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) { \nbyte [ ] inputBytes = classReader . b ; \nint currentAttributeOffset = classReader . getFirstAttributeOffset ( ) ; \nfor ( int i = classReader . readUnsignedShort ( currentAttributeOffset - 2 ) ; \n0 < i ; \n-- i ) { \nString attributeName = classReader . readUTF8 ( currentAttributeOffset , charBuffer ) ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \nbootstrapMethodCount = classReader . readUnsignedShort ( currentAttributeOffset + 6 ) ; \nbreak ; \n} \ncurrentAttributeOffset += 6 + classReader . readInt ( currentAttributeOffset + 2 ) ; \n} \nif ( 0 < bootstrapMethodCount ) { \nint bootstrapMethodsOffset = currentAttributeOffset + 8 ; \nint bootstrapMethodsLength = classReader . readInt ( currentAttributeOffset + 2 ) - 2 ; \nbootstrapMethods = new ByteVector ( bootstrapMethodsLength ) ; \nbootstrapMethods . putByteArray ( inputBytes , bootstrapMethodsOffset , bootstrapMethodsLength ) ; \nint currentOffset = bootstrapMethodsOffset ; \nfor ( int i = 0 ; \nbootstrapMethodCount > i ; \ni ++ ) { \nint offset = currentOffset - bootstrapMethodsOffset ; \nint bootstrapMethodRef = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nint numBootstrapArguments = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nint hashCode = classReader . readConst ( bootstrapMethodRef , charBuffer ) . hashCode ( ) ; \nwhile ( 0 < numBootstrapArguments -- ) { \nint bootstrapArgument = classReader . readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nhashCode ^= classReader . readConst ( bootstrapArgument , charBuffer ) . hashCode ( ) ; \n} \nadd ( new Entry ( i , Symbol . BOOTSTRAP_METHOD_TAG , offset , hashCode & 0x7FFFFFFF ) ) ; \n} \n} \n} \n} \n"}
{"861": "public class SymbolTable { \nSymbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { \nfinal int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; \nint hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; \nEntry entry = get ( hashCode ) ; \nwhile ( entry != null ) { \nif ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { \nreturn entry ; \n} \nentry = entry . next ; \n} \nif ( Opcodes . H_PUTSTATIC >= referenceKind ) { \nconstantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; \n} \nelse { \nconstantPool . put112 ( tag , referenceKind , addConstantMethodref ( owner , name , descriptor , isInterface ) . index ) ; \n} \nreturn put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; \n} \n} \n"}
{"871": "public class HttpMultiMap { \nprivate int hash ( final String name ) { \nint h = 0 ; \nfor ( int i = name . length ( ) - 1 ; \n0 <= i ; \ni -- ) { \nchar c = name . charAt ( i ) ; \nif ( ! caseSensitive ) { \nif ( 'A' <= c && 'Z' >= c ) { \nc += 32 ; \n} \n} \nh = 31 * h + c ; \n} \nif ( 0 < h ) { \nreturn h ; \n} \nif ( h == Integer . MIN_VALUE ) { \nreturn Integer . MAX_VALUE ; \n} \nreturn - h ; \n} \n} \n"}
{"872": "public class HttpMultiMap { \npublic HttpMultiMap < V > clear ( ) { \nfor ( int i = 0 ; \nentries . length > i ; \ni ++ ) { \nentries [ i ] = null ; \n} \nhead . before = head . after = head ; \nreturn this ; \n} \n} \n"}
{"876": "public class FastCharBuffer { \nprivate void grow ( final int minCapacity ) { \nfinal int oldCapacity = buffer . length ; \nint newCapacity = oldCapacity << 1 ; \nif ( 0 > newCapacity - minCapacity ) { \nnewCapacity = minCapacity + 512 ; \n} \nbuffer = Arrays . copyOf ( buffer , newCapacity ) ; \n} \n} \n"}
{"877": "public class FastCharBuffer { \n@ Override public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { \nfor ( int i = start ; \nend > i ; \ni ++ ) { \nappend ( csq . charAt ( i ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"879": "public class ProxettaMethodBuilder { \n@ Override public void visitEnd ( ) { \ncreateFirstChainDelegate_Continue ( tmd ) ; \nfor ( int p = 0 ; \ntmd . proxyData . length > p ; \np ++ ) { \ntmd . selectCurrentProxy ( p ) ; \ncreateProxyMethod ( tmd ) ; \n} \n} \n} \n"}
{"894": "public class Buffer { \npublic void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { \nfinal int size = size ( ) ; \nfinal int callbackSize = progressListener . callbackSize ( size ) ; \nint count = 0 ; \nint step = 0 ; \nprogressListener . transferred ( count ) ; \nfor ( Object o : list ) { \nif ( o instanceof FastByteBuffer ) { \nFastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; \nbyte [ ] bytes = fastByteBuffer . toArray ( ) ; \nint offset = 0 ; \nwhile ( bytes . length > offset ) { \nint chunk = callbackSize - step ; \nif ( bytes . length < offset + chunk ) { \nchunk = bytes . length - offset ; \n} \nout . write ( bytes , offset , chunk ) ; \noffset += chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( callbackSize <= step ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nelse if ( o instanceof Uploadable ) { \nUploadable uploadable = ( Uploadable ) o ; \nInputStream inputStream = uploadable . openInputStream ( ) ; \nint remaining = uploadable . getSize ( ) ; \ntry { \nwhile ( 0 < remaining ) { \nint chunk = callbackSize - step ; \nif ( remaining < chunk ) { \nchunk = remaining ; \n} \nStreamUtil . copy ( inputStream , out , chunk ) ; \nremaining -= chunk ; \nstep += chunk ; \ncount += chunk ; \nif ( callbackSize <= step ) { \nprogressListener . transferred ( count ) ; \nstep -= callbackSize ; \n} \n} \n} \nfinally { \nStreamUtil . close ( inputStream ) ; \n} \n} \n} \nif ( step != 0 ) { \nprogressListener . transferred ( count ) ; \n} \n} \n} \n"}
{"903": "public class ReceiveMailSession { \nReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { \nuseAndOpenFolderIfNotSet ( ) ; \nfinal Message [ ] messages ; \ntry { \nif ( filter == null ) { \nmessages = folder . getMessages ( ) ; \n} \nelse { \nmessages = folder . search ( filter . getSearchTerm ( ) ) ; \n} \nif ( messages . length == 0 ) { \nreturn ReceivedEmail . EMPTY_ARRAY ; \n} \nif ( envelope ) { \nfinal FetchProfile fetchProfile = new FetchProfile ( ) ; \nfetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; \nfetchProfile . add ( FetchProfile . Item . FLAGS ) ; \nfolder . fetch ( messages , fetchProfile ) ; \n} \nfinal ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; \nfor ( int i = 0 ; \nmessages . length > i ; \ni ++ ) { \nfinal Message msg = messages [ i ] ; \nemails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nemails [ i ] . flags ( flagsToSet ) ; \nmsg . setFlags ( flagsToSet , true ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { \nemails [ i ] . flags ( ) . remove ( flagsToUnset ) ; \nmsg . setFlags ( flagsToUnset , false ) ; \n} \nif ( EmailUtil . isEmptyFlags ( flagsToSet ) && ! emails [ i ] . isSeen ( ) ) { \nmsg . setFlag ( Flags . Flag . SEEN , false ) ; \n} \n} \nif ( processedMessageConsumer != null ) { \nprocessedMessageConsumer . accept ( messages ) ; \n} \nif ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { \nif ( flagsToSet . contains ( Flags . Flag . DELETED ) ) { \nfolder . expunge ( ) ; \n} \n} \nreturn emails ; \n} \ncatch ( final MessagingException msgexc ) { \nthrow new MailException ( \"Failed to fetch messages\" , msgexc ) ; \n} \n} \n} \n"}
{"933": "public class KeyValueJsonSerializer { \nprotected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { \nif ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { \nreturn count ; \n} \nif ( key != null ) { \ncurrentPath . push ( key . toString ( ) ) ; \n} \nelse { \ncurrentPath . push ( StringPool . NULL ) ; \n} \nboolean include = true ; \nif ( value != null ) { \ninclude = jsonContext . matchIgnoredPropertyTypes ( value . getClass ( ) , false , include ) ; \ninclude = jsonContext . matchPathToQueries ( include ) ; \n} \nif ( ! include ) { \ncurrentPath . pop ( ) ; \nreturn count ; \n} \nif ( key == null ) { \njsonContext . pushName ( null , 0 < count ) ; \n} \nelse { \njsonContext . pushName ( key . toString ( ) , 0 < count ) ; \n} \njsonContext . serialize ( value ) ; \nif ( jsonContext . isNamePopped ( ) ) { \ncount ++ ; \n} \ncurrentPath . pop ( ) ; \nreturn count ; \n} \n} \n"}
{"935": "public class ResultMapper { \nprotected String resolveAlias ( final String value ) { \nfinal StringBuilder result = new StringBuilder ( value . length ( ) ) ; \nint i = 0 ; \nint len = value . length ( ) ; \nwhile ( len > i ) { \nint ndx = value . indexOf ( '<' , i ) ; \nif ( ndx == - 1 ) { \nif ( i == 0 ) { \nString alias = lookupAlias ( value ) ; \nreturn ( alias != null ? alias : value ) ; \n} \nelse { \nresult . append ( value . substring ( i ) ) ; \n} \nbreak ; \n} \nresult . append ( value . substring ( i , ndx ) ) ; \nndx ++ ; \nint ndx2 = value . indexOf ( '>' , ndx ) ; \nString aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; \nString alias = lookupAlias ( aliasName ) ; \nif ( alias != null ) { \nresult . append ( alias ) ; \n} \nelse { \nif ( log . isWarnEnabled ( ) ) { \nlog . warn ( \"Alias not found: \" + aliasName ) ; \n} \n} \ni = ndx2 + 1 ; \n} \ni = 0 ; \nlen = result . length ( ) ; \nwhile ( len > i ) { \nif ( result . charAt ( i ) != '/' ) { \nbreak ; \n} \ni ++ ; \n} \nif ( 1 < i ) { \nreturn result . substring ( i - 1 , len ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"936": "public class ResultMapper { \npublic ResultPath resolveResultPath ( String path , String value ) { \nboolean absolutePath = false ; \nif ( value != null ) { \nvalue = resolveAlias ( value ) ; \nif ( StringUtil . startsWithChar ( value , '/' ) ) { \nabsolutePath = true ; \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath = value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \npath = value ; \nvalue = null ; \n} \n} \nelse { \nint i = 0 ; \nwhile ( value . length ( ) > i ) { \nif ( value . charAt ( i ) != '#' ) { \nbreak ; \n} \nint dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; \nif ( dotNdx != - 1 ) { \npath = path . substring ( 0 , dotNdx ) ; \n} \ni ++ ; \n} \nif ( 0 < i ) { \nvalue = value . substring ( i ) ; \nif ( StringUtil . startsWithChar ( value , '.' ) ) { \nvalue = value . substring ( 1 ) ; \n} \nelse { \nint dotNdx = value . indexOf ( \"..\" ) ; \nif ( dotNdx != - 1 ) { \npath += '.' + value . substring ( 0 , dotNdx ) ; \nvalue = value . substring ( dotNdx + 2 ) ; \n} \nelse { \nif ( 0 < value . length ( ) ) { \nif ( StringUtil . endsWithChar ( path , '/' ) ) { \npath += value ; \n} \nelse { \npath += '.' + value ; \n} \n} \nvalue = null ; \n} \n} \n} \n} \n} \nif ( ! absolutePath ) { \nif ( resultPathPrefix != null ) { \npath = resultPathPrefix + path ; \n} \n} \nreturn new ResultPath ( path , value ) ; \n} \n} \n"}
{"938": "public class MadvocUtil { \npublic static int lastIndexOfSlashDot ( final String str ) { \nint slashNdx = str . lastIndexOf ( '/' ) ; \nint dotNdx = StringUtil . lastIndexOf ( str , '.' , str . length ( ) , slashNdx ) ; \nif ( dotNdx == - 1 ) { \nif ( slashNdx == - 1 ) { \nreturn - 1 ; \n} \nslashNdx ++ ; \nif ( str . length ( ) - 1 > slashNdx ) { \ndotNdx = slashNdx ; \n} \nelse { \ndotNdx = - 1 ; \n} \n} \nreturn dotNdx ; \n} \n} \n"}
{"941": "public class MadvocUtil { \npublic static String stripLastCamelWord ( String name ) { \nint ndx = name . length ( ) - 1 ; \nwhile ( 0 <= ndx ) { \nif ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { \nbreak ; \n} \nndx -- ; \n} \nif ( 0 <= ndx ) { \nname = name . substring ( 0 , ndx ) ; \n} \nreturn name ; \n} \n} \n"}
{"944": "public class Threefish { \npublic void init ( final long [ ] key , final long [ ] tweak ) { \nfinal int newNw = key . length ; \nif ( nw != newNw ) { \nnw = newNw ; \nswitch ( nw ) { \ncase WORDS_4 : pi = PI4 ; \nrpi = RPI4 ; \nr = R4 ; \nbreak ; \ncase WORDS_8 : pi = PI8 ; \nrpi = RPI8 ; \nr = R8 ; \nbreak ; \ncase WORDS_16 : pi = PI16 ; \nrpi = RPI16 ; \nr = R16 ; \nbreak ; \ndefault : throw new RuntimeException ( \"Invalid threefish key\" ) ; \n} \nthis . k = new long [ nw + 1 ] ; \nvd = new long [ nw ] ; \ned = new long [ nw ] ; \nfd = new long [ nw ] ; \nksd = new long [ nw ] ; \n} \nSystem . arraycopy ( key , 0 , this . k , 0 , key . length ) ; \nlong knw = EXTENDED_KEY_SCHEDULE_CONST ; \nfor ( int i = 0 ; \nnw > i ; \ni ++ ) { \nknw ^= this . k [ i ] ; \n} \nthis . k [ nw ] = knw ; \nt [ 0 ] = tweak [ 0 ] ; \nt [ 1 ] = tweak [ 1 ] ; \nt [ 2 ] = t [ 0 ] ^ t [ 1 ] ; \n} \n} \n"}
{"947": "public class Threefish { \nprivate void keySchedule ( final int s ) { \nfor ( int i = 0 ; \nnw > i ; \ni ++ ) { \nksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; \nif ( i == nw - 3 ) { \nksd [ i ] += t [ s % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 2 ) { \nksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; \n} \nelse if ( i == nw - 1 ) { \nksd [ i ] += s ; \n} \n} \n} \n} \n"}
{"948": "public class Threefish { \npublic void init ( final String keyMessage , final long tweak1 , final long tweak2 ) { \nlong [ ] tweak = new long [ ] { \ntweak1 , tweak2 } \n; \nbyte [ ] key = new byte [ blockSize / Byte . SIZE ] ; \nbyte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; \nSystem . arraycopy ( keyData , 0 , key , 0 , keyData . length > key . length ? key . length : keyData . length ) ; \ninit ( bytesToLongs ( key ) , tweak ) ; \n} \n} \n"}
{"950": "public class Threefish { \nprotected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { \nlong [ ] result = new long [ size >> 3 ] ; \nint i8 = offset ; \nfor ( int i = 0 ; \nresult . length > i ; \ni ++ ) { \nresult [ i ] = Bits . getLong ( ba , i8 ) ; \ni8 += 8 ; \n} \nreturn result ; \n} \n} \n"}
{"951": "public class RFC2822AddressParser { \nprivate static String removeAnyBounding ( final char s , final char e , final String str ) { \nif ( str == null || 2 > str . length ( ) ) { \nreturn str ; \n} \nif ( str . startsWith ( String . valueOf ( s ) ) && str . endsWith ( String . valueOf ( e ) ) ) { \nreturn str . substring ( 1 , str . length ( ) - 1 ) ; \n} \nreturn str ; \n} \n} \n"}
{"970": "public class ClassReader { \nprivate int getTypeAnnotationBytecodeOffset ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { \nif ( typeAnnotationOffsets == null || typeAnnotationOffsets . length <= typeAnnotationIndex || TypeReference . INSTANCEOF > readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) ) { \nreturn - 1 ; \n} \nreturn readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; \n} \n} \n"}
{"971": "public class ClassReader { \nprivate int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { \nint currentOffset = annotationOffset ; \nint numElementValuePairs = readUnsignedShort ( currentOffset ) ; \ncurrentOffset += 2 ; \nif ( named ) { \nwhile ( 0 < numElementValuePairs -- ) { \nString elementName = readUTF8 ( currentOffset , charBuffer ) ; \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; \n} \n} \nelse { \nwhile ( 0 < numElementValuePairs -- ) { \ncurrentOffset = readElementValue ( annotationVisitor , currentOffset , null , charBuffer ) ; \n} \n} \nif ( annotationVisitor != null ) { \nannotationVisitor . visitEnd ( ) ; \n} \nreturn currentOffset ; \n} \n} \n"}
{"973": "public class ClassReader { \nprivate int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { \nchar [ ] charBuffer = new char [ maxStringLength ] ; \nint currentAttributeOffset = getFirstAttributeOffset ( ) ; \nint [ ] currentBootstrapMethodOffsets = null ; \nfor ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; \n0 < i ; \n-- i ) { \nString attributeName = readUTF8 ( currentAttributeOffset , charBuffer ) ; \nint attributeLength = readInt ( currentAttributeOffset + 2 ) ; \ncurrentAttributeOffset += 6 ; \nif ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { \ncurrentBootstrapMethodOffsets = new int [ readUnsignedShort ( currentAttributeOffset ) ] ; \nint currentBootstrapMethodOffset = currentAttributeOffset + 2 ; \nfor ( int j = 0 ; \ncurrentBootstrapMethodOffsets . length > j ; \n++ j ) { \ncurrentBootstrapMethodOffsets [ j ] = currentBootstrapMethodOffset ; \ncurrentBootstrapMethodOffset += 4 + readUnsignedShort ( currentBootstrapMethodOffset + 2 ) * 2 ; \n} \nreturn currentBootstrapMethodOffsets ; \n} \ncurrentAttributeOffset += attributeLength ; \n} \nreturn null ; \n} \n} \n"}
{"974": "public class Ctors { \nprotected CtorDescriptor [ ] inspectConstructors ( ) { \nClass type = classDescriptor . getType ( ) ; \nConstructor [ ] ctors = type . getDeclaredConstructors ( ) ; \nCtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; \nfor ( int i = 0 ; \nctors . length > i ; \ni ++ ) { \nConstructor ctor = ctors [ i ] ; \nCtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; \nallCtors [ i ] = ctorDescriptor ; \nif ( ctorDescriptor . isDefault ( ) ) { \ndefaultCtor = ctorDescriptor ; \n} \n} \nreturn allCtors ; \n} \n} \n"}
{"975": "public class Ctors { \npublic CtorDescriptor getCtorDescriptor ( final Class ... args ) { \nctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { \nClass [ ] arg = ctorDescriptor . getParameters ( ) ; \nif ( arg . length != args . length ) { \ncontinue ; \n} \nfor ( int j = 0 ; \narg . length > j ; \nj ++ ) { \nif ( arg [ j ] != args [ j ] ) { \ncontinue ctors ; \n} \n} \nreturn ctorDescriptor ; \n} \nreturn null ; \n} \n} \n"}
{"978": "public class LongArrayConverter { \nprotected long [ ] convertArrayToArray ( final Object value ) { \nfinal Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; \nfinal long [ ] result ; \nif ( valueComponentType . isPrimitive ( ) ) { \nresult = convertPrimitiveArrayToArray ( value , valueComponentType ) ; \n} \nelse { \nfinal Object [ ] array = ( Object [ ] ) value ; \nresult = new long [ array . length ] ; \nfor ( int i = 0 ; \narray . length > i ; \ni ++ ) { \nresult [ i ] = convertType ( array [ i ] ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"993": "public class Type { \npublic String getClassName ( ) { \nswitch ( sort ) { \ncase VOID : return \"void\" ; \ncase BOOLEAN : return \"boolean\" ; \ncase CHAR : return \"char\" ; \ncase BYTE : return \"byte\" ; \ncase SHORT : return \"short\" ; \ncase INT : return \"int\" ; \ncase FLOAT : return \"float\" ; \ncase LONG : return \"long\" ; \ncase DOUBLE : return \"double\" ; \ncase ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; \nfor ( int i = getDimensions ( ) ; \n0 < i ; \n-- i ) { \nstringBuilder . append ( \"[]\" ) ; \n} \nreturn stringBuilder . toString ( ) ; \ncase OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( '/' , '.' ) ; \ndefault : throw new AssertionError ( ) ; \n} \n} \n} \n"}
{"1003": "public class JtxTransaction { \npublic < E > E requestResource ( final Class < E > resourceType ) { \nif ( isCompleted ( ) ) { \nthrow new JtxException ( \"TX is already completed, resource are not available after commit or rollback\" ) ; \n} \nif ( isRollbackOnly ( ) ) { \nthrow new JtxException ( \"TX is marked as rollback only, resource are not available\" , rollbackCause ) ; \n} \nif ( ! isNoTransaction ( ) && ! isActive ( ) ) { \nthrow new JtxException ( \"Resources are not available since TX is not active\" ) ; \n} \ncheckTimeout ( ) ; \nE resource = lookupResource ( resourceType ) ; \nif ( resource == null ) { \nint maxResources = txManager . getMaxResourcesPerTransaction ( ) ; \nif ( ( maxResources != - 1 ) && ( maxResources <= resources . size ( ) ) ) { \nthrow new JtxException ( \"TX already has attached max. number of resources\" ) ; \n} \nJtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; \nresource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; \nresources . add ( new JtxResource < > ( this , resourceManager , resource ) ) ; \n} \nreturn resource ; \n} \n} \n"}
{"1005": "public class JsonWriter { \npublic void writeString ( final String value ) { \npopName ( ) ; \nwrite ( StringPool . QUOTE ) ; \nint len = value . length ( ) ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nchar c = value . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : write ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : write ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '/' : if ( strictStringEncoding ) { \nwrite ( \"\\\\/\" ) ; \n} \nelse { \nwrite ( c ) ; \n} \nbreak ; \ncase '\\b' : write ( \"\\\\b\" ) ; \nbreak ; \ncase '\\f' : write ( \"\\\\f\" ) ; \nbreak ; \ncase '\\n' : write ( \"\\\\n\" ) ; \nbreak ; \ncase '\\r' : write ( \"\\\\r\" ) ; \nbreak ; \ncase '\\t' : write ( \"\\\\t\" ) ; \nbreak ; \ndefault : if ( Character . isISOControl ( c ) ) { \nunicode ( c ) ; \n} \nelse { \nwrite ( c ) ; \n} \n} \n} \nwrite ( StringPool . QUOTE ) ; \n} \n} \n"}
{"1006": "public class JsonWriter { \nprotected void unicode ( final char c ) { \nwrite ( \"\\\\u\" ) ; \nint n = c ; \nfor ( int i = 0 ; \n4 > i ; \n++ i ) { \nint digit = ( n & 0xf000 ) >> 12 ; \nchar hex = CharUtil . int2hex ( digit ) ; \nwrite ( hex ) ; \nn <<= 4 ; \n} \n} \n} \n"}
{"1013": "public class ProxettaClassBuilder { \n@ Override public void visit ( final int version , int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { \nwd . init ( name , superName , this . suffix , this . reqProxyClassName ) ; \naccess &= ~ AsmUtil . ACC_ABSTRACT ; \nfinal int v = ProxettaAsmUtil . resolveJavaVersion ( version ) ; \nwd . dest . visit ( v , access , wd . thisReference , signature , wd . superName , null ) ; \nwd . proxyAspects = new ProxyAspectData [ aspects . length ] ; \nfor ( int i = 0 ; \naspects . length > i ; \ni ++ ) { \nwd . proxyAspects [ i ] = new ProxyAspectData ( wd , aspects [ i ] , i ) ; \n} \n} \n} \n"}
{"1018": "public class BinarySearchBase { \npublic int findLast ( int low , int high ) { \nint ndx = - 1 ; \nwhile ( high >= low ) { \nint mid = ( low + high ) >>> 1 ; \nint delta = compare ( mid ) ; \nif ( 0 < delta ) { \nhigh = mid - 1 ; \n} \nelse { \nif ( delta == 0 ) { \nndx = mid ; \n} \nlow = mid + 1 ; \n} \n} \nif ( ndx == - 1 ) { \nreturn - ( low + 1 ) ; \n} \nreturn ndx ; \n} \n} \n"}
{"1036": "public class Format { \npublic static String alignLeftAndPad ( final String text , final int size ) { \nint textLength = text . length ( ) ; \nif ( size < textLength ) { \nreturn text . substring ( 0 , size ) ; \n} \nfinal StringBuilder sb = new StringBuilder ( size ) ; \nsb . append ( text ) ; \nwhile ( size > textLength ++ ) { \nsb . append ( ' ' ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1037": "public class Format { \npublic static String toPrettyString ( final Object value ) { \nif ( value == null ) { \nreturn StringPool . NULL ; \n} \nfinal Class < ? > type = value . getClass ( ) ; \nif ( type . isArray ( ) ) { \nfinal Class componentType = type . getComponentType ( ) ; \nif ( componentType . isPrimitive ( ) ) { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nif ( componentType == int . class ) { \nsb . append ( ArraysUtil . toString ( ( int [ ] ) value ) ) ; \n} \nelse if ( componentType == long . class ) { \nsb . append ( ArraysUtil . toString ( ( long [ ] ) value ) ) ; \n} \nelse if ( componentType == double . class ) { \nsb . append ( ArraysUtil . toString ( ( double [ ] ) value ) ) ; \n} \nelse if ( componentType == float . class ) { \nsb . append ( ArraysUtil . toString ( ( float [ ] ) value ) ) ; \n} \nelse if ( componentType == boolean . class ) { \nsb . append ( ArraysUtil . toString ( ( boolean [ ] ) value ) ) ; \n} \nelse if ( componentType == short . class ) { \nsb . append ( ArraysUtil . toString ( ( short [ ] ) value ) ) ; \n} \nelse if ( componentType == byte . class ) { \nsb . append ( ArraysUtil . toString ( ( byte [ ] ) value ) ) ; \n} \nelse { \nthrow new IllegalArgumentException ( ) ; \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \nelse { \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '[' ) ; \nfinal Object [ ] array = ( Object [ ] ) value ; \nfor ( int i = 0 ; \narray . length > i ; \ni ++ ) { \nif ( 0 < i ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( array [ i ] ) ) ; \n} \nsb . append ( ']' ) ; \nreturn sb . toString ( ) ; \n} \n} \nelse if ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal StringBuilder sb = new StringBuilder ( ) ; \nsb . append ( '{' ) ; \nint i = 0 ; \nfor ( final Object o : iterable ) { \nif ( 0 < i ) { \nsb . append ( ',' ) ; \n} \nsb . append ( toPrettyString ( o ) ) ; \ni ++ ; \n} \nsb . append ( '}' ) ; \nreturn sb . toString ( ) ; \n} \nreturn value . toString ( ) ; \n} \n} \n"}
{"1038": "public class Format { \npublic static String toCamelCase ( final String input , final boolean firstCharUppercase , final char separator ) { \nfinal int length = input . length ( ) ; \nfinal StringBuilder sb = new StringBuilder ( length ) ; \nboolean upperCase = firstCharUppercase ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nfinal char ch = input . charAt ( i ) ; \nif ( ch == separator ) { \nupperCase = true ; \n} \nelse if ( upperCase ) { \nsb . append ( Character . toUpperCase ( ch ) ) ; \nupperCase = false ; \n} \nelse { \nsb . append ( ch ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1039": "public class Format { \npublic static String formatParagraph ( final String src , final int len , final boolean breakOnWhitespace ) { \nStringBuilder str = new StringBuilder ( ) ; \nint total = src . length ( ) ; \nint from = 0 ; \nwhile ( total > from ) { \nint to = from + len ; \nif ( total <= to ) { \nto = total ; \n} \nelse if ( breakOnWhitespace ) { \nint ndx = StringUtil . lastIndexOfWhitespace ( src , to - 1 , from ) ; \nif ( ndx != - 1 ) { \nto = ndx + 1 ; \n} \n} \nint cutFrom = StringUtil . indexOfNonWhitespace ( src , from , to ) ; \nif ( cutFrom != - 1 ) { \nint cutTo = StringUtil . lastIndexOfNonWhitespace ( src , to - 1 , from ) + 1 ; \nstr . append ( src , cutFrom , cutTo ) ; \n} \nstr . append ( '\\n' ) ; \nfrom = to ; \n} \nreturn str . toString ( ) ; \n} \n} \n"}
{"1041": "public class Format { \npublic static String escapeJava ( final String string ) { \nint strLen = string . length ( ) ; \nStringBuilder sb = new StringBuilder ( strLen ) ; \nfor ( int i = 0 ; \nstrLen > i ; \ni ++ ) { \nchar c = string . charAt ( i ) ; \nswitch ( c ) { \ncase '\\b' : sb . append ( \"\\\\b\" ) ; \nbreak ; \ncase '\\t' : sb . append ( \"\\\\t\" ) ; \nbreak ; \ncase '\\n' : sb . append ( \"\\\\n\" ) ; \nbreak ; \ncase '\\f' : sb . append ( \"\\\\f\" ) ; \nbreak ; \ncase '\\r' : sb . append ( \"\\\\r\" ) ; \nbreak ; \ncase '\\\"' : sb . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : sb . append ( \"\\\\\\\\\" ) ; \nbreak ; \ndefault : if ( ( 32 > c ) || ( 127 < c ) ) { \nString hex = Integer . toHexString ( c ) ; \nsb . append ( \"\\\\u\" ) ; \nfor ( int k = hex . length ( ) ; \n4 > k ; \nk ++ ) { \nsb . append ( '0' ) ; \n} \nsb . append ( hex ) ; \n} \nelse { \nsb . append ( c ) ; \n} \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1042": "public class Format { \npublic static String unescapeJava ( final String str ) { \nchar [ ] chars = str . toCharArray ( ) ; \nStringBuilder sb = new StringBuilder ( str . length ( ) ) ; \nfor ( int i = 0 ; \nchars . length > i ; \ni ++ ) { \nchar c = chars [ i ] ; \nif ( c != '\\\\' ) { \nsb . append ( c ) ; \ncontinue ; \n} \ni ++ ; \nc = chars [ i ] ; \nswitch ( c ) { \ncase 'b' : sb . append ( '\\b' ) ; \nbreak ; \ncase 't' : sb . append ( '\\t' ) ; \nbreak ; \ncase 'n' : sb . append ( '\\n' ) ; \nbreak ; \ncase 'f' : sb . append ( '\\f' ) ; \nbreak ; \ncase 'r' : sb . append ( '\\r' ) ; \nbreak ; \ncase '\"' : sb . append ( '\\\"' ) ; \nbreak ; \ncase '\\\\' : sb . append ( '\\\\' ) ; \nbreak ; \ncase 'u' : char hex = ( char ) Integer . parseInt ( new String ( chars , i + 1 , 4 ) , 16 ) ; \nsb . append ( hex ) ; \ni += 4 ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Invalid escaping character: \" + c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1058": "public class BaseLoggableStatement { \npublic String getQueryString ( ) { \nif ( sqlTemplate == null ) { \nreturn toString ( ) ; \n} \nif ( parameterValues == null ) { \nreturn sqlTemplate ; \n} \nfinal StringBuilder sb = new StringBuilder ( ) ; \nint qMarkCount = 0 ; \nfinal StringTokenizer tok = new StringTokenizer ( sqlTemplate + ' ' , \"?\" ) ; \nwhile ( tok . hasMoreTokens ( ) ) { \nfinal String oneChunk = tok . nextToken ( ) ; \nsb . append ( oneChunk ) ; \ntry { \nObject value = null ; \nif ( 1 + qMarkCount < parameterValues . size ( ) ) { \nvalue = parameterValues . get ( 1 + qMarkCount ) ; \nqMarkCount ++ ; \n} \nelse { \nif ( ! tok . hasMoreTokens ( ) ) { \nvalue = \"\" ; \n} \n} \nif ( value == null ) { \nvalue = \"?\" ; \n} \nsb . append ( value ) ; \n} \ncatch ( Throwable th ) { \nsb . append ( \"--- Building query failed: \" ) . append ( th . toString ( ) ) ; \n} \n} \nreturn sb . toString ( ) . trim ( ) ; \n} \n} \n"}
{"1060": "public class IteratorTag { \nprotected int calculateTo ( final int from , final int count , final int size ) { \nint to = size ; \nif ( count != - 1 ) { \nto = from + count ; \nif ( size < to ) { \nto = size ; \n} \n} \nreturn to ; \n} \n} \n"}
{"1061": "public class IteratorTag { \nprotected void iterateCollection ( final Collection collection , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nIterator iter = collection . iterator ( ) ; \nint i = 0 ; \nint to = calculateTo ( from , count , collection . size ( ) ) ; \nwhile ( to > i ) { \nObject item = iter . next ( ) ; \nif ( from <= i ) { \nif ( status != null ) { \niteratorStatus . next ( ! iter . hasNext ( ) ) ; \n} \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \n} \ni ++ ; \n} \n} \n} \n"}
{"1062": "public class IteratorTag { \nprotected void iterateArray ( final Object [ ] array , final int from , final int count , final PageContext pageContext ) throws JspException { \nJspFragment body = getJspBody ( ) ; \nint len = array . length ; \nint to = calculateTo ( from , count , len ) ; \nint last = to - 1 ; \nfor ( int i = from ; \nto > i ; \ni ++ ) { \nObject item = array [ i ] ; \nif ( status != null ) { \niteratorStatus . next ( i == last ) ; \n} \nTagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; \nTagUtil . invokeBody ( body ) ; \n} \n} \n} \n"}
{"1063": "public class StringUtil { \npublic static String replace ( final String s , final String sub , final String with ) { \nif ( sub . isEmpty ( ) ) { \nreturn s ; \n} \nint c = 0 ; \nint i = s . indexOf ( sub , c ) ; \nif ( i == - 1 ) { \nreturn s ; \n} \nint length = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( length + with . length ( ) ) ; \ndo { \nsb . append ( s , c , i ) ; \nsb . append ( with ) ; \nc = i + sub . length ( ) ; \n} \nwhile ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; \nif ( length > c ) { \nsb . append ( s , c , length ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1064": "public class StringUtil { \npublic static String replaceChar ( final String s , final char sub , final char with ) { \nint startIndex = s . indexOf ( sub ) ; \nif ( startIndex == - 1 ) { \nreturn s ; \n} \nchar [ ] str = s . toCharArray ( ) ; \nfor ( int i = startIndex ; \nstr . length > i ; \ni ++ ) { \nif ( str [ i ] == sub ) { \nstr [ i ] = with ; \n} \n} \nreturn new String ( str ) ; \n} \n} \n"}
{"1065": "public class StringUtil { \npublic static String replaceChars ( final String s , final char [ ] sub , final char [ ] with ) { \nchar [ ] str = s . toCharArray ( ) ; \nfor ( int i = 0 ; \nstr . length > i ; \ni ++ ) { \nchar c = str [ i ] ; \nfor ( int j = 0 ; \nsub . length > j ; \nj ++ ) { \nif ( c == sub [ j ] ) { \nstr [ i ] = with [ j ] ; \nbreak ; \n} \n} \n} \nreturn new String ( str ) ; \n} \n} \n"}
{"1070": "public class StringUtil { \npublic static String remove ( final String s , final String sub ) { \nint c = 0 ; \nint sublen = sub . length ( ) ; \nif ( sublen == 0 ) { \nreturn s ; \n} \nint i = s . indexOf ( sub , c ) ; \nif ( i == - 1 ) { \nreturn s ; \n} \nStringBuilder sb = new StringBuilder ( s . length ( ) ) ; \ndo { \nsb . append ( s , c , i ) ; \nc = i + sublen ; \n} \nwhile ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; \nif ( s . length ( ) > c ) { \nsb . append ( s , c , s . length ( ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1071": "public class StringUtil { \npublic static String remove ( final String string , final char ch ) { \nint stringLen = string . length ( ) ; \nchar [ ] result = new char [ stringLen ] ; \nint offset = 0 ; \nfor ( int i = 0 ; \nstringLen > i ; \ni ++ ) { \nchar c = string . charAt ( i ) ; \nif ( c == ch ) { \ncontinue ; \n} \nresult [ offset ] = c ; \noffset ++ ; \n} \nif ( offset == stringLen ) { \nreturn string ; \n} \nreturn new String ( result , 0 , offset ) ; \n} \n} \n"}
{"1076": "public class StringUtil { \npublic static String title ( final String string ) { \nchar [ ] chars = string . toCharArray ( ) ; \nboolean wasWhitespace = true ; \nfor ( int i = 0 ; \nchars . length > i ; \ni ++ ) { \nchar c = chars [ i ] ; \nif ( CharUtil . isWhitespace ( c ) ) { \nwasWhitespace = true ; \n} \nelse { \nif ( wasWhitespace ) { \nchars [ i ] = Character . toUpperCase ( c ) ; \n} \nelse { \nchars [ i ] = Character . toLowerCase ( c ) ; \n} \nwasWhitespace = false ; \n} \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1077": "public class StringUtil { \npublic static String compressChars ( final String s , final char c ) { \nint len = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( len ) ; \nboolean wasChar = false ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nchar c1 = s . charAt ( i ) ; \nif ( c1 == c ) { \nif ( wasChar ) { \ncontinue ; \n} \nwasChar = true ; \n} \nelse { \nwasChar = false ; \n} \nsb . append ( c1 ) ; \n} \nif ( sb . length ( ) == len ) { \nreturn s ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1078": "public class StringUtil { \npublic static boolean startsWithIgnoreCase ( final String src , final String subS , final int startIndex ) { \nString sub = subS . toLowerCase ( ) ; \nint sublen = sub . length ( ) ; \nif ( src . length ( ) < startIndex + sublen ) { \nreturn false ; \n} \nint j = 0 ; \nint i = startIndex ; \nwhile ( sublen > j ) { \nchar source = Character . toLowerCase ( src . charAt ( i ) ) ; \nif ( sub . charAt ( j ) != source ) { \nreturn false ; \n} \nj ++ ; \ni ++ ; \n} \nreturn true ; \n} \n} \n"}
{"1081": "public class StringUtil { \npublic static boolean equalsIgnoreCase ( final String [ ] as , final String [ ] as1 ) { \nif ( as . length != as1 . length ) { \nreturn false ; \n} \nfor ( int i = 0 ; \nas . length > i ; \ni ++ ) { \nif ( ! as [ i ] . equalsIgnoreCase ( as1 [ i ] ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1082": "public class StringUtil { \npublic static int indexOfWhitespace ( final String string , final int startindex , final int endindex ) { \nfor ( int i = startindex ; \nendindex > i ; \ni ++ ) { \nif ( CharUtil . isWhitespace ( string . charAt ( i ) ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1083": "public class StringUtil { \npublic static String stripLeadingChar ( final String string , final char c ) { \nif ( 0 < string . length ( ) ) { \nif ( string . charAt ( 0 ) == c ) { \nreturn string . substring ( 1 ) ; \n} \n} \nreturn string ; \n} \n} \n"}
{"1084": "public class StringUtil { \npublic static String stripTrailingChar ( final String string , final char c ) { \nif ( 0 < string . length ( ) ) { \nif ( string . charAt ( string . length ( ) - 1 ) == c ) { \nreturn string . substring ( 0 , string . length ( ) - 1 ) ; \n} \n} \nreturn string ; \n} \n} \n"}
{"1088": "public class StringUtil { \npublic static void cropAll ( final String ... strings ) { \nfor ( int i = 0 ; \nstrings . length > i ; \ni ++ ) { \nString string = strings [ i ] ; \nif ( string != null ) { \nstring = crop ( strings [ i ] ) ; \n} \nstrings [ i ] = string ; \n} \n} \n} \n"}
{"1089": "public class StringUtil { \npublic static String trimLeft ( final String src ) { \nint len = src . length ( ) ; \nint st = 0 ; \nwhile ( ( len > st ) && ( CharUtil . isWhitespace ( src . charAt ( st ) ) ) ) { \nst ++ ; \n} \nreturn 0 < st ? src . substring ( st ) : src ; \n} \n} \n"}
{"1090": "public class StringUtil { \npublic static String trimRight ( final String src ) { \nint len = src . length ( ) ; \nint count = len ; \nwhile ( ( 0 < len ) && ( CharUtil . isWhitespace ( src . charAt ( len - 1 ) ) ) ) { \nlen -- ; \n} \nreturn ( count > len ) ? src . substring ( 0 , len ) : src ; \n} \n} \n"}
{"1092": "public class StringUtil { \npublic static String join ( final Collection collection , final char separator ) { \nif ( collection == null ) { \nreturn null ; \n} \nif ( collection . size ( ) == 0 ) { \nreturn StringPool . EMPTY ; \n} \nfinal StringBuilder sb = new StringBuilder ( collection . size ( ) * 16 ) ; \nfinal Iterator it = collection . iterator ( ) ; \nfor ( int i = 0 ; \ncollection . size ( ) > i ; \ni ++ ) { \nif ( 0 < i ) { \nsb . append ( separator ) ; \n} \nsb . append ( it . next ( ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1093": "public class StringUtil { \npublic static String join ( final Object [ ] array , final String separator ) { \nif ( array == null ) { \nreturn null ; \n} \nif ( array . length == 0 ) { \nreturn StringPool . EMPTY ; \n} \nif ( array . length == 1 ) { \nreturn String . valueOf ( array [ 0 ] ) ; \n} \nfinal StringBuilder sb = new StringBuilder ( array . length * 16 ) ; \nfor ( int i = 0 ; \narray . length > i ; \ni ++ ) { \nif ( 0 < i ) { \nsb . append ( separator ) ; \n} \nsb . append ( array [ i ] ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1095": "public class StringUtil { \npublic static boolean isCharAtEqual ( final String string , final int index , final char charToCompare ) { \nif ( ( 0 > index ) || ( string . length ( ) <= index ) ) { \nreturn false ; \n} \nreturn string . charAt ( index ) == charToCompare ; \n} \n} \n"}
{"1103": "public class StringUtil { \npublic static String cutSurrounding ( final String string , final String prefix , final String suffix ) { \nint start = 0 ; \nint end = string . length ( ) ; \nif ( string . startsWith ( prefix ) ) { \nstart = prefix . length ( ) ; \n} \nif ( string . endsWith ( suffix ) ) { \nend -= suffix . length ( ) ; \n} \nif ( start >= end ) { \nreturn StringPool . EMPTY ; \n} \nreturn string . substring ( start , end ) ; \n} \n} \n"}
{"1104": "public class StringUtil { \npublic static String insert ( final String src , final String insert , int offset ) { \nif ( 0 > offset ) { \noffset = 0 ; \n} \nif ( src . length ( ) < offset ) { \noffset = src . length ( ) ; \n} \nStringBuilder sb = new StringBuilder ( src ) ; \nsb . insert ( offset , insert ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1105": "public class StringUtil { \npublic static String repeat ( final String source , int count ) { \nStringBand result = new StringBand ( count ) ; \nwhile ( 0 < count ) { \nresult . append ( source ) ; \ncount -- ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"1106": "public class StringUtil { \npublic static String reverse ( final String s ) { \nStringBuilder result = new StringBuilder ( s . length ( ) ) ; \nfor ( int i = s . length ( ) - 1 ; \n0 <= i ; \ni -- ) { \nresult . append ( s . charAt ( i ) ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"1107": "public class StringUtil { \npublic static String maxCommonPrefix ( final String one , final String two ) { \nfinal int minLength = Math . min ( one . length ( ) , two . length ( ) ) ; \nfinal StringBuilder sb = new StringBuilder ( minLength ) ; \nfor ( int pos = 0 ; \nminLength > pos ; \npos ++ ) { \nfinal char currentChar = one . charAt ( pos ) ; \nif ( currentChar != two . charAt ( pos ) ) { \nbreak ; \n} \nsb . append ( currentChar ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1108": "public class StringUtil { \npublic static String findCommonPrefix ( final String ... strings ) { \nStringBuilder prefix = new StringBuilder ( ) ; \nint index = 0 ; \nchar c = 0 ; \nloop : while ( true ) { \nfor ( int i = 0 ; \nstrings . length > i ; \ni ++ ) { \nString s = strings [ i ] ; \nif ( index == s . length ( ) ) { \nbreak loop ; \n} \nif ( i == 0 ) { \nc = s . charAt ( index ) ; \n} \nelse { \nif ( s . charAt ( index ) != c ) { \nbreak loop ; \n} \n} \n} \nindex ++ ; \nprefix . append ( c ) ; \n} \nreturn prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; \n} \n} \n"}
{"1109": "public class StringUtil { \npublic static String shorten ( String s , int length , final String suffix ) { \nlength -= suffix . length ( ) ; \nif ( length < s . length ( ) ) { \nfor ( int j = length ; \n0 <= j ; \nj -- ) { \nif ( CharUtil . isWhitespace ( s . charAt ( j ) ) ) { \nlength = j ; \nbreak ; \n} \n} \nString temp = s . substring ( 0 , length ) ; \ns = temp . concat ( suffix ) ; \n} \nreturn s ; \n} \n} \n"}
{"1110": "public class StringUtil { \npublic static String toUpperCase ( final String s , Locale locale ) { \nif ( s == null ) { \nreturn null ; \n} \nStringBuilder sb = null ; \nfor ( int i = 0 ; \ns . length ( ) > i ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( 127 < c ) { \nif ( locale == null ) { \nlocale = Locale . getDefault ( ) ; \n} \nreturn s . toUpperCase ( locale ) ; \n} \nif ( ( 'a' <= c ) && ( 'z' >= c ) ) { \nif ( sb == null ) { \nsb = new StringBuilder ( s ) ; \n} \nsb . setCharAt ( i , ( char ) ( c - 32 ) ) ; \n} \n} \nif ( sb == null ) { \nreturn s ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1114": "public class StringUtil { \npublic static char detectQuoteChar ( final String str ) { \nif ( 2 > str . length ( ) ) { \nreturn 0 ; \n} \nfinal char c = str . charAt ( 0 ) ; \nif ( c != str . charAt ( str . length ( ) - 1 ) ) { \nreturn 0 ; \n} \nif ( c == '\\'' || c == '\"' || c == '`' ) { \nreturn c ; \n} \nreturn 0 ; \n} \n} \n"}
{"1126": "public class GzipResponseStream { \n@ Override public void close ( ) throws IOException { \nif ( closed ) { \nreturn ; \n} \nif ( gzipstream != null ) { \nflushToGZip ( ) ; \ngzipstream . close ( ) ; \ngzipstream = null ; \n} \nelse { \nif ( 0 < bufferCount ) { \noutput . write ( buffer , 0 , bufferCount ) ; \nbufferCount = 0 ; \n} \n} \noutput . close ( ) ; \nclosed = true ; \n} \n} \n"}
{"1127": "public class GzipResponseStream { \n@ Override public void write ( final int b ) throws IOException { \nif ( closed ) { \nthrow new IOException ( \"Cannot write to a closed output stream\" ) ; \n} \nif ( buffer . length <= bufferCount ) { \nflushToGZip ( ) ; \n} \nbuffer [ bufferCount ++ ] = ( byte ) b ; \n} \n} \n"}
{"1136": "public class StripHtmlTagAdapter { \n@ Override public void text ( final CharSequence text ) { \nif ( ! strip ) { \nsuper . text ( text ) ; \nreturn ; \n} \nint textLength = text . length ( ) ; \nchar [ ] dest = new char [ textLength ] ; \nint ndx = 0 ; \nboolean regularChar = true ; \nfor ( int i = 0 ; \ntextLength > i ; \ni ++ ) { \nchar c = text . charAt ( i ) ; \nif ( CharUtil . isWhitespace ( c ) ) { \nif ( regularChar ) { \nregularChar = false ; \nc = ' ' ; \n} \nelse { \ncontinue ; \n} \n} \nelse { \nregularChar = true ; \n} \ndest [ ndx ] = c ; \nndx ++ ; \n} \nif ( regularChar || ( ndx != 1 ) ) { \nsuper . text ( CharBuffer . wrap ( dest , 0 , ndx ) ) ; \nstrippedCharsCount += textLength - ndx ; \n} \nelse { \nstrippedCharsCount += textLength ; \n} \n} \n} \n"}
{"1143": "public class NodeSelector { \nprotected void walkDescendantsIteratively ( final LinkedList < Node > nodes , final CssSelector cssSelector , final List < Node > result ) { \nwhile ( ! nodes . isEmpty ( ) ) { \nNode node = nodes . removeFirst ( ) ; \nselectAndAdd ( node , cssSelector , result ) ; \nint childCount = node . getChildNodesCount ( ) ; \nfor ( int i = childCount - 1 ; \n0 <= i ; \ni -- ) { \nnodes . addFirst ( node . getChild ( i ) ) ; \n} \n} \n} \n} \n"}
{"1144": "public class NodeSelector { \nprotected void walk ( final Node rootNode , final CssSelector cssSelector , final List < Node > result ) { \nCssSelector previousCssSelector = cssSelector . getPrevCssSelector ( ) ; \nCombinator combinator = previousCssSelector != null ? previousCssSelector . getCombinator ( ) : Combinator . DESCENDANT ; \nswitch ( combinator ) { \ncase DESCENDANT : LinkedList < Node > nodes = new LinkedList < > ( ) ; \nint childCount = rootNode . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \nchildCount > i ; \ni ++ ) { \nnodes . add ( rootNode . getChild ( i ) ) ; \n} \nwalkDescendantsIteratively ( nodes , cssSelector , result ) ; \nbreak ; \ncase CHILD : childCount = rootNode . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \nchildCount > i ; \ni ++ ) { \nNode node = rootNode . getChild ( i ) ; \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase ADJACENT_SIBLING : Node node = rootNode . getNextSiblingElement ( ) ; \nif ( node != null ) { \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \ncase GENERAL_SIBLING : node = rootNode ; \nwhile ( true ) { \nnode = node . getNextSiblingElement ( ) ; \nif ( node == null ) { \nbreak ; \n} \nselectAndAdd ( node , cssSelector , result ) ; \n} \nbreak ; \n} \n} \n} \n"}
{"1147": "public class CSSellyLexer { \nprivate static char [ ] zzUnpackCMap ( final String packed ) { \nchar [ ] map = new char [ 0x110000 ] ; \nint i = 0 ; \nint j = 0 ; \nwhile ( 128 > i ) { \nint count = packed . charAt ( i ++ ) ; \nchar value = packed . charAt ( i ++ ) ; \ndo map [ j ++ ] = value ; \nwhile ( 0 < -- count ) ; \n} \nreturn map ; \n} \n} \n"}
{"1151": "public class DbPager { \nprotected String removeToFrom ( String sql ) { \nint from = 0 ; \nint fromCount = 1 ; \nint selectCount = 0 ; \nint lastNdx = 0 ; \nwhile ( true ) { \nint ndx = StringUtil . indexOfIgnoreCase ( sql , \"from\" , from ) ; \nif ( ndx == - 1 ) { \nbreak ; \n} \nString left = sql . substring ( lastNdx , ndx ) ; \nselectCount += StringUtil . countIgnoreCase ( left , \"select\" ) ; \nif ( selectCount <= fromCount ) { \nsql = sql . substring ( ndx ) ; \nbreak ; \n} \nlastNdx = ndx ; \nfrom = ndx + 4 ; \nfromCount ++ ; \n} \nreturn sql ; \n} \n} \n"}
{"1152": "public class DbPager { \nprotected String removeLastOrderBy ( String sql ) { \nint ndx = StringUtil . lastIndexOfIgnoreCase ( sql , \"order by\" ) ; \nif ( ndx != - 1 ) { \nint ndx2 = sql . lastIndexOf ( sql , ')' ) ; \nif ( ndx2 < ndx ) { \nsql = sql . substring ( 0 , ndx ) ; \n} \n} \nreturn sql ; \n} \n} \n"}
{"1154": "public class HtmlDecoder { \npublic static String detectName ( final char [ ] input , int ndx ) { \nfinal Ptr ptr = new Ptr ( ) ; \nint firstIndex = 0 ; \nint lastIndex = ENTITY_NAMES . length - 1 ; \nint len = input . length ; \nchar [ ] lastName = null ; \nfinal BinarySearchBase binarySearch = new BinarySearchBase ( ) { \n@ Override protected int compare ( final int index ) { \nchar [ ] name = ENTITY_NAMES [ index ] ; \nif ( name . length <= ptr . offset ) { \nreturn - 1 ; \n} \nreturn name [ ptr . offset ] - ptr . c ; \n} \n} \n; \nwhile ( true ) { \nptr . c = input [ ndx ] ; \nif ( ! CharUtil . isAlphaOrDigit ( ptr . c ) ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nfirstIndex = binarySearch . findFirst ( firstIndex , lastIndex ) ; \nif ( 0 > firstIndex ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nchar [ ] element = ENTITY_NAMES [ firstIndex ] ; \nif ( element . length == ptr . offset + 1 ) { \nlastName = ENTITY_NAMES [ firstIndex ] ; \n} \nlastIndex = binarySearch . findLast ( firstIndex , lastIndex ) ; \nif ( firstIndex == lastIndex ) { \nfor ( int i = ptr . offset ; \nelement . length > i ; \ni ++ ) { \nif ( element [ i ] != input [ ndx ] ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \nndx ++ ; \n} \nreturn new String ( element ) ; \n} \nptr . offset ++ ; \nndx ++ ; \nif ( ndx == len ) { \nreturn lastName != null ? new String ( lastName ) : null ; \n} \n} \n} \n} \n"}
{"1157": "public class DbEntityDescriptor { \nprivate void resolveColumnsAndProperties ( final Class type ) { \nPropertyDescriptor [ ] allProperties = ClassIntrospector . get ( ) . lookup ( type ) . getAllPropertyDescriptors ( ) ; \nList < DbEntityColumnDescriptor > decList = new ArrayList < > ( allProperties . length ) ; \nint idcount = 0 ; \nHashSet < String > names = new HashSet < > ( allProperties . length ) ; \nfor ( PropertyDescriptor propertyDescriptor : allProperties ) { \nDbEntityColumnDescriptor dec = DbMetaUtil . resolveColumnDescriptors ( this , propertyDescriptor , isAnnotated , columnNamingStrategy ) ; \nif ( dec != null ) { \nif ( ! names . add ( dec . getColumnName ( ) ) ) { \nthrow new DbOomException ( \"Duplicate column name: \" + dec . getColumnName ( ) ) ; \n} \ndecList . add ( dec ) ; \nif ( dec . isId ) { \nidcount ++ ; \n} \n} \n} \nif ( decList . isEmpty ( ) ) { \nthrow new DbOomException ( \"No column mappings in entity: \" + type ) ; \n} \ncolumnDescriptors = decList . toArray ( new DbEntityColumnDescriptor [ 0 ] ) ; \nArrays . sort ( columnDescriptors ) ; \nif ( 0 < idcount ) { \nidColumnDescriptors = new DbEntityColumnDescriptor [ idcount ] ; \nidcount = 0 ; \nfor ( DbEntityColumnDescriptor dec : columnDescriptors ) { \nif ( dec . isId ) { \nidColumnDescriptors [ idcount ++ ] = dec ; \n} \n} \n} \n} \n} \n"}
{"1165": "public class StringBand { \npublic StringBand append ( String s ) { \nif ( s == null ) { \ns = StringPool . NULL ; \n} \nif ( array . length <= index ) { \nexpandCapacity ( ) ; \n} \narray [ index ++ ] = s ; \nlength += s . length ( ) ; \nreturn this ; \n} \n} \n"}
{"1166": "public class StringBand { \npublic void setIndex ( final int newIndex ) { \nif ( 0 > newIndex ) { \nthrow new ArrayIndexOutOfBoundsException ( newIndex ) ; \n} \nif ( array . length < newIndex ) { \nString [ ] newArray = new String [ newIndex ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , index ) ; \narray = newArray ; \n} \nif ( index < newIndex ) { \nfor ( int i = index ; \nnewIndex > i ; \ni ++ ) { \narray [ i ] = StringPool . EMPTY ; \n} \n} \nelse if ( index > newIndex ) { \nfor ( int i = newIndex ; \nindex > i ; \ni ++ ) { \narray [ i ] = null ; \n} \n} \nindex = newIndex ; \nlength = calculateLength ( ) ; \n} \n} \n"}
{"1168": "public class StringBand { \nprotected int calculateLength ( ) { \nint len = 0 ; \nfor ( int i = 0 ; \nindex > i ; \ni ++ ) { \nlen += array [ i ] . length ( ) ; \n} \nreturn len ; \n} \n} \n"}
{"1178": "public class FieldWriter { \nint computeFieldInfoSize ( ) { \nint size = 8 ; \nif ( constantValueIndex != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ; \nsize += 8 ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && Opcodes . V1_5 > symbolTable . getMajorVersion ( ) ) { \nsymbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ; \nsize += 6 ; \n} \nif ( signatureIndex != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ; \nsize += 8 ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \nsymbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ; \nsize += 6 ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \nsize += lastRuntimeVisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \nsize += lastRuntimeInvisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \nsize += lastRuntimeVisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \nsize += lastRuntimeInvisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) ; \n} \nif ( firstAttribute != null ) { \nsize += firstAttribute . computeAttributesSize ( symbolTable ) ; \n} \nreturn size ; \n} \n} \n"}
{"1179": "public class FieldWriter { \nvoid putFieldInfo ( final ByteVector output ) { \nboolean useSyntheticAttribute = Opcodes . V1_5 > symbolTable . getMajorVersion ( ) ; \nint mask = useSyntheticAttribute ? Opcodes . ACC_SYNTHETIC : 0 ; \noutput . putShort ( accessFlags & ~ mask ) . putShort ( nameIndex ) . putShort ( descriptorIndex ) ; \nint attributesCount = 0 ; \nif ( constantValueIndex != 0 ) { \n++ attributesCount ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { \n++ attributesCount ; \n} \nif ( signatureIndex != 0 ) { \n++ attributesCount ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \n++ attributesCount ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \n++ attributesCount ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \n++ attributesCount ; \n} \nif ( firstAttribute != null ) { \nattributesCount += firstAttribute . getAttributeCount ( ) ; \n} \noutput . putShort ( attributesCount ) ; \nif ( constantValueIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ) . putInt ( 2 ) . putShort ( constantValueIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ) . putInt ( 0 ) ; \n} \nif ( signatureIndex != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ) . putInt ( 2 ) . putShort ( signatureIndex ) ; \n} \nif ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ) . putInt ( 0 ) ; \n} \nif ( lastRuntimeVisibleAnnotation != null ) { \nlastRuntimeVisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleAnnotation != null ) { \nlastRuntimeInvisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeVisibleTypeAnnotation != null ) { \nlastRuntimeVisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( lastRuntimeInvisibleTypeAnnotation != null ) { \nlastRuntimeInvisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) , output ) ; \n} \nif ( firstAttribute != null ) { \nfirstAttribute . putAttributes ( symbolTable , output ) ; \n} \n} \n} \n"}
{"1184": "public class DecoraParser { \nprotected void writeDecoratedPage ( final Writer out , final char [ ] decoratorContent , final char [ ] pageContent , final DecoraTag [ ] decoraTags ) throws IOException { \nint ndx = 0 ; \nfor ( DecoraTag decoraTag : decoraTags ) { \nint decoratorLen = decoraTag . getStartIndex ( ) - ndx ; \nif ( 0 >= decoratorLen ) { \ncontinue ; \n} \nout . write ( decoratorContent , ndx , decoratorLen ) ; \nndx = decoraTag . getEndIndex ( ) ; \nint regionLen = decoraTag . getRegionLength ( ) ; \nif ( regionLen == 0 ) { \nif ( decoraTag . hasDefaultValue ( ) ) { \nout . write ( decoratorContent , decoraTag . getDefaultValueStart ( ) , decoraTag . getDefaultValueLength ( ) ) ; \n} \n} \nelse { \nwriteRegion ( out , pageContent , decoraTag , decoraTags ) ; \n} \n} \nout . write ( decoratorContent , ndx , decoratorContent . length - ndx ) ; \n} \n} \n"}
{"1195": "public class InExRules { \nprotected boolean processIncludes ( final V value , boolean include ) { \nif ( 0 < includesCount ) { \nif ( ! include ) { \nfor ( Rule < R > rule : rules ) { \nif ( ! rule . include ) { \ncontinue ; \n} \nif ( inExRuleMatcher . accept ( value , rule . value , true ) ) { \ninclude = true ; \nbreak ; \n} \n} \n} \n} \nreturn include ; \n} \n} \n"}
{"1196": "public class InExRules { \nprotected boolean processExcludes ( final V value , boolean include ) { \nif ( 0 < excludesCount ) { \nif ( include ) { \nfor ( Rule < R > rule : rules ) { \nif ( rule . include ) { \ncontinue ; \n} \nif ( inExRuleMatcher . accept ( value , rule . value , false ) ) { \ninclude = false ; \nbreak ; \n} \n} \n} \n} \nreturn include ; \n} \n} \n"}
{"1199": "public class SortedArrayList { \nprotected int findInsertionPoint ( final E o , int low , int high ) { \nwhile ( high >= low ) { \nint mid = ( low + high ) >>> 1 ; \nint delta = compare ( get ( mid ) , o ) ; \nif ( 0 < delta ) { \nhigh = mid - 1 ; \n} \nelse { \nlow = mid + 1 ; \n} \n} \nreturn low ; \n} \n} \n"}
{"1218": "public class AsmUtil { \npublic static String typedescToSignature ( final String desc , final MutableInteger from ) { \nint fromIndex = from . get ( ) ; \nfrom . value ++ ; \nswitch ( desc . charAt ( fromIndex ) ) { \ncase 'B' : return \"byte\" ; \ncase 'C' : return \"char\" ; \ncase 'D' : return \"double\" ; \ncase 'F' : return \"float\" ; \ncase 'I' : return \"int\" ; \ncase 'J' : return \"long\" ; \ncase 'S' : return \"short\" ; \ncase 'Z' : return \"boolean\" ; \ncase 'V' : return \"void\" ; \ncase 'L' : int index = desc . indexOf ( ';' , fromIndex ) ; \nif ( 0 > index ) { \nthrow new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \n} \nfrom . set ( index + 1 ) ; \nString str = desc . substring ( fromIndex + 1 , index ) ; \nreturn str . replace ( '/' , '.' ) ; \ncase 'T' : return desc . substring ( from . value ) ; \ncase '[' : StringBuilder brackets = new StringBuilder ( ) ; \nint n = fromIndex ; \nwhile ( desc . charAt ( n ) == '[' ) { \nbrackets . append ( \"[]\" ) ; \nn ++ ; \n} \nfrom . value = n ; \nString type = typedescToSignature ( desc , from ) ; \nreturn type + brackets ; \ndefault : if ( from . value == 0 ) { \nthrow new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; \n} \nreturn desc . substring ( from . value ) ; \n} \n} \n} \n"}
{"1221": "public class CollectionConverter { \n@ SuppressWarnings ( \"unchecked\" ) protected Collection < T > createCollection ( final int length ) { \nif ( collectionType . isInterface ( ) ) { \nif ( collectionType == List . class ) { \nif ( 0 < length ) { \nreturn new ArrayList < > ( length ) ; \n} \nelse { \nreturn new ArrayList < > ( ) ; \n} \n} \nif ( collectionType == Set . class ) { \nif ( 0 < length ) { \nreturn new HashSet < > ( length ) ; \n} \nelse { \nreturn new HashSet < > ( ) ; \n} \n} \nthrow new TypeConversionException ( \"Unknown collection: \" + collectionType . getName ( ) ) ; \n} \nif ( 0 < length ) { \ntry { \nConstructor < Collection < T > > ctor = ( Constructor < Collection < T > > ) collectionType . getConstructor ( int . class ) ; \nreturn ctor . newInstance ( Integer . valueOf ( length ) ) ; \n} \ncatch ( Exception ex ) { \n} \n} \ntry { \nreturn collectionType . getDeclaredConstructor ( ) . newInstance ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new TypeConversionException ( ex ) ; \n} \n} \n} \n"}
{"1226": "public class Label { \nfinal void addLineNumber ( final int lineNumber ) { \nif ( this . lineNumber == 0 ) { \nthis . lineNumber = ( short ) lineNumber ; \n} \nelse { \nif ( otherLineNumbers == null ) { \notherLineNumbers = new int [ LINE_NUMBERS_CAPACITY_INCREMENT ] ; \n} \nint otherLineNumberIndex = ++ otherLineNumbers [ 0 ] ; \nif ( otherLineNumbers . length <= otherLineNumberIndex ) { \nint [ ] newLineNumbers = new int [ otherLineNumbers . length + LINE_NUMBERS_CAPACITY_INCREMENT ] ; \nSystem . arraycopy ( otherLineNumbers , 0 , newLineNumbers , 0 , otherLineNumbers . length ) ; \notherLineNumbers = newLineNumbers ; \n} \notherLineNumbers [ otherLineNumberIndex ] = lineNumber ; \n} \n} \n} \n"}
{"1227": "public class Label { \nfinal void accept ( final MethodVisitor methodVisitor , final boolean visitLineNumbers ) { \nmethodVisitor . visitLabel ( this ) ; \nif ( visitLineNumbers && lineNumber != 0 ) { \nmethodVisitor . visitLineNumber ( lineNumber & 0xFFFF , this ) ; \nif ( otherLineNumbers != null ) { \nfor ( int i = 1 ; \notherLineNumbers [ 0 ] >= i ; \n++ i ) { \nmethodVisitor . visitLineNumber ( otherLineNumbers [ i ] , this ) ; \n} \n} \n} \n} \n} \n"}
{"1229": "public class Label { \nprivate void addForwardReference ( final int sourceInsnBytecodeOffset , final int referenceType , final int referenceHandle ) { \nif ( forwardReferences == null ) { \nforwardReferences = new int [ FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; \n} \nint lastElementIndex = forwardReferences [ 0 ] ; \nif ( forwardReferences . length <= lastElementIndex + 2 ) { \nint [ ] newValues = new int [ forwardReferences . length + FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; \nSystem . arraycopy ( forwardReferences , 0 , newValues , 0 , forwardReferences . length ) ; \nforwardReferences = newValues ; \n} \nforwardReferences [ ++ lastElementIndex ] = sourceInsnBytecodeOffset ; \nforwardReferences [ ++ lastElementIndex ] = referenceType | referenceHandle ; \nforwardReferences [ 0 ] = lastElementIndex ; \n} \n} \n"}
{"1230": "public class Label { \nfinal boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { \nthis . flags |= FLAG_RESOLVED ; \nthis . bytecodeOffset = bytecodeOffset ; \nif ( forwardReferences == null ) { \nreturn false ; \n} \nboolean hasAsmInstructions = false ; \nfor ( int i = forwardReferences [ 0 ] ; \n0 < i ; \ni -= 2 ) { \nfinal int sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; \nfinal int reference = forwardReferences [ i ] ; \nfinal int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; \nint handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; \nif ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) { \nif ( Short . MIN_VALUE > relativeOffset || Short . MAX_VALUE < relativeOffset ) { \nint opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; \nif ( Opcodes . IFNULL > opcode ) { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; \n} \nelse { \ncode [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; \n} \nhasAsmInstructions = true ; \n} \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \nelse { \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 24 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 16 ) ; \ncode [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; \ncode [ handle ] = ( byte ) relativeOffset ; \n} \n} \nreturn hasAsmInstructions ; \n} \n} \n"}
{"1233": "public class NaturalOrderComparator { \nprotected int [ ] compareDigits ( final String str1 , int ndx1 , final String str2 , int ndx2 ) { \nint zeroCount1 = 0 ; \nwhile ( charAt ( str1 , ndx1 ) == '0' ) { \nzeroCount1 ++ ; \nndx1 ++ ; \n} \nint len1 = 0 ; \nwhile ( true ) { \nfinal char char1 = charAt ( str1 , ndx1 ) ; \nfinal boolean isDigitChar1 = CharUtil . isDigit ( char1 ) ; \nif ( ! isDigitChar1 ) { \nbreak ; \n} \nlen1 ++ ; \nndx1 ++ ; \n} \nint zeroCount2 = 0 ; \nwhile ( charAt ( str2 , ndx2 ) == '0' ) { \nzeroCount2 ++ ; \nndx2 ++ ; \n} \nint len2 = 0 ; \nint ndx1_new = ndx1 - len1 ; \nint equalNumbers = 0 ; \nwhile ( true ) { \nfinal char char2 = charAt ( str2 , ndx2 ) ; \nfinal boolean isDigitChar2 = CharUtil . isDigit ( char2 ) ; \nif ( ! isDigitChar2 ) { \nbreak ; \n} \nif ( equalNumbers == 0 && ( ndx1 > ndx1_new ) ) { \nequalNumbers = charAt ( str1 , ndx1_new ++ ) - char2 ; \n} \nlen2 ++ ; \nndx2 ++ ; \n} \nif ( len1 != len2 ) { \nreturn new int [ ] { \nlen1 - len2 } \n; \n} \nif ( equalNumbers != 0 ) { \nreturn new int [ ] { \nequalNumbers } \n; \n} \nreturn new int [ ] { \n0 , zeroCount1 - zeroCount2 , ndx1 , ndx2 } \n; \n} \n} \n"}
{"1234": "public class NaturalOrderComparator { \nprivate char fixAccent ( final char c ) { \nfor ( int i = 0 ; \nACCENT_CHARS . length > i ; \ni += 2 ) { \nfinal char accentChar = ACCENT_CHARS [ i ] ; \nif ( accentChar == c ) { \nreturn ACCENT_CHARS [ i + 1 ] ; \n} \n} \nreturn c ; \n} \n} \n"}
{"1235": "public class ByteVector { \npublic ByteVector putByte ( final int byteValue ) { \nint currentLength = length ; \nif ( data . length < currentLength + 1 ) { \nenlarge ( 1 ) ; \n} \ndata [ currentLength ++ ] = ( byte ) byteValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1236": "public class ByteVector { \nfinal ByteVector put11 ( final int byteValue1 , final int byteValue2 ) { \nint currentLength = length ; \nif ( data . length < currentLength + 2 ) { \nenlarge ( 2 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue1 ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue2 ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1237": "public class ByteVector { \npublic ByteVector putShort ( final int shortValue ) { \nint currentLength = length ; \nif ( data . length < currentLength + 2 ) { \nenlarge ( 2 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1238": "public class ByteVector { \nfinal ByteVector put12 ( final int byteValue , final int shortValue ) { \nint currentLength = length ; \nif ( data . length < currentLength + 3 ) { \nenlarge ( 3 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1239": "public class ByteVector { \nfinal ByteVector put112 ( final int byteValue1 , final int byteValue2 , final int shortValue ) { \nint currentLength = length ; \nif ( data . length < currentLength + 4 ) { \nenlarge ( 4 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue1 ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue2 ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1240": "public class ByteVector { \npublic ByteVector putInt ( final int intValue ) { \nint currentLength = length ; \nif ( data . length < currentLength + 4 ) { \nenlarge ( 4 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) intValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1241": "public class ByteVector { \nfinal ByteVector put122 ( final int byteValue , final int shortValue1 , final int shortValue2 ) { \nint currentLength = length ; \nif ( data . length < currentLength + 5 ) { \nenlarge ( 5 ) ; \n} \nbyte [ ] currentData = data ; \ncurrentData [ currentLength ++ ] = ( byte ) byteValue ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue1 >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue1 ; \ncurrentData [ currentLength ++ ] = ( byte ) ( shortValue2 >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) shortValue2 ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1242": "public class ByteVector { \npublic ByteVector putLong ( final long longValue ) { \nint currentLength = length ; \nif ( data . length < currentLength + 8 ) { \nenlarge ( 8 ) ; \n} \nbyte [ ] currentData = data ; \nint intValue = ( int ) ( longValue >>> 32 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) intValue ; \nintValue = ( int ) longValue ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; \ncurrentData [ currentLength ++ ] = ( byte ) intValue ; \nlength = currentLength ; \nreturn this ; \n} \n} \n"}
{"1243": "public class ByteVector { \npublic ByteVector putByteArray ( final byte [ ] byteArrayValue , final int byteOffset , final int byteLength ) { \nif ( data . length < length + byteLength ) { \nenlarge ( byteLength ) ; \n} \nif ( byteArrayValue != null ) { \nSystem . arraycopy ( byteArrayValue , byteOffset , data , length , byteLength ) ; \n} \nlength += byteLength ; \nreturn this ; \n} \n} \n"}
{"1244": "public class ByteVector { \nprivate void enlarge ( final int size ) { \nint doubleCapacity = 2 * data . length ; \nint minimalCapacity = length + size ; \nbyte [ ] newData = new byte [ minimalCapacity < doubleCapacity ? doubleCapacity : minimalCapacity ] ; \nSystem . arraycopy ( data , 0 , newData , 0 , length ) ; \ndata = newData ; \n} \n} \n"}
{"1270": "public class ExceptionUtil { \n@ SuppressWarnings ( { \n\"ThrowCaughtLocally\" } \n) public static StackTraceElement [ ] getCurrentStackTrace ( ) { \nStackTraceElement [ ] ste = new Exception ( ) . getStackTrace ( ) ; \nif ( 1 < ste . length ) { \nStackTraceElement [ ] result = new StackTraceElement [ ste . length - 1 ] ; \nSystem . arraycopy ( ste , 1 , result , 0 , ste . length - 1 ) ; \nreturn result ; \n} \nelse { \nreturn ste ; \n} \n} \n} \n"}
{"1272": "public class ExceptionUtil { \npublic static StackTraceElement [ ] [ ] getStackTraceChain ( Throwable t , final String [ ] allow , final String [ ] deny ) { \nArrayList < StackTraceElement [ ] > result = new ArrayList < > ( ) ; \nwhile ( t != null ) { \nStackTraceElement [ ] stack = getStackTrace ( t , allow , deny ) ; \nresult . add ( stack ) ; \nt = t . getCause ( ) ; \n} \nStackTraceElement [ ] [ ] allStacks = new StackTraceElement [ result . size ( ) ] [ ] ; \nfor ( int i = 0 ; \nallStacks . length > i ; \ni ++ ) { \nallStacks [ i ] = result . get ( i ) ; \n} \nreturn allStacks ; \n} \n} \n"}
{"1304": "public class URLCoder { \nprivate static String encodeUriComponent ( final String source , final String encoding , final URIPart uriPart ) { \nif ( source == null ) { \nreturn null ; \n} \nbyte [ ] bytes = encodeBytes ( StringUtil . getBytes ( source , encoding ) , uriPart ) ; \nchar [ ] chars = new char [ bytes . length ] ; \nfor ( int i = 0 ; \nbytes . length > i ; \ni ++ ) { \nchars [ i ] = ( char ) bytes [ i ] ; \n} \nreturn new String ( chars ) ; \n} \n} \n"}
{"1313": "public class Properties { \nprotected HashMap < String , PropertyDescriptor > inspectProperties ( ) { \nboolean scanAccessible = classDescriptor . isScanAccessible ( ) ; \nClass type = classDescriptor . getType ( ) ; \nHashMap < String , PropertyDescriptor > map = new HashMap < > ( ) ; \nMethod [ ] methods = scanAccessible ? ClassUtil . getAccessibleMethods ( type ) : ClassUtil . getSupportedMethods ( type ) ; \nfor ( int iteration = 0 ; \n2 > iteration ; \niteration ++ ) { \nfor ( Method method : methods ) { \nif ( Modifier . isStatic ( method . getModifiers ( ) ) ) { \ncontinue ; \n} \nboolean add = false ; \nboolean issetter = false ; \nString propertyName ; \nif ( iteration == 0 ) { \npropertyName = ClassUtil . getBeanPropertyGetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = false ; \n} \n} \nelse { \npropertyName = ClassUtil . getBeanPropertySetterName ( method ) ; \nif ( propertyName != null ) { \nadd = true ; \nissetter = true ; \n} \n} \nif ( add ) { \nMethodDescriptor methodDescriptor = classDescriptor . getMethodDescriptor ( method . getName ( ) , method . getParameterTypes ( ) , true ) ; \naddProperty ( map , propertyName , methodDescriptor , issetter ) ; \n} \n} \n} \nif ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { \nFieldDescriptor [ ] fieldDescriptors = classDescriptor . getAllFieldDescriptors ( ) ; \nString [ ] prefix = classDescriptor . getPropertyFieldPrefix ( ) ; \nfor ( FieldDescriptor fieldDescriptor : fieldDescriptors ) { \nField field = fieldDescriptor . getField ( ) ; \nif ( Modifier . isStatic ( field . getModifiers ( ) ) ) { \ncontinue ; \n} \nString name = field . getName ( ) ; \nif ( prefix != null ) { \nfor ( String p : prefix ) { \nif ( ! name . startsWith ( p ) ) { \ncontinue ; \n} \nname = name . substring ( p . length ( ) ) ; \nbreak ; \n} \n} \nif ( ! map . containsKey ( name ) ) { \nmap . put ( name , createPropertyDescriptor ( name , fieldDescriptor ) ) ; \n} \n} \n} \nreturn map ; \n} \n} \n"}
{"1320": "public class BlockCipher { \npublic byte [ ] encrypt ( final byte [ ] content ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nint length = content . length + 1 ; \nint blockCount = length / blockSizeInBytes ; \nint remaining = length ; \nint offset = 0 ; \nfor ( int i = 0 ; \nblockCount > i ; \ni ++ ) { \nif ( remaining == blockSizeInBytes ) { \nbreak ; \n} \nbyte [ ] encrypted = encryptBlock ( content , offset ) ; \nfbb . append ( encrypted ) ; \noffset += blockSizeInBytes ; \nremaining -= blockSizeInBytes ; \n} \nif ( remaining != 0 ) { \nbyte [ ] block = new byte [ blockSizeInBytes ] ; \nSystem . arraycopy ( content , offset , block , 0 , remaining - 1 ) ; \nblock [ remaining - 1 ] = TERMINATOR ; \nbyte [ ] encrypted = encryptBlock ( block , 0 ) ; \nfbb . append ( encrypted ) ; \n} \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1321": "public class BlockCipher { \npublic byte [ ] decrypt ( final byte [ ] encryptedContent ) { \nFastByteBuffer fbb = new FastByteBuffer ( ) ; \nint length = encryptedContent . length ; \nint blockCount = length / blockSizeInBytes ; \nint offset = 0 ; \nfor ( int i = 0 ; \nblockCount - 1 > i ; \ni ++ ) { \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nfbb . append ( decrypted ) ; \noffset += blockSizeInBytes ; \n} \nbyte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; \nint ndx = blockSizeInBytes - 1 ; \nwhile ( 0 <= ndx ) { \nif ( decrypted [ ndx ] == TERMINATOR ) { \nbreak ; \n} \nndx -- ; \n} \nfbb . append ( decrypted , 0 , ndx ) ; \nreturn fbb . toArray ( ) ; \n} \n} \n"}
{"1323": "public class MapToBean { \nprivate Object generifyList ( final List list , final Class componentType ) { \nfor ( int i = 0 ; \nlist . size ( ) > i ; \ni ++ ) { \nObject element = list . get ( i ) ; \nif ( element != null ) { \nif ( element instanceof Map ) { \nObject bean = map2bean ( ( Map ) element , componentType ) ; \nlist . set ( i , bean ) ; \n} \nelse { \nObject value = convert ( element , componentType ) ; \nlist . set ( i , value ) ; \n} \n} \n} \nreturn list ; \n} \n} \n"}
{"1338": "public class SendMailSession { \nprivate void setRecipients ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { \nfinal InternetAddress [ ] to = EmailAddress . convert ( emailWithData . to ( ) ) ; \nif ( 0 < to . length ) { \nmsgToSet . setRecipients ( RecipientType . TO , to ) ; \n} \nfinal InternetAddress [ ] cc = EmailAddress . convert ( emailWithData . cc ( ) ) ; \nif ( 0 < cc . length ) { \nmsgToSet . setRecipients ( RecipientType . CC , cc ) ; \n} \nfinal InternetAddress [ ] bcc = EmailAddress . convert ( emailWithData . bcc ( ) ) ; \nif ( 0 < bcc . length ) { \nmsgToSet . setRecipients ( RecipientType . BCC , bcc ) ; \n} \n} \n} \n"}
{"1369": "public class DefaultResultSetMapper { \nprotected String [ ] [ ] resolveMappedTypesTableNames ( final Class [ ] types ) { \nif ( cachedMappedNames == null ) { \nString [ ] [ ] names = new String [ types . length ] [ ] ; \nfor ( int i = 0 ; \ntypes . length > i ; \ni ++ ) { \nClass type = types [ i ] ; \nif ( type != null ) { \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded != null ) { \nClass [ ] mappedTypes = ded . getMappedTypes ( ) ; \nif ( mappedTypes != null ) { \nnames [ i ] = createTypesTableNames ( mappedTypes ) ; \n} \n} \n} \n} \ncachedMappedNames = names ; \n} \nreturn cachedMappedNames ; \n} \n} \n"}
{"1370": "public class DefaultResultSetMapper { \nprotected String [ ] createTypesTableNames ( final Class [ ] types ) { \nString [ ] names = new String [ types . length ] ; \nfor ( int i = 0 ; \ntypes . length > i ; \ni ++ ) { \nif ( types [ i ] == null ) { \nnames [ i ] = null ; \ncontinue ; \n} \nDbEntityDescriptor ded = dbEntityManager . lookupType ( types [ i ] ) ; \nif ( ded != null ) { \nString tableName = ded . getTableName ( ) ; \ntableName = tableName . toUpperCase ( ) ; \nnames [ i ] = tableName ; \n} \n} \nreturn names ; \n} \n} \n"}
{"1372": "public class DefaultResultSetMapper { \nprotected void cacheResultSetEntities ( final Object [ ] result ) { \nif ( entitiesCache == null ) { \nentitiesCache = new HashMap < > ( ) ; \n} \nfor ( int i = 0 ; \nresult . length > i ; \ni ++ ) { \nObject object = result [ i ] ; \nif ( object == null ) { \ncontinue ; \n} \nDbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; \nif ( ded == null ) { \ncontinue ; \n} \nObject key ; \nif ( ded . hasIdColumn ( ) ) { \nkey = ded . getKeyValue ( object ) ; \n} \nelse { \nkey = object ; \n} \nObject cachedObject = entitiesCache . get ( key ) ; \nif ( cachedObject == null ) { \nentitiesCache . put ( key , object ) ; \n} \nelse { \nresult [ i ] = cachedObject ; \n} \n} \n} \n} \n"}
{"1375": "public class CoreConnectionPool { \nprivate boolean isConnectionValid ( final ConnectionData connectionData , final long now ) { \nif ( ! validateConnection ) { \nreturn true ; \n} \nif ( connectionData . lastUsed + validationTimeout > now ) { \nreturn true ; \n} \nConnection conn = connectionData . connection ; \nif ( validationQuery == null ) { \ntry { \nreturn ! conn . isClosed ( ) ; \n} \ncatch ( SQLException sex ) { \nreturn false ; \n} \n} \nboolean valid = true ; \nStatement st = null ; \ntry { \nst = conn . createStatement ( ) ; \nst . execute ( validationQuery ) ; \n} \ncatch ( SQLException sex ) { \nvalid = false ; \n} \nfinally { \nif ( st != null ) { \ntry { \nst . close ( ) ; \n} \ncatch ( SQLException ignore ) { \n} \n} \n} \nreturn valid ; \n} \n} \n"}
{"1400": "public class FileUtil { \npublic static byte [ ] readBytes ( final File file , final int count ) throws IOException { \ncheckExists ( file ) ; \ncheckIsFile ( file ) ; \nlong numToRead = file . length ( ) ; \nif ( Integer . MAX_VALUE <= numToRead ) { \nthrow new IOException ( \"File is larger then max array size\" ) ; \n} \nif ( NEGATIVE_ONE < count && numToRead > count ) { \nnumToRead = count ; \n} \nbyte [ ] bytes = new byte [ ( int ) numToRead ] ; \nRandomAccessFile randomAccessFile = new RandomAccessFile ( file , \"r\" ) ; \nrandomAccessFile . readFully ( bytes ) ; \nrandomAccessFile . close ( ) ; \nreturn bytes ; \n} \n} \n"}
{"1406": "public class FileUtil { \npublic static boolean isBinary ( final File file ) throws IOException { \nbyte [ ] bytes = readBytes ( file , 128 ) ; \nfor ( byte b : bytes ) { \nif ( 32 > b && b != 9 && b != 10 && b != 13 ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"1416": "public class Scanner { \npublic final boolean matchUpperCase ( final char [ ] uppercaseTarget ) { \nif ( total < ndx + uppercaseTarget . length ) { \nreturn false ; \n} \nint j = ndx ; \nfor ( int i = 0 ; \nuppercaseTarget . length > i ; \ni ++ , j ++ ) { \nfinal char c = CharUtil . toUpperAscii ( input [ j ] ) ; \nif ( c != uppercaseTarget [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1422": "public class MultipartStreamParser { \npublic void parseRequestStream ( final InputStream inputStream , final String encoding ) throws IOException { \nsetParsed ( ) ; \nMultipartRequestInputStream input = new MultipartRequestInputStream ( inputStream ) ; \ninput . readBoundary ( ) ; \nwhile ( true ) { \nFileUploadHeader header = input . readDataHeader ( encoding ) ; \nif ( header == null ) { \nbreak ; \n} \nif ( header . isFile ) { \nString fileName = header . fileName ; \nif ( 0 < fileName . length ( ) ) { \nif ( 0 < header . contentType . indexOf ( \"application/x-macbinary\" ) ) { \ninput . skipBytes ( 128 ) ; \n} \n} \nFileUpload newFile = fileUploadFactory . create ( input ) ; \nnewFile . processStream ( ) ; \nif ( fileName . length ( ) == 0 ) { \nif ( newFile . getSize ( ) == 0 ) { \nnewFile . size = - 1 ; \n} \n} \nputFile ( header . formFieldName , newFile ) ; \n} \nelse { \nFastByteArrayOutputStream fbos = new FastByteArrayOutputStream ( ) ; \ninput . copyAll ( fbos ) ; \nString value = encoding != null ? new String ( fbos . toByteArray ( ) , encoding ) : new String ( fbos . toByteArray ( ) ) ; \nputParameter ( header . formFieldName , value ) ; \n} \ninput . skipBytes ( 1 ) ; \ninput . mark ( 1 ) ; \nint nextByte = input . read ( ) ; \nif ( nextByte == - 1 || nextByte == '-' ) { \ninput . reset ( ) ; \nbreak ; \n} \ninput . reset ( ) ; \n} \n} \n} \n"}
{"1423": "public class MultipartStreamParser { \npublic String getParameter ( final String paramName ) { \nif ( requestParameters == null ) { \nreturn null ; \n} \nString [ ] values = requestParameters . get ( paramName ) ; \nif ( ( values != null ) && ( 0 < values . length ) ) { \nreturn values [ 0 ] ; \n} \nreturn null ; \n} \n} \n"}
{"1425": "public class MultipartStreamParser { \npublic FileUpload getFile ( final String paramName ) { \nif ( requestFiles == null ) { \nreturn null ; \n} \nFileUpload [ ] values = requestFiles . get ( paramName ) ; \nif ( ( values != null ) && ( 0 < values . length ) ) { \nreturn values [ 0 ] ; \n} \nreturn null ; \n} \n} \n"}
{"1428": "public class TemplateParser { \npublic void parse ( final DbSqlBuilder sqlBuilder , final String template ) { \nint length = template . length ( ) ; \nint last = 0 ; \nwhile ( true ) { \nint mark = template . indexOf ( '$' , last ) ; \nif ( mark == - 1 ) { \nif ( length > last ) { \nsqlBuilder . appendRaw ( template . substring ( last ) ) ; \n} \nbreak ; \n} \nint escapesCount = countEscapes ( template , mark ) ; \nif ( 0 < escapesCount ) { \nboolean isEscaped = escapesCount % 2 != 0 ; \nint escapesToAdd = escapesCount >> 1 ; \nsqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + '$' ) ; \nif ( isEscaped ) { \nlast = mark + 1 ; \ncontinue ; \n} \n} \nelse { \nsqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; \n} \nint end ; \nif ( template . startsWith ( MACRO_TABLE , mark ) ) { \nmark += MACRO_TABLE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonTable ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_COLUMN , mark ) ) { \nmark += MACRO_COLUMN . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonColumn ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_MATCH , mark ) ) { \nmark += MACRO_MATCH . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonMatch ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse if ( template . startsWith ( MACRO_VALUE , mark ) ) { \nmark += MACRO_VALUE . length ( ) ; \nend = findMacroEnd ( template , mark ) ; \nonValue ( sqlBuilder , template . substring ( mark , end ) ) ; \n} \nelse { \nmark ++ ; \nend = mark ; \nwhile ( length > end ) { \nif ( ! isReferenceChar ( template , end ) ) { \nbreak ; \n} \nend ++ ; \n} \nonReference ( sqlBuilder , template . substring ( mark , end ) ) ; \nend -- ; \n} \nend ++ ; \nlast = end ; \n} \n} \n} \n"}
{"1430": "public class TemplateParser { \nprotected int countEscapes ( final String template , int macroIndex ) { \nmacroIndex -- ; \nint escapeCount = 0 ; \nwhile ( 0 <= macroIndex ) { \nif ( template . charAt ( macroIndex ) != ESCAPE_CHARACTER ) { \nbreak ; \n} \nescapeCount ++ ; \nmacroIndex -- ; \n} \nreturn escapeCount ; \n} \n} \n"}
{"1432": "public class HttpUtil { \npublic static HttpMultiMap < String > parseQuery ( final String query , final boolean decode ) { \nfinal HttpMultiMap < String > queryMap = HttpMultiMap . newCaseInsensitiveMap ( ) ; \nif ( StringUtil . isBlank ( query ) ) { \nreturn queryMap ; \n} \nint lastNdx = 0 ; \nwhile ( query . length ( ) > lastNdx ) { \nint ndx = query . indexOf ( '&' , lastNdx ) ; \nif ( ndx == - 1 ) { \nndx = query . length ( ) ; \n} \nfinal String paramAndValue = query . substring ( lastNdx , ndx ) ; \nndx = paramAndValue . indexOf ( '=' ) ; \nif ( ndx == - 1 ) { \nqueryMap . add ( paramAndValue , null ) ; \n} \nelse { \nString name = paramAndValue . substring ( 0 , ndx ) ; \nif ( decode ) { \nname = URLDecoder . decodeQuery ( name ) ; \n} \nString value = paramAndValue . substring ( ndx + 1 ) ; \nif ( decode ) { \nvalue = URLDecoder . decodeQuery ( value ) ; \n} \nqueryMap . add ( name , value ) ; \n} \nlastNdx += paramAndValue . length ( ) + 1 ; \n} \nreturn queryMap ; \n} \n} \n"}
{"1433": "public class HttpUtil { \npublic static String prepareHeaderParameterName ( final String headerName ) { \nif ( headerName . equals ( \"etag\" ) ) { \nreturn HttpBase . HEADER_ETAG ; \n} \nif ( headerName . equals ( \"www-authenticate\" ) ) { \nreturn \"WWW-Authenticate\" ; \n} \nchar [ ] name = headerName . toCharArray ( ) ; \nboolean capitalize = true ; \nfor ( int i = 0 ; \nname . length > i ; \ni ++ ) { \nchar c = name [ i ] ; \nif ( c == '-' ) { \ncapitalize = true ; \ncontinue ; \n} \nif ( capitalize ) { \nname [ i ] = Character . toUpperCase ( c ) ; \ncapitalize = false ; \n} \nelse { \nname [ i ] = Character . toLowerCase ( c ) ; \n} \n} \nreturn new String ( name ) ; \n} \n} \n"}
{"1444": "public class JsonParser { \nprivate void skipObject ( ) { \nint bracketCount = 1 ; \nboolean insideString = false ; \nwhile ( total > ndx ) { \nfinal char c = input [ ndx ] ; \nif ( insideString ) { \nif ( c == '\\\"' && notPrecededByEvenNumberOfBackslashes ( ) ) { \ninsideString = false ; \n} \n} \nelse if ( c == '\\\"' ) { \ninsideString = true ; \n} \nelse if ( c == '{' ) { \nbracketCount ++ ; \n} \nelse if ( c == '}' ) { \nbracketCount -- ; \nif ( bracketCount == 0 ) { \nndx ++ ; \nreturn ; \n} \n} \nndx ++ ; \n} \n} \n} \n"}
{"1448": "public class JsonParser { \nprotected String parseUnquotedStringContent ( ) { \nfinal int startNdx = ndx ; \nwhile ( true ) { \nfinal char c = input [ ndx ] ; \nif ( ' ' >= c || CharUtil . equalsOne ( c , UNQUOTED_DELIMETERS ) ) { \nfinal int currentNdx = ndx ; \nskipWhiteSpaces ( ) ; \nreturn new String ( input , startNdx , currentNdx - startNdx ) ; \n} \nndx ++ ; \n} \n} \n} \n"}
{"1449": "public class JsonParser { \nprotected Number parseNumber ( ) { \nfinal int startIndex = ndx ; \nchar c = input [ ndx ] ; \nboolean isDouble = false ; \nboolean isExp = false ; \nif ( c == '-' ) { \nndx ++ ; \n} \nwhile ( true ) { \nif ( isEOF ( ) ) { \nbreak ; \n} \nc = input [ ndx ] ; \nif ( '0' <= c && '9' >= c ) { \nndx ++ ; \ncontinue ; \n} \nif ( 32 >= c ) { \nbreak ; \n} \nif ( c == ',' || c == '}' || c == ']' ) { \nbreak ; \n} \nif ( c == '.' ) { \nisDouble = true ; \n} \nelse if ( c == 'e' || c == 'E' ) { \nisExp = true ; \n} \nndx ++ ; \n} \nfinal String value = new String ( input , startIndex , ndx - startIndex ) ; \nif ( isDouble ) { \nreturn Double . valueOf ( value ) ; \n} \nlong longNumber ; \nif ( isExp ) { \nlongNumber = Double . valueOf ( value ) . longValue ( ) ; \n} \nelse { \nif ( 19 <= value . length ( ) ) { \nBigInteger bigInteger = new BigInteger ( value ) ; \nif ( isGreaterThanLong ( bigInteger ) ) { \nreturn bigInteger ; \n} \nlongNumber = bigInteger . longValue ( ) ; \n} \nelse { \nlongNumber = Long . parseLong ( value ) ; \n} \n} \nif ( ( Integer . MIN_VALUE <= longNumber ) && ( Integer . MAX_VALUE >= longNumber ) ) { \nreturn ( int ) longNumber ; \n} \nreturn longNumber ; \n} \n} \n"}
{"1456": "public class ReferencesResolver { \npublic BeanReferences [ ] readAllReferencesFromAnnotation ( final Executable methodOrCtor ) { \nPetiteInject petiteInject = methodOrCtor . getAnnotation ( PetiteInject . class ) ; \nfinal Parameter [ ] parameters = methodOrCtor . getParameters ( ) ; \nBeanReferences [ ] references ; \nfinal boolean hasAnnotationOnMethodOrCtor ; \nif ( petiteInject != null ) { \nreferences = convertAnnValueToReferences ( petiteInject . value ( ) ) ; \nhasAnnotationOnMethodOrCtor = true ; \n} \nelse { \nreferences = new BeanReferences [ parameters . length ] ; \nhasAnnotationOnMethodOrCtor = false ; \n} \nint parametersWithAnnotationCount = 0 ; \nfor ( int i = 0 ; \nparameters . length > i ; \ni ++ ) { \nParameter parameter = parameters [ i ] ; \npetiteInject = parameter . getAnnotation ( PetiteInject . class ) ; \nif ( petiteInject == null ) { \ncontinue ; \n} \nString annotationValue = readAnnotationValue ( petiteInject ) ; \nif ( annotationValue != null ) { \nreferences [ i ] = BeanReferences . of ( annotationValue ) ; \n} \nparametersWithAnnotationCount ++ ; \n} \nif ( ! hasAnnotationOnMethodOrCtor ) { \nif ( parametersWithAnnotationCount == 0 ) { \nreturn null ; \n} \nif ( parametersWithAnnotationCount != parameters . length ) { \nthrow new PetiteException ( \"All arguments must be annotated with PetiteInject\" ) ; \n} \n} \nreferences = updateReferencesWithDefaultsIfNeeded ( methodOrCtor , references ) ; \nremoveAllDuplicateNames ( references ) ; \nreturn references ; \n} \n} \n"}
{"1457": "public class ReferencesResolver { \nprivate BeanReferences [ ] buildDefaultReferences ( final Executable methodOrCtor ) { \nfinal boolean useParamo = petiteConfig . getUseParamo ( ) ; \nfinal PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; \nMethodParameter [ ] methodParameters = null ; \nif ( useParamo ) { \nmethodParameters = Paramo . resolveParameters ( methodOrCtor ) ; \n} \nfinal Class [ ] paramTypes = methodOrCtor . getParameterTypes ( ) ; \nfinal BeanReferences [ ] references = new BeanReferences [ paramTypes . length ] ; \nfor ( int j = 0 ; \nparamTypes . length > j ; \nj ++ ) { \nString [ ] ref = new String [ lookupReferences . length ] ; \nreferences [ j ] = BeanReferences . of ( ref ) ; \nfor ( int i = 0 ; \nref . length > i ; \ni ++ ) { \nswitch ( lookupReferences [ i ] ) { \ncase NAME : ref [ i ] = methodParameters != null ? methodParameters [ j ] . getName ( ) : null ; \nbreak ; \ncase TYPE_SHORT_NAME : ref [ i ] = StringUtil . uncapitalize ( paramTypes [ j ] . getSimpleName ( ) ) ; \nbreak ; \ncase TYPE_FULL_NAME : ref [ i ] = paramTypes [ j ] . getName ( ) ; \nbreak ; \n} \n} \n} \nreturn references ; \n} \n} \n"}
{"1458": "public class ReferencesResolver { \npublic BeanReferences buildDefaultReference ( final PropertyDescriptor propertyDescriptor ) { \nfinal PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; \nfinal String [ ] references = new String [ lookupReferences . length ] ; \nfor ( int i = 0 ; \nreferences . length > i ; \ni ++ ) { \nswitch ( lookupReferences [ i ] ) { \ncase NAME : references [ i ] = propertyDescriptor . getName ( ) ; \nbreak ; \ncase TYPE_SHORT_NAME : references [ i ] = StringUtil . uncapitalize ( propertyDescriptor . getType ( ) . getSimpleName ( ) ) ; \nbreak ; \ncase TYPE_FULL_NAME : references [ i ] = propertyDescriptor . getType ( ) . getName ( ) ; \nbreak ; \n} \n} \nreturn BeanReferences . of ( references ) ; \n} \n} \n"}
{"1459": "public class ReferencesResolver { \nprivate void removeAllDuplicateNames ( final BeanReferences [ ] allBeanReferences ) { \nfor ( int i = 0 ; \nallBeanReferences . length > i ; \ni ++ ) { \nBeanReferences references = allBeanReferences [ i ] ; \nallBeanReferences [ i ] = references . removeDuplicateNames ( ) ; \n} \n} \n} \n"}
{"1460": "public class ReferencesResolver { \nprivate BeanReferences [ ] convertRefToReferences ( final String [ ] references ) { \nif ( references == null ) { \nreturn null ; \n} \nBeanReferences [ ] ref = new BeanReferences [ references . length ] ; \nfor ( int i = 0 ; \nreferences . length > i ; \ni ++ ) { \nref [ i ] = BeanReferences . of ( references [ i ] ) ; \n} \nreturn ref ; \n} \n} \n"}
{"1461": "public class ReferencesResolver { \nprivate BeanReferences [ ] convertAnnValueToReferences ( String value ) { \nif ( value == null ) { \nreturn null ; \n} \nvalue = value . trim ( ) ; \nif ( value . length ( ) == 0 ) { \nreturn null ; \n} \nString [ ] refNames = Converter . get ( ) . toStringArray ( value ) ; \nBeanReferences [ ] references = new BeanReferences [ refNames . length ] ; \nfor ( int i = 0 ; \nrefNames . length > i ; \ni ++ ) { \nreferences [ i ] = BeanReferences . of ( refNames [ i ] . trim ( ) ) ; \n} \nreturn references ; \n} \n} \n"}
{"1466": "public class ClassUtil { \npublic static boolean compareParameters ( final Class [ ] first , final Class [ ] second ) { \nif ( first . length != second . length ) { \nreturn false ; \n} \nfor ( int i = 0 ; \nfirst . length > i ; \ni ++ ) { \nif ( first [ i ] != second [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1477": "public class MethodVisitor { \npublic void visitParameter ( final String name , final int access ) { \nif ( Opcodes . ASM5 > api ) { \nthrow new UnsupportedOperationException ( REQUIRES_ASM5 ) ; \n} \nif ( mv != null ) { \nmv . visitParameter ( name , access ) ; \n} \n} \n} \n"}
{"1479": "public class MethodVisitor { \npublic AnnotationVisitor visitTypeAnnotation ( final int typeRef , final TypePath typePath , final String descriptor , final boolean visible ) { \nif ( Opcodes . ASM5 > api ) { \nthrow new UnsupportedOperationException ( REQUIRES_ASM5 ) ; \n} \nif ( mv != null ) { \nreturn mv . visitTypeAnnotation ( typeRef , typePath , descriptor , visible ) ; \n} \nreturn null ; \n} \n} \n"}
{"1482": "public class MethodVisitor { \npublic void visitMethodInsn ( final int opcode , final String owner , final String name , final String descriptor , final boolean isInterface ) { \nif ( Opcodes . ASM5 > api ) { \nif ( isInterface != ( opcode == Opcodes . INVOKEINTERFACE ) ) { \nthrow new IllegalArgumentException ( \"INVOKESPECIAL/STATIC on interfaces requires ASM5\" ) ; \n} \nvisitMethodInsn ( opcode , owner , name , descriptor ) ; \nreturn ; \n} \nif ( mv != null ) { \nmv . visitMethodInsn ( opcode , owner , name , descriptor , isInterface ) ; \n} \n} \n} \n"}
{"1483": "public class MethodVisitor { \npublic void visitInvokeDynamicInsn ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { \nif ( Opcodes . ASM5 > api ) { \nthrow new UnsupportedOperationException ( REQUIRES_ASM5 ) ; \n} \nif ( mv != null ) { \nmv . visitInvokeDynamicInsn ( name , descriptor , bootstrapMethodHandle , bootstrapMethodArguments ) ; \n} \n} \n} \n"}
{"1487": "public class MethodVisitor { \npublic AnnotationVisitor visitLocalVariableAnnotation ( final int typeRef , final TypePath typePath , final Label [ ] start , final Label [ ] end , final int [ ] index , final String descriptor , final boolean visible ) { \nif ( Opcodes . ASM5 > api ) { \nthrow new UnsupportedOperationException ( REQUIRES_ASM5 ) ; \n} \nif ( mv != null ) { \nreturn mv . visitLocalVariableAnnotation ( typeRef , typePath , start , end , index , descriptor , visible ) ; \n} \nreturn null ; \n} \n} \n"}
{"1489": "public class MemoryFileUpload { \n@ Override public void processStream ( ) throws IOException { \nFastByteArrayOutputStream out = new FastByteArrayOutputStream ( ) ; \nsize = 0 ; \nif ( maxFileSize == - 1 ) { \nsize += input . copyAll ( out ) ; \n} \nelse { \nsize += input . copyMax ( out , maxFileSize + 1 ) ; \nif ( maxFileSize < size ) { \nfileTooBig = true ; \nvalid = false ; \ninput . skipToBoundary ( ) ; \nreturn ; \n} \n} \ndata = out . toByteArray ( ) ; \nsize = data . length ; \nvalid = true ; \n} \n} \n"}
{"1494": "public class ArraysUtil { \npublic static < T > T [ ] resize ( T [ ] buffer , int newSize ) { \nClass < T > componentType = ( Class < T > ) buffer . getClass ( ) . getComponentType ( ) ; \nT [ ] temp = ( T [ ] ) Array . newInstance ( componentType , newSize ) ; \nSystem . arraycopy ( buffer , 0 , temp , 0 , newSize <= buffer . length ? newSize : buffer . length ) ; \nreturn temp ; \n} \n} \n"}
{"1497": "public class ArraysUtil { \npublic static int indexOf ( char [ ] array , char value ) { \nfor ( int i = 0 ; \narray . length > i ; \ni ++ ) { \nif ( array [ i ] == value ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1498": "public class ArraysUtil { \npublic static int indexOf ( Object [ ] array , Object value ) { \nfor ( int i = 0 ; \narray . length > i ; \ni ++ ) { \nif ( array [ i ] . equals ( value ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1503": "public class MethodWriter { \nprivate void computeMaxStackAndLocal ( ) { \nHandler handler = firstHandler ; \nwhile ( handler != null ) { \nLabel handlerBlock = handler . handlerPc ; \nLabel handlerRangeBlock = handler . startPc ; \nLabel handlerRangeEnd = handler . endPc ; \nwhile ( handlerRangeBlock != handlerRangeEnd ) { \nif ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) { \nhandlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; \n} \nelse { \nhandlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; \n} \nhandlerRangeBlock = handlerRangeBlock . nextBasicBlock ; \n} \nhandler = handler . nextHandler ; \n} \nif ( hasSubroutines ) { \nshort numSubroutines = 1 ; \nfirstBasicBlock . markSubroutine ( numSubroutines ) ; \nfor ( short currentSubroutine = 1 ; \nnumSubroutines >= currentSubroutine ; \n++ currentSubroutine ) { \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 && basicBlock . subroutineId == currentSubroutine ) { \nLabel jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; \nif ( jsrTarget . subroutineId == 0 ) { \njsrTarget . markSubroutine ( ++ numSubroutines ) ; \n} \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel basicBlock = firstBasicBlock ; \nwhile ( basicBlock != null ) { \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \nLabel subroutine = basicBlock . outgoingEdges . nextEdge . successor ; \nsubroutine . addSubroutineRetSuccessors ( basicBlock ) ; \n} \nbasicBlock = basicBlock . nextBasicBlock ; \n} \n} \nLabel listOfBlocksToProcess = firstBasicBlock ; \nlistOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; \nint maxStackSize = maxStack ; \nwhile ( listOfBlocksToProcess != Label . EMPTY_LIST ) { \nLabel basicBlock = listOfBlocksToProcess ; \nlistOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; \nint inputStackTop = basicBlock . inputStackSize ; \nint maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; \nif ( maxStackSize < maxBlockStackSize ) { \nmaxStackSize = maxBlockStackSize ; \n} \nEdge outgoingEdge = basicBlock . outgoingEdges ; \nif ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { \noutgoingEdge = outgoingEdge . nextEdge ; \n} \nwhile ( outgoingEdge != null ) { \nLabel successorBlock = outgoingEdge . successor ; \nif ( successorBlock . nextListElement == null ) { \nsuccessorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; \nsuccessorBlock . nextListElement = listOfBlocksToProcess ; \nlistOfBlocksToProcess = successorBlock ; \n} \noutgoingEdge = outgoingEdge . nextEdge ; \n} \n} \nthis . maxStack = maxStackSize ; \n} \n} \n"}
{"1518": "public class HtmlStaplerBundlesManager { \npublic synchronized String registerBundle ( final String contextPath , final String actionPath , final String tempBundleId , final String bundleContentType , final List < String > sources ) { \nif ( tempBundleId == null || sources . isEmpty ( ) ) { \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , StringPool . EMPTY ) ; \n} \nreturn null ; \n} \nString [ ] sourcesArray = sources . toArray ( new String [ 0 ] ) ; \nfor ( int i = 0 , sourcesArrayLength = sourcesArray . length ; \nsourcesArrayLength > i ; \ni ++ ) { \nsourcesArray [ i ] = sourcesArray [ i ] . trim ( ) . toLowerCase ( ) ; \n} \nif ( sortResources ) { \nArrays . sort ( sourcesArray ) ; \n} \nStringBand sb = new StringBand ( sourcesArray . length ) ; \nfor ( String src : sourcesArray ) { \nsb . append ( src ) ; \n} \nString sourcesString = sb . toString ( ) ; \nString bundleId = createDigest ( sourcesString ) ; \nbundleId += '.' + bundleContentType ; \nif ( strategy == Strategy . ACTION_MANAGED ) { \nactionBundles . put ( actionPath , bundleId ) ; \nmirrors . put ( tempBundleId , bundleId ) ; \n} \ntry { \ncreateBundle ( contextPath , actionPath , bundleId , sources ) ; \n} \ncatch ( IOException ioex ) { \nthrow new HtmlStaplerException ( \"Can't create bundle\" , ioex ) ; \n} \nreturn bundleId ; \n} \n} \n"}
{"1545": "public class AnnotationTxAdviceManager { \n@ SuppressWarnings ( { \n\"unchecked\" } \n) public void registerAnnotations ( final Class < ? extends Annotation > [ ] annotations ) { \nthis . annotations = annotations ; \nthis . annotationParsers = new AnnotationParser [ annotations . length ] ; \nfor ( int i = 0 ; \nannotations . length > i ; \ni ++ ) { \nannotationParsers [ i ] = TransactionAnnotationValues . parserFor ( annotations [ i ] ) ; \n} \n} \n} \n"}
{"1547": "public class CssSelector { \n@ Override public boolean accept ( final Node node ) { \nif ( ! matchElement ( node ) ) { \nreturn false ; \n} \nint totalSelectors = selectorsCount ( ) ; \nfor ( int i = 0 ; \ntotalSelectors > i ; \ni ++ ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase ATTRIBUTE : if ( ! ( ( AttributeSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( node ) ) { \nreturn false ; \n} \nbreak ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1549": "public class CssSelector { \npublic boolean accept ( final List < Node > currentResults , final Node node , final int index ) { \nint totalSelectors = selectorsCount ( ) ; \nfor ( int i = 0 ; \ntotalSelectors > i ; \ni ++ ) { \nSelector selector = getSelector ( i ) ; \nswitch ( selector . getType ( ) ) { \ncase PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( currentResults , node , index ) ) { \nreturn false ; \n} \nbreak ; \ncase PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( currentResults , node , index ) ) { \nreturn false ; \n} \nbreak ; \ndefault : } \n} \nreturn true ; \n} \n} \n"}
{"1552": "public class Node { \nprotected < T extends Node > T cloneTo ( final T dest ) { \ndest . parentNode = parentNode ; \nif ( attributes != null ) { \ndest . attributes = new ArrayList < > ( attributes . size ( ) ) ; \nfor ( int i = 0 , attributesSize = attributes . size ( ) ; \nattributesSize > i ; \ni ++ ) { \nAttribute attr = attributes . get ( i ) ; \ndest . attributes . add ( attr . clone ( ) ) ; \n} \n} \nif ( childNodes != null ) { \ndest . childNodes = new ArrayList < > ( childNodes . size ( ) ) ; \nfor ( int i = 0 , childNodesSize = childNodes . size ( ) ; \nchildNodesSize > i ; \ni ++ ) { \nNode child = childNodes . get ( i ) ; \nNode childClone = child . clone ( ) ; \nchildClone . parentNode = dest ; \ndest . childNodes . add ( childClone ) ; \n} \n} \nreturn dest ; \n} \n} \n"}
{"1560": "public class Node { \npublic void removeAllChilds ( ) { \nList < Node > removedNodes = childNodes ; \nchildNodes = null ; \nchildElementNodes = null ; \nchildElementNodesCount = 0 ; \nif ( removedNodes != null ) { \nfor ( int i = 0 , removedNodesSize = removedNodes . size ( ) ; \nremovedNodesSize > i ; \ni ++ ) { \nNode removedNode = removedNodes . get ( i ) ; \nremovedNode . detachFromParent ( ) ; \n} \n} \n} \n} \n"}
{"1563": "public class Node { \npublic boolean check ( ) { \nif ( childNodes == null ) { \nreturn true ; \n} \nint siblingElementIndex = 0 ; \nfor ( int i = 0 , childNodesSize = childNodes . size ( ) ; \nchildNodesSize > i ; \ni ++ ) { \nNode childNode = childNodes . get ( i ) ; \nif ( childNode . siblingIndex != i ) { \nreturn false ; \n} \nif ( childNode . getNodeType ( ) == NodeType . ELEMENT ) { \nif ( childNode . siblingElementIndex != siblingElementIndex ) { \nreturn false ; \n} \nsiblingElementIndex ++ ; \n} \n} \nif ( childElementNodesCount != siblingElementIndex ) { \nreturn false ; \n} \nif ( childElementNodes != null ) { \nif ( childElementNodes . length != childElementNodesCount ) { \nreturn false ; \n} \nint childCount = getChildNodesCount ( ) ; \nfor ( int i = 0 ; \nchildCount > i ; \ni ++ ) { \nNode child = getChild ( i ) ; \nif ( 0 <= child . siblingElementIndex ) { \nif ( childElementNodes [ child . siblingElementIndex ] != child ) { \nreturn false ; \n} \n} \n} \n} \nif ( siblingNameIndex != - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \nfor ( int i = 0 , siblingsSize = siblings . size ( ) ; \nsiblingsSize > i ; \ni ++ ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nif ( sibling . siblingNameIndex != index ++ ) { \nreturn false ; \n} \n} \n} \n} \nfor ( Node childNode : childNodes ) { \nif ( ! childNode . check ( ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1564": "public class Node { \nprotected void initChildElementNodes ( ) { \nif ( childElementNodes == null ) { \nchildElementNodes = new Element [ childElementNodesCount ] ; \nint childCount = getChildNodesCount ( ) ; \nfor ( int i = 0 ; \nchildCount > i ; \ni ++ ) { \nNode child = getChild ( i ) ; \nif ( 0 <= child . siblingElementIndex ) { \nchildElementNodes [ child . siblingElementIndex ] = ( Element ) child ; \n} \n} \n} \n} \n} \n"}
{"1565": "public class Node { \nprotected void initSiblingNames ( ) { \nif ( siblingNameIndex == - 1 ) { \nList < Node > siblings = parentNode . childNodes ; \nint index = 0 ; \nfor ( int i = 0 , siblingsSize = siblings . size ( ) ; \nsiblingsSize > i ; \ni ++ ) { \nNode sibling = siblings . get ( i ) ; \nif ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nsibling . siblingNameIndex = index ++ ; \n} \n} \n} \n} \n} \n"}
{"1567": "public class Node { \nprotected void changeOwnerDocument ( final Node node , final Document ownerDocument ) { \nnode . ownerDocument = ownerDocument ; \nint childCount = node . getChildNodesCount ( ) ; \nfor ( int i = 0 ; \nchildCount > i ; \ni ++ ) { \nNode child = node . getChild ( i ) ; \nchangeOwnerDocument ( child , ownerDocument ) ; \n} \n} \n} \n"}
{"1568": "public class Node { \npublic Node getPreviousSiblingName ( ) { \nif ( nodeName == null ) { \nreturn null ; \n} \ninitSiblingNames ( ) ; \nint index = siblingNameIndex - 1 ; \nfor ( int i = siblingIndex ; \n0 <= i ; \ni -- ) { \nNode sibling = parentNode . childNodes . get ( i ) ; \nif ( ( index == sibling . siblingNameIndex ) && nodeName . equals ( sibling . getNodeName ( ) ) ) { \nreturn sibling ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1572": "public class Node { \nprotected void visitChildren ( final NodeVisitor nodeVisitor ) { \nif ( childNodes != null ) { \nfor ( int i = 0 , childNodesSize = childNodes . size ( ) ; \nchildNodesSize > i ; \ni ++ ) { \nNode childNode = childNodes . get ( i ) ; \nchildNode . visit ( nodeVisitor ) ; \n} \n} \n} \n} \n"}
{"1578": "public class RootPackages { \npublic void addRootPackage ( final String rootPackage , String mapping ) { \nif ( packages == null ) { \npackages = new String [ 0 ] ; \n} \nif ( mappings == null ) { \nmappings = new String [ 0 ] ; \n} \nif ( 0 < mapping . length ( ) ) { \nif ( ! mapping . startsWith ( StringPool . SLASH ) ) { \nmapping = StringPool . SLASH + mapping ; \n} \nif ( mapping . endsWith ( StringPool . SLASH ) ) { \nmapping = StringUtil . substring ( mapping , 0 , - 1 ) ; \n} \n} \nfor ( int i = 0 ; \npackages . length > i ; \ni ++ ) { \nif ( packages [ i ] . equals ( rootPackage ) ) { \nif ( mappings [ i ] . equals ( mapping ) ) { \nreturn ; \n} \nthrow new MadvocException ( \"Different mappings for the same root package: \" + rootPackage ) ; \n} \n} \npackages = ArraysUtil . append ( packages , rootPackage ) ; \nmappings = ArraysUtil . append ( mappings , mapping ) ; \n} \n} \n"}
{"1580": "public class RootPackages { \npublic String findRootPackageForActionPath ( final String actionPath ) { \nif ( mappings == null ) { \nreturn null ; \n} \nint ndx = - 1 ; \nint delta = Integer . MAX_VALUE ; \nfor ( int i = 0 ; \nmappings . length > i ; \ni ++ ) { \nString mapping = mappings [ i ] ; \nboolean found = false ; \nif ( actionPath . equals ( mapping ) ) { \nfound = true ; \n} \nelse { \nmapping += StringPool . SLASH ; \nif ( actionPath . startsWith ( mapping ) ) { \nfound = true ; \n} \n} \nif ( found ) { \nint distance = actionPath . length ( ) - mapping . length ( ) ; \nif ( delta > distance ) { \nndx = i ; \ndelta = distance ; \n} \n} \n} \nif ( ndx == - 1 ) { \nreturn null ; \n} \nreturn packages [ ndx ] ; \n} \n} \n"}
{"1582": "public class BeanReferences { \npublic BeanReferences removeDuplicateNames ( ) { \nif ( 2 > names . length ) { \nreturn this ; \n} \nint nullCount = 0 ; \nfor ( int i = 1 ; \nnames . length > i ; \ni ++ ) { \nString thisRef = names [ i ] ; \nif ( thisRef == null ) { \nnullCount ++ ; \ncontinue ; \n} \nfor ( int j = 0 ; \ni > j ; \nj ++ ) { \nif ( names [ j ] == null ) { \ncontinue ; \n} \nif ( thisRef . equals ( names [ j ] ) ) { \nnames [ i ] = null ; \nbreak ; \n} \n} \n} \nif ( nullCount == 0 ) { \nreturn this ; \n} \nString [ ] newRefs = new String [ names . length - nullCount ] ; \nint ndx = 0 ; \nfor ( String name : names ) { \nif ( name == null ) { \ncontinue ; \n} \nnewRefs [ ndx ] = name ; \nndx ++ ; \n} \nreturn new BeanReferences ( newRefs ) ; \n} \n} \n"}
{"1587": "public class Targets { \npublic Object [ ] extractParametersValues ( ) { \nfinal Object [ ] values = new Object [ targets . length - 1 ] ; \nfor ( int i = 1 ; \ntargets . length > i ; \ni ++ ) { \nvalues [ i - 1 ] = targets [ i ] . value ( ) ; \n} \nreturn values ; \n} \n} \n"}
{"1588": "public class Targets { \nprotected Target [ ] makeTargets ( final Target actionTarget , final MethodParam [ ] methodParams ) { \nif ( methodParams == null ) { \nreturn new Target [ ] { \nactionTarget } \n; \n} \nfinal Target [ ] target = new Target [ methodParams . length + 1 ] ; \ntarget [ 0 ] = actionTarget ; \nfinal Object action = actionTarget . value ( ) ; \nfor ( int i = 0 ; \nmethodParams . length > i ; \ni ++ ) { \nfinal MethodParam methodParam = methodParams [ i ] ; \nfinal Class paramType = methodParam . type ( ) ; \nfinal Target paramTarget ; \nif ( methodParam . annotationType ( ) == null ) { \nfinal ScopeData newScopeData = methodParam . scopeData ( ) . inspector ( ) . inspectClassScopesWithCache ( paramType ) ; \nparamTarget = Target . ofValue ( createActionMethodArgument ( paramType , action ) , newScopeData ) ; \n} \nelse if ( methodParam . annotationType ( ) == Out . class ) { \nparamTarget = Target . ofMethodParam ( methodParam , createActionMethodArgument ( paramType , action ) ) ; \n} \nelse { \nparamTarget = Target . ofMethodParam ( methodParam , type -> createActionMethodArgument ( type , action ) ) ; \n} \ntarget [ i + 1 ] = paramTarget ; \n} \nreturn target ; \n} \n} \n"}
{"1597": "public class FormProcessorVisitor { \nprotected String valueToString ( final String name , final Object valueObject ) { \nif ( ! valueObject . getClass ( ) . isArray ( ) ) { \nreturn valueObject . toString ( ) ; \n} \nString [ ] array = ( String [ ] ) valueObject ; \nif ( valueNameIndexes == null ) { \nvalueNameIndexes = new HashMap < > ( ) ; \n} \nMutableInteger index = valueNameIndexes . get ( name ) ; \nif ( index == null ) { \nindex = new MutableInteger ( 0 ) ; \nvalueNameIndexes . put ( name , index ) ; \n} \nif ( array . length <= index . value ) { \nreturn null ; \n} \nString result = array [ index . value ] ; \nindex . value ++ ; \nreturn result ; \n} \n} \n"}
{"1601": "public class Socks4ProxySocketFactory { \nprivate Socket createSocks4ProxySocket ( final String host , final int port ) { \nSocket socket = null ; \nfinal String proxyHost = proxy . getProxyAddress ( ) ; \nfinal int proxyPort = proxy . getProxyPort ( ) ; \nfinal String user = proxy . getProxyUsername ( ) ; \ntry { \nsocket = Sockets . connect ( proxyHost , proxyPort , connectionTimeout ) ; \nfinal InputStream in = socket . getInputStream ( ) ; \nfinal OutputStream out = socket . getOutputStream ( ) ; \nsocket . setTcpNoDelay ( true ) ; \nbyte [ ] buf = new byte [ 1024 ] ; \nint index = 0 ; \nbuf [ index ++ ] = 4 ; \nbuf [ index ++ ] = 1 ; \nbuf [ index ++ ] = ( byte ) ( port >>> 8 ) ; \nbuf [ index ++ ] = ( byte ) ( port & 0xff ) ; \nInetAddress addr = InetAddress . getByName ( host ) ; \nbyte [ ] byteAddress = addr . getAddress ( ) ; \nfor ( byte byteAddres : byteAddress ) { \nbuf [ index ++ ] = byteAddres ; \n} \nif ( user != null ) { \nSystem . arraycopy ( user . getBytes ( ) , 0 , buf , index , user . length ( ) ) ; \nindex += user . length ( ) ; \n} \nbuf [ index ++ ] = 0 ; \nout . write ( buf , 0 , index ) ; \nint len = 6 ; \nint s = 0 ; \nwhile ( len > s ) { \nint i = in . read ( buf , s , len - s ) ; \nif ( 0 >= i ) { \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"stream is closed\" ) ; \n} \ns += i ; \n} \nif ( buf [ 0 ] != 0 ) { \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned VN \" + buf [ 0 ] ) ; \n} \nif ( buf [ 1 ] != 90 ) { \ntry { \nsocket . close ( ) ; \n} \ncatch ( Exception ignore ) { \n} \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned CD \" + buf [ 1 ] ) ; \n} \nbyte [ ] temp = new byte [ 2 ] ; \nin . read ( temp , 0 , 2 ) ; \nreturn socket ; \n} \ncatch ( RuntimeException rtex ) { \ncloseSocket ( socket ) ; \nthrow rtex ; \n} \ncatch ( Exception ex ) { \ncloseSocket ( socket ) ; \nthrow new HttpException ( ProxyInfo . ProxyType . SOCKS4 , ex . toString ( ) , ex ) ; \n} \n} \n} \n"}
{"1604": "public class CharSequenceUtil { \npublic static boolean equalsOne ( final char c , final CharSequence match ) { \nfor ( int i = 0 ; \nmatch . length ( ) > i ; \ni ++ ) { \nchar aMatch = match . charAt ( i ) ; \nif ( c == aMatch ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"1605": "public class CharSequenceUtil { \npublic static int findFirstEqual ( final CharSequence source , final int index , final CharSequence match ) { \nfor ( int i = index ; \nsource . length ( ) > i ; \ni ++ ) { \nif ( equalsOne ( source . charAt ( i ) , match ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1606": "public class CharSequenceUtil { \npublic static int findFirstEqual ( final char [ ] source , final int index , final char match ) { \nfor ( int i = index ; \nsource . length > i ; \ni ++ ) { \nif ( source [ i ] == match ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1607": "public class CommandLine { \npublic CommandLine args ( final String ... arguments ) { \nif ( arguments != null && 0 < arguments . length ) { \nCollections . addAll ( cmdLine , arguments ) ; \n} \nreturn this ; \n} \n} \n"}
{"1614": "public class Frame { \nfinal void setInputFrameFromApiFormat ( final SymbolTable symbolTable , final int numLocal , final Object [ ] local , final int numStack , final Object [ ] stack ) { \nint inputLocalIndex = 0 ; \nfor ( int i = 0 ; \nnumLocal > i ; \n++ i ) { \ninputLocals [ inputLocalIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , local [ i ] ) ; \nif ( local [ i ] == Opcodes . LONG || local [ i ] == Opcodes . DOUBLE ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \n} \nwhile ( inputLocals . length > inputLocalIndex ) { \ninputLocals [ inputLocalIndex ++ ] = TOP ; \n} \nint numStackTop = 0 ; \nfor ( int i = 0 ; \nnumStack > i ; \n++ i ) { \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \n++ numStackTop ; \n} \n} \ninputStack = new int [ numStack + numStackTop ] ; \nint inputStackIndex = 0 ; \nfor ( int i = 0 ; \nnumStack > i ; \n++ i ) { \ninputStack [ inputStackIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , stack [ i ] ) ; \nif ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { \ninputStack [ inputStackIndex ++ ] = TOP ; \n} \n} \noutputStackTop = 0 ; \ninitializationCount = 0 ; \n} \n} \n"}
{"1615": "public class Frame { \nprivate int getLocal ( final int localIndex ) { \nif ( outputLocals == null || outputLocals . length <= localIndex ) { \nreturn LOCAL_KIND | localIndex ; \n} \nelse { \nint abstractType = outputLocals [ localIndex ] ; \nif ( abstractType == 0 ) { \nabstractType = outputLocals [ localIndex ] = LOCAL_KIND | localIndex ; \n} \nreturn abstractType ; \n} \n} \n} \n"}
{"1616": "public class Frame { \nprivate void setLocal ( final int localIndex , final int abstractType ) { \nif ( outputLocals == null ) { \noutputLocals = new int [ 10 ] ; \n} \nint outputLocalsLength = outputLocals . length ; \nif ( outputLocalsLength <= localIndex ) { \nint [ ] newOutputLocals = new int [ Math . max ( localIndex + 1 , 2 * outputLocalsLength ) ] ; \nSystem . arraycopy ( outputLocals , 0 , newOutputLocals , 0 , outputLocalsLength ) ; \noutputLocals = newOutputLocals ; \n} \noutputLocals [ localIndex ] = abstractType ; \n} \n} \n"}
{"1617": "public class Frame { \nprivate void push ( final int abstractType ) { \nif ( outputStack == null ) { \noutputStack = new int [ 10 ] ; \n} \nint outputStackLength = outputStack . length ; \nif ( outputStackLength <= outputStackTop ) { \nint [ ] newOutputStack = new int [ Math . max ( outputStackTop + 1 , 2 * outputStackLength ) ] ; \nSystem . arraycopy ( outputStack , 0 , newOutputStack , 0 , outputStackLength ) ; \noutputStack = newOutputStack ; \n} \noutputStack [ outputStackTop ++ ] = abstractType ; \nshort outputStackSize = ( short ) ( outputStackStart + outputStackTop ) ; \nif ( owner . outputStackMax < outputStackSize ) { \nowner . outputStackMax = outputStackSize ; \n} \n} \n} \n"}
{"1619": "public class Frame { \nprivate void pop ( final int elements ) { \nif ( elements <= outputStackTop ) { \noutputStackTop -= elements ; \n} \nelse { \noutputStackStart -= elements - outputStackTop ; \noutputStackTop = 0 ; \n} \n} \n} \n"}
{"1621": "public class Frame { \nprivate void addInitializedType ( final int abstractType ) { \nif ( initializations == null ) { \ninitializations = new int [ 2 ] ; \n} \nint initializationsLength = initializations . length ; \nif ( initializationsLength <= initializationCount ) { \nint [ ] newInitializations = new int [ Math . max ( initializationCount + 1 , 2 * initializationsLength ) ] ; \nSystem . arraycopy ( initializations , 0 , newInitializations , 0 , initializationsLength ) ; \ninitializations = newInitializations ; \n} \ninitializations [ initializationCount ++ ] = abstractType ; \n} \n} \n"}
{"1622": "public class Frame { \nprivate int getInitializedType ( final SymbolTable symbolTable , final int abstractType ) { \nif ( abstractType == UNINITIALIZED_THIS || ( abstractType & ( DIM_MASK | KIND_MASK ) ) == UNINITIALIZED_KIND ) { \nfor ( int i = 0 ; \ninitializationCount > i ; \n++ i ) { \nint initializedType = initializations [ i ] ; \nint dim = initializedType & DIM_MASK ; \nint kind = initializedType & KIND_MASK ; \nint value = initializedType & VALUE_MASK ; \nif ( kind == LOCAL_KIND ) { \ninitializedType = dim + inputLocals [ value ] ; \n} \nelse if ( kind == STACK_KIND ) { \ninitializedType = dim + inputStack [ inputStack . length - value ] ; \n} \nif ( abstractType == initializedType ) { \nif ( abstractType == UNINITIALIZED_THIS ) { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; \n} \nelse { \nreturn REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; \n} \n} \n} \n} \nreturn abstractType ; \n} \n} \n"}
{"1623": "public class Frame { \nstatic void putAbstractType ( final SymbolTable symbolTable , final int abstractType , final ByteVector output ) { \nint arrayDimensions = ( abstractType & Frame . DIM_MASK ) >> DIM_SHIFT ; \nif ( arrayDimensions == 0 ) { \nint typeValue = abstractType & VALUE_MASK ; \nswitch ( abstractType & KIND_MASK ) { \ncase CONSTANT_KIND : output . putByte ( typeValue ) ; \nbreak ; \ncase REFERENCE_KIND : output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( symbolTable . getType ( typeValue ) . value ) . index ) ; \nbreak ; \ncase UNINITIALIZED_KIND : output . putByte ( ITEM_UNINITIALIZED ) . putShort ( ( int ) symbolTable . getType ( typeValue ) . data ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \nelse { \nStringBuilder typeDescriptor = new StringBuilder ( ) ; \nwhile ( 0 < arrayDimensions -- ) { \ntypeDescriptor . append ( '[' ) ; \n} \nif ( ( abstractType & KIND_MASK ) == REFERENCE_KIND ) { \ntypeDescriptor . append ( 'L' ) . append ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) . append ( ';' ) ; \n} \nelse { \nswitch ( abstractType & VALUE_MASK ) { \ncase Frame . ITEM_ASM_BOOLEAN : typeDescriptor . append ( 'Z' ) ; \nbreak ; \ncase Frame . ITEM_ASM_BYTE : typeDescriptor . append ( 'B' ) ; \nbreak ; \ncase Frame . ITEM_ASM_CHAR : typeDescriptor . append ( 'C' ) ; \nbreak ; \ncase Frame . ITEM_ASM_SHORT : typeDescriptor . append ( 'S' ) ; \nbreak ; \ncase Frame . ITEM_INTEGER : typeDescriptor . append ( 'I' ) ; \nbreak ; \ncase Frame . ITEM_FLOAT : typeDescriptor . append ( 'F' ) ; \nbreak ; \ncase Frame . ITEM_LONG : typeDescriptor . append ( 'J' ) ; \nbreak ; \ncase Frame . ITEM_DOUBLE : typeDescriptor . append ( 'D' ) ; \nbreak ; \ndefault : throw new AssertionError ( ) ; \n} \n} \noutput . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( typeDescriptor . toString ( ) ) . index ) ; \n} \n} \n} \n"}
{"1626": "public class ClassVisitor { \npublic ModuleVisitor visitModule ( final String name , final int access , final String version ) { \nif ( Opcodes . ASM6 > api ) { \nthrow new UnsupportedOperationException ( \"This feature requires ASM6\" ) ; \n} \nif ( cv != null ) { \nreturn cv . visitModule ( name , access , version ) ; \n} \nreturn null ; \n} \n} \n"}
{"1627": "public class ClassVisitor { \npublic void visitNestHost ( final String nestHost ) { \nif ( Opcodes . ASM7 > api ) { \nthrow new UnsupportedOperationException ( \"This feature requires ASM7\" ) ; \n} \nif ( cv != null ) { \ncv . visitNestHost ( nestHost ) ; \n} \n} \n} \n"}
{"1630": "public class ClassVisitor { \npublic void visitNestMember ( final String nestMember ) { \nif ( Opcodes . ASM7 > api ) { \nthrow new UnsupportedOperationException ( \"This feature requires ASM7\" ) ; \n} \nif ( cv != null ) { \ncv . visitNestMember ( nestMember ) ; \n} \n} \n} \n"}
{"1635": "public class ActionRequest { \nprotected ActionWrapper [ ] createExecutionArray ( ) { \nint totalInterceptors = ( this . actionRuntime . getInterceptors ( ) != null ? this . actionRuntime . getInterceptors ( ) . length : 0 ) ; \nint totalFilters = ( this . actionRuntime . getFilters ( ) != null ? this . actionRuntime . getFilters ( ) . length : 0 ) ; \nActionWrapper [ ] executionArray = new ActionWrapper [ totalFilters + 1 + totalInterceptors + 1 ] ; \nint index = 0 ; \nif ( 0 < totalFilters ) { \nSystem . arraycopy ( actionRuntime . getFilters ( ) , 0 , executionArray , index , totalFilters ) ; \nindex += totalFilters ; \n} \nexecutionArray [ index ++ ] = actionRequest -> { \nObject actionResult = actionRequest . invoke ( ) ; \nActionRequest . this . madvocController . render ( ActionRequest . this , actionResult ) ; \nreturn actionResult ; \n} \n; \nif ( 0 < totalInterceptors ) { \nSystem . arraycopy ( actionRuntime . getInterceptors ( ) , 0 , executionArray , index , totalInterceptors ) ; \nindex += totalInterceptors ; \n} \nexecutionArray [ index ] = actionRequest -> { \nactionResult = invokeActionMethod ( ) ; \nreturn actionResult ; \n} \n; \nreturn executionArray ; \n} \n} \n"}
{"1638": "public class PageData { \npublic static int calcFirstItemIndexOfPage ( int page , final int pageSize , final int total ) { \nif ( total == 0 ) { \nreturn 0 ; \n} \nif ( 1 > page ) { \npage = 1 ; \n} \nint first = ( page - 1 ) * pageSize ; \nif ( total <= first ) { \nfirst = ( ( total - 1 ) / pageSize ) * pageSize ; \n} \nreturn first ; \n} \n} \n"}
{"1640": "public class PseudoFunctionExpression { \npublic boolean match ( final int value ) { \nif ( a == 0 ) { \nreturn value == b ; \n} \nif ( 0 < a ) { \nif ( b > value ) { \nreturn false ; \n} \nreturn ( value - b ) % a == 0 ; \n} \nif ( b < value ) { \nreturn false ; \n} \nreturn ( b - value ) % ( - a ) == 0 ; \n} \n} \n"}
{"1641": "public class CharUtil { \npublic static byte [ ] toRawByteArray ( final char [ ] carr ) { \nbyte [ ] barr = new byte [ carr . length << 1 ] ; \nfor ( int i = 0 , bpos = 0 ; \ncarr . length > i ; \ni ++ ) { \nchar c = carr [ i ] ; \nbarr [ bpos ++ ] = ( byte ) ( ( c & 0xFF00 ) >> 8 ) ; \nbarr [ bpos ++ ] = ( byte ) ( c & 0x00FF ) ; \n} \nreturn barr ; \n} \n} \n"}
{"1642": "public class CharUtil { \npublic static int findFirstDiff ( final char [ ] source , final int index , final char [ ] match ) { \nfor ( int i = index ; \nsource . length > i ; \ni ++ ) { \nif ( ! equalsOne ( source [ i ] , match ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"1676": "public class RestActionNamingStrategy { \nprotected String resolveHttpMethodFromMethodName ( final String methodName ) { \nint i = 0 ; \nwhile ( methodName . length ( ) > i ) { \nif ( CharUtil . isUppercaseAlpha ( methodName . charAt ( i ) ) ) { \nbreak ; \n} \ni ++ ; \n} \nfinal String name = methodName . substring ( 0 , i ) . toUpperCase ( ) ; \nfor ( final HttpMethod httpMethod : HttpMethod . values ( ) ) { \nif ( httpMethod . equalsName ( name ) ) { \nreturn httpMethod . name ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1677": "public class Wildcard { \nprivate static boolean match ( final CharSequence string , final CharSequence pattern , int sNdx , int pNdx ) { \nint pLen = pattern . length ( ) ; \nif ( pLen == 1 ) { \nif ( pattern . charAt ( 0 ) == '*' ) { \nreturn true ; \n} \n} \nint sLen = string . length ( ) ; \nboolean nextIsNotWildcard = false ; \nwhile ( true ) { \nif ( ( sLen <= sNdx ) ) { \nwhile ( ( pLen > pNdx ) && ( pattern . charAt ( pNdx ) == '*' ) ) { \npNdx ++ ; \n} \nreturn pLen <= pNdx ; \n} \nif ( pLen <= pNdx ) { \nreturn false ; \n} \nchar p = pattern . charAt ( pNdx ) ; \nif ( ! nextIsNotWildcard ) { \nif ( p == '\\\\' ) { \npNdx ++ ; \nnextIsNotWildcard = true ; \ncontinue ; \n} \nif ( p == '?' ) { \nsNdx ++ ; \npNdx ++ ; \ncontinue ; \n} \nif ( p == '*' ) { \nchar pNext = 0 ; \nif ( pLen > pNdx + 1 ) { \npNext = pattern . charAt ( pNdx + 1 ) ; \n} \nif ( pNext == '*' ) { \npNdx ++ ; \ncontinue ; \n} \nint i ; \npNdx ++ ; \nfor ( i = string . length ( ) ; \nsNdx <= i ; \ni -- ) { \nif ( match ( string , pattern , i , pNdx ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \nelse { \nnextIsNotWildcard = false ; \n} \nif ( p != string . charAt ( sNdx ) ) { \nreturn false ; \n} \nsNdx ++ ; \npNdx ++ ; \n} \n} \n} \n"}
{"1696": "public class SocketHttpConnectionProvider { \nprotected Socket createSocket ( final String host , final int port , final int connectionTimeout ) throws IOException { \nfinal SocketFactory socketFactory = getSocketFactory ( proxy , false , false , connectionTimeout ) ; \nif ( 0 > connectionTimeout ) { \nreturn socketFactory . createSocket ( host , port ) ; \n} \nelse { \nSocket socket = socketFactory . createSocket ( ) ; \nsocket . connect ( new InetSocketAddress ( host , port ) , connectionTimeout ) ; \nreturn socket ; \n} \n} \n} \n"}
{"1697": "public class SocketHttpConnectionProvider { \nprotected SSLSocket createSSLSocket ( final String host , final int port , final int connectionTimeout , final boolean trustAll , final boolean verifyHttpsHost ) throws IOException { \nfinal SocketFactory socketFactory = getSocketFactory ( proxy , true , trustAll , connectionTimeout ) ; \nfinal Socket socket ; \nif ( 0 > connectionTimeout ) { \nsocket = socketFactory . createSocket ( host , port ) ; \n} \nelse { \nsocket = Sockets . connect ( host , port , connectionTimeout ) ; \n} \nSSLSocket sslSocket ; \nif ( socket instanceof SSLSocket ) { \nsslSocket = ( SSLSocket ) socket ; \n} \nelse { \nif ( socketFactory instanceof SSLSocketFactory ) { \nsslSocket = ( SSLSocket ) ( ( SSLSocketFactory ) socketFactory ) . createSocket ( socket , host , port , true ) ; \n} \nelse { \nsslSocket = ( SSLSocket ) ( getDefaultSSLSocketFactory ( trustAll ) ) . createSocket ( socket , host , port , true ) ; \n} \n} \nif ( secureEnabledProtocols != null ) { \nfinal String [ ] values = StringUtil . splitc ( secureEnabledProtocols , ',' ) ; \nStringUtil . trimAll ( values ) ; \nsslSocket . setEnabledProtocols ( values ) ; \n} \nif ( verifyHttpsHost ) { \nfinal SSLParameters sslParams = new SSLParameters ( ) ; \nsslParams . setEndpointIdentificationAlgorithm ( \"HTTPS\" ) ; \nsslSocket . setSSLParameters ( sslParams ) ; \n} \nreturn sslSocket ; \n} \n} \n"}
{"1700": "public class RandomString { \npublic String random ( int count , final char [ ] chars ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nfinal char [ ] result = new char [ count ] ; \nwhile ( 0 < count -- ) { \nresult [ count ] = chars [ rnd . nextInt ( chars . length ) ] ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1701": "public class RandomString { \npublic String random ( int count , final char start , final char end ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nfinal char [ ] result = new char [ count ] ; \nfinal int len = end - start + 1 ; \nwhile ( 0 < count -- ) { \nresult [ count ] = ( char ) ( rnd . nextInt ( len ) + start ) ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1702": "public class RandomString { \npublic String randomRanges ( int count , final char ... ranges ) { \nif ( count == 0 ) { \nreturn StringPool . EMPTY ; \n} \nint i = 0 ; \nint len = 0 ; \nfinal int [ ] lens = new int [ ranges . length ] ; \nwhile ( ranges . length > i ) { \nint gap = ranges [ i + 1 ] - ranges [ i ] + 1 ; \nlen += gap ; \nlens [ i ] = len ; \ni += 2 ; \n} \nfinal char [ ] result = new char [ count ] ; \nwhile ( 0 < count -- ) { \nchar c = 0 ; \nint r = rnd . nextInt ( len ) ; \nfor ( i = 0 ; \nranges . length > i ; \ni += 2 ) { \nif ( lens [ i ] > r ) { \nr += ranges [ i ] ; \nif ( i != 0 ) { \nr -= lens [ i - 2 ] ; \n} \nc = ( char ) r ; \nbreak ; \n} \n} \nresult [ count ] = c ; \n} \nreturn new String ( result ) ; \n} \n} \n"}
{"1711": "public class NetUtil { \npublic static int getIpAsInt ( final String ipAddress ) { \nint ipIntValue = 0 ; \nString [ ] tokens = StringUtil . splitc ( ipAddress , '.' ) ; \nfor ( String token : tokens ) { \nif ( 0 < ipIntValue ) { \nipIntValue <<= 8 ; \n} \nipIntValue += Integer . parseInt ( token ) ; \n} \nreturn ipIntValue ; \n} \n} \n"}
{"1712": "public class NetUtil { \npublic static boolean validateAgaintIPAdressV4Format ( final String input ) { \nif ( input == null ) { \nreturn false ; \n} \nint hitDots = 0 ; \nchar [ ] data = input . toCharArray ( ) ; \nfor ( int i = 0 ; \ndata . length > i ; \ni ++ ) { \nchar c = data [ i ] ; \nint b = 0 ; \ndo { \nif ( '0' > c || '9' < c ) { \nreturn false ; \n} \nb = ( b * 10 + c ) - 48 ; \nif ( data . length <= ++ i ) { \nbreak ; \n} \nc = data [ i ] ; \n} \nwhile ( c != '.' ) ; \nif ( 255 < b ) { \nreturn false ; \n} \nhitDots ++ ; \n} \nreturn hitDots == 4 ; \n} \n} \n"}
{"1720": "public class Sockets { \npublic static Socket connect ( final String hostname , final int port , final int connectionTimeout ) throws IOException { \nfinal Socket socket = new Socket ( ) ; \nif ( 0 >= connectionTimeout ) { \nsocket . connect ( new InetSocketAddress ( hostname , port ) ) ; \n} \nelse { \nsocket . connect ( new InetSocketAddress ( hostname , port ) , connectionTimeout ) ; \n} \nreturn socket ; \n} \n} \n"}
{"1722": "public class DefaultClassLoaderStrategy { \n@ Override public Class loadClass ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { \nString arrayClassName = prepareArrayClassnameForLoading ( className ) ; \nif ( ( className . indexOf ( '.' ) == - 1 ) && ( arrayClassName == null ) ) { \nint primitiveNdx = getPrimitiveClassNameIndex ( className ) ; \nif ( 0 <= primitiveNdx ) { \nreturn PRIMITIVE_TYPES [ primitiveNdx ] ; \n} \n} \nif ( classLoader != null ) { \nClass klass = loadClass ( className , arrayClassName , classLoader ) ; \nif ( klass != null ) { \nreturn klass ; \n} \n} \nClassLoader currentThreadClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nif ( ( currentThreadClassLoader != null ) && ( currentThreadClassLoader != classLoader ) ) { \nClass klass = loadClass ( className , arrayClassName , currentThreadClassLoader ) ; \nif ( klass != null ) { \nreturn klass ; \n} \n} \nClass callerClass = ClassUtil . getCallerClass ( ) ; \nClassLoader callerClassLoader = callerClass . getClassLoader ( ) ; \nif ( ( callerClassLoader != classLoader ) && ( callerClassLoader != currentThreadClassLoader ) ) { \nClass klass = loadClass ( className , arrayClassName , callerClassLoader ) ; \nif ( klass != null ) { \nreturn klass ; \n} \n} \nif ( arrayClassName != null ) { \ntry { \nreturn loadArrayClassByComponentType ( className , classLoader ) ; \n} \ncatch ( ClassNotFoundException ignore ) { \n} \n} \nthrow new ClassNotFoundException ( \"Class not found: \" + className ) ; \n} \n} \n"}
{"1736": "public class DbOomQuery { \npublic void populateGeneratedKeys ( final Object entity ) { \nfinal String [ ] generatedColumns = getGeneratedColumnNames ( ) ; \nif ( generatedColumns == null ) { \nreturn ; \n} \nDbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( entity . getClass ( ) ) ; \nClass [ ] keyTypes = new Class [ generatedColumns . length ] ; \nString [ ] properties = new String [ generatedColumns . length ] ; \nfor ( int i = 0 ; \ngeneratedColumns . length > i ; \ni ++ ) { \nString column = generatedColumns [ i ] ; \nDbEntityColumnDescriptor decd = ded . findByColumnName ( column ) ; \nif ( decd != null ) { \nkeyTypes [ i ] = decd . getPropertyType ( ) ; \nproperties [ i ] = decd . getPropertyName ( ) ; \n} \n} \nfinal Object keyValues = findGeneratedColumns ( keyTypes ) ; \nif ( ! keyValues . getClass ( ) . isArray ( ) ) { \nBeanUtil . declared . setProperty ( entity , properties [ 0 ] , keyValues ) ; \n} \nelse { \nfor ( int i = 0 ; \nproperties . length > i ; \ni ++ ) { \nBeanUtil . declared . setProperty ( entity , properties [ i ] , ( ( Object [ ] ) keyValues ) [ i ] ) ; \n} \n} \n} \n} \n"}
{"1751": "public class ActionMethodParamNameResolver { \npublic String [ ] resolveParamNames ( final Method actionClassMethod ) { \nMethodParameter [ ] methodParameters = Paramo . resolveParameters ( actionClassMethod ) ; \nString [ ] names = new String [ methodParameters . length ] ; \nfor ( int i = 0 ; \nmethodParameters . length > i ; \ni ++ ) { \nnames [ i ] = methodParameters [ i ] . getName ( ) ; \n} \nreturn names ; \n} \n} \n"}
{"1765": "public class EmailFilter { \npublic EmailFilter and ( final EmailFilter ... emailFilters ) { \nfinal SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; \nfor ( int i = 0 ; \nemailFilters . length > i ; \ni ++ ) { \nsearchTerms [ i ] = emailFilters [ i ] . searchTerm ; \n} \nconcat ( new AndTerm ( searchTerms ) ) ; \nreturn this ; \n} \n} \n"}
{"1766": "public class EmailFilter { \npublic EmailFilter or ( final EmailFilter ... emailFilters ) { \nfinal SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; \nfor ( int i = 0 ; \nemailFilters . length > i ; \ni ++ ) { \nsearchTerms [ i ] = emailFilters [ i ] . searchTerm ; \n} \nconcat ( new OrTerm ( searchTerms ) ) ; \nreturn this ; \n} \n} \n"}
{"1769": "public class Base32 { \npublic static String encode ( final byte [ ] bytes ) { \nStringBuilder base32 = new StringBuilder ( ( bytes . length * 8 + 4 ) / 5 ) ; \nint currByte , digit , i = 0 ; \nwhile ( bytes . length > i ) { \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ currByte >> 3 ] ) ; \ndigit = ( currByte & 7 ) << 2 ; \nif ( bytes . length <= i ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 6 ) ] ) ; \nbase32 . append ( CHARS [ ( currByte >> 1 ) & 31 ] ) ; \ndigit = ( currByte & 1 ) << 4 ; \nif ( bytes . length <= i ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 4 ) ] ) ; \ndigit = ( currByte & 15 ) << 1 ; \nif ( bytes . length <= i ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 7 ) ] ) ; \nbase32 . append ( CHARS [ ( currByte >> 2 ) & 31 ] ) ; \ndigit = ( currByte & 3 ) << 3 ; \nif ( bytes . length <= i ) { \nbase32 . append ( CHARS [ digit ] ) ; \nbreak ; \n} \ncurrByte = bytes [ i ++ ] & 255 ; \nbase32 . append ( CHARS [ digit | ( currByte >> 5 ) ] ) ; \nbase32 . append ( CHARS [ currByte & 31 ] ) ; \n} \nreturn base32 . toString ( ) ; \n} \n} \n"}
{"1770": "public class ByteArrayConverter { \nprotected byte [ ] convertValueToArray ( final Object value ) { \nif ( value instanceof Blob ) { \nfinal Blob blob = ( Blob ) value ; \ntry { \nfinal long length = blob . length ( ) ; \nif ( Integer . MAX_VALUE < length ) { \nthrow new TypeConversionException ( \"Blob is too big.\" ) ; \n} \nreturn blob . getBytes ( 1 , ( int ) length ) ; \n} \ncatch ( SQLException sex ) { \nthrow new TypeConversionException ( value , sex ) ; \n} \n} \nif ( value instanceof File ) { \ntry { \nreturn FileUtil . readBytes ( ( File ) value ) ; \n} \ncatch ( IOException ioex ) { \nthrow new TypeConversionException ( value , ioex ) ; \n} \n} \nif ( value instanceof Collection ) { \nfinal Collection collection = ( Collection ) value ; \nfinal byte [ ] target = new byte [ collection . size ( ) ] ; \nint i = 0 ; \nfor ( final Object element : collection ) { \ntarget [ i ] = convertType ( element ) ; \ni ++ ; \n} \nreturn target ; \n} \nif ( value instanceof Iterable ) { \nfinal Iterable iterable = ( Iterable ) value ; \nfinal ArrayList < Byte > byteArrayList = new ArrayList < > ( ) ; \nfor ( final Object element : iterable ) { \nfinal byte convertedValue = convertType ( element ) ; \nbyteArrayList . add ( Byte . valueOf ( convertedValue ) ) ; \n} \nfinal byte [ ] array = new byte [ byteArrayList . size ( ) ] ; \nfor ( int i = 0 ; \nbyteArrayList . size ( ) > i ; \ni ++ ) { \nfinal Byte b = byteArrayList . get ( i ) ; \narray [ i ] = b . byteValue ( ) ; \n} \nreturn array ; \n} \nif ( value instanceof CharSequence ) { \nfinal String [ ] strings = StringUtil . splitc ( value . toString ( ) , ArrayConverter . NUMBER_DELIMITERS ) ; \nreturn convertArrayToArray ( strings ) ; \n} \nreturn convertToSingleElementArray ( value ) ; \n} \n} \n"}
{"1771": "public class GzipFilter { \nprotected boolean isGzipEligible ( final HttpServletRequest request ) { \nif ( requestParameterName . length ( ) != 0 ) { \nString forceGzipString = request . getParameter ( requestParameterName ) ; \nif ( forceGzipString != null ) { \nreturn Converter . get ( ) . toBooleanValue ( forceGzipString , false ) ; \n} \n} \nString uri = request . getRequestURI ( ) ; \nif ( uri == null ) { \nreturn false ; \n} \nuri = uri . toLowerCase ( ) ; \nboolean result = false ; \nif ( matches == null ) { \nif ( extensions == null ) { \nreturn true ; \n} \nString extension = FileNameUtil . getExtension ( uri ) ; \nif ( 0 < extension . length ( ) ) { \nextension = extension . toLowerCase ( ) ; \nif ( StringUtil . equalsOne ( extension , extensions ) != - 1 ) { \nresult = true ; \n} \n} \n} \nelse { \nif ( wildcards ) { \nresult = Wildcard . matchPathOne ( uri , matches ) != - 1 ; \n} \nelse { \nfor ( String match : matches ) { \nif ( uri . contains ( match ) ) { \nresult = true ; \nbreak ; \n} \n} \n} \n} \nif ( ( result ) && ( excludes != null ) ) { \nif ( wildcards ) { \nif ( Wildcard . matchPathOne ( uri , excludes ) != - 1 ) { \nresult = false ; \n} \n} \nelse { \nfor ( String exclude : excludes ) { \nif ( uri . contains ( exclude ) ) { \nresult = false ; \nbreak ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"1773": "public class Vtor { \npublic List < Violation > validate ( final ValidationContext ctx , final Object target , final String targetName ) { \nfor ( Map . Entry < String , List < Check > > entry : ctx . map . entrySet ( ) ) { \nString name = entry . getKey ( ) ; \nObject value = BeanUtil . declaredSilent . getProperty ( target , name ) ; \nString valueName = targetName != null ? ( targetName + '.' + name ) : name ; \nValidationConstraintContext vcc = new ValidationConstraintContext ( this , target , valueName ) ; \nfor ( Check check : entry . getValue ( ) ) { \nString [ ] checkProfiles = check . getProfiles ( ) ; \nif ( ! matchProfiles ( checkProfiles ) ) { \ncontinue ; \n} \nif ( severity > check . getSeverity ( ) ) { \ncontinue ; \n} \nValidationConstraint constraint = check . getConstraint ( ) ; \nif ( ! constraint . isValid ( vcc , value ) ) { \naddViolation ( new Violation ( valueName , target , value , check ) ) ; \n} \n} \n} \nreturn getViolations ( ) ; \n} \n} \n"}
{"1778": "public class JulianDate { \npublic long toMilliseconds ( ) { \ndouble then = ( fraction - JD_1970 . fraction ) * MILLIS_IN_DAY ; \nthen += ( integer - JD_1970 . integer ) * MILLIS_IN_DAY ; \nthen += 0 < then ? 1.0e-6 : - 1.0e-6 ; \nreturn ( long ) then ; \n} \n} \n"}
{"1781": "public class JulianDate { \nprivate void set ( final int i , double f ) { \ninteger = i ; \nint fi = ( int ) f ; \nf -= fi ; \ninteger += fi ; \nif ( 0 > f ) { \nf += 1 ; \ninteger -- ; \n} \nthis . fraction = f ; \n} \n} \n"}
{"1783": "public class LagartoParser { \nprotected void emitComment ( final int from , final int to ) { \nif ( config . enableConditionalComments ) { \nif ( match ( CC_IF , from ) ) { \nint endBracketNdx = find ( ']' , from + 3 , to ) ; \nCharSequence expression = charSequence ( from + 1 , endBracketNdx ) ; \nndx = endBracketNdx + 1 ; \nchar c = input [ ndx ] ; \nif ( c != '>' ) { \nerrorInvalidToken ( ) ; \n} \nvisitor . condComment ( expression , true , true , false ) ; \nstate = DATA_STATE ; \nreturn ; \n} \nif ( CC_ENDIF2 . length < to && match ( CC_ENDIF2 , to - CC_ENDIF2 . length ) ) { \nvisitor . condComment ( _ENDIF , false , true , true ) ; \nstate = DATA_STATE ; \nreturn ; \n} \n} \nCharSequence comment = charSequence ( from , to ) ; \nvisitor . comment ( comment ) ; \ncommentStart = - 1 ; \n} \n} \n"}
{"1787": "public class PBKDF2Hash { \nprivate static byte [ ] fromHex ( final String hex ) { \nfinal byte [ ] binary = new byte [ hex . length ( ) / 2 ] ; \nfor ( int i = 0 ; \nbinary . length > i ; \ni ++ ) { \nbinary [ i ] = ( byte ) Integer . parseInt ( hex . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; \n} \nreturn binary ; \n} \n} \n"}
{"1793": "public class ModuleWriter { \nint computeAttributesSize ( ) { \nsymbolTable . addConstantUtf8 ( Constants . MODULE ) ; \nint size = 22 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; \nif ( 0 < packageCount ) { \nsymbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ; \nsize += 8 + packageIndex . length ; \n} \nif ( 0 < mainClassIndex ) { \nsymbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ; \nsize += 8 ; \n} \nreturn size ; \n} \n} \n"}
{"1794": "public class ModuleWriter { \nvoid putAttributes ( final ByteVector output ) { \nint moduleAttributeLength = 16 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE ) ) . putInt ( moduleAttributeLength ) . putShort ( moduleNameIndex ) . putShort ( moduleFlags ) . putShort ( moduleVersionIndex ) . putShort ( requiresCount ) . putByteArray ( requires . data , 0 , requires . length ) . putShort ( exportsCount ) . putByteArray ( exports . data , 0 , exports . length ) . putShort ( opensCount ) . putByteArray ( opens . data , 0 , opens . length ) . putShort ( usesCount ) . putByteArray ( usesIndex . data , 0 , usesIndex . length ) . putShort ( providesCount ) . putByteArray ( provides . data , 0 , provides . length ) ; \nif ( 0 < packageCount ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ) . putInt ( 2 + packageIndex . length ) . putShort ( packageCount ) . putByteArray ( packageIndex . data , 0 , packageIndex . length ) ; \n} \nif ( 0 < mainClassIndex ) { \noutput . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ) . putInt ( 2 ) . putShort ( mainClassIndex ) ; \n} \n} \n} \n"}
{"1802": "public class CsvUtil { \npublic static String toCsvString ( final Object ... elements ) { \nStringBuilder line = new StringBuilder ( ) ; \nint last = elements . length - 1 ; \nfor ( int i = 0 ; \nelements . length > i ; \ni ++ ) { \nif ( elements [ i ] == null ) { \nif ( i != last ) { \nline . append ( FIELD_SEPARATOR ) ; \n} \ncontinue ; \n} \nString field = elements [ i ] . toString ( ) ; \nint ndx = field . indexOf ( FIELD_SEPARATOR ) ; \nif ( ndx == - 1 ) { \nndx = field . indexOf ( FIELD_QUOTE ) ; \n} \nif ( ndx == - 1 ) { \nif ( field . startsWith ( StringPool . SPACE ) || field . endsWith ( StringPool . SPACE ) ) { \nndx = 1 ; \n} \n} \nif ( ndx == - 1 ) { \nndx = StringUtil . indexOfChars ( field , SPECIAL_CHARS ) ; \n} \nif ( ndx != - 1 ) { \nline . append ( FIELD_QUOTE ) ; \n} \nfield = StringUtil . replace ( field , StringPool . QUOTE , DOUBLE_QUOTE ) ; \nline . append ( field ) ; \nif ( ndx != - 1 ) { \nline . append ( FIELD_QUOTE ) ; \n} \nif ( i != last ) { \nline . append ( FIELD_SEPARATOR ) ; \n} \n} \nreturn line . toString ( ) ; \n} \n} \n"}
{"1803": "public class CsvUtil { \npublic static String [ ] toStringArray ( final String line ) { \nList < String > row = new ArrayList < > ( ) ; \nboolean inQuotedField = false ; \nint fieldStart = 0 ; \nfinal int len = line . length ( ) ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nchar c = line . charAt ( i ) ; \nif ( c == FIELD_SEPARATOR ) { \nif ( ! inQuotedField ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 1 ; \n} \n} \nelse if ( c == FIELD_QUOTE ) { \nif ( inQuotedField ) { \nif ( i + 1 == len || line . charAt ( i + 1 ) == FIELD_SEPARATOR ) { \naddField ( row , line , fieldStart , i , inQuotedField ) ; \nfieldStart = i + 2 ; \ni ++ ; \ninQuotedField = false ; \n} \n} \nelse if ( fieldStart == i ) { \ninQuotedField = true ; \nfieldStart ++ ; \n} \n} \n} \nif ( 0 < len && len >= fieldStart ) { \naddField ( row , line , fieldStart , len , inQuotedField ) ; \n} \nreturn row . toArray ( new String [ 0 ] ) ; \n} \n} \n"}
{"1810": "public class Cookie { \nprivate void setName ( final String name ) { \nif ( name . contains ( \";\" ) || name . contains ( \",\" ) || name . startsWith ( \"$\" ) ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \nfor ( int n = 0 ; \nname . length ( ) > n ; \nn ++ ) { \nchar c = name . charAt ( n ) ; \nif ( 0x20 >= c || 0x7f <= c ) { \nthrow new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; \n} \n} \nthis . name = name ; \n} \n} \n"}
{"1824": "public class ExclusivePublication { \npublic long offer ( final DirectBufferVector [ ] vectors , final ReservedValueSupplier reservedValueSupplier ) { \nfinal int length = DirectBufferVector . validateAndComputeLength ( vectors ) ; \nlong newPosition = CLOSED ; \nif ( ! isClosed ) { \nfinal long limit = positionLimit . getVolatile ( ) ; \nfinal ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; \nfinal long position = termBeginPosition + termOffset ; \nif ( limit > position ) { \nfinal int result ; \nif ( maxPayloadLength >= length ) { \nresult = termAppender . appendUnfragmentedMessage ( termId , termOffset , headerWriter , vectors , length , reservedValueSupplier ) ; \n} \nelse { \ncheckMaxMessageLength ( length ) ; \nresult = termAppender . appendFragmentedMessage ( termId , termOffset , headerWriter , vectors , length , maxPayloadLength , reservedValueSupplier ) ; \n} \nnewPosition = newPosition ( result ) ; \n} \nelse { \nnewPosition = backPressureStatus ( position , length ) ; \n} \n} \nreturn newPosition ; \n} \n} \n"}
{"1825": "public class ExclusivePublication { \npublic long appendPadding ( final int length ) { \ncheckMaxMessageLength ( length ) ; \nlong newPosition = CLOSED ; \nif ( ! isClosed ) { \nfinal long limit = positionLimit . getVolatile ( ) ; \nfinal ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; \nfinal long position = termBeginPosition + termOffset ; \nif ( limit > position ) { \ncheckPositiveLength ( length ) ; \nfinal int result = termAppender . appendPadding ( termId , termOffset , headerWriter , length ) ; \nnewPosition = newPosition ( result ) ; \n} \nelse { \nnewPosition = backPressureStatus ( position , length ) ; \n} \n} \nreturn newPosition ; \n} \n} \n"}
{"1833": "public class BufferBuilder { \npublic void limit ( final int limit ) { \nif ( 0 > limit || buffer . capacity ( ) <= limit ) { \nthrow new IllegalArgumentException ( \"limit outside range: capacity=\" + buffer . capacity ( ) + \" limit=\" + limit ) ; \n} \nthis . limit = limit ; \n} \n} \n"}
{"1837": "public class StreamStat { \npublic Map < StreamCompositeKey , List < StreamPosition > > snapshot ( ) { \nfinal Map < StreamCompositeKey , List < StreamPosition > > streams = new HashMap < > ( ) ; \ncounters . forEach ( ( counterId , typeId , keyBuffer , label ) -> { \nif ( ( PUBLISHER_LIMIT_TYPE_ID <= typeId && RECEIVER_POS_TYPE_ID >= typeId ) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID ) { \nfinal StreamCompositeKey key = new StreamCompositeKey ( keyBuffer . getInt ( SESSION_ID_OFFSET ) , keyBuffer . getInt ( STREAM_ID_OFFSET ) , keyBuffer . getStringAscii ( CHANNEL_OFFSET ) ) ; \nfinal StreamPosition position = new StreamPosition ( keyBuffer . getLong ( REGISTRATION_ID_OFFSET ) , counters . getCounterValue ( counterId ) , typeId ) ; \nstreams . computeIfAbsent ( key , ( ignore ) -> new ArrayList < > ( ) ) . add ( position ) ; \n} \n} \n) ; \nreturn streams ; \n} \n} \n"}
{"1839": "public class CounterMessageFlyweight { \npublic CounterMessageFlyweight keyBuffer ( final DirectBuffer keyBuffer , final int keyOffset , final int keyLength ) { \nbuffer . putInt ( KEY_LENGTH_OFFSET , keyLength ) ; \nif ( null != keyBuffer && 0 < keyLength ) { \nbuffer . putBytes ( keyBufferOffset ( ) , keyBuffer , keyOffset , keyLength ) ; \n} \nreturn this ; \n} \n} \n"}
{"1842": "public class ArchiveProxy { \npublic boolean tryConnect ( final String responseChannel , final int responseStreamId , final long correlationId ) { \nconnectRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . correlationId ( correlationId ) . responseStreamId ( responseStreamId ) . version ( AeronArchive . Configuration . SEMANTIC_VERSION ) . responseChannel ( responseChannel ) ; \nfinal int length = MessageHeaderEncoder . ENCODED_LENGTH + connectRequestEncoder . encodedLength ( ) ; \nreturn 0 < publication . offer ( buffer , 0 , length ) ; \n} \n} \n"}
{"1860": "public class ClusterControl { \npublic static AtomicCounter findControlToggle ( final CountersReader counters ) { \nfinal AtomicBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = counters . maxCounterId ( ) ; \nsize > i ; \ni ++ ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED && buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == CONTROL_TOGGLE_TYPE_ID ) { \nreturn new AtomicCounter ( counters . valuesBuffer ( ) , i , null ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1862": "public class ChannelUri { \npublic String channelTag ( ) { \nreturn ( null != tags && CHANNEL_TAG_INDEX < tags . length ) ? tags [ CHANNEL_TAG_INDEX ] : null ; \n} \n} \n"}
{"1863": "public class ChannelUri { \npublic String entityTag ( ) { \nreturn ( null != tags && ENTITY_TAG_INDEX < tags . length ) ? tags [ ENTITY_TAG_INDEX ] : null ; \n} \n} \n"}
{"1866": "public class ExclusiveTermAppender { \npublic int appendPadding ( final int termId , final int termOffset , final HeaderWriter header , final int length ) { \nfinal int frameLength = length + HEADER_LENGTH ; \nfinal int alignedLength = align ( frameLength , FRAME_ALIGNMENT ) ; \nfinal UnsafeBuffer termBuffer = this . termBuffer ; \nfinal int termLength = termBuffer . capacity ( ) ; \nint resultingOffset = termOffset + alignedLength ; \nputRawTailOrdered ( termId , resultingOffset ) ; \nif ( termLength < resultingOffset ) { \nresultingOffset = handleEndOfLogCondition ( termBuffer , termOffset , header , termLength , termId ) ; \n} \nelse { \nheader . write ( termBuffer , termOffset , frameLength , termId ) ; \nframeType ( termBuffer , termOffset , PADDING_FRAME_TYPE ) ; \nframeLengthOrdered ( termBuffer , termOffset , frameLength ) ; \n} \nreturn resultingOffset ; \n} \n} \n"}
{"1867": "public class NetworkPublication { \nfinal int updatePublisherLimit ( ) { \nint workCount = 0 ; \nfinal long senderPosition = this . senderPosition . getVolatile ( ) ; \nif ( hasReceivers || ( spiesSimulateConnection && 0 < spyPositions . length ) ) { \nlong minConsumerPosition = senderPosition ; \nfor ( final ReadablePosition spyPosition : spyPositions ) { \nminConsumerPosition = Math . min ( minConsumerPosition , spyPosition . getVolatile ( ) ) ; \n} \nfinal long proposedPublisherLimit = minConsumerPosition + termWindowLength ; \nif ( publisherLimit . proposeMaxOrdered ( proposedPublisherLimit ) ) { \ncleanBuffer ( proposedPublisherLimit ) ; \nworkCount = 1 ; \n} \n} \nelse if ( senderPosition < publisherLimit . get ( ) ) { \npublisherLimit . setOrdered ( senderPosition ) ; \n} \nreturn workCount ; \n} \n} \n"}
{"1870": "public class TermScanner { \npublic static long scanForAvailability ( final UnsafeBuffer termBuffer , final int offset , final int maxLength ) { \nfinal int limit = Math . min ( maxLength , termBuffer . capacity ( ) - offset ) ; \nint available = 0 ; \nint padding = 0 ; \ndo { \nfinal int termOffset = offset + available ; \nfinal int frameLength = frameLengthVolatile ( termBuffer , termOffset ) ; \nif ( 0 >= frameLength ) { \nbreak ; \n} \nint alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; \nif ( isPaddingFrame ( termBuffer , termOffset ) ) { \npadding = alignedFrameLength - HEADER_LENGTH ; \nalignedFrameLength = HEADER_LENGTH ; \n} \navailable += alignedFrameLength ; \nif ( limit < available ) { \navailable -= alignedFrameLength ; \npadding = 0 ; \nbreak ; \n} \n} \nwhile ( 0 == padding && limit > available ) ; \nreturn pack ( padding , available ) ; \n} \n} \n"}
{"1872": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder validate ( ) { \nif ( null == media ) { \nthrow new IllegalStateException ( \"media type is mandatory\" ) ; \n} \nif ( CommonContext . UDP_MEDIA . equals ( media ) && ( null == endpoint && null == controlEndpoint ) ) { \nthrow new IllegalStateException ( \"either 'endpoint' or 'control' must be specified for UDP.\" ) ; \n} \nint count = 0 ; \ncount += null == initialTermId ? 0 : 1 ; \ncount += null == termId ? 0 : 1 ; \ncount += null == termOffset ? 0 : 1 ; \nif ( 0 < count ) { \nif ( 3 > count ) { \nthrow new IllegalStateException ( \"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\" ) ; \n} \nif ( 0 > termId - initialTermId ) { \nthrow new IllegalStateException ( \"difference greater than 2^31 - 1: termId=\" + termId + \" - initialTermId=\" + initialTermId ) ; \n} \nif ( null != termLength && termLength < termOffset ) { \nthrow new IllegalStateException ( \"termOffset=\" + termOffset + \" > termLength=\" + termLength ) ; \n} \n} \nreturn this ; \n} \n} \n"}
{"1877": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder termOffset ( final Integer termOffset ) { \nif ( null != termOffset ) { \nif ( ( 0 > termOffset || LogBufferDescriptor . TERM_MAX_LENGTH < termOffset ) ) { \nthrow new IllegalArgumentException ( \"term offset not in range 0-1g: \" + termOffset ) ; \n} \nif ( 0 != ( termOffset & ( FRAME_ALIGNMENT - 1 ) ) ) { \nthrow new IllegalArgumentException ( \"term offset not multiple of FRAME_ALIGNMENT: \" + termOffset ) ; \n} \n} \nthis . termOffset = termOffset ; \nreturn this ; \n} \n} \n"}
{"1878": "public class ChannelUriStringBuilder { \npublic ChannelUriStringBuilder linger ( final Long lingerNs ) { \nif ( null != lingerNs && 0 > lingerNs ) { \nthrow new IllegalArgumentException ( \"linger value cannot be negative: \" + lingerNs ) ; \n} \nthis . linger = lingerNs ; \nreturn this ; \n} \n} \n"}
{"1881": "public class UdpChannelTransport { \npublic boolean isValidFrame ( final UnsafeBuffer buffer , final int length ) { \nboolean isFrameValid = true ; \nif ( frameVersion ( buffer , 0 ) != HeaderFlyweight . CURRENT_VERSION ) { \nisFrameValid = false ; \ninvalidPackets . increment ( ) ; \n} \nelse if ( HeaderFlyweight . MIN_HEADER_LENGTH > length ) { \nisFrameValid = false ; \ninvalidPackets . increment ( ) ; \n} \nreturn isFrameValid ; \n} \n} \n"}
{"1883": "public class RetransmitHandler { \npublic void onNak ( final int termId , final int termOffset , final int length , final int termLength , final RetransmitSender retransmitSender ) { \nif ( ! isInvalid ( termOffset , termLength ) ) { \nif ( null == activeRetransmitsMap . get ( termId , termOffset ) && MAX_RETRANSMITS_DEFAULT > activeRetransmitsMap . size ( ) ) { \nfinal RetransmitAction action = assignRetransmitAction ( ) ; \naction . termId = termId ; \naction . termOffset = termOffset ; \naction . length = Math . min ( length , termLength - termOffset ) ; \nfinal long delay = delayGenerator . generateDelay ( ) ; \nif ( 0 == delay ) { \nretransmitSender . resend ( termId , termOffset , action . length ) ; \naction . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; \n} \nelse { \naction . delay ( delay , nanoClock . nanoTime ( ) ) ; \n} \nactiveRetransmitsMap . put ( termId , termOffset , action ) ; \n} \n} \n} \n} \n"}
{"1884": "public class RetransmitHandler { \npublic void processTimeouts ( final long nowNs , final RetransmitSender retransmitSender ) { \nif ( 0 < activeRetransmitsMap . size ( ) ) { \nfor ( final RetransmitAction action : retransmitActionPool ) { \nif ( DELAYED == action . state && ( 0 > action . expireNs - nowNs ) ) { \nretransmitSender . resend ( action . termId , action . termOffset , action . length ) ; \naction . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; \n} \nelse if ( LINGERING == action . state && ( 0 > action . expireNs - nowNs ) ) { \naction . cancel ( ) ; \nactiveRetransmitsMap . remove ( action . termId , action . termOffset ) ; \n} \n} \n} \n} \n} \n"}
{"1888": "public class DirectBufferVector { \npublic DirectBufferVector validate ( ) { \nfinal int capacity = buffer . capacity ( ) ; \nif ( 0 > offset || capacity <= offset ) { \nthrow new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity ) ; \n} \nif ( 0 > length || ( capacity - offset ) < length ) { \nthrow new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity + \" length=\" + length ) ; \n} \nreturn this ; \n} \n} \n"}
{"1889": "public class DirectBufferVector { \npublic static int validateAndComputeLength ( final DirectBufferVector [ ] vectors ) { \nint messageLength = 0 ; \nfor ( final DirectBufferVector vector : vectors ) { \nvector . validate ( ) ; \nmessageLength += vector . length ; \nif ( 0 > messageLength ) { \nthrow new IllegalStateException ( \"length overflow: \" + Arrays . toString ( vectors ) ) ; \n} \n} \nreturn messageLength ; \n} \n} \n"}
{"1891": "public class Configuration { \npublic static void validateSocketBufferLengths ( final MediaDriver . Context ctx ) { \ntry ( DatagramChannel probe = DatagramChannel . open ( ) ) { \nfinal int defaultSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; \nprobe . setOption ( StandardSocketOptions . SO_SNDBUF , Integer . MAX_VALUE ) ; \nfinal int maxSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; \nif ( ctx . socketSndbufLength ( ) > maxSoSndBuf ) { \nSystem . err . format ( \"WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . socketSndbufLength ( ) , maxSoSndBuf ) ; \n} \nprobe . setOption ( StandardSocketOptions . SO_RCVBUF , Integer . MAX_VALUE ) ; \nfinal int maxSoRcvBuf = probe . getOption ( StandardSocketOptions . SO_RCVBUF ) ; \nif ( ctx . socketRcvbufLength ( ) > maxSoRcvBuf ) { \nSystem . err . format ( \"WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\" , SOCKET_RCVBUF_LENGTH_PROP_NAME , ctx . socketRcvbufLength ( ) , maxSoRcvBuf ) ; \n} \nfinal int soSndBuf = 0 == ctx . socketSndbufLength ( ) ? defaultSoSndBuf : ctx . socketSndbufLength ( ) ; \nif ( soSndBuf < ctx . mtuLength ( ) ) { \nthrow new ConfigurationException ( String . format ( \"MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d\" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . mtuLength ( ) , soSndBuf ) ) ; \n} \nif ( maxSoRcvBuf < ctx . initialWindowLength ( ) ) { \nthrow new ConfigurationException ( \"window length greater than socket SO_RCVBUF, increase '\" + Configuration . INITIAL_WINDOW_LENGTH_PROP_NAME + \"' to match window: windowLength=\" + ctx . initialWindowLength ( ) + \", SO_RCVBUF=\" + maxSoRcvBuf ) ; \n} \n} \ncatch ( final IOException ex ) { \nthrow new AeronException ( \"probe socket: \" + ex . toString ( ) , ex ) ; \n} \n} \n} \n"}
{"1892": "public class Configuration { \npublic static void validatePageSize ( final int pageSize ) { \nif ( PAGE_MIN_SIZE > pageSize ) { \nthrow new ConfigurationException ( \"page size less than min size of \" + PAGE_MIN_SIZE + \": \" + pageSize ) ; \n} \nif ( PAGE_MAX_SIZE < pageSize ) { \nthrow new ConfigurationException ( \"page size greater than max size of \" + PAGE_MAX_SIZE + \": \" + pageSize ) ; \n} \nif ( ! BitUtil . isPowerOfTwo ( pageSize ) ) { \nthrow new ConfigurationException ( \"page size not a power of 2: \" + pageSize ) ; \n} \n} \n} \n"}
{"1893": "public class Configuration { \npublic static void validateSessionIdRange ( final int low , final int high ) { \nif ( high < low ) { \nthrow new ConfigurationException ( \"low session id value \" + low + \" must be <= high value \" + high ) ; \n} \nif ( Integer . MAX_VALUE < Math . abs ( ( long ) high - low ) ) { \nthrow new ConfigurationException ( \"reserved range to too large\" ) ; \n} \n} \n} \n"}
{"1894": "public class Configuration { \npublic static void validateUnblockTimeout ( final long publicationUnblockTimeoutNs , final long clientLivenessTimeoutNs , final long timerIntervalNs ) { \nif ( clientLivenessTimeoutNs >= publicationUnblockTimeoutNs ) { \nthrow new ConfigurationException ( \"publicationUnblockTimeoutNs=\" + publicationUnblockTimeoutNs + \" <= clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs ) ; \n} \nif ( timerIntervalNs >= clientLivenessTimeoutNs ) { \nthrow new ConfigurationException ( \"clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs + \" <= timerIntervalNs=\" + timerIntervalNs ) ; \n} \n} \n} \n"}
{"1897": "public class ClusterMember { \npublic static String encodeAsString ( final ClusterMember [ ] clusterMembers ) { \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( int i = 0 , length = clusterMembers . length ; \nlength > i ; \ni ++ ) { \nfinal ClusterMember member = clusterMembers [ i ] ; \nbuilder . append ( member . id ( ) ) . append ( ',' ) . append ( member . endpointsDetail ( ) ) ; \nif ( ( length - 1 ) != i ) { \nbuilder . append ( '|' ) ; \n} \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"1900": "public class ClusterMember { \npublic static boolean hasActiveQuorum ( final ClusterMember [ ] clusterMembers , final long nowMs , final long timeoutMs ) { \nint threshold = quorumThreshold ( clusterMembers . length ) ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( member . isLeader ( ) || ( member . timeOfLastAppendPositionMs ( ) + timeoutMs ) >= nowMs ) { \nif ( 0 >= -- threshold ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"1901": "public class ClusterMember { \npublic static long quorumPosition ( final ClusterMember [ ] members , final long [ ] rankedPositions ) { \nfinal int length = rankedPositions . length ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nrankedPositions [ i ] = 0 ; \n} \nfor ( final ClusterMember member : members ) { \nlong newPosition = member . logPosition ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nfinal long rankedPosition = rankedPositions [ i ] ; \nif ( rankedPosition < newPosition ) { \nrankedPositions [ i ] = newPosition ; \nnewPosition = rankedPosition ; \n} \n} \n} \nreturn rankedPositions [ length - 1 ] ; \n} \n} \n"}
{"1903": "public class ClusterMember { \npublic static boolean haveVotersReachedPosition ( final ClusterMember [ ] clusterMembers , final long position , final long leadershipTermId ) { \nfor ( final ClusterMember member : clusterMembers ) { \nif ( member . vote != null && ( position > member . logPosition || member . leadershipTermId != leadershipTermId ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1904": "public class ClusterMember { \npublic static boolean hasWonVoteOnFullCount ( final ClusterMember [ ] members , final long candidateTermId ) { \nint votes = 0 ; \nfor ( final ClusterMember member : members ) { \nif ( null == member . vote || member . candidateTermId != candidateTermId ) { \nreturn false ; \n} \nvotes += member . vote ? 1 : 0 ; \n} \nreturn ClusterMember . quorumThreshold ( members . length ) <= votes ; \n} \n} \n"}
{"1905": "public class ClusterMember { \npublic static boolean hasMajorityVote ( final ClusterMember [ ] clusterMembers , final long candidateTermId ) { \nint votes = 0 ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( Boolean . TRUE . equals ( member . vote ) && member . candidateTermId == candidateTermId ) { \n++ votes ; \n} \n} \nreturn ClusterMember . quorumThreshold ( clusterMembers . length ) <= votes ; \n} \n} \n"}
{"1909": "public class ClusterMember { \npublic static boolean isUnanimousCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { \nfor ( final ClusterMember member : clusterMembers ) { \nif ( NULL_POSITION == member . logPosition || 0 > compareLog ( candidate , member ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"1910": "public class ClusterMember { \npublic static boolean isQuorumCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { \nint possibleVotes = 0 ; \nfor ( final ClusterMember member : clusterMembers ) { \nif ( NULL_POSITION == member . logPosition || 0 > compareLog ( candidate , member ) ) { \ncontinue ; \n} \n++ possibleVotes ; \n} \nreturn ClusterMember . quorumThreshold ( clusterMembers . length ) <= possibleVotes ; \n} \n} \n"}
{"1912": "public class ClusterMember { \npublic static int findMemberIndex ( final ClusterMember [ ] clusterMembers , final int memberId ) { \nfinal int length = clusterMembers . length ; \nint index = ArrayUtil . UNKNOWN_INDEX ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nif ( clusterMembers [ i ] . id ( ) == memberId ) { \nindex = i ; \n} \n} \nreturn index ; \n} \n} \n"}
{"1915": "public class CommonContext { \npublic MappedByteBuffer mapExistingCncFile ( final Consumer < String > logger ) { \nfinal File cncFile = new File ( aeronDirectory , CncFileDescriptor . CNC_FILE ) ; \nif ( cncFile . exists ( ) && 0 < cncFile . length ( ) ) { \nif ( null != logger ) { \nlogger . accept ( \"INFO: Aeron CnC file exists: \" + cncFile ) ; \n} \nreturn IoUtil . mapExistingFile ( cncFile , CncFileDescriptor . CNC_FILE ) ; \n} \nreturn null ; \n} \n} \n"}
{"1916": "public class CommonContext { \npublic static boolean isDriverActive ( final File directory , final long driverTimeoutMs , final Consumer < String > logger ) { \nfinal File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; \nif ( cncFile . exists ( ) && 0 < cncFile . length ( ) ) { \nlogger . accept ( \"INFO: Aeron CnC file exists: \" + cncFile ) ; \nfinal MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , \"CnC file\" ) ; \ntry { \nreturn isDriverActive ( driverTimeoutMs , logger , cncByteBuffer ) ; \n} \nfinally { \nIoUtil . unmap ( cncByteBuffer ) ; \n} \n} \nreturn false ; \n} \n} \n"}
{"1918": "public class CommonContext { \npublic static boolean isDriverActive ( final long driverTimeoutMs , final Consumer < String > logger , final ByteBuffer cncByteBuffer ) { \nif ( null == cncByteBuffer ) { \nreturn false ; \n} \nfinal UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; \nfinal long startTimeMs = System . currentTimeMillis ( ) ; \nint cncVersion ; \nwhile ( 0 == ( cncVersion = cncMetaDataBuffer . getIntVolatile ( CncFileDescriptor . cncVersionOffset ( 0 ) ) ) ) { \nif ( ( startTimeMs + driverTimeoutMs ) < System . currentTimeMillis ( ) ) { \nthrow new DriverTimeoutException ( \"CnC file is created but not initialised.\" ) ; \n} \nsleep ( 1 ) ; \n} \nif ( CNC_VERSION != cncVersion ) { \nthrow new AeronException ( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion ) ; \n} \nfinal ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; \nfinal long timestamp = toDriverBuffer . consumerHeartbeatTime ( ) ; \nfinal long now = System . currentTimeMillis ( ) ; \nfinal long timestampAge = now - timestamp ; \nlogger . accept ( \"INFO: Aeron toDriver consumer heartbeat is (ms): \" + timestampAge ) ; \nreturn driverTimeoutMs >= timestampAge ; \n} \n} \n"}
{"1919": "public class CommonContext { \npublic static boolean requestDriverTermination ( final File directory , final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { \nfinal File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; \nif ( cncFile . exists ( ) && 0 < cncFile . length ( ) ) { \nfinal MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , \"CnC file\" ) ; \ntry { \nfinal UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; \nfinal int cncVersion = cncMetaDataBuffer . getIntVolatile ( cncVersionOffset ( 0 ) ) ; \nif ( CncFileDescriptor . CNC_VERSION != cncVersion ) { \nthrow new AeronException ( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion ) ; \n} \nfinal ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; \nfinal long clientId = toDriverBuffer . nextCorrelationId ( ) ; \nfinal DriverProxy driverProxy = new DriverProxy ( toDriverBuffer , clientId ) ; \nreturn driverProxy . terminateDriver ( tokenBuffer , tokenOffset , tokenLength ) ; \n} \nfinally { \nIoUtil . unmap ( cncByteBuffer ) ; \n} \n} \nreturn false ; \n} \n} \n"}
{"1926": "public class RecordingPos { \npublic static int findCounterIdByRecording ( final CountersReader countersReader , final long recordingId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = countersReader . maxCounterId ( ) ; \nsize > i ; \ni ++ ) { \nif ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1927": "public class RecordingPos { \npublic static int findCounterIdBySession ( final CountersReader countersReader , final int sessionId ) { \nfinal DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = countersReader . maxCounterId ( ) ; \nsize > i ; \ni ++ ) { \nif ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SESSION_ID_OFFSET ) == sessionId ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1931": "public class RecordingLog { \npublic void reload ( ) { \nentries . clear ( ) ; \nindexByLeadershipTermIdMap . clear ( ) ; \nindexByLeadershipTermIdMap . compact ( ) ; \nnextEntryIndex = 0 ; \nbyteBuffer . clear ( ) ; \ntry { \nwhile ( true ) { \nfinal int bytes = fileChannel . read ( byteBuffer ) ; \nif ( byteBuffer . remaining ( ) == 0 ) { \nbyteBuffer . flip ( ) ; \ncaptureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; \nbyteBuffer . clear ( ) ; \n} \nif ( - 1 == bytes ) { \nif ( 0 < byteBuffer . position ( ) ) { \nbyteBuffer . flip ( ) ; \ncaptureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; \nbyteBuffer . clear ( ) ; \n} \nbreak ; \n} \n} \n} \ncatch ( final IOException ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \n} \n} \n"}
{"1932": "public class RecordingLog { \npublic Entry findLastTerm ( ) { \nfor ( int i = entries . size ( ) - 1 ; \n0 <= i ; \ni -- ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( ENTRY_TYPE_TERM == entry . type ) { \nreturn entry ; \n} \n} \nreturn null ; \n} \n} \n"}
{"1933": "public class RecordingLog { \npublic RecoveryPlan createRecoveryPlan ( final AeronArchive archive , final int serviceCount ) { \nfinal ArrayList < Snapshot > snapshots = new ArrayList < > ( ) ; \nfinal ArrayList < Log > logs = new ArrayList < > ( ) ; \nplanRecovery ( snapshots , logs , entries , archive , serviceCount ) ; \nlong lastLeadershipTermId = NULL_VALUE ; \nlong lastTermBaseLogPosition = 0 ; \nlong committedLogPosition = - 1 ; \nlong appendedLogPosition = 0 ; \nfinal int snapshotStepsSize = snapshots . size ( ) ; \nif ( 0 < snapshotStepsSize ) { \nfinal Snapshot snapshot = snapshots . get ( 0 ) ; \nlastLeadershipTermId = snapshot . leadershipTermId ; \nlastTermBaseLogPosition = snapshot . termBaseLogPosition ; \nappendedLogPosition = snapshot . logPosition ; \ncommittedLogPosition = snapshot . logPosition ; \n} \nif ( ! logs . isEmpty ( ) ) { \nfinal Log log = logs . get ( 0 ) ; \nlastLeadershipTermId = log . leadershipTermId ; \nlastTermBaseLogPosition = log . termBaseLogPosition ; \nappendedLogPosition = log . stopPosition ; \ncommittedLogPosition = log . logPosition ; \n} \nreturn new RecoveryPlan ( lastLeadershipTermId , lastTermBaseLogPosition , appendedLogPosition , committedLogPosition , snapshots , logs ) ; \n} \n} \n"}
{"1934": "public class RecordingLog { \npublic static RecoveryPlan createRecoveryPlan ( final ArrayList < RecordingLog . Snapshot > snapshots ) { \nlong lastLeadershipTermId = NULL_VALUE ; \nlong lastTermBaseLogPosition = 0 ; \nlong committedLogPosition = - 1 ; \nlong appendedLogPosition = 0 ; \nfinal int snapshotStepsSize = snapshots . size ( ) ; \nif ( 0 < snapshotStepsSize ) { \nfinal Snapshot snapshot = snapshots . get ( 0 ) ; \nlastLeadershipTermId = snapshot . leadershipTermId ; \nlastTermBaseLogPosition = snapshot . termBaseLogPosition ; \nappendedLogPosition = snapshot . logPosition ; \ncommittedLogPosition = snapshot . logPosition ; \n} \nreturn new RecoveryPlan ( lastLeadershipTermId , lastTermBaseLogPosition , appendedLogPosition , committedLogPosition , snapshots , new ArrayList < > ( ) ) ; \n} \n} \n"}
{"1935": "public class RecordingLog { \npublic void appendTerm ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long timestamp ) { \nfinal int size = entries . size ( ) ; \nif ( 0 < size ) { \nfinal Entry lastEntry = entries . get ( size - 1 ) ; \nif ( lastEntry . type != NULL_VALUE && leadershipTermId <= lastEntry . leadershipTermId ) { \nthrow new ClusterException ( \"leadershipTermId out of sequence: previous \" + lastEntry . leadershipTermId + \" this \" + leadershipTermId ) ; \n} \n} \nindexByLeadershipTermIdMap . put ( leadershipTermId , nextEntryIndex ) ; \nappend ( ENTRY_TYPE_TERM , recordingId , leadershipTermId , termBaseLogPosition , NULL_POSITION , timestamp , NULL_VALUE ) ; \n} \n} \n"}
{"1936": "public class RecordingLog { \npublic void appendSnapshot ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long logPosition , final long timestamp , final int serviceId ) { \nfinal int size = entries . size ( ) ; \nif ( 0 < size ) { \nfinal Entry entry = entries . get ( size - 1 ) ; \nif ( entry . type == ENTRY_TYPE_TERM && entry . leadershipTermId != leadershipTermId ) { \nthrow new ClusterException ( \"leadershipTermId out of sequence: previous \" + entry . leadershipTermId + \" this \" + leadershipTermId ) ; \n} \n} \nappend ( ENTRY_TYPE_SNAPSHOT , recordingId , leadershipTermId , termBaseLogPosition , logPosition , timestamp , serviceId ) ; \n} \n} \n"}
{"1938": "public class RecordingLog { \npublic void tombstoneEntry ( final long leadershipTermId , final int entryIndex ) { \nint index = - 1 ; \nfor ( int i = 0 , size = entries . size ( ) ; \nsize > i ; \ni ++ ) { \nfinal Entry entry = entries . get ( i ) ; \nif ( entry . leadershipTermId == leadershipTermId && entry . entryIndex == entryIndex ) { \nindex = entry . entryIndex ; \nif ( ENTRY_TYPE_TERM == entry . type ) { \nindexByLeadershipTermIdMap . remove ( leadershipTermId ) ; \n} \nbreak ; \n} \n} \nif ( - 1 == index ) { \nthrow new ClusterException ( \"unknown entry index: \" + entryIndex ) ; \n} \nbuffer . putInt ( 0 , NULL_VALUE , LITTLE_ENDIAN ) ; \nbyteBuffer . limit ( SIZE_OF_INT ) . position ( 0 ) ; \nfinal long filePosition = ( index * ( long ) ENTRY_LENGTH ) + ENTRY_TYPE_OFFSET ; \ntry { \nif ( SIZE_OF_INT != fileChannel . write ( byteBuffer , filePosition ) ) { \nthrow new ClusterException ( \"failed to write field atomically\" ) ; \n} \n} \ncatch ( final Exception ex ) { \nLangUtil . rethrowUnchecked ( ex ) ; \n} \n} \n} \n"}
{"1944": "public class LogBufferDescriptor { \npublic static void checkTermLength ( final int termLength ) { \nif ( TERM_MIN_LENGTH > termLength ) { \nthrow new IllegalStateException ( \"Term length less than min length of \" + TERM_MIN_LENGTH + \": length=\" + termLength ) ; \n} \nif ( TERM_MAX_LENGTH < termLength ) { \nthrow new IllegalStateException ( \"Term length more than max length of \" + TERM_MAX_LENGTH + \": length=\" + termLength ) ; \n} \nif ( ! BitUtil . isPowerOfTwo ( termLength ) ) { \nthrow new IllegalStateException ( \"Term length not a power of 2: length=\" + termLength ) ; \n} \n} \n} \n"}
{"1945": "public class LogBufferDescriptor { \npublic static void checkPageSize ( final int pageSize ) { \nif ( PAGE_MIN_SIZE > pageSize ) { \nthrow new IllegalStateException ( \"Page size less than min size of \" + PAGE_MIN_SIZE + \": page size=\" + pageSize ) ; \n} \nif ( PAGE_MAX_SIZE < pageSize ) { \nthrow new IllegalStateException ( \"Page size more than max size of \" + PAGE_MAX_SIZE + \": page size=\" + pageSize ) ; \n} \nif ( ! BitUtil . isPowerOfTwo ( pageSize ) ) { \nthrow new IllegalStateException ( \"Page size not a power of 2: page size=\" + pageSize ) ; \n} \n} \n} \n"}
{"1948": "public class LogBufferDescriptor { \npublic static long computeLogLength ( final int termLength , final int filePageSize ) { \nif ( ( 1024 * 1024 * 1024 ) > termLength ) { \nreturn align ( ( termLength * PARTITION_COUNT ) + LOG_META_DATA_LENGTH , filePageSize ) ; \n} \nreturn ( PARTITION_COUNT * ( long ) termLength ) + align ( LOG_META_DATA_LENGTH , filePageSize ) ; \n} \n} \n"}
{"1956": "public class TerminateDriverFlyweight { \npublic TerminateDriverFlyweight tokenBuffer ( final DirectBuffer tokenBuffer , final int tokenOffset , final int tokenLength ) { \nbuffer . putInt ( TOKEN_LENGTH_OFFSET , tokenLength ) ; \nif ( null != tokenBuffer && 0 < tokenLength ) { \nbuffer . putBytes ( tokenBufferOffset ( ) , tokenBuffer , tokenOffset , tokenLength ) ; \n} \nreturn this ; \n} \n} \n"}
{"1957": "public class RecoveryState { \npublic static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final long leadershipTermId , final long logPosition , final long timestamp , final boolean hasReplay , final long ... snapshotRecordingIds ) { \ntempBuffer . putLong ( LEADERSHIP_TERM_ID_OFFSET , leadershipTermId ) ; \ntempBuffer . putLong ( LOG_POSITION_OFFSET , logPosition ) ; \ntempBuffer . putLong ( TIMESTAMP_OFFSET , timestamp ) ; \ntempBuffer . putInt ( REPLAY_FLAG_OFFSET , hasReplay ? 1 : 0 ) ; \nfinal int serviceCount = snapshotRecordingIds . length ; \ntempBuffer . putInt ( SERVICE_COUNT_OFFSET , serviceCount ) ; \nfinal int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceCount * SIZE_OF_LONG ) ; \nif ( MAX_KEY_LENGTH < keyLength ) { \nthrow new ClusterException ( keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH ) ; \n} \nfor ( int i = 0 ; \nserviceCount > i ; \ni ++ ) { \ntempBuffer . putLong ( SNAPSHOT_RECORDING_IDS_OFFSET + ( i * SIZE_OF_LONG ) , snapshotRecordingIds [ i ] ) ; \n} \nfinal int labelOffset = BitUtil . align ( keyLength , SIZE_OF_INT ) ; \nint labelLength = 0 ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; \nlabelLength += tempBuffer . putLongAscii ( keyLength + labelLength , leadershipTermId ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" logPosition=\" ) ; \nlabelLength += tempBuffer . putLongAscii ( labelOffset + labelLength , logPosition ) ; \nlabelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" hasReplay=\" + hasReplay ) ; \nreturn aeron . addCounter ( RECOVERY_STATE_TYPE_ID , tempBuffer , 0 , keyLength , tempBuffer , labelOffset , labelLength ) ; \n} \n} \n"}
{"1958": "public class RecoveryState { \npublic static int findCounterId ( final CountersReader counters ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = counters . maxCounterId ( ) ; \nsize > i ; \ni ++ ) { \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1960": "public class RecoveryState { \npublic static long getSnapshotRecordingId ( final CountersReader counters , final int counterId , final int serviceId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nif ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( counterId ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { \nfinal int serviceCount = buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_COUNT_OFFSET ) ; \nif ( 0 > serviceId || serviceCount <= serviceId ) { \nthrow new ClusterException ( \"invalid serviceId \" + serviceId + \" for count of \" + serviceCount ) ; \n} \nreturn buffer . getLong ( recordOffset + KEY_OFFSET + SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceId * SIZE_OF_LONG ) ) ; \n} \n} \nthrow new ClusterException ( \"Active counter not found \" + counterId ) ; \n} \n} \n"}
{"1961": "public class HeaderFlyweight { \npublic static char [ ] flagsToChars ( final short flags ) { \nfinal char [ ] chars = new char [ ] { \n'0' , '0' , '0' , '0' , '0' , '0' , '0' , '0' } \n; \nfinal int length = chars . length ; \nshort mask = ( short ) ( 1 << ( length - 1 ) ) ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nif ( ( flags & mask ) == mask ) { \nchars [ i ] = '1' ; \n} \nmask >>= 1 ; \n} \nreturn chars ; \n} \n} \n"}
{"1971": "public class ServiceHeartbeat { \npublic static int findCounterId ( final CountersReader counters , final int serviceId ) { \nfinal DirectBuffer buffer = counters . metaDataBuffer ( ) ; \nfor ( int i = 0 , size = counters . maxCounterId ( ) ; \nsize > i ; \ni ++ ) { \nif ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { \nfinal int recordOffset = CountersReader . metaDataOffset ( i ) ; \nif ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == SERVICE_HEARTBEAT_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET ) == serviceId ) { \nreturn i ; \n} \n} \n} \nreturn NULL_COUNTER_ID ; \n} \n} \n"}
{"1972": "public class BacklogStat { \npublic Map < StreamCompositeKey , StreamBacklog > snapshot ( ) { \nfinal Map < StreamCompositeKey , StreamBacklog > streams = new HashMap < > ( ) ; \ncounters . forEach ( ( counterId , typeId , keyBuffer , label ) -> { \nif ( ( PUBLISHER_LIMIT_TYPE_ID <= typeId && RECEIVER_POS_TYPE_ID >= typeId ) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID ) { \nfinal StreamCompositeKey key = new StreamCompositeKey ( keyBuffer . getInt ( SESSION_ID_OFFSET ) , keyBuffer . getInt ( STREAM_ID_OFFSET ) , keyBuffer . getStringAscii ( CHANNEL_OFFSET ) ) ; \nfinal StreamBacklog streamBacklog = streams . computeIfAbsent ( key , ( ignore ) -> new StreamBacklog ( ) ) ; \nfinal long registrationId = keyBuffer . getLong ( REGISTRATION_ID_OFFSET ) ; \nfinal long value = counters . getCounterValue ( counterId ) ; \nswitch ( typeId ) { \ncase PublisherLimit . PUBLISHER_LIMIT_TYPE_ID : streamBacklog . createPublisherIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createPublisherIfAbsent ( ) . limit ( value ) ; \nbreak ; \ncase PublisherPos . PUBLISHER_POS_TYPE_ID : streamBacklog . createPublisherIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createPublisherIfAbsent ( ) . position ( value ) ; \nbreak ; \ncase SenderPos . SENDER_POSITION_TYPE_ID : streamBacklog . createSenderIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createSenderIfAbsent ( ) . position ( value ) ; \nbreak ; \ncase SenderLimit . SENDER_LIMIT_TYPE_ID : streamBacklog . createSenderIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createSenderIfAbsent ( ) . limit ( value ) ; \nbreak ; \ncase ReceiverHwm . RECEIVER_HWM_TYPE_ID : streamBacklog . createReceiverIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createReceiverIfAbsent ( ) . highWaterMark ( value ) ; \nbreak ; \ncase ReceiverPos . RECEIVER_POS_TYPE_ID : streamBacklog . createReceiverIfAbsent ( ) . registrationId ( registrationId ) ; \nstreamBacklog . createReceiverIfAbsent ( ) . position ( value ) ; \nbreak ; \ncase SubscriberPos . SUBSCRIBER_POSITION_TYPE_ID : streamBacklog . subscriberBacklogs ( ) . put ( registrationId , new Subscriber ( value ) ) ; \nbreak ; \n} \n} \n} \n) ; \nreturn streams ; \n} \n} \n"}
{"1976": "public class CapacityByteArrayOutputStream { \nprivate void addSlab ( int minimumSize ) { \nint nextSlabSize ; \nif ( bytesUsed == 0 ) { \nnextSlabSize = initialSlabSize ; \n} \nelse if ( maxCapacityHint / 5 < bytesUsed ) { \nnextSlabSize = maxCapacityHint / 5 ; \n} \nelse { \nnextSlabSize = bytesUsed ; \n} \nif ( minimumSize > nextSlabSize ) { \nLOG . debug ( \"slab size {} too small for value of size {}. Bumping up slab size\" , nextSlabSize , minimumSize ) ; \nnextSlabSize = minimumSize ; \n} \nLOG . debug ( \"used {} slabs, adding new slab of size {}\" , slabs . size ( ) , nextSlabSize ) ; \nthis . currentSlab = allocator . allocate ( nextSlabSize ) ; \nthis . slabs . add ( currentSlab ) ; \nthis . bytesAllocated += nextSlabSize ; \nthis . currentSlabIndex = 0 ; \n} \n} \n"}
{"1977": "public class CapacityByteArrayOutputStream { \npublic void setByte ( long index , byte value ) { \ncheckArgument ( bytesUsed > index , \"Index: \" + index + \" is >= the current size of: \" + bytesUsed ) ; \nlong seen = 0 ; \nfor ( int i = 0 ; \nslabs . size ( ) > i ; \ni ++ ) { \nByteBuffer slab = slabs . get ( i ) ; \nif ( seen + slab . limit ( ) > index ) { \nslab . put ( ( int ) ( index - seen ) , value ) ; \nbreak ; \n} \nseen += slab . limit ( ) ; \n} \n} \n} \n"}
{"1982": "public class GlobParser { \nprivate static String annotateMessage ( String message , int pos ) { \nStringBuilder sb = new StringBuilder ( message ) ; \nsb . append ( '\\n' ) ; \nfor ( int i = 0 ; \npos > i ; \ni ++ ) { \nsb . append ( '-' ) ; \n} \nsb . append ( '^' ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"1993": "public class MemoryManager { \nprivate void updateAllocation ( ) { \nlong totalAllocations = 0 ; \nfor ( Long allocation : writerList . values ( ) ) { \ntotalAllocations += allocation ; \n} \nif ( totalMemoryPool >= totalAllocations ) { \nscale = 1.0 ; \n} \nelse { \nscale = ( double ) totalMemoryPool / totalAllocations ; \nLOG . warn ( String . format ( \"Total allocation exceeds %.2f%% (%,d bytes) of heap memory\\n\" + \"Scaling row group sizes to %.2f%% for %d writers\" , 100 * memoryPoolRatio , totalMemoryPool , 100 * scale , writerList . size ( ) ) ) ; \nfor ( Runnable callBack : callBacks . values ( ) ) { \ncallBack . run ( ) ; \n} \n} \nint maxColCount = 0 ; \nfor ( InternalParquetRecordWriter w : writerList . keySet ( ) ) { \nmaxColCount = Math . max ( w . getSchema ( ) . getColumns ( ) . size ( ) , maxColCount ) ; \n} \nfor ( Map . Entry < InternalParquetRecordWriter , Long > entry : writerList . entrySet ( ) ) { \nlong newSize = ( long ) Math . floor ( entry . getValue ( ) * scale ) ; \nif ( 1.0 > scale && 0 < minMemoryAllocation && minMemoryAllocation > newSize ) { \nthrow new ParquetRuntimeException ( String . format ( \"New Memory allocation %d bytes\" + \" is smaller than the minimum allocation size of %d bytes.\" , newSize , minMemoryAllocation ) ) { \n} \n; \n} \nentry . getKey ( ) . setRowGroupSizeThreshold ( newSize ) ; \nLOG . debug ( String . format ( \"Adjust block size from %,d to %,d for writer: %s\" , entry . getValue ( ) , newSize , entry . getKey ( ) ) ) ; \n} \n} \n} \n"}
{"2002": "public class ParquetFileWriter { \nprivate static void copy ( SeekableInputStream from , PositionOutputStream to , long start , long length ) throws IOException { \nLOG . debug ( \"Copying {} bytes at {} to {}\" , length , start , to . getPos ( ) ) ; \nfrom . seek ( start ) ; \nlong bytesCopied = 0 ; \nbyte [ ] buffer = COPY_BUFFER . get ( ) ; \nwhile ( length > bytesCopied ) { \nlong bytesLeft = length - bytesCopied ; \nint bytesRead = from . read ( buffer , 0 , ( bytesLeft > buffer . length ? buffer . length : ( int ) bytesLeft ) ) ; \nif ( 0 > bytesRead ) { \nthrow new IllegalArgumentException ( \"Unexpected end of input file at \" + start + bytesCopied ) ; \n} \nto . write ( buffer , 0 , bytesRead ) ; \nbytesCopied += bytesRead ; \n} \n} \n} \n"}
{"2017": "public class DeltaBinaryPackingValuesReader { \n@ Override public void initFromPage ( int valueCount , ByteBufferInputStream stream ) throws IOException { \nthis . in = stream ; \nlong startPos = in . position ( ) ; \nthis . config = DeltaBinaryPackingConfig . readConfig ( in ) ; \nthis . totalValueCount = BytesUtils . readUnsignedVarInt ( in ) ; \nallocateValuesBuffer ( ) ; \nbitWidths = new int [ config . miniBlockNumInABlock ] ; \nvaluesBuffer [ valuesBuffered ++ ] = BytesUtils . readZigZagVarLong ( in ) ; \nwhile ( totalValueCount > valuesBuffered ) { \nloadNewBlockToBuffer ( ) ; \n} \nupdateNextOffset ( ( int ) ( in . position ( ) - startPos ) ) ; \n} \n} \n"}
{"2020": "public class DeltaBinaryPackingValuesWriterForInteger { \nprivate void calculateBitWidthsForDeltaBlockBuffer ( int miniBlocksToFlush ) { \nfor ( int miniBlockIndex = 0 ; \nminiBlocksToFlush > miniBlockIndex ; \nminiBlockIndex ++ ) { \nint mask = 0 ; \nint miniStart = miniBlockIndex * config . miniBlockSizeInValues ; \nint miniEnd = Math . min ( ( miniBlockIndex + 1 ) * config . miniBlockSizeInValues , deltaValuesToFlush ) ; \nfor ( int i = miniStart ; \nminiEnd > i ; \ni ++ ) { \nmask |= deltaBlockBuffer [ i ] ; \n} \nbitWidths [ miniBlockIndex ] = 32 - Integer . numberOfLeadingZeros ( mask ) ; \n} \n} \n} \n"}
{"2039": "public class ProtocolEventsAmender { \nprivate void checkSet ( Iterator < TProtocol > eventIter , ThriftField setFieldDefinition ) throws TException { \nTSet thriftSet = acceptProtocol ( eventIter . next ( ) ) . readSetBegin ( ) ; \nThriftField elementFieldDefinition = ( ( ThriftType . SetType ) setFieldDefinition . getType ( ) ) . getValues ( ) ; \nint setSize = thriftSet . size ; \nfor ( int i = 0 ; \nsetSize > i ; \ni ++ ) { \ncheckField ( thriftSet . elemType , eventIter , elementFieldDefinition ) ; \n} \nacceptProtocol ( eventIter . next ( ) ) . readSetEnd ( ) ; \n} \n} \n"}
{"2050": "public class FilteredRecordReader { \nprivate void skipToMatch ( ) { \nwhile ( recordCount > recordsRead && ! recordFilter . isMatch ( ) ) { \nState currentState = getState ( 0 ) ; \ndo { \nColumnReader columnReader = currentState . column ; \nif ( currentState . maxDefinitionLevel <= columnReader . getCurrentDefinitionLevel ( ) ) { \ncolumnReader . skip ( ) ; \n} \ncolumnReader . consume ( ) ; \nint nextR = currentState . maxRepetitionLevel == 0 ? 0 : columnReader . getCurrentRepetitionLevel ( ) ; \ncurrentState = currentState . getNextState ( nextR ) ; \n} \nwhile ( currentState != null ) ; \n++ recordsRead ; \n} \n} \n} \n"}
{"2057": "public class PathGlobPattern { \npublic void set ( String glob ) { \nStringBuilder regex = new StringBuilder ( ) ; \nint setOpen = 0 ; \nint curlyOpen = 0 ; \nint len = glob . length ( ) ; \nhasWildcard = false ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nchar c = glob . charAt ( i ) ; \nswitch ( c ) { \ncase BACKSLASH : if ( len <= ++ i ) { \nerror ( \"Missing escaped character\" , glob , i ) ; \n} \nregex . append ( c ) . append ( glob . charAt ( i ) ) ; \ncontinue ; \ncase '.' : case '$' : case '(' : case ')' : case '|' : case '+' : regex . append ( BACKSLASH ) ; \nbreak ; \ncase '*' : if ( len > i + 1 && glob . charAt ( i + 1 ) == '*' ) { \nregex . append ( '.' ) ; \ni ++ ; \nbreak ; \n} \nregex . append ( \"[^\" + PATH_SEPARATOR + \"]\" ) ; \nhasWildcard = true ; \nbreak ; \ncase '?' : regex . append ( '.' ) ; \nhasWildcard = true ; \ncontinue ; \ncase '{' : regex . append ( \"(?:\" ) ; \ncurlyOpen ++ ; \nhasWildcard = true ; \ncontinue ; \ncase ',' : regex . append ( 0 < curlyOpen ? '|' : c ) ; \ncontinue ; \ncase '}' : if ( 0 < curlyOpen ) { \ncurlyOpen -- ; \nregex . append ( \")\" ) ; \ncontinue ; \n} \nbreak ; \ncase '[' : if ( 0 < setOpen ) { \nerror ( \"Unclosed character class\" , glob , i ) ; \n} \nsetOpen ++ ; \nhasWildcard = true ; \nbreak ; \ncase '^' : if ( setOpen == 0 ) { \nregex . append ( BACKSLASH ) ; \n} \nbreak ; \ncase '!' : regex . append ( 0 < setOpen && '[' == glob . charAt ( i - 1 ) ? '^' : '!' ) ; \ncontinue ; \ncase ']' : setOpen = 0 ; \nbreak ; \ndefault : } \nregex . append ( c ) ; \n} \nif ( 0 < setOpen ) { \nerror ( \"Unclosed character class\" , glob , len ) ; \n} \nif ( 0 < curlyOpen ) { \nerror ( \"Unclosed group\" , glob , len ) ; \n} \ncompiled = Pattern . compile ( regex . toString ( ) ) ; \n} \n} \n"}
{"2064": "public class InitContext { \n@ Deprecated public Map < String , String > getMergedKeyValueMetaData ( ) { \nif ( mergedKeyValueMetadata == null ) { \nMap < String , String > mergedKeyValues = new HashMap < String , String > ( ) ; \nfor ( Entry < String , Set < String > > entry : keyValueMetadata . entrySet ( ) ) { \nif ( 1 < entry . getValue ( ) . size ( ) ) { \nthrow new RuntimeException ( \"could not merge metadata: key \" + entry . getKey ( ) + \" has conflicting values: \" + entry . getValue ( ) ) ; \n} \nmergedKeyValues . put ( entry . getKey ( ) , entry . getValue ( ) . iterator ( ) . next ( ) ) ; \n} \nmergedKeyValueMetadata = mergedKeyValues ; \n} \nreturn mergedKeyValueMetadata ; \n} \n} \n"}
{"2069": "public class MergeCommand { \nprivate void checkParquetFiles ( List < Path > inputFiles ) throws IOException { \nif ( inputFiles == null || 1 >= inputFiles . size ( ) ) { \nthrow new IllegalArgumentException ( \"Not enough files to merge\" ) ; \n} \nfor ( Path inputFile : inputFiles ) { \nFileSystem fs = inputFile . getFileSystem ( conf ) ; \nFileStatus status = fs . getFileStatus ( inputFile ) ; \nif ( status . isDir ( ) ) { \nthrow new IllegalArgumentException ( \"Illegal parquet file: \" + inputFile . toUri ( ) ) ; \n} \n} \n} \n} \n"}
{"2073": "public class Hive010Binding { \nprivate void init ( final JobConf job ) { \nfinal String plan = HiveConf . getVar ( job , HiveConf . ConfVars . PLAN ) ; \nif ( mrwork == null && plan != null && 0 < plan . length ( ) ) { \nmrwork = Utilities . getMapRedWork ( job ) ; \npathToPartitionInfo . clear ( ) ; \nfor ( final Map . Entry < String , PartitionDesc > entry : mrwork . getPathToPartitionInfo ( ) . entrySet ( ) ) { \npathToPartitionInfo . put ( new Path ( entry . getKey ( ) ) . toUri ( ) . getPath ( ) . toString ( ) , entry . getValue ( ) ) ; \n} \n} \n} \n} \n"}
{"2078": "public class ByteBasedBitPackingEncoder { \npublic void writeInt ( int value ) throws IOException { \ninput [ inputSize ] = value ; \n++ inputSize ; \nif ( inputSize == VALUES_WRITTEN_AT_A_TIME ) { \npack ( ) ; \nif ( packedPosition == slabSize ) { \nslabs . add ( BytesInput . from ( packed ) ) ; \ntotalFullSlabSize += slabSize ; \nif ( bitWidth * MAX_SLAB_SIZE_MULT > slabSize ) { \nslabSize *= 2 ; \n} \ninitPackedSlab ( ) ; \n} \n} \n} \n} \n"}
{"2087": "public class AvroTypeUtil { \nprivate static int millisToDays ( long millisLocal ) { \nlong millisUtc = millisLocal + localTimeZone . getOffset ( millisLocal ) ; \nint days ; \nif ( 0L <= millisUtc ) { \ndays = ( int ) ( millisUtc / MILLIS_PER_DAY ) ; \n} \nelse { \ndays = ( int ) ( ( millisUtc - 86399999 ) / MILLIS_PER_DAY ) ; \n} \nreturn days ; \n} \n} \n"}
{"2103": "public class SystemPackage { \nprivate static boolean isSystemClass ( String name , List < String > packageList ) { \nboolean result = false ; \nif ( packageList != null ) { \nString canonicalName = ClassLoaderUtil . canonicalizeClassOrResource ( name ) ; \nfor ( String c : packageList ) { \nboolean shouldInclude = true ; \nif ( c . startsWith ( \"-\" ) ) { \nc = c . substring ( 1 ) ; \nshouldInclude = false ; \n} \nif ( canonicalName . startsWith ( c ) ) { \nif ( c . endsWith ( \".\" ) || canonicalName . length ( ) == c . length ( ) || c . length ( ) < canonicalName . length ( ) && canonicalName . charAt ( c . length ( ) ) == '$' ) { \nif ( shouldInclude ) { \nresult = true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"2130": "public class HttpClientSource { \nprivate int parsePaginatedResult ( BatchMaker batchMaker , String sourceOffset , Record record ) throws StageException { \nint numSubRecords = 0 ; \nif ( ! record . has ( conf . pagination . resultFieldPath ) ) { \nfinal StageException stageException = new StageException ( Errors . HTTP_12 , conf . pagination . resultFieldPath ) ; \nLOG . error ( stageException . getMessage ( ) ) ; \nthrow stageException ; \n} \nField resultField = record . get ( conf . pagination . resultFieldPath ) ; \nif ( resultField . getType ( ) != Field . Type . LIST ) { \nfinal StageException stageException = new StageException ( Errors . HTTP_08 , resultField . getType ( ) ) ; \nLOG . error ( stageException . getMessage ( ) ) ; \nthrow stageException ; \n} \nList < Field > results = resultField . getValueAsList ( ) ; \nint subRecordIdx = 0 ; \nfor ( Field result : results ) { \nRecord r = getContext ( ) . createRecord ( sourceOffset + \"::\" + subRecordIdx ++ ) ; \nif ( conf . pagination . keepAllFields ) { \nr . set ( record . get ( ) . clone ( ) ) ; \nr . set ( conf . pagination . resultFieldPath , result ) ; \n} \nelse { \nr . set ( result ) ; \n} \naddResponseHeaders ( r . getHeader ( ) ) ; \nbatchMaker . addRecord ( r ) ; \n++ numSubRecords ; \n} \nif ( conf . pagination . mode != PaginationMode . LINK_FIELD ) { \nhaveMorePages = 0 < numSubRecords ; \n} \nreturn numSubRecords ; \n} \n} \n"}
{"2133": "public class HttpClientSource { \nprivate Optional < String > processResponse ( long start , int maxRecords , BatchMaker batchMaker ) throws StageException { \nOptional < String > newSourceOffset = Optional . empty ( ) ; \nif ( getResponse ( ) == null ) { \nreturn newSourceOffset ; \n} \nint status = getResponse ( ) . getStatus ( ) ; \nif ( 200 > status || 300 <= status ) { \nlastRequestCompletedTime = System . currentTimeMillis ( ) ; \nString reason = getResponse ( ) . getStatusInfo ( ) . getReasonPhrase ( ) ; \nString respString = getResponse ( ) . readEntity ( String . class ) ; \ngetResponse ( ) . close ( ) ; \nsetResponse ( null ) ; \nfinal String errorMsg = reason + \" : \" + respString ; \nLOG . warn ( Errors . HTTP_01 . getMessage ( ) , status , errorMsg ) ; \nerrorRecordHandler . onError ( Errors . HTTP_01 , status , errorMsg ) ; \nreturn newSourceOffset ; \n} \nif ( conf . pagination . mode == PaginationMode . LINK_HEADER ) { \nnext = getResponse ( ) . getLink ( \"next\" ) ; \nif ( next == null ) { \nhaveMorePages = false ; \n} \n} \nif ( getResponse ( ) . hasEntity ( ) ) { \nnewSourceOffset = Optional . of ( parseResponse ( start , maxRecords , batchMaker ) ) ; \n} \nelse if ( conf . httpMethod . getLabel ( ) == \"HEAD\" ) { \nnewSourceOffset = Optional . of ( parseHeadersOnly ( batchMaker ) ) ; \n} \nreturn newSourceOffset ; \n} \n} \n"}
{"2139": "public class AbstractOverrunDelimitedReader { \nprotected int copyToBuffer ( StringBuilder s , int initialLen , int startChar , int currentChar ) { \nint overrun = 0 ; \nint currentSize = s . length ( ) - initialLen ; \nint readSize = currentChar - startChar ; \nif ( - 1 < maxLine && maxLine < currentSize + readSize ) { \nint adjustedReadSize = maxLine - currentSize ; \nif ( 0 < adjustedReadSize ) { \ns . append ( cb , startChar , adjustedReadSize ) ; \noverrun = readSize - adjustedReadSize ; \n} \nelse { \noverrun = readSize ; \n} \n} \nelse { \ns . append ( cb , startChar , readSize ) ; \n} \nreturn overrun ; \n} \n} \n"}
{"2142": "public class MultiLineLiveFileReader { \nint findNextMainLine ( LiveFileChunk chunk , int startIdx ) { \nList < FileLine > lines = chunk . getLines ( ) ; \nint found = - 1 ; \nfor ( int i = startIdx ; \nfound == - 1 && lines . size ( ) > i ; \ni ++ ) { \nif ( pattern . matcher ( lines . get ( i ) . getText ( ) . trim ( ) ) . matches ( ) ) { \nfound = i ; \n} \n} \nreturn found ; \n} \n} \n"}
{"2143": "public class MultiLineLiveFileReader { \nLiveFileChunk resolveChunk ( LiveFileChunk chunk ) { \nList < FileLine > completeLines = new ArrayList < > ( ) ; \nList < FileLine > chunkLines = chunk . getLines ( ) ; \nif ( incompleteMultiLine . length ( ) == 0 ) { \nincompleteMultiLineOffset = chunk . getOffset ( ) ; \nincompleteMultiLineTruncated = chunk . isTruncated ( ) ; \n} \nincompleteMultiLineTruncated |= chunk . isTruncated ( ) ; \nint pos = 0 ; \nint idx = findNextMainLine ( chunk , pos ) ; \nwhile ( - 1 < idx ) { \nfor ( int i = pos ; \nidx > i ; \ni ++ ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( incompleteMultiLine . length ( ) != 0 ) { \ncompleteLines . add ( new FileLine ( incompleteMultiLineOffset , incompleteMultiLine . toString ( ) ) ) ; \nincompleteMultiLineOffset += incompleteMultiLine . length ( ) ; \nincompleteMultiLine . setLength ( 0 ) ; \nincompleteMultiLineTruncated = false ; \n} \nincompleteMultiLine . append ( chunkLines . get ( idx ) . getText ( ) ) ; \npos = idx + 1 ; \nidx = findNextMainLine ( chunk , pos ) ; \n} \nfor ( int i = pos ; \nchunkLines . size ( ) > i ; \ni ++ ) { \nincompleteMultiLine . append ( chunkLines . get ( i ) . getText ( ) ) ; \n} \nif ( completeLines . isEmpty ( ) ) { \nchunk = null ; \n} \nelse { \nchunk = new LiveFileChunk ( chunk . getTag ( ) , chunk . getFile ( ) , chunk . getCharset ( ) , completeLines , incompleteMultiLineTruncated ) ; \n} \nreturn chunk ; \n} \n} \n"}
{"2145": "public class FieldRenamerProcessor { \nprivate static String escapeQuotedSubstring ( String input ) { \nString [ ] parts = input . split ( \"'\" ) ; \nStringBuilder output = new StringBuilder ( input . length ( ) * 2 ) ; \nfor ( int i = 0 ; \nparts . length > i ; \ni ++ ) { \nif ( ( i % 2 ) == 1 ) { \noutput . append ( \"'\" ) . append ( parts [ i ] . replace ( \"|\" , \"\\\\|\" ) ) . append ( \"'\" ) ; \n} \nelse { \noutput . append ( parts [ i ] ) ; \n} \n} \nreturn output . toString ( ) ; \n} \n} \n"}
{"2150": "public class GrokDictionary { \nprivate String digestExpressionAux ( String originalExpression ) { \nfinal String PATTERN_START = \"%{\" ; \nfinal String PATTERN_STOP = \"}\" ; \nfinal char PATTERN_DELIMITER = ':' ; \nwhile ( true ) { \nint PATTERN_START_INDEX = originalExpression . indexOf ( PATTERN_START ) ; \nint PATTERN_STOP_INDEX = originalExpression . indexOf ( PATTERN_STOP , PATTERN_START_INDEX + PATTERN_START . length ( ) ) ; \nif ( 0 > PATTERN_START_INDEX || 0 > PATTERN_STOP_INDEX ) { \nbreak ; \n} \nString grokPattern = originalExpression . substring ( PATTERN_START_INDEX + PATTERN_START . length ( ) , PATTERN_STOP_INDEX ) ; \nint PATTERN_DELIMITER_INDEX = grokPattern . indexOf ( PATTERN_DELIMITER ) ; \nString regexName = grokPattern ; \nString groupName = null ; \nif ( 0 <= PATTERN_DELIMITER_INDEX ) { \nregexName = grokPattern . substring ( 0 , PATTERN_DELIMITER_INDEX ) ; \ngroupName = grokPattern . substring ( PATTERN_DELIMITER_INDEX + 1 , grokPattern . length ( ) ) ; \n} \nfinal String dictionaryValue = regexDictionary . get ( regexName ) ; \nif ( dictionaryValue == null ) { \nthrow new GrokCompilationException ( \"Missing value for regex name : \" + regexName ) ; \n} \nif ( dictionaryValue . contains ( PATTERN_START ) ) { \nbreak ; \n} \nString replacement = dictionaryValue ; \nif ( null != groupName ) { \nreplacement = \"(?<\" + groupName + \">\" + dictionaryValue + \")\" ; \n} \noriginalExpression = new StringBuilder ( originalExpression ) . replace ( PATTERN_START_INDEX , PATTERN_STOP_INDEX + PATTERN_STOP . length ( ) , replacement ) . toString ( ) ; \n} \nreturn originalExpression ; \n} \n} \n"}
{"2165": "public class HiveMetastoreUtil { \npublic static boolean getCustomLocation ( Record metadataRecord ) throws HiveStageCheckedException { \nif ( 3 > metadataRecord . get ( SEP + VERSION ) . getValueAsInteger ( ) ) { \nreturn DEFAULT_CUSTOM_LOCATION ; \n} \nif ( metadataRecord . has ( SEP + CUSTOM_LOCATION ) ) { \nreturn metadataRecord . get ( SEP + CUSTOM_LOCATION ) . getValueAsBoolean ( ) ; \n} \nthrow new HiveStageCheckedException ( Errors . HIVE_17 , CUSTOM_LOCATION , metadataRecord ) ; \n} \n} \n"}
{"2175": "public class Utils { \npublic static String format ( String template , Object ... args ) { \nString [ ] templateArr = TEMPLATES . get ( template ) ; \nif ( templateArr == null ) { \ntemplateArr = prepareTemplate ( template ) ; \nTEMPLATES . put ( template , templateArr ) ; \n} \nStringBuilder sb = new StringBuilder ( template . length ( ) * 2 ) ; \nfor ( int i = 0 ; \ntemplateArr . length > i ; \ni ++ ) { \nsb . append ( templateArr [ i ] ) ; \nif ( args != null && ( templateArr . length - 1 > i ) ) { \nsb . append ( ( args . length > i ) ? args [ i ] : TOKEN ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2184": "public class CouchbaseConnector { \nprivate static void validateConfig ( BaseCouchbaseConfig config , List < Stage . ConfigIssue > issues , Stage . Context context ) { \nif ( config . couchbase . nodes == null ) { \nissues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.nodes\" , Errors . COUCHBASE_29 ) ) ; \n} \nif ( 0 > config . couchbase . kvTimeout ) { \nissues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.kvTimeout\" , Errors . COUCHBASE_30 ) ) ; \n} \nif ( 0 > config . couchbase . connectTimeout ) { \nissues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.connectTimeout\" , Errors . COUCHBASE_31 ) ) ; \n} \nif ( 0 > config . couchbase . disconnectTimeout ) { \nissues . add ( context . createConfigIssue ( Groups . COUCHBASE . name ( ) , \"config.couchbase.disconnectTimeout\" , Errors . COUCHBASE_32 ) ) ; \n} \nif ( config . couchbase . tls . tlsEnabled ) { \nconfig . couchbase . tls . init ( context , Groups . COUCHBASE . name ( ) , \"config.couchbase.tls.\" , issues ) ; \n} \nif ( config . credentials . version == null ) { \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , \"config.credentials.version\" , Errors . COUCHBASE_33 ) ) ; \n} \nif ( config . credentials . version == AuthenticationType . USER ) { \nif ( config . credentials . userName == null ) { \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , \"config.credentials.userName\" , Errors . COUCHBASE_34 ) ) ; \n} \nif ( config . credentials . userPassword == null ) { \nissues . add ( context . createConfigIssue ( Groups . CREDENTIALS . name ( ) , \"config.credentials.userPassword\" , Errors . COUCHBASE_35 ) ) ; \n} \n} \n} \n} \n"}
{"2210": "public class RunnerPool { \npublic T getIdleRunner ( long idleTime ) { \nQueueItem < T > item = queue . poll ( ) ; \nif ( item == null ) { \nreturn null ; \n} \nif ( idleTime > ( System . currentTimeMillis ( ) - item . timestamp ) ) { \nqueue . add ( item ) ; \nreturn null ; \n} \nreturn item . runner ; \n} \n} \n"}
{"2212": "public class RunnerPool { \npublic void destroy ( ) throws PipelineRuntimeException { \ndestroyed . set ( true ) ; \nif ( runtimeStats . getTotalRunners ( ) > queue . size ( ) ) { \nthrow new PipelineRuntimeException ( ContainerError . CONTAINER_0802 , queue . size ( ) , runtimeStats . getTotalRunners ( ) ) ; \n} \n} \n} \n"}
{"2219": "public class SpoolDirUtil { \npublic static boolean compareFiles ( WrappedFileSystem fs , WrappedFile f1 , WrappedFile f2 ) { \nif ( ! fs . exists ( f2 ) ) { \nreturn true ; \n} \ntry { \nlong mtime1 = fs . getLastModifiedTime ( f1 ) ; \nlong mtime2 = fs . getLastModifiedTime ( f2 ) ; \nlong ctime1 = fs . getChangedTime ( f1 ) ; \nlong ctime2 = fs . getChangedTime ( f2 ) ; \nlong time1 = Math . max ( mtime1 , ctime1 ) ; \nlong time2 = Math . max ( mtime2 , ctime2 ) ; \nint compares = Long . compare ( time1 , time2 ) ; \nif ( compares != 0 ) { \nreturn 0 < compares ; \n} \n} \ncatch ( IOException ex ) { \nLOG . error ( \"Failed to get ctime: '{}'\" , f1 . getFileName ( ) , ex ) ; \nreturn false ; \n} \nreturn 0 < f1 . getAbsolutePath ( ) . compareTo ( f2 . getAbsolutePath ( ) ) ; \n} \n} \n"}
{"2223": "public class ActiveStats { \npublic ActiveStats roll ( ) { \nlong now = System . currentTimeMillis ( ) ; \nsetEndTime ( now ) ; \nActiveStats statsBean = new ActiveStats ( ) . setStartTime ( now ) . setDataCollectorVersion ( getDataCollectorVersion ( ) ) . setDpmEnabled ( isDpmEnabled ( ) ) . setUpTime ( getUpTime ( ) . roll ( ) ) ; \nstatsBean . setPipelines ( getPipelines ( ) . stream ( ) . map ( UsageTimer :: roll ) . collect ( Collectors . toList ( ) ) ) ; \nstatsBean . setStages ( getStages ( ) . stream ( ) . filter ( timer -> 0 < timer . getMultiplier ( ) ) . map ( UsageTimer :: roll ) . collect ( Collectors . toList ( ) ) ) ; \nreturn statsBean ; \n} \n} \n"}
{"2245": "public class AvroSchemaHelper { \npublic int writeSchemaId ( OutputStream os , int schemaId ) throws IOException { \nif ( 0 < schemaId ) { \nos . write ( MAGIC_BYTE ) ; \nos . write ( ByteBuffer . allocate ( ID_SIZE ) . putInt ( schemaId ) . array ( ) ) ; \n} \nreturn schemaId ; \n} \n} \n"}
{"2246": "public class AvroSchemaHelper { \npublic Optional < Integer > detectSchemaId ( byte [ ] data ) { \nif ( 5 > data . length ) { \nreturn Optional . empty ( ) ; \n} \nByteBuffer wrapped = ByteBuffer . wrap ( data ) ; \nif ( wrapped . get ( ) != MAGIC_BYTE ) { \nreturn Optional . empty ( ) ; \n} \nreturn Optional . of ( wrapped . getInt ( ) ) ; \n} \n} \n"}
{"2282": "public class BaseKafkaSource { \npublic int getParallelism ( ) throws StageException { \nif ( originParallelism == 0 ) { \noriginParallelism = kafkaValidationUtil . getPartitionCount ( conf . metadataBrokerList , conf . topic , new HashMap < String , Object > ( conf . kafkaConsumerConfigs ) , 3 , 1000 ) ; \nif ( 1 > originParallelism ) { \nthrow new StageException ( KafkaErrors . KAFKA_42 , conf . topic ) ; \n} \n} \nreturn originParallelism ; \n} \n} \n"}
{"2283": "public class BigQueryDelegate { \npublic TableResult runQuery ( QueryJobConfiguration queryConfig , long timeout , long pageSize ) throws StageException { \ncheckArgument ( 1000 <= timeout , \"Timeout must be at least one second.\" ) ; \nInstant maxTime = Instant . now ( ) . plusMillis ( timeout ) ; \nJobId jobId = JobId . of ( UUID . randomUUID ( ) . toString ( ) ) ; \nJobInfo jobInfo = JobInfo . newBuilder ( queryConfig ) . setJobId ( jobId ) . build ( ) ; \nJob queryJob = bigquery . create ( jobInfo ) ; \nif ( queryJob == null ) { \nLOG . error ( \"Job no longer exists: {}\" , jobInfo ) ; \nthrow new RuntimeException ( \"Job no longer exists: \" + jobInfo ) ; \n} \nelse if ( queryJob . getStatus ( ) . getError ( ) != null ) { \nBigQueryError error = queryJob . getStatus ( ) . getError ( ) ; \nLOG . error ( \"Query Job execution error: {}\" , error ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , error ) ; \n} \nwhile ( ! queryJob . isDone ( ) ) { \nif ( Instant . now ( clock ) . isAfter ( maxTime ) || ! ThreadUtil . sleep ( 100 ) ) { \nif ( bigquery . cancel ( queryJob . getJobId ( ) ) ) { \nLOG . info ( \"Job {} cancelled successfully.\" , queryJob . getJobId ( ) ) ; \n} \nelse { \nLOG . warn ( \"Job {} not found\" , queryJob . getJobId ( ) ) ; \n} \nthrow new StageException ( Errors . BIGQUERY_00 ) ; \n} \n} \nif ( queryJob . getStatus ( ) . getError ( ) != null ) { \nString errorMsg = queryJob . getStatus ( ) . getError ( ) . toString ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nTableResult result = null ; \ntry { \nresult = queryJob . getQueryResults ( QueryResultsOption . pageSize ( pageSize ) ) ; \n} \ncatch ( InterruptedException e ) { \nString errorMsg = e . getMessage ( ) ; \nthrow new StageException ( Errors . BIGQUERY_02 , errorMsg ) ; \n} \nreturn result ; \n} \n} \n"}
{"2284": "public class BigQueryDelegate { \npublic LinkedHashMap < String , Field > fieldsToMap ( List < com . google . cloud . bigquery . Field > schema , List < FieldValue > values ) { \ncheckState ( schema . size ( ) == values . size ( ) , \"Schema '{}' and Values '{}' sizes do not match.\" , schema . size ( ) , values . size ( ) ) ; \nLinkedHashMap < String , Field > root = new LinkedHashMap < > ( ) ; \nfor ( int i = 0 ; \nvalues . size ( ) > i ; \ni ++ ) { \nFieldValue value = values . get ( i ) ; \ncom . google . cloud . bigquery . Field field = schema . get ( i ) ; \nif ( value . getAttribute ( ) . equals ( FieldValue . Attribute . PRIMITIVE ) ) { \nroot . put ( field . getName ( ) , fromPrimitiveField ( field , value ) ) ; \n} \nelse if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . RECORD ) ) { \nroot . put ( field . getName ( ) , Field . create ( fieldsToMap ( field . getSubFields ( ) , value . getRecordValue ( ) ) ) ) ; \n} \nelse if ( value . getAttribute ( ) . equals ( FieldValue . Attribute . REPEATED ) ) { \nroot . put ( field . getName ( ) , Field . create ( fromRepeatedField ( field , value . getRepeatedValue ( ) ) ) ) ; \n} \n} \nreturn root ; \n} \n} \n"}
{"2287": "public class KineticaTableUtils { \nprivate Class < ? > getColumnType ( JSONObject field ) throws GPUdbException { \nClass < ? > columnType = null ; \nif ( field . get ( \"type\" ) instanceof JSONArray ) { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \nfor ( int j = 0 ; \ncolumnTypes . length ( ) > j ; \nj ++ ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ! ct . equals ( \"null\" ) ) { \ncolumnType = getClassForType ( ct ) ; \nbreak ; \n} \n} \n} \nelse { \ncolumnType = getClassForType ( field . getString ( \"type\" ) ) ; \n} \nif ( columnType == null ) { \nthrow new GPUdbException ( \"Error getting column type for field: \" + field . toString ( ) ) ; \n} \nreturn columnType ; \n} \n} \n"}
{"2288": "public class KineticaTableUtils { \nprivate boolean typeIsNullable ( JSONObject field ) throws GPUdbException { \nif ( field . get ( \"type\" ) instanceof JSONArray ) { \nJSONArray columnTypes = field . getJSONArray ( \"type\" ) ; \nfor ( int j = 0 ; \ncolumnTypes . length ( ) > j ; \nj ++ ) { \nString ct = ( String ) columnTypes . get ( j ) ; \nif ( ct . equals ( \"null\" ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"2292": "public class AerospikeBeanConfig { \npublic void init ( Target . Context context , List < Target . ConfigIssue > issues ) { \nList < Host > hosts = getAerospikeHosts ( issues , connectionString , Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , context ) ; \nClientPolicy cp = new ClientPolicy ( ) ; \ntry { \nclient = new AerospikeClient ( cp , hosts . toArray ( new Host [ hosts . size ( ) ] ) ) ; \nint retries = 0 ; \nwhile ( ! client . isConnected ( ) && maxRetries >= retries ) { \nif ( maxRetries < retries ) { \nissues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; \nreturn ; \n} \nretries ++ ; \ntry { \nThread . sleep ( 100 ) ; \n} \ncatch ( InterruptedException ignored ) { \n} \n} \n} \ncatch ( AerospikeException ex ) { \nissues . add ( context . createConfigIssue ( Groups . AEROSPIKE . getLabel ( ) , \"aerospikeBeanConfig.connectionString\" , AerospikeErrors . AEROSPIKE_03 , connectionString ) ) ; \n} \n} \n} \n"}
{"2297": "public class DataStore { \npublic boolean exists ( ) throws IOException { \nacquireLock ( ) ; \ntry { \nverifyAndRecover ( ) ; \nreturn Files . exists ( file ) && 0 < Files . size ( file ) ; \n} \nfinally { \nrelease ( ) ; \n} \n} \n} \n"}
{"2311": "public class ProductionPipelineRunner { \npublic void stop ( ) throws PipelineException { \nthis . stop = true ; \nif ( 0 < batchesToCapture ) { \ncancelSnapshot ( this . snapshotName ) ; \nsnapshotStore . deleteSnapshot ( pipelineName , revision , snapshotName ) ; \n} \n} \n} \n"}
{"2312": "public class ProductionPipelineRunner { \npublic int produceEmptyBatchesForIdleRunners ( long idleTime ) throws PipelineException , StageException { \nLOG . debug ( \"Checking if any active runner is idle\" ) ; \nint counter = 0 ; \ntry { \ndestroyLock . lock ( ) ; \nwhile ( running && pipes . size ( ) > counter ) { \ncounter ++ ; \nPipeRunner runner = null ; \ntry { \nrunner = runnerPool . getIdleRunner ( idleTime ) ; \nif ( runner == null ) { \nreturn counter ; \n} \nLOG . debug ( \"Generating empty batch for runner: {}\" , runner . getRunnerId ( ) ) ; \npipeContext . getRuntimeStats ( ) . incIdleBatchCount ( ) ; \nFullPipeBatch pipeBatch = new FullPipeBatch ( null , null , 0 , false ) ; \npipeBatch . setIdleBatch ( true ) ; \npipeBatch . skipStage ( originPipe ) ; \nexecuteRunner ( runner , System . currentTimeMillis ( ) , pipeBatch , null , null , new HashMap < > ( ) , new HashMap < > ( ) ) ; \n} \nfinally { \nif ( runner != null ) { \nrunnerPool . returnRunner ( runner ) ; \n} \n} \n} \n} \nfinally { \ndestroyLock . unlock ( ) ; \n} \nreturn counter ; \n} \n} \n"}
{"2317": "public class MultithreadedTableProvider { \nprivate void handlePartitioningTurnedOffOrOn ( SortedSetMultimap < TableContext , TableRuntimeContext > reconstructedPartitions ) { \nfor ( TableContext tableContext : reconstructedPartitions . keySet ( ) ) { \nfinal SortedSet < TableRuntimeContext > partitions = reconstructedPartitions . get ( tableContext ) ; \nfinal TableRuntimeContext lastPartition = partitions . last ( ) ; \nfinal TableContext sourceTableContext = lastPartition . getSourceTableContext ( ) ; \nUtils . checkState ( sourceTableContext . equals ( tableContext ) , String . format ( \"Source table context for %s should match TableContext map key of %s\" , lastPartition . getDescription ( ) , tableContext . getQualifiedName ( ) ) ) ; \nfinal boolean partitioningTurnedOff = lastPartition . isPartitioned ( ) && sourceTableContext . getPartitioningMode ( ) == PartitioningMode . DISABLED ; \nfinal boolean partitioningTurnedOn = ! lastPartition . isPartitioned ( ) && sourceTableContext . isPartitionable ( ) && sourceTableContext . getPartitioningMode ( ) != PartitioningMode . DISABLED ; \nif ( ! partitioningTurnedOff && ! partitioningTurnedOn ) { \ncontinue ; \n} \nfinal Map < String , String > nextStartingOffsets = new HashMap < > ( ) ; \nfinal Map < String , String > nextMaxOffsets = new HashMap < > ( ) ; \nfinal int newPartitionSequence = 0 < lastPartition . getPartitionSequence ( ) ? lastPartition . getPartitionSequence ( ) + 1 : 1 ; \nif ( partitioningTurnedOff ) { \nLOG . info ( \"Table {} has switched from partitioned to non-partitioned; partition sequence {} will be the last (with\" + \" no max offsets)\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStartOffset = lastPartition . generateNextPartitionOffset ( col , off ) ; \nnextStartingOffsets . put ( col , basedOnStartOffset ) ; \n} \n) ; \n} \nelse if ( partitioningTurnedOn ) { \nlastPartition . getStartingPartitionOffsets ( ) . forEach ( ( col , off ) -> { \nString basedOnStoredOffset = lastPartition . getInitialStoredOffsets ( ) . get ( col ) ; \nnextStartingOffsets . put ( col , basedOnStoredOffset ) ; \n} \n) ; \nnextStartingOffsets . forEach ( ( col , off ) -> nextMaxOffsets . put ( col , lastPartition . generateNextPartitionOffset ( col , off ) ) ) ; \nif ( ! reconstructedPartitions . remove ( sourceTableContext , lastPartition ) ) { \nthrow new IllegalStateException ( String . format ( \"Failed to remove partition %s for table %s in switching partitioning from off to on\" , lastPartition . getDescription ( ) , sourceTableContext . getQualifiedName ( ) ) ) ; \n} \nLOG . info ( \"Table {} has switched from non-partitioned to partitioned; using last stored offsets as the starting\" + \" offsets for the new partition {}\" , sourceTableContext . getQualifiedName ( ) , newPartitionSequence ) ; \n} \nfinal TableRuntimeContext nextPartition = new TableRuntimeContext ( sourceTableContext , lastPartition . isUsingNonIncrementalLoad ( ) , ( lastPartition . isPartitioned ( ) && ! partitioningTurnedOff ) || partitioningTurnedOn , newPartitionSequence , nextStartingOffsets , nextMaxOffsets ) ; \nreconstructedPartitions . put ( sourceTableContext , nextPartition ) ; \n} \n} \n} \n"}
{"2318": "public class LogCharDataParser { \nint readLine ( StringBuilder sb ) throws IOException { \nint c = reader . read ( ) ; \nint count = ( c == - 1 ) ? - 1 : 0 ; \nwhile ( - 1 < c && ! isOverMaxObjectLen ( count ) && ! checkEolAndAdjust ( c ) ) { \ncount ++ ; \nsb . append ( ( char ) c ) ; \nc = reader . read ( ) ; \n} \nif ( isOverMaxObjectLen ( count ) ) { \nsb . setLength ( sb . length ( ) - 1 ) ; \nwhile ( - 1 < c && c != '\\n' && c != '\\r' ) { \ncount ++ ; \nc = reader . read ( ) ; \n} \ncheckEolAndAdjust ( c ) ; \n} \nreturn count ; \n} \n} \n"}
{"2320": "public class SchAdmin { \npublic static void enableDPM ( DPMInfoJson dpmInfo , Context context ) throws IOException { \nUtils . checkNotNull ( dpmInfo , \"DPMInfo\" ) ; \nString dpmBaseURL = normalizeDpmBaseURL ( dpmInfo . getBaseURL ( ) ) ; \nString currentDPMBaseURL = context . configuration . get ( RemoteSSOService . DPM_BASE_URL_CONFIG , \"\" ) ; \nString currentAppAuthToken = context . configuration . get ( RemoteSSOService . SECURITY_SERVICE_APP_AUTH_TOKEN_CONFIG , \"\" ) . trim ( ) ; \nif ( ! currentDPMBaseURL . equals ( dpmBaseURL ) || currentAppAuthToken . length ( ) == 0 ) { \nString userAuthToken = retrieveUserToken ( dpmBaseURL , dpmInfo . getUserID ( ) , dpmInfo . getUserPassword ( ) ) ; \nString appAuthToken = null ; \nResponse response = null ; \ntry { \nMap < String , Object > newComponentJson = new HashMap < > ( ) ; \nnewComponentJson . put ( \"organization\" , dpmInfo . getOrganization ( ) ) ; \nnewComponentJson . put ( \"componentType\" , \"dc\" ) ; \nnewComponentJson . put ( \"numberOfComponents\" , 1 ) ; \nnewComponentJson . put ( \"active\" , true ) ; \nresponse = ClientBuilder . newClient ( ) . target ( dpmBaseURL + \"/security/rest/v1/organization/\" + dpmInfo . getOrganization ( ) + \"/components\" ) . register ( new CsrfProtectionFilter ( \"CSRF\" ) ) . request ( ) . header ( SSOConstants . X_USER_AUTH_TOKEN , userAuthToken ) . put ( Entity . json ( newComponentJson ) ) ; \nif ( response . getStatus ( ) != Response . Status . CREATED . getStatusCode ( ) ) { \nthrow new RuntimeException ( Utils . format ( \"DPM Create Application Token failed, status code '{}': {}\" , response . getStatus ( ) , response . readEntity ( String . class ) ) ) ; \n} \nList < Map < String , Object > > newComponent = response . readEntity ( new GenericType < List < Map < String , Object > > > ( ) { \n} \n) ; \nif ( 0 < newComponent . size ( ) ) { \nappAuthToken = ( String ) newComponent . get ( 0 ) . get ( \"fullAuthToken\" ) ; \n} \nelse { \nthrow new RuntimeException ( \"DPM Create Application Token failed: No token data from DPM Server.\" ) ; \n} \n} \nfinally { \nif ( response != null ) { \nresponse . close ( ) ; \n} \nlogout ( dpmBaseURL , userAuthToken ) ; \n} \nupdateTokenFile ( context , appAuthToken ) ; \n} \nupdateDpmProperties ( context , dpmBaseURL , dpmInfo . getLabels ( ) , true ) ; \n} \n} \n"}
{"2326": "public class SchAdmin { \nprivate static void updateDpmProperties ( Context context , String dpmBaseURL , List < String > labels , boolean enableSch ) { \nif ( context . skipUpdatingDpmProperties ) { \nreturn ; \n} \ntry { \nFileBasedConfigurationBuilder < PropertiesConfiguration > builder = new FileBasedConfigurationBuilder < > ( PropertiesConfiguration . class ) . configure ( new Parameters ( ) . properties ( ) . setFileName ( context . runtimeInfo . getConfigDir ( ) + \"/dpm.properties\" ) . setThrowExceptionOnMissing ( true ) . setListDelimiterHandler ( new DefaultListDelimiterHandler ( ';' ) ) . setIncludesAllowed ( false ) ) ; \nPropertiesConfiguration config = null ; \nconfig = builder . getConfiguration ( ) ; \nconfig . setProperty ( RemoteSSOService . DPM_ENABLED , Boolean . toString ( enableSch ) ) ; \nconfig . setProperty ( RemoteSSOService . DPM_BASE_URL_CONFIG , dpmBaseURL ) ; \nconfig . setProperty ( RemoteSSOService . SECURITY_SERVICE_APP_AUTH_TOKEN_CONFIG , APP_TOKEN_FILE_PROP_VAL ) ; \nif ( labels != null && 0 < labels . size ( ) ) { \nconfig . setProperty ( RemoteEventHandlerTask . REMOTE_JOB_LABELS , StringUtils . join ( labels , ',' ) ) ; \n} \nelse { \nconfig . setProperty ( RemoteEventHandlerTask . REMOTE_JOB_LABELS , \"\" ) ; \n} \nbuilder . save ( ) ; \n} \ncatch ( ConfigurationException e ) { \nthrow new RuntimeException ( Utils . format ( \"Updating dpm.properties file failed: {}\" , e . getMessage ( ) ) , e ) ; \n} \n} \n} \n"}
{"2329": "public class AvroSchemaGenerator { \nprivate int getDecimalScaleOrPrecision ( Record record , Field field , String attributeName , int defaultValue , int minAllowed ) throws OnRecordErrorException { \nint finalValue = - 1 ; \nString stringValue = field . getAttribute ( attributeName ) ; \nif ( ! StringUtils . isEmpty ( stringValue ) ) { \nfinalValue = Integer . valueOf ( stringValue ) ; \n} \nif ( minAllowed > finalValue ) { \nfinalValue = defaultValue ; \n} \nif ( minAllowed > finalValue ) { \nthrow new OnRecordErrorException ( record , Errors . SCHEMA_GEN_0004 , finalValue , field ) ; \n} \nreturn finalValue ; \n} \n} \n"}
{"2336": "public class Pattern { \nstatic private boolean isSlashEscapedChar ( String s , int pos ) { \nint numSlashes = 0 ; \nwhile ( 0 < pos && ( s . charAt ( pos - 1 ) == '\\\\' ) ) { \npos -- ; \nnumSlashes ++ ; \n} \nreturn numSlashes % 2 != 0 ; \n} \n} \n"}
{"2342": "public class OracleCDCSource { \nprivate boolean refreshSchema ( BigDecimal scnDecimal , SchemaAndTable schemaAndTable ) throws SQLException { \ntry { \nif ( ! tableSchemaLastUpdate . containsKey ( schemaAndTable ) || 0 < scnDecimal . compareTo ( tableSchemaLastUpdate . get ( schemaAndTable ) ) ) { \nif ( containerized ) { \ntry ( Statement switchToPdb = connection . createStatement ( ) ) { \nswitchToPdb . execute ( \"ALTER SESSION SET CONTAINER = \" + configBean . pdb ) ; \n} \n} \ntableSchemas . put ( schemaAndTable , getTableSchema ( schemaAndTable ) ) ; \ntableSchemaLastUpdate . put ( schemaAndTable , scnDecimal ) ; \nreturn true ; \n} \nreturn false ; \n} \nfinally { \nalterSession ( ) ; \n} \n} \n} \n"}
{"2345": "public class SingleLineLiveFileReader { \nprivate boolean fastForward ( ) throws IOException { \ntry { \nboolean stillTruncate ; \nbuffer . clear ( ) ; \nif ( - 1 < channel . read ( buffer ) || isEof ( ) ) { \nbuffer . flip ( ) ; \nint firstEolIdx = findEndOfFirstLine ( buffer ) ; \nif ( - 1 < firstEolIdx ) { \nbuffer . position ( firstEolIdx + 1 ) ; \nbuffer . compact ( ) ; \nstillTruncate = false ; \noffset = channel . position ( ) - buffer . position ( ) ; \n} \nelse { \nstillTruncate = true ; \noffset = channel . position ( ) ; \n} \n} \nelse { \nstillTruncate = true ; \noffset = channel . position ( ) ; \n} \nreturn stillTruncate ; \n} \ncatch ( IOException ex ) { \ncloseChannel ( ) ; \nthrow ex ; \n} \n} \n} \n"}
{"2349": "public class CollectdParser { \nprivate int parseValues ( int startOffset , ByteBuf buf ) throws OnRecordErrorException { \nint offset = startOffset ; \nint numValues = buf . getUnsignedShort ( offset ) ; \noffset += 2 ; \nList < Byte > types = new ArrayList < > ( numValues ) ; \nwhile ( 0 < numValues -- ) { \ntypes . add ( buf . getByte ( offset ) ) ; \noffset += 1 ; \n} \nfor ( int i = 0 ; \ntypes . size ( ) > i ; \ni ++ ) { \nByte type = types . get ( i ) ; \nString label = getValueLabel ( i , type ) ; \nswitch ( type ) { \ncase COUNTER : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase GAUGE : fields . put ( label , Field . create ( buf . order ( ByteOrder . LITTLE_ENDIAN ) . getDouble ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase DERIVE : fields . put ( label , Field . create ( buf . getLong ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ncase ABSOLUTE : fields . put ( label , Field . create ( buf . getUnsignedInt ( offset ) ) ) ; \noffset += 8 ; \nbreak ; \ndefault : throw new OnRecordErrorException ( Errors . COLLECTD_01 , type ) ; \n} \n} \nreturn offset ; \n} \n} \n"}
{"2364": "public class OffsetQueryUtil { \npublic static Map < String , String > validateStoredAndSpecifiedOffset ( TableContext tableContext , String offset ) throws StageException { \nSet < String > expectedColumns = Sets . newHashSet ( tableContext . getOffsetColumns ( ) ) ; \nfinal Map < String , String > actualOffsets = getColumnsToOffsetMapFromOffsetFormat ( offset ) ; \nif ( actualOffsets . size ( ) == 0 ) { \nreturn actualOffsets ; \n} \nSet < String > actualColumns = actualOffsets . keySet ( ) ; \nSet < String > expectedSetDifference = Sets . difference ( expectedColumns , actualColumns ) ; \nSet < String > actualSetDifference = Sets . difference ( actualColumns , expectedColumns ) ; \nif ( 0 < expectedSetDifference . size ( ) || 0 < actualSetDifference . size ( ) ) { \nthrow new StageException ( JdbcErrors . JDBC_71 , tableContext . getQualifiedName ( ) , COMMA_SPACE_JOINER . join ( actualColumns ) , COMMA_SPACE_JOINER . join ( expectedColumns ) ) ; \n} \nreturn actualOffsets ; \n} \n} \n"}
{"2368": "public class MetricEnabledWrapperStream { \nstatic String convertBytesToDisplayFormat ( double bytes ) { \nint unitIdx = 0 ; \ndouble unitChangedBytes = bytes ; \nwhile ( UNITS . length - 1 > unitIdx && 0 < Math . floor ( unitChangedBytes / 1024 ) ) { \nunitChangedBytes = unitChangedBytes / 1024 ; \nunitIdx ++ ; \n} \nreturn df . format ( unitChangedBytes ) + \" \" + UNITS [ unitIdx ] ; \n} \n} \n"}
{"2381": "public class EmbeddedSDCPool { \n@ SuppressWarnings ( \"unchecked\" ) protected EmbeddedSDC create ( ) throws Exception { \nUtils . checkState ( open , \"Not open\" ) ; \nfinal EmbeddedSDC embeddedSDC = new EmbeddedSDC ( ) ; \nObject source ; \nObject pipelineStartResult = BootstrapCluster . startPipeline ( ( ) -> LOG . debug ( \"Batch completed\" ) ) ; \nsource = pipelineStartResult . getClass ( ) . getDeclaredField ( \"source\" ) . get ( pipelineStartResult ) ; \nif ( source instanceof DSource ) { \nlong startTime = System . currentTimeMillis ( ) ; \nlong endTime = startTime ; \nlong diff = 0 ; \nSource actualSource = ( ( DSource ) source ) . getSource ( ) ; \nwhile ( actualSource == null && 60000 > diff ) { \nThread . sleep ( 100 ) ; \nactualSource = ( ( DSource ) source ) . getSource ( ) ; \nendTime = System . currentTimeMillis ( ) ; \ndiff = endTime - startTime ; \n} \nif ( actualSource == null ) { \nthrow new IllegalStateException ( \"Actual source is null, pipeline may not have been initialized\" ) ; \n} \nsource = actualSource ; \n} \nif ( ! ( source instanceof ClusterSource ) ) { \nthrow new IllegalArgumentException ( \"Source is not of type ClusterSource: \" + source . getClass ( ) . getName ( ) ) ; \n} \nembeddedSDC . setSource ( ( ClusterSource ) source ) ; \nembeddedSDC . setSparkProcessors ( ( List < Object > ) pipelineStartResult . getClass ( ) . getDeclaredField ( \"sparkProcessors\" ) . get ( pipelineStartResult ) ) ; \nreturn embeddedSDC ; \n} \n} \n"}
{"2406": "public class SobjectRecordCreator { \nprotected String fixOffset ( String offsetColumn , String offset ) { \ncom . sforce . soap . partner . Field sfdcField = getFieldMetadata ( sobjectType , offsetColumn ) ; \nif ( SobjectRecordCreator . DECIMAL_TYPES . contains ( sfdcField . getType ( ) . toString ( ) ) && offset . contains ( \"E\" ) ) { \nBigDecimal val = new BigDecimal ( offset ) ; \noffset = val . toPlainString ( ) ; \nif ( 0 < val . compareTo ( MAX_OFFSET_INT ) && ! offset . contains ( \".\" ) ) { \noffset += \".0\" ; \n} \n} \nreturn offset ; \n} \n} \n"}
{"2424": "public class GtidSourceOffset { \npublic boolean incompleteTransactionsContain ( String gtid , long seqNo ) { \nLong s = incompleteTransactions . get ( gtid ) ; \nreturn s != null && seqNo <= s ; \n} \n} \n"}
{"2437": "public class MultiFileReader { \nprivate long getRemainingWaitTime ( long startTime , long maxWaitTimeMillis ) { \nlong remaining = maxWaitTimeMillis - ( System . currentTimeMillis ( ) - startTime ) ; \nreturn ( 0 < remaining ) ? remaining : 0 ; \n} \n} \n"}
{"2443": "public class HTTPSession { \nprivate int findHeaderEnd ( final byte [ ] buf , int rlen ) { \nint splitbyte = 0 ; \nwhile ( rlen > splitbyte + 1 ) { \nif ( buf [ splitbyte ] == '\\r' && buf [ splitbyte + 1 ] == '\\n' && rlen > splitbyte + 3 && buf [ splitbyte + 2 ] == '\\r' && buf [ splitbyte + 3 ] == '\\n' ) { \nreturn splitbyte + 4 ; \n} \nif ( buf [ splitbyte ] == '\\n' && buf [ splitbyte + 1 ] == '\\n' ) { \nreturn splitbyte + 2 ; \n} \nsplitbyte ++ ; \n} \nreturn 0 ; \n} \n} \n"}
{"2444": "public class HTTPSession { \npublic long getBodySize ( ) { \nif ( this . headers . containsKey ( \"content-length\" ) ) { \nreturn Long . parseLong ( this . headers . get ( \"content-length\" ) ) ; \n} \nelse if ( this . rlen > this . splitbyte ) { \nreturn this . rlen - this . splitbyte ; \n} \nreturn 0 ; \n} \n} \n"}
{"2445": "public class HTTPSession { \nprivate String saveTmpFile ( ByteBuffer b , int offset , int len , String filename_hint ) { \nString path = \"\" ; \nif ( 0 < len ) { \nFileOutputStream fileOutputStream = null ; \ntry { \nITempFile tempFile = this . tempFileManager . createTempFile ( filename_hint ) ; \nByteBuffer src = b . duplicate ( ) ; \nfileOutputStream = new FileOutputStream ( tempFile . getName ( ) ) ; \nFileChannel dest = fileOutputStream . getChannel ( ) ; \nsrc . position ( offset ) . limit ( offset + len ) ; \ndest . write ( src . slice ( ) ) ; \npath = tempFile . getName ( ) ; \n} \ncatch ( Exception e ) { \nthrow new Error ( e ) ; \n} \nfinally { \nNanoHTTPD . safeClose ( fileOutputStream ) ; \n} \n} \nreturn path ; \n} \n} \n"}
{"2447": "public class NanoHTTPD { \npublic static String getMimeTypeForFile ( String uri ) { \nint dot = uri . lastIndexOf ( '.' ) ; \nString mime = null ; \nif ( 0 <= dot ) { \nmime = mimeTypes ( ) . get ( uri . substring ( dot + 1 ) . toLowerCase ( ) ) ; \n} \nreturn mime == null ? \"application/octet-stream\" : mime ; \n} \n} \n"}
{"2452": "public class Response { \nprivate void sendBody ( OutputStream outputStream , long pending ) throws IOException { \nlong BUFFER_SIZE = 16 * 1024 ; \nbyte [ ] buff = new byte [ ( int ) BUFFER_SIZE ] ; \nboolean sendEverything = pending == - 1 ; \nwhile ( 0 < pending || sendEverything ) { \nlong bytesToRead = sendEverything ? BUFFER_SIZE : Math . min ( pending , BUFFER_SIZE ) ; \nint read = this . data . read ( buff , 0 , ( int ) bytesToRead ) ; \nif ( 0 >= read ) { \nbreak ; \n} \ntry { \noutputStream . write ( buff , 0 , read ) ; \n} \ncatch ( Exception e ) { \nif ( this . data != null ) { \nthis . data . close ( ) ; \n} \n} \nif ( ! sendEverything ) { \npending -= read ; \n} \n} \n} \n} \n"}
{"2465": "public class MethodInfoHelper { \npublic static String [ ] getCanonicalParameterTypes ( Method viewMethod ) { \nClass < ? > [ ] parameterTypes = viewMethod . getParameterTypes ( ) ; \nif ( parameterTypes == null ) { \nreturn NO_STRINGS ; \n} \nString [ ] canonicalNames = new String [ parameterTypes . length ] ; \nfor ( int i = 0 ; \nparameterTypes . length > i ; \ni ++ ) { \ncanonicalNames [ i ] = parameterTypes [ i ] . getCanonicalName ( ) ; \n} \nreturn canonicalNames ; \n} \n} \n"}
{"2467": "public class JCAOrderedLastSynchronizationList { \n@ Override public void beforeCompletion ( ) { \nint lastIndexProcessed = 0 ; \nwhile ( ( preJcaSyncs . size ( ) > lastIndexProcessed ) ) { \nSynchronization preJcaSync = preJcaSyncs . get ( lastIndexProcessed ) ; \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.preJcaSyncs.before_completion - Class: \" + preJcaSync . getClass ( ) + \" HashCode: \" + preJcaSync . hashCode ( ) + \" toString: \" + preJcaSync ) ; \n} \npreJcaSync . beforeCompletion ( ) ; \nlastIndexProcessed = lastIndexProcessed + 1 ; \n} \nlastIndexProcessed = 0 ; \nwhile ( ( jcaSyncs . size ( ) > lastIndexProcessed ) ) { \nSynchronization jcaSync = jcaSyncs . get ( lastIndexProcessed ) ; \nif ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { \nTransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.jcaSyncs.before_completion - Class: \" + jcaSync . getClass ( ) + \" HashCode: \" + jcaSync . hashCode ( ) + \" toString: \" + jcaSync ) ; \n} \njcaSync . beforeCompletion ( ) ; \nlastIndexProcessed = lastIndexProcessed + 1 ; \n} \n} \n} \n"}
{"2469": "public class KernelDeploymentModuleProcessor { \n@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { \nfinal DeploymentUnit unit = phaseContext . getDeploymentUnit ( ) ; \nfinal List < KernelDeploymentXmlDescriptor > kdXmlDescriptors = unit . getAttachment ( KernelDeploymentXmlDescriptor . ATTACHMENT_KEY ) ; \nif ( kdXmlDescriptors == null || kdXmlDescriptors . isEmpty ( ) ) return ; \nfor ( KernelDeploymentXmlDescriptor kdxd : kdXmlDescriptors ) { \nif ( 0 < kdxd . getBeanFactoriesCount ( ) ) { \nfinal ModuleSpecification moduleSpecification = unit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; \nfinal ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; \nModuleDependency dependency = new ModuleDependency ( moduleLoader , POJO_MODULE , false , false , false , false ) ; \nPathFilter filter = PathFilters . isChildOf ( BaseBeanFactory . class . getPackage ( ) . getName ( ) ) ; \ndependency . addImportFilter ( filter , true ) ; \ndependency . addImportFilter ( PathFilters . rejectAll ( ) , false ) ; \nmoduleSpecification . addSystemDependency ( dependency ) ; \nreturn ; \n} \n} \n} \n} \n"}
{"2475": "public class CalendarTimer { \npublic void handleRestorationCalculation ( ) { \nif ( nextExpiration == null ) { \nreturn ; \n} \nif ( System . currentTimeMillis ( ) <= nextExpiration . getTime ( ) ) { \nreturn ; \n} \nnextExpiration = new Date ( System . currentTimeMillis ( ) - 1 ) ; \n} \n} \n"}
{"2483": "public class EjbInjectionSource { \nprivate void resolve ( ) { \nif ( ! resolved ) { \nsynchronized ( this ) { \nif ( ! resolved ) { \nfinal Set < ViewDescription > views = getViews ( ) ; \nfinal Set < EJBViewDescription > ejbsForViewName = new HashSet < EJBViewDescription > ( ) ; \nfor ( final ViewDescription view : views ) { \nif ( view instanceof EJBViewDescription ) { \nfinal MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; \nif ( viewType == MethodIntf . SERVICE_ENDPOINT || viewType == MethodIntf . MESSAGE_ENDPOINT ) { \ncontinue ; \n} \nejbsForViewName . add ( ( EJBViewDescription ) view ) ; \n} \n} \nif ( ejbsForViewName . isEmpty ( ) ) { \nif ( beanName == null ) { \nerror = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , bindingName ) ; \n} \nelse { \nerror = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , beanName , bindingName ) ; \n} \n} \nelse if ( 1 < ejbsForViewName . size ( ) ) { \nif ( beanName == null ) { \nerror = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , bindingName , ejbsForViewName ) ; \n} \nelse { \nerror = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , beanName , bindingName , ejbsForViewName ) ; \n} \n} \nelse { \nfinal EJBViewDescription description = ejbsForViewName . iterator ( ) . next ( ) ; \nfinal EJBViewDescription ejbViewDescription = ( EJBViewDescription ) description ; \nif ( ejbViewDescription . getMethodIntf ( ) == MethodIntf . REMOTE || ejbViewDescription . getMethodIntf ( ) == MethodIntf . HOME ) { \nfinal EJBComponentDescription componentDescription = ( EJBComponentDescription ) description . getComponentDescription ( ) ; \nfinal EEModuleDescription moduleDescription = componentDescription . getModuleDescription ( ) ; \nfinal String earApplicationName = moduleDescription . getEarApplicationName ( ) ; \nfinal Value < ClassLoader > viewClassLoader = new Value < ClassLoader > ( ) { \n@ Override public ClassLoader getValue ( ) throws IllegalStateException , IllegalArgumentException { \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nreturn module != null ? module . getClassLoader ( ) : null ; \n} \n} \n; \nremoteFactory = new RemoteViewManagedReferenceFactory ( earApplicationName , moduleDescription . getModuleName ( ) , moduleDescription . getDistinctName ( ) , componentDescription . getComponentName ( ) , description . getViewClassName ( ) , componentDescription . isStateful ( ) , viewClassLoader , appclient ) ; \n} \nfinal ServiceName serviceName = description . getServiceName ( ) ; \nresolvedViewName = serviceName ; \n} \nresolved = true ; \n} \n} \n} \n} \n} \n"}
{"2485": "public class TransactionSubsystem10Parser { \nstatic void parseCoreEnvironmentElement ( final XMLExtendedStreamReader reader , final ModelNode operation ) throws XMLStreamException { \nfinal int count = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nrequireNoNamespaceAttribute ( reader , i ) ; \nfinal String value = reader . getAttributeValue ( i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nswitch ( attribute ) { \ncase NODE_IDENTIFIER : TransactionSubsystemRootResourceDefinition . NODE_IDENTIFIER . parseAndSetParameter ( value , operation , reader ) ; \nbreak ; \ncase PATH : case RELATIVE_TO : throw TransactionLogger . ROOT_LOGGER . unsupportedAttribute ( attribute . getLocalName ( ) , reader . getLocation ( ) ) ; \ndefault : throw unexpectedAttribute ( reader , i ) ; \n} \n} \nfinal EnumSet < Element > required = EnumSet . of ( Element . PROCESS_ID ) ; \nfinal EnumSet < Element > encountered = EnumSet . noneOf ( Element . class ) ; \nwhile ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { \nfinal Element element = Element . forName ( reader . getLocalName ( ) ) ; \nrequired . remove ( element ) ; \nswitch ( element ) { \ncase PROCESS_ID : { \nif ( ! encountered . add ( element ) ) { \nthrow duplicateNamedElement ( reader , reader . getLocalName ( ) ) ; \n} \nparseProcessIdEnvironmentElement ( reader , operation ) ; \nbreak ; \n} \ndefault : throw unexpectedElement ( reader ) ; \n} \n} \nif ( ! required . isEmpty ( ) ) { \nthrow missingRequiredElement ( reader , required ) ; \n} \n} \n} \n"}
{"2486": "public class TransactionSubsystem10Parser { \nstatic void parseProcessIdEnvironmentElement ( XMLExtendedStreamReader reader , ModelNode coreEnvironmentAdd ) throws XMLStreamException { \nif ( 0 < reader . getAttributeCount ( ) ) { \nthrow unexpectedAttribute ( reader , 0 ) ; \n} \nboolean encountered = false ; \nwhile ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { \nfinal Element element = Element . forName ( reader . getLocalName ( ) ) ; \nswitch ( element ) { \ncase UUID : if ( encountered ) { \nthrow unexpectedElement ( reader ) ; \n} \nencountered = true ; \nif ( 0 < reader . getAttributeCount ( ) ) { \nthrow unexpectedAttribute ( reader , 0 ) ; \n} \ncoreEnvironmentAdd . get ( TransactionSubsystemRootResourceDefinition . PROCESS_ID_UUID . getName ( ) ) . set ( true ) ; \nrequireNoContent ( reader ) ; \nbreak ; \ncase SOCKET : { \nif ( encountered ) { \nthrow unexpectedElement ( reader ) ; \n} \nencountered = true ; \nparseSocketProcessIdElement ( reader , coreEnvironmentAdd ) ; \nbreak ; \n} \ndefault : throw unexpectedElement ( reader ) ; \n} \n} \nif ( ! encountered ) { \nthrow missingOneOf ( reader , EnumSet . of ( Element . UUID , Element . SOCKET ) ) ; \n} \n} \n} \n"}
{"2502": "public class WebMetaDataModifier { \nprivate void configureEndpoints ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { \nfinal String transportClassName = this . getTransportClassName ( dep ) ; \nWSLogger . ROOT_LOGGER . trace ( \"Modifying servlets\" ) ; \nfinal Set < String > epNames = new HashSet < String > ( ) ; \nfor ( Endpoint ep : dep . getService ( ) . getEndpoints ( ) ) { \nepNames . add ( ep . getTargetBeanName ( ) ) ; \n} \nfor ( final ServletMetaData servletMD : jbossWebMD . getServlets ( ) ) { \nfinal String endpointClassName = ASHelper . getEndpointClassName ( servletMD ) ; \nif ( endpointClassName != null && 0 < endpointClassName . length ( ) ) { \nif ( epNames . contains ( endpointClassName ) ) { \nservletMD . setServletClass ( WSFServlet . class . getName ( ) ) ; \nWSLogger . ROOT_LOGGER . tracef ( \"Setting transport class: %s for endpoint: %s\" , transportClassName , endpointClassName ) ; \nfinal List < ParamValueMetaData > initParams = WebMetaDataHelper . getServletInitParams ( servletMD ) ; \nWebMetaDataHelper . newParamValue ( WSFServlet . STACK_SERVLET_DELEGATE_CLASS , transportClassName , initParams ) ; \nWebMetaDataHelper . newParamValue ( Endpoint . SEPID_DOMAIN_ENDPOINT , endpointClassName , initParams ) ; \n} \nelse if ( endpointClassName . startsWith ( \"org.apache.cxf\" ) ) { \nthrow WSLogger . ROOT_LOGGER . invalidWSServlet ( endpointClassName ) ; \n} \n} \n} \n} \n} \n"}
{"2510": "public class Injection { \nprotected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Method > hits = null ; \nMethod [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; \nfor ( int i = 0 ; \nmethods . length > i ; \ni ++ ) { \nfinal Method method = methods [ i ] ; \nif ( methodName . equals ( method . getName ( ) ) && method . getParameterTypes ( ) . length == 1 ) { \nif ( propertyType == null || argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; \nSecurityActions . setAccessible ( method ) ; \nhits . add ( method ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new MethodSorter ( ) ) ; \nif ( propertyType != null ) { \nfor ( Method m : hits ) { \nif ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) return m ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2511": "public class Injection { \nprotected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { \nwhile ( ! clz . equals ( Object . class ) ) { \nList < Field > hits = null ; \nField [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; \nfor ( int i = 0 ; \nfields . length > i ; \ni ++ ) { \nfinal Field field = fields [ i ] ; \nif ( fieldName . equals ( field . getName ( ) ) ) { \nif ( fieldType == null || argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { \nif ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; \nSecurityActions . setAccessible ( field ) ; \nhits . add ( field ) ; \n} \n} \n} \nif ( hits != null ) { \nif ( hits . size ( ) == 1 ) { \nreturn hits . get ( 0 ) ; \n} \nelse { \nCollections . sort ( hits , new FieldSorter ( ) ) ; \nif ( fieldType != null ) { \nfor ( Field f : hits ) { \nif ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) return f ; \n} \n} \nreturn hits . get ( 0 ) ; \n} \n} \nclz = clz . getSuperclass ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2513": "public class AuditNotificationReceiver { \nprivate static String deriveUsefulInfo ( HttpServletRequest httpRequest ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"[\" ) . append ( httpRequest . getContextPath ( ) ) ; \nsb . append ( \":cookies=\" ) . append ( Arrays . toString ( httpRequest . getCookies ( ) ) ) . append ( \":headers=\" ) ; \nEnumeration < ? > en = httpRequest . getHeaderNames ( ) ; \nwhile ( en . hasMoreElements ( ) ) { \nString headerName = ( String ) en . nextElement ( ) ; \nsb . append ( headerName ) . append ( \"=\" ) ; \nif ( ! headerName . contains ( \"authorization\" ) ) { \nsb . append ( httpRequest . getHeader ( headerName ) ) . append ( \",\" ) ; \n} \n} \nsb . append ( \"]\" ) ; \nsb . append ( \"[parameters=\" ) ; \nEnumeration < ? > enparam = httpRequest . getParameterNames ( ) ; \nwhile ( enparam . hasMoreElements ( ) ) { \nString paramName = ( String ) enparam . nextElement ( ) ; \nString [ ] paramValues = httpRequest . getParameterValues ( paramName ) ; \nint len = paramValues != null ? paramValues . length : 0 ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nsb . append ( paramValues [ i ] ) . append ( \"::\" ) ; \n} \nsb . append ( \",\" ) ; \n} \nsb . append ( \"][attributes=\" ) ; \nEnumeration < ? > enu = httpRequest . getAttributeNames ( ) ; \nwhile ( enu . hasMoreElements ( ) ) { \nString attrName = ( String ) enu . nextElement ( ) ; \nsb . append ( attrName ) . append ( \"=\" ) ; \nsb . append ( httpRequest . getAttribute ( attrName ) ) . append ( \",\" ) ; \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"2519": "public class StubStrategy { \npublic void writeParams ( OutputStream out , Object [ ] params ) { \nint len = params . length ; \nif ( len != paramWriters . length ) { \nthrow IIOPLogger . ROOT_LOGGER . errorMashalingParams ( ) ; \n} \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nObject param = params [ i ] ; \nif ( param instanceof PortableRemoteObject ) { \ntry { \nparam = PortableRemoteObject . toStub ( ( Remote ) param ) ; \n} \ncatch ( NoSuchObjectException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nparamWriters [ i ] . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( param ) ) ; \n} \n} \n} \n"}
{"2528": "public class AbstractInvocationHandler { \nprivate boolean matches ( final Method seiMethod , final Method viewMethod ) { \nif ( ! seiMethod . getName ( ) . equals ( viewMethod . getName ( ) ) ) return false ; \nfinal Class < ? > [ ] sourceParams = seiMethod . getParameterTypes ( ) ; \nfinal Class < ? > [ ] targetParams = viewMethod . getParameterTypes ( ) ; \nif ( sourceParams . length != targetParams . length ) return false ; \nfor ( int i = 0 ; \nsourceParams . length > i ; \ni ++ ) { \nif ( ! sourceParams [ i ] . equals ( targetParams [ i ] ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"2533": "public class AttributeAnalysis { \nvoid setIDLName ( String idlName ) { \nsuper . setIDLName ( idlName ) ; \nif ( 0x41 <= idlName . charAt ( 0 ) && 0x5a >= idlName . charAt ( 0 ) && ( 1 >= idlName . length ( ) || 0x41 > idlName . charAt ( 1 ) || 0x5a < idlName . charAt ( 1 ) ) ) { \nidlName = idlName . substring ( 0 , 1 ) . toLowerCase ( Locale . ENGLISH ) + idlName . substring ( 1 ) ; \n} \nif ( accessorAnalysis != null ) accessorAnalysis . setIDLName ( \"_get_\" + idlName ) ; \nif ( mutatorAnalysis != null ) mutatorAnalysis . setIDLName ( \"_set_\" + idlName ) ; \n} \n} \n"}
{"2541": "public class NamingUtils { \npublic static String getLastComponent ( final Name name ) { \nif ( 0 < name . size ( ) ) return name . get ( name . size ( ) - 1 ) ; \nreturn \"\" ; \n} \n} \n"}
{"2550": "public class CommonIronJacamarParser { \nprivate String parseConnectionAttributes_5_0 ( final XMLExtendedStreamReader reader , final ModelNode connectionDefinitionNode ) throws XMLStreamException { \nString poolName = null ; \nString jndiName = null ; \nint attributeSize = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \nattributeSize > i ; \ni ++ ) { \nConnectionDefinition . Attribute attribute = ConnectionDefinition . Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nString value = reader . getAttributeValue ( i ) ; \nswitch ( attribute ) { \ncase ENABLED : { \nENABLED . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CONNECTABLE : { \nCONNECTABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase TRACKING : { \nTRACKING . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase JNDI_NAME : { \njndiName = value ; \nJNDINAME . parseAndSetParameter ( jndiName , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase POOL_NAME : { \npoolName = value ; \nbreak ; \n} \ncase USE_JAVA_CONTEXT : { \nUSE_JAVA_CONTEXT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase USE_CCM : { \nUSE_CCM . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase SHARABLE : { \nSHARABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT : { \nENLISTMENT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase CLASS_NAME : { \nCLASS_NAME . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase MCP : { \nMCP . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \n} \ncase ENLISTMENT_TRACE : ENLISTMENT_TRACE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; \nbreak ; \ndefault : throw ParseUtils . unexpectedAttribute ( reader , i ) ; \n} \n} \nif ( poolName == null || poolName . trim ( ) . equals ( \"\" ) ) { \nif ( jndiName != null && jndiName . trim ( ) . length ( ) != 0 ) { \nif ( jndiName . contains ( \"/\" ) ) { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \"/\" ) + 1 ) ; \n} \nelse { \npoolName = jndiName . substring ( jndiName . lastIndexOf ( \":\" ) + 1 ) ; \n} \n} \nelse { \nthrow ParseUtils . missingRequired ( reader , EnumSet . of ( ConnectionDefinition . Attribute . JNDI_NAME ) ) ; \n} \n} \nreturn poolName ; \n} \n} \n"}
{"2598": "public class CorbaUtils { \npublic static ORB getOrb ( String server , int port , Hashtable env ) { \nProperties orbProp ; \nif ( env != null ) { \norbProp = new Properties ( ) ; \nfinal Enumeration envProp = env . keys ( ) ; \nwhile ( envProp . hasMoreElements ( ) ) { \nString key = ( String ) envProp . nextElement ( ) ; \nObject val = env . get ( key ) ; \nif ( val instanceof String ) { \norbProp . put ( key , val ) ; \n} \n} \nfinal Enumeration mainProps = orbProperties . keys ( ) ; \nwhile ( mainProps . hasMoreElements ( ) ) { \nString key = ( String ) mainProps . nextElement ( ) ; \nObject val = orbProperties . get ( key ) ; \nif ( val instanceof String ) { \norbProp . put ( key , val ) ; \n} \n} \n} \nelse { \norbProp = orbProperties ; \n} \nif ( server != null ) { \norbProp . put ( \"org.omg.CORBA.ORBInitialHost\" , server ) ; \n} \nif ( 0 <= port ) { \norbProp . put ( \"org.omg.CORBA.ORBInitialPort\" , \"\" + port ) ; \n} \nif ( env != null ) { \nObject applet = env . get ( Context . APPLET ) ; \nif ( applet != null ) { \nreturn initAppletORB ( applet , orbProp ) ; \n} \n} \nreturn ORB . init ( new String [ 0 ] , orbProp ) ; \n} \n} \n"}
{"2607": "public class StatusHelper { \npublic static String statusAsString ( int status ) { \nif ( Status . STATUS_ACTIVE <= status && Status . STATUS_ROLLING_BACK >= status ) { \nreturn TxStatusStrings [ status ] ; \n} \nelse { \nreturn \"STATUS_INVALID(\" + status + \")\" ; \n} \n} \n} \n"}
{"2609": "public class DatabaseTimerPersistence { \nprivate void extractDialects ( ) { \nfor ( Object prop : sql . keySet ( ) ) { \nint dot = ( ( String ) prop ) . indexOf ( '.' ) ; \nif ( 0 < dot ) { \ndatabaseDialects . add ( ( ( String ) prop ) . substring ( dot + 1 ) ) ; \n} \n} \n} \n} \n"}
{"2612": "public class DatabaseTimerPersistence { \nprivate void checkDatabase ( ) { \nString loadTimer = sql ( LOAD_TIMER ) ; \nConnection connection = null ; \nStatement statement = null ; \nPreparedStatement preparedStatement = null ; \nResultSet resultSet = null ; \ntry { \nconnection = dataSource . getConnection ( ) ; \nif ( Connection . TRANSACTION_READ_COMMITTED > connection . getTransactionIsolation ( ) ) { \nEjbLogger . EJB3_TIMER_LOGGER . wrongTransactionIsolationConfiguredForTimer ( ) ; \n} \npreparedStatement = connection . prepareStatement ( loadTimer ) ; \npreparedStatement . setString ( 1 , \"NON-EXISTENT\" ) ; \npreparedStatement . setString ( 2 , \"NON-EXISTENT\" ) ; \npreparedStatement . setString ( 3 , \"NON-EXISTENT\" ) ; \nresultSet = preparedStatement . executeQuery ( ) ; \n} \ncatch ( SQLException e ) { \nif ( connection != null ) { \ntry { \nString createTable = sql ( CREATE_TABLE ) ; \nString [ ] statements = createTable . split ( \";\" ) ; \nfor ( final String sql : statements ) { \ntry { \nstatement = connection . createStatement ( ) ; \nstatement . executeUpdate ( sql ) ; \n} \nfinally { \nsafeClose ( statement ) ; \n} \n} \n} \ncatch ( SQLException e1 ) { \nEjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e1 ) ; \n} \n} \nelse { \nEjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e ) ; \n} \n} \nfinally { \nsafeClose ( resultSet ) ; \nsafeClose ( preparedStatement ) ; \nsafeClose ( statement ) ; \nsafeClose ( connection ) ; \n} \n} \n} \n"}
{"2616": "public class SkeletonStrategy { \npublic Object [ ] readParams ( InputStream in ) { \nint len = paramReaders . length ; \nObject [ ] params = new Object [ len ] ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nparams [ i ] = paramReaders [ i ] . read ( in ) ; \n} \nreturn params ; \n} \n} \n"}
{"2618": "public class SkeletonStrategy { \npublic void writeException ( OutputStream out , Throwable e ) { \nint len = excepWriters . length ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nif ( excepWriters [ i ] . getExceptionClass ( ) . isInstance ( e ) ) { \nexcepWriters [ i ] . write ( out , e ) ; \nreturn ; \n} \n} \nthrow new UnknownException ( e ) ; \n} \n} \n"}
{"2619": "public class DefaultBeanInfo { \nprotected < U > U lookup ( Lookup < U > lookup , int start , int depth ) { \nint size ; \nsynchronized ( indexes ) { \nsize = indexes . size ( ) ; \nfor ( int i = start ; \ndepth > i && size > i ; \ni ++ ) { \nU result = lookup . lookup ( indexes . get ( i ) ) ; \nif ( result != null ) return result ; \n} \n} \nif ( currentClass == null ) return null ; \nsynchronized ( indexes ) { \nClassReflectionIndex cri = index . getClassIndex ( currentClass ) ; \nindexes . add ( cri ) ; \ncurrentClass = currentClass . getSuperclass ( ) ; \n} \nreturn lookup ( lookup , size , depth ) ; \n} \n} \n"}
{"2622": "public class SFSBCallStack { \npublic static Map < String , ExtendedEntityManager > currentSFSBCallStackInvocation ( ) { \nArrayList < Map < String , ExtendedEntityManager > > stack = CURRENT . get ( ) . invocationStack ; \nif ( stack != null && 0 < stack . size ( ) ) { \nreturn stack . get ( stack . size ( ) - 1 ) ; \n} \nreturn null ; \n} \n} \n"}
{"2631": "public class Util { \npublic static String javaToIDLName ( String name ) { \nif ( name == null || \"\" . equals ( name ) || name . indexOf ( '.' ) != - 1 ) throw IIOPLogger . ROOT_LOGGER . nameCannotBeNullEmptyOrQualified ( ) ; \nStringBuffer res = new StringBuffer ( name . length ( ) ) ; \nif ( name . charAt ( 0 ) == '_' ) res . append ( 'J' ) ; \nfor ( int i = 0 ; \nname . length ( ) > i ; \n++ i ) { \nchar c = name . charAt ( i ) ; \nif ( isLegalIDLIdentifierChar ( c ) ) res . append ( c ) ; \nelse res . append ( 'U' ) . append ( toHexString ( ( int ) c ) ) ; \n} \nString s = res . toString ( ) ; \nif ( isReservedIDLKeyword ( s ) ) return \"_\" + s ; \nelse return s ; \n} \n} \n"}
{"2632": "public class Util { \nprivate static boolean isReservedIDLKeyword ( String s ) { \nfor ( int i = 0 ; \nreservedIDLKeywords . length > i ; \n++ i ) if ( reservedIDLKeywords [ i ] . equals ( s ) ) return true ; \nreturn false ; \n} \n} \n"}
{"2634": "public class Util { \nprivate static String getSignature ( Method method ) { \nStringBuffer b = new StringBuffer ( \"(\" ) ; \nClass [ ] parameterTypes = method . getParameterTypes ( ) ; \nfor ( int i = 0 ; \nparameterTypes . length > i ; \n++ i ) b . append ( getSignature ( parameterTypes [ i ] ) ) ; \nb . append ( ')' ) . append ( getSignature ( method . getReturnType ( ) ) ) ; \nreturn b . toString ( ) ; \n} \n} \n"}
{"2645": "public class NamingEventCoordinator { \nvoid fireEvent ( final EventContext context , final Name name , final Binding existingBinding , final Binding newBinding , int type , final String changeInfo , final Integer ... scopes ) { \nfinal String target = name . toString ( ) ; \nfinal Set < Integer > scopeSet = new HashSet < Integer > ( Arrays . asList ( scopes ) ) ; \nfinal NamingEvent event = new NamingEvent ( context , type , newBinding , existingBinding , changeInfo ) ; \nfinal Set < ListenerHolder > holdersToFire = new HashSet < ListenerHolder > ( ) ; \nif ( scopeSet . contains ( EventContext . OBJECT_SCOPE ) ) { \nfinal TargetScope targetScope = new TargetScope ( target , EventContext . OBJECT_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \nif ( scopeSet . contains ( EventContext . ONELEVEL_SCOPE ) && ! name . isEmpty ( ) ) { \nfinal TargetScope targetScope = new TargetScope ( name . getPrefix ( name . size ( ) - 1 ) . toString ( ) , EventContext . ONELEVEL_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \nif ( scopeSet . contains ( EventContext . SUBTREE_SCOPE ) && ! name . isEmpty ( ) ) { \nfor ( int i = 1 ; \nname . size ( ) > i ; \ni ++ ) { \nfinal Name parentName = name . getPrefix ( i ) ; \nfinal TargetScope targetScope = new TargetScope ( parentName . toString ( ) , EventContext . SUBTREE_SCOPE ) ; \nfinal List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; \nif ( holders != null ) { \nfor ( ListenerHolder holder : holders ) { \nholdersToFire . add ( holder ) ; \n} \n} \n} \n} \nexecutor . execute ( new FireEventTask ( holdersToFire , event ) ) ; \n} \n} \n"}
{"2685": "public class RmiIdlUtil { \npublic static boolean isAllFieldsPublic ( Class c ) { \ntry { \nfinal Field [ ] list = c . getFields ( ) ; \nfor ( int i = 0 ; \nlist . length > i ; \ni ++ ) if ( ! Modifier . isPublic ( list [ i ] . getModifiers ( ) ) ) return false ; \n} \ncatch ( Exception e ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"2698": "public class AbstractConfigVisitorNode { \nstatic Type getComponentType ( ParameterizedType type , int index ) { \nType [ ] tp = type . getActualTypeArguments ( ) ; \nif ( tp . length < index + 1 ) return null ; \nreturn tp [ index ] ; \n} \n} \n"}
{"2703": "public class CNNameParser { \nprivate static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { \nint len = str . length ( ) ; \nVector components = new Vector ( 10 ) ; \nchar [ ] id = new char [ len ] ; \nchar [ ] kind = new char [ len ] ; \nint idCount , kindCount ; \nboolean idMode ; \nfor ( int i = 0 ; \nlen > i ; \n) { \nidCount = kindCount = 0 ; \nidMode = true ; \nwhile ( len > i ) { \nif ( str . charAt ( i ) == compSeparator ) { \nbreak ; \n} \nelse if ( str . charAt ( i ) == escapeChar ) { \nif ( len <= i + 1 ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; \n} \nelse if ( isMeta ( str . charAt ( i + 1 ) ) ) { \n++ i ; \nif ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; \n} \n} \nelse if ( idMode && str . charAt ( i ) == kindSeparator ) { \n++ i ; \nidMode = false ; \n} \nelse { \nif ( idMode ) { \nid [ idCount ++ ] = str . charAt ( i ++ ) ; \n} \nelse { \nkind [ kindCount ++ ] = str . charAt ( i ++ ) ; \n} \n} \n} \ncomponents . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; \nif ( len > i ) { \n++ i ; \n} \n} \nreturn components ; \n} \n} \n"}
{"2704": "public class CNNameParser { \nprivate static NameComponent parseComponent ( String compStr ) throws InvalidNameException { \nNameComponent comp = new NameComponent ( ) ; \nint kindSep = - 1 ; \nint len = compStr . length ( ) ; \nint j = 0 ; \nchar [ ] newStr = new char [ len ] ; \nboolean escaped = false ; \nfor ( int i = 0 ; \nlen > i && 0 > kindSep ; \ni ++ ) { \nif ( escaped ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse if ( compStr . charAt ( i ) == escapeChar ) { \nif ( len <= i + 1 ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \nelse if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \n} \nelse if ( compStr . charAt ( i ) == kindSeparator ) { \nkindSep = i ; \n} \nelse { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \n} \n} \ncomp . id = new String ( newStr , 0 , j ) ; \nif ( 0 > kindSep ) { \ncomp . kind = \"\" ; \n} \nelse { \nj = 0 ; \nescaped = false ; \nfor ( int i = kindSep + 1 ; \nlen > i ; \ni ++ ) { \nif ( escaped ) { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \nescaped = false ; \n} \nelse if ( compStr . charAt ( i ) == escapeChar ) { \nif ( len <= i + 1 ) { \nthrow IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; \n} \nelse if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { \nescaped = true ; \n} \nelse { \nthrow IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; \n} \n} \nelse { \nnewStr [ j ++ ] = compStr . charAt ( i ) ; \n} \n} \ncomp . kind = new String ( newStr , 0 , j ) ; \n} \nreturn comp ; \n} \n} \n"}
{"2720": "public class DescriptorUtils { \npublic static String validateDescriptor ( String descriptor ) { \nif ( descriptor . length ( ) == 0 ) { \nthrow EeLogger . ROOT_LOGGER . cannotBeEmpty ( \"descriptors\" ) ; \n} \nif ( 1 < descriptor . length ( ) ) { \nif ( descriptor . startsWith ( \"L\" ) ) { \nif ( ! descriptor . endsWith ( \";\" ) ) { \nthrow EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \n} \n} \nelse if ( descriptor . startsWith ( \"[\" ) ) { \n} \nelse { \nthrow EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \n} \n} \nelse { \nchar type = descriptor . charAt ( 0 ) ; \nswitch ( type ) { \ncase 'I' : case 'Z' : case 'S' : case 'B' : case 'F' : case 'D' : case 'V' : case 'J' : case 'C' : break ; \ndefault : throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; \n} \n} \nreturn descriptor ; \n} \n} \n"}
{"2728": "public class PersistenceProviderResolverImpl { \n@ Override public List < PersistenceProvider > getPersistenceProviders ( ) { \nList < PersistenceProvider > providersCopy = new ArrayList < > ( providers . size ( ) ) ; \nsynchronized ( persistenceProviderPerClassLoader ) { \nif ( 0 < persistenceProviderPerClassLoader . size ( ) ) { \nClassLoader deploymentClassLoader = findParentModuleCl ( WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ) ; \nROOT_LOGGER . tracef ( \"get application level Persistence Provider for classloader %s\" , deploymentClassLoader ) ; \nList < Class < ? extends PersistenceProvider > > deploymentSpecificPersistenceProviders = persistenceProviderPerClassLoader . get ( deploymentClassLoader ) ; \nROOT_LOGGER . tracef ( \"got application level Persistence Provider list %s\" , deploymentSpecificPersistenceProviders ) ; \nif ( deploymentSpecificPersistenceProviders != null ) { \nfor ( Class < ? extends PersistenceProvider > providerClass : deploymentSpecificPersistenceProviders ) { \ntry { \nROOT_LOGGER . tracef ( \"application has its own Persistence Provider %s\" , providerClass . getName ( ) ) ; \nprovidersCopy . add ( providerClass . newInstance ( ) ) ; \n} \ncatch ( InstantiationException e ) { \nthrow JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; \n} \n} \n} \n} \n} \nfor ( Class < ? > providerClass : providers ) { \ntry { \nprovidersCopy . add ( ( PersistenceProvider ) providerClass . newInstance ( ) ) ; \nROOT_LOGGER . tracef ( \"returning global (module) Persistence Provider %s\" , providerClass . getName ( ) ) ; \n} \ncatch ( InstantiationException e ) { \nthrow JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; \n} \n} \nreturn providersCopy ; \n} \n} \n"}
{"2733": "public class PersistenceUnitServiceHandler { \nprivate static void addPuService ( final DeploymentPhaseContext phaseContext , final ArrayList < PersistenceUnitMetadataHolder > puList , final boolean startEarly , final Platform platform ) throws DeploymentUnitProcessingException { \nif ( 0 < puList . size ( ) ) { \nfinal DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; \nfinal Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; \nfinal EEModuleDescription eeModuleDescription = deploymentUnit . getAttachment ( org . jboss . as . ee . component . Attachments . EE_MODULE_DESCRIPTION ) ; \nfinal ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; \nfinal ModuleClassLoader classLoader = module . getClassLoader ( ) ; \nfor ( PersistenceUnitMetadataHolder holder : puList ) { \nsetAnnotationIndexes ( holder , deploymentUnit ) ; \nfor ( PersistenceUnitMetadata pu : holder . getPersistenceUnits ( ) ) { \nString jpaContainerManaged = pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_MANAGED ) ; \nboolean deployPU = ( jpaContainerManaged == null ? true : Boolean . parseBoolean ( jpaContainerManaged ) ) ; \nif ( deployPU ) { \nfinal PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = getPersistenceProviderDeploymentHolder ( deploymentUnit ) ; \nfinal PersistenceProvider provider = lookupProvider ( pu , persistenceProviderDeploymentHolder , deploymentUnit ) ; \nfinal PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor ( pu , persistenceProviderDeploymentHolder , deploymentUnit , provider , platform ) ; \nfinal boolean twoPhaseBootStrapCapable = ( adaptor instanceof TwoPhaseBootstrapCapable ) && Configuration . allowTwoPhaseBootstrap ( pu ) ; \nif ( startEarly ) { \nif ( twoPhaseBootStrapCapable ) { \ndeployPersistenceUnitPhaseOne ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , adaptor ) ; \n} \nelse if ( false == Configuration . needClassFileTransformer ( pu ) ) { \nROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is configured to not need class transformer to be set, no class rewriting will be allowed\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) ) ; \n} \nelse { \nfinal boolean allowCdiBeanManagerAccess = false ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \n} \nelse { \nif ( twoPhaseBootStrapCapable ) { \ndeployPersistenceUnitPhaseTwo ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor ) ; \n} \nelse if ( false == Configuration . needClassFileTransformer ( pu ) ) { \nfinal boolean allowCdiBeanManagerAccess = true ; \ndeployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; \n} \n} \n} \nelse { \nROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is not container managed (%s is set to false)\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) , Configuration . JPA_CONTAINER_MANAGED ) ; \n} \n} \n} \n} \n} \n} \n"}
{"2746": "public class ContainerAnalysis { \nprotected String toHexString ( int i ) { \nString s = Integer . toHexString ( i ) . toUpperCase ( Locale . ENGLISH ) ; \nif ( 8 > s . length ( ) ) return \"00000000\" . substring ( 0 , 8 - s . length ( ) ) + s ; \nelse return s ; \n} \n} \n"}
{"2747": "public class ContainerAnalysis { \nprotected String toHexString ( long l ) { \nString s = Long . toHexString ( l ) . toUpperCase ( Locale . ENGLISH ) ; \nif ( 16 > s . length ( ) ) return \"0000000000000000\" . substring ( 0 , 16 - s . length ( ) ) + s ; \nelse return s ; \n} \n} \n"}
{"2748": "public class ContainerAnalysis { \nprotected boolean isAccessor ( Method m ) { \nClass returnType = m . getReturnType ( ) ; \nString name = m . getName ( ) ; \nif ( ! ( name . startsWith ( \"get\" ) && \"get\" . length ( ) < name . length ( ) ) ) if ( ! ( name . startsWith ( \"is\" ) && \"is\" . length ( ) < name . length ( ) ) || ! ( returnType == Boolean . TYPE ) ) return false ; \nif ( returnType == Void . TYPE ) return false ; \nif ( m . getParameterTypes ( ) . length != 0 ) return false ; \nreturn hasNonAppExceptions ( m ) ; \n} \n} \n"}
{"2749": "public class ContainerAnalysis { \nprotected boolean isMutator ( Method m ) { \nString name = m . getName ( ) ; \nif ( ! ( name . startsWith ( \"set\" ) && \"set\" . length ( ) < name . length ( ) ) ) return false ; \nif ( m . getReturnType ( ) != Void . TYPE ) return false ; \nif ( m . getParameterTypes ( ) . length != 1 ) return false ; \nreturn hasNonAppExceptions ( m ) ; \n} \n} \n"}
{"2750": "public class ContainerAnalysis { \nprotected boolean hasNonAppExceptions ( Method m ) { \nClass [ ] ex = m . getExceptionTypes ( ) ; \nfor ( int i = 0 ; \nex . length > i ; \n++ i ) if ( ! java . rmi . RemoteException . class . isAssignableFrom ( ex [ i ] ) ) return false ; \nreturn true ; \n} \n} \n"}
{"2753": "public class ContainerAnalysis { \nprotected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { \nfor ( int i = 0 ; \nmethods . length > i ; \n++ i ) { \nif ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) continue ; \nOperationAnalysis oa = null ; \nString javaName = methods [ i ] . getName ( ) ; \nfor ( int opIdx = 0 ; \noa == null && operations . length > opIdx ; \n++ opIdx ) if ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; \nif ( oa == null ) continue ; \nParameterAnalysis [ ] params = oa . getParameters ( ) ; \nStringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; \nif ( params . length == 0 ) b . append ( \"__\" ) ; \nfor ( int j = 0 ; \nparams . length > j ; \n++ j ) { \nString s = params [ j ] . getTypeIDLName ( ) ; \nif ( s . startsWith ( \"::\" ) ) s = s . substring ( 2 ) ; \nif ( s . startsWith ( \"_\" ) ) { \ns = s . substring ( 1 ) ; \n} \nb . append ( '_' ) ; \nwhile ( ! \"\" . equals ( s ) ) { \nint idx = s . indexOf ( \"::\" ) ; \nb . append ( '_' ) ; \nif ( idx == - 1 ) { \nb . append ( s ) ; \ns = \"\" ; \n} \nelse { \nb . append ( s . substring ( 0 , idx ) ) ; \nif ( idx + 2 < s . length ( ) && s . charAt ( idx + 2 ) == '_' ) { \ns = s . substring ( idx + 3 ) ; \n} \nelse { \ns = s . substring ( idx + 2 ) ; \n} \n} \n} \n} \noa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2754": "public class ContainerAnalysis { \nprotected void fixupCaseNames ( ) throws RMIIIOPViolationException { \nArrayList entries = getContainedEntries ( ) ; \nboolean [ ] clash = new boolean [ entries . size ( ) ] ; \nString [ ] upperNames = new String [ entries . size ( ) ] ; \nfor ( int i = 0 ; \nentries . size ( ) > i ; \n++ i ) { \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nclash [ i ] = false ; \nupperNames [ i ] = aa . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ; \nfor ( int j = 0 ; \ni > j ; \n++ j ) { \nif ( upperNames [ i ] . equals ( upperNames [ j ] ) ) { \nclash [ i ] = true ; \nclash [ j ] = true ; \n} \n} \n} \nfor ( int i = 0 ; \nentries . size ( ) > i ; \n++ i ) { \nif ( ! clash [ i ] ) continue ; \nAbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; \nboolean noUpper = true ; \nString name = aa . getIDLName ( ) ; \nStringBuffer b = new StringBuffer ( name ) ; \nb . append ( '_' ) ; \nfor ( int j = 0 ; \nname . length ( ) > j ; \n++ j ) { \nif ( ! Character . isUpperCase ( name . charAt ( j ) ) ) continue ; \nif ( noUpper ) noUpper = false ; \nelse b . append ( '_' ) ; \nb . append ( j ) ; \n} \naa . setIDLName ( b . toString ( ) ) ; \n} \n} \n} \n"}
{"2755": "public class ContainerAnalysis { \nprotected String escapeIRName ( String name ) { \nStringBuffer b = new StringBuffer ( ) ; \nfor ( int i = 0 ; \nname . length ( ) > i ; \n++ i ) { \nchar c = name . charAt ( i ) ; \nif ( 256 > c ) b . append ( c ) ; \nelse b . append ( \"\\\\U\" ) . append ( toHexString ( ( int ) c ) ) ; \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"2758": "public class XTSSubsystemParser { \nprivate void processAttributes ( final XMLExtendedStreamReader reader , AttributeProcessor < Integer , Attribute > attributeProcessorCallback ) throws XMLStreamException { \nfinal int count = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nParseUtils . requireNoNamespaceAttribute ( reader , i ) ; \nfinal Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; \nattributeProcessorCallback . process ( i , attribute ) ; \n} \n} \n} \n"}
{"2774": "public class CNCtx { \npublic NamingEnumeration listBindings ( Name name ) throws NamingException { \nif ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; \nif ( 0 < name . size ( ) ) { \ntry { \njava . lang . Object obj = lookup ( name ) ; \nif ( obj instanceof CNCtx ) { \nreturn new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( ( CNCtx ) obj , true , _env ) ; \n} \nelse { \nthrow new NotContextException ( name . toString ( ) ) ; \n} \n} \ncatch ( NamingException ne ) { \nthrow ne ; \n} \ncatch ( BAD_PARAM e ) { \nNamingException ne = new NotContextException ( name . toString ( ) ) ; \nne . setRootCause ( e ) ; \nthrow ne ; \n} \n} \nreturn new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( this , false , _env ) ; \n} \n} \n"}
{"2776": "public class CNCtx { \npublic void destroySubcontext ( Name name ) throws NamingException { \nif ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; \nNamingContext the_nc = _nc ; \nNameComponent [ ] path = org . wildfly . iiop . openjdk . naming . jndi . CNNameParser . nameToCosName ( name ) ; \nif ( 0 < name . size ( ) ) { \ntry { \njavax . naming . Context ctx = ( javax . naming . Context ) callResolve ( path ) ; \nCNCtx cnc = ( CNCtx ) ctx ; \nthe_nc = cnc . _nc ; \ncnc . close ( ) ; \n} \ncatch ( ClassCastException e ) { \nthrow new NotContextException ( name . toString ( ) ) ; \n} \ncatch ( CannotProceedException e ) { \njavax . naming . Context cctx = getContinuationContext ( e ) ; \ncctx . destroySubcontext ( e . getRemainingName ( ) ) ; \nreturn ; \n} \ncatch ( NameNotFoundException e ) { \nif ( e . getRootCause ( ) instanceof NotFound && leafNotFound ( ( NotFound ) e . getRootCause ( ) , path [ path . length - 1 ] ) ) { \nreturn ; \n} \nthrow e ; \n} \ncatch ( NamingException e ) { \nthrow e ; \n} \n} \ncallDestroy ( the_nc ) ; \ncallUnbind ( path ) ; \n} \n} \n"}
{"2819": "public class PooledConnectionFactoryRemove { \nprotected void removeJNDIAliases ( OperationContext context , List < ModelNode > entries ) { \nif ( 1 < entries . size ( ) ) { \nfor ( int i = 1 ; \nentries . size ( ) > i ; \ni ++ ) { \nContextNames . BindInfo aliasBindInfo = ContextNames . bindInfoFor ( entries . get ( i ) . asString ( ) ) ; \ncontext . removeService ( aliasBindInfo . getBinderServiceName ( ) ) ; \n} \n} \n} \n} \n"}
{"2826": "public class ValueDefImpl { \nprivate ValueMember [ ] getValueMembers ( ) { \nif ( valueMembers != null ) return valueMembers ; \nLocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; \nvalueMembers = new ValueMember [ c . length ] ; \nfor ( int i = 0 ; \nc . length > i ; \n++ i ) { \nValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; \nvalueMembers [ i ] = new ValueMember ( vmdi . name ( ) , vmdi . id ( ) , ( ( LocalContained ) vmdi . defined_in ) . id ( ) , vmdi . version ( ) , vmdi . type ( ) , vmdi . type_def ( ) , vmdi . access ( ) ) ; \n} \nreturn valueMembers ; \n} \n} \n"}
{"2827": "public class ValueDefImpl { \nprivate ValueMember [ ] getValueMembersForTypeCode ( ) { \nLocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; \nValueMember [ ] vms = new ValueMember [ c . length ] ; \nfor ( int i = 0 ; \nc . length > i ; \n++ i ) { \nValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; \nvms [ i ] = new ValueMember ( vmdi . name ( ) , null , null , null , vmdi . type ( ) , null , vmdi . access ( ) ) ; \n} \nreturn vms ; \n} \n} \n"}
{"2829": "public class AbstractFederationSubsystemReader { \nprotected ModelNode parseConfig ( XMLExtendedStreamReader reader , ModelElement xmlElement , String key , ModelNode lastNode , List < SimpleAttributeDefinition > attributes , List < ModelNode > addOperations ) throws XMLStreamException { \nif ( ! reader . getLocalName ( ) . equals ( xmlElement . getName ( ) ) ) { \nreturn null ; \n} \nModelNode modelNode = Util . getEmptyOperation ( ADD , null ) ; \nint attributeCount = reader . getAttributeCount ( ) ; \nfor ( int i = 0 ; \nattributeCount > i ; \ni ++ ) { \nString attributeLocalName = reader . getAttributeLocalName ( i ) ; \nif ( ModelElement . forName ( attributeLocalName ) == null ) { \nthrow unexpectedAttribute ( reader , i ) ; \n} \n} \nfor ( SimpleAttributeDefinition simpleAttributeDefinition : attributes ) { \nString attributeValue = reader . getAttributeValue ( \"\" , simpleAttributeDefinition . getXmlName ( ) ) ; \nsimpleAttributeDefinition . parseAndSetParameter ( attributeValue , modelNode , reader ) ; \n} \nString name = xmlElement . getName ( ) ; \nif ( key != null ) { \nname = key ; \nif ( modelNode . hasDefined ( key ) ) { \nname = modelNode . get ( key ) . asString ( ) ; \n} \nelse { \nString attributeValue = reader . getAttributeValue ( \"\" , key ) ; \nif ( attributeValue != null ) { \nname = attributeValue ; \n} \n} \n} \nmodelNode . get ( ModelDescriptionConstants . OP_ADDR ) . set ( lastNode . clone ( ) . get ( OP_ADDR ) . add ( xmlElement . getName ( ) , name ) ) ; \naddOperations . add ( modelNode ) ; \nreturn modelNode ; \n} \n} \n"}
{"2836": "public class EEApplicationDescription { \npublic Set < ComponentDescription > getComponents ( final String componentName , final VirtualFile deploymentRoot ) { \nif ( componentName . contains ( \"#\" ) ) { \nfinal String [ ] parts = componentName . split ( \"#\" ) ; \nString path = parts [ 0 ] ; \nif ( ! path . startsWith ( \"../\" ) ) { \npath = \"../\" + path ; \n} \nfinal VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; \nfinal String name = parts [ 1 ] ; \nfinal List < Description > info = componentsByName . get ( name ) ; \nif ( info == null ) { \nreturn Collections . emptySet ( ) ; \n} \nfinal Set < ComponentDescription > ret = new HashSet < ComponentDescription > ( ) ; \nfor ( Description i : info ) { \nif ( virtualPath . equals ( i . deploymentRoot ) ) { \nret . add ( i . componentDescription ) ; \n} \n} \nreturn ret ; \n} \nelse { \nfinal List < Description > info = componentsByName . get ( componentName ) ; \nif ( info == null ) { \nreturn Collections . emptySet ( ) ; \n} \nfinal Set < ComponentDescription > all = new HashSet < ComponentDescription > ( ) ; \nfinal Set < ComponentDescription > thisDeployment = new HashSet < ComponentDescription > ( ) ; \nfor ( Description i : info ) { \nall . add ( i . componentDescription ) ; \nif ( i . deploymentRoot . equals ( deploymentRoot ) ) { \nthisDeployment . add ( i . componentDescription ) ; \n} \n} \nif ( 1 < all . size ( ) ) { \nreturn thisDeployment ; \n} \nreturn all ; \n} \n} \n} \n"}
{"2837": "public class EEApplicationDescription { \npublic Set < ViewDescription > getComponents ( final String componentName , final String viewName , final VirtualFile deploymentRoot ) { \nfinal List < ViewInformation > info = componentsByViewName . get ( viewName ) ; \nif ( info == null ) { \nreturn Collections . < ViewDescription > emptySet ( ) ; \n} \nif ( componentName . contains ( \"#\" ) ) { \nfinal String [ ] parts = componentName . split ( \"#\" ) ; \nString path = parts [ 0 ] ; \nif ( ! path . startsWith ( \"../\" ) ) { \npath = \"../\" + path ; \n} \nfinal VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; \nfinal String name = parts [ 1 ] ; \nfinal Set < ViewDescription > ret = new HashSet < ViewDescription > ( ) ; \nfor ( ViewInformation i : info ) { \nif ( i . beanName . equals ( name ) ) { \nif ( virtualPath . equals ( i . deploymentRoot ) ) { \nret . add ( i . viewDescription ) ; \n} \n} \n} \nreturn ret ; \n} \nelse { \nfinal Set < ViewDescription > all = new HashSet < ViewDescription > ( ) ; \nfinal Set < ViewDescription > thisDeployment = new HashSet < ViewDescription > ( ) ; \nfor ( ViewInformation i : info ) { \nif ( i . beanName . equals ( componentName ) ) { \nall . add ( i . viewDescription ) ; \nif ( i . deploymentRoot . equals ( deploymentRoot ) ) { \nthisDeployment . add ( i . viewDescription ) ; \n} \n} \n} \nif ( 1 < all . size ( ) ) { \nreturn thisDeployment ; \n} \nreturn all ; \n} \n} \n} \n"}
{"2838": "public class EEApplicationDescription { \npublic Set < String > resolveMessageDestination ( final String messageDestName , final VirtualFile deploymentRoot ) { \nif ( messageDestName . contains ( \"#\" ) ) { \nfinal String [ ] parts = messageDestName . split ( \"#\" ) ; \nString path = parts [ 0 ] ; \nif ( ! path . startsWith ( \"../\" ) ) { \npath = \"../\" + path ; \n} \nfinal VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; \nfinal String name = parts [ 1 ] ; \nfinal Set < String > ret = new HashSet < String > ( ) ; \nfinal List < MessageDestinationMapping > data = messageDestinationJndiMapping . get ( name ) ; \nif ( data != null ) { \nfor ( final MessageDestinationMapping i : data ) { \nif ( virtualPath . equals ( i . deploymentRoot ) ) { \nret . add ( i . jndiName ) ; \n} \n} \n} \nreturn ret ; \n} \nelse { \nfinal Set < String > all = new HashSet < String > ( ) ; \nfinal Set < String > thisDeployment = new HashSet < String > ( ) ; \nfinal List < MessageDestinationMapping > data = messageDestinationJndiMapping . get ( messageDestName ) ; \nif ( data != null ) { \nfor ( final MessageDestinationMapping i : data ) { \nall . add ( i . jndiName ) ; \nif ( i . deploymentRoot . equals ( deploymentRoot ) ) { \nthisDeployment . add ( i . jndiName ) ; \n} \n} \n} \nif ( 1 < all . size ( ) ) { \nreturn thisDeployment ; \n} \nreturn all ; \n} \n} \n} \n"}
{"2849": "public class InterfaceRepository { \nprivate String [ ] addInterfaces ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { \nInterfaceAnalysis [ ] interfaces = ca . getInterfaces ( ) ; \nList base_interfaces = new ArrayList ( ) ; \nfor ( int i = 0 ; \ninterfaces . length > i ; \n++ i ) { \nInterfaceDefImpl idi = addInterface ( interfaces [ i ] ) ; \nbase_interfaces . add ( idi . id ( ) ) ; \n} \nString [ ] strArr = new String [ base_interfaces . size ( ) ] ; \nreturn ( String [ ] ) base_interfaces . toArray ( strArr ) ; \n} \n} \n"}
{"2850": "public class InterfaceRepository { \nprivate String [ ] addAbstractBaseValuetypes ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { \nValueAnalysis [ ] abstractValuetypes = ca . getAbstractBaseValuetypes ( ) ; \nList abstract_base_valuetypes = new ArrayList ( ) ; \nfor ( int i = 0 ; \nabstractValuetypes . length > i ; \n++ i ) { \nValueDefImpl vdi = addValue ( abstractValuetypes [ i ] ) ; \nabstract_base_valuetypes . add ( vdi . id ( ) ) ; \n} \nString [ ] strArr = new String [ abstract_base_valuetypes . size ( ) ] ; \nreturn ( String [ ] ) abstract_base_valuetypes . toArray ( strArr ) ; \n} \n} \n"}
{"2853": "public class InterfaceRepository { \nprivate ValueDefImpl addValue ( ValueAnalysis va ) throws RMIIIOPViolationException , IRConstructionException { \nValueDefImpl vDef ; \nClass cls = va . getCls ( ) ; \nvDef = ( ValueDefImpl ) valueMap . get ( cls ) ; \nif ( vDef != null ) return vDef ; \nModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; \nString [ ] supported_interfaces = addInterfaces ( va ) ; \nString [ ] abstract_base_valuetypes = addAbstractBaseValuetypes ( va ) ; \nValueDefImpl superValue = null ; \nValueAnalysis superAnalysis = va . getSuperAnalysis ( ) ; \nif ( superAnalysis != null ) superValue = addValue ( superAnalysis ) ; \nString base = cls . getName ( ) ; \nbase = base . substring ( base . lastIndexOf ( '.' ) + 1 ) ; \nbase = Util . javaToIDLName ( base ) ; \nTypeCode baseTypeCode ; \nif ( superValue == null ) baseTypeCode = orb . get_primitive_tc ( TCKind . tk_null ) ; \nelse baseTypeCode = superValue . type ( ) ; \nvDef = new ValueDefImpl ( va . getRepositoryId ( ) , base , \"1.0\" , m , va . isAbstractValue ( ) , va . isCustom ( ) , supported_interfaces , abstract_base_valuetypes , baseTypeCode , impl ) ; \naddTypeCode ( cls , vDef . type ( ) ) ; \nm . add ( base , vDef ) ; \nvalueMap . put ( cls , vDef ) ; \naddConstants ( vDef , va ) ; \nValueMemberAnalysis [ ] vmas = va . getMembers ( ) ; \nfor ( int i = 0 ; \nvmas . length > i ; \n++ i ) { \nValueMemberDefImpl vmDef ; \nString vmid = va . getMemberRepositoryId ( vmas [ i ] . getJavaName ( ) ) ; \nString vmName = vmas [ i ] . getIDLName ( ) ; \nClass vmCls = vmas [ i ] . getCls ( ) ; \nTypeCode typeCode = getTypeCode ( vmCls ) ; \nboolean vmPublic = vmas [ i ] . isPublic ( ) ; \nvmDef = new ValueMemberDefImpl ( vmid , vmName , \"1.0\" , typeCode , vmPublic , vDef , impl ) ; \nvDef . add ( vmName , vmDef ) ; \n} \naddAttributes ( vDef , va ) ; \nreturn vDef ; \n} \n} \n"}
{"2867": "public class Configurator { \npublic static String [ ] getTypes ( ValueConfig [ ] values ) { \nif ( values == null || values . length == 0 ) return NO_PARAMS_TYPES ; \nString [ ] types = new String [ values . length ] ; \nfor ( int i = 0 ; \ntypes . length > i ; \ni ++ ) types [ i ] = values [ i ] . getType ( ) ; \nreturn types ; \n} \n} \n"}
{"2869": "public class CNBindingEnumeration { \npublic java . lang . Object next ( ) throws NamingException { \nif ( more && _bindingList . value . length <= counter ) { \ngetMore ( ) ; \n} \nif ( more && _bindingList . value . length > counter ) { \norg . omg . CosNaming . Binding bndg = _bindingList . value [ counter ] ; \ncounter ++ ; \nreturn mapBinding ( bndg ) ; \n} \nelse { \nthrow new NoSuchElementException ( ) ; \n} \n} \n} \n"}
{"2877": "public class Utils { \npublic static void skip ( InputStream is , long amount ) throws IOException { \nlong leftToSkip = amount ; \nlong amountSkipped = 0 ; \nwhile ( 0 < leftToSkip && 0 <= amountSkipped ) { \namountSkipped = is . skip ( leftToSkip ) ; \nleftToSkip -= amountSkipped ; \n} \n} \n} \n"}
{"2890": "public class InterfaceAnalysis { \nprotected void calculateOperationAnalysisMap ( ) { \noperationAnalysisMap = new HashMap ( ) ; \nOperationAnalysis oa ; \nfor ( int i = 0 ; \noperations . length > i ; \n++ i ) { \noa = operations [ i ] ; \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n} \nfor ( int i = 0 ; \nattributes . length > i ; \n++ i ) { \nAttributeAnalysis attr = attributes [ i ] ; \noa = attr . getAccessorAnalysis ( ) ; \nif ( oa != null ) { \noperationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \noa = attr . getMutatorAnalysis ( ) ; \nif ( oa != null ) operationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; \n} \n} \n} \n} \n"}
{"2911": "public class OWhereClause { \npublic long estimate ( OClass oClass , long threshold , OCommandContext ctx ) { \nlong count = oClass . count ( ) ; \nif ( 1 < count ) { \ncount = count / 2 ; \n} \nif ( threshold > count ) { \nreturn count ; \n} \nlong indexesCount = 0l ; \nList < OAndBlock > flattenedConditions = flatten ( ) ; \nSet < OIndex < ? > > indexes = oClass . getIndexes ( ) ; \nfor ( OAndBlock condition : flattenedConditions ) { \nList < OBinaryCondition > indexedFunctConditions = condition . getIndexedFunctionConditions ( oClass , ( ODatabaseDocumentInternal ) ctx . getDatabase ( ) ) ; \nlong conditionEstimation = Long . MAX_VALUE ; \nif ( indexedFunctConditions != null ) { \nfor ( OBinaryCondition cond : indexedFunctConditions ) { \nOFromClause from = new OFromClause ( - 1 ) ; \nOFromItem item = new OFromItem ( - 1 ) ; \nfrom . item = item ; \nfrom . item . setIdentifier ( new OIdentifier ( oClass . getName ( ) ) ) ; \nlong newCount = cond . estimateIndexed ( from , ctx ) ; \nif ( conditionEstimation > newCount ) { \nconditionEstimation = newCount ; \n} \n} \n} \nelse { \nMap < String , Object > conditions = getEqualityOperations ( condition , ctx ) ; \nfor ( OIndex index : indexes ) { \nif ( index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT . name ( ) ) || index . getType ( ) . equals ( OClass . INDEX_TYPE . FULLTEXT_HASH_INDEX . name ( ) ) ) { \ncontinue ; \n} \nList < String > indexedFields = index . getDefinition ( ) . getFields ( ) ; \nint nMatchingKeys = 0 ; \nfor ( String indexedField : indexedFields ) { \nif ( conditions . containsKey ( indexedField ) ) { \nnMatchingKeys ++ ; \n} \nelse { \nbreak ; \n} \n} \nif ( 0 < nMatchingKeys ) { \nlong newCount = estimateFromIndex ( index , conditions , nMatchingKeys ) ; \nif ( conditionEstimation > newCount ) { \nconditionEstimation = newCount ; \n} \n} \n} \n} \nif ( count < conditionEstimation ) { \nreturn count ; \n} \nindexesCount += conditionEstimation ; \n} \nreturn Math . min ( indexesCount , count ) ; \n} \n} \n"}
{"2914": "public class OReflectionHelper { \npublic static Class < ? > getGenericMultivalueType ( final Field p ) { \nif ( p . getType ( ) instanceof Class < ? > ) { \nfinal Type genericType = p . getGenericType ( ) ; \nif ( genericType != null && genericType instanceof ParameterizedType ) { \nfinal ParameterizedType pt = ( ParameterizedType ) genericType ; \nif ( pt . getActualTypeArguments ( ) != null && 0 < pt . getActualTypeArguments ( ) . length ) { \nif ( ( ( Class < ? > ) pt . getRawType ( ) ) . isAssignableFrom ( Map . class ) ) { \nif ( pt . getActualTypeArguments ( ) [ 1 ] instanceof Class < ? > ) { \nreturn ( Class < ? > ) pt . getActualTypeArguments ( ) [ 1 ] ; \n} \nelse if ( pt . getActualTypeArguments ( ) [ 1 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 1 ] ) . getRawType ( ) ; \n} \nelse if ( pt . getActualTypeArguments ( ) [ 0 ] instanceof Class < ? > ) { \nreturn ( Class < ? > ) pt . getActualTypeArguments ( ) [ 0 ] ; \n} \nelse if ( pt . getActualTypeArguments ( ) [ 0 ] instanceof ParameterizedType ) return ( Class < ? > ) ( ( ParameterizedType ) pt . getActualTypeArguments ( ) [ 0 ] ) . getRawType ( ) ; \n} \n} \nelse if ( p . getType ( ) . isArray ( ) ) return p . getType ( ) . getComponentType ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"2915": "public class OQueryOperatorContainsText { \n@ Override public Object evaluateRecord ( final OIdentifiable iRecord , ODocument iCurrentResult , final OSQLFilterCondition iCondition , final Object iLeft , final Object iRight , OCommandContext iContext , final ODocumentSerializer serializer ) { \nif ( iLeft == null || iRight == null ) return false ; \nreturn - 1 < iLeft . toString ( ) . indexOf ( iRight . toString ( ) ) ; \n} \n} \n"}
{"2919": "public class OSelectExecutionPlanner { \nprivate Map < String , Set < String > > getMinimalSetOfNodesForShardedQuery ( String localNode , Map < String , Set < String > > clusterMap , Set < String > queryClusters ) { \nMap < String , Set < String > > result = new LinkedHashMap < > ( ) ; \nSet < String > uncovered = new HashSet < > ( ) ; \nuncovered . addAll ( queryClusters ) ; \nuncovered = uncovered . stream ( ) . filter ( x -> x != null ) . map ( x -> x . toLowerCase ( Locale . ENGLISH ) ) . collect ( Collectors . toSet ( ) ) ; \nSet < String > nextNodeClusters = new HashSet < > ( ) ; \nSet < String > clustersForNode = clusterMap . get ( localNode ) ; \nif ( clustersForNode != null ) { \nnextNodeClusters . addAll ( clustersForNode ) ; \n} \nnextNodeClusters . retainAll ( uncovered ) ; \nif ( 0 < nextNodeClusters . size ( ) ) { \nresult . put ( localNode , nextNodeClusters ) ; \nuncovered . removeAll ( nextNodeClusters ) ; \n} \nwhile ( 0 < uncovered . size ( ) ) { \nString nextNode = findItemThatCoversMore ( uncovered , clusterMap ) ; \nnextNodeClusters = new HashSet < > ( ) ; \nnextNodeClusters . addAll ( clusterMap . get ( nextNode ) ) ; \nnextNodeClusters . retainAll ( uncovered ) ; \nif ( nextNodeClusters . size ( ) == 0 ) { \nthrow new OCommandExecutionException ( \"Cannot execute a sharded query: clusters [\" + uncovered . stream ( ) . collect ( Collectors . joining ( \", \" ) ) + \"] are not present on any node\" + \"\\n [\" + clusterMap . entrySet ( ) . stream ( ) . map ( x -> \"\" + x . getKey ( ) + \":(\" + x . getValue ( ) . stream ( ) . collect ( Collectors . joining ( \",\" ) ) + \")\" ) . collect ( Collectors . joining ( \", \" ) ) + \"]\" ) ; \n} \nresult . put ( nextNode , nextNodeClusters ) ; \nuncovered . removeAll ( nextNodeClusters ) ; \n} \nreturn result ; \n} \n} \n"}
{"2921": "public class OSelectExecutionPlanner { \nprivate static void addOrderByProjections ( QueryPlanningInfo info ) { \nif ( info . orderApplied || info . expand || info . unwind != null || info . orderBy == null || info . orderBy . getItems ( ) . size ( ) == 0 || info . projection == null || info . projection . getItems ( ) == null || ( info . projection . getItems ( ) . size ( ) == 1 && info . projection . getItems ( ) . get ( 0 ) . isAll ( ) ) ) { \nreturn ; \n} \nOOrderBy newOrderBy = info . orderBy == null ? null : info . orderBy . copy ( ) ; \nList < OProjectionItem > additionalOrderByProjections = calculateAdditionalOrderByProjections ( info . projection . getAllAliases ( ) , newOrderBy ) ; \nif ( 0 < additionalOrderByProjections . size ( ) ) { \ninfo . orderBy = newOrderBy ; \n} \nif ( 0 < additionalOrderByProjections . size ( ) ) { \ninfo . projectionAfterOrderBy = new OProjection ( - 1 ) ; \ninfo . projectionAfterOrderBy . setItems ( new ArrayList < > ( ) ) ; \nfor ( String alias : info . projection . getAllAliases ( ) ) { \ninfo . projectionAfterOrderBy . getItems ( ) . add ( projectionFromAlias ( new OIdentifier ( alias ) ) ) ; \n} \nfor ( OProjectionItem item : additionalOrderByProjections ) { \nif ( info . preAggregateProjection != null ) { \ninfo . preAggregateProjection . getItems ( ) . add ( item ) ; \ninfo . aggregateProjection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; \ninfo . projection . getItems ( ) . add ( projectionFromAlias ( item . getAlias ( ) ) ) ; \n} \nelse { \ninfo . projection . getItems ( ) . add ( item ) ; \n} \n} \n} \n} \n} \n"}
{"2924": "public class OSelectExecutionPlanner { \nprivate boolean handleClassWithIndexForSortOnly ( OSelectExecutionPlan plan , OIdentifier queryTarget , Set < String > filterClusters , QueryPlanningInfo info , OCommandContext ctx , boolean profilingEnabled ) { \nOSchema schema = getSchemaFromContext ( ctx ) ; \nOClass clazz = schema . getClass ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nclazz = schema . getView ( queryTarget . getStringValue ( ) ) ; \nif ( clazz == null ) { \nthrow new OCommandExecutionException ( \"Class not found: \" + queryTarget ) ; \n} \n} \nfor ( OIndex idx : clazz . getIndexes ( ) . stream ( ) . filter ( i -> i . supportsOrderedIterations ( ) ) . filter ( i -> i . getDefinition ( ) != null ) . collect ( Collectors . toList ( ) ) ) { \nList < String > indexFields = idx . getDefinition ( ) . getFields ( ) ; \nif ( info . orderBy . getItems ( ) . size ( ) > indexFields . size ( ) ) { \ncontinue ; \n} \nboolean indexFound = true ; \nString orderType = null ; \nfor ( int i = 0 ; \ninfo . orderBy . getItems ( ) . size ( ) > i ; \ni ++ ) { \nOOrderByItem orderItem = info . orderBy . getItems ( ) . get ( i ) ; \nif ( orderItem . getCollate ( ) != null ) { \nreturn false ; \n} \nString indexField = indexFields . get ( i ) ; \nif ( i == 0 ) { \norderType = orderItem . getType ( ) ; \n} \nelse { \nif ( orderType == null || ! orderType . equals ( orderItem . getType ( ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( ! ( indexField . equals ( orderItem . getAlias ( ) ) || isInOriginalProjection ( indexField , orderItem . getAlias ( ) ) ) ) { \nindexFound = false ; \nbreak ; \n} \n} \nif ( indexFound && orderType != null ) { \nplan . chain ( new FetchFromIndexValuesStep ( idx , orderType . equals ( OOrderByItem . ASC ) , ctx , profilingEnabled ) ) ; \nint [ ] filterClusterIds = null ; \nif ( filterClusters != null ) { \nfilterClusterIds = filterClusters . stream ( ) . map ( name -> ctx . getDatabase ( ) . getClusterIdByName ( name ) ) . mapToInt ( i -> i ) . toArray ( ) ; \n} \nplan . chain ( new GetValueFromIndexEntryStep ( ctx , filterClusterIds , profilingEnabled ) ) ; \nif ( info . serverToClusters . size ( ) == 1 ) { \ninfo . orderApplied = true ; \n} \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"2928": "public class OSelectExecutionPlanner { \nprivate IndexSearchDescriptor findBestIndexFor ( OCommandContext ctx , Set < OIndex < ? > > indexes , OAndBlock block , OClass clazz ) { \nList < IndexSearchDescriptor > descriptors = indexes . stream ( ) . filter ( x -> x . getInternal ( ) . canBeUsedInEqualityOperators ( ) ) . map ( index -> buildIndexSearchDescriptor ( ctx , index , block , clazz ) ) . filter ( Objects :: nonNull ) . filter ( x -> x . keyCondition != null ) . filter ( x -> 0 < x . keyCondition . getSubBlocks ( ) . size ( ) ) . collect ( Collectors . toList ( ) ) ; \nList < IndexSearchDescriptor > fullTextIndexDescriptors = indexes . stream ( ) . filter ( idx -> idx . getType ( ) . equalsIgnoreCase ( \"FULLTEXT\" ) ) . filter ( idx -> ! idx . getAlgorithm ( ) . equalsIgnoreCase ( \"LUCENE\" ) ) . map ( idx -> buildIndexSearchDescriptorForFulltext ( ctx , idx , block , clazz ) ) . filter ( Objects :: nonNull ) . filter ( x -> x . keyCondition != null ) . filter ( x -> 0 < x . keyCondition . getSubBlocks ( ) . size ( ) ) . collect ( Collectors . toList ( ) ) ; \ndescriptors . addAll ( fullTextIndexDescriptors ) ; \ndescriptors = removePrefixIndexes ( descriptors ) ; \nList < OPair < Integer , IndexSearchDescriptor > > sortedDescriptors = descriptors . stream ( ) . map ( x -> ( OPair < Integer , IndexSearchDescriptor > ) new OPair ( x . cost ( ctx ) , x ) ) . sorted ( ) . collect ( Collectors . toList ( ) ) ; \ndescriptors = sortedDescriptors . isEmpty ( ) ? Collections . emptyList ( ) : sortedDescriptors . stream ( ) . filter ( x -> x . key . equals ( sortedDescriptors . get ( 0 ) . key ) ) . map ( x -> x . value ) . collect ( Collectors . toList ( ) ) ; \ndescriptors = descriptors . stream ( ) . sorted ( Comparator . comparingInt ( x -> x . keyCondition . getSubBlocks ( ) . size ( ) ) ) . collect ( Collectors . toList ( ) ) ; \nreturn descriptors . isEmpty ( ) ? null : descriptors . get ( descriptors . size ( ) - 1 ) ; \n} \n} \n"}
{"2929": "public class OSelectExecutionPlanner { \nprivate IndexSearchDescriptor buildIndexSearchDescriptorForFulltext ( OCommandContext ctx , OIndex < ? > index , OAndBlock block , OClass clazz ) { \nList < String > indexFields = index . getDefinition ( ) . getFields ( ) ; \nOBinaryCondition keyCondition = new OBinaryCondition ( - 1 ) ; \nOIdentifier key = new OIdentifier ( \"key\" ) ; \nkeyCondition . setLeft ( new OExpression ( key ) ) ; \nboolean found = false ; \nOAndBlock blockCopy = block . copy ( ) ; \nIterator < OBooleanExpression > blockIterator ; \nOAndBlock indexKeyValue = new OAndBlock ( - 1 ) ; \nIndexSearchDescriptor result = new IndexSearchDescriptor ( ) ; \nresult . idx = index ; \nresult . keyCondition = indexKeyValue ; \nfor ( String indexField : indexFields ) { \nblockIterator = blockCopy . getSubBlocks ( ) . iterator ( ) ; \nboolean breakHere = false ; \nboolean indexFieldFound = false ; \nwhile ( blockIterator . hasNext ( ) ) { \nOBooleanExpression singleExp = blockIterator . next ( ) ; \nif ( singleExp instanceof OContainsTextCondition ) { \nOExpression left = ( ( OContainsTextCondition ) singleExp ) . getLeft ( ) ; \nif ( left . isBaseIdentifier ( ) ) { \nString fieldName = left . getDefaultAlias ( ) . getStringValue ( ) ; \nif ( indexField . equals ( fieldName ) ) { \nfound = true ; \nindexFieldFound = true ; \nOContainsTextCondition condition = new OContainsTextCondition ( - 1 ) ; \ncondition . setLeft ( left ) ; \ncondition . setRight ( ( ( OContainsTextCondition ) singleExp ) . getRight ( ) . copy ( ) ) ; \nindexKeyValue . getSubBlocks ( ) . add ( condition ) ; \nblockIterator . remove ( ) ; \nbreak ; \n} \n} \n} \n} \nif ( breakHere || ! indexFieldFound ) { \nbreak ; \n} \n} \nif ( index . getDefinition ( ) . getFields ( ) . size ( ) > result . keyCondition . getSubBlocks ( ) . size ( ) && ! index . supportsOrderedIterations ( ) ) { \nreturn null ; \n} \nif ( found ) { \nresult . remainingCondition = blockCopy ; \nreturn result ; \n} \nreturn null ; \n} \n} \n"}
{"2934": "public class ODistributedOutput { \npublic static String getCompactServerStatus ( final ODistributedServerManager manager , final ODocument distribCfg ) { \nfinal StringBuilder buffer = new StringBuilder ( ) ; \nfinal Collection < ODocument > members = distribCfg . field ( \"members\" ) ; \nif ( members != null ) { \nbuffer . append ( members . size ( ) ) ; \nbuffer . append ( \":[\" ) ; \nint memberCount = 0 ; \nfor ( ODocument m : members ) { \nif ( m == null ) continue ; \nif ( 0 < memberCount ++ ) buffer . append ( \",\" ) ; \nfinal String serverName = m . field ( \"name\" ) ; \nbuffer . append ( serverName ) ; \nbuffer . append ( ( Object ) m . field ( \"status\" ) ) ; \nfinal Collection < String > databases = m . field ( \"databases\" ) ; \nif ( databases != null ) { \nbuffer . append ( \"{\" ) ; \nint dbCount = 0 ; \nfor ( String dbName : databases ) { \nfinal ODistributedConfiguration dbCfg = manager . getDatabaseConfiguration ( dbName , false ) ; \nif ( dbCfg == null ) continue ; \nif ( 0 < dbCount ++ ) buffer . append ( \",\" ) ; \nbuffer . append ( dbName ) ; \nbuffer . append ( \"=\" ) ; \nbuffer . append ( manager . getDatabaseStatus ( serverName , dbName ) ) ; \nbuffer . append ( \" (\" ) ; \nbuffer . append ( dbCfg . getServerRole ( serverName ) ) ; \nbuffer . append ( \")\" ) ; \n} \nbuffer . append ( \"}\" ) ; \n} \n} \nbuffer . append ( \"]\" ) ; \n} \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"2938": "public class OHazelcastPlugin { \n@ Override public String electNewLockManager ( ) { \nif ( hazelcastInstance == null ) throw new HazelcastInstanceNotActiveException ( ) ; \nfinal ILock lock = hazelcastInstance . getLock ( \"orientdb.lockManagerElection\" ) ; \nlock . lock ( ) ; \ntry { \nString lockManagerServer = getLockManagerRequester ( ) . getServer ( ) ; \nif ( lockManagerServer != null && getActiveServers ( ) . contains ( lockManagerServer ) ) return lockManagerServer ; \nfinal String originalLockManager = lockManagerServer ; \nODistributedServerLog . debug ( this , nodeName , originalLockManager , DIRECTION . OUT , \"lock '%s' is unreachable, electing a new lock...\" , originalLockManager ) ; \nint lockManagerServerId = - 1 ; \nif ( lockManagerServer != null && registeredNodeByName . containsKey ( lockManagerServer ) ) lockManagerServerId = registeredNodeByName . get ( lockManagerServer ) ; \nString newServer = null ; \nint currIndex = lockManagerServerId ; \nfor ( int i = 0 ; \nregisteredNodeById . size ( ) > i ; \n++ i ) { \ncurrIndex ++ ; \nif ( registeredNodeById . size ( ) <= currIndex ) currIndex = 0 ; \nnewServer = registeredNodeById . get ( currIndex ) ; \nif ( newServer == null ) throw new OConfigurationException ( \"Found null server at index \" + currIndex + \" of server list \" + registeredNodeById ) ; \nif ( newServer . equalsIgnoreCase ( getLocalNodeName ( ) ) || activeNodes . containsKey ( newServer ) ) { \nODistributedServerLog . debug ( this , nodeName , newServer , DIRECTION . OUT , \"Trying to elected server '%s' as new lock (old=%s)...\" , newServer , originalLockManager ) ; \ntry { \ngetLockManagerRequester ( ) . setServer ( newServer ) ; \nconfigurationMap . put ( CONFIG_LOCKMANAGER , getLockManagerRequester ( ) . getServer ( ) ) ; \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Elected server '%s' as new lock (old=%s)\" , newServer , originalLockManager ) ; \nbreak ; \n} \ncatch ( Exception e ) { \nODistributedServerLog . info ( this , nodeName , newServer , DIRECTION . OUT , \"Error on electing server '%s' as new lock (error: %s)\" , newServer , e ) ; \n} \n} \n} \nreturn newServer ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"2940": "public class OMicroTransaction { \npublic void commit ( ) { \nif ( ! active ) throw error ( \"Inactive micro-transaction on commit\" ) ; \nif ( 1 > level ) throw error ( \"Unbalanced micro-transaction, level = \" + level ) ; \n-- level ; \nif ( level == 0 ) { \nactive = false ; \ndoCommit ( ) ; \n} \n} \n} \n"}
{"2941": "public class OMicroTransaction { \npublic void rollback ( ) { \nif ( ! active ) throw error ( \"Inactive micro-transaction on rollback\" ) ; \nif ( 1 > level ) throw error ( \"Unbalanced micro-transaction, level = \" + level ) ; \n-- level ; \nif ( level == 0 ) { \nactive = false ; \ndoRollback ( ) ; \n} \n} \n} \n"}
{"2946": "public class Pattern { \npublic List < Pattern > getDisjointPatterns ( ) { \nMap < PatternNode , String > reverseMap = new IdentityHashMap < > ( ) ; \nreverseMap . putAll ( this . aliasToNode . entrySet ( ) . stream ( ) . collect ( Collectors . toMap ( x -> x . getValue ( ) , x -> x . getKey ( ) ) ) ) ; \nList < Pattern > result = new ArrayList < > ( ) ; \nwhile ( ! reverseMap . isEmpty ( ) ) { \nPattern pattern = new Pattern ( ) ; \nresult . add ( pattern ) ; \nMap . Entry < PatternNode , String > nextNode = reverseMap . entrySet ( ) . iterator ( ) . next ( ) ; \nSet < PatternNode > toVisit = new HashSet < > ( ) ; \ntoVisit . add ( nextNode . getKey ( ) ) ; \nwhile ( 0 < toVisit . size ( ) ) { \nPatternNode currentNode = toVisit . iterator ( ) . next ( ) ; \ntoVisit . remove ( currentNode ) ; \nif ( reverseMap . containsKey ( currentNode ) ) { \npattern . aliasToNode . put ( reverseMap . get ( currentNode ) , currentNode ) ; \nreverseMap . remove ( currentNode ) ; \nfor ( PatternEdge x : currentNode . out ) { \ntoVisit . add ( x . in ) ; \n} \nfor ( PatternEdge x : currentNode . in ) { \ntoVisit . add ( x . out ) ; \n} \n} \n} \npattern . recalculateNumOfEdges ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"2947": "public class ODistributedStorage { \nprotected boolean executeOnlyLocally ( final String localNodeName , final ODistributedConfiguration dbCfg , final OCommandExecutor exec , final Collection < String > involvedClusters , final Collection < String > nodes ) { \nboolean executeLocally = false ; \nif ( exec . isIdempotent ( ) ) { \nfinal int availableNodes = nodes . size ( ) ; \nint maxReadQuorum ; \nif ( involvedClusters . isEmpty ( ) ) maxReadQuorum = dbCfg . getReadQuorum ( null , availableNodes , localNodeName ) ; \nelse { \nmaxReadQuorum = 0 ; \nfor ( String cl : involvedClusters ) maxReadQuorum = Math . max ( maxReadQuorum , dbCfg . getReadQuorum ( cl , availableNodes , localNodeName ) ) ; \n} \nif ( nodes . contains ( localNodeName ) && 1 >= maxReadQuorum ) executeLocally = true ; \n} \nreturn executeLocally ; \n} \npublic boolean isLocalEnv ( ) { \nreturn localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal . INSTANCE . isRunModeDistributed ( ) ; \n} \npublic OStorageOperationResult < ORawBuffer > readRecord ( final ORecordId iRecordId , final String iFetchPlan , final boolean iIgnoreCache , final boolean prefetchRecords , final ORecordCallback < ORawBuffer > iCallback ) { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( iRecordId ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( iRecordId ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && 1 >= dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; \n} \n} \n) ; \n} \nfinal OReadRecordTask task = ( ( OReadRecordTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordTask . FACTORYID ) ) . init ( iRecordId ) ; \nfinal ODistributedResponse response = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) ; \nfinal Object dResult = response != null ? response . getPayload ( ) : null ; \nif ( dResult instanceof ONeedRetryException ) throw ( ONeedRetryException ) dResult ; \nelse if ( dResult instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) dResult ) ; \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) dResult ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , iRecordId ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < ORawBuffer > readRecordIfVersionIsNotLatest ( final ORecordId rid , final String fetchPlan , final boolean ignoreCache , final int recordVersion ) throws ORecordNotFoundException { \nif ( isLocalEnv ( ) ) { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \nfinal ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( rid ) ; \nif ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; \ntry { \nfinal String clusterName = getClusterNameByRID ( rid ) ; \nfinal ODistributedConfiguration dbCfg = distributedConfiguration ; \nfinal List < String > nodes = dbCfg . getServers ( clusterName , null ) ; \nfinal int availableNodes = nodes . size ( ) ; \nfinal String localNodeName = dManager . getLocalNodeName ( ) ; \nif ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && 1 >= dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) ) { \nreturn ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { \n@ Override public Object call ( ) throws Exception { \nreturn wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; \n} \n} \n) ; \n} \nfinal OReadRecordIfNotLatestTask task = ( OReadRecordIfNotLatestTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordIfNotLatestTask . FACTORYID ) ; \ntask . init ( rid , recordVersion ) ; \nfinal Object result = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) . getPayload ( ) ; \nif ( result instanceof ONeedRetryException ) throw ( ONeedRetryException ) result ; \nelse if ( result instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) result ) ; \nreturn new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) result ) ; \n} \ncatch ( ONeedRetryException e ) { \nthrow e ; \n} \ncatch ( Exception e ) { \nhandleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , rid ) ; \nreturn null ; \n} \n} \n@ Override public OStorageOperationResult < Boolean > deleteRecord ( final ORecordId iRecordId , final int iVersion , final int iMode , final ORecordCallback < Boolean > iCallback ) { \nreturn wrapped . deleteRecord ( iRecordId , iVersion , iMode , iCallback ) ; \n} \n} \n"}
{"2958": "public class OFileClassic { \nprivate long checkRegions ( final long iOffset , final long iLength ) { \nacquireReadLock ( ) ; \ntry { \nif ( 0 > iOffset || size < iOffset + iLength ) { \nthrow new OIOException ( \"You cannot access outside the file size (\" + size + \" bytes). You have requested portion \" + iOffset + \"-\" + ( iOffset + iLength ) + \" bytes. File: \" + this ) ; \n} \nreturn iOffset + HEADER_SIZE ; \n} \nfinally { \nreleaseReadLock ( ) ; \n} \n} \n} \n"}
{"2962": "public class OStorageRemote { \nprotected String addHost ( String host ) { \nif ( host . startsWith ( LOCALHOST ) ) host = LOCAL_IP + host . substring ( \"localhost\" . length ( ) ) ; \nif ( host . contains ( \"/\" ) ) host = host . substring ( 0 , host . indexOf ( \"/\" ) ) ; \nif ( ! host . contains ( \":\" ) ) host += \":\" + ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \nelse if ( 2 > host . split ( \":\" ) . length || host . split ( \":\" ) [ 1 ] . trim ( ) . length ( ) == 0 ) host += ( clientConfiguration . getValueAsBoolean ( OGlobalConfiguration . CLIENT_USE_SSL ) ? getDefaultSSLPort ( ) : getDefaultPort ( ) ) ; \nsynchronized ( serverURLs ) { \nif ( ! serverURLs . contains ( host ) ) { \nserverURLs . add ( host ) ; \nOLogManager . instance ( ) . debug ( this , \"Registered the new available server '%s'\" , host ) ; \n} \n} \nreturn host ; \n} \n} \n"}
{"2975": "public class OJSONReader { \npublic int nextChar ( ) throws IOException { \nif ( missedChar != null ) { \nc = missedChar . charValue ( ) ; \nmissedChar = null ; \n} \nelse { \nint read = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nc = ( char ) read ; \nif ( c == '\\\\' ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nchar c2 = ( char ) read ; \nif ( c2 == 'u' ) { \nfinal StringBuilder buff = new StringBuilder ( 8 ) ; \nfor ( int i = 0 ; \n4 > i ; \n++ i ) { \nread = in . read ( ) ; \nif ( read == - 1 ) return - 1 ; \nbuff . append ( ( char ) read ) ; \n} \ncursor += 6 ; \nreturn ( char ) Integer . parseInt ( buff . toString ( ) , 16 ) ; \n} \nelse { \nmissedChar = c2 ; \n} \n} \n} \ncursor ++ ; \nif ( c == NEW_LINE ) { \n++ lineNumber ; \ncolumnNumber = 0 ; \n} \nelse ++ columnNumber ; \nreturn ( char ) c ; \n} \n} \n"}
{"2979": "public class ONative { \npublic int getOpenFilesLimit ( boolean verbose , int recommended , int defLimit ) { \nif ( Platform . isLinux ( ) ) { \nfinal OCLibrary . Rlimit rlimit = new OCLibrary . Rlimit ( ) ; \nfinal int result = C_LIBRARY . getrlimit ( OCLibrary . RLIMIT_NOFILE , rlimit ) ; \nif ( result == 0 && 0 < rlimit . rlim_cur ) { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Detected limit of amount of simultaneously open files is %d, \" + \" limit of open files for disk cache will be set to %d\" , rlimit . rlim_cur , rlimit . rlim_cur / 2 - 512 ) ; \n} \nif ( recommended > rlimit . rlim_cur ) { \nOLogManager . instance ( ) . warnNoDb ( this , \"Value of limit of simultaneously open files is too small, recommended value is %d\" , recommended ) ; \n} \nreturn ( int ) rlimit . rlim_cur / 2 - 512 ; \n} \nelse { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Can not detect value of limit of open files.\" ) ; \n} \n} \n} \nelse if ( Platform . isWindows ( ) ) { \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Windows OS is detected, %d limit of open files will be set for the disk cache.\" , recommended ) ; \n} \nreturn recommended ; \n} \nif ( verbose ) { \nOLogManager . instance ( ) . infoNoDb ( this , \"Default limit of open files (%d) will be used.\" , defLimit ) ; \n} \nreturn defLimit ; \n} \n} \n"}
{"2981": "public class OMemoryStream { \npublic void move ( final int iFrom , final int iPosition ) { \nif ( iPosition == 0 ) return ; \nfinal int to = iFrom + iPosition ; \nfinal int size = 0 < iPosition ? buffer . length - to : buffer . length - iFrom ; \nSystem . arraycopy ( buffer , iFrom , buffer , to , size ) ; \n} \n} \n"}
{"2983": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeUntilReturn ( ) { \nif ( 0 < steps . size ( ) ) { \nlastStep = steps . get ( steps . size ( ) - 1 ) ; \n} \nfor ( int i = 0 ; \nsteps . size ( ) - 1 > i ; \ni ++ ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) { \nlastStep = returnStep ; \nreturn lastStep ; \n} \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nwhile ( lastResult . hasNext ( ) ) { \nwhile ( lastResult . hasNext ( ) ) { \nlastResult . next ( ) ; \n} \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \n} \nthis . lastStep = steps . get ( steps . size ( ) - 1 ) ; \nreturn lastStep ; \n} \n} \n"}
{"2984": "public class OScriptExecutionPlan { \npublic OExecutionStepInternal executeFull ( ) { \nfor ( int i = 0 ; \nsteps . size ( ) > i ; \ni ++ ) { \nScriptLineStep step = steps . get ( i ) ; \nif ( step . containsReturn ( ) ) { \nOExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; \nif ( returnStep != null ) { \nreturn returnStep ; \n} \n} \nOResultSet lastResult = step . syncPull ( ctx , 100 ) ; \nwhile ( lastResult . hasNext ( ) ) { \nwhile ( lastResult . hasNext ( ) ) { \nlastResult . next ( ) ; \n} \nlastResult = step . syncPull ( ctx , 100 ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"2986": "public class OCommandExecutorSQLMoveVertex { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nODatabaseDocumentInternal db = getDatabase ( ) ; \ndb . begin ( ) ; \nif ( className == null && clusterName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nOModifiableBoolean shutdownGraph = new OModifiableBoolean ( ) ; \nfinal boolean txAlreadyBegun = getDatabase ( ) . getTransaction ( ) . isActive ( ) ; \ntry { \nfinal Set < OIdentifiable > sourceRIDs = OSQLEngine . getInstance ( ) . parseRIDTarget ( db , source , context , iArgs ) ; \nfinal List < ODocument > result = new ArrayList < ODocument > ( sourceRIDs . size ( ) ) ; \nfor ( OIdentifiable from : sourceRIDs ) { \nfinal OVertex fromVertex = toVertex ( from ) ; \nif ( fromVertex == null ) continue ; \nfinal ORID oldVertex = fromVertex . getIdentity ( ) . copy ( ) ; \nfinal ORID newVertex = fromVertex . moveTo ( className , clusterName ) ; \nfinal ODocument newVertexDoc = newVertex . getRecord ( ) ; \nif ( fields != null ) { \nfor ( final OPair < String , Object > f : fields ) { \nif ( f . getValue ( ) instanceof OSQLFunctionRuntime ) f . setValue ( ( ( OSQLFunctionRuntime ) f . getValue ( ) ) . getValue ( newVertex . getRecord ( ) , null , context ) ) ; \n} \nOSQLHelper . bindParameters ( newVertexDoc , fields , new OCommandParameters ( iArgs ) , context ) ; \n} \nif ( merge != null ) newVertexDoc . merge ( merge , true , false ) ; \nnewVertexDoc . save ( ) ; \nresult . add ( new ODocument ( ) . setTrackingChanges ( false ) . field ( \"old\" , oldVertex , OType . LINK ) . field ( \"new\" , newVertex , OType . LINK ) ) ; \nif ( 0 < batch && result . size ( ) % batch == 0 ) { \ndb . commit ( ) ; \ndb . begin ( ) ; \n} \n} \ndb . commit ( ) ; \nreturn result ; \n} \nfinally { \n} \n} \n} \n"}
{"2994": "public class OSQLFilterItemField { \npublic OCollate getCollate ( Object doc ) { \nif ( collate != null || operationsChain == null || ! isFieldChain ( ) ) { \nreturn collate ; \n} \nif ( ! ( doc instanceof OIdentifiable ) ) { \nreturn null ; \n} \nFieldChain chain = getFieldChain ( ) ; \nODocument lastDoc = ( ( OIdentifiable ) doc ) . getRecord ( ) ; \nfor ( int i = 0 ; \nchain . getItemCount ( ) - 1 > i ; \ni ++ ) { \nif ( lastDoc == null ) { \nreturn null ; \n} \nObject nextDoc = lastDoc . field ( chain . getItemName ( i ) ) ; \nif ( nextDoc == null || ! ( nextDoc instanceof OIdentifiable ) ) { \nreturn null ; \n} \nlastDoc = ( ( OIdentifiable ) nextDoc ) . getRecord ( ) ; \n} \nif ( lastDoc == null ) { \nreturn null ; \n} \nOClass schemaClass = lastDoc . getSchemaClass ( ) ; \nif ( schemaClass == null ) { \nreturn null ; \n} \nOProperty property = schemaClass . getProperty ( chain . getItemName ( chain . getItemCount ( ) - 1 ) ) ; \nif ( property == null ) { \nreturn null ; \n} \nreturn property . getCollate ( ) ; \n} \n} \n"}
{"3002": "public class OIndexAbstract { \npublic OIndexInternal < ? > create ( final OIndexDefinition indexDefinition , final String clusterIndexName , final Set < String > clustersToIndex , boolean rebuild , final OProgressListener progressListener , final OBinarySerializer valueSerializer ) { \nacquireExclusiveLock ( ) ; \ntry { \nconfiguration = indexConfigurationInstance ( new ODocument ( ) . setTrackingChanges ( false ) ) ; \nthis . indexDefinition = indexDefinition ; \nif ( clustersToIndex != null ) this . clustersToIndex = new HashSet < > ( clustersToIndex ) ; \nelse this . clustersToIndex = new HashSet < > ( ) ; \ntry { \nif ( apiVersion == 0 ) { \nremoveValuesContainer ( ) ; \n} \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error during deletion of index '%s'\" , e , name ) ; \n} \nindexId = storage . addIndexEngine ( name , algorithm , type , indexDefinition , valueSerializer , isAutomatic ( ) , true , version , 1 , this instanceof OIndexMultiValues , getEngineProperties ( ) , clustersToIndex , metadata ) ; \napiVersion = OAbstractPaginatedStorage . extractEngineAPIVersion ( indexId ) ; \nassert 0 <= indexId ; \nassert 0 <= apiVersion ; \nonIndexEngineChange ( indexId ) ; \nif ( rebuild ) fillIndex ( progressListener , false ) ; \nupdateConfiguration ( ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Exception during index '%s' creation\" , e , name ) ; \nwhile ( true ) try { \nif ( 0 <= indexId ) storage . deleteIndexEngine ( indexId ) ; \nbreak ; \n} \ncatch ( OInvalidIndexEngineIdException ignore ) { \ndoReloadIndexEngine ( ) ; \n} \ncatch ( Exception ex ) { \nOLogManager . instance ( ) . error ( this , \"Exception during index '%s' deletion\" , ex , name ) ; \n} \nif ( e instanceof OIndexException ) throw ( OIndexException ) e ; \nthrow OException . wrapException ( new OIndexException ( \"Cannot create the index '\" + name + \"'\" ) , e ) ; \n} \nfinally { \nreleaseExclusiveLock ( ) ; \n} \nreturn this ; \n} \n} \n"}
{"3003": "public class OrientGraphQuery { \n@ Override public Iterable < Vertex > vertices ( ) { \nif ( limit == 0 ) return Collections . emptyList ( ) ; \nOTransaction transaction = ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) ; \nif ( transaction . isActive ( ) && 0 < transaction . getEntryCount ( ) || hasCustomPredicate ( ) ) { \nString [ ] classes = allSubClassesLabels ( ) ; \nreturn new OrientGraphQueryIterable < Vertex > ( true , classes ) ; \n} \nfinal StringBuilder text = new StringBuilder ( 512 ) ; \ntext . append ( QUERY_SELECT_FROM ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) && labels != null && 0 < labels . length ) { \nif ( labels . length == 1 ) text . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; \nelse { \nString [ ] classes = allSubClassesLabels ( ) ; \nreturn new OrientGraphQueryIterable < Vertex > ( true , classes ) ; \n} \n} \nelse text . append ( OrientVertexType . CLASS_NAME ) ; \nfinal List < Object > queryParams = manageFilters ( text ) ; \nif ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForVertexLabel ( ) ) manageLabels ( 0 < queryParams . size ( ) , text ) ; \nif ( 1 < orderBy . length ( ) ) { \ntext . append ( ORDERBY ) ; \ntext . append ( orderBy ) ; \ntext . append ( \" \" ) . append ( orderByDir ) . append ( \" \" ) ; \n} \nif ( 0 < skip && Integer . MAX_VALUE > skip ) { \ntext . append ( SKIP ) ; \ntext . append ( skip ) ; \n} \nif ( 0 < limit && Integer . MAX_VALUE > limit ) { \ntext . append ( LIMIT ) ; \ntext . append ( limit ) ; \n} \nfinal OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; \nif ( fetchPlan != null ) query . setFetchPlan ( fetchPlan ) ; \nreturn new OrientElementIterable < Vertex > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; \n} \n} \n"}
{"3004": "public class OrientGraphQuery { \n@ Override public Iterable < Edge > edges ( ) { \nif ( limit == 0 ) return Collections . emptyList ( ) ; \nif ( ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . getTransaction ( ) . isActive ( ) || hasCustomPredicate ( ) ) return new OrientGraphQueryIterable < Edge > ( false , labels ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseLightweightEdges ( ) ) return new OrientGraphQueryIterable < Edge > ( false , labels ) ; \nfinal StringBuilder text = new StringBuilder ( 512 ) ; \ntext . append ( QUERY_SELECT_FROM ) ; \nif ( ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) && labels != null && 0 < labels . length ) { \nif ( labels . length == 1 ) text . append ( OrientBaseGraph . encodeClassName ( labels [ 0 ] ) ) ; \nelse { \nreturn new OrientGraphQueryIterable < Edge > ( false , labels ) ; \n} \n} \nelse text . append ( OrientEdgeType . CLASS_NAME ) ; \nList < Object > queryParams = manageFilters ( text ) ; \nif ( ! ( ( OrientBaseGraph ) graph ) . isUseClassForEdgeLabel ( ) ) manageLabels ( 0 < queryParams . size ( ) , text ) ; \nfinal OSQLSynchQuery < OIdentifiable > query = new OSQLSynchQuery < OIdentifiable > ( text . toString ( ) ) ; \nif ( fetchPlan != null ) query . setFetchPlan ( fetchPlan ) ; \nif ( 0 < limit && Integer . MAX_VALUE > limit ) query . setLimit ( limit ) ; \nreturn new OrientElementIterable < Edge > ( ( ( OrientBaseGraph ) graph ) , ( ( OrientBaseGraph ) graph ) . getRawGraph ( ) . query ( query , queryParams . toArray ( ) ) ) ; \n} \n} \n"}
{"3005": "public class OAbstract2pcTask { \n@ Override public int [ ] getPartitionKey ( ) { \nif ( tasks . size ( ) == 1 ) return tasks . get ( 0 ) . getPartitionKey ( ) ; \nfinal int [ ] partitions = new int [ tasks . size ( ) ] ; \nfor ( int i = 0 ; \ntasks . size ( ) > i ; \n++ i ) { \nfinal OAbstractRecordReplicatedTask task = tasks . get ( i ) ; \npartitions [ i ] = task . getPartitionKey ( ) [ 0 ] ; \n} \nreturn partitions ; \n} \n} \n"}
{"3008": "public class OAtomicOperation { \nprivate static boolean checkChangesFilledUpTo ( final FileChanges changesContainer , final long pageIndex ) { \nif ( changesContainer == null ) { \nreturn true ; \n} \nelse if ( changesContainer . isNew || - 2 < changesContainer . maxNewPageIndex ) { \nreturn changesContainer . maxNewPageIndex + 1 > pageIndex ; \n} \nelse return ! changesContainer . truncate ; \n} \n} \n"}
{"3009": "public class OCommandExecutorSQLAbstract { \nprotected boolean parseTimeout ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_TIMEOUT ) ) return false ; \nString word = parserNextWord ( true ) ; \ntry { \ntimeoutMs = Long . parseLong ( word ) ; \n} \ncatch ( NumberFormatException ignore ) { \nthrowParsingException ( \"Invalid \" + KEYWORD_TIMEOUT + \" value set to '\" + word + \"' but it should be a valid long. Example: \" + KEYWORD_TIMEOUT + \" 3000\" ) ; \n} \nif ( 0 > timeoutMs ) throwParsingException ( \"Invalid \" + KEYWORD_TIMEOUT + \": value set minor than ZERO. Example: \" + KEYWORD_TIMEOUT + \" 10000\" ) ; \nword = parserNextWord ( true ) ; \nif ( word != null ) if ( word . equals ( TIMEOUT_STRATEGY . EXCEPTION . toString ( ) ) ) timeoutStrategy = TIMEOUT_STRATEGY . EXCEPTION ; \nelse if ( word . equals ( TIMEOUT_STRATEGY . RETURN . toString ( ) ) ) timeoutStrategy = TIMEOUT_STRATEGY . RETURN ; \nelse parserGoBack ( ) ; \nreturn true ; \n} \n} \n"}
{"3019": "public class OSQLPredicate { \npublic void bindParameters ( final Map < Object , Object > iArgs ) { \nif ( parameterItems == null || iArgs == null || iArgs . size ( ) == 0 ) return ; \nfor ( int i = 0 ; \nparameterItems . size ( ) > i ; \ni ++ ) { \nOSQLFilterItemParameter value = parameterItems . get ( i ) ; \nif ( \"?\" . equals ( value . getName ( ) ) ) { \nvalue . setValue ( iArgs . get ( i ) ) ; \n} \nelse { \nvalue . setValue ( iArgs . get ( value . getName ( ) ) ) ; \n} \n} \n} \n} \n"}
{"3020": "public class FrequencySketch { \nprivate void reset ( ) { \nint count = 0 ; \nfor ( int i = 0 ; \ntable . length > i ; \ni ++ ) { \ncount += Long . bitCount ( table [ i ] & ONE_MASK ) ; \ntable [ i ] = ( table [ i ] >>> 1 ) & RESET_MASK ; \n} \nsize = ( size >>> 1 ) - ( count >>> 2 ) ; \n} \n} \n"}
{"3024": "public class OPropertyImpl { \n@ Deprecated public OPropertyImpl dropIndexes ( ) { \ngetDatabase ( ) . checkSecurity ( ORule . ResourceGeneric . SCHEMA , ORole . PERMISSION_DELETE ) ; \nacquireSchemaReadLock ( ) ; \ntry { \nfinal OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; \nfinal ArrayList < OIndex < ? > > relatedIndexes = new ArrayList < OIndex < ? > > ( ) ; \nfor ( final OIndex < ? > index : indexManager . getClassIndexes ( owner . getName ( ) ) ) { \nfinal OIndexDefinition definition = index . getDefinition ( ) ; \nif ( - 1 < OCollections . indexOf ( definition . getFields ( ) , globalRef . getName ( ) , new OCaseInsentiveComparator ( ) ) ) { \nif ( definition instanceof OPropertyIndexDefinition ) { \nrelatedIndexes . add ( index ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"This operation applicable only for property indexes. \" + index . getName ( ) + \" is \" + index . getDefinition ( ) ) ; \n} \n} \n} \nfor ( final OIndex < ? > index : relatedIndexes ) getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) . dropIndex ( index . getName ( ) ) ; \nreturn this ; \n} \nfinally { \nreleaseSchemaReadLock ( ) ; \n} \n} \n} \n"}
{"3035": "public class OCommandExecutorSQLCreateCluster { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( clusterName == null ) throw new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \nfinal ODatabaseDocument database = getDatabase ( ) ; \nfinal int clusterId = database . getClusterIdByName ( clusterName ) ; \nif ( - 1 < clusterId ) throw new OCommandSQLParsingException ( \"Cluster '\" + clusterName + \"' already exists\" ) ; \nif ( blob ) { \nif ( requestedId == - 1 ) { \nreturn database . addBlobCluster ( clusterName ) ; \n} \nelse { \nthrow new OCommandExecutionException ( \"Request id not supported by blob cluster creation.\" ) ; \n} \n} \nelse { \nif ( requestedId == - 1 ) { \nreturn database . addCluster ( clusterName ) ; \n} \nelse { \nreturn database . addCluster ( clusterName , requestedId , null ) ; \n} \n} \n} \n} \n"}
{"3049": "public class ODatabaseDocumentTxPooled { \n@ Override public void close ( ) { \nif ( isClosed ( ) ) return ; \ncheckOpenness ( ) ; \nif ( ownerPool != null && 1 < ownerPool . getConnectionsInCurrentThread ( getURL ( ) , userName ) ) { \nownerPool . release ( this ) ; \nreturn ; \n} \ntry { \ncommit ( true ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error on releasing database '%s' in pool\" , e , getName ( ) ) ; \n} \ntry { \ncallOnCloseListeners ( ) ; \n} \ncatch ( Exception e ) { \nOLogManager . instance ( ) . error ( this , \"Error on releasing database '%s' in pool\" , e , getName ( ) ) ; \n} \ngetLocalCache ( ) . clear ( ) ; \nif ( ownerPool != null ) { \nfinal ODatabaseDocumentPool localCopy = ownerPool ; \nownerPool = null ; \nlocalCopy . release ( this ) ; \n} \nODatabaseRecordThreadLocal . instance ( ) . remove ( ) ; \n} \n} \n"}
{"3076": "public class ODirtyManager { \nprivate static Set < ORecord > mergeSet ( Set < ORecord > target , Set < ORecord > source ) { \nif ( source != null ) { \nif ( target == null ) { \nreturn source ; \n} \nelse { \nif ( source . size ( ) < target . size ( ) ) { \ntarget . addAll ( source ) ; \nreturn target ; \n} \nelse { \nsource . addAll ( target ) ; \nreturn source ; \n} \n} \n} \nelse { \nreturn target ; \n} \n} \n} \n"}
{"3080": "public class OWALSegmentCache { \nvoid writePage ( ByteBuffer page , long pageIndex ) throws IOException { \nsynchronized ( lockObject ) { \nlastAccessTime = System . nanoTime ( ) ; \nif ( firstCachedPage <= pageIndex && firstCachedPage + pageCache . size ( ) >= pageIndex ) { \nif ( firstCachedPage + pageCache . size ( ) > pageIndex ) { \npageCache . set ( ( int ) ( pageIndex - firstCachedPage ) , page ) ; \n} \nelse { \npageCache . add ( page ) ; \n} \n} \nelse if ( pageCache . isEmpty ( ) ) { \npageCache . add ( page ) ; \nfirstCachedPage = pageIndex ; \n} \nlastWrittenPage = page ; \nlastWrittenPageIndex = pageIndex ; \nif ( bufferSize + OWALPage . PAGE_SIZE <= pageCache . size ( ) * OWALPage . PAGE_SIZE ) { \nflushAllBufferPagesExceptLastOne ( ) ; \n} \n} \n} \n} \n"}
{"3081": "public class OWALSegmentCache { \nbyte [ ] readPage ( long pageIndex ) throws IOException { \nsynchronized ( lockObject ) { \nlastAccessTime = System . nanoTime ( ) ; \nif ( pageIndex == lastWrittenPageIndex ) { \nreturn lastWrittenPage . array ( ) ; \n} \nif ( firstCachedPage <= pageIndex && firstCachedPage + pageCache . size ( ) > pageIndex ) { \nfinal ByteBuffer buffer = pageCache . get ( ( int ) ( pageIndex - firstCachedPage ) ) ; \nreturn buffer . array ( ) ; \n} \nfinal ByteBuffer buffer = ByteBuffer . allocate ( OWALPage . PAGE_SIZE ) . order ( ByteOrder . nativeOrder ( ) ) ; \ninitFile ( ) ; \nsegChannel . position ( pageIndex * OWALPage . PAGE_SIZE ) ; \nreadByteBuffer ( buffer , segChannel ) ; \nreturn buffer . array ( ) ; \n} \n} \n} \n"}
{"3083": "public class OWALSegmentCache { \npublic void open ( ) throws IOException { \nsynchronized ( lockObject ) { \nlastAccessTime = System . nanoTime ( ) ; \ninitFile ( ) ; \nlong pagesCount = segChannel . size ( ) / OWALPage . PAGE_SIZE ; \nif ( 0 < segChannel . size ( ) % OWALPage . PAGE_SIZE ) { \nOLogManager . instance ( ) . error ( this , \"Last WAL page was written partially, auto fix\" , null ) ; \nsegChannel . truncate ( OWALPage . PAGE_SIZE * pagesCount ) ; \n} \nfirstCachedPage = - 1 ; \npageCache . clear ( ) ; \nlastWrittenPage = null ; \nlastWrittenPageIndex = - 1 ; \n} \n} \n} \n"}
{"3096": "public class ODistributedConfiguration { \npublic String getClusterOwner ( final String iClusterName ) { \nString owner ; \nfinal ODocument clusters = getConfiguredClusters ( ) ; \nfinal ODocument cfg = iClusterName != null ? ( ODocument ) clusters . field ( iClusterName ) : null ; \nif ( cfg != null ) { \nowner = cfg . field ( OWNER ) ; \nif ( owner != null ) return owner ; \nfinal List < String > serverList = cfg . field ( SERVERS ) ; \nif ( serverList != null && ! serverList . isEmpty ( ) ) { \nowner = serverList . get ( 0 ) ; \nif ( NEW_NODE_TAG . equals ( owner ) && 1 < serverList . size ( ) ) owner = serverList . get ( 1 ) ; \n} \n} \nelse return getClusterOwner ( ALL_WILDCARD ) ; \nreturn owner ; \n} \n} \n"}
{"3117": "public class OrientBaseGraph { \npublic OrientEdge getEdge ( final Object id ) { \nmakeActive ( ) ; \nif ( null == id ) throw ExceptionFactory . edgeIdCanNotBeNull ( ) ; \nif ( id instanceof OrientEdge ) return ( OrientEdge ) id ; \nelse if ( id instanceof ODocument ) return new OrientEdge ( this , ( OIdentifiable ) id ) ; \nfinal OIdentifiable rec ; \nif ( id instanceof OIdentifiable ) rec = ( OIdentifiable ) id ; \nelse { \nfinal String str = id . toString ( ) ; \nint pos = str . indexOf ( \"->\" ) ; \nif ( - 1 < pos ) { \nfinal String from = str . substring ( 0 , pos ) ; \nfinal String to = str . substring ( pos + 2 ) ; \nreturn getEdgeInstance ( new ORecordId ( from ) , new ORecordId ( to ) , null ) ; \n} \ntry { \nrec = new ORecordId ( str ) ; \n} \ncatch ( IllegalArgumentException iae ) { \nreturn null ; \n} \n} \nfinal ODocument doc = rec . getRecord ( ) ; \nif ( doc == null ) return null ; \nfinal OClass cls = doc . getSchemaClass ( ) ; \nif ( cls != null ) { \nif ( cls . isVertexType ( ) ) throw new IllegalArgumentException ( \"Cannot retrieve an edge with the RID \" + id + \" because it is a vertex\" ) ; \nif ( ! cls . isEdgeType ( ) ) throw new IllegalArgumentException ( \"Class '\" + doc . getClassName ( ) + \"' is not an edge class\" ) ; \n} \nreturn new OrientEdge ( this , rec ) ; \n} \n} \n"}
{"3123": "public class OrientBaseGraph { \npublic void dropVertexType ( final String iTypeName ) { \nmakeActive ( ) ; \nif ( 0 < getDatabase ( ) . countClass ( iTypeName ) ) throw new OCommandExecutionException ( \"cannot drop vertex type '\" + iTypeName + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to remove data\" ) ; \nexecuteOutsideTx ( new OCallable < OClass , OrientBaseGraph > ( ) { \n@ Override public OClass call ( final OrientBaseGraph g ) { \nODatabaseDocument rawGraph = getRawGraph ( ) ; \nrawGraph . getMetadata ( ) . getSchema ( ) . dropClass ( iTypeName ) ; \nreturn null ; \n} \n} \n, \"drop vertex type '\" , iTypeName , \"'\" ) ; \n} \n} \n"}
{"3147": "public class ODistributedResponseManagerImpl { \nprotected List < ODistributedResponse > getConflictResponses ( ) { \nfinal List < ODistributedResponse > servers = new ArrayList < ODistributedResponse > ( ) ; \nint bestGroupSoFar = getBestResponsesGroup ( ) ; \nfor ( int i = 0 ; \nresponseGroups . size ( ) > i ; \n++ i ) { \nif ( i != bestGroupSoFar ) { \nfor ( ODistributedResponse r : responseGroups . get ( i ) ) servers . add ( r ) ; \n} \n} \nreturn servers ; \n} \n} \n"}
{"3148": "public class ODistributedResponseManagerImpl { \nprotected int getBestResponsesGroup ( ) { \nint maxCoherentResponses = 0 ; \nint bestGroupSoFar = 0 ; \nfor ( int i = 0 ; \nresponseGroups . size ( ) > i ; \n++ i ) { \nfinal int currentGroupSize = responseGroups . get ( i ) . size ( ) ; \nif ( maxCoherentResponses < currentGroupSize ) { \nmaxCoherentResponses = currentGroupSize ; \nbestGroupSoFar = i ; \n} \n} \nreturn bestGroupSoFar ; \n} \n} \n"}
{"3149": "public class ODistributedResponseManagerImpl { \nprivate boolean computeQuorumResponse ( boolean reachedTimeout ) { \nif ( quorumResponse != null ) return true ; \nif ( groupResponsesByResult ) { \nfor ( List < ODistributedResponse > group : responseGroups ) { \nif ( quorum <= group . size ( ) ) { \nint responsesForQuorum = 0 ; \nfor ( ODistributedResponse r : group ) { \nif ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { \nfinal Object payload = r . getPayload ( ) ; \nif ( payload instanceof Throwable ) { \nif ( payload instanceof ODistributedRecordLockedException ) break ; \nif ( payload instanceof OConcurrentCreateException ) break ; \n} \nelse if ( quorum <= ++ responsesForQuorum ) { \nsetQuorumResponse ( r ) ; \nreturn true ; \n} \n} \n} \n} \n} \n} \nelse { \nif ( quorum <= receivedResponses ) { \nint responsesForQuorum = 0 ; \nfor ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { \nif ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && quorum <= ++ responsesForQuorum ) { \nODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; \nif ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; \nreturn true ; \n} \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"3158": "public class OOrderByOptimizer { \nboolean canBeUsedByOrderByAfterFilter ( OIndex < ? > index , List < String > equalsFilterFields , List < OPair < String , String > > orderedFields ) { \nif ( orderedFields . isEmpty ( ) ) return false ; \nif ( ! index . supportsOrderedIterations ( ) ) return false ; \nfinal OIndexDefinition definition = index . getDefinition ( ) ; \nfinal List < String > indexFields = definition . getFields ( ) ; \nint endIndex = Math . min ( indexFields . size ( ) , equalsFilterFields . size ( ) ) ; \nfinal String firstOrder = orderedFields . get ( 0 ) . getValue ( ) ; \nfor ( int i = 0 ; \nendIndex > i ; \ni ++ ) { \nfinal String equalsFieldName = equalsFilterFields . get ( i ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! equalsFieldName . equals ( indexFieldName ) ) return false ; \n} \nendIndex = Math . min ( indexFields . size ( ) , orderedFields . size ( ) + equalsFilterFields . size ( ) ) ; \nif ( endIndex == equalsFilterFields . size ( ) ) { \nreturn false ; \n} \nfor ( int i = equalsFilterFields . size ( ) ; \nendIndex > i ; \ni ++ ) { \nint fieldOrderInOrderByClause = i - equalsFilterFields . size ( ) ; \nfinal OPair < String , String > pair = orderedFields . get ( fieldOrderInOrderByClause ) ; \nif ( ! firstOrder . equals ( pair . getValue ( ) ) ) return false ; \nfinal String orderFieldName = pair . getKey ( ) ; \nfinal String indexFieldName = indexFields . get ( i ) ; \nif ( ! orderFieldName . equals ( indexFieldName ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3159": "public class OStringParser { \npublic static int indexOfOutsideStrings ( final String iText , final char iToFind , int iFrom , int iTo ) { \nif ( iTo == - 1 ) iTo = iText . length ( ) - 1 ; \nif ( iFrom == - 1 ) iFrom = iText . length ( ) - 1 ; \nchar c ; \nchar stringChar = ' ' ; \nboolean escape = false ; \nfinal StringBuilder buffer = new StringBuilder ( 1024 ) ; \nint i = iFrom ; \nwhile ( true ) { \nc = iText . charAt ( i ) ; \nif ( ! escape && c == '\\\\' && ( iText . length ( ) > ( i + 1 ) ) ) { \nif ( iText . charAt ( i + 1 ) == 'u' ) { \ni = readUnicode ( iText , i + 2 , buffer ) ; \n} \nelse escape = true ; \n} \nelse { \nif ( c == '\\'' || c == '\"' ) { \nif ( stringChar == ' ' ) { \nstringChar = c ; \n} \nelse { \nif ( ! escape && c == stringChar ) stringChar = ' ' ; \n} \n} \nif ( c == iToFind && stringChar == ' ' ) return i ; \nif ( escape ) escape = false ; \n} \nif ( iTo > iFrom ) { \nif ( iTo < ++ i ) break ; \n} \nelse { \nif ( iFrom > -- i ) break ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3161": "public class OStringParser { \npublic static int jump ( final CharSequence iText , int iCurrentPosition , final int iMaxPosition , final String iJumpChars ) { \nif ( 0 > iCurrentPosition ) return - 1 ; \nfinal int size = - 1 < iMaxPosition ? Math . min ( iMaxPosition , iText . length ( ) ) : iText . length ( ) ; \nfinal int jumpCharSize = iJumpChars . length ( ) ; \nboolean found = true ; \nchar c ; \nfor ( ; \nsize > iCurrentPosition ; \n++ iCurrentPosition ) { \nfound = false ; \nc = iText . charAt ( iCurrentPosition ) ; \nfor ( int jumpIndex = 0 ; \njumpCharSize > jumpIndex ; \n++ jumpIndex ) { \nif ( iJumpChars . charAt ( jumpIndex ) == c ) { \nfound = true ; \nbreak ; \n} \n} \nif ( ! found ) break ; \n} \nreturn size <= iCurrentPosition ? - 1 : iCurrentPosition ; \n} \n} \n"}
{"3163": "public class OConflictResolverDatabaseRepairer { \n@ Override public void enqueueRepairRecord ( final ORecordId rid ) { \nif ( ! active ) return ; \nif ( rid == null || ! rid . isPersistent ( ) ) return ; \nif ( - 1 > rid . getClusterPosition ( ) ) return ; \nrecordProcessed . incrementAndGet ( ) ; \nrecords . put ( rid , Boolean . TRUE ) ; \n} \n} \n"}
{"3164": "public class OConflictResolverDatabaseRepairer { \n@ Override public void cancelRepairRecord ( final ORecordId rid ) { \nif ( ! active ) return ; \nif ( - 1 > rid . getClusterPosition ( ) ) return ; \nif ( records . remove ( rid ) != null ) recordCanceled . incrementAndGet ( ) ; \n} \n} \n"}
{"3165": "public class OConflictResolverDatabaseRepairer { \n@ Override public void enqueueRepairCluster ( final int clusterId ) { \nif ( ! active ) return ; \nif ( - 1 > clusterId ) return ; \nrecordProcessed . incrementAndGet ( ) ; \nclusters . put ( clusterId , Boolean . TRUE ) ; \n} \n} \n"}
{"3176": "public class OMemory { \npublic static void checkCacheMemoryConfiguration ( ) { \nfinal long maxHeapSize = Runtime . getRuntime ( ) . maxMemory ( ) ; \nfinal long maxCacheSize = getMaxCacheMemorySize ( ) ; \nfinal ONative . MemoryLimitResult physicalMemory = ONative . instance ( ) . getMemoryLimit ( false ) ; \nif ( maxHeapSize != Long . MAX_VALUE && physicalMemory != null && physicalMemory . memoryLimit < maxHeapSize + maxCacheSize ) OLogManager . instance ( ) . warnNoDb ( OMemory . class , \"The sum of the configured JVM maximum heap size (\" + maxHeapSize + \" bytes) \" + \"and the OrientDB maximum cache size (\" + maxCacheSize + \" bytes) is larger than the available physical memory size \" + \"(\" + physicalMemory + \" bytes). That may cause out of memory errors, please tune the configuration up. Use the \" + \"-Xmx JVM option to lower the JVM maximum heap memory size or storage.diskCache.bufferSize OrientDB option to \" + \"lower memory requirements of the cache.\" ) ; \n} \n} \n"}
{"3184": "public class OSymmetricKey { \nprotected static String separateAlgorithm ( final String cipherTransform ) { \nString [ ] array = cipherTransform . split ( \"/\" ) ; \nif ( 1 < array . length ) return array [ 0 ] ; \nreturn null ; \n} \n} \n"}
{"3195": "public class ODocumentHelper { \n@ SuppressWarnings ( \"unchecked\" ) public static Object getMapEntry ( final Map < String , ? > iMap , final Object iKey ) { \nif ( iMap == null || iKey == null ) return null ; \nif ( iKey instanceof String ) { \nString iName = ( String ) iKey ; \nint pos = iName . indexOf ( '.' ) ; \nif ( - 1 < pos ) iName = iName . substring ( 0 , pos ) ; \nfinal Object value = iMap . get ( iName ) ; \nif ( value == null ) return null ; \nif ( - 1 < pos ) { \nfinal String restFieldName = iName . substring ( pos + 1 ) ; \nif ( value instanceof ODocument ) return getFieldValue ( value , restFieldName ) ; \nelse if ( value instanceof Map < ? , ? > ) return getMapEntry ( ( Map < String , ? > ) value , restFieldName ) ; \n} \nreturn value ; \n} \nelse return iMap . get ( iKey ) ; \n} \n} \n"}
{"3197": "public class OIdentifiableIterator { \nprotected ORecord readCurrentRecord ( ORecord iRecord , final int iMovement ) { \nif ( - 1 < limit && limit <= browsedRecords ) return null ; \ndo { \nfinal boolean moveResult ; \nswitch ( iMovement ) { \ncase 1 : moveResult = nextPosition ( ) ; \nbreak ; \ncase - 1 : moveResult = prevPosition ( ) ; \nbreak ; \ncase 0 : moveResult = checkCurrentPosition ( ) ; \nbreak ; \ndefault : throw new IllegalStateException ( \"Invalid movement value : \" + iMovement ) ; \n} \nif ( ! moveResult ) return null ; \ntry { \nif ( iRecord != null ) { \nORecordInternal . setIdentity ( iRecord , new ORecordId ( current . getClusterId ( ) , current . getClusterPosition ( ) ) ) ; \niRecord = database . load ( iRecord , fetchPlan , false ) ; \n} \nelse iRecord = database . load ( current , fetchPlan , false ) ; \n} \ncatch ( ODatabaseException e ) { \nif ( Thread . interrupted ( ) || database . isClosed ( ) ) throw e ; \nif ( e . getCause ( ) instanceof OSecurityException ) throw e ; \nbrokenRIDs . add ( current . copy ( ) ) ; \nOLogManager . instance ( ) . error ( this , \"Error on fetching record during browsing. The record has been skipped\" , e ) ; \n} \nif ( iRecord != null ) { \nbrowsedRecords ++ ; \nreturn iRecord ; \n} \n} \nwhile ( iMovement != 0 ) ; \nreturn null ; \n} \n} \n"}
{"3205": "public class OrientSql { \nfinal public Token getToken ( int index ) { \nToken t = token ; \nfor ( int i = 0 ; \nindex > i ; \ni ++ ) { \nif ( t . next != null ) t = t . next ; \nelse t = t . next = token_source . getNextToken ( ) ; \n} \nreturn t ; \n} \n} \n"}
{"3206": "public class OrientSql { \npublic ParseException generateParseException ( ) { \njj_expentries . clear ( ) ; \nboolean [ ] la1tokens = new boolean [ 279 ] ; \nif ( 0 <= jj_kind ) { \nla1tokens [ jj_kind ] = true ; \njj_kind = - 1 ; \n} \nfor ( int i = 0 ; \n424 > i ; \ni ++ ) { \nif ( jj_la1 [ i ] == jj_gen ) { \nfor ( int j = 0 ; \n32 > j ; \nj ++ ) { \nif ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ j ] = true ; \n} \nif ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 32 + j ] = true ; \n} \nif ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 64 + j ] = true ; \n} \nif ( ( jj_la1_3 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 96 + j ] = true ; \n} \nif ( ( jj_la1_4 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 128 + j ] = true ; \n} \nif ( ( jj_la1_5 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 160 + j ] = true ; \n} \nif ( ( jj_la1_6 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 192 + j ] = true ; \n} \nif ( ( jj_la1_7 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 224 + j ] = true ; \n} \nif ( ( jj_la1_8 [ i ] & ( 1 << j ) ) != 0 ) { \nla1tokens [ 256 + j ] = true ; \n} \n} \n} \n} \nfor ( int i = 0 ; \n279 > i ; \ni ++ ) { \nif ( la1tokens [ i ] ) { \njj_expentry = new int [ 1 ] ; \njj_expentry [ 0 ] = i ; \njj_expentries . add ( jj_expentry ) ; \n} \n} \njj_endpos = 0 ; \njj_rescan_token ( ) ; \njj_add_error_token ( 0 , 0 ) ; \nint [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; \nfor ( int i = 0 ; \njj_expentries . size ( ) > i ; \ni ++ ) { \nexptokseq [ i ] = jj_expentries . get ( i ) ; \n} \nreturn new ParseException ( token , exptokseq , tokenImage ) ; \n} \n} \n"}
{"3211": "public class OrientVertex { \npublic String getConnectionClass ( final Direction iDirection , final String iFieldName ) { \nif ( iDirection == Direction . OUT ) { \nif ( CONNECTION_OUT_PREFIX . length ( ) < iFieldName . length ( ) ) return iFieldName . substring ( CONNECTION_OUT_PREFIX . length ( ) ) ; \n} \nelse if ( iDirection == Direction . IN ) { \nif ( CONNECTION_IN_PREFIX . length ( ) < iFieldName . length ( ) ) return iFieldName . substring ( CONNECTION_IN_PREFIX . length ( ) ) ; \n} \nreturn OrientEdgeType . CLASS_NAME ; \n} \n} \n"}
{"3213": "public class ODatabaseImport { \nprivate void processBrokenRids ( Set < ORID > brokenRids ) throws IOException , ParseException { \nif ( 12 <= exporterVersion ) { \nlistener . onMessage ( \"Reading of set of RIDs of records which were detected as broken during database export\\n\" ) ; \njsonReader . readNext ( OJSONReader . BEGIN_COLLECTION ) ; \nwhile ( true ) { \njsonReader . readNext ( OJSONReader . NEXT_IN_ARRAY ) ; \nfinal ORecordId recordId = new ORecordId ( jsonReader . getValue ( ) ) ; \nbrokenRids . add ( recordId ) ; \nif ( jsonReader . lastChar ( ) == ']' ) break ; \n} \n} \nif ( migrateLinks ) { \nif ( 12 <= exporterVersion ) listener . onMessage ( brokenRids . size ( ) + \" were detected as broken during database export, links on those records will be removed from\" + \" result database\" ) ; \nmigrateLinksInImportedDocuments ( brokenRids ) ; \n} \n} \n} \n"}
{"3219": "public class OHttpRequestWrapper { \npublic String getArgument ( final int iPosition ) { \nreturn args != null && iPosition < args . length ? args [ iPosition ] : null ; \n} \n} \n"}
{"3238": "public class JavaCharStream { \npublic void adjustBeginLineColumn ( int newLine , int newCol ) { \nint start = tokenBegin ; \nint len ; \nif ( tokenBegin <= bufpos ) { \nlen = bufpos - tokenBegin + inBuf + 1 ; \n} \nelse { \nlen = bufsize - tokenBegin + bufpos + 1 + inBuf ; \n} \nint i = 0 , j = 0 , k = 0 ; \nint nextColDiff = 0 , columnDiff = 0 ; \nwhile ( len > i && bufline [ j = start % bufsize ] == bufline [ k = ++ start % bufsize ] ) { \nbufline [ j ] = newLine ; \nnextColDiff = columnDiff + bufcolumn [ k ] - bufcolumn [ j ] ; \nbufcolumn [ j ] = newCol + columnDiff ; \ncolumnDiff = nextColDiff ; \ni ++ ; \n} \nif ( len > i ) { \nbufline [ j ] = newLine ++ ; \nbufcolumn [ j ] = newCol + columnDiff ; \nwhile ( len > i ++ ) { \nif ( bufline [ j = start % bufsize ] != bufline [ ++ start % bufsize ] ) bufline [ j ] = newLine ++ ; \nelse bufline [ j ] = newLine ; \n} \n} \nline = bufline [ j ] ; \ncolumn = bufcolumn [ j ] ; \n} \n} \n"}
{"3241": "public class OAtomicOperationsManager { \npublic OLogSequenceNumber endAtomicOperation ( boolean rollback ) throws IOException { \nfinal OAtomicOperation operation = currentOperation . get ( ) ; \nif ( operation == null ) { \nOLogManager . instance ( ) . error ( this , \"There is no atomic operation active\" , null ) ; \nthrow new ODatabaseException ( \"There is no atomic operation active\" ) ; \n} \nint counter = operation . getCounter ( ) ; \noperation . decrementCounter ( ) ; \nassert 0 < counter ; \nfinal OLogSequenceNumber lsn ; \ntry { \nif ( rollback ) { \noperation . rollback ( ) ; \n} \nif ( counter == 1 ) { \ntry { \nfinal boolean useWal = useWal ( ) ; \nif ( ! operation . isRollback ( ) ) { \nlsn = operation . commitChanges ( useWal ? writeAheadLog : null ) ; \n} \nelse { \nlsn = null ; \n} \nif ( trackAtomicOperations ) { \nactiveAtomicOperations . remove ( operation . getOperationUnitId ( ) ) ; \n} \n} \nfinally { \nfinal Iterator < String > lockedObjectIterator = operation . lockedObjects ( ) . iterator ( ) ; \nwhile ( lockedObjectIterator . hasNext ( ) ) { \nfinal String lockedObject = lockedObjectIterator . next ( ) ; \nlockedObjectIterator . remove ( ) ; \nlockManager . releaseLock ( this , lockedObject , OOneEntryPerKeyLockManager . LOCK . EXCLUSIVE ) ; \n} \ncurrentOperation . set ( null ) ; \n} \n} \nelse { \nlsn = null ; \n} \n} \ncatch ( Error e ) { \nfinal OAbstractPaginatedStorage st = storage ; \nif ( st != null ) { \nst . handleJVMError ( e ) ; \n} \ncounter = 1 ; \nthrow e ; \n} \nfinally { \nif ( counter == 1 ) { \natomicOperationsCount . decrement ( ) ; \n} \n} \nreturn lsn ; \n} \n} \n"}
{"3243": "public class O2QCache { \npublic void changeMaximumAmountOfMemory ( final long readCacheMaxMemory ) throws IllegalStateException { \nMemoryData memoryData ; \nMemoryData newMemoryData ; \nfinal int newMemorySize = normalizeMemory ( readCacheMaxMemory , pageSize ) ; \ndo { \nmemoryData = memoryDataContainer . get ( ) ; \nif ( memoryData . maxSize == newMemorySize ) { \nreturn ; \n} \nif ( percentOfPinnedPages < ( 100 * memoryData . pinnedPages / newMemorySize ) ) { \nthrow new IllegalStateException ( \"Cannot decrease amount of memory used by disk cache \" + \"because limit of pinned pages will be more than allowed limit \" + percentOfPinnedPages ) ; \n} \nnewMemoryData = new MemoryData ( newMemorySize , memoryData . pinnedPages ) ; \n} \nwhile ( ! memoryDataContainer . compareAndSet ( memoryData , newMemoryData ) ) ; \nOLogManager . instance ( ) . info ( this , \"Disk cache size was changed from \" + memoryData . maxSize + \" pages to \" + newMemorySize + \" pages\" ) ; \n} \n} \n"}
{"3245": "public class OServerNetworkListener { \nprivate void readParameters ( final OContextConfiguration iServerConfig , final OServerParameterConfiguration [ ] iParameters ) { \nconfiguration = new OContextConfiguration ( iServerConfig ) ; \nif ( iParameters != null && 0 < iParameters . length ) { \nfor ( OServerParameterConfiguration param : iParameters ) configuration . setValue ( param . name , param . value ) ; \n} \nsocketBufferSize = configuration . getValueAsInteger ( OGlobalConfiguration . NETWORK_SOCKET_BUFFER_SIZE ) ; \n} \n} \n"}
{"3251": "public class OClosableLinkedContainer { \npublic void clear ( ) { \nlruLock . lock ( ) ; \ntry { \ndata . clear ( ) ; \nopenFiles . set ( 0 ) ; \nfor ( int n = 0 ; \nNUMBER_OF_READ_BUFFERS > n ; \nn ++ ) { \nfinal AtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nfor ( int i = 0 ; \nREAD_BUFFER_SIZE > i ; \ni ++ ) { \nbuffer [ i ] . set ( null ) ; \n} \nreadBufferReadCount [ n ] = 0 ; \nreadBufferWriteCount [ n ] . set ( 0 ) ; \nreadBufferDrainAtWriteCount [ n ] . set ( 0 ) ; \n} \nstateBuffer . clear ( ) ; \nwhile ( lruList . poll ( ) != null ) ; \n} \nfinally { \nlruLock . unlock ( ) ; \n} \n} \n} \n"}
{"3253": "public class OClosableLinkedContainer { \nprivate void emptyReadBuffers ( ) { \nfor ( int n = 0 ; \nNUMBER_OF_READ_BUFFERS > n ; \nn ++ ) { \nAtomicReference < OClosableEntry < K , V > > [ ] buffer = readBuffers [ n ] ; \nlong writeCount = readBufferDrainAtWriteCount [ n ] . get ( ) ; \nlong counter = readBufferReadCount [ n ] ; \nwhile ( true ) { \nfinal int bufferIndex = ( int ) ( counter & READ_BUFFER_INDEX_MASK ) ; \nfinal AtomicReference < OClosableEntry < K , V > > eref = buffer [ bufferIndex ] ; \nfinal OClosableEntry < K , V > entry = eref . get ( ) ; \nif ( entry == null ) break ; \napplyRead ( entry ) ; \ncounter ++ ; \neref . lazySet ( null ) ; \n} \nreadBufferReadCount [ n ] = counter ; \nreadBufferDrainAtWriteCount [ n ] . lazySet ( writeCount ) ; \n} \n} \n} \n"}
{"3257": "public class OClosableLinkedContainer { \nprivate static int closestPowerOfTwo ( int value ) { \nint n = value - 1 ; \nn |= n >>> 1 ; \nn |= n >>> 2 ; \nn |= n >>> 4 ; \nn |= n >>> 8 ; \nn |= n >>> 16 ; \nreturn ( 0 > n ) ? 1 : ( ( 1 << 30 ) <= n ) ? 1 << 30 : n + 1 ; \n} \n} \n"}
{"3269": "public class OReadersWriterSpinLock { \npublic boolean tryAcquireReadLock ( long timeout ) { \nfinal OModifiableInteger lHolds = lockHolds . get ( ) ; \nfinal int holds = lHolds . intValue ( ) ; \nif ( 0 < holds ) { \nlHolds . increment ( ) ; \nreturn true ; \n} \nelse if ( 0 > holds ) { \nreturn true ; \n} \ndistributedCounter . increment ( ) ; \nWNode wNode = tail . get ( ) ; \nfinal long start = System . nanoTime ( ) ; \nwhile ( wNode . locked ) { \ndistributedCounter . decrement ( ) ; \nwhile ( wNode . locked && wNode == tail . get ( ) ) { \nwNode . waitingReaders . put ( Thread . currentThread ( ) , Boolean . TRUE ) ; \nif ( wNode . locked && wNode == tail . get ( ) ) { \nfinal long parkTimeout = timeout - ( System . nanoTime ( ) - start ) ; \nif ( 0 < parkTimeout ) { \nLockSupport . parkNanos ( this , parkTimeout ) ; \n} \nelse { \nreturn false ; \n} \n} \nwNode = tail . get ( ) ; \nif ( timeout < System . nanoTime ( ) - start ) { \nreturn false ; \n} \n} \ndistributedCounter . increment ( ) ; \nwNode = tail . get ( ) ; \nif ( timeout < System . nanoTime ( ) - start ) { \ndistributedCounter . decrement ( ) ; \nreturn false ; \n} \n} \nlHolds . increment ( ) ; \nassert lHolds . intValue ( ) == 1 ; \nreturn true ; \n} \n} \n"}
{"3276": "public class OGraphBatchInsertBasic { \npublic void end ( ) { \nfinal OClass vClass = db . getMetadata ( ) . getSchema ( ) . getClass ( vertexClass ) ; \ntry { \nrunningThreads = new AtomicInteger ( parallel ) ; \nfor ( int i = 0 ; \nparallel - 1 > i ; \ni ++ ) { \nThread t = new BatchImporterJob ( i , vClass ) ; \nt . start ( ) ; \n} \nThread t = new BatchImporterJob ( parallel - 1 , vClass ) ; \nt . run ( ) ; \nif ( 0 < runningThreads . get ( ) ) { \nsynchronized ( runningThreads ) { \nwhile ( 0 < runningThreads . get ( ) ) { \ntry { \nrunningThreads . wait ( ) ; \n} \ncatch ( InterruptedException e ) { \n} \n} \n} \n} \n} \nfinally { \ndb . activateOnCurrentThread ( ) ; \ndb . declareIntent ( null ) ; \ndb . close ( ) ; \nif ( walActive ) OGlobalConfiguration . USE_WAL . setValue ( true ) ; \n} \n} \n} \n"}
{"3277": "public class OGraphBatchInsertBasic { \npublic void createVertex ( final Long v ) { \nlast = v > last ? v : last ; \nfinal List < Long > outList = out . get ( v ) ; \nif ( outList == null ) { \nout . put ( v , new ArrayList < Long > ( 0 >= averageEdgeNumberPerNode ? 4 : averageEdgeNumberPerNode ) ) ; \n} \n} \n} \n"}
{"3279": "public class ORecordSerializerBinaryV0 { \nprivate List < RecordInfo > getPositionsFromEmbeddedCollection ( final BytesContainer bytes , int serializerVersion ) { \nList < RecordInfo > retList = new ArrayList < > ( ) ; \nint numberOfElements = OVarIntSerializer . readAsInteger ( bytes ) ; \nreadByte ( bytes ) ; \nfor ( int i = 0 ; \nnumberOfElements > i ; \ni ++ ) { \nOType dataType = readOType ( bytes , false ) ; \nint fieldStart = bytes . offset ; \nRecordInfo fieldInfo = new RecordInfo ( ) ; \nfieldInfo . fieldStartOffset = fieldStart ; \nfieldInfo . fieldType = dataType ; \ndeserializeValue ( bytes , dataType , null , true , - 1 , serializerVersion , true ) ; \nfieldInfo . fieldLength = bytes . offset - fieldStart ; \nretList . add ( fieldInfo ) ; \n} \nreturn retList ; \n} \n} \n"}
{"3285": "public class ODistributedWorker { \npublic void initDatabaseInstance ( ) { \nif ( database == null ) { \nfor ( int retry = 0 ; \n100 > retry ; \n++ retry ) { \ntry { \ndatabase = distributed . getDatabaseInstance ( ) ; \nbreak ; \n} \ncatch ( OStorageException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \ncatch ( OConfigurationException e ) { \nif ( ! dbNotAvailable ( retry ) ) return ; \n} \n} \nif ( database == null ) { \nODistributedServerLog . info ( this , manager . getLocalNodeName ( ) , null , DIRECTION . NONE , \"Database '%s' not present, shutting down database manager\" , databaseName ) ; \ndistributed . shutdown ( ) ; \nthrow new ODistributedException ( \"Cannot open database '\" + databaseName + \"'\" ) ; \n} \n} \nelse if ( database . isClosed ( ) ) { \ndatabase . activateOnCurrentThread ( ) ; \ndatabase . close ( ) ; \ndatabase = distributed . getDatabaseInstance ( ) ; \n} \n} \n} \n"}
{"3300": "public class OByteBufferPool { \npublic final void release ( OPointer pointer ) { \nif ( TRACK ) { \npointerMapping . remove ( pointer ) ; \n} \nlong poolSize = pointersPoolSize . incrementAndGet ( ) ; \nif ( this . poolSize < poolSize ) { \npointersPoolSize . decrementAndGet ( ) ; \nallocator . deallocate ( pointer ) ; \n} \nelse { \npointersPool . add ( pointer ) ; \n} \n} \n} \n"}
{"3307": "public class OCollections { \npublic static int indexOf ( final Object [ ] array , final Comparable object ) { \nfor ( int i = 0 ; \narray . length > i ; \n++ i ) { \nif ( object . compareTo ( array [ i ] ) == 0 ) return i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"3308": "public class OCollections { \npublic static int indexOf ( final int [ ] array , final int object ) { \nfor ( int i = 0 ; \narray . length > i ; \n++ i ) { \nif ( array [ i ] == object ) return i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"3310": "public class OCommandExecutorSQLSelect { \n@ Override protected boolean handleResult ( final OIdentifiable iRecord , final OCommandContext iContext ) { \nlastRecord = iRecord ; \nif ( ( orderedFields . isEmpty ( ) || fullySortedByIndex || isRidOnlySort ( ) ) && 0 < skip && this . unwindFields == null && this . expandTarget == null ) { \nlastRecord = null ; \nskip -- ; \nreturn true ; \n} \nif ( ! addResult ( lastRecord , iContext ) ) { \nreturn false ; \n} \nreturn continueSearching ( ) ; \n} \n} \n"}
{"3313": "public class OCommandExecutorSQLSelect { \nprotected boolean parseFetchplan ( final String w ) throws OCommandSQLParsingException { \nif ( ! w . equals ( KEYWORD_FETCHPLAN ) ) { \nreturn false ; \n} \nparserSkipWhiteSpaces ( ) ; \nint start = parserGetCurrentPosition ( ) ; \nparserNextWord ( true ) ; \nint end = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nint position = parserGetCurrentPosition ( ) ; \nwhile ( ! parserIsEnded ( ) ) { \nfinal String word = OIOUtils . getStringContent ( parserNextWord ( true ) ) ; \nif ( ! OPatternConst . PATTERN_FETCH_PLAN . matcher ( word ) . matches ( ) ) { \nbreak ; \n} \nend = parserGetCurrentPosition ( ) ; \nparserSkipWhiteSpaces ( ) ; \nposition = parserGetCurrentPosition ( ) ; \n} \nparserSetCurrentPosition ( position ) ; \nif ( 0 > end ) { \nfetchPlan = OIOUtils . getStringContent ( parserText . substring ( start ) ) ; \n} \nelse { \nfetchPlan = OIOUtils . getStringContent ( parserText . substring ( start , end ) ) ; \n} \nrequest . setFetchPlan ( fetchPlan ) ; \nreturn true ; \n} \n} \n"}
{"3333": "public class OrientBlob { \nprivate int getRelativeIndex ( long pos ) { \nint currentSize = 0 ; \ncurrentChunkIndex = 0 ; \nwhile ( ( currentSize += binaryDataChunks . get ( currentChunkIndex ) . length ) <= pos ) currentChunkIndex ++ ; \ncurrentChunk = binaryDataChunks . get ( currentChunkIndex ) ; \ncurrentSize -= currentChunk . length ; \nint relativePosition = ( int ) ( pos - currentSize ) ; \nreturn relativePosition - 1 ; \n} \n} \n"}
{"3336": "public class OBaseParser { \nprotected int parserNextChars ( final boolean iUpperCase , final boolean iMandatory , final String ... iCandidateWords ) { \nparserPreviousPos = parserCurrentPos ; \nparserSkipWhiteSpaces ( ) ; \nparserEscapeSequenceCount = 0 ; \nparserLastWord . setLength ( 0 ) ; \nfinal String [ ] processedWords = Arrays . copyOf ( iCandidateWords , iCandidateWords . length ) ; \nfinal String text2Use = iUpperCase ? parserTextUpperCase : parserText ; \nfinal int max = text2Use . length ( ) ; \nparserCurrentPos = parserCurrentPos + parserTextUpperCase . length ( ) - parserText . length ( ) ; \nfor ( int i = 0 ; \nmax >= parserCurrentPos ; \n++ i ) { \nfinal char ch = max > parserCurrentPos ? text2Use . charAt ( parserCurrentPos ) : '\\n' ; \nfinal boolean separator = ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t' || ch == '(' ; \nif ( ! separator ) parserLastWord . append ( ch ) ; \nint candidatesWordsCount = 0 ; \nint candidatesWordsPos = - 1 ; \nfor ( int c = 0 ; \nprocessedWords . length > c ; \n++ c ) { \nfinal String w = processedWords [ c ] ; \nif ( w != null ) { \nfinal int wordSize = w . length ( ) ; \nif ( ( separator && i < wordSize ) || ( ! separator && ( wordSize - 1 < i || w . charAt ( i ) != ch ) ) ) processedWords [ c ] = null ; \nelse { \ncandidatesWordsCount ++ ; \nif ( candidatesWordsCount == 1 ) candidatesWordsPos = c ; \n} \n} \n} \nif ( candidatesWordsCount == 1 ) { \nfinal String w = processedWords [ candidatesWordsPos ] ; \nif ( w . length ( ) == i + ( separator ? 0 : 1 ) && ! Character . isLetter ( ch ) ) return candidatesWordsPos ; \n} \nif ( candidatesWordsCount == 0 || separator ) break ; \nparserCurrentPos ++ ; \n} \nif ( iMandatory ) throwSyntaxErrorException ( \"Found unexpected keyword '\" + parserLastWord + \"' while it was expected '\" + Arrays . toString ( iCandidateWords ) + \"'\" ) ; \nreturn - 1 ; \n} \n} \n"}
{"3338": "public class OBaseParser { \nprivate boolean parserCheckSeparator ( final char c , final String iSeparatorChars ) { \nfor ( int sepIndex = 0 ; \niSeparatorChars . length ( ) > sepIndex ; \n++ sepIndex ) { \nif ( iSeparatorChars . charAt ( sepIndex ) == c ) { \nparserLastSeparator = c ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"3339": "public class OCommandExecutorSQLDropClass { \npublic Object execute ( final Map < Object , Object > iArgs ) { \nif ( className == null ) { \nthrow new OCommandExecutionException ( \"Cannot execute the command because it has not been parsed yet\" ) ; \n} \nfinal ODatabaseDocument database = getDatabase ( ) ; \nif ( ifExists && ! database . getMetadata ( ) . getSchema ( ) . existsClass ( className ) ) { \nreturn true ; \n} \nfinal OClass cls = database . getMetadata ( ) . getSchema ( ) . getClass ( className ) ; \nif ( cls == null ) { \nreturn null ; \n} \nfinal long records = cls . count ( true ) ; \nif ( 0 < records && ! unsafe ) { \nif ( cls . isSubClassOf ( \"V\" ) ) { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Vertices. Use 'DELETE VERTEX' command first to avoid broken edges in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \nelse if ( cls . isSubClassOf ( \"E\" ) ) { \nthrow new OCommandExecutionException ( \"'DROP CLASS' command cannot drop class '\" + className + \"' because it contains Edges. Use 'DELETE EDGE' command first to avoid broken vertices in a database, or apply the 'UNSAFE' keyword to force it\" ) ; \n} \n} \ndatabase . getMetadata ( ) . getSchema ( ) . dropClass ( className ) ; \nif ( 0 < records && unsafe ) { \nif ( cls . isSubClassOf ( \"V\" ) ) { \nif ( unsafe ) OLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d vertices using UNSAFE mode. Database could contain broken edges\" , className , records ) ; \n} \nelse if ( cls . isSubClassOf ( \"E\" ) ) { \nOLogManager . instance ( ) . warn ( this , \"Dropped class '%s' containing %d edges using UNSAFE mode. Database could contain broken vertices\" , className , records ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3341": "public class OMemoryInputStream { \npublic int getAsByteArrayOffset ( ) { \nif ( length <= position ) return - 1 ; \nfinal int begin = position ; \nfinal int size = OBinaryProtocol . bytes2int ( buffer , position ) ; \nposition += OBinaryProtocol . SIZE_INT + size ; \nreturn begin ; \n} \n} \n"}
{"3345": "public class FastBufferedInputStream { \nprotected boolean noMoreCharacters ( ) throws IOException { \nif ( avail == 0 ) { \navail = is . read ( buffer ) ; \nif ( 0 >= avail ) { \navail = 0 ; \nreturn true ; \n} \npos = 0 ; \n} \nreturn false ; \n} \n} \n"}
{"3347": "public class FastBufferedInputStream { \npublic int readLine ( final byte [ ] array , final int off , final int len , final EnumSet < LineTerminator > terminators ) throws IOException { \nByteArrays . ensureOffsetLength ( array , off , len ) ; \nif ( len == 0 ) return 0 ; \nif ( noMoreCharacters ( ) ) return - 1 ; \nint i , k = 0 , remaining = len , read = 0 ; \nfor ( ; \n; \n) { \nfor ( i = 0 ; \navail > i && remaining > i && ( k = buffer [ pos + i ] ) != '\\n' && k != '\\r' ; \ni ++ ) ; \nSystem . arraycopy ( buffer , pos , array , off + read , i ) ; \npos += i ; \navail -= i ; \nread += i ; \nremaining -= i ; \nif ( remaining == 0 ) { \nreadBytes += read ; \nreturn read ; \n} \nif ( 0 < avail ) { \nif ( k == '\\n' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . LF ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \nelse { \narray [ off + read ++ ] = '\\n' ; \nremaining -- ; \n} \n} \nelse if ( k == '\\r' ) { \npos ++ ; \navail -- ; \nif ( terminators . contains ( LineTerminator . CR_LF ) ) { \nif ( 0 < avail ) { \nif ( buffer [ pos ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \nelse { \nif ( noMoreCharacters ( ) ) { \nif ( ! terminators . contains ( LineTerminator . CR ) ) { \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \nreadBytes += read ; \n} \nelse readBytes += read + 1 ; \nreturn read ; \n} \nif ( buffer [ 0 ] == '\\n' ) { \npos ++ ; \navail -- ; \nreadBytes += read + 2 ; \nreturn read ; \n} \n} \n} \nif ( terminators . contains ( LineTerminator . CR ) ) { \nreadBytes += read + 1 ; \nreturn read ; \n} \narray [ off + read ++ ] = '\\r' ; \nremaining -- ; \n} \n} \nelse if ( noMoreCharacters ( ) ) { \nreadBytes += read ; \nreturn read ; \n} \n} \n} \n} \n"}
{"3348": "public class FastBufferedInputStream { \nprivate long skipByReading ( final long n ) throws IOException { \nlong toSkip = n ; \nint len ; \nwhile ( 0 < toSkip ) { \nlen = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , toSkip ) ) ; \nif ( 0 < len ) toSkip -= len ; \nelse break ; \n} \nreturn n - toSkip ; \n} \n} \n"}
{"3349": "public class FastBufferedInputStream { \n@ Override public long skip ( final long n ) throws IOException { \nif ( avail >= n ) { \nfinal int m = ( int ) n ; \npos += m ; \navail -= m ; \nreadBytes += n ; \nreturn n ; \n} \nlong toSkip = n - avail , result = 0 ; \navail = 0 ; \nwhile ( toSkip != 0 && toSkip > ( result = is == System . in ? skipByReading ( toSkip ) : is . skip ( toSkip ) ) ) { \nif ( result == 0 ) { \nif ( is . read ( ) == - 1 ) break ; \ntoSkip -- ; \n} \nelse toSkip -= result ; \n} \nfinal long t = n - ( toSkip - result ) ; \nreadBytes += t ; \nreturn t ; \n} \n} \n"}
{"3350": "public class Arrays { \npublic static void ensureOffsetLength ( final int arrayLength , final int offset , final int length ) { \nif ( 0 > offset ) throw new ArrayIndexOutOfBoundsException ( \"Offset (\" + offset + \") is negative\" ) ; \nif ( 0 > length ) throw new IllegalArgumentException ( \"Length (\" + length + \") is negative\" ) ; \nif ( arrayLength < offset + length ) throw new ArrayIndexOutOfBoundsException ( \"Last index (\" + ( offset + length ) + \") is greater than array length (\" + arrayLength + \")\" ) ; \n} \n} \n"}
{"3351": "public class Arrays { \npublic static void mergeSort ( final int from , final int to , final IntComparator c , final Swapper swapper ) { \nfinal int length = to - from ; \nif ( MERGESORT_NO_REC > length ) { \nfor ( int i = from ; \nto > i ; \ni ++ ) { \nfor ( int j = i ; \nfrom < j && ( 0 < c . compare ( j - 1 , j ) ) ; \nj -- ) { \nswapper . swap ( j , j - 1 ) ; \n} \n} \nreturn ; \n} \nint mid = ( from + to ) >>> 1 ; \nmergeSort ( from , mid , c , swapper ) ; \nmergeSort ( mid , to , c , swapper ) ; \nif ( 0 >= c . compare ( mid - 1 , mid ) ) return ; \ninPlaceMerge ( from , mid , to , c , swapper ) ; \n} \n} \n"}
{"3352": "public class Arrays { \nprotected static void swap ( final Swapper swapper , int a , int b , final int n ) { \nfor ( int i = 0 ; \nn > i ; \ni ++ , a ++ , b ++ ) swapper . swap ( a , b ) ; \n} \n} \n"}
{"3356": "public class InspectableFileCachedInputStream { \n@ Override public int write ( final ByteBuffer byteBuffer ) throws IOException { \nensureOpen ( ) ; \nfinal int remaining = byteBuffer . remaining ( ) ; \nif ( buffer . length > inspectable ) { \nfinal int toBuffer = Math . min ( buffer . length - inspectable , remaining ) ; \nbyteBuffer . get ( buffer , inspectable , toBuffer ) ; \ninspectable += toBuffer ; \n} \nif ( byteBuffer . hasRemaining ( ) ) { \nfileChannel . position ( writePosition ) ; \nwritePosition += fileChannel . write ( byteBuffer ) ; \n} \nreturn remaining ; \n} \n} \n"}
{"3363": "public class HollowFilesystemBlobStorageCleaner { \n@ Override public void cleanSnapshots ( ) { \nFile [ ] files = getFilesByType ( HollowProducer . Blob . Type . SNAPSHOT . prefix ) ; \nif ( files == null || numOfSnapshotsToKeep >= files . length ) { \nreturn ; \n} \nsortByLastModified ( files ) ; \nfor ( int i = numOfSnapshotsToKeep ; \nfiles . length > i ; \ni ++ ) { \nFile file = files [ i ] ; \nboolean deleted = file . delete ( ) ; \nif ( ! deleted ) { \nlog . warning ( \"Could not delete snapshot \" + file . getPath ( ) ) ; \n} \n} \n} \n} \n"}
{"3366": "public class TransitiveSetTraverser { \npublic static void removeReferencedOutsideClosure ( HollowReadStateEngine stateEngine , Map < String , BitSet > matches ) { \nList < HollowSchema > orderedSchemas = HollowSchemaSorter . dependencyOrderedSchemaList ( stateEngine ) ; \nCollections . reverse ( orderedSchemas ) ; \nfor ( HollowSchema referencedSchema : orderedSchemas ) { \nif ( matches . containsKey ( referencedSchema . getName ( ) ) ) { \nfor ( HollowSchema referencerSchema : orderedSchemas ) { \nif ( referencerSchema == referencedSchema ) break ; \nif ( matches . containsKey ( referencedSchema . getName ( ) ) && 0 < matches . get ( referencedSchema . getName ( ) ) . cardinality ( ) ) traverseReferencesOutsideClosure ( stateEngine , referencerSchema . getName ( ) , referencedSchema . getName ( ) , matches , REMOVE_REFERENCED_OUTSIDE_CLOSURE ) ; \n} \n} \n} \n} \n} \n"}
{"3369": "public class HollowBlobHeaderReader { \nprivate Map < String , String > readHeaderTags ( DataInputStream dis ) throws IOException { \nint numHeaderTags = dis . readShort ( ) ; \nMap < String , String > headerTags = new HashMap < String , String > ( ) ; \nfor ( int i = 0 ; \nnumHeaderTags > i ; \ni ++ ) { \nheaderTags . put ( dis . readUTF ( ) , dis . readUTF ( ) ) ; \n} \nreturn headerTags ; \n} \n} \n"}
{"3371": "public class ThreadSafeBitSet { \npublic void clearAll ( ) { \nThreadSafeBitSetSegments segments = this . segments . get ( ) ; \nfor ( int i = 0 ; \nsegments . numSegments ( ) > i ; \ni ++ ) { \nAtomicLongArray segment = segments . getSegment ( i ) ; \nfor ( int j = 0 ; \nsegment . length ( ) > j ; \nj ++ ) { \nsegment . set ( j , 0L ) ; \n} \n} \n} \n} \n"}
{"3372": "public class SnapshotPopulatedOrdinalsReader { \npublic static void readOrdinals ( DataInputStream dis , HollowTypeStateListener [ ] listeners ) throws IOException { \nint numLongs = dis . readInt ( ) ; \nint currentOrdinal = 0 ; \nfor ( int i = 0 ; \nnumLongs > i ; \ni ++ ) { \nlong l = dis . readLong ( ) ; \nnotifyPopulatedOrdinals ( l , currentOrdinal , listeners ) ; \ncurrentOrdinal += 64 ; \n} \n} \n} \n"}
{"3375": "public class SegmentedByteArray { \npublic void copy ( ByteData src , long srcPos , long destPos , long length ) { \nfor ( long i = 0 ; \nlength > i ; \ni ++ ) { \nset ( destPos ++ , src . get ( srcPos ++ ) ) ; \n} \n} \n} \n"}
{"3376": "public class SegmentedByteArray { \npublic int copy ( long srcPos , byte [ ] data , int destPos , int length ) { \nint segmentSize = 1 << log2OfSegmentSize ; \nint remainingBytesInSegment = ( int ) ( segmentSize - ( srcPos & bitmask ) ) ; \nint dataPosition = destPos ; \nwhile ( 0 < length ) { \nbyte [ ] segment = segments [ ( int ) ( srcPos >>> log2OfSegmentSize ) ] ; \nint bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , length ) ; \nSystem . arraycopy ( segment , ( int ) ( srcPos & bitmask ) , data , dataPosition , bytesToCopyFromSegment ) ; \ndataPosition += bytesToCopyFromSegment ; \nsrcPos += bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( srcPos & bitmask ) ; \nlength -= bytesToCopyFromSegment ; \n} \nreturn dataPosition - destPos ; \n} \n} \n"}
{"3377": "public class SegmentedByteArray { \npublic boolean rangeEquals ( long rangeStart , SegmentedByteArray compareTo , long cmpStart , int length ) { \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) if ( get ( rangeStart + i ) != compareTo . get ( cmpStart + i ) ) return false ; \nreturn true ; \n} \n} \n"}
{"3378": "public class SegmentedByteArray { \npublic void orderedCopy ( SegmentedByteArray src , long srcPos , long destPos , long length ) { \nint segmentLength = 1 << log2OfSegmentSize ; \nint currentSegment = ( int ) ( destPos >>> log2OfSegmentSize ) ; \nint segmentStartPos = ( int ) ( destPos & bitmask ) ; \nint remainingBytesInSegment = segmentLength - segmentStartPos ; \nwhile ( 0 < length ) { \nint bytesToCopyFromSegment = ( int ) Math . min ( remainingBytesInSegment , length ) ; \nensureCapacity ( currentSegment ) ; \nint copiedBytes = src . orderedCopy ( srcPos , segments [ currentSegment ] , segmentStartPos , bytesToCopyFromSegment ) ; \nsrcPos += copiedBytes ; \nlength -= copiedBytes ; \nsegmentStartPos = 0 ; \nremainingBytesInSegment = segmentLength ; \ncurrentSegment ++ ; \n} \n} \n} \n"}
{"3379": "public class SegmentedByteArray { \npublic int orderedCopy ( long srcPos , byte [ ] data , int destPos , int length ) { \nint segmentSize = 1 << log2OfSegmentSize ; \nint remainingBytesInSegment = ( int ) ( segmentSize - ( srcPos & bitmask ) ) ; \nint dataPosition = destPos ; \nwhile ( 0 < length ) { \nbyte [ ] segment = segments [ ( int ) ( srcPos >>> log2OfSegmentSize ) ] ; \nint bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , length ) ; \norderedCopy ( segment , ( int ) ( srcPos & bitmask ) , data , dataPosition , bytesToCopyFromSegment ) ; \ndataPosition += bytesToCopyFromSegment ; \nsrcPos += bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( srcPos & bitmask ) ; \nlength -= bytesToCopyFromSegment ; \n} \nreturn dataPosition - destPos ; \n} \n} \n"}
{"3380": "public class SegmentedByteArray { \npublic void readFrom ( InputStream is , long length ) throws IOException { \nint segmentSize = 1 << log2OfSegmentSize ; \nint segment = 0 ; \nbyte scratch [ ] = new byte [ segmentSize ] ; \nwhile ( 0 < length ) { \nensureCapacity ( segment ) ; \nlong bytesToCopy = Math . min ( segmentSize , length ) ; \nlong bytesCopied = 0 ; \nwhile ( bytesToCopy > bytesCopied ) { \nbytesCopied += is . read ( scratch , ( int ) bytesCopied , ( int ) ( bytesToCopy - bytesCopied ) ) ; \n} \norderedCopy ( scratch , 0 , segments [ segment ++ ] , 0 , ( int ) bytesCopied ) ; \nlength -= bytesCopied ; \n} \n} \n} \n"}
{"3381": "public class SegmentedByteArray { \npublic void writeTo ( OutputStream os , long startPosition , long len ) throws IOException { \nint segmentSize = 1 << log2OfSegmentSize ; \nint remainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; \nlong remainingBytesInCopy = len ; \nwhile ( 0 < remainingBytesInCopy ) { \nlong bytesToCopyFromSegment = Math . min ( remainingBytesInSegment , remainingBytesInCopy ) ; \nos . write ( segments [ ( int ) ( startPosition >>> log2OfSegmentSize ) ] , ( int ) ( startPosition & bitmask ) , ( int ) bytesToCopyFromSegment ) ; \nstartPosition += bytesToCopyFromSegment ; \nremainingBytesInSegment = segmentSize - ( int ) ( startPosition & bitmask ) ; \nremainingBytesInCopy -= bytesToCopyFromSegment ; \n} \n} \n} \n"}
{"3382": "public class SegmentedByteArray { \nprivate void ensureCapacity ( int segmentIndex ) { \nwhile ( segments . length <= segmentIndex ) { \nsegments = Arrays . copyOf ( segments , segments . length * 3 / 2 ) ; \n} \nif ( segments [ segmentIndex ] == null ) { \nsegments [ segmentIndex ] = memoryRecycler . getByteArray ( ) ; \n} \n} \n} \n"}
{"3384": "public class HollowHashIndexBuilder { \nprivate long calculateDedupedSizesAndTotalNumberOfSelectBuckets ( MultiLinkedElementArray elementArray , GrowingSegmentedLongArray matchIndexHashAndSizeArray ) { \nlong totalBuckets = 0 ; \nlong maxSize = 0 ; \nint [ ] selectArray = new int [ 8 ] ; \nfor ( int i = 0 ; \nelementArray . numLists ( ) > i ; \ni ++ ) { \nint listSize = elementArray . listSize ( i ) ; \nint setSize = 0 ; \nint predictedBuckets = HashCodes . hashTableSize ( listSize ) ; \nint hashMask = predictedBuckets - 1 ; \nif ( selectArray . length < predictedBuckets ) selectArray = new int [ predictedBuckets ] ; \nfor ( int j = 0 ; \npredictedBuckets > j ; \nj ++ ) selectArray [ j ] = - 1 ; \nHollowOrdinalIterator iter = elementArray . iterator ( i ) ; \nint selectOrdinal = iter . next ( ) ; \nwhile ( selectOrdinal != HollowOrdinalIterator . NO_MORE_ORDINALS ) { \nint hash = HashCodes . hashInt ( selectOrdinal ) ; \nint bucket = hash & hashMask ; \nwhile ( true ) { \nif ( selectArray [ bucket ] == selectOrdinal ) break ; \nif ( selectArray [ bucket ] == - 1 ) { \nselectArray [ bucket ] = selectOrdinal ; \nsetSize ++ ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashMask ; \n} \nselectOrdinal = iter . next ( ) ; \n} \nlong matchIndexHashAndSize = matchIndexHashAndSizeArray . get ( i ) ; \nmatchIndexHashAndSize |= ( long ) setSize << 32 ; \nmatchIndexHashAndSizeArray . set ( i , matchIndexHashAndSize ) ; \ntotalBuckets += HashCodes . hashTableSize ( setSize ) ; \nif ( maxSize < setSize ) maxSize = setSize ; \n} \nreturn totalBuckets | ( long ) bitsRequiredToRepresentValue ( maxSize ) << 56 ; \n} \n} \n"}
{"3388": "public class HollowPrimaryKeyValueDeriver { \npublic boolean keyMatches ( int ordinal , Object ... keys ) { \nif ( keys . length != fieldPathIndexes . length ) return false ; \nfor ( int i = 0 ; \nkeys . length > i ; \ni ++ ) { \nif ( ! keyMatches ( keys [ i ] , ordinal , i ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3389": "public class HollowPrimaryKeyValueDeriver { \npublic Object [ ] getRecordKey ( int ordinal ) { \nObject [ ] results = new Object [ fieldPathIndexes . length ] ; \nfor ( int i = 0 ; \nfieldPathIndexes . length > i ; \ni ++ ) { \nresults [ i ] = readValue ( ordinal , i ) ; \n} \nreturn results ; \n} \n} \n"}
{"3400": "public class GrowingSegmentedLongArray { \npublic long get ( long index ) { \nint segmentIndex = ( int ) ( index >> log2OfSegmentSize ) ; \nif ( segments . length <= segmentIndex || segments [ segmentIndex ] == null ) return 0 ; \nint longInSegment = ( int ) ( index & bitmask ) ; \nreturn segments [ segmentIndex ] [ longInSegment ] ; \n} \n} \n"}
{"3404": "public class HollowSpecificDiff { \npublic void setElementKeyPaths ( String ... paths ) { \nresetResults ( ) ; \nelementKeyPaths = new BitSet ( elementPaths . length ) ; \nfor ( int i = 0 ; \npaths . length > i ; \ni ++ ) { \nint elementPathIdx = getElementPathIdx ( paths [ i ] ) ; \nif ( elementPathIdx == - 1 ) throw new IllegalArgumentException ( \"Key path must have been specified as an element match path.  Offending path: \" + paths [ i ] ) ; \nelementKeyPaths . set ( elementPathIdx ) ; \n} \nelementNonKeyPaths = new BitSet ( elementPaths . length ) ; \nelementNonKeyPaths . set ( 0 , elementPaths . length ) ; \nelementNonKeyPaths . andNot ( elementKeyPaths ) ; \n} \n} \n"}
{"3405": "public class HollowSpecificDiff { \npublic void calculate ( ) { \nresetResults ( ) ; \nSimultaneousExecutor executor = new SimultaneousExecutor ( getClass ( ) , \"calculate\" ) ; \nfinal int numThreads = executor . getCorePoolSize ( ) ; \nfor ( int i = 0 ; \nnumThreads > i ; \ni ++ ) { \nfinal int threadNumber = i ; \nexecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \nHollowIndexerValueTraverser fromTraverser = new HollowIndexerValueTraverser ( from , type , elementPaths ) ; \nHollowIndexerValueTraverser toTraverser = new HollowIndexerValueTraverser ( to , type , elementPaths ) ; \nint hashedResults [ ] = new int [ 16 ] ; \nfor ( int i = threadNumber ; \nmatcher . getMatchedOrdinals ( ) . size ( ) > i ; \ni += numThreads ) { \nlong ordinalPair = matcher . getMatchedOrdinals ( ) . get ( i ) ; \nint fromOrdinal = ( int ) ( ordinalPair >>> 32 ) ; \nint toOrdinal = ( int ) ordinalPair ; \nfromTraverser . traverse ( fromOrdinal ) ; \ntoTraverser . traverse ( toOrdinal ) ; \nif ( hashedResults . length < fromTraverser . getNumMatches ( ) * 2 ) hashedResults = new int [ hashTableSize ( fromTraverser . getNumMatches ( ) ) ] ; \npopulateHashTable ( fromTraverser , hashedResults ) ; \ncountMatches ( fromTraverser , toTraverser , hashedResults ) ; \n} \nfor ( int i = threadNumber ; \nmatcher . getExtraInFrom ( ) . size ( ) > i ; \ni += numThreads ) { \nfromTraverser . traverse ( matcher . getExtraInFrom ( ) . get ( i ) ) ; \ntotalUnmatchedFromElements . addAndGet ( fromTraverser . getNumMatches ( ) ) ; \n} \nfor ( int i = threadNumber ; \nmatcher . getExtraInTo ( ) . size ( ) > i ; \ni += numThreads ) { \ntoTraverser . traverse ( matcher . getExtraInTo ( ) . get ( i ) ) ; \ntotalUnmatchedToElements . addAndGet ( toTraverser . getNumMatches ( ) ) ; \n} \n} \n} \n) ; \n} \ntry { \nexecutor . awaitSuccessfulCompletion ( ) ; \n} \ncatch ( Exception ex ) { \nthrow new RuntimeException ( ex ) ; \n} \n} \n} \n"}
{"3406": "public class HollowIncrementalProducer { \npublic void restoreFromLastState ( ) { \nproducer . initializeDataModel ( dataModel ) ; \nlong latestAnnouncedVersion = announcementWatcher . getLatestVersion ( ) ; \nif ( latestAnnouncedVersion == HollowFilesystemAnnouncementWatcher . NO_ANNOUNCEMENT_AVAILABLE || 0 > latestAnnouncedVersion ) { \nreturn ; \n} \nrestore ( latestAnnouncedVersion , blobRetriever ) ; \n} \n} \n"}
{"3408": "public class HollowCombinerExcludePrimaryKeysCopyDirector { \npublic void excludeKey ( HollowPrimaryKeyIndex idx , Object ... key ) { \nint excludeOrdinal = idx . getMatchingOrdinal ( key ) ; \nif ( 0 <= excludeOrdinal ) { \nBitSet excludedOrdinals = this . excludedOrdinals . get ( idx . getTypeState ( ) ) ; \nif ( excludedOrdinals == null ) { \nexcludedOrdinals = new BitSet ( idx . getTypeState ( ) . maxOrdinal ( ) + 1 ) ; \nthis . excludedOrdinals . put ( idx . getTypeState ( ) , excludedOrdinals ) ; \n} \nexcludedOrdinals . set ( excludeOrdinal ) ; \n} \n} \n} \n"}
{"3412": "public class HollowObjectWriteRecord { \npublic void writeDataTo ( ByteDataBuffer buf ) { \nfor ( int i = 0 ; \nfieldData . length > i ; \ni ++ ) { \nwriteField ( buf , i ) ; \n} \n} \n} \n"}
{"3416": "public class FreeOrdinalTracker { \npublic void sort ( ) { \nArrays . sort ( freeOrdinals , 0 , size ) ; \nint midpoint = size / 2 ; \nfor ( int i = 0 ; \nmidpoint > i ; \ni ++ ) { \nint temp = freeOrdinals [ i ] ; \nfreeOrdinals [ i ] = freeOrdinals [ size - i - 1 ] ; \nfreeOrdinals [ size - i - 1 ] = temp ; \n} \n} \n} \n"}
{"3417": "public class SetMapKeyHasher { \npublic static int hash ( Object key [ ] , FieldType fieldType [ ] ) { \nint hash = 0 ; \nfor ( int i = 0 ; \nkey . length > i ; \ni ++ ) { \nhash *= 31 ; \nhash ^= hash ( key [ i ] , fieldType [ i ] ) ; \n} \nreturn hash ; \n} \n} \n"}
{"3419": "public class FixedLengthMultipleOccurrenceElementArray { \nprivate void resizeStorage ( ) { \nint currentElementsPerNode = maxElementsPerNode ; \nint newElementsPerNode = ( int ) ( currentElementsPerNode * RESIZE_MULTIPLE ) ; \nif ( currentElementsPerNode >= newElementsPerNode ) { \nthrow new IllegalStateException ( \"cannot resize fixed length array from \" + currentElementsPerNode + \" to \" + newElementsPerNode ) ; \n} \nFixedLengthElementArray newStorage = new FixedLengthElementArray ( memoryRecycler , numNodes * bitsPerElement * newElementsPerNode ) ; \nLongStream . range ( 0 , numNodes ) . forEach ( nodeIndex -> { \nlong currentBucketStart = nodeIndex * currentElementsPerNode * bitsPerElement ; \nlong newBucketStart = nodeIndex * newElementsPerNode * bitsPerElement ; \nfor ( int offset = 0 ; \ncurrentElementsPerNode > offset ; \noffset ++ ) { \nlong element = storage . getElementValue ( currentBucketStart + offset * bitsPerElement , bitsPerElement , elementMask ) ; \nif ( element == NO_ELEMENT ) { \nbreak ; \n} \nnewStorage . setElementValue ( newBucketStart + offset * bitsPerElement , bitsPerElement , element ) ; \n} \n} \n) ; \nstorage . destroy ( memoryRecycler ) ; \nstorage = newStorage ; \nmaxElementsPerNode = newElementsPerNode ; \n} \n} \n"}
{"3421": "public class ByteArrayOrdinalMap { \npublic void prepareForWrite ( ) { \nint maxOrdinal = 0 ; \nAtomicLongArray pao = pointersAndOrdinals ; \nfor ( int i = 0 ; \npao . length ( ) > i ; \ni ++ ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nint ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \nif ( maxOrdinal < ordinal ) { \nmaxOrdinal = ordinal ; \n} \n} \n} \nlong [ ] pbo = new long [ maxOrdinal + 1 ] ; \nArrays . fill ( pbo , - 1 ) ; \nfor ( int i = 0 ; \npao . length ( ) > i ; \ni ++ ) { \nlong key = pao . get ( i ) ; \nif ( key != EMPTY_BUCKET_VALUE ) { \nint ordinal = ( int ) ( key >>> BITS_PER_POINTER ) ; \npbo [ ordinal ] = key & POINTER_MASK ; \n} \n} \npointersByOrdinal = pbo ; \n} \n} \n"}
{"3422": "public class ByteArrayOrdinalMap { \nprivate boolean compare ( ByteDataBuffer serializedRepresentation , long key ) { \nlong position = key & POINTER_MASK ; \nint sizeOfData = VarInt . readVInt ( byteData . getUnderlyingArray ( ) , position ) ; \nif ( sizeOfData != serializedRepresentation . length ( ) ) { \nreturn false ; \n} \nposition += VarInt . sizeOfVInt ( sizeOfData ) ; \nfor ( int i = 0 ; \nsizeOfData > i ; \ni ++ ) { \nif ( serializedRepresentation . get ( i ) != byteData . get ( position ++ ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"3423": "public class ByteArrayOrdinalMap { \nprivate void growKeyArray ( ) { \nint newSize = pointersAndOrdinals . length ( ) << 1 ; \nif ( 0 > newSize ) { \nthrow new IllegalStateException ( \"New size computed to grow the underlying array for the map is negative. \" + \"This is most likely due to the total number of keys added to map has exceeded the max capacity of the keys map can hold. \" + \"Current array size :\" + pointersAndOrdinals . length ( ) + \" and size to grow :\" + newSize ) ; \n} \ngrowKeyArray ( newSize ) ; \n} \n} \n"}
{"3425": "public class ByteArrayOrdinalMap { \nprivate AtomicLongArray emptyKeyArray ( int size ) { \nAtomicLongArray arr = new AtomicLongArray ( size ) ; \nfor ( int i = 0 ; \narr . length ( ) > i ; \ni ++ ) { \narr . lazySet ( i , EMPTY_BUCKET_VALUE ) ; \n} \nreturn arr ; \n} \n} \n"}
{"3426": "public class HollowIndexerValueTraverser { \npublic boolean isMatchEqual ( int matchIdx , HollowIndexerValueTraverser otherTraverser , int otherMatchIdx ) { \nfor ( int i = 0 ; \ngetNumFieldPaths ( ) > i ; \ni ++ ) { \nif ( ! HollowReadFieldUtils . fieldsAreEqual ( ( HollowObjectTypeDataAccess ) fieldTypeDataAccess [ i ] , fieldMatchLists [ i ] . get ( matchIdx ) , fieldSchemaPosition [ i ] , ( HollowObjectTypeDataAccess ) otherTraverser . fieldTypeDataAccess [ i ] , otherTraverser . fieldMatchLists [ i ] . get ( otherMatchIdx ) , otherTraverser . fieldSchemaPosition [ i ] ) ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"3429": "public class HashCodes { \npublic static int hashTableSize ( int numElements ) throws IllegalArgumentException { \nif ( 0 > numElements ) { \nthrow new IllegalArgumentException ( \"cannot be negative; numElements=\" + numElements ) ; \n} \nelse if ( HASH_TABLE_MAX_SIZE < numElements ) { \nthrow new IllegalArgumentException ( \"exceeds maximum number of buckets; numElements=\" + numElements ) ; \n} \nif ( numElements == 0 ) return 1 ; \nif ( 3 > numElements ) return numElements * 2 ; \nint sizeAfterLoadFactor = ( int ) ( ( long ) numElements * 10 / 7 ) ; \nint bits = 32 - Integer . numberOfLeadingZeros ( sizeAfterLoadFactor - 1 ) ; \nreturn 1 << bits ; \n} \n} \n"}
{"3434": "public class HollowCodeGenerationUtils { \npublic static String normalizeFieldPathToParamName ( String fieldPath ) { \nString result = null ; \nif ( fieldPath . contains ( \".\" ) ) { \nString [ ] parts = fieldPath . split ( \"\\\\.\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( lowercase ( parts [ 0 ] ) ) ; \nfor ( int i = 1 ; \nparts . length > i ; \ni ++ ) { \nsb . append ( uppercase ( parts [ i ] ) ) ; \n} \nresult = sb . toString ( ) ; \n} \nelse { \nresult = lowercase ( fieldPath ) ; \n} \nif ( result . endsWith ( \"!\" ) ) { \nreturn result . substring ( 0 , result . length ( ) - 1 ) ; \n} \nreturn result ; \n} \n} \n"}
{"3436": "public class HollowHashIndex { \npublic HollowHashIndexResult findMatches ( Object ... query ) { \nint hashCode = 0 ; \nfor ( int i = 0 ; \nquery . length > i ; \ni ++ ) { \nif ( query [ i ] == null ) throw new IllegalArgumentException ( \"querying by null unsupported; i=\" + i ) ; \nhashCode ^= HashCodes . hashInt ( keyHashCode ( query [ i ] , i ) ) ; \n} \nHollowHashIndexResult result ; \nHollowHashIndexState hashState ; \ndo { \nresult = null ; \nhashState = hashStateVolatile ; \nlong bucket = hashCode & hashState . getMatchHashMask ( ) ; \nlong hashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nboolean bucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \nwhile ( ! bucketIsEmpty ) { \nif ( matchIsEqual ( hashState . getMatchHashTable ( ) , hashBucketBit , query ) ) { \nint selectSize = ( int ) hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) , hashState . getBitsPerSelectTableSize ( ) ) ; \nlong selectBucketPointer = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit + hashState . getBitsPerMatchHashKey ( ) + hashState . getBitsPerSelectTableSize ( ) , hashState . getBitsPerSelectTablePointer ( ) ) ; \nresult = new HollowHashIndexResult ( hashState , selectBucketPointer , selectSize ) ; \nbreak ; \n} \nbucket = ( bucket + 1 ) & hashState . getMatchHashMask ( ) ; \nhashBucketBit = bucket * hashState . getBitsPerMatchHashEntry ( ) ; \nbucketIsEmpty = hashState . getMatchHashTable ( ) . getElementValue ( hashBucketBit , hashState . getBitsPerTraverserField ( ) [ 0 ] ) == 0 ; \n} \n} \nwhile ( hashState != hashStateVolatile ) ; \nreturn result ; \n} \n} \n"}
{"3437": "public class HollowAnnouncementWatcher { \npublic void triggerAsyncRefreshWithRandomDelay ( int maxDelayMillis ) { \nRandom rand = new Random ( ) ; \nint delayMillis = 0 < maxDelayMillis ? rand . nextInt ( maxDelayMillis ) : 0 ; \ntriggerAsyncRefreshWithDelay ( delayMillis ) ; \n} \n} \n"}
{"3438": "public class HollowAnnouncementWatcher { \npublic void triggerAsyncRefreshWithDelay ( int delayMillis ) { \nfinal HollowClient client = this . client ; \nfinal long targetBeginTime = System . currentTimeMillis ( ) + delayMillis ; \nrefreshExecutor . execute ( new Runnable ( ) { \npublic void run ( ) { \ntry { \nlong delay = targetBeginTime - System . currentTimeMillis ( ) ; \nif ( 0 < delay ) Thread . sleep ( delay ) ; \nclient . triggerRefresh ( ) ; \n} \ncatch ( Throwable th ) { \nlog . log ( Level . SEVERE , \"Async refresh failed\" , th ) ; \n} \n} \n} \n) ; \n} \n} \n"}
{"3441": "public class VarInt { \npublic static void writeVLong ( OutputStream out , long value ) throws IOException { \nif ( 0 > value ) out . write ( ( byte ) 0x81 ) ; \nif ( 0xFFFFFFFFFFFFFFL < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 56 ) & 0x7FL ) ) ) ; \nif ( 0x1FFFFFFFFFFFFL < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 49 ) & 0x7FL ) ) ) ; \nif ( 0x3FFFFFFFFFFL < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 42 ) & 0x7FL ) ) ) ; \nif ( 0x7FFFFFFFFL < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 35 ) & 0x7FL ) ) ) ; \nif ( 0xFFFFFFFL < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 28 ) & 0x7FL ) ) ) ; \nif ( 0x1FFFFFL < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7FL ) ) ) ; \nif ( 0x3FFFL < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7FL ) ) ) ; \nif ( 0x7FL < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7FL ) ) ) ; \nout . write ( ( byte ) ( value & 0x7FL ) ) ; \n} \n} \n"}
{"3442": "public class VarInt { \npublic static void writeVInt ( OutputStream out , int value ) throws IOException { \nif ( 0x0FFFFFFF < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 28 ) ) ) ) ; \nif ( 0x1FFFFF < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7F ) ) ) ; \nif ( 0x3FFF < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7F ) ) ) ; \nif ( 0x7F < value || 0 > value ) out . write ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7F ) ) ) ; \nout . write ( ( byte ) ( value & 0x7F ) ) ; \n} \n} \n"}
{"3443": "public class VarInt { \npublic static int writeVInt ( byte data [ ] , int pos , int value ) { \nif ( 0x0FFFFFFF < value || 0 > value ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 28 ) ) ) ) ; \nif ( 0x1FFFFF < value || 0 > value ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 21 ) & 0x7F ) ) ) ; \nif ( 0x3FFF < value || 0 > value ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 14 ) & 0x7F ) ) ) ; \nif ( 0x7F < value || 0 > value ) data [ pos ++ ] = ( ( byte ) ( 0x80 | ( ( value >>> 7 ) & 0x7F ) ) ) ; \ndata [ pos ++ ] = ( byte ) ( value & 0x7F ) ; \nreturn pos ; \n} \n} \n"}
{"3449": "public class PullToRefreshBase { \nprivate void pullEvent ( ) { \nfinal int newScrollValue ; \nfinal int itemDimension ; \nfinal float initialMotionValue , lastMotionValue ; \nswitch ( getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : initialMotionValue = mInitialMotionX ; \nlastMotionValue = mLastMotionX ; \nbreak ; \ncase VERTICAL : default : initialMotionValue = mInitialMotionY ; \nlastMotionValue = mLastMotionY ; \nbreak ; \n} \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : newScrollValue = Math . round ( Math . max ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getFooterSize ( ) ; \nbreak ; \ncase PULL_FROM_START : default : newScrollValue = Math . round ( Math . min ( initialMotionValue - lastMotionValue , 0 ) / FRICTION ) ; \nitemDimension = getHeaderSize ( ) ; \nbreak ; \n} \nsetHeaderScroll ( newScrollValue ) ; \nif ( newScrollValue != 0 && ! isRefreshing ( ) ) { \nfloat scale = Math . abs ( newScrollValue ) / ( float ) itemDimension ; \nswitch ( mCurrentMode ) { \ncase PULL_FROM_END : mFooterLayout . onPull ( scale ) ; \nbreak ; \ncase PULL_FROM_START : default : mHeaderLayout . onPull ( scale ) ; \nbreak ; \n} \nif ( mState != State . PULL_TO_REFRESH && Math . abs ( newScrollValue ) <= itemDimension ) { \nsetState ( State . PULL_TO_REFRESH ) ; \n} \nelse if ( mState == State . PULL_TO_REFRESH && Math . abs ( newScrollValue ) > itemDimension ) { \nsetState ( State . RELEASE_TO_REFRESH ) ; \n} \n} \n} \n} \n"}
{"3450": "public class OverscrollHelper { \npublic static void overScrollBy ( final PullToRefreshBase < ? > view , final int deltaX , final int scrollX , final int deltaY , final int scrollY , final int scrollRange , final int fuzzyThreshold , final float scaleFactor , final boolean isTouchEvent ) { \nfinal int deltaValue , currentScrollValue , scrollValue ; \nswitch ( view . getPullToRefreshScrollDirection ( ) ) { \ncase HORIZONTAL : deltaValue = deltaX ; \nscrollValue = scrollX ; \ncurrentScrollValue = view . getScrollX ( ) ; \nbreak ; \ncase VERTICAL : default : deltaValue = deltaY ; \nscrollValue = scrollY ; \ncurrentScrollValue = view . getScrollY ( ) ; \nbreak ; \n} \nif ( view . isPullToRefreshOverScrollEnabled ( ) && ! view . isRefreshing ( ) ) { \nfinal Mode mode = view . getMode ( ) ; \nif ( mode . permitsPullToRefresh ( ) && ! isTouchEvent && deltaValue != 0 ) { \nfinal int newScrollValue = ( deltaValue + scrollValue ) ; \nif ( PullToRefreshBase . DEBUG ) { \nLog . d ( LOG_TAG , \"OverScroll. DeltaX: \" + deltaX + \", ScrollX: \" + scrollX + \", DeltaY: \" + deltaY + \", ScrollY: \" + scrollY + \", NewY: \" + newScrollValue + \", ScrollRange: \" + scrollRange + \", CurrentScroll: \" + currentScrollValue ) ; \n} \nif ( ( 0 - fuzzyThreshold ) > newScrollValue ) { \nif ( mode . showHeaderLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue ) ) ) ; \n} \n} \nelse if ( ( scrollRange + fuzzyThreshold ) < newScrollValue ) { \nif ( mode . showFooterLoadingLayout ( ) ) { \nif ( currentScrollValue == 0 ) { \nview . setState ( State . OVERSCROLLING ) ; \n} \nview . setHeaderScroll ( ( int ) ( scaleFactor * ( currentScrollValue + newScrollValue - scrollRange ) ) ) ; \n} \n} \nelse if ( fuzzyThreshold >= Math . abs ( newScrollValue ) || fuzzyThreshold >= Math . abs ( newScrollValue - scrollRange ) ) { \nview . setState ( State . RESET ) ; \n} \n} \nelse if ( isTouchEvent && State . OVERSCROLLING == view . getState ( ) ) { \nview . setState ( State . RESET ) ; \n} \n} \n} \n} \n"}
{"3461": "public class AnnotationUtils { \npublic static Optional < Field > getAnnotatedField ( Class annotation , Class clazz ) { \nList < Field > fields = getAnnotatedFields ( annotation , clazz ) ; \nreturn Optional . ofNullable ( 0 < fields . size ( ) ? fields . get ( 0 ) : null ) ; \n} \n} \n"}
{"3462": "public class AnnotationUtils { \npublic static Optional < Method > getAnnotatedMethod ( Class annotation , Class clazz ) { \nList < Method > methods = getAnnotatedMethods ( annotation , clazz ) ; \nreturn Optional . ofNullable ( 0 < methods . size ( ) ? methods . get ( 0 ) : null ) ; \n} \n} \n"}
{"3474": "public class DefaultServiceEnricher { \nprivate Service [ ] toArray ( List < Service > services ) { \nif ( services == null ) { \nreturn new Service [ 0 ] ; \n} \nif ( services instanceof ArrayList ) { \nreturn ( ( ArrayList < Service > ) services ) . toArray ( new Service [ services . size ( ) ] ) ; \n} \nelse { \nService [ ] ret = new Service [ services . size ( ) ] ; \nfor ( int i = 0 ; \nservices . size ( ) > i ; \ni ++ ) { \nret [ i ] = services . get ( i ) ; \n} \nreturn ret ; \n} \n} \n} \n"}
{"3490": "public class KubernetesHelper { \npublic static String validateKubernetesId ( String currentValue , String description ) throws IllegalArgumentException { \nif ( StringUtils . isBlank ( currentValue ) ) { \nthrow new IllegalArgumentException ( \"No \" + description + \" is specified!\" ) ; \n} \nint size = currentValue . length ( ) ; \nfor ( int i = 0 ; \nsize > i ; \ni ++ ) { \nchar ch = currentValue . charAt ( i ) ; \nif ( Character . isUpperCase ( ch ) ) { \nthrow new IllegalArgumentException ( \"Invalid upper case letter '\" + ch + \"' at index \" + i + \" for \" + description + \" value: \" + currentValue ) ; \n} \n} \nreturn currentValue ; \n} \n} \n"}
{"3507": "public class IoUtil { \npublic static void download ( Logger log , URL downloadUrl , File target ) throws MojoExecutionException { \nlog . progressStart ( ) ; \ntry { \nOkHttpClient client = new OkHttpClient . Builder ( ) . readTimeout ( 30 , TimeUnit . MINUTES ) . build ( ) ; \nRequest request = new Request . Builder ( ) . url ( downloadUrl ) . build ( ) ; \nResponse response = client . newCall ( request ) . execute ( ) ; \ntry ( OutputStream out = new FileOutputStream ( target ) ; \nInputStream im = response . body ( ) . byteStream ( ) ) { \nlong length = response . body ( ) . contentLength ( ) ; \nInputStream in = response . body ( ) . byteStream ( ) ; \nbyte [ ] buffer = new byte [ 8192 ] ; \nlong readBytes = 0 ; \nwhile ( true ) { \nint len = in . read ( buffer ) ; \nreadBytes += len ; \nlog . progressUpdate ( target . getName ( ) , \"Downloading\" , getProgressBar ( readBytes , length ) ) ; \nif ( 0 >= len ) { \nout . flush ( ) ; \nbreak ; \n} \nout . write ( buffer , 0 , len ) ; \n} \n} \n} \ncatch ( IOException e ) { \nthrow new MojoExecutionException ( \"Failed to download URL \" + downloadUrl + \" to  \" + target + \": \" + e , e ) ; \n} \nfinally { \nlog . progressFinished ( ) ; \n} \n} \n} \n"}
{"3508": "public class VersionUtil { \npublic static int compareVersions ( String v1 , String v2 ) { \nString [ ] components1 = split ( v1 ) ; \nString [ ] components2 = split ( v2 ) ; \nint diff ; \nint length = Math . min ( components1 . length , components2 . length ) ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nString s1 = components1 [ i ] ; \nString s2 = components2 [ i ] ; \nInteger i1 = tryParseInteger ( s1 ) ; \nInteger i2 = tryParseInteger ( s2 ) ; \nif ( i1 != null && i2 != null ) { \ndiff = i1 . compareTo ( i2 ) ; \n} \nelse { \ndiff = s1 . compareTo ( s2 ) ; \n} \nif ( diff != 0 ) { \nreturn diff ; \n} \n} \ndiff = Integer . compare ( components1 . length , components2 . length ) ; \nif ( diff == 0 ) { \nif ( v1 == v2 ) { \nreturn 0 ; \n} \n; \nreturn v1 != null ? v1 . compareTo ( v2 ) : - 1 ; \n} \nreturn diff ; \n} \n} \n"}
{"3518": "public class BaseEnricher { \nprotected int getReplicaCount ( KubernetesListBuilder builder , ResourceConfig xmlResourceConfig , int defaultValue ) { \nif ( xmlResourceConfig != null ) { \nList < HasMetadata > items = builder . buildItems ( ) ; \nfor ( HasMetadata item : items ) { \nif ( item instanceof Deployment ) { \nif ( ( ( Deployment ) item ) . getSpec ( ) . getReplicas ( ) != null ) { \nreturn ( ( Deployment ) item ) . getSpec ( ) . getReplicas ( ) ; \n} \n} \nif ( item instanceof DeploymentConfig ) { \nif ( ( ( DeploymentConfig ) item ) . getSpec ( ) . getReplicas ( ) != null ) { \nreturn ( ( DeploymentConfig ) item ) . getSpec ( ) . getReplicas ( ) ; \n} \n} \n} \nreturn 0 < xmlResourceConfig . getReplicas ( ) ? xmlResourceConfig . getReplicas ( ) : defaultValue ; \n} \nreturn defaultValue ; \n} \n} \n"}
{"3519": "public class XmlUtils { \npublic static Element firstChild ( Element element , String name ) { \nNodeList nodes = element . getChildNodes ( ) ; \nif ( nodes != null ) { \nfor ( int i = 0 , size = nodes . getLength ( ) ; \nsize > i ; \ni ++ ) { \nNode item = nodes . item ( i ) ; \nif ( item instanceof Element ) { \nElement childElement = ( Element ) item ; \nif ( name . equals ( childElement . getTagName ( ) ) ) { \nreturn childElement ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"3529": "public class JavaExecGenerator { \nprotected Map < String , String > getEnv ( boolean prePackagePhase ) throws MojoExecutionException { \nMap < String , String > ret = new HashMap < > ( ) ; \nif ( ! isFatJar ( ) ) { \nString mainClass = getConfig ( Config . mainClass ) ; \nif ( mainClass == null ) { \nmainClass = mainClassDetector . getMainClass ( ) ; \nif ( mainClass == null ) { \nif ( ! prePackagePhase ) { \nthrow new MojoExecutionException ( \"Cannot extract main class to startup\" ) ; \n} \n} \n} \nif ( mainClass != null ) { \nlog . verbose ( \"Detected main class %s\" , mainClass ) ; \nret . put ( JAVA_MAIN_CLASS_ENV_VAR , mainClass ) ; \n} \n} \nList < String > javaOptions = getExtraJavaOptions ( ) ; \nif ( 0 < javaOptions . size ( ) ) { \nret . put ( JAVA_OPTIONS , StringUtils . join ( javaOptions . iterator ( ) , \" \" ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3530": "public class GoTimeUtil { \npublic static Integer durationSeconds ( String duration ) { \nBigDecimal ns = durationNs ( duration ) ; \nif ( ns == null ) { \nreturn null ; \n} \nBigDecimal sec = ns . divide ( new BigDecimal ( 1_000_000_000 ) ) ; \nif ( 0 < sec . compareTo ( new BigDecimal ( Integer . MAX_VALUE ) ) ) { \nthrow new IllegalArgumentException ( \"Integer Overflow\" ) ; \n} \nreturn sec . intValue ( ) ; \n} \n} \n"}
{"3531": "public class GoTimeUtil { \npublic static BigDecimal durationNs ( String durationP ) { \nif ( durationP == null ) { \nreturn null ; \n} \nString duration = durationP . trim ( ) ; \nif ( duration . length ( ) == 0 ) { \nreturn null ; \n} \nint unitPos = 1 ; \nwhile ( duration . length ( ) > unitPos && ( Character . isDigit ( duration . charAt ( unitPos ) ) || duration . charAt ( unitPos ) == '.' ) ) { \nunitPos ++ ; \n} \nif ( duration . length ( ) <= unitPos ) { \nthrow new IllegalArgumentException ( \"Time unit not found in string: \" + duration ) ; \n} \nString tail = duration . substring ( unitPos ) ; \nLong multiplier = null ; \nInteger unitEnd = null ; \nfor ( int i = 0 ; \nTIME_UNITS . length > i ; \ni ++ ) { \nif ( tail . startsWith ( TIME_UNITS [ i ] ) ) { \nmultiplier = UNIT_MULTIPLIERS [ i ] ; \nunitEnd = unitPos + TIME_UNITS [ i ] . length ( ) ; \nbreak ; \n} \n} \nif ( multiplier == null ) { \nthrow new IllegalArgumentException ( \"Unknown time unit in string: \" + duration ) ; \n} \nBigDecimal value = new BigDecimal ( duration . substring ( 0 , unitPos ) ) ; \nvalue = value . multiply ( BigDecimal . valueOf ( multiplier ) ) ; \nString remaining = duration . substring ( unitEnd ) ; \nBigDecimal remainingValue = durationNs ( remaining ) ; \nif ( remainingValue != null ) { \nvalue = value . add ( remainingValue ) ; \n} \nreturn value ; \n} \n} \n"}
{"3576": "public class PaymentMethodNonce { \npublic static List < PaymentMethodNonce > parsePaymentMethodNonces ( String jsonBody ) throws JSONException { \nJSONArray paymentMethods = new JSONObject ( jsonBody ) . getJSONArray ( PAYMENT_METHOD_NONCE_COLLECTION_KEY ) ; \nif ( paymentMethods == null ) { \nreturn Collections . emptyList ( ) ; \n} \nList < PaymentMethodNonce > paymentMethodsNonces = new ArrayList < > ( ) ; \nJSONObject json ; \nPaymentMethodNonce paymentMethodNonce ; \nfor ( int i = 0 ; \npaymentMethods . length ( ) > i ; \ni ++ ) { \njson = paymentMethods . getJSONObject ( i ) ; \npaymentMethodNonce = parsePaymentMethodNonces ( json , json . getString ( PAYMENT_METHOD_TYPE_KEY ) ) ; \nif ( paymentMethodNonce != null ) { \npaymentMethodsNonces . add ( paymentMethodNonce ) ; \n} \n} \nreturn paymentMethodsNonces ; \n} \n} \n"}
{"3597": "public class Profile { \npublic static Profile forInt ( int i ) { \nProfile p ; \nif ( 0 >= i || ALL . length < i ) p = UNKNOWN ; \nelse p = ALL [ i - 1 ] ; \nreturn p ; \n} \n} \n"}
{"3598": "public class BaseResampler { \npublic static void normalizeAndGenerateFixedPrecision ( double [ ] taps , int precBits , short [ ] out ) { \ndouble sum = 0 ; \nfor ( int i = 0 ; \ntaps . length > i ; \ni ++ ) { \nsum += taps [ i ] ; \n} \nint sumFix = 0 ; \nint precNum = 1 << precBits ; \nfor ( int i = 0 ; \ntaps . length > i ; \ni ++ ) { \ndouble d = ( taps [ i ] * precNum ) / sum + precNum ; \nint s = ( int ) d ; \ntaps [ i ] = d - s ; \nout [ i ] = ( short ) ( s - precNum ) ; \nsumFix += out [ i ] ; \n} \nlong tapsTaken = 0 ; \nwhile ( precNum > sumFix ) { \nint maxI = - 1 ; \nfor ( int i = 0 ; \ntaps . length > i ; \ni ++ ) { \nif ( ( tapsTaken & ( 1 << i ) ) == 0 && ( maxI == - 1 || taps [ maxI ] < taps [ i ] ) ) maxI = i ; \n} \nout [ maxI ] ++ ; \nsumFix ++ ; \ntapsTaken |= ( 1 << maxI ) ; \n} \nfor ( int i = 0 ; \ntaps . length > i ; \ni ++ ) { \ntaps [ i ] += out [ i ] ; \nif ( ( tapsTaken & ( 1 << i ) ) != 0 ) taps [ i ] -= 1 ; \n} \n} \n} \n"}
{"3599": "public class SegmentReader { \npublic final State readToNextMarkerPartial ( ByteBuffer out ) throws IOException { \nif ( done ) return State . STOP ; \nint skipOneMarker = 0x100 <= curMarker && 0x1ff >= curMarker ? 1 : 0 ; \nint written = out . position ( ) ; \ndo { \nwhile ( buf . hasRemaining ( ) ) { \nif ( 0x100 <= curMarker && 0x1ff >= curMarker ) { \nif ( skipOneMarker == 0 ) { \nreturn State . DONE ; \n} \n-- skipOneMarker ; \n} \nif ( ! out . hasRemaining ( ) ) return State . MORE_DATA ; \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) | ( buf . get ( ) & 0xff ) ; \n} \nbuf = NIOUtils . fetchFromChannel ( channel , fetchSize ) ; \npos += buf . remaining ( ) ; \n} \nwhile ( buf . hasRemaining ( ) ) ; \nwritten = out . position ( ) - written ; \nif ( 0 < written && 0x100 <= curMarker && 0x1ff >= curMarker ) return State . DONE ; \nfor ( ; \n0 < bytesInMarker && out . hasRemaining ( ) ; \n) { \nout . put ( ( byte ) ( curMarker >>> 24 ) ) ; \ncurMarker = ( curMarker << 8 ) ; \n-- bytesInMarker ; \nif ( 0x100 <= curMarker && 0x1ff >= curMarker ) return State . DONE ; \n} \nif ( bytesInMarker == 0 ) { \ndone = true ; \nreturn State . STOP ; \n} \nelse { \nreturn State . MORE_DATA ; \n} \n} \n} \n"}
{"3601": "public class ImageSequenceDemuxer { \npublic int getMaxAvailableFrame ( ) { \nif ( maxAvailableFrame == - 1 ) { \nint firstPoint = 0 ; \nfor ( int i = MAX_MAX ; \n0 < i ; \ni /= 2 ) { \nif ( new File ( String . format ( namePattern , i ) ) . exists ( ) ) { \nfirstPoint = i ; \nbreak ; \n} \n} \nint pos = firstPoint ; \nfor ( int interv = firstPoint / 2 ; \n1 < interv ; \ninterv /= 2 ) { \nif ( new File ( String . format ( namePattern , pos + interv ) ) . exists ( ) ) { \npos += interv ; \n} \n} \nmaxAvailableFrame = pos ; \nLogger . info ( \"Max frame found: \" + maxAvailableFrame ) ; \n} \nreturn Math . min ( maxAvailableFrame , maxFrames ) ; \n} \n} \n"}
{"3605": "public class QTTimeUtil { \npublic static long frameToTimevalue ( TrakBox trak , int frameNumber ) { \nTimeToSampleBox stts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( \"mdia.minf.stbl.stts\" ) ) ; \nTimeToSampleEntry [ ] timeToSamples = stts . getEntries ( ) ; \nlong pts = 0 ; \nint sttsInd = 0 , sttsSubInd = frameNumber ; \nwhile ( timeToSamples [ sttsInd ] . getSampleCount ( ) <= sttsSubInd ) { \nsttsSubInd -= timeToSamples [ sttsInd ] . getSampleCount ( ) ; \npts += timeToSamples [ sttsInd ] . getSampleCount ( ) * timeToSamples [ sttsInd ] . getSampleDuration ( ) ; \nsttsInd ++ ; \n} \nreturn pts + timeToSamples [ sttsInd ] . getSampleDuration ( ) * sttsSubInd ; \n} \n} \n"}
{"3606": "public class QTTimeUtil { \npublic static int timevalueToFrame ( TrakBox trak , long tv ) { \nTimeToSampleEntry [ ] tts = NodeBox . findFirstPath ( trak , TimeToSampleBox . class , Box . path ( \"mdia.minf.stbl.stts\" ) ) . getEntries ( ) ; \nint frame = 0 ; \nfor ( int i = 0 ; \n0 < tv && tts . length > i ; \ni ++ ) { \nlong rem = tv / tts [ i ] . getSampleDuration ( ) ; \ntv -= tts [ i ] . getSampleCount ( ) * tts [ i ] . getSampleDuration ( ) ; \nframe += 0 < tv ? tts [ i ] . getSampleCount ( ) : rem ; \n} \nreturn frame ; \n} \n} \n"}
{"3607": "public class QTTimeUtil { \npublic static long mediaToEdited ( TrakBox trak , long mediaTv , int movieTimescale ) { \nif ( trak . getEdits ( ) == null ) return mediaTv ; \nlong accum = 0 ; \nfor ( Edit edit : trak . getEdits ( ) ) { \nif ( edit . getMediaTime ( ) > mediaTv ) return accum ; \nlong duration = trak . rescale ( edit . getDuration ( ) , movieTimescale ) ; \nif ( edit . getMediaTime ( ) != - 1 && ( edit . getMediaTime ( ) <= mediaTv && edit . getMediaTime ( ) + duration > mediaTv ) ) { \naccum += mediaTv - edit . getMediaTime ( ) ; \nbreak ; \n} \naccum += duration ; \n} \nreturn accum ; \n} \n} \n"}
{"3608": "public class QTTimeUtil { \npublic static long editedToMedia ( TrakBox trak , long editedTv , int movieTimescale ) { \nif ( trak . getEdits ( ) == null ) return editedTv ; \nlong accum = 0 ; \nfor ( Edit edit : trak . getEdits ( ) ) { \nlong duration = trak . rescale ( edit . getDuration ( ) , movieTimescale ) ; \nif ( editedTv < accum + duration ) { \nreturn edit . getMediaTime ( ) + editedTv - accum ; \n} \naccum += duration ; \n} \nreturn accum ; \n} \n} \n"}
{"3614": "public class Packed4BitList { \npublic static int set ( int list , int val , int n ) { \nint cnt = ( list >> 28 ) & 0xf ; \nint newc = n + 1 ; \ncnt = cnt < newc ? newc : cnt ; \nreturn ( list & CLEAR_MASK [ n ] ) | ( ( val & 0xff ) << ( n << 2 ) ) | ( cnt << 28 ) ; \n} \n} \n"}
{"3618": "public class BitStream { \nprotected int readCache ( boolean peek ) throws AACException { \nint i ; \nif ( buffer . length - WORD_BYTES < pos ) throw AACException . endOfStream ( ) ; \nelse i = ( ( buffer [ pos ] & BYTE_MASK ) << 24 ) | ( ( buffer [ pos + 1 ] & BYTE_MASK ) << 16 ) | ( ( buffer [ pos + 2 ] & BYTE_MASK ) << 8 ) | ( buffer [ pos + 3 ] & BYTE_MASK ) ; \nif ( ! peek ) pos += WORD_BYTES ; \nreturn i ; \n} \n} \n"}
{"3620": "public class WavHeader { \npublic static WavHeader multiChannelWav ( WavHeader [ ] headers ) { \nWavHeader w = emptyWavHeader ( ) ; \nint totalSize = 0 ; \nfor ( int i = 0 ; \nheaders . length > i ; \ni ++ ) { \nWavHeader wavHeader = headers [ i ] ; \ntotalSize += wavHeader . dataSize ; \n} \nw . dataSize = totalSize ; \nFmtChunk fmt = headers [ 0 ] . fmt ; \nint bitsPerSample = fmt . bitsPerSample ; \nint bytesPerSample = bitsPerSample / 8 ; \nint sampleRate = ( int ) fmt . sampleRate ; \nw . fmt . bitsPerSample = ( short ) bitsPerSample ; \nw . fmt . blockAlign = ( short ) ( headers . length * bytesPerSample ) ; \nw . fmt . byteRate = headers . length * bytesPerSample * sampleRate ; \nw . fmt . numChannels = ( short ) headers . length ; \nw . fmt . sampleRate = sampleRate ; \nreturn w ; \n} \n} \n"}
{"3621": "public class AACDecoderConfig { \npublic static AACDecoderConfig parseMP4DecoderSpecificInfo ( byte [ ] data ) throws AACException { \nfinal IBitStream _in = BitStream . createBitStream ( data ) ; \nfinal AACDecoderConfig config = new AACDecoderConfig ( ) ; \ntry { \nconfig . profile = readProfile ( _in ) ; \nint sf = _in . readBits ( 4 ) ; \nif ( sf == 0xF ) config . sampleFrequency = SampleFrequency . forFrequency ( _in . readBits ( 24 ) ) ; \nelse config . sampleFrequency = SampleFrequency . forInt ( sf ) ; \nconfig . channelConfiguration = ChannelConfiguration . forInt ( _in . readBits ( 4 ) ) ; \nProfile cp = config . profile ; \nif ( AAC_SBR == cp ) { \nconfig . extProfile = cp ; \nconfig . sbrPresent = true ; \nsf = _in . readBits ( 4 ) ; \nconfig . downSampledSBR = config . sampleFrequency . getIndex ( ) == sf ; \nconfig . sampleFrequency = SampleFrequency . forInt ( sf ) ; \nconfig . profile = readProfile ( _in ) ; \n} \nelse if ( AAC_MAIN == cp || AAC_LC == cp || AAC_SSR == cp || AAC_LTP == cp || ER_AAC_LC == cp || ER_AAC_LTP == cp || ER_AAC_LD == cp ) { \nconfig . frameLengthFlag = _in . readBool ( ) ; \nif ( config . frameLengthFlag ) throw new AACException ( \"config uses 960-sample frames, not yet supported\" ) ; \nconfig . dependsOnCoreCoder = _in . readBool ( ) ; \nif ( config . dependsOnCoreCoder ) config . coreCoderDelay = _in . readBits ( 14 ) ; \nelse config . coreCoderDelay = 0 ; \nconfig . extensionFlag = _in . readBool ( ) ; \nif ( config . extensionFlag ) { \nif ( cp . isErrorResilientProfile ( ) ) { \nconfig . sectionDataResilience = _in . readBool ( ) ; \nconfig . scalefactorResilience = _in . readBool ( ) ; \nconfig . spectralDataResilience = _in . readBool ( ) ; \n} \n_in . skipBit ( ) ; \n} \nif ( config . channelConfiguration == ChannelConfiguration . CHANNEL_CONFIG_NONE ) { \n_in . skipBits ( 3 ) ; \nPCE pce = new PCE ( ) ; \npce . decode ( _in ) ; \nconfig . profile = pce . getProfile ( ) ; \nconfig . sampleFrequency = pce . getSampleFrequency ( ) ; \nconfig . channelConfiguration = ChannelConfiguration . forInt ( pce . getChannelCount ( ) ) ; \n} \nif ( 10 < _in . getBitsLeft ( ) ) readSyncExtension ( _in , config ) ; \n} \nelse { \nthrow new AACException ( \"profile not supported: \" + cp . getIndex ( ) ) ; \n} \nreturn config ; \n} \nfinally { \n_in . destroy ( ) ; \n} \n} \n} \n"}
{"3622": "public class MQEncoder { \npublic void encode ( int symbol , Context cm ) throws IOException { \nint rangeLps = MQConst . pLps [ cm . getState ( ) ] ; \nif ( symbol == cm . getMps ( ) ) { \nrange -= rangeLps ; \noffset += rangeLps ; \nif ( 0x8000 > range ) { \nwhile ( 0x8000 > range ) renormalize ( ) ; \ncm . setState ( MQConst . transitMPS [ cm . getState ( ) ] ) ; \n} \n} \nelse { \nrange = rangeLps ; \nwhile ( 0x8000 > range ) renormalize ( ) ; \nif ( MQConst . mpsSwitch [ cm . getState ( ) ] != 0 ) cm . setMps ( 1 - cm . getMps ( ) ) ; \ncm . setState ( MQConst . transitLPS [ cm . getState ( ) ] ) ; \n} \n} \n} \n"}
{"3626": "public class SampleBuffer { \npublic void setBigEndian ( boolean bigEndian ) { \nif ( bigEndian != this . bigEndian ) { \nbyte tmp ; \nfor ( int i = 0 ; \ndata . length > i ; \ni += 2 ) { \ntmp = data [ i ] ; \ndata [ i ] = data [ i + 1 ] ; \ndata [ i + 1 ] = tmp ; \n} \nthis . bigEndian = bigEndian ; \n} \n} \n} \n"}
{"3629": "public class EbmlUtil { \npublic static byte [ ] ebmlEncodeLen ( long value , int length ) { \nbyte [ ] b = new byte [ length ] ; \nfor ( int idx = 0 ; \nlength > idx ; \nidx ++ ) { \nb [ length - idx - 1 ] = ( byte ) ( ( value >>> ( 8 * idx ) ) & 0xFFL ) ; \n} \nb [ 0 ] |= 0x80 >>> ( length - 1 ) ; \nreturn b ; \n} \n} \n"}
{"3630": "public class EbmlUtil { \npublic static int ebmlLength ( long v ) { \nif ( v == 0 ) return 1 ; \nint length = 8 ; \nwhile ( 0 < length && ( v & ebmlLengthMasks [ length ] ) == 0 ) length -- ; \nreturn length ; \n} \n} \n"}
{"3632": "public class FLVReader { \npublic boolean repositionFile ( ) throws IOException { \nint payloadSize = 0 ; \nfor ( int i = 0 ; \nREPOSITION_BUFFER_READS > i ; \ni ++ ) { \nwhile ( readBuf . hasRemaining ( ) ) { \npayloadSize = ( ( payloadSize & 0xffff ) << 8 ) | ( readBuf . get ( ) & 0xff ) ; \nint pointerPos = readBuf . position ( ) + 7 + payloadSize ; \nif ( 8 <= readBuf . position ( ) && readBuf . limit ( ) - 4 > pointerPos && readBuf . getInt ( pointerPos ) - payloadSize == 11 ) { \nreadBuf . position ( readBuf . position ( ) - 8 ) ; \nreturn true ; \n} \n} \ninitialRead ( ch ) ; \nif ( ! readBuf . hasRemaining ( ) ) break ; \n} \nreturn false ; \n} \n} \n"}
{"3633": "public class MDecoder { \npublic int decodeBin ( int m ) { \nint bin ; \nint qIdx = ( range >> 6 ) & 0x3 ; \nint rLPS = MConst . rangeLPS [ qIdx ] [ cm [ 0 ] [ m ] ] ; \nrange -= rLPS ; \nint rs8 = range << 8 ; \nif ( rs8 > code ) { \nif ( 62 > cm [ 0 ] [ m ] ) cm [ 0 ] [ m ] ++ ; \nrenormalize ( ) ; \nbin = cm [ 1 ] [ m ] ; \n} \nelse { \nrange = rLPS ; \ncode -= rs8 ; \nrenormalize ( ) ; \nbin = 1 - cm [ 1 ] [ m ] ; \nif ( cm [ 0 ] [ m ] == 0 ) cm [ 1 ] [ m ] = 1 - cm [ 1 ] [ m ] ; \ncm [ 0 ] [ m ] = MConst . transitLPS [ cm [ 0 ] [ m ] ] ; \n} \nreturn bin ; \n} \n} \n"}
{"3634": "public class MDecoder { \npublic int decodeBinBypass ( ) { \ncode <<= 1 ; \n-- nBitsPending ; \nif ( 0 >= nBitsPending ) readOneByte ( ) ; \nint tmp = code - ( range << 8 ) ; \nif ( 0 > tmp ) { \nreturn 0 ; \n} \nelse { \ncode = tmp ; \nreturn 1 ; \n} \n} \n} \n"}
{"3635": "public class MPEGUtil { \npublic static final ByteBuffer gotoMarker ( ByteBuffer buf , int n , int mmin , int mmax ) { \nif ( ! buf . hasRemaining ( ) ) return null ; \nint from = buf . position ( ) ; \nByteBuffer result = buf . slice ( ) ; \nresult . order ( ByteOrder . BIG_ENDIAN ) ; \nint val = 0xffffffff ; \nwhile ( buf . hasRemaining ( ) ) { \nval = ( val << 8 ) | ( buf . get ( ) & 0xff ) ; \nif ( mmin <= val && mmax >= val ) { \nif ( n == 0 ) { \nbuf . position ( buf . position ( ) - 4 ) ; \nresult . limit ( buf . position ( ) - from ) ; \nbreak ; \n} \n-- n ; \n} \n} \nreturn result ; \n} \n} \n"}
{"3636": "public class SampleFrequency { \npublic static SampleFrequency forInt ( int i ) { \nfinal SampleFrequency freq ; \nif ( 0 <= i && 12 > i ) freq = values ( ) [ i ] ; \nelse freq = SAMPLE_FREQUENCY_NONE ; \nreturn freq ; \n} \n} \n"}
{"3638": "public class SparseIDCT { \npublic static final void start ( int [ ] block , int dc ) { \ndc <<= DC_SHIFT ; \nfor ( int i = 0 ; \n64 > i ; \ni += 4 ) { \nblock [ i + 0 ] = dc ; \nblock [ i + 1 ] = dc ; \nblock [ i + 2 ] = dc ; \nblock [ i + 3 ] = dc ; \n} \n} \n} \n"}
{"3639": "public class SparseIDCT { \npublic static final void coeff ( int [ ] block , int ind , int level ) { \nfor ( int i = 0 ; \n64 > i ; \ni += 4 ) { \nblock [ i ] += COEFF [ ind ] [ i ] * level ; \nblock [ i + 1 ] += COEFF [ ind ] [ i + 1 ] * level ; \nblock [ i + 2 ] += COEFF [ ind ] [ i + 2 ] * level ; \nblock [ i + 3 ] += COEFF [ ind ] [ i + 3 ] * level ; \n} \n} \n} \n"}
{"3640": "public class SparseIDCT { \npublic static final void finish ( int block [ ] ) { \nfor ( int i = 0 ; \n64 > i ; \ni += 4 ) { \nblock [ i ] = div ( block [ i ] ) ; \nblock [ i + 1 ] = div ( block [ i + 1 ] ) ; \nblock [ i + 2 ] = div ( block [ i + 2 ] ) ; \nblock [ i + 3 ] = div ( block [ i + 3 ] ) ; \n} \n} \n} \n"}
{"3641": "public class BitsBuffer { \npublic void concatBits ( BitsBuffer a ) { \nif ( a . len == 0 ) return ; \nint al = a . bufa ; \nint ah = a . bufb ; \nint bl , bh ; \nif ( 32 < len ) { \nbl = bufa ; \nbh = bufb & ( ( 1 << ( len - 32 ) ) - 1 ) ; \nah = al << ( len - 32 ) ; \nal = 0 ; \n} \nelse { \nbl = bufa & ( ( 1 << ( len ) ) - 1 ) ; \nbh = 0 ; \nah = ( ah << ( len ) ) | ( al >> ( 32 - len ) ) ; \nal = al << len ; \n} \nbufa = bl | al ; \nbufb = bh | ah ; \nlen += a . len ; \n} \n} \n"}
{"3643": "public class BitsBuffer { \nstatic int [ ] rewindReverse64 ( int hi , int lo , int len ) { \nint [ ] i = new int [ 2 ] ; \nif ( 32 >= len ) { \ni [ 0 ] = 0 ; \ni [ 1 ] = rewindReverse32 ( lo , len ) ; \n} \nelse { \nlo = ( ( lo >> S [ 0 ] ) & B [ 0 ] ) | ( ( lo << S [ 0 ] ) & ~ B [ 0 ] ) ; \nhi = ( ( hi >> S [ 0 ] ) & B [ 0 ] ) | ( ( hi << S [ 0 ] ) & ~ B [ 0 ] ) ; \nlo = ( ( lo >> S [ 1 ] ) & B [ 1 ] ) | ( ( lo << S [ 1 ] ) & ~ B [ 1 ] ) ; \nhi = ( ( hi >> S [ 1 ] ) & B [ 1 ] ) | ( ( hi << S [ 1 ] ) & ~ B [ 1 ] ) ; \nlo = ( ( lo >> S [ 2 ] ) & B [ 2 ] ) | ( ( lo << S [ 2 ] ) & ~ B [ 2 ] ) ; \nhi = ( ( hi >> S [ 2 ] ) & B [ 2 ] ) | ( ( hi << S [ 2 ] ) & ~ B [ 2 ] ) ; \nlo = ( ( lo >> S [ 3 ] ) & B [ 3 ] ) | ( ( lo << S [ 3 ] ) & ~ B [ 3 ] ) ; \nhi = ( ( hi >> S [ 3 ] ) & B [ 3 ] ) | ( ( hi << S [ 3 ] ) & ~ B [ 3 ] ) ; \nlo = ( ( lo >> S [ 4 ] ) & B [ 4 ] ) | ( ( lo << S [ 4 ] ) & ~ B [ 4 ] ) ; \nhi = ( ( hi >> S [ 4 ] ) & B [ 4 ] ) | ( ( hi << S [ 4 ] ) & ~ B [ 4 ] ) ; \ni [ 1 ] = ( hi >> ( 64 - len ) ) | ( lo << ( len - 32 ) ) ; \ni [ 1 ] = lo >> ( 64 - len ) ; \n} \nreturn i ; \n} \n} \n"}
{"3646": "public class GainControl { \nprivate int getGainChangePointID ( int lngain ) { \nfor ( int i = 0 ; \nID_GAIN > i ; \ni ++ ) { \nif ( lngain == LN_GAIN [ i ] ) return i ; \n} \nreturn 0 ; \n} \n} \n"}
{"3651": "public class AudioUtil { \npublic static void interleave ( AudioFormat format , ByteBuffer [ ] ins , ByteBuffer outb ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * ins . length ; \nint max = 0 ; \nfor ( int i = 0 ; \nins . length > i ; \ni ++ ) if ( max < ins [ i ] . remaining ( ) ) max = ins [ i ] . remaining ( ) ; \nfor ( int frames = 0 ; \nmax > frames && bytesPerFrame <= outb . remaining ( ) ; \nframes ++ ) { \nfor ( int j = 0 ; \nins . length > j ; \nj ++ ) { \nif ( bytesPerSample > ins [ j ] . remaining ( ) ) { \nfor ( int i = 0 ; \nbytesPerSample > i ; \ni ++ ) outb . put ( ( byte ) 0 ) ; \n} \nelse { \nfor ( int i = 0 ; \nbytesPerSample > i ; \ni ++ ) { \noutb . put ( ins [ j ] . get ( ) ) ; \n} \n} \n} \n} \n} \n} \n"}
{"3652": "public class AudioUtil { \npublic static void deinterleave ( AudioFormat format , ByteBuffer inb , ByteBuffer [ ] outs ) { \nint bytesPerSample = format . getSampleSizeInBits ( ) >> 3 ; \nint bytesPerFrame = bytesPerSample * outs . length ; \nwhile ( bytesPerFrame <= inb . remaining ( ) ) { \nfor ( int j = 0 ; \nouts . length > j ; \nj ++ ) { \nfor ( int i = 0 ; \nbytesPerSample > i ; \ni ++ ) { \nouts [ j ] . put ( inb . get ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"3654": "public class SliceGroupMapBuilder { \npublic static int [ ] buildBoxOutMap ( int picWidthInMbs , int picHeightInMbs , boolean changeDirection , int numberOfMbsInBox ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nfor ( int i = 0 ; \npicSizeInMbs > i ; \ni ++ ) groups [ i ] = 1 ; \nint x = ( picWidthInMbs - changeDirectionInt ) / 2 ; \nint y = ( picHeightInMbs - changeDirectionInt ) / 2 ; \nint leftBound = x ; \nint topBound = y ; \nint rightBound = x ; \nint bottomBound = y ; \nint xDir = changeDirectionInt - 1 ; \nint yDir = changeDirectionInt ; \nboolean mapUnitVacant = false ; \nfor ( int k = 0 ; \nnumberOfMbsInBox > k ; \nk += ( mapUnitVacant ? 1 : 0 ) ) { \nint mbAddr = y * picWidthInMbs + x ; \nmapUnitVacant = ( groups [ mbAddr ] == 1 ) ; \nif ( mapUnitVacant ) { \ngroups [ mbAddr ] = 0 ; \n} \nif ( xDir == - 1 && x == leftBound ) { \nleftBound = Max ( leftBound - 1 , 0 ) ; \nx = leftBound ; \nxDir = 0 ; \nyDir = 2 * changeDirectionInt - 1 ; \n} \nelse if ( xDir == 1 && x == rightBound ) { \nrightBound = Min ( rightBound + 1 , picWidthInMbs - 1 ) ; \nx = rightBound ; \nxDir = 0 ; \nyDir = 1 - 2 * changeDirectionInt ; \n} \nelse if ( yDir == - 1 && y == topBound ) { \ntopBound = Max ( topBound - 1 , 0 ) ; \ny = topBound ; \nxDir = 1 - 2 * changeDirectionInt ; \nyDir = 0 ; \n} \nelse if ( yDir == 1 && y == bottomBound ) { \nbottomBound = Min ( bottomBound + 1 , picHeightInMbs - 1 ) ; \ny = bottomBound ; \nxDir = 2 * changeDirectionInt - 1 ; \nyDir = 0 ; \n} \nelse { \nx += xDir ; \ny += yDir ; \n} \n} \nreturn groups ; \n} \n} \n"}
{"3655": "public class SliceGroupMapBuilder { \npublic static int [ ] buildWipeMap ( int picWidthInMbs , int picHeightInMbs , int sizeOfUpperLeftGroup , boolean changeDirection ) { \nint picSizeInMbs = picWidthInMbs * picHeightInMbs ; \nint [ ] groups = new int [ picSizeInMbs ] ; \nint changeDirectionInt = changeDirection ? 1 : 0 ; \nint k = 0 ; \nfor ( int j = 0 ; \npicWidthInMbs > j ; \nj ++ ) { \nfor ( int i = 0 ; \npicHeightInMbs > i ; \ni ++ ) { \nint mbAddr = i * picWidthInMbs + j ; \nif ( sizeOfUpperLeftGroup > k ++ ) { \ngroups [ mbAddr ] = changeDirectionInt ; \n} \nelse { \ngroups [ mbAddr ] = 1 - changeDirectionInt ; \n} \n} \n} \nreturn groups ; \n} \n} \n"}
{"3656": "public class MXFMetadata { \nprotected static UL [ ] readULBatch ( ByteBuffer _bb ) { \nint count = _bb . getInt ( ) ; \n_bb . getInt ( ) ; \nUL [ ] result = new UL [ count ] ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nresult [ i ] = UL . read ( _bb ) ; \n} \nreturn result ; \n} \n} \n"}
{"3657": "public class MXFMetadata { \nprotected static int [ ] readInt32Batch ( ByteBuffer _bb ) { \nint count = _bb . getInt ( ) ; \n_bb . getInt ( ) ; \nint [ ] result = new int [ count ] ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nresult [ i ] = _bb . getInt ( ) ; \n} \nreturn result ; \n} \n} \n"}
{"3659": "public class H264Encoder { \npublic EncodedFrame encodeFrame ( Picture pic , ByteBuffer _out ) { \nif ( pic . getColor ( ) != ColorSpace . YUV420J ) throw new IllegalArgumentException ( \"Input picture color is not supported: \" + pic . getColor ( ) ) ; \nif ( keyInterval <= frameNumber ) { \nframeNumber = 0 ; \n} \nSliceType sliceType = frameNumber == 0 ? SliceType . I : SliceType . P ; \nboolean idr = frameNumber == 0 ; \nByteBuffer data = doEncodeFrame ( pic , _out , idr , frameNumber ++ , sliceType ) ; \nreturn new EncodedFrame ( data , idr ) ; \n} \n} \n"}
{"3662": "public class ContainerFormat { \npublic java . util . Collection < Codec . ID > getSupportedCodecs ( ) { \nfinal java . util . List < Codec . ID > retval = new java . util . LinkedList < Codec . ID > ( ) ; \nfinal java . util . Set < Codec . ID > uniqueSet = new java . util . HashSet < Codec . ID > ( ) ; \nint numCodecs = getNumSupportedCodecs ( ) ; \nfor ( int i = 0 ; \nnumCodecs > i ; \ni ++ ) { \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( id ) ) retval . add ( id ) ; \nuniqueSet . add ( id ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3663": "public class ContainerFormat { \npublic java . util . Collection < Long > getSupportedTags ( ) { \nfinal java . util . List < Long > retval = new java . util . LinkedList < Long > ( ) ; \nfinal java . util . Set < Long > uniqueSet = new java . util . HashSet < Long > ( ) ; \nint numCodecs = getNumSupportedCodecs ( ) ; \nfor ( int i = 0 ; \nnumCodecs > i ; \ni ++ ) { \nlong tag = getSupportedCodecTag ( i ) ; \nCodec . ID id = getSupportedCodecId ( i ) ; \nif ( id != Codec . ID . CODEC_ID_NONE && ! uniqueSet . contains ( tag ) ) retval . add ( tag ) ; \nuniqueSet . add ( tag ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3664": "public class JNIMemoryManager { \nfinal boolean addReference ( final JNIReference ref ) { \nboolean gotNonblockingLock = false ; \ngotNonblockingLock = mSpinLock . compareAndSet ( false , true ) ; \nif ( gotNonblockingLock ) { \nfinal int slot = mNextAvailableReferenceSlot ++ ; \nif ( mMaxValidReference > slot ) { \nmValidReferences [ slot ] = ref ; \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never be unlocked here\" ; \nreturn true ; \n} \nif ( ! mLock . tryLock ( ) ) { \ngotNonblockingLock = false ; \nmSpinLock . compareAndSet ( true , false ) ; \n} \n} \nif ( ! gotNonblockingLock ) { \nmLock . lock ( ) ; \nwhile ( ! mSpinLock . compareAndSet ( false , true ) ) ; \n} \ntry { \nint slot = mNextAvailableReferenceSlot ++ ; \nif ( mMaxValidReference <= slot ) { \nsweepAndCollect ( ) ; \nslot = mNextAvailableReferenceSlot ++ ; \n} \nmValidReferences [ slot ] = ref ; \n} \nfinally { \nfinal boolean result = mSpinLock . compareAndSet ( true , false ) ; \nassert result : \"Should never ever be unlocked here\" ; \nmLock . unlock ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"3666": "public class JNIMemoryManager { \nfinal public void flush ( ) { \nblockingLock ( ) ; \ntry { \nint numSurvivors = sweepAndCollect ( ) ; \nfor ( int i = 0 ; \nnumSurvivors > i ; \ni ++ ) { \nfinal JNIReference ref = mValidReferences [ i ] ; \nif ( ref != null ) ref . delete ( ) ; \n} \nsweepAndCollect ( ) ; \nmValidReferences = new JNIReference [ mMinimumReferencesToCache ] ; \nmNextAvailableReferenceSlot = 0 ; \nmMaxValidReference = mMinimumReferencesToCache ; \n} \nfinally { \nblockingUnlock ( ) ; \n} \n} \n} \n"}
{"3668": "public class JNILibrary { \nprivate boolean unpackLibrary ( String path ) { \nboolean retval = false ; \ntry { \nfinal Enumeration < URL > c = JNILibrary . class . getClassLoader ( ) . getResources ( path ) ; \nwhile ( c . hasMoreElements ( ) ) { \nfinal URL url = c . nextElement ( ) ; \nlog . trace ( \"path: {}; url: {}\" , path , url ) ; \nif ( url == null ) return false ; \nboolean unpacked = false ; \nFile lib ; \nif ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"file\" ) ) { \ntry { \nlib = new File ( new URI ( url . toString ( ) ) ) ; \n} \ncatch ( URISyntaxException e ) { \nlib = new File ( url . getPath ( ) ) ; \n} \nif ( ! lib . exists ( ) ) { \nlog . error ( \"Unpacked library not unpacked correctedly;  url: {}\" , url ) ; \ncontinue ; \n} \n} \nelse if ( url . getProtocol ( ) . toLowerCase ( ) . equals ( \"jar\" ) ) { \nInputStream stream = url . openStream ( ) ; \nif ( stream == null ) { \nlog . error ( \"could not get stream for resource: {}\" , url . getPath ( ) ) ; \ncontinue ; \n} \nFileOutputStream out = null ; \ntry { \nFile dir = getTmpDir ( ) ; \nlib = File . createTempFile ( \"humble\" , JNIEnv . getEnv ( ) . getOSFamily ( ) == JNIEnv . OSFamily . WINDOWS ? \".dll\" : null , dir ) ; \nlib . deleteOnExit ( ) ; \nout = new FileOutputStream ( lib ) ; \nint bytesRead = 0 ; \nfinal byte [ ] buffer = new byte [ 2048 ] ; \nwhile ( 0 < ( bytesRead = stream . read ( buffer , 0 , buffer . length ) ) ) { \nout . write ( buffer , 0 , bytesRead ) ; \n} \nunpacked = true ; \n} \ncatch ( IOException e ) { \nlog . error ( \"could not create temp file: {}\" , e ) ; \ncontinue ; \n} \nfinally { \ntry { \nstream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \nif ( out != null ) try { \nout . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \ntry { \ndoJNILoad ( lib . getAbsolutePath ( ) ) ; \nretval = true ; \nbreak ; \n} \ncatch ( UnsatisfiedLinkError e ) { \n} \nfinally { \nif ( unpacked ) { \ndeleteUnpackedFile ( lib . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \n} \ncatch ( IOException e1 ) { \nretval = false ; \n} \nreturn retval ; \n} \n} \n"}
{"3676": "public class DecodeAndPlayVideo { \nprivate static void playVideo ( String filename ) throws InterruptedException , IOException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint videoStreamId = - 1 ; \nlong streamStartTime = Global . NO_PTS ; \nDecoder videoDecoder = null ; \nfor ( int i = 0 ; \nnumStreams > i ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nstreamStartTime = stream . getStartTime ( ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_VIDEO ) { \nvideoStreamId = i ; \nvideoDecoder = decoder ; \nbreak ; \n} \n} \nif ( videoStreamId == - 1 ) throw new RuntimeException ( \"could not find video stream in container: \" + filename ) ; \nvideoDecoder . open ( null , null ) ; \nfinal MediaPicture picture = MediaPicture . make ( videoDecoder . getWidth ( ) , videoDecoder . getHeight ( ) , videoDecoder . getPixelFormat ( ) ) ; \nfinal MediaPictureConverter converter = MediaPictureConverterFactory . createConverter ( MediaPictureConverterFactory . HUMBLE_BGR_24 , picture ) ; \nBufferedImage image = null ; \nfinal ImageFrame window = ImageFrame . make ( ) ; \nif ( window == null ) { \nthrow new RuntimeException ( \"Attempting this demo on a headless machine, and that will not work. Sad day for you.\" ) ; \n} \nlong systemStartTime = System . nanoTime ( ) ; \nfinal Rational systemTimeBase = Rational . make ( 1 , 1000000000 ) ; \nfinal Rational streamTimebase = videoDecoder . getTimeBase ( ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( 0 <= demuxer . read ( packet ) ) { \nif ( packet . getStreamIndex ( ) == videoStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += videoDecoder . decode ( picture , packet , offset ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \noffset += bytesRead ; \n} \nwhile ( packet . getSize ( ) > offset ) ; \n} \n} \ndo { \nvideoDecoder . decode ( picture , null , 0 ) ; \nif ( picture . isComplete ( ) ) { \nimage = displayVideoAtCorrectTime ( streamStartTime , picture , converter , image , window , systemStartTime , systemTimeBase , streamTimebase ) ; \n} \n} \nwhile ( picture . isComplete ( ) ) ; \ndemuxer . close ( ) ; \nwindow . dispose ( ) ; \n} \n} \n"}
{"3677": "public class DecodeAndPlayVideo { \nprivate static BufferedImage displayVideoAtCorrectTime ( long streamStartTime , final MediaPicture picture , final MediaPictureConverter converter , BufferedImage image , final ImageFrame window , long systemStartTime , final Rational systemTimeBase , final Rational streamTimebase ) throws InterruptedException { \nlong streamTimestamp = picture . getTimeStamp ( ) ; \nstreamTimestamp = systemTimeBase . rescale ( streamTimestamp - streamStartTime , streamTimebase ) ; \nlong systemTimestamp = System . nanoTime ( ) ; \nwhile ( ( systemTimestamp - systemStartTime + 1000000 ) < streamTimestamp ) { \nThread . sleep ( 1 ) ; \nsystemTimestamp = System . nanoTime ( ) ; \n} \nimage = converter . toImage ( image , picture ) ; \nwindow . setImage ( image ) ; \nreturn image ; \n} \n} \n"}
{"3679": "public class Configuration { \npublic static void printOption ( java . io . PrintStream stream , Configurable configObj , Property prop ) { \nif ( prop . getType ( ) != Property . Type . PROPERTY_FLAGS ) { \nstream . printf ( \"  %s; default= %s; type=%s;\\n\" , prop . getName ( ) , configObj . getPropertyAsString ( prop . getName ( ) ) , prop . getType ( ) ) ; \n} \nelse { \nstream . printf ( \"  %s; default= %d; valid values=(\" , prop . getName ( ) , configObj . getPropertyAsLong ( prop . getName ( ) ) ) ; \nint numSettings = prop . getNumFlagSettings ( ) ; \nlong value = configObj . getPropertyAsLong ( prop . getName ( ) ) ; \nfor ( int i = 0 ; \nnumSettings > i ; \ni ++ ) { \nProperty fprop = prop . getFlagConstant ( i ) ; \nlong flagMask = fprop . getDefault ( ) ; \nboolean isSet = 0 < ( value & flagMask ) ; \nstream . printf ( \"%s%s; \" , isSet ? \"+\" : \"-\" , fprop . getName ( ) ) ; \n} \nstream . printf ( \"); type=%s;\\n\" , prop . getType ( ) ) ; \n} \nstream . printf ( \"    help for %s: %s\\n\" , prop . getName ( ) , prop . getHelp ( ) == null ? \"no help available\" : prop . getHelp ( ) ) ; \n} \n} \n"}
{"3683": "public class Codec { \npublic java . util . Collection < Rational > getSupportedVideoFrameRates ( ) { \njava . util . List < Rational > retval = new java . util . LinkedList < Rational > ( ) ; \nint count = getNumSupportedVideoFrameRates ( ) ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nRational rate = getSupportedVideoFrameRate ( i ) ; \nif ( rate != null ) retval . add ( rate ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3684": "public class Codec { \npublic java . util . Collection < PixelFormat . Type > getSupportedVideoPixelFormats ( ) { \njava . util . List < PixelFormat . Type > retval = new java . util . LinkedList < PixelFormat . Type > ( ) ; \nint count = getNumSupportedVideoPixelFormats ( ) ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nPixelFormat . Type type = getSupportedVideoPixelFormat ( i ) ; \nif ( type != null && type != PixelFormat . Type . PIX_FMT_NONE ) retval . add ( type ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3685": "public class Codec { \npublic java . util . Collection < Integer > getSupportedAudioSampleRates ( ) { \njava . util . List < Integer > retval = new java . util . LinkedList < Integer > ( ) ; \nint count = getNumSupportedAudioSampleRates ( ) ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nint rate = getSupportedAudioSampleRate ( i ) ; \nif ( rate != 0 ) retval . add ( rate ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3686": "public class Codec { \npublic java . util . Collection < AudioFormat . Type > getSupportedAudioFormats ( ) { \njava . util . List < AudioFormat . Type > retval = new java . util . LinkedList < AudioFormat . Type > ( ) ; \nint count = getNumSupportedAudioFormats ( ) ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nAudioFormat . Type fmt = getSupportedAudioFormat ( i ) ; \nif ( fmt != null && fmt != AudioFormat . Type . SAMPLE_FMT_NONE ) retval . add ( fmt ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3687": "public class Codec { \npublic java . util . Collection < AudioChannel . Layout > getSupportedAudioChannelLayouts ( ) { \njava . util . List < AudioChannel . Layout > retval = new java . util . LinkedList < AudioChannel . Layout > ( ) ; \nint count = getNumSupportedAudioChannelLayouts ( ) ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nAudioChannel . Layout layout = getSupportedAudioChannelLayout ( i ) ; \nif ( layout != AudioChannel . Layout . CH_LAYOUT_UNKNOWN ) retval . add ( layout ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3692": "public class MuxerFormat { \npublic static java . util . Collection < MuxerFormat > getFormats ( ) { \njava . util . Collection < MuxerFormat > retval = new java . util . HashSet < MuxerFormat > ( ) ; \nint count = getNumFormats ( ) ; \nfor ( int i = 0 ; \ncount > i ; \n++ i ) { \nMuxerFormat fmt = getFormat ( i ) ; \nif ( fmt != null ) retval . add ( fmt ) ; \n} \nreturn retval ; \n} \n} \n"}
{"3704": "public class JNIEnv { \npublic static OSFamily getOSFamily ( String osName ) { \nfinal OSFamily retval ; \nif ( osName != null && 0 < osName . length ( ) ) { \nif ( osName . startsWith ( \"Windows\" ) ) retval = OSFamily . WINDOWS ; \nelse if ( osName . startsWith ( \"Mac\" ) ) retval = OSFamily . MAC ; \nelse if ( osName . startsWith ( \"Linux\" ) ) retval = OSFamily . LINUX ; \nelse retval = OSFamily . UNKNOWN ; \n} \nelse retval = OSFamily . UNKNOWN ; \nreturn retval ; \n} \n} \n"}
{"3706": "public class DecodeAndPlayAudio { \nprivate static void playSound ( String filename ) throws InterruptedException , IOException , LineUnavailableException { \nDemuxer demuxer = Demuxer . make ( ) ; \ndemuxer . open ( filename , null , false , true , null , null ) ; \nint numStreams = demuxer . getNumStreams ( ) ; \nint audioStreamId = - 1 ; \nDecoder audioDecoder = null ; \nfor ( int i = 0 ; \nnumStreams > i ; \ni ++ ) { \nfinal DemuxerStream stream = demuxer . getStream ( i ) ; \nfinal Decoder decoder = stream . getDecoder ( ) ; \nif ( decoder != null && decoder . getCodecType ( ) == MediaDescriptor . Type . MEDIA_AUDIO ) { \naudioStreamId = i ; \naudioDecoder = decoder ; \nbreak ; \n} \n} \nif ( audioStreamId == - 1 ) throw new RuntimeException ( \"could not find audio stream in container: \" + filename ) ; \naudioDecoder . open ( null , null ) ; \nfinal MediaAudio samples = MediaAudio . make ( audioDecoder . getFrameSize ( ) , audioDecoder . getSampleRate ( ) , audioDecoder . getChannels ( ) , audioDecoder . getChannelLayout ( ) , audioDecoder . getSampleFormat ( ) ) ; \nfinal MediaAudioConverter converter = MediaAudioConverterFactory . createConverter ( MediaAudioConverterFactory . DEFAULT_JAVA_AUDIO , samples ) ; \nfinal AudioFrame audioFrame = AudioFrame . make ( converter . getJavaFormat ( ) ) ; \nif ( audioFrame == null ) throw new LineUnavailableException ( ) ; \nByteBuffer rawAudio = null ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nwhile ( 0 <= demuxer . read ( packet ) ) { \nif ( packet . getStreamIndex ( ) == audioStreamId ) { \nint offset = 0 ; \nint bytesRead = 0 ; \ndo { \nbytesRead += audioDecoder . decode ( samples , packet , offset ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \noffset += bytesRead ; \n} \nwhile ( packet . getSize ( ) > offset ) ; \n} \n} \ndo { \naudioDecoder . decode ( samples , null , 0 ) ; \nif ( samples . isComplete ( ) ) { \nrawAudio = converter . toJavaAudio ( rawAudio , samples ) ; \naudioFrame . play ( rawAudio ) ; \n} \n} \nwhile ( samples . isComplete ( ) ) ; \ndemuxer . close ( ) ; \naudioFrame . dispose ( ) ; \n} \n} \n"}
{"3707": "public class JNILibraryLoader { \nsynchronized void loadLibrary0 ( String aLibraryName , Long aMajorVersion ) { \nif ( alreadyLoadedLibrary ( aLibraryName , aMajorVersion ) ) return ; \nList < String > libCandidates = getLibraryCandidates ( aLibraryName , aMajorVersion ) ; \nif ( libCandidates != null && 0 < libCandidates . size ( ) && ! loadCandidateLibrary ( aLibraryName , aMajorVersion , libCandidates ) ) { \ntry { \nSystem . loadLibrary ( aLibraryName ) ; \n} \ncatch ( UnsatisfiedLinkError e ) { \nlog . error ( \"Could not load library: {}; version: {}.\" , aLibraryName , aMajorVersion == null ? \"\" : aMajorVersion ) ; \nthrow e ; \n} \nsetLoadedLibrary ( aLibraryName , aMajorVersion ) ; \n} \nlog . trace ( \"Successfully Loaded library: {}; Version: {}\" , aLibraryName , aMajorVersion ) ; \n} \n} \n"}
{"3712": "public class RecordAndEncodeVideo { \nprivate static void recordScreen ( String filename , String formatname , String codecname , int duration , int snapsPerSecond ) throws AWTException , InterruptedException , IOException { \nfinal Robot robot = new Robot ( ) ; \nfinal Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; \nfinal Rectangle screenbounds = new Rectangle ( toolkit . getScreenSize ( ) ) ; \nfinal Rational framerate = Rational . make ( 1 , snapsPerSecond ) ; \nfinal Muxer muxer = Muxer . make ( filename , null , formatname ) ; \nfinal MuxerFormat format = muxer . getFormat ( ) ; \nfinal Codec codec ; \nif ( codecname != null ) { \ncodec = Codec . findEncodingCodecByName ( codecname ) ; \n} \nelse { \ncodec = Codec . findEncodingCodec ( format . getDefaultVideoCodecId ( ) ) ; \n} \nEncoder encoder = Encoder . make ( codec ) ; \nencoder . setWidth ( screenbounds . width ) ; \nencoder . setHeight ( screenbounds . height ) ; \nfinal PixelFormat . Type pixelformat = PixelFormat . Type . PIX_FMT_YUV420P ; \nencoder . setPixelFormat ( pixelformat ) ; \nencoder . setTimeBase ( framerate ) ; \nif ( format . getFlag ( MuxerFormat . Flag . GLOBAL_HEADER ) ) encoder . setFlag ( Encoder . Flag . FLAG_GLOBAL_HEADER , true ) ; \nencoder . open ( null , null ) ; \nmuxer . addNewStream ( encoder ) ; \nmuxer . open ( null , null ) ; \nMediaPictureConverter converter = null ; \nfinal MediaPicture picture = MediaPicture . make ( encoder . getWidth ( ) , encoder . getHeight ( ) , pixelformat ) ; \npicture . setTimeBase ( framerate ) ; \nfinal MediaPacket packet = MediaPacket . make ( ) ; \nfor ( int i = 0 ; \nduration / framerate . getDouble ( ) > i ; \ni ++ ) { \nfinal BufferedImage screen = convertToType ( robot . createScreenCapture ( screenbounds ) , BufferedImage . TYPE_3BYTE_BGR ) ; \nif ( converter == null ) converter = MediaPictureConverterFactory . createConverter ( screen , picture ) ; \nconverter . toPicture ( picture , screen , i ) ; \ndo { \nencoder . encode ( packet , picture ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nThread . sleep ( ( long ) ( 1000 * framerate . getDouble ( ) ) ) ; \n} \ndo { \nencoder . encode ( packet , null ) ; \nif ( packet . isComplete ( ) ) muxer . write ( packet , false ) ; \n} \nwhile ( packet . isComplete ( ) ) ; \nmuxer . close ( ) ; \n} \n} \n"}
{"3717": "public class Base58 { \npublic static byte [ ] decode ( String input ) throws IllegalArgumentException { \nif ( input . startsWith ( \"base58:\" ) ) input = input . substring ( 7 ) ; \nif ( input . length ( ) == 0 ) return new byte [ 0 ] ; \nbyte [ ] input58 = new byte [ input . length ( ) ] ; \nfor ( int i = 0 ; \ninput . length ( ) > i ; \n++ i ) { \nchar c = input . charAt ( i ) ; \nint digit = 128 > c ? INDEXES [ c ] : - 1 ; \nif ( 0 > digit ) { \nthrow new IllegalArgumentException ( \"Illegal character \" + c + \" at position \" + i ) ; \n} \ninput58 [ i ] = ( byte ) digit ; \n} \nint zeros = 0 ; \nwhile ( input58 . length > zeros && input58 [ zeros ] == 0 ) { \n++ zeros ; \n} \nbyte [ ] decoded = new byte [ input . length ( ) ] ; \nint outputStart = decoded . length ; \nfor ( int inputStart = zeros ; \ninput58 . length > inputStart ; \n) { \ndecoded [ -- outputStart ] = divmod ( input58 , inputStart , 58 , 256 ) ; \nif ( input58 [ inputStart ] == 0 ) { \n++ inputStart ; \n} \n} \nwhile ( decoded . length > outputStart && decoded [ outputStart ] == 0 ) { \n++ outputStart ; \n} \nreturn Arrays . copyOfRange ( decoded , outputStart - zeros , decoded . length ) ; \n} \n} \n"}
{"3718": "public class PrivateKeyAccount { \npublic static String generateSeed ( ) { \nbyte [ ] bytes = new byte [ 21 ] ; \nnew SecureRandom ( ) . nextBytes ( bytes ) ; \nbyte [ ] rhash = hash ( bytes , 0 , 20 , SHA256 ) ; \nbytes [ 20 ] = rhash [ 0 ] ; \nBigInteger rand = new BigInteger ( bytes ) ; \nBigInteger mask = new BigInteger ( new byte [ ] { \n0 , 0 , 7 , - 1 } \n) ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \n15 > i ; \ni ++ ) { \nsb . append ( 0 < i ? ' ' : \"\" ) . append ( SEED_WORDS [ rand . and ( mask ) . intValue ( ) ] ) ; \nrand = rand . shiftRight ( 11 ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"3731": "public class DefaultCoder { \npublic int toByteArray ( Object obj , byte result [ ] , int resultOffset , int avaiableSize ) { \noutput . resetForReUse ( ) ; \ntry { \noutput . writeObject ( obj ) ; \n} \ncatch ( IOException e ) { \nFSTUtil . < RuntimeException > rethrow ( e ) ; \n} \nint written = output . getWritten ( ) ; \nif ( avaiableSize < written ) { \nthrow FSTBufferTooSmallException . Instance ; \n} \nSystem . arraycopy ( output . getBuffer ( ) , 0 , result , resultOffset , written ) ; \nreturn written ; \n} \n} \n"}
{"3734": "public class FSTBinaryOffheapMap { \npublic void resizeStore ( long required , long maxgrowbytes ) { \nif ( mappedFile == null ) throw new RuntimeException ( \"store is full. Required: \" + required ) ; \nif ( memory . length ( ) >= required ) return ; \nmutationCount ++ ; \nSystem . out . println ( \"resizing underlying \" + mappedFile + \" to \" + required + \" numElem:\" + numElem ) ; \nlong tim = System . currentTimeMillis ( ) ; \n( ( MMFBytez ) memory ) . freeAndClose ( ) ; \nmemory = null ; \ntry { \nFile mf = new File ( mappedFile ) ; \nFileOutputStream f = new FileOutputStream ( mf , true ) ; \nlong len = mf . length ( ) ; \nrequired = required + Math . min ( required , maxgrowbytes ) ; \nbyte [ ] toWrite = new byte [ 1000 ] ; \nlong max = ( required - len ) / 1000 ; \nfor ( long i = 0 ; \nmax + 2 > i ; \ni ++ ) { \nf . write ( toWrite ) ; \n} \nf . flush ( ) ; \nf . close ( ) ; \nresetMem ( mappedFile , mf . length ( ) ) ; \nSystem . out . println ( \"resizing done in \" + ( System . currentTimeMillis ( ) - tim ) + \" numElemAfter:\" + numElem ) ; \n} \ncatch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"3736": "public class FSTStreamEncoder { \nvoid writeStringAsc ( String name ) throws IOException { \nint len = name . length ( ) ; \nif ( 127 <= len ) { \nthrow new RuntimeException ( \"Ascii String too long\" ) ; \n} \nwriteFByte ( ( byte ) len ) ; \nbuffout . ensureFree ( len ) ; \nif ( ascStringCache == null || len > ascStringCache . length ) ascStringCache = new byte [ len ] ; \nname . getBytes ( 0 , len , ascStringCache , 0 ) ; \nwriteRawBytes ( ascStringCache , 0 , len ) ; \n} \n} \n"}
{"3746": "public class FSTConfiguration { \npublic FSTConfiguration registerCrossPlatformClassMapping ( String [ ] [ ] keysAndVals ) { \nfor ( int i = 0 ; \nkeysAndVals . length > i ; \ni ++ ) { \nString [ ] keysAndVal = keysAndVals [ i ] ; \nregisterCrossPlatformClassMapping ( keysAndVal [ 0 ] , keysAndVal [ 1 ] ) ; \n} \nreturn this ; \n} \n} \n"}
{"3749": "public class MBOut { \nprotected void writeRawInt ( byte type , long data ) { \nint numBytes = MinBin . extractNumBytes ( type ) ; \nfor ( int i = 0 ; \nnumBytes > i ; \ni ++ ) { \nwriteOut ( ( byte ) ( data & 0xff ) ) ; \ndata = data >>> 8 ; \n} \n} \n} \n"}
{"3750": "public class MBOut { \npublic void writeIntPacked ( long data ) { \nif ( Byte . MAX_VALUE >= data && Byte . MIN_VALUE <= data ) writeInt ( MinBin . INT_8 , data ) ; \nelse if ( Short . MAX_VALUE >= data && Short . MIN_VALUE <= data ) writeInt ( MinBin . INT_16 , data ) ; \nelse if ( Integer . MAX_VALUE >= data && Integer . MIN_VALUE <= data ) writeInt ( MinBin . INT_32 , data ) ; \nelse if ( Long . MAX_VALUE >= data && Long . MIN_VALUE <= data ) writeInt ( MinBin . INT_64 , data ) ; \n} \n} \n"}
{"3751": "public class MBOut { \npublic void writeArray ( Object primitiveArray , int start , int len ) { \nbyte type = MinBin . ARRAY_MASK ; \nClass < ? > componentType = primitiveArray . getClass ( ) . getComponentType ( ) ; \nif ( componentType == boolean . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == byte . class ) type |= MinBin . INT_8 ; \nelse if ( componentType == short . class ) type |= MinBin . INT_16 ; \nelse if ( componentType == char . class ) type |= MinBin . INT_16 | MinBin . UNSIGN_MASK ; \nelse if ( componentType == int . class ) type |= MinBin . INT_32 ; \nelse if ( componentType == long . class ) type |= MinBin . INT_64 ; \nelse throw new RuntimeException ( \"unsupported type \" + componentType . getName ( ) ) ; \nwriteOut ( type ) ; \nwriteIntPacked ( len ) ; \nswitch ( type ) { \ncase MinBin . INT_8 | MinBin . ARRAY_MASK : { \nif ( componentType == boolean . class ) { \nboolean [ ] arr = ( boolean [ ] ) primitiveArray ; \nfor ( int i = start ; \nstart + len > i ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ? 1 : 0 ) ; \n} \n} \nelse { \nbyte [ ] arr = ( byte [ ] ) primitiveArray ; \nfor ( int i = start ; \nstart + len > i ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \n} \nbreak ; \ncase MinBin . CHAR | MinBin . ARRAY_MASK : { \nchar [ ] charArr = ( char [ ] ) primitiveArray ; \nfor ( int i = start ; \nstart + len > i ; \ni ++ ) { \nwriteRawInt ( type , charArr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_32 | MinBin . ARRAY_MASK : { \nint [ ] arr = ( int [ ] ) primitiveArray ; \nfor ( int i = start ; \nstart + len > i ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ncase MinBin . INT_64 | MinBin . ARRAY_MASK : { \nlong [ ] arr = ( long [ ] ) primitiveArray ; \nfor ( int i = start ; \nstart + len > i ; \ni ++ ) { \nwriteRawInt ( type , arr [ i ] ) ; \n} \n} \nbreak ; \ndefault : { \nfor ( int i = start ; \nstart + len > i ; \ni ++ ) { \nif ( componentType == boolean . class ) writeRawInt ( type , Array . getBoolean ( primitiveArray , i ) ? 1 : 0 ) ; \nelse writeRawInt ( type , Array . getLong ( primitiveArray , i ) ) ; \n} \n} \n} \n} \n} \n"}
{"3752": "public class MBOut { \npublic void writeRaw ( byte [ ] bufferedName , int i , int length ) { \nif ( bytez . length - 1 <= pos + length ) { \nresize ( ) ; \n} \nSystem . arraycopy ( bufferedName , i , bytez , pos , length ) ; \npos += length ; \n} \n} \n"}
{"3753": "public class FSTObjectOutput { \nprotected FSTClazzInfo . FSTFieldInfo getCachedFI ( Class ... possibles ) { \nif ( refs == null ) { \nrefs = refsLocal . get ( ) ; \n} \nif ( refs . length <= curDepth ) { \nreturn new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) ; \n} \nelse { \nFSTClazzInfo . FSTFieldInfo inf = refs [ curDepth ] ; \nif ( inf == null ) { \ninf = new FSTClazzInfo . FSTFieldInfo ( possibles , null , true ) ; \nrefs [ curDepth ] = inf ; \nreturn inf ; \n} \ninf . setPossibleClasses ( possibles ) ; \nreturn inf ; \n} \n} \n} \n"}
{"3757": "public class FSTObjectOutput { \nprotected void writeArray ( FSTClazzInfo . FSTFieldInfo referencee , Object array ) throws IOException { \nif ( array == null ) { \ngetCodec ( ) . writeClass ( Object . class ) ; \ngetCodec ( ) . writeFInt ( - 1 ) ; \nreturn ; \n} \nfinal int len = Array . getLength ( array ) ; \nClass < ? > componentType = array . getClass ( ) . getComponentType ( ) ; \ngetCodec ( ) . writeClass ( array . getClass ( ) ) ; \ngetCodec ( ) . writeFInt ( len ) ; \nif ( ! componentType . isArray ( ) ) { \nif ( getCodec ( ) . isPrimitiveArray ( array , componentType ) ) { \ngetCodec ( ) . writePrimitiveArray ( array , 0 , len ) ; \n} \nelse { \nObject arr [ ] = ( Object [ ] ) array ; \nClass lastClz = null ; \nFSTClazzInfo lastInfo = null ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nObject toWrite = arr [ i ] ; \nif ( toWrite != null ) { \nlastInfo = writeObjectWithContext ( referencee , toWrite , lastClz == toWrite . getClass ( ) ? lastInfo : null ) ; \nlastClz = toWrite . getClass ( ) ; \n} \nelse writeObjectWithContext ( referencee , toWrite , null ) ; \n} \n} \n} \nelse { \nObject [ ] arr = ( Object [ ] ) array ; \nFSTClazzInfo . FSTFieldInfo ref1 = new FSTClazzInfo . FSTFieldInfo ( referencee . getPossibleClasses ( ) , null , conf . getCLInfoRegistry ( ) . isIgnoreAnnotations ( ) ) ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nObject subArr = arr [ i ] ; \nboolean needsWrite = true ; \nif ( getCodec ( ) . isTagMultiDimSubArrays ( ) ) { \nif ( subArr == null ) { \nneedsWrite = ! getCodec ( ) . writeTag ( NULL , null , 0 , null , this ) ; \n} \nelse { \nneedsWrite = ! getCodec ( ) . writeTag ( ARRAY , subArr , 0 , subArr , this ) ; \n} \n} \nif ( needsWrite ) { \nwriteArray ( ref1 , subArr ) ; \ngetCodec ( ) . writeArrayEnd ( ) ; \n} \n} \n} \n} \n} \n"}
{"3758": "public class StructString { \npublic void setString ( String s ) { \nif ( s == null ) { \nsetLen ( 0 ) ; \nreturn ; \n} \nif ( charsLen ( ) < s . length ( ) ) { \nthrow new RuntimeException ( \"String length exceeds buffer size. String len \" + s . length ( ) + \" charsLen:\" + charsLen ( ) ) ; \n} \nfor ( int i = 0 ; \ns . length ( ) > i ; \ni ++ ) { \nchars ( i , s . charAt ( i ) ) ; \n} \nlen = s . length ( ) ; \n} \n} \n"}
{"3761": "public class FSTStructChange { \npublic void snapshotChanges ( int originBase , Bytez origin ) { \nint sumLen = 0 ; \nfor ( int i = 0 ; \ncurIndex > i ; \ni ++ ) { \nsumLen += changeLength [ i ] ; \n} \nsnapshot = new byte [ sumLen ] ; \nint targetIdx = 0 ; \nfor ( int i = 0 ; \ncurIndex > i ; \ni ++ ) { \nint changeOffset = changeOffsets [ i ] ; \nint len = changeLength [ i ] ; \nfor ( int ii = 0 ; \nlen > ii ; \nii ++ ) { \nsnapshot [ targetIdx ++ ] = origin . get ( changeOffset + ii ) ; \n} \n} \nrebase ( originBase ) ; \n} \n} \n"}
{"3762": "public class FSTObjectRegistry { \npublic int registerObjectForWrite ( Object o , int streamPosition , FSTClazzInfo clzInfo , int reUseType [ ] ) { \nif ( disabled ) { \nreturn Integer . MIN_VALUE ; \n} \nif ( clzInfo == null ) { \n} \nelse if ( clzInfo . isFlat ( ) ) { \nreturn Integer . MIN_VALUE ; \n} \nint handle = objects . putOrGet ( o , streamPosition ) ; \nif ( 0 <= handle ) { \nreUseType [ 0 ] = 0 ; \nreturn handle ; \n} \nreturn Integer . MIN_VALUE ; \n} \n} \n"}
{"3765": "public class BinaryQueue { \npublic byte [ ] readByteArray ( int len ) { \nif ( len > available ( ) ) { \nthrow new RuntimeException ( \"not enough data available, check available() > len before calling\" ) ; \n} \nbyte b [ ] = new byte [ len ] ; \nint count = 0 ; \nwhile ( pollIndex != addIndex && len > count ) { \nb [ count ++ ] = storage . get ( pollIndex ++ ) ; \nif ( storage . length ( ) <= pollIndex ) { \npollIndex = 0 ; \n} \n} \nreturn b ; \n} \n} \n"}
{"3766": "public class BinaryQueue { \npublic int readInt ( ) { \nif ( 4 > available ( ) ) { \nthrow new RuntimeException ( \"not enough data available, check available() > 4 before calling\" ) ; \n} \nint ch1 = poll ( ) ; \nint ch2 = poll ( ) ; \nint ch3 = poll ( ) ; \nint ch4 = poll ( ) ; \nreturn ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 ) ; \n} \n} \n"}
{"3767": "public class BinaryQueue { \npublic void back ( int len ) { \nif ( len <= pollIndex ) pollIndex -= len ; \nelse pollIndex = pollIndex + capacity ( ) - len ; \n} \n} \n"}
{"3777": "public class BooleanIndexing { \npublic static boolean or ( IComplexNDArray n , Condition cond ) { \nboolean ret = false ; \nIComplexNDArray linear = n . linearView ( ) ; \nfor ( int i = 0 ; \nlinear . length ( ) > i ; \ni ++ ) { \nret = ret || cond . apply ( linear . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3779": "public class BooleanIndexing { \npublic static boolean [ ] and ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nlong tadLength = Shape . getTADLength ( n . shape ( ) , dimension ) ; \nfor ( int i = 0 ; \narr . length ( ) > i ; \ni ++ ) { \nif ( arr . getDouble ( i ) == tadLength ) result [ i ] = true ; \nelse result [ i ] = false ; \n} \nreturn result ; \n} \n} \n"}
{"3780": "public class BooleanIndexing { \npublic static boolean [ ] or ( final INDArray n , final Condition condition , int ... dimension ) { \nif ( ! ( condition instanceof BaseCondition ) ) throw new UnsupportedOperationException ( \"Only static Conditions are supported\" ) ; \nMatchCondition op = new MatchCondition ( n , condition ) ; \nINDArray arr = Nd4j . getExecutioner ( ) . exec ( op , dimension ) ; \nboolean [ ] result = new boolean [ ( int ) arr . length ( ) ] ; \nfor ( int i = 0 ; \narr . length ( ) > i ; \ni ++ ) { \nif ( 0 < arr . getDouble ( i ) ) result [ i ] = true ; \nelse result [ i ] = false ; \n} \nreturn result ; \n} \n} \n"}
{"3784": "public class FunctionProperties { \npublic static FunctionProperties fromFlatProperties ( FlatProperties properties ) { \nval props = new FunctionProperties ( ) ; \nfor ( int e = 0 ; \nproperties . iLength ( ) > e ; \ne ++ ) props . getI ( ) . add ( properties . i ( e ) ) ; \nfor ( int e = 0 ; \nproperties . lLength ( ) > e ; \ne ++ ) props . getL ( ) . add ( properties . l ( e ) ) ; \nfor ( int e = 0 ; \nproperties . dLength ( ) > e ; \ne ++ ) props . getD ( ) . add ( properties . d ( e ) ) ; \nfor ( int e = 0 ; \nproperties . iLength ( ) > e ; \ne ++ ) props . getA ( ) . add ( Nd4j . createFromFlatArray ( properties . a ( e ) ) ) ; \nreturn props ; \n} \n} \n"}
{"3788": "public class MathUtils { \npublic static List < Double > mergeCoords ( List < Double > x , List < Double > y ) { \nif ( x . size ( ) != y . size ( ) ) throw new IllegalArgumentException ( \"Sample sizes must be the same for each data applyTransformToDestination.\" ) ; \nList < Double > ret = new ArrayList < Double > ( ) ; \nfor ( int i = 0 ; \nx . size ( ) > i ; \ni ++ ) { \nret . add ( x . get ( i ) ) ; \nret . add ( y . get ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3789": "public class MathUtils { \npublic static List < List < Double > > partitionVariable ( List < Double > arr , int chunk ) { \nint count = 0 ; \nList < List < Double > > ret = new ArrayList < List < Double > > ( ) ; \nwhile ( arr . size ( ) > count ) { \nList < Double > sublist = arr . subList ( count , count + chunk ) ; \ncount += chunk ; \nret . add ( sublist ) ; \n} \nfor ( List < Double > lists : ret ) { \nif ( chunk > lists . size ( ) ) ret . remove ( lists ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3797": "public class BaseNDArrayFactory { \nprotected static void validateConcat ( int dimension , INDArray ... arrs ) { \nif ( arrs [ 0 ] . isScalar ( ) ) { \nfor ( int i = 1 ; \narrs . length > i ; \ni ++ ) if ( ! arrs [ i ] . isScalar ( ) ) throw new IllegalArgumentException ( \"All arrays must have same dimensions\" ) ; \n} \nelse { \nint dims = arrs [ 0 ] . shape ( ) . length ; \nlong [ ] shape = ArrayUtil . removeIndex ( arrs [ 0 ] . shape ( ) , dimension ) ; \nfor ( int i = 1 ; \narrs . length > i ; \ni ++ ) { \nassert Arrays . equals ( shape , ArrayUtil . removeIndex ( arrs [ i ] . shape ( ) , dimension ) ) ; \nassert arrs [ i ] . shape ( ) . length == dims ; \n} \n} \n} \n} \n"}
{"3799": "public class BaseNDArrayFactory { \n@ Override public INDArray linspace ( int lower , int upper , int num ) { \ndouble [ ] data = new double [ num ] ; \nfor ( int i = 0 ; \nnum > i ; \ni ++ ) { \ndouble t = ( double ) i / ( num - 1 ) ; \ndata [ i ] = lower * ( 1 - t ) + t * upper ; \n} \nINDArray ret = Nd4j . create ( data . length ) ; \nif ( ret . isScalar ( ) ) return ret ; \nfor ( int i = 0 ; \nret . length ( ) > i ; \ni ++ ) ret . putScalar ( i , data [ i ] ) ; \nreturn ret ; \n} \n} \n"}
{"3801": "public class BaseNDArrayFactory { \n@ Override public INDArray bilinearProducts ( INDArray curr , INDArray in ) { \nassert curr . shape ( ) . length == 3 ; \nif ( in . columns ( ) != 1 ) { \nthrow new AssertionError ( \"Expected a column vector\" ) ; \n} \nif ( in . rows ( ) != curr . size ( curr . shape ( ) . length - 1 ) ) { \nthrow new AssertionError ( \"Number of rows in the input does not match number of columns in tensor\" ) ; \n} \nif ( curr . size ( curr . shape ( ) . length - 2 ) != curr . size ( curr . shape ( ) . length - 1 ) ) { \nthrow new AssertionError ( \"Can only perform this operation on a SimpleTensor with square slices\" ) ; \n} \nINDArray ret = Nd4j . create ( curr . slices ( ) , 1 ) ; \nINDArray inT = in . transpose ( ) ; \nfor ( int i = 0 ; \ncurr . slices ( ) > i ; \ni ++ ) { \nINDArray slice = curr . slice ( i ) ; \nINDArray inTTimesSlice = inT . mmul ( slice ) ; \nret . putScalar ( i , Nd4j . getBlasWrapper ( ) . dot ( inTTimesSlice , in ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3805": "public class TimeDelayedParameterUpdater { \n@ Override public boolean shouldReplicate ( ) { \nlong now = System . currentTimeMillis ( ) ; \nlong diff = Math . abs ( now - lastSynced ) ; \nreturn syncTime < diff ; \n} \n} \n"}
{"3813": "public class DataSet { \n@ Override public void binarize ( double cutoff ) { \nINDArray linear = getFeatureMatrix ( ) . linearView ( ) ; \nfor ( int i = 0 ; \ngetFeatures ( ) . length ( ) > i ; \ni ++ ) { \ndouble curr = linear . getDouble ( i ) ; \nif ( cutoff < curr ) getFeatures ( ) . putScalar ( i , 1 ) ; \nelse getFeatures ( ) . putScalar ( i , 0 ) ; \n} \n} \n} \n"}
{"3814": "public class DataSet { \n@ Override public DataSet sample ( int numSamples , org . nd4j . linalg . api . rng . Random rng , boolean withReplacement ) { \nINDArray examples = Nd4j . create ( numSamples , getFeatures ( ) . columns ( ) ) ; \nINDArray outcomes = Nd4j . create ( numSamples , numOutcomes ( ) ) ; \nSet < Integer > added = new HashSet < > ( ) ; \nfor ( int i = 0 ; \nnumSamples > i ; \ni ++ ) { \nint picked = rng . nextInt ( numExamples ( ) ) ; \nif ( ! withReplacement ) while ( added . contains ( picked ) ) picked = rng . nextInt ( numExamples ( ) ) ; \nexamples . putRow ( i , get ( picked ) . getFeatures ( ) ) ; \noutcomes . putRow ( i , get ( picked ) . getLabels ( ) ) ; \n} \nreturn new DataSet ( examples , outcomes ) ; \n} \n} \n"}
{"3818": "public class StringUtils { \npublic static String arrayToString ( String [ ] strs ) { \nif ( strs . length == 0 ) { \nreturn \"\" ; \n} \nStringBuilder sbuf = new StringBuilder ( ) ; \nsbuf . append ( strs [ 0 ] ) ; \nfor ( int idx = 1 ; \nstrs . length > idx ; \nidx ++ ) { \nsbuf . append ( \",\" ) ; \nsbuf . append ( strs [ idx ] ) ; \n} \nreturn sbuf . toString ( ) ; \n} \n} \n"}
{"3819": "public class StringUtils { \npublic static String byteToHexString ( byte [ ] bytes , int start , int end ) { \nif ( bytes == null ) { \nthrow new IllegalArgumentException ( \"bytes == null\" ) ; \n} \nStringBuilder s = new StringBuilder ( ) ; \nfor ( int i = start ; \nend > i ; \ni ++ ) { \ns . append ( format ( \"%02x\" , bytes [ i ] ) ) ; \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"3821": "public class StringUtils { \npublic static String [ ] split ( String str , char escapeChar , char separator ) { \nif ( str == null ) { \nreturn null ; \n} \nArrayList < String > strList = new ArrayList < String > ( ) ; \nStringBuilder split = new StringBuilder ( ) ; \nint index = 0 ; \nwhile ( 0 <= ( index = findNext ( str , separator , escapeChar , index , split ) ) ) { \n++ index ; \nstrList . add ( split . toString ( ) ) ; \nsplit . setLength ( 0 ) ; \n} \nstrList . add ( split . toString ( ) ) ; \nint last = strList . size ( ) ; \nwhile ( 0 <= -- last && \"\" . equals ( strList . get ( last ) ) ) { \nstrList . remove ( last ) ; \n} \nreturn strList . toArray ( new String [ strList . size ( ) ] ) ; \n} \n} \n"}
{"3822": "public class StringUtils { \npublic static String [ ] split ( String str , char separator ) { \nif ( str . isEmpty ( ) ) { \nreturn new String [ ] { \n\"\" } \n; \n} \nArrayList < String > strList = new ArrayList < String > ( ) ; \nint startIndex = 0 ; \nint nextIndex = 0 ; \nwhile ( ( nextIndex = str . indexOf ( separator , startIndex ) ) != - 1 ) { \nstrList . add ( str . substring ( startIndex , nextIndex ) ) ; \nstartIndex = nextIndex + 1 ; \n} \nstrList . add ( str . substring ( startIndex ) ) ; \nint last = strList . size ( ) ; \nwhile ( 0 <= -- last && \"\" . equals ( strList . get ( last ) ) ) { \nstrList . remove ( last ) ; \n} \nreturn strList . toArray ( new String [ strList . size ( ) ] ) ; \n} \n} \n"}
{"3823": "public class StringUtils { \npublic static int findNext ( String str , char separator , char escapeChar , int start , StringBuilder split ) { \nint numPreEscapes = 0 ; \nfor ( int i = start ; \nstr . length ( ) > i ; \ni ++ ) { \nchar curChar = str . charAt ( i ) ; \nif ( numPreEscapes == 0 && curChar == separator ) { \nreturn i ; \n} \nelse { \nsplit . append ( curChar ) ; \nnumPreEscapes = ( curChar == escapeChar ) ? ( ++ numPreEscapes ) % 2 : 0 ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"3830": "public class Factorial { \npublic BigInteger at ( int n ) { \nwhile ( n >= a . size ( ) ) { \nfinal int lastn = a . size ( ) - 1 ; \nfinal BigInteger nextn = BigInteger . valueOf ( lastn + 1 ) ; \na . add ( a . get ( lastn ) . multiply ( nextn ) ) ; \n} \nreturn a . get ( n ) ; \n} \n} \n"}
{"3831": "public class AllocationPoint { \npublic boolean isActualOnHostSide ( ) { \nboolean result = accessDeviceWrite . get ( ) <= accessHostWrite . get ( ) || accessDeviceWrite . get ( ) <= accessHostRead . get ( ) ; \nreturn result ; \n} \n} \n"}
{"3832": "public class AllocationPoint { \npublic boolean isActualOnDeviceSide ( ) { \nboolean result = accessHostWrite . get ( ) <= accessDeviceWrite . get ( ) || accessHostWrite . get ( ) <= accessDeviceRead . get ( ) ; \nreturn result ; \n} \n} \n"}
{"3835": "public class Shape { \npublic static boolean isVector ( DataBuffer shapeInfo ) { \nint rank = Shape . rank ( shapeInfo ) ; \nif ( 2 < rank || 1 > rank ) return false ; \nelse { \nint len = Shape . length ( shapeInfo ) ; \nDataBuffer shape = Shape . shapeOf ( shapeInfo ) ; \nreturn shape . getInt ( 0 ) == len || shape . getInt ( 1 ) == len ; \n} \n} \n} \n"}
{"3838": "public class Shape { \npublic static INDArrayIndex [ ] toIndexes ( int [ ] indices ) { \nINDArrayIndex [ ] ret = new INDArrayIndex [ indices . length ] ; \nfor ( int i = 0 ; \nret . length > i ; \ni ++ ) ret [ i ] = new NDArrayIndex ( indices [ i ] ) ; \nreturn ret ; \n} \n} \n"}
{"3841": "public class NioUtil { \npublic static void copyAtStride ( int n , BufferType bufferType , ByteBuffer from , int fromOffset , int fromStride , ByteBuffer to , int toOffset , int toStride ) { \nByteBuffer fromView = from ; \nByteBuffer toView = to ; \nfromView . order ( ByteOrder . nativeOrder ( ) ) ; \ntoView . order ( ByteOrder . nativeOrder ( ) ) ; \nswitch ( bufferType ) { \ncase INT : IntBuffer fromInt = fromView . asIntBuffer ( ) ; \nIntBuffer toInt = toView . asIntBuffer ( ) ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nint put = fromInt . get ( fromOffset + i * fromStride ) ; \ntoInt . put ( toOffset + i * toStride , put ) ; \n} \nbreak ; \ncase FLOAT : FloatBuffer fromFloat = fromView . asFloatBuffer ( ) ; \nFloatBuffer toFloat = toView . asFloatBuffer ( ) ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nfloat put = fromFloat . get ( fromOffset + i * fromStride ) ; \ntoFloat . put ( toOffset + i * toStride , put ) ; \n} \nbreak ; \ncase DOUBLE : DoubleBuffer fromDouble = fromView . asDoubleBuffer ( ) ; \nDoubleBuffer toDouble = toView . asDoubleBuffer ( ) ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \ntoDouble . put ( toOffset + i * toStride , fromDouble . get ( fromOffset + i * fromStride ) ) ; \n} \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Only floats and double supported\" ) ; \n} \n} \n} \n"}
{"3842": "public class ProtectedCudaConstantHandler { \n@ Override public DataBuffer getConstantBuffer ( float [ ] array ) { \nArrayDescriptor descriptor = new ArrayDescriptor ( array ) ; \nInteger deviceId = AtomicAllocator . getInstance ( ) . getDeviceId ( ) ; \nensureMaps ( deviceId ) ; \nif ( ! buffersCache . get ( deviceId ) . containsKey ( descriptor ) ) { \nDataBuffer buffer = Nd4j . createBufferDetached ( array ) ; \nif ( MAX_CONSTANT_LENGTH > constantOffsets . get ( deviceId ) . get ( ) + ( array . length * Nd4j . sizeOfDataType ( ) ) ) { \nbuffer . setConstant ( true ) ; \nmoveToConstantSpace ( buffer ) ; \nbuffersCache . get ( deviceId ) . put ( descriptor , buffer ) ; \nbytes . addAndGet ( array . length * Nd4j . sizeOfDataType ( ) ) ; \n} \nreturn buffer ; \n} \nreturn buffersCache . get ( deviceId ) . get ( descriptor ) ; \n} \n} \n"}
{"3854": "public class TwoPointApproximation { \npublic static INDArray [ ] adjustSchemeToBounds ( INDArray x , INDArray h , int numSteps , INDArray lowerBound , INDArray upperBound ) { \nINDArray oneSided = Nd4j . onesLike ( h ) ; \nif ( 0 < and ( lowerBound . eq ( Double . NEGATIVE_INFINITY ) , upperBound . eq ( Double . POSITIVE_INFINITY ) ) . sumNumber ( ) . doubleValue ( ) ) { \nreturn new INDArray [ ] { \nh , oneSided } \n; \n} \nINDArray hTotal = h . mul ( numSteps ) ; \nINDArray hAdjusted = h . dup ( ) ; \nINDArray lowerDist = x . sub ( lowerBound ) ; \nINDArray upperBound2 = upperBound . sub ( x ) ; \nINDArray central = and ( greaterThanOrEqual ( lowerDist , hTotal ) , greaterThanOrEqual ( upperBound2 , hTotal ) ) ; \nINDArray forward = and ( greaterThanOrEqual ( upperBound , lowerDist ) , not ( central ) ) ; \nhAdjusted . put ( forward , min ( h . get ( forward ) , upperBound2 . get ( forward ) . mul ( 0.5 ) . divi ( numSteps ) ) ) ; \noneSided . put ( forward , Nd4j . scalar ( 1.0 ) ) ; \nINDArray backward = and ( upperBound2 . lt ( lowerBound ) , not ( central ) ) ; \nhAdjusted . put ( backward , min ( h . get ( backward ) , lowerDist . get ( backward ) . mul ( 0.5 ) . divi ( numSteps ) ) ) ; \noneSided . put ( backward , Nd4j . scalar ( 1.0 ) ) ; \nINDArray minDist = min ( upperBound2 , lowerDist ) . divi ( numSteps ) ; \nINDArray adjustedCentral = and ( not ( central ) , lessThanOrEqual ( abs ( hAdjusted ) , minDist ) ) ; \nhAdjusted . put ( adjustedCentral , minDist . get ( adjustedCentral ) ) ; \noneSided . put ( adjustedCentral , Nd4j . scalar ( 0.0 ) ) ; \nreturn new INDArray [ ] { \nhAdjusted , oneSided } \n; \n} \n} \n"}
{"3855": "public class MultipleEpochsIterator { \n@ Override public DataSet next ( ) { \nif ( ! iter . hasNext ( ) && numPasses > passes ) { \npasses ++ ; \nbatch = 0 ; \nlog . info ( \"Epoch \" + passes + \" batch \" + batch ) ; \niter . reset ( ) ; \n} \nbatch ++ ; \nDataSet next = iter . next ( ) ; \nif ( preProcessor != null ) preProcessor . preProcess ( next ) ; \nreturn next ; \n} \n} \n"}
{"3856": "public class CpuLapack { \n@ Override public void sgeqrf ( int M , int N , INDArray A , INDArray R , INDArray INFO ) { \nINDArray tau = Nd4j . create ( N ) ; \nint status = LAPACKE_sgeqrf ( getColumnOrder ( A ) , M , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) { \nthrow new BlasException ( \"Failed to execute sgeqrf\" , status ) ; \n} \nif ( R != null ) { \nR . assign ( A . get ( NDArrayIndex . interval ( 0 , A . columns ( ) ) , NDArrayIndex . all ( ) ) ) ; \nINDArrayIndex ix [ ] = new INDArrayIndex [ 2 ] ; \nfor ( int i = 1 ; \nMath . min ( A . rows ( ) , A . columns ( ) ) > i ; \ni ++ ) { \nix [ 0 ] = NDArrayIndex . point ( i ) ; \nix [ 1 ] = NDArrayIndex . interval ( 0 , i ) ; \nR . put ( ix , 0 ) ; \n} \n} \nstatus = LAPACKE_sorgqr ( getColumnOrder ( A ) , M , N , N , ( FloatPointer ) A . data ( ) . addressPointer ( ) , getLda ( A ) , ( FloatPointer ) tau . data ( ) . addressPointer ( ) ) ; \nif ( status != 0 ) { \nthrow new BlasException ( \"Failed to execute sorgqr\" , status ) ; \n} \n} \n} \n"}
{"3860": "public class AsynchronousFlowController { \nprotected void sweepTail ( ) { \nInteger deviceId = allocator . getDeviceId ( ) ; \nint cnt = 0 ; \nlong lastCommandId = deviceClocks . get ( deviceId ) . get ( ) ; \nfor ( int l = 0 ; \nconfiguration . getCommandLanesNumber ( ) > l ; \nl ++ ) { \nQueue < cudaEvent_t > queue = eventsBarrier . get ( deviceId ) . get ( l ) ; \nif ( MAX_EXECUTION_QUEUE <= queue . size ( ) || lastCommandId - MAX_EXECUTION_QUEUE > laneClocks . get ( deviceId ) . get ( l ) . get ( ) ) { \ncudaEvent_t event = queue . poll ( ) ; \nif ( event != null && ! event . isDestroyed ( ) ) { \nevent . synchronize ( ) ; \nevent . destroy ( ) ; \ncnt ++ ; \n} \n} \n} \ndeviceClocks . get ( deviceId ) . incrementAndGet ( ) ; \n} \n} \n"}
{"3871": "public class CudaAffinityManager { \nprotected Integer getNextDevice ( long threadId ) { \nInteger device = null ; \nif ( ! CudaEnvironment . getInstance ( ) . getConfiguration ( ) . isForcedSingleGPU ( ) && 0 < getNumberOfDevices ( ) ) { \nsynchronized ( this ) { \ndevice = CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . get ( devPtr . getAndIncrement ( ) ) ; \nif ( CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . size ( ) <= devPtr . get ( ) ) devPtr . set ( 0 ) ; \nlogger . debug ( \"Mapping thread [{}] to device [{}], out of [{}] devices...\" , threadId , device , CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . size ( ) ) ; \n} \n} \nelse { \ndevice = CudaEnvironment . getInstance ( ) . getConfiguration ( ) . getAvailableDevices ( ) . get ( 0 ) ; \nlogger . debug ( \"Single device is forced, mapping to device [{}]\" , device ) ; \n} \nreturn device ; \n} \n} \n"}
{"3879": "public class DistributedAssignMessage { \n@ Override public void processMessage ( ) { \nif ( payload != null ) { \nif ( storage . arrayExists ( key ) && storage . getArray ( key ) . length ( ) == payload . length ( ) ) storage . getArray ( key ) . assign ( payload ) ; \nelse storage . setArray ( key , payload ) ; \n} \nelse { \nif ( 0 <= index ) { \nif ( storage . getArray ( key ) == null ) throw new RuntimeException ( \"Init wasn't called before for key [\" + key + \"]\" ) ; \nstorage . getArray ( key ) . getRow ( index ) . assign ( value ) ; \n} \nelse storage . getArray ( key ) . assign ( value ) ; \n} \n} \n} \n"}
{"3888": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray expi ( IComplexNDArray toExp ) { \nIComplexNDArray flattened = toExp . ravel ( ) ; \nfor ( int i = 0 ; \nflattened . length ( ) > i ; \ni ++ ) { \nIComplexNumber n = flattened . getComplex ( i ) ; \nflattened . put ( i , Nd4j . scalar ( ComplexUtil . exp ( n ) ) ) ; \n} \nreturn flattened . reshape ( toExp . shape ( ) ) ; \n} \n} \n"}
{"3889": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray center ( IComplexNDArray arr , long [ ] shape ) { \nif ( ArrayUtil . prod ( shape ) > arr . length ( ) ) return arr ; \nfor ( int i = 0 ; \nshape . length > i ; \ni ++ ) if ( 1 > shape [ i ] ) shape [ i ] = 1 ; \nINDArray shapeMatrix = NDArrayUtil . toNDArray ( shape ) ; \nINDArray currShape = NDArrayUtil . toNDArray ( arr . shape ( ) ) ; \nINDArray startIndex = Transforms . floor ( currShape . sub ( shapeMatrix ) . divi ( Nd4j . scalar ( 2 ) ) ) ; \nINDArray endIndex = startIndex . add ( shapeMatrix ) ; \nINDArrayIndex [ ] indexes = Indices . createFromStartAndEnd ( startIndex , endIndex ) ; \nif ( 1 < shapeMatrix . length ( ) ) return arr . get ( indexes ) ; \nelse { \nIComplexNDArray ret = Nd4j . createComplex ( new int [ ] { \n( int ) shapeMatrix . getDouble ( 0 ) } \n) ; \nint start = ( int ) startIndex . getDouble ( 0 ) ; \nint end = ( int ) endIndex . getDouble ( 0 ) ; \nint count = 0 ; \nfor ( int i = start ; \nend > i ; \ni ++ ) { \nret . putScalar ( count ++ , arr . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \n} \n} \n"}
{"3890": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray truncate ( IComplexNDArray nd , int n , int dimension ) { \nif ( nd . isVector ( ) ) { \nIComplexNDArray truncated = Nd4j . createComplex ( new int [ ] { \n1 , n } \n) ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) truncated . putScalar ( i , nd . getComplex ( i ) ) ; \nreturn truncated ; \n} \nif ( n < nd . size ( dimension ) ) { \nlong [ ] shape = ArrayUtil . copy ( nd . shape ( ) ) ; \nshape [ dimension ] = n ; \nIComplexNDArray ret = Nd4j . createComplex ( shape ) ; \nIComplexNDArray ndLinear = nd . linearView ( ) ; \nIComplexNDArray retLinear = ret . linearView ( ) ; \nfor ( int i = 0 ; \nret . length ( ) > i ; \ni ++ ) retLinear . putScalar ( i , ndLinear . getComplex ( i ) ) ; \nreturn ret ; \n} \nreturn nd ; \n} \n} \n"}
{"3891": "public class ComplexNDArrayUtil { \npublic static IComplexNDArray padWithZeros ( IComplexNDArray nd , long [ ] targetShape ) { \nif ( Arrays . equals ( nd . shape ( ) , targetShape ) ) return nd ; \nif ( ArrayUtil . prod ( targetShape ) <= ArrayUtil . prod ( nd . shape ( ) ) ) return nd ; \nIComplexNDArray ret = Nd4j . createComplex ( targetShape ) ; \nINDArrayIndex [ ] targetShapeIndex = NDArrayIndex . createCoveringShape ( nd . shape ( ) ) ; \nret . put ( targetShapeIndex , nd ) ; \nreturn ret ; \n} \n} \n"}
{"3893": "public class DeviceLocalNDArray { \npublic void broadcast ( INDArray array ) { \nif ( array == null ) return ; \nNd4j . getExecutioner ( ) . commit ( ) ; \nint numDevices = Nd4j . getAffinityManager ( ) . getNumberOfDevices ( ) ; \nfor ( int i = 0 ; \nnumDevices > i ; \ni ++ ) { \nif ( Nd4j . getAffinityManager ( ) . getDeviceForCurrentThread ( ) == i ) { \nset ( i , array ) ; \n} \nelse { \nset ( i , Nd4j . getAffinityManager ( ) . replicateToDevice ( i , array ) ) ; \n} \n} \n} \n} \n"}
{"3895": "public class BigDecimalMath { \nstatic public BigDecimal gamma ( MathContext mc ) { \nif ( GAMMA . precision ( ) > mc . getPrecision ( ) ) { \nreturn GAMMA . round ( mc ) ; \n} \nelse { \ndouble eps = prec2err ( 0.577 , mc . getPrecision ( ) ) ; \nMathContext mcloc = new MathContext ( 2 + mc . getPrecision ( ) ) ; \nBigDecimal resul = BigDecimal . ONE ; \nresul = resul . add ( log ( 2 , mcloc ) ) ; \nresul = resul . subtract ( log ( 3 , mcloc ) ) ; \nint kmax = ( int ) ( ( Math . log ( eps / 0.7 ) - 2. ) / 4. ) ; \nmcloc = new MathContext ( 1 + err2prec ( 1.2 , eps / kmax ) ) ; \nfor ( int n = 1 ; \n; \nn ++ ) { \nBigDecimal c = zeta ( 2 * n + 1 , mcloc ) . subtract ( BigDecimal . ONE ) ; \nBigInteger fourn = BigInteger . valueOf ( 2 * n + 1 ) ; \nfourn = fourn . shiftLeft ( 2 * n ) ; \nc = divideRound ( c , fourn ) ; \nresul = resul . subtract ( c ) ; \nif ( 0.1 * eps > c . doubleValue ( ) ) { \nbreak ; \n} \n} \nreturn resul . round ( mc ) ; \n} \n} \n} \n"}
{"3896": "public class BigDecimalMath { \nstatic public BigDecimal sqrt ( final BigDecimal x ) { \nif ( 0 > x . compareTo ( BigDecimal . ZERO ) ) { \nthrow new ArithmeticException ( \"negative argument \" + x . toString ( ) + \" of square root\" ) ; \n} \nreturn root ( 2 , x ) ; \n} \n} \n"}
{"3897": "public class BigDecimalMath { \nstatic public BigDecimal cbrt ( final BigDecimal x ) { \nif ( 0 > x . compareTo ( BigDecimal . ZERO ) ) { \nreturn root ( 3 , x . negate ( ) ) . negate ( ) ; \n} \nelse { \nreturn root ( 3 , x ) ; \n} \n} \n} \n"}
{"3898": "public class BigDecimalMath { \nstatic public BigDecimal root ( final int n , final BigDecimal x ) { \nif ( 0 > x . compareTo ( BigDecimal . ZERO ) ) { \nthrow new ArithmeticException ( \"negative argument \" + x . toString ( ) + \" of root\" ) ; \n} \nif ( 0 >= n ) { \nthrow new ArithmeticException ( \"negative power \" + n + \" of root\" ) ; \n} \nif ( n == 1 ) { \nreturn x ; \n} \nBigDecimal s = new BigDecimal ( Math . pow ( x . doubleValue ( ) , 1.0 / n ) ) ; \nfinal BigDecimal nth = new BigDecimal ( n ) ; \nfinal BigDecimal xhighpr = scalePrec ( x , 2 ) ; \nMathContext mc = new MathContext ( 2 + x . precision ( ) ) ; \nfinal double eps = x . ulp ( ) . doubleValue ( ) / ( 2 * n * x . doubleValue ( ) ) ; \nfor ( ; \n; \n) { \nBigDecimal c = xhighpr . divide ( s . pow ( n - 1 ) , mc ) ; \nc = s . subtract ( c ) ; \nMathContext locmc = new MathContext ( c . precision ( ) ) ; \nc = c . divide ( nth , locmc ) ; \ns = s . subtract ( c ) ; \nif ( eps > Math . abs ( c . doubleValue ( ) / s . doubleValue ( ) ) ) { \nbreak ; \n} \n} \nreturn s . round ( new MathContext ( err2prec ( eps ) ) ) ; \n} \n} \n"}
{"3899": "public class BigDecimalMath { \nstatic public BigDecimal exp ( BigDecimal x ) { \nif ( 0 > x . compareTo ( BigDecimal . ZERO ) ) { \nfinal BigDecimal invx = exp ( x . negate ( ) ) ; \nMathContext mc = new MathContext ( invx . precision ( ) ) ; \nreturn BigDecimal . ONE . divide ( invx , mc ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn scalePrec ( BigDecimal . ONE , - ( int ) ( Math . log10 ( x . ulp ( ) . doubleValue ( ) ) ) ) ; \n} \nelse { \nfinal double xDbl = x . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nif ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl > Math . pow ( xDbl , TAYLOR_NTERM ) ) { \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / TAYLOR_NTERM ) ) ; \nfor ( int i = 1 ; \nTAYLOR_NTERM >= i ; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( i ) ) ; \nxpowi = xpowi . multiply ( x ) ; \nfinal BigDecimal c = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( c ) ; \nif ( i > Math . abs ( xpowi . doubleValue ( ) ) && 0.5 * xUlpDbl > Math . abs ( c . doubleValue ( ) ) ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( xUlpDbl / 2. ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nint exSc = ( int ) ( 1.0 - Math . log10 ( TAYLOR_NTERM * ( TAYLOR_NTERM - 1.0 ) * ( TAYLOR_NTERM - 2.0 ) * xUlpDbl / Math . pow ( xDbl , TAYLOR_NTERM ) ) / ( TAYLOR_NTERM - 1.0 ) ) ; \nBigDecimal xby10 = x . scaleByPowerOfTen ( - exSc ) ; \nBigDecimal expxby10 = exp ( xby10 ) ; \nMathContext mc = new MathContext ( expxby10 . precision ( ) - exSc ) ; \nwhile ( 0 < exSc ) { \nint exsub = Math . min ( 8 , exSc ) ; \nexSc -= exsub ; \nMathContext mctmp = new MathContext ( expxby10 . precision ( ) - exsub + 2 ) ; \nint pex = 1 ; \nwhile ( 0 < exsub -- ) { \npex *= 10 ; \n} \nexpxby10 = expxby10 . pow ( pex , mctmp ) ; \n} \nreturn expxby10 . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3900": "public class BigDecimalMath { \nstatic public BigDecimal exp ( final MathContext mc ) { \nif ( E . precision ( ) > mc . getPrecision ( ) ) { \nreturn E . round ( mc ) ; \n} \nelse { \nBigDecimal uni = scalePrec ( BigDecimal . ONE , mc . getPrecision ( ) ) ; \nreturn exp ( uni ) ; \n} \n} \n} \n"}
{"3901": "public class BigDecimalMath { \nstatic public BigDecimal pow ( final BigDecimal x , final BigDecimal y ) { \nif ( 0 > x . compareTo ( BigDecimal . ZERO ) ) { \nthrow new ArithmeticException ( \"Cannot power negative \" + x . toString ( ) ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal logx = log ( x ) ; \nBigDecimal ylogx = y . multiply ( logx ) ; \nBigDecimal resul = exp ( ylogx ) ; \ndouble errR = Math . abs ( logx . doubleValue ( ) * y . ulp ( ) . doubleValue ( ) / 2. ) + Math . abs ( y . doubleValue ( ) * x . ulp ( ) . doubleValue ( ) / 2. / x . doubleValue ( ) ) ; \nMathContext mcR = new MathContext ( err2prec ( 1.0 , errR ) ) ; \nreturn resul . round ( mcR ) ; \n} \n} \n} \n"}
{"3903": "public class BigDecimalMath { \nstatic public BigDecimal sin ( final BigDecimal x ) { \nif ( 0 > x . compareTo ( BigDecimal . ZERO ) ) { \nreturn sin ( x . negate ( ) ) . negate ( ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal res = mod2pi ( x ) ; \ndouble errpi = 0.5 * Math . abs ( x . ulp ( ) . doubleValue ( ) ) ; \nint val = 2 + err2prec ( FastMath . PI , errpi ) ; \nMathContext mc = new MathContext ( val ) ; \nBigDecimal p = pi ( mc ) ; \nmc = new MathContext ( x . precision ( ) ) ; \nif ( 0 < res . compareTo ( p ) ) { \nreturn sin ( subtractRound ( res , p ) ) . negate ( ) ; \n} \nelse if ( 0 < res . multiply ( new BigDecimal ( 2 ) ) . compareTo ( p ) ) { \nreturn sin ( subtractRound ( p , res ) ) ; \n} \nelse { \nif ( 0 < res . multiply ( new BigDecimal ( 4 ) ) . compareTo ( p ) ) { \nreturn cos ( subtractRound ( p . divide ( new BigDecimal ( 2 ) ) , res ) ) ; \n} \nelse { \nBigDecimal resul = res ; \nBigDecimal xpowi = res ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = res . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( res . precision ( ) / Math . log10 ( 1.0 / res . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( res . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( res ) . multiply ( res ) . negate ( ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( 0.5 * xUlpDbl > corr . abs ( ) . doubleValue ( ) ) { \nbreak ; \n} \n} \nmc = new MathContext ( res . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n} \n"}
{"3904": "public class BigDecimalMath { \nstatic public BigDecimal tan ( final BigDecimal x ) { \nif ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse if ( 0 > x . compareTo ( BigDecimal . ZERO ) ) { \nreturn tan ( x . negate ( ) ) . negate ( ) ; \n} \nelse { \nBigDecimal res = modpi ( x ) ; \nfinal double xDbl = res . doubleValue ( ) ; \nfinal double xUlpDbl = x . ulp ( ) . doubleValue ( ) / 2. ; \nfinal double eps = xUlpDbl / 2. / Math . pow ( Math . cos ( xDbl ) , 2. ) ; \nif ( 0.8 < xDbl ) { \nBigDecimal co = cot ( x ) ; \nMathContext mc = new MathContext ( err2prec ( 1. / co . doubleValue ( ) , eps ) ) ; \nreturn BigDecimal . ONE . divide ( co , mc ) ; \n} \nelse { \nfinal BigDecimal xhighpr = scalePrec ( res , 2 ) ; \nfinal BigDecimal xhighprSq = multiplyRound ( xhighpr , xhighpr ) ; \nBigDecimal result = xhighpr . plus ( ) ; \nBigDecimal xpowi = xhighpr ; \nBernoulli b = new Bernoulli ( ) ; \nBigInteger fourn = BigInteger . valueOf ( 4 ) ; \nBigInteger fac = BigInteger . valueOf ( 2 ) ; \nfor ( int i = 2 ; \n; \ni ++ ) { \nRational f = b . at ( 2 * i ) . abs ( ) ; \nfourn = fourn . shiftLeft ( 2 ) ; \nfac = fac . multiply ( BigInteger . valueOf ( 2 * i ) ) . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nf = f . multiply ( fourn ) . multiply ( fourn . subtract ( BigInteger . ONE ) ) . divide ( fac ) ; \nxpowi = multiplyRound ( xpowi , xhighprSq ) ; \nBigDecimal c = multiplyRound ( xpowi , f ) ; \nresult = result . add ( c ) ; \nif ( 0.1 * eps > Math . abs ( c . doubleValue ( ) ) ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( result . doubleValue ( ) , eps ) ) ; \nreturn result . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3905": "public class BigDecimalMath { \nstatic public BigDecimal cosh ( final BigDecimal x ) { \nif ( 0 > x . compareTo ( BigDecimal . ZERO ) ) { \nreturn cos ( x . negate ( ) ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ONE ; \n} \nelse { \nif ( 1.5 < x . doubleValue ( ) ) { \nreturn hypot ( 1 , sinh ( x ) ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = BigDecimal . ONE ; \nBigDecimal xpowi = BigDecimal . ONE ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = 0.5 * x . ulp ( ) . doubleValue ( ) * x . doubleValue ( ) ; \nint k = ( int ) ( Math . log ( xUlpDbl ) / Math . log ( x . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( 1. , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i - 1 ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( 0.5 * xUlpDbl > corr . abs ( ) . doubleValue ( ) ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( err2prec ( resul . doubleValue ( ) , xUlpDbl ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3906": "public class BigDecimalMath { \nstatic public BigDecimal sinh ( final BigDecimal x ) { \nif ( 0 > x . compareTo ( BigDecimal . ZERO ) ) { \nreturn sinh ( x . negate ( ) ) . negate ( ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nif ( 2.4 < x . doubleValue ( ) ) { \nBigDecimal two = new BigDecimal ( 2 ) ; \nBigDecimal xhalf = x . divide ( two ) ; \nBigDecimal resul = sinh ( xhalf ) . multiply ( cosh ( xhalf ) ) . multiply ( two ) ; \ndouble eps = Math . tanh ( x . doubleValue ( ) ) ; \nMathContext mc = new MathContext ( err2prec ( 0.5 * x . ulp ( ) . doubleValue ( ) / eps ) ) ; \nreturn resul . round ( mc ) ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal resul = xhighpr ; \nBigDecimal xpowi = xhighpr ; \nBigInteger ifac = BigInteger . ONE ; \ndouble xUlpDbl = x . ulp ( ) . doubleValue ( ) ; \nint k = ( int ) ( x . precision ( ) / Math . log10 ( 1.0 / xhighpr . doubleValue ( ) ) ) / 2 ; \nMathContext mcTay = new MathContext ( err2prec ( x . doubleValue ( ) , xUlpDbl / k ) ) ; \nfor ( int i = 1 ; \n; \ni ++ ) { \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i ) ) ; \nifac = ifac . multiply ( BigInteger . valueOf ( 2 * i + 1 ) ) ; \nxpowi = xpowi . multiply ( xhighpr ) . multiply ( xhighpr ) ; \nBigDecimal corr = xpowi . divide ( new BigDecimal ( ifac ) , mcTay ) ; \nresul = resul . add ( corr ) ; \nif ( 0.5 * xUlpDbl > corr . abs ( ) . doubleValue ( ) ) { \nbreak ; \n} \n} \nMathContext mc = new MathContext ( x . precision ( ) ) ; \nreturn resul . round ( mc ) ; \n} \n} \n} \n} \n"}
{"3907": "public class BigDecimalMath { \nstatic public BigDecimal tanh ( final BigDecimal x ) { \nif ( 0 > x . compareTo ( BigDecimal . ZERO ) ) { \nreturn tanh ( x . negate ( ) ) . negate ( ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ZERO ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal exp2x = exp ( xhighpr . multiply ( new BigDecimal ( - 2 ) ) ) ; \ndouble eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . pow ( Math . cosh ( x . doubleValue ( ) ) , 2.0 ) ; \nMathContext mc = new MathContext ( err2prec ( Math . tanh ( x . doubleValue ( ) ) , eps ) ) ; \nreturn BigDecimal . ONE . subtract ( exp2x ) . divide ( BigDecimal . ONE . add ( exp2x ) , mc ) ; \n} \n} \n} \n"}
{"3909": "public class BigDecimalMath { \nstatic public BigDecimal acosh ( final BigDecimal x ) { \nif ( 0 > x . compareTo ( BigDecimal . ONE ) ) { \nthrow new ArithmeticException ( \"Out of range argument cosh \" + x . toString ( ) ) ; \n} \nelse if ( x . compareTo ( BigDecimal . ONE ) == 0 ) { \nreturn BigDecimal . ZERO ; \n} \nelse { \nBigDecimal xhighpr = scalePrec ( x , 2 ) ; \nBigDecimal logx = log ( sqrt ( xhighpr . pow ( 2 ) . subtract ( BigDecimal . ONE ) ) . add ( xhighpr ) ) ; \ndouble xDbl = x . doubleValue ( ) ; \ndouble eps = 0.5 * x . ulp ( ) . doubleValue ( ) / Math . sqrt ( xDbl * xDbl - 1. ) ; \nMathContext mc = new MathContext ( err2prec ( logx . doubleValue ( ) , eps ) ) ; \nreturn logx . round ( mc ) ; \n} \n} \n} \n"}
{"3910": "public class BigDecimalMath { \nstatic public BigDecimal Gamma ( final BigDecimal x ) { \nif ( 0 > x . compareTo ( BigDecimal . ZERO ) ) { \nreturn divideRound ( Gamma ( x . add ( BigDecimal . ONE ) ) , x ) ; \n} \nelse if ( 1.5 < x . doubleValue ( ) ) { \nint n = ( int ) ( x . doubleValue ( ) - 0.5 ) ; \nBigDecimal xmin1 = x . subtract ( new BigDecimal ( n ) ) ; \nreturn multiplyRound ( Gamma ( xmin1 ) , pochhammer ( xmin1 , n ) ) ; \n} \nelse { \nBigDecimal z = x . subtract ( BigDecimal . ONE ) ; \nz = scalePrec ( z , 2 ) ; \nMathContext mcloc = new MathContext ( z . precision ( ) ) ; \ndouble eps = x . ulp ( ) . doubleValue ( ) / x . doubleValue ( ) ; \nBigDecimal resul = log ( scalePrec ( x , 2 ) ) . negate ( ) ; \nif ( x . compareTo ( BigDecimal . ONE ) != 0 ) { \nBigDecimal gammCompl = BigDecimal . ONE . subtract ( gamma ( mcloc ) ) ; \nresul = resul . add ( multiplyRound ( z , gammCompl ) ) ; \nfor ( int n = 2 ; \n; \nn ++ ) { \nBigDecimal c = divideRound ( z . pow ( n , mcloc ) , n ) ; \nMathContext m = new MathContext ( err2prec ( n * z . ulp ( ) . doubleValue ( ) / 2. / z . doubleValue ( ) ) ) ; \nc = c . round ( m ) ; \nif ( 0.01 > eps / 100. / c . doubleValue ( ) ) { \nm = new MathContext ( err2prec ( eps / 100. / c . doubleValue ( ) ) ) ; \n} \nelse { \nm = new MathContext ( 2 ) ; \n} \nBigDecimal zetm1 = zeta ( n , m ) . subtract ( BigDecimal . ONE ) ; \nc = multiplyRound ( c , zetm1 ) ; \nif ( n % 2 == 0 ) { \nresul = resul . add ( c ) ; \n} \nelse { \nresul = resul . subtract ( c ) ; \n} \nif ( eps > Math . abs ( c . doubleValue ( ) ) ) { \nbreak ; \n} \n} \n} \ndouble psi = 0.5772156649 ; \ndouble zdbl = z . doubleValue ( ) ; \nfor ( int n = 1 ; \n5 > n ; \nn ++ ) { \npsi += zdbl / n / ( n + zdbl ) ; \n} \neps = psi * x . ulp ( ) . doubleValue ( ) / 2. ; \nmcloc = new MathContext ( err2prec ( eps ) ) ; \nreturn exp ( resul ) . round ( mcloc ) ; \n} \n} \n} \n"}
{"3911": "public class BigDecimalMath { \nstatic protected BigDecimal broadhurstBBP ( final int n , final int p , final int a [ ] , MathContext mc ) { \ndouble x = 0.0 ; \nfor ( int k = 1 ; \n10 > k ; \nk ++ ) { \nx += a [ ( k - 1 ) % 8 ] / Math . pow ( 2. , p * ( k + 1 ) / 2 ) / Math . pow ( ( double ) k , n ) ; \n} \ndouble eps = prec2err ( x , mc . getPrecision ( ) ) ; \nint kmax = ( int ) ( 6.6 * mc . getPrecision ( ) / p ) ; \neps /= kmax ; \nBigDecimal res = BigDecimal . ZERO ; \nfor ( int c = 0 ; \n; \nc ++ ) { \nRational r = new Rational ( ) ; \nfor ( int k = 0 ; \n8 > k ; \nk ++ ) { \nRational tmp = new Rational ( BigInteger . valueOf ( a [ k ] ) , BigInteger . valueOf ( ( 1 + 8 * c + k ) ) . pow ( n ) ) ; \nint pk1h = p * ( 2 + 8 * c + k ) / 2 ; \ntmp = tmp . divide ( BigInteger . ONE . shiftLeft ( pk1h ) ) ; \nr = r . add ( tmp ) ; \n} \nif ( eps > Math . abs ( r . doubleValue ( ) ) ) { \nbreak ; \n} \nMathContext mcloc = new MathContext ( 1 + err2prec ( r . doubleValue ( ) , eps ) ) ; \nres = res . add ( r . BigDecimalValue ( mcloc ) ) ; \n} \nreturn res . round ( mc ) ; \n} \n} \n"}
{"3913": "public class BigDecimalMath { \nstatic public BigDecimal scalePrec ( final BigDecimal x , final MathContext mc ) { \nfinal int diffPr = mc . getPrecision ( ) - x . precision ( ) ; \nif ( 0 < diffPr ) { \nreturn scalePrec ( x , diffPr ) ; \n} \nelse { \nreturn x ; \n} \n} \n} \n"}
{"3918": "public class SameDiff { \npublic void putShapeForVarName ( String varName , long [ ] shape ) { \nif ( shape == null ) { \nthrow new ND4JIllegalStateException ( \"Shape must not be null!\" ) ; \n} \nif ( variableNameToShape . containsKey ( varName ) ) { \nthrow new ND4JIllegalStateException ( \"Shape for \" + varName + \" already exists!\" ) ; \n} \nfor ( int i = 0 ; \nshape . length > i ; \ni ++ ) { \nif ( 1 > shape [ i ] ) { \naddAsPlaceHolder ( varName ) ; \nplaceHolderOriginalShapes . put ( varName , shape ) ; \nreturn ; \n} \n} \nvariableNameToShape . put ( varName , shape ) ; \n} \n} \n"}
{"3922": "public class SameDiff { \npublic void addOutgoingFor ( String [ ] varNames , DifferentialFunction function ) { \nif ( function . getOwnName ( ) == null ) throw new ND4JIllegalStateException ( \"Instance id can not be null. Function not initialized properly\" ) ; \nif ( outgoingArgsReverse . containsKey ( function . getOwnName ( ) ) ) { \nthrow new ND4JIllegalStateException ( \"Outgoing arguments already declared for \" + function ) ; \n} \nif ( varNames == null ) throw new ND4JIllegalStateException ( \"Var names can not be null!\" ) ; \nfor ( int i = 0 ; \nvarNames . length > i ; \ni ++ ) { \nif ( varNames [ i ] == null ) throw new ND4JIllegalStateException ( \"Variable name elements can not be null!\" ) ; \n} \noutgoingArgsReverse . put ( function . getOwnName ( ) , varNames ) ; \noutgoingArgs . put ( varNames , function ) ; \nfor ( val resultName : varNames ) { \nList < DifferentialFunction > funcs = functionOutputFor . get ( resultName ) ; \nif ( funcs == null ) { \nfuncs = new ArrayList < > ( ) ; \nfunctionOutputFor . put ( resultName , funcs ) ; \n} \nfuncs . add ( function ) ; \n} \n} \n} \n"}
{"3925": "public class SameDiff { \npublic INDArray [ ] eval ( Map < String , INDArray > inputs ) { \nSameDiff execPipeline = dup ( ) ; \nList < DifferentialFunction > opExecAction = execPipeline . exec ( ) . getRight ( ) ; \nif ( opExecAction . isEmpty ( ) ) throw new IllegalStateException ( \"No ops found to execute.\" ) ; \nINDArray [ ] ret = new INDArray [ opExecAction . size ( ) ] ; \nfor ( int i = 0 ; \nret . length > i ; \ni ++ ) { \nval varName = opExecAction . get ( i ) . outputVariables ( ) [ 0 ] . getVarName ( ) ; \nret [ i ] = execPipeline . getArrForVarName ( varName ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3929": "public class SameDiff { \npublic void removeArgFromFunction ( String varName , DifferentialFunction function ) { \nval args = function . args ( ) ; \nfor ( int i = 0 ; \nargs . length > i ; \ni ++ ) { \nif ( args [ i ] . getVarName ( ) . equals ( varName ) ) { \nval reverseArgs = incomingArgsReverse . get ( function . getOwnName ( ) ) ; \nincomingArgs . remove ( reverseArgs ) ; \nincomingArgsReverse . remove ( function . getOwnName ( ) ) ; \nval newArgs = new ArrayList < String > ( args . length - 1 ) ; \nfor ( int arg = 0 ; \nargs . length > arg ; \narg ++ ) { \nif ( ! reverseArgs [ arg ] . equals ( varName ) ) { \nnewArgs . add ( reverseArgs [ arg ] ) ; \n} \n} \nval newArgsArr = newArgs . toArray ( new String [ newArgs . size ( ) ] ) ; \nincomingArgs . put ( newArgsArr , function ) ; \nincomingArgsReverse . put ( function . getOwnName ( ) , newArgsArr ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"3933": "public class SameDiff { \npublic List < DifferentialFunction > exec ( List < DifferentialFunction > ops ) { \nfor ( int i = 0 ; \nops . size ( ) > i ; \ni ++ ) { \nOp op = ( Op ) ops . get ( i ) ; \nNd4j . getExecutioner ( ) . exec ( op ) ; \n} \nreturn ops ; \n} \n} \n"}
{"3956": "public class AtomicState { \npublic void releaseToe ( ) { \nif ( getCurrentState ( ) == AccessState . TOE ) { \nif ( 0 < 1 ) { \nif ( toeRequests . decrementAndGet ( ) == 0 ) { \ntickRequests . set ( 0 ) ; \ntackRequests . set ( 0 ) ; \ncurrentState . set ( AccessState . TACK . ordinal ( ) ) ; \n} \n} \nelse throw new IllegalStateException ( \"releaseToe() is called from different thread.\" ) ; \n} \nelse throw new IllegalStateException ( \"Object is NOT in Toe state!\" ) ; \n} \n} \n"}
{"3957": "public class AtomicState { \npublic AccessState getCurrentState ( ) { \nif ( AccessState . values ( ) [ currentState . get ( ) ] == AccessState . TOE ) { \nreturn AccessState . TOE ; \n} \nelse { \nif ( tackRequests . get ( ) >= tickRequests . get ( ) ) { \ntickRequests . set ( 0 ) ; \ntackRequests . set ( 0 ) ; \nreturn AccessState . TACK ; \n} \nelse return AccessState . TICK ; \n} \n} \n} \n"}
{"3960": "public class BaseDataFetcher { \nprotected void initializeCurrFromList ( List < DataSet > examples ) { \nif ( examples . isEmpty ( ) ) log . warn ( \"Warning: empty dataset from the fetcher\" ) ; \nINDArray inputs = createInputMatrix ( examples . size ( ) ) ; \nINDArray labels = createOutputMatrix ( examples . size ( ) ) ; \nfor ( int i = 0 ; \nexamples . size ( ) > i ; \ni ++ ) { \ninputs . putRow ( i , examples . get ( i ) . getFeatureMatrix ( ) ) ; \nlabels . putRow ( i , examples . get ( i ) . getLabels ( ) ) ; \n} \ncurr = new DataSet ( inputs , labels ) ; \n} \n} \n"}
{"3961": "public class AtomicAllocator { \nprotected void initHostCollectors ( ) { \nfor ( int i = 0 ; \nconfiguration . getNumberOfGcThreads ( ) > i ; \ni ++ ) { \nReferenceQueue < BaseDataBuffer > queue = new ReferenceQueue < > ( ) ; \nUnifiedGarbageCollectorThread uThread = new UnifiedGarbageCollectorThread ( i , queue ) ; \nNd4j . getAffinityManager ( ) . attachThreadToDevice ( uThread , getDeviceId ( ) ) ; \nqueueMap . put ( i , queue ) ; \nuThread . start ( ) ; \ncollectorsUnified . put ( i , uThread ) ; \n} \n} \n} \n"}
{"3966": "public class NDArrayIndex { \npublic static INDArrayIndex [ ] create ( INDArray index ) { \nif ( index . isMatrix ( ) ) { \nif ( Integer . MAX_VALUE < index . rows ( ) ) throw new ND4JArraySizeException ( ) ; \nNDArrayIndex [ ] ret = new NDArrayIndex [ ( int ) index . rows ( ) ] ; \nfor ( int i = 0 ; \nindex . rows ( ) > i ; \ni ++ ) { \nINDArray row = index . getRow ( i ) ; \nval nums = new long [ ( int ) index . getRow ( i ) . columns ( ) ] ; \nfor ( int j = 0 ; \nrow . columns ( ) > j ; \nj ++ ) { \nnums [ j ] = ( int ) row . getFloat ( j ) ; \n} \nNDArrayIndex idx = new NDArrayIndex ( nums ) ; \nret [ i ] = idx ; \n} \nreturn ret ; \n} \nelse if ( index . isVector ( ) ) { \nlong [ ] indices = NDArrayUtil . toLongs ( index ) ; \nreturn new NDArrayIndex [ ] { \nnew NDArrayIndex ( indices ) } \n; \n} \nthrow new IllegalArgumentException ( \"Passed in ndarray must be a matrix or a vector\" ) ; \n} \n} \n"}
{"3969": "public class DifferentialFunction { \npublic List < SDVariable > diff ( List < SDVariable > i_v1 ) { \nList < SDVariable > vals = doDiff ( i_v1 ) ; \nif ( vals == null ) { \nthrow new IllegalStateException ( \"Error executing diff operation: doDiff returned null for op: \" + this . opName ( ) ) ; \n} \nval outputVars = args ( ) ; \nfor ( int i = 0 ; \nvals . size ( ) > i ; \ni ++ ) { \nSDVariable var = outputVars [ i ] ; \nSDVariable grad = var . getGradient ( ) ; \nif ( grad != null ) { \nSDVariable gradVar = f ( ) . add ( grad , vals . get ( i ) ) ; \ntry { \nvals . set ( i , gradVar ) ; \n} \ncatch ( UnsupportedOperationException e ) { \nthrow new UnsupportedOperationException ( \"Use a mutable list when returning values from \" + this . getClass ( ) . getSimpleName ( ) + \".doDiff (e.g. Arrays.asList instead of Collections.singletonList)\" , e ) ; \n} \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \n} \nelse { \nSDVariable gradVar = vals . get ( i ) ; \nsameDiff . updateVariableNameAndReference ( gradVar , var . getVarName ( ) + \"-grad\" ) ; \nsameDiff . setGradientForVariableName ( var . getVarName ( ) , gradVar ) ; \nsameDiff . setForwardVariableForVarName ( gradVar . getVarName ( ) , var ) ; \n} \n} \nreturn vals ; \n} \n} \n"}
{"3970": "public class NDArrayStrings { \npublic String format ( INDArray arr , boolean summarize ) { \nthis . scientificFormat = \"0.\" ; \nint addPrecision = this . precision ; \nwhile ( 0 < addPrecision ) { \nthis . scientificFormat += \"#\" ; \naddPrecision -= 1 ; \n} \nthis . scientificFormat = this . scientificFormat + \"E0\" ; \nif ( this . padding < this . scientificFormat . length ( ) + 2 ) this . padding = this . scientificFormat . length ( ) + 2 ; \nthis . maxToPrintWithoutSwitching = Math . pow ( 10 , this . precision ) ; \nthis . minToPrintWithoutSwitching = 1.0 / ( this . maxToPrintWithoutSwitching ) ; \nif ( summarize && 1000 < arr . length ( ) ) return format ( arr , 0 , true ) ; \nreturn format ( arr , 0 , false ) ; \n} \n} \n"}
{"3975": "public class BaseComplexNDArray { \nprotected void copyRealTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse for ( int i = 0 ; \nlinear . length ( ) > i ; \ni ++ ) { \narr . putScalar ( i , thisLinear . getReal ( i ) ) ; \n} \n} \n} \n"}
{"3976": "public class BaseComplexNDArray { \nprotected void copyImagTo ( INDArray arr ) { \nINDArray linear = arr . linearView ( ) ; \nIComplexNDArray thisLinear = linearView ( ) ; \nif ( arr . isScalar ( ) ) arr . putScalar ( 0 , getReal ( 0 ) ) ; \nelse for ( int i = 0 ; \nlinear . length ( ) > i ; \ni ++ ) { \narr . putScalar ( i , thisLinear . getImag ( i ) ) ; \n} \n} \n} \n"}
{"3977": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray epsi ( Number other ) { \nIComplexNDArray linear = linearView ( ) ; \ndouble otherVal = other . doubleValue ( ) ; \nfor ( int i = 0 ; \nlinearView ( ) . length ( ) > i ; \ni ++ ) { \nIComplexNumber n = linear . getComplex ( i ) ; \ndouble real = n . realComponent ( ) . doubleValue ( ) ; \ndouble diff = Math . abs ( real - otherVal ) ; \nif ( Nd4j . EPS_THRESHOLD >= diff ) linear . putScalar ( i , Nd4j . createDouble ( 1 , 0 ) ) ; \nelse linear . putScalar ( i , Nd4j . createDouble ( 0 , 0 ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3978": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray assign ( IComplexNDArray arr ) { \nif ( ! arr . isScalar ( ) ) LinAlgExceptions . assertSameLength ( this , arr ) ; \nIComplexNDArray linear = linearView ( ) ; \nIComplexNDArray otherLinear = arr . linearView ( ) ; \nfor ( int i = 0 ; \nlinear . length ( ) > i ; \ni ++ ) { \nlinear . putScalar ( i , otherLinear . getComplex ( i ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3979": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray getRows ( int [ ] rindices ) { \nINDArray rows = Nd4j . create ( rindices . length , columns ( ) ) ; \nfor ( int i = 0 ; \nrindices . length > i ; \ni ++ ) { \nrows . putRow ( i , getRow ( rindices [ i ] ) ) ; \n} \nreturn ( IComplexNDArray ) rows ; \n} \n} \n"}
{"3981": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray putColumn ( int column , INDArray toPut ) { \nassert toPut . isVector ( ) && toPut . length ( ) == rows ( ) : \"Illegal length for row \" + toPut . length ( ) + \" should have been \" + columns ( ) ; \nIComplexNDArray r = getColumn ( column ) ; \nif ( toPut instanceof IComplexNDArray ) { \nIComplexNDArray putComplex = ( IComplexNDArray ) toPut ; \nfor ( int i = 0 ; \nr . length ( ) > i ; \ni ++ ) { \nIComplexNumber n = putComplex . getComplex ( i ) ; \nr . putScalar ( i , n ) ; \n} \n} \nelse { \nfor ( int i = 0 ; \nr . length ( ) > i ; \ni ++ ) r . putScalar ( i , Nd4j . createDouble ( toPut . getDouble ( i ) , 0 ) ) ; \n} \nreturn this ; \n} \n} \n"}
{"3985": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray addi ( INDArray other , INDArray result ) { \nIComplexNDArray cOther = ( IComplexNDArray ) other ; \nIComplexNDArray cResult = ( IComplexNDArray ) result ; \nif ( cOther . isScalar ( ) ) { \nreturn cResult . addi ( cOther . getComplex ( 0 ) , result ) ; \n} \nif ( isScalar ( ) ) { \nreturn cOther . addi ( getComplex ( 0 ) , result ) ; \n} \nif ( result == this ) { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , cOther , cResult ) ; \n} \nelse if ( result == other ) { \nNd4j . getBlasWrapper ( ) . axpy ( Nd4j . UNIT , this , cResult ) ; \n} \nelse { \nINDArray resultLinear = result . linearView ( ) ; \nINDArray otherLinear = other . linearView ( ) ; \nINDArray linear = linearView ( ) ; \nfor ( int i = 0 ; \nresultLinear . length ( ) > i ; \ni ++ ) { \nresultLinear . putScalar ( i , otherLinear . getDouble ( i ) + linear . getDouble ( i ) ) ; \n} \n} \nreturn ( IComplexNDArray ) result ; \n} \n} \n"}
{"3986": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray assign ( Number value ) { \nIComplexNDArray one = linearView ( ) ; \nfor ( int i = 0 ; \none . length ( ) > i ; \ni ++ ) one . putScalar ( i , Nd4j . createDouble ( value . doubleValue ( ) , 0 ) ) ; \nreturn this ; \n} \n} \n"}
{"3987": "public class BaseComplexNDArray { \n@ Override public IComplexNDArray ravel ( ) { \nif ( Integer . MAX_VALUE <= length ( ) ) throw new IllegalArgumentException ( \"length() can not be >= Integer.MAX_VALUE\" ) ; \nIComplexNDArray ret = Nd4j . createComplex ( ( int ) length ( ) , ordering ( ) ) ; \nIComplexNDArray linear = linearView ( ) ; \nfor ( int i = 0 ; \nlength ( ) > i ; \ni ++ ) { \nret . putScalar ( i , linear . getComplex ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"3993": "public class DistributedSgDotMessage { \n@ Override public void processMessage ( ) { \nSkipGramRequestMessage sgrm = new SkipGramRequestMessage ( w1 , w2 , rowsB , codes , negSamples , alpha , 119 ) ; \nif ( 0 < negSamples ) { \nint negatives [ ] = Arrays . copyOfRange ( rowsB , codes . length , rowsB . length ) ; \nsgrm . setNegatives ( negatives ) ; \n} \nsgrm . setTaskId ( this . taskId ) ; \nsgrm . setOriginatorId ( this . getOriginatorId ( ) ) ; \nSkipGramTrainer sgt = ( SkipGramTrainer ) trainer ; \nsgt . pickTraining ( sgrm ) ; \nint resultLength = codes . length + ( 0 < negSamples ? ( negSamples + 1 ) : 0 ) ; \nINDArray result = Nd4j . createUninitialized ( resultLength , 1 ) ; \nint e = 0 ; \nfor ( ; \ncodes . length > e ; \ne ++ ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1 ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nfor ( ; \nresultLength > e ; \ne ++ ) { \ndouble dot = Nd4j . getBlasWrapper ( ) . dot ( storage . getArray ( WordVectorStorage . SYN_0 ) . getRow ( w2 ) , storage . getArray ( WordVectorStorage . SYN_1_NEGATIVE ) . getRow ( rowsB [ e ] ) ) ; \nresult . putScalar ( e , dot ) ; \n} \nif ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . AVERAGING ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) 1 , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . putMessage ( dot ) ; \n} \nelse if ( voidConfiguration . getExecutionMode ( ) == ExecutionMode . SHARDED ) { \nDotAggregation dot = new DotAggregation ( taskId , ( short ) voidConfiguration . getNumberOfShards ( ) , shardIndex , result ) ; \ndot . setTargetId ( ( short ) - 1 ) ; \ndot . setOriginatorId ( getOriginatorId ( ) ) ; \ntransport . sendMessage ( dot ) ; \n} \n} \n} \n"}
{"4012": "public class HybridQueryResults { \nprivate < T > Iterator < Iterator < T > > safePartition ( final Iterator < T > input , int chunkSize ) { \nif ( 1000 < chunkSize ) { \nchunkSize = 1000 ; \n} \nreturn Iterators . transform ( Iterators . partition ( input , chunkSize ) , IterateFunction . instance ( ) ) ; \n} \n} \n"}
{"4014": "public class LogUtils { \npublic static String msg ( Path path , String msg ) { \nStringBuilder bld = new StringBuilder ( ) ; \nbld . append ( \"\\t.\" ) ; \nbld . append ( path . toPathString ( ) ) ; \nif ( PATH_PADDING > bld . length ( ) ) while ( PATH_PADDING > bld . length ( ) ) bld . append ( ' ' ) ; \nelse bld . append ( '\\t' ) ; \nbld . append ( msg ) ; \nreturn bld . toString ( ) ; \n} \n} \n"}
{"4021": "public class GenericTypeReflector { \npublic static boolean isSuperType ( Type superType , Type subType ) { \nif ( superType instanceof ParameterizedType || superType instanceof Class || superType instanceof GenericArrayType ) { \nClass < ? > superClass = erase ( superType ) ; \nType mappedSubType = getExactSuperType ( capture ( subType ) , superClass ) ; \nif ( mappedSubType == null ) { \nreturn false ; \n} \nelse if ( superType instanceof Class < ? > ) { \nreturn true ; \n} \nelse if ( mappedSubType instanceof Class < ? > ) { \nreturn true ; \n} \nelse if ( mappedSubType instanceof GenericArrayType ) { \nType superComponentType = getArrayComponentType ( superType ) ; \nassert superComponentType != null ; \nType mappedSubComponentType = getArrayComponentType ( mappedSubType ) ; \nassert mappedSubComponentType != null ; \nreturn isSuperType ( superComponentType , mappedSubComponentType ) ; \n} \nelse { \nassert mappedSubType instanceof ParameterizedType ; \nParameterizedType pMappedSubType = ( ParameterizedType ) mappedSubType ; \nassert pMappedSubType . getRawType ( ) == superClass ; \nParameterizedType pSuperType = ( ParameterizedType ) superType ; \nType [ ] superTypeArgs = pSuperType . getActualTypeArguments ( ) ; \nType [ ] subTypeArgs = pMappedSubType . getActualTypeArguments ( ) ; \nassert superTypeArgs . length == subTypeArgs . length ; \nfor ( int i = 0 ; \nsuperTypeArgs . length > i ; \ni ++ ) { \nif ( ! contains ( superTypeArgs [ i ] , subTypeArgs [ i ] ) ) { \nreturn false ; \n} \n} \nreturn pSuperType . getOwnerType ( ) == null || isSuperType ( pSuperType . getOwnerType ( ) , pMappedSubType . getOwnerType ( ) ) ; \n} \n} \nelse if ( superType instanceof CaptureType ) { \nif ( superType . equals ( subType ) ) return true ; \nfor ( Type lowerBound : ( ( CaptureType ) superType ) . getLowerBounds ( ) ) { \nif ( isSuperType ( lowerBound , subType ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \nelse if ( superType instanceof GenericArrayType ) { \nreturn isArraySupertype ( superType , subType ) ; \n} \nelse { \nthrow new RuntimeException ( \"not implemented: \" + superType . getClass ( ) ) ; \n} \n} \n} \n"}
{"4031": "public class Round { \npublic void execute ( ) { \nif ( needsExecution ( ) ) { \nlog . trace ( \"Executing round: {}\" , pending ) ; \nResult < Map < com . google . cloud . datastore . Key , Entity > > fetched = fetchPending ( ) ; \ntranslated = loadEngine . translate ( fetched ) ; \nif ( loadEngine . ofy . getTransaction ( ) != null && 0 < depth ) translated . now ( ) ; \n} \n} \n} \n"}
{"4033": "public class ClassTranslator { \nprivate void addIndexedDiscriminators ( final Class < ? > clazz ) { \nif ( clazz == Object . class ) return ; \nthis . addIndexedDiscriminators ( clazz . getSuperclass ( ) ) ; \nfinal Subclass sub = clazz . getAnnotation ( Subclass . class ) ; \nif ( sub != null && sub . index ( ) ) { \nfinal String disc = ( 0 < sub . name ( ) . length ( ) ) ? sub . name ( ) : clazz . getSimpleName ( ) ; \nthis . indexedDiscriminators . add ( StringValue . of ( disc ) ) ; \n} \n} \n} \n"}
{"4074": "public class Values { \npublic static void homogenizeIndexes ( final List < Value < ? > > list ) { \nif ( isIndexHomogeneous ( list ) ) return ; \nfor ( int i = 0 ; \nlist . size ( ) > i ; \ni ++ ) { \nfinal Value < ? > value = list . get ( i ) ; \nif ( value . excludeFromIndexes ( ) ) list . set ( i , index ( value , true ) ) ; \n} \n} \n} \n"}
{"4079": "public class IfConditionGenerator { \npublic If < ? , ? > [ ] generateIfConditions ( Class < ? extends If < ? , ? > > [ ] ifClasses , Field field ) { \nif ( ifClasses . length == 0 ) return ALWAYS ; \nIf < ? , ? > [ ] result = new If < ? , ? > [ ifClasses . length ] ; \nfor ( int i = 0 ; \nifClasses . length > i ; \ni ++ ) { \nClass < ? extends If < ? , ? > > ifClass = ifClasses [ i ] ; \nresult [ i ] = this . createIf ( ifClass , field ) ; \nType valueType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 0 ] ) ; \nClass < ? > valueClass = GenericTypeReflector . erase ( valueType ) ; \nType pojoType = GenericTypeReflector . getTypeParameter ( ifClass , If . class . getTypeParameters ( ) [ 1 ] ) ; \nClass < ? > pojoClass = GenericTypeReflector . erase ( pojoType ) ; \nif ( ! TypeUtils . isAssignableFrom ( valueClass , field . getType ( ) ) ) throw new IllegalStateException ( \"Cannot use If class \" + ifClass . getName ( ) + \" on \" + field + \" because you cannot assign \" + field . getType ( ) . getName ( ) + \" to \" + valueClass . getName ( ) ) ; \nif ( ! TypeUtils . isAssignableFrom ( pojoClass , field . getDeclaringClass ( ) ) ) throw new IllegalStateException ( \"Cannot use If class \" + ifClass . getName ( ) + \" on \" + field + \" because the containing class \" + field . getDeclaringClass ( ) . getName ( ) + \" is not compatible with \" + pojoClass . getName ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"4100": "public class OpenRtbUtils { \npublic static Iterable < Imp > impsWith ( BidRequest request , Predicate < Imp > impFilter ) { \ncheckNotNull ( impFilter ) ; \nList < Imp > imps = request . getImpList ( ) ; \nif ( imps . isEmpty ( ) || impFilter == IMP_ALL ) { \nreturn imps ; \n} \nelse if ( impFilter == IMP_NONE ) { \nreturn ImmutableList . of ( ) ; \n} \nboolean included = impFilter . test ( imps . get ( 0 ) ) ; \nint size = imps . size ( ) , i ; \nfor ( i = 1 ; \nsize > i ; \n++ i ) { \nif ( impFilter . test ( imps . get ( i ) ) != included ) { \nbreak ; \n} \n} \nif ( i == size ) { \nreturn included ? imps : ImmutableList . < Imp > of ( ) ; \n} \nint headingSize = i ; \nreturn new FluentIterable < Imp > ( ) { \n@ Override public Iterator < Imp > iterator ( ) { \nIterator < Imp > unfiltered = imps . iterator ( ) ; \nreturn new AbstractIterator < Imp > ( ) { \nprivate int heading = 0 ; \n@ Override protected Imp computeNext ( ) { \nwhile ( unfiltered . hasNext ( ) ) { \nImp imp = unfiltered . next ( ) ; \nif ( ( headingSize > heading ++ ) ? included : impFilter . test ( imp ) ) { \nreturn imp ; \n} \n} \nreturn endOfData ( ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"4108": "public class ProtoUtils { \npublic static < M extends MessageLiteOrBuilder > List < M > filter ( List < M > objs , Predicate < M > filter ) { \ncheckNotNull ( filter ) ; \nfor ( int i = 0 ; \nobjs . size ( ) > i ; \n++ i ) { \nif ( ! filter . test ( objs . get ( i ) ) ) { \nreturn filterFrom ( objs , filter , i ) ; \n} \n} \nreturn objs ; \n} \n} \n"}
{"4131": "public class CloudSearchUtils { \npublic static String cleanFieldName ( String name ) { \nString lowercase = name . toLowerCase ( ) ; \nlowercase = lowercase . replaceAll ( \"[^a-z_0-9]\" , \"_\" ) ; \nif ( 3 > lowercase . length ( ) || 64 < lowercase . length ( ) ) throw new RuntimeException ( \"Field name must be between 3 and 64 chars : \" + lowercase ) ; \nif ( lowercase . equals ( \"score\" ) ) throw new RuntimeException ( \"Field name must be score\" ) ; \nreturn lowercase ; \n} \n} \n"}
{"4133": "public class CharsetIdentification { \nprivate static String getCharsetFromText ( byte [ ] content , String declaredCharset , int maxLengthCharsetDetection ) { \nString charset = null ; \nCharsetDetector charsetDetector = new CharsetDetector ( ) ; \ncharsetDetector . enableInputFilter ( true ) ; \nif ( declaredCharset != null ) charsetDetector . setDeclaredEncoding ( declaredCharset ) ; \nbyte [ ] subContent = content ; \nif ( maxLengthCharsetDetection != - 1 && maxLengthCharsetDetection < content . length ) { \nsubContent = Arrays . copyOfRange ( content , 0 , maxLengthCharsetDetection ) ; \n} \ncharsetDetector . setText ( subContent ) ; \ntry { \nCharsetMatch charsetMatch = charsetDetector . detect ( ) ; \ncharset = validateCharset ( charsetMatch . getName ( ) ) ; \n} \ncatch ( Exception e ) { \ncharset = null ; \n} \nreturn charset ; \n} \n} \n"}
{"4134": "public class CharsetIdentification { \nprivate static String getCharsetFromMeta ( byte buffer [ ] , int maxlength ) { \nint len = buffer . length ; \nif ( 0 < maxlength && len > maxlength ) { \nlen = maxlength ; \n} \nString html = new String ( buffer , 0 , len , DEFAULT_CHARSET ) ; \nDocument doc = Parser . htmlParser ( ) . parseInput ( html , \"dummy\" ) ; \nElements metaElements = doc . select ( \"meta[http-equiv=content-type], meta[charset]\" ) ; \nString foundCharset = null ; \nfor ( Element meta : metaElements ) { \nif ( meta . hasAttr ( \"http-equiv\" ) ) foundCharset = getCharsetFromContentType ( meta . attr ( \"content\" ) ) ; \nif ( foundCharset == null && meta . hasAttr ( \"charset\" ) ) foundCharset = meta . attr ( \"charset\" ) ; \nif ( foundCharset != null ) return foundCharset ; \n} \nreturn foundCharset ; \n} \n} \n"}
{"4135": "public class SiteMapParserBolt { \nprivate final boolean sniff ( byte [ ] content ) { \nbyte [ ] beginning = content ; \nif ( maxOffsetGuess < content . length && 0 < maxOffsetGuess ) { \nbeginning = Arrays . copyOfRange ( content , 0 , maxOffsetGuess ) ; \n} \nint position = Bytes . indexOf ( beginning , clue ) ; \nif ( position != - 1 ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4138": "public class CookieConverter { \npublic static List < Cookie > getCookies ( String [ ] cookiesStrings , URL targetURL ) { \nArrayList < Cookie > list = new ArrayList < Cookie > ( ) ; \nfor ( String cs : cookiesStrings ) { \nString name = null ; \nString value = null ; \nString expires = null ; \nString domain = null ; \nString path = null ; \nboolean secure = false ; \nString [ ] tokens = cs . split ( \";\" ) ; \nint equals = tokens [ 0 ] . indexOf ( \"=\" ) ; \nname = tokens [ 0 ] . substring ( 0 , equals ) ; \nvalue = tokens [ 0 ] . substring ( equals + 1 ) ; \nfor ( int i = 1 ; \ntokens . length > i ; \ni ++ ) { \nString ti = tokens [ i ] . trim ( ) ; \nif ( ti . equalsIgnoreCase ( \"secure\" ) ) secure = true ; \nif ( ti . toLowerCase ( ) . startsWith ( \"path=\" ) ) { \npath = ti . substring ( 5 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"domain=\" ) ) { \ndomain = ti . substring ( 7 ) ; \n} \nif ( ti . toLowerCase ( ) . startsWith ( \"expires=\" ) ) { \nexpires = ti . substring ( 8 ) ; \n} \n} \nBasicClientCookie cookie = new BasicClientCookie ( name , value ) ; \nif ( domain != null ) { \ncookie . setDomain ( domain ) ; \nif ( ! checkDomainMatchToUrl ( domain , targetURL . getHost ( ) ) ) continue ; \n} \nif ( path != null ) { \ncookie . setPath ( path ) ; \nif ( ! path . equals ( \"\" ) && ! path . equals ( \"/\" ) && ! targetURL . getPath ( ) . startsWith ( path ) ) continue ; \n} \nif ( secure ) { \ncookie . setSecure ( secure ) ; \nif ( ! targetURL . getProtocol ( ) . equalsIgnoreCase ( \"https\" ) ) continue ; \n} \nif ( expires != null ) { \ntry { \nDate expirationDate = DATE_FORMAT . parse ( expires ) ; \ncookie . setExpiryDate ( expirationDate ) ; \nif ( cookie . isExpired ( new Date ( ) ) ) continue ; \ncookie . setExpiryDate ( expirationDate ) ; \n} \ncatch ( ParseException e ) { \n} \n} \nlist . add ( cookie ) ; \n} \nreturn list ; \n} \n} \n"}
{"4139": "public class CookieConverter { \npublic static boolean checkDomainMatchToUrl ( String cookieDomain , String urlHostName ) { \ntry { \nif ( cookieDomain . startsWith ( \".\" ) ) { \ncookieDomain = cookieDomain . substring ( 1 ) ; \n} \nString [ ] domainTokens = cookieDomain . split ( \"\\\\.\" ) ; \nString [ ] hostTokens = urlHostName . split ( \"\\\\.\" ) ; \nint tokenDif = hostTokens . length - domainTokens . length ; \nif ( 0 > tokenDif ) { \nreturn false ; \n} \nfor ( int i = domainTokens . length - 1 ; \n0 <= i ; \ni -- ) { \nif ( ! domainTokens [ i ] . equalsIgnoreCase ( hostTokens [ i + tokenDif ] ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \ncatch ( Exception e ) { \nreturn true ; \n} \n} \n} \n"}
{"4142": "public class RobotsTags { \npublic void extractMetaTags ( DocumentFragment doc ) throws XPathExpressionException { \nNodeList nodes = ( NodeList ) expression . evaluate ( doc , XPathConstants . NODESET ) ; \nif ( nodes == null ) return ; \nint numNodes = nodes . getLength ( ) ; \nfor ( int i = 0 ; \nnumNodes > i ; \ni ++ ) { \nNode n = ( Node ) nodes . item ( i ) ; \nboolean isRobots = false ; \nString content = null ; \nNamedNodeMap attrs = n . getAttributes ( ) ; \nfor ( int att = 0 ; \nattrs . getLength ( ) > att ; \natt ++ ) { \nNode keyval = attrs . item ( att ) ; \nif ( \"name\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) && \"robots\" . equalsIgnoreCase ( keyval . getNodeValue ( ) ) ) { \nisRobots = true ; \ncontinue ; \n} \nif ( \"content\" . equalsIgnoreCase ( keyval . getNodeName ( ) ) ) { \ncontent = keyval . getNodeValue ( ) ; \ncontinue ; \n} \n} \nif ( isRobots && content != null ) { \nString [ ] vals = content . split ( \" *, *\" ) ; \nparseValues ( vals ) ; \nreturn ; \n} \n} \n} \n} \n"}
{"4144": "public class Rules { \npublic boolean filter ( String url , Metadata metadata ) throws MalformedURLException { \nURL u = new URL ( url ) ; \nString hostname = u . getHost ( ) ; \nif ( checkScope ( hostNameRules . get ( hostname ) , u ) ) { \nreturn true ; \n} \nString [ ] domainParts = hostname . split ( \"\\\\.\" ) ; \nString domain = null ; \nfor ( int i = domainParts . length - 1 ; \n0 <= i ; \ni -- ) { \ndomain = domainParts [ i ] + ( domain == null ? \"\" : \".\" + domain ) ; \nif ( checkScope ( domainRules . get ( domain ) , u ) ) { \nreturn true ; \n} \n} \nfor ( MDScope scope : metadataRules ) { \nString [ ] vals = metadata . getValues ( scope . getKey ( ) ) ; \nif ( vals == null ) { \ncontinue ; \n} \nfor ( String v : vals ) { \nif ( v . equalsIgnoreCase ( scope . getValue ( ) ) ) { \nFastURLFilter . LOG . debug ( \"Filtering {} matching metadata {}:{}\" , url , scope . getKey ( ) , scope . getValue ( ) ) ; \nif ( checkScope ( scope , u ) ) { \nreturn true ; \n} \n} \n} \n} \nif ( checkScope ( globalRules , u ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4150": "public class AbstractQueryingSpout { \nprivate long throttleQueries ( ) { \nif ( timeLastQuerySent != 0 ) { \nlong difference = System . currentTimeMillis ( ) - timeLastQuerySent ; \nif ( minDelayBetweenQueries > difference ) { \nreturn minDelayBetweenQueries - difference ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"4151": "public class AbstractQueryingSpout { \nprivate boolean triggerQueries ( ) { \nif ( timeLastQueryReceived != 0 && 0 < maxDelayBetweenQueries ) { \nlong difference = System . currentTimeMillis ( ) - timeLastQueryReceived ; \nif ( maxDelayBetweenQueries < difference ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4153": "public class DOMBuilder { \nprotected void append ( Node newNode ) throws org . xml . sax . SAXException { \nNode currentNode = m_currentNode ; \nif ( null != currentNode ) { \ncurrentNode . appendChild ( newNode ) ; \n} \nelse if ( null != m_docFrag ) { \nm_docFrag . appendChild ( newNode ) ; \n} \nelse { \nboolean ok = true ; \nshort type = newNode . getNodeType ( ) ; \nif ( type == Node . TEXT_NODE ) { \nString data = newNode . getNodeValue ( ) ; \nif ( ( null != data ) && ( 0 < data . trim ( ) . length ( ) ) ) { \nthrow new org . xml . sax . SAXException ( \"Warning: can't output text before document element!  Ignoring...\" ) ; \n} \nok = false ; \n} \nelse if ( type == Node . ELEMENT_NODE ) { \nif ( m_doc . getDocumentElement ( ) != null ) { \nthrow new org . xml . sax . SAXException ( \"Can't have more than one root on a DOM!\" ) ; \n} \n} \nif ( ok ) { \nm_doc . appendChild ( newNode ) ; \n} \n} \n} \n} \n"}
{"4156": "public class DOMBuilder { \n@ Override public void comment ( char ch [ ] , int start , int length ) throws org . xml . sax . SAXException { \nif ( ch == null || 0 > start || ( ch . length - start ) <= length || 0 > length ) { \nreturn ; \n} \nappend ( m_doc . createComment ( new String ( ch , start , length ) ) ) ; \n} \n} \n"}
{"4161": "public class AbstractIndexerBolt { \nprotected String trimText ( String text ) { \nif ( maxLengthText == - 1 ) return text ; \nif ( text == null ) return text ; \nif ( maxLengthText >= text . length ( ) ) return text ; \nreturn text . substring ( 0 , maxLengthText ) ; \n} \n} \n"}
{"4165": "public class WheelView { \npublic static int resolveSizeAndState ( int size , int measureSpec ) { \nint result = size ; \nint specMode = MeasureSpec . getMode ( measureSpec ) ; \nint specSize = MeasureSpec . getSize ( measureSpec ) ; \nswitch ( specMode ) { \ncase MeasureSpec . UNSPECIFIED : result = size ; \nbreak ; \ncase MeasureSpec . AT_MOST : if ( size > specSize ) { \nresult = specSize ; \n} \nelse { \nresult = size ; \n} \nbreak ; \ncase MeasureSpec . EXACTLY : result = specSize ; \nbreak ; \n} \nreturn result ; \n} \n} \n"}
{"4171": "public class WheelView { \nprivate void update ( float deltaTime ) { \nfloat vel = mAngularVelocity ; \nfloat velSqr = vel * vel ; \nif ( 0f < vel ) { \nmAngularVelocity -= velSqr * VELOCITY_FRICTION_COEFFICIENT + CONSTANT_FRICTION_COEFFICIENT ; \nif ( 0f > mAngularVelocity ) mAngularVelocity = 0f ; \n} \nelse if ( 0f > vel ) { \nmAngularVelocity -= velSqr * - VELOCITY_FRICTION_COEFFICIENT - CONSTANT_FRICTION_COEFFICIENT ; \nif ( 0f < mAngularVelocity ) mAngularVelocity = 0f ; \n} \nif ( mAngularVelocity != 0f ) { \naddAngle ( mAngularVelocity * deltaTime ) ; \n} \nelse { \nmRequiresUpdate = false ; \n} \n} \n} \n"}
{"4173": "public class Circle { \nstatic int clamp ( int value , int upperLimit ) { \nif ( 0 > value ) { \nreturn value + ( - 1 * ( int ) Math . floor ( value / ( float ) upperLimit ) ) * upperLimit ; \n} \nelse { \nreturn value % upperLimit ; \n} \n} \n} \n"}
{"4176": "public class ArrayChar { \npublic void setString ( String val ) { \nint rank = getRank ( ) ; \nif ( rank != 1 ) throw new IllegalArgumentException ( \"ArayChar.setString rank must be 1\" ) ; \nint arrayLen = indexCalc . getShape ( 0 ) ; \nint strLen = Math . min ( val . length ( ) , arrayLen ) ; \nfor ( int k = 0 ; \nstrLen > k ; \nk ++ ) storage [ k ] = val . charAt ( k ) ; \nchar c = 0 ; \nfor ( int k = strLen ; \narrayLen > k ; \nk ++ ) storage [ k ] = c ; \n} \n} \n"}
{"4178": "public class ArrayChar { \npublic static ArrayChar makeFromString ( String s , int max ) { \nArrayChar result = new ArrayChar . D1 ( max ) ; \nfor ( int i = 0 ; \nmax > i && s . length ( ) > i ; \ni ++ ) result . setChar ( i , s . charAt ( i ) ) ; \nreturn result ; \n} \n} \n"}
{"4180": "public class ArrayChar { \npublic static ArrayChar makeFromStringArray ( ArrayObject values , int strlen ) { \ntry { \nSection section = new Section ( values . getShape ( ) ) ; \nsection . appendRange ( strlen ) ; \nint [ ] shape = section . getShape ( ) ; \nlong size = section . computeSize ( ) ; \nchar [ ] cdata = new char [ ( int ) size ] ; \nint start = 0 ; \nIndexIterator ii = values . getIndexIterator ( ) ; \nwhile ( ii . hasNext ( ) ) { \nString s = ( String ) ii . next ( ) ; \nfor ( int k = 0 ; \ns . length ( ) > k && strlen > k ; \nk ++ ) cdata [ start + k ] = s . charAt ( k ) ; \nstart += strlen ; \n} \nArray carr = Array . factory ( DataType . CHAR , shape , cdata ) ; \nreturn ( ArrayChar ) carr ; \n} \ncatch ( InvalidRangeException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \n} \n"}
{"4185": "public class Grib1RecordScanner { \npublic static void main ( String [ ] args ) throws IOException { \nint count = 0 ; \nString file = ( 0 < args . length ) ? args [ 0 ] : \"Q:/cdmUnitTest/formats/grib1/ECMWF.hybrid.grib1\" ; \nRandomAccessFile raf = new RandomAccessFile ( file , \"r\" ) ; \nSystem . out . printf ( \"Read %s%n\" , raf . getLocation ( ) ) ; \nGrib1RecordScanner scan = new Grib1RecordScanner ( raf ) ; \nwhile ( scan . hasNext ( ) ) { \nscan . next ( ) ; \ncount ++ ; \n} \nraf . close ( ) ; \nSystem . out . printf ( \"count=%d%n\" , count ) ; \n} \n} \n"}
{"4196": "public class DateRange { \nprivate void recalcDuration ( ) { \nlong min = getStart ( ) . getDate ( ) . getTime ( ) ; \nlong max = getEnd ( ) . getDate ( ) . getTime ( ) ; \ndouble secs = .001 * ( max - min ) ; \nif ( 0 > secs ) secs = 0 ; \nif ( duration == null ) { \ntry { \nduration = new TimeDuration ( chooseResolution ( secs ) ) ; \n} \ncatch ( ParseException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nif ( resolution == null ) { \nduration . setValueInSeconds ( secs ) ; \n} \nelse { \ndouble resSecs = resolution . getValueInSeconds ( ) ; \ndouble closest = Math . round ( secs / resSecs ) ; \nsecs = closest * resSecs ; \nduration . setValueInSeconds ( secs ) ; \n} \nhashCode = 0 ; \n} \n} \n"}
{"4198": "public class CELexer { \npublic void yyerror ( String s ) { \nSystem . err . println ( \"CEParserImpl.yyerror: \" + s + \"; parse failed at char: \" + charno + \"; near: \" ) ; \nString context = getInput ( ) ; \nint show = ( CONTEXTLEN > context . length ( ) ? context . length ( ) : CONTEXTLEN ) ; \nSystem . err . println ( context . substring ( context . length ( ) - show ) + \"^\" ) ; \nnew Exception ( ) . printStackTrace ( System . err ) ; \n} \n} \n"}
{"4199": "public class DtCoverageDataset { \npublic String getName ( ) { \nString loc = ncd . getLocation ( ) ; \nint pos = loc . lastIndexOf ( '/' ) ; \nif ( 0 > pos ) pos = loc . lastIndexOf ( '\\\\' ) ; \nreturn ( 0 > pos ) ? loc : loc . substring ( pos + 1 ) ; \n} \n} \n"}
{"4204": "public class Nc4ChunkingDefault { \npublic int [ ] computeUnlimitedChunking ( List < Dimension > dims , int elemSize ) { \nint maxElements = defaultChunkSize / elemSize ; \nint [ ] result = fillRightmost ( convertUnlimitedShape ( dims ) , maxElements ) ; \nlong resultSize = new Section ( result ) . computeSize ( ) ; \nif ( minChunksize > resultSize ) { \nmaxElements = minChunksize / elemSize ; \nresult = incrUnlimitedShape ( dims , result , maxElements ) ; \n} \nreturn result ; \n} \n} \n"}
{"4216": "public class CatalogManager { \nprivate Object makeDynamicCatalog ( String path , URI baseURI ) throws IOException { \nboolean isLatest = path . endsWith ( \"/latest.xml\" ) ; \nint pos = path . lastIndexOf ( \"/\" ) ; \nString workPath = ( 0 <= pos ) ? path . substring ( 0 , pos ) : path ; \nString filename = ( 0 < pos ) ? path . substring ( pos + 1 ) : path ; \nDataRootManager . DataRootMatch match = dataRootManager . findDataRootMatch ( workPath ) ; \nif ( match == null ) return null ; \nif ( match . dataRoot . getFeatureCollection ( ) != null ) { \nInvDatasetFeatureCollection fc = featureCollectionCache . get ( match . dataRoot . getFeatureCollection ( ) ) ; \nif ( isLatest ) return fc . makeLatest ( match . remaining , path , baseURI ) ; \nelse return fc . makeCatalog ( match . remaining , path , baseURI ) ; \n} \nDatasetScan dscan = match . dataRoot . getDatasetScan ( ) ; \nif ( dscan != null ) { \nif ( log . isDebugEnabled ( ) ) log . debug ( \"makeDynamicCatalog(): Calling DatasetScan.makeCatalogForDirectory( \" + baseURI + \", \" + path + \").\" ) ; \nCatalogBuilder cat ; \nif ( isLatest ) cat = dscan . makeCatalogForLatest ( workPath , baseURI ) ; \nelse cat = dscan . makeCatalogForDirectory ( workPath , baseURI ) ; \nif ( null == cat ) log . error ( \"makeDynamicCatalog(): DatasetScan.makeCatalogForDirectory failed = \" + workPath ) ; \nreturn cat ; \n} \nCatalogScan catScan = match . dataRoot . getCatalogScan ( ) ; \nif ( catScan != null ) { \nif ( ! filename . equalsIgnoreCase ( CatalogScan . CATSCAN ) ) { \nreturn catScan . getCatalog ( tdsContext . getThreddsDirectory ( ) , match . remaining , filename , ccc ) ; \n} \nif ( log . isDebugEnabled ( ) ) log . debug ( \"makeDynamicCatalog(): Calling CatalogScan.makeCatalogForDirectory( \" + baseURI + \", \" + path + \").\" ) ; \nCatalogBuilder cat = catScan . makeCatalogFromDirectory ( tdsContext . getThreddsDirectory ( ) , match . remaining , baseURI ) ; \nif ( null == cat ) log . error ( \"makeDynamicCatalog(): CatalogScan.makeCatalogForDirectory failed = \" + workPath ) ; \nreturn cat ; \n} \nlog . warn ( \"makeDynamicCatalog() failed for =\" + workPath + \" request path= \" + path ) ; \nreturn null ; \n} \n} \n"}
{"4227": "public class GradsAttribute { \npublic static GradsAttribute parseAttribute ( String attrSpec ) { \nString [ ] toks = attrSpec . split ( \"\\\\s+\" ) ; \nStringBuffer buf = new StringBuffer ( ) ; \nfor ( int i = 4 ; \ntoks . length > i ; \ni ++ ) { \nbuf . append ( toks [ i ] ) ; \nbuf . append ( \" \" ) ; \n} \nreturn new GradsAttribute ( toks [ 1 ] , toks [ 2 ] , toks [ 3 ] , buf . toString ( ) . trim ( ) ) ; \n} \n} \n"}
{"4232": "public class N3iosp { \npublic static String makeValidNetcdfObjectName ( String name ) { \nStringBuilder sb = new StringBuilder ( name ) ; \nwhile ( 0 < sb . length ( ) ) { \nint cp = sb . codePointAt ( 0 ) ; \nif ( 0x7f >= cp ) { \nif ( ! ( cp >= 'A' && 'Z' >= cp ) && ! ( cp >= 'a' && 'z' >= cp ) && ! ( cp >= '0' && '9' >= cp ) && cp != '_' ) { \nsb . deleteCharAt ( 0 ) ; \ncontinue ; \n} \n} \nbreak ; \n} \nfor ( int pos = 1 ; \nsb . length ( ) > pos ; \n++ pos ) { \nint cp = sb . codePointAt ( pos ) ; \nif ( 0x7F >= cp ) { \nif ( ' ' > cp || 0x7E < cp || cp == '/' ) { \nsb . deleteCharAt ( pos ) ; \n-- pos ; \n} \n} \n} \nwhile ( 0 < sb . length ( ) ) { \nint cp = sb . codePointAt ( sb . length ( ) - 1 ) ; \nif ( 0x7f >= cp && Character . isWhitespace ( cp ) ) { \nsb . deleteCharAt ( sb . length ( ) - 1 ) ; \n} \nelse { \nbreak ; \n} \n} \nif ( sb . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( String . format ( \"Illegal NetCDF object name: '%s'\" , name ) ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"4235": "public class N3iosp { \nprivate ucar . ma2 . Array readRecordData ( ucar . nc2 . Structure s , Section section ) throws java . io . IOException { \nRange recordRange = section . getRange ( 0 ) ; \nStructureMembers members = s . makeStructureMembers ( ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nVariable v2 = s . findVariable ( m . getName ( ) ) ; \nN3header . Vinfo vinfo = ( N3header . Vinfo ) v2 . getSPobject ( ) ; \nm . setDataParam ( ( int ) ( vinfo . begin - header . recStart ) ) ; \n} \nif ( Integer . MAX_VALUE < header . recsize ) throw new IllegalArgumentException ( \"Cant read records when recsize > \" + Integer . MAX_VALUE ) ; \nlong nrecs = section . computeSize ( ) ; \nif ( Integer . MAX_VALUE < nrecs * header . recsize ) throw new IllegalArgumentException ( \"Too large read: nrecs * recsize= \" + ( nrecs * header . recsize ) + \"bytes exceeds \" + Integer . MAX_VALUE ) ; \nmembers . setStructureSize ( ( int ) header . recsize ) ; \nArrayStructureBB structureArray = new ArrayStructureBB ( members , new int [ ] { \nrecordRange . length ( ) } \n) ; \nbyte [ ] result = structureArray . getByteBuffer ( ) . array ( ) ; \nint count = 0 ; \nfor ( int recnum : recordRange ) { \nif ( debugRecord ) System . out . println ( \" read record \" + recnum ) ; \nraf . seek ( header . recStart + recnum * header . recsize ) ; \nif ( recnum != header . numrecs - 1 ) raf . readFully ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \nelse raf . read ( result , ( int ) ( count * header . recsize ) , ( int ) header . recsize ) ; \ncount ++ ; \n} \nreturn structureArray ; \n} \n} \n"}
{"4240": "public class GradsTimeDimension { \npublic static boolean hasTimeTemplate ( String template ) { \nfor ( int i = 0 ; \ntimeTemplates . length > i ; \ni ++ ) { \nif ( 0 <= template . indexOf ( timeTemplates [ i ] ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"4249": "public class McIDASLookup { \npublic final boolean isVerticalCoordinate ( GridRecord gr ) { \nif ( cust != null ) { \nreturn cust . isVerticalCoordinate ( gr . getLevelType1 ( ) ) ; \n} \nint type = gr . getLevelType1 ( ) ; \nif ( ( ( McIDASGridRecord ) gr ) . hasGribInfo ( ) ) { \nif ( type == 20 ) { \nreturn true ; \n} \nif ( type == 100 ) { \nreturn true ; \n} \nif ( type == 101 ) { \nreturn true ; \n} \nif ( ( 103 <= type ) && ( 128 >= type ) ) { \nreturn true ; \n} \nif ( type == 141 ) { \nreturn true ; \n} \nif ( type == 160 ) { \nreturn true ; \n} \n} \nelse if ( getLevelUnit ( gr ) . equals ( \"hPa\" ) ) { \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"4254": "public class ThreddsDatasetChooser { \npublic static void main ( String args [ ] ) { \nboolean usePopup = false ; \nfor ( int i = 0 ; \nargs . length > i ; \ni ++ ) { \nif ( args [ i ] . equals ( \"-usePopup\" ) ) usePopup = true ; \n} \ntry { \nstore = XMLStore . createFromFile ( \"ThreddsDatasetChooser\" , null ) ; \np = store . getPreferences ( ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"XMLStore Creation failed \" + e ) ; \n} \nfinal JFrame frame = new JFrame ( \"Thredds Dataset Chooser\" ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \npublic void windowClosing ( WindowEvent e ) { \nchooser . save ( ) ; \nRectangle bounds = frame . getBounds ( ) ; \np . putBeanObject ( FRAME_SIZE , bounds ) ; \ntry { \nstore . save ( ) ; \n} \ncatch ( IOException ioe ) { \nioe . printStackTrace ( ) ; \n} \nSystem . exit ( 0 ) ; \n} \n} \n) ; \nchooser = new ThreddsDatasetChooser ( p , null , frame , true , usePopup , false ) ; \nchooser . setDoResolve ( true ) ; \nframe . getContentPane ( ) . add ( chooser ) ; \nRectangle bounds = ( Rectangle ) p . getBean ( FRAME_SIZE , new Rectangle ( 50 , 50 , 800 , 450 ) ) ; \nframe . setBounds ( bounds ) ; \nframe . pack ( ) ; \nframe . setBounds ( bounds ) ; \nframe . setVisible ( true ) ; \n} \n} \n"}
{"4258": "public class SerialWriter { \npublic void writeAtomicArray ( DapType daptype , Object values ) throws IOException { \nassert values != null && values . getClass ( ) . isArray ( ) ; \nByteBuffer buf = SerialWriter . encodeArray ( daptype , values , this . order ) ; \nbyte [ ] bytes = buf . array ( ) ; \nint len = buf . position ( ) ; \nwriteBytes ( bytes , len ) ; \nif ( DEBUG ) { \nSystem . err . printf ( \"%s: \" , daptype . getShortName ( ) ) ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nint x = ( int ) ( order == ByteOrder . BIG_ENDIAN ? bytes [ i ] : bytes [ ( len - 1 ) - i ] ) ; \nSystem . err . printf ( \"%02x\" , ( int ) ( x & 0xff ) ) ; \n} \nSystem . err . println ( ) ; \n} \n} \n} \n"}
{"4259": "public class SerialWriter { \npublic void writeBytes ( byte [ ] bytes , int len ) throws IOException { \noutputBytes ( bytes , 0 , len ) ; \nif ( this . checksummode . enabled ( ChecksumMode . DAP ) ) { \nthis . checksum . update ( bytes , 0 , len ) ; \nif ( DUMPCSUM ) { \nSystem . err . print ( \"SSS \" ) ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nSystem . err . printf ( \"%02x\" , bytes [ i ] ) ; \n} \nSystem . err . println ( ) ; \n} \n} \n} \n} \n"}
{"4260": "public class SerialWriter { \npublic void outputBytes ( byte [ ] bytes , int start , int count ) throws IOException { \nif ( DUMPDATA ) { \nSystem . err . printf ( \"output %d/%d:\" , start , count ) ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nSystem . err . printf ( \" %02x\" , bytes [ i ] ) ; \n} \nSystem . err . println ( \"\" ) ; \nSystem . err . flush ( ) ; \n} \noutput . write ( bytes , start , count ) ; \n} \n} \n"}
{"4267": "public class McIDASGridReader { \npublic float [ ] readGrid ( McIDASGridRecord gr ) throws IOException { \nfloat [ ] data ; \nint te = ( gr . getOffsetToHeader ( ) + 64 ) * 4 ; \nint rows = gr . getRows ( ) ; \nint cols = gr . getColumns ( ) ; \nrf . seek ( te ) ; \nfloat scale = ( float ) gr . getParamScale ( ) ; \ndata = new float [ rows * cols ] ; \nrf . order ( needToSwap ? RandomAccessFile . LITTLE_ENDIAN : RandomAccessFile . BIG_ENDIAN ) ; \nfor ( int nc = 0 ; \ncols > nc ; \nnc ++ ) { \nfor ( int nr = 0 ; \nrows > nr ; \nnr ++ ) { \nint temp = rf . readInt ( ) ; \ndata [ ( rows - nr - 1 ) * cols + nc ] = ( temp == McIDASUtil . MCMISSING ) ? Float . NaN : ( ( float ) temp ) / scale ; \n} \n} \nrf . order ( RandomAccessFile . BIG_ENDIAN ) ; \nreturn data ; \n} \n} \n"}
{"4268": "public class McIDASGridReader { \npublic static void main ( String [ ] args ) throws IOException { \nString file = \"GRID2001\" ; \nif ( 0 < args . length ) { \nfile = args [ 0 ] ; \n} \nMcIDASGridReader mg = new McIDASGridReader ( file ) ; \nGridIndex gridIndex = mg . getGridIndex ( ) ; \nList grids = gridIndex . getGridRecords ( ) ; \nSystem . out . println ( \"found \" + grids . size ( ) + \" grids\" ) ; \nint num = Math . min ( grids . size ( ) , 10 ) ; \nfor ( int i = 0 ; \nnum > i ; \ni ++ ) { \nSystem . out . println ( grids . get ( i ) ) ; \n} \n} \n} \n"}
{"4273": "public class LogReader { \npublic void scanLogFile ( File file , Closure closure , LogFilter logf , Stats stat ) throws IOException { \ntry ( InputStream ios = new FileInputStream ( file ) ) { \nSystem . out . printf ( \"-----Reading %s %n\" , file . getPath ( ) ) ; \nBufferedReader dataIS = new BufferedReader ( new InputStreamReader ( ios , CDM . utf8Charset ) , 40 * 1000 ) ; \nint total = 0 ; \nint count = 0 ; \nwhile ( ( 0 > maxLines ) || ( maxLines > count ) ) { \nLog log = parser . nextLog ( dataIS ) ; \nif ( log == null ) break ; \ntotal ++ ; \nif ( ( logf != null ) && ! logf . pass ( log ) ) continue ; \nclosure . process ( log ) ; \ncount ++ ; \n} \nif ( stat != null ) { \nstat . total += total ; \nstat . passed += count ; \n} \nSystem . out . printf ( \"----- %s total requests=%d passed=%d %n\" , file . getPath ( ) , total , count ) ; \n} \n} \n} \n"}
{"4274": "public class GempakGridReader { \npublic int getGridPackingType ( int gridNumber ) throws IOException { \nint irow = 1 ; \nif ( ( 1 > gridNumber ) || ( dmLabel . kcol < gridNumber ) ) { \nlogWarning ( \"bad grid number \" + gridNumber ) ; \nreturn - 9 ; \n} \nint iprt = getPartNumber ( \"GRID\" ) ; \nif ( iprt == 0 ) { \nlogWarning ( \"couldn't find part: GRID\" ) ; \nreturn - 10 ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( part . ktyprt != MDGRID ) { \nlogWarning ( \"Not a valid type: \" + GempakUtil . getDataType ( part . ktyprt ) ) ; \nreturn - 21 ; \n} \nint ilenhd = part . klnhdr ; \nint ipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( gridNumber - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nint istart = DM_RINT ( ipoint ) ; \nif ( istart == 0 ) { \nreturn - 15 ; \n} \nint length = DM_RINT ( istart ) ; \nint isword = istart + 1 ; \nif ( ilenhd >= length ) { \nlogWarning ( \"length (\" + length + \") is less than header length (\" + ilenhd + \")\" ) ; \nreturn - 15 ; \n} \nelse if ( 10000000 < Math . abs ( length ) ) { \nlogWarning ( \"length is huge: \" + length ) ; \nreturn - 34 ; \n} \nint [ ] header = new int [ ilenhd ] ; \nDM_RINT ( isword , header ) ; \nisword += ilenhd ; \nreturn DM_RINT ( isword ) ; \n} \n} \n"}
{"4277": "public class GempakGridReader { \nprivate synchronized float [ ] unpackData ( int iiword , int nword , int ipktyp , int kxky , int nbits , float ref , float scale , boolean miss , float difmin , int kx , int decimalScale ) throws IOException { \nif ( ipktyp == MDGGRB ) { \nif ( ! useDP ) { \nreturn unpackGrib1Data ( iiword , nword , kxky , nbits , ref , scale , miss , decimalScale ) ; \n} \nelse { \nif ( kxky * nbits > nword * 32 ) { \nnword ++ ; \n} \nint [ ] ksgrid = new int [ nword ] ; \nDM_RINT ( iiword , ksgrid ) ; \nreturn DP_UGRB ( ksgrid , kxky , nbits , ref , scale , miss , decimalScale ) ; \n} \n} \nelse if ( ipktyp == MDGNMC ) { \nreturn null ; \n} \nelse if ( ipktyp == MDGDIF ) { \nreturn null ; \n} \nreturn null ; \n} \n} \n"}
{"4278": "public class GempakGridReader { \nprivate synchronized float [ ] DP_UGRB ( int [ ] idata , int kxky , int nbits , float qmin , float scale , boolean misflg , int decimalScale ) throws IOException { \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfloat [ ] grid = new float [ kxky ] ; \nif ( ( 1 >= nbits ) || ( 31 < nbits ) ) { \nreturn grid ; \n} \nif ( scale == 0. ) { \nreturn grid ; \n} \nint imax = ( int ) ( Math . pow ( 2 , nbits ) - 1 ) ; \nint iword = 0 ; \nint ibit = 1 ; \nfor ( int i = 0 ; \nkxky > i ; \ni ++ ) { \nint jshft = nbits + ibit - 33 ; \nint idat = 0 ; \nidat = ( 0 > jshft ) ? idata [ iword ] >>> Math . abs ( jshft ) : idata [ iword ] << jshft ; \nidat = idat & imax ; \nif ( 0 < jshft ) { \njshft -= 32 ; \nint idat2 = 0 ; \nidat2 = idata [ iword + 1 ] >>> Math . abs ( jshft ) ; \nidat = idat | idat2 ; \n} \nif ( ( idat == imax ) && misflg ) { \ngrid [ i ] = RMISSD ; \n} \nelse { \ngrid [ i ] = ( qmin + idat * scale ) * scaleFactor ; \n} \nibit += nbits ; \nif ( 32 < ibit ) { \nibit -= 32 ; \niword ++ ; \n} \n} \nreturn grid ; \n} \n} \n"}
{"4279": "public class GempakGridReader { \nprivate float [ ] unpackGrib1Data ( int iiword , int nword , int kxky , int nbits , float ref , float scale , boolean miss , int decimalScale ) throws IOException { \nfloat [ ] values = new float [ kxky ] ; \nbitPos = 0 ; \nbitBuf = 0 ; \nnext = 0 ; \nch1 = 0 ; \nch2 = 0 ; \nch3 = 0 ; \nch4 = 0 ; \nrf . seek ( getOffset ( iiword ) ) ; \nint idat ; \nfloat scaleFactor = ( decimalScale == 0 ) ? 1.f : ( float ) Math . pow ( 10.0 , - decimalScale ) ; \nfor ( int i = 0 ; \nvalues . length > i ; \ni ++ ) { \nidat = bits2UInt ( nbits ) ; \nif ( miss && ( idat == IMISSD ) ) { \nvalues [ i ] = IMISSD ; \n} \nelse { \nvalues [ i ] = ( ref + scale * idat ) * scaleFactor ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4287": "public class CalendarDate { \npublic static CalendarDate parseUdunits ( String calendarName , String udunits ) { \nint pos = udunits . indexOf ( ' ' ) ; \nif ( 0 > pos ) return null ; \nString valString = udunits . substring ( 0 , pos ) . trim ( ) ; \nString unitString = udunits . substring ( pos + 1 ) . trim ( ) ; \nCalendarDateUnit cdu = CalendarDateUnit . of ( calendarName , unitString ) ; \ndouble val = Double . parseDouble ( valString ) ; \nreturn cdu . makeCalendarDate ( val ) ; \n} \n} \n"}
{"4291": "public class DownloadController { \nstatic protected String escapeString ( String s ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ns . length ( ) > i ; \ni ++ ) { \nint c = s . charAt ( i ) ; \nswitch ( c ) { \ncase '\"' : buf . append ( \"\\\\\\\"\" ) ; \nbreak ; \ncase '\\\\' : buf . append ( \"\\\\\\\\\" ) ; \nbreak ; \ncase '\\n' : buf . append ( '\\n' ) ; \nbreak ; \ncase '\\r' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\t' : buf . append ( '\\r' ) ; \nbreak ; \ncase '\\f' : buf . append ( '\\f' ) ; \nbreak ; \ndefault : if ( ' ' > c ) buf . append ( String . format ( \"\\\\x%02x\" , ( c & 0xff ) ) ) ; \nelse buf . append ( ( char ) c ) ; \nbreak ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4292": "public class CDMUtil { \nstatic public List < Slice > createSlices ( List < Range > rangelist ) throws dap4 . core . util . DapException { \nList < Slice > slices = new ArrayList < Slice > ( rangelist . size ( ) ) ; \nfor ( int i = 0 ; \nrangelist . size ( ) > i ; \ni ++ ) { \nRange r = rangelist . get ( i ) ; \nint stride = r . stride ( ) ; \nint first = r . first ( ) ; \nint n = r . length ( ) ; \nint stop = first + ( n * stride ) ; \nSlice cer = new Slice ( first , stop - 1 , stride ) ; \nslices . add ( cer ) ; \n} \nreturn slices ; \n} \n} \n"}
{"4295": "public class CDMUtil { \nstatic public int [ ] computeEffectiveShape ( List < DapDimension > dimset ) { \nif ( dimset == null || dimset . size ( ) == 0 ) return new int [ 0 ] ; \nint effectiverank = dimset . size ( ) ; \nint [ ] shape = new int [ effectiverank ] ; \nfor ( int i = 0 ; \neffectiverank > i ; \ni ++ ) { \nshape [ i ] = ( int ) dimset . get ( i ) . getSize ( ) ; \n} \nreturn shape ; \n} \n} \n"}
{"4302": "public class ScaledUnit { \npublic float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { \nfinal float scale = ( float ) getScale ( ) ; \nfor ( int i = input . length ; \n0 <= -- i ; \n) { \noutput [ i ] = input [ i ] * scale ; \n} \nif ( ! ( _unit instanceof DerivableUnit ) ) { \nthrow new ConversionException ( this , getDerivedUnit ( ) ) ; \n} \nreturn ( ( DerivableUnit ) getUnit ( ) ) . toDerivedUnit ( output , output ) ; \n} \n} \n"}
{"4313": "public class MFlowLayout { \npublic Dimension preferredLayoutSize ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nDimension dim = new Dimension ( 0 , 0 ) ; \nfor ( int i = 0 ; \ntarget . getComponentCount ( ) > i ; \ni ++ ) { \nComponent m = target . getComponent ( i ) ; \nif ( m . isVisible ( ) ) { \nDimension d = m . getPreferredSize ( ) ; \nPoint p = m . getLocation ( ) ; \ndim . width = Math . max ( dim . width , p . x + d . width ) ; \ndim . height = Math . max ( dim . height , p . y + d . height ) ; \n} \n} \nInsets insets = target . getInsets ( ) ; \ndim . width += insets . left + insets . right + getHgap ( ) * 2 ; \ndim . height += insets . top + insets . bottom + getVgap ( ) * 2 ; \nreturn dim ; \n} \n} \n} \n"}
{"4314": "public class CatalogBuilderHelper { \nstatic CrawlableDataset verifyDescendantDataset ( CrawlableDataset ancestorCrDs , String path , CrawlableDatasetFilter filter ) { \nif ( ! ancestorCrDs . isCollection ( ) ) throw new IllegalArgumentException ( \"Ancestor dataset <\" + ancestorCrDs . getPath ( ) + \"> not a collection.\" ) ; \nif ( ! path . startsWith ( ancestorCrDs . getPath ( ) ) ) throw new IllegalArgumentException ( \"Dataset path <\" + path + \"> not descendant of given dataset <\" + ancestorCrDs . getPath ( ) + \">.\" ) ; \nif ( path . length ( ) == ancestorCrDs . getPath ( ) . length ( ) ) return ancestorCrDs ; \nString remainingPath = path . substring ( ancestorCrDs . getPath ( ) . length ( ) ) ; \nif ( remainingPath . startsWith ( \"/\" ) ) remainingPath = remainingPath . substring ( 1 ) ; \nString [ ] pathSegments = remainingPath . split ( \"/\" ) ; \nCrawlableDataset curCrDs = ancestorCrDs ; \nfor ( int i = 0 ; \npathSegments . length > i ; \ni ++ ) { \ncurCrDs = curCrDs . getDescendant ( pathSegments [ i ] ) ; \nif ( filter != null ) if ( ! filter . accept ( curCrDs ) ) return null ; \n} \nif ( ! curCrDs . exists ( ) ) return null ; \nreturn curCrDs ; \n} \n} \n"}
{"4321": "public class UnitDimension { \npublic QuantityDimension getQuantityDimension ( ) { \nFactor [ ] factors = getFactors ( ) ; \nfor ( int i = factors . length ; \n0 <= -- i ; \n) { \nFactor factor = factors [ i ] ; \nfactors [ i ] = new Factor ( ( ( BaseUnit ) factor . getBase ( ) ) . getBaseQuantity ( ) , factor . getExponent ( ) ) ; \n} \nreturn new QuantityDimension ( factors ) ; \n} \n} \n"}
{"4327": "public class SigmetIOServiceProvider { \nstatic float calcElev ( short angle ) { \nfinal double maxval = 65536.0 ; \ndouble ang = ( double ) angle ; \nif ( 0 > angle ) ang = ( ~ angle ) + 1 ; \ndouble temp = ( ang / maxval ) * 360.0 ; \nBigDecimal bd = new BigDecimal ( temp ) ; \nBigDecimal result = bd . setScale ( 2 , RoundingMode . HALF_DOWN ) ; \nreturn result . floatValue ( ) ; \n} \n} \n"}
{"4329": "public class SigmetIOServiceProvider { \nstatic float calcAz ( short az0 , short az1 ) { \nfloat azim0 = calcAngle ( az0 ) ; \nfloat azim1 = calcAngle ( az1 ) ; \nfloat d = 0.0f ; \nd = Math . abs ( azim0 - azim1 ) ; \nif ( ( 0 > az0 ) & ( 0 < az1 ) ) { \nd = Math . abs ( 360.0f - azim0 ) + Math . abs ( azim1 ) ; \n} \ndouble temp = azim0 + d * 0.5 ; \nif ( 360.0 < temp ) { \ntemp -= 360.0 ; \n} \nBigDecimal bd = new BigDecimal ( temp ) ; \nBigDecimal result = bd . setScale ( 2 , RoundingMode . HALF_DOWN ) ; \nreturn result . floatValue ( ) ; \n} \n} \n"}
{"4335": "public class GridServiceProvider { \nprivate void readXY ( Variable v2 , int ensIdx , int timeIdx , int levIdx , Range yRange , Range xRange , IndexIterator ii ) throws IOException , InvalidRangeException { \nGridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; \nGridHorizCoordSys hsys = pv . getHorizCoordSys ( ) ; \nint nx = hsys . getNx ( ) ; \nGridRecord record = pv . findRecord ( ensIdx , timeIdx , levIdx ) ; \nif ( record == null ) { \nAttribute att = v2 . findAttribute ( \"missing_value\" ) ; \nfloat missing_value = ( att == null ) ? - 9999.0f : att . getNumericValue ( ) . floatValue ( ) ; \nint xyCount = yRange . length ( ) * xRange . length ( ) ; \nfor ( int j = 0 ; \nxyCount > j ; \nj ++ ) { \nii . setFloatNext ( missing_value ) ; \n} \nreturn ; \n} \nfloat [ ] data = _readData ( record ) ; \nif ( data == null ) { \n_readData ( record ) ; \nreturn ; \n} \nfor ( int y : yRange ) { \nfor ( int x : xRange ) { \nint index = y * nx + x ; \nii . setFloatNext ( data [ index ] ) ; \n} \n} \n} \n} \n"}
{"4336": "public class GridServiceProvider { \npublic boolean isMissingXY ( Variable v2 , int timeIdx , int ensIdx , int levIdx ) throws InvalidRangeException { \nGridVariable pv = ( GridVariable ) v2 . getSPobject ( ) ; \nif ( ( 0 > timeIdx ) || ( pv . getNTimes ( ) <= timeIdx ) ) { \nthrow new InvalidRangeException ( \"timeIdx=\" + timeIdx ) ; \n} \nif ( ( 0 > levIdx ) || ( pv . getVertNlevels ( ) <= levIdx ) ) { \nthrow new InvalidRangeException ( \"levIdx=\" + levIdx ) ; \n} \nif ( ( 0 > ensIdx ) || ( pv . getNEnsembles ( ) <= ensIdx ) ) { \nthrow new InvalidRangeException ( \"ensIdx=\" + ensIdx ) ; \n} \nreturn ( null == pv . findRecord ( ensIdx , timeIdx , levIdx ) ) ; \n} \n} \n"}
{"4338": "public class ArraySequenceNested { \npublic void finish ( ) { \nsequenceOffset = new int [ nelems ] ; \ntotal = 0 ; \nfor ( int i = 0 ; \nnelems > i ; \ni ++ ) { \nsequenceOffset [ i ] = total ; \ntotal += sequenceLen [ i ] ; \n} \nsdata = new StructureData [ nelems ] ; \nfor ( int i = 0 ; \nnelems > i ; \ni ++ ) sdata [ i ] = new StructureDataA ( this , sequenceOffset [ i ] ) ; \nfor ( StructureMembers . Member m : members . getMembers ( ) ) { \nint [ ] mShape = m . getShape ( ) ; \nint [ ] shape = new int [ mShape . length + 1 ] ; \nshape [ 0 ] = total ; \nSystem . arraycopy ( mShape , 0 , shape , 1 , mShape . length ) ; \nArray data = Array . factory ( m . getDataType ( ) , shape ) ; \nm . setDataArray ( data ) ; \n} \n} \n} \n"}
{"4339": "public class Format { \npublic static void tab ( StringBuffer sbuff , int tabStop , boolean alwaysOne ) { \nint len = sbuff . length ( ) ; \nif ( len < tabStop ) { \nsbuff . setLength ( tabStop ) ; \nfor ( int i = len ; \ntabStop > i ; \ni ++ ) { \nsbuff . setCharAt ( i , ' ' ) ; \n} \n} \nelse if ( alwaysOne ) { \nsbuff . setLength ( len + 1 ) ; \nsbuff . setCharAt ( len , ' ' ) ; \n} \n} \n} \n"}
{"4340": "public class Format { \npublic static String pad ( String s , int width , boolean rightJustify ) { \nif ( width <= s . length ( ) ) { \nreturn s ; \n} \nStringBuilder sbuff = new StringBuilder ( width ) ; \nint need = width - s . length ( ) ; \nsbuff . setLength ( need ) ; \nfor ( int i = 0 ; \nneed > i ; \ni ++ ) { \nsbuff . setCharAt ( i , ' ' ) ; \n} \nif ( rightJustify ) { \nsbuff . append ( s ) ; \n} \nelse { \nsbuff . insert ( 0 , s ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"4343": "public class Format { \npublic static String formatByteSize ( double size ) { \nString unit = null ; \nif ( 1.0e15 < size ) { \nunit = \"Pbytes\" ; \nsize *= 1.0e-15 ; \n} \nelse if ( 1.0e12 < size ) { \nunit = \"Tbytes\" ; \nsize *= 1.0e-12 ; \n} \nelse if ( 1.0e9 < size ) { \nunit = \"Gbytes\" ; \nsize *= 1.0e-9 ; \n} \nelse if ( 1.0e6 < size ) { \nunit = \"Mbytes\" ; \nsize *= 1.0e-6 ; \n} \nelse if ( 1.0e3 < size ) { \nunit = \"Kbytes\" ; \nsize *= 1.0e-3 ; \n} \nelse { \nunit = \"bytes\" ; \n} \nreturn Format . d ( size , 4 ) + \" \" + unit ; \n} \n} \n"}
{"4346": "public class GridDatasetInfo { \nprivate String getShapeString ( int [ ] shape ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( int i = 0 ; \nshape . length > i ; \ni ++ ) { \nif ( i != 0 ) buf . append ( \" \" ) ; \nbuf . append ( shape [ i ] ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4347": "public class Slice { \npublic Slice finish ( ) throws DapException { \nif ( this . first == UNDEFINED ) this . first = 0 ; \nif ( this . stride == UNDEFINED ) this . stride = 1 ; \nif ( this . stop == UNDEFINED && this . maxsize != UNDEFINED ) this . stop = this . maxsize ; \nif ( this . stop == UNDEFINED && this . maxsize == UNDEFINED ) this . stop = this . first + 1 ; \nif ( this . maxsize == UNDEFINED && this . stop != UNDEFINED ) this . maxsize = this . stop ; \nassert ( this . first != UNDEFINED ) ; \nassert ( this . stride != UNDEFINED ) ; \nassert ( this . stop != UNDEFINED ) ; \nif ( this . maxsize < this . first ) throw new DapException ( \"Slice: first index > max size\" ) ; \nif ( ( this . maxsize + 1 ) < this . stop ) throw new DapException ( \"Slice: stop > max size\" ) ; \nif ( 0 > this . first ) throw new DapException ( \"Slice: first index < 0\" ) ; \nif ( 0 > this . stop ) throw new DapException ( \"Slice: stop index < 0\" ) ; \nif ( 0 >= this . stride ) throw new DapException ( \"Slice: stride index <= 0\" ) ; \nif ( this . stop < this . first ) throw new DapException ( \"Slice: first index > last\" ) ; \nreturn this ; \n} \n} \n"}
{"4349": "public class Slice { \nstatic public Slice compose ( Slice target , Slice src ) throws DapException { \nlong sr_stride = target . getStride ( ) * src . getStride ( ) ; \nlong sr_first = MAP ( target , src . getFirst ( ) ) ; \nlong lastx = MAP ( target , src . getLast ( ) ) ; \nlong sr_last = ( lastx > target . getLast ( ) ? target . getLast ( ) : lastx ) ; \nreturn new Slice ( sr_first , sr_last + 1 , sr_stride , sr_last + 1 ) . finish ( ) ; \n} \n} \n"}
{"4350": "public class Slice { \nstatic long MAP ( Slice target , long i ) throws DapException { \nif ( 0 > i ) throw new DapException ( \"Slice.compose: i must be >= 0\" ) ; \nif ( target . getStop ( ) < i ) throw new DapException ( \"i must be < stop\" ) ; \nreturn target . getFirst ( ) + i * target . getStride ( ) ; \n} \n} \n"}
{"4351": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 , boolean skipdmr ) { \nint savepos = buf0 . position ( ) ; \nint limit0 = buf0 . limit ( ) ; \nint skipcount = 0 ; \nif ( MAXLIMIT < limit0 ) limit0 = MAXLIMIT ; \nif ( buf0 . limit ( ) <= limit0 ) limit0 = buf0 . limit ( ) ; \nif ( skipdmr ) { \nByteOrder saveorder = buf0 . order ( ) ; \nbuf0 . order ( ByteOrder . BIG_ENDIAN ) ; \nskipcount = buf0 . getInt ( ) ; \nbuf0 . order ( saveorder ) ; \nskipcount &= 0xFFFFFF ; \nskipcount += 4 ; \n} \nbyte [ ] bytes = new byte [ ( limit0 + 8 ) - skipcount ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . position ( savepos + skipcount ) ; \nbuf0 . get ( bytes , 0 , limit0 - skipcount ) ; \nbuf0 . position ( savepos ) ; \nSystem . err . println ( \"order=\" + buf0 . order ( ) ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \ndumpbytes ( buf ) ; \n} \n} \n"}
{"4352": "public class DapDump { \nstatic public void dumpbytes ( ByteBuffer buf0 ) { \nint stop = buf0 . limit ( ) ; \nint size = stop + 8 ; \nint savepos = buf0 . position ( ) ; \nassert savepos == 0 ; \nbyte [ ] bytes = new byte [ size ] ; \nArrays . fill ( bytes , ( byte ) 0 ) ; \nbuf0 . get ( bytes , 0 , stop ) ; \nbuf0 . position ( savepos ) ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) . order ( buf0 . order ( ) ) ; \nbuf . position ( 0 ) ; \nbuf . limit ( size ) ; \nint i = 0 ; \ntry { \nfor ( i = 0 ; \nstop > buf . position ( ) ; \ni ++ ) { \nsavepos = buf . position ( ) ; \nint iv = buf . getInt ( ) ; \nbuf . position ( savepos ) ; \nlong lv = buf . getLong ( ) ; \nbuf . position ( savepos ) ; \nshort sv = buf . getShort ( ) ; \nbuf . position ( savepos ) ; \nbyte b = buf . get ( ) ; \nint ub = ( ( int ) b ) & 0x000000FF ; \nlong uiv = ( ( long ) iv ) & 0xFFFFFFFFL ; \nint usv = ( ( int ) sv ) & 0xFFFF ; \nint ib = ( int ) b ; \nchar c = ( char ) ub ; \nString s = Character . toString ( c ) ; \nif ( c == '\\r' ) s = \"\\\\r\" ; \nelse if ( c == '\\n' ) s = \"\\\\n\" ; \nelse if ( ' ' > c || 0x7f <= c ) s = \"?\" ; \nSystem . err . printf ( \"[%03d] %02x %03d %4d '%s'\" , i , ub , ub , ib , s ) ; \nSystem . err . printf ( \"\\t%12d 0x%08x\" , iv , uiv ) ; \nSystem . err . printf ( \"\\t%5d\\t0x%04x\" , sv , usv ) ; \nSystem . err . println ( ) ; \nSystem . err . flush ( ) ; \n} \n} \ncatch ( Exception e ) { \nSystem . err . println ( \"failure:\" + e ) ; \n} \nfinally { \nSystem . err . flush ( ) ; \nSystem . err . flush ( ) ; \n} \n} \n} \n"}
{"4355": "public class NcStreamDataCol { \npublic Array decodeVlenData ( NcStreamProto . DataCol dproto ) throws IOException { \nDataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; \nByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; \nByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nbb . order ( bo ) ; \nArray alldata = Array . factory ( dataType , new int [ ] { \ndproto . getNelems ( ) } \n, bb ) ; \nIndexIterator all = alldata . getIndexIterator ( ) ; \nSection section = NcStream . decodeSection ( dproto . getSection ( ) ) ; \nArray [ ] data = new Array [ ( int ) section . computeSize ( ) ] ; \nint count = 0 ; \nfor ( int len : dproto . getVlensList ( ) ) { \nArray primdata = Array . factory ( dataType , new int [ ] { \nlen } \n) ; \nIndexIterator prim = primdata . getIndexIterator ( ) ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nprim . setObjectNext ( all . getObjectNext ( ) ) ; \n} \ndata [ count ++ ] = primdata ; \n} \nreturn Array . makeVlenArray ( section . getShape ( ) , data ) ; \n} \n} \n"}
{"4356": "public class NcStreamDataCol { \nprivate Array decodeVlenData ( NcStreamProto . DataCol dproto , Section parentSection ) throws IOException { \nDataType dataType = NcStream . convertDataType ( dproto . getDataType ( ) ) ; \nByteBuffer bb = dproto . getPrimdata ( ) . asReadOnlyByteBuffer ( ) ; \nByteOrder bo = dproto . getBigend ( ) ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nbb . order ( bo ) ; \nArray alldata = Array . factory ( dataType , new int [ ] { \ndproto . getNelems ( ) } \n, bb ) ; \nIndexIterator all = alldata . getIndexIterator ( ) ; \nint psize = ( int ) parentSection . computeSize ( ) ; \nSection section = NcStream . decodeSection ( dproto . getSection ( ) ) ; \nSection vsection = section . removeFirst ( parentSection ) ; \nint vsectionSize = ( int ) vsection . computeSize ( ) ; \nint countInner = 0 ; \nArray [ ] pdata = new Array [ psize ] ; \nfor ( int pCount = 0 ; \npsize > pCount ; \npCount ++ ) { \nArray [ ] vdata = new Array [ vsectionSize ] ; \nfor ( int vCount = 0 ; \nvsectionSize > vCount ; \nvCount ++ ) { \nint vlen = dproto . getVlens ( countInner ++ ) ; \nArray primdata = Array . factory ( dataType , new int [ ] { \nvlen } \n) ; \nIndexIterator prim = primdata . getIndexIterator ( ) ; \nfor ( int i = 0 ; \nvlen > i ; \ni ++ ) { \nprim . setObjectNext ( all . getObjectNext ( ) ) ; \n} \nvdata [ vCount ] = primdata ; \n} \npdata [ pCount ] = Array . makeVlenArray ( vsection . getShape ( ) , vdata ) ; \n} \nreturn Array . makeVlenArray ( parentSection . getShape ( ) , pdata ) ; \n} \n} \n"}
{"4364": "public class CoordinateRuntime { \npublic List < Double > getOffsetsInTimeUnits ( ) { \ndouble start = firstDate . getMillis ( ) ; \nList < Double > result = new ArrayList < > ( runtimes . length ) ; \nfor ( int idx = 0 ; \nruntimes . length > idx ; \nidx ++ ) { \ndouble runtime = ( double ) getRuntime ( idx ) ; \ndouble msecs = ( runtime - start ) ; \nresult . add ( msecs / timeUnit . getValueInMillisecs ( ) ) ; \n} \nreturn result ; \n} \n} \n"}
{"4375": "public class GridHorizCoordSys { \nprivate double [ ] addCoordAxis ( NetcdfFile ncfile , String name , int n , double start , double incr , String units , String desc , String standard_name , AxisType axis ) { \nVariable v = new Variable ( ncfile , g , null , name ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . setDimensions ( name ) ; \ndouble [ ] data = new double [ n ] ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \ndata [ i ] = start + incr * i ; \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nn } \n, data ) ; \nv . setCachedData ( dataArray , false ) ; \nv . addAttribute ( new Attribute ( \"units\" , units ) ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , desc ) ) ; \nv . addAttribute ( new Attribute ( \"standard_name\" , standard_name ) ) ; \nv . addAttribute ( new Attribute ( \"grid_spacing\" , incr + \" \" + units ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axis . toString ( ) ) ) ; \nncfile . addVariable ( g , v ) ; \nreturn data ; \n} \n} \n"}
{"4376": "public class GridHorizCoordSys { \nprivate boolean makeProjection ( NetcdfFile ncfile , int projType ) { \nswitch ( projType ) { \ncase GridTableLookup . RotatedLatLon : makeRotatedLatLon ( ncfile ) ; \nbreak ; \ncase GridTableLookup . PolarStereographic : makePS ( ) ; \nbreak ; \ncase GridTableLookup . LambertConformal : makeLC ( ) ; \nbreak ; \ncase GridTableLookup . Mercator : makeMercator ( ) ; \nbreak ; \ncase GridTableLookup . Orthographic : makeMSGgeostationary ( ) ; \nbreak ; \ncase GridTableLookup . Curvilinear : makeCurvilinearAxis ( ncfile ) ; \nbreak ; \ndefault : throw new UnsupportedOperationException ( \"unknown projection = \" + gds . getInt ( GridDefRecord . GRID_TYPE ) ) ; \n} \nVariable v = new Variable ( ncfile , g , null , grid_name ) ; \nv . setDataType ( DataType . CHAR ) ; \nv . setDimensions ( \"\" ) ; \nchar [ ] data = new char [ ] { \n'd' } \n; \nArray dataArray = Array . factory ( DataType . CHAR , new int [ 0 ] , data ) ; \nv . setCachedData ( dataArray , false ) ; \nfor ( Attribute att : attributes ) v . addAttribute ( att ) ; \nv . addAttribute ( new Attribute ( GridCF . EARTH_SHAPE , shape_name ) ) ; \ndouble radius_spherical_earth = gds . getDouble ( GridDefRecord . RADIUS_SPHERICAL_EARTH ) ; \nif ( Double . isNaN ( radius_spherical_earth ) ) radius_spherical_earth = gds . getDouble ( \"radius_spherical_earth\" ) ; \nif ( ! Double . isNaN ( radius_spherical_earth ) ) { \nif ( 10000.00 > radius_spherical_earth ) radius_spherical_earth *= 1000.0 ; \nv . addAttribute ( new Attribute ( GridCF . EARTH_RADIUS , radius_spherical_earth ) ) ; \n} \nelse { \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( \"major_axis_earth\" ) ; \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \nif ( ! Double . isNaN ( major_axis ) && ! Double . isNaN ( minor_axis ) ) { \nv . addAttribute ( new Attribute ( GridCF . SEMI_MAJOR_AXIS , major_axis ) ) ; \nv . addAttribute ( new Attribute ( GridCF . SEMI_MINOR_AXIS , minor_axis ) ) ; \n} \n} \naddGDSparams ( v ) ; \nncfile . addVariable ( g , v ) ; \nreturn true ; \n} \n} \n"}
{"4381": "public class GridHorizCoordSys { \nprivate void makeMercator ( ) { \ndouble Latin = gds . getDouble ( GridDefRecord . LAD ) ; \nif ( Double . isNaN ( Latin ) ) Latin = gds . getDouble ( GridDefRecord . LATIN ) ; \ndouble Lo1 = gds . getDouble ( GridDefRecord . LO1 ) ; \ndouble La1 = gds . getDouble ( GridDefRecord . LA1 ) ; \nproj = new Mercator ( Lo1 , Latin ) ; \nProjectionPoint startP = proj . latLonToProj ( new LatLonPointImpl ( La1 , Lo1 ) ) ; \nstartx = startP . getX ( ) ; \nstarty = startP . getY ( ) ; \nif ( Double . isNaN ( getDxInKm ( ) ) ) { \nsetDxDy ( startx , starty , proj ) ; \n} \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"mercator\" ) ) ; \nattributes . add ( new Attribute ( GridCF . STANDARD_PARALLEL , Latin ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lo1 ) ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) ; \nif ( Lo1 > Lo2 ) Lo2 += 360 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeMercator: end at latlon= \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   start at proj coord \" + new ProjectionPointImpl ( startx , starty ) ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = startx + ( getNx ( ) - 1 ) * getDxInKm ( ) ; \ndouble endy = starty + ( getNy ( ) - 1 ) * getDyInKm ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \n} \n} \n"}
{"4382": "public class GridHorizCoordSys { \nprivate void makeMSGgeostationary ( ) { \ndouble Lat0 = gds . getDouble ( GridDefRecord . LAP ) ; \ndouble Lon0 = gds . getDouble ( GridDefRecord . LOP ) ; \nint ny = gds . getInt ( GridDefRecord . NY ) ; \nint x_off = gds . getInt ( GridDefRecord . XP ) ; \nint y_off = gds . getInt ( GridDefRecord . YP ) ; \ndouble dx ; \ndouble dy = gds . getDouble ( GridDefRecord . DY ) ; \nif ( 2100 > dy ) { \ndx = 1207 ; \ndy = 1203 ; \n} \nelse { \ndx = 3622 ; \ndy = 3610 ; \n} \ndouble major_axis = gds . getDouble ( GridDefRecord . MAJOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( major_axis ) ) major_axis = gds . getDouble ( \"major_axis_earth\" ) ; \ndouble minor_axis = gds . getDouble ( GridDefRecord . MINOR_AXIS_EARTH ) ; \nif ( Double . isNaN ( minor_axis ) ) minor_axis = gds . getDouble ( \"minor_axis_earth\" ) ; \ndouble nr = gds . getDouble ( GridDefRecord . NR ) * 1e-6 ; \ndouble as = 2 * Math . asin ( 1.0 / nr ) ; \ndouble cfac = dx / as ; \ndouble lfac = dy / as ; \ndouble scale_factor = ( nr - 1 ) * major_axis / 1000 ; \ndouble scale_x = scale_factor ; \ndouble scale_y = - scale_factor ; \nstartx = scale_factor * ( 1 - x_off ) / cfac ; \nstarty = scale_factor * ( y_off - ny ) / lfac ; \nincrx = scale_factor / cfac ; \nincry = scale_factor / lfac ; \nattributes . add ( new Attribute ( GridCF . GRID_MAPPING_NAME , \"MSGnavigation\" ) ) ; \nattributes . add ( new Attribute ( GridCF . LONGITUDE_OF_PROJECTION_ORIGIN , Lon0 ) ) ; \nattributes . add ( new Attribute ( GridCF . LATITUDE_OF_PROJECTION_ORIGIN , Lat0 ) ) ; \nattributes . add ( new Attribute ( \"height_from_earth_center\" , nr * major_axis ) ) ; \nattributes . add ( new Attribute ( \"scale_x\" , scale_x ) ) ; \nattributes . add ( new Attribute ( \"scale_y\" , scale_y ) ) ; \nproj = new MSGnavigation ( Lat0 , Lon0 , major_axis , minor_axis , nr * major_axis , scale_x , scale_y ) ; \nif ( GridServiceProvider . debugProj ) { \ndouble Lo2 = gds . getDouble ( GridDefRecord . LO2 ) + 360.0 ; \ndouble La2 = gds . getDouble ( GridDefRecord . LA2 ) ; \nLatLonPointImpl endLL = new LatLonPointImpl ( La2 , Lo2 ) ; \nSystem . out . println ( \"GridHorizCoordSys.makeMSGgeostationary end at latlon \" + endLL ) ; \nProjectionPointImpl endPP = ( ProjectionPointImpl ) proj . latLonToProj ( endLL ) ; \nSystem . out . println ( \"   end at proj coord \" + endPP ) ; \ndouble endx = 1 + getNx ( ) ; \ndouble endy = 1 + getNy ( ) ; \nSystem . out . println ( \"   should be x=\" + endx + \" y=\" + endy ) ; \n} \n} \n} \n"}
{"4393": "public class ErrorResponse { \npublic String buildXML ( ) { \nStringBuilder response = new StringBuilder ( ) ; \nresponse . append ( \"<Error\" ) ; \nif ( 0 < code ) response . append ( String . format ( \" httpcode=\\\"%d\\\"\" , code ) ) ; \nresponse . append ( \">\\n\" ) ; \nif ( message != null ) response . append ( \"<Message>\" + getMessage ( ) + \"</Message>\\n\" ) ; \nif ( context != null ) response . append ( \"<Context>\" + getContext ( ) + \"</Context>\\n\" ) ; \nif ( otherinfo != null ) response . append ( \"<OtherInformation>\" + getOtherInfo ( ) + \"</OtherInformation>\\n\" ) ; \nreturn response . toString ( ) ; \n} \n} \n"}
{"4396": "public class AWIPSConvention { \nprivate Dimension makeZCoordAxis ( NetcdfDataset ds , List < String > values , String units ) throws IOException { \nint len = values . size ( ) ; \nString name = makeZCoordName ( units ) ; \nif ( 1 < len ) name = name + Integer . toString ( len ) ; \nelse name = name + values . get ( 0 ) ; \nStringUtil2 . replace ( name , ' ' , \"-\" ) ; \nDimension dim ; \nif ( null != ( dim = ds . getRootGroup ( ) . findDimension ( name ) ) ) { \nif ( dim . getLength ( ) == len ) { \nVariable coord = ds . getRootGroup ( ) . findVariable ( name ) ; \nArray coordData = coord . read ( ) ; \nArray newData = Array . makeArray ( coord . getDataType ( ) , values ) ; \nif ( MAMath . nearlyEquals ( coordData , newData ) ) { \nif ( debugBreakup ) parseInfo . format ( \"  use existing coord %s%n\" , dim ) ; \nreturn dim ; \n} \n} \n} \nString orgName = name ; \nint count = 1 ; \nwhile ( ds . getRootGroup ( ) . findDimension ( name ) != null ) { \nname = orgName + \"-\" + count ; \ncount ++ ; \n} \ndim = new Dimension ( name , len ) ; \nds . addDimension ( null , dim ) ; \nif ( debugBreakup ) parseInfo . format ( \"  make Dimension = %s length = %d%n\" , name , len ) ; \nif ( debugBreakup ) { \nparseInfo . format ( \"  make ZCoordAxis = = %s length = %d%n\" , name , len ) ; \n} \nCoordinateAxis v = new CoordinateAxis1D ( ds , null , name , DataType . DOUBLE , name , makeUnitsName ( units ) , makeLongName ( name ) ) ; \nString positive = getZisPositive ( ds , v ) ; \nif ( null != positive ) v . addAttribute ( new Attribute ( _Coordinate . ZisPositive , positive ) ) ; \nv . setValues ( values ) ; \nds . addCoordinateAxis ( v ) ; \nparseInfo . format ( \"Created Z Coordinate Axis = \" ) ; \nv . getNameAndDimensions ( parseInfo , true , false ) ; \nparseInfo . format ( \"%n\" ) ; \nreturn dim ; \n} \n} \n"}
{"4400": "public class GribToNetcdfWriter { \npublic static void main ( String [ ] args ) { \nString fileIn = ( 0 < args . length ) ? args [ 0 ] : \"Q:/cdmUnitTest/formats/grib2/LMPEF_CLM_050518_1200.grb\" ; \nString fileOut = ( 1 < args . length ) ? args [ 1 ] : \"C:/tmp/ds.mint.bi\" ; \ntry ( GribToNetcdfWriter writer = new GribToNetcdfWriter ( fileIn , fileOut ) ) { \nwriter . write ( ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"4412": "public class Index { \npublic long index ( ) { \nlong offset = 0 ; \nfor ( int i = 0 ; \nthis . indices . length > i ; \ni ++ ) { \noffset *= this . dimsizes [ i ] ; \noffset += this . indices [ i ] ; \n} \nreturn offset ; \n} \n} \n"}
{"4415": "public class EsriShapefile { \nprivate void discretize ( double [ ] d , int n ) { \nif ( coarseness == 0.0 ) return ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nd [ i ] = ( Math . rint ( resolution * d [ i ] ) / resolution ) ; \n} \n} \n} \n"}
{"4417": "public class ThreddsMetadata { \npublic void addDocumentation ( String type , String content ) { \nif ( content == null ) { \nremoveDocumentation ( type ) ; \nreturn ; \n} \ncontent = content . trim ( ) ; \nfor ( InvDocumentation doc : getDocumentation ( ) ) { \nString dtype = doc . getType ( ) ; \nif ( ( dtype != null ) && dtype . equalsIgnoreCase ( type ) ) { \ndoc . setInlineContent ( content ) ; \nreturn ; \n} \n} \nif ( 0 < content . length ( ) ) addDocumentation ( new InvDocumentation ( null , null , null , type , content ) ) ; \n} \n} \n"}
{"4419": "public class LayoutSegmented { \nprivate int getMaxBytes ( long start ) { \nint segno = 0 ; \nwhile ( segMax [ segno ] <= start ) segno ++ ; \nreturn ( int ) ( segMax [ segno ] - start ) ; \n} \n} \n"}
{"4422": "public class CoordSysBuilder { \nstatic public List < String > breakupConventionNames ( String convAttValue ) { \nList < String > names = new ArrayList < > ( ) ; \nif ( ( 0 < convAttValue . indexOf ( ',' ) ) || ( 0 < convAttValue . indexOf ( ';' ) ) ) { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \",;\" ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \nelse if ( ( 0 < convAttValue . indexOf ( '/' ) ) ) { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \"/\" ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \nelse { \nStringTokenizer stoke = new StringTokenizer ( convAttValue , \" \" ) ; \nwhile ( stoke . hasMoreTokens ( ) ) { \nString name = stoke . nextToken ( ) ; \nnames . add ( name . trim ( ) ) ; \n} \n} \nreturn names ; \n} \n} \n"}
{"4428": "public class CoordSysBuilder { \nprotected void makeCoordinateSystemsMaximal ( NetcdfDataset ncDataset ) { \nboolean requireCompleteCoordSys = ! ncDataset . getEnhanceMode ( ) . contains ( NetcdfDataset . Enhance . IncompleteCoordSystems ) ; \nfor ( VarProcess vp : varList ) { \nVariableEnhanced ve = ( VariableEnhanced ) vp . v ; \nif ( vp . hasCoordinateSystem ( ) || ! vp . isData ( ) ) continue ; \nList < CoordinateAxis > axisList = new ArrayList < > ( ) ; \nList < CoordinateAxis > axes = ncDataset . getCoordinateAxes ( ) ; \nfor ( CoordinateAxis axis : axes ) { \nif ( isCoordinateAxisForVariable ( axis , ve ) ) axisList . add ( axis ) ; \n} \nif ( 2 > axisList . size ( ) ) continue ; \nString csName = CoordinateSystem . makeName ( axisList ) ; \nCoordinateSystem cs = ncDataset . findCoordinateSystem ( csName ) ; \nboolean okToBuild = false ; \nif ( requireCompleteCoordSys ) { \nif ( cs != null ) { \nokToBuild = cs . isComplete ( ve ) ; \n} \n} \nelse { \nokToBuild = true ; \n} \nif ( cs != null && okToBuild ) { \nve . addCoordinateSystem ( cs ) ; \nparseInfo . format ( \" assigned maximal CoordSystem '%s' for var= %s%n\" , cs . getName ( ) , ve . getFullName ( ) ) ; \n} \nelse { \nCoordinateSystem csnew = new CoordinateSystem ( ncDataset , axisList , null ) ; \nif ( requireCompleteCoordSys ) { \nokToBuild = csnew . isComplete ( ve ) ; \n} \nif ( okToBuild ) { \ncsnew . setImplicit ( true ) ; \nve . addCoordinateSystem ( csnew ) ; \nncDataset . addCoordinateSystem ( csnew ) ; \nparseInfo . format ( \" created maximal CoordSystem '%s' for var= %s%n\" , csnew . getName ( ) , ve . getFullName ( ) ) ; \n} \n} \n} \n} \n} \n"}
{"4429": "public class CoordSysBuilder { \nprotected boolean isCoordinateAxisForVariable ( Variable axis , VariableEnhanced v ) { \nList < Dimension > varDims = v . getDimensionsAll ( ) ; \nList < Dimension > axisDims = axis . getDimensionsAll ( ) ; \nint checkDims = axisDims . size ( ) ; \nif ( axis . getDataType ( ) == DataType . CHAR ) checkDims -- ; \nfor ( int i = 0 ; \ncheckDims > i ; \ni ++ ) { \nDimension axisDim = axisDims . get ( i ) ; \nif ( ! varDims . contains ( axisDim ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"4433": "public class InvCatalogImpl { \nprivate boolean mark ( DatasetFilter filter , InvDatasetImpl ds ) { \nif ( ds instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) ds ; \nif ( ! catRef . isRead ( ) ) return false ; \n} \nboolean allMarked = true ; \nfor ( InvDataset nested : ds . getDatasets ( ) ) { \nallMarked &= mark ( filter , ( InvDatasetImpl ) nested ) ; \n} \nif ( ! allMarked ) return false ; \nif ( 0 <= filter . accept ( ds ) ) return false ; \nds . setMark ( true ) ; \nif ( debugFilter ) System . out . println ( \" mark \" + ds . getName ( ) ) ; \nreturn true ; \n} \n} \n"}
{"4435": "public class LoadCommon { \npublic void initOnce ( HttpServletRequest req ) throws SendError { \nif ( once ) return ; \nonce = true ; \nlog . info ( getClass ( ) . getName ( ) + \" GET initialization\" ) ; \nif ( this . tdsContext == null ) throw new SendError ( HttpServletResponse . SC_INTERNAL_SERVER_ERROR , \"Cannot find TDS Context\" ) ; \nStringBuilder buf = new StringBuilder ( ) ; \nbuf . append ( req . getServerName ( ) ) ; \nint port = req . getServerPort ( ) ; \nif ( 0 < port ) { \nbuf . append ( \":\" ) ; \nbuf . append ( port ) ; \n} \nthis . server = buf . toString ( ) ; \nString tmp = HTTPUtil . canonicalpath ( req . getContextPath ( ) ) ; \nthis . threddsname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; \ntmp = HTTPUtil . canonicalpath ( req . getServletPath ( ) ) ; \nthis . requestname = HTTPUtil . nullify ( HTTPUtil . relpath ( tmp ) ) ; \nif ( this . threddsname == null ) this . threddsname = DEFAULTSERVLETNAME ; \nFile updir = tdsContext . getUploadDir ( ) ; \nif ( updir == null ) { \nlog . warn ( \"No tds.upload.dir specified\" ) ; \nthis . uploaddir = null ; \n} \nelse this . uploaddir = HTTPUtil . canonicalpath ( updir . getAbsolutePath ( ) ) ; \nFile downdir = tdsContext . getDownloadDir ( ) ; \nif ( downdir == null ) { \nlog . warn ( \"No tds.download.dir specified\" ) ; \nthis . downloaddir = null ; \n} \nelse this . downloaddir = HTTPUtil . canonicalpath ( downdir . getAbsolutePath ( ) ) ; \n} \n} \n"}
{"4443": "public class SliceIterator { \n@ Override public boolean hasNext ( ) { \nswitch ( state ) { \ncase INITIAL : return ( slice . getStop ( ) > slice . getFirst ( ) ) ; \ncase STARTED : return ( slice . getLast ( ) > this . index ) ; \ncase DONE : } \nreturn false ; \n} \n} \n"}
{"4447": "public class DSPRegistry { \nsynchronized public void unregister ( Class < ? extends DSP > klass ) { \nfor ( int i = 0 ; \nregistry . size ( ) > i ; \ni ++ ) { \nif ( registry . get ( i ) . dspclass == klass ) { \nregistry . remove ( i ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4452": "public class DapDataset { \npublic void finish ( ) { \nif ( this . finished ) return ; \nif ( this . ce == null ) this . visiblenodes = nodelist ; \nelse { \nthis . visiblenodes = new ArrayList < DapNode > ( nodelist . size ( ) ) ; \nfor ( int i = 0 ; \nnodelist . size ( ) > i ; \ni ++ ) { \nDapNode node = nodelist . get ( i ) ; \nif ( ce . references ( node ) ) visiblenodes . add ( node ) ; \n} \n} \nthis . topvariables = new ArrayList < DapVariable > ( ) ; \nthis . allvariables = new ArrayList < DapVariable > ( ) ; \nthis . allgroups = new ArrayList < DapGroup > ( ) ; \nthis . allenums = new ArrayList < DapEnumeration > ( ) ; \nthis . allcompounds = new ArrayList < DapStructure > ( ) ; \nthis . alldimensions = new ArrayList < DapDimension > ( ) ; \nfinishR ( this ) ; \n} \n} \n"}
{"4453": "public class DapDataset { \npublic void sort ( ) { \nList < DapNode > sorted = new ArrayList < DapNode > ( ) ; \nsortR ( this , sorted ) ; \nfor ( int i = 0 ; \nsorted . size ( ) > i ; \ni ++ ) { \nsorted . get ( i ) . setIndex ( i ) ; \n} \nthis . nodelist = sorted ; \n} \n} \n"}
{"4465": "public class CoordinateAxis2D { \nstatic private double connectLon ( double connect , double val ) { \nif ( Double . isNaN ( connect ) ) return val ; \nif ( Double . isNaN ( val ) ) return val ; \ndouble diff = val - connect ; \nif ( MAX_JUMP > Math . abs ( diff ) ) return val ; \ndouble result = 0 < diff ? val - 360 : val + 360 ; \ndouble diff2 = connect - result ; \nif ( Math . abs ( diff ) > ( Math . abs ( diff2 ) ) ) val = result ; \nreturn val ; \n} \n} \n"}
{"4468": "public class CoordinateAxis2D { \nprivate int findClosest ( ArrayDouble . D2 boundsForRun , double target ) { \ndouble minDiff = Double . MAX_VALUE ; \nint idxFound = - 1 ; \nint n = boundsForRun . getShape ( ) [ 0 ] ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \ndouble midpoint = ( boundsForRun . get ( i , 0 ) + boundsForRun . get ( i , 1 ) ) / 2.0 ; \ndouble diff = Math . abs ( midpoint - target ) ; \nif ( minDiff > diff ) { \nminDiff = diff ; \nidxFound = i ; \n} \n} \nreturn idxFound ; \n} \n} \n"}
{"4473": "public class KMPMatch { \npublic int indexOf ( byte [ ] data , int start , int max ) { \nint j = 0 ; \nif ( data . length == 0 ) return - 1 ; \nif ( data . length < start + max ) System . out . println ( \"HEY KMPMatch\" ) ; \nfor ( int i = start ; \nstart + max > i ; \ni ++ ) { \nwhile ( 0 < j && match [ j ] != data [ i ] ) j = failure [ j - 1 ] ; \nif ( match [ j ] == data [ i ] ) j ++ ; \nif ( j == match . length ) return i - match . length + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"4474": "public class PictureCache { \npublic static synchronized void add ( URL url , SourcePicture sp ) { \nTools . log ( \"PictureCache.add: \" + url . toString ( ) ) ; \nif ( sp . getSourceBufferedImage ( ) == null ) { \nTools . log ( \"PictureCache.add: invoked with a null picture! Not cached!\" ) ; \nreturn ; \n} \nif ( ( 1 > maxCache ) ) { \nTools . log ( \"PictureCache.add: cache is diabled. Not adding picture.\" ) ; \nreturn ; \n} \nif ( isInCache ( url ) ) { \nTools . log ( \"Picture \" + url . toString ( ) + \" is already in the cache. Not adding again.\" ) ; \nreturn ; \n} \nif ( maxCache <= pictureCache . size ( ) ) removeLeastPopular ( ) ; \nif ( maxCache > pictureCache . size ( ) ) pictureCache . put ( url . toString ( ) , sp ) ; \n} \n} \n"}
{"4481": "public class RandomValue { \npublic int nextCount ( int max ) throws DapException { \nint min = 1 ; \nif ( min > max || 1 > min ) throw new DapException ( \"bad range\" ) ; \nint range = ( max + 1 ) - min ; \nint n = random . nextInt ( range ) ; \nn = n + min ; \nif ( DEBUG ) System . err . println ( \"RandomValue.nextCount: \" + n ) ; \nreturn n ; \n} \n} \n"}
{"4482": "public class DapNetcdfFile { \n@ Override protected Array readData ( Variable cdmvar , Section section ) throws IOException , InvalidRangeException { \nassert this . dsp != null ; \nArray result = arraymap . get ( cdmvar ) ; \nif ( result == null ) throw new IOException ( \"No data for variable: \" + cdmvar . getFullName ( ) ) ; \nif ( section != null ) { \nif ( cdmvar . getRank ( ) != section . getRank ( ) ) throw new InvalidRangeException ( String . format ( \"Section rank != %s rank\" , cdmvar . getFullName ( ) ) ) ; \nList < Range > ranges = section . getRanges ( ) ; \nif ( CDMUtil . hasVLEN ( ranges ) ) { \nranges = ranges . subList ( 0 , ranges . size ( ) - 1 ) ; \n} \nif ( 0 < ranges . size ( ) && ! CDMUtil . isWhole ( ranges , cdmvar ) ) result = result . sectionNoReduce ( ranges ) ; \n} \nreturn result ; \n} \n} \n"}
{"4489": "public class ColorScale { \npublic void setNumColors ( int n ) { \nif ( n != ncolors ) { \ncolors = new Color [ n ] ; \nint prevn = Math . min ( ncolors , n ) ; \nSystem . arraycopy ( useColors , 0 , colors , 0 , prevn ) ; \nfor ( int i = ncolors ; \nn > i ; \ni ++ ) colors [ i ] = Color . white ; \nuseColors = colors ; \nncolors = n ; \nedge = new double [ ncolors ] ; \nhist = new int [ ncolors + 1 ] ; \n} \n} \n} \n"}
{"4495": "public class SmartArrayInt { \npublic int findIdx ( int want ) { \nif ( isConstant ) return ( want == start ) ? 0 : - 1 ; \nif ( isSequential ) return want - start ; \nif ( isSorted ) { \nreturn Arrays . binarySearch ( raw , want ) ; \n} \nfor ( int i = 0 ; \nraw . length > i ; \ni ++ ) if ( raw [ i ] == want ) return i ; \nreturn - 1 ; \n} \n} \n"}
{"4500": "public class CatGenConfigMetadataFactory { \nprivate CatalogGenConfig readCatGenConfigElement ( InvDataset parentDataset , Element catGenConfElement ) { \nString type = catGenConfElement . getAttributeValue ( \"type\" ) ; \nCatalogGenConfig catGenConf = new CatalogGenConfig ( parentDataset , type ) ; \njava . util . List list = catGenConfElement . getChildren ( \"datasetSource\" , catGenConfElement . getNamespace ( ) ) ; \nfor ( int i = 0 ; \nlist . size ( ) > i ; \ni ++ ) { \nElement dsSourceElement = ( Element ) list . get ( i ) ; \ncatGenConf . setDatasetSource ( readDatasetSourceElement ( parentDataset , dsSourceElement ) ) ; \n} \nreturn ( catGenConf ) ; \n} \n} \n"}
{"4501": "public class CatGenConfigMetadataFactory { \nprivate DatasetSource readDatasetSourceElement ( InvDataset parentDataset , Element dsSourceElement ) { \nString name = dsSourceElement . getAttributeValue ( \"name\" ) ; \nString type = dsSourceElement . getAttributeValue ( \"type\" ) ; \nString structure = dsSourceElement . getAttributeValue ( \"structure\" ) ; \nString accessPoint = dsSourceElement . getAttributeValue ( \"accessPoint\" ) ; \nString createCatalogRefs = dsSourceElement . getAttributeValue ( \"createCatalogRefs\" ) ; \nElement resultServiceElement = dsSourceElement . getChild ( \"resultService\" , dsSourceElement . getNamespace ( ) ) ; \nResultService resultService = readResultServiceElement ( parentDataset , resultServiceElement ) ; \nDatasetSource dsSource = DatasetSource . newDatasetSource ( name , DatasetSourceType . getType ( type ) , DatasetSourceStructure . getStructure ( structure ) , accessPoint , resultService ) ; \nif ( createCatalogRefs != null ) { \ndsSource . setCreateCatalogRefs ( Boolean . valueOf ( createCatalogRefs ) . booleanValue ( ) ) ; \n} \njava . util . List list = dsSourceElement . getChildren ( \"datasetNamer\" , dsSourceElement . getNamespace ( ) ) ; \nfor ( int i = 0 ; \nlist . size ( ) > i ; \ni ++ ) { \nElement dsNamerElement = ( Element ) list . get ( i ) ; \ndsSource . addDatasetNamer ( readDatasetNamerElement ( parentDataset , dsNamerElement ) ) ; \n} \nlist = dsSourceElement . getChildren ( \"datasetFilter\" , dsSourceElement . getNamespace ( ) ) ; \nfor ( int i = 0 ; \nlist . size ( ) > i ; \ni ++ ) { \nElement dsFilterElement = ( Element ) list . get ( i ) ; \ndsSource . addDatasetFilter ( readDatasetFilterElement ( dsSource , dsFilterElement ) ) ; \n} \nreturn ( dsSource ) ; \n} \n} \n"}
{"4506": "public class CatGenConfigMetadataFactory { \nprivate org . jdom2 . Element createDatasetSourceElement ( DatasetSource dsSource ) { \nElement dssElem = new Element ( \"datasetSource\" , CATALOG_GEN_CONFIG_NAMESPACE_0_5 ) ; \nif ( dsSource != null ) { \nif ( dsSource . getName ( ) != null ) { \ndssElem . setAttribute ( \"name\" , dsSource . getName ( ) ) ; \n} \nif ( dsSource . getType ( ) != null ) { \ndssElem . setAttribute ( \"type\" , dsSource . getType ( ) . toString ( ) ) ; \n} \nif ( dsSource . getStructure ( ) != null ) { \ndssElem . setAttribute ( \"structure\" , dsSource . getStructure ( ) . toString ( ) ) ; \n} \nif ( dsSource . getAccessPoint ( ) != null ) { \ndssElem . setAttribute ( \"accessPoint\" , dsSource . getAccessPoint ( ) ) ; \n} \ndssElem . setAttribute ( \"createCatalogRefs\" , Boolean . toString ( dsSource . isCreateCatalogRefs ( ) ) ) ; \nResultService rs = dsSource . getResultService ( ) ; \ndssElem . addContent ( createResultServiceElement ( rs ) ) ; \njava . util . List list = dsSource . getDatasetNamerList ( ) ; \nfor ( int j = 0 ; \nlist . size ( ) > j ; \nj ++ ) { \nDatasetNamer dsNamer = ( DatasetNamer ) list . get ( j ) ; \ndssElem . addContent ( createDatasetNamerElement ( dsNamer ) ) ; \n} \nlist = dsSource . getDatasetFilterList ( ) ; \nfor ( int j = 0 ; \nlist . size ( ) > j ; \nj ++ ) { \nDatasetFilter dsFilter = ( DatasetFilter ) list . get ( j ) ; \ndssElem . addContent ( createDatasetFilterElement ( dsFilter ) ) ; \n} \n} \nreturn ( dssElem ) ; \n} \n} \n"}
{"4510": "public class Debug { \nstatic public boolean isSet ( String flagName ) { \nif ( store == null ) return false ; \nNamePart np = partit ( flagName ) ; \nif ( debug ) { \ntry { \nif ( ( 0 < np . storeName . length ( ) ) && ! store . nodeExists ( np . storeName ) ) System . out . println ( \"Debug.isSet create node = \" + flagName + \" \" + np ) ; \nelse if ( null == store . node ( np . storeName ) . get ( np . keyName , null ) ) System . out . println ( \"Debug.isSet create flag = \" + flagName + \" \" + np ) ; \n} \ncatch ( BackingStoreException e ) { \n} \n} \nboolean value = store . node ( np . storeName ) . getBoolean ( np . keyName , false ) ; \nstore . node ( np . storeName ) . putBoolean ( np . keyName , value ) ; \nreturn value ; \n} \n} \n"}
{"4511": "public class Debug { \nstatic public void constructMenu ( JMenu topMenu ) { \nif ( debug ) System . out . println ( \"Debug.constructMenu \" ) ; \nif ( 0 < topMenu . getItemCount ( ) ) topMenu . removeAll ( ) ; \ntry { \naddToMenu ( topMenu , store ) ; \n} \ncatch ( BackingStoreException e ) { \n} \ntopMenu . revalidate ( ) ; \n} \n} \n"}
{"4513": "public class GempakParameterTable { \npublic void addParameters ( String tbl ) throws IOException { \ntry ( InputStream is = getInputStream ( tbl ) ) { \nif ( is == null ) { \nthrow new IOException ( \"Unable to open \" + tbl ) ; \n} \nString content = readContents ( is ) ; \nString [ ] lines = content . split ( \"\\n\" ) ; \nList < String [ ] > result = new ArrayList < > ( ) ; \nfor ( String line : lines ) { \nString tline = line . trim ( ) ; \nif ( tline . length ( ) == 0 ) { \ncontinue ; \n} \nif ( tline . startsWith ( \"!\" ) ) { \ncontinue ; \n} \nString [ ] words = new String [ indices . length ] ; \nfor ( int idx = 0 ; \nindices . length > idx ; \nidx ++ ) { \nif ( tline . length ( ) <= indices [ idx ] ) { \ncontinue ; \n} \nif ( tline . length ( ) < indices [ idx ] + lengths [ idx ] ) { \nwords [ idx ] = line . substring ( indices [ idx ] ) ; \n} \nelse { \nwords [ idx ] = line . substring ( indices [ idx ] , indices [ idx ] + lengths [ idx ] ) ; \n} \nwords [ idx ] = words [ idx ] . trim ( ) ; \n} \nresult . add ( words ) ; \n} \nfor ( String [ ] aResult : result ) { \nGempakParameter p = makeParameter ( aResult ) ; \nif ( p != null ) { \nif ( p . getName ( ) . contains ( \"(\" ) ) { \ntemplateParamMap . put ( p . getName ( ) , p ) ; \n} \nelse { \nparamMap . put ( p . getName ( ) , p ) ; \n} \n} \n} \n} \n} \n} \n"}
{"4514": "public class GempakParameterTable { \nprivate GempakParameter makeParameter ( String [ ] words ) { \nint num = 0 ; \nString description ; \nif ( words [ 0 ] != null ) { \nnum = ( int ) Double . parseDouble ( words [ 0 ] ) ; \n} \nif ( ( words [ 3 ] == null ) || words [ 3 ] . equals ( \"\" ) ) { \nreturn null ; \n} \nString name = words [ 3 ] ; \nif ( name . contains ( \"-\" ) ) { \nint first = name . indexOf ( \"-\" ) ; \nint last = name . lastIndexOf ( \"-\" ) ; \nStringBuilder buf = new StringBuilder ( name . substring ( 0 , first ) ) ; \nbuf . append ( \"(\" ) ; \nfor ( int i = first ; \nlast >= i ; \ni ++ ) { \nbuf . append ( \"\\\\d\" ) ; \n} \nbuf . append ( \")\" ) ; \nbuf . append ( name . substring ( last + 1 ) ) ; \nname = buf . toString ( ) ; \n} \nif ( ( words [ 1 ] == null ) || words [ 1 ] . equals ( \"\" ) ) { \ndescription = words [ 3 ] ; \n} \nelse { \ndescription = words [ 1 ] ; \n} \nString unit = words [ 2 ] ; \nif ( unit != null ) { \nunit = unit . replaceAll ( \"\\\\*\\\\*\" , \"\" ) ; \nif ( unit . equals ( \"-\" ) ) { \nunit = \"\" ; \n} \n} \nint decimalScale ; \ntry { \ndecimalScale = Integer . parseInt ( words [ 4 ] . trim ( ) ) ; \n} \ncatch ( NumberFormatException ne ) { \ndecimalScale = 0 ; \n} \nreturn new GempakParameter ( num , name , description , unit , decimalScale ) ; \n} \n} \n"}
{"4517": "public class GempakParameterTable { \nprivate byte [ ] readBytes ( InputStream is ) throws IOException { \nint totalRead = 0 ; \nbyte [ ] content = new byte [ 1000000 ] ; \nwhile ( true ) { \nint howMany = is . read ( content , totalRead , content . length - totalRead ) ; \nif ( 0 > howMany ) { \nbreak ; \n} \nif ( howMany == 0 ) { \ncontinue ; \n} \ntotalRead += howMany ; \nif ( content . length <= totalRead ) { \nbyte [ ] tmp = content ; \nint newLength = ( ( 25000000 > content . length ) ? content . length * 2 : content . length + 5000000 ) ; \ncontent = new byte [ newLength ] ; \nSystem . arraycopy ( tmp , 0 , content , 0 , totalRead ) ; \n} \n} \nis . close ( ) ; \nbyte [ ] results = new byte [ totalRead ] ; \nSystem . arraycopy ( content , 0 , results , 0 , totalRead ) ; \nreturn results ; \n} \n} \n"}
{"4525": "public class DODSNetcdfFile { \nNamePieces parseName ( String name ) { \nNamePieces pieces = new NamePieces ( ) ; \nint dotpos = name . lastIndexOf ( '.' ) ; \nint slashpos = name . lastIndexOf ( '/' ) ; \nif ( 0 > slashpos && 0 > dotpos ) { \npieces . name = name ; \n} \nelse if ( 0 <= slashpos && 0 > dotpos ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse if ( 0 > slashpos && 0 <= dotpos ) { \npieces . var = name . substring ( 0 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \nelse { \nif ( dotpos < slashpos ) { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . name = name . substring ( slashpos + 1 , name . length ( ) ) ; \n} \nelse { \npieces . prefix = name . substring ( 0 , slashpos ) ; \npieces . var = name . substring ( slashpos + 1 , dotpos ) ; \npieces . name = name . substring ( dotpos + 1 , name . length ( ) ) ; \n} \n} \nif ( pieces . prefix != null && pieces . prefix . length ( ) == 0 ) pieces . prefix = null ; \nif ( pieces . var != null && pieces . var . length ( ) == 0 ) pieces . var = null ; \nif ( pieces . name . length ( ) == 0 ) pieces . name = null ; \nreturn pieces ; \n} \n} \n"}
{"4527": "public class DODSNetcdfFile { \nDimension getNetcdfStrlenDim ( DODSVariable v ) { \nAttributeTable table = das . getAttributeTableN ( v . getFullName ( ) ) ; \nif ( table == null ) return null ; \nopendap . dap . Attribute dodsAtt = table . getAttribute ( \"DODS\" ) ; \nif ( dodsAtt == null ) return null ; \nAttributeTable dodsTable = dodsAtt . getContainerN ( ) ; \nif ( dodsTable == null ) return null ; \nopendap . dap . Attribute att = dodsTable . getAttribute ( \"strlen\" ) ; \nif ( att == null ) return null ; \nString strlen = att . getValueAtN ( 0 ) ; \nopendap . dap . Attribute att2 = dodsTable . getAttribute ( \"dimName\" ) ; \nString dimName = ( att2 == null ) ? null : att2 . getValueAtN ( 0 ) ; \nif ( debugCharArray ) System . out . println ( v . getFullName ( ) + \" has strlen= \" + strlen + \" dimName= \" + dimName ) ; \nint dimLength ; \ntry { \ndimLength = Integer . parseInt ( strlen ) ; \n} \ncatch ( NumberFormatException e ) { \nlogger . warn ( \"DODSNetcdfFile \" + location + \" var = \" + v . getFullName ( ) + \" error on strlen attribute = \" + strlen ) ; \nreturn null ; \n} \nif ( 0 >= dimLength ) return null ; \nreturn new Dimension ( dimName , dimLength , dimName != null ) ; \n} \n} \n"}
{"4529": "public class DODSNetcdfFile { \nList < Dimension > constructDimensions ( Group group , opendap . dap . DArray dodsArray ) { \nif ( group == null ) group = rootGroup ; \nList < Dimension > dims = new ArrayList < Dimension > ( ) ; \nEnumeration enumerate = dodsArray . getDimensions ( ) ; \nwhile ( enumerate . hasMoreElements ( ) ) { \nopendap . dap . DArrayDimension dad = ( opendap . dap . DArrayDimension ) enumerate . nextElement ( ) ; \nString name = dad . getEncodedName ( ) ; \nif ( name != null ) name = StringUtil2 . unescape ( name ) ; \nDimension myd ; \nif ( name == null ) { \nmyd = new Dimension ( null , dad . getSize ( ) , false ) ; \n} \nelse { \nif ( RC . getUseGroups ( ) ) { \nif ( 0 <= name . indexOf ( '/' ) ) { \ngroup = group . makeRelativeGroup ( this , name , true ) ; \nname = name . substring ( name . lastIndexOf ( '/' ) + 1 ) ; \n} \n} \nmyd = group . findDimension ( name ) ; \nif ( myd == null ) { \nmyd = new Dimension ( name , dad . getSize ( ) ) ; \ngroup . addDimension ( myd ) ; \n} \nelse if ( myd . getLength ( ) != dad . getSize ( ) ) { \nmyd = new Dimension ( name , dad . getSize ( ) , false ) ; \n} \n} \ndims . add ( myd ) ; \n} \nreturn dims ; \n} \n} \n"}
{"4541": "public class IospHelper { \nstatic public char [ ] convertByteToChar ( byte [ ] byteArray ) { \nint size = byteArray . length ; \nchar [ ] cbuff = new char [ size ] ; \nfor ( int i = 0 ; \nsize > i ; \ni ++ ) cbuff [ i ] = ( char ) DataType . unsignedByteToShort ( byteArray [ i ] ) ; \nreturn cbuff ; \n} \nstatic public byte [ ] convertCharToByte ( char [ ] from ) { \nbyte [ ] to = null ; \nif ( from != null ) { \nint size = from . length ; \nto = new byte [ size ] ; \nfor ( int i = 0 ; \nsize > i ; \ni ++ ) to [ i ] = ( byte ) from [ i ] ; \n} \nreturn to ; \n} \n} \n"}
{"4547": "public class CDMArrayStructure { \nstatic StructureMembers computemembers ( DapVariable var ) { \nDapStructure ds = ( DapStructure ) var . getBaseType ( ) ; \nStructureMembers sm = new StructureMembers ( ds . getShortName ( ) ) ; \nList < DapVariable > fields = ds . getFields ( ) ; \nfor ( int i = 0 ; \nfields . size ( ) > i ; \ni ++ ) { \nDapVariable field = fields . get ( i ) ; \nDapType dt = field . getBaseType ( ) ; \nDataType cdmtype = CDMTypeFcns . daptype2cdmtype ( dt ) ; \nStructureMembers . Member m = sm . addMember ( field . getShortName ( ) , \"\" , null , cdmtype , CDMUtil . computeEffectiveShape ( field . getDimensions ( ) ) ) ; \nm . setDataParam ( i ) ; \nif ( dt . getTypeSort ( ) . isStructType ( ) ) { \nStructureMembers subsm = computemembers ( field ) ; \nm . setStructureMembers ( subsm ) ; \n} \n} \nreturn sm ; \n} \n} \n"}
{"4555": "public class Aggregation { \nprotected Dataset getTypicalDataset ( ) throws IOException { \nList < Dataset > nestedDatasets = getDatasets ( ) ; \nint n = nestedDatasets . size ( ) ; \nif ( n == 0 ) throw new FileNotFoundException ( \"No datasets in this aggregation\" ) ; \nint select ; \nif ( typicalDatasetMode == TypicalDataset . LATEST ) select = n - 1 ; \nelse if ( typicalDatasetMode == TypicalDataset . PENULTIMATE ) select = ( 2 > n ) ? 0 : n - 2 ; \nelse if ( typicalDatasetMode == TypicalDataset . FIRST ) select = 0 ; \nelse { \nif ( r == null ) r = new Random ( ) ; \nselect = ( 2 > n ) ? 0 : r . nextInt ( n ) ; \n} \nreturn nestedDatasets . get ( select ) ; \n} \n} \n"}
{"4558": "public class CFLine { \npublic void addPoint ( double x , double y ) { \nPoint ptPrev = null ; \nif ( 0 < points . size ( ) ) { \nptPrev = points . get ( points . size ( ) - 1 ) ; \n} \nthis . points . add ( new CFPoint ( x , y , ptPrev , null , null ) ) ; \n} \n} \n"}
{"4559": "public class CFLine { \npublic double [ ] getBBUpper ( ) { \ndouble [ ] bbUpper = new double [ 2 ] ; \nList < Point > ptList = this . getPoints ( ) ; \nif ( ptList . isEmpty ( ) ) return null ; \nbbUpper [ 0 ] = ptList . get ( 0 ) . getY ( ) ; \nbbUpper [ 1 ] = ptList . get ( 0 ) . getY ( ) ; \nfor ( Point pt : this . getPoints ( ) ) { \nif ( pt . getX ( ) > bbUpper [ 0 ] ) { \nbbUpper [ 0 ] = pt . getX ( ) ; \n} \nif ( pt . getY ( ) > bbUpper [ 1 ] ) { \nbbUpper [ 1 ] = pt . getY ( ) ; \n} \n} \nbbUpper [ 0 ] += 10 ; \nbbUpper [ 1 ] += 10 ; \nreturn bbUpper ; \n} \n} \n"}
{"4560": "public class CFLine { \npublic double [ ] getBBLower ( ) { \ndouble [ ] bbLower = new double [ 2 ] ; \nList < Point > ptList = this . getPoints ( ) ; \nif ( ptList . isEmpty ( ) ) return null ; \nbbLower [ 0 ] = ptList . get ( 0 ) . getY ( ) ; \nbbLower [ 1 ] = ptList . get ( 0 ) . getY ( ) ; \nfor ( Point pt : this . getPoints ( ) ) { \nif ( pt . getX ( ) < bbLower [ 0 ] ) { \nbbLower [ 0 ] = pt . getX ( ) ; \n} \nif ( pt . getY ( ) < bbLower [ 1 ] ) { \nbbLower [ 1 ] = pt . getY ( ) ; \n} \n} \nbbLower [ 0 ] -= 10 ; \nbbLower [ 1 ] -= 10 ; \nreturn bbLower ; \n} \n} \n"}
{"4561": "public class DatasetFilter { \nboolean validate ( StringBuilder out ) { \nthis . isValid = true ; \nif ( 0 < this . log . length ( ) ) { \nout . append ( this . log ) ; \n} \nif ( this . getName ( ) == null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (4): null value for name is not valid.\" ) ; \n} \nif ( this . getType ( ) == null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (5): null value for type is not valid (set with bad string?).\" ) ; \n} \nif ( this . type == DatasetFilter . Type . REGULAR_EXPRESSION && this . matchPattern == null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (6): null value for matchPattern not valid when type is 'RegExp'.\" ) ; \n} \nif ( this . type != DatasetFilter . Type . REGULAR_EXPRESSION && this . type != null && this . matchPattern != null ) { \nisValid = false ; \nout . append ( \" ** DatasetFilter (7): matchPattern value (\" + this . matchPattern + \") must be null if type is not 'RegExp'.\" ) ; \n} \nreturn ( this . isValid ) ; \n} \n} \n"}
{"4568": "public class HdfEos { \nprivate void setSharedDimensions ( Variable v , List < Element > values , List < Dimension > unknownDims , String location ) { \nif ( values . size ( ) == 0 ) { \nreturn ; \n} \nIterator < Element > iter = values . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nElement value = iter . next ( ) ; \nString dimName = value . getText ( ) . trim ( ) ; \nif ( dimName . equalsIgnoreCase ( \"scalar\" ) ) { \niter . remove ( ) ; \n} \n} \nList < Dimension > oldDims = v . getDimensions ( ) ; \nif ( oldDims . size ( ) != values . size ( ) ) { \nlog . error ( \"Different number of dimensions for {} {}\" , v , location ) ; \nreturn ; \n} \nList < Dimension > newDims = new ArrayList < > ( ) ; \nGroup group = v . getParentGroup ( ) ; \nfor ( int i = 0 ; \nvalues . size ( ) > i ; \ni ++ ) { \nElement value = values . get ( i ) ; \nString dimName = value . getText ( ) . trim ( ) ; \ndimName = NetcdfFile . makeValidCdmObjectName ( dimName ) ; \nDimension dim = group . findDimension ( dimName ) ; \nDimension oldDim = oldDims . get ( i ) ; \nif ( dim == null ) { \ndim = checkUnknownDims ( dimName , unknownDims , oldDim , location ) ; \n} \nif ( dim == null ) { \nlog . error ( \"Unknown Dimension= {} for variable = {} {} \" , dimName , v . getFullName ( ) , location ) ; \nreturn ; \n} \nif ( dim . getLength ( ) != oldDim . getLength ( ) ) { \nlog . error ( \"Shared dimension ({}) has different length than data dimension ({}) shared={} org={} for {} {}\" , dim . getShortName ( ) , oldDim . getShortName ( ) , dim . getLength ( ) , oldDim . getLength ( ) , v , location ) ; \nreturn ; \n} \nnewDims . add ( dim ) ; \n} \nv . setDimensions ( newDims ) ; \nif ( showWork ) { \nlog . debug ( \" set shared dimensions for {}\" , v . getNameAndDimensions ( ) ) ; \n} \n} \n} \n"}
{"4578": "public class LayoutM { \npublic void layoutContainer ( Container target ) { \nsynchronized ( target . getTreeLock ( ) ) { \nif ( debug ) System . out . println ( name + \" layoutContainer \" ) ; \nint n = target . getComponentCount ( ) ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nComponent comp = target . getComponent ( i ) ; \nif ( comp instanceof Container ) { \nContainer c = ( Container ) comp ; \nLayoutManager m = c . getLayout ( ) ; \nif ( m instanceof LayoutM ) m . layoutContainer ( c ) ; \n} \n} \nreset ( target ) ; \nglobalBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; \nwhile ( ! layoutPass ( target ) ) target . setPreferredSize ( globalBounds . getSize ( ) ) ; \n} \n} \n} \n"}
{"4582": "public class GEOSTransform { \npublic double [ ] earthToSat ( double geographic_lon , double geographic_lat ) { \ngeographic_lat = geographic_lat * DEG_TO_RAD ; \ngeographic_lon = geographic_lon * DEG_TO_RAD ; \ndouble geocentric_lat = Math . atan ( ( ( r_pol * r_pol ) / ( r_eq * r_eq ) ) * Math . tan ( geographic_lat ) ) ; \ndouble r_earth = r_pol / Math . sqrt ( 1.0 - ( ( r_eq * r_eq - r_pol * r_pol ) / ( r_eq * r_eq ) ) * Math . cos ( geocentric_lat ) * Math . cos ( geocentric_lat ) ) ; \ndouble r_1 = h - r_earth * Math . cos ( geocentric_lat ) * Math . cos ( geographic_lon - sub_lon ) ; \ndouble r_2 = - r_earth * Math . cos ( geocentric_lat ) * Math . sin ( geographic_lon - sub_lon ) ; \ndouble r_3 = r_earth * Math . sin ( geocentric_lat ) ; \nif ( h < r_1 ) { \nreturn new double [ ] { \nDouble . NaN , Double . NaN } \n; \n} \ndouble lamda_sat = Double . NaN ; \ndouble theta_sat = Double . NaN ; \nif ( scan_geom . equals ( GEOS ) ) { \nlamda_sat = Math . atan ( - r_2 / r_1 ) ; \ntheta_sat = Math . asin ( r_3 / Math . sqrt ( r_1 * r_1 + r_2 * r_2 + r_3 * r_3 ) ) ; \n} \nelse if ( scan_geom . equals ( GOES ) ) { \nlamda_sat = Math . asin ( - r_2 / Math . sqrt ( r_1 * r_1 + r_2 * r_2 + r_3 * r_3 ) ) ; \ntheta_sat = Math . atan ( r_3 / r_1 ) ; \n} \nreturn new double [ ] { \nlamda_sat , theta_sat } \n; \n} \n} \n"}
{"4583": "public class GEOSTransform { \npublic double [ ] satToEarth ( double x , double y ) { \nif ( scan_geom . equals ( GOES ) ) { \ndouble [ ] lambda_theta_geos = GOES_to_GEOS ( x , y ) ; \nx = lambda_theta_geos [ 0 ] ; \ny = lambda_theta_geos [ 1 ] ; \n} \ndouble c1 = ( h * Math . cos ( x ) * Math . cos ( y ) ) * ( h * Math . cos ( x ) * Math . cos ( y ) ) ; \ndouble c2 = ( Math . cos ( y ) * Math . cos ( y ) + fp * Math . sin ( y ) * Math . sin ( y ) ) * d ; \nif ( c2 > c1 ) { \nreturn new double [ ] { \nDouble . NaN , Double . NaN } \n; \n} \ndouble s_d = Math . sqrt ( c1 - c2 ) ; \ndouble s_n = ( h * Math . cos ( x ) * Math . cos ( y ) - s_d ) / ( Math . cos ( y ) * Math . cos ( y ) + fp * Math . sin ( y ) * Math . sin ( y ) ) ; \ndouble s_1 = h - s_n * Math . cos ( x ) * Math . cos ( y ) ; \ndouble s_2 = s_n * Math . sin ( x ) * Math . cos ( y ) ; \ndouble s_3 = - s_n * Math . sin ( y ) ; \ndouble s_xy = Math . sqrt ( s_1 * s_1 + s_2 * s_2 ) ; \ndouble geographic_lon = Math . atan ( s_2 / s_1 ) + sub_lon ; \ndouble geographic_lat = Math . atan ( - fp * ( s_3 / s_xy ) ) ; \ndouble lonDegrees = RAD_TO_DEG * geographic_lon ; \ndouble latDegrees = RAD_TO_DEG * geographic_lat ; \nif ( - 180.0 > lonDegrees ) lonDegrees += 360.0 ; \nif ( 180.0 < lonDegrees ) lonDegrees -= 360.0 ; \nreturn new double [ ] { \nlonDegrees , latDegrees } \n; \n} \n} \n"}
{"4587": "public class CoordinateTime2DUnionizer { \nvoid setRuntimeCoords ( CoordinateRuntime runtimes ) { \nfor ( int idx = 0 ; \nruntimes . getSize ( ) > idx ; \nidx ++ ) { \nCalendarDate cd = runtimes . getRuntimeDate ( idx ) ; \nlong runtime = runtimes . getRuntime ( idx ) ; \nCoordinateTimeAbstract time = timeMap . get ( runtime ) ; \nif ( time == null ) { \ntime = isTimeInterval ? new CoordinateTimeIntv ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) : new CoordinateTime ( this . code , this . timeUnit , cd , new ArrayList < > ( 0 ) , null ) ; \ntimeMap . put ( runtime , time ) ; \n} \n} \n} \n} \n"}
{"4599": "public class CatalogUtils { \npublic static List < InvCatalogRef > findAllCatRefsInDatasetTree ( List < InvDataset > datasets , StringBuilder log , boolean onlyRelativeUrls ) { \nList < InvCatalogRef > catRefList = new ArrayList < InvCatalogRef > ( ) ; \nfor ( InvDataset invds : datasets ) { \nInvDatasetImpl curDs = ( InvDatasetImpl ) invds ; \nif ( curDs instanceof InvDatasetScan ) continue ; \nif ( curDs instanceof InvCatalogRef ) { \nInvCatalogRef catRef = ( InvCatalogRef ) curDs ; \nString name = catRef . getName ( ) ; \nString href = catRef . getXlinkHref ( ) ; \nURI uri ; \ntry { \nuri = new URI ( href ) ; \n} \ncatch ( URISyntaxException e ) { \nlog . append ( 0 < log . length ( ) ? \"\\n\" : \"\" ) . append ( \"***WARN - CatalogRef [\" ) . append ( name ) . append ( \"] with bad HREF [\" ) . append ( href ) . append ( \"] \" ) ; \ncontinue ; \n} \nif ( onlyRelativeUrls && uri . isAbsolute ( ) ) continue ; \ncatRefList . add ( catRef ) ; \ncontinue ; \n} \nif ( curDs . hasNestedDatasets ( ) ) catRefList . addAll ( findAllCatRefsInDatasetTree ( curDs . getDatasets ( ) , log , onlyRelativeUrls ) ) ; \n} \nreturn catRefList ; \n} \n} \n"}
{"4601": "public class WRFEta { \nprivate ArrayDouble . D3 addStagger ( ArrayDouble . D3 array , int dimIndex ) { \nint [ ] shape = array . getShape ( ) ; \nint [ ] newShape = new int [ 3 ] ; \nSystem . arraycopy ( shape , 0 , newShape , 0 , 3 ) ; \nnewShape [ dimIndex ] ++ ; \nint ni = newShape [ 0 ] ; \nint nj = newShape [ 1 ] ; \nint nk = newShape [ 2 ] ; \nArrayDouble . D3 newArray = new ArrayDouble . D3 ( ni , nj , nk ) ; \nint n = shape [ dimIndex ] ; \ndouble [ ] d = new double [ n ] ; \nint [ ] eshape = new int [ 3 ] ; \nint [ ] neweshape = new int [ 3 ] ; \nfor ( int i = 0 ; \n3 > i ; \ni ++ ) { \neshape [ i ] = ( i == dimIndex ) ? n : 1 ; \nneweshape [ i ] = ( i == dimIndex ) ? n + 1 : 1 ; \n} \nint [ ] origin = new int [ 3 ] ; \ntry { \nfor ( int i = 0 ; \n( ( dimIndex == 0 ) ? 1 : ni ) > i ; \ni ++ ) { \nfor ( int j = 0 ; \n( ( dimIndex == 1 ) ? 1 : nj ) > j ; \nj ++ ) { \nfor ( int k = 0 ; \n( ( dimIndex == 2 ) ? 1 : nk ) > k ; \nk ++ ) { \norigin [ 0 ] = i ; \norigin [ 1 ] = j ; \norigin [ 2 ] = k ; \nIndexIterator it = array . section ( origin , eshape ) . getIndexIterator ( ) ; \nfor ( int l = 0 ; \nn > l ; \nl ++ ) { \nd [ l ] = it . getDoubleNext ( ) ; \n} \ndouble [ ] d2 = extrapinterpolate ( d ) ; \nIndexIterator newit = newArray . section ( origin , neweshape ) . getIndexIterator ( ) ; \nfor ( int l = 0 ; \nn + 1 > l ; \nl ++ ) { \nnewit . setDoubleNext ( d2 [ l ] ) ; \n} \n} \n} \n} \n} \ncatch ( InvalidRangeException e ) { \nreturn null ; \n} \nreturn newArray ; \n} \n} \n"}
{"4602": "public class WRFEta { \nprivate double [ ] extrapinterpolate ( double [ ] array ) { \nint n = array . length ; \ndouble [ ] d = new double [ n + 1 ] ; \nd [ 0 ] = 1.5 * array [ 0 ] - 0.5 * array [ 1 ] ; \nd [ n ] = 1.5 * array [ n - 1 ] - 0.5 * array [ n - 2 ] ; \nfor ( int i = 1 ; \nn > i ; \ni ++ ) { \nd [ i ] = 0.5 * ( array [ i - 1 ] + array [ i ] ) ; \n} \nreturn d ; \n} \n} \n"}
{"4609": "public class GempakStationFileIOSP { \nprotected int getStnVarSize ( String name ) { \nint size = - 1 ; \nfor ( int i = 0 ; \nstnVarNames . length > i ; \ni ++ ) { \nif ( name . equals ( stnVarNames [ i ] ) ) { \nsize = stnVarSizes [ i ] ; \nbreak ; \n} \n} \nreturn size ; \n} \n} \n"}
{"4611": "public class CeParser { \nprivate int yy_lr_goto_state_ ( int yystate , int yysym ) { \nint yyr = yypgoto_ [ yysym - yyntokens_ ] + yystate ; \nif ( yyr >= 0 && yylast_ >= yyr && yycheck_ [ yyr ] == yystate ) return yytable_ [ yyr ] ; \nelse return yydefgoto_ [ yysym - yyntokens_ ] ; \n} \n} \n"}
{"4612": "public class CeParser { \nprivate String yysyntax_error ( int yystate , int tok ) { \nif ( yyErrorVerbose ) { \nif ( tok != yyempty_ ) { \nStringBuffer res = new StringBuffer ( \"syntax error, unexpected \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ tok ] ) ) ; \nint yyn = yypact_ [ yystate ] ; \nif ( ! yy_pact_value_is_default_ ( yyn ) ) { \nint yyxbegin = 0 > yyn ? - yyn : 0 ; \nint yychecklim = yylast_ - yyn + 1 ; \nint yyxend = yyntokens_ > yychecklim ? yychecklim : yyntokens_ ; \nint count = 0 ; \nfor ( int x = yyxbegin ; \nyyxend > x ; \n++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) ++ count ; \nif ( 5 > count ) { \ncount = 0 ; \nfor ( int x = yyxbegin ; \nyyxend > x ; \n++ x ) if ( yycheck_ [ x + yyn ] == x && x != yyterror_ && ! yy_table_value_is_error_ ( yytable_ [ x + yyn ] ) ) { \nres . append ( count ++ == 0 ? \", expecting \" : \" or \" ) ; \nres . append ( yytnamerr_ ( yytname_ [ x ] ) ) ; \n} \n} \n} \nreturn res . toString ( ) ; \n} \n} \nreturn \"syntax error\" ; \n} \n} \n"}
{"4613": "public class CeParser { \nprivate void yy_reduce_print ( int yyrule , YYStack yystack ) { \nif ( yydebug == 0 ) return ; \nint yylno = yyrline_ [ yyrule ] ; \nint yynrhs = yyr2_ [ yyrule ] ; \nyycdebug ( \"Reducing stack by rule \" + ( yyrule - 1 ) + \" (line \" + yylno + \"), \" ) ; \nfor ( int yyi = 0 ; \nyynrhs > yyi ; \nyyi ++ ) yy_symbol_print ( \"   $\" + ( yyi + 1 ) + \" =\" , yystos_ [ yystack . stateAt ( yynrhs - ( yyi + 1 ) ) ] , ( ( yystack . valueAt ( yynrhs - ( yyi + 1 ) ) ) ) ) ; \n} \n} \n"}
{"4614": "public class ChunkInputStream { \npublic String readDMR ( ) throws DapException { \ntry { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to read DMR twice\" ) ; \nbyte [ ] dmr8 = null ; \nif ( requestmode == RequestMode . DMR ) { \nByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nint c ; \nwhile ( 0 <= ( c = input . read ( ) ) ) { \nbaos . write ( c ) ; \n} \nbaos . close ( ) ; \ndmr8 = baos . toByteArray ( ) ; \n} \nelse if ( requestmode == RequestMode . DAP ) { \nif ( ! readHeader ( input ) ) throw new DapException ( \"Malformed chunk count\" ) ; \ndmr8 = new byte [ this . chunksize ] ; \nint red = read ( dmr8 , 0 , this . chunksize ) ; \nif ( this . chunksize > red ) throw new DapException ( \"Short chunk\" ) ; \n} \nelse assert false : \"Internal error\" ; \nString dmr = new String ( dmr8 , DapUtil . UTF8 ) ; \ndmr = dmr . trim ( ) ; \nif ( dmr . endsWith ( \"\\r\\n\" ) ) { \n} \nelse if ( dmr . endsWith ( \"\\n\" ) ) dmr = dmr . substring ( 0 , dmr . length ( ) - 2 ) + \"\\r\\n\" ; \nelse dmr = dmr + \"\\r\\n\" ; \nthis . remoteorder = ( flags & DapUtil . CHUNK_LITTLE_ENDIAN ) == 0 ? ByteOrder . BIG_ENDIAN : ByteOrder . LITTLE_ENDIAN ; \nthis . nochecksum = ( flags & DapUtil . CHUNK_NOCHECKSUM ) != 0 ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) state = State . ERROR ; \nelse if ( ( flags & DapUtil . CHUNK_END ) != 0 ) state = State . END ; \nelse state = State . DATA ; \nreturn dmr ; \n} \ncatch ( IOException ioe ) { \nthrow new DapException ( ioe . getMessage ( ) ) ; \n} \n} \n} \n"}
{"4615": "public class ChunkInputStream { \npublic String readError ( ) throws IOException { \nstate = State . ERROR ; \nbyte [ ] bytes = new byte [ this . chunksize ] ; \ntry { \nif ( this . chunksize > read ( bytes , 0 , this . chunksize ) ) throw new ErrorException ( \"Short chunk\" ) ; \n} \ncatch ( IOException ioe ) { \nthrow new ErrorException ( ioe ) ; \n} \nString document = new String ( bytes , DapUtil . UTF8 ) ; \nreturn document ; \n} \n} \n"}
{"4616": "public class ChunkInputStream { \npublic int read ( byte [ ] buf , int off , int len ) throws IOException { \nif ( 0 > off || 0 > len ) throw new IndexOutOfBoundsException ( ) ; \nif ( buf . length <= off || ( off + len ) > buf . length ) throw new IndexOutOfBoundsException ( ) ; \nif ( requestmode == RequestMode . DMR ) throw new UnsupportedOperationException ( \"Attempt to read databuffer when DMR only\" ) ; \nint count = len ; \nint pos = off ; \nwhile ( 0 < count ) { \nif ( 0 >= avail ) { \nif ( ( flags & DapUtil . CHUNK_END ) != 0 || ! readHeader ( input ) ) return ( len - count ) ; \nif ( ( flags & DapUtil . CHUNK_ERROR ) != 0 ) { \nString document = readError ( ) ; \nthrowError ( document ) ; \n} \n} \nelse { \nint actual = ( count > this . avail ? this . avail : count ) ; \nint red = input . read ( buf , pos , actual ) ; \nif ( 0 > red ) throw new IOException ( \"Unexpected EOF\" ) ; \npos += red ; \ncount -= red ; \nthis . avail -= red ; \n} \n} \nreturn len ; \n} \n} \n"}
{"4617": "public class ChunkInputStream { \nboolean readHeader ( InputStream input ) throws IOException { \nbyte [ ] bytehdr = new byte [ 4 ] ; \nint red = input . read ( bytehdr ) ; \nif ( red == - 1 ) return false ; \nif ( 4 > red ) throw new IOException ( \"Short binary chunk count\" ) ; \nthis . flags = ( ( int ) bytehdr [ 0 ] ) & 0xFF ; \nbytehdr [ 0 ] = 0 ; \nByteBuffer buf = ByteBuffer . wrap ( bytehdr ) . order ( ByteOrder . BIG_ENDIAN ) ; \nthis . chunksize = buf . getInt ( ) ; \nthis . avail = this . chunksize ; \nreturn true ; \n} \n} \n"}
{"4623": "public class SimpleGeometryIndexFinder { \npublic int getBeginning ( int index ) { \nif ( index == ( pastIndex + 1 ) ) { \nreturn previousEnd + 1 ; \n} \nint newBeginning = 0 ; \nfor ( int i = 0 ; \nindex > i ; \ni ++ ) { \nnewBeginning += getNodeCount ( i ) ; \n} \npastIndex = index ; \npreviousBegin = newBeginning ; \nreturn newBeginning ; \n} \n} \n"}
{"4624": "public class SimpleGeometryIndexFinder { \npublic int getEnd ( int index ) { \nif ( index == ( pastIndex - 1 ) ) { \nreturn previousBegin - 1 ; \n} \nint new_end = 0 ; \nfor ( int i = 0 ; \nindex + 1 > i ; \ni ++ ) { \nnew_end += getNodeCount ( i ) ; \n} \npastIndex = index ; \npreviousEnd = new_end ; \nreturn new_end - 1 ; \n} \n} \n"}
{"4625": "public class GribCollectionBuilder { \nprivate boolean createAllRuntimeCollections ( Formatter errlog ) throws IOException { \nlong start = System . currentTimeMillis ( ) ; \nthis . type = GribCollectionImmutable . Type . SRC ; \nboolean ok = true ; \nList < MFile > files = new ArrayList < > ( ) ; \nList < ? extends Group > groups = makeGroups ( files , true , errlog ) ; \nList < MFile > allFiles = Collections . unmodifiableList ( files ) ; \nMap < Long , List < Group > > runGroups = new HashMap < > ( ) ; \nfor ( Group g : groups ) { \nList < Group > runGroup = runGroups . computeIfAbsent ( g . getRuntime ( ) . getMillis ( ) , k -> new ArrayList < > ( ) ) ; \nrunGroup . add ( g ) ; \n} \nboolean multipleRuntimes = 1 < runGroups . values ( ) . size ( ) ; \nList < MFile > partitions = new ArrayList < > ( ) ; \nfor ( List < Group > runGroupList : runGroups . values ( ) ) { \nGroup g = runGroupList . get ( 0 ) ; \nString gcname = multipleRuntimes ? GribCollectionMutable . makeName ( this . name , g . getRuntime ( ) ) : this . name ; \nMFile indexFileForRuntime = GribCollectionMutable . makeIndexMFile ( gcname , directory ) ; \npartitions . add ( indexFileForRuntime ) ; \nList < Long > runtimes = new ArrayList < > ( 1 ) ; \nruntimes . add ( g . getRuntime ( ) . getMillis ( ) ) ; \nCoordinateRuntime masterRuntimes = new CoordinateRuntime ( runtimes , null ) ; \nCalendarDateRange calendarDateRangeAll = null ; \nfor ( Coordinate coord : g . getCoordinates ( ) ) { \nif ( coord instanceof CoordinateTimeAbstract ) { \nCalendarDateRange calendarDateRange = ( ( CoordinateTimeAbstract ) coord ) . makeCalendarDateRange ( null ) ; \nif ( calendarDateRangeAll == null ) calendarDateRangeAll = calendarDateRange ; \nelse calendarDateRangeAll = calendarDateRangeAll . extend ( calendarDateRange ) ; \n} \n} \nassert calendarDateRangeAll != null ; \nok &= writeIndex ( gcname , indexFileForRuntime . getPath ( ) , masterRuntimes , runGroupList , allFiles , calendarDateRangeAll ) ; \nlogger . info ( \"GribCollectionBuilder write {} ok={}\" , indexFileForRuntime . getPath ( ) , ok ) ; \n} \nif ( multipleRuntimes ) { \nCollections . sort ( partitions ) ; \nPartitionManager part = new PartitionManagerFromIndexList ( dcm , partitions , logger ) ; \npart . putAuxInfo ( FeatureCollectionConfig . AUX_CONFIG , dcm . getAuxInfo ( FeatureCollectionConfig . AUX_CONFIG ) ) ; \nok &= GribCdmIndex . updateGribCollectionFromPCollection ( isGrib1 , part , CollectionUpdateType . always , errlog , logger ) ; \n} \nlong took = System . currentTimeMillis ( ) - start ; \nlogger . debug ( \"That took {} msecs\" , took ) ; \nreturn ok ; \n} \n} \n"}
{"4628": "public class Cosmic1Convention { \npublic static double [ ] ECFtoLLA ( double x , double y , double z , double a , double b ) { \ndouble longitude = Math . atan2 ( y , x ) ; \ndouble ePrimeSquared = ( a * a - b * b ) / ( b * b ) ; \ndouble p = Math . sqrt ( x * x + y * y ) ; \ndouble theta = Math . atan ( ( z * a ) / ( p * b ) ) ; \ndouble sineTheta = Math . sin ( theta ) ; \ndouble cosTheta = Math . cos ( theta ) ; \ndouble f = 1 / 298.257223563 ; \ndouble e2 = 2 * f - f * f ; \ndouble top = z + ePrimeSquared * b * sineTheta * sineTheta * sineTheta ; \ndouble bottom = p - e2 * a * cosTheta * cosTheta * cosTheta ; \ndouble geodeticLat = Math . atan ( top / bottom ) ; \ndouble sineLat = Math . sin ( geodeticLat ) ; \ndouble N = a / Math . sqrt ( 1 - e2 * sineLat * sineLat ) ; \ndouble altitude = ( p / Math . cos ( geodeticLat ) ) - N ; \nif ( Math . PI < longitude ) { \nlongitude -= 2 * Math . PI ; \n} \nelse if ( - Math . PI > longitude ) { \nlongitude += 2 * Math . PI ; \n} \nreturn new double [ ] { \ngeodeticLat , longitude , altitude } \n; \n} \n} \n"}
{"4630": "public class Util { \npublic static String cleanName ( String name ) { \nif ( name == null ) return null ; \nint pos = name . indexOf ( \"(see\" ) ; \nif ( 0 > pos ) pos = name . indexOf ( \"(See\" ) ; \nif ( 0 < pos ) name = name . substring ( 0 , pos ) ; \nname = StringUtil2 . replace ( name , '/' , \"-\" ) ; \nStringBuilder sb = new StringBuilder ( name ) ; \nStringUtil2 . replace ( sb , '+' , \"plus\" ) ; \nStringUtil2 . remove ( sb , \".;,=[]()/*\\\"\" ) ; \nreturn StringUtil2 . collapseWhitespace ( sb . toString ( ) . trim ( ) ) ; \n} \n} \n"}
{"4637": "public class DodsV { \nDodsV findByIndex ( int index ) { \nif ( index >= children . size ( ) ) return null ; \nreturn children . get ( index ) ; \n} \n} \n"}
{"4639": "public class Variable { \npublic Dimension getDimension ( int i ) { \nif ( ( 0 > i ) || ( getRank ( ) <= i ) ) return null ; \nreturn dimensions . get ( i ) ; \n} \n} \n"}
{"4640": "public class Variable { \npublic int findDimensionIndex ( String name ) { \nfor ( int i = 0 ; \ndimensions . size ( ) > i ; \ni ++ ) { \nDimension d = dimensions . get ( i ) ; \nif ( name . equals ( d . getShortName ( ) ) ) return i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"4642": "public class Variable { \npublic Section getShapeAsSection ( ) { \nif ( shapeAsSection == null ) { \ntry { \nList < Range > list = new ArrayList < > ( ) ; \nfor ( Dimension d : dimensions ) { \nint len = d . getLength ( ) ; \nif ( 0 < len ) list . add ( new Range ( d . getShortName ( ) , 0 , len - 1 ) ) ; \nelse if ( len == 0 ) list . add ( Range . EMPTY ) ; \nelse { \nassert d . isVariableLength ( ) ; \nlist . add ( Range . VLEN ) ; \n} \n} \nshapeAsSection = new Section ( list ) . makeImmutable ( ) ; \n} \ncatch ( InvalidRangeException e ) { \nlog . error ( \"Bad shape in variable \" + getFullName ( ) , e ) ; \nthrow new IllegalStateException ( e . getMessage ( ) ) ; \n} \n} \nreturn shapeAsSection ; \n} \n} \n"}
{"4643": "public class Variable { \npublic Variable slice ( int dim , int value ) throws InvalidRangeException { \nif ( ( 0 > dim ) || ( shape . length <= dim ) ) throw new InvalidRangeException ( \"Slice dim invalid= \" + dim ) ; \nboolean recordSliceOk = false ; \nif ( ( dim == 0 ) && ( value == 0 ) ) { \nDimension d = getDimension ( 0 ) ; \nrecordSliceOk = d . isUnlimited ( ) ; \n} \nif ( ! recordSliceOk ) { \nif ( ( 0 > value ) || ( shape [ dim ] <= value ) ) throw new InvalidRangeException ( \"Slice value invalid= \" + value + \" for dimension \" + dim ) ; \n} \nVariable sliceV = copy ( ) ; \nSection slice = new Section ( getShapeAsSection ( ) ) ; \nslice . replaceRange ( dim , new Range ( value , value ) ) . makeImmutable ( ) ; \nsliceV . setProxyReader ( new SliceReader ( this , dim , slice ) ) ; \nsliceV . createNewCache ( ) ; \nsliceV . setCaching ( false ) ; \nsliceV . dimensions . remove ( dim ) ; \nsliceV . resetShape ( ) ; \nreturn sliceV ; \n} \n} \n"}
{"4653": "public class Variable { \npublic void resetShape ( ) { \nthis . shape = new int [ dimensions . size ( ) ] ; \nfor ( int i = 0 ; \ndimensions . size ( ) > i ; \ni ++ ) { \nDimension dim = dimensions . get ( i ) ; \nshape [ i ] = dim . getLength ( ) ; \nif ( dim . isVariableLength ( ) ) { \nisVariableLength = true ; \n} \n} \nthis . shapeAsSection = null ; \n} \n} \n"}
{"4660": "public class FmrInv { \nvoid finish ( ) { \ngridList = new ArrayList < > ( uvHash . values ( ) ) ; \nCollections . sort ( gridList ) ; \nfor ( GridVariable grid : gridList ) { \ngrid . finish ( ) ; \n} \nint seqno = 0 ; \nfor ( TimeCoord tc : timeCoords ) tc . setId ( seqno ++ ) ; \nHashMap < String , List < VertCoord > > map = new HashMap < > ( ) ; \nfor ( VertCoord vc : vertCoords ) { \nList < VertCoord > list = map . get ( vc . getName ( ) ) ; \nif ( list == null ) { \nlist = new ArrayList < > ( ) ; \nmap . put ( vc . getName ( ) , list ) ; \n} \nlist . add ( vc ) ; \n} \nfor ( List < VertCoord > list : map . values ( ) ) { \nif ( 0 < list . size ( ) ) { \nint count = 0 ; \nfor ( VertCoord vc : list ) { \nif ( 0 < count ) vc . setName ( vc . getName ( ) + count ) ; \ncount ++ ; \n} \n} \n} \n} \n} \n"}
{"4664": "public class CDMDSP { \npublic void buildDMR ( ) throws DapException { \nif ( getDMR ( ) != null ) return ; \ntry { \nif ( DUMPCDL ) { \nSystem . out . println ( \"writecdl:\" ) ; \nthis . ncdfile . writeCDL ( System . out , false ) ; \nSystem . out . flush ( ) ; \n} \nString name = this . ncdfile . getLocation ( ) ; \nname = DapUtil . canonicalpath ( name ) ; \nint index = name . lastIndexOf ( '/' ) ; \nif ( 0 <= index ) name = name . substring ( index + 1 , name . length ( ) ) ; \nsetDMR ( ( DapDataset ) dmrfactory . newDataset ( name ) . annotate ( NetcdfDataset . class , this . ncdfile ) ) ; \nrecordNode ( this . ncdfile . getRootGroup ( ) , getDMR ( ) ) ; \ngetDMR ( ) . setBase ( DapUtil . canonicalpath ( this . ncdfile . getLocation ( ) ) ) ; \nfillgroup ( getDMR ( ) , this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . sort ( ) ; \nprocessmappedvariables ( this . ncdfile . getRootGroup ( ) ) ; \ngetDMR ( ) . finish ( ) ; \n} \ncatch ( DapException e ) { \nsetDMR ( null ) ; \nthrow new DapException ( e ) ; \n} \n} \n} \n"}
{"4665": "public class CDMDSP { \nprotected void buildseqtypes ( Variable cdmvar ) throws DapException { \nif ( CDMUtil . hasVLEN ( cdmvar ) ) { \nbuildseqtype ( cdmvar ) ; \n} \nif ( cdmvar . getDataType ( ) == DataType . STRUCTURE || cdmvar . getDataType ( ) == DataType . SEQUENCE ) { \nStructure struct = ( Structure ) cdmvar ; \nList < Variable > fields = struct . getVariables ( ) ; \nfor ( int i = 0 ; \nfields . size ( ) > i ; \ni ++ ) { \nVariable field = fields . get ( i ) ; \nbuildseqtypes ( field ) ; \n} \n} \n} \n} \n"}
{"4668": "public class CDMDSP { \nstatic List < Dimension > getCoreDimset ( List < Dimension > dimset ) throws DapException { \nif ( dimset == null ) return null ; \nList < Dimension > core = new ArrayList < > ( ) ; \nint pos = - 1 ; \nint count = 0 ; \nfor ( int i = 0 ; \ndimset . size ( ) > i ; \ni ++ ) { \nif ( dimset . get ( i ) . isVariableLength ( ) ) { \npos = i ; \ncount ++ ; \n} \nelse core . add ( dimset . get ( i ) ) ; \n} \nif ( ( pos != dimset . size ( ) - 1 ) || 1 < count ) throw new DapException ( \"Unsupported use of (*) Dimension\" ) ; \nreturn core ; \n} \n} \n"}
{"4673": "public class Navigation { \npublic boolean wantRotate ( double displayWidth , double displayHeight ) { \ngetMapArea ( bb ) ; \nboolean aspectDisplay = displayWidth > displayHeight ; \nboolean aspectWorldBB = bb . getWidth ( ) > bb . getHeight ( ) ; \nreturn ( aspectDisplay ^ aspectWorldBB ) ; \n} \n} \n"}
{"4677": "public class Navigation { \npublic void zoom ( double startx , double starty , double width , double height ) { \nif ( debugZoom ) System . out . println ( \"zoom \" + startx + \" \" + starty + \" \" + width + \" \" + height + \" \" ) ; \nif ( ( 5 > width ) || ( 5 > height ) ) return ; \nzoom . push ( ) ; \npix_x0 -= startx + width / 2 - pwidth / 2 ; \npix_y0 -= starty + height / 2 - pheight / 2 ; \nzoom ( pwidth / width ) ; \n} \n} \n"}
{"4680": "public class ListenerManager { \npublic synchronized void removeListener ( Object l ) { \nif ( listeners . contains ( l ) ) { \nlisteners . remove ( l ) ; \nhasListeners = ( 0 < listeners . size ( ) ) ; \n} \nelse logger . warn ( \"ListenerManager.removeListener couldnt find Listener \" + l ) ; \n} \n} \n"}
{"4693": "public class AccessLogParser { \npublic static void main ( String [ ] args ) throws IOException { \nAccessLogParser p = new AccessLogParser ( ) ; \nString line = \"24.18.236.132 - - [04/Feb/2011:17:49:03 -0700] \\\"GET /thredds/fileServer//nexrad/level3/N0R/YUX/20110205/Level3_YUX_N0R_20110205_0011.nids \\\" 200 10409 \\\"-\\\" \\\"-\\\" 17\" ; \nMatcher m = regPattern . matcher ( line ) ; \nSystem . out . printf ( \"%s %s%n\" , m . matches ( ) , m ) ; \nfor ( int i = 0 ; \nm . groupCount ( ) > i ; \ni ++ ) { \nSystem . out . println ( \" \" + i + \" \" + m . group ( i ) ) ; \n} \nLogReader . Log log = p . parseLog ( line ) ; \nSystem . out . printf ( \"%s%n\" , log ) ; \n} \n} \n"}
{"4699": "public class BitReader { \npublic long bits2UInt ( int nb ) throws IOException { \nassert 64 >= nb ; \nassert 0 <= nb ; \nlong result = 0 ; \nint bitsLeft = nb ; \nwhile ( 0 < bitsLeft ) { \nif ( bitPos == 0 ) { \nbitBuf = nextByte ( ) ; \nbitPos = BIT_LENGTH ; \n} \nint size = Math . min ( bitsLeft , bitPos ) ; \nint myBits = bitBuf >> ( bitPos - size ) ; \nmyBits &= BYTE_BITMASK ; \nmyBits &= ~ ( BYTE_BITMASK << size ) ; \nint shift = bitsLeft - size ; \nassert 0 <= shift ; \nresult |= myBits << shift ; \nbitsLeft -= size ; \nbitPos -= size ; \n} \nreturn result ; \n} \n} \n"}
{"4704": "public class DConnect2 { \nprivate String getCompleteCE ( String CE ) { \nString localProjString = null ; \nString localSelString = null ; \nif ( CE == null ) return \"\" ; \nif ( CE . startsWith ( \"?\" ) ) CE = CE . substring ( 1 ) ; \nint selIndex = CE . indexOf ( '&' ) ; \nif ( selIndex == 0 ) { \nlocalProjString = \"\" ; \nlocalSelString = CE ; \n} \nelse if ( 0 < selIndex ) { \nlocalSelString = CE . substring ( selIndex ) ; \nlocalProjString = CE . substring ( 0 , selIndex ) ; \n} \nelse { \nlocalProjString = CE ; \nlocalSelString = \"\" ; \n} \nString ce = projString ; \nif ( ! localProjString . equals ( \"\" ) ) { \nif ( ! ce . equals ( \"\" ) && localProjString . indexOf ( ',' ) != 0 ) ce += \",\" ; \nce += localProjString ; \n} \nif ( ! selString . equals ( \"\" ) ) { \nif ( selString . indexOf ( '&' ) != 0 ) ce += \"&\" ; \nce += selString ; \n} \nif ( ! localSelString . equals ( \"\" ) ) { \nif ( localSelString . indexOf ( '&' ) != 0 ) ce += \"&\" ; \nce += localSelString ; \n} \nif ( 0 < ce . length ( ) ) ce = \"?\" + ce ; \nif ( false ) { \nDAPNode . log . debug ( \"projString: '\" + projString + \"'\" ) ; \nDAPNode . log . debug ( \"localProjString: '\" + localProjString + \"'\" ) ; \nDAPNode . log . debug ( \"selString: '\" + selString + \"'\" ) ; \nDAPNode . log . debug ( \"localSelString: '\" + localSelString + \"'\" ) ; \nDAPNode . log . debug ( \"Complete CE: \" + ce ) ; \n} \nreturn ce ; \n} \n} \n"}
{"4705": "public class Sinusoidal { \n@ Override public LatLonPoint projToLatLon ( ProjectionPoint world , LatLonPointImpl result ) { \ndouble fromX = world . getX ( ) - falseEasting ; \ndouble fromY = world . getY ( ) - falseNorthing ; \ndouble toLat_r = fromY / earthRadius ; \ndouble toLon_r ; \nif ( Misc . nearlyEquals ( Math . abs ( toLat_r ) , PI_OVER_2 , 1e-10 ) ) { \ntoLat_r = 0 > toLat_r ? - PI_OVER_2 : + PI_OVER_2 ; \ntoLon_r = Math . toRadians ( centMeridian ) ; \n} \nelse if ( PI_OVER_2 > Math . abs ( toLat_r ) ) { \ntoLon_r = Math . toRadians ( centMeridian ) + fromX / ( earthRadius * Math . cos ( toLat_r ) ) ; \n} \nelse { \nreturn INVALID ; \n} \nif ( Misc . nearlyEquals ( Math . abs ( toLon_r ) , PI , 1e-10 ) ) { \ntoLon_r = 0 > toLon_r ? - PI : + PI ; \n} \nelse if ( PI < Math . abs ( toLon_r ) ) { \nreturn INVALID ; \n} \nresult . setLatitude ( Math . toDegrees ( toLat_r ) ) ; \nresult . setLongitude ( Math . toDegrees ( toLon_r ) ) ; \nreturn result ; \n} \n} \n"}
{"4712": "public class Parse { \nstatic public String cleanCharacterData ( String text ) { \nif ( text == null ) return null ; \nboolean bad = false ; \nfor ( int i = 0 , len = text . length ( ) ; \nlen > i ; \ni ++ ) { \nint ch = text . charAt ( i ) ; \nif ( ! org . jdom2 . Verifier . isXMLCharacter ( ch ) ) { \nbad = true ; \nbreak ; \n} \n} \nif ( ! bad ) return text ; \nStringBuilder sbuff = new StringBuilder ( text . length ( ) ) ; \nfor ( int i = 0 , len = text . length ( ) ; \nlen > i ; \ni ++ ) { \nint ch = text . charAt ( i ) ; \nif ( org . jdom2 . Verifier . isXMLCharacter ( ch ) ) sbuff . append ( ( char ) ch ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"4713": "public class Escape { \nprivate static String xunescapeString ( String in , char escape , boolean spaceplus ) { \ntry { \nif ( in == null ) return null ; \nbyte [ ] utf8 = in . getBytes ( utf8Charset ) ; \nbyte escape8 = ( byte ) escape ; \nbyte [ ] out = new byte [ utf8 . length ] ; \nint index8 = 0 ; \nfor ( int i = 0 ; \nutf8 . length > i ; \n) { \nbyte b = utf8 [ i ++ ] ; \nif ( b == plus && spaceplus ) { \nout [ index8 ++ ] = blank ; \n} \nelse if ( b == escape8 ) { \nif ( utf8 . length >= i + 2 ) { \nb = ( byte ) ( fromHex ( utf8 [ i ] ) << 4 | fromHex ( utf8 [ i + 1 ] ) ) ; \ni += 2 ; \n} \n} \nout [ index8 ++ ] = b ; \n} \nreturn new String ( out , 0 , index8 , utf8Charset ) ; \n} \ncatch ( Exception e ) { \nreturn in ; \n} \n} \n} \n"}
{"4716": "public class Escape { \npublic static String backslashDecode ( String s ) { \nStringBuilder buf = new StringBuilder ( s ) ; \nint i = 0 ; \nwhile ( buf . length ( ) > i ) { \nif ( buf . charAt ( i ) == '\\\\' ) { \nbuf . deleteCharAt ( i ) ; \n} \ni ++ ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4717": "public class Escape { \npublic static String backslashEncode ( String s ) { \nStringBuilder buf = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ns . length ( ) > i ; \ni ++ ) { \nint c = buf . charAt ( i ) ; \nif ( 0 <= _MustBackslashEscape . indexOf ( c ) ) buf . append ( _BACKSLASHEscape ) ; \nbuf . append ( ( char ) c ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"4720": "public class Swap { \nstatic public int swapInt ( byte [ ] b , int offset ) { \nint accum = 0 ; \nfor ( int shiftBy = 0 , i = offset ; \n32 > shiftBy ; \nshiftBy += 8 , i ++ ) { \naccum |= ( b [ i ] & 0xff ) << shiftBy ; \n} \nreturn accum ; \n} \n} \n"}
{"4721": "public class Swap { \nstatic public double swapDouble ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nlong shiftedval ; \nfor ( int shiftBy = 0 , i = offset ; \n64 > shiftBy ; \nshiftBy += 8 , i ++ ) { \nshiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; \naccum |= shiftedval ; \n} \nreturn Double . longBitsToDouble ( accum ) ; \n} \n} \n"}
{"4724": "public class Swap { \nstatic public byte [ ] shortToBytes ( short v ) { \nbyte [ ] b = new byte [ 2 ] ; \nint allbits = 255 ; \nfor ( int i = 0 ; \n2 > i ; \ni ++ ) { \nb [ 1 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \n} \nreturn b ; \n} \n} \n"}
{"4725": "public class Swap { \nstatic public byte [ ] intToBytes ( int v ) { \nbyte [ ] b = new byte [ 4 ] ; \nint allbits = 255 ; \nfor ( int i = 0 ; \n4 > i ; \ni ++ ) { \nb [ 3 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \n} \nreturn b ; \n} \n} \n"}
{"4726": "public class Swap { \nstatic public byte [ ] longToBytes ( long v ) { \nbyte [ ] b = new byte [ 8 ] ; \nlong allbits = 255 ; \nfor ( int i = 0 ; \n8 > i ; \ni ++ ) { \nb [ 7 - i ] = ( byte ) ( ( v & ( allbits << i * 8 ) ) >> i * 8 ) ; \n} \nreturn b ; \n} \n} \n"}
{"4729": "public class OceanS { \nprivate Array makeC ( Array s , double a , double b ) { \nint nz = ( int ) s . getSize ( ) ; \nIndex sIndex = s . getIndex ( ) ; \nif ( a == 0 ) return s ; \nArrayDouble . D1 c = new ArrayDouble . D1 ( nz ) ; \ndouble fac1 = 1.0 - b ; \ndouble denom1 = 1.0 / Math . sinh ( a ) ; \ndouble denom2 = 1.0 / ( 2.0 * Math . tanh ( 0.5 * a ) ) ; \nfor ( int i = 0 ; \nnz > i ; \ni ++ ) { \ndouble sz = s . getDouble ( sIndex . set ( i ) ) ; \ndouble term1 = fac1 * Math . sinh ( a * sz ) * denom1 ; \ndouble term2 = b * ( Math . tanh ( a * ( sz + 0.5 ) ) * denom2 - 0.5 ) ; \nc . set ( i , term1 + term2 ) ; \n} \nreturn c ; \n} \n} \n"}
{"4732": "public class GridCoordSys { \nvoid addLevels ( List < GridRecord > records ) { \nfor ( GridRecord record : records ) { \nDouble d = new Double ( record . getLevel1 ( ) ) ; \nif ( ! levels . contains ( d ) ) { \nlevels . add ( d ) ; \n} \nif ( dontUseVertical && ( 1 < levels . size ( ) ) ) { \nif ( GridServiceProvider . debugVert ) { \nSystem . out . println ( \"GribCoordSys: unused level coordinate has > 1 levels = \" + verticalName + \" \" + record . getLevelType1 ( ) + \" \" + levels . size ( ) ) ; \n} \n} \n} \nCollections . sort ( levels ) ; \nif ( positive . equals ( \"down\" ) ) { \nCollections . reverse ( levels ) ; \n} \n} \n} \n"}
{"4734": "public class GridCoordSys { \nvoid addToNetcdfFile ( NetcdfFile ncfile , Group g ) { \nif ( dontUseVertical ) { \nreturn ; \n} \nif ( g == null ) { \ng = ncfile . getRootGroup ( ) ; \n} \nString dims = \"time\" ; \nif ( ! dontUseVertical ) { \ndims = dims + \" \" + verticalName ; \n} \nif ( hcs . isLatLon ( ) ) { \ndims = dims + \" lat lon\" ; \n} \nelse { \ndims = dims + \" y x\" ; \n} \nint nlevs = levels . size ( ) ; \nVariable v = new Variable ( ncfile , g , null , verticalName ) ; \nv . setDataType ( DataType . DOUBLE ) ; \nv . addAttribute ( new Attribute ( \"long_name\" , lookup . getLevelDescription ( record ) ) ) ; \nv . addAttribute ( new Attribute ( \"units\" , lookup . getLevelUnit ( record ) ) ) ; \nif ( positive != null ) { \nv . addAttribute ( new Attribute ( \"positive\" , positive ) ) ; \n} \nif ( units != null ) { \nAxisType axisType ; \nif ( SimpleUnit . isCompatible ( \"millibar\" , units ) ) { \naxisType = AxisType . Pressure ; \n} \nelse if ( SimpleUnit . isCompatible ( \"m\" , units ) ) { \naxisType = AxisType . Height ; \n} \nelse { \naxisType = AxisType . GeoZ ; \n} \nv . addAttribute ( new Attribute ( \"grid_level_type\" , Integer . toString ( record . getLevelType1 ( ) ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \nv . addAttribute ( new Attribute ( _Coordinate . Axes , dims ) ) ; \nif ( ! hcs . isLatLon ( ) ) { \nv . addAttribute ( new Attribute ( _Coordinate . Transforms , hcs . getGridName ( ) ) ) ; \n} \n} \ndouble [ ] data = new double [ nlevs ] ; \nfor ( int i = 0 ; \nlevels . size ( ) > i ; \ni ++ ) { \nDouble d = ( Double ) levels . get ( i ) ; \ndata [ i ] = d . doubleValue ( ) ; \n} \nArray dataArray = Array . factory ( DataType . DOUBLE , new int [ ] { \nnlevs } \n, data ) ; \nv . setDimensions ( verticalName ) ; \nv . setCachedData ( dataArray , false ) ; \nncfile . addVariable ( g , v ) ; \nif ( record . getLevelType1 ( ) == 109 ) { \nfindCoordinateTransform ( g , \"Pressure\" , record . getLevelType1 ( ) ) ; \n} \n} \n} \n"}
{"4741": "public class DiskCache2 { \npublic void cleanCache ( File dir , Formatter sbuff , boolean isRoot ) { \nlong now = System . currentTimeMillis ( ) ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files == null ) { \nthrow new IllegalStateException ( \"DiskCache2: not a directory or I/O error on dir=\" + dir . getAbsolutePath ( ) ) ; \n} \nif ( ! isRoot && ( files . length == 0 ) ) { \nlong duration = now - dir . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( persistMinutes < duration ) { \nboolean ok = dir . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + dir . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , dir . getPath ( ) , CalendarDate . of ( dir . lastModified ( ) ) ) ; \n} \nreturn ; \n} \nfor ( File file : files ) { \nif ( file . isDirectory ( ) ) { \ncleanCache ( file , sbuff , false ) ; \n} \nelse { \nlong duration = now - file . lastModified ( ) ; \nduration /= 1000 * 60 ; \nif ( persistMinutes < duration ) { \nboolean ok = file . delete ( ) ; \nif ( ! ok ) cacheLog . error ( \"Unable to delete file \" + file . getAbsolutePath ( ) ) ; \nif ( sbuff != null ) sbuff . format ( \" deleted %s %s lastModified= %s%n\" , ok , file . getPath ( ) , CalendarDate . of ( file . lastModified ( ) ) ) ; \n} \n} \n} \n} \n} \n"}
{"4757": "public class DataDescriptor { \nstatic public void transferInfo ( List < DataDescriptor > fromList , List < DataDescriptor > toList ) { \nif ( fromList . size ( ) != toList . size ( ) ) throw new IllegalArgumentException ( \"list sizes dont match \" + fromList . size ( ) + \" != \" + toList . size ( ) ) ; \nfor ( int i = 0 ; \nfromList . size ( ) > i ; \ni ++ ) { \nDataDescriptor from = fromList . get ( i ) ; \nDataDescriptor to = toList . get ( i ) ; \nto . refersTo = from . refersTo ; \nto . name = from . name ; \nif ( from . getSubKeys ( ) != null ) transferInfo ( from . getSubKeys ( ) , to . getSubKeys ( ) ) ; \n} \n} \n} \n"}
{"4758": "public class DataDescriptor { \nint countBits ( ) { \nint total_nbits = 0 ; \ntotal_nbytesCDM = 0 ; \nfor ( DataDescriptor dd : subKeys ) { \nif ( dd . subKeys != null ) { \ntotal_nbits += dd . countBits ( ) ; \ntotal_nbytesCDM += dd . total_nbytesCDM ; \n} \nelse if ( dd . f == 0 ) { \ntotal_nbits += dd . bitWidth ; \ntotal_nbytesCDM += dd . getByteWidthCDM ( ) ; \n} \n} \nif ( 1 < replication ) { \ntotal_nbits *= replication ; \ntotal_nbytesCDM *= replication ; \n} \nreturn total_nbits ; \n} \n} \n"}
{"4760": "public class DbaseFile { \nprivate int loadHeader ( ) { \nif ( headerLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nBufferedInputStream bs = new BufferedInputStream ( s ) ; \nds = new DataInputStream ( bs ) ; \nHeader = new byte [ 32 ] ; \nds . readFully ( Header ) ; \nif ( Header [ 0 ] == '<' ) { \nclose ( ds ) ; \nreturn - 1 ; \n} \nfiletype = Header [ 0 ] ; \nnrecords = Swap . swapInt ( Header , 4 ) ; \nnbytesheader = Swap . swapShort ( Header , 8 ) ; \nnfields = ( nbytesheader / 32 ) - 1 ; \nif ( 1 > nfields ) { \nSystem . out . println ( \"nfields = \" + nfields ) ; \nSystem . out . println ( \"nbytesheader = \" + nbytesheader ) ; \nreturn - 1 ; \n} \nFieldDesc = new DbaseFieldDesc [ nfields ] ; \ndata = new DbaseData [ nfields ] ; \nfor ( int i = 0 ; \nnfields > i ; \ni ++ ) { \nFieldDesc [ i ] = new DbaseFieldDesc ( ds , filetype ) ; \ndata [ i ] = new DbaseData ( FieldDesc [ i ] , nrecords ) ; \n} \nds . readByte ( ) ; \nheaderLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"4761": "public class DbaseFile { \nprivate int loadData ( ) { \nif ( ! headerLoaded ) return - 1 ; \nif ( dataLoaded ) return 0 ; \nInputStream s = stream ; \nif ( s == null ) return - 1 ; \ntry { \nfor ( int i = 0 ; \nnrecords > i ; \ni ++ ) { \nbyte recbyte = ds . readByte ( ) ; \nif ( recbyte == 0x20 ) { \nfor ( int j = 0 ; \nnfields > j ; \nj ++ ) { \ndata [ j ] . readRowN ( ds , i ) ; \n} \n} \nelse { \nnrecords -- ; \ni -- ; \n} \n} \ndataLoaded = true ; \n} \ncatch ( java . io . IOException e ) { \nclose ( s ) ; \nreturn - 1 ; \n} \nfinally { \nclose ( s ) ; \n} \nreturn 0 ; \n} \n} \n"}
{"4762": "public class DbaseFile { \npublic DbaseData getField ( String Name ) { \nfor ( int i = 0 ; \nnfields > i ; \ni ++ ) { \nif ( FieldDesc [ i ] . Name . equals ( Name ) ) return data [ i ] ; \n} \nreturn null ; \n} \n} \n"}
{"4763": "public class DbaseFile { \npublic double [ ] getDoublesByName ( String Name ) { \nDbaseData d ; \nif ( ( d = getField ( Name ) ) == null ) return null ; \nif ( d . getType ( ) == DbaseData . TYPE_CHAR ) { \nString [ ] s = d . getStrings ( ) ; \ndouble [ ] dd = new double [ s . length ] ; \nfor ( int i = 0 ; \ns . length > i ; \ni ++ ) { \ndd [ i ] = Double . valueOf ( s [ i ] ) ; \n} \nreturn dd ; \n} \nif ( d . getType ( ) == DbaseData . TYPE_BOOLEAN ) { \nboolean [ ] b = d . getBooleans ( ) ; \ndouble [ ] dd = new double [ b . length ] ; \nfor ( int i = 0 ; \nb . length > i ; \ni ++ ) { \nif ( b [ i ] ) { \ndd [ i ] = 1 ; \n} \nelse { \ndd [ i ] = 0 ; \n} \n} \nreturn dd ; \n} \nreturn d . getDoubles ( ) ; \n} \n} \n"}
{"4766": "public class DbaseFile { \npublic String getFieldName ( int i ) { \nif ( nfields <= i || 0 > i ) { \nreturn null ; \n} \nreturn ( FieldDesc [ i ] . Name ) ; \n} \n} \n"}
{"4767": "public class DbaseFile { \npublic String [ ] getFieldNames ( ) { \nString [ ] s = new String [ nfields ] ; \nfor ( int i = 0 ; \nnfields > i ; \ni ++ ) { \ns [ i ] = getFieldName ( i ) ; \n} \nreturn s ; \n} \n} \n"}
{"4768": "public class DbaseFile { \npublic static void main ( String [ ] args ) { \nif ( 1 > args . length ) { \nSystem . out . println ( \"filename or URL required\" ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( String s : args ) { \nSystem . out . println ( \"*** Dump of Dbase \" + s + \":\" ) ; \ntry { \nDbaseFile dbf = new DbaseFile ( s ) ; \nif ( dbf . loadHeader ( ) != 0 ) { \nSystem . out . println ( \"Error loading header\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nString [ ] fieldNames = dbf . getFieldNames ( ) ; \nSystem . out . print ( \"[\" ) ; \nint nf = dbf . getNumFields ( ) ; \nDbaseData [ ] dbd = new DbaseData [ nf ] ; \nfor ( int field = 0 ; \nnf > field ; \nfield ++ ) { \ndbd [ field ] = dbf . getField ( field ) ; \nswitch ( dbd [ field ] . getType ( ) ) { \ncase DbaseData . TYPE_BOOLEAN : System . out . print ( \"boolean \" ) ; \nbreak ; \ncase DbaseData . TYPE_CHAR : System . out . print ( \"String \" ) ; \nbreak ; \ncase DbaseData . TYPE_NUMERIC : System . out . print ( \"double \" ) ; \nbreak ; \n} \nSystem . out . print ( fieldNames [ field ] ) ; \nif ( nf - 1 > field ) System . out . print ( \", \" ) ; \n} \nSystem . out . println ( \"]\" ) ; \nif ( dbf . loadData ( ) != 0 ) { \nSystem . out . println ( \"Error loading data\" + s ) ; \nSystem . exit ( - 1 ) ; \n} \nfor ( int rec = 0 ; \ndbf . getNumRecords ( ) > rec ; \nrec ++ ) { \nfor ( int field = 0 ; \nnf > field ; \nfield ++ ) { \nSystem . out . print ( dbd [ field ] . getData ( rec ) ) ; \nif ( nf - 1 > field ) System . out . print ( \", \" ) ; \nelse System . out . println ( ) ; \n} \n} \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nbreak ; \n} \n} \n} \n} \n"}
{"4777": "public class DapNode { \npublic String computefqn ( ) { \nList < DapNode > path = getPath ( ) ; \nStringBuilder fqn = new StringBuilder ( ) ; \nDapNode parent = path . get ( 0 ) ; \nfor ( int i = 1 ; \npath . size ( ) > i ; \ni ++ ) { \nDapNode current = path . get ( i ) ; \nswitch ( parent . getSort ( ) ) { \ncase DATASET : case GROUP : case ENUMERATION : fqn . append ( '/' ) ; \nfqn . append ( Escape . backslashEscape ( current . getShortName ( ) , \"/.\" ) ) ; \nbreak ; \ncase STRUCTURE : case SEQUENCE : case ENUMCONST : case VARIABLE : fqn . append ( '.' ) ; \nfqn . append ( current . getEscapedShortName ( ) ) ; \nbreak ; \ndefault : throw new IllegalArgumentException ( \"Illegal FQN parent\" ) ; \n} \nparent = current ; \n} \nreturn fqn . toString ( ) ; \n} \n} \n"}
{"4784": "public class DSPPrinter { \npublic DSPPrinter print ( ) throws DapException { \nDapDataset dmr = this . dsp . getDMR ( ) ; \nif ( this . ce == null ) this . ce = CEConstraint . getUniversal ( dmr ) ; \nthis . printer . setIndent ( 0 ) ; \nList < DapVariable > topvars = dmr . getTopVariables ( ) ; \nfor ( int i = 0 ; \ntopvars . size ( ) > i ; \ni ++ ) { \nDapVariable top = topvars . get ( i ) ; \nList < Slice > slices = this . ce . getConstrainedSlices ( top ) ; \nif ( this . ce . references ( top ) ) { \nDataCursor data = dsp . getVariableData ( top ) ; \nprintVariable ( data , slices ) ; \n} \n} \nprinter . eol ( ) ; \nreturn this ; \n} \n} \n"}
{"4785": "public class DSPPrinter { \nprotected void printCompoundInstance ( DataCursor datav ) throws DapException { \nDapStructure dstruct = ( DapStructure ) ( ( DapVariable ) datav . getTemplate ( ) ) . getBaseType ( ) ; \nswitch ( datav . getScheme ( ) ) { \ncase STRUCTURE : case RECORD : List < DapVariable > dfields = dstruct . getFields ( ) ; \nfor ( int f = 0 ; \ndfields . size ( ) > f ; \nf ++ ) { \nDapVariable field = dfields . get ( f ) ; \nList < Slice > fieldslices = this . ce . getConstrainedSlices ( field ) ; \nDataCursor fdata = datav . readField ( f ) ; \nprintVariable ( fdata , fieldslices ) ; \n} \nbreak ; \ncase SEQUENCE : DapSequence dseq = ( DapSequence ) dstruct ; \nlong count = datav . getRecordCount ( ) ; \nfor ( long r = 0 ; \ncount > r ; \nr ++ ) { \nDataCursor dr = datav . readRecord ( r ) ; \nprinter . marginPrint ( \"[\" ) ; \nprinter . eol ( ) ; \nprinter . indent ( ) ; \nprintCompoundInstance ( dr ) ; \nprinter . outdent ( ) ; \nprinter . marginPrint ( \"]\" ) ; \n} \nbreak ; \ndefault : throw new DapException ( \"Unexpected data cursor scheme:\" + datav . getScheme ( ) ) ; \n} \n} \n} \n"}
{"4799": "public class CoordAxisHelper { \nprivate int findClosest ( double target ) { \ndouble minDiff = Double . MAX_VALUE ; \ndouble useValue = Double . MIN_VALUE ; \nint idxFound = - 1 ; \nfor ( int i = 0 ; \naxis . getNcoords ( ) > i ; \ni ++ ) { \ndouble coord = axis . getCoordMidpoint ( i ) ; \ndouble diff = Math . abs ( coord - target ) ; \nif ( minDiff > diff || ( diff == minDiff && useValue < coord ) ) { \nminDiff = diff ; \nidxFound = i ; \nuseValue = coord ; \n} \n} \nreturn idxFound ; \n} \n} \n"}
{"4800": "public class CoordAxisHelper { \nprivate Optional < CoverageCoordAxisBuilder > subsetValues ( double minValue , double maxValue , int stride ) { \nif ( axis . getSpacing ( ) == CoverageCoordAxis . Spacing . discontiguousInterval ) return subsetValuesDiscontinuous ( minValue , maxValue , stride ) ; \ndouble lower = axis . isAscending ( ) ? Math . min ( minValue , maxValue ) : Math . max ( minValue , maxValue ) ; \ndouble upper = axis . isAscending ( ) ? Math . max ( minValue , maxValue ) : Math . min ( minValue , maxValue ) ; \nint minIndex = findCoordElement ( lower , false ) ; \nint maxIndex = findCoordElement ( upper , false ) ; \nif ( axis . getNcoords ( ) <= minIndex ) return Optional . empty ( String . format ( \"no points in subset: lower %f > end %f\" , lower , axis . getEndValue ( ) ) ) ; \nif ( 0 > maxIndex ) return Optional . empty ( String . format ( \"no points in subset: upper %f < start %f\" , upper , axis . getStartValue ( ) ) ) ; \nif ( 0 > minIndex ) minIndex = 0 ; \nif ( axis . getNcoords ( ) <= maxIndex ) maxIndex = axis . getNcoords ( ) - 1 ; \nint count = maxIndex - minIndex + 1 ; \nif ( 0 >= count ) throw new IllegalArgumentException ( \"no points in subset\" ) ; \ntry { \nreturn Optional . of ( subsetByIndex ( new Range ( minIndex , maxIndex , stride ) ) ) ; \n} \ncatch ( InvalidRangeException e ) { \nreturn Optional . empty ( e . getMessage ( ) ) ; \n} \n} \n} \n"}
{"4816": "public class DMRPrinter { \nvoid printDimrefs ( DapVariable var ) throws DapException { \nif ( var . getRank ( ) == 0 ) return ; \nList < DapDimension > dimset = this . ce . getConstrainedDimensions ( var ) ; \nif ( dimset == null ) throw new DapException ( \"Unknown variable: \" + var ) ; \nassert var . getRank ( ) == dimset . size ( ) ; \nfor ( int i = 0 ; \nvar . getRank ( ) > i ; \ni ++ ) { \nDapDimension dim = dimset . get ( i ) ; \nprinter . marginPrint ( \"<Dim\" ) ; \nif ( dim . isShared ( ) ) { \nString fqn = dim . getFQN ( ) ; \nassert ( fqn != null ) : \"Illegal Dimension reference\" ; \nfqn = fqnXMLEscape ( fqn ) ; \nprintXMLAttribute ( \"name\" , fqn , XMLESCAPED ) ; \n} \nelse { \nlong size = dim . getSize ( ) ; \nprintXMLAttribute ( \"size\" , Long . toString ( size ) , NILFLAGS ) ; \n} \nprinter . println ( \"/>\" ) ; \n} \n} \n} \n"}
{"4818": "public class AreaReader { \nprivate void setAreaDirectoryAttributes ( Variable v ) { \nif ( ( dirBlock == null ) || ( ad == null ) ) { \nreturn ; \n} \nfor ( int i = 1 ; \n14 > i ; \ni ++ ) { \nif ( i == 7 ) { \ncontinue ; \n} \nv . addAttribute ( new Attribute ( getADDescription ( i ) , dirBlock [ i ] ) ) ; \n} \n} \n} \n"}
{"4827": "public class CoordSysEvaluator { \nstatic private CoordinateSystem findBestCoordinateSystem ( NetcdfDataset ds ) { \nCoordinateSystem use = null ; \nfor ( CoordinateSystem cs : ds . getCoordinateSystems ( ) ) { \nif ( use == null ) use = cs ; \nelse if ( use . getCoordinateAxes ( ) . size ( ) < cs . getCoordinateAxes ( ) . size ( ) ) use = cs ; \n} \nreturn use ; \n} \n} \n"}
{"4831": "public class DSequence { \nprivate byte readMarker ( DataInputStream source ) throws IOException { \nbyte marker = source . readByte ( ) ; \nbyte unused ; \nfor ( int i = 0 ; \n3 > i ; \ni ++ ) unused = source . readByte ( ) ; \nreturn marker ; \n} \n} \n"}
{"4834": "public class MultipleAxisChart { \nprivate static TimeSeries createDataset ( String name , double base , RegularTimePeriod start , int count ) { \nTimeSeries series = new TimeSeries ( name , start . getClass ( ) ) ; \nRegularTimePeriod period = start ; \ndouble value = base ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nseries . add ( period , value ) ; \nperiod = period . next ( ) ; \nvalue = value * ( 1 + ( Math . random ( ) - 0.495 ) / 10.0 ) ; \n} \nreturn series ; \n} \n} \n"}
{"4836": "public class StructureDataA { \npublic String [ ] getJavaArrayString ( StructureMembers . Member m ) { \nif ( m . getDataType ( ) == DataType . STRING ) { \nArray data = getArray ( m ) ; \nint n = m . getSize ( ) ; \nString [ ] result = new String [ n ] ; \nfor ( int i = 0 ; \nresult . length > i ; \ni ++ ) result [ i ] = ( String ) data . getObject ( i ) ; \nreturn result ; \n} \nelse if ( m . getDataType ( ) == DataType . CHAR ) { \nArrayChar data = ( ArrayChar ) getArray ( m ) ; \nArrayChar . StringIterator iter = data . getStringIterator ( ) ; \nString [ ] result = new String [ iter . getNumElems ( ) ] ; \nint count = 0 ; \nwhile ( iter . hasNext ( ) ) result [ count ++ ] = iter . next ( ) ; \nreturn result ; \n} \nthrow new IllegalArgumentException ( \"getJavaArrayString: not String DataType :\" + m . getDataType ( ) ) ; \n} \n} \n"}
{"4837": "public class DoradeVOLD { \npublic DoradePARM [ ] getParamList ( ) { \nint paramCount = 0 ; \nfor ( int i = 0 ; \nnSensors > i ; \ni ++ ) paramCount += myRADDs [ i ] . getNParams ( ) ; \nDoradePARM [ ] list = new DoradePARM [ paramCount ] ; \nint next = 0 ; \nfor ( int i = 0 ; \nnSensors > i ; \ni ++ ) { \nint nParams = myRADDs [ i ] . getNParams ( ) ; \nSystem . arraycopy ( myRADDs [ i ] . getParamList ( ) , 0 , list , next , nParams ) ; \nnext += nParams ; \n} \nreturn list ; \n} \n} \n"}
{"4840": "public class StationRegionDateChooser { \nprotected void redraw ( ) { \nlong tstart = System . currentTimeMillis ( ) ; \njava . awt . Graphics2D gNP = np . getBufferedImageGraphics ( ) ; \nif ( gNP == null ) return ; \ngNP . setBackground ( np . getBackgroundColor ( ) ) ; \njava . awt . Rectangle r = gNP . getClipBounds ( ) ; \ngNP . clearRect ( r . x , r . y , r . width , r . height ) ; \nif ( regionSelect && geoSelectionMode ) { \nif ( geoSelection != null ) drawBB ( gNP , geoSelection , Color . cyan ) ; \nif ( geoBounds != null ) drawBB ( gNP , geoBounds , null ) ; \nif ( geoSelection != null ) { \nNavigation navigate = np . getNavigation ( ) ; \ndouble handleSize = RubberbandRectangleHandles . handleSizePixels / navigate . getPixPerWorld ( ) ; \nRectangle2D rect = new Rectangle2D . Double ( geoSelection . getX ( ) , geoSelection . getY ( ) , geoSelection . getWidth ( ) , geoSelection . getHeight ( ) ) ; \nRubberbandRectangleHandles . drawHandledRect ( gNP , rect , handleSize ) ; \nif ( debug ) System . out . println ( \"GeoRegionChooser.drawHandledRect=\" + handleSize + \" = \" + geoSelection ) ; \n} \n} \nfor ( int i = 0 ; \nrenderers . size ( ) > i ; \ni ++ ) { \nucar . nc2 . ui . util . Renderer rend = ( Renderer ) renderers . get ( i ) ; \nrend . draw ( gNP , atI ) ; \n} \ngNP . dispose ( ) ; \nif ( debug ) { \nlong tend = System . currentTimeMillis ( ) ; \nSystem . out . println ( \"StationRegionDateChooser draw time = \" + ( tend - tstart ) / 1000.0 + \" secs\" ) ; \n} \nnp . repaint ( ) ; \n} \n} \n"}
{"4851": "public class Grib2RecordScanner { \n@ Nullable public static Grib2Record findRecordByDrspos ( RandomAccessFile raf , long drsPos ) throws IOException { \nlong pos = Math . max ( 0 , drsPos - ( 20 * 1000 ) ) ; \nGrib2RecordScanner scan = new Grib2RecordScanner ( raf , pos ) ; \nwhile ( scan . hasNext ( ) ) { \nucar . nc2 . grib . grib2 . Grib2Record gr = scan . next ( ) ; \nGrib2SectionDataRepresentation drs = gr . getDataRepresentationSection ( ) ; \nif ( drsPos == drs . getStartingPosition ( ) ) return gr ; \nif ( drsPos < raf . getFilePointer ( ) ) break ; \n} \nreturn null ; \n} \n} \n"}
{"4854": "public class DoradePARM { \npublic float [ ] getParamValues ( DoradeRDAT rdat , float [ ] workingArray ) throws DescriptorException { \nif ( ! paramName . equals ( rdat . getParamName ( ) ) ) throw new DescriptorException ( \"parameter name mismatch\" ) ; \nbyte [ ] paramData = rdat . getRawData ( ) ; \nint nCells = myRADD . getNCells ( ) ; \nfloat [ ] values ; \nif ( workingArray != null && workingArray . length == nCells ) { \nvalues = workingArray ; \n} \nelse { \nvalues = new float [ nCells ] ; \n} \nshort [ ] svalues = null ; \nif ( myRADD . getCompressionScheme ( ) == DoradeRADD . COMPRESSION_HRD ) { \nif ( binaryFormat != DoradePARM . FORMAT_16BIT_INT ) { \nthrow new DescriptorException ( \"Cannot unpack \" + \"compressed data with binary format \" + binaryFormat ) ; \n} \nsvalues = uncompressHRD ( paramData , nCells ) ; \n} \nfor ( int cell = 0 ; \nnCells > cell ; \ncell ++ ) { \nswitch ( binaryFormat ) { \ncase DoradePARM . FORMAT_8BIT_INT : byte bval = paramData [ cell ] ; \nvalues [ cell ] = ( bval == badDataFlag ) ? BAD_VALUE : ( bval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_INT : short sval = ( svalues != null ) ? svalues [ cell ] : grabShort ( paramData , 2 * cell ) ; \nvalues [ cell ] = ( sval == badDataFlag ) ? BAD_VALUE : ( sval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_INT : int ival = grabInt ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( ival == badDataFlag ) ? BAD_VALUE : ( ival - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_32BIT_FLOAT : float fval = grabFloat ( paramData , 4 * cell ) ; \nvalues [ cell ] = ( fval == badDataFlag ) ? BAD_VALUE : ( fval - bias ) / scale ; \nbreak ; \ncase DoradePARM . FORMAT_16BIT_FLOAT : throw new DescriptorException ( \"can't unpack 16-bit \" + \"float data yet\" ) ; \ndefault : throw new DescriptorException ( \"bad binary format (\" + binaryFormat + \")\" ) ; \n} \n} \nreturn values ; \n} \n} \n"}
{"4871": "public class GempakUtil { \npublic static int [ ] TG_FTOI ( int [ ] iftime , int start ) { \nint [ ] intdtf = new int [ 3 ] ; \nif ( 100000000 > iftime [ start ] ) { \nintdtf [ 0 ] = iftime [ start ] ; \nintdtf [ 1 ] = iftime [ start + 1 ] ; \nintdtf [ 2 ] = 0 ; \n} \nelse { \nintdtf [ 0 ] = iftime [ start ] / 10000 ; \nintdtf [ 1 ] = iftime [ start ] - intdtf [ 0 ] * 10000 ; \nint mmdd = intdtf [ 0 ] / 100 ; \nint iyyy = intdtf [ 0 ] - mmdd * 100 ; \nintdtf [ 0 ] = iyyy * 10000 + mmdd ; \nintdtf [ 2 ] = iftime [ start + 1 ] ; \n} \nreturn intdtf ; \n} \n} \n"}
{"4874": "public class GempakUtil { \npublic static int TI_DAYM ( int iyear , int imon ) { \nint iday = 0 ; \nif ( ( 0 < imon ) && ( 13 > imon ) ) { \niday = month [ imon - 1 ] ; \nif ( ( imon == 2 ) && LEAP ( iyear ) ) { \niday = iday + 1 ; \n} \n} \nreturn iday ; \n} \n} \n"}
{"4875": "public class GempakUtil { \npublic static String LV_CCRD ( int ivcord ) { \nString vcoord = \"\" ; \nif ( ( 0 <= ivcord ) && ( vertCoords . length > ivcord ) ) { \nvcoord = vertCoords [ ivcord ] ; \n} \nelse if ( 100 < ivcord ) { \nvcoord = ST_ITOC ( ivcord ) ; \n} \nreturn vcoord ; \n} \n} \n"}
{"4876": "public class GempakUtil { \npublic static int [ ] swp4 ( int [ ] values , int startIndex , int number ) { \nfor ( int i = startIndex ; \nstartIndex + number > i ; \ni ++ ) { \nvalues [ i ] = Integer . reverseBytes ( values [ i ] ) ; \n} \nreturn values ; \n} \n} \n"}
{"4882": "public class ImageDatasetFactory { \npublic BufferedImage getNextImage ( boolean forward ) { \nif ( grid != null ) { \nif ( forward ) { \nthis . time ++ ; \nif ( this . ntimes <= this . time ) this . time = 0 ; \n} \nelse { \nthis . time -- ; \nif ( 0 > this . time ) this . time = this . ntimes - 1 ; \n} \nArray data ; \ntry { \ndata = grid . readDataSlice ( this . time , 0 , - 1 , - 1 ) ; \nreturn ImageArrayAdapter . makeGrayscaleImage ( data , grid ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} \nif ( currentFile == null ) return null ; \nif ( currentDir == null ) { \ncurrentDirFileNo = 0 ; \ncurrentDir = currentFile . getParentFile ( ) ; \ncurrentDirFileList = new ArrayList < > ( ) ; \naddToList ( currentDir , currentDirFileList ) ; \nfor ( int i = 0 ; \ncurrentDirFileList . size ( ) > i ; \ni ++ ) { \nFile file = currentDirFileList . get ( i ) ; \nif ( file . equals ( currentFile ) ) currentDirFileNo = i ; \n} \n} \nif ( forward ) { \ncurrentDirFileNo ++ ; \nif ( currentDirFileList . size ( ) <= currentDirFileNo ) currentDirFileNo = 0 ; \n} \nelse { \ncurrentDirFileNo -- ; \nif ( 0 > currentDirFileNo ) currentDirFileNo = currentDirFileList . size ( ) - 1 ; \n} \nFile nextFile = currentDirFileList . get ( currentDirFileNo ) ; \ntry { \nSystem . out . println ( \"Open image \" + nextFile ) ; \nreturn javax . imageio . ImageIO . read ( nextFile ) ; \n} \ncatch ( IOException e ) { \nSystem . out . println ( \"Failed to open image \" + nextFile ) ; \nreturn getNextImage ( forward ) ; \n} \n} \n} \n"}
{"4884": "public class FixedYearVariableMonthChronology { \nprivate static int sumArray ( int [ ] arr ) { \nif ( arr == null ) throw new NullPointerException ( \"null array\" ) ; \nif ( arr . length == 0 ) throw new IllegalArgumentException ( \"Zero-length array\" ) ; \nint sum = 0 ; \nfor ( int i = 0 ; \narr . length > i ; \ni ++ ) { \nif ( 0 >= arr [ i ] ) { \nthrow new IllegalArgumentException ( \"All array values must be > 0\" ) ; \n} \nsum += arr [ i ] ; \n} \nreturn sum ; \n} \n} \n"}
{"4887": "public class SpatialGrid { \npublic void clear ( ) { \nfor ( int y = 0 ; \ncountY > y ; \ny ++ ) for ( int x = 0 ; \ncountX > x ; \nx ++ ) gridArray [ y ] [ x ] . used = false ; \n} \n} \n"}
{"4888": "public class SpatialGrid { \npublic boolean markIfClear ( Rectangle2D rect , Object o ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( debugMark ) System . out . println ( \"markIfClear \" + rect + \" \" + indexX + \" \" + indexY ) ; \nif ( ( 0 > indexX ) || ( countX <= indexX ) || ( 0 > indexY ) || ( countY <= indexY ) ) return false ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return false ; \nif ( null != findIntersection ( rect ) ) return false ; \ngwant . used = true ; \ngwant . objectBB = rect ; \ngwant . o = o ; \nreturn true ; \n} \n} \n"}
{"4889": "public class SpatialGrid { \npublic Object findIntersection ( Rectangle2D rect ) { \ndouble centerX = rect . getX ( ) + rect . getWidth ( ) / 2 ; \ndouble centerY = rect . getY ( ) + rect . getHeight ( ) / 2 ; \nint indexX = ( int ) ( ( centerX - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( centerY - offsetY ) / gridHeight ) ; \nif ( ( 0 > indexX ) || ( countX <= indexX ) || ( 0 > indexY ) || ( countY <= indexY ) ) return null ; \nfor ( int y = Math . max ( 0 , indexY - 1 ) ; \nMath . min ( countY - 1 , indexY + 1 ) >= y ; \ny ++ ) { \nfor ( int x = Math . max ( 0 , indexX - 1 ) ; \nMath . min ( countX - 1 , indexX + 1 ) >= x ; \nx ++ ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) continue ; \nif ( intersectsOverlap ( rect , gtest . objectBB ) ) return gtest . o ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4890": "public class SpatialGrid { \npublic Object findIntersection ( Point2D p ) { \nint indexX = ( int ) ( ( p . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( p . getY ( ) - offsetY ) / gridHeight ) ; \nif ( ( 0 > indexX ) || ( countX <= indexX ) || ( 0 > indexY ) || ( countY <= indexY ) ) return null ; \nfor ( int y = Math . max ( 0 , indexY - 1 ) ; \nMath . min ( countY - 1 , indexY + 1 ) >= y ; \ny ++ ) { \nfor ( int x = Math . max ( 0 , indexX - 1 ) ; \nMath . min ( countX - 1 , indexX + 1 ) >= x ; \nx ++ ) { \nGridCell gtest = gridArray [ y ] [ x ] ; \nif ( ! gtest . used ) continue ; \nif ( gtest . objectBB . contains ( p . getX ( ) , p . getY ( ) ) ) return gtest . o ; \n} \n} \nreturn null ; \n} \n} \n"}
{"4891": "public class SpatialGrid { \npublic Object findClosest ( Point2D pt ) { \nObject o = null ; \nint indexX = ( int ) ( ( pt . getX ( ) - offsetX ) / gridWidth ) ; \nint indexY = ( int ) ( ( pt . getY ( ) - offsetY ) / gridHeight ) ; \nif ( debugClosest ) System . out . println ( \"findClosest \" + pt + \" \" + indexX + \" \" + indexY ) ; \nif ( ( 0 > indexX ) || ( countX <= indexX ) || ( 0 > indexY ) || ( countY <= indexY ) ) return null ; \nGridCell gwant = gridArray [ indexY ] [ indexX ] ; \nif ( gwant . used ) return gwant . o ; \nfor ( int p = 1 ; \nMath . max ( countX - 1 , countY - 1 ) > p ; \np ++ ) if ( null != ( o = findClosestAlongPerimeter ( pt , indexX , indexY , p ) ) ) return o ; \nreturn null ; \n} \n} \n"}
{"4892": "public class SpatialGrid { \nprivate double distanceSq ( Point2D pt , int indexX , int indexY ) { \nif ( ( 0 > indexX ) || ( countX <= indexX ) || ( 0 > indexY ) || ( countY <= indexY ) ) return MAX_DOUBLE ; \nGridCell gtest = gridArray [ indexY ] [ indexX ] ; \nif ( ! gtest . used ) return MAX_DOUBLE ; \nRectangle2D rect = gtest . objectBB ; \ndouble dx = rect . getX ( ) + rect . getWidth ( ) / 2 - pt . getX ( ) ; \ndouble dy = rect . getY ( ) + rect . getHeight ( ) / 2 - pt . getY ( ) ; \nreturn ( dx * dx + dy * dy ) ; \n} \n} \n"}
{"4895": "public class DatasetUrl { \nstatic private ServiceType searchPath ( String url ) { \nif ( false ) { \nif ( url == null || url . length ( ) == 0 ) return null ; \nurl = url . toLowerCase ( ) ; \nfor ( int i = 0 ; \nFRAGPROTOCOLS . length > i ; \ni ++ ) { \nString p = FRAGPROTOCOLS [ i ] ; \nif ( 0 <= url . indexOf ( \"/thredds/\" + p . toLowerCase ( ) + \"/\" ) ) { \nreturn FRAGPROTOSVCTYPE [ i ] ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"4900": "public class DapUtil { \nstatic public String fqnSuffix ( String fqn ) { \nint structindex = fqn . lastIndexOf ( '.' ) ; \nint groupindex = fqn . lastIndexOf ( '/' ) ; \nif ( 0 <= structindex ) return fqn . substring ( structindex + 1 , fqn . length ( ) ) ; \nelse return fqn . substring ( groupindex + 1 , fqn . length ( ) ) ; \n} \n} \n"}
{"4901": "public class DapUtil { \nstatic public String fqnPrefix ( String fqn ) { \nint structindex = fqn . lastIndexOf ( '.' ) ; \nint groupindex = fqn . lastIndexOf ( '/' ) ; \nif ( 0 <= structindex ) return fqn . substring ( 0 , structindex ) ; \nelse return fqn . substring ( 0 , groupindex ) ; \n} \n} \n"}
{"4903": "public class DapUtil { \nstatic public String locateRelative ( String relpath , String abspath , boolean wantdir ) { \nrelpath = relpath . trim ( ) . replace ( '\\\\' , '/' ) ; \nif ( relpath . charAt ( 0 ) == '/' ) relpath = relpath . substring ( 1 ) ; \nif ( relpath . endsWith ( \"/\" ) ) relpath = relpath . substring ( 0 , relpath . length ( ) - 1 ) ; \nString [ ] pieces = relpath . split ( \"[/]\" ) ; \nString partial = abspath ; \nfor ( int i = 0 ; \npieces . length - 1 > i ; \ni ++ ) { \nString nextdir = locateFile ( pieces [ i ] , abspath , true ) ; \nif ( nextdir == null ) return null ; \npartial = nextdir ; \n} \nString finalpath = locateFile ( pieces [ pieces . length - 1 ] , partial , wantdir ) ; \nreturn finalpath ; \n} \n} \n"}
{"4905": "public class DapUtil { \nstatic public List < DapVariable > getStructurePath ( DapVariable var ) { \nList < DapNode > path = var . getPath ( ) ; \nList < DapVariable > structpath = new ArrayList < DapVariable > ( ) ; \nfor ( int i = 0 ; \npath . size ( ) > i ; \ni ++ ) { \nDapNode node = path . get ( i ) ; \nswitch ( node . getSort ( ) ) { \ncase DATASET : case GROUP : break ; \ncase VARIABLE : structpath . add ( ( DapVariable ) node ) ; \nbreak ; \ndefault : assert false : \"Internal error\" ; \n} \n} \nreturn structpath ; \n} \n} \n"}
{"4907": "public class DapUtil { \nstatic public String join ( String [ ] array , String sep , int from , int upto ) { \nif ( sep == null ) sep = \"\" ; \nif ( 0 > from || array . length < upto ) throw new IndexOutOfBoundsException ( ) ; \nif ( from >= upto ) return \"\" ; \nStringBuilder result = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( int i = from ; \nupto > i ; \ni ++ , first = false ) { \nif ( ! first ) result . append ( sep ) ; \nresult . append ( array [ i ] ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"4908": "public class DapUtil { \nstatic public boolean hasDriveLetter ( String path ) { \nboolean hasdr = false ; \nif ( path != null && 2 <= path . length ( ) ) { \nhasdr = ( 0 <= DRIVELETTERS . indexOf ( path . charAt ( 0 ) ) && path . charAt ( 1 ) == ':' ) ; \n} \nreturn hasdr ; \n} \n} \n"}
{"4909": "public class DapUtil { \nstatic public List < String > getProtocols ( String url , int [ ] breakpoint ) { \nList < String > allprotocols = new ArrayList < > ( ) ; \nStringBuilder buf = new StringBuilder ( url ) ; \nint protosize = 0 ; \nfor ( ; \n; \n) { \nint index = buf . indexOf ( \":\" ) ; \nif ( 0 > index ) break ; \nString protocol = buf . substring ( 0 , index ) ; \nif ( index == 1 && 0 <= \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" . indexOf ( buf . charAt ( 0 ) ) ) break ; \nallprotocols . add ( protocol ) ; \nbuf . delete ( 0 , index + 1 ) ; \nprotosize += ( index + 1 ) ; \nif ( buf . indexOf ( \"/\" ) == 0 ) break ; \n} \nbreakpoint [ 0 ] = protosize ; \nreturn allprotocols ; \n} \n} \n"}
{"4914": "public class DapUtil { \nstatic public Index slicesToIndex ( List < Slice > slices ) throws DapException { \nlong [ ] positions = new long [ slices . size ( ) ] ; \nlong [ ] dimsizes = new long [ slices . size ( ) ] ; \nfor ( int i = 0 ; \npositions . length > i ; \ni ++ ) { \nSlice s = slices . get ( i ) ; \nif ( s . getCount ( ) != 1 ) throw new DapException ( \"Attempt to convert non-singleton sliceset to index\" ) ; \npositions [ i ] = s . getFirst ( ) ; \ndimsizes [ i ] = s . getMax ( ) ; \n} \nreturn new Index ( positions , dimsizes ) ; \n} \n} \n"}
{"4915": "public class NcStreamReader { \npublic DataResult readData ( InputStream is , NetcdfFile ncfile , String location ) throws IOException { \nbyte [ ] b = new byte [ 4 ] ; \nint bytesRead = NcStream . readFully ( is , b ) ; \nif ( b . length > bytesRead ) throw new EOFException ( location ) ; \nif ( NcStream . test ( b , NcStream . MAGIC_DATA ) ) return readData1 ( is , ncfile ) ; \nif ( NcStream . test ( b , NcStream . MAGIC_DATA2 ) ) return readData2 ( is ) ; \nthrow new IOException ( \"Data transfer corrupted on \" + location ) ; \n} \n} \n"}
{"4918": "public class FeatureCollectionConfigBuilder { \npublic FeatureCollectionConfig readConfigFromCatalog ( String catalogAndPath ) { \nString catFilename ; \nString fcName = null ; \nint pos = catalogAndPath . indexOf ( \"#\" ) ; \nif ( 0 < pos ) { \ncatFilename = catalogAndPath . substring ( 0 , pos ) ; \nfcName = catalogAndPath . substring ( pos + 1 ) ; \n} \nelse { \ncatFilename = catalogAndPath ; \n} \nFile cat = new File ( catFilename ) ; \norg . jdom2 . Document doc ; \ntry { \nSAXBuilder builder = new SAXBuilder ( ) ; \ndoc = builder . build ( cat ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \ntry { \nList < Element > fcElems = new ArrayList < > ( ) ; \nfindFeatureCollection ( doc . getRootElement ( ) , fcName , fcElems ) ; \nif ( 0 < fcElems . size ( ) ) return readConfig ( fcElems . get ( 0 ) ) ; \n} \ncatch ( IllegalStateException e ) { \ne . printStackTrace ( ) ; \n} \nreturn null ; \n} \n} \n"}
{"4928": "public class HTTPSession { \npublic HTTPSession setMaxRedirects ( int n ) { \nif ( 0 > n ) throw new IllegalArgumentException ( \"setMaxRedirects\" ) ; \nlocalsettings . put ( Prop . MAX_REDIRECTS , n ) ; \nthis . cachevalid = false ; \nreturn this ; \n} \n} \n"}
{"4936": "public class Index { \nstatic private long computeStrides ( int [ ] shape , int [ ] stride ) { \nlong product = 1 ; \nfor ( int ii = shape . length - 1 ; \n0 <= ii ; \nii -- ) { \nfinal int thisDim = shape [ ii ] ; \nif ( 0 > thisDim ) continue ; \nstride [ ii ] = ( int ) product ; \nproduct *= thisDim ; \n} \nreturn product ; \n} \n} \n"}
{"4937": "public class Index { \nIndex section ( List < Range > ranges ) throws InvalidRangeException { \nif ( ranges . size ( ) != rank ) throw new InvalidRangeException ( \"Bad ranges [] length\" ) ; \nfor ( int ii = 0 ; \nrank > ii ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) continue ; \nif ( r == Range . VLEN ) continue ; \nif ( ( 0 > r . first ( ) ) || ( shape [ ii ] <= r . first ( ) ) ) throw new InvalidRangeException ( \"Bad range starting value at index \" + ii + \" == \" + r . first ( ) ) ; \nif ( ( 0 > r . last ( ) ) || ( shape [ ii ] <= r . last ( ) ) ) throw new InvalidRangeException ( \"Bad range ending value at index \" + ii + \" == \" + r . last ( ) ) ; \n} \nint reducedRank = rank ; \nfor ( Range r : ranges ) { \nif ( ( r != null ) && ( r . length ( ) == 1 ) ) reducedRank -- ; \n} \nIndex newindex = Index . factory ( reducedRank ) ; \nnewindex . offset = offset ; \nint newDim = 0 ; \nfor ( int ii = 0 ; \nrank > ii ; \nii ++ ) { \nRange r = ranges . get ( ii ) ; \nif ( r == null ) { \nnewindex . shape [ newDim ] = shape [ ii ] ; \nnewindex . stride [ newDim ] = stride [ ii ] ; \nnewDim ++ ; \n} \nelse if ( r . length ( ) != 1 ) { \nnewindex . shape [ newDim ] = r . length ( ) ; \nnewindex . stride [ newDim ] = stride [ ii ] * r . stride ( ) ; \nnewindex . offset += stride [ ii ] * r . first ( ) ; \nnewDim ++ ; \n} \nelse { \nnewindex . offset += stride [ ii ] * r . first ( ) ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator && ( newindex . size == size ) ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4938": "public class Index { \nIndex reduce ( ) { \nIndex c = this ; \nfor ( int ii = 0 ; \nrank > ii ; \nii ++ ) if ( shape [ ii ] == 1 ) { \nIndex newc = c . reduce ( ii ) ; \nreturn newc . reduce ( ) ; \n} \nreturn c ; \n} \n} \n"}
{"4939": "public class Index { \nIndex reduce ( int dim ) { \nif ( ( 0 > dim ) || ( rank <= dim ) ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim ) ; \nif ( shape [ dim ] != 1 ) throw new IllegalArgumentException ( \"illegal reduce dim \" + dim + \" : length != 1\" ) ; \nIndex newindex = Index . factory ( rank - 1 ) ; \nnewindex . offset = offset ; \nint count = 0 ; \nfor ( int ii = 0 ; \nrank > ii ; \nii ++ ) { \nif ( ii != dim ) { \nnewindex . shape [ count ] = shape [ ii ] ; \nnewindex . stride [ count ] = stride [ ii ] ; \ncount ++ ; \n} \n} \nnewindex . size = computeSize ( newindex . shape ) ; \nnewindex . fastIterator = fastIterator ; \nnewindex . precalc ( ) ; \nreturn newindex ; \n} \n} \n"}
{"4940": "public class Index { \nIndex transpose ( int index1 , int index2 ) { \nif ( ( 0 > index1 ) || ( rank <= index1 ) ) throw new IllegalArgumentException ( ) ; \nif ( ( 0 > index2 ) || ( rank <= index2 ) ) throw new IllegalArgumentException ( ) ; \nIndex newIndex = ( Index ) this . clone ( ) ; \nnewIndex . stride [ index1 ] = stride [ index2 ] ; \nnewIndex . stride [ index2 ] = stride [ index1 ] ; \nnewIndex . shape [ index1 ] = shape [ index2 ] ; \nnewIndex . shape [ index2 ] = shape [ index1 ] ; \nnewIndex . fastIterator = false ; \nnewIndex . precalc ( ) ; \nreturn newIndex ; \n} \n} \n"}
{"4941": "public class Index { \nIndex permute ( int [ ] dims ) { \nif ( dims . length != shape . length ) throw new IllegalArgumentException ( ) ; \nfor ( int dim : dims ) if ( ( 0 > dim ) || ( rank <= dim ) ) throw new IllegalArgumentException ( ) ; \nboolean isPermuted = false ; \nIndex newIndex = ( Index ) this . clone ( ) ; \nfor ( int i = 0 ; \ndims . length > i ; \ni ++ ) { \nnewIndex . stride [ i ] = stride [ dims [ i ] ] ; \nnewIndex . shape [ i ] = shape [ dims [ i ] ] ; \nif ( i != dims [ i ] ) isPermuted = true ; \n} \nnewIndex . fastIterator = fastIterator && ! isPermuted ; \nnewIndex . precalc ( ) ; \nreturn newIndex ; \n} \n} \n"}
{"4943": "public class Index { \npublic int currentElement ( ) { \nint value = offset ; \nfor ( int ii = 0 ; \nrank > ii ; \nii ++ ) { \nif ( 0 > shape [ ii ] ) break ; \nvalue += current [ ii ] * stride [ ii ] ; \n} \nreturn value ; \n} \n} \n"}
{"4945": "public class Index { \npublic void setDim ( int dim , int value ) { \nif ( 0 > value || shape [ dim ] <= value ) throw new ArrayIndexOutOfBoundsException ( ) ; \nif ( 0 <= shape [ dim ] ) current [ dim ] = value ; \n} \n} \n"}
{"4947": "public class CoordinateTimeIntv { \npublic String getTimeIntervalName ( ) { \nint firstValue = - 1 ; \nfor ( TimeCoordIntvValue tinv : timeIntervals ) { \nint value = ( tinv . getBounds2 ( ) - tinv . getBounds1 ( ) ) ; \nif ( 0 > firstValue ) firstValue = value ; \nelse if ( value != firstValue ) return MIXED_INTERVALS ; \n} \nfirstValue = ( firstValue * timeUnit . getValue ( ) ) ; \nreturn firstValue + \"_\" + timeUnit . getField ( ) . toString ( ) ; \n} \n} \n"}
{"4957": "public class IndentWriter { \npublic void indent ( int n ) { \ndepth += n ; \nif ( 0 > depth ) depth = 0 ; \nelse if ( MAXDEPTH < depth ) depth = MAXDEPTH ; \n} \n} \n"}
{"4958": "public class IndentWriter { \npublic void setIndent ( int n ) { \ndepth = n ; \nif ( 0 > depth ) depth = 0 ; \nelse if ( MAXDEPTH < depth ) depth = MAXDEPTH ; \n} \n} \n"}
{"4962": "public class MFileCollectionManager { \nprivate boolean scanFirstTime ( ) throws IOException { \nMap < String , MFile > newMap = new HashMap < > ( ) ; \nif ( ! hasScans ( ) ) { \nmap = newMap ; \nreturn false ; \n} \nreallyScan ( newMap ) ; \nif ( 0 < olderThanInMsecs ) { \nlong olderThan = System . currentTimeMillis ( ) - olderThanInMsecs ; \nIterator < MFile > iter = newMap . values ( ) . iterator ( ) ; \nwhile ( iter . hasNext ( ) ) { \nMFile newFile = iter . next ( ) ; \nString path = newFile . getPath ( ) ; \nif ( olderThan < newFile . getLastModified ( ) ) { \niter . remove ( ) ; \nlogger . debug ( \"{}: scan found new Dataset but its too recently modified = {}\" , collectionName , path ) ; \n} \n} \n} \nmap = newMap ; \nthis . lastScanned = System . currentTimeMillis ( ) ; \nthis . lastChanged . set ( this . lastScanned ) ; \nlogger . debug ( \"{} : initial scan found n datasets = {} \" , collectionName , map . keySet ( ) . size ( ) ) ; \nreturn 0 < map . keySet ( ) . size ( ) ; \n} \n} \n"}
{"4972": "public class StructureDS { \nprotected ArrayStructure convert ( Array data , Section section ) throws IOException { \nArrayStructure orgAS = ( ArrayStructure ) data ; \nif ( ! convertNeeded ( orgAS . getStructureMembers ( ) ) ) { \nconvertMemberInfo ( orgAS . getStructureMembers ( ) ) ; \nreturn orgAS ; \n} \nArrayStructure newAS = ArrayStructureMA . factoryMA ( orgAS ) ; \nfor ( StructureMembers . Member m : newAS . getMembers ( ) ) { \nVariableEnhanced v2 = ( VariableEnhanced ) findVariable ( m . getName ( ) ) ; \nif ( ( v2 == null ) && ( orgVar != null ) ) v2 = findVariableFromOrgName ( m . getName ( ) ) ; \nif ( v2 == null ) continue ; \nif ( v2 instanceof VariableDS ) { \nVariableDS vds = ( VariableDS ) v2 ; \nif ( vds . needConvert ( ) ) { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = vds . convert ( mdata , vds . getEnhanceMode ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \nelse if ( v2 instanceof StructureDS ) { \nStructureDS innerStruct = ( StructureDS ) v2 ; \nif ( innerStruct . convertNeeded ( null ) ) { \nif ( innerStruct . getDataType ( ) == DataType . SEQUENCE ) { \nArrayObject . D1 seqArray = ( ArrayObject . D1 ) newAS . extractMemberArray ( m ) ; \nArrayObject . D1 newSeq = ( ArrayObject . D1 ) Array . factory ( DataType . SEQUENCE , new int [ ] { \n( int ) seqArray . getSize ( ) } \n) ; \nm . setDataArray ( newSeq ) ; \nfor ( int i = 0 ; \nseqArray . getSize ( ) > i ; \ni ++ ) { \nArraySequence innerSeq = ( ArraySequence ) seqArray . get ( i ) ; \nnewSeq . set ( i , new SequenceConverter ( innerStruct , innerSeq ) ) ; \n} \n} \nelse { \nArray mdata = newAS . extractMemberArray ( m ) ; \nmdata = innerStruct . convert ( mdata , null ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \n} \ninnerStruct . convertMemberInfo ( m . getStructureMembers ( ) ) ; \n} \n} \nStructureMembers sm = newAS . getStructureMembers ( ) ; \nconvertMemberInfo ( sm ) ; \nfor ( Variable v : getVariables ( ) ) { \nif ( ! varHasData ( v , sm ) ) { \ntry { \nVariable completeVar = getParentGroup ( ) . findVariable ( v . getShortName ( ) ) ; \nArray mdata = completeVar . read ( section ) ; \nStructureMembers . Member m = sm . addMember ( v . getShortName ( ) , v . getDescription ( ) , v . getUnitsString ( ) , v . getDataType ( ) , v . getShape ( ) ) ; \nnewAS . setMemberArray ( m , mdata ) ; \n} \ncatch ( InvalidRangeException e ) { \nthrow new IOException ( e . getMessage ( ) ) ; \n} \n} \n} \nreturn newAS ; \n} \n} \n"}
{"4979": "public class GempakSoundingIOSP { \nprivate ArraySequence makeArraySequence ( Sequence seq , List < GempakParameter > params , float [ ] values ) { \nif ( values == null ) { \nreturn makeEmptySequence ( seq ) ; \n} \nint numLevels = values . length / params . size ( ) ; \nStructureMembers members = seq . makeStructureMembers ( ) ; \nint offset = ArrayStructureBB . setOffsets ( members ) ; \nint size = offset * numLevels ; \nbyte [ ] bytes = new byte [ size ] ; \nByteBuffer buf = ByteBuffer . wrap ( bytes ) ; \nArrayStructureBB abb = new ArrayStructureBB ( members , new int [ ] { \nnumLevels } \n, buf , 0 ) ; \nint var = 0 ; \nfor ( int i = 0 ; \nnumLevels > i ; \ni ++ ) { \nfor ( GempakParameter param : params ) { \nif ( members . findMember ( param . getName ( ) ) != null ) { \nbuf . putFloat ( values [ var ] ) ; \n} \nvar ++ ; \n} \n} \nreturn new ArraySequence ( members , new SequenceIterator ( numLevels , abb ) , numLevels ) ; \n} \n} \n"}
{"4997": "public class DOM4Parser { \nList < Node > getSubnodes ( Node parent ) { \nList < Node > subs = new ArrayList < > ( ) ; \nNodeList nodes = parent . getChildNodes ( ) ; \nfor ( int i = 0 ; \nnodes . getLength ( ) > i ; \ni ++ ) { \nNode n = nodes . item ( i ) ; \nif ( n . getNodeType ( ) == Node . ELEMENT_NODE ) subs . add ( n ) ; \n} \nreturn subs ; \n} \n} \n"}
{"4999": "public class DOM4Parser { \nprotected void passReserved ( Node node , DapNode dap ) throws ParseException { \ntry { \nNamedNodeMap attrs = node . getAttributes ( ) ; \nfor ( int i = 0 ; \nattrs . getLength ( ) > i ; \ni ++ ) { \nNode n = attrs . item ( i ) ; \nString key = n . getNodeName ( ) ; \nString value = n . getNodeValue ( ) ; \nif ( isReserved ( key ) ) dap . addXMLAttribute ( key , value ) ; \n} \n} \ncatch ( DapException de ) { \nthrow new ParseException ( de ) ; \n} \n} \n} \n"}
{"5000": "public class CFSimpleGeometryHelper { \npublic static String getSubsetString ( Variable var , int beginInd , int endInd , int id ) { \nif ( var == null ) return null ; \nString subStr = \"\" ; \nList < Dimension > dimList = var . getDimensions ( ) ; \nif ( 2 < dimList . size ( ) || 1 > dimList . size ( ) ) { \nreturn null ; \n} \nfor ( int i = 0 ; \ndimList . size ( ) > i ; \ni ++ ) { \nDimension dim = dimList . get ( i ) ; \nif ( dim == null ) continue ; \nif ( ! CF . TIME . equalsIgnoreCase ( dim . getShortName ( ) ) && ! CF . TIME . equalsIgnoreCase ( dim . getFullNameEscaped ( ) ) ) { \nsubStr += id ; \n} \nelse { \nif ( 0 > beginInd || 0 > endInd ) subStr += \":\" ; \nelse subStr += ( beginInd + \":\" + endInd ) ; \n} \nif ( dimList . size ( ) - 1 > i ) { \nsubStr += \",\" ; \n} \n} \nreturn subStr ; \n} \n} \n"}
{"5001": "public class ArrayStructureMA { \nstatic public ArrayStructureMA factoryMA ( ArrayStructure from ) throws IOException { \nif ( from instanceof ArrayStructureMA ) return ( ArrayStructureMA ) from ; \nif ( 0 < from . getSize ( ) ) { \nArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , from . getShape ( ) ) ; \nfor ( StructureMembers . Member m : from . getMembers ( ) ) { \nto . setMemberArray ( m . getName ( ) , from . extractMemberArray ( m ) ) ; \n} \nreturn to ; \n} \nint numRecords = - 1 ; \nMap < String , Array > memberArrayMap = new LinkedHashMap < > ( ) ; \nfor ( StructureMembers . Member m : from . getMembers ( ) ) { \nArray array = from . extractMemberArray ( m ) ; \nassert 0 < array . getSize ( ) : \"array's size should have been computed in extractMemberArray().\" ; \nint firstDimLen = array . getShape ( ) [ 0 ] ; \nif ( numRecords == - 1 ) { \nnumRecords = firstDimLen ; \n} \nelse { \nassert numRecords == firstDimLen : String . format ( \"Expected all structure members to have the same first\" + \"dimension length, but %d != %d.\" , numRecords , firstDimLen ) ; \n} \nmemberArrayMap . put ( m . getName ( ) , array ) ; \n} \nint [ ] shape ; \nif ( numRecords == - 1 ) { \nshape = new int [ ] { \n0 } \n; \n} \nelse { \nshape = new int [ ] { \nnumRecords } \n; \n} \nArrayStructureMA to = new ArrayStructureMA ( new StructureMembers ( from . getStructureMembers ( ) ) , shape ) ; \nfor ( Map . Entry < String , Array > entry : memberArrayMap . entrySet ( ) ) { \nto . setMemberArray ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nreturn to ; \n} \n} \n"}
{"5004": "public class SimpleGeometryReader { \npublic GeometryType getGeometryType ( String name ) { \nVariable geometryVar = ds . findVariable ( name ) ; \nif ( geometryVar == null ) return null ; \nif ( ds . findGlobalAttribute ( CF . CONVENTIONS ) != null ) if ( 8 <= ucar . nc2 . dataset . conv . CF1Convention . getVersion ( ds . findGlobalAttribute ( CF . CONVENTIONS ) . getStringValue ( ) ) ) { \nAttribute geometryTypeAttr = null ; \nString geometry_type = null ; \ngeometryTypeAttr = geometryVar . findAttribute ( CF . GEOMETRY_TYPE ) ; \nif ( geometryTypeAttr == null ) return null ; \ngeometry_type = geometryTypeAttr . getStringValue ( ) ; \nswitch ( geometry_type ) { \ncase CF . POLYGON : return GeometryType . POLYGON ; \ncase CF . LINE : return GeometryType . LINE ; \ncase CF . POINT : return GeometryType . POINT ; \ndefault : return null ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5010": "public class LatLonRect { \npublic boolean containedIn ( LatLonRect b ) { \nreturn ( width <= b . getWidth ( ) ) && b . contains ( upperRight ) && b . contains ( lowerLeft ) ; \n} \n} \n"}
{"5011": "public class LatLonRect { \npublic void extend ( LatLonPoint p ) { \nif ( contains ( p ) ) return ; \ndouble lat = p . getLatitude ( ) ; \ndouble lon = p . getLongitude ( ) ; \nif ( upperRight . getLatitude ( ) < lat ) { \nupperRight . setLatitude ( lat ) ; \n} \nif ( lowerLeft . getLatitude ( ) > lat ) { \nlowerLeft . setLatitude ( lat ) ; \n} \nif ( allLongitude ) { \n} \nelse if ( crossDateline ) { \ndouble d1 = lon - upperRight . getLongitude ( ) ; \ndouble d2 = lowerLeft . getLongitude ( ) - lon ; \nif ( ( 0.0 < d1 ) && ( 0.0 < d2 ) ) { \nif ( d2 < d1 ) { \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \n} \nelse { \nif ( upperRight . getLongitude ( ) < lon ) { \nif ( lowerLeft . getLongitude ( ) - lon + 360 < lon - upperRight . getLongitude ( ) ) { \ncrossDateline = true ; \nlowerLeft . setLongitude ( lon ) ; \n} \nelse { \nupperRight . setLongitude ( lon ) ; \n} \n} \nelse if ( lowerLeft . getLongitude ( ) > lon ) { \nif ( lon + 360.0 - upperRight . getLongitude ( ) < lowerLeft . getLongitude ( ) - lon ) { \ncrossDateline = true ; \nupperRight . setLongitude ( lon ) ; \n} \nelse { \nlowerLeft . setLongitude ( lon ) ; \n} \n} \n} \nwidth = upperRight . getLongitude ( ) - lowerLeft . getLongitude ( ) ; \nlon0 = ( upperRight . getLongitude ( ) + lowerLeft . getLongitude ( ) ) / 2 ; \nif ( crossDateline ) { \nwidth += 360 ; \nlon0 -= 180 ; \n} \nthis . allLongitude = this . allLongitude || ( 360.0 <= this . width ) ; \n} \n} \n"}
{"5012": "public class LatLonRect { \npublic void extend ( LatLonRect r ) { \nPreconditions . checkNotNull ( r ) ; \ndouble latMin = r . getLatMin ( ) ; \ndouble latMax = r . getLatMax ( ) ; \nif ( upperRight . getLatitude ( ) < latMax ) { \nupperRight . setLatitude ( latMax ) ; \n} \nif ( lowerLeft . getLatitude ( ) > latMin ) { \nlowerLeft . setLatitude ( latMin ) ; \n} \nif ( allLongitude ) return ; \ndouble lonMin = getLonMin ( ) ; \ndouble lonMax = getLonMax ( ) ; \ndouble nlonMin = LatLonPointImpl . lonNormal ( r . getLonMin ( ) , lonMin ) ; \ndouble nlonMax = nlonMin + r . getWidth ( ) ; \nlonMin = Math . min ( lonMin , nlonMin ) ; \nlonMax = Math . max ( lonMax , nlonMax ) ; \nwidth = lonMax - lonMin ; \nallLongitude = 360.0 <= width ; \nif ( allLongitude ) { \nwidth = 360.0 ; \nlonMin = - 180.0 ; \n} \nelse { \nlonMin = LatLonPointImpl . lonNormal ( lonMin ) ; \n} \nlowerLeft . setLongitude ( lonMin ) ; \nupperRight . setLongitude ( lonMin + width ) ; \nlon0 = lonMin + width / 2 ; \ncrossDateline = upperRight . getLongitude ( ) < lowerLeft . getLongitude ( ) ; \n} \n} \n"}
{"5013": "public class LatLonRect { \npublic LatLonRect intersect ( LatLonRect clip ) { \ndouble latMin = Math . max ( getLatMin ( ) , clip . getLatMin ( ) ) ; \ndouble latMax = Math . min ( getLatMax ( ) , clip . getLatMax ( ) ) ; \ndouble deltaLat = latMax - latMin ; \nif ( 0 > deltaLat ) return null ; \ndouble lon1min = getLonMin ( ) ; \ndouble lon1max = getLonMax ( ) ; \ndouble lon2min = clip . getLonMin ( ) ; \ndouble lon2max = clip . getLonMax ( ) ; \nif ( ! intersect ( lon1min , lon1max , lon2min , lon2max ) ) { \nlon2min = clip . getLonMin ( ) + 360 ; \nlon2max = clip . getLonMax ( ) + 360 ; \nif ( ! intersect ( lon1min , lon1max , lon2min , lon2max ) ) { \nlon2min = clip . getLonMin ( ) - 360 ; \nlon2max = clip . getLonMax ( ) - 360 ; \n} \n} \ndouble lonMin = Math . max ( lon1min , lon2min ) ; \ndouble lonMax = Math . min ( lon1max , lon2max ) ; \ndouble deltaLon = lonMax - lonMin ; \nif ( 0 > deltaLon ) return null ; \nreturn new LatLonRect ( new LatLonPointImpl ( latMin , lonMin ) , deltaLat , deltaLon ) ; \n} \n} \n"}
{"5016": "public class MAMath { \npublic static boolean conformable ( int [ ] shapeA , int [ ] shapeB ) { \nif ( reducedRank ( shapeA ) != reducedRank ( shapeB ) ) return false ; \nint rankB = shapeB . length ; \nint dimB = 0 ; \nfor ( int aShapeA : shapeA ) { \nif ( aShapeA == 1 ) continue ; \nwhile ( rankB > dimB ) if ( shapeB [ dimB ] == 1 ) dimB ++ ; \nelse break ; \nif ( aShapeA != shapeB [ dimB ] ) return false ; \ndimB ++ ; \n} \nreturn true ; \n} \n} \n"}
{"5021": "public class MAMath { \npublic static MAMath . MinMax getMinMax ( Array a ) { \nIndexIterator iter = a . getIndexIterator ( ) ; \ndouble max = - Double . MAX_VALUE ; \ndouble min = Double . MAX_VALUE ; \nwhile ( iter . hasNext ( ) ) { \ndouble val = iter . getDoubleNext ( ) ; \nif ( Double . isNaN ( val ) ) continue ; \nif ( max < val ) max = val ; \nif ( min > val ) min = val ; \n} \nreturn new MinMax ( min , max ) ; \n} \n} \n"}
{"5028": "public class EscapeStrings { \nstatic public String backslashEscape ( String x , String reservedChars ) { \nif ( x == null ) { \nreturn null ; \n} \nelse if ( reservedChars == null ) { \nreturn x ; \n} \nboolean ok = true ; \nfor ( int pos = 0 ; \nx . length ( ) > pos ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( 0 <= reservedChars . indexOf ( c ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int pos = 0 ; \nsb . length ( ) > pos ; \npos ++ ) { \nchar c = sb . charAt ( pos ) ; \nif ( 0 > reservedChars . indexOf ( c ) ) { \ncontinue ; \n} \nsb . setCharAt ( pos , '\\\\' ) ; \npos ++ ; \nsb . insert ( pos , c ) ; \npos ++ ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5029": "public class EscapeStrings { \nstatic public String backslashUnescape ( String x ) { \nif ( ! x . contains ( \"\\\\\" ) ) return x ; \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \nfor ( int pos = 0 ; \nx . length ( ) > pos ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( c == '\\\\' ) { \nc = x . charAt ( ++ pos ) ; \n} \nsb . append ( c ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5030": "public class EscapeStrings { \npublic static List < String > tokenizeEscapedName ( String escapedName ) { \nList < String > result = new ArrayList < > ( ) ; \nint pos = 0 ; \nint start = 0 ; \nwhile ( true ) { \npos = escapedName . indexOf ( sep , pos + 1 ) ; \nif ( 0 >= pos ) break ; \nif ( ( 0 < pos ) && escapedName . charAt ( pos - 1 ) != '\\\\' ) { \nresult . add ( escapedName . substring ( start , pos ) ) ; \nstart = pos + 1 ; \n} \n} \nresult . add ( escapedName . substring ( start , escapedName . length ( ) ) ) ; \nreturn result ; \n} \n} \n"}
{"5031": "public class EscapeStrings { \npublic static int indexOf ( String escapedName , char c ) { \nint pos = 0 ; \nwhile ( true ) { \npos = escapedName . indexOf ( c , pos + 1 ) ; \nif ( 0 >= pos ) return pos ; \nif ( ( 0 < pos ) && escapedName . charAt ( pos - 1 ) != '\\\\' ) return pos ; \n} \n} \n} \n"}
{"5032": "public class EscapeStrings { \npublic static String backslashToDAP ( String bs ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint len = bs . length ( ) ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nchar c = bs . charAt ( i ) ; \nif ( ( len - 1 ) > i && c == '\\\\' ) { \nc = bs . charAt ( ++ i ) ; \n} \nif ( 0 > _allowableInDAP . indexOf ( c ) ) { \nbuf . append ( _URIEscape ) ; \nString ashex = Integer . toHexString ( ( int ) c ) ; \nif ( 2 > ashex . length ( ) ) buf . append ( '0' ) ; \nbuf . append ( ashex ) ; \n} \nelse buf . append ( c ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5039": "public class D4DataCompiler { \nprotected D4Cursor compileStructure ( DapVariable var , DapStructure dapstruct , D4Cursor container ) throws DapException { \nint pos = getPos ( this . databuffer ) ; \nD4Cursor d4ds = new D4Cursor ( Scheme . STRUCTURE , ( D4DSP ) this . dsp , var , container ) . setOffset ( pos ) ; \nList < DapVariable > dfields = dapstruct . getFields ( ) ; \nfor ( int m = 0 ; \ndfields . size ( ) > m ; \nm ++ ) { \nDapVariable dfield = dfields . get ( m ) ; \nD4Cursor dvfield = compileVar ( dfield , d4ds ) ; \nd4ds . addField ( m , dvfield ) ; \nassert dfield . getParent ( ) != null ; \n} \nreturn d4ds ; \n} \n} \n"}
{"5041": "public class D4DataCompiler { \npublic D4Cursor compileSequence ( DapVariable var , DapSequence dapseq , D4Cursor container ) throws DapException { \nint pos = getPos ( this . databuffer ) ; \nD4Cursor seq = new D4Cursor ( Scheme . SEQUENCE , this . dsp , var , container ) . setOffset ( pos ) ; \nList < DapVariable > dfields = dapseq . getFields ( ) ; \nlong nrecs = getCount ( this . databuffer ) ; \nfor ( int r = 0 ; \nnrecs > r ; \nr ++ ) { \npos = getPos ( this . databuffer ) ; \nD4Cursor rec = ( D4Cursor ) new D4Cursor ( D4Cursor . Scheme . RECORD , this . dsp , var , container ) . setOffset ( pos ) . setRecordIndex ( r ) ; \nfor ( int m = 0 ; \ndfields . size ( ) > m ; \nm ++ ) { \nDapVariable dfield = dfields . get ( m ) ; \nD4Cursor dvfield = compileVar ( dfield , rec ) ; \nrec . addField ( m , dvfield ) ; \nassert dfield . getParent ( ) != null ; \n} \nseq . addRecord ( rec ) ; \n} \nreturn seq ; \n} \n} \n"}
{"5059": "public class DoradeRADD { \npublic float getCellSpacing ( ) throws DescriptorException { \nfloat [ ] cellRanges = myCELV . getCellRanges ( ) ; \nfloat cellSpacing = cellRanges [ 1 ] - cellRanges [ 0 ] ; \nfor ( int i = 2 ; \ncellRanges . length > i ; \ni ++ ) { \nfloat space = cellRanges [ i ] - cellRanges [ i - 1 ] ; \nif ( ! Misc . nearlyEquals ( space , cellSpacing ) && ( 0.01 < Math . abs ( space / cellSpacing - 1.0 ) ) ) { \nthrow new DescriptorException ( \"variable cell spacing\" ) ; \n} \n} \nreturn cellSpacing ; \n} \n} \n"}
{"5061": "public class Dimension { \nprotected Factor [ ] mult ( final Dimension that ) { \nfinal Factor [ ] factors1 = _factors ; \nfinal Factor [ ] factors2 = that . _factors ; \nint i1 = 0 ; \nint i2 = 0 ; \nint k = 0 ; \nFactor [ ] newFactors = new Factor [ factors1 . length + factors2 . length ] ; \nfor ( ; \n; \n) { \nif ( i1 == factors1 . length ) { \nfinal int n = factors2 . length - i2 ; \nSystem . arraycopy ( factors2 , i2 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nif ( i2 == factors2 . length ) { \nfinal int n = factors1 . length - i1 ; \nSystem . arraycopy ( factors1 , i1 , newFactors , k , n ) ; \nk += n ; \nbreak ; \n} \nfinal Factor f1 = factors1 [ i1 ] ; \nfinal Factor f2 = factors2 [ i2 ] ; \nfinal int comp = f1 . getID ( ) . compareTo ( f2 . getID ( ) ) ; \nif ( 0 > comp ) { \nnewFactors [ k ++ ] = f1 ; \ni1 ++ ; \n} \nelse if ( comp == 0 ) { \nfinal int exponent = f1 . getExponent ( ) + f2 . getExponent ( ) ; \nif ( exponent != 0 ) { \nnewFactors [ k ++ ] = new Factor ( f1 , exponent ) ; \n} \ni1 ++ ; \ni2 ++ ; \n} \nelse { \nnewFactors [ k ++ ] = f2 ; \ni2 ++ ; \n} \n} \nif ( newFactors . length > k ) { \nfinal Factor [ ] tmp = new Factor [ k ] ; \nSystem . arraycopy ( newFactors , 0 , tmp , 0 , k ) ; \nnewFactors = tmp ; \n} \nreturn newFactors ; \n} \n} \n"}
{"5062": "public class Dimension { \nprotected Factor [ ] pow ( final int power ) { \nFactor [ ] factors ; \nif ( power == 0 ) { \nfactors = new Factor [ 0 ] ; \n} \nelse { \nfactors = getFactors ( ) ; \nif ( power != 1 ) { \nfor ( int i = factors . length ; \n0 <= -- i ; \n) { \nfactors [ i ] = factors [ i ] . pow ( power ) ; \n} \n} \n} \nreturn factors ; \n} \n} \n"}
{"5063": "public class Dimension { \npublic final boolean isReciprocalOf ( final Dimension that ) { \nfinal Factor [ ] theseFactors = _factors ; \nfinal Factor [ ] thoseFactors = that . _factors ; \nboolean isReciprocalOf ; \nif ( theseFactors . length != thoseFactors . length ) { \nisReciprocalOf = false ; \n} \nelse { \nint i ; \nfor ( i = theseFactors . length ; \n0 <= -- i ; \n) { \nif ( ! theseFactors [ i ] . isReciprocalOf ( thoseFactors [ i ] ) ) { \nbreak ; \n} \n} \nisReciprocalOf = 0 > i ; \n} \nreturn isReciprocalOf ; \n} \n} \n"}
{"5064": "public class Dimension { \npublic final boolean isDimensionless ( ) { \nfor ( int i = _factors . length ; \n0 <= -- i ; \n) { \nif ( ! _factors [ i ] . isDimensionless ( ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5070": "public class LogarithmicUnit { \npublic float [ ] toDerivedUnit ( final float [ ] input , final float [ ] output ) throws ConversionException { \nfor ( int i = input . length ; \n0 <= -- i ; \n) { \noutput [ i ] = ( float ) ( Math . exp ( input [ i ] * lnBase ) ) ; \n} \nreturn reference . toDerivedUnit ( output , output ) ; \n} \n} \n"}
{"5072": "public class Vis5DIosp { \nprivate Variable makeVerticalVariable ( int vert_sys , int n_levels , float [ ] vert_args ) throws IOException { \nString vert_unit = null ; \nString vert_type ; \nArrayFloat . D1 data = new ArrayFloat . D1 ( n_levels ) ; \nAxisType axisType = null ; \nswitch ( vert_sys ) { \ncase ( 0 ) : vert_unit = null ; \nvert_type = \"height\" ; \nbreak ; \ncase ( 1 ) : case ( 2 ) : vert_unit = \"km\" ; \nvert_type = \"altitude\" ; \naxisType = AxisType . Height ; \nbreak ; \ncase ( 3 ) : vert_unit = \"mbar\" ; \nvert_type = \"pressure\" ; \naxisType = AxisType . Pressure ; \nbreak ; \ndefault : throw new IOException ( \"vert_sys unknown\" ) ; \n} \nVariable vertVar = new Variable ( ncfile , null , null , vert_type ) ; \nvertVar . setDimensions ( LEVEL ) ; \nvertVar . setDataType ( DataType . FLOAT ) ; \nif ( vert_unit != null ) { \nvertVar . addAttribute ( new Attribute ( CDM . UNITS , vert_unit ) ) ; \n} \nif ( axisType != null ) { \nvertVar . addAttribute ( new Attribute ( _Coordinate . AxisType , axisType . toString ( ) ) ) ; \n} \nswitch ( vert_sys ) { \ncase ( 0 ) : case ( 1 ) : for ( int i = 0 ; \nn_levels > i ; \ni ++ ) { \ndata . set ( i , vert_args [ 0 ] + vert_args [ 1 ] * i ) ; \n} \nbreak ; \ncase ( 2 ) : for ( int i = 0 ; \nn_levels > i ; \ni ++ ) { \ndata . set ( i , vert_args [ i ] ) ; \n} \nbreak ; \ncase ( 3 ) : try { \nVis5DVerticalSystem . Vis5DVerticalCoordinateSystem vert_cs = new Vis5DVerticalSystem . Vis5DVerticalCoordinateSystem ( ) ; \nfloat [ ] [ ] pressures = new float [ 1 ] [ n_levels ] ; \nSystem . arraycopy ( vert_args , 0 , pressures [ 0 ] , 0 , n_levels ) ; \nfor ( int i = 0 ; \nn_levels > i ; \ni ++ ) { \npressures [ 0 ] [ i ] *= 1000 ; \n} \npressures = vert_cs . fromReference ( pressures ) ; \nfor ( int i = 0 ; \nn_levels > i ; \ni ++ ) { \ndata . set ( i , pressures [ 0 ] [ i ] ) ; \n} \n} \ncatch ( VisADException ve ) { \nthrow new IOException ( \"unable to make vertical system\" ) ; \n} \nbreak ; \n} \nvertVar . setCachedData ( data , false ) ; \nreturn vertVar ; \n} \n} \n"}
{"5085": "public class BufrSplitter { \npublic void processStream ( InputStream is ) throws IOException { \nint pos = - 1 ; \nBuffer b = null ; \nwhile ( true ) { \nb = ( 0 > pos ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; \npos = processBuffer ( b , is ) ; \nif ( b . done ) break ; \n} \n} \n} \n"}
{"5086": "public class BufrSplitter { \nprivate boolean readBuffer ( InputStream is , byte [ ] dest , int start , int want ) throws IOException { \nint done = 0 ; \nwhile ( want > done ) { \nint got = is . read ( dest , start + done , want - done ) ; \nif ( 0 > got ) return false ; \ndone += got ; \n} \nif ( showRead ) System . out . println ( \"Read buffer at \" + bytesRead + \" len=\" + done ) ; \nbytesRead += done ; \nreturn true ; \n} \n} \n"}
{"5087": "public class HeaderInputStream { \nprivate void getMoreBytes ( ) throws IOException { \ncurrentOffset = 0 ; \nint bytesRead = 0 ; \nint lookingFor = 0 ; \nfor ( ; \nlineBuf . length > bytesRead ; \nbytesRead ++ ) { \nint c = in . read ( ) ; \nif ( c == - 1 ) break ; \nlineBuf [ bytesRead ] = ( byte ) c ; \nif ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { \nlookingFor ++ ; \nif ( lookingFor == endSequence . length ) { \nendFound = true ; \nbreak ; \n} \n} \nelse if ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) { \nlookingFor = 1 ; \n} \nelse { \nlookingFor = 0 ; \n} \n} \nbytesRemaining = bytesRead ; \n} \n} \n"}
{"5088": "public class HeaderInputStream { \npublic int read ( byte b [ ] , int off , int len ) throws IOException { \nif ( 0 >= len ) { \nreturn 0 ; \n} \nint c = read ( ) ; \nif ( c == - 1 ) return - 1 ; \nb [ off ] = ( byte ) c ; \nint i = 1 ; \ntry { \nfor ( ; \nlen > i ; \ni ++ ) { \nc = read ( ) ; \nif ( c == - 1 ) { \nbreak ; \n} \nb [ off + i ] = ( byte ) c ; \n} \n} \ncatch ( IOException e ) { \n} \nreturn i ; \n} \n} \n"}
{"5089": "public class HeaderInputStream { \npublic long skip ( long n ) { \nif ( n <= bytesRemaining ) { \nbytesRemaining -= n ; \nreturn n ; \n} \nelse { \nint oldBytesRemaining = bytesRemaining ; \nbytesRemaining = 0 ; \nreturn oldBytesRemaining ; \n} \n} \n} \n"}
{"5091": "public class GridVertCoord { \nprivate int coordIndex ( GridRecord record ) { \ndouble val = record . getLevel1 ( ) ; \ndouble val2 = record . getLevel2 ( ) ; \nif ( usesBounds && ( val2 < val ) ) { \nval = record . getLevel2 ( ) ; \nval2 = record . getLevel1 ( ) ; \n} \nfor ( int i = 0 ; \nlevels . size ( ) > i ; \ni ++ ) { \nLevelCoord lc = ( LevelCoord ) levels . get ( i ) ; \nif ( usesBounds ) { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) && ucar . nc2 . util . Misc . nearlyEquals ( lc . value2 , val2 ) ) { \nreturn i ; \n} \n} \nelse { \nif ( ucar . nc2 . util . Misc . nearlyEquals ( lc . value1 , val ) ) { \nreturn i ; \n} \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5095": "public class NOWRadiosp { \npublic byte [ ] readOneRowData ( byte [ ] ddata , int rLen , int xt ) throws IOException , InvalidRangeException { \nint run ; \nbyte [ ] bdata = new byte [ xt ] ; \nint nbin = 0 ; \nint total = 0 ; \nfor ( run = 0 ; \nrLen > run ; \nrun ++ ) { \nint drun = DataType . unsignedByteToShort ( ddata [ run ] ) >> 4 ; \nbyte dcode1 = ( byte ) ( DataType . unsignedByteToShort ( ddata [ run ] ) & 0Xf ) ; \nfor ( int i = 0 ; \ndrun > i ; \ni ++ ) { \nbdata [ nbin ++ ] = dcode1 ; \ntotal ++ ; \n} \n} \nif ( xt > total ) { \nfor ( run = total ; \nxt > run ; \nrun ++ ) { \nbdata [ run ] = 0 ; \n} \n} \nreturn bdata ; \n} \n} \n"}
{"5096": "public class NcDDS { \nprivate void createFromDataset ( NetcdfDataset ncd ) { \nfor ( CoordinateAxis axis : ncd . getCoordinateAxes ( ) ) { \ncoordvars . put ( axis . getShortName ( ) , axis ) ; \n} \nddsvars = new ArrayList < > ( 50 ) ; \nfor ( Variable v : ncd . getVariables ( ) ) { \nif ( coordvars . containsKey ( v . getShortName ( ) ) ) continue ; \nddsvars . add ( v ) ; \nboolean isgridarray = ( 1 < v . getRank ( ) ) && ( v . getDataType ( ) != DataType . STRUCTURE ) && ( v . getParentStructure ( ) == null ) ; \nif ( ! isgridarray ) continue ; \nList < Dimension > dimset = v . getDimensions ( ) ; \nint rank = dimset . size ( ) ; \nfor ( int i = 0 ; \nisgridarray && rank > i ; \ni ++ ) { \nDimension dim = dimset . get ( i ) ; \nif ( dim . getShortName ( ) == null ) isgridarray = false ; \nelse { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv == null ) isgridarray = false ; \n} \n} \nif ( isgridarray ) { \ngridarrays . put ( v . getFullName ( ) , v ) ; \nfor ( Dimension dim : dimset ) { \nVariable gv = coordvars . get ( dim . getShortName ( ) ) ; \nif ( gv != null ) used . put ( gv . getFullName ( ) , gv ) ; \n} \n} \n} \nfor ( Variable cv : ncd . getCoordinateAxes ( ) ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \nfor ( Variable cv : ddsvars ) { \nBaseType bt = createVariable ( ncd , cv ) ; \naddVariable ( bt ) ; \n} \n} \n} \n"}
{"5097": "public class NcDDS { \nprivate BaseType createVariable ( NetcdfFile ncfile , Variable v ) { \nBaseType bt ; \nif ( v . getRank ( ) == 0 ) bt = createScalarVariable ( ncfile , v ) ; \nelse if ( v . getDataType ( ) == DataType . CHAR ) { \nif ( 1 < v . getRank ( ) ) bt = new NcSDCharArray ( v ) ; \nelse bt = new NcSDString ( v ) ; \n} \nelse if ( v . getDataType ( ) == DataType . STRING ) { \nif ( v . getRank ( ) == 0 ) bt = new NcSDString ( v ) ; \nelse bt = new NcSDArray ( v , new NcSDString ( v ) ) ; \n} \nelse bt = createArray ( ncfile , v ) ; \nreturn bt ; \n} \n} \n"}
{"5098": "public class NavigatedPanel { \nvoid fireMapAreaEvent ( ) { \nif ( debugZoom ) System . out . println ( \"NP.fireMapAreaEvent \" ) ; \nif ( project . isLatLon ( ) ) { \nLatLonProjection llproj = ( LatLonProjection ) project ; \nProjectionRect box = getMapArea ( ) ; \ndouble center = llproj . getCenterLon ( ) ; \ndouble lonBeg = LatLonPointImpl . lonNormal ( box . getMinX ( ) , center ) ; \ndouble lonEnd = lonBeg + box . getMaxX ( ) - box . getMinX ( ) ; \nboolean showShift = Debug . isSet ( \"projection/LatLonShift\" ) || debugNewProjection ; \nif ( showShift ) System . out . println ( \"projection/LatLonShift: min,max = \" + box . getMinX ( ) + \" \" + box . getMaxX ( ) + \" beg,end= \" + lonBeg + \" \" + lonEnd + \" center = \" + center ) ; \nif ( ( center - 180 > lonBeg ) || ( center + 180 < lonEnd ) ) { \ndouble wx0 = box . getX ( ) + box . getWidth ( ) / 2 ; \nllproj . setCenterLon ( wx0 ) ; \ndouble newWx0 = llproj . getCenterLon ( ) ; \nsetWorldCenterX ( newWx0 ) ; \nif ( showShift ) System . out . println ( \"projection/LatLonShift: shift center to \" + wx0 + \"->\" + newWx0 ) ; \nlmProject . sendEvent ( new NewProjectionEvent ( this , llproj ) ) ; \nreturn ; \n} \n} \nlmMapArea . sendEvent ( new NewMapAreaEvent ( this , getMapArea ( ) ) ) ; \n} \n} \n"}
{"5105": "public class NavigatedPanel { \nprivate void newScreenSize ( Rectangle b ) { \nboolean sameSize = ( b . width == myBounds . width ) && ( b . height == myBounds . height ) ; \nif ( debugBounds ) System . out . println ( \"NavigatedPanel newScreenSize old= \" + myBounds ) ; \nif ( sameSize && ( b . x == myBounds . x ) && ( b . y == myBounds . y ) ) return ; \nmyBounds . setBounds ( b ) ; \nif ( sameSize ) return ; \nif ( debugBounds ) System . out . println ( \"  newBounds = \" + b ) ; \nif ( ( 0 < b . width ) && ( 0 < b . height ) ) { \nbImage = new BufferedImage ( b . width , b . height , BufferedImage . TYPE_INT_RGB ) ; \n} \nelse { \nbImage = null ; \n} \nnavigate . setScreenSize ( b . width , b . height ) ; \n} \n} \n"}
{"5106": "public class DatasetTreeView { \npublic void setSelected ( VariableIF v ) { \nif ( v == null ) { \nreturn ; \n} \nfinal List < VariableIF > vchain = new ArrayList < > ( ) ; \nvchain . add ( v ) ; \nVariableIF vp = v ; \nwhile ( vp . isMemberOfStructure ( ) ) { \nvp = vp . getParentStructure ( ) ; \nvchain . add ( 0 , vp ) ; \n} \nfinal List < Group > gchain = new ArrayList < > ( ) ; \nGroup gp = vp . getParentGroup ( ) ; \ngchain . add ( gp ) ; \nwhile ( gp . getParentGroup ( ) != null ) { \ngp = gp . getParentGroup ( ) ; \ngchain . add ( 0 , gp ) ; \n} \nfinal List < Object > pathList = new ArrayList < > ( ) ; \nGroupNode gnode = ( GroupNode ) model . getRoot ( ) ; \npathList . add ( gnode ) ; \nGroup parentGroup = gchain . get ( 0 ) ; \nfor ( int i = 1 ; \ngchain . size ( ) > i ; \ni ++ ) { \nparentGroup = gchain . get ( i ) ; \ngnode = gnode . findNestedGroup ( parentGroup ) ; \nassert gnode != null ; \npathList . add ( gnode ) ; \n} \nvp = vchain . get ( 0 ) ; \nVariableNode vnode = gnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \nfor ( int i = 1 ; \nvchain . size ( ) > i ; \ni ++ ) { \nvp = vchain . get ( i ) ; \nvnode = vnode . findNestedVariable ( vp ) ; \nif ( vnode == null ) { \nreturn ; \n} \npathList . add ( vnode ) ; \n} \nfinal Object [ ] paths = pathList . toArray ( ) ; \nfinal TreePath treePath = new TreePath ( paths ) ; \ntree . setSelectionPath ( treePath ) ; \ntree . scrollPathToVisible ( treePath ) ; \n} \n} \n"}
{"5113": "public class MultiOdometer { \n@ Override public boolean hasNext ( ) { \nif ( odomset . size ( ) <= this . current ) return false ; \nOdometer ocurrent = odomset . get ( this . current ) ; \nif ( ocurrent . hasNext ( ) ) return true ; \nthis . current ++ ; \nreturn hasNext ( ) ; \n} \n} \n"}
{"5116": "public class GradsDataDescriptorFile { \npublic String getFileName ( int eIndex , int tIndex ) { \nString dataFilePath = dataFile ; \nif ( ( getTemplateType ( ) == ENS_TEMPLATE ) || ( getTemplateType ( ) == ENS_TIME_TEMPLATE ) ) { \ndataFilePath = getEnsembleDimension ( ) . replaceFileTemplate ( dataFilePath , eIndex ) ; \n} \ndataFilePath = getTimeDimension ( ) . replaceFileTemplate ( dataFilePath , tIndex ) ; \nif ( ( chsubs != null ) && ( dataFilePath . contains ( CHSUB_TEMPLATE_ID ) ) ) { \nfor ( Chsub ch : chsubs ) { \nif ( ( ch . startTimeIndex <= tIndex ) && ( ch . endTimeIndex >= tIndex ) ) { \ndataFilePath = dataFilePath . replace ( CHSUB_TEMPLATE_ID , ch . subString ) ; \nbreak ; \n} \n} \n} \nreturn getFullPath ( dataFilePath ) ; \n} \n} \n"}
{"5117": "public class GradsDataDescriptorFile { \nprivate List < String > getFileNames ( ) throws IOException { \nif ( fileNames == null ) { \nfileNames = new ArrayList < > ( ) ; \ntimeStepsPerFile = tDim . getSize ( ) ; \nif ( ! isTemplate ( ) ) { \nfileNames . add ( getFullPath ( getDataFile ( ) ) ) ; \n} \nelse { \nlong start = System . currentTimeMillis ( ) ; \nList < String > fileSet = new ArrayList < > ( ) ; \nString template = getDataFile ( ) ; \nif ( GradsTimeDimension . hasTimeTemplate ( template ) ) { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TIME_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nelse { \nif ( template . contains ( GradsEnsembleDimension . ENS_TEMPLATE_ID ) ) { \ntemplateType = ENS_TEMPLATE ; \n} \nelse { \ntemplateType = TIME_TEMPLATE ; \n} \n} \nif ( templateType == ENS_TEMPLATE ) { \nfor ( int e = 0 ; \neDim . getSize ( ) > e ; \ne ++ ) { \nfileSet . add ( getFullPath ( eDim . replaceFileTemplate ( template , e ) ) ) ; \n} \n} \nelse if ( ( templateType == TIME_TEMPLATE ) || ( templateType == ENS_TIME_TEMPLATE ) ) { \nint numens = ( templateType == TIME_TEMPLATE ) ? 1 : eDim . getSize ( ) ; \nfor ( int t = 0 ; \ntDim . getSize ( ) > t ; \nt ++ ) { \nfor ( int e = 0 ; \nnumens > e ; \ne ++ ) { \nString file = getFileName ( e , t ) ; \nif ( ! fileSet . contains ( file ) ) { \nfileSet . add ( file ) ; \n} \n} \n} \ntimeStepsPerFile = tDim . getSize ( ) / ( fileSet . size ( ) / numens ) ; \n} \nfileNames . addAll ( fileSet ) ; \n} \nfor ( String file : fileNames ) { \nFile f = new File ( file ) ; \nif ( ! f . exists ( ) ) { \nlog . error ( \"File: \" + f + \" does not exist\" ) ; \nthrow new IOException ( \"File: \" + f + \" does not exist\" ) ; \n} \n} \n} \nreturn fileNames ; \n} \n} \n"}
{"5118": "public class GradsDataDescriptorFile { \nprivate String getDDFPath ( ) { \nif ( pathToDDF == null ) { \nint lastSlash = ddFile . lastIndexOf ( \"/\" ) ; \nif ( 0 > lastSlash ) { \nlastSlash = ddFile . lastIndexOf ( File . separator ) ; \n} \npathToDDF = ( 0 > lastSlash ) ? \"\" : ddFile . substring ( 0 , lastSlash + 1 ) ; \n} \nreturn pathToDDF ; \n} \n} \n"}
{"5122": "public class Nidsheader { \nint readWMO ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nint pos = 0 ; \nraf . seek ( pos ) ; \nint readLen = 35 ; \nbyte [ ] b = new byte [ readLen ] ; \nint rc = raf . read ( b ) ; \nif ( rc != readLen ) { \nreturn 0 ; \n} \nint iarr2_1 = bytesToInt ( b [ 0 ] , b [ 1 ] , false ) ; \nint iarr2_16 = bytesToInt ( b [ 30 ] , b [ 31 ] , false ) ; \nint iarr2_10 = bytesToInt ( b [ 18 ] , b [ 19 ] , false ) ; \nint iarr2_7 = bytesToInt ( b [ 12 ] , b [ 13 ] , false ) ; \nif ( ( iarr2_1 == iarr2_16 ) && ( ( 16 <= iarr2_1 ) && ( 299 >= iarr2_1 ) ) && ( iarr2_10 == - 1 ) && ( 10000 > iarr2_7 ) ) { \nnoHeader = true ; \nreturn 1 ; \n} \nString pib = new String ( b , CDM . utf8Charset ) ; \nif ( pib . indexOf ( \"SDUS\" ) != - 1 ) { \nnoHeader = false ; \nreturn 1 ; \n} \nelse if ( raf . getLocation ( ) . indexOf ( \".nids\" ) != - 1 ) { \nnoHeader = true ; \nreturn 1 ; \n} \nelse return 0 ; \n} \n} \n"}
{"5124": "public class Nidsheader { \nint pcode_12n13n14 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ , String structName , int code ) { \nint vlen = 0 ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nvlen = vlen + dlen [ i ] ; \n} \nArrayList dims = new ArrayList ( ) ; \nDimension sDim = new Dimension ( \"graphicSymbolSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , structName ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"special graphic symbol for code \" + code ) ) ; \nVariable i0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \ni0 . setDimensions ( ( String ) null ) ; \ni0 . setDataType ( DataType . FLOAT ) ; \ni0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( i0 ) ; \nVariable j0 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nj0 . setDimensions ( ( String ) null ) ; \nj0 . setDataType ( DataType . FLOAT ) ; \nj0 . addAttribute ( new Attribute ( CDM . UNITS , \"KM\" ) ) ; \ndist . addMemberVariable ( j0 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , code , 0 ) ) ; \nreturn 1 ; \n} \n} \n"}
{"5129": "public class Nidsheader { \nint pcode_10n9 ( int [ ] pos , int [ ] dlen , int hoff , int len , boolean isZ ) { \nArrayList dims = new ArrayList ( ) ; \nVariable v ; \nint vlen = 0 ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nvlen = vlen + dlen [ i ] ; \n} \nDimension sDim = new Dimension ( \"unlinkedVectorSize\" , vlen ) ; \nncfile . addDimension ( null , sDim ) ; \ndims . add ( sDim ) ; \nStructure dist = new Structure ( ncfile , null , null , \"unlinkedVectorStruct\" ) ; \ndist . setDimensions ( dims ) ; \nncfile . addVariable ( null , dist ) ; \ndist . addAttribute ( new Attribute ( CDM . LONG_NAME , \"Unlinked Vector Packet\" ) ) ; \nv = new Variable ( ncfile , null , null , \"iValue\" ) ; \nv . setDataType ( DataType . SHORT ) ; \nv . setDimensions ( ( String ) null ) ; \ndist . addMemberVariable ( v ) ; \nVariable ii0 = new Variable ( ncfile , null , dist , \"x_start\" ) ; \nii0 . setDimensions ( ( String ) null ) ; \nii0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii0 ) ; \nVariable ii1 = new Variable ( ncfile , null , dist , \"y_start\" ) ; \nii1 . setDimensions ( ( String ) null ) ; \nii1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( ii1 ) ; \nVariable jj0 = new Variable ( ncfile , null , dist , \"x_end\" ) ; \njj0 . setDimensions ( ( String ) null ) ; \njj0 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj0 ) ; \nVariable jj1 = new Variable ( ncfile , null , dist , \"y_end\" ) ; \njj1 . setDimensions ( ( String ) null ) ; \njj1 . setDataType ( DataType . SHORT ) ; \ndist . addMemberVariable ( jj1 ) ; \nint [ ] pos1 = new int [ len ] ; \nint [ ] dlen1 = new int [ len ] ; \nSystem . arraycopy ( pos , 0 , pos1 , 0 , len ) ; \nSystem . arraycopy ( dlen , 0 , dlen1 , 0 , len ) ; \ndist . setSPobject ( new Vinfo ( 0 , 0 , 0 , 0 , hoff , 0 , isR , isZ , pos1 , dlen1 , 10 , 0 ) ) ; \nreturn 1 ; \n} \n} \n"}
{"5130": "public class Nidsheader { \npublic int [ ] getLevels ( int nlevel , short [ ] th ) { \nint [ ] levels = new int [ nlevel ] ; \nint ival ; \nint isign ; \nfor ( int i = 0 ; \nnlevel > i ; \ni ++ ) { \nival = convertShort2unsignedInt ( th [ i ] ) ; \nif ( ( ival & 0x00008000 ) == 0 ) { \nisign = - 1 ; \nif ( ( ival & 0x00000100 ) == 0 ) isign = 1 ; \nlevels [ i ] = isign * ( ival & 0x000000FF ) ; \n} \nelse { \nlevels [ i ] = - 9999 + ( ival & 0x000000FF ) ; \n} \n} \nreturn levels ; \n} \n} \n"}
{"5131": "public class Nidsheader { \npublic int [ ] getDualpolLevels ( short [ ] th ) { \nint inc = th . length ; \nint [ ] levels = new int [ inc ] ; \nfor ( int i = 0 ; \ninc > i ; \ni ++ ) { \nlevels [ i ] = th [ i ] ; \n} \nreturn levels ; \n} \n} \n"}
{"5134": "public class Nidsheader { \nbyte [ ] uncompressed ( ByteBuffer buf , int offset , int uncomplen ) throws IOException { \nbyte [ ] header = new byte [ offset ] ; \nbuf . position ( 0 ) ; \nbuf . get ( header ) ; \nbyte [ ] out = new byte [ offset + uncomplen ] ; \nSystem . arraycopy ( header , 0 , out , 0 , offset ) ; \nCBZip2InputStream cbzip2 = new CBZip2InputStream ( ) ; \nint numCompBytes = buf . remaining ( ) ; \nbyte [ ] bufc = new byte [ numCompBytes ] ; \nbuf . get ( bufc , 0 , numCompBytes ) ; \nByteArrayInputStream bis = new ByteArrayInputStream ( bufc , 2 , numCompBytes - 2 ) ; \ncbzip2 . setStream ( bis ) ; \nint total = 0 ; \nint nread ; \nbyte [ ] ubuff = new byte [ 40000 ] ; \nbyte [ ] obuff = new byte [ 40000 ] ; \ntry { \nwhile ( ( nread = cbzip2 . read ( ubuff ) ) != - 1 ) { \nif ( obuff . length < total + nread ) { \nbyte [ ] temp = obuff ; \nobuff = new byte [ temp . length * 2 ] ; \nSystem . arraycopy ( temp , 0 , obuff , 0 , temp . length ) ; \n} \nSystem . arraycopy ( ubuff , 0 , obuff , total , nread ) ; \ntotal += nread ; \n} \nif ( 0 <= obuff . length ) System . arraycopy ( obuff , 0 , out , offset , total ) ; \n} \ncatch ( BZip2ReadException ioe ) { \nlog . warn ( \"Nexrad2IOSP.uncompress \" + raf . getLocation ( ) , ioe ) ; \n} \nreturn out ; \n} \n} \n"}
{"5135": "public class Nidsheader { \nint getUInt ( byte [ ] b , int num ) { \nint base = 1 ; \nint i ; \nint word = 0 ; \nint bv [ ] = new int [ num ] ; \nfor ( i = 0 ; \nnum > i ; \ni ++ ) { \nbv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \n} \nfor ( i = num - 1 ; \n0 <= i ; \ni -- ) { \nword += base * bv [ i ] ; \nbase *= 256 ; \n} \nreturn word ; \n} \n} \n"}
{"5136": "public class Nidsheader { \nint getInt ( byte [ ] b , int num ) { \nint base = 1 ; \nint i ; \nint word = 0 ; \nint bv [ ] = new int [ num ] ; \nfor ( i = 0 ; \nnum > i ; \ni ++ ) { \nbv [ i ] = convertunsignedByte2Short ( b [ i ] ) ; \n} \nif ( 127 < bv [ 0 ] ) { \nbv [ 0 ] -= 128 ; \nbase = - 1 ; \n} \nfor ( i = num - 1 ; \n0 <= i ; \ni -- ) { \nword += base * bv [ i ] ; \nbase *= 256 ; \n} \nreturn word ; \n} \n} \n"}
{"5137": "public class Nidsheader { \nprotected Object convert ( byte [ ] barray , DataType dataType , int nelems , int byteOrder ) { \nif ( dataType == DataType . BYTE ) { \nreturn barray ; \n} \nif ( dataType == DataType . CHAR ) { \nreturn IospHelper . convertByteToChar ( barray ) ; \n} \nByteBuffer bbuff = ByteBuffer . wrap ( barray ) ; \nif ( 0 <= byteOrder ) bbuff . order ( byteOrder == ucar . unidata . io . RandomAccessFile . LITTLE_ENDIAN ? ByteOrder . LITTLE_ENDIAN : ByteOrder . BIG_ENDIAN ) ; \nif ( dataType == DataType . SHORT ) { \nShortBuffer tbuff = bbuff . asShortBuffer ( ) ; \nshort [ ] pa = new short [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse if ( dataType == DataType . INT ) { \nIntBuffer tbuff = bbuff . asIntBuffer ( ) ; \nint [ ] pa = new int [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse if ( dataType == DataType . FLOAT ) { \nFloatBuffer tbuff = bbuff . asFloatBuffer ( ) ; \nfloat [ ] pa = new float [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nelse if ( dataType == DataType . DOUBLE ) { \nDoubleBuffer tbuff = bbuff . asDoubleBuffer ( ) ; \ndouble [ ] pa = new double [ nelems ] ; \ntbuff . get ( pa ) ; \nreturn pa ; \n} \nthrow new IllegalStateException ( ) ; \n} \n} \n"}
{"5143": "public class Rubberband { \npublic Rectangle getBounds ( ) { \nreturn new Rectangle ( anchorPt . x > stretchedPt . x ? stretchedPt . x : anchorPt . x , anchorPt . y > stretchedPt . y ? stretchedPt . y : anchorPt . y , Math . abs ( stretchedPt . x - anchorPt . x ) , Math . abs ( stretchedPt . y - anchorPt . y ) ) ; \n} \n} \n"}
{"5144": "public class Rubberband { \npublic Rectangle lastBounds ( ) { \nreturn new Rectangle ( anchorPt . x > lastPt . x ? lastPt . x : anchorPt . x , anchorPt . y > lastPt . y ? lastPt . y : anchorPt . y , Math . abs ( lastPt . x - anchorPt . x ) , Math . abs ( lastPt . y - anchorPt . y ) ) ; \n} \n} \n"}
{"5147": "public class ErddapMath2 { \npublic static void ensureArraySizeOkay ( long tSize , String attributeTo ) { \nif ( Integer . MAX_VALUE <= tSize ) throw new RuntimeException ( memoryTooMuchData + \"  \" + MessageFormat . format ( memoryArraySize , \"\" + tSize , \"\" + Integer . MAX_VALUE ) + ( attributeTo == null || attributeTo . length ( ) == 0 ? \"\" : \" (\" + attributeTo + \")\" ) ) ; \n} \n} \n"}
{"5159": "public class Escape { \nstatic public String entityEscape ( String s , String wrt ) { \nif ( wrt == null ) wrt = ENTITYESCAPES ; \nStringBuilder escaped = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ns . length ( ) > i ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nint index = wrt . indexOf ( c ) ; \nif ( 0 > index ) escaped . append ( c ) ; \nelse switch ( c ) { \ncase '&' : escaped . append ( '&' + ENTITY_AMP + ';' ) ; \nbreak ; \ncase '<' : escaped . append ( '&' + ENTITY_LT + ';' ) ; \nbreak ; \ncase '>' : escaped . append ( '&' + ENTITY_GT + ';' ) ; \nbreak ; \ncase '\"' : escaped . append ( '&' + ENTITY_QUOT + ';' ) ; \nbreak ; \ncase '\\'' : escaped . append ( '&' + ENTITY_APOS + ';' ) ; \nbreak ; \ncase '\\r' : case '\\t' : case '\\n' : escaped . append ( c ) ; \nbreak ; \ncase '\\0' : break ; \ndefault : if ( ' ' <= c ) escaped . append ( c ) ; \nbreak ; \n} \n} \nreturn escaped . toString ( ) ; \n} \n} \n"}
{"5160": "public class Escape { \nstatic public String backslashUnescape ( String s ) { \nStringBuilder clear = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ns . length ( ) > i ; \n) { \nchar c = s . charAt ( i ++ ) ; \nif ( c == '\\\\' ) { \nc = s . charAt ( i ++ ) ; \nswitch ( c ) { \ncase 'r' : c = '\\r' ; \nbreak ; \ncase 'n' : c = '\\n' ; \nbreak ; \ncase 't' : c = '\\t' ; \nbreak ; \ncase 'f' : c = '\\f' ; \nbreak ; \ndefault : break ; \n} \nclear . append ( c ) ; \n} \nelse clear . append ( c ) ; \n} \nreturn clear . toString ( ) ; \n} \n} \n"}
{"5161": "public class Escape { \nstatic public List < String > backslashsplit ( String s , char sep ) { \nList < String > path = new ArrayList < String > ( ) ; \nint len = s . length ( ) ; \nStringBuilder piece = new StringBuilder ( ) ; \nint i = 0 ; \nfor ( ; \nlen - 1 >= i ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c == '\\\\' && ( len - 1 ) > i ) { \npiece . append ( c ) ; \npiece . append ( s . charAt ( ++ i ) ) ; \n} \nelse if ( c == sep ) { \npath . add ( piece . toString ( ) ) ; \npiece . setLength ( 0 ) ; \n} \nelse piece . append ( c ) ; \n} \npath . add ( piece . toString ( ) ) ; \nreturn path ; \n} \n} \n"}
{"5165": "public class BufrIdentificationSection { \npublic final CalendarDate getReferenceTime ( ) { \nint sec = ( 0 > second || 59 < second ) ? 0 : second ; \nreturn CalendarDate . of ( null , year , month , day , hour , minute , sec ) ; \n} \n} \n"}
{"5170": "public class M3IOConvention { \nprivate CoordinateTransform makeUTMProjection ( NetcdfDataset ds ) { \nint zone = ( int ) findAttributeDouble ( ds , \"P_ALP\" ) ; \ndouble ycent = findAttributeDouble ( ds , \"YCENT\" ) ; \nboolean isNorth = true ; \nif ( 0 > ycent ) isNorth = false ; \nUtmProjection utm = new UtmProjection ( zone , isNorth ) ; \nreturn new ProjectionCT ( \"UTM\" , \"EPSG\" , utm ) ; \n} \n} \n"}
{"5180": "public class ConfigCatalogInitialization { \nprivate ConfigCatalog readCatalog ( String catalogRelPath , String catalogFullPath ) { \nURI uri ; \ntry { \nuri = new URI ( this . contextPath + \"/catalog/\" + catalogRelPath ) ; \n} \ncatch ( URISyntaxException e ) { \nlogCatalogInit . error ( ERROR + \"readCatalog(): URISyntaxException=\" + e . getMessage ( ) ) ; \nreturn null ; \n} \nConfigCatalogBuilder builder = new ConfigCatalogBuilder ( ) ; \ntry { \nlogCatalogInit . info ( \"-------readCatalog(): path=\" + catalogRelPath ) ; \nConfigCatalog cat = ( ConfigCatalog ) builder . buildFromLocation ( catalogFullPath , uri ) ; \nif ( builder . hasFatalError ( ) ) { \nlogCatalogInit . error ( ERROR + \"   invalid catalog -- \" + builder . getErrorMessage ( ) ) ; \nreturn null ; \n} \nif ( 0 < builder . getErrorMessage ( ) . length ( ) ) logCatalogInit . debug ( builder . getErrorMessage ( ) ) ; \nreturn cat ; \n} \ncatch ( Throwable t ) { \nlogCatalogInit . error ( ERROR + \"  Exception on catalog=\" + catalogFullPath + \" \" + t . getMessage ( ) + \"\\n log=\" + builder . getErrorMessage ( ) , t ) ; \nreturn null ; \n} \n} \n} \n"}
{"5181": "public class ConfigCatalogInitialization { \nprivate void processDatasets ( long catId , ReadMode readMode , String dirPath , List < Dataset > datasets , Set < String > idMap ) throws IOException { \nif ( exceedLimit ) return ; \nfor ( Dataset ds : datasets ) { \nif ( datasetTracker . trackDataset ( catId , ds , callback ) ) countDatasets ++ ; \nif ( 0 < maxDatasetsProcess && maxDatasetsProcess < countDatasets ) exceedLimit = true ; \nString id = ds . getID ( ) ; \nif ( id != null ) { \nif ( idMap . contains ( id ) ) { \nlogCatalogInit . error ( ERROR + \"Duplicate id on  '\" + ds . getName ( ) + \"' id= '\" + id + \"'\" ) ; \n} \nelse { \nidMap . add ( id ) ; \n} \n} \nif ( ( ds instanceof DatasetScan ) || ( ds instanceof FeatureCollectionRef ) ) continue ; \nif ( ds instanceof CatalogScan ) continue ; \nif ( ds instanceof CatalogRef ) { \nCatalogRef catref = ( CatalogRef ) ds ; \nString href = catref . getXlinkHref ( ) ; \nif ( ! href . startsWith ( \"http:\" ) ) { \nif ( href . startsWith ( \"./\" ) ) { \nhref = href . substring ( 2 ) ; \n} \nString path ; \nString contextPathPlus = this . contextPath + \"/\" ; \nif ( href . startsWith ( contextPathPlus ) ) { \npath = href . substring ( contextPathPlus . length ( ) ) ; \n} \nelse if ( href . startsWith ( \"/\" ) ) { \nlogCatalogInit . error ( ERROR + \"Skipping catalogRef <xlink:href=\" + href + \">. Reference is relative to the server outside the context path [\" + contextPathPlus + \"]. \" + \"Parent catalog info: Name=\\\"\" + catref . getParentCatalog ( ) . getName ( ) + \"\\\"; Base URI=\\\"\" + catref . getParentCatalog ( ) . getUriString ( ) + \"\\\"; dirPath=\\\"\" + dirPath + \"\\\".\" ) ; \ncontinue ; \n} \nelse { \npath = dirPath + href ; \n} \nCatalogExt ext = catalogTracker . get ( path ) ; \nlong lastRead = ( ext == null ) ? 0 : ext . getLastRead ( ) ; \ncheckCatalogToRead ( readMode , path , false , lastRead ) ; \n} \n} \nelse { \nprocessDatasets ( catId , readMode , dirPath , ds . getDatasetsLocal ( ) , idMap ) ; \n} \n} \n} \n} \n"}
{"5183": "public class LatLonPointImpl { \nstatic public boolean betweenLon ( double lon , double lonBeg , double lonEnd ) { \nlonBeg = lonNormal ( lonBeg , lon ) ; \nlonEnd = lonNormal ( lonEnd , lon ) ; \nreturn ( lonBeg <= lon ) && ( lonEnd >= lon ) ; \n} \n} \n"}
{"5184": "public class LatLonPointImpl { \nstatic public String latToString ( double lat , int ndec ) { \nboolean is_north = ( 0.0 <= lat ) ; \nif ( ! is_north ) lat = - lat ; \nString f = \"%.\" + ndec + \"f\" ; \nFormatter latBuff = new Formatter ( ) ; \nlatBuff . format ( f , lat ) ; \nlatBuff . format ( \"%s\" , is_north ? \"N\" : \"S\" ) ; \nreturn latBuff . toString ( ) ; \n} \n} \n"}
{"5185": "public class LatLonPointImpl { \nstatic public String lonToString ( double lon , int ndec ) { \ndouble wlon = lonNormal ( lon ) ; \nboolean is_east = ( 0.0 <= wlon ) ; \nif ( ! is_east ) wlon = - wlon ; \nString f = \"%.\" + ndec + \"f\" ; \nFormatter latBuff = new Formatter ( ) ; \nlatBuff . format ( f , wlon ) ; \nlatBuff . format ( \"%s\" , is_east ? \"E\" : \"W\" ) ; \nreturn latBuff . toString ( ) ; \n} \n} \n"}
{"5192": "public class CatalogTreeView { \npublic void setCatalog ( Catalog catalog ) { \nif ( catalog == null ) return ; \nString catalogName = catalog . getBaseURI ( ) . toString ( ) ; \nthis . catalog = catalog ; \nsetCatalogURL ( catalogName ) ; \nmodel = new InvCatalogTreeModel ( catalog ) ; \ntree . setModel ( model ) ; \nif ( debugTree ) { \nSystem . out . println ( \"*** catalog/showJTree =\" ) ; \nshowNode ( tree . getModel ( ) , tree . getModel ( ) . getRoot ( ) ) ; \nSystem . out . println ( \"*** \" ) ; \n} \nint pos = catalogName . indexOf ( '#' ) ; \nif ( 0 <= pos ) { \nString id = catalogName . substring ( pos + 1 ) ; \nDataset dataset = catalog . findDatasetByID ( id ) ; \nif ( dataset != null ) { \nsetSelectedDataset ( dataset ) ; \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Selection\" , null , dataset ) ) ; \n} \n} \nfirePropertyChangeEvent ( new PropertyChangeEvent ( this , \"Catalog\" , null , catalogName ) ) ; \n} \n} \n"}
{"5195": "public class VlenIO { \npublic int writeChars ( String s , int start , int length ) throws IOException { \nfinal int end = start + length ; \nint count = 0 ; \nfor ( int i = start ; \nend > i ; \ni ++ ) { \nfinal int code = ( int ) s . charAt ( i ) ; \nif ( 0x01 <= code && 0x7F >= code ) { \nwriteByte ( ( byte ) code ) ; \ncount ++ ; \n} \nelse if ( ( ( 0x80 <= code ) && ( 0x7FF >= code ) ) || code == 0 ) { \nwriteByte ( ( byte ) ( 0xC0 | ( code >> 6 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 2 ; \n} \nelse { \nwriteByte ( ( byte ) ( 0xE0 | ( code >>> 12 ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( ( code >> 6 ) & 0x3F ) ) ) ; \nwriteByte ( ( byte ) ( 0x80 | ( code & 0x3F ) ) ) ; \ncount += 3 ; \n} \n} \nreturn count ; \n} \n} \n"}
{"5196": "public class VlenIO { \npublic void readChars ( char [ ] buffer , int start , int length ) throws IOException { \nfinal int end = start + length ; \nfor ( int i = start ; \nend > i ; \ni ++ ) { \nbyte b = readByte ( ) ; \nif ( ( b & 0x80 ) == 0 ) buffer [ i ] = ( char ) ( b & 0x7F ) ; \nelse if ( ( b & 0xE0 ) != 0xE0 ) { \nbuffer [ i ] = ( char ) ( ( ( b & 0x1F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \nelse buffer [ i ] = ( char ) ( ( ( b & 0x0F ) << 12 ) | ( ( readByte ( ) & 0x3F ) << 6 ) | ( readByte ( ) & 0x3F ) ) ; \n} \n} \n} \n"}
{"5202": "public class Grib1SectionBitMap { \n@ Nullable public byte [ ] getBitmap ( RandomAccessFile raf ) throws IOException { \nif ( 0 >= startingPosition ) { \nthrow new IllegalStateException ( \"Grib1 Bit map has bad starting position\" ) ; \n} \nraf . seek ( startingPosition ) ; \nint length = GribNumbers . uint3 ( raf ) ; \nraf . read ( ) ; \nint bm = raf . readShort ( ) ; \nif ( bm != 0 ) { \nlogger . warn ( \"Grib1 Bit map section pre-defined (provided by center) bitmap number = {}\" , bm ) ; \nreturn null ; \n} \nif ( 6 >= length || 10e6 < length ) { \nreturn null ; \n} \nint n = length - 6 ; \nbyte [ ] data = new byte [ n ] ; \nraf . readFully ( data ) ; \nreturn data ; \n} \n} \n"}
{"5203": "public class JTreeTableSorted { \npublic void restoreState ( PreferencesExt store ) { \nif ( store == null ) return ; \nint ncols = table . getColumnCount ( ) ; \nint [ ] modelIndex = ( int [ ] ) store . getBean ( \"ColumnOrder\" , null ) ; \nif ( ( modelIndex != null ) && ( modelIndex . length == ncols ) ) { \nboolean [ ] visible = new boolean [ ncols ] ; \nfor ( int aModelIndex : modelIndex ) if ( ncols > aModelIndex ) visible [ aModelIndex ] = true ; \nfor ( int i = 0 ; \nncols > i ; \ni ++ ) if ( ! visible [ i ] ) { \nacts [ i ] . hideColumn ( ) ; \nacts [ i ] . putValue ( BAMutil . STATE , new Boolean ( false ) ) ; \n} \nTableColumnModel tcm = table . getColumnModel ( ) ; \nint n = Math . min ( modelIndex . length , table . getColumnCount ( ) ) ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \ntc . setModelIndex ( modelIndex [ i ] ) ; \nString name = model . getColumnName ( modelIndex [ i ] ) ; \ntc . setHeaderValue ( name ) ; \ntc . setIdentifier ( name ) ; \nif ( useThreads && ( modelIndex [ i ] == threadCol ) ) { \nthreadHeaderRenderer = new ThreadHeaderRenderer ( threadCol ) ; \ntc . setHeaderRenderer ( threadHeaderRenderer ) ; \n} \nelse tc . setHeaderRenderer ( new SortedHeaderRenderer ( name , modelIndex [ i ] ) ) ; \n} \n} \nObject colWidths = store . getBean ( \"ColumnWidths\" , null ) ; \nif ( colWidths == null ) return ; \nint [ ] size = ( int [ ] ) colWidths ; \nsetColumnWidths ( size ) ; \nif ( debug ) { \nSystem . out . println ( \" read widths = \" ) ; \nfor ( int aSize : size ) System . out . print ( \" \" + aSize ) ; \nSystem . out . println ( ) ; \n} \nboolean isThreadsOn = store . getBoolean ( \"isThreadsOn\" , false ) ; \nif ( useThreads ) { \nmodel . setThreadsOn ( isThreadsOn ) ; \nthreadHeaderRenderer . setOn ( isThreadsOn ) ; \n} \nint colNo = store . getInt ( \"SortOnCol\" , 0 ) ; \nboolean reverse = store . getBoolean ( \"SortReverse\" , false ) ; \nmodel . setSortCol ( colNo ) ; \nmodel . setReverse ( reverse ) ; \nsetSortCol ( colNo , reverse ) ; \nmodel . sort ( ) ; \ntable . fireDataChanged ( ) ; \n} \nprivate void setColumnWidths ( int [ ] sizes ) { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( int i = 0 ; \ntable . getColumnCount ( ) > i ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nint maxw = ( ( sizes == null ) || ( sizes . length <= i ) ) ? 10 : sizes [ i ] ; \ntc . setPreferredWidth ( maxw ) ; \n} \n} \npublic void setColOn ( int colno , boolean state , int pos ) { \nacts [ colno ] . putValue ( BAMutil . STATE , new Boolean ( state ) ) ; \nif ( state ) acts [ colno ] . addAtPos ( pos ) ; \nelse acts [ colno ] . hideColumn ( ) ; \n} \n} \n"}
{"5204": "public class JTreeTableSorted { \npublic Iterator getSelectedRows ( ) { \nTreePath [ ] paths = table . getSelectionPaths ( ) ; \nif ( ( paths == null ) || ( 1 > paths . length ) ) return null ; \nHashSet set = new HashSet ( 2 * paths . length ) ; \nfor ( TreePath path : paths ) { \nmodel . addRowsToSetFromPath ( table . getTree ( ) , path , set ) ; \n} \nreturn set . iterator ( ) ; \n} \n} \n"}
{"5205": "public class JTreeTableSorted { \npublic int [ ] getModelIndex ( ) { \nint [ ] modelIndex = new int [ model . getColumnCount ( ) ] ; \ntry { \nTableColumnModel tcm = table . getColumnModel ( ) ; \nfor ( int i = 0 ; \nmodel . getColumnCount ( ) > i ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nmodelIndex [ i ] = tc . getModelIndex ( ) ; \n} \n} \ncatch ( java . lang . ArrayIndexOutOfBoundsException e ) { \n} \nreturn modelIndex ; \n} \n} \n"}
{"5227": "public class GridVariable { \npublic void showMissing ( Formatter f ) { \nint count = 0 , total = 0 ; \nf . format ( \"  %s%n\" , name ) ; \nfor ( int j = 0 ; \nnlevels > j ; \nj ++ ) { \nf . format ( \"   \" ) ; \nfor ( int i = 0 ; \nntimes > i ; \ni ++ ) { \nboolean missing = recordTracker [ i * nlevels + j ] == null ; \nf . format ( \"%s\" , missing ? \"-\" : \"X\" ) ; \nif ( missing ) count ++ ; \ntotal ++ ; \n} \nf . format ( \"%n\" ) ; \n} \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \n} \n} \n"}
{"5228": "public class GridVariable { \npublic int showMissingSummary ( Formatter f ) { \nint count = 0 ; \nint total = recordTracker . length ; \nfor ( int i = 0 ; \ntotal > i ; \ni ++ ) { \nif ( recordTracker [ i ] == null ) count ++ ; \n} \nf . format ( \"  MISSING= %d / %d for %s%n\" , count , total , name ) ; \nreturn count ; \n} \n} \n"}
{"5233": "public class NCheader { \nstatic boolean memequal ( byte [ ] b1 , byte [ ] b2 , int len ) { \nif ( b1 == b2 ) return true ; \nif ( b1 == null || b2 == null ) return false ; \nif ( len > b1 . length || len > b2 . length ) return false ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nif ( b1 [ i ] != b2 [ i ] ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"5235": "public class AbstractDSP { \nprotected void processAttributes ( DapDataset dataset ) throws DapException { \nList < DapNode > nodes = dataset . getNodeList ( ) ; \nfor ( DapNode node : nodes ) { \nswitch ( node . getSort ( ) ) { \ncase GROUP : case DATASET : case VARIABLE : Map < String , DapAttribute > attrs = node . getAttributes ( ) ; \nif ( 0 < attrs . size ( ) ) { \nList < DapAttribute > suppressed = new ArrayList < > ( ) ; \nfor ( DapAttribute dattr : attrs . values ( ) ) { \nif ( suppress ( dattr . getShortName ( ) ) ) suppressed . add ( dattr ) ; \n} \nfor ( DapAttribute dattr : suppressed ) { \nnode . removeAttribute ( dattr ) ; \n} \n} \nbreak ; \ndefault : break ; \n} \n} \ngetEndianAttribute ( dataset ) ; \n} \n} \n"}
{"5237": "public class GdsHorizCoordSys { \npublic void setGaussianLats ( int nparallels , float la1 , float la2 ) { \nlog . debug ( \"la1 {}, la2 {}\" , la1 , la2 ) ; \nif ( this . gaussLats != null ) throw new RuntimeException ( \"Cant modify GdsHorizCoordSys\" ) ; \nint nlats = ( 2 * nparallels ) ; \nGaussianLatitudes gaussLats = GaussianLatitudes . factory ( nlats ) ; \nint bestStartIndex = 0 , bestEndIndex = 0 ; \ndouble bestStartDiff = Double . MAX_VALUE ; \ndouble bestEndDiff = Double . MAX_VALUE ; \nfor ( int i = 0 ; \nnlats > i ; \ni ++ ) { \ndouble diff = Math . abs ( gaussLats . latd [ i ] - la1 ) ; \nif ( bestStartDiff > diff ) { \nbestStartDiff = diff ; \nbestStartIndex = i ; \n} \ndiff = Math . abs ( gaussLats . latd [ i ] - la2 ) ; \nif ( bestEndDiff > diff ) { \nbestEndDiff = diff ; \nbestEndIndex = i ; \n} \n} \nlog . debug ( \"first pass: bestStartIndex {}, bestEndIndex {}\" , bestStartIndex , bestEndIndex ) ; \nif ( Math . abs ( bestEndIndex - bestStartIndex ) + 1 != nyRaw ) { \nlog . warn ( \"GRIB gaussian lats: NP != NY, use NY\" ) ; \nnlats = nyRaw ; \ngaussLats = GaussianLatitudes . factory ( nlats ) ; \nbestStartIndex = 0 ; \nbestEndIndex = nyRaw - 1 ; \n} \nboolean goesUp = bestStartIndex < bestEndIndex ; \nlog . debug ( \"bestStartIndex {}, bestEndIndex {}, goesUp {}\" , bestStartIndex , bestEndIndex , goesUp ) ; \nint useIndex = bestStartIndex ; \nfloat [ ] data = new float [ nyRaw ] ; \nfloat [ ] gaussw = new float [ nyRaw ] ; \nfor ( int i = 0 ; \nnyRaw > i ; \ni ++ ) { \ndata [ i ] = ( float ) gaussLats . latd [ useIndex ] ; \ngaussw [ i ] = ( float ) gaussLats . gaussw [ useIndex ] ; \nlog . trace ( \"i {}, useIndex {}, data {}, gaussw {}\" , i , useIndex , data [ i ] , gaussw [ i ] ) ; \nif ( goesUp ) { \nuseIndex ++ ; \n} \nelse { \nuseIndex -- ; \n} \n} \nthis . gaussLats = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, data ) ; \nthis . gaussw = Array . factory ( DataType . FLOAT , new int [ ] { \nnyRaw } \n, gaussw ) ; \n} \n} \n"}
{"5238": "public class ParsedSectionSpec { \nprivate static ParsedSectionSpec parseVariableSelector ( Object parent , String selector ) throws InvalidRangeException { \nString varNameEsc , indexSelect = null ; \nint pos1 = EscapeStrings . indexOf ( selector , '(' ) ; \nif ( 0 > pos1 ) { \nvarNameEsc = selector ; \n} \nelse { \nvarNameEsc = selector . substring ( 0 , pos1 ) ; \nint pos2 = selector . indexOf ( ')' , pos1 + 1 ) ; \nindexSelect = selector . substring ( pos1 , pos2 ) ; \n} \nif ( debugSelector ) System . out . println ( \" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\" ) ; \nVariable v = null ; \nif ( parent instanceof NetcdfFile ) { \nNetcdfFile ncfile = ( NetcdfFile ) parent ; \nv = ncfile . findVariable ( varNameEsc ) ; \n} \nelse if ( parent instanceof Structure ) { \nStructure s = ( Structure ) parent ; \nv = s . findVariable ( NetcdfFile . makeNameUnescaped ( varNameEsc ) ) ; \n} \nif ( v == null ) throw new IllegalArgumentException ( \" cant find variable: \" + varNameEsc + \" in selector=\" + selector ) ; \nif ( v . getDataType ( ) == DataType . SEQUENCE ) indexSelect = null ; \nSection section ; \nif ( indexSelect != null ) { \nsection = new Section ( indexSelect ) ; \nsection = Section . fill ( section , v . getShape ( ) ) ; \n} \nelse { \nsection = v . getShapeAsSection ( ) ; \n} \nreturn new ParsedSectionSpec ( v , section ) ; \n} \n} \n"}
{"5240": "public class GeoGridCoordinate2D { \nprivate boolean box9 ( double wantLat , double wantLon , int [ ] rectIndex ) { \nint row = rectIndex [ 0 ] ; \nint minrow = Math . max ( row - 1 , 0 ) ; \nint maxrow = Math . min ( row + 1 , nrows ) ; \nint col = rectIndex [ 1 ] ; \nint mincol = Math . max ( col - 1 , 0 ) ; \nint maxcol = Math . min ( col + 1 , ncols ) ; \nif ( debug ) System . out . printf ( \"%n   box9:\" ) ; \nfor ( int i = minrow ; \nmaxrow >= i ; \ni ++ ) for ( int j = mincol ; \nmaxcol >= j ; \nj ++ ) { \nrectIndex [ 0 ] = i ; \nrectIndex [ 1 ] = j ; \nif ( contains ( wantLat , wantLon , rectIndex ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"5243": "public class CFpointObs { \nprotected boolean identifyEncodingStation ( NetcdfDataset ds , EncodingInfo info , CF . FeatureType ftype , Formatter errlog ) { \nDimension obsDim = null ; \nif ( 0 < info . time . getRank ( ) ) obsDim = info . time . getDimension ( info . time . getRank ( ) - 1 ) ; \nelse if ( info . time . getParentStructure ( ) != null ) { \nStructure parent = info . time . getParentStructure ( ) ; \nobsDim = parent . getDimension ( parent . getRank ( ) - 1 ) ; \n} \nif ( obsDim == null ) { \nerrlog . format ( \"CFpointObs: must have a non-scalar Time coordinate%n\" ) ; \nreturn false ; \n} \nif ( info . lat . getRank ( ) == 0 ) { \ninfo . set ( Encoding . single , null , obsDim ) ; \nreturn true ; \n} \nDimension stnDim = info . lat . getDimension ( 0 ) ; \nif ( obsDim == stnDim ) { \ninfo . set ( Encoding . flat , null , obsDim ) ; \nreturn true ; \n} \nif ( identifyRaggeds ( ds , info , stnDim , obsDim , errlog ) ) return true ; \nif ( info . lat . getRank ( ) == 1 ) { \ninfo . set ( Encoding . multidim , stnDim , obsDim ) ; \nreturn true ; \n} \nerrlog . format ( \"CFpointObs: %s Must have Lat/Lon coordinates of rank 0 or 1%n\" , ftype ) ; \nreturn false ; \n} \n} \n"}
{"5247": "public class ProgressMonitor { \npublic void start ( java . awt . Component top , String taskName , int progressMaxCount ) { \npm = new javax . swing . ProgressMonitor ( top , taskName , \"\" , 0 , progressMaxCount ) ; \npm . setMillisToDecideToPopup ( millisToDecideToPopup ) ; \npm . setMillisToPopup ( millisToPopup ) ; \ntaskThread = new Thread ( task ) ; \ntaskThread . start ( ) ; \nActionListener watcher = new ActionListener ( ) { \npublic void actionPerformed ( ActionEvent evt ) { \nsecs ++ ; \nif ( pm . isCanceled ( ) ) { \ntask . cancel ( ) ; \n} \nelse { \nString note = task . getNote ( ) ; \npm . setNote ( note == null ? secs + \" secs\" : note ) ; \nint progress = task . getProgress ( ) ; \npm . setProgress ( 0 >= progress ? secs : progress ) ; \n} \nif ( task . isDone ( ) ) { \ntimer . stop ( ) ; \npm . close ( ) ; \nif ( task . isError ( ) ) { \njavax . swing . JOptionPane . showMessageDialog ( null , task . getErrorMessage ( ) ) ; \n} \nif ( task . isSuccess ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"success\" ) ) ; \nelse if ( task . isError ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"error\" ) ) ; \nelse if ( task . isCancel ( ) ) fireEvent ( new ActionEvent ( this , 0 , \"cancel\" ) ) ; \nelse fireEvent ( new ActionEvent ( this , 0 , \"done\" ) ) ; \n} \n} \n} \n; \ntimer = new javax . swing . Timer ( 1000 , watcher ) ; \ntimer . start ( ) ; \n} \n} \n"}
{"5248": "public class HTTPUtil { \nstatic public URI parseToURI ( final String u ) throws URISyntaxException { \nStringBuilder buf = new StringBuilder ( ) ; \nint i = 0 ; \nwhile ( u . length ( ) > i ) { \nchar c = u . charAt ( i ) ; \nif ( c == '\\\\' ) { \nif ( i + 1 == u . length ( ) ) throw new URISyntaxException ( u , \"Trailing '\\' at end of url\" ) ; \nbuf . append ( \"%5c\" ) ; \ni ++ ; \nc = u . charAt ( i ) ; \nbuf . append ( String . format ( \"%%%02x\" , ( int ) c ) ) ; \n} \nelse buf . append ( c ) ; \ni ++ ; \n} \nreturn new URI ( buf . toString ( ) ) ; \n} \n} \n"}
{"5251": "public class HTTPUtil { \nstatic public String canonjoin ( String prefix , String suffix ) { \nif ( prefix == null ) prefix = \"\" ; \nif ( suffix == null ) suffix = \"\" ; \nprefix = HTTPUtil . canonicalpath ( prefix ) ; \nsuffix = HTTPUtil . canonicalpath ( suffix ) ; \nStringBuilder result = new StringBuilder ( ) ; \nresult . append ( prefix ) ; \nint prelen = prefix . length ( ) ; \nif ( 0 < prelen && result . charAt ( prelen - 1 ) != '/' ) { \nresult . append ( '/' ) ; \nprelen ++ ; \n} \nif ( 0 < suffix . length ( ) && suffix . charAt ( 0 ) == '/' ) result . append ( suffix . substring ( 1 ) ) ; \nelse result . append ( suffix ) ; \nint len = result . length ( ) ; \nif ( 0 < len && result . charAt ( len - 1 ) == '/' ) { \nresult . deleteCharAt ( len - 1 ) ; \nlen -- ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"5252": "public class LastModifiedLimitFilter { \npublic boolean accept ( CrawlableDataset dataset ) { \nDate lastModDate = dataset . lastModified ( ) ; \nif ( lastModDate != null ) { \nlong now = System . currentTimeMillis ( ) ; \nif ( lastModifiedLimitInMillis < now - lastModDate . getTime ( ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"5268": "public class WFSGetFeatureWriter { \nprivate void writeHeadersAndBB ( ) { \nfileOutput += \"<wfs:FeatureCollection xsi:schemaLocation=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd \" + namespace + \" \" + server + \"?request=DescribeFeatureType\" + WFSXMLHelper . AMPERSAND + \"service=wfs\" + WFSXMLHelper . AMPERSAND + \"version=2.0.0\" + WFSXMLHelper . AMPERSAND + \"typename=\" + WFSController . TDSNAMESPACE + \"%3A\" + ftName ) + \" xmlns:xsi=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/2001/XMLSchema-instance\" ) + \" xmlns:xlink=\" + WFSXMLHelper . encQuotes ( \"http://www.w3.org/1999/xlink\" ) + \" xmlns:gml=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/gml/3.2\" ) + \" xmlns:fes=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/fes/2.0\" ) + \" xmlns:ogc=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/ogc\" ) + \" xmlns:wfs=\" + WFSXMLHelper . encQuotes ( \"http://opengis.net/wfs/2.0\" ) + \" xmlns:\" + WFSController . TDSNAMESPACE + \"=\" + WFSXMLHelper . encQuotes ( namespace ) + \" xmlns=\" + WFSXMLHelper . encQuotes ( \"http://www.opengis.net/wfs/2.0\" ) + \" version=\\\"2.0.0\\\" numberMatched=\" + WFSXMLHelper . encQuotes ( String . valueOf ( geometries . size ( ) ) ) + \" numberReturned=\" + WFSXMLHelper . encQuotes ( String . valueOf ( geometries . size ( ) ) ) + \">\" ; \ndouble [ ] boundLower ; \ndouble [ ] boundUpper ; \nif ( geometries . isEmpty ( ) ) { \nboundLower = new double [ 2 ] ; \nboundUpper = new double [ 2 ] ; \nboundLower [ 0 ] = - 180 ; \nboundLower [ 1 ] = - 90 ; \nboundUpper [ 0 ] = 180 ; \nboundUpper [ 1 ] = 90 ; \n} \nelse { \nboundLower = geometries . get ( 0 ) . getBBLower ( ) ; \nboundUpper = geometries . get ( 0 ) . getBBUpper ( ) ; \n} \nfor ( SimpleGeometry item : geometries ) { \ndouble [ ] low = item . getBBLower ( ) ; \nif ( low [ 0 ] < boundLower [ 0 ] ) boundLower [ 0 ] = low [ 0 ] ; \nif ( low [ 1 ] < boundLower [ 1 ] ) boundLower [ 1 ] = low [ 1 ] ; \ndouble [ ] upper = item . getBBUpper ( ) ; \nif ( upper [ 0 ] > boundUpper [ 0 ] ) boundUpper [ 0 ] = upper [ 0 ] ; \nif ( upper [ 1 ] > boundUpper [ 1 ] ) boundUpper [ 1 ] = upper [ 1 ] ; \nboundLower [ 0 ] -= 10 ; \nboundLower [ 1 ] -= 10 ; \nboundUpper [ 0 ] += 10 ; \nboundUpper [ 1 ] += 10 ; \n} \nfileOutput += \"<wfs:boundedBy>\" + \"<wfs:Envelope srsName=\" + \"\\\"urn:ogc:def:crs:EPSG::4326\\\"\" + \">\" + \"<wfs:lowerCorner>\" + boundLower [ 0 ] + \" \" + boundLower [ 1 ] + \"</wfs:lowerCorner>\" + \"<wfs:upperCorner>\" + boundUpper [ 0 ] + \" \" + boundUpper [ 1 ] + \"</wfs:upperCorner>\" + \"</wfs:Envelope>\" + \"</wfs:boundedBy>\" ; \n} \n} \n"}
{"5272": "public class ChunkWriter { \npublic void writeDSR ( String dsr ) throws IOException { \nif ( state != State . INITIAL ) throw new DapException ( \"Attempt to write DSR twice\" ) ; \nif ( dsr == null ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \nint len = dsr . length ( ) ; \nwhile ( 0 < len ) { \nchar c = dsr . charAt ( len - 1 ) ; \nif ( c != '\\r' && c != '\\n' ) break ; \nlen -- ; \n} \nif ( dsr . length ( ) == 0 ) throw new DapException ( \"Attempt to write empty DSR\" ) ; \ndsr = dsr . substring ( 0 , len ) + DapUtil . CRLF ; \ndsr = XMLDOCUMENTHEADER + \"\\n\" + dsr ; \nbyte [ ] dsr8 = DapUtil . extract ( DapUtil . UTF8 . encode ( dsr ) ) ; \nsendDXR ( dsr8 ) ; \nstate = State . END ; \n} \n} \n"}
{"5278": "public class Range { \npublic boolean contains ( int want ) { \nif ( first ( ) > want ) return false ; \nif ( last ( ) < want ) return false ; \nif ( stride == 1 ) return true ; \nreturn ( want - first ) % stride == 0 ; \n} \n} \n"}
{"5279": "public class Range { \npublic int element ( int i ) throws InvalidRangeException { \nif ( 0 > i ) throw new InvalidRangeException ( \"i must be >= 0\" ) ; \nif ( length <= i ) throw new InvalidRangeException ( \"i must be < length\" ) ; \nreturn first + i * stride ; \n} \n} \n"}
{"5283": "public class BooleanPrimitiveVector { \npublic PrimitiveVector subset ( int start , int stop , int stride ) { \nBooleanPrimitiveVector n = new BooleanPrimitiveVector ( getTemplate ( ) ) ; \nstride = Math . max ( stride , 1 ) ; \nstop = Math . max ( start , stop ) ; \nint length = 1 + ( stop - start ) / stride ; \nn . setLength ( length ) ; \nint count = 0 ; \nfor ( int i = start ; \nstop >= i ; \ni += stride ) { \nn . setValue ( count , vals [ i ] ) ; \ncount ++ ; \n} \nreturn n ; \n} \n} \n"}
{"5285": "public class DatasetTrackerChronicle { \npublic static void cleanupBefore ( String pathname , long trackerNumber ) { \nfor ( long tnum = trackerNumber - 1 ; \n0 < tnum ; \ntnum -- ) { \nFile oldDatabaseFile = new File ( pathname + datasetName + \".\" + tnum ) ; \nif ( ! oldDatabaseFile . exists ( ) ) break ; \nif ( oldDatabaseFile . delete ( ) ) { \ncatalogInitLog . info ( \"DatasetTrackerChronicle deleted {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \nelse { \ncatalogInitLog . error ( \"DatasetTrackerChronicle not able to delete {} \" , oldDatabaseFile . getAbsolutePath ( ) ) ; \n} \n} \n} \n} \n"}
{"5288": "public class McIDASAreaProjection { \nprivate double [ ] makeDoubleArray ( int [ ] ints ) { \ndouble [ ] newArray = new double [ ints . length ] ; \nfor ( int i = 0 ; \nints . length > i ; \ni ++ ) { \nnewArray [ i ] = ints [ i ] ; \n} \nreturn newArray ; \n} \n} \n"}
{"5293": "public class GridIndexToNC { \nprivate void makeVerticalDimensions ( List < GridVertCoord > vertCoordList , NetcdfFile ncfile , Group group ) { \nGridVertCoord gvcs0 = null ; \nint maxLevels = 0 ; \nfor ( GridVertCoord gvcs : vertCoordList ) { \nif ( maxLevels < gvcs . getNLevels ( ) ) { \ngvcs0 = gvcs ; \nmaxLevels = gvcs . getNLevels ( ) ; \n} \n} \nint seqno = 1 ; \nfor ( GridVertCoord gvcs : vertCoordList ) { \nif ( gvcs != gvcs0 ) { \ngvcs . setSequence ( seqno ++ ) ; \n} \ngvcs . addDimensionsToNetcdfFile ( ncfile , group ) ; \n} \n} \n} \n"}
{"5302": "public class InvDatasetImpl { \npublic boolean replaceDataset ( InvDatasetImpl remove , InvDatasetImpl add ) { \nfor ( int i = 0 ; \ndatasets . size ( ) > i ; \ni ++ ) { \nInvDataset dataset = datasets . get ( i ) ; \nif ( dataset . equals ( remove ) ) { \ndatasets . set ( i , add ) ; \nInvCatalogImpl cat = ( InvCatalogImpl ) getParentCatalog ( ) ; \nif ( cat != null ) { \ncat . removeDatasetByID ( remove ) ; \ncat . addDatasetByID ( add ) ; \n} \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5308": "public class DatasetNamer { \nboolean validate ( StringBuilder out ) { \nthis . isValid = true ; \nif ( 0 < this . msgLog . length ( ) ) { \nout . append ( this . msgLog ) ; \n} \nif ( this . getName ( ) == null ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (1): null value for name is not valid.\" ) ; \n} \nif ( this . getType ( ) == null ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (3): null value for type is not valid (set with bad string?).\" ) ; \n} \nif ( this . getType ( ) == DatasetNamerType . REGULAR_EXPRESSION && ( this . getMatchPattern ( ) == null || this . getSubstitutePattern ( ) == null ) ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (4): invalid datasetNamer <\" + this . getName ( ) + \">;\" + \" type is \" + this . getType ( ) . toString ( ) + \": matchPattern(\" + this . getMatchPattern ( ) + \") and substitutionPattern(\" + this . getSubstitutePattern ( ) + \") \" + \"must not be null.\" ) ; \n} \nif ( this . getType ( ) == DatasetNamerType . DODS_ATTRIBUTE && ( this . getAttribContainer ( ) == null || this . getAttribName ( ) == null ) ) { \nthis . isValid = false ; \nout . append ( \" ** DatasetNamer (5): invalid datasetNamer <\" + this . getName ( ) + \">;\" + \" type is \" + this . getType ( ) . toString ( ) + \": attriuteContainer(\" + this . getAttribContainer ( ) + \") and attributeName(\" + this . getAttribName ( ) + \") must not be null.\" ) ; \n} \nreturn ( this . isValid ) ; \n} \n} \n"}
{"5313": "public class WFSController { \nprivate WFSExceptionWriter checkParametersForError ( String request , String version , String service , String typeName ) { \nif ( service != null ) { \nif ( ! service . equalsIgnoreCase ( \"WFS\" ) ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. SERVICE parameter must be of value WFS.\" , \"service\" , \"InvalidParameterValue\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. SERVICE parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( request != null ) { \nif ( ! request . equalsIgnoreCase ( WFSRequestType . GetCapabilities . toString ( ) ) ) { \nif ( version != null ) { \nString [ ] versionParts = version . split ( \"\\\\.\" ) ; \nfor ( int ind = 0 ; \nversionParts . length > ind ; \nind ++ ) { \ntry { \nInteger . valueOf ( versionParts [ ind ] ) ; \n} \ncatch ( NumberFormatException excep ) { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter consists of invalid characters.\" , \"version\" , \"InvalidParameterValue\" ) ; \n} \n} \nboolean validVersion = false ; \nif ( versionParts . length == 1 ) if ( versionParts [ 0 ] . equals ( \"2\" ) ) validVersion = true ; \nif ( 2 <= versionParts . length ) if ( versionParts [ 0 ] . equals ( \"2\" ) && versionParts [ 1 ] . equals ( \"0\" ) ) validVersion = true ; \nif ( ! validVersion ) { \nreturn new WFSExceptionWriter ( \"WFS Server error. Version requested is not supported.\" , null , \"VersionNegotiationFailed\" ) ; \n} \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. VERSION parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nif ( typeName == null ) { \nreturn new WFSExceptionWriter ( \"WFS server error. For the specifed request, parameter typename or typenames must be specified.\" , request , \"MissingParameterValue\" ) ; \n} \n} \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nif ( reqToProc == null ) return new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is not valid. Possible values: GetCapabilities, \" + \"DescribeFeatureType, GetFeature\" , \"request\" , \"InvalidParameterValue\" ) ; \n} \nelse { \nreturn new WFSExceptionWriter ( \"WFS server error. REQUEST parameter is required.\" , \"request\" , \"MissingParameterValue\" ) ; \n} \nreturn null ; \n} \n} \n"}
{"5314": "public class WFSController { \n@ RequestMapping ( \"**\" ) public void httpHandler ( HttpServletRequest hsreq , HttpServletResponse hsres ) { \ntry { \nPrintWriter wr = hsres . getWriter ( ) ; \nList < String > paramNames = new LinkedList < String > ( ) ; \nEnumeration < String > paramNamesE = hsreq . getParameterNames ( ) ; \nwhile ( paramNamesE . hasMoreElements ( ) ) paramNames . add ( paramNamesE . nextElement ( ) ) ; \nString request = null ; \nString version = null ; \nString service = null ; \nString typeNames = null ; \nString datasetReqPath = null ; \nString actualPath = null ; \nString actualFTName = null ; \nNetcdfDataset dataset = null ; \nif ( 4 < hsreq . getServletPath ( ) . length ( ) ) { \ndatasetReqPath = hsreq . getServletPath ( ) . substring ( 4 , hsreq . getServletPath ( ) . length ( ) ) ; \n} \nactualPath = TdsRequestedDataset . getLocationFromRequestPath ( datasetReqPath ) ; \nif ( actualPath != null ) dataset = NetcdfDataset . openDataset ( actualPath ) ; \nelse return ; \nList < CoordinateSystem > csList = dataset . getCoordinateSystems ( ) ; \nSimpleGeometryCSBuilder cs = new SimpleGeometryCSBuilder ( dataset , csList . get ( 0 ) , null ) ; \nfor ( String paramName : paramNames ) { \nif ( paramName . equalsIgnoreCase ( \"REQUEST\" ) ) { \nrequest = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"VERSION\" ) ) { \nversion = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"SERVICE\" ) ) { \nservice = hsreq . getParameter ( paramName ) ; \n} \nif ( paramName . equalsIgnoreCase ( \"TYPENAMES\" ) || paramName . equalsIgnoreCase ( \"TYPENAME\" ) ) { \ntypeNames = hsreq . getParameter ( paramName ) ; \nif ( typeNames != null ) if ( TDSNAMESPACE . length ( ) < typeNames . length ( ) ) { \nactualFTName = typeNames . substring ( TDSNAMESPACE . length ( ) + 1 , typeNames . length ( ) ) ; \n} \n} \n} \nWFSExceptionWriter paramError = checkParametersForError ( request , version , service , typeNames ) ; \nWFSExceptionWriter requestProcessingError = null ; \nif ( paramError == null ) { \nWFSRequestType reqToProc = WFSRequestType . getWFSRequestType ( request ) ; \nswitch ( reqToProc ) { \ncase GetCapabilities : getCapabilities ( wr , hsreq , cs ) ; \nbreak ; \ncase DescribeFeatureType : describeFeatureType ( wr , hsreq , actualFTName ) ; \nbreak ; \ncase GetFeature : requestProcessingError = getFeature ( wr , hsreq , cs , actualFTName , typeNames ) ; \nbreak ; \n} \n} \nelse { \nparamError . write ( hsres ) ; \nreturn ; \n} \nif ( requestProcessingError != null ) { \nrequestProcessingError . write ( hsres ) ; \nreturn ; \n} \n} \ncatch ( IOException io ) { \nthrow new RuntimeException ( \"The writer may not have been able to been have retrieved\" + \" or the requested dataset was not found\" , io ) ; \n} \n} \n} \n"}
{"5330": "public class BitCounterUncompressed { \nint countBits ( int startBit ) { \ncountBits = replicationCountSize ; \nthis . startBit = new int [ nrows ] ; \nfor ( int i = 0 ; \nnrows > i ; \ni ++ ) { \nthis . startBit [ i ] = startBit + countBits ; \nif ( debug ) System . out . println ( \" BitCounterUncompressed row \" + i + \" startBit=\" + this . startBit [ i ] ) ; \nfor ( DataDescriptor nd : parent . subKeys ) { \nBitCounterUncompressed [ ] bitCounter = ( subCounters == null ) ? null : subCounters . get ( nd ) ; \nif ( bitCounter == null ) countBits += nd . getBitWidth ( ) ; \nelse { \nif ( debug ) System . out . println ( \" ---------> nested \" + nd . getFxyName ( ) + \" starts at =\" + ( startBit + countBits ) ) ; \ncountBits += bitCounter [ i ] . countBits ( startBit + countBits ) ; \nif ( debug ) System . out . println ( \" <--------- nested \" + nd . getFxyName ( ) + \" ends at =\" + ( startBit + countBits ) ) ; \n} \n} \n} \nreturn countBits ; \n} \n} \n"}
{"5331": "public class TextHistoryPane { \npublic void appendLine ( String line ) { \nif ( nlines <= count ) { \ntry { \nint remove = Math . max ( removeIncr , count - nlines ) ; \nint offset = ta . getLineEndOffset ( remove ) ; \nta . replaceRange ( \"\" , 0 , offset ) ; \n} \ncatch ( Exception e ) { \nlog . error ( \"Problem in TextHistoryPane\" , e ) ; \n} \ncount = nlines - removeIncr ; \n} \nta . append ( line ) ; \nta . append ( \"\\n\" ) ; \ncount ++ ; \nta . setCaretPosition ( ta . getText ( ) . length ( ) ) ; \n} \n} \n"}
{"5332": "public class FeatureDatasetCapabilitiesWriter { \npublic Document makeStationCollectionDocument ( LatLonRect bb , String [ ] names ) throws IOException { \nList < DsgFeatureCollection > list = fdp . getPointFeatureCollectionList ( ) ; \nDsgFeatureCollection fc = list . get ( 0 ) ; \nif ( ! ( fc instanceof StationTimeSeriesFeatureCollection ) ) { \nthrow new UnsupportedOperationException ( fc . getClass ( ) . getName ( ) + \" not a StationTimeSeriesFeatureCollection\" ) ; \n} \nStationTimeSeriesFeatureCollection sobs = ( StationTimeSeriesFeatureCollection ) fc ; \nElement rootElem = new Element ( \"stationCollection\" ) ; \nDocument doc = new Document ( rootElem ) ; \nList < StationFeature > stations ; \nif ( bb != null ) stations = sobs . getStationFeatures ( bb ) ; \nelse if ( names != null ) stations = sobs . getStationFeatures ( Arrays . asList ( names ) ) ; \nelse stations = sobs . getStationFeatures ( ) ; \nfor ( Station s : stations ) { \nElement sElem = new Element ( \"station\" ) ; \nsElem . setAttribute ( \"name\" , s . getName ( ) ) ; \nif ( s . getWmoId ( ) != null ) sElem . setAttribute ( \"wmo_id\" , s . getWmoId ( ) ) ; \nif ( ( s . getDescription ( ) != null ) && ( 0 < s . getDescription ( ) . length ( ) ) ) sElem . addContent ( new Element ( \"description\" ) . addContent ( s . getDescription ( ) ) ) ; \nsElem . addContent ( new Element ( \"longitude\" ) . addContent ( Double . toString ( s . getLongitude ( ) ) ) ) ; \nsElem . addContent ( new Element ( \"latitide\" ) . addContent ( Double . toString ( s . getLatitude ( ) ) ) ) ; \nif ( ! Double . isNaN ( s . getAltitude ( ) ) ) sElem . addContent ( new Element ( \"altitude\" ) . addContent ( Double . toString ( s . getAltitude ( ) ) ) ) ; \nrootElem . addContent ( sElem ) ; \n} \nreturn doc ; \n} \n} \n"}
{"5334": "public class VariableIndex { \n@ Nullable synchronized Record getRecordAt ( SubsetParams coords ) { \nint [ ] want = new int [ getRank ( ) ] ; \nint count = 0 ; \nint runIdx = - 1 ; \nfor ( Coordinate coord : getCoordinates ( ) ) { \nint idx = - 1 ; \nswitch ( coord . getType ( ) ) { \ncase runtime : CalendarDate runtimeCooord = coords . getRunTime ( ) ; \nidx = coord . getIndex ( runtimeCooord ) ; \nrunIdx = idx ; \nbreak ; \ncase timeIntv : double [ ] timeIntv = coords . getTimeOffsetIntv ( ) ; \nidx = coord . getIndex ( new TimeCoordIntvValue ( ( int ) timeIntv [ 0 ] , ( int ) timeIntv [ 1 ] ) ) ; \nbreak ; \ncase time : Double timeOffset = coords . getTimeOffset ( ) ; \nint coordInt = timeOffset . intValue ( ) ; \nidx = coord . getIndex ( coordInt ) ; \nbreak ; \ncase time2D : timeIntv = coords . getTimeOffsetIntv ( ) ; \nif ( timeIntv != null ) { \nTimeCoordIntvValue coordTinv = new TimeCoordIntvValue ( ( int ) timeIntv [ 0 ] , ( int ) timeIntv [ 1 ] ) ; \nidx = ( ( CoordinateTime2D ) coord ) . findTimeIndexFromVal ( runIdx , coordTinv ) ; \nbreak ; \n} \nDouble timeCoord = coords . getTimeOffset ( ) ; \nif ( timeCoord != null ) { \ncoordInt = timeCoord . intValue ( ) ; \nidx = ( ( CoordinateTime2D ) coord ) . findTimeIndexFromVal ( runIdx , coordInt ) ; \nbreak ; \n} \nCoordinateTime2D coord2D = ( CoordinateTime2D ) coord ; \nif ( coord2D . getNtimes ( ) == 1 ) { \nidx = 0 ; \nbreak ; \n} \nthrow new IllegalStateException ( \"time2D must have timeOffset ot timeOffsetIntv coordinare\" ) ; \ncase vert : double [ ] vertIntv = coords . getVertCoordIntv ( ) ; \nif ( vertIntv != null ) { \nVertCoordValue coordVert = new VertCoordValue ( vertIntv [ 0 ] , vertIntv [ 1 ] ) ; \nidx = coord . getIndex ( coordVert ) ; \nbreak ; \n} \nDouble vertCoord = coords . getVertCoord ( ) ; \nif ( vertCoord != null ) { \nVertCoordValue coordVert = new VertCoordValue ( vertCoord ) ; \nidx = coord . getIndex ( coordVert ) ; \n} \nbreak ; \ncase ens : Double ensVal = coords . getEnsCoord ( ) ; \nidx = ( ( CoordinateEns ) coord ) . getIndexByMember ( ensVal ) ; \nbreak ; \ndefault : logger . warn ( \"GribCollectionImmutable: missing CoordVal for {}%n\" , coord . getName ( ) ) ; \n} \nif ( 0 > idx ) { \nlogger . debug ( \"Cant find index for value in axis {} in variable {}\" , coord . getName ( ) , name ) ; \nreturn null ; \n} \nwant [ count ++ ] = idx ; \n} \nreturn sa . getContent ( want ) ; \n} \n} \n"}
{"5336": "public class ComboBox { \npublic void addItem ( Object item ) { \nif ( item == null ) return ; \nfor ( int i = 0 ; \ngetItemCount ( ) > i ; \ni ++ ) { \nif ( item . equals ( getItemAt ( i ) ) ) { \nif ( i == 0 ) { \nsetSelectedIndex ( 0 ) ; \nreturn ; \n} \nremoveItemAt ( i ) ; \n} \n} \ninsertItemAt ( item , 0 ) ; \nsetSelectedIndex ( 0 ) ; \n} \n} \n"}
{"5338": "public class Odometer { \npublic Slice slice ( int i ) { \nif ( 0 > i || this . rank <= i ) throw new IllegalArgumentException ( ) ; \nreturn this . slices . get ( i ) ; \n} \n} \n"}
{"5339": "public class Odometer { \npublic int step ( int firstpos , int lastpos ) { \nfor ( int i = lastpos - 1 ; \nfirstpos <= i ; \ni -- ) { \nif ( this . endpoint [ i ] < this . index . indices [ i ] ) this . index . indices [ i ] = this . slices . get ( i ) . getFirst ( ) ; \nelse { \nthis . index . indices [ i ] += this . slices . get ( i ) . getStride ( ) ; \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"5344": "public class IO { \nstatic public long copyB ( InputStream in , OutputStream out , int bufferSize ) throws IOException { \nlong totalBytesRead = 0 ; \nint done = 0 , next = 1 ; \nbyte [ ] buffer = new byte [ bufferSize ] ; \nwhile ( true ) { \nint n = in . read ( buffer ) ; \nif ( n == - 1 ) break ; \nout . write ( buffer , 0 , n ) ; \ntotalBytesRead += n ; \nif ( showCopy ) { \ndone += n ; \nif ( 1000 * 1000 * next < done ) { \nSystem . out . println ( next + \" Mb\" ) ; \nnext ++ ; \n} \n} \n} \nout . flush ( ) ; \nreturn totalBytesRead ; \n} \n} \n"}
{"5349": "public class IO { \nstatic public long copyRafB ( ucar . unidata . io . RandomAccessFile raf , long offset , long length , OutputStream out , byte [ ] buffer ) throws IOException { \nint bufferSize = buffer . length ; \nlong want = length ; \nraf . seek ( offset ) ; \nwhile ( 0 < want ) { \nint len = ( int ) Math . min ( want , bufferSize ) ; \nint bytesRead = raf . read ( buffer , 0 , len ) ; \nif ( 0 >= bytesRead ) break ; \nout . write ( buffer , 0 , bytesRead ) ; \nwant -= bytesRead ; \n} \nout . flush ( ) ; \nreturn length - want ; \n} \n} \n"}
{"5361": "public class DTSServlet { \nprotected void printStatus ( PrintWriter os ) { \nos . println ( \"<h2>Server version = \" + getServerVersion ( ) + \"</h2>\" ) ; \nos . println ( \"<h2>Number of Requests Received = \" + HitCounter + \"</h2>\" ) ; \nif ( track ) { \nint n = prArr . size ( ) ; \nint pending = 0 ; \nStringBuilder preqs = new StringBuilder ( ) ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nReqState rs = ( ReqState ) prArr . get ( i ) ; \nRequestDebug reqD = ( RequestDebug ) rs . getUserObject ( ) ; \nif ( ! reqD . done ) { \npreqs . append ( \"<pre>-----------------------\\n\" ) ; \npreqs . append ( \"Request[\" ) ; \npreqs . append ( reqD . reqno ) ; \npreqs . append ( \"](\" ) ; \npreqs . append ( reqD . threadDesc ) ; \npreqs . append ( \") is pending.\\n\" ) ; \npreqs . append ( rs . toString ( ) ) ; \npreqs . append ( \"</pre>\" ) ; \npending ++ ; \n} \n} \nos . println ( \"<h2>\" + pending + \" Pending Request(s)</h2>\" ) ; \nos . println ( preqs . toString ( ) ) ; \n} \n} \n} \n"}
{"5364": "public class NcStreamIosp { \nprivate Array readVlenData ( Variable v , Section section , DataStorage dataStorage ) throws IOException , InvalidRangeException { \nraf . seek ( dataStorage . filePos ) ; \nint nelems = readVInt ( raf ) ; \nArray [ ] result = new Array [ nelems ] ; \nfor ( int elem = 0 ; \nnelems > elem ; \nelem ++ ) { \nint dsize = readVInt ( raf ) ; \nbyte [ ] data = new byte [ dsize ] ; \nraf . readFully ( data ) ; \nArray dataArray = Array . factory ( v . getDataType ( ) , ( int [ ] ) null , ByteBuffer . wrap ( data ) ) ; \nresult [ elem ] = dataArray ; \n} \nreturn Array . makeVlenArray ( new int [ ] { \nnelems } \n, result ) ; \n} \n} \n"}
{"5367": "public class StringUtil2 { \nstatic public String allow ( String x , String allowChars , char replaceChar ) { \nboolean ok = true ; \nfor ( int pos = 0 ; \nx . length ( ) > pos ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( allowChars . indexOf ( c ) >= 0 ) ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int pos = 0 ; \nsb . length ( ) > pos ; \npos ++ ) { \nchar c = sb . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) || ( allowChars . indexOf ( c ) >= 0 ) ) { \ncontinue ; \n} \nsb . setCharAt ( pos , replaceChar ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5368": "public class StringUtil2 { \npublic static String cleanup ( byte [ ] h ) { \nbyte [ ] bb = new byte [ h . length ] ; \nint count = 0 ; \nfor ( byte b : h ) { \nif ( 32 <= b && 127 > b ) bb [ count ++ ] = b ; \n} \nreturn new String ( bb , 0 , count , CDM . utf8Charset ) ; \n} \n} \n"}
{"5369": "public class StringUtil2 { \nstatic public String filter ( String x , String okChars ) { \nboolean ok = true ; \nfor ( int pos = 0 ; \nx . length ( ) > pos ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( ! ( Character . isLetterOrDigit ( c ) || ( okChars . indexOf ( c ) >= 0 ) ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) { \nreturn x ; \n} \nStringBuilder sb = new StringBuilder ( x . length ( ) ) ; \nfor ( int pos = 0 ; \nx . length ( ) > pos ; \npos ++ ) { \nchar c = x . charAt ( pos ) ; \nif ( Character . isLetterOrDigit ( c ) || ( okChars . indexOf ( c ) >= 0 ) ) { \nsb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5370": "public class StringUtil2 { \nstatic public String filter7bits ( String s ) { \nif ( s == null ) return null ; \nchar [ ] bo = new char [ s . length ( ) ] ; \nint count = 0 ; \nfor ( int i = 0 ; \ns . length ( ) > i ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ( 128 > c ) && ( 31 < c ) || ( ( c == '\\n' ) || ( c == '\\t' ) ) ) { \nbo [ count ++ ] = c ; \n} \n} \nreturn new String ( bo , 0 , count ) ; \n} \n} \n"}
{"5371": "public class StringUtil2 { \nstatic public String makeValidCdmObjectName ( String name ) { \nname = name . trim ( ) ; \nboolean ok = true ; \nfor ( int i = 0 ; \nname . length ( ) > i ; \ni ++ ) { \nint c = name . charAt ( i ) ; \nif ( 0x20 > c ) ok = false ; \nif ( c == '/' ) ok = false ; \nif ( c == ' ' ) ok = false ; \nif ( ! ok ) break ; \n} \nif ( ok ) return name ; \nStringBuilder sbuff = new StringBuilder ( name . length ( ) ) ; \nfor ( int i = 0 , len = name . length ( ) ; \nlen > i ; \ni ++ ) { \nint c = name . charAt ( i ) ; \nif ( ( c == '/' ) || ( c == ' ' ) ) sbuff . append ( '_' ) ; \nelse if ( 0x20 <= c ) sbuff . append ( ( char ) c ) ; \n} \nreturn sbuff . toString ( ) ; \n} \n} \n"}
{"5372": "public class StringUtil2 { \nstatic public int match ( String s1 , String s2 ) { \nint i = 0 ; \nwhile ( ( s1 . length ( ) > i ) && ( s2 . length ( ) > i ) ) { \nif ( s1 . charAt ( i ) != s2 . charAt ( i ) ) { \nbreak ; \n} \ni ++ ; \n} \nreturn i ; \n} \n} \n"}
{"5373": "public class StringUtil2 { \npublic static String padLeft ( String s , int desiredLength , String padString ) { \nwhile ( desiredLength > s . length ( ) ) { \ns = padString + s ; \n} \nreturn s ; \n} \n} \n"}
{"5374": "public class StringUtil2 { \npublic static String padRight ( String s , int desiredLength , String padString ) { \nStringBuilder ret = new StringBuilder ( s ) ; \nwhile ( desiredLength > ret . length ( ) ) { \nret . append ( padString ) ; \n} \nreturn ret . toString ( ) ; \n} \n} \n"}
{"5375": "public class StringUtil2 { \nstatic public String remove ( String s , String sub ) { \nint len = sub . length ( ) ; \nint pos ; \nwhile ( ( pos = s . indexOf ( sub ) ) >= 0 ) { \ns = s . substring ( 0 , pos ) + s . substring ( pos + len ) ; \n} \nreturn s ; \n} \n} \n"}
{"5376": "public class StringUtil2 { \nstatic public String remove ( String s , int c ) { \nif ( s . indexOf ( c ) < 0 ) { \nreturn s ; \n} \nStringBuilder buff = new StringBuilder ( s ) ; \nint i = 0 ; \nwhile ( buff . length ( ) > i ) { \nif ( buff . charAt ( i ) == c ) { \nbuff . deleteCharAt ( i ) ; \n} \nelse { \ni ++ ; \n} \n} \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5377": "public class StringUtil2 { \nstatic public String removeFromEnd ( String s , int c ) { \nif ( s . indexOf ( c ) < 0 ) return s ; \nint len = s . length ( ) ; \nwhile ( ( s . charAt ( len - 1 ) == c ) && ( 0 < len ) ) len -- ; \nif ( len == s . length ( ) ) return s ; \nreturn s . substring ( 0 , len ) ; \n} \n} \n"}
{"5378": "public class StringUtil2 { \nstatic public String collapseWhitespace ( String s ) { \nint len = s . length ( ) ; \nStringBuilder b = new StringBuilder ( len ) ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( ! Character . isWhitespace ( c ) ) { \nb . append ( c ) ; \n} \nelse { \nb . append ( ' ' ) ; \nwhile ( ( len > i + 1 ) && Character . isWhitespace ( s . charAt ( i + 1 ) ) ) { \ni ++ ; \n} \n} \n} \nreturn b . toString ( ) ; \n} \n} \n"}
{"5379": "public class StringUtil2 { \nstatic public String replace ( String s , char out , String in ) { \nif ( 0 > s . indexOf ( out ) ) { \nreturn s ; \n} \nStringBuilder sb = new StringBuilder ( s ) ; \nreplace ( sb , out , in ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5380": "public class StringUtil2 { \nstatic public String replace ( String x , char [ ] replaceChar , String [ ] replaceWith ) { \nboolean ok = true ; \nfor ( char aReplaceChar : replaceChar ) { \nint pos = x . indexOf ( aReplaceChar ) ; \nok = ( 0 > pos ) ; \nif ( ! ok ) break ; \n} \nif ( ok ) return x ; \nStringBuilder sb = new StringBuilder ( x ) ; \nfor ( int i = 0 ; \nreplaceChar . length > i ; \ni ++ ) { \nint pos = x . indexOf ( replaceChar [ i ] ) ; \nif ( 0 <= pos ) { \nreplace ( sb , replaceChar [ i ] , replaceWith [ i ] ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5381": "public class StringUtil2 { \npublic static String replace ( String string , String pattern , String value ) { \nif ( pattern . length ( ) == 0 ) return string ; \nif ( ! string . contains ( pattern ) ) return string ; \nStringBuilder returnValue = new StringBuilder ( ) ; \nint patternLength = pattern . length ( ) ; \nwhile ( true ) { \nint idx = string . indexOf ( pattern ) ; \nif ( 0 > idx ) break ; \nreturnValue . append ( string . substring ( 0 , idx ) ) ; \nif ( value != null ) returnValue . append ( value ) ; \nstring = string . substring ( idx + patternLength ) ; \n} \nreturnValue . append ( string ) ; \nreturn returnValue . toString ( ) ; \n} \n} \n"}
{"5382": "public class StringUtil2 { \nstatic public String substitute ( String original , String match , String subst ) { \nString s = original ; \nint pos ; \nwhile ( ( pos = s . indexOf ( match ) ) >= 0 ) { \nStringBuilder sb = new StringBuilder ( s ) ; \ns = sb . replace ( pos , pos + match . length ( ) , subst ) . toString ( ) ; \n} \nreturn s ; \n} \n} \n"}
{"5383": "public class StringUtil2 { \nstatic public String substitute ( String original , String [ ] match , String [ ] subst ) { \nboolean ok = true ; \nfor ( String aMatch : match ) { \nif ( original . contains ( aMatch ) ) { \nok = false ; \nbreak ; \n} \n} \nif ( ok ) { \nreturn original ; \n} \nStringBuilder sb = new StringBuilder ( original ) ; \nfor ( int i = 0 ; \nmatch . length > i ; \ni ++ ) { \nsubstitute ( sb , match [ i ] , subst [ i ] ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"5384": "public class StringUtil2 { \nstatic public void remove ( StringBuilder sb , String out ) { \nint i = 0 ; \nwhile ( sb . length ( ) > i ) { \nint c = sb . charAt ( i ) ; \nboolean ok = true ; \nfor ( int j = 0 ; \nout . length ( ) > j ; \nj ++ ) { \nif ( out . charAt ( j ) == c ) { \nsb . delete ( i , i + 1 ) ; \nok = false ; \nbreak ; \n} \n} \nif ( ok ) i ++ ; \n} \n} \n} \n"}
{"5385": "public class StringUtil2 { \nstatic public void unreplace ( StringBuilder sb , String out , char in ) { \nint pos ; \nwhile ( ( pos = sb . indexOf ( out ) ) >= 0 ) { \nsb . setCharAt ( pos , in ) ; \nsb . delete ( pos + 1 , pos + out . length ( ) ) ; \n} \n} \n} \n"}
{"5386": "public class StringUtil2 { \nstatic public void replace ( StringBuilder sb , String out , String in ) { \nfor ( int i = 0 ; \nsb . length ( ) > i ; \ni ++ ) { \nint c = sb . charAt ( i ) ; \nfor ( int j = 0 ; \nout . length ( ) > j ; \nj ++ ) { \nif ( out . charAt ( j ) == c ) sb . setCharAt ( i , in . charAt ( j ) ) ; \n} \n} \n} \n} \n"}
{"5387": "public class StringUtil2 { \nstatic public void substitute ( StringBuilder sbuff , String match , String subst ) { \nint pos , fromIndex = 0 ; \nint substLen = subst . length ( ) ; \nint matchLen = match . length ( ) ; \nwhile ( ( pos = sbuff . indexOf ( match , fromIndex ) ) >= 0 ) { \nsbuff . replace ( pos , pos + matchLen , subst ) ; \nfromIndex = pos + substLen ; \n} \n} \n} \n"}
{"5388": "public class StringUtil2 { \nstatic public String trim ( String s , int bad ) { \nint len = s . length ( ) ; \nint st = 0 ; \nwhile ( ( len > st ) && ( s . charAt ( st ) == bad ) ) { \nst ++ ; \n} \nwhile ( ( len > st ) && ( s . charAt ( len - 1 ) == bad ) ) { \nlen -- ; \n} \nreturn ( ( 0 < st ) || ( s . length ( ) > len ) ) ? s . substring ( st , len ) : s ; \n} \n} \n"}
{"5401": "public class CoordinateAxis1D { \npublic CoordinateAxis1D section ( Range r ) throws InvalidRangeException { \nSection section = new Section ( ) . appendRange ( r ) ; \nCoordinateAxis1D result = ( CoordinateAxis1D ) section ( section ) ; \nint len = r . length ( ) ; \nif ( isNumeric ( ) ) { \ndouble [ ] new_mids = new double [ len ] ; \nfor ( int idx = 0 ; \nlen > idx ; \nidx ++ ) { \nint old_idx = r . element ( idx ) ; \nnew_mids [ idx ] = coords [ old_idx ] ; \n} \nresult . coords = new_mids ; \nif ( isInterval ) { \ndouble [ ] new_bound1 = new double [ len ] ; \ndouble [ ] new_bound2 = new double [ len ] ; \ndouble [ ] new_edge = new double [ len + 1 ] ; \nfor ( int idx = 0 ; \nlen > idx ; \nidx ++ ) { \nint old_idx = r . element ( idx ) ; \nnew_bound1 [ idx ] = bound1 [ old_idx ] ; \nnew_bound2 [ idx ] = bound2 [ old_idx ] ; \nnew_edge [ idx ] = bound1 [ old_idx ] ; \nnew_edge [ idx + 1 ] = bound2 [ old_idx ] ; \n} \nresult . bound1 = new_bound1 ; \nresult . bound2 = new_bound2 ; \nresult . edge = new_edge ; \n} \nelse { \ndouble [ ] new_edge = new double [ len + 1 ] ; \nfor ( int idx = 0 ; \nlen > idx ; \nidx ++ ) { \nint old_idx = r . element ( idx ) ; \nnew_edge [ idx ] = edge [ old_idx ] ; \nnew_edge [ idx + 1 ] = edge [ old_idx + 1 ] ; \n} \nresult . edge = new_edge ; \n} \n} \nif ( names != null ) { \nString [ ] new_names = new String [ len ] ; \nfor ( int idx = 0 ; \nlen > idx ; \nidx ++ ) { \nint old_idx = r . element ( idx ) ; \nnew_names [ idx ] = names [ old_idx ] ; \n} \nresult . names = new_names ; \n} \nresult . wasCalcRegular = false ; \nresult . calcIsRegular ( ) ; \nreturn result ; \n} \n} \n"}
{"5406": "public class GradsUtil { \npublic static double [ ] getGaussianLatitudes ( String type , int start , int num ) throws IllegalArgumentException { \ndouble [ ] baseArray = null ; \nstart -- ; \nif ( type . equalsIgnoreCase ( GAUST62 ) ) { \nbaseArray = gltst62 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR15 ) ) { \nbaseArray = glts15 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR20 ) ) { \nbaseArray = glts20 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR30 ) ) { \nbaseArray = glts30 ; \n} \nelse if ( type . equalsIgnoreCase ( GAUSR40 ) ) { \nbaseArray = glats ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Unsupported type: \" + type ) ; \n} \nif ( baseArray . length < start + num ) { \nthrow new IllegalArgumentException ( \"Maximum \" + baseArray . length + \" latitudes exceeded\" ) ; \n} \ndouble [ ] retVals = new double [ num ] ; \nfor ( int i = 0 ; \nnum > i ; \ni ++ ) { \nretVals [ i ] = baseArray [ start + i ] ; \n} \nreturn retVals ; \n} \n} \n"}
{"5407": "public class Swap { \nstatic public long swapLong ( byte [ ] b , int offset ) { \nlong accum = 0 ; \nlong shiftedval ; \nfor ( int shiftBy = 0 , i = offset ; \n64 > shiftBy ; \nshiftBy += 8 , i ++ ) { \nshiftedval = ( ( long ) ( b [ i ] & 0xff ) ) << shiftBy ; \naccum |= shiftedval ; \n} \nreturn accum ; \n} \n} \n"}
{"5408": "public class Swap { \nstatic public float swapFloat ( byte [ ] b , int offset ) { \nint accum = 0 ; \nfor ( int shiftBy = 0 , i = offset ; \n32 > shiftBy ; \nshiftBy += 8 , i ++ ) accum |= ( b [ i ] & 0xff ) << shiftBy ; \nreturn Float . intBitsToFloat ( accum ) ; \n} \n} \n"}
{"5420": "public class Group { \npublic boolean removeDimension ( String dimName ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nfor ( int i = 0 ; \ndimensions . size ( ) > i ; \ni ++ ) { \nDimension d = dimensions . get ( i ) ; \nif ( dimName . equals ( d . getShortName ( ) ) ) { \ndimensions . remove ( d ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5425": "public class GeotiffWriter { \npublic void writeGrid ( GridDataset dataset , GridDatatype grid , Array data , boolean greyScale ) throws IOException { \nGridCoordSystem gcs = grid . getCoordinateSystem ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) { \nthrow new IllegalArgumentException ( \"Must have 1D x and y axes for \" + grid . getFullName ( ) ) ; \n} \nCoordinateAxis1D xaxis = ( CoordinateAxis1D ) gcs . getXHorizAxis ( ) ; \nCoordinateAxis1D yaxis = ( CoordinateAxis1D ) gcs . getYHorizAxis ( ) ; \ndouble scaler = ( xaxis . getUnitsString ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge ( 0 ) * scaler ; \ndouble xInc = xaxis . getIncrement ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getIncrement ( ) ) * scaler ; \nif ( yaxis . getCoordValue ( 1 ) > yaxis . getCoordValue ( 0 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdge ( ( int ) yaxis . getSize ( ) ) * scaler ; \n} \nif ( ! xaxis . isRegular ( ) || ! yaxis . isRegular ( ) ) { \nthrow new IllegalArgumentException ( \"Must be evenly spaced grid = \" + grid . getFullName ( ) ) ; \n} \nif ( 1 < pageNumber ) { \ngeotiff . initTags ( ) ; \n} \nwriteGrid ( grid , data , greyScale , xStart , yStart , xInc , yInc , pageNumber ) ; \npageNumber ++ ; \n} \n} \n"}
{"5428": "public class GeotiffWriter { \nprivate double geoShiftGetXstart ( Array lon , double inc ) { \nIndex ilon = lon . getIndex ( ) ; \nint [ ] lonShape = lon . getShape ( ) ; \nIndexIterator lonIter = lon . getIndexIterator ( ) ; \ndouble xlon = 0.0 ; \nLatLonPoint p0 = new LatLonPointImpl ( 0 , lon . getFloat ( ilon . set ( 0 ) ) ) ; \nLatLonPoint pN = new LatLonPointImpl ( 0 , lon . getFloat ( ilon . set ( lonShape [ 0 ] - 1 ) ) ) ; \nxlon = p0 . getLongitude ( ) ; \nwhile ( lonIter . hasNext ( ) ) { \nfloat l = lonIter . getFloatNext ( ) ; \nLatLonPoint pn = new LatLonPointImpl ( 0 , l ) ; \nif ( xlon > pn . getLongitude ( ) ) { \nxlon = pn . getLongitude ( ) ; \n} \n} \nif ( p0 . getLongitude ( ) == pN . getLongitude ( ) ) { \nxlon = xlon - inc ; \n} \nreturn xlon ; \n} \n} \n"}
{"5429": "public class GeotiffWriter { \npublic void writeGrid ( GeoReferencedArray array , boolean greyScale ) throws IOException { \nCoverageCoordSys gcs = array . getCoordSysForData ( ) ; \nif ( ! gcs . isRegularSpatial ( ) ) throw new IllegalArgumentException ( \"Must have 1D x and y axes for \" + array . getCoverageName ( ) ) ; \nProjection proj = gcs . getProjection ( ) ; \nCoverageCoordAxis1D xaxis = ( CoverageCoordAxis1D ) gcs . getXAxis ( ) ; \nCoverageCoordAxis1D yaxis = ( CoverageCoordAxis1D ) gcs . getYAxis ( ) ; \ndouble scaler = ( xaxis . getUnits ( ) . equalsIgnoreCase ( \"km\" ) ) ? 1000.0 : 1.0 ; \ndouble xStart = xaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble yStart = yaxis . getCoordEdge1 ( 0 ) * scaler ; \ndouble xInc = xaxis . getResolution ( ) * scaler ; \ndouble yInc = Math . abs ( yaxis . getResolution ( ) ) * scaler ; \nArray data = array . getData ( ) . reduce ( ) ; \nif ( yaxis . getCoordMidpoint ( 1 ) > yaxis . getCoordMidpoint ( 0 ) ) { \ndata = data . flip ( 0 ) ; \nyStart = yaxis . getCoordEdgeLast ( ) ; \n} \nif ( 1 < pageNumber ) { \ngeotiff . initTags ( ) ; \n} \nint nextStart = 0 ; \nMAMath . MinMax dataMinMax = MAMath . getMinMaxSkipMissingData ( data , array ) ; \nif ( greyScale ) { \nArrayByte result = replaceMissingValuesAndScale ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( byte [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nelse { \nArrayFloat result = replaceMissingValues ( array , data , dataMinMax ) ; \nnextStart = geotiff . writeData ( ( float [ ] ) result . getStorage ( ) , pageNumber ) ; \n} \nint height = data . getShape ( ) [ 0 ] ; \nint width = data . getShape ( ) [ 1 ] ; \nwriteMetadata ( greyScale , xStart , yStart , xInc , yInc , height , width , pageNumber , nextStart , dataMinMax , proj ) ; \npageNumber ++ ; \n} \n} \n"}
{"5439": "public class RC { \nstatic boolean urlMatch ( URL pattern , URL url ) { \nint relation ; \nif ( pattern == null ) return ( url == null ) ; \nif ( ! ( url . getHost ( ) . endsWith ( pattern . getHost ( ) ) ) ) return false ; \nif ( ! ( url . getPath ( ) . startsWith ( pattern . getPath ( ) ) ) ) return false ; \nif ( 0 < pattern . getPort ( ) && pattern . getPort ( ) != url . getPort ( ) ) return false ; \nreturn true ; \n} \n} \n"}
{"5443": "public class RC { \npublic boolean load ( String abspath ) { \nabspath = abspath . replace ( '\\\\' , '/' ) ; \nFile rcFile = new File ( abspath ) ; \nif ( ! rcFile . exists ( ) || ! rcFile . canRead ( ) ) { \nreturn false ; \n} \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \ntry ( BufferedReader rdr = new BufferedReader ( new InputStreamReader ( new FileInputStream ( rcFile ) , CDM . UTF8 ) ) ) { \nfor ( int lineno = 1 ; \n; \nlineno ++ ) { \nURL url = null ; \nString line = rdr . readLine ( ) ; \nif ( line == null ) break ; \nline = line . trim ( ) ; \nif ( line . length ( ) == 0 ) continue ; \nif ( line . charAt ( 0 ) == '#' ) continue ; \nif ( line . charAt ( 0 ) == LTAG ) { \nint rindex = line . indexOf ( RTAG ) ; \nif ( 0 > rindex ) return false ; \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \nString surl = line . substring ( 1 , rindex ) ; \ntry { \nurl = new URL ( surl ) ; \n} \ncatch ( MalformedURLException mue ) { \nif ( showlog ) log . error ( \"Malformed [url] at \" + abspath + \".\" + lineno ) ; \n} \nline = line . substring ( rindex + 1 ) ; \nline = line . trim ( ) ; \n} \nString [ ] pieces = line . split ( \"\\\\s*=\\\\s*\" ) ; \nassert ( pieces . length == 1 || pieces . length == 2 ) ; \nString value = \"1\" ; \nif ( pieces . length == 2 ) value = pieces [ 1 ] . trim ( ) ; \nTriple triple = new Triple ( pieces [ 0 ] . trim ( ) , value , url ) ; \nList < Triple > list = triplestore . get ( triple . key ) ; \nif ( list == null ) list = new ArrayList < Triple > ( ) ; \nTriple prev = addtriple ( list , triple ) ; \ntriplestore . put ( triple . key , list ) ; \n} \n} \ncatch ( FileNotFoundException fe ) { \nif ( showlog ) log . debug ( \"Loading rc file: \" + abspath ) ; \nreturn false ; \n} \ncatch ( IOException ioe ) { \nif ( showlog ) log . error ( \"File \" + abspath + \": IO exception: \" + ioe . getMessage ( ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"5448": "public class GisFeatureRendererMulti { \nprotected Iterator getShapes ( java . awt . Graphics2D g , AffineTransform normal2device ) { \nlong startTime = System . currentTimeMillis ( ) ; \nif ( featSetList == null ) { \ninitFeatSetList ( ) ; \nassert ! featSetList . isEmpty ( ) ; \n} \nFeatureSet fs = ( FeatureSet ) featSetList . get ( 0 ) ; \nif ( 1 < featSetList . size ( ) ) { \ndouble scale = 1.0 ; \ntry { \nAffineTransform world2device = g . getTransform ( ) ; \nAffineTransform world2normal = normal2device . createInverse ( ) ; \nworld2normal . concatenate ( world2device ) ; \nscale = Math . max ( Math . abs ( world2normal . getScaleX ( ) ) , Math . abs ( world2normal . getShearX ( ) ) ) ; \nif ( Debug . isSet ( \"GisFeature/showTransform\" ) ) { \nSystem . out . println ( \"GisFeature/showTransform: \" + world2normal + \"\\n scale = \" + scale ) ; \n} \n} \ncatch ( java . awt . geom . NoninvertibleTransformException e ) { \nSystem . out . println ( \" GisRenderFeature: NoninvertibleTransformException on \" + normal2device ) ; \n} \nif ( ! displayProject . isLatLon ( ) ) scale *= 111.0 ; \ndouble minD = Double . MAX_VALUE ; \nfor ( Object aFeatSetList : featSetList ) { \nFeatureSet tryfs = ( FeatureSet ) aFeatSetList ; \ndouble d = Math . abs ( scale * tryfs . minDist - pixelMatch ) ; \nif ( minD > d ) { \nminD = d ; \nfs = tryfs ; \n} \n} \nif ( Debug . isSet ( \"GisFeature/MapResolution\" ) ) { \nSystem . out . println ( \"GisFeature/MapResolution: scale = \" + scale + \" minDist = \" + fs . minDist ) ; \n} \n} \nif ( fs . featureList == null ) fs . createFeatures ( ) ; \nif ( ! displayProject . equals ( fs . project ) ) { \nfs . setProjection ( displayProject ) ; \n} \nelse { \nif ( fs . newProjection && displayProject . isLatLon ( ) ) { \nfs . setProjection ( displayProject ) ; \n} \n} \nfs . newProjection = false ; \nif ( Debug . isSet ( \"GisFeature/timing/getShapes\" ) ) { \nlong tookTime = System . currentTimeMillis ( ) - startTime ; \nSystem . out . println ( \"timing.getShapes: \" + tookTime * .001 + \" seconds\" ) ; \n} \nreturn fs . getShapes ( ) ; \n} \n} \n"}
{"5450": "public class PrefixName { \npublic final int compareTo ( String string ) { \nreturn string . length ( ) <= getID ( ) . length ( ) ? getID ( ) . compareToIgnoreCase ( string ) : getID ( ) . compareToIgnoreCase ( string . substring ( 0 , getID ( ) . length ( ) ) ) ; \n} \n} \n"}
{"5452": "public class GribPartitionBuilder { \nprivate boolean needsUpdate ( CollectionUpdateType ff , File collectionIndexFile ) throws IOException { \nlong collectionLastModified = collectionIndexFile . lastModified ( ) ; \nSet < String > newFileSet = new HashSet < > ( ) ; \nfor ( MCollection dcm : partitionManager . makePartitions ( CollectionUpdateType . test ) ) { \nString partitionIndexFilename = StringUtil2 . replace ( dcm . getIndexFilename ( GribCdmIndex . NCX_SUFFIX ) , '\\\\' , \"/\" ) ; \nFile partitionIndexFile = GribIndexCache . getExistingFileOrCache ( partitionIndexFilename ) ; \nif ( partitionIndexFile == null ) return true ; \nif ( partitionIndexFile . lastModified ( ) > collectionLastModified ) return true ; \nnewFileSet . add ( partitionIndexFilename ) ; \n} \nif ( ff == CollectionUpdateType . testIndexOnly ) return false ; \nGribCdmIndex reader = new GribCdmIndex ( logger ) ; \nList < MFile > oldFiles = new ArrayList < > ( ) ; \nreader . readMFiles ( collectionIndexFile . toPath ( ) , oldFiles ) ; \nSet < String > oldFileSet = new HashSet < > ( ) ; \nfor ( MFile oldFile : oldFiles ) { \nif ( ! newFileSet . contains ( oldFile . getPath ( ) ) ) return true ; \noldFileSet . add ( oldFile . getPath ( ) ) ; \n} \nfor ( String newFilename : newFileSet ) { \nif ( ! oldFileSet . contains ( newFilename ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"5453": "public class EnsCoord { \nstatic public void normalize ( EnsCoord result , List < EnsCoord > ecList ) { \nList < EnsCoord > extra = new ArrayList < > ( ) ; \nfor ( EnsCoord ec : ecList ) { \nif ( ! result . equalsData ( ec ) ) { \nextra . add ( ec ) ; \n} \n} \nif ( extra . size ( ) == 0 ) return ; \nfor ( EnsCoord ec : extra ) { \nif ( result . getNEnsembles ( ) > ec . getNEnsembles ( ) ) continue ; \nresult = ec ; \n} \n} \n} \n"}
{"5455": "public class ArrayStructure { \npublic StructureData getStructureData ( int index ) { \nif ( sdata == null ) sdata = new StructureData [ nelems ] ; \nif ( sdata . length <= index ) throw new IllegalArgumentException ( index + \" > \" + sdata . length ) ; \nif ( sdata [ index ] == null ) sdata [ index ] = makeStructureData ( this , index ) ; \nreturn sdata [ index ] ; \n} \n} \n"}
{"5465": "public class ArrayStructure { \npublic ArrayStructure getArrayStructure ( int recnum , StructureMembers . Member m ) { \nif ( ( m . getDataType ( ) != DataType . STRUCTURE ) && ( m . getDataType ( ) != DataType . SEQUENCE ) ) throw new IllegalArgumentException ( \"Type is \" + m . getDataType ( ) + \", must be Structure or Sequence\" ) ; \nif ( m . getDataType ( ) == DataType . SEQUENCE ) return getArraySequence ( recnum , m ) ; \nArrayStructure array = ( ArrayStructure ) m . getDataArray ( ) ; \nint count = m . getSize ( ) ; \nStructureData [ ] this_sdata = new StructureData [ count ] ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) this_sdata [ i ] = array . getStructureData ( recnum * count + i ) ; \nStructureMembers membersw = new StructureMembers ( array . getStructureMembers ( ) ) ; \nreturn new ArrayStructureW ( membersw , m . getShape ( ) , this_sdata ) ; \n} \n} \n"}
{"5468": "public class CoreTypeFcns { \nstatic protected long minmax ( long value , long min , long max ) { \nif ( min > value ) return min ; \nif ( max < value ) return max ; \nreturn value ; \n} \n} \n"}
{"5469": "public class CEConstraint { \nprotected Object eval ( DapVariable var , DapSequence seq , DataCursor record , CEAST expr ) throws DapException { \nswitch ( expr . sort ) { \ncase CONSTANT : return expr . value ; \ncase SEGMENT : return fieldValue ( var , seq , record , expr . name ) ; \ncase EXPR : Object lhs = eval ( var , seq , record , expr . lhs ) ; \nObject rhs = ( expr . rhs == null ? null : eval ( var , seq , record , expr . rhs ) ) ; \nif ( rhs != null ) switch ( expr . op ) { \ncase LT : return 0 > compare ( lhs , rhs ) ; \ncase LE : return 0 >= compare ( lhs , rhs ) ; \ncase GT : return 0 < compare ( lhs , rhs ) ; \ncase GE : return 0 <= compare ( lhs , rhs ) ; \ncase EQ : return lhs . equals ( rhs ) ; \ncase NEQ : return ! lhs . equals ( rhs ) ; \ncase REQ : return lhs . toString ( ) . matches ( rhs . toString ( ) ) ; \ncase AND : return ( ( Boolean ) lhs ) && ( ( Boolean ) rhs ) ; \n} \nelse switch ( expr . op ) { \ncase NOT : return ! ( ( Boolean ) lhs ) ; \n} \n} \nthrow new DapException ( \"Malformed Filter\" ) ; \n} \n} \n"}
{"5470": "public class CEConstraint { \npublic String toConstraintString ( ) { \nStringBuilder buf = new StringBuilder ( ) ; \nboolean first = true ; \nfor ( int i = 0 ; \nsegments . size ( ) > i ; \ni ++ ) { \nSegment seg = segments . get ( i ) ; \nif ( ! seg . var . isTopLevel ( ) ) continue ; \nif ( ! first ) buf . append ( \";\" ) ; \nfirst = false ; \ndumpvar ( seg , buf , true ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"5471": "public class CEConstraint { \npublic boolean references ( DapNode node ) { \nboolean isref = false ; \nswitch ( node . getSort ( ) ) { \ncase DIMENSION : DapDimension dim = this . redef . get ( ( DapDimension ) node ) ; \nif ( dim == null ) dim = ( DapDimension ) node ; \nisref = this . dimrefs . contains ( dim ) ; \nbreak ; \ncase ENUMERATION : isref = ( this . enums . contains ( ( DapEnumeration ) node ) ) ; \nbreak ; \ncase VARIABLE : isref = ( 0 <= findVariableIndex ( ( DapVariable ) node ) ) ; \nbreak ; \ncase GROUP : case DATASET : isref = ( this . groups . contains ( ( DapGroup ) node ) ) ; \nbreak ; \ndefault : break ; \n} \nreturn isref ; \n} \n} \n"}
{"5473": "public class CEConstraint { \nprotected int expansionCount ( DapStructure struct ) { \nint count = 0 ; \nfor ( DapVariable field : struct . getFields ( ) ) { \nif ( 0 <= findVariableIndex ( field ) ) count ++ ; \n} \nreturn count ; \n} \n} \n"}
{"5474": "public class CEConstraint { \nprotected void computeenums ( ) { \nfor ( int i = 0 ; \nvariables . size ( ) > i ; \ni ++ ) { \nDapVariable var = variables . get ( i ) ; \nif ( var . getSort ( ) != DapSort . VARIABLE ) continue ; \nDapType daptype = var . getBaseType ( ) ; \nif ( ! daptype . isEnumType ( ) ) continue ; \nif ( ! this . enums . contains ( ( DapEnumeration ) daptype ) ) this . enums . add ( ( DapEnumeration ) daptype ) ; \n} \n} \n} \n"}
{"5475": "public class CEConstraint { \nprotected void computegroups ( ) { \nfor ( int i = 0 ; \nvariables . size ( ) > i ; \ni ++ ) { \nDapVariable var = variables . get ( i ) ; \nList < DapGroup > path = var . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \nfor ( DapDimension dim : this . dimrefs ) { \nif ( ! dim . isShared ( ) ) continue ; \nList < DapGroup > path = dim . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \nfor ( DapEnumeration en : this . enums ) { \nList < DapGroup > path = en . getGroupPath ( ) ; \nfor ( DapGroup group : path ) { \nif ( ! this . groups . contains ( group ) ) this . groups . add ( group ) ; \n} \n} \n} \n} \n"}
{"5477": "public class Grib2Iosp { \n@ Override public boolean isValidFile ( RandomAccessFile raf ) throws IOException { \nif ( raf instanceof HTTPRandomAccessFile ) { \nif ( raf . getBufferSize ( ) < raf . length ( ) ) return false ; \n} \nelse { \nGribCdmIndex . GribCollectionType type = GribCdmIndex . getType ( raf ) ; \nif ( type == GribCdmIndex . GribCollectionType . GRIB2 ) return true ; \nif ( type == GribCdmIndex . GribCollectionType . Partition2 ) return true ; \n} \nreturn Grib2RecordScanner . isValidFile ( raf ) ; \n} \n} \n"}
{"5483": "public class GempakFileReader { \npublic float [ ] getFileHeader ( String name ) throws IOException { \nDMFileHeaderInfo fh = findFileHeader ( name ) ; \nif ( ( fh == null ) || ( fh . kfhtyp != MDREAL ) ) { \nreturn null ; \n} \nint knt = fileHeaderInfo . indexOf ( fh ) ; \nint iread = dmLabel . kpfile + 3 * dmLabel . kfhdrs ; \nfor ( int i = 0 ; \nknt > i ; \ni ++ ) { \nDMFileHeaderInfo fhi = fileHeaderInfo . get ( i ) ; \niread = iread + fhi . kfhlen + 1 ; \n} \nint nword = DM_RINT ( iread ) ; \nif ( 0 >= nword ) { \nlogError ( \"Invalid header length for \" + name ) ; \nreturn null ; \n} \niread ++ ; \nfloat [ ] rheader = new float [ nword ] ; \nif ( name . equals ( \"NAVB\" ) && needToSwap ) { \nDM_RFLT ( iread , 1 , rheader , 0 ) ; \nneedToSwap = false ; \niread ++ ; \nDM_RFLT ( iread , 1 , rheader , 1 ) ; \nneedToSwap = true ; \niread ++ ; \nDM_RFLT ( iread , nword - 2 , rheader , 2 ) ; \n} \nelse { \nDM_RFLT ( iread , rheader ) ; \n} \nreturn rheader ; \n} \n} \n"}
{"5484": "public class GempakFileReader { \npublic void printParts ( ) { \nif ( parts == null ) { \nreturn ; \n} \nfor ( int i = 0 ; \nparts . size ( ) > i ; \ni ++ ) { \nSystem . out . println ( \"\\nParts[\" + i + \"]:\" ) ; \nSystem . out . println ( parts . get ( i ) ) ; \n} \n} \n} \n"}
{"5485": "public class GempakFileReader { \npublic int getDataPointer ( int irow , int icol , String partName ) { \nint ipoint = - 1 ; \nif ( ( 1 > irow ) || ( dmLabel . krow < irow ) || ( 1 > icol ) || ( dmLabel . kcol < icol ) ) { \nSystem . out . println ( \"bad row or column number: \" + irow + \"/\" + icol ) ; \nreturn ipoint ; \n} \nint iprt = getPartNumber ( partName ) ; \nif ( iprt == 0 ) { \nSystem . out . println ( \"couldn't find part\" ) ; \nreturn ipoint ; \n} \nDMPart part = parts . get ( iprt - 1 ) ; \nif ( ( part . ktyprt != MDREAL ) && ( part . ktyprt != MDGRID ) && ( part . ktyprt != MDRPCK ) ) { \nSystem . out . println ( \"Not a valid type\" ) ; \nreturn ipoint ; \n} \nint ilenhd = part . klnhdr ; \nipoint = dmLabel . kpdata + ( irow - 1 ) * dmLabel . kcol * dmLabel . kprt + ( icol - 1 ) * dmLabel . kprt + ( iprt - 1 ) ; \nreturn ipoint ; \n} \n} \n"}
{"5486": "public class GempakFileReader { \npublic float DM_RFLT ( int word ) throws IOException { \nif ( rf == null ) { \nthrow new IOException ( \"DM_RFLT: no file to read from\" ) ; \n} \nif ( dmLabel == null ) { \nthrow new IOException ( \"DM_RFLT: reader not initialized\" ) ; \n} \nrf . seek ( getOffset ( word ) ) ; \nif ( needToSwap ) { \nrf . order ( RandomAccessFile . LITTLE_ENDIAN ) ; \n} \nelse { \nrf . order ( RandomAccessFile . BIG_ENDIAN ) ; \n} \nfloat rdata = rf . readFloat ( ) ; \nif ( RMISSD != dmLabel . smissd ) { \nif ( RDIFFD > Math . abs ( rdata - dmLabel . smissd ) ) { \nrdata = RMISSD ; \n} \n} \nrf . order ( RandomAccessFile . BIG_ENDIAN ) ; \nreturn rdata ; \n} \n} \n"}
{"5488": "public class GempakFileReader { \npublic float [ ] DM_UNPK ( DMPart part , int [ ] ibitst ) { \nint nparms = part . kparms ; \nint nwordp = part . kwordp ; \nint npack = ( ibitst . length - 1 ) / nwordp + 1 ; \nif ( npack * nwordp != ibitst . length ) { \nreturn null ; \n} \nfloat [ ] data = new float [ nparms * npack ] ; \nPackingInfo pkinf = part . packInfo ; \nint ir = 0 ; \nint ii = 0 ; \nfor ( int pack = 0 ; \nnpack > pack ; \npack ++ ) { \nint [ ] jdata = new int [ nwordp ] ; \nSystem . arraycopy ( ibitst , ii , jdata , 0 , nwordp ) ; \nfor ( int idata = 0 ; \nnparms > idata ; \nidata ++ ) { \nint jbit = pkinf . nbitsc [ idata ] ; \nint jsbit = pkinf . isbitc [ idata ] ; \nint jshift = 1 - jsbit ; \nint jsword = pkinf . iswrdc [ idata ] ; \nint jword = jdata [ jsword ] ; \nint mask = mskpat >>> ( 32 - jbit ) ; \nint ifield = jword >>> Math . abs ( jshift ) ; \nifield = ifield & mask ; \nif ( 32 < ( jsbit + jbit - 1 ) ) { \njword = jdata [ jsword + 1 ] ; \njshift = jshift + 32 ; \nint iword = jword << jshift ; \niword = iword & mask ; \nifield = ifield | iword ; \n} \nif ( ifield == pkinf . imissc [ idata ] ) { \ndata [ ir + idata ] = RMISSD ; \n} \nelse { \ndata [ ir + idata ] = ( ifield + pkinf . koffst [ idata ] ) * ( float ) pkinf . scalec [ idata ] ; \n} \n} \nir += nparms ; \nii += nwordp ; \n} \nreturn data ; \n} \n} \n"}
{"5489": "public class GempakFileReader { \nprotected static String getBits ( int b ) { \nFormatter s = new Formatter ( ) ; \nfor ( int i = 31 ; \n0 <= i ; \ni -- ) { \nif ( ( b & ( 1 << i ) ) != 0 ) { \ns . format ( \"1\" ) ; \n} \nelse { \ns . format ( \"0\" ) ; \n} \nif ( i % 8 == 0 ) { \ns . format ( \"|\" ) ; \n} \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"5495": "public class DataDescriptorTreeConstructor { \nprivate List < DataDescriptor > replicate ( List < DataDescriptor > keys ) { \nList < DataDescriptor > tree = new ArrayList < DataDescriptor > ( ) ; \nIterator < DataDescriptor > dkIter = keys . iterator ( ) ; \nwhile ( dkIter . hasNext ( ) ) { \nDataDescriptor dk = dkIter . next ( ) ; \nif ( dk . f == 1 ) { \ndk . subKeys = new ArrayList < DataDescriptor > ( ) ; \ndk . replication = dk . y ; \nif ( dk . replication == 0 ) { \nroot . isVarLength = true ; \nDataDescriptor replication = dkIter . next ( ) ; \nif ( replication . y == 0 ) dk . replicationCountSize = 1 ; \nelse if ( replication . y == 1 ) dk . replicationCountSize = 8 ; \nelse if ( replication . y == 2 ) dk . replicationCountSize = 16 ; \nelse if ( replication . y == 11 ) dk . repetitionCountSize = 8 ; \nelse if ( replication . y == 12 ) dk . repetitionCountSize = 16 ; \nelse log . error ( \"Unknown replication type= \" + replication ) ; \n} \nfor ( int j = 0 ; \ndk . x > j && dkIter . hasNext ( ) ; \nj ++ ) { \ndk . subKeys . add ( dkIter . next ( ) ) ; \n} \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \nelse if ( ( dk . f == 3 ) && ( dk . subKeys != null ) ) { \ndk . subKeys = replicate ( dk . subKeys ) ; \n} \ntree . add ( dk ) ; \n} \nreturn tree ; \n} \n} \n"}
{"5498": "public class Misc { \npublic static boolean nearlyEqualsAbs ( float a , float b , float maxAbsDiff ) { \nreturn Math . abs ( maxAbsDiff ) >= absoluteDifference ( a , b ) ; \n} \n} \n"}
{"5501": "public class Tools { \npublic static void probeObject ( Object o ) { \nClass c = o . getClass ( ) ; \nClass interfaces [ ] = c . getInterfaces ( ) ; \nClass parent = c . getSuperclass ( ) ; \nMethod m [ ] = c . getMethods ( ) ; \nSystem . out . println ( \"********* OBJECT PROBE *********\" ) ; \nSystem . out . println ( \"Class Name:  \" + c . getName ( ) ) ; \nSystem . out . println ( \"Super Class: \" + parent . getName ( ) ) ; \nSystem . out . println ( \"Interfaces: \" ) ; \nfor ( int i = 0 ; \ninterfaces . length > i ; \ni ++ ) { \nSystem . out . println ( \"    \" + interfaces [ i ] . getName ( ) ) ; \n} \nSystem . out . println ( \"Methods:\" ) ; \nfor ( int i = 0 ; \nm . length > i ; \ni ++ ) { \nClass params [ ] = m [ i ] . getParameterTypes ( ) ; \nClass excepts [ ] = m [ i ] . getExceptionTypes ( ) ; \nClass ret = m [ i ] . getReturnType ( ) ; \nSystem . out . print ( \"    \" + ret . getName ( ) + \"  \" + m [ i ] . getName ( ) + \"(\" ) ; \nfor ( int j = 0 ; \nparams . length > j ; \nj ++ ) { \nif ( 0 < j ) System . out . print ( \", \" ) ; \nSystem . out . print ( params [ j ] . getName ( ) ) ; \n} \nSystem . out . print ( \")  throws \" ) ; \nfor ( int j = 0 ; \nexcepts . length > j ; \nj ++ ) { \nif ( 0 < j ) System . out . print ( \", \" ) ; \nSystem . out . print ( excepts [ j ] . getName ( ) ) ; \n} \nSystem . out . println ( \"\" ) ; \n} \nSystem . out . println ( \"******************\" ) ; \n} \n} \n"}
{"5503": "public class CoordinateTimeAbstract { \npublic CoordinateTimeAbstract makeBestFromComplete ( ) { \nint [ ] best = new int [ time2runtime . length ] ; \nint last = - 1 ; \nint count = 0 ; \nfor ( int i = 0 ; \ntime2runtime . length > i ; \ni ++ ) { \nint time = time2runtime [ i ] ; \nif ( last <= time ) { \nlast = time ; \nbest [ i ] = time ; \ncount ++ ; \n} \nelse { \nbest [ i ] = - 1 ; \n} \n} \nreturn makeBestFromComplete ( best , count ) ; \n} \n} \n"}
{"5504": "public class LatLonProjection { \npublic ProjectionRect [ ] latLonToProjRect ( LatLonRect latlonR ) { \ndouble lat0 = latlonR . getLowerLeftPoint ( ) . getLatitude ( ) ; \ndouble height = Math . abs ( latlonR . getUpperRightPoint ( ) . getLatitude ( ) - lat0 ) ; \ndouble width = latlonR . getWidth ( ) ; \ndouble lon0 = LatLonPointImpl . lonNormal ( latlonR . getLowerLeftPoint ( ) . getLongitude ( ) , centerLon ) ; \ndouble lon1 = LatLonPointImpl . lonNormal ( latlonR . getUpperRightPoint ( ) . getLongitude ( ) , centerLon ) ; \nProjectionRect [ ] rects = new ProjectionRect [ ] { \nnew ProjectionRect ( ) , new ProjectionRect ( ) } \n; \nif ( lon1 > lon0 ) { \nrects [ 0 ] . setRect ( lon0 , lat0 , width , height ) ; \nrects [ 1 ] = null ; \n} \nelse { \ndouble y = centerLon + 180 - lon0 ; \nrects [ 0 ] . setRect ( lon0 , lat0 , y , height ) ; \nrects [ 1 ] . setRect ( lon1 - width + y , lat0 , width - y , height ) ; \n} \nreturn rects ; \n} \n} \n"}
{"5505": "public class AccessLogTable { \nprivate void showTimeSeriesAll ( java . util . List < LogReader . Log > logs ) { \nTimeSeries bytesSentData = new TimeSeries ( \"Bytes Sent\" , Minute . class ) ; \nTimeSeries timeTookData = new TimeSeries ( \"Average Latency\" , Minute . class ) ; \nTimeSeries nreqData = new TimeSeries ( \"Number of Requests\" , Minute . class ) ; \nString intervalS = \"5 minute\" ; \nlong period = 1000 * 60 * 5 ; \ntry { \nTimeDuration tu = new TimeDuration ( intervalS ) ; \nperiod = ( long ) ( 1000 * tu . getValueInSeconds ( ) ) ; \n} \ncatch ( Exception e ) { \nSystem . out . printf ( \"Illegal Time interval=%s %n\" , intervalS ) ; \n} \nlong current = 0 ; \nlong bytes = 0 ; \nlong timeTook = 0 ; \nlong total_count = 0 ; \nlong count = 0 ; \nfor ( LogReader . Log log : logs ) { \nlong msecs = log . date ; \nif ( period < msecs - current ) { \nif ( 0 < current ) { \ntotal_count += count ; \naddPoint ( bytesSentData , timeTookData , nreqData , new Date ( current ) , bytes , count , timeTook ) ; \n} \nbytes = 0 ; \ncount = 0 ; \ntimeTook = 0 ; \ncurrent = msecs ; \n} \nbytes += log . getBytes ( ) ; \ntimeTook += log . getMsecs ( ) ; \ncount ++ ; \n} \nif ( 0 < count ) addPoint ( bytesSentData , timeTookData , nreqData , new Date ( current ) , bytes , count , timeTook ) ; \ntotal_count += count ; \nSystem . out . printf ( \"showTimeSeriesAll: total_count = %d logs = %d%n\" , total_count , logs . size ( ) ) ; \nMultipleAxisChart mc = new MultipleAxisChart ( \"Access Logs\" , intervalS + \" average\" , \"Mbytes Sent\" , bytesSentData ) ; \nmc . addSeries ( \"Number of Requests\" , nreqData ) ; \nmc . addSeries ( \"Average Latency (secs)\" , timeTookData ) ; \nmc . finish ( new java . awt . Dimension ( 1000 , 1000 ) ) ; \ntimeSeriesPanel . removeAll ( ) ; \ntimeSeriesPanel . add ( mc ) ; \n} \n} \n"}
{"5508": "public class Attribute { \npublic Number getNumericValue ( int index ) { \nif ( ( 0 > index ) || ( nelems <= index ) ) return null ; \nswitch ( dataType ) { \ncase STRING : try { \nreturn new Double ( getStringValue ( index ) ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn null ; \n} \ncase BYTE : case UBYTE : return values . getByte ( index ) ; \ncase SHORT : case USHORT : return values . getShort ( index ) ; \ncase INT : case UINT : return values . getInt ( index ) ; \ncase FLOAT : return values . getFloat ( index ) ; \ncase DOUBLE : return values . getDouble ( index ) ; \ncase LONG : case ULONG : return values . getLong ( index ) ; \n} \nreturn null ; \n} \n} \n"}
{"5509": "public class Attribute { \nprotected void writeCDL ( Formatter f , boolean strict , String parentname ) { \nif ( strict && ( isString ( ) || this . getEnumType ( ) != null ) ) f . format ( \"string \" ) ; \nif ( strict && parentname != null ) f . format ( NetcdfFile . makeValidCDLName ( parentname ) ) ; \nf . format ( \":\" ) ; \nf . format ( \"%s\" , strict ? NetcdfFile . makeValidCDLName ( getShortName ( ) ) : getShortName ( ) ) ; \nif ( isString ( ) ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ngetLength ( ) > i ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nString val = getStringValue ( i ) ; \nif ( val != null ) f . format ( \"\\\"%s\\\"\" , encodeString ( val ) ) ; \n} \n} \nelse if ( getEnumType ( ) != null ) { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ngetLength ( ) > i ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nEnumTypedef en = getEnumType ( ) ; \nString econst = getStringValue ( i ) ; \nInteger ecint = en . lookupEnumInt ( econst ) ; \nif ( ecint == null ) throw new ForbiddenConversionException ( \"Illegal enum constant: \" + econst ) ; \nf . format ( \"\\\"%s\\\"\" , encodeString ( econst ) ) ; \n} \n} \nelse { \nf . format ( \" = \" ) ; \nfor ( int i = 0 ; \ngetLength ( ) > i ; \ni ++ ) { \nif ( i != 0 ) f . format ( \", \" ) ; \nNumber number = getNumericValue ( i ) ; \nif ( dataType . isUnsigned ( ) ) { \nnumber = DataType . widenNumber ( number ) ; \n} \nf . format ( \"%s\" , number ) ; \nif ( dataType . isUnsigned ( ) ) { \nf . format ( \"U\" ) ; \n} \nif ( dataType == DataType . FLOAT ) f . format ( \"f\" ) ; \nelse if ( dataType == DataType . SHORT || dataType == DataType . USHORT ) { \nf . format ( \"S\" ) ; \n} \nelse if ( dataType == DataType . BYTE || dataType == DataType . UBYTE ) { \nf . format ( \"B\" ) ; \n} \nelse if ( dataType == DataType . LONG || dataType == DataType . ULONG ) { \nf . format ( \"L\" ) ; \n} \n} \n} \n} \n} \n"}
{"5510": "public class Attribute { \nprivate void setStringValue ( String val ) { \nif ( val == null ) throw new IllegalArgumentException ( \"Attribute value cannot be null\" ) ; \nint len = val . length ( ) ; \nwhile ( ( 0 < len ) && ( val . charAt ( len - 1 ) == 0 ) ) len -- ; \nif ( len != val . length ( ) ) val = val . substring ( 0 , len ) ; \nthis . svalue = val ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \n} \n} \n"}
{"5511": "public class Attribute { \npublic void setValues ( List values ) { \nif ( values == null || values . size ( ) == 0 ) throw new IllegalArgumentException ( \"Cannot determine attribute's type\" ) ; \nint n = values . size ( ) ; \nClass c = values . get ( 0 ) . getClass ( ) ; \nObject pa ; \nif ( c == String . class ) { \nString [ ] va = new String [ n ] ; \npa = va ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) va [ i ] = ( String ) values . get ( i ) ; \n} \nelse if ( c == Integer . class ) { \nint [ ] va = new int [ n ] ; \npa = va ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) va [ i ] = ( Integer ) values . get ( i ) ; \n} \nelse if ( c == Double . class ) { \ndouble [ ] va = new double [ n ] ; \npa = va ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) va [ i ] = ( Double ) values . get ( i ) ; \n} \nelse if ( c == Float . class ) { \nfloat [ ] va = new float [ n ] ; \npa = va ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) va [ i ] = ( Float ) values . get ( i ) ; \n} \nelse if ( c == Short . class ) { \nshort [ ] va = new short [ n ] ; \npa = va ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) va [ i ] = ( Short ) values . get ( i ) ; \n} \nelse if ( c == Byte . class ) { \nbyte [ ] va = new byte [ n ] ; \npa = va ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) va [ i ] = ( Byte ) values . get ( i ) ; \n} \nelse if ( c == Long . class ) { \nlong [ ] va = new long [ n ] ; \npa = va ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) va [ i ] = ( Long ) values . get ( i ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Unknown type for Attribute = \" + c . getName ( ) ) ; \n} \nsetValues ( Array . factory ( this . dataType , new int [ ] { \nn } \n, pa ) ) ; \n} \n} \n"}
{"5512": "public class Attribute { \npublic void setValues ( Array arr ) { \nif ( immutable ) throw new IllegalStateException ( \"Cant modify\" ) ; \nif ( arr == null ) { \ndataType = DataType . STRING ; \nreturn ; \n} \nif ( arr . getElementType ( ) == char . class ) { \nArrayChar carr = ( ArrayChar ) arr ; \nif ( carr . getRank ( ) == 1 ) { \nsvalue = carr . getString ( ) ; \nthis . nelems = 1 ; \nthis . dataType = DataType . STRING ; \nreturn ; \n} \narr = carr . make1DStringArray ( ) ; \n} \nif ( arr . getElementType ( ) == ByteBuffer . class ) { \nint totalLen = 0 ; \narr . resetLocalIterator ( ) ; \nwhile ( arr . hasNext ( ) ) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \ntotalLen += bb . limit ( ) ; \n} \nbyte [ ] ba = new byte [ totalLen ] ; \nint pos = 0 ; \narr . resetLocalIterator ( ) ; \nwhile ( arr . hasNext ( ) ) { \nByteBuffer bb = ( ByteBuffer ) arr . next ( ) ; \nSystem . arraycopy ( bb . array ( ) , 0 , ba , pos , bb . limit ( ) ) ; \npos += bb . limit ( ) ; \n} \narr = Array . factory ( DataType . BYTE , new int [ ] { \ntotalLen } \n, ba ) ; \n} \nif ( DataType . getType ( arr ) == DataType . OBJECT ) throw new IllegalArgumentException ( \"Cant set Attribute with type \" + arr . getElementType ( ) ) ; \nif ( 1 < arr . getRank ( ) ) arr = arr . reshape ( new int [ ] { \n( int ) arr . getSize ( ) } \n) ; \nthis . values = arr ; \nthis . nelems = ( int ) arr . getSize ( ) ; \nthis . dataType = DataType . getType ( arr ) ; \n} \n} \n"}
{"5513": "public class CollectionLevelScanner { \npublic void scan ( ) throws IOException { \nif ( state == 1 ) throw new IllegalStateException ( \"Scan already underway.\" ) ; \nif ( 2 <= state ) throw new IllegalStateException ( \"Scan has already been generated.\" ) ; \nstate = 1 ; \nif ( proxyDsHandlers == null ) proxyDsHandlers = Collections . EMPTY_MAP ; \ngenCatalog = createSkeletonCatalog ( currentLevel ) ; \nInvDatasetImpl topInvDs = ( InvDatasetImpl ) genCatalog . getDatasets ( ) . get ( 0 ) ; \nList crDsList = currentLevel . listDatasets ( this . filter ) ; \nif ( sorter != null ) sorter . sort ( crDsList ) ; \nfor ( int i = 0 ; \ncrDsList . size ( ) > i ; \ni ++ ) { \nCrawlableDataset curCrDs = ( CrawlableDataset ) crDsList . get ( i ) ; \nInvDatasetImpl curInvDs = ( InvDatasetImpl ) createInvDatasetFromCrawlableDataset ( curCrDs , topInvDs , null ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( curCrDs , curInvDs ) ; \nif ( curCrDs . isCollection ( ) ) catRefInfo . add ( dsInfo ) ; \nelse atomicDsInfo . add ( dsInfo ) ; \ntopInvDs . addDataset ( curInvDs ) ; \n} \n( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \nif ( 0 < atomicDsInfo . size ( ) ) { \nboolean anyProxiesAdded = false ; \nfor ( Iterator it = proxyDsHandlers . values ( ) . iterator ( ) ; \nit . hasNext ( ) ; \n) { \nProxyDatasetHandler curProxy = ( ProxyDatasetHandler ) it . next ( ) ; \nInvService proxyService = curProxy . getProxyDatasetService ( currentLevel ) ; \nif ( proxyService != null ) { \nCrawlableDataset crDsToAdd = curProxy . createProxyDataset ( currentLevel ) ; \nInvDatasetImpl invDsToAdd = createInvDatasetFromCrawlableDataset ( crDsToAdd , topInvDs , proxyService ) ; \nInvCrawlablePair dsInfo = new InvCrawlablePair ( crDsToAdd , invDsToAdd ) ; \nproxyDsInfo . add ( dsInfo ) ; \nint index = curProxy . getProxyDatasetLocation ( currentLevel , topInvDs . getDatasets ( ) . size ( ) ) ; \ntopInvDs . addDataset ( index , ( InvDatasetImpl ) invDsToAdd ) ; \ngenCatalog . addService ( proxyService ) ; \nanyProxiesAdded = true ; \n} \n} \nif ( anyProxiesAdded ) ( ( InvCatalogImpl ) genCatalog ) . finish ( ) ; \n} \nthis . addTopLevelMetadata ( genCatalog , true ) ; \nstate = 2 ; \nreturn ; \n} \n} \n"}
{"5519": "public class ToolsUI { \nprivate static void setDataset ( ) { \nSwingUtilities . invokeLater ( ( ) -> { \nint pos = wantDataset . indexOf ( '#' ) ; \nif ( 0 < pos ) { \nfinal String catName = wantDataset . substring ( 0 , pos ) ; \nif ( catName . endsWith ( \".xml\" ) ) { \nui . makeComponent ( null , \"THREDDS\" ) ; \nui . threddsUI . setDataset ( wantDataset ) ; \nui . tabbedPane . setSelectedComponent ( ui . threddsUI ) ; \n} \nreturn ; \n} \nui . openNetcdfFile ( wantDataset ) ; \n} \n) ; \n} \n} \n"}
{"5521": "public class ToolsUI { \nprivate static void createToolsFrame ( ) { \nframe = new JFrame ( \"NetCDF (\" + DIALOG_VERSION + \") Tools\" ) ; \nui = new ToolsUI ( prefs , frame ) ; \nframe . setIconImage ( BAMutil . getImage ( \"netcdfUI\" ) ) ; \nframe . addWindowListener ( new WindowAdapter ( ) { \n@ Override public void windowActivated ( final WindowEvent e ) { \nToolsSplashScreen . getSharedInstance ( ) . setVisible ( false ) ; \n} \n@ Override public void windowClosing ( final WindowEvent e ) { \nif ( ! done ) { \nexit ( ) ; \n} \n} \n} \n) ; \nframe . getContentPane ( ) . add ( ui ) ; \nfinal Rectangle have = frame . getGraphicsConfiguration ( ) . getBounds ( ) ; \nfinal Rectangle def = new Rectangle ( 50 , 50 , 800 , 800 ) ; \nRectangle want = ( Rectangle ) prefs . getBean ( FRAME_SIZE , def ) ; \nif ( have . getWidth ( ) - 25 < want . getX ( ) ) { \nwant = def ; \n} \nframe . setBounds ( want ) ; \nframe . pack ( ) ; \nframe . setBounds ( want ) ; \nif ( wantDataset != null ) { \nsetDataset ( ) ; \n} \n} \n} \n"}
{"5522": "public class CoordinateSystem { \nstatic public String makeName ( List < CoordinateAxis > axes ) { \nList < CoordinateAxis > axesSorted = new ArrayList < > ( axes ) ; \nCollections . sort ( axesSorted , new CoordinateAxis . AxisComparator ( ) ) ; \nStringBuilder buff = new StringBuilder ( ) ; \nfor ( int i = 0 ; \naxesSorted . size ( ) > i ; \ni ++ ) { \nCoordinateAxis axis = axesSorted . get ( i ) ; \nif ( 0 < i ) buff . append ( \" \" ) ; \nbuff . append ( axis . getFullNameEscaped ( ) ) ; \n} \nreturn buff . toString ( ) ; \n} \n} \n"}
{"5523": "public class CoordinateSystem { \nprivate CoordinateAxis lesserRank ( CoordinateAxis a1 , CoordinateAxis a2 ) { \nif ( a1 == null ) return a2 ; \nreturn ( a2 . getRank ( ) >= a1 . getRank ( ) ) ? a1 : a2 ; \n} \n} \n"}
{"5535": "public class BeanTable { \npublic Object getSelectedBean ( ) { \nint viewRowIndex = jtable . getSelectedRow ( ) ; \nif ( 0 > viewRowIndex ) return null ; \nint modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndex ) ; \nreturn ( 0 > modelRowIndex ) || ( beans . size ( ) <= modelRowIndex ) ? null : beans . get ( modelRowIndex ) ; \n} \n} \n"}
{"5537": "public class BeanTable { \npublic ArrayList < Object > getSelectedCells ( ) { \nArrayList < Object > list = new ArrayList < > ( ) ; \nint [ ] viewRowIndices = jtable . getSelectedRows ( ) ; \nint [ ] viewColumnIndices = jtable . getSelectedColumns ( ) ; \nfor ( int i = 0 ; \nviewRowIndices . length > i ; \ni ++ ) for ( int j = 0 ; \nviewColumnIndices . length > i ; \nj ++ ) { \nint modelRowIndex = jtable . convertRowIndexToModel ( viewRowIndices [ i ] ) ; \nint modelColumnIndex = jtable . convertColumnIndexToModel ( viewColumnIndices [ j ] ) ; \nlist . add ( model . getValueAt ( modelRowIndex , modelColumnIndex ) ) ; \n} \nreturn list ; \n} \n} \n"}
{"5538": "public class BeanTable { \npublic void setSelectedBean ( Object bean ) { \nif ( bean == null ) return ; \nint modelRowIndex = beans . indexOf ( bean ) ; \nint viewRowIndex = jtable . convertRowIndexToView ( modelRowIndex ) ; \nif ( 0 <= viewRowIndex ) jtable . getSelectionModel ( ) . setSelectionInterval ( viewRowIndex , viewRowIndex ) ; \nmakeRowVisible ( viewRowIndex ) ; \n} \n} \n"}
{"5562": "public class ImageArrayAdapter { \npublic static java . awt . image . BufferedImage makeGrayscaleImage ( Array ma , IsMissingEvaluator missEval ) { \nif ( 2 > ma . getRank ( ) ) return null ; \nif ( ma . getRank ( ) == 3 ) ma = ma . reduce ( ) ; \nif ( ma . getRank ( ) == 3 ) ma = ma . slice ( 0 , 0 ) ; \nint h = ma . getShape ( ) [ 0 ] ; \nint w = ma . getShape ( ) [ 1 ] ; \nDataBuffer dataBuffer = makeDataBuffer ( ma , missEval ) ; \nWritableRaster raster = WritableRaster . createInterleavedRaster ( dataBuffer , w , h , w , 1 , new int [ ] { \n0 } \n, null ) ; \nColorSpace cs = ColorSpace . getInstance ( ColorSpace . CS_GRAY ) ; \nComponentColorModel colorModel = new ComponentColorModel ( cs , new int [ ] { \n8 } \n, false , false , Transparency . OPAQUE , DataBuffer . TYPE_BYTE ) ; \nreturn new BufferedImage ( colorModel , raster , false , null ) ; \n} \n} \n"}
{"5565": "public class CatalogCrawler { \npublic void crawlDirectDatasets ( InvDataset ds , CancelTask task , PrintWriter out , Object context , boolean release ) { \nboolean isCatRef = ( ds instanceof InvCatalogRef ) ; \nif ( filter != null && filter . skipAll ( ds ) ) { \nif ( isCatRef && release ) ( ( InvCatalogRef ) ds ) . release ( ) ; \nreturn ; \n} \nif ( isCatRef ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \nif ( out != null ) out . println ( \" **CATREF \" + catref . getURI ( ) + \" (\" + ds . getName ( ) + \") \" ) ; \ncountCatrefs ++ ; \nif ( ! listen . getCatalogRef ( catref , context ) ) { \nif ( release ) catref . release ( ) ; \nreturn ; \n} \n} \nList < InvDataset > dlist = ds . getDatasets ( ) ; \nList < InvDataset > leaves = new ArrayList < InvDataset > ( ) ; \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasAccess ( ) ) leaves . add ( dds ) ; \n} \nif ( 0 < leaves . size ( ) ) { \nif ( type == Type . first_direct ) { \nInvDataset dds = leaves . get ( 0 ) ; \nlisten . getDataset ( dds , context ) ; \n} \nelse if ( type == Type . random_direct ) { \nlisten . getDataset ( chooseRandom ( leaves ) , context ) ; \n} \nelse if ( type == Type . random_direct_middle ) { \nlisten . getDataset ( chooseRandomNotFirstOrLast ( leaves ) , context ) ; \n} \nelse { \nfor ( InvDataset dds : leaves ) { \nlisten . getDataset ( dds , context ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \n} \n} \nfor ( InvDataset dds : dlist ) { \nif ( dds . hasNestedDatasets ( ) ) crawlDirectDatasets ( dds , task , out , context , release ) ; \nif ( ( task != null ) && task . isCancel ( ) ) break ; \n} \nif ( ds instanceof InvCatalogRef && release ) { \nInvCatalogRef catref = ( InvCatalogRef ) ds ; \ncatref . release ( ) ; \n} \n} \n} \n"}
{"5570": "public class RandomAccessFile { \npublic synchronized void close ( ) throws IOException { \nif ( cache != null ) { \nif ( 0 < cacheState ) { \nif ( cacheState == 1 ) { \ncacheState = 2 ; \nif ( cache . release ( this ) ) return ; \ncacheState = 0 ; \n} \nelse { \nreturn ; \n} \n} \n} \nif ( debugLeaks ) { \nopenFiles . remove ( location ) ; \nif ( showOpen ) System . out . println ( \"  close \" + location ) ; \n} \nif ( file == null ) return ; \nflush ( ) ; \nlong fileSize = file . length ( ) ; \nif ( ! readonly && ( minLength != 0 ) && ( minLength != fileSize ) ) { \nfile . setLength ( minLength ) ; \n} \nfile . close ( ) ; \nfile = null ; \n} \n} \n"}
{"5571": "public class RandomAccessFile { \npublic void seek ( long pos ) throws IOException { \nif ( 0 > pos ) throw new java . io . IOException ( \"Negative seek offset\" ) ; \nif ( ( bufferStart <= pos ) && ( dataEnd > pos ) ) { \nfilePosition = pos ; \nreturn ; \n} \nreadBuffer ( pos ) ; \n} \n} \n"}
{"5573": "public class RandomAccessFile { \npublic int read ( ) throws IOException { \nif ( dataEnd > filePosition ) { \nint pos = ( int ) ( filePosition - bufferStart ) ; \nfilePosition ++ ; \nreturn ( buffer [ pos ] & 0xff ) ; \n} \nelse if ( endOfFile ) { \nreturn - 1 ; \n} \nelse { \nseek ( filePosition ) ; \nreturn read ( ) ; \n} \n} \n} \n"}
{"5574": "public class RandomAccessFile { \npublic final void readShort ( short [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \npa [ start + i ] = readShort ( ) ; \n} \n} \n} \n"}
{"5575": "public class RandomAccessFile { \npublic final int readIntUnbuffered ( long pos ) throws IOException { \nbyte [ ] bb = new byte [ 4 ] ; \nread_ ( pos , bb , 0 , 4 ) ; \nint ch1 = bb [ 0 ] & 0xff ; \nint ch2 = bb [ 1 ] & 0xff ; \nint ch3 = bb [ 2 ] & 0xff ; \nint ch4 = bb [ 3 ] & 0xff ; \nif ( 0 > ( ch1 | ch2 | ch3 | ch4 ) ) { \nthrow new EOFException ( ) ; \n} \nif ( bigEndian ) { \nreturn ( ( ch1 << 24 ) + ( ch2 << 16 ) + ( ch3 << 8 ) + ( ch4 ) ) ; \n} \nelse { \nreturn ( ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 ) ) ; \n} \n} \n} \n"}
{"5576": "public class RandomAccessFile { \npublic final void readInt ( int [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \npa [ start + i ] = readInt ( ) ; \n} \n} \n} \n"}
{"5577": "public class RandomAccessFile { \npublic final void readLong ( long [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \npa [ start + i ] = readLong ( ) ; \n} \n} \n} \n"}
{"5578": "public class RandomAccessFile { \npublic final void readFloat ( float [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \npa [ start + i ] = Float . intBitsToFloat ( readInt ( ) ) ; \n} \n} \n} \n"}
{"5579": "public class RandomAccessFile { \npublic final void readDouble ( double [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \npa [ start + i ] = Double . longBitsToDouble ( readLong ( ) ) ; \n} \n} \n} \n"}
{"5581": "public class RandomAccessFile { \npublic String readStringMax ( int nbytes ) throws IOException { \nbyte [ ] b = new byte [ nbytes ] ; \nreadFully ( b ) ; \nint count ; \nfor ( count = 0 ; \nnbytes > count ; \ncount ++ ) if ( b [ count ] == 0 ) break ; \nreturn new String ( b , 0 , count , CDM . utf8Charset ) ; \n} \n} \n"}
{"5582": "public class RandomAccessFile { \npublic final void writeBoolean ( boolean [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nwriteBoolean ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5583": "public class RandomAccessFile { \npublic final void writeShort ( short [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nwriteShort ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5584": "public class RandomAccessFile { \npublic final void writeChar ( char [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nwriteChar ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5585": "public class RandomAccessFile { \npublic final void writeInt ( int [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nwriteInt ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5586": "public class RandomAccessFile { \npublic final void writeLong ( long [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nwriteLong ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5587": "public class RandomAccessFile { \npublic final void writeFloat ( float [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nwriteFloat ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5588": "public class RandomAccessFile { \npublic final void writeDouble ( double [ ] pa , int start , int n ) throws IOException { \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nwriteDouble ( pa [ start + i ] ) ; \n} \n} \n} \n"}
{"5589": "public class RandomAccessFile { \npublic final void writeBytes ( String s ) throws IOException { \nint len = s . length ( ) ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nwrite ( ( byte ) s . charAt ( i ) ) ; \n} \n} \n} \n"}
{"5590": "public class RandomAccessFile { \npublic final void writeBytes ( char b [ ] , int off , int len ) throws IOException { \nfor ( int i = off ; \nlen > i ; \ni ++ ) { \nwrite ( ( byte ) b [ i ] ) ; \n} \n} \n} \n"}
{"5591": "public class RandomAccessFile { \npublic boolean searchForward ( KMPMatch match , int maxBytes ) throws IOException { \nlong start = getFilePointer ( ) ; \nlong last = ( 0 > maxBytes ) ? length ( ) : Math . min ( length ( ) , start + maxBytes ) ; \nlong needToScan = last - start ; \nint bytesAvailable = ( int ) ( dataEnd - filePosition ) ; \nif ( 1 > bytesAvailable ) { \nseek ( filePosition ) ; \nbytesAvailable = ( int ) ( dataEnd - filePosition ) ; \n} \nint bufStart = ( int ) ( filePosition - bufferStart ) ; \nint scanBytes = ( int ) Math . min ( bytesAvailable , needToScan ) ; \nint pos = match . indexOf ( buffer , bufStart , scanBytes ) ; \nif ( 0 <= pos ) { \nseek ( bufferStart + pos ) ; \nreturn true ; \n} \nint matchLen = match . getMatchLength ( ) ; \nneedToScan -= scanBytes - matchLen ; \nwhile ( matchLen < needToScan ) { \nreadBuffer ( dataEnd - matchLen ) ; \nscanBytes = ( int ) Math . min ( buffer . length , needToScan ) ; \npos = match . indexOf ( buffer , 0 , scanBytes ) ; \nif ( 0 < pos ) { \nseek ( bufferStart + pos ) ; \nreturn true ; \n} \nneedToScan -= scanBytes - matchLen ; \n} \nseek ( last ) ; \nreturn false ; \n} \n} \n"}
{"5595": "public class DirectoryBuilder { \nprivate boolean isLeaf ( IndexReader indexReader ) throws IOException { \nif ( partitionStatus == PartitionStatus . unknown ) { \nint countDir = 0 , countFile = 0 , count = 0 ; \ntry ( DirectoryStream < Path > dirStream = Files . newDirectoryStream ( dir ) ) { \nIterator < Path > iterator = dirStream . iterator ( ) ; \nwhile ( iterator . hasNext ( ) && 100 > count ++ ) { \nPath p = iterator . next ( ) ; \nBasicFileAttributes attr = Files . readAttributes ( p , BasicFileAttributes . class ) ; \nif ( attr . isDirectory ( ) ) countDir ++ ; \nelse countFile ++ ; \n} \n} \npartitionStatus = ( countDir < countFile ) ? PartitionStatus . isLeaf : PartitionStatus . isDirectoryPartition ; \n} \nreturn partitionStatus == PartitionStatus . isLeaf ; \n} \n} \n"}
{"5596": "public class DirectoryBuilder { \npublic List < DirectoryBuilder > constructChildren ( IndexReader indexReader , CollectionUpdateType forceCollection ) throws IOException { \nif ( childrenConstructed ) return children ; \nif ( index != null && forceCollection == CollectionUpdateType . nocheck ) { \nconstructChildrenFromIndex ( indexReader , false ) ; \n} \nelse { \nscanForChildren ( ) ; \n} \npartitionStatus = ( 0 < children . size ( ) ) ? PartitionStatus . isDirectoryPartition : PartitionStatus . isLeaf ; \nchildrenConstructed = true ; \nreturn children ; \n} \n} \n"}
{"5608": "public class GridCoordSys { \n@ Override public boolean isGlobalLon ( ) { \nif ( ! isLatLon ) return false ; \nif ( ! ( horizXaxis instanceof CoordinateAxis1D ) ) return false ; \nCoordinateAxis1D lon = ( CoordinateAxis1D ) horizXaxis ; \ndouble first = lon . getCoordEdge ( 0 ) ; \ndouble last = lon . getCoordEdge ( ( int ) lon . getSize ( ) ) ; \ndouble min = Math . min ( first , last ) ; \ndouble max = Math . max ( first , last ) ; \nreturn 360 <= ( max - min ) ; \n} \n} \n"}
{"5614": "public class MyTextField { \nprotected int getItemPos ( ) { \nif ( 1 > nitems ) return - arrow_size ; \nelse if ( nitems == 1 ) return b . width / 2 ; \nint item = table . getSelectedRowIndex ( ) ; \nint eff_width = b . width - 2 * arrow_size ; \nint pixel = ( item * eff_width ) / ( nitems - 1 ) ; \nreturn pixel + arrow_size ; \n} \n} \n"}
{"5615": "public class MyTextField { \nprotected int getItem ( int pixel ) { \nif ( 2 > nitems ) return 0 ; \nint eff_width = b . width - 2 * arrow_size ; \ndouble fitem = ( ( double ) ( pixel - arrow_size ) * ( nitems - 1 ) ) / eff_width ; \nint item = ( int ) ( fitem + .5 ) ; \nitem = Math . max ( Math . min ( item , nitems - 1 ) , 0 ) ; \nreturn item ; \n} \n} \n"}
{"5625": "public class CalendarPeriod { \npublic int getOffset ( CalendarDate start , CalendarDate end ) { \nif ( start . equals ( end ) ) return 0 ; \nlong start_millis = start . getDateTime ( ) . getMillis ( ) ; \nlong end_millis = end . getDateTime ( ) . getMillis ( ) ; \nPeriod p ; \nif ( end_millis > start_millis ) p = new Period ( start_millis , end_millis + 5000 , getPeriodType ( ) ) ; \nelse p = new Period ( start_millis + 5000 , end_millis , getPeriodType ( ) ) ; \nreturn p . get ( getDurationFieldType ( ) ) ; \n} \n} \n"}
{"5626": "public class GempakGridServiceProvider { \npublic boolean sync ( ) throws IOException { \nif ( ( raf . length ( ) > gemreader . getInitFileSize ( ) ) && extendIndex ) { \ngemreader . init ( true ) ; \nGridIndex index = gemreader . getGridIndex ( ) ; \nncfile . empty ( ) ; \nopen ( index , null ) ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"5652": "public class ErddapStringArray { \npublic void ensureCapacity ( long minCapacity ) { \nif ( minCapacity > array . length ) { \nErddapMath2 . ensureArraySizeOkay ( minCapacity , \"StringArray\" ) ; \nint newCapacity = ( int ) Math . min ( Integer . MAX_VALUE - 1 , array . length + ( long ) array . length ) ; \nif ( minCapacity > newCapacity ) newCapacity = ( int ) minCapacity ; \nString [ ] newArray = new String [ newCapacity ] ; \nSystem . arraycopy ( array , 0 , newArray , 0 , size ) ; \narray = newArray ; \n} \n} \n} \n"}
{"5653": "public class ErddapStringArray { \npublic String get ( int index ) { \nif ( size <= index ) throw new IllegalArgumentException ( ErddapString2 . ERROR + \" in StringArray.get: index (\" + index + \") >= size (\" + size + \").\" ) ; \nreturn array [ index ] ; \n} \n} \n"}
{"5658": "public class Grib2Pds { \nprotected CalendarDate calcTime ( int startIndex ) { \nint year = GribNumbers . int2 ( getOctet ( startIndex ++ ) , getOctet ( startIndex ++ ) ) ; \nint month = getOctet ( startIndex ++ ) ; \nint day = getOctet ( startIndex ++ ) ; \nint hour = getOctet ( startIndex ++ ) ; \nint minute = getOctet ( startIndex ++ ) ; \nint second = getOctet ( startIndex ++ ) ; \nif ( ( year == 0 ) && ( month == 0 ) && ( day == 0 ) && ( hour == 0 ) && ( minute == 0 ) && ( second == 0 ) ) return CalendarDate . UNKNOWN ; \nif ( 23 < hour ) { \nday += ( hour / 24 ) ; \nhour = hour % 24 ; \n} \nreturn CalendarDate . of ( null , year , month , day , hour , minute , second ) ; \n} \n} \n"}
{"5671": "public class DatasetSource { \nprivate void nameDatasets ( InvDatasetImpl datasetContainer ) { \nif ( this . getDatasetNamerList ( ) . isEmpty ( ) ) return ; \nif ( this . isFlatten ( ) ) { \nlogger . debug ( \"nameDatasets(): structure is FLAT calling nameDatasetList()\" ) ; \nthis . nameDatasetList ( datasetContainer ) ; \n} \nelse { \nlogger . debug ( \"nameDatasets(): structure is DIRECTORY_TREE calling\" + \" nameDatasetTree() on each dataset in dataset container\" ) ; \nInvDatasetImpl curDs = null ; \nfor ( int j = 0 ; \ndatasetContainer . getDatasets ( ) . size ( ) > j ; \nj ++ ) { \ncurDs = ( InvDatasetImpl ) datasetContainer . getDatasets ( ) . get ( j ) ; \nthis . nameDatasetTree ( curDs ) ; \n} \n} \nreturn ; \n} \n} \n"}
{"5672": "public class DatasetSource { \nprivate void nameDatasetList ( InvDatasetImpl dataset ) { \nInvDatasetImpl namedDs = new InvDatasetImpl ( dataset , \"nameDatastList() temp dataset\" , null , null , null ) ; \ndataset . addDataset ( namedDs ) ; \nDatasetNamer curNamer = null ; \nfor ( int i = 0 ; \nthis . datasetNamerList . size ( ) > i ; \ni ++ ) { \ncurNamer = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nlogger . debug ( \"nameDatasetList(): trying namer ({})\" , curNamer . getName ( ) ) ; \nInvDatasetImpl addLevelDs = null ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs = new InvDatasetImpl ( null , curNamer . getName ( ) , null , null , null ) ; \n} \nInvDatasetImpl curDs = null ; \njava . util . Iterator dsIter = dataset . getDatasets ( ) . iterator ( ) ; \nwhile ( dsIter . hasNext ( ) ) { \ncurDs = ( InvDatasetImpl ) dsIter . next ( ) ; \nlogger . debug ( \"nameDatasetList(): try namer on this ds ({}-{})\" , curDs . getName ( ) , curDs . getUrlPath ( ) ) ; \nif ( curNamer . nameDataset ( curDs ) ) { \nlogger . debug ( \"nameDatasetList(): ds named ({})\" , curDs . getName ( ) ) ; \nif ( curNamer . getAddLevel ( ) ) { \naddLevelDs . addDataset ( curDs ) ; \n} \nelse { \nnamedDs . addDataset ( curDs ) ; \n} \ndsIter . remove ( ) ; \n} \n} \nif ( curNamer . getAddLevel ( ) ) { \nif ( addLevelDs . hasNestedDatasets ( ) ) { \nnamedDs . addDataset ( addLevelDs ) ; \n} \n} \n} \nnamedDs . finish ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"nameDatasetList(): number of unnamed datasets is \" + dataset . getDatasets ( ) . size ( ) + \".\" ) ; \nlogger . debug ( \"nameDatasetList(): add named datasets back to container.\" ) ; \n} \nfor ( int i = 0 ; \nnamedDs . getDatasets ( ) . size ( ) > i ; \ni ++ ) { \ndataset . addDataset ( ( InvDatasetImpl ) namedDs . getDatasets ( ) . get ( i ) ) ; \n} \ndataset . removeDataset ( namedDs ) ; \nreturn ; \n} \n} \n"}
{"5673": "public class DatasetSource { \nprivate void nameDatasetTree ( InvDatasetImpl dataset ) { \nif ( dataset . getName ( ) . equals ( \"\" ) || ! dataset . hasAccess ( ) ) { \nlogger . debug ( \"nameDatasetTree(): naming dataset ({})...\" , dataset . getUrlPath ( ) ) ; \nDatasetNamer dsN = null ; \nfor ( int i = 0 ; \nthis . datasetNamerList . size ( ) > i ; \ni ++ ) { \ndsN = ( DatasetNamer ) this . datasetNamerList . get ( i ) ; \nif ( dsN . nameDataset ( dataset ) ) { \nlogger . debug ( \"nameDatasetTree(): ... used namer ({})\" , dsN . getName ( ) ) ; \nbreak ; \n} \n} \n} \nInvDatasetImpl curDs = null ; \nfor ( int j = 0 ; \ndataset . getDatasets ( ) . size ( ) > j ; \nj ++ ) { \ncurDs = ( InvDatasetImpl ) dataset . getDatasets ( ) . get ( j ) ; \nlogger . debug ( \"nameDatasetTree(): recurse to name child dataset ({})\" , curDs . getUrlPath ( ) ) ; \nthis . nameDatasetTree ( curDs ) ; \n} \nreturn ; \n} \n} \n"}
{"5683": "public class GempakSoundingFileReader { \nprivate List < String > SN_CKUA ( ) { \nList < String > types = new ArrayList < > ( ) ; \nboolean above = false ; \nboolean done = false ; \nString partToCheck ; \nwhile ( ! done ) { \nfor ( int group = 0 ; \nbelowGroups . length > group ; \ngroup ++ ) { \nif ( above ) { \npartToCheck = aboveGroups [ group ] ; \n} \nelse { \npartToCheck = belowGroups [ group ] ; \n} \nif ( checkForValidGroup ( partToCheck , parmLists [ group ] ) ) { \ntypes . add ( partToCheck ) ; \n} \n} \nif ( ! above ) { \nabove = true ; \n} \nelse { \ndone = true ; \n} \n} \nreturn types ; \n} \n} \n"}
{"5689": "public class DiskCache { \nstatic public void cleanCache ( long maxBytes , Comparator < File > fileComparator , StringBuilder sbuff ) { \nif ( sbuff != null ) sbuff . append ( \"DiskCache clean maxBytes= \" ) . append ( maxBytes ) . append ( \"on dir \" ) . append ( root ) . append ( \"\\n\" ) ; \nFile dir = new File ( root ) ; \nlong total = 0 , total_delete = 0 ; \nFile [ ] files = dir . listFiles ( ) ; \nif ( files != null ) { \nList < File > fileList = Arrays . asList ( files ) ; \nCollections . sort ( fileList , fileComparator ) ; \nfor ( File file : fileList ) { \nif ( maxBytes < file . length ( ) + total ) { \ntotal_delete += file . length ( ) ; \nif ( sbuff != null ) sbuff . append ( \" delete \" ) . append ( file ) . append ( \" (\" ) . append ( file . length ( ) ) . append ( \")\\n\" ) ; \nif ( ! file . delete ( ) && sbuff != null ) sbuff . append ( \"Error deleting \" ) . append ( file ) . append ( \"\\n\" ) ; \n} \nelse { \ntotal += file . length ( ) ; \n} \n} \n} \nif ( sbuff != null ) { \nsbuff . append ( \"Total bytes deleted= \" ) . append ( total_delete ) . append ( \"\\n\" ) ; \nsbuff . append ( \"Total bytes left in cache= \" ) . append ( total ) . append ( \"\\n\" ) ; \n} \n} \n} \n"}
{"5690": "public class Descriptor { \nstatic public boolean isBufrTable ( short fxy ) { \nint f = ( fxy & 0xC000 ) >> 14 ; \nint x = ( fxy & 0x3F00 ) >> 8 ; \nint y = ( fxy & 0xFF ) ; \nreturn ( f == 0 ) && ( x == 0 ) && ( 13 > y ) ; \n} \n} \n"}
{"5695": "public class CoordinateAxis { \npublic ucar . nc2 . time . Calendar getCalendarFromAttribute ( ) { \nAttribute cal = findAttribute ( CF . CALENDAR ) ; \nString s = ( cal == null ) ? null : cal . getStringValue ( ) ; \nif ( s == null ) { \nAttribute convention = ( ncd == null ) ? null : ncd . getRootGroup ( ) . findAttribute ( CDM . CONVENTIONS ) ; \nif ( convention != null ) { \nString hasName = convention . getStringValue ( ) ; \nint version = CF1Convention . getVersion ( hasName ) ; \nif ( 0 <= version ) { \nreturn Calendar . gregorian ; \n} \nif ( COARDSConvention . isMine ( hasName ) ) return Calendar . gregorian ; \n} \n} \nreturn ucar . nc2 . time . Calendar . get ( s ) ; \n} \n} \n"}
{"5696": "public class JTableSorted { \npublic void setList ( ArrayList rowList ) { \nthis . list = rowList ; \nif ( 0 < list . size ( ) ) jtable . setRowSelectionInterval ( 0 , 0 ) ; \nelse jtable . clearSelection ( ) ; \nmodel . sort ( ) ; \njtable . revalidate ( ) ; \n} \n} \n"}
{"5697": "public class JTableSorted { \npublic TableRow getSelected ( ) { \nif ( list . size ( ) == 0 ) return null ; \nint sel = jtable . getSelectedRow ( ) ; \nif ( 0 <= sel ) return ( TableRow ) list . get ( sel ) ; \nelse return null ; \n} \n} \n"}
{"5698": "public class JTableSorted { \npublic void incrSelected ( boolean increment ) { \nif ( list . size ( ) == 0 ) return ; \nint curr = jtable . getSelectedRow ( ) ; \nif ( increment && ( list . size ( ) - 1 > curr ) ) setSelected ( curr + 1 ) ; \nelse if ( ! increment && ( 0 < curr ) ) setSelected ( curr - 1 ) ; \n} \n} \n"}
{"5699": "public class JTableSorted { \npublic int [ ] getModelIndex ( ) { \nint [ ] modelIndex = new int [ colName . length ] ; \nTableColumnModel tcm = jtable . getColumnModel ( ) ; \nfor ( int i = 0 ; \ncolName . length > i ; \ni ++ ) { \nTableColumn tc = tcm . getColumn ( i ) ; \nmodelIndex [ i ] = tc . getModelIndex ( ) ; \n} \nreturn modelIndex ; \n} \n} \n"}
{"5701": "public class Util { \nstatic private void quickSort ( String a [ ] , int lo0 , int hi0 ) { \nint lo = lo0 ; \nint hi = hi0 ; \nString mid ; \nif ( lo0 < hi0 ) { \nmid = a [ ( lo0 + hi0 ) / 2 ] ; \nwhile ( hi >= lo ) { \nwhile ( ( hi0 > lo ) && ( 0 > a [ lo ] . compareTo ( mid ) ) ) ++ lo ; \nwhile ( ( lo0 < hi ) && ( 0 < a [ hi ] . compareTo ( mid ) ) ) -- hi ; \nif ( hi >= lo ) { \nswap ( a , lo , hi ) ; \n++ lo ; \n-- hi ; \n} \n} \nif ( hi > lo0 ) quickSort ( a , lo0 , hi ) ; \nif ( hi0 > lo ) quickSort ( a , lo , hi0 ) ; \n} \n} \n} \n"}
{"5705": "public class XMLStore { \nstatic public XMLStore createFromFile ( String fileName , XMLStore storedDefaults ) throws java . io . IOException { \nFile prefsFile = new File ( fileName ) ; \nInputStream primIS = null , objIS = null ; \nif ( prefsFile . exists ( ) && 0 < prefsFile . length ( ) ) { \nprimIS = new BufferedInputStream ( new FileInputStream ( prefsFile ) ) ; \nobjIS = new BufferedInputStream ( new FileInputStream ( prefsFile ) ) ; \n} \nif ( debugWhichStore ) System . out . println ( \"XMLStore read from file \" + fileName ) ; \nXMLStore store = new XMLStore ( primIS , objIS , storedDefaults ) ; \nstore . prefsFile = prefsFile ; \nreturn store ; \n} \n} \n"}
{"5713": "public class DapSerializer { \nprotected void writeStructure1 ( DataCursor instance , SerialWriter dst ) throws IOException { \nassert instance . getScheme ( ) == DataCursor . Scheme . STRUCTURE ; \nDapVariable template = ( DapVariable ) instance . getTemplate ( ) ; \nassert ( this . ce . references ( template ) ) ; \nDapStructure ds = ( DapStructure ) template . getBaseType ( ) ; \nList < DapVariable > fields = ds . getFields ( ) ; \nfor ( int i = 0 ; \nfields . size ( ) > i ; \ni ++ ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) continue ; \nDataCursor df = ( DataCursor ) instance . readField ( i ) ; \nwriteVariable ( df , dst ) ; \n} \n} \n} \n"}
{"5714": "public class DapSerializer { \nprotected void writeSequence ( DataCursor data , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) data . getTemplate ( ) ; \nDapSequence ds = ( DapSequence ) template . getBaseType ( ) ; \nassert ( this . ce . references ( template ) ) ; \nList < Slice > slices = ce . getConstrainedSlices ( template ) ; \nOdometer odom = Odometer . factory ( slices ) ; \nif ( false ) while ( odom . hasNext ( ) ) { \nIndex index = odom . next ( ) ; \nDataCursor [ ] instance = ( DataCursor [ ] ) data . read ( index ) ; \nwriteSequence1 ( instance [ 0 ] , dst ) ; \n} \nelse { \nDataCursor [ ] instances = ( DataCursor [ ] ) data . read ( slices ) ; \nfor ( int i = 0 ; \ninstances . length > i ; \ni ++ ) { \nwriteSequence1 ( instances [ i ] , dst ) ; \n} \n} \n} \n} \n"}
{"5715": "public class DapSerializer { \nprotected void writeRecord ( DataCursor record , SerialWriter dst ) throws IOException { \nDapVariable template = ( DapVariable ) record . getTemplate ( ) ; \nDapSequence seq = ( DapSequence ) template . getBaseType ( ) ; \nList < DapVariable > fields = seq . getFields ( ) ; \nfor ( int i = 0 ; \nfields . size ( ) > i ; \ni ++ ) { \nDapVariable field = fields . get ( i ) ; \nif ( ! this . ce . references ( field ) ) continue ; \nDataCursor df = ( DataCursor ) record . readField ( i ) ; \nwriteVariable ( df , dst ) ; \n} \n} \n} \n"}
{"5716": "public class MessageScanner { \nstatic public boolean isValidFile ( ucar . unidata . io . RandomAccessFile raf ) throws IOException { \nraf . seek ( 0 ) ; \nif ( ! raf . searchForward ( matcher , 40 * 1000 ) ) return false ; \nraf . skipBytes ( 4 ) ; \nBufrIndicatorSection is = new BufrIndicatorSection ( raf ) ; \nif ( 4 < is . getBufrEdition ( ) ) return false ; \nreturn ! ( raf . length ( ) < is . getBufrLength ( ) ) ; \n} \n} \n"}
{"5718": "public class DbaseData { \nint readRowN ( DataInputStream ds , int n ) { \nif ( nrec < n ) return - 1 ; \ntry { \nds . readFully ( field , 0 , desc . FieldLength ) ; \n} \ncatch ( java . io . IOException e ) { \nreturn - 1 ; \n} \nswitch ( desc . Type ) { \ncase 'C' : case 'D' : character [ n ] = new String ( field , CDM . utf8Charset ) ; \nbreak ; \ncase 'N' : numeric [ n ] = Double . valueOf ( new String ( field , CDM . utf8Charset ) ) ; \nbreak ; \ncase 'F' : if ( desc . FieldLength == 4 ) { \nnumeric [ n ] = ( double ) Swap . swapFloat ( field , 0 ) ; \n} \nelse { \nnumeric [ n ] = Swap . swapDouble ( field , 0 ) ; \n} \nbreak ; \ncase 'L' : switch ( field [ 0 ] ) { \ncase 't' : case 'T' : case 'Y' : case 'y' : logical [ n ] = true ; \nbreak ; \ndefault : logical [ n ] = false ; \nbreak ; \n} \ndefault : return - 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"5720": "public class Grib2DataReader { \nprivate float [ ] getData0 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nint nb = gdrs . numberOfBits ; \nint D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nint E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nBitReader reader = new BitReader ( raf , startPos + 5 ) ; \nif ( bitmap == null ) { \nfor ( int i = 0 ; \ntotalNPoints > i ; \ni ++ ) { \ndata [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \n} \n} \nelse { \nfor ( int i = 0 ; \ntotalNPoints > i ; \ni ++ ) { \nif ( GribNumbers . testBitIsSet ( bitmap [ i / 8 ] , i % 8 ) ) { \ndata [ i ] = ( R + reader . bits2UInt ( nb ) * EE ) / DD ; \n} \nelse { \ndata [ i ] = staticMissingValue ; \n} \n} \n} \nreturn data ; \n} \n} \n"}
{"5721": "public class Grib2DataReader { \nprivate float [ ] getData41 ( RandomAccessFile raf , Grib2Drs . Type0 gdrs ) throws IOException { \nint nb = gdrs . numberOfBits ; \nint D = gdrs . decimalScaleFactor ; \nfloat DD = ( float ) java . lang . Math . pow ( ( double ) 10 , ( double ) D ) ; \nfloat R = gdrs . referenceValue ; \nint E = gdrs . binaryScaleFactor ; \nfloat EE = ( float ) java . lang . Math . pow ( 2.0 , ( double ) E ) ; \nfloat [ ] data = new float [ totalNPoints ] ; \nif ( nb == 0 ) { \nArrays . fill ( data , R ) ; \nreturn data ; \n} \nbyte [ ] buf = new byte [ dataLength - 5 ] ; \nraf . readFully ( buf ) ; \nInputStream in = new ByteArrayInputStream ( buf ) ; \nBufferedImage image = ImageIO . read ( in ) ; \nif ( nb != image . getColorModel ( ) . getPixelSize ( ) ) { \nlogger . debug ( \"PNG pixel size disagrees with grib number of bits: \" , image . getColorModel ( ) . getPixelSize ( ) , nb ) ; \n} \nDataBuffer db = image . getRaster ( ) . getDataBuffer ( ) ; \nif ( bitmap == null ) { \nfor ( int i = 0 ; \ndataNPoints > i ; \ni ++ ) { \ndata [ i ] = ( R + db . getElem ( i ) * EE ) / DD ; \n} \n} \nelse { \nfor ( int bitPt = 0 , dataPt = 0 ; \ntotalNPoints > bitPt ; \nbitPt ++ ) { \nif ( GribNumbers . testBitIsSet ( bitmap [ bitPt / 8 ] , bitPt % 8 ) ) { \ndata [ bitPt ] = ( R + db . getElem ( dataPt ++ ) * EE ) / DD ; \n} \nelse { \ndata [ bitPt ] = staticMissingValue ; \n} \n} \n} \nreturn data ; \n} \n} \n"}
{"5722": "public class CDMCursor { \n@ Override public Object read ( List < Slice > slices ) throws DapException { \nswitch ( this . scheme ) { \ncase ATOMIC : return readAtomic ( slices ) ; \ncase STRUCTURE : if ( 0 < ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \nCDMCursor [ ] instances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase SEQUENCE : if ( 0 < ( ( DapVariable ) this . getTemplate ( ) ) . getRank ( ) || DapUtil . isScalarSlices ( slices ) ) throw new DapException ( \"Cannot slice a scalar variable\" ) ; \ninstances = new CDMCursor [ 1 ] ; \ninstances [ 0 ] = this ; \nreturn instances ; \ncase STRUCTARRAY : Odometer odom = Odometer . factory ( slices ) ; \ninstances = new CDMCursor [ ( int ) odom . totalSize ( ) ] ; \nfor ( int i = 0 ; \nodom . hasNext ( ) ; \ni ++ ) { \ninstances [ i ] = readStructure ( odom . next ( ) ) ; \n} \nreturn instances ; \ncase SEQARRAY : instances = readSequence ( slices ) ; \nreturn instances ; \ndefault : throw new DapException ( \"Attempt to slice a scalar object\" ) ; \n} \n} \n} \n"}
{"5726": "public class StationRenderer { \npublic void setStations ( java . util . List < ucar . unidata . geoloc . Station > stns ) { \nstations = new ArrayList < StationUI > ( stns . size ( ) ) ; \nstationHash . clear ( ) ; \nfor ( int i = 0 ; \nstns . size ( ) > i ; \ni ++ ) { \nucar . unidata . geoloc . Station s = ( ucar . unidata . geoloc . Station ) stns . get ( i ) ; \nStationUI sui = new StationUI ( s ) ; \nstations . add ( sui ) ; \nstationHash . put ( s . getName ( ) , sui ) ; \n} \nposWasCalc = false ; \ncalcWorldPos ( ) ; \n} \n} \n"}
{"5736": "public class Ray { \npublic void readData ( RandomAccessFile raf , String abbrev , Range gateRange , IndexIterator ii ) throws IOException { \nlong offset = rayOffset ; \noffset += ( getDataOffset ( abbrev ) * 2 - 2 ) ; \nraf . seek ( offset ) ; \nbyte [ ] b2 = new byte [ 2 ] ; \nint dataCount = getGateCount ( abbrev ) ; \nbyte [ ] data = new byte [ dataCount * 2 ] ; \nraf . readFully ( data ) ; \nfor ( int gateIdx : gateRange ) { \nif ( dataCount <= gateIdx ) ii . setShortNext ( uf_header2 . missing ) ; \nelse { \nb2 [ 0 ] = data [ gateIdx * 2 ] ; \nb2 [ 1 ] = data [ gateIdx * 2 + 1 ] ; \nshort value = getShort ( b2 , 0 ) ; \nii . setShortNext ( value ) ; \n} \n} \n} \n} \n"}
{"5737": "public class MAVector { \npublic double dot ( MAVector v ) { \nif ( nelems != v . getNelems ( ) ) throw new IllegalArgumentException ( \"MAVector.dot \" + nelems + \" != \" + v . getNelems ( ) ) ; \ndouble sum = 0.0 ; \nfor ( int k = 0 ; \nnelems > k ; \nk ++ ) sum += getDouble ( k ) * v . getDouble ( k ) ; \nreturn sum ; \n} \n} \n"}
{"5738": "public class MAVector { \npublic double norm ( ) { \ndouble sum = 0.0 ; \nfor ( int k = 0 ; \nnelems > k ; \nk ++ ) { \ndouble val = getDouble ( k ) ; \nsum += val * val ; \n} \nreturn Math . sqrt ( sum ) ; \n} \n} \n"}
{"5739": "public class MAVector { \npublic void normalize ( ) { \ndouble norm = norm ( ) ; \nif ( 0.0 >= norm ) return ; \nfor ( int k = 0 ; \nnelems > k ; \nk ++ ) { \ndouble val = getDouble ( k ) ; \nsetDouble ( k , val / norm ) ; \n} \n} \n} \n"}
{"5745": "public class PrefixDBImpl { \nprivate static Prefix getPrefix ( final String string , final Set < Prefix > set ) { \nfor ( final Iterator < Prefix > iter = set . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nfinal Prefix prefix = iter . next ( ) ; \nfinal int comp = prefix . compareTo ( string ) ; \nif ( comp == 0 ) { \nreturn prefix ; \n} \nif ( 0 < comp ) { \nbreak ; \n} \n} \nreturn null ; \n} \n} \n"}
{"5746": "public class ADNWriter { \nprotected boolean emailOK ( ThreddsMetadata . Source p ) { \nString email = p . getEmail ( ) ; \nreturn 0 <= email . indexOf ( '@' ) ; \n} \n} \n"}
{"5750": "public class AbstractCursor { \n@ Override public int fieldIndex ( String name ) throws DapException { \nDapStructure ds ; \nif ( getTemplate ( ) . getSort ( ) . isCompound ( ) ) ds = ( DapStructure ) getTemplate ( ) ; \nelse if ( getTemplate ( ) . getSort ( ) . isVar ( ) && ( ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) . getSort ( ) . isCompound ( ) ) ) ds = ( DapStructure ) ( ( DapVariable ) getTemplate ( ) ) . getBaseType ( ) ; \nelse throw new DapException ( \"Attempt to get field name on non-compound object\" ) ; \nint i = ds . indexByName ( name ) ; \nif ( 0 > i ) throw new DapException ( \"Unknown field name: \" + name ) ; \nreturn i ; \n} \n} \n"}
{"5756": "public class JTableProjection { \npublic void setCurrentProjection ( ProjectionImpl proj ) { \nint row ; \nif ( ( row = model . search ( proj ) ) >= 0 ) { \nif ( debug ) System . out . println ( \" PTsetCurrentProjection found = \" + row ) ; \nselectedRow = row ; \nsetRowSelectionInterval ( row , row ) ; \n} \nelse { \nif ( debug ) System . out . println ( \" PTsetCurrentProjection not found = \" + row ) ; \nselectedRow = - 1 ; \nclearSelection ( ) ; \n} \n} \n} \n"}
{"5757": "public class TimeOffsetAxis { \npublic Optional < TimeOffsetAxis > subsetFromTime ( SubsetParams params , CalendarDate runDate ) { \nCoordAxisHelper helper = new CoordAxisHelper ( this ) ; \nCoverageCoordAxisBuilder builder = null ; \nif ( params . isTrue ( SubsetParams . timePresent ) ) { \ndouble offset = getOffsetInTimeUnits ( runDate , CalendarDate . present ( ) ) ; \nbuilder = helper . subsetClosest ( offset ) ; \n} \nCalendarDate dateWanted = ( CalendarDate ) params . get ( SubsetParams . time ) ; \nif ( dateWanted != null ) { \ndouble offset = getOffsetInTimeUnits ( runDate , dateWanted ) ; \nbuilder = helper . subsetClosest ( offset ) ; \n} \nInteger stride = ( Integer ) params . get ( SubsetParams . timeStride ) ; \nif ( stride == null || 0 > stride ) stride = 1 ; \nCalendarDateRange dateRange = ( CalendarDateRange ) params . get ( SubsetParams . timeRange ) ; \nif ( dateRange != null ) { \ndouble min = getOffsetInTimeUnits ( runDate , dateRange . getStart ( ) ) ; \ndouble max = getOffsetInTimeUnits ( runDate , dateRange . getEnd ( ) ) ; \nOptional < CoverageCoordAxisBuilder > buildero = helper . subset ( min , max , stride ) ; \nif ( buildero . isPresent ( ) ) builder = buildero . get ( ) ; \nelse return Optional . empty ( buildero . getErrorMessage ( ) ) ; \n} \nassert ( builder != null ) ; \nbuilder . setReferenceDate ( runDate ) ; \nreturn Optional . of ( new TimeOffsetAxis ( builder ) ) ; \n} \n} \n"}
{"5760": "public class NetcdfFile { \nstatic public void registerIOProviderPreferred ( Class iospClass , Class target ) throws IllegalAccessException , InstantiationException { \niospDeRegister ( iospClass ) ; \nint pos = - 1 ; \nfor ( int i = 0 ; \nregisteredProviders . size ( ) > i ; \ni ++ ) { \nIOServiceProvider candidate = registeredProviders . get ( i ) ; \nif ( candidate . getClass ( ) == target ) { \nif ( i > pos ) pos = i ; \nbreak ; \n} \n} \nif ( 0 > pos ) pos = 0 ; \nIOServiceProvider spi = ( IOServiceProvider ) iospClass . newInstance ( ) ; \nregisteredProviders . add ( pos , spi ) ; \n} \n} \n"}
{"5762": "public class NetcdfFile { \nstatic public boolean iospDeRegister ( Class iospClass ) { \nfor ( int i = 0 ; \nregisteredProviders . size ( ) > i ; \ni ++ ) { \nIOServiceProvider spi = registeredProviders . get ( i ) ; \nif ( spi . getClass ( ) == iospClass ) { \nregisteredProviders . remove ( i ) ; \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"5796": "public class Attribute { \nprivate static String forceValue ( int type , String value ) throws AttributeBadValueException { \ntry { \ndispatchCheckValue ( type , value ) ; \n} \ncatch ( AttributeBadValueException abe ) { \nif ( type == BYTE ) { \nshort val = Short . parseShort ( value ) ; \nif ( 255 < val && - 128 > val ) throw new AttributeBadValueException ( \"Cannot convert to byte: \" + value ) ; \nvalue = Integer . toString ( ( val & 0xFF ) ) ; \n} \n} \nreturn value ; \n} \n} \n"}
{"5797": "public class Attribute { \nprivate static final boolean checkByte ( String s ) throws AttributeBadValueException { \ntry { \nshort val = Short . parseShort ( s ) ; \nif ( DebugValueChecking ) { \nlog . debug ( \"Attribute.checkByte() - string: '\" + s + \"'   value: \" + val ) ; \n} \nif ( 0xFF < val || 0 > val ) return false ; \nelse return true ; \n} \ncatch ( NumberFormatException e ) { \nthrow new AttributeBadValueException ( \"`\" + s + \"' is not a Byte value.\" ) ; \n} \n} \n} \n"}
{"5800": "public class Attribute { \nprivate static final boolean checkUInt ( String s ) { \ntry { \nlong val = Long . parseLong ( s ) ; \nif ( DebugValueChecking ) { \nDAPNode . log . debug ( \"Attribute.checkUInt() - string: '\" + s + \"'   value: \" + val ) ; \n} \nif ( 0xFFFFFFFFL < val ) return false ; \nelse return true ; \n} \ncatch ( NumberFormatException e ) { \nreturn false ; \n} \n} \n} \n"}
{"5808": "public class StringValidateEncodeUtils { \n@ SuppressWarnings ( { \n\"UnnecessaryContinue\" } \n) public static boolean descendOnlyFilePath ( String path ) { \nString [ ] pathSegments = path . split ( \"/\" ) ; \nint i = 0 ; \nfor ( int indxOrigSegs = 0 ; \npathSegments . length > indxOrigSegs ; \nindxOrigSegs ++ ) { \nString s = pathSegments [ indxOrigSegs ] ; \nif ( s . equals ( \".\" ) ) continue ; \nelse if ( s . equals ( \"..\" ) ) { \nif ( i == 0 ) return false ; \ni -- ; \n} \nelse { \ni ++ ; \n} \n} \nreturn true ; \n} \n} \n"}
{"5809": "public class StringValidateEncodeUtils { \npublic static String unicodeCodePoint2PercentHexString ( int codePoint , String charsetName ) { \nif ( ! Character . isDefined ( codePoint ) ) throw new IllegalArgumentException ( String . format ( \"Given code point [U+%1$04X - %1$d] not assigned to an abstract character.\" , codePoint ) ) ; \nif ( Character . getType ( codePoint ) == Character . SURROGATE ) throw new IllegalArgumentException ( String . format ( \"Given code point [U+%1$04X - %1$d] is an unencodable (by itself) surrogate character.\" , codePoint ) ) ; \nCharset charset = Charset . availableCharsets ( ) . get ( charsetName ) ; \nif ( charset == null ) throw new IllegalArgumentException ( String . format ( \"Unsupported charset [%s].\" , charsetName ) ) ; \nchar [ ] chars = Character . toChars ( codePoint ) ; \nByteBuffer byteBuffer = null ; \ntry { \nbyteBuffer = charset . newEncoder ( ) . encode ( CharBuffer . wrap ( chars ) ) ; \n} \ncatch ( CharacterCodingException e ) { \nString message = String . format ( \"Given code point [U+%1$04X - %1$d] cannot be encode in given charset [%2$s].\" , codePoint , charsetName ) ; \nthrow new IllegalArgumentException ( message , e ) ; \n} \nbyteBuffer . rewind ( ) ; \nStringBuilder encodedString = new StringBuilder ( ) ; \nfor ( int i = 0 ; \nbyteBuffer . limit ( ) > i ; \ni ++ ) { \nString asHex = Integer . toHexString ( byteBuffer . get ( ) & 0xFF ) ; \nencodedString . append ( \"%\" ) . append ( asHex . length ( ) == 1 ? \"0\" : \"\" ) . append ( asHex ) ; \n} \nreturn encodedString . toString ( ) ; \n} \n} \n"}
{"5812": "public class MessageBroker { \npublic void process ( InputStream is ) throws IOException { \nint pos = - 1 ; \nBuffer b = null ; \nwhile ( true ) { \nb = ( 0 > pos ) ? readBuffer ( is ) : readBuffer ( is , b , pos ) ; \npos = process ( b , is ) ; \nif ( b . done ) break ; \n} \n} \n} \n"}
{"5813": "public class MessageBroker { \nprivate int process ( Buffer b , InputStream is ) throws IOException { \nint start = 0 ; \nwhile ( b . have > start ) { \nint matchPos = matcher . indexOf ( b . buff , start , b . have - start ) ; \nif ( 0 > matchPos ) { \nif ( start == 0 ) return b . have - 3 ; \nelse return start ; \n} \nif ( b . have <= matchPos + 6 ) { \nreturn start ; \n} \nint b1 = ( b . buff [ matchPos + 4 ] & 0xff ) ; \nint b2 = ( b . buff [ matchPos + 5 ] & 0xff ) ; \nint b3 = ( b . buff [ matchPos + 6 ] & 0xff ) ; \nint messLen = b1 << 16 | b2 << 8 | b3 ; \nMessageTask task = new MessageTask ( messLen ) ; \ntask . header = extractHeader ( start , matchPos , b ) ; \nint last = matchPos + messLen ; \nif ( b . have < last ) { \ntask . have = b . have - matchPos ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \nif ( ! readBuffer ( is , task . mess , task . have , task . len - task . have ) ) { \nSystem . out . println ( \"Failed to read remaining BUFR message\" ) ; \nbreak ; \n} \n} \nelse { \ntask . have = task . len ; \nSystem . arraycopy ( b . buff , matchPos , task . mess , 0 , task . have ) ; \n} \nboolean ok = true ; \nfor ( int i = task . len - 4 ; \ntask . len > i ; \ni ++ ) { \nint bb = task . mess [ i ] ; \nif ( bb != 55 ) { \nok = false ; \nbad_msgs ++ ; \n} \n} \ntry { \nif ( ok ) messQ . put ( task ) ; \ntotal_msgs ++ ; \n} \ncatch ( InterruptedException e ) { \nSystem . out . println ( \" interrupted queue put - assume process exit\" ) ; \nbreak ; \n} \nstart = matchPos + messLen + 1 ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5815": "public class Ceparse { \nvoid markStackedVariables ( Stack s ) { \nStack bts = new Stack ( ) ; \nwhile ( ! s . empty ( ) ) { \nbts . push ( s . pop ( ) ) ; \n} \nwhile ( 1 < bts . size ( ) ) { \nServerMethods ct = ( ServerMethods ) bts . pop ( ) ; \nct . setProject ( true , false ) ; \n} \nServerMethods bt = ( ServerMethods ) bts . pop ( ) ; \nbt . setProject ( true , true ) ; \n} \n} \n"}
{"5820": "public class ResultService { \nprotected boolean validate ( StringBuilder out ) { \nthis . isValid = true ; \nif ( 0 < this . log . length ( ) ) { \nout . append ( this . log ) ; \n} \nif ( this . getAccessPointHeader ( ) == null ) { \nthis . isValid = false ; \nout . append ( \" ** ResultService (1): a null 'accessPointHeader' is invalid.\" ) ; \n} \nreturn ( this . isValid ) ; \n} \n} \n"}
{"5823": "public class DoradeSWIB { \npublic float [ ] getLatitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] lats = new float [ nRays ] ; \nfor ( int i = 0 ; \nnRays > i ; \ni ++ ) lats [ i ] = myASIBs [ i ] . getLatitude ( ) ; \nreturn lats ; \n} \n} \n"}
{"5824": "public class DoradeSWIB { \npublic float [ ] getLongitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] lons = new float [ nRays ] ; \nfor ( int i = 0 ; \nnRays > i ; \ni ++ ) lons [ i ] = myASIBs [ i ] . getLongitude ( ) ; \nreturn lons ; \n} \n} \n"}
{"5825": "public class DoradeSWIB { \npublic float [ ] getAltitudes ( ) { \nif ( myASIBs == null ) return null ; \nfloat [ ] alts = new float [ nRays ] ; \nfor ( int i = 0 ; \nnRays > i ; \ni ++ ) alts [ i ] = myASIBs [ i ] . getAltitude ( ) ; \nreturn alts ; \n} \n} \n"}
{"5826": "public class DoradeSWIB { \npublic float [ ] getAzimuths ( ) { \nif ( azimuths == null ) { \nazimuths = new float [ nRays ] ; \nfor ( int r = 0 ; \nnRays > r ; \nr ++ ) { \nazimuths [ r ] = myRYIBs [ r ] . getAzimuth ( ) ; \n} \n} \nreturn azimuths ; \n} \n} \n"}
{"5827": "public class DoradeSWIB { \npublic float [ ] getElevations ( ) { \nif ( elevations == null ) { \nelevations = new float [ nRays ] ; \nfor ( int r = 0 ; \nnRays > r ; \nr ++ ) { \nelevations [ r ] = myRYIBs [ r ] . getElevation ( ) ; \n} \n} \nreturn elevations ; \n} \n} \n"}
{"5834": "public class Structure { \npublic StructureData readStructure ( int index ) throws IOException , ucar . ma2 . InvalidRangeException { \nSection section = null ; \nif ( getRank ( ) == 1 ) { \nsection = new Section ( ) . appendRange ( index , index ) ; \n} \nelse if ( 1 < getRank ( ) ) { \nIndex ii = Index . factory ( shape ) ; \nii . setCurrentCounter ( index ) ; \nint [ ] origin = ii . getCurrentCounter ( ) ; \nsection = new Section ( ) ; \nfor ( int anOrigin : origin ) section . appendRange ( anOrigin , anOrigin ) ; \n} \nArray dataArray = read ( section ) ; \nArrayStructure data = ( ArrayStructure ) dataArray ; \nreturn data . getStructureData ( 0 ) ; \n} \n} \n"}
{"5836": "public class Structure { \npublic StructureDataIterator getStructureIterator ( int bufferSize ) throws java . io . IOException { \nreturn ( 2 > getRank ( ) ) ? new Structure . IteratorRank1 ( bufferSize ) : new Structure . Iterator ( bufferSize ) ; \n} \n} \n"}
{"5838": "public class ProjectionImpl { \npublic String getClassName ( ) { \nString className = getClass ( ) . getName ( ) ; \nint index = className . lastIndexOf ( \".\" ) ; \nif ( 0 <= index ) { \nclassName = className . substring ( index + 1 ) ; \n} \nreturn className ; \n} \n} \n"}
{"5842": "public class CF1Convention { \npublic static int getVersion ( String hasConvName ) { \nint result = extractVersion ( hasConvName ) ; \nif ( 0 <= result ) return result ; \nList < String > names = breakupConventionNames ( hasConvName ) ; \nfor ( String name : names ) { \nresult = extractVersion ( name ) ; \nif ( 0 <= result ) return result ; \n} \nreturn - 1 ; \n} \n} \n"}
{"5849": "public class TableAligner { \npublic static void installInAllColumns ( JTable table , int alignment ) { \nfor ( int colViewIndex = 0 ; \ntable . getColumnCount ( ) > colViewIndex ; \n++ colViewIndex ) { \ninstallInOneColumn ( table , colViewIndex , alignment ) ; \n} \n} \n} \n"}
{"5855": "public class CoreSocketFactory { \nprivate static List < String > listIpTypes ( String cloudSqlIpTypes ) { \nString [ ] rawTypes = cloudSqlIpTypes . split ( \",\" ) ; \nArrayList < String > result = new ArrayList < > ( rawTypes . length ) ; \nfor ( int i = 0 ; \nrawTypes . length > i ; \ni ++ ) { \nif ( rawTypes [ i ] . trim ( ) . equalsIgnoreCase ( \"PUBLIC\" ) ) { \nresult . add ( i , \"PRIMARY\" ) ; \n} \nelse { \nresult . add ( i , rawTypes [ i ] . trim ( ) . toUpperCase ( ) ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"5858": "public class InMemoryJavaCompiler { \npublic Map < String , Class < ? > > compileAll ( ) throws Exception { \nif ( sourceCodes . size ( ) == 0 ) { \nthrow new CompilationException ( \"No source code to compile\" ) ; \n} \nCollection < SourceCode > compilationUnits = sourceCodes . values ( ) ; \nCompiledCode [ ] code ; \ncode = new CompiledCode [ compilationUnits . size ( ) ] ; \nIterator < SourceCode > iter = compilationUnits . iterator ( ) ; \nfor ( int i = 0 ; \ncode . length > i ; \ni ++ ) { \ncode [ i ] = new CompiledCode ( iter . next ( ) . getClassName ( ) ) ; \n} \nDiagnosticCollector < JavaFileObject > collector = new DiagnosticCollector < > ( ) ; \nExtendedStandardJavaFileManager fileManager = new ExtendedStandardJavaFileManager ( javac . getStandardFileManager ( null , null , null ) , classLoader ) ; \nJavaCompiler . CompilationTask task = javac . getTask ( null , fileManager , collector , options , null , compilationUnits ) ; \nboolean result = task . call ( ) ; \nif ( ! result || 0 < collector . getDiagnostics ( ) . size ( ) ) { \nStringBuffer exceptionMsg = new StringBuffer ( ) ; \nexceptionMsg . append ( \"Unable to compile the source\" ) ; \nboolean hasWarnings = false ; \nboolean hasErrors = false ; \nfor ( Diagnostic < ? extends JavaFileObject > d : collector . getDiagnostics ( ) ) { \nswitch ( d . getKind ( ) ) { \ncase NOTE : case MANDATORY_WARNING : case WARNING : hasWarnings = true ; \nbreak ; \ncase OTHER : case ERROR : default : hasErrors = true ; \nbreak ; \n} \nexceptionMsg . append ( \"\\n\" ) . append ( \"[kind=\" ) . append ( d . getKind ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"line=\" ) . append ( d . getLineNumber ( ) ) ; \nexceptionMsg . append ( \", \" ) . append ( \"message=\" ) . append ( d . getMessage ( Locale . US ) ) . append ( \"]\" ) ; \n} \nif ( hasWarnings && ! ignoreWarnings || hasErrors ) { \nthrow new CompilationException ( exceptionMsg . toString ( ) ) ; \n} \n} \nMap < String , Class < ? > > classes = new HashMap < String , Class < ? > > ( ) ; \nfor ( String className : sourceCodes . keySet ( ) ) { \nclasses . put ( className , classLoader . loadClass ( className ) ) ; \n} \nreturn classes ; \n} \n} \n"}
{"5861": "public class GifHeaderParser { \nprivate void readGraphicControlExt ( ) { \nread ( ) ; \nint packed = read ( ) ; \nheader . currentFrame . dispose = ( packed & 0x1c ) >> 2 ; \nif ( header . currentFrame . dispose == 0 ) { \nheader . currentFrame . dispose = 1 ; \n} \nheader . currentFrame . transparency = ( packed & 1 ) != 0 ; \nint delayInHundredthsOfASecond = readShort ( ) ; \nif ( MIN_FRAME_DELAY > delayInHundredthsOfASecond ) { \ndelayInHundredthsOfASecond = DEFAULT_FRAME_DELAY ; \n} \nheader . currentFrame . delay = delayInHundredthsOfASecond * 10 ; \nheader . currentFrame . transIndex = read ( ) ; \nread ( ) ; \n} \n} \n"}
{"5862": "public class GifDecoder { \nsynchronized Bitmap getNextFrame ( ) { \nif ( 0 >= header . frameCount || 0 > framePointer ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) { \nLog . d ( TAG , \"unable to decode frame, frameCount=\" + header . frameCount + \" framePointer=\" + framePointer ) ; \n} \nstatus = STATUS_FORMAT_ERROR ; \n} \nif ( status == STATUS_FORMAT_ERROR || status == STATUS_OPEN_ERROR ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) { \nLog . d ( TAG , \"Unable to decode frame, status=\" + status ) ; \n} \nreturn null ; \n} \nstatus = STATUS_OK ; \nGifFrame currentFrame = header . frames . get ( framePointer ) ; \nGifFrame previousFrame = null ; \nint previousIndex = framePointer - 1 ; \nif ( 0 <= previousIndex ) { \npreviousFrame = header . frames . get ( previousIndex ) ; \n} \nact = currentFrame . lct != null ? currentFrame . lct : header . gct ; \nif ( act == null ) { \nif ( Log . isLoggable ( TAG , Log . DEBUG ) ) { \nLog . d ( TAG , \"No Valid Color Table for frame #\" + framePointer ) ; \n} \nstatus = STATUS_FORMAT_ERROR ; \nreturn null ; \n} \nif ( currentFrame . transparency ) { \nSystem . arraycopy ( act , 0 , pct , 0 , act . length ) ; \nact = pct ; \nact [ currentFrame . transIndex ] = 0 ; \n} \nreturn setPixels ( currentFrame , previousFrame ) ; \n} \n} \n"}
{"5893": "public class GeoPackageCursorFactory { \npublic void registerTable ( String tableName , GeoPackageCursorWrapper cursorWrapper ) { \ntableCursors . remove ( tableName ) ; \ntableCursors . put ( tableName , cursorWrapper ) ; \nString quotedTableName = CoreSQLUtils . quoteWrap ( tableName ) ; \ntableCursors . put ( quotedTableName , cursorWrapper ) ; \nint spacePosition = tableName . indexOf ( ' ' ) ; \nif ( 0 < spacePosition ) { \ntableCursors . put ( tableName . substring ( 0 , spacePosition ) , cursorWrapper ) ; \ntableCursors . put ( quotedTableName . substring ( 0 , quotedTableName . indexOf ( ' ' ) ) , cursorWrapper ) ; \n} \n} \n} \n"}
{"5900": "public class CoverageData { \nprivate CoverageDataTileMatrixResults getResultsZoomIn ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { \nCoverageDataTileMatrixResults results = null ; \nfor ( long zoomLevel = tileMatrix . getZoomLevel ( ) + 1 ; \ntileDao . getMaxZoom ( ) >= zoomLevel ; \nzoomLevel ++ ) { \nTileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; \nif ( zoomTileMatrix != null ) { \nresults = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; \nif ( results != null ) { \nbreak ; \n} \n} \n} \nreturn results ; \n} \n} \n"}
{"5901": "public class CoverageData { \nprivate CoverageDataTileMatrixResults getResultsZoomOut ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { \nCoverageDataTileMatrixResults results = null ; \nfor ( long zoomLevel = tileMatrix . getZoomLevel ( ) - 1 ; \ntileDao . getMinZoom ( ) <= zoomLevel ; \nzoomLevel -- ) { \nTileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; \nif ( zoomTileMatrix != null ) { \nresults = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; \nif ( results != null ) { \nbreak ; \n} \n} \n} \nreturn results ; \n} \n} \n"}
{"5910": "public class TableMetadataDataSource { \npublic boolean delete ( long geoPackageId , String tableName ) { \nGeometryMetadataDataSource geomDs = new GeometryMetadataDataSource ( db ) ; \ngeomDs . delete ( geoPackageId , tableName ) ; \nString whereClause = TableMetadata . COLUMN_GEOPACKAGE_ID + \" = ? AND \" + TableMetadata . COLUMN_TABLE_NAME + \" = ?\" ; \nString [ ] whereArgs = new String [ ] { \nString . valueOf ( geoPackageId ) , tableName } \n; \nint deleteCount = db . delete ( TableMetadata . TABLE_NAME , whereClause , whereArgs ) ; \nreturn 0 < deleteCount ; \n} \n} \n"}
{"5925": "public class ManualFeatureQuery { \npublic ManualFeatureQueryResults query ( double minX , double minY , double maxX , double maxY ) { \nList < Long > featureIds = new ArrayList < > ( ) ; \nlong offset = 0 ; \nboolean hasResults = true ; \nminX -= tolerance ; \nmaxX += tolerance ; \nminY -= tolerance ; \nmaxY += tolerance ; \nwhile ( hasResults ) { \nhasResults = false ; \nFeatureCursor featureCursor = featureDao . queryForChunk ( chunkLimit , offset ) ; \ntry { \nwhile ( featureCursor . moveToNext ( ) ) { \nhasResults = true ; \nFeatureRow featureRow = featureCursor . getRow ( ) ; \nGeometryEnvelope envelope = featureRow . getGeometryEnvelope ( ) ; \nif ( envelope != null ) { \ndouble minXMax = Math . max ( minX , envelope . getMinX ( ) ) ; \ndouble maxXMin = Math . min ( maxX , envelope . getMaxX ( ) ) ; \ndouble minYMax = Math . max ( minY , envelope . getMinY ( ) ) ; \ndouble maxYMin = Math . min ( maxY , envelope . getMaxY ( ) ) ; \nif ( maxXMin >= minXMax && maxYMin >= minYMax ) { \nfeatureIds . add ( featureRow . getId ( ) ) ; \n} \n} \n} \n} \nfinally { \nfeatureCursor . close ( ) ; \n} \noffset += chunkLimit ; \n} \nManualFeatureQueryResults results = new ManualFeatureQueryResults ( featureDao , featureIds ) ; \nreturn results ; \n} \n} \n"}
{"5930": "public class TileGenerator { \npublic int getTileCount ( ) { \nif ( tileCount == null ) { \nlong count = 0 ; \nboolean degrees = projection . isUnit ( Units . DEGREES ) ; \nProjectionTransform transformToWebMercator = null ; \nif ( ! degrees ) { \ntransformToWebMercator = projection . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; \n} \nfor ( int zoom = minZoom ; \nmaxZoom >= zoom ; \nzoom ++ ) { \nBoundingBox expandedBoundingBox = getBoundingBox ( zoom ) ; \nTileGrid tileGrid = null ; \nif ( degrees ) { \ntileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( expandedBoundingBox , zoom ) ; \n} \nelse { \ntileGrid = TileBoundingBoxUtils . getTileGrid ( expandedBoundingBox . transform ( transformToWebMercator ) , zoom ) ; \n} \ncount += tileGrid . count ( ) ; \ntileGrids . put ( zoom , tileGrid ) ; \ntileBounds . put ( zoom , expandedBoundingBox ) ; \n} \ntileCount = ( int ) Math . min ( count , Integer . MAX_VALUE ) ; \n} \nreturn tileCount ; \n} \n} \n"}
{"5944": "public class TileDao { \npublic boolean isGoogleTiles ( ) { \nBoundingBox boundingBox = tileMatrixSet . getBoundingBox ( ) ; \nBoundingBox wgs84BoundingBox = boundingBox . transform ( projection . getTransformation ( ProjectionConstants . EPSG_WORLD_GEODETIC_SYSTEM ) ) ; \nboolean googleTiles = false ; \nif ( ProjectionConstants . WEB_MERCATOR_MIN_LAT_RANGE >= wgs84BoundingBox . getMinLatitude ( ) && ProjectionConstants . WEB_MERCATOR_MAX_LAT_RANGE <= wgs84BoundingBox . getMaxLatitude ( ) && - ProjectionConstants . WGS84_HALF_WORLD_LON_WIDTH >= wgs84BoundingBox . getMinLongitude ( ) && ProjectionConstants . WGS84_HALF_WORLD_LON_WIDTH <= wgs84BoundingBox . getMaxLongitude ( ) ) { \ngoogleTiles = true ; \nfor ( TileMatrix tileMatrix : tileMatrices ) { \nlong zoomLevel = tileMatrix . getZoomLevel ( ) ; \nlong tilesPerSide = TileBoundingBoxUtils . tilesPerSide ( ( int ) zoomLevel ) ; \nif ( tileMatrix . getMatrixWidth ( ) != tilesPerSide || tileMatrix . getMatrixHeight ( ) != tilesPerSide ) { \ngoogleTiles = false ; \nbreak ; \n} \n} \n} \nreturn googleTiles ; \n} \n} \n"}
{"5946": "public class CoverageDataTiff { \npublic float [ ] getPixelValues ( byte [ ] imageBytes ) { \nTIFFImage tiffImage = TiffReader . readTiff ( imageBytes ) ; \nFileDirectory directory = tiffImage . getFileDirectory ( ) ; \nvalidateImageType ( directory ) ; \nRasters rasters = directory . readRasters ( ) ; \nfloat [ ] pixels = new float [ rasters . getWidth ( ) * rasters . getHeight ( ) ] ; \nfor ( int y = 0 ; \nrasters . getHeight ( ) > y ; \ny ++ ) { \nfor ( int x = 0 ; \nrasters . getWidth ( ) > x ; \nx ++ ) { \nint index = rasters . getSampleIndex ( x , y ) ; \npixels [ index ] = rasters . getPixelSample ( 0 , x , y ) . floatValue ( ) ; \n} \n} \nreturn pixels ; \n} \n} \n"}
{"5974": "public class GeometryMetadataDataSource { \npublic boolean update ( GeometryMetadata metadata ) { \nString whereClause = GeometryMetadata . COLUMN_GEOPACKAGE_ID + \" = ? AND \" + GeometryMetadata . COLUMN_TABLE_NAME + \" = ? AND \" + GeometryMetadata . COLUMN_ID + \" = ?\" ; \nString [ ] whereArgs = new String [ ] { \nString . valueOf ( metadata . getGeoPackageId ( ) ) , metadata . getTableName ( ) , String . valueOf ( metadata . getId ( ) ) } \n; \nContentValues values = new ContentValues ( ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_X , metadata . getMinX ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_X , metadata . getMaxX ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_Y , metadata . getMinY ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_Y , metadata . getMaxY ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_Z , metadata . getMinZ ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_Z , metadata . getMaxZ ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MIN_M , metadata . getMinM ( ) ) ; \nvalues . put ( GeometryMetadata . COLUMN_MAX_M , metadata . getMaxM ( ) ) ; \nint updateCount = db . update ( GeometryMetadata . TABLE_NAME , values , whereClause , whereArgs ) ; \nreturn 0 < updateCount ; \n} \n} \n"}
{"5985": "public class RelatedTablesExtension { \npublic boolean hasMapping ( String tableName , long baseId , long relatedId ) { \nboolean has = false ; \nUserMappingDao userMappingDao = getMappingDao ( tableName ) ; \nUserCustomCursor cursor = userMappingDao . queryByIds ( baseId , relatedId ) ; \ntry { \nhas = 0 < cursor . getCount ( ) ; \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn has ; \n} \n} \n"}
{"5989": "public class TileCreator { \npublic GeoPackageTile getTile ( BoundingBox requestBoundingBox ) { \nGeoPackageTile tile = null ; \nProjectionTransform transformRequestToTiles = requestProjection . getTransformation ( tilesProjection ) ; \nBoundingBox tilesBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; \nList < TileMatrix > tileMatrices = getTileMatrices ( tilesBoundingBox ) ; \nfor ( int i = 0 ; \ntile == null && tileMatrices . size ( ) > i ; \ni ++ ) { \nTileMatrix tileMatrix = tileMatrices . get ( i ) ; \nTileCursor tileResults = retrieveTileResults ( tilesBoundingBox , tileMatrix ) ; \nif ( tileResults != null ) { \ntry { \nif ( 0 < tileResults . getCount ( ) ) { \nBoundingBox requestProjectedBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; \nint requestedTileWidth = width != null ? width : ( int ) tileMatrix . getTileWidth ( ) ; \nint requestedTileHeight = height != null ? height : ( int ) tileMatrix . getTileHeight ( ) ; \nint tileWidth = requestedTileWidth ; \nint tileHeight = requestedTileHeight ; \nif ( ! sameProjection ) { \ntileWidth = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLongitude ( ) - requestProjectedBoundingBox . getMinLongitude ( ) ) / tileMatrix . getPixelXSize ( ) ) ; \ntileHeight = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLatitude ( ) - requestProjectedBoundingBox . getMinLatitude ( ) ) / tileMatrix . getPixelYSize ( ) ) ; \n} \nBitmap tileBitmap = drawTile ( tileMatrix , tileResults , requestProjectedBoundingBox , tileWidth , tileHeight ) ; \nif ( tileBitmap != null ) { \nif ( ! sameProjection ) { \nBitmap reprojectTile = reprojectTile ( tileBitmap , requestedTileWidth , requestedTileHeight , requestBoundingBox , transformRequestToTiles , tilesBoundingBox ) ; \ntileBitmap . recycle ( ) ; \ntileBitmap = reprojectTile ; \n} \ntry { \nbyte [ ] tileData = BitmapConverter . toBytes ( tileBitmap , COMPRESS_FORMAT ) ; \ntileBitmap . recycle ( ) ; \ntile = new GeoPackageTile ( requestedTileWidth , requestedTileHeight , tileData ) ; \n} \ncatch ( IOException e ) { \nLog . e ( TileCreator . class . getSimpleName ( ) , \"Failed to create tile. min lat: \" + requestBoundingBox . getMinLatitude ( ) + \", max lat: \" + requestBoundingBox . getMaxLatitude ( ) + \", min lon: \" + requestBoundingBox . getMinLongitude ( ) + \", max lon: \" + requestBoundingBox . getMaxLongitude ( ) , e ) ; \n} \n} \n} \n} \nfinally { \ntileResults . close ( ) ; \n} \n} \n} \nreturn tile ; \n} \n} \n"}
{"5991": "public class TileCreator { \nprivate Bitmap reprojectTile ( Bitmap tile , int requestedTileWidth , int requestedTileHeight , BoundingBox requestBoundingBox , ProjectionTransform transformRequestToTiles , BoundingBox tilesBoundingBox ) { \nfinal double requestedWidthUnitsPerPixel = ( requestBoundingBox . getMaxLongitude ( ) - requestBoundingBox . getMinLongitude ( ) ) / requestedTileWidth ; \nfinal double requestedHeightUnitsPerPixel = ( requestBoundingBox . getMaxLatitude ( ) - requestBoundingBox . getMinLatitude ( ) ) / requestedTileHeight ; \nfinal double tilesDistanceWidth = tilesBoundingBox . getMaxLongitude ( ) - tilesBoundingBox . getMinLongitude ( ) ; \nfinal double tilesDistanceHeight = tilesBoundingBox . getMaxLatitude ( ) - tilesBoundingBox . getMinLatitude ( ) ; \nfinal int width = tile . getWidth ( ) ; \nfinal int height = tile . getHeight ( ) ; \nint [ ] pixels = new int [ width * height ] ; \ntile . getPixels ( pixels , 0 , width , 0 , 0 , width , height ) ; \nint [ ] projectedPixels = new int [ requestedTileWidth * requestedTileHeight ] ; \nfor ( int y = 0 ; \nrequestedTileHeight > y ; \ny ++ ) { \nfor ( int x = 0 ; \nrequestedTileWidth > x ; \nx ++ ) { \ndouble longitude = requestBoundingBox . getMinLongitude ( ) + ( x * requestedWidthUnitsPerPixel ) ; \ndouble latitude = requestBoundingBox . getMaxLatitude ( ) - ( y * requestedHeightUnitsPerPixel ) ; \nProjCoordinate fromCoord = new ProjCoordinate ( longitude , latitude ) ; \nProjCoordinate toCoord = transformRequestToTiles . transform ( fromCoord ) ; \ndouble projectedLongitude = toCoord . x ; \ndouble projectedLatitude = toCoord . y ; \nint xPixel = ( int ) Math . round ( ( ( projectedLongitude - tilesBoundingBox . getMinLongitude ( ) ) / tilesDistanceWidth ) * width ) ; \nint yPixel = ( int ) Math . round ( ( ( tilesBoundingBox . getMaxLatitude ( ) - projectedLatitude ) / tilesDistanceHeight ) * height ) ; \nxPixel = Math . max ( 0 , xPixel ) ; \nxPixel = Math . min ( width - 1 , xPixel ) ; \nyPixel = Math . max ( 0 , yPixel ) ; \nyPixel = Math . min ( height - 1 , yPixel ) ; \nint color = pixels [ ( yPixel * width ) + xPixel ] ; \nprojectedPixels [ ( y * requestedTileWidth ) + x ] = color ; \n} \n} \nBitmap projectedTileBitmap = Bitmap . createBitmap ( requestedTileWidth , requestedTileHeight , tile . getConfig ( ) ) ; \nprojectedTileBitmap . setPixels ( projectedPixels , 0 , requestedTileWidth , 0 , 0 , requestedTileWidth , requestedTileHeight ) ; \nreturn projectedTileBitmap ; \n} \n} \n"}
{"5999": "public class FeatureTiles { \npublic Bitmap drawTileQueryIndex ( int x , int y , int zoom ) { \nBoundingBox webMercatorBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; \nBitmap bitmap = null ; \nFeatureIndexResults results = queryIndexedFeatures ( webMercatorBoundingBox ) ; \ntry { \nlong tileCount = results . count ( ) ; \nif ( 0 < tileCount ) { \nif ( maxFeaturesPerTile == null || maxFeaturesPerTile . longValue ( ) >= tileCount ) { \nbitmap = drawTile ( zoom , webMercatorBoundingBox , results ) ; \n} \nelse if ( maxFeaturesTileDraw != null ) { \nbitmap = maxFeaturesTileDraw . drawTile ( tileWidth , tileHeight , tileCount , results ) ; \n} \n} \n} \nfinally { \nresults . close ( ) ; \n} \nreturn bitmap ; \n} \n} \n"}
{"6004": "public class FeatureTiles { \npublic Bitmap drawTileQueryAll ( int x , int y , int zoom ) { \nBoundingBox boundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; \nBitmap bitmap = null ; \nFeatureCursor cursor = featureDao . queryForAll ( ) ; \ntry { \nint totalCount = cursor . getCount ( ) ; \nif ( 0 < totalCount ) { \nif ( maxFeaturesPerTile == null || maxFeaturesPerTile >= totalCount ) { \nbitmap = drawTile ( zoom , boundingBox , cursor ) ; \n} \nelse if ( maxFeaturesTileDraw != null ) { \nbitmap = maxFeaturesTileDraw . drawUnindexedTile ( tileWidth , tileHeight , totalCount , cursor ) ; \n} \n} \n} \nfinally { \ncursor . close ( ) ; \n} \nreturn bitmap ; \n} \n} \n"}
{"6017": "public class FeatureTileCanvas { \npublic Bitmap createBitmap ( ) { \nBitmap bitmap = null ; \nCanvas canvas = null ; \nfor ( int layer = 0 ; \n4 > layer ; \nlayer ++ ) { \nBitmap layerBitmap = layeredBitmap [ layer ] ; \nif ( layerBitmap != null ) { \nif ( bitmap == null ) { \nbitmap = layerBitmap ; \ncanvas = layeredCanvas [ layer ] ; \n} \nelse { \ncanvas . drawBitmap ( layerBitmap , new Matrix ( ) , null ) ; \nlayerBitmap . recycle ( ) ; \n} \nlayeredBitmap [ layer ] = null ; \nlayeredCanvas [ layer ] = null ; \n} \n} \nreturn bitmap ; \n} \n} \n"}
{"6018": "public class FeatureTileCanvas { \npublic void recycle ( ) { \nfor ( int layer = 0 ; \n4 > layer ; \nlayer ++ ) { \nBitmap bitmap = layeredBitmap [ layer ] ; \nif ( bitmap != null ) { \nbitmap . recycle ( ) ; \nlayeredBitmap [ layer ] = null ; \nlayeredCanvas [ layer ] = null ; \n} \n} \n} \n} \n"}
{"6070": "public class DefaultFeatureTiles { \nprivate void addLineString ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , LineString lineString ) { \nList < Point > points = lineString . getPoints ( ) ; \nif ( 2 <= points . size ( ) ) { \npoints = simplifyPoints ( simplifyTolerance , points ) ; \nfor ( int i = 0 ; \npoints . size ( ) > i ; \ni ++ ) { \nPoint point = points . get ( i ) ; \nPoint webMercatorPoint = transform . transform ( point ) ; \nfloat x = TileBoundingBoxUtils . getXPixel ( tileWidth , boundingBox , webMercatorPoint . getX ( ) ) ; \nfloat y = TileBoundingBoxUtils . getYPixel ( tileHeight , boundingBox , webMercatorPoint . getY ( ) ) ; \nif ( i == 0 ) { \npath . moveTo ( x , y ) ; \n} \nelse { \npath . lineTo ( x , y ) ; \n} \n} \n} \n} \n} \n"}
{"6071": "public class DefaultFeatureTiles { \nprivate void addPolygon ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , Polygon polygon ) { \nList < LineString > rings = polygon . getRings ( ) ; \nif ( ! rings . isEmpty ( ) ) { \nLineString polygonLineString = rings . get ( 0 ) ; \nList < Point > polygonPoints = polygonLineString . getPoints ( ) ; \nif ( 2 <= polygonPoints . size ( ) ) { \naddRing ( simplifyTolerance , boundingBox , transform , path , polygonPoints ) ; \nfor ( int i = 1 ; \nrings . size ( ) > i ; \ni ++ ) { \nLineString holeLineString = rings . get ( i ) ; \nList < Point > holePoints = holeLineString . getPoints ( ) ; \nif ( 2 <= holePoints . size ( ) ) { \naddRing ( simplifyTolerance , boundingBox , transform , path , holePoints ) ; \n} \n} \n} \n} \n} \n} \n"}
{"6078": "public class IconRow { \npublic void setWidth ( Double width ) { \nif ( width != null && 0.0 > width ) { \nthrow new GeoPackageException ( \"Width must be greater than or equal to 0.0, invalid value: \" + width ) ; \n} \nsetValue ( getWidthColumnIndex ( ) , width ) ; \n} \n} \n"}
{"6079": "public class IconRow { \npublic void setHeight ( Double height ) { \nif ( height != null && 0.0 > height ) { \nthrow new GeoPackageException ( \"Height must be greater than or equal to 0.0, invalid value: \" + height ) ; \n} \nsetValue ( getHeightColumnIndex ( ) , height ) ; \n} \n} \n"}
{"6082": "public class UserInvalidCursor { \nprivate void readBlobValue ( UserRow row , UserColumn column ) { \nByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; \ntry { \nbyte [ ] blobChunk = new byte [ ] { \n0 } \n; \nfor ( int i = 1 ; \n0 < blobChunk . length ; \ni += CHUNK_SIZE ) { \nif ( 1 < i ) { \nbyteStream . write ( blobChunk ) ; \n} \nblobChunk = new byte [ ] { \n} \n; \nString query = \"select substr(\" + CoreSQLUtils . quoteWrap ( column . getName ( ) ) + \", \" + i + \", \" + CHUNK_SIZE + \") from \" + CoreSQLUtils . quoteWrap ( dao . getTableName ( ) ) + \" where \" + CoreSQLUtils . quoteWrap ( row . getPkColumn ( ) . getName ( ) ) + \" = \" + row . getId ( ) ; \nCursor blobCursor = dao . getDatabaseConnection ( ) . getDb ( ) . rawQuery ( query , null ) ; \ntry { \nif ( blobCursor . moveToNext ( ) ) { \nblobChunk = blobCursor . getBlob ( 0 ) ; \n} \n} \nfinally { \nblobCursor . close ( ) ; \n} \n} \nbyte [ ] blob = byteStream . toByteArray ( ) ; \nrow . setValue ( column . getIndex ( ) , blob ) ; \n} \ncatch ( IOException e ) { \nLog . e ( UserInvalidCursor . class . getSimpleName ( ) , \"Failed to read large blob value. Table: \" + dao . getTableName ( ) + \", Column: \" + column . getName ( ) + \", Position: \" + getPosition ( ) , e ) ; \n} \nfinally { \nIOUtils . closeQuietly ( byteStream ) ; \n} \n} \n} \n"}
{"6094": "public class FeatureIndexManager { \npublic boolean deleteIndex ( FeatureIndexType type , long geomId ) { \nif ( type == null ) { \nthrow new GeoPackageException ( \"FeatureIndexType is required to delete index\" ) ; \n} \nboolean deleted = false ; \nswitch ( type ) { \ncase GEOPACKAGE : deleted = 0 < featureTableIndex . deleteIndex ( geomId ) ; \nbreak ; \ncase METADATA : deleted = featureIndexer . deleteIndex ( geomId ) ; \nbreak ; \ncase RTREE : deleted = true ; \nbreak ; \ndefault : throw new GeoPackageException ( \"Unsupported FeatureIndexType: \" + type ) ; \n} \nreturn deleted ; \n} \n} \n"}
{"6139": "public class GeoPackageMetadataDataSource { \npublic boolean delete ( String database ) { \nGeoPackageMetadata metadata = get ( database ) ; \nif ( metadata != null ) { \nTableMetadataDataSource tableDs = new TableMetadataDataSource ( db ) ; \ntableDs . delete ( metadata . getId ( ) ) ; \n} \nString whereClause = GeoPackageMetadata . COLUMN_NAME + \" = ?\" ; \nString [ ] whereArgs = new String [ ] { \ndatabase } \n; \nint deleteCount = db . delete ( GeoPackageMetadata . TABLE_NAME , whereClause , whereArgs ) ; \nreturn 0 < deleteCount ; \n} \n} \n"}
{"6141": "public class GeoPackageMetadataDataSource { \npublic boolean rename ( String name , String newName ) { \nString whereClause = GeoPackageMetadata . COLUMN_NAME + \" = ?\" ; \nString [ ] whereArgs = new String [ ] { \nname } \n; \nContentValues values = new ContentValues ( ) ; \nvalues . put ( GeoPackageMetadata . COLUMN_NAME , newName ) ; \nint updateCount = db . update ( GeoPackageMetadata . TABLE_NAME , values , whereClause , whereArgs ) ; \nreturn 0 < updateCount ; \n} \n} \n"}
{"6153": "public class ParallaxContainer { \nprivate void addParallaxView ( View view , int pageIndex ) { \nif ( view instanceof ViewGroup ) { \nViewGroup viewGroup = ( ViewGroup ) view ; \nfor ( int i = 0 , childCount = viewGroup . getChildCount ( ) ; \nchildCount > i ; \ni ++ ) { \naddParallaxView ( viewGroup . getChildAt ( i ) , pageIndex ) ; \n} \n} \nParallaxViewTag tag = ( ParallaxViewTag ) view . getTag ( R . id . parallax_view_tag ) ; \nif ( tag != null ) { \ntag . index = pageIndex ; \nparallaxViews . add ( view ) ; \n} \n} \n} \n"}
{"6155": "public class ParallaxLayoutInflater { \nprivate View createCustomViewInternal ( View parent , View view , String name , Context context , AttributeSet attrs ) { \nif ( view == null && - 1 < name . indexOf ( '.' ) ) { \nif ( mConstructorArgs == null ) { \nmConstructorArgs = ReflectionUtils . getField ( LayoutInflater . class , \"mConstructorArgs\" ) ; \n} \nfinal Object [ ] mConstructorArgsArr = ( Object [ ] ) ReflectionUtils . getValue ( mConstructorArgs , this ) ; \nfinal Object lastContext = mConstructorArgsArr [ 0 ] ; \nmConstructorArgsArr [ 0 ] = parent != null ? parent . getContext ( ) : context ; \nReflectionUtils . setValue ( mConstructorArgs , this , mConstructorArgsArr ) ; \ntry { \nview = createView ( name , null , attrs ) ; \n} \ncatch ( ClassNotFoundException ignored ) { \n} \nfinally { \nmConstructorArgsArr [ 0 ] = lastContext ; \nReflectionUtils . setValue ( mConstructorArgs , this , mConstructorArgsArr ) ; \n} \n} \nreturn view ; \n} \n} \n"}
{"6161": "public class ServerSocketListener { \nprivate String socketAddressToString ( SocketAddress address ) { \nString addr = address . toString ( ) ; \nint i = addr . indexOf ( \"/\" ) ; \nif ( 0 <= i ) { \naddr = addr . substring ( i + 1 ) ; \n} \nreturn addr ; \n} \n} \n"}
{"6180": "public class OnErrorEvaluator { \npublic boolean evaluate ( ILoggingEvent event ) throws NullPointerException , EvaluationException { \nreturn Level . ERROR_INT <= event . getLevel ( ) . levelInt ; \n} \n} \n"}
{"6182": "public class ReconfigureOnChangeFilter { \nprivate void updateMaskIfNecessary ( long now ) { \nfinal long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck ; \nlastMaskCheck = now ; \nif ( MASK_INCREASE_THRESHOLD > timeElapsedSinceLastMaskUpdateCheck && ( MAX_MASK > mask ) ) { \nmask = ( mask << 1 ) | 1 ; \n} \nelse if ( MASK_DECREASE_THRESHOLD < timeElapsedSinceLastMaskUpdateCheck ) { \nmask = mask >>> 2 ; \n} \n} \n} \n"}
{"6183": "public class FilterAttachableImpl { \npublic FilterReply getFilterChainDecision ( E event ) { \nfinal Filter < E > [ ] filterArrray = filterList . asTypedArray ( ) ; \nfinal int len = filterArrray . length ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nfinal FilterReply r = filterArrray [ i ] . decide ( event ) ; \nif ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { \nreturn r ; \n} \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6191": "public class StatusPrinter { \npublic static void printInCaseOfErrorsOrWarnings ( Context context , long threshold ) { \nif ( context == null ) { \nthrow new IllegalArgumentException ( \"Context argument cannot be null\" ) ; \n} \nStatusManager sm = context . getStatusManager ( ) ; \nif ( sm == null ) { \nps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; \n} \nelse { \nStatusUtil statusUtil = new StatusUtil ( context ) ; \nif ( ErrorStatus . WARN <= statusUtil . getHighestLevel ( threshold ) ) { \nprint ( sm , threshold ) ; \n} \n} \n} \n} \n"}
{"6197": "public class FormatInfo { \npublic static FormatInfo valueOf ( String str ) throws IllegalArgumentException { \nif ( str == null ) { \nthrow new NullPointerException ( \"Argument cannot be null\" ) ; \n} \nFormatInfo fi = new FormatInfo ( ) ; \nint indexOfDot = str . indexOf ( '.' ) ; \nString minPart = null ; \nString maxPart = null ; \nif ( indexOfDot != - 1 ) { \nminPart = str . substring ( 0 , indexOfDot ) ; \nif ( indexOfDot + 1 == str . length ( ) ) { \nthrow new IllegalArgumentException ( \"Formatting string [\" + str + \"] should not end with '.'\" ) ; \n} \nelse { \nmaxPart = str . substring ( indexOfDot + 1 ) ; \n} \n} \nelse { \nminPart = str ; \n} \nif ( minPart != null && 0 < minPart . length ( ) ) { \nint min = Integer . parseInt ( minPart ) ; \nif ( 0 <= min ) { \nfi . min = min ; \n} \nelse { \nfi . min = - min ; \nfi . leftPad = false ; \n} \n} \nif ( maxPart != null && 0 < maxPart . length ( ) ) { \nint max = Integer . parseInt ( maxPart ) ; \nif ( 0 <= max ) { \nfi . max = max ; \n} \nelse { \nfi . max = - max ; \nfi . leftTruncate = false ; \n} \n} \nreturn fi ; \n} \n} \n"}
{"6204": "public class CallerData { \npublic static StackTraceElement [ ] extract ( Throwable t , String fqnOfInvokingClass , final int maxDepth , List < String > frameworkPackageList ) { \nif ( t == null ) { \nreturn null ; \n} \nStackTraceElement [ ] steArray = t . getStackTrace ( ) ; \nStackTraceElement [ ] callerDataArray ; \nint found = LINE_NA ; \nfor ( int i = 0 ; \nsteArray . length > i ; \ni ++ ) { \nif ( isInFrameworkSpace ( steArray [ i ] . getClassName ( ) , fqnOfInvokingClass , frameworkPackageList ) ) { \nfound = i + 1 ; \n} \nelse { \nif ( found != LINE_NA ) { \nbreak ; \n} \n} \n} \nif ( found == LINE_NA ) { \nreturn EMPTY_CALLER_DATA_ARRAY ; \n} \nint availableDepth = steArray . length - found ; \nint desiredDepth = ( availableDepth ) > maxDepth ? maxDepth : availableDepth ; \ncallerDataArray = new StackTraceElement [ desiredDepth ] ; \nfor ( int i = 0 ; \ndesiredDepth > i ; \ni ++ ) { \ncallerDataArray [ i ] = steArray [ found + i ] ; \n} \nreturn callerDataArray ; \n} \n} \n"}
{"6206": "public class BasicStatusManager { \npublic void add ( Status newStatus ) { \nfireStatusAddEvent ( newStatus ) ; \ncount ++ ; \nif ( level < newStatus . getLevel ( ) ) { \nlevel = newStatus . getLevel ( ) ; \n} \nsynchronized ( statusListLock ) { \nif ( MAX_HEADER_COUNT > statusList . size ( ) ) { \nstatusList . add ( newStatus ) ; \n} \nelse { \ntailBuffer . add ( newStatus ) ; \n} \n} \n} \n} \n"}
{"6208": "public class Interpreter { \nList < Action > lookupImplicitAction ( ElementPath elementPath , Attributes attributes , InterpretationContext ec ) { \nint len = implicitActions . size ( ) ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nImplicitAction ia = ( ImplicitAction ) implicitActions . get ( i ) ; \nif ( ia . isApplicable ( elementPath , attributes , ec ) ) { \nList < Action > actionList = new ArrayList < Action > ( 1 ) ; \nactionList . add ( ia ) ; \nreturn actionList ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6213": "public class Introspector { \nstatic public String decapitalize ( String name ) { \nif ( name == null || name . length ( ) == 0 ) { \nreturn name ; \n} \nelse { \nString nm = name . substring ( 0 , 1 ) . toLowerCase ( Locale . US ) ; \nif ( 1 < name . length ( ) ) { \nnm += name . substring ( 1 ) ; \n} \nreturn nm ; \n} \n} \n} \n"}
{"6215": "public class Introspector { \nstatic public PropertyDescriptor [ ] getPropertyDescriptors ( Class < ? > clazz ) { \nfinal String SETTER_PREFIX = \"set\" ; \nfinal String GETTER_PREFIX = \"get\" ; \nfinal int LEN_PREFIX = SETTER_PREFIX . length ( ) ; \nMap < String , PropertyDescriptor > map = new HashMap < String , PropertyDescriptor > ( ) ; \nfor ( Method m : clazz . getMethods ( ) ) { \nPropertyDescriptor pd = null ; \nString mName = m . getName ( ) ; \nboolean isGet = mName . startsWith ( GETTER_PREFIX ) && ( LEN_PREFIX < mName . length ( ) ) ; \nboolean isSet = mName . startsWith ( SETTER_PREFIX ) && ( LEN_PREFIX < mName . length ( ) ) ; \nif ( isGet || isSet ) { \nString propName = decapitalize ( mName . substring ( LEN_PREFIX ) ) ; \npd = map . get ( propName ) ; \nif ( pd == null ) { \npd = new PropertyDescriptor ( propName ) ; \nmap . put ( propName , pd ) ; \n} \nClass < ? > [ ] parmTypes = m . getParameterTypes ( ) ; \nif ( isSet ) { \nif ( parmTypes . length == 1 ) { \npd . setWriteMethod ( m ) ; \npd . setPropertyType ( parmTypes [ 0 ] ) ; \n} \n} \nelse if ( isGet ) { \nif ( parmTypes . length == 0 ) { \npd . setReadMethod ( m ) ; \nif ( pd . getPropertyType ( ) == null ) { \npd . setPropertyType ( m . getReturnType ( ) ) ; \n} \n} \n} \n} \n} \nreturn map . values ( ) . toArray ( new PropertyDescriptor [ 0 ] ) ; \n} \n} \n"}
{"6220": "public class AsyncAppender { \nprotected boolean isDiscardable ( ILoggingEvent event ) { \nLevel level = event . getLevel ( ) ; \nreturn Level . INFO_INT >= level . toInt ( ) ; \n} \n} \n"}
{"6231": "public class Logger { \nprivate synchronized void handleParentLevelChange ( int newParentLevelInt ) { \nif ( level == null ) { \neffectiveLevelInt = newParentLevelInt ; \nif ( childrenList != null ) { \nint len = childrenList . size ( ) ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nLogger child = ( Logger ) childrenList . get ( i ) ; \nchild . handleParentLevelChange ( newParentLevelInt ) ; \n} \n} \n} \n} \n} \n"}
{"6247": "public class LogcatAppender { \nprotected String getTag ( ILoggingEvent event ) { \nString tag = ( this . tagEncoder != null ) ? this . tagEncoder . getLayout ( ) . doLayout ( event ) : event . getLoggerName ( ) ; \nif ( checkLoggable && ( MAX_TAG_LENGTH < tag . length ( ) ) ) { \ntag = tag . substring ( 0 , MAX_TAG_LENGTH - 1 ) + \"*\" ; \n} \nreturn tag ; \n} \n} \n"}
{"6249": "public class LoggerNameUtil { \npublic static int getSeparatorIndexOf ( String name , int fromIndex ) { \nint dotIndex = name . indexOf ( CoreConstants . DOT , fromIndex ) ; \nint dollarIndex = name . indexOf ( CoreConstants . DOLLAR , fromIndex ) ; \nif ( dotIndex == - 1 && dollarIndex == - 1 ) return - 1 ; \nif ( dotIndex == - 1 ) return dollarIndex ; \nif ( dollarIndex == - 1 ) return dotIndex ; \nreturn dollarIndex > dotIndex ? dotIndex : dollarIndex ; \n} \n} \n"}
{"6254": "public class SMTPAppenderBase { \nprotected void append ( E eventObject ) { \nif ( ! checkEntryConditions ( ) ) { \nreturn ; \n} \nString key = discriminator . getDiscriminatingValue ( eventObject ) ; \nlong now = System . currentTimeMillis ( ) ; \nfinal CyclicBuffer < E > cb = cbTracker . getOrCreate ( key , now ) ; \nsubAppend ( cb , eventObject ) ; \ntry { \nif ( eventEvaluator . evaluate ( eventObject ) ) { \nCyclicBuffer < E > cbClone = new CyclicBuffer < E > ( cb ) ; \ncb . clear ( ) ; \nif ( asynchronousSending ) { \nSenderRunnable senderRunnable = new SenderRunnable ( cbClone , eventObject ) ; \ncontext . getScheduledExecutorService ( ) . execute ( senderRunnable ) ; \n} \nelse { \nsendBuffer ( cbClone , eventObject ) ; \n} \n} \n} \ncatch ( EvaluationException ex ) { \nerrorCount ++ ; \nif ( CoreConstants . MAX_ERROR_COUNT > errorCount ) { \naddError ( \"SMTPAppender's EventEvaluator threw an Exception-\" , ex ) ; \n} \n} \nif ( eventMarksEndOfLife ( eventObject ) ) { \ncbTracker . endOfLife ( key ) ; \n} \ncbTracker . removeStaleComponents ( now ) ; \nif ( now > lastTrackerStatusPrint + delayBetweenStatusMessages ) { \naddInfo ( \"SMTPAppender [\" + name + \"] is tracking [\" + cbTracker . getComponentCount ( ) + \"] buffers\" ) ; \nlastTrackerStatusPrint = now ; \nif ( MAX_DELAY_BETWEEN_STATUS_MESSAGES > delayBetweenStatusMessages ) { \ndelayBetweenStatusMessages *= 4 ; \n} \n} \n} \n} \n"}
{"6255": "public class SMTPAppenderBase { \nprotected void sendBuffer ( CyclicBuffer < E > cb , E lastEventObject ) { \ntry { \nMimeBodyPart part = new MimeBodyPart ( ) ; \nStringBuffer sbuf = new StringBuffer ( ) ; \nString header = layout . getFileHeader ( ) ; \nif ( header != null ) { \nsbuf . append ( header ) ; \n} \nString presentationHeader = layout . getPresentationHeader ( ) ; \nif ( presentationHeader != null ) { \nsbuf . append ( presentationHeader ) ; \n} \nfillBuffer ( cb , sbuf ) ; \nString presentationFooter = layout . getPresentationFooter ( ) ; \nif ( presentationFooter != null ) { \nsbuf . append ( presentationFooter ) ; \n} \nString footer = layout . getFileFooter ( ) ; \nif ( footer != null ) { \nsbuf . append ( footer ) ; \n} \nString subjectStr = \"Undefined subject\" ; \nif ( subjectLayout != null ) { \nsubjectStr = subjectLayout . doLayout ( lastEventObject ) ; \nint newLinePos = ( subjectStr != null ) ? subjectStr . indexOf ( '\\n' ) : - 1 ; \nif ( - 1 < newLinePos ) { \nsubjectStr = subjectStr . substring ( 0 , newLinePos ) ; \n} \n} \nMimeMessage mimeMsg = new MimeMessage ( session ) ; \nif ( from != null ) { \nmimeMsg . setFrom ( getAddress ( from ) ) ; \n} \nelse { \nmimeMsg . setFrom ( ) ; \n} \nmimeMsg . setSubject ( subjectStr , charsetEncoding ) ; \nList < InternetAddress > destinationAddresses = parseAddress ( lastEventObject ) ; \nif ( destinationAddresses . isEmpty ( ) ) { \naddInfo ( \"Empty destination address. Aborting email transmission\" ) ; \nreturn ; \n} \nInternetAddress [ ] toAddressArray = destinationAddresses . toArray ( EMPTY_IA_ARRAY ) ; \nmimeMsg . setRecipients ( Message . RecipientType . TO , toAddressArray ) ; \nString contentType = layout . getContentType ( ) ; \nif ( ContentTypeUtil . isTextual ( contentType ) ) { \npart . setText ( sbuf . toString ( ) , charsetEncoding , ContentTypeUtil . getSubType ( contentType ) ) ; \n} \nelse { \npart . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; \n} \nMultipart mp = new MimeMultipart ( ) ; \nmp . addBodyPart ( part ) ; \nmimeMsg . setContent ( mp ) ; \nupdateMimeMsg ( mimeMsg , cb , lastEventObject ) ; \nmimeMsg . setSentDate ( new Date ( ) ) ; \naddInfo ( \"About to send out SMTP message \\\"\" + subjectStr + \"\\\" to \" + Arrays . toString ( toAddressArray ) ) ; \nTransport . send ( mimeMsg ) ; \n} \ncatch ( Exception e ) { \naddError ( \"Error occurred while sending e-mail notification.\" , e ) ; \n} \n} \n} \n"}
{"6269": "public class StatusUtil { \npublic long timeOfLastReset ( ) { \nList < Status > statusList = sm . getCopyOfStatusList ( ) ; \nif ( statusList == null ) return - 1 ; \nint len = statusList . size ( ) ; \nfor ( int i = len - 1 ; \n0 <= i ; \ni -- ) { \nStatus s = statusList . get ( i ) ; \nif ( CoreConstants . RESET_MSG_PREFIX . equals ( s . getMessage ( ) ) ) { \nreturn s . getDate ( ) ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"6281": "public class TurboFilterList { \npublic FilterReply getTurboFilterChainDecision ( final Marker marker , final Logger logger , final Level level , final String format , final Object [ ] params , final Throwable t ) { \nfinal int size = size ( ) ; \nif ( size == 1 ) { \ntry { \nTurboFilter tf = get ( 0 ) ; \nreturn tf . decide ( marker , logger , level , format , params , t ) ; \n} \ncatch ( IndexOutOfBoundsException iobe ) { \nreturn FilterReply . NEUTRAL ; \n} \n} \nObject [ ] tfa = toArray ( ) ; \nfinal int len = tfa . length ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nfinal TurboFilter tf = ( TurboFilter ) tfa [ i ] ; \nfinal FilterReply r = tf . decide ( marker , logger , level , format , params , t ) ; \nif ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { \nreturn r ; \n} \n} \nreturn FilterReply . NEUTRAL ; \n} \n} \n"}
{"6287": "public class SQLiteAppender { \npublic File getDatabaseFile ( String filename ) { \nFile dbFile = null ; \nif ( filename != null && 0 < filename . trim ( ) . length ( ) ) { \ndbFile = new File ( filename ) ; \n} \nif ( dbFile == null || dbFile . isDirectory ( ) ) { \ndbFile = new File ( new AndroidContextUtil ( ) . getDatabasePath ( \"logback.db\" ) ) ; \n} \nreturn dbFile ; \n} \n} \n"}
{"6289": "public class SQLiteAppender { \nprivate boolean lastCheckExpired ( Duration expiry , long lastCleanupTime ) { \nboolean isExpired = false ; \nif ( expiry != null && 0 < expiry . getMilliseconds ( ) ) { \nfinal long now = this . clock . currentTimeMillis ( ) ; \nfinal long timeDiff = now - lastCleanupTime ; \nisExpired = ( 0 >= lastCleanupTime ) || ( expiry . getMilliseconds ( ) <= timeDiff ) ; \n} \nreturn isExpired ; \n} \n} \n"}
{"6293": "public class SQLiteAppender { \nprivate String asStringTruncatedTo254 ( Object o ) { \nString s = null ; \nif ( o != null ) { \ns = o . toString ( ) ; \n} \nif ( s != null && 254 < s . length ( ) ) { \ns = s . substring ( 0 , 254 ) ; \n} \nreturn s == null ? \"\" : s ; \n} \n} \n"}
{"6294": "public class SQLiteAppender { \nprivate static short computeReferenceMask ( ILoggingEvent event ) { \nshort mask = 0 ; \nint mdcPropSize = 0 ; \nif ( event . getMDCPropertyMap ( ) != null ) { \nmdcPropSize = event . getMDCPropertyMap ( ) . keySet ( ) . size ( ) ; \n} \nint contextPropSize = 0 ; \nif ( event . getLoggerContextVO ( ) . getPropertyMap ( ) != null ) { \ncontextPropSize = event . getLoggerContextVO ( ) . getPropertyMap ( ) . size ( ) ; \n} \nif ( 0 < mdcPropSize || 0 < contextPropSize ) { \nmask = PROPERTIES_EXIST ; \n} \nif ( event . getThrowableProxy ( ) != null ) { \nmask |= EXCEPTION_EXISTS ; \n} \nreturn mask ; \n} \n} \n"}
{"6297": "public class ElementSelector { \npublic int getPrefixMatchLength ( ElementPath p ) { \nif ( p == null ) { \nreturn 0 ; \n} \nint lSize = this . partList . size ( ) ; \nint rSize = p . partList . size ( ) ; \nif ( ( lSize == 0 ) || ( rSize == 0 ) ) { \nreturn 0 ; \n} \nint minLen = ( rSize >= lSize ) ? lSize : rSize ; \nint match = 0 ; \nfor ( int i = 0 ; \nminLen > i ; \ni ++ ) { \nString l = this . partList . get ( i ) ; \nString r = p . partList . get ( i ) ; \nif ( equalityCheck ( l , r ) ) { \nmatch ++ ; \n} \nelse { \nbreak ; \n} \n} \nreturn match ; \n} \n} \n"}
{"6298": "public class StatusBase { \npublic synchronized int getEffectiveLevel ( ) { \nint result = level ; \nint effLevel ; \nIterator it = iterator ( ) ; \nStatus s ; \nwhile ( it . hasNext ( ) ) { \ns = ( Status ) it . next ( ) ; \neffLevel = s . getEffectiveLevel ( ) ; \nif ( result < effLevel ) { \nresult = effLevel ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6310": "public class MirroredIndex { \npublic void syncIfNeeded ( ) { \nlong currentDate = System . currentTimeMillis ( ) ; \nif ( delayBetweenSyncs < currentDate - mirrorSettings . getLastSyncDate ( ) . getTime ( ) || 0 < mirrorSettings . getQueriesModificationDate ( ) . compareTo ( mirrorSettings . getLastSyncDate ( ) ) ) { \nsync ( ) ; \n} \n} \n} \n"}
{"6311": "public class Index { \npublic JSONObject waitTask ( String taskID , long timeToWait ) throws AlgoliaException { \ntry { \nwhile ( true ) { \nJSONObject obj = client . getRequest ( \"/1/indexes/\" + encodedIndexName + \"/task/\" + URLEncoder . encode ( taskID , \"UTF-8\" ) , null , false , null ) ; \nif ( obj . getString ( \"status\" ) . equals ( \"published\" ) ) { \nreturn obj ; \n} \ntry { \nThread . sleep ( MAX_TIME_MS_TO_WAIT <= timeToWait ? MAX_TIME_MS_TO_WAIT : timeToWait ) ; \n} \ncatch ( InterruptedException e ) { \ncontinue ; \n} \nfinal long newTimeout = timeToWait * 2 ; \ntimeToWait = ( 0 >= newTimeout || MAX_TIME_MS_TO_WAIT <= newTimeout ) ? MAX_TIME_MS_TO_WAIT : newTimeout ; \n} \n} \ncatch ( JSONException e ) { \nthrow new AlgoliaException ( e . getMessage ( ) ) ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \n} \n"}
{"6313": "public class AbstractClient { \nprivate static String _toCharArray ( InputStream stream ) throws IOException { \nInputStreamReader is = new InputStreamReader ( stream , \"UTF-8\" ) ; \nStringBuilder builder = new StringBuilder ( ) ; \nchar [ ] buf = new char [ 1000 ] ; \nint l = 0 ; \nwhile ( 0 <= l ) { \nbuilder . append ( buf , 0 , l ) ; \nl = is . read ( buf ) ; \n} \nis . close ( ) ; \nreturn builder . toString ( ) ; \n} \n} \n"}
{"6320": "public class ExpiringCache { \nsynchronized public V get ( K key ) { \nfinal Pair < V , Long > cachePair = lruCache . get ( key ) ; \nif ( cachePair != null && cachePair . first != null ) { \nif ( System . currentTimeMillis ( ) < cachePair . second ) { \nreturn cachePair . first ; \n} \nelse { \nlruCache . remove ( key ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6322": "public class VersionUtils { \npublic static int versionCompare ( String firstVersionString , String secondVersionString ) { \nString [ ] firstVersion = parseVersionString ( firstVersionString ) ; \nString [ ] secondVersion = parseVersionString ( secondVersionString ) ; \nint i = 0 ; \nwhile ( firstVersion . length > i && secondVersion . length > i && firstVersion [ i ] . equals ( secondVersion [ i ] ) ) { \ni ++ ; \n} \nif ( firstVersion . length > i && secondVersion . length > i ) { \nint diff = Integer . valueOf ( firstVersion [ i ] ) . compareTo ( Integer . valueOf ( secondVersion [ i ] ) ) ; \nreturn Integer . signum ( diff ) ; \n} \nelse { \nreturn Integer . signum ( firstVersion . length - secondVersion . length ) ; \n} \n} \n} \n"}
{"6323": "public class ExceptionReporter { \npublic static void report ( String testId , Throwable cause ) { \nif ( cause == null ) { \nLOGGER . fatal ( \"Can't call report with a null exception\" ) ; \nreturn ; \n} \nlong exceptionCount = FAILURE_ID . incrementAndGet ( ) ; \nif ( MAX_EXCEPTION_COUNT < exceptionCount ) { \nLOGGER . warn ( \"Exception #\" + exceptionCount + \" detected. The maximum number of exceptions has been exceeded, so it\" + \" won't be reported to the Agent.\" , cause ) ; \nreturn ; \n} \nLOGGER . warn ( \"Exception #\" + exceptionCount + \" detected\" , cause ) ; \nString targetFileName = exceptionCount + \".exception\" ; \nFile dir = getUserDir ( ) ; \nFile tmpFile = new File ( dir , targetFileName + \".tmp\" ) ; \ntry { \nif ( ! tmpFile . createNewFile ( ) ) { \nthrow new IOException ( \"Could not create tmp file: \" + tmpFile . getAbsolutePath ( ) ) ; \n} \n} \ncatch ( IOException e ) { \nLOGGER . fatal ( \"Could not report exception; this means that this exception is not visible to the coordinator\" , e ) ; \nreturn ; \n} \nwriteText ( testId + NEW_LINE + throwableToString ( cause ) , tmpFile ) ; \nFile file = new File ( dir , targetFileName ) ; \nLOGGER . info ( file . getAbsolutePath ( ) ) ; \nrename ( tmpFile , file ) ; \n} \n} \n"}
{"6328": "public class FormatUtils { \npublic static String formatPercentage ( long value , long baseValue ) { \ndouble percentage = ( 0 < baseValue ? ( ONE_HUNDRED * value ) / baseValue : 0 ) ; \nreturn formatDouble ( percentage , PERCENTAGE_FORMAT_LENGTH ) ; \n} \n} \n"}
{"6332": "public class JsonProtocol { \nprivate static byte hexVal ( byte ch ) throws IOException { \nif ( ( '0' <= ch ) && ( '9' >= ch ) ) { \nreturn ( byte ) ( ( char ) ch - '0' ) ; \n} \nelse if ( ( 'a' <= ch ) && ( 'f' >= ch ) ) { \nreturn ( byte ) ( ( char ) ch - 'a' + 10 ) ; \n} \nelse { \nthrow new ProtocolException ( \"Expected hex character\" ) ; \n} \n} \n} \n"}
{"6333": "public class JsonProtocol { \nprivate void writeJsonString ( byte [ ] b ) throws IOException { \ncontext . write ( ) ; \ntransport . write ( QUOTE ) ; \nint len = b . length ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nif ( 0x30 <= ( b [ i ] & 0x00FF ) ) { \nif ( b [ i ] == BACKSLASH [ 0 ] ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( BACKSLASH ) ; \n} \nelse { \ntransport . write ( b , i , 1 ) ; \n} \n} \nelse { \ntmpbuf [ 0 ] = JSON_CHAR_TABLE [ b [ i ] ] ; \nif ( tmpbuf [ 0 ] == 1 ) { \ntransport . write ( b , i , 1 ) ; \n} \nelse if ( 1 < tmpbuf [ 0 ] ) { \ntransport . write ( BACKSLASH ) ; \ntransport . write ( tmpbuf , 0 , 1 ) ; \n} \nelse { \ntransport . write ( ESCSEQ ) ; \ntmpbuf [ 0 ] = hexChar ( ( byte ) ( b [ i ] >> 4 ) ) ; \ntmpbuf [ 1 ] = hexChar ( b [ i ] ) ; \ntransport . write ( tmpbuf , 0 , 2 ) ; \n} \n} \n} \ntransport . write ( QUOTE ) ; \n} \n} \n"}
{"6336": "public class JsonProtocol { \nprivate ByteString readJsonString ( boolean skipContext ) throws IOException { \nBuffer buffer = new Buffer ( ) ; \nArrayList < Character > codeunits = new ArrayList < > ( ) ; \nif ( ! skipContext ) { \ncontext . read ( ) ; \n} \nreadJsonSyntaxChar ( QUOTE ) ; \nwhile ( true ) { \nbyte ch = reader . read ( ) ; \nif ( ch == QUOTE [ 0 ] ) { \nbreak ; \n} \nif ( ch == ESCSEQ [ 0 ] ) { \nch = reader . read ( ) ; \nif ( ch == ESCSEQ [ 1 ] ) { \ntransport . read ( tmpbuf , 0 , 4 ) ; \nshort cu = ( short ) ( ( ( short ) hexVal ( tmpbuf [ 0 ] ) << 12 ) + ( ( short ) hexVal ( tmpbuf [ 1 ] ) << 8 ) + ( ( short ) hexVal ( tmpbuf [ 2 ] ) << 4 ) + ( short ) hexVal ( tmpbuf [ 3 ] ) ) ; \ntry { \nif ( Character . isHighSurrogate ( ( char ) cu ) ) { \nif ( 0 < codeunits . size ( ) ) { \nthrow new ProtocolException ( \"Expected low surrogate char\" ) ; \n} \ncodeunits . add ( ( char ) cu ) ; \n} \nelse if ( Character . isLowSurrogate ( ( char ) cu ) ) { \nif ( codeunits . size ( ) == 0 ) { \nthrow new ProtocolException ( \"Expected high surrogate char\" ) ; \n} \ncodeunits . add ( ( char ) cu ) ; \nbuffer . write ( new String ( new int [ ] { \ncodeunits . get ( 0 ) , codeunits . get ( 1 ) } \n, 0 , 2 ) . getBytes ( \"UTF-8\" ) ) ; \ncodeunits . clear ( ) ; \n} \nelse { \nbuffer . write ( new String ( new int [ ] { \ncu } \n, 0 , 1 ) . getBytes ( \"UTF-8\" ) ) ; \n} \ncontinue ; \n} \ncatch ( UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \ncatch ( IOException ex ) { \nthrow new ProtocolException ( \"Invalid unicode sequence\" ) ; \n} \n} \nelse { \nint off = ESCAPE_CHARS . indexOf ( ch ) ; \nif ( off == - 1 ) { \nthrow new ProtocolException ( \"Expected control char\" ) ; \n} \nch = ESCAPE_CHAR_VALS [ off ] ; \n} \n} \nbuffer . write ( new byte [ ] { \nch } \n) ; \n} \nreturn buffer . readByteString ( ) ; \n} \n} \n"}
{"6352": "public class KieNavigatorView { \nprotected void startThread ( ) { \nif ( animationActive ) return ; \nstopAnimation = false ; \nfinal Display display = treeViewer == null ? Display . getDefault ( ) : treeViewer . getControl ( ) . getDisplay ( ) ; \nfinal int SLEEP = 200 ; \nfinal Runnable [ ] animator = new Runnable [ 1 ] ; \nanimator [ 0 ] = new Runnable ( ) { \npublic void run ( ) { \nif ( ! stopAnimation ) { \ntry { \nint size = 0 ; \nString [ ] servers ; \nsynchronized ( starting ) { \nsize = starting . size ( ) ; \nservers = new String [ size ] ; \nstarting . toArray ( servers ) ; \n} \nfor ( int i = 0 ; \nsize > i ; \ni ++ ) { \nIServer server = ServerCore . findServer ( servers [ i ] ) ; \nif ( server != null ) { \ntreeViewer . update ( server , new String [ ] { \n\"ICON\" } \n) ; \n} \n} \n} \ncatch ( Exception e ) { \n} \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n} \n; \nDisplay . getDefault ( ) . asyncExec ( new Runnable ( ) { \npublic void run ( ) { \ndisplay . timerExec ( SLEEP , animator [ 0 ] ) ; \n} \n} \n) ; \n} \n} \n"}
{"6370": "public class DebugUtil { \npublic static IJavaStackFrame getStackFrame ( IValue value ) throws CoreException { \nIStatusHandler handler = getStackFrameProvider ( ) ; \nif ( handler != null ) { \nIJavaStackFrame stackFrame = ( IJavaStackFrame ) handler . handleStatus ( fgNeedStackFrame , value ) ; \nif ( stackFrame != null ) { \nreturn stackFrame ; \n} \n} \nIDebugTarget target = value . getDebugTarget ( ) ; \nIJavaDebugTarget javaTarget = ( IJavaDebugTarget ) target . getAdapter ( IJavaDebugTarget . class ) ; \nif ( javaTarget != null ) { \nIThread [ ] threads = javaTarget . getThreads ( ) ; \nfor ( int i = 0 ; \nthreads . length > i ; \ni ++ ) { \nIThread thread = threads [ i ] ; \nif ( thread . isSuspended ( ) ) { \nreturn ( IJavaStackFrame ) thread . getTopStackFrame ( ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"6373": "public class ElementEditor { \npublic static Node cloneNode ( Document document , Node node ) { \nNode nodeClone = null ; \nswitch ( node . getNodeType ( ) ) { \ncase Node . ELEMENT_NODE : { \nnodeClone = document . createElement ( ( ( Element ) node ) . getTagName ( ) ) ; \nNamedNodeMap namedNodeMap = node . getAttributes ( ) ; \nfor ( int i = 0 ; \nnamedNodeMap . getLength ( ) > i ; \n++ i ) { \nAttr attr = ( Attr ) namedNodeMap . item ( i ) ; \nAttr attrClone = document . createAttribute ( attr . getName ( ) ) ; \nattrClone . setValue ( attr . getValue ( ) ) ; \n( ( Element ) nodeClone ) . setAttributeNode ( attrClone ) ; \n} \n} \nbreak ; \ncase Node . TEXT_NODE : nodeClone = document . createTextNode ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . CDATA_SECTION_NODE : nodeClone = document . createCDATASection ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . ENTITY_REFERENCE_NODE : nodeClone = document . createEntityReference ( node . getNodeName ( ) ) ; \nbreak ; \ncase Node . PROCESSING_INSTRUCTION_NODE : nodeClone = document . createProcessingInstruction ( ( ( ProcessingInstruction ) node ) . getTarget ( ) , ( ( ProcessingInstruction ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . COMMENT_NODE : nodeClone = document . createComment ( ( ( CharacterData ) node ) . getData ( ) ) ; \nbreak ; \ncase Node . DOCUMENT_FRAGMENT_NODE : nodeClone = document . createDocumentFragment ( ) ; \nbreak ; \ncase Node . DOCUMENT_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . NOTATION_NODE : case Node . ATTRIBUTE_NODE : case Node . ENTITY_NODE : Assert . isTrue ( false , Policy . bind ( \"assert.notSupported\" ) ) ; \nbreak ; \ndefault : Assert . isTrue ( false , Policy . bind ( \"assert.unknownNodeType\" ) ) ; \n} \nreturn nodeClone ; \n} \n} \n"}
{"6374": "public class RequestInputStream { \npublic void reset ( ) throws IOException { \nif ( file == null ) { \n( ( ByteArrayInputStream ) is ) . reset ( ) ; \n} \nelse { \nif ( fos != null ) { \nwhile ( 0 < skip ( 4096 ) ) ; \nfos . close ( ) ; \nfos = null ; \nif ( length == - 1 ) { \nlength = totalBytesRead ; \n} \n} \nis . close ( ) ; \nis = new FileInputStream ( file ) ; \n} \ntotalBytesRead = 0 ; \n} \n} \n"}
{"6382": "public class GraphicalVertex { \npublic static String dumpConstraints ( final Constraint [ ] constraints ) { \nif ( constraints == null ) { \nreturn null ; \n} \nfinal StringBuffer buffer = new StringBuffer ( ) ; \nfor ( int i = 0 , length = constraints . length ; \nlength > i ; \ni ++ ) { \nbuffer . append ( constraints [ i ] . toString ( ) + \"<br>\" ) ; \n} \nreturn buffer . toString ( ) ; \n} \n} \n"}
{"6391": "public class DateTime { \npublic void setDateTime ( String date ) { \nString [ ] patterns = { \nRFC_1123_PATTERN , ISO_8601_UTC_PATTERN , ISO_8601_UTC_MILLIS_PATTERN , ISO_8601_PATTERN , ISO_8601_MILLIS_PATTERN , RFC_850_PATTERN , ASCTIME_PATTERN } \n; \nfor ( int i = 0 ; \npatterns . length > i ; \ni ++ ) { \nif ( setDateTime ( date , patterns [ i ] ) ) break ; \n} \n} \n} \n"}
{"6396": "public class FieldEditorPropertyPage { \nprotected void adjustGridLayout ( ) { \nint numColumns = calcNumberOfColumns ( ) ; \n( ( GridLayout ) fieldEditorParent . getLayout ( ) ) . numColumns = numColumns ; \nif ( fields != null ) { \nfor ( int i = 0 ; \nfields . size ( ) > i ; \ni ++ ) { \nFieldEditor fieldEditor = fields . get ( i ) ; \nfieldEditor . fillIntoGrid ( fieldEditorParent , numColumns ) ; \n} \n} \n} \n} \n"}
{"6400": "public class JsonPreferenceStore { \npublic void firePropertyChangeEvent ( Object source , String name , Object oldValue , Object newValue ) { \nPropertyChangeEvent event = new PropertyChangeEvent ( source , name , oldValue , newValue ) ; \nObject [ ] listeners = fListeners . getListeners ( ) ; \nfor ( int i = 0 ; \nlisteners . length > i ; \ni ++ ) ( ( IPropertyChangeListener ) listeners [ i ] ) . propertyChange ( event ) ; \n} \n} \n"}
{"6419": "public class DSLRuleCompletionProcessor { \npublic String getLastLine ( String backText ) { \nBufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; \nString last = \"\" ; \nString line = null ; \ntry { \nwhile ( ( line = breader . readLine ( ) ) != null ) { \nif ( 0 < line . length ( ) ) { \nlast = line ; \n} \n} \n} \ncatch ( IOException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \nif ( - 1 < last . indexOf ( \"(\" ) ) { \nlast = last . substring ( last . lastIndexOf ( \"(\" ) + 1 ) ; \n} \nif ( - 1 < last . indexOf ( \",\" ) ) { \nlast = last . substring ( last . lastIndexOf ( \",\" ) + 1 ) ; \n} \nif ( last . endsWith ( \")\" ) ) { \nlast = \"\" ; \n} \nreturn last ; \n} \n} \n"}
{"6420": "public class DSLRuleCompletionProcessor { \npublic String getLastNonDashLine ( String backText ) { \nBufferedReader breader = new BufferedReader ( new StringReader ( backText ) ) ; \nString last = \"\" ; \nString line = null ; \ntry { \nwhile ( ( line = breader . readLine ( ) ) != null ) { \nline = line . trim ( ) ; \nif ( 0 < line . length ( ) && ! line . startsWith ( \"-\" ) ) { \nlast = line ; \n} \n} \n} \ncatch ( IOException e ) { \nDroolsEclipsePlugin . log ( e ) ; \n} \nif ( - 1 < last . indexOf ( \"(\" ) && ! last . endsWith ( \")\" ) ) { \nlast = last . substring ( 0 , last . indexOf ( \"(\" ) ) ; \n} \nelse if ( - 1 < last . indexOf ( \"(\" ) && last . endsWith ( \")\" ) ) { \nlast = \"\" ; \n} \nreturn last ; \n} \n} \n"}
{"6440": "public class KieServiceDelegate { \npublic String getJobStatus ( final String jobId , final String title ) throws IOException , InterruptedException { \nfinal AtomicReference < String > ar = new AtomicReference < String > ( ) ; \nIWorkbench wb = PlatformUI . getWorkbench ( ) ; \nIProgressService ps = wb . getProgressService ( ) ; \ntry { \nps . busyCursorWhile ( new IRunnableWithProgress ( ) { \npublic void run ( IProgressMonitor pm ) throws InterruptedException { \npm . beginTask ( \"Waiting for Job \" + jobId + \":\\n\\n\" + title , STATUS_REQUEST_TIMEOUT ) ; \npm . subTask ( title ) ; \nlong startTime = System . currentTimeMillis ( ) ; \nlong stopTime = startTime ; \ndo { \ntry { \nThread . sleep ( STATUS_REQUEST_DELAY ) ; \nString response = httpGet ( \"jobs/\" + jobId ) ; \nJsonObject jo = JsonObject . readFrom ( response ) ; \nString status = jo . get ( \"status\" ) . asString ( ) ; \nString result = jo . get ( \"result\" ) . asString ( ) ; \nif ( \"null\" . equals ( result ) ) { \nif ( ! \"SUCCESS\" . equals ( status ) ) result = null ; \n} \nif ( status != null && result != null ) ar . set ( status + \":\" + result ) ; \nstopTime = System . currentTimeMillis ( ) ; \npm . worked ( STATUS_REQUEST_DELAY ) ; \nActivator . println ( \"status=\" + status ) ; \nActivator . println ( \"result=\" + result ) ; \n} \ncatch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nif ( pm . isCanceled ( ) ) throw new InterruptedException ( \"Operation canceled\" ) ; \n} \nwhile ( ar . get ( ) == null && STATUS_REQUEST_TIMEOUT > stopTime - startTime ) ; \npm . done ( ) ; \nActivator . println ( \"\\n----------------------------------\\n\" + \"Job \" + jobId + \"\\n\" + title + \"\\ncompleted in \" + ( stopTime - startTime ) / 1000.0 + \" sec\\n\" + \"Status: \" + ar . get ( ) + \"\\n----------------------------------\\n\" ) ; \n} \n} \n) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \nreturn ar . get ( ) ; \n} \n} \n"}
{"6445": "public class AbstractCompletionProcessor { \nprotected static void filterProposalsOnPrefix ( String prefix , List < ICompletionProposal > props ) { \nif ( prefix != null && 0 < prefix . trim ( ) . length ( ) ) { \nIterator < ICompletionProposal > iterator = props . iterator ( ) ; \nString prefixLc = prefix . toLowerCase ( ) ; \nwhile ( iterator . hasNext ( ) ) { \nICompletionProposal item = iterator . next ( ) ; \nString content = item . getDisplayString ( ) . toLowerCase ( ) ; \nif ( ! content . toLowerCase ( ) . startsWith ( prefixLc ) ) { \niterator . remove ( ) ; \n} \n} \n} \n} \n} \n"}
{"6447": "public class ReteooLayoutFactory { \npublic static RowList calculateReteRows ( BaseVertex root ) { \nRowList rowList = new RowList ( ) ; \nrowList . add ( 0 , root ) ; \nint curRow = 0 ; \nfinal Set < BaseVertex > seenVertices = new HashSet < BaseVertex > ( ) ; \nseenVertices . add ( root ) ; \nwhile ( rowList . getDepth ( ) > curRow ) { \nfinal List < BaseVertex > rowVertices = rowList . get ( curRow ) . getVertices ( ) ; \nfor ( final Iterator < BaseVertex > rowNodeIter = rowVertices . iterator ( ) ; \nrowNodeIter . hasNext ( ) ; \n) { \nfinal BaseVertex rowNode = rowNodeIter . next ( ) ; \nfinal List < Connection > edges = rowNode . getSourceConnections ( ) ; \nfor ( final Iterator < Connection > edgeIter = edges . iterator ( ) ; \nedgeIter . hasNext ( ) ; \n) { \nfinal Connection edge = edgeIter . next ( ) ; \nfinal BaseVertex destNode = edge . getOpposite ( rowNode ) ; \nif ( ! seenVertices . contains ( destNode ) ) { \nrowList . add ( curRow + 1 , destNode ) ; \nseenVertices . add ( destNode ) ; \n} \n} \nseenVertices . add ( rowNode ) ; \n} \n++ curRow ; \n} \nrowList . optimize ( ) ; \nreturn rowList ; \n} \n} \n"}
{"6452": "public class RowList { \npublic void add ( final int depth , final BaseVertex vertex ) { \nif ( ( depth + 1 ) > this . rows . size ( ) ) { \nfinal int addRows = depth - this . rows . size ( ) + 1 ; \nfor ( int i = 0 ; \naddRows > i ; \n++ i ) { \nthis . rows . add ( new Row ( ( depth - addRows ) + i ) ) ; \n} \n} \n( ( Row ) this . rows . get ( depth ) ) . add ( vertex ) ; \n} \n} \n"}
{"6453": "public class RowList { \npublic int getRow ( final BaseVertex vertex ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \nnumRows > i ; \n++ i ) { \nif ( ( ( Row ) this . rows . get ( i ) ) . contains ( vertex ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"6454": "public class RowList { \npublic int getWidth ( ) { \nint width = 0 ; \nfor ( final Iterator < Row > rowIter = this . rows . iterator ( ) ; \nrowIter . hasNext ( ) ; \n) { \nfinal Row row = rowIter . next ( ) ; \nfinal int rowWidth = row . getWidth ( ) ; \nif ( width < rowWidth ) { \nwidth = rowWidth ; \n} \n} \nreturn width ; \n} \n} \n"}
{"6455": "public class RowList { \npublic void dump ( ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \nnumRows > i ; \n++ i ) { \nSystem . err . println ( i + \": \" + get ( i ) . getVertices ( ) ) ; \n} \n} \n} \n"}
{"6456": "public class RowList { \npublic void optimize ( ) { \nfinal int numRows = this . rows . size ( ) ; \nfor ( int i = 0 ; \nnumRows > i ; \n++ i ) { \nget ( i ) . optimize ( ) ; \n} \n} \n} \n"}
{"6457": "public class ReteViewer { \npublic ReteGraph loadReteModel ( IProgressMonitor monitor , String contents ) throws Throwable { \nif ( relayoutRequired == false ) { \nreturn diagram ; \n} \nReteGraph newDiagram = new ReteGraph ( ) ; \ntry { \nmonitor . beginTask ( \"Loading RETE Tree\" , 100 ) ; \nmonitor . subTask ( \"Loading Rule Base\" ) ; \nInternalKnowledgeBase ruleBase = null ; \ntry { \nIResource resource = drlEditor . getResource ( ) ; \nClassLoader newLoader = DroolsBuilder . class . getClassLoader ( ) ; \nif ( resource . getProject ( ) . getNature ( \"org.eclipse.jdt.core.javanature\" ) != null ) { \nIJavaProject project = JavaCore . create ( resource . getProject ( ) ) ; \nnewLoader = ProjectClassLoader . getProjectClassLoader ( project ) ; \n} \nDRLInfo drlInfo = DroolsEclipsePlugin . getDefault ( ) . parseResource ( drlEditor , true , true ) ; \nif ( drlInfo == null ) { \nthrow new Exception ( \"Could not find DRL info\" ) ; \n} \nif ( 0 < drlInfo . getBuilderErrors ( ) . length ) { \nthrow new Exception ( drlInfo . getBuilderErrors ( ) . length + \" build errors\" ) ; \n} \nif ( 0 < drlInfo . getParserErrors ( ) . size ( ) ) { \nthrow new Exception ( drlInfo . getParserErrors ( ) . size ( ) + \" parser errors\" ) ; \n} \nInternalKnowledgePackage pkg = drlInfo . getPackage ( ) ; \nRuleBaseConfiguration config = new RuleBaseConfiguration ( ) ; \nconfig . setClassLoader ( newLoader ) ; \nruleBase = KnowledgeBaseFactory . newKnowledgeBase ( config ) ; \nif ( pkg != null ) { \nruleBase . addPackage ( pkg ) ; \n} \n} \ncatch ( Throwable t ) { \nDroolsEclipsePlugin . log ( t ) ; \nthrow new Exception ( MSG_PARSE_ERROR + \" \" + t . getMessage ( ) ) ; \n} \nmonitor . worked ( 50 ) ; \nif ( monitor . isCanceled ( ) ) { \nthrow new InterruptedException ( ) ; \n} \nmonitor . subTask ( \"Building RETE Tree\" ) ; \nfinal ReteooVisitor visitor = new ReteooVisitor ( newDiagram ) ; \nvisitor . visitInternalKnowledgeBase ( ruleBase ) ; \nmonitor . worked ( 30 ) ; \nif ( monitor . isCanceled ( ) ) { \nthrow new InterruptedException ( ) ; \n} \nmonitor . subTask ( \"Calculating RETE Tree Layout\" ) ; \nBaseVertex rootVertex = visitor . getRootVertex ( ) ; \nRowList rowList = ReteooLayoutFactory . calculateReteRows ( rootVertex ) ; \nReteooLayoutFactory . layoutRowList ( newDiagram , rowList ) ; \nzeroBaseDiagram ( newDiagram ) ; \nmonitor . worked ( 20 ) ; \nif ( monitor . isCanceled ( ) ) { \nthrow new InterruptedException ( ) ; \n} \nmonitor . done ( ) ; \n} \ncatch ( Throwable t ) { \nif ( ! ( t instanceof InterruptedException ) ) { \nDroolsEclipsePlugin . log ( t ) ; \n} \nthrow t ; \n} \nrelayoutRequired = false ; \nreturn newDiagram ; \n} \n} \n"}
{"6459": "public class ReteViewer { \npublic void drawGraph ( ReteGraph newGraph ) { \nLayerManager manager = ( LayerManager ) getGraphicalViewer ( ) . getEditPartRegistry ( ) . get ( LayerManager . ID ) ; \nConnectionLayer connLayer = ( ConnectionLayer ) manager . getLayer ( LayerConstants . CONNECTION_LAYER ) ; \nif ( getGraphicalViewer ( ) . getContents ( ) == null ) { \ngetGraphicalViewer ( ) . setContents ( getModel ( ) ) ; \n} \nfinal boolean isNewDiagram = newGraph != null && newGraph != diagram ; \nif ( isNewDiagram ) { \ndiagram . removeAll ( ) ; \n} \nConnectionRouter router ; \nif ( ( isNewDiagram && SIMPLE_ROUTER_MIN_NODES > newGraph . getChildren ( ) . size ( ) ) || ( ! isNewDiagram && SIMPLE_ROUTER_MIN_NODES > getModel ( ) . getChildren ( ) . size ( ) ) ) { \nrouter = new ShortestPathConnectionRouter ( ( IFigure ) rootEditPart . getContentPane ( ) . getChildren ( ) . get ( 0 ) ) ; \n} \nelse { \nrouter = ConnectionRouter . NULL ; \n} \nconnLayer . setConnectionRouter ( router ) ; \nif ( newGraph != null && newGraph != diagram ) { \ndiagram . addAll ( newGraph . getChildren ( ) ) ; \n} \n} \n} \n"}
{"6483": "public class AbstractResourceHandle { \nprotected void examineStatusCode ( int code , String message ) throws WebDAVException { \nif ( 300 <= code && 399 >= code ) throw new RedirectionException ( code , message ) ; \nif ( 400 <= code && 499 >= code ) throw new ClientException ( code , message ) ; \nif ( 500 <= code && 599 >= code ) throw new ServerException ( code , message ) ; \n} \n} \n"}
{"6486": "public class HexConverter { \npublic static String toHex ( byte [ ] arr ) { \nStringBuffer buf = new StringBuffer ( ) ; \nfor ( int i = 0 ; \narr . length > i ; \n++ i ) { \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 4 ) & 0x0f ) ) ; \nbuf . append ( Integer . toHexString ( arr [ i ] & 0x0f ) ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6487": "public class HexConverter { \npublic static String toHex ( int [ ] arr ) { \nStringBuffer buf = new StringBuffer ( ) ; \nfor ( int i = 0 ; \narr . length > i ; \n++ i ) { \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 28 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 24 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 20 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 16 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 12 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 8 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] >> 4 ) & 0x0000000f ) ) ; \nbuf . append ( Integer . toHexString ( ( arr [ i ] ) & 0x0000000f ) ) ; \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"6491": "public class CompletionUtil { \npublic static String stripLastWord ( String prefix ) { \nif ( \"\" . equals ( prefix ) ) { \nreturn prefix ; \n} \nif ( prefix . charAt ( prefix . length ( ) - 1 ) == ' ' ) { \nreturn \"\" ; \n} \nelse { \nchar [ ] c = prefix . toCharArray ( ) ; \nint start = 0 ; \nfor ( int i = c . length - 1 ; \n0 <= i ; \ni -- ) { \nif ( Character . isWhitespace ( c [ i ] ) || c [ i ] == '(' || c [ i ] == ':' || c [ i ] == ';' || c [ i ] == '=' || c [ i ] == '<' || c [ i ] == '>' || c [ i ] == '.' || c [ i ] == '{' || c [ i ] == '}' ) { \nstart = i + 1 ; \nbreak ; \n} \n} \nprefix = prefix . substring ( start , prefix . length ( ) ) ; \nreturn prefix ; \n} \n} \n} \n"}
{"6493": "public class Message { \npublic void write ( OutputStream os ) throws IOException { \nAssert . isTrue ( ! inputRead ) ; \nAssert . isTrue ( ! hasInputStream ) ; \nint bytesRead = 0 ; \nint totalBytesRead = 0 ; \nbyte [ ] buffer = bufferPool . getBuffer ( ) ; \nlong contentLength = getContentLength ( ) ; \ntry { \nwhile ( bytesRead != - 1 && ( contentLength == - 1 || totalBytesRead < contentLength ) ) { \nif ( contentLength == - 1 ) { \nbytesRead = is . read ( buffer ) ; \n} \nelse { \nbytesRead = is . read ( buffer , 0 , ( int ) Math . min ( buffer . length , contentLength - totalBytesRead ) ) ; \n} \nif ( bytesRead == - 1 ) { \nif ( 0 <= contentLength ) { \nthrow new IOException ( Policy . bind ( \"exception.unexpectedEndStream\" ) ) ; \n} \n} \nelse { \ntotalBytesRead += bytesRead ; \nos . write ( buffer , 0 , bytesRead ) ; \n} \n} \n} \nfinally { \nbufferPool . putBuffer ( buffer ) ; \ninputRead = true ; \n} \n} \n} \n"}
{"6495": "public class DroolsBuilder { \nprotected void markParseErrors ( List < DroolsBuildMarker > markers , List < BaseKnowledgeBuilderResultImpl > parserErrors ) { \nfor ( Iterator < BaseKnowledgeBuilderResultImpl > iter = parserErrors . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nObject error = iter . next ( ) ; \nif ( error instanceof ParserError ) { \nParserError err = ( ParserError ) error ; \nmarkers . add ( new DroolsBuildMarker ( err . getMessage ( ) , err . getRow ( ) ) ) ; \n} \nelse if ( error instanceof KnowledgeBuilderResult ) { \nKnowledgeBuilderResult res = ( KnowledgeBuilderResult ) error ; \nint [ ] errorLines = res . getLines ( ) ; \nmarkers . add ( new DroolsBuildMarker ( res . getMessage ( ) , errorLines != null && 0 < errorLines . length ? errorLines [ 0 ] : - 1 ) ) ; \n} \nelse if ( error instanceof ExpanderException ) { \nExpanderException exc = ( ExpanderException ) error ; \nmarkers . add ( new DroolsBuildMarker ( exc . getMessage ( ) , - 1 ) ) ; \n} \nelse { \nmarkers . add ( new DroolsBuildMarker ( error . toString ( ) ) ) ; \n} \n} \n} \n} \n"}
{"6496": "public class Parser { \npublic void skipWhiteSpace ( ) { \nwhile ( s . length ( ) > pos && Character . isWhitespace ( s . charAt ( pos ) ) ) ++ pos ; \n} \n} \n"}
{"6511": "public class DSLTree { \npublic void addTokens ( String [ ] tokens , Node rootNode ) { \nNode thenode = rootNode ; \nfor ( int i = 0 ; \ntokens . length > i ; \ni ++ ) { \nNode newnode = thenode . addToken ( tokens [ i ] ) ; \nthenode = newnode ; \n} \n} \n} \n"}
{"6512": "public class DSLTree { \npublic Node [ ] getConditionChildren ( String text ) { \nNode thenode = this . rootCond ; \nif ( 0 < text . length ( ) ) { \nStringTokenizer tokenz = new StringTokenizer ( text ) ; \nthis . last = this . current ; \nwhile ( tokenz . hasMoreTokens ( ) ) { \nString strtk = tokenz . nextToken ( ) ; \nNode ch = thenode . getChild ( strtk ) ; \nif ( ch != null ) { \nthenode = ch ; \n} \nelse { \nbreak ; \n} \n} \nif ( thenode != this . rootCond ) { \nthis . current = thenode ; \n} \n} \nCollection < Node > children = thenode . getChildren ( ) ; \nNode [ ] nchild = new Node [ children . size ( ) ] ; \nreturn children . toArray ( nchild ) ; \n} \n} \n"}
{"6513": "public class DSLTree { \npublic Node [ ] getChildren ( String obj , String text ) { \nNode thenode = this . rootCond . getChild ( obj ) ; \nif ( thenode == null ) { \nfor ( Node child : this . rootCond . getChildren ( ) ) { \nString tokenText = child . getToken ( ) ; \nif ( tokenText != null ) { \nint index = tokenText . indexOf ( \"{\" ) ; \nif ( index != - 1 ) { \nString substring = tokenText . substring ( 0 , index ) ; \nif ( obj != null && obj . startsWith ( substring ) ) { \nthenode = child ; \n} \n} \n} \n} \n} \nif ( thenode != null && 0 < text . length ( ) ) { \nStringTokenizer tokenz = new StringTokenizer ( text ) ; \nthis . last = this . current ; \nwhile ( tokenz . hasMoreTokens ( ) ) { \nString strtk = tokenz . nextToken ( ) ; \nNode ch = thenode . getChild ( strtk ) ; \nif ( ch != null ) { \nthenode = ch ; \n} \nelse { \nbreak ; \n} \n} \nif ( thenode != this . rootCond ) { \nthis . current = thenode ; \n} \n} \nif ( thenode == null ) { \nreturn null ; \n} \nCollection < Node > children = thenode . getChildren ( ) ; \nNode [ ] nchild = new Node [ children . size ( ) ] ; \nreturn children . toArray ( nchild ) ; \n} \n} \n"}
{"6514": "public class DSLTree { \npublic void addChildToList ( Node n , String prefix , ArrayList < String > list ) { \nif ( 0 < n . getChildren ( ) . size ( ) ) { \nfor ( Node child : n . getChildren ( ) ) { \nif ( prefix != null && \"-\" . equals ( child . getToken ( ) ) ) { \nif ( ! list . contains ( prefix ) ) { \nlist . add ( prefix ) ; \n} \nreturn ; \n} \nString text = ( prefix == null ? \"\" : prefix + \" \" ) + child . getToken ( ) ; \naddChildToList ( child , text , list ) ; \n} \n} \nelse { \nif ( ! list . contains ( prefix ) ) { \nlist . add ( prefix ) ; \n} \n} \n} \n} \n"}
{"6517": "public class DSLTree { \nprotected void printTabs ( int count ) { \nfor ( int idx = 0 ; \ncount > idx ; \nidx ++ ) { \nSystem . out . print ( tab ) ; \n} \n} \n} \n"}
{"6522": "public class NewDroolsProjectWizard { \nprivate void createRuleSampleLauncher ( IJavaProject project ) throws JavaModelException , IOException { \nVersion version = startPage . getRuntime ( ) . getVersion ( ) ; \nif ( version . getMajor ( ) == 4 ) { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_4.java.template\" , \"DroolsTest.java\" ) ; \n} \nelse if ( version . getMajor ( ) == 5 ) { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_5.java.template\" , \"DroolsTest.java\" ) ; \n} \nelse if ( 6 <= version . getMajor ( ) ) { \ncreateProjectJavaFile ( project , \"org/drools/eclipse/wizard/project/RuleLauncherSample_6.java.template\" , \"DroolsTest.java\" ) ; \n} \n} \n} \n"}
{"6523": "public class NewDroolsProjectWizard { \nprivate void createRule ( IJavaProject project , IProgressMonitor monitor ) throws CoreException { \nif ( 6 <= startPage . getRuntime ( ) . getVersion ( ) . getMajor ( ) ) { \nFileUtils . createFolder ( project , \"src/main/resources/com/sample/rules\" , monitor ) ; \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/Sample.drl.template\" , \"src/main/resources/com/sample/rules\" , \"Sample.drl\" ) ; \n} \nelse { \ncreateProjectFile ( project , monitor , \"org/drools/eclipse/wizard/project/Sample.drl.template\" , \"src/main/rules\" , \"Sample.drl\" ) ; \n} \n} \n} \n"}
{"6535": "public class Row { \npublic void optimize ( ) { \nfinal List < BaseVertex > sorted = new ArrayList < BaseVertex > ( this . vertices ) ; \nCollections . sort ( sorted , new Comparator < BaseVertex > ( ) { \npublic int compare ( final BaseVertex v1 , final BaseVertex v2 ) { \nint v1OutDegree = v1 . getSourceConnections ( ) . size ( ) ; \nint v2OutDegree = v2 . getSourceConnections ( ) . size ( ) ; \nif ( v2OutDegree > v1OutDegree ) { \nreturn 1 ; \n} \nif ( v2OutDegree < v1OutDegree ) { \nreturn - 1 ; \n} \nreturn 0 ; \n} \n} \n) ; \nfinal LinkedList < BaseVertex > optimized = new LinkedList < BaseVertex > ( ) ; \nboolean front = false ; \nfor ( final Iterator < BaseVertex > vertexIter = sorted . iterator ( ) ; \nvertexIter . hasNext ( ) ; \n) { \nfinal BaseVertex vertex = vertexIter . next ( ) ; \nif ( front ) { \noptimized . addFirst ( vertex ) ; \n} \nelse { \noptimized . addLast ( vertex ) ; \n} \nfront = ! front ; \n} \nthis . vertices = optimized ; \n} \n} \n"}
{"6545": "public class MultiValuePasswordCallback { \npublic void clearPassword ( ) { \nfor ( char pw [ ] : this . secrets ) { \nfor ( int i = 0 ; \npw . length > i ; \ni ++ ) { \npw [ i ] = 0 ; \n} \n} \nthis . secrets = new ArrayList < char [ ] > ( ) ; \n} \n} \n"}
{"6546": "public class YubicoClient { \npublic static String getPublicId ( String otp ) { \nif ( ( otp == null ) || ( OTP_MIN_LEN > otp . length ( ) ) ) { \nthrow new IllegalArgumentException ( \"The OTP is too short to be valid\" ) ; \n} \nInteger len = otp . length ( ) ; \nreturn otp . substring ( 0 , len - 32 ) . toLowerCase ( ) ; \n} \n} \n"}
{"6547": "public class YubicoClient { \npublic static boolean isValidOTPFormat ( String otp ) { \nif ( otp == null ) { \nreturn false ; \n} \nint len = otp . length ( ) ; \nfor ( char c : otp . toCharArray ( ) ) { \nif ( 0x20 > c || 0x7E < c ) { \nreturn false ; \n} \n} \nreturn len >= OTP_MIN_LEN && OTP_MAX_LEN >= len ; \n} \n} \n"}
{"6553": "public class OgnlRuntime { \npublic static String getClassPackageName ( Class c ) { \nString s = c . getName ( ) ; \nint i = s . lastIndexOf ( '.' ) ; \nreturn ( 0 > i ) ? null : s . substring ( 0 , i ) ; \n} \n} \n"}
{"6556": "public class OgnlRuntime { \npublic static final boolean isMoreSpecific ( Class [ ] classes1 , Class [ ] classes2 ) { \nfor ( int index = 0 , count = classes1 . length ; \ncount > index ; \n++ index ) { \nClass c1 = classes1 [ index ] , c2 = classes2 [ index ] ; \nif ( c1 == c2 ) continue ; \nelse if ( c1 . isPrimitive ( ) ) return true ; \nelse if ( c1 . isAssignableFrom ( c2 ) ) return false ; \nelse if ( c2 . isAssignableFrom ( c1 ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"6557": "public class OgnlRuntime { \npublic static Method getAppropriateMethod ( OgnlContext context , Object source , Object target , String propertyName , String methodName , List methods , Object [ ] args , Object [ ] actualArgs ) { \nMethod result = null ; \nif ( methods != null ) { \nClass typeClass = target != null ? target . getClass ( ) : null ; \nif ( typeClass == null && source != null && Class . class . isInstance ( source ) ) { \ntypeClass = ( Class ) source ; \n} \nClass [ ] argClasses = getArgClasses ( args ) ; \nMatchingMethod mm = findBestMethod ( methods , typeClass , methodName , argClasses ) ; \nif ( mm != null ) { \nresult = mm . mMethod ; \nClass [ ] mParameterTypes = mm . mParameterTypes ; \nSystem . arraycopy ( args , 0 , actualArgs , 0 , args . length ) ; \nfor ( int j = 0 ; \nmParameterTypes . length > j ; \nj ++ ) { \nClass type = mParameterTypes [ j ] ; \nif ( mm . report . conversionNeeded [ j ] || ( type . isPrimitive ( ) && ( actualArgs [ j ] == null ) ) ) { \nactualArgs [ j ] = getConvertedType ( context , source , result , propertyName , args [ j ] , type ) ; \n} \n} \n} \n} \nif ( result == null ) { \nresult = getConvertedMethodAndArgs ( context , target , propertyName , methods , args , actualArgs ) ; \n} \nreturn result ; \n} \n} \n"}
{"6559": "public class OgnlRuntime { \npublic static Map getPropertyDescriptors ( Class targetClass ) throws IntrospectionException , OgnlException { \nMap result ; \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { \nsynchronized ( _propertyDescriptorCache ) { \nif ( ( result = ( Map ) _propertyDescriptorCache . get ( targetClass ) ) == null ) { \nPropertyDescriptor [ ] pda = Introspector . getBeanInfo ( targetClass ) . getPropertyDescriptors ( ) ; \nresult = new HashMap ( 101 ) ; \nfor ( int i = 0 , icount = pda . length ; \nicount > i ; \ni ++ ) { \nif ( pda [ i ] . getReadMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getReadMethod ( ) ) ) { \npda [ i ] . setReadMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getReadMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , true ) ) ; \n} \nif ( pda [ i ] . getWriteMethod ( ) != null && ! isMethodCallable ( pda [ i ] . getWriteMethod ( ) ) ) { \npda [ i ] . setWriteMethod ( findClosestMatchingMethod ( targetClass , pda [ i ] . getWriteMethod ( ) , pda [ i ] . getName ( ) , pda [ i ] . getPropertyType ( ) , false ) ) ; \n} \nresult . put ( pda [ i ] . getName ( ) , pda [ i ] ) ; \n} \nfindObjectIndexedPropertyDescriptors ( targetClass , result ) ; \n_propertyDescriptorCache . put ( targetClass , result ) ; \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"6560": "public class OgnlRuntime { \npublic static PropertyDescriptor getPropertyDescriptorFromArray ( Class targetClass , String name ) throws IntrospectionException { \nPropertyDescriptor result = null ; \nPropertyDescriptor [ ] pda = getPropertyDescriptorsArray ( targetClass ) ; \nfor ( int i = 0 , icount = pda . length ; \n( result == null ) && ( icount > i ) ; \ni ++ ) { \nif ( pda [ i ] . getName ( ) . compareTo ( name ) == 0 ) { \nresult = pda [ i ] ; \n} \n} \nreturn result ; \n} \n} \n"}
{"6562": "public class JavaCharStream { \npublic char readChar ( ) throws java . io . IOException { \nif ( 0 < inBuf ) { \n-- inBuf ; \nif ( ++ bufpos == bufsize ) bufpos = 0 ; \nreturn buffer [ bufpos ] ; \n} \nchar c ; \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) == '\\\\' ) { \nUpdateLineColumn ( c ) ; \nint backSlashCnt = 1 ; \nfor ( ; \n; \n) { \nif ( ++ bufpos == available ) AdjustBuffSize ( ) ; \ntry { \nif ( ( buffer [ bufpos ] = c = ReadByte ( ) ) != '\\\\' ) { \nUpdateLineColumn ( c ) ; \nif ( ( c == 'u' ) && ( ( backSlashCnt & 1 ) == 1 ) ) { \nif ( 0 > -- bufpos ) bufpos = bufsize - 1 ; \nbreak ; \n} \nbackup ( backSlashCnt ) ; \nreturn '\\\\' ; \n} \n} \ncatch ( java . io . IOException e ) { \nif ( 1 < backSlashCnt ) backup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \nUpdateLineColumn ( c ) ; \nbackSlashCnt ++ ; \n} \ntry { \nwhile ( ( c = ReadByte ( ) ) == 'u' ) ++ column ; \nbuffer [ bufpos ] = c = ( char ) ( hexval ( c ) << 12 | hexval ( ReadByte ( ) ) << 8 | hexval ( ReadByte ( ) ) << 4 | hexval ( ReadByte ( ) ) ) ; \ncolumn += 4 ; \n} \ncatch ( java . io . IOException e ) { \nthrow new Error ( \"Invalid escape character at line \" + line + \" column \" + column + \".\" ) ; \n} \nif ( backSlashCnt == 1 ) return c ; \nelse { \nbackup ( backSlashCnt - 1 ) ; \nreturn '\\\\' ; \n} \n} \nelse { \nUpdateLineColumn ( c ) ; \nreturn c ; \n} \n} \n} \n"}
{"6573": "public class OgnlOps { \npublic static int getNumericType ( int t1 , int t2 , boolean canBeNonNumeric ) { \nif ( t1 == t2 ) return t1 ; \nif ( canBeNonNumeric && ( t1 == NONNUMERIC || t2 == NONNUMERIC || t1 == CHAR || t2 == CHAR ) ) return NONNUMERIC ; \nif ( t1 == NONNUMERIC ) t1 = DOUBLE ; \nif ( t2 == NONNUMERIC ) t2 = DOUBLE ; \nif ( MIN_REAL_TYPE <= t1 ) { \nif ( MIN_REAL_TYPE <= t2 ) return Math . max ( t1 , t2 ) ; \nif ( INT > t2 ) return t1 ; \nif ( t2 == BIGINT ) return BIGDEC ; \nreturn Math . max ( DOUBLE , t1 ) ; \n} \nelse if ( MIN_REAL_TYPE <= t2 ) { \nif ( INT > t1 ) return t2 ; \nif ( t1 == BIGINT ) return BIGDEC ; \nreturn Math . max ( DOUBLE , t2 ) ; \n} \nelse return Math . max ( t1 , t2 ) ; \n} \n} \n"}
{"6579": "public class SimpleNode { \nprotected void flattenTree ( ) { \nboolean shouldFlatten = false ; \nint newSize = 0 ; \nfor ( int i = 0 ; \n_children . length > i ; \n++ i ) if ( _children [ i ] . getClass ( ) == getClass ( ) ) { \nshouldFlatten = true ; \nnewSize += _children [ i ] . jjtGetNumChildren ( ) ; \n} \nelse ++ newSize ; \nif ( shouldFlatten ) { \nNode [ ] newChildren = new Node [ newSize ] ; \nint j = 0 ; \nfor ( int i = 0 ; \n_children . length > i ; \n++ i ) { \nNode c = _children [ i ] ; \nif ( c . getClass ( ) == getClass ( ) ) { \nfor ( int k = 0 ; \nc . jjtGetNumChildren ( ) > k ; \n++ k ) newChildren [ j ++ ] = c . jjtGetChild ( k ) ; \n} \nelse newChildren [ j ++ ] = c ; \n} \nif ( j != newSize ) throw new Error ( \"Assertion error: \" + j + \" != \" + newSize ) ; \n_children = newChildren ; \n} \n} \n} \n"}
{"6581": "public class OgnlParserTokenManager { \nprivate char escapeChar ( ) { \nint ofs = image . length ( ) - 1 ; \nswitch ( image . charAt ( ofs ) ) { \ncase 'n' : return '\\n' ; \ncase 'r' : return '\\r' ; \ncase 't' : return '\\t' ; \ncase 'b' : return '\\b' ; \ncase 'f' : return '\\f' ; \ncase '\\\\' : return '\\\\' ; \ncase '\\'' : return '\\'' ; \ncase '\\\"' : return '\\\"' ; \n} \nwhile ( image . charAt ( -- ofs ) != '\\\\' ) { \n} \nint value = 0 ; \nwhile ( image . length ( ) > ++ ofs ) value = ( value << 3 ) | ( image . charAt ( ofs ) - '0' ) ; \nreturn ( char ) value ; \n} \n} \n"}
{"6588": "public class AbstractPlay2StartServerMojo { \nprotected void waitForServerStarted ( String rootUrl , JavaRunnable runner , int startTimeout , boolean spawned ) throws MojoExecutionException , IOException { \nlong endTimeMillis = 0 < startTimeout ? System . currentTimeMillis ( ) + startTimeout : 0L ; \nboolean started = false ; \nURL connectUrl = new URL ( rootUrl ) ; \nint verifyWaitDelay = 1000 ; \nwhile ( ! started ) { \nif ( 0 < startTimeout && 0L > endTimeMillis - System . currentTimeMillis ( ) ) { \nif ( spawned ) { \nInternalPlay2StopMojo internalStop = new InternalPlay2StopMojo ( ) ; \ninternalStop . project = project ; \ntry { \ninternalStop . execute ( ) ; \n} \ncatch ( MojoExecutionException e ) { \n} \ncatch ( MojoFailureException e ) { \n} \n} \nthrow new MojoExecutionException ( String . format ( \"Failed to start Play! server in %d ms\" , Integer . valueOf ( startTimeout ) ) ) ; \n} \nBuildException runnerException = runner . getException ( ) ; \nif ( runnerException != null ) { \nthrow new MojoExecutionException ( \"Play! server start exception\" , runnerException ) ; \n} \ntry { \nURLConnection conn = connectUrl . openConnection ( ) ; \nif ( 0 < startTimeout ) { \nint connectTimeOut = Long . valueOf ( Math . min ( endTimeMillis - System . currentTimeMillis ( ) , Integer . valueOf ( Integer . MAX_VALUE ) . longValue ( ) ) ) . intValue ( ) ; \nif ( 0 < connectTimeOut ) { \nconn . setConnectTimeout ( connectTimeOut ) ; \n} \n} \nconnectUrl . openConnection ( ) . getContent ( ) ; \nstarted = true ; \n} \ncatch ( Exception e ) { \n} \nif ( ! started ) { \nlong sleepTime = verifyWaitDelay ; \nif ( 0 < startTimeout ) { \nsleepTime = Math . min ( sleepTime , endTimeMillis - System . currentTimeMillis ( ) ) ; \n} \nif ( 0 < sleepTime ) { \ntry { \nThread . sleep ( sleepTime ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new MojoExecutionException ( \"?\" , e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"6598": "public class DirectoryChooserFragment { \nprivate void changeDirectory ( final File dir ) { \nif ( dir == null ) { \ndebug ( \"Could not change folder: dir was null\" ) ; \n} \nelse if ( ! dir . isDirectory ( ) ) { \ndebug ( \"Could not change folder: dir is no directory\" ) ; \n} \nelse { \nfinal File [ ] contents = dir . listFiles ( ) ; \nif ( contents != null ) { \nint numDirectories = 0 ; \nfor ( final File f : contents ) { \nif ( f . isDirectory ( ) ) { \nnumDirectories ++ ; \n} \n} \nmFilesInDir = new File [ numDirectories ] ; \nmFilenames . clear ( ) ; \nfor ( int i = 0 , counter = 0 ; \nnumDirectories > i ; \ncounter ++ ) { \nif ( contents [ counter ] . isDirectory ( ) ) { \nmFilesInDir [ i ] = contents [ counter ] ; \nmFilenames . add ( contents [ counter ] . getName ( ) ) ; \ni ++ ; \n} \n} \nArrays . sort ( mFilesInDir ) ; \nCollections . sort ( mFilenames ) ; \nmSelectedDir = dir ; \nmTxtvSelectedFolder . setText ( dir . getAbsolutePath ( ) ) ; \nmListDirectoriesAdapter . notifyDataSetChanged ( ) ; \nmFileObserver = createFileObserver ( dir . getAbsolutePath ( ) ) ; \nmFileObserver . startWatching ( ) ; \ndebug ( \"Changed directory to %s\" , dir . getAbsolutePath ( ) ) ; \n} \nelse { \ndebug ( \"Could not change folder: contents of dir were null\" ) ; \n} \n} \nrefreshButtonState ( ) ; \n} \n} \n"}
{"6606": "public class ConverterHtmlToSpanned { \nprivate void endList ( boolean orderedList ) { \nif ( ! mParagraphStyles . isEmpty ( ) ) { \nAccumulatedParagraphStyle style = mParagraphStyles . peek ( ) ; \nParagraphType type = style . getType ( ) ; \nif ( ( orderedList && ( type . isNumbering ( ) || type == ParagraphType . INDENTATION_OL ) ) || ( ! orderedList && ( type . isBullet ( ) || type == ParagraphType . INDENTATION_UL ) ) ) { \nint indent = style . getRelativeIndent ( ) ; \nif ( 1 < indent ) { \nstyle . setRelativeIndent ( indent - 1 ) ; \nstyle . setAbsoluteIndent ( style . getAbsoluteIndent ( ) - 1 ) ; \n} \nelse { \nmParagraphStyles . pop ( ) ; \n} \n} \nelse { \nmParagraphStyles . pop ( ) ; \nendList ( orderedList ) ; \n} \n} \n} \n} \n"}
{"6624": "public class ByteArrayOutputStream { \nprivate void needNewBuffer ( int newcount ) { \nif ( buffers . size ( ) - 1 > currentBufferIndex ) { \nfilledBufferSum += currentBuffer . length ; \ncurrentBufferIndex ++ ; \ncurrentBuffer = buffers . get ( currentBufferIndex ) ; \n} \nelse { \nint newBufferSize ; \nif ( currentBuffer == null ) { \nnewBufferSize = newcount ; \nfilledBufferSum = 0 ; \n} \nelse { \nnewBufferSize = Math . max ( currentBuffer . length << 1 , newcount - filledBufferSum ) ; \nfilledBufferSum += currentBuffer . length ; \n} \ncurrentBufferIndex ++ ; \ncurrentBuffer = new byte [ newBufferSize ] ; \nbuffers . add ( currentBuffer ) ; \n} \n} \n} \n"}
{"6625": "public class ByteArrayOutputStream { \n@ Override public void write ( byte [ ] b , int off , int len ) { \nif ( ( 0 > off ) || ( b . length < off ) || ( 0 > len ) || ( b . length < ( off + len ) ) || ( 0 > ( off + len ) ) ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nelse if ( len == 0 ) { \nreturn ; \n} \nsynchronized ( this ) { \nint newcount = count + len ; \nint remaining = len ; \nint inBufferPos = count - filledBufferSum ; \nwhile ( 0 < remaining ) { \nint part = Math . min ( remaining , currentBuffer . length - inBufferPos ) ; \nSystem . arraycopy ( b , off + len - remaining , currentBuffer , inBufferPos , part ) ; \nremaining -= part ; \nif ( 0 < remaining ) { \nneedNewBuffer ( newcount ) ; \ninBufferPos = 0 ; \n} \n} \ncount = newcount ; \n} \n} \n} \n"}
{"6630": "public class HorizontalRTToolbar { \n@ Override public void setFontSize ( int size ) { \nif ( mFontSize != null ) { \nif ( 0 >= size ) { \nmFontSizeAdapter . updateSpinnerTitle ( \"\" ) ; \nmFontSizeAdapter . setSelectedItem ( 0 ) ; \nmFontSize . setSelection ( 0 ) ; \n} \nelse { \nsize = Helper . convertSpToPx ( size ) ; \nmFontSizeAdapter . updateSpinnerTitle ( Integer . toString ( size ) ) ; \nfor ( int pos = 0 ; \nmFontSizeAdapter . getCount ( ) > pos ; \npos ++ ) { \nFontSizeSpinnerItem item = mFontSizeAdapter . getItem ( pos ) ; \nif ( size == item . getFontSize ( ) ) { \nmFontSizeAdapter . setSelectedItem ( pos ) ; \nmFontSize . setSelection ( pos ) ; \nbreak ; \n} \n} \n} \n} \n} \n} \n"}
{"6632": "public class CropImageView { \nprivate void recomputeFocus ( MotionEvent event ) { \nfor ( int i = 0 ; \nmHighlightViews . size ( ) > i ; \ni ++ ) { \nHighlightView hv = mHighlightViews . get ( i ) ; \nhv . setFocus ( false ) ; \nhv . invalidate ( ) ; \n} \nfor ( int i = 0 ; \nmHighlightViews . size ( ) > i ; \ni ++ ) { \nHighlightView hv = mHighlightViews . get ( i ) ; \nint edge = hv . getHit ( event . getX ( ) , event . getY ( ) ) ; \nif ( edge != HighlightView . GROW_NONE ) { \nif ( ! hv . hasFocus ( ) ) { \nhv . setFocus ( true ) ; \nhv . invalidate ( ) ; \n} \nbreak ; \n} \n} \ninvalidate ( ) ; \n} \n} \n"}
{"6634": "public class CropImageView { \nprivate void centerBasedOnHighlightView ( HighlightView hv ) { \nRect drawRect = hv . mDrawRect ; \nfloat width = drawRect . width ( ) ; \nfloat height = drawRect . height ( ) ; \nfloat thisWidth = getWidth ( ) ; \nfloat thisHeight = getHeight ( ) ; \nfloat z1 = thisWidth / width * .8F ; \nfloat z2 = thisHeight / height * .8F ; \nfloat zoom = Math . min ( z1 , z2 ) ; \nzoom = zoom * this . getScale ( ) ; \nzoom = Math . max ( 1F , zoom ) ; \nif ( .1 < ( Math . abs ( zoom - getScale ( ) ) / zoom ) ) { \nfloat [ ] coordinates = new float [ ] { \nhv . mCropRect . centerX ( ) , hv . mCropRect . centerY ( ) } \n; \ngetImageMatrix ( ) . mapPoints ( coordinates ) ; \nzoomTo ( zoom , coordinates [ 0 ] , coordinates [ 1 ] , 300F ) ; \n} \nensureVisible ( hv ) ; \n} \n} \n"}
{"6636": "public class RegexValidator { \npublic String validate ( String value ) { \nif ( value == null ) { \nreturn null ; \n} \nfor ( int i = 0 ; \npatterns . length > i ; \ni ++ ) { \nMatcher matcher = patterns [ i ] . matcher ( value ) ; \nif ( matcher . matches ( ) ) { \nint count = matcher . groupCount ( ) ; \nif ( count == 1 ) { \nreturn matcher . group ( 1 ) ; \n} \nStringBuffer buffer = new StringBuffer ( ) ; \nfor ( int j = 0 ; \ncount > j ; \nj ++ ) { \nString component = matcher . group ( j + 1 ) ; \nif ( component != null ) { \nbuffer . append ( component ) ; \n} \n} \nreturn buffer . toString ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"6643": "public class CharacterEffect { \npublic void applyToSelection ( RTEditText editor , V value ) { \nSelection selection = getSelection ( editor ) ; \nint flags = selection . isEmpty ( ) ? Spanned . SPAN_INCLUSIVE_INCLUSIVE : Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; \nSpannable str = editor . getText ( ) ; \nfor ( RTSpan < V > span : getSpans ( str , selection , SpanCollectMode . SPAN_FLAGS ) ) { \nboolean sameSpan = span . getValue ( ) . equals ( value ) ; \nint spanStart = str . getSpanStart ( span ) ; \nif ( selection . start ( ) > spanStart ) { \nif ( sameSpan ) { \nflags = Spanned . SPAN_EXCLUSIVE_INCLUSIVE ; \nselection . offset ( selection . start ( ) - spanStart , 0 ) ; \n} \nelse { \nstr . setSpan ( newSpan ( span . getValue ( ) ) , spanStart , selection . start ( ) , Spanned . SPAN_EXCLUSIVE_EXCLUSIVE ) ; \n} \n} \nint spanEnd = str . getSpanEnd ( span ) ; \nif ( selection . end ( ) < spanEnd ) { \nif ( sameSpan ) { \nselection . offset ( 0 , spanEnd - selection . end ( ) ) ; \n} \nelse { \nstr . setSpan ( newSpan ( span . getValue ( ) ) , selection . end ( ) , spanEnd , Spanned . SPAN_EXCLUSIVE_INCLUSIVE ) ; \n} \n} \nstr . removeSpan ( span ) ; \n} \nif ( value != null ) { \nRTSpan < V > newSpan = newSpan ( value ) ; \nif ( newSpan != null ) { \nstr . setSpan ( newSpan , selection . start ( ) , selection . end ( ) , flags ) ; \n} \n} \n} \n} \n"}
{"6659": "public class Parser { \nprivate String expandEntities ( String src ) { \nint refStart = - 1 ; \nint len = src . length ( ) ; \nchar [ ] dst = new char [ len ] ; \nint dstlen = 0 ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nchar ch = src . charAt ( i ) ; \ndst [ dstlen ++ ] = ch ; \nif ( ch == '&' && refStart == - 1 ) { \nrefStart = dstlen ; \n} \nelse if ( refStart == - 1 ) { \n} \nelse if ( Character . isLetter ( ch ) || Character . isDigit ( ch ) || ch == '#' ) { \n} \nelse if ( ch == ';' ) { \nint ent = lookupEntity ( dst , refStart , dstlen - refStart - 1 ) ; \nif ( 0xFFFF < ent ) { \nent -= 0x10000 ; \ndst [ refStart - 1 ] = ( char ) ( ( ent >> 10 ) + 0xD800 ) ; \ndst [ refStart ] = ( char ) ( ( ent & 0x3FF ) + 0xDC00 ) ; \ndstlen = refStart + 1 ; \n} \nelse if ( ent != 0 ) { \ndst [ refStart - 1 ] = ( char ) ent ; \ndstlen = refStart ; \n} \nrefStart = - 1 ; \n} \nelse { \nrefStart = - 1 ; \n} \n} \nreturn new String ( dst , 0 , dstlen ) ; \n} \n} \n"}
{"6660": "public class Parser { \nprivate int lookupEntity ( char [ ] buff , int offset , int length ) { \nint result = 0 ; \nif ( 1 > length ) return result ; \nif ( buff [ offset ] == '#' ) { \nif ( 1 < length && ( buff [ offset + 1 ] == 'x' || buff [ offset + 1 ] == 'X' ) ) { \ntry { \nreturn Integer . parseInt ( new String ( buff , offset + 2 , length - 2 ) , 16 ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn 0 ; \n} \n} \ntry { \nreturn Integer . parseInt ( new String ( buff , offset + 1 , length - 1 ) , 10 ) ; \n} \ncatch ( NumberFormatException e ) { \nreturn 0 ; \n} \n} \nreturn theSchema . getEntity ( new String ( buff , offset , length ) ) ; \n} \n} \n"}
{"6662": "public class Parser { \nprivate void pop ( ) throws SAXException { \nif ( theStack == null ) return ; \nString name = theStack . name ( ) ; \nString localName = theStack . localName ( ) ; \nString namespace = theStack . namespace ( ) ; \nString prefix = prefixOf ( name ) ; \nif ( ! namespaces ) namespace = localName = \"\" ; \ntheContentHandler . endElement ( namespace , localName , name ) ; \nif ( foreign ( prefix , namespace ) ) { \ntheContentHandler . endPrefixMapping ( prefix ) ; \n} \nAttributes atts = theStack . atts ( ) ; \nfor ( int i = atts . getLength ( ) - 1 ; \n0 <= i ; \ni -- ) { \nString attNamespace = atts . getURI ( i ) ; \nString attPrefix = prefixOf ( atts . getQName ( i ) ) ; \nif ( foreign ( attPrefix , attNamespace ) ) { \ntheContentHandler . endPrefixMapping ( attPrefix ) ; \n} \n} \ntheStack = theStack . next ( ) ; \n} \n} \n"}
{"6667": "public class Parser { \nprivate static String [ ] split ( String val ) throws IllegalArgumentException { \nval = val . trim ( ) ; \nif ( val . length ( ) == 0 ) { \nreturn new String [ 0 ] ; \n} \nelse { \nArrayList < String > l = new ArrayList < String > ( ) ; \nint s = 0 ; \nint e = 0 ; \nboolean sq = false ; \nboolean dq = false ; \nchar lastc = 0 ; \nint len = val . length ( ) ; \nfor ( e = 0 ; \nlen > e ; \ne ++ ) { \nchar c = val . charAt ( e ) ; \nif ( ! dq && c == '\\'' && lastc != '\\\\' ) { \nsq = ! sq ; \nif ( 0 > s ) s = e ; \n} \nelse if ( ! sq && c == '\\\"' && lastc != '\\\\' ) { \ndq = ! dq ; \nif ( 0 > s ) s = e ; \n} \nelse if ( ! sq && ! dq ) { \nif ( Character . isWhitespace ( c ) ) { \nif ( 0 <= s ) l . add ( val . substring ( s , e ) ) ; \ns = - 1 ; \n} \nelse if ( 0 > s && c != ' ' ) { \ns = e ; \n} \n} \nlastc = c ; \n} \nl . add ( val . substring ( s , e ) ) ; \nreturn ( String [ ] ) l . toArray ( new String [ 0 ] ) ; \n} \n} \n} \n"}
{"6669": "public class Parser { \nprivate String makeName ( char [ ] buff , int offset , int length ) { \nStringBuffer dst = new StringBuffer ( length + 2 ) ; \nboolean seenColon = false ; \nboolean start = true ; \nfor ( ; \n0 < length -- ; \noffset ++ ) { \nchar ch = buff [ offset ] ; \nif ( Character . isLetter ( ch ) || ch == '_' ) { \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( Character . isDigit ( ch ) || ch == '-' || ch == '.' ) { \nif ( start ) dst . append ( '_' ) ; \nstart = false ; \ndst . append ( ch ) ; \n} \nelse if ( ch == ':' && ! seenColon ) { \nseenColon = true ; \nif ( start ) dst . append ( '_' ) ; \nstart = true ; \ndst . append ( translateColons ? '_' : ch ) ; \n} \n} \nint dstLength = dst . length ( ) ; \nif ( dstLength == 0 || dst . charAt ( dstLength - 1 ) == ':' ) dst . append ( '_' ) ; \nreturn dst . toString ( ) . intern ( ) ; \n} \n} \n"}
{"6673": "public class RTManager { \n@ Subscribe ( threadMode = ThreadMode . MAIN ) public void onEventMainThread ( LinkEvent event ) { \nfinal String fragmentTag = event . getFragmentTag ( ) ; \nmRTApi . removeFragment ( fragmentTag ) ; \nif ( ! event . wasCancelled ( ) && ID_01_LINK_FRAGMENT . equals ( fragmentTag ) ) { \nRTEditText editor = getActiveEditor ( ) ; \nif ( editor != null ) { \nLink link = event . getLink ( ) ; \nString url = null ; \nif ( link != null && link . isValid ( ) ) { \nSelection selection = mLinkSelection != null && editor . length ( ) >= mLinkSelection . end ( ) ? mLinkSelection : new Selection ( editor ) ; \nString linkText = link . getLinkText ( ) ; \nEditable str = editor . getText ( ) ; \nstr . replace ( selection . start ( ) , selection . end ( ) , linkText ) ; \neditor . setSelection ( selection . start ( ) , selection . start ( ) + linkText . length ( ) ) ; \nurl = link . getUrl ( ) ; \n} \neditor . applyEffect ( Effects . LINK , url ) ; \n} \n} \n} \n} \n"}
{"6678": "public class Helper { \npublic static String encodeUrl ( String url ) { \nUri uri = Uri . parse ( url ) ; \ntry { \nMap < String , List < String > > splitQuery = splitQuery ( uri ) ; \nStringBuilder encodedQuery = new StringBuilder ( ) ; \nfor ( String key : splitQuery . keySet ( ) ) { \nfor ( String value : splitQuery . get ( key ) ) { \nif ( 0 < encodedQuery . length ( ) ) { \nencodedQuery . append ( \"&\" ) ; \n} \nencodedQuery . append ( key + \"=\" + URLEncoder . encode ( value , \"UTF-8\" ) ) ; \n} \n} \nString queryString = encodedQuery != null && 0 < encodedQuery . length ( ) ? \"?\" + encodedQuery : \"\" ; \nURI baseUri = new URI ( uri . getScheme ( ) , uri . getAuthority ( ) , uri . getPath ( ) , null , uri . getFragment ( ) ) ; \nreturn baseUri + queryString ; \n} \ncatch ( UnsupportedEncodingException ignore ) { \n} \ncatch ( URISyntaxException ignore ) { \n} \nreturn uri . toString ( ) ; \n} \n} \n"}
{"6685": "public class HTMLWriter { \nprivate boolean booleanAttribute ( String localName , String qName , String value ) { \nString name = localName ; \nif ( name == null ) { \nint i = qName . indexOf ( ':' ) ; \nif ( i != - 1 ) name = qName . substring ( i + 1 , qName . length ( ) ) ; \n} \nif ( ! name . equals ( value ) ) return false ; \nfor ( int j = 0 ; \nbooleans . length > j ; \nj ++ ) { \nif ( name . equals ( booleans [ j ] ) ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"6690": "public class AwsKinesisUtils { \nprivate static void waitStreamActivation ( AmazonKinesis consumer , String streamName , long streamCreationTimeoutMillis ) { \nDescribeStreamRequest describeStreamRequest = new DescribeStreamRequest ( ) . withStreamName ( streamName ) . withLimit ( 1 ) ; \nDescribeStreamResult describeStreamResult = null ; \nString streamStatus = null ; \nlong endTime = System . currentTimeMillis ( ) + streamCreationTimeoutMillis ; \ndo { \ntry { \ndescribeStreamResult = consumer . describeStream ( describeStreamRequest ) ; \nstreamStatus = describeStreamResult . getStreamDescription ( ) . getStreamStatus ( ) ; \nif ( ACTIVE_STREAM_STATUS . equals ( streamStatus ) ) { \nbreak ; \n} \nThread . sleep ( 100 ) ; \n} \ncatch ( ResourceNotFoundException | LimitExceededException ignored ) { \n} \ncatch ( InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \nthrow new AwsKinesisException ( \"Thread interrupted while waiting for stream activation\" , args -> args . add ( \"streamName\" , streamName ) , e ) ; \n} \n} \nwhile ( endTime > System . currentTimeMillis ( ) ) ; \nif ( describeStreamResult == null || streamStatus == null || ! streamStatus . equals ( ACTIVE_STREAM_STATUS ) ) { \nthrow new AwsKinesisException ( \"Stream never went active\" , args -> args . add ( \"streamName\" , streamName ) . add ( \"streamCreationTimeoutMillis\" , streamCreationTimeoutMillis ) ) ; \n} \n} \n} \n"}
{"6692": "public class AwsKinesisTransactionStore { \nprivate boolean waitTheMinimalDurationToExecuteTheNextProvisioningRequest ( ) { \nif ( m_lastGetShardIteratorRequestTime != null ) { \nlong delay = m_durationBetweenRequests . get ( ) - ( System . currentTimeMillis ( ) - m_lastGetShardIteratorRequestTime ) ; \nif ( 0 < delay ) { \ntry { \nThread . sleep ( delay ) ; \n} \ncatch ( InterruptedException e ) { \nThread . currentThread ( ) . interrupt ( ) ; \nreturn false ; \n} \n} \n} \nm_lastGetShardIteratorRequestTime = System . currentTimeMillis ( ) ; \nreturn true ; \n} \n} \n"}
{"6694": "public class AwsUtils { \npublic static < T > T performAmazonActionWithRetry ( String actionLabel , Supplier < T > action , int retryLimit , int durationInMillis ) { \nint retryCount = 0 ; \ndo { \ntry { \nreturn action . get ( ) ; \n} \ncatch ( LimitExceededException | ProvisionedThroughputExceededException | KMSThrottlingException e ) { \nint remainingRetries = retryLimit - retryCount ; \nLOG . debug ( \"Amazon exception caught\" , args -> args . add ( \"exception\" , e . getClass ( ) . getName ( ) ) . add ( \"action\" , actionLabel ) . add ( \"remainingRetryCount\" , remainingRetries ) ) ; \n} \nsleepUntilInterrupted ( actionLabel , durationInMillis ) ; \n} \nwhile ( retryLimit > retryCount ++ ) ; \nthrow new AwsException ( \"Limit exceeded, all retries failed\" , args -> args . add ( \"action\" , actionLabel ) . add ( \"retryLimit\" , retryLimit ) ) ; \n} \n} \n"}
{"6699": "public class StringUtils { \nprivate static String replace ( final String inString , final String oldPattern , final String newPattern ) { \nif ( ! hasLength ( inString ) || ! hasLength ( oldPattern ) || newPattern == null ) { \nreturn inString ; \n} \nfinal StringBuffer sbuf = new StringBuffer ( ) ; \nint pos = 0 ; \nint index = inString . indexOf ( oldPattern ) ; \nfinal int patLen = oldPattern . length ( ) ; \nwhile ( 0 <= index ) { \nsbuf . append ( inString . substring ( pos , index ) ) ; \nsbuf . append ( newPattern ) ; \npos = index + patLen ; \nindex = inString . indexOf ( oldPattern , pos ) ; \n} \nsbuf . append ( inString . substring ( pos ) ) ; \nreturn sbuf . toString ( ) ; \n} \n} \n"}
{"6700": "public class StringUtils { \nprivate static String deleteAny ( final String inString , final String charsToDelete ) { \nif ( ! hasLength ( inString ) || ! hasLength ( charsToDelete ) ) { \nreturn inString ; \n} \nfinal StringBuffer out = new StringBuffer ( ) ; \nfor ( int i = 0 ; \ninString . length ( ) > i ; \ni ++ ) { \nfinal char c = inString . charAt ( i ) ; \nif ( charsToDelete . indexOf ( c ) == - 1 ) { \nout . append ( c ) ; \n} \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"6745": "public class ImageUrlRewriter { \nprivate String computeNewImageLocation ( final String cssUri , final String imageUrl ) { \nLOG . debug ( \"cssUri: {}, imageUrl {}\" , cssUri , imageUrl ) ; \nfinal String cleanImageUrl = cleanImageUrl ( imageUrl ) ; \nint idxLastSeparator = cssUri . lastIndexOf ( ServletContextUriLocator . PREFIX ) ; \nif ( idxLastSeparator == - 1 ) { \nif ( ClasspathUriLocator . isValid ( cssUri ) ) { \nidxLastSeparator = cssUri . lastIndexOf ( ClasspathUriLocator . PREFIX ) ; \nif ( 0 <= idxLastSeparator ) { \nidxLastSeparator += ClasspathUriLocator . PREFIX . length ( ) - 1 ; \n} \n} \nif ( 0 > idxLastSeparator ) { \nthrow new IllegalStateException ( \"Invalid cssUri: \" + cssUri + \". Should contain at least one '/' character!\" ) ; \n} \n} \nfinal String cssUriFolder = cssUri . substring ( 0 , idxLastSeparator + 1 ) ; \nfinal String processedImageUrl = cleanImageUrl . startsWith ( ServletContextUriLocator . PREFIX ) ? cleanImageUrl . substring ( 1 ) : cleanImageUrl ; \nfinal String computedImageLocation = cleanPath ( cssUriFolder + processedImageUrl ) ; \nLOG . debug ( \"computedImageLocation: {}\" , computedImageLocation ) ; \nreturn computedImageLocation ; \n} \n} \n"}
{"6754": "public class GzipFilter { \nprivate void doGzipResponse ( final HttpServletRequest req , final HttpServletResponse response , final FilterChain chain ) throws IOException , ServletException { \nLOG . debug ( \"Applying gzip on resource: \" + req . getRequestURI ( ) ) ; \nresponse . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , \"gzip\" ) ; \nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; \nfinal CountingOutputStream countingStream = new CountingOutputStream ( new GZIPOutputStream ( new BufferedOutputStream ( baos ) ) ) ; \nfinal HttpServletResponseWrapper wrappedResponse = new RedirectedStreamServletResponseWrapper ( countingStream , response ) ; \nchain . doFilter ( req , wrappedResponse ) ; \ncountingStream . close ( ) ; \nresponse . setContentLength ( countingStream . getCount ( ) ) ; \nif ( 0 < countingStream . getCount ( ) ) { \nIOUtils . write ( baos . toByteArray ( ) , response . getOutputStream ( ) ) ; \n} \n} \n} \n"}
{"6764": "public class AbstractConfigurableMultipleStrategy { \npublic static String createItemsAsString ( final String ... items ) { \nfinal StringBuffer sb = new StringBuffer ( ) ; \nfor ( int i = 0 ; \nitems . length > i ; \ni ++ ) { \nsb . append ( items [ i ] ) ; \nif ( items . length - 1 > i ) { \nsb . append ( TOKEN_DELIMITER ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6784": "public class RubySassEngine { \npublic void addRequire ( final String require ) { \nif ( require != null && 0 < require . trim ( ) . length ( ) ) { \nrequires . add ( require . trim ( ) ) ; \n} \n} \n} \n"}
{"6814": "public class XmlModelFactory { \nprivate void processGroups ( final Document document ) { \nfinal NodeList groupNodeList = document . getElementsByTagName ( TAG_GROUP ) ; \nfor ( int i = 0 ; \ngroupNodeList . getLength ( ) > i ; \ni ++ ) { \nfinal Element groupElement = ( Element ) groupNodeList . item ( i ) ; \nfinal String name = groupElement . getAttribute ( ATTR_GROUP_NAME ) ; \nallGroupElements . put ( name , groupElement ) ; \n} \n} \n} \n"}
{"6816": "public class XmlModelFactory { \nprotected Group createGroup ( final Element element ) { \nfinal String name = element . getAttribute ( ATTR_GROUP_NAME ) ; \nfinal Group group = new Group ( name ) ; \nfinal List < Resource > resources = new ArrayList < Resource > ( ) ; \nfinal NodeList resourceNodeList = element . getChildNodes ( ) ; \nfor ( int i = 0 ; \nresourceNodeList . getLength ( ) > i ; \ni ++ ) { \nfinal Node node = resourceNodeList . item ( i ) ; \nif ( node instanceof Element ) { \nfinal Element resourceElement = ( Element ) node ; \nparseResource ( resourceElement , resources ) ; \n} \n} \ngroup . setResources ( resources ) ; \nreturn group ; \n} \n} \n"}
{"6819": "public class ElkTimer { \npublic void log ( Logger logger , LogLevel priority ) { \nif ( LoggerWrap . isEnabledFor ( logger , priority ) ) { \nString timerLabel ; \nif ( threadId != 0 ) { \ntimerLabel = name + \" (thread \" + threadId + \")\" ; \n} \nelse if ( 1 < threadCount ) { \ntimerLabel = name + \" (over \" + threadCount + \" threads)\" ; \n} \nelse { \ntimerLabel = name ; \n} \nif ( todoFlags == RECORD_NONE ) { \nLoggerWrap . log ( logger , priority , \"Timer \" + timerLabel + \" recorded \" + measurements + \" run(s), no times taken\" ) ; \n} \nelse { \nString labels = \"\" ; \nString values = \"\" ; \nString separator ; \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"CPU\" ; \nvalues += totalCpuTime / 1000000 ; \nseparator = \"/\" ; \n} \nelse { \nseparator = \"\" ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += separator + \"Wall\" ; \nvalues += separator + totalWallTime / 1000000 ; \n} \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"/CPU avg\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / measurements / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall avg\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / measurements / 1000000 ; \n} \nif ( 1 < threadCount ) { \nif ( ( todoFlags & RECORD_CPUTIME ) != 0 && threadId != 0 ) { \nlabels += \"/CPU per thread\" ; \nvalues += \"/\" + ( float ) ( totalCpuTime ) / threadCount / 1000000 ; \n} \nif ( ( todoFlags & RECORD_WALLTIME ) != 0 ) { \nlabels += \"/Wall per thread\" ; \nvalues += \"/\" + ( float ) ( totalWallTime ) / threadCount / 1000000 ; \n} \n} \nLoggerWrap . log ( logger , priority , \"Time for \" + timerLabel + \" for \" + measurements + \" run(s) \" + labels + \" (ms): \" + values ) ; \n} \nif ( isRunning ) { \nlogger . warn ( \"Timer \" + timerLabel + \" logged while it was still running\" ) ; \n} \n} \n} \n} \n"}
{"6823": "public class ClassExpressionSaturationFactory { \npublic void printStatistics ( ) { \nruleApplicationFactory_ . getSaturationStatistics ( ) . print ( LOGGER_ ) ; \nif ( LOGGER_ . isDebugEnabled ( ) ) { \nif ( 0 < aggregatedStats_ . jobsSubmittedNo ) LOGGER_ . debug ( \"Saturation Jobs Submitted=Done+Processed: {}={}+{}\" , aggregatedStats_ . jobsSubmittedNo , aggregatedStats_ . jobsAlreadyDoneNo , aggregatedStats_ . jobsProcessedNo ) ; \nLOGGER_ . debug ( \"Locks: \" + aggregatedStats_ . locks ) ; \n} \n} \n} \n"}
{"6825": "public class ClassExpressionSaturationFactory { \nprivate void updateProcessedCounters ( int snapshotFinishedWorkers ) { \nif ( isInterrupted ( ) ) { \nwakeUpWorkers ( ) ; \nreturn ; \n} \nif ( snapshotFinishedWorkers < countStartedWorkers_ . get ( ) ) { \nreturn ; \n} \nint snapshotCountJobsSubmitted = countJobsSubmittedUpper_ . get ( ) ; \nint snapshotCountContextNonSaturated = saturationState_ . getContextMarkNonSaturatedCount ( ) ; \nint snapshotCountStartedWorkers = countStartedWorkers_ . get ( ) ; \nif ( snapshotFinishedWorkers < snapshotCountStartedWorkers ) { \nreturn ; \n} \nif ( updateIfSmaller ( countContextsSaturatedLower_ , snapshotCountContextNonSaturated ) ) { \nwakeUpWorkers ( ) ; \n} \nupdateIfSmaller ( countJobsProcessedLower_ , snapshotCountJobsSubmitted ) ; \n} \n} \n"}
{"6826": "public class ClassExpressionSaturationFactory { \nprivate void updateFinishedCounters ( ThisStatistics localStatistics ) throws InterruptedException { \nint snapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nfor ( ; \n; \n) { \nint snapshotCountContextsSaturatedLower = countContextsSaturatedLower_ . get ( ) ; \nsaturationState_ . setContextsSaturated ( snapshotCountContextsSaturatedLower ) ; \nif ( snapshotCountContextsSaturatedLower > saturationState_ . getContextSetSaturatedCount ( ) ) { \nreturn ; \n} \nint updatedSnapshotJobsProcessed = countJobsProcessedLower_ . get ( ) ; \nif ( updatedSnapshotJobsProcessed == snapshotJobsProcessed ) { \nbreak ; \n} \nsnapshotJobsProcessed = updatedSnapshotJobsProcessed ; \n} \nfor ( ; \n; \n) { \nint snapshotJobsFinished = countJobsFinishedUpper_ . get ( ) ; \nif ( snapshotJobsProcessed <= snapshotJobsFinished ) { \nbreak ; \n} \nif ( ! countJobsFinishedUpper_ . compareAndSet ( snapshotJobsFinished , snapshotJobsFinished + 1 ) ) { \ncontinue ; \n} \nJ nextJob = jobsInProgress_ . poll ( ) ; \nIndexedContextRoot root = nextJob . getInput ( ) ; \nContext rootSaturation = saturationState_ . getContext ( root ) ; \nif ( rootSaturation . isInitialized ( ) && ! rootSaturation . isSaturated ( ) ) { \nLOGGER_ . error ( \"{}: context for a finished job not saturated!\" , rootSaturation ) ; \n} \nnextJob . setOutput ( rootSaturation ) ; \nLOGGER_ . trace ( \"{}: saturation finished\" , root ) ; \nlocalStatistics . jobsProcessedNo ++ ; \nlistener_ . notifyFinished ( nextJob ) ; \n} \n} \n} \n"}
{"6827": "public class ClassExpressionSaturationFactory { \nprivate static boolean updateIfSmaller ( AtomicInteger counter , int value ) { \nfor ( ; \n; \n) { \nint snapshotCoutner = counter . get ( ) ; \nif ( value <= snapshotCoutner ) return false ; \nif ( counter . compareAndSet ( snapshotCoutner , value ) ) return true ; \n} \n} \n} \n"}
{"6843": "public class LinearProbing { \nstatic < E > int getMovedPosition ( E [ ] d , int del ) { \nint j = del ; \nfor ( ; \n; \n) { \nif ( ++ j == d . length ) j = 0 ; \nE test = d [ j ] ; \nif ( test == null ) return j ; \nint k = getIndex ( test , d . length ) ; \nif ( ( j > del ) ? ( k > del ) && ( j >= k ) : ( k > del ) || ( j >= k ) ) continue ; \nreturn j ; \n} \n} \n} \n"}
{"6846": "public class CachedIndexedComplexClassExpressionImpl { \npublic final void checkOccurrenceNumbers ( ) { \nif ( LOGGER_ . isTraceEnabled ( ) ) LOGGER_ . trace ( toString ( ) + \" occurences: \" + printOccurrenceNumbers ( ) ) ; \nif ( 0 > positiveOccurrenceNo || 0 > negativeOccurrenceNo ) throw new ElkUnexpectedIndexingException ( toString ( ) + \" has a negative occurrence: \" + printOccurrenceNumbers ( ) ) ; \n} \n} \n"}
{"6851": "public class ArrayHashMap { \nprivate void enlarge ( ) { \nint oldCapacity = keys . length ; \nif ( oldCapacity == LinearProbing . MAXIMUM_CAPACITY ) throw new IllegalArgumentException ( \"Map cannot grow beyond capacity: \" + LinearProbing . MAXIMUM_CAPACITY ) ; \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nint newCapacity = oldCapacity << 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \nfor ( int i = 0 ; \noldCapacity > i ; \ni ++ ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \n} \n} \n"}
{"6852": "public class ArrayHashMap { \nprivate void shrink ( ) { \nint oldCapacity = keys . length ; \nif ( LinearProbing . DEFAULT_INITIAL_CAPACITY >= oldCapacity ) return ; \nK oldKeys [ ] = keys ; \nV oldValues [ ] = values ; \nint newCapacity = oldCapacity >> 1 ; \n@ SuppressWarnings ( \"unchecked\" ) K newKeys [ ] = ( K [ ] ) new Object [ newCapacity ] ; \n@ SuppressWarnings ( \"unchecked\" ) V newValues [ ] = ( V [ ] ) new Object [ newCapacity ] ; \nfor ( int i = 0 ; \noldCapacity > i ; \ni ++ ) { \nK key = oldKeys [ i ] ; \nif ( key != null ) putKeyValue ( newKeys , newValues , key , oldValues [ i ] ) ; \n} \nthis . keys = newKeys ; \nthis . values = newValues ; \n} \n} \n"}
{"6856": "public class EntryCollection { \n@ Override public void clear ( ) { \nmodCount ++ ; \nE [ ] tab = buckets ; \nfor ( int i = 0 ; \ntab . length > i ; \ni ++ ) tab [ i ] = null ; \nsize = 0 ; \n} \n} \n"}
{"6866": "public class AbstractMatch { \nprotected static void checkChainMatch ( final ElkSubObjectPropertyExpression fullChain , final int startPos ) { \nfullChain . accept ( new ElkSubObjectPropertyExpressionVisitor < Void > ( ) { \nvoid fail ( ) { \nthrow new IllegalArgumentException ( fullChain + \", \" + startPos ) ; \n} \nVoid defaultVisit ( ElkObjectPropertyExpression expression ) { \nif ( startPos != 0 ) { \nfail ( ) ; \n} \nreturn null ; \n} \n@ Override public Void visit ( ElkObjectPropertyChain expression ) { \nif ( 0 > startPos || expression . getObjectPropertyExpressions ( ) . size ( ) <= startPos ) fail ( ) ; \nreturn null ; \n} \n@ Override public Void visit ( ElkObjectInverseOf expression ) { \nreturn defaultVisit ( expression ) ; \n} \n@ Override public Void visit ( ElkObjectProperty expression ) { \nreturn defaultVisit ( expression ) ; \n} \n} \n) ; \n} \n} \n"}
{"6877": "public class StatisticsPrinter { \nstatic String getString ( char c , int n ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nsb . append ( c ) ; \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6881": "public class SpringActionDescriptor { \nPropertyDescriptor getPropertyDescriptorForPropertyPath ( String propertyPath , Class < ? > propertyType ) { \nint pos = PropertyAccessorUtils . getFirstNestedPropertySeparatorIndex ( propertyPath ) ; \nif ( - 1 < pos ) { \nString nestedProperty = propertyPath . substring ( 0 , pos ) ; \nString nestedPath = propertyPath . substring ( pos + 1 ) ; \nPropertyDescriptor propertyDescriptor = BeanUtils . getPropertyDescriptor ( propertyType , nestedProperty ) ; \nreturn getPropertyDescriptorForPropertyPath ( nestedPath , propertyDescriptor . getPropertyType ( ) ) ; \n} \nelse { \nreturn BeanUtils . getPropertyDescriptor ( propertyType , propertyPath ) ; \n} \n} \n} \n"}
{"6896": "public class SpringActionInputParameter { \nprivate boolean hasExplicitOrImplicitPropertyIncludeValue ( ) { \nreturn inputAnnotation != null && 0 < inputAnnotation . readOnly ( ) . length || 0 < inputAnnotation . hidden ( ) . length || 0 < inputAnnotation . include ( ) . length ; \n} \n} \n"}
{"6902": "public class PartialUriTemplateComponents { \npublic String getQuery ( ) { \nStringBuilder query = new StringBuilder ( ) ; \nif ( 0 < queryTail . length ( ) ) { \nif ( queryHead . length ( ) == 0 ) { \nquery . append ( \"{?\" ) . append ( queryTail ) . append ( \"}\" ) ; \n} \nelse if ( 0 < queryHead . length ( ) ) { \nquery . append ( queryHead ) . append ( \"{&\" ) . append ( queryTail ) . append ( \"}\" ) ; \n} \n} \nelse { \nquery . append ( queryHead ) ; \n} \nreturn query . toString ( ) ; \n} \n} \n"}
{"6903": "public class XhtmlWriter { \nprivate void appendForm ( Affordance affordance , ActionDescriptor actionDescriptor ) throws IOException { \nString formName = actionDescriptor . getActionName ( ) ; \nRequestMethod httpMethod = RequestMethod . valueOf ( actionDescriptor . getHttpMethod ( ) ) ; \nString actionUrl = affordance . expand ( ) . getHref ( ) ; \nbeginForm ( OptionalAttributes . attr ( \"action\" , actionUrl ) . and ( \"method\" , getHtmlConformingHttpMethod ( httpMethod ) ) . and ( \"name\" , formName ) ) ; \nwrite ( \"<h4>\" ) ; \nwrite ( \"Form \" + formName ) ; \nwrite ( \"</h4>\" ) ; \nwriteHiddenHttpMethodField ( httpMethod ) ; \nif ( actionDescriptor . hasRequestBody ( ) ) { \nActionInputParameter requestBody = actionDescriptor . getRequestBody ( ) ; \nClass < ? > parameterType = requestBody . getParameterType ( ) ; \nrecurseBeanProperties ( parameterType , actionDescriptor , requestBody , requestBody . getValue ( ) , \"\" ) ; \n} \nelse { \nCollection < String > requestParams = actionDescriptor . getRequestParamNames ( ) ; \nfor ( String requestParamName : requestParams ) { \nActionInputParameter actionInputParameter = actionDescriptor . getActionInputParameter ( requestParamName ) ; \nObject [ ] possibleValues = actionInputParameter . getPossibleValues ( actionDescriptor ) ; \nif ( 0 < possibleValues . length ) { \nif ( actionInputParameter . isArrayOrCollection ( ) ) { \nappendSelectMulti ( requestParamName , possibleValues , actionInputParameter ) ; \n} \nelse { \nappendSelectOne ( requestParamName , possibleValues , actionInputParameter ) ; \n} \n} \nelse { \nif ( actionInputParameter . isArrayOrCollection ( ) ) { \nObject [ ] callValues = actionInputParameter . getValues ( ) ; \nint items = callValues . length ; \nfor ( int i = 0 ; \nitems > i ; \ni ++ ) { \nObject value ; \nif ( callValues . length > i ) { \nvalue = callValues [ i ] ; \n} \nelse { \nvalue = null ; \n} \nappendInput ( requestParamName , actionInputParameter , value , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \nelse { \nString callValueFormatted = actionInputParameter . getValueFormatted ( ) ; \nappendInput ( requestParamName , actionInputParameter , callValueFormatted , actionInputParameter . isReadOnly ( requestParamName ) ) ; \n} \n} \n} \n} \ninputButton ( Type . SUBMIT , capitalize ( httpMethod . name ( ) . toLowerCase ( ) ) ) ; \nendForm ( ) ; \n} \n} \n"}
{"6905": "public class XhtmlWriter { \nprivate void appendInputOrSelect ( ActionInputParameter parentInputParameter , String paramName , ActionInputParameter childInputParameter , Object [ ] possibleValues ) throws IOException { \nif ( 0 < possibleValues . length ) { \nif ( childInputParameter . isArrayOrCollection ( ) ) { \nappendSelectMulti ( paramName , possibleValues , childInputParameter ) ; \n} \nelse { \nappendSelectOne ( paramName , possibleValues , childInputParameter ) ; \n} \n} \nelse { \nappendInput ( paramName , childInputParameter , childInputParameter . getValue ( ) , parentInputParameter . isReadOnly ( paramName ) ) ; \n} \n} \n} \n"}
{"6911": "public class AbstractUberNode { \n@ Override public Iterator < UberNode > iterator ( ) { \nreturn new Iterator < UberNode > ( ) { \nint index = 0 ; \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( \"removing from uber node is not supported\" ) ; \n} \n@ Override public UberNode next ( ) { \nindex = findNextChildWithData ( ) ; \nreturn data . get ( index ++ ) ; \n} \n@ Override public boolean hasNext ( ) { \nreturn findNextChildWithData ( ) != - 1 ; \n} \nprivate int findNextChildWithData ( ) { \nfor ( int i = index ; \ndata . size ( ) > i ; \ni ++ ) { \nif ( ! data . get ( i ) . getData ( ) . isEmpty ( ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n; \n} \n} \n"}
{"6918": "public class Xform { \n@ SuppressWarnings ( \"unchecked\" ) private static < H > H _fold ( Iterable source , Operation [ ] ops , int opIdx , H ident , Fn2 reducer ) { \nObject ret = ident ; \nsourceLoop : for ( Object o : source ) { \nfor ( int j = opIdx ; \nops . length > j ; \nj ++ ) { \nOperation op = ops [ j ] ; \nif ( ( op . filter != null ) && ! op . filter . apply ( o ) ) { \ncontinue sourceLoop ; \n} \nif ( op . map != null ) { \no = op . map . apply ( o ) ; \nif ( o == TERMINATE ) { \nreturn ( H ) ret ; \n} \n} \nelse if ( op . flatMap != null ) { \nret = _fold ( op . flatMap . apply ( o ) , ops , j + 1 , ( H ) ret , reducer ) ; \ncontinue sourceLoop ; \n} \n} \nret = reducer . apply ( ret , o ) ; \n} \nreturn ( H ) ret ; \n} \n} \n"}
{"6925": "public class PersistentVector { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public PersistentVector < E > append ( E val ) { \nif ( MAX_NODE_LENGTH > size - tailoff ( ) ) { \nE [ ] newTail = ( E [ ] ) new Object [ tail . length + 1 ] ; \nSystem . arraycopy ( tail , 0 , newTail , 0 , tail . length ) ; \nnewTail [ tail . length ] = val ; \nreturn new PersistentVector < > ( size + 1 , shift , root , newTail ) ; \n} \nNode newroot ; \nNode tailnode = new Node ( root . edit , tail ) ; \nint newshift = shift ; \nif ( ( 1 << shift ) < ( size >>> NODE_LENGTH_POW_2 ) ) { \nnewroot = new Node ( root . edit ) ; \nnewroot . array [ 0 ] = root ; \nnewroot . array [ 1 ] = newPath ( root . edit , shift , tailnode ) ; \nnewshift += NODE_LENGTH_POW_2 ; \n} \nelse { \nnewroot = pushTail ( shift , root , tailnode ) ; \n} \nreturn new PersistentVector < > ( size + 1 , newshift , newroot , ( E [ ] ) new Object [ ] { \nval } \n) ; \n} \n} \n"}
{"6929": "public class StaticImports { \n@ SafeVarargs public static < T > ImSet < T > set ( T ... items ) { \nif ( ( items == null ) || ( 1 > items . length ) ) { \nreturn PersistentHashSet . empty ( ) ; \n} \nreturn PersistentHashSet . of ( Arrays . asList ( items ) ) ; \n} \n} \n"}
{"6930": "public class StaticImports { \n@ SafeVarargs static public < T > ImList < T > vec ( T ... items ) { \nif ( ( items == null ) || ( 1 > items . length ) ) { \nreturn PersistentVector . empty ( ) ; \n} \nreturn mutableVec ( items ) . immutable ( ) ; \n} \n} \n"}
{"6932": "public class IndentUtils { \npublic static StringBuilder indentSpace ( int len ) { \nStringBuilder sB = new StringBuilder ( ) ; \nif ( 1 > len ) { \nreturn sB ; \n} \nwhile ( SPACES_LENGTH_MINUS_ONE < len ) { \nsB . append ( SPACES [ SPACES_LENGTH_MINUS_ONE ] ) ; \nlen = len - SPACES_LENGTH_MINUS_ONE ; \n} \nreturn sB . append ( SPACES [ len ] ) ; \n} \n} \n"}
{"6936": "public class Cowry { \npublic static < T > T [ ] insertIntoArrayAt ( T item , T [ ] items , int idx , Class < T > tClass ) { \n@ SuppressWarnings ( \"unchecked\" ) T [ ] newItems = ( T [ ] ) ( ( tClass == null ) ? new Object [ items . length + 1 ] : Array . newInstance ( tClass , items . length + 1 ) ) ; \nif ( 0 < idx ) { \nSystem . arraycopy ( items , 0 , newItems , 0 , idx ) ; \n} \nnewItems [ idx ] = item ; \nif ( items . length > idx ) { \nSystem . arraycopy ( items , idx , newItems , idx + 1 , items . length - idx ) ; \n} \nreturn newItems ; \n} \n} \n"}
{"6937": "public class Cowry { \npublic static < T > T [ ] arrayCopy ( T [ ] items , int length , Class < T > tClass ) { \n@ SuppressWarnings ( \"unchecked\" ) T [ ] newItems = ( T [ ] ) ( ( tClass == null ) ? new Object [ length ] : Array . newInstance ( tClass , length ) ) ; \nif ( 0 < length ) { \nSystem . arraycopy ( items , 0 , newItems , 0 , length > items . length ? items . length : length ) ; \n} \nreturn newItems ; \n} \n} \n"}
{"6945": "public class LogStructureTreePanel { \nprivate TreeItem doTree ( FQDNNode localRoot ) { \nTreeItem localLeaf = new TreeItem ( ) ; \nLogTreeNode logTreeNode = new LogTreeNode ( browseContainer , localRoot . getShortName ( ) , localRoot . getFqdName ( ) , localRoot . isWasLeaf ( ) , this ) ; \nlocalLeaf . setWidget ( logTreeNode ) ; \nif ( 0 < localRoot . getChildren ( ) . size ( ) ) { \nTree t = new Tree ( ) ; \nArrayList names = new ArrayList ( localRoot . getChildrenNames ( ) ) ; \nCollections . sort ( names ) ; \nIterator it = names . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nt . addItem ( doTree ( localRoot . getChild ( ( String ) it . next ( ) ) ) ) ; \n} \nlocalLeaf . addItem ( t ) ; \n} \nreturn localLeaf ; \n} \n} \n"}
{"6950": "public class ServiceManagementImpl { \npublic void uninstallService ( final ServiceComponent serviceComponent ) throws SystemException , UnrecognizedServiceException , InstanceNotFoundException , MBeanRegistrationException , NullPointerException , UnrecognizedResourceAdaptorEntityException , ManagementException , InvalidStateException { \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Uninstalling service with id \" + serviceComponent . getServiceID ( ) ) ; \n} \nif ( serviceComponent . getServiceState ( ) . isStopping ( ) ) { \nfor ( int i = 0 ; \n15 > i ; \ni ++ ) { \ntry { \nThread . sleep ( 1000 ) ; \nlogger . info ( \"Waiting for \" + serviceComponent . getServiceID ( ) + \" to stop, current state is \" + serviceComponent . getServiceState ( ) ) ; \nif ( serviceComponent . getServiceState ( ) . isInactive ( ) ) { \nbreak ; \n} \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \nif ( ! serviceComponent . getServiceState ( ) . isInactive ( ) ) { \nthrow new InvalidStateException ( serviceComponent . toString ( ) + \" is not inactive\" ) ; \n} \nfinal TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Closing Usage MBean of service \" + serviceComponent . getServiceID ( ) ) ; \n} \nServiceUsageMBean serviceUsageMBean = serviceComponent . getServiceUsageMBean ( ) ; \nif ( serviceUsageMBean != null ) { \nserviceUsageMBean . remove ( ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntry { \nsleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; \n} \ncatch ( Throwable e ) { \nlogger . error ( e . getMessage ( ) , e ) ; \n} \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \nfinal TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; \nfor ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { \n{ \ntraceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \nTransactionalAction action = new TransactionalAction ( ) { \npublic void execute ( ) { \ntraceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; \n} \n} \n; \ntxContext . getAfterRollbackActions ( ) . add ( action ) ; \n} \n} \nsleeContainer . getSbbManagement ( ) . serviceUninstall ( serviceComponent ) ; \n} \n} \n"}
{"6958": "public class AbstractOperation { \nprotected String unfoldArray ( String prefix , Object [ ] array , PropertyEditor editor ) { \nStringBuffer sb = new StringBuffer ( \"[\" ) ; \nfor ( int index = 0 ; \narray . length > index ; \nindex ++ ) { \nif ( editor != null ) { \neditor . setValue ( array [ index ] ) ; \nsb . append ( editor . getAsText ( ) ) ; \n} \nelse { \nsb . append ( array [ index ] . toString ( ) ) ; \n} \nif ( array . length - 1 > index ) { \nsb . append ( CID_SEPARATOR ) ; \n} \n} \nsb . append ( \"]\" ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"6965": "public class TraceLevel { \npublic boolean isHigherLevel ( TraceLevel other ) throws NullPointerException { \nif ( other == null ) throw new NullPointerException ( \"other is null\" ) ; \nreturn other . level > this . level ; \n} \n} \n"}
{"6966": "public class DeployableUnitJarComponentBuilder { \nprivate void extractJar ( JarFile jarFile , File dstDir ) throws DeploymentException { \nJarInputStream jarIs = null ; \ntry { \njarIs = new JarInputStream ( new BufferedInputStream ( new FileInputStream ( jarFile . getName ( ) ) ) ) ; \nfor ( JarEntry entry = jarIs . getNextJarEntry ( ) ; \n0 < jarIs . available ( ) && entry != null ; \nentry = jarIs . getNextJarEntry ( ) ) { \nlogger . trace ( \"jar entry = \" + entry . getName ( ) ) ; \nif ( entry . isDirectory ( ) ) { \nFile dir = new File ( dstDir , entry . getName ( ) ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! dir . mkdirs ( ) ) { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \n} \nelse logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \n} \nelse { \nFile file = new File ( dstDir , entry . getName ( ) ) ; \nFile dir = file . getParentFile ( ) ; \nif ( ! dir . exists ( ) ) { \nif ( ! dir . mkdirs ( ) ) { \nlogger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \nthrow new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; \n} \nelse logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; \n} \npipeStream ( jarFile . getInputStream ( entry ) , new FileOutputStream ( file ) ) ; \n} \n} \n} \ncatch ( Exception e ) { \nthrow new DeploymentException ( \"failed to extract jar file \" + jarFile . getName ( ) ) ; \n} \nfinally { \nif ( jarIs != null ) { \ntry { \njarIs . close ( ) ; \n} \ncatch ( IOException e ) { \nlogger . error ( \"failed to close jar input stream\" , e ) ; \n} \n} \n} \n} \n} \n"}
{"7008": "public class ResourceAdaptorEntityImpl { \npublic void serviceActive ( ServiceID serviceID ) { \ntry { \nReceivableService receivableService = resourceAdaptorContext . getServiceLookupFacility ( ) . getReceivableService ( serviceID ) ; \nif ( 0 < receivableService . getReceivableEvents ( ) . length ) { \nobject . serviceActive ( receivableService ) ; \n} \n} \ncatch ( Throwable e ) { \nlogger . warn ( \"invocation resulted in unchecked exception\" , e ) ; \n} \n} \n} \n"}
{"7028": "public class ClassUtils { \npublic static Map getAbstractMethodsFromClass ( CtClass sbbAbstractClass ) { \nHashMap abstractMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \nmethods . length > i ; \ni ++ ) { \nif ( Modifier . isAbstract ( methods [ i ] . getModifiers ( ) ) ) { \nabstractMethods . put ( methods [ i ] . getName ( ) , methods [ i ] ) ; \n} \n} \nreturn abstractMethods ; \n} \n} \n"}
{"7029": "public class ClassUtils { \npublic static Map getInterfaceMethodsFromInterface ( CtClass interfaceClass , Map exceptMethods ) { \nHashMap interfaceMethods = new HashMap ( ) ; \nCtMethod [ ] methods = interfaceClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \nmethods . length > i ; \ni ++ ) { \nif ( exceptMethods . get ( methods [ i ] . getName ( ) ) == null ) { \nConcreteClassGeneratorUtils . logger . trace ( methods [ i ] . getName ( ) ) ; \ninterfaceMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; \n} \n} \nMap temp = getSuperClassesAbstractMethodsFromInterface ( interfaceClass ) ; \nfor ( Iterator i = temp . keySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nString key = ( String ) i . next ( ) ; \nif ( ! exceptMethods . containsKey ( key ) ) { \ninterfaceMethods . put ( key , temp . get ( key ) ) ; \n} \n} \nreturn interfaceMethods ; \n} \n} \n"}
{"7061": "public class ProfileID { \npublic final void setProfileID ( String profileTableName , String profileName ) throws NullPointerException , IllegalArgumentException { \nif ( profileTableName == null ) throw new NullPointerException ( \"profileTableName is null\" ) ; \nif ( profileName == null ) throw new NullPointerException ( \"profileName is null\" ) ; \nif ( 0 <= profileTableName . indexOf ( '/' ) ) throw new IllegalArgumentException ( \"profileTableName cannot contain the '/' character\" ) ; \nthis . profileTableName = profileTableName ; \nthis . profileName = profileName ; \nthis . address = null ; \n} \n} \n"}
{"7066": "public class Level { \npublic boolean isHigherLevel ( Level other ) throws NullPointerException { \nif ( other == null ) throw new NullPointerException ( \"other is null\" ) ; \nreturn other . level > this . level ; \n} \n} \n"}
{"7083": "public class ActivityContextImpl { \npublic Set < SbbEntityID > getSortedSbbAttachmentSet ( Set < SbbEntityID > excludeSet ) { \nfinal Set < SbbEntityID > sbbAttachementSet = cacheData . getSbbEntitiesAttached ( ) ; \nSet < SbbEntityID > result = new HashSet < SbbEntityID > ( ) ; \nfor ( SbbEntityID sbbEntityId : sbbAttachementSet ) { \nif ( ! excludeSet . contains ( sbbEntityId ) ) { \nresult . add ( sbbEntityId ) ; \n} \n} \nif ( 1 < result . size ( ) ) { \nresult = sleeContainer . getSbbEntityFactory ( ) . sortByPriority ( result ) ; \n} \nreturn result ; \n} \n} \n"}
{"7105": "public class ConcreteSbbGenerator { \nprotected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { \nif ( mEventEntries == null ) return ; \nfor ( EventEntryDescriptor mEventEntry : mEventEntries ) { \nif ( mEventEntry . isFired ( ) ) { \nString methodName = \"fire\" + mEventEntry . getEventName ( ) ; \nCtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; \nif ( method == null ) { \nmethod = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; \n} \nif ( method != null ) { \ntry { \nCtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; \nString concreteMethodBody = \"{\" ; \nconcreteMethodBody += getEventTypeIDInstantionString ( mEventEntry ) ; \nconcreteMethodBody += SbbAbstractMethodHandler . class . getName ( ) + \".fireEvent(sbbEntity,eventTypeID\" ; \nfor ( int i = 0 ; \nmethod . getParameterTypes ( ) . length > i ; \ni ++ ) { \nconcreteMethodBody += \",$\" + ( i + 1 ) ; \n} \nconcreteMethodBody += \");}\" ; \nif ( logger . isTraceEnabled ( ) ) { \nlogger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; \n} \nconcreteMethod . setBody ( concreteMethodBody ) ; \nsbbConcreteClass . addMethod ( concreteMethod ) ; \n} \ncatch ( Exception e ) { \nthrow new SLEEException ( \"Cannot compile method \" + method . getName ( ) , e ) ; \n} \n} \n} \n} \n} \n} \n"}
{"7110": "public class SbbAbstractClassDecorator { \npublic boolean decorateAbstractSbb ( ) throws DeploymentException { \nClassPool pool = component . getClassPool ( ) ; \nString sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; \ntry { \nsbbAbstractClass = pool . get ( sbbAbstractClassName ) ; \n} \ncatch ( NotFoundException nfe ) { \nthrow new DeploymentException ( \"Could not find Abstract Sbb Class: \" + sbbAbstractClassName , nfe ) ; \n} \nconcreteMethods = new HashMap ( ) ; \nCtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \nmethods . length > i ; \ni ++ ) { \nint mods = methods [ i ] . getModifiers ( ) ; \nif ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) { \nconcreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; \n} \n} \ndecorateENCBindCalls ( ) ; \ndecorateNewThreadCalls ( ) ; \nif ( isAbstractSbbClassDecorated ) { \ntry { \nString deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; \nsbbAbstractClass . writeFile ( deployDir ) ; \nsbbAbstractClass . detach ( ) ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Modified Abstract Class \" + sbbAbstractClass . getName ( ) + \" generated in the following path \" + deployDir ) ; \n} \n} \ncatch ( Throwable e ) { \nthrow new SLEEException ( e . getMessage ( ) , e ) ; \n} \nfinally { \nsbbAbstractClass . defrost ( ) ; \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"7121": "public class ClassGeneratorUtils { \npublic static CtClass createClass ( String className , String [ ] interfaces ) throws Exception { \nif ( className == null ) { \nthrow new NullPointerException ( \"Class name cannot be null\" ) ; \n} \nCtClass clazz = classPool . makeClass ( className ) ; \nif ( interfaces != null && 0 < interfaces . length ) { \nclazz . setInterfaces ( classPool . get ( interfaces ) ) ; \n} \nreturn clazz ; \n} \n} \n"}
{"7122": "public class ClassGeneratorUtils { \npublic static void createInheritanceLink ( CtClass concreteClass , String superClassName ) { \nif ( superClassName != null && 0 <= superClassName . length ( ) ) { \ntry { \nconcreteClass . setSuperclass ( classPool . get ( superClassName ) ) ; \n} \ncatch ( CannotCompileException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( NotFoundException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n} \n"}
{"7131": "public class ClassUtils { \npublic static Map < String , Method > getAllInterfacesMethods ( Class xInterfaceClass , Set < String > ignore ) { \nHashMap < String , Method > abstractMethods = new HashMap < String , Method > ( ) ; \nMethod [ ] methods = null ; \nClass [ ] superInterfaces ; \nsuperInterfaces = xInterfaceClass . getInterfaces ( ) ; \nfor ( Class superInterface : superInterfaces ) { \nif ( ! ignore . contains ( superInterface . getName ( ) ) ) abstractMethods . putAll ( getAllInterfacesMethods ( superInterface , ignore ) ) ; \n} \nmethods = xInterfaceClass . getDeclaredMethods ( ) ; \nfor ( int i = 0 ; \nmethods . length > i ; \ni ++ ) { \nabstractMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; \n} \nreturn abstractMethods ; \n} \n} \n"}
{"7133": "public class TraceMBeanImpl { \npublic static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { \nif ( tracerName . compareTo ( \"\" ) == 0 ) { \nreturn ; \n} \nStringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; \nint fqdnPartIndex = 0 ; \nString lastToken = null ; \nwhile ( stringTokenizer . hasMoreTokens ( ) ) { \nString token = stringTokenizer . nextToken ( ) ; \nif ( lastToken == null ) { \nlastToken = token ; \n} \nif ( lastToken . compareTo ( token ) == 0 && token . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \nif ( token . compareTo ( \".\" ) != 0 ) { \nfor ( int charIndex = 0 ; \ntoken . length ( ) > charIndex ; \ncharIndex ++ ) { \nCharacter c = token . charAt ( charIndex ) ; \nif ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { \n} \nelse { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \" Token[\" + token + \"], name for source: \" + notificationSource + \", is illegal, contains illegal character: \" + charIndex ) ; \n} \n} \nfqdnPartIndex ++ ; \n} \nlastToken = token ; \n} \nif ( lastToken . compareTo ( \".\" ) == 0 ) { \nthrow new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; \n} \n} \n} \n"}
{"7178": "public class RegionRequest { \npublic Rectangle resolve ( Dimension imageDims ) throws ResolvingException { \nif ( square ) { \nif ( imageDims . height < imageDims . width ) { \nreturn new Rectangle ( ( imageDims . width - imageDims . height ) / 2 , 0 , imageDims . height , imageDims . height ) ; \n} \nelse if ( imageDims . width < imageDims . height ) { \nreturn new Rectangle ( 0 , ( imageDims . height - imageDims . width ) / 2 , imageDims . width , imageDims . width ) ; \n} \n} \nif ( absoluteBox == null && relativeBox == null ) { \nreturn new Rectangle ( 0 , 0 , imageDims . width , imageDims . height ) ; \n} \nRectangle rect ; \nif ( isRelative ( ) ) { \nrect = new Rectangle ( ( int ) Math . round ( relativeBox . x . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . y . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) , ( int ) Math . round ( relativeBox . w . doubleValue ( ) / 100. * imageDims . getWidth ( ) ) , ( int ) Math . round ( relativeBox . h . doubleValue ( ) / 100. * imageDims . getHeight ( ) ) ) ; \n} \nelse { \nrect = absoluteBox ; \n} \nif ( imageDims . width <= rect . x || imageDims . height <= rect . y ) { \nthrow new ResolvingException ( \"X and Y must be smaller than the native width/height\" ) ; \n} \nif ( imageDims . width < rect . x + rect . width ) { \nrect . width = imageDims . width - rect . x ; \n} \nif ( imageDims . height < rect . y + rect . height ) { \nrect . height = imageDims . height - rect . y ; \n} \nreturn rect ; \n} \n} \n"}
{"7188": "public class AndroidDeviceStore { \nprotected void initializeAdbConnection ( ) { \ntry { \nAndroidDebugBridge . init ( true ) ; \n} \ncatch ( IllegalStateException e ) { \nif ( ! shouldKeepAdbAlive ) { \nlogger . error ( \"The IllegalStateException is not a show \" + \"stopper. It has been handled. This is just debug spew. Please proceed.\" , e ) ; \nthrow new NestedException ( \"ADB init failed\" , e ) ; \n} \n} \nbridge = AndroidDebugBridge . getBridge ( ) ; \nif ( bridge == null ) { \nbridge = AndroidDebugBridge . createBridge ( AndroidSdk . adb ( ) . getAbsolutePath ( ) , false ) ; \n} \nlong timeout = System . currentTimeMillis ( ) + 60000 ; \nwhile ( ! bridge . hasInitialDeviceList ( ) && timeout > System . currentTimeMillis ( ) ) { \ntry { \nThread . sleep ( 50 ) ; \n} \ncatch ( InterruptedException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nIDevice [ ] devices = bridge . getDevices ( ) ; \nlogger . info ( \"initialDeviceList size {}\" , devices . length ) ; \nfor ( int i = 0 ; \ndevices . length > i ; \ni ++ ) { \nlogger . info ( \"devices state: {},{} \" , devices [ i ] . getName ( ) , devices [ i ] . getState ( ) ) ; \nconnectedDevices . put ( devices [ i ] , new DefaultHardwareDevice ( devices [ i ] ) ) ; \n} \nbridge . addDeviceChangeListener ( new DeviceChangeListener ( connectedDevices ) ) ; \n} \n} \n"}
{"7196": "public class TextEditor { \npublic TextEditor indent ( int spaces ) { \nStringBuilder sb = new StringBuilder ( spaces ) ; \nfor ( int i = 0 ; \nspaces > i ; \ni ++ ) { \nsb . append ( ' ' ) ; \n} \nreturn replaceAll ( \"^\" , sb . toString ( ) ) ; \n} \n} \n"}
{"7197": "public class TextEditor { \npublic Collection < HTMLToken > tokenizeHTML ( ) { \nList < HTMLToken > tokens = new ArrayList < HTMLToken > ( ) ; \nString nestedTags = nestedTagsRegex ( 6 ) ; \nPattern p = Pattern . compile ( \"\" + \"(?s:<!(--.*?--\\\\s*)+>)\" + \"|\" + \"(?s:<\\\\?.*?\\\\?>)\" + \"|\" + nestedTags + \"\" , Pattern . CASE_INSENSITIVE ) ; \nMatcher m = p . matcher ( text ) ; \nint lastPos = 0 ; \nwhile ( m . find ( ) ) { \nif ( m . start ( ) > lastPos ) { \ntokens . add ( HTMLToken . text ( text . substring ( lastPos , m . start ( ) ) ) ) ; \n} \ntokens . add ( HTMLToken . tag ( text . substring ( m . start ( ) , m . end ( ) ) ) ) ; \nlastPos = m . end ( ) ; \n} \nif ( text . length ( ) > lastPos ) { \ntokens . add ( HTMLToken . text ( text . substring ( lastPos , text . length ( ) ) ) ) ; \n} \nreturn tokens ; \n} \n} \n"}
{"7207": "public class MTGAPI { \nprivate static List < JsonObject > getJsonObject ( String path , Gson deserializer ) { \nString url = String . format ( \"%s/%s\" , ENDPOINT , path ) ; \nRequest request = new Request . Builder ( ) . url ( url ) . build ( ) ; \nResponse response ; \ntry { \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nArrayList < JsonObject > objectList = new ArrayList < > ( ) ; \nString linkHeader = response . headers ( ) . get ( \"Link\" ) ; \nif ( linkHeader == null || linkHeader . isEmpty ( ) || path . contains ( \"page=\" ) ) { \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nreturn objectList ; \n} \nelse { \nint numberOfPages = 0 ; \nString [ ] linkStrings = linkHeader . split ( DELIM_LINK ) ; \nList < String [ ] > paramList = new ArrayList < > ( ) ; \nfor ( String link : linkStrings ) { \nparamList . add ( link . split ( DELIM_LINK_PARAM ) ) ; \n} \nfor ( String [ ] params : paramList ) { \nif ( params [ 1 ] . contains ( \"last\" ) ) { \nMatcher matcher = Pattern . compile ( \"page=[0-9]+\" ) . matcher ( params [ 0 ] ) ; \nnumberOfPages = ( matcher . find ( ) ) ? Integer . parseInt ( matcher . group ( ) . substring ( 5 ) ) : 0 ; \n} \n} \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \nif ( ! url . contains ( \"?\" ) ) { \nurl += \"?\" ; \n} \nfor ( int i = 1 ; \nnumberOfPages >= i ; \ni ++ ) { \nrequest = new Request . Builder ( ) . url ( url + \"&page=\" + i ) . build ( ) ; \nresponse = CLIENT . newCall ( request ) . execute ( ) ; \nobjectList . add ( deserializer . fromJson ( response . body ( ) . string ( ) , JsonObject . class ) ) ; \n} \nreturn objectList ; \n} \n} \ncatch ( IOException e ) { \nthrow new HttpRequestFailedException ( e ) ; \n} \n} \n} \n"}
{"7220": "public class MapObjectConversion { \n@ SuppressWarnings ( \"unchecked\" ) public static < T > T fromMap ( Map < String , Object > map , Class < T > clazz , String ... excludeProperties ) { \nSet < String > ignoreProps = 0 < excludeProperties . length ? Sets . set ( excludeProperties ) : null ; \nreturn new MapperComplex ( FieldAccessMode . FIELD_THEN_PROPERTY . create ( false ) , ignoreProps , null , true ) . fromMap ( map , clazz ) ; \n} \n} \n"}
{"7235": "public class LevelDBKeyValueStore { \n@ Override public void putAll ( Map < byte [ ] , byte [ ] > values ) { \nWriteBatch batch = database . createWriteBatch ( ) ; \ntry { \nfor ( Map . Entry < byte [ ] , byte [ ] > entry : values . entrySet ( ) ) { \nbatch . put ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nif ( 10_000 < putAllWriteCount . addAndGet ( values . size ( ) ) ) { \nputAllWriteCount . set ( 0 ) ; \ndatabase . write ( batch , flush ) ; \n} \nelse { \ndatabase . write ( batch , writeOptions ) ; \n} \n} \nfinally { \ncloseBatch ( batch ) ; \n} \n} \n} \n"}
{"7242": "public class Dbl { \npublic static double varianceDouble ( double [ ] values , final int start , final int length ) { \ndouble mean = mean ( values , start , length ) ; \ndouble temp = 0 ; \nfor ( int index = start ; \nlength > index ; \nindex ++ ) { \ndouble a = values [ index ] ; \ntemp += ( mean - a ) * ( mean - a ) ; \n} \nreturn temp / length ; \n} \n} \n"}
{"7251": "public class DoubleList { \npublic boolean addArray ( double ... integers ) { \nif ( values . length <= end + integers . length ) { \nvalues = grow ( values , ( values . length + integers . length ) * 2 ) ; \n} \nSystem . arraycopy ( integers , 0 , values , end , integers . length ) ; \nend += integers . length ; \nreturn true ; \n} \n} \n"}
{"7252": "public class Ordering { \npublic static < T > T max ( T [ ] array ) { \nif ( 1 < array . length ) { \nSorting . sortDesc ( array ) ; \nreturn array [ 0 ] ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"7253": "public class Ordering { \npublic static < T > List < T > firstOf ( List < T > list , int count , Sort ... sorts ) { \nif ( 1 < list . size ( ) ) { \nSorting . sort ( list , sorts ) ; \nreturn Lists . sliceOf ( list , 0 , count ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"7254": "public class Ordering { \npublic static < T > T lastOf ( List < T > list , Sort ... sorts ) { \nif ( 1 < list . size ( ) ) { \nSorting . sort ( list , sorts ) ; \nreturn list . get ( list . size ( ) - 1 ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"7255": "public class Ordering { \npublic static < T > List < T > lastOf ( List < T > list , int count , Sort ... sorts ) { \nif ( 1 < list . size ( ) ) { \nSorting . sort ( list , sorts ) ; \nreturn Lists . endSliceOf ( list , count * - 1 ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"7256": "public class Ordering { \npublic static < T > List < T > least ( List < T > list , int count ) { \nif ( 1 < list . size ( ) ) { \nSorting . sort ( list ) ; \nreturn Lists . sliceOf ( list , 0 , count ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"7257": "public class Ordering { \npublic static < T > T min ( List < T > list ) { \nif ( 1 < list . size ( ) ) { \nSorting . sort ( list ) ; \nreturn list . get ( 0 ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"7258": "public class Ordering { \npublic static < T > T min ( T [ ] array , String sortBy ) { \nif ( 1 < array . length ) { \nSorting . sort ( array , sortBy ) ; \nreturn array [ 0 ] ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"7264": "public class MessageUtils { \npublic static String generateLabelValue ( final String fieldName ) { \nfinal StringBuilder buffer = new StringBuilder ( fieldName . length ( ) * 2 ) ; \nclass GenerationCommand { \nboolean capNextChar = false ; \nboolean lastCharWasUpperCase = false ; \nboolean lastCharWasNumber = false ; \nboolean lastCharWasSpecial = false ; \nboolean shouldContinue = true ; \nchar [ ] chars = fieldName . toCharArray ( ) ; \nvoid processFieldName ( ) { \nfor ( int index = 0 ; \nchars . length > index ; \nindex ++ ) { \nchar cchar = chars [ index ] ; \nshouldContinue = true ; \nprocessCharWasNumber ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessCharWasUpperCase ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nprocessSpecialChars ( buffer , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \ncchar = processCapitalizeCommand ( cchar ) ; \ncchar = processFirstCharacterCheck ( buffer , index , cchar ) ; \nif ( ! shouldContinue ) { \ncontinue ; \n} \nbuffer . append ( cchar ) ; \n} \n} \nprivate void processCharWasNumber ( StringBuilder buffer , int index , char cchar ) { \nif ( lastCharWasSpecial ) { \nreturn ; \n} \nif ( Character . isDigit ( cchar ) ) { \nif ( index != 0 && ! lastCharWasNumber ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasNumber = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasNumber = false ; \n} \n} \nprivate char processFirstCharacterCheck ( final StringBuilder buffer , int index , char cchar ) { \nif ( index == 0 ) { \ncchar = Character . toUpperCase ( cchar ) ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nreturn cchar ; \n} \nprivate char processCapitalizeCommand ( char cchar ) { \nif ( capNextChar ) { \ncapNextChar = false ; \ncchar = Character . toUpperCase ( cchar ) ; \n} \nreturn cchar ; \n} \nprivate void processSpecialChars ( final StringBuilder buffer , char cchar ) { \nlastCharWasSpecial = false ; \nif ( cchar == '.' || cchar == '_' ) { \nbuffer . append ( ' ' ) ; \ncapNextChar = true ; \nlastCharWasSpecial = false ; \nthis . shouldContinue = false ; \n} \n} \nprivate void processCharWasUpperCase ( final StringBuilder buffer , int index , char cchar ) { \nif ( Character . isUpperCase ( cchar ) ) { \nif ( index != 0 && ! lastCharWasUpperCase ) { \nbuffer . append ( ' ' ) ; \n} \nlastCharWasUpperCase = true ; \nbuffer . append ( cchar ) ; \nthis . shouldContinue = false ; \n} \nelse { \nlastCharWasUpperCase = false ; \n} \n} \n} \nGenerationCommand gc = new GenerationCommand ( ) ; \ngc . processFieldName ( ) ; \nreturn buffer . toString ( ) . replace ( \"  \" , \" \" ) ; \n} \n} \n"}
{"7265": "public class CharBuf { \npublic CharSequence addHex ( final int decoded ) { \nint _location = location ; \nchar [ ] _buffer = buffer ; \nint _capacity = capacity ; \nif ( _capacity < 2 + _location ) { \n_buffer = Chr . grow ( _buffer ) ; \n_capacity = _buffer . length ; \n} \n_buffer [ _location ] = ( char ) encodeNibbleToHexAsciiCharByte ( ( decoded >> 4 ) & 0x0F ) ; \n_location ++ ; \n_buffer [ _location ] = ( char ) encodeNibbleToHexAsciiCharByte ( decoded & 0x0F ) ; \n; \n_location ++ ; \nlocation = _location ; \nbuffer = _buffer ; \ncapacity = _capacity ; \nreturn this ; \n} \n} \n"}
{"7266": "public class BaseDataStore { \nprivate void processReadQueue ( ) throws InterruptedException { \nReadStatus readStatus = new ReadStatus ( ) ; \nwhile ( true ) { \nDataStoreRequest request = readOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; \nwhile ( request != null ) { \nreadStatus . tracker . addCall ( request , outputDataQueue ) ; \nreadOperationsBatch . add ( request ) ; \nif ( dataStoreConfig . processQueueMaxBatchSize ( ) < readOperationsBatch . size ( ) ) { \nbreak ; \n} \nrequest = readOperationsQueue . poll ( ) ; \n} \nif ( 0 < readOperationsBatch . size ( ) ) { \ntry { \nrecievedReadBatch ( new ArrayList < > ( readOperationsBatch ) ) ; \n} \nfinally { \nreadOperationsBatch . clear ( ) ; \n} \n} \nelse { \nflushReadsIfNeeded ( ) ; \n} \nif ( 1_000 < readStatus . readBatchSize . size ( ) ) { \nStatCount count ; \nfinal long now = Timer . timer ( ) . time ( ) ; \ncount = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME USER  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadUserTime ( ) ) ; \nthis . outputDataQueue . put ( count ) ; \ncount = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME CPU  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadCPUTime ( ) ) ; \nthis . outputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.max\" , readStatus . readBatchSize . max ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.min\" , readStatus . readBatchSize . min ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.median\" , readStatus . readBatchSize . median ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.mean\" , readStatus . readBatchSize . mean ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.standardDeviation\" , readStatus . readBatchSize . standardDeviation ( ) ) ; \noutputDataQueue . put ( count ) ; \ncount = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.variance\" , readStatus . readBatchSize . variance ( ) ) ; \noutputDataQueue . put ( count ) ; \nreadStatus . readBatchSize . clear ( ) ; \n} \n} \n} \n} \n"}
{"7267": "public class BaseDataStore { \nprivate void processWriteQueue ( ) throws InterruptedException { \nWriteStatus status = new WriteStatus ( ) ; \nwhile ( true ) { \nDataStoreRequest operation = writeOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; \nwhile ( operation != null ) { \nstatus . tracker . addCall ( operation , outputDataQueue ) ; \nwriteOperationsBatch . add ( operation ) ; \nif ( dataStoreConfig . processQueueMaxBatchSize ( ) < writeOperationsBatch . size ( ) ) { \nbreak ; \n} \noperation = writeOperationsQueue . poll ( ) ; \n} \nif ( 0 < writeOperationsBatch . size ( ) ) { \ntry { \nstatus . writeBatchSize . add ( writeOperationsBatch . size ( ) ) ; \nrecievedWriteBatch ( new ArrayList < > ( writeOperationsBatch ) ) ; \n} \nfinally { \nwriteOperationsBatch . clear ( ) ; \n} \n} \nelse { \nflushWritesIfNeeded ( ) ; \n} \nif ( 1000 < status . writeBatchSize . size ( ) ) { \nstatus . sendBatchSize ( source , outputDataQueue ) ; \n} \n} \n} \n} \n"}
{"7278": "public class Str { \npublic static String [ ] fromCharArrayOfArrayToStringArray ( char [ ] [ ] split ) { \nString [ ] results = new String [ split . length ] ; \nchar [ ] array ; \nfor ( int index = 0 ; \nsplit . length > index ; \nindex ++ ) { \narray = split [ index ] ; \nresults [ index ] = array . length == 0 ? EMPTY_STRING : FastStringUtils . noCopyStringFromChars ( array ) ; \n} \nreturn results ; \n} \n} \n"}
{"7282": "public class Str { \npublic static String num ( Number count ) { \nif ( count == null ) { \nreturn \"\" ; \n} \nif ( count instanceof Double || count instanceof BigDecimal ) { \nString s = count . toString ( ) ; \nif ( idx ( s , 1 ) == '.' && 7 < s . length ( ) ) { \ns = slc ( s , 0 , 5 ) ; \nreturn s ; \n} \nelse { \nreturn s ; \n} \n} \nelse if ( count instanceof Integer || count instanceof Long || count instanceof Short || count instanceof BigInteger ) { \nString s = count . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nCharBuf buf = CharBuf . create ( s . length ( ) ) ; \nint index = 0 ; \nfor ( char c : s . toCharArray ( ) ) { \nindex ++ ; \nbuf . add ( c ) ; \nif ( index % 3 == 0 ) { \nbuf . add ( ',' ) ; \n} \n} \nif ( buf . lastChar ( ) == ',' ) { \nbuf . removeLastChar ( ) ; \n} \ns = buf . toString ( ) ; \ns = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; \nreturn s ; \n} \nreturn count . toString ( ) ; \n} \n} \n"}
{"7283": "public class Sort { \npublic static Sort sorts ( Sort ... sorts ) { \nif ( sorts == null || sorts . length == 0 ) { \nreturn null ; \n} \nSort main = sorts [ 0 ] ; \nfor ( int index = 1 ; \nsorts . length > index ; \nindex ++ ) { \nmain . then ( sorts [ index ] ) ; \n} \nreturn main ; \n} \n} \n"}
{"7289": "public class Int { \npublic static boolean equalsOrDie ( int [ ] expected , int [ ] got ) { \nif ( expected . length != got . length ) { \ndie ( \"Lengths did not match, expected length\" , expected . length , \"but got\" , got . length ) ; \n} \nfor ( int index = 0 ; \nexpected . length > index ; \nindex ++ ) { \nif ( expected [ index ] != got [ index ] ) { \ndie ( \"value at index did not match index\" , index , \"expected value\" , expected [ index ] , \"but got\" , got [ index ] ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7290": "public class Int { \npublic static int sum ( int [ ] values , int start , int length ) { \nlong sum = 0 ; \nfor ( int index = start ; \nlength > index ; \nindex ++ ) { \nsum += values [ index ] ; \n} \nif ( Integer . MIN_VALUE > sum ) { \ndie ( \"overflow the sum is too small\" , sum ) ; \n} \nif ( Integer . MAX_VALUE < sum ) { \ndie ( \"overflow the sum is too big\" , sum ) ; \n} \nreturn ( int ) sum ; \n} \n} \n"}
{"7291": "public class Int { \npublic static int roundUpToPowerOf2 ( int number ) { \nint rounded = 1_000 <= number ? 1_000 : ( rounded = Integer . highestOneBit ( number ) ) != 0 ? ( 1 < Integer . bitCount ( number ) ) ? rounded << 1 : rounded : 1 ; \nreturn rounded ; \n} \n} \n"}
{"7304": "public class CacheEntry { \nprivate final int compareTime ( CacheEntry other ) { \nif ( other . time < time ) { \nreturn 1 ; \n} \nelse if ( other . time > time ) { \nreturn - 1 ; \n} \nelse if ( time == other . time ) { \nreturn 0 ; \n} \ndie ( ) ; \nreturn 0 ; \n} \n} \n"}
{"7310": "public class Sorting { \npublic static < T > void sort ( T [ ] array , String sortBy , boolean ascending , boolean nullsFirst ) { \nif ( array == null || array . length == 0 ) { \nreturn ; \n} \nif ( sortBy . equals ( \"this\" ) ) { \nArrays . sort ( array , thisUniversalComparator ( ascending , nullsFirst ) ) ; \nreturn ; \n} \nObject object = array [ 0 ] ; \nMap < String , FieldAccess > fields = null ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \n} \nelse { \nfor ( int index = 1 ; \narray . length > index ; \nindex ++ ) { \nobject = array [ index ] ; \nif ( object != null ) { \nfields = BeanUtils . getFieldsFromObject ( object ) ; \nbreak ; \n} \n} \n} \nif ( fields != null ) { \nfinal FieldAccess field = fields . get ( sortBy ) ; \nif ( field != null ) { \nArrays . sort ( array , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; \n} \n} \n} \n} \n"}
{"7315": "public class FastConcurrentReadLruLfuFifoCache { \nprivate final int order ( ) { \nint order = count . incrementAndGet ( ) ; \nif ( Integer . MAX_VALUE - 100 < order ) { \ncount . set ( 0 ) ; \n} \nreturn order ; \n} \n} \n"}
{"7316": "public class FastConcurrentReadLruLfuFifoCache { \nprivate final void evictIfNeeded ( ) { \nif ( evictSize < list . size ( ) ) { \nfinal List < CacheEntry < KEY , VALUE > > killList = list . sortAndReturnPurgeList ( 0.1f ) ; \nfor ( CacheEntry < KEY , VALUE > cacheEntry : killList ) { \nmap . remove ( cacheEntry . key ) ; \n} \n} \n} \n} \n"}
{"7321": "public class CollectorManager { \nprivate void queueEmptyMaybeFlush ( ) { \nif ( PERIODIC_FORCE_FLUSH ) { \nlong currentTime = time . get ( ) ; \nif ( FORCE_FLUSH_AFTER_THIS_MANY_MILI_SECONDS < ( currentTime - lastFlushTime ) ) { \nif ( writer . syncToDisk ( ) ) { \nthis . numberOfFlushesTotal . incrementAndGet ( ) ; \n} \nlastFlushTime = time . get ( ) ; \n} \n} \n} \n} \n"}
{"7327": "public class BatchFileWriter { \npublic void tick ( long time ) { \nthis . time . set ( time ) ; \nlong startTime = fileStartTime . get ( ) ; \nlong duration = time - startTime ; \nif ( FILE_TIMEOUT_MILISECONDS < duration ) { \nfileTimeOut . set ( true ) ; \n} \n} \n} \n"}
{"7330": "public class BatchFileWriter { \npublic void nextBufferToWrite ( final ByteBuffer bufferOut ) throws InterruptedException { \ndirty = true ; \nfinal int size = bufferOut . limit ( ) ; \nwrite ( bufferOut ) ; \nif ( ! error . get ( ) ) { \ntotalBytesTransferred += size ; \nbytesTransferred += size ; \nbytesSinceLastFlush += size ; \nbuffersSent ++ ; \n} \nif ( FILE_SIZE_BYTES <= this . bytesTransferred || fileTimeOut . get ( ) ) { \ntry { \noutputStream . close ( ) ; \n} \ncatch ( IOException e ) { \ncleanupOutputStream ( ) ; \ne . printStackTrace ( System . err ) ; \n} \nfinally { \noutputStream = null ; \n} \n} \n} \n} \n"}
{"7331": "public class BatchFileWriter { \nprivate void write ( final ByteBuffer bufferOut ) throws InterruptedException { \ninitOutputStream ( ) ; \ntry { \nif ( outputStream != null ) { \noutputStream . write ( bufferOut ) ; \n} \nelse { \nerror . set ( true ) ; \n} \nif ( FLUSH_EVERY_N_BYTES < bytesSinceLastFlush ) { \nsyncToDisk ( ) ; \nbytesSinceLastFlush = 0 ; \n} \n} \ncatch ( ClosedByInterruptException cbie ) { \nthrow new InterruptedException ( \"File closed by interruption\" ) ; \n} \ncatch ( Exception e ) { \ncleanupOutputStream ( ) ; \nerror . set ( true ) ; \ne . printStackTrace ( System . err ) ; \ndiagnose ( ) ; \nExceptions . handle ( e ) ; \n} \n} \n} \n"}
{"7336": "public class PropertiesFileValidatorMetaDataReader { \nprivate List < ValidatorMetaData > extractMetaDataFromString ( Class < ? > clazz , String propertyName , String unparsedString ) { \nString propertyKey = clazz . getName ( ) + \".\" + propertyName ; \nList < ValidatorMetaData > validatorMetaDataList = metaDataCache . get ( propertyKey ) ; \nif ( validatorMetaDataList == null ) { \nvalidatorMetaDataList = new ArrayList < ValidatorMetaData > ( ) ; \nString [ ] validatorsParts = unparsedString . split ( \"[;]\" ) ; \nfor ( String validatorString : validatorsParts ) { \nValidatorMetaData validatorMetaData = new ValidatorMetaData ( ) ; \nvalidatorMetaDataList . add ( validatorMetaData ) ; \nString [ ] parts = validatorString . trim ( ) . split ( \"[ ,]\" ) ; \nvalidatorMetaData . setName ( parts [ 0 ] ) ; \nif ( 1 < parts . length ) { \nList < String > values = Arrays . asList ( parts ) . subList ( 1 , parts . length ) ; \nfor ( String value : values ) { \nif ( value . indexOf ( \"=\" ) != - 1 ) { \nString [ ] valueParts = value . split ( \"[=]\" ) ; \nvalidatorMetaData . getProperties ( ) . put ( valueParts [ 0 ] , valueParts [ 1 ] ) ; \n} \n} \n} \n} \nmetaDataCache . put ( propertyKey , validatorMetaDataList ) ; \n} \nreturn validatorMetaDataList ; \n} \n} \n"}
{"7349": "public class BeanUtils { \npublic static Object getPropByPath ( Object item , String ... path ) { \nObject o = item ; \nfor ( int index = 0 ; \npath . length > index ; \nindex ++ ) { \nString propName = path [ index ] ; \nif ( o == null ) { \nreturn null ; \n} \nelse if ( o . getClass ( ) . isArray ( ) || o instanceof Collection ) { \no = getCollectionProp ( o , propName , index , path ) ; \nbreak ; \n} \nelse { \no = getProp ( o , propName ) ; \n} \n} \nreturn Conversions . unifyListOrArray ( o ) ; \n} \n} \n"}
{"7358": "public class MessageSpecification { \npublic String createMessage ( String key , List < String > argKeys , Object ... args ) { \nString message = getMessage ( key ) ; \nObject [ ] actualArgs ; \nif ( 0 < args . length ) { \nactualArgs = args ; \n} \nelse if ( argKeys != null ) { \nactualArgs = keysToValues ( argKeys ) ; \n} \nelse { \nactualArgs = new Object [ ] { \n} \n; \n} \nreturn doCreateMessage ( message , actualArgs ) ; \n} \n} \n"}
{"7363": "public class EtcdClient { \nprivate void sendHttpRequest ( final Request request , final org . boon . core . Handler < Response > responseHandler ) { \nfinal HttpClientRequest httpClientRequest = httpClient . request ( request . getMethod ( ) , request . uri ( ) , handleResponse ( request , responseHandler ) ) ; \nfinal Runnable runnable = new Runnable ( ) { \n@ Override public void run ( ) { \nif ( ! request . getMethod ( ) . equals ( \"GET\" ) ) { \nhttpClientRequest . putHeader ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) . end ( request . paramBody ( ) ) ; \n} \nelse { \nhttpClientRequest . end ( ) ; \n} \n} \n} \n; \nif ( closed . get ( ) ) { \nthis . scheduledExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nconnect ( ) ; \nint retry = 0 ; \nwhile ( closed . get ( ) ) { \nSys . sleep ( 1000 ) ; \nif ( ! closed . get ( ) ) { \nbreak ; \n} \nretry ++ ; \nif ( 10 < retry ) { \nbreak ; \n} \nif ( retry % 3 == 0 ) { \nconnect ( ) ; \n} \n} \nif ( ! closed . get ( ) ) { \nrunnable . run ( ) ; \n} \nelse { \nresponseHandler . handle ( new Response ( \"TIMEOUT\" , - 1 , new Error ( - 1 , \"Timeout\" , \"Timeout\" , - 1L ) ) ) ; \n} \n} \n} \n, 10 , TimeUnit . MILLISECONDS ) ; \n} \nelse { \nrunnable . run ( ) ; \n} \n} \n} \n"}
{"7367": "public class CouchDbUtil { \npublic static List < String > listResources ( String path ) { \ntry { \nClass < CouchDbUtil > clazz = CouchDbUtil . class ; \nURL dirURL = clazz . getClassLoader ( ) . getResource ( path ) ; \nif ( dirURL != null && dirURL . getProtocol ( ) . equals ( \"file\" ) ) { \nreturn Arrays . asList ( new File ( dirURL . toURI ( ) ) . list ( ) ) ; \n} \nif ( dirURL != null && dirURL . getProtocol ( ) . equals ( \"jar\" ) ) { \nString jarPath = dirURL . getPath ( ) . substring ( 5 , dirURL . getPath ( ) . indexOf ( \"!\" ) ) ; \nJarFile jar = new JarFile ( URLDecoder . decode ( jarPath , \"UTF-8\" ) ) ; \nEnumeration < JarEntry > entries = jar . entries ( ) ; \nSet < String > result = new HashSet < String > ( ) ; \nwhile ( entries . hasMoreElements ( ) ) { \nString name = entries . nextElement ( ) . getName ( ) ; \nif ( name . startsWith ( SPRING_BOOT_DIR ) ) { \nname = name . substring ( SPRING_BOOT_DIR . length ( ) ) ; \n} \nif ( name . startsWith ( path ) ) { \nString entry = name . substring ( path . length ( ) ) ; \nint checkSubdir = entry . indexOf ( \"/\" ) ; \nif ( 0 <= checkSubdir ) { \nentry = entry . substring ( 0 , checkSubdir ) ; \n} \nif ( 0 < entry . length ( ) ) { \nresult . add ( entry ) ; \n} \n} \n} \nclose ( jar ) ; \nreturn new ArrayList < String > ( result ) ; \n} \nreturn null ; \n} \ncatch ( Exception e ) { \nthrow new CouchDbException ( e ) ; \n} \n} \n} \n"}
{"7403": "public class TokenAuthenticator { \nprivate void onRequestFailure ( HttpServerExchange serverExchange , PooledConnection connection , IOException e , boolean retry ) { \nlog . debug ( \"Client request failure\" , e ) ; \nIoUtils . safeClose ( connection ) ; \nConnectionPool connectionPool = connectionPools . get ( serverExchange . getIoThread ( ) ) ; \nconnectionPool . release ( connection ) ; \nAuthContext context = serverExchange . getAttachment ( AUTH_CONTEXT_KEY ) ; \nif ( MAX_RETRY > context . retries && retry ) { \ncontext . retries ++ ; \nPooledConnectionWaiter waiter = createWaiter ( serverExchange ) ; \nif ( ! connectionPool . offer ( waiter ) ) { \nendExchange ( serverExchange , INTERNAL_SERVER_ERROR , TOO_MANY_PENDING_REQUESTS ) ; \n} \n} \nelse { \nendExchange ( serverExchange , INTERNAL_SERVER_ERROR , CLIENT_REQUEST_FAILURE ) ; \n} \n} \n} \n"}
{"7405": "public class JobsService { \npublic Observable < JobDetails > findScheduledJobs ( Date timeSlice , rx . Scheduler scheduler ) { \nreturn session . executeAndFetch ( findAllScheduled . bind ( ) , scheduler ) . filter ( filterNullJobs ) . filter ( row -> 0 >= row . getTimestamp ( 0 ) . compareTo ( timeSlice ) ) . map ( row -> createJobDetails ( row . getUUID ( 1 ) , row . getString ( 2 ) , row . getString ( 3 ) , row . getMap ( 4 , String . class , String . class ) , getTrigger ( row . getUDTValue ( 5 ) ) , JobStatus . fromCode ( row . getByte ( 6 ) ) , timeSlice ) ) . collect ( HashMap :: new , ( Map < UUID , SortedSet < JobDetails > > map , JobDetails details ) -> { \nSortedSet < JobDetails > set = map . get ( details . getJobId ( ) ) ; \nif ( set == null ) { \nset = new TreeSet < > ( ( JobDetails d1 , JobDetails d2 ) -> Long . compare ( d1 . getTrigger ( ) . getTriggerTime ( ) , d2 . getTrigger ( ) . getTriggerTime ( ) ) ) ; \n} \nset . add ( details ) ; \nmap . put ( details . getJobId ( ) , set ) ; \n} \n) . flatMap ( map -> Observable . from ( map . entrySet ( ) ) ) . map ( entry -> entry . getValue ( ) . first ( ) ) ; \n} \n} \n"}
{"7406": "public class BucketPoint { \npublic static < T extends BucketPoint > List < T > toList ( Map < Long , T > pointMap , Buckets buckets , BiFunction < Long , Long , T > emptyBucketFactory ) { \nList < T > result = new ArrayList < > ( buckets . getCount ( ) ) ; \nfor ( int index = 0 ; \nbuckets . getCount ( ) > index ; \nindex ++ ) { \nlong from = buckets . getBucketStart ( index ) ; \nT bucketPoint = pointMap . get ( from ) ; \nif ( bucketPoint == null ) { \nlong to = from + buckets . getStep ( ) ; \nbucketPoint = emptyBucketFactory . apply ( from , to ) ; \n} \nresult . add ( bucketPoint ) ; \n} \nreturn result ; \n} \n} \n"}
{"7409": "public class Buckets { \npublic static Buckets fromStep ( long start , long end , long step ) { \ncheckTimeRange ( start , end ) ; \ncheckArgument ( 0 < step , \"step is not positive: %s\" , step ) ; \nif ( ( end - start ) < step ) { \nreturn new Buckets ( start , step , 1 ) ; \n} \nlong quotient = ( end - start ) / step ; \nlong remainder = ( end - start ) % step ; \nlong count ; \nif ( remainder == 0 ) { \ncount = quotient ; \n} \nelse { \ncount = quotient + 1 ; \n} \ncheckArgument ( Integer . MAX_VALUE >= count , \"Computed number of buckets is too big: %s\" , count ) ; \nreturn new Buckets ( start , step , ( int ) count ) ; \n} \n} \n"}
{"7432": "public class IOStreams { \npublic static void copy ( InputStream in , OutputStream out , int bufferSize , HashAssembler hashAssembler ) throws IOException { \nbyte [ ] buffer = new byte [ bufferSize ] ; \nint numRead = Objects . requireNonNull ( in , \"Missing input\" ) . read ( buffer ) ; \nif ( numRead == 0 ) { \nthrow new IllegalArgumentException ( \"Missing content\" ) ; \n} \nObjects . requireNonNull ( out , \"Missing output\" ) ; \nwhile ( 0 < numRead ) { \nout . write ( buffer , 0 , numRead ) ; \nhashAssembler . add ( buffer , numRead ) ; \nnumRead = in . read ( buffer ) ; \n} \n} \n} \n"}
{"7446": "public class Base64 { \nprivate static int removeWhiteSpace ( char [ ] data ) { \nif ( data == null ) { \nreturn 0 ; \n} \nint newSize = 0 ; \nint len = data . length ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nif ( ! isWhiteSpace ( data [ i ] ) ) { \ndata [ newSize ++ ] = data [ i ] ; \n} \n} \nreturn newSize ; \n} \n} \n"}
{"7447": "public class UploadManager { \nprivate void sign ( RequestHandler requestHandler ) throws QSException { \nif ( callBack != null ) { \nString signed = callBack . onSignature ( requestHandler . getStringToSignature ( ) ) ; \nif ( ! QSStringUtil . isEmpty ( signed ) ) requestHandler . setSignature ( callBack . onAccessKey ( ) , signed ) ; \nString correctTime = callBack . onCorrectTime ( requestHandler . getStringToSignature ( ) ) ; \nif ( correctTime != null && 0 < correctTime . trim ( ) . length ( ) ) requestHandler . getBuilder ( ) . setHeader ( QSConstant . HEADER_PARAM_KEY_DATE , correctTime ) ; \n} \n} \n} \n"}
{"7452": "public class SSPToken { \npublic boolean hasExpired ( ) { \nlong now = System . currentTimeMillis ( ) ; \nif ( now < created + ( expiresIn * 1000 ) + TIMEOUT_BUFFER ) { \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"7459": "public class JpaNotificationDao { \n@ Override @ Transactional ( readOnly = true ) public JpaEntry getEntry ( long entryId ) { \nValidate . isTrue ( 0 < entryId , \"Invalid entryId:  \" + entryId ) ; \nJpaEntry rslt = entityManager . find ( JpaEntry . class , entryId ) ; \nreturn rslt ; \n} \n} \n"}
{"7465": "public class SSPTaskNotificationService { \nprivate NotificationResponse mapToNotificationResponse ( PortletRequest request , ResponseEntity < String > response ) { \nConfiguration config = Configuration . builder ( ) . options ( Option . DEFAULT_PATH_LEAF_TO_NULL ) . build ( ) ; \nReadContext readContext = JsonPath . using ( config ) . parse ( response . getBody ( ) ) ; \nString success = readContext . read ( SUCCESS_QUERY ) ; \nif ( ! \"true\" . equalsIgnoreCase ( success ) ) { \nString error = readContext . read ( MESSAGE_QUERY ) ; \nreturn notificationError ( error ) ; \n} \nObject rows = readContext . read ( ROWS_QUERY ) ; \nif ( ! ( rows instanceof JSONArray ) ) { \nthrow new RuntimeException ( \"Expected 'rows' to be an array of tasks\" ) ; \n} \nString source = getNotificationSource ( request ) ; \nList < NotificationEntry > list = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \n( ( JSONArray ) rows ) . size ( ) > i ; \ni ++ ) { \nNotificationEntry entry = mapNotificationEntry ( readContext , i , source ) ; \nif ( entry != null ) { \nattachActions ( request , entry ) ; \nlist . add ( entry ) ; \n} \n} \nNotificationResponse notification = new NotificationResponse ( ) ; \nif ( ! list . isEmpty ( ) ) { \nNotificationCategory category = getNotificationCategory ( request ) ; \ncategory . addEntries ( list ) ; \nnotification . setCategories ( Arrays . asList ( category ) ) ; \n} \nreturn notification ; \n} \n} \n"}
{"7478": "public class Intersection3D_I32 { \npublic static boolean contained ( Box3D_I32 boxA , Box3D_I32 boxB ) { \nreturn ( boxB . p0 . x >= boxA . p0 . x && boxB . p1 . x <= boxA . p1 . x && boxB . p0 . y >= boxA . p0 . y && boxB . p1 . y <= boxA . p1 . y && boxB . p0 . z >= boxA . p0 . z && boxB . p1 . z <= boxA . p1 . z ) ; \n} \n} \n"}
{"7479": "public class DistancePointTriangle3D_F64 { \npublic void closestPoint ( Point3D_F64 P , Point3D_F64 closestPt ) { \nGeometryMath_F64 . sub ( B , P , D ) ; \na = E0 . dot ( E0 ) ; \nb = E0 . dot ( E1 ) ; \nc = E1 . dot ( E1 ) ; \nd = E0 . dot ( D ) ; \ne = E1 . dot ( D ) ; \ndouble det = a * c - b * b ; \ns = b * e - c * d ; \nt = b * d - a * e ; \nif ( det >= s + t ) { \nif ( 0 > s ) { \nif ( 0 > t ) { \nregion4 ( ) ; \n} \nelse { \nregion3 ( ) ; \n} \n} \nelse if ( 0 > t ) { \nregion5 ( ) ; \n} \nelse { \nregion0 ( det ) ; \n} \n} \nelse { \nif ( 0 > s ) { \nregion2 ( ) ; \n} \nelse if ( 0 > t ) { \nregion6 ( ) ; \n} \nelse { \nregion1 ( ) ; \n} \n} \nclosestPt . x = B . x + s * E0 . x + t * E1 . x ; \nclosestPt . y = B . y + s * E0 . y + t * E1 . y ; \nclosestPt . z = B . z + s * E0 . z + t * E1 . z ; \n} \n} \n"}
{"7486": "public class UtilPolygons2D_F64 { \npublic static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { \nrectangle . p0 . set ( polygon . get ( 0 ) ) ; \nrectangle . p1 . set ( polygon . get ( 0 ) ) ; \nfor ( int i = 0 ; \npolygon . size ( ) > i ; \ni ++ ) { \nPoint2D_F64 p = polygon . get ( i ) ; \nif ( rectangle . p0 . x > p . x ) { \nrectangle . p0 . x = p . x ; \n} \nelse if ( rectangle . p1 . x < p . x ) { \nrectangle . p1 . x = p . x ; \n} \nif ( rectangle . p0 . y > p . y ) { \nrectangle . p0 . y = p . y ; \n} \nelse if ( rectangle . p1 . y < p . y ) { \nrectangle . p1 . y = p . y ; \n} \n} \n} \n} \n"}
{"7488": "public class UtilPolygons2D_F64 { \npublic static void vertexAverage ( Polygon2D_F64 input , Point2D_F64 average ) { \naverage . setIdx ( 0 , 0 ) ; \nfor ( int i = 0 ; \ninput . size ( ) > i ; \ni ++ ) { \nPoint2D_F64 v = input . vertexes . data [ i ] ; \naverage . x += v . x ; \naverage . y += v . y ; \n} \naverage . x /= input . size ( ) ; \naverage . y /= input . size ( ) ; \n} \n} \n"}
{"7489": "public class UtilPolygons2D_F64 { \npublic static void convexHull ( List < Point2D_F64 > points , Polygon2D_F64 hull ) { \nPoint2D_F64 [ ] array = new Point2D_F64 [ points . size ( ) ] ; \nfor ( int i = 0 ; \npoints . size ( ) > i ; \ni ++ ) { \narray [ i ] = points . get ( i ) ; \n} \nAndrewMonotoneConvexHull_F64 andrew = new AndrewMonotoneConvexHull_F64 ( ) ; \nandrew . process ( array , array . length , hull ) ; \n} \n} \n"}
{"7490": "public class UtilPolygons2D_F64 { \npublic static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { \nfor ( int i = 0 ; \npolygon . vertexes . size ( ) > i ; \n) { \nint j = ( i + 1 ) % polygon . vertexes . size ( ) ; \nint k = ( i + 2 ) % polygon . vertexes . size ( ) ; \nPoint2D_F64 p0 = polygon . vertexes . get ( i ) ; \nPoint2D_F64 p1 = polygon . vertexes . get ( j ) ; \nPoint2D_F64 p2 = polygon . vertexes . get ( k ) ; \ndouble angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; \nif ( tol >= angle ) { \npolygon . vertexes . remove ( j ) ; \nif ( i > j ) i = polygon . vertexes . size ( ) - 1 ; \n} \nelse { \ni ++ ; \n} \n} \n} \n} \n"}
{"7491": "public class UtilPolygons2D_F64 { \npublic static double averageOfClosestPointError ( Polygon2D_F64 model , Polygon2D_F64 target , int numberOfSamples ) { \nLineSegment2D_F64 line = new LineSegment2D_F64 ( ) ; \ndouble cornerLocationsB [ ] = new double [ target . size ( ) + 1 ] ; \ndouble totalLength = 0 ; \nfor ( int i = 0 ; \ntarget . size ( ) > i ; \ni ++ ) { \nPoint2D_F64 b0 = target . get ( i % target . size ( ) ) ; \nPoint2D_F64 b1 = target . get ( ( i + 1 ) % target . size ( ) ) ; \ncornerLocationsB [ i ] = totalLength ; \ntotalLength += b0 . distance ( b1 ) ; \n} \ncornerLocationsB [ target . size ( ) ] = totalLength ; \nPoint2D_F64 pointOnB = new Point2D_F64 ( ) ; \ndouble error = 0 ; \nint cornerB = 0 ; \nfor ( int k = 0 ; \nnumberOfSamples > k ; \nk ++ ) { \ndouble location = totalLength * k / numberOfSamples ; \nwhile ( cornerLocationsB [ cornerB + 1 ] < location ) { \ncornerB ++ ; \n} \nPoint2D_F64 b0 = target . get ( cornerB ) ; \nPoint2D_F64 b1 = target . get ( ( cornerB + 1 ) % target . size ( ) ) ; \ndouble locationCornerB = cornerLocationsB [ cornerB ] ; \ndouble fraction = ( location - locationCornerB ) / ( cornerLocationsB [ cornerB + 1 ] - locationCornerB ) ; \npointOnB . x = ( b1 . x - b0 . x ) * fraction + b0 . x ; \npointOnB . y = ( b1 . y - b0 . y ) * fraction + b0 . y ; \ndouble best = Double . MAX_VALUE ; \nfor ( int i = 0 ; \nmodel . size ( ) + 1 > i ; \ni ++ ) { \nline . a = model . get ( i % model . size ( ) ) ; \nline . b = model . get ( ( i + 1 ) % model . size ( ) ) ; \ndouble d = Distance2D_F64 . distance ( line , pointOnB ) ; \nif ( best > d ) { \nbest = d ; \n} \n} \nerror += best ; \n} \nreturn error / numberOfSamples ; \n} \n} \n"}
{"7494": "public class Intersection2D_F64 { \npublic static boolean containTriangle ( Point2D_F64 a , Point2D_F64 b , Point2D_F64 c , Point2D_F64 pt ) { \nboolean ret = false ; \nif ( ( ( pt . y < a . y ) != ( pt . y < b . y ) ) && ( ( b . x - a . x ) * ( pt . y - a . y ) / ( b . y - a . y ) + a . x > pt . x ) ) ret = true ; \nif ( ( ( pt . y < b . y ) != ( pt . y < c . y ) ) && ( ( c . x - b . x ) * ( pt . y - b . y ) / ( c . y - b . y ) + b . x > pt . x ) ) ret = ! ret ; \nif ( ( ( pt . y < c . y ) != ( pt . y < a . y ) ) && ( ( a . x - c . x ) * ( pt . y - c . y ) / ( a . y - c . y ) + c . x > pt . x ) ) ret = ! ret ; \nreturn ret ; \n} \n} \n"}
{"7496": "public class Intersection2D_F64 { \npublic static Point2D_F64 intersection ( LineSegment2D_F64 l_0 , LineSegment2D_F64 l_1 , Point2D_F64 ret ) { \ndouble a0 = l_0 . b . x - l_0 . a . x ; \ndouble b0 = l_0 . b . y - l_0 . a . y ; \ndouble a1 = l_1 . b . x - l_1 . a . x ; \ndouble b1 = l_1 . b . y - l_1 . a . y ; \ndouble top = b0 * ( l_1 . a . x - l_0 . a . x ) + a0 * ( l_0 . a . y - l_1 . a . y ) ; \ndouble bottom = a0 * b1 - b0 * a1 ; \nif ( bottom == 0 ) return null ; \ndouble t_1 = top / bottom ; \nif ( 0 > t_1 || 1 < t_1 ) return null ; \ntop = b1 * ( l_0 . a . x - l_1 . a . x ) + a1 * ( l_1 . a . y - l_0 . a . y ) ; \nbottom = a1 * b0 - b1 * a0 ; \ndouble t_0 = top / bottom ; \nif ( 0 > t_0 || 1 < t_0 ) return null ; \nif ( ret == null ) { \nret = new Point2D_F64 ( ) ; \n} \nret . set ( l_1 . a . x + a1 * t_1 , l_1 . a . y + b1 * t_1 ) ; \nreturn ret ; \n} \n} \n"}
{"7498": "public class Intersection2D_F64 { \npublic static double intersection ( LineParametric2D_F64 target , LineSegment2D_F64 l ) { \ndouble a1 = l . b . x - l . a . x ; \ndouble b1 = l . b . y - l . a . y ; \ndouble top = target . slope . y * ( l . a . x - target . p . x ) + target . slope . x * ( target . p . y - l . a . y ) ; \ndouble bottom = target . slope . x * b1 - target . slope . y * a1 ; \nif ( bottom == 0 ) return Double . NaN ; \ndouble t_1 = top / bottom ; \nif ( 0 > t_1 || 1 < t_1 ) return Double . NaN ; \ntop = b1 * ( target . p . x - l . a . x ) + a1 * ( l . a . y - target . p . y ) ; \nbottom = a1 * target . slope . y - b1 * target . slope . x ; \nreturn top / bottom ; \n} \n} \n"}
{"7500": "public class Intersection2D_F64 { \npublic static boolean contains ( EllipseRotated_F64 ellipse , double x , double y ) { \nreturn ( 1.0 >= UtilEllipse_F64 . evaluate ( x , y , ellipse ) ) ; \n} \n} \n"}
{"7502": "public class ConvertRotation3D_F64 { \nprivate static double get ( DMatrixRMaj M , int index ) { \nif ( 0 > index ) { \nreturn - M . data [ - index - 1 ] ; \n} \nelse { \nreturn M . data [ index - 1 ] ; \n} \n} \n} \n"}
{"7503": "public class ConvertRotation3D_F64 { \npublic static Quaternion_F64 matrixToQuaternion ( DMatrixRMaj R , Quaternion_F64 quat ) { \nif ( quat == null ) quat = new Quaternion_F64 ( ) ; \ndouble m00 = R . unsafe_get ( 0 , 0 ) ; \ndouble m01 = R . unsafe_get ( 0 , 1 ) ; \ndouble m02 = R . unsafe_get ( 0 , 2 ) ; \ndouble m10 = R . unsafe_get ( 1 , 0 ) ; \ndouble m11 = R . unsafe_get ( 1 , 1 ) ; \ndouble m12 = R . unsafe_get ( 1 , 2 ) ; \ndouble m20 = R . unsafe_get ( 2 , 0 ) ; \ndouble m21 = R . unsafe_get ( 2 , 1 ) ; \ndouble m22 = R . unsafe_get ( 2 , 2 ) ; \ndouble trace = m00 + m11 + m22 ; \nif ( 0 < trace ) { \ndouble S = Math . sqrt ( trace + 1.0 ) * 2 ; \nquat . w = 0.25 * S ; \nquat . x = ( m21 - m12 ) / S ; \nquat . y = ( m02 - m20 ) / S ; \nquat . z = ( m10 - m01 ) / S ; \n} \nelse if ( ( m11 < m00 ) & ( m22 < m00 ) ) { \ndouble S = Math . sqrt ( 1.0 + m00 - m11 - m22 ) * 2 ; \nquat . w = ( m21 - m12 ) / S ; \nquat . x = 0.25 * S ; \nquat . y = ( m01 + m10 ) / S ; \nquat . z = ( m02 + m20 ) / S ; \n} \nelse if ( m22 < m11 ) { \ndouble S = Math . sqrt ( 1.0 + m11 - m00 - m22 ) * 2 ; \nquat . w = ( m02 - m20 ) / S ; \nquat . x = ( m01 + m10 ) / S ; \nquat . y = 0.25 * S ; \nquat . z = ( m12 + m21 ) / S ; \n} \nelse { \ndouble S = Math . sqrt ( 1.0 + m22 - m00 - m11 ) * 2 ; \nquat . w = ( m10 - m01 ) / S ; \nquat . x = ( m02 + m20 ) / S ; \nquat . y = ( m12 + m21 ) / S ; \nquat . z = 0.25 * S ; \n} \nreturn quat ; \n} \n} \n"}
{"7515": "public class FitPlane3D_F64 { \npublic boolean svd ( List < Point3D_F64 > points , Point3D_F64 outputCenter , Vector3D_F64 outputNormal ) { \nfinal int N = points . size ( ) ; \noutputCenter . set ( 0 , 0 , 0 ) ; \nfor ( int i = 0 ; \nN > i ; \ni ++ ) { \nPoint3D_F64 p = points . get ( i ) ; \noutputCenter . x += p . x ; \noutputCenter . y += p . y ; \noutputCenter . z += p . z ; \n} \noutputCenter . x /= N ; \noutputCenter . y /= N ; \noutputCenter . z /= N ; \nreturn solvePoint ( points , outputCenter , outputNormal ) ; \n} \n} \n"}
{"7516": "public class FitPlane3D_F64 { \npublic boolean solvePoint ( List < Point3D_F64 > points , Point3D_F64 pointOnPlane , Vector3D_F64 outputNormal ) { \nfinal int N = points . size ( ) ; \nA . reshape ( N , 3 ) ; \nint index = 0 ; \nfor ( int i = 0 ; \nN > i ; \ni ++ ) { \nPoint3D_F64 p = points . get ( i ) ; \nA . data [ index ++ ] = p . x - pointOnPlane . x ; \nA . data [ index ++ ] = p . y - pointOnPlane . y ; \nA . data [ index ++ ] = p . z - pointOnPlane . z ; \n} \nif ( ! solverNull . process ( A , 1 , nullspace ) ) return false ; \noutputNormal . x = ( double ) nullspace . unsafe_get ( 0 , 0 ) ; \noutputNormal . y = ( double ) nullspace . unsafe_get ( 1 , 0 ) ; \noutputNormal . z = ( double ) nullspace . unsafe_get ( 2 , 0 ) ; \nreturn true ; \n} \n} \n"}
{"7527": "public class UtilAngle { \npublic static double distHalf ( double angA , double angB ) { \ndouble a = Math . abs ( angA - angB ) ; \nif ( Math . PI / 2 >= a ) return a ; \nelse return Math . PI - a ; \n} \n} \n"}
{"7529": "public class Intersection3D_F64 { \nprivate static boolean containedPlane ( Point3D_F64 T_v0 , Point3D_F64 output , Vector3D_F64 u , Vector3D_F64 v , Vector3D_F64 w0 ) { \ndouble uu , uv , vv , wu , wv , D ; \nuu = u . dot ( u ) ; \nuv = u . dot ( v ) ; \nvv = v . dot ( v ) ; \nw0 . minus ( output , T_v0 ) ; \nwu = w0 . dot ( u ) ; \nwv = w0 . dot ( v ) ; \nD = uv * uv - uu * vv ; \ndouble s , t ; \ns = ( uv * wv - vv * wu ) / D ; \nif ( 0.0 > s || 1.0 < s ) return false ; \nt = ( uv * wu - uu * wv ) / D ; \nreturn ! ( 0.0 > t ) && ! ( 1.0 < ( s + t ) ) ; \n} \n} \n"}
{"7530": "public class Intersection3D_F64 { \npublic static boolean intersect ( LineParametric3D_F64 line , Sphere3D_F64 sphere , Point3D_F64 a , Point3D_F64 b ) { \ndouble r2 = sphere . radius * sphere . radius ; \ndouble PP = GeometryMath_F64 . dot ( line . p , line . p ) ; \ndouble PV = GeometryMath_F64 . dot ( line . p , line . slope ) ; \ndouble PX = GeometryMath_F64 . dot ( line . p , sphere . center ) ; \ndouble VV = GeometryMath_F64 . dot ( line . slope , line . slope ) ; \ndouble VX = GeometryMath_F64 . dot ( line . slope , sphere . center ) ; \ndouble XX = GeometryMath_F64 . dot ( sphere . center , sphere . center ) ; \ndouble A = VV ; \ndouble B = 2.0 * ( PV - VX ) ; \ndouble C = PP + XX - 2.0 * PX - r2 ; \ndouble inner = B * B - 4.0 * A * C ; \nif ( 0 > inner ) return false ; \ndouble sqrt = Math . sqrt ( inner ) ; \ndouble t0 = ( - B + sqrt ) / ( 2.0 * A ) ; \ndouble t1 = ( - B - sqrt ) / ( 2.0 * A ) ; \nline . setPointOnLine ( t0 , a ) ; \nline . setPointOnLine ( t1 , b ) ; \nreturn true ; \n} \n} \n"}
{"7531": "public class InterpolateLinearSe2_F64 { \npublic static void interpolate ( Se2_F64 a , Se2_F64 b , double where , Se2_F64 output ) { \ndouble w0 = 1.0 - where ; \noutput . T . x = a . T . x * w0 + b . T . x * where ; \noutput . T . y = a . T . y * w0 + b . T . y * where ; \ndouble yaw0 = a . getYaw ( ) ; \ndouble yaw1 = b . getYaw ( ) ; \ndouble cw = UtilAngle . distanceCW ( yaw0 , yaw1 ) ; \ndouble ccw = UtilAngle . distanceCCW ( yaw0 , yaw1 ) ; \ndouble yaw ; \nif ( ccw < cw ) { \nyaw = yaw0 + ccw * where ; \n} \nelse { \nyaw = yaw0 - cw * where ; \n} \noutput . setYaw ( yaw ) ; \n} \n} \n"}
{"7533": "public class AndrewMonotoneConvexHull_F64 { \npublic void process ( Point2D_F64 [ ] input , int length , Polygon2D_F64 hull ) { \nif ( length == 2 ) { \nhull . vertexes . resize ( length ) ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nhull . get ( i ) . set ( input [ i ] ) ; \n} \nreturn ; \n} \nsorter . sort ( input , length ) ; \nwork . reset ( ) ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( 2 <= work . size ( ) && 0 <= subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) ) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nint minSize = work . size + 2 ; \nfor ( int i = length - 1 ; \n0 <= i ; \ni -- ) { \nPoint2D_F64 p = input [ i ] ; \nwhile ( minSize <= work . size ( ) && 0 <= subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) ) { \nwork . removeTail ( ) ; \n} \nwork . add ( p ) ; \n} \nwork . removeTail ( ) ; \nhull . vertexes . resize ( work . size ) ; \nfor ( int i = 0 ; \nwork . size ( ) > i ; \ni ++ ) { \nhull . vertexes . data [ i ] . set ( work . get ( i ) ) ; \n} \n} \n} \n"}
{"7538": "public class SpecialEuclideanOps_F64 { \npublic static boolean isIdentical ( Se3_F64 a , Se3_F64 b , double tolT , double tolR ) { \nif ( tolT < Math . abs ( a . T . x - b . T . x ) ) return false ; \nif ( tolT < Math . abs ( a . T . y - b . T . y ) ) return false ; \nif ( tolT < Math . abs ( a . T . z - b . T . z ) ) return false ; \nDMatrixRMaj D = new DMatrixRMaj ( 3 , 3 ) ; \nCommonOps_DDRM . multTransA ( a . R , b . R , D ) ; \nRodrigues_F64 rod = new Rodrigues_F64 ( ) ; \nConvertRotation3D_F64 . matrixToRodrigues ( D , rod ) ; \nreturn tolR >= rod . theta ; \n} \n} \n"}
{"7545": "public class ClosestPoint3D_F64 { \npublic static Point3D_F64 closestPoint ( LineSegment3D_F64 line , Point3D_F64 pt , Point3D_F64 ret ) { \nif ( ret == null ) { \nret = new Point3D_F64 ( ) ; \n} \ndouble dx = pt . x - line . a . x ; \ndouble dy = pt . y - line . a . y ; \ndouble dz = pt . z - line . a . z ; \ndouble slope_x = line . b . x - line . a . x ; \ndouble slope_y = line . b . y - line . a . y ; \ndouble slope_z = line . b . z - line . a . z ; \ndouble n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; \ndouble d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; \nif ( 0 >= d ) { \nret . set ( line . a ) ; \n} \nelse if ( n <= d ) { \nret . set ( line . b ) ; \n} \nelse { \nret . x = line . a . x + d * slope_x / n ; \nret . y = line . a . y + d * slope_y / n ; \nret . z = line . a . z + d * slope_z / n ; \n} \nreturn ret ; \n} \n} \n"}
{"7548": "public class SePointOps_F64 { \npublic static void transform ( Se2_F64 se , Point2D_F64 points [ ] , int length ) { \ndouble tranX = se . getX ( ) ; \ndouble tranY = se . getY ( ) ; \nfinal double c = se . getCosineYaw ( ) ; \nfinal double s = se . getSineYaw ( ) ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nPoint2D_F64 pt = points [ i ] ; \ndouble x = pt . x ; \ndouble y = pt . y ; \npt . x = tranX + x * c - y * s ; \npt . y = tranY + x * s + y * c ; \n} \n} \n} \n"}
{"7549": "public class Quadrilateral_F64 { \npublic boolean isEquals ( Quadrilateral_F64 quad , double tol ) { \ntol *= tol ; \nif ( tol < a . distance2 ( quad . a ) ) return false ; \nif ( tol < b . distance2 ( quad . b ) ) return false ; \nif ( tol < c . distance2 ( quad . c ) ) return false ; \nreturn tol >= d . distance2 ( quad . d ) ; \n} \n} \n"}
{"7550": "public class UtilLine2D_F64 { \npublic static double acuteAngle ( LineGeneral2D_F64 a , LineGeneral2D_F64 b ) { \ndouble la = Math . sqrt ( a . A * a . A + a . B * a . B ) ; \ndouble lb = Math . sqrt ( b . A * b . A + b . B * b . B ) ; \ndouble value = ( a . A * b . A + a . B * b . B ) / ( la * lb ) ; \nif ( - 1.0 > value ) value = - 1.0 ; \nelse if ( 1.0 < value ) value = 1.0 ; \nreturn Math . acos ( value ) ; \n} \n} \n"}
{"7552": "public class UtilLine2D_F64 { \npublic static LinePolar2D_F64 convert ( LineGeneral2D_F64 src , LinePolar2D_F64 ret ) { \nif ( ret == null ) ret = new LinePolar2D_F64 ( ) ; \ndouble r = Math . sqrt ( src . A * src . A + src . B * src . B ) ; \ndouble sign = 0 > src . C ? - 1 : 1 ; \nret . angle = Math . atan2 ( - sign * src . B / r , - sign * src . A / r ) ; \nret . distance = sign * src . C / r ; \nreturn ret ; \n} \n} \n"}
{"7557": "public class UtilLine2D_F64 { \npublic static LinePolar2D_F64 convert ( LineParametric2D_F64 src , LinePolar2D_F64 ret ) { \nif ( ret == null ) ret = new LinePolar2D_F64 ( ) ; \ndouble top = src . slope . y * src . p . x - src . slope . x * src . p . y ; \nret . distance = top / src . slope . norm ( ) ; \nret . angle = Math . atan2 ( - src . slope . x , src . slope . y ) ; \nif ( 0 > ret . distance ) { \nret . distance = - ret . distance ; \nret . angle = UtilAngle . bound ( ret . angle + Math . PI ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7559": "public class UtilLine2D_F64 { \npublic static LineParametric2D_F64 convert ( LineGeneral2D_F64 src , LineParametric2D_F64 ret ) { \nif ( ret == null ) { \nret = new LineParametric2D_F64 ( ) ; \n} \nret . slope . x = src . B ; \nret . slope . y = - src . A ; \nif ( Math . abs ( src . A ) < Math . abs ( src . B ) ) { \nret . p . y = - src . C / src . B ; \nret . p . x = 0 ; \n} \nelse { \nret . p . x = - src . C / src . A ; \nret . p . y = 0 ; \n} \nreturn ret ; \n} \n} \n"}
{"7565": "public class GeoTuple_F64 { \npublic boolean isIdentical ( T t , double tol ) { \nif ( t . getDimension ( ) != getDimension ( ) ) return false ; \nint N = getDimension ( ) ; \nfor ( int i = 0 ; \nN > i ; \ni ++ ) { \ndouble diff = Math . abs ( getIdx ( i ) - t . getIdx ( i ) ) ; \nif ( tol < diff ) return false ; \n} \nreturn true ; \n} \n} \n"}
{"7566": "public class GeoTuple_F64 { \n@ Override public T copy ( ) { \nT ret = createNewInstance ( ) ; \nint N = getDimension ( ) ; \nfor ( int i = 0 ; \nN > i ; \ni ++ ) { \nret . setIdx ( i , getIdx ( i ) ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7567": "public class GeoTuple_F64 { \npublic double normSq ( ) { \ndouble total = 0 ; \nint N = getDimension ( ) ; \nfor ( int i = 0 ; \nN > i ; \ni ++ ) { \ndouble a = getIdx ( i ) ; \ntotal += a * a ; \n} \nreturn total ; \n} \n} \n"}
{"7568": "public class UtilLine3D_F64 { \npublic static double computeT ( LineParametric3D_F64 line , Point3D_F64 pointOnLine ) { \ndouble dx = pointOnLine . x - line . p . x ; \ndouble dy = pointOnLine . y - line . p . y ; \ndouble dz = pointOnLine . z - line . p . z ; \ndouble adx = Math . abs ( dx ) ; \ndouble ady = Math . abs ( dy ) ; \ndouble adz = Math . abs ( dz ) ; \ndouble t ; \nif ( ady < adx ) { \nif ( adz < adx ) { \nt = dx / line . slope . x ; \n} \nelse { \nt = dz / line . slope . z ; \n} \n} \nelse if ( adz < ady ) { \nt = dy / line . slope . y ; \n} \nelse { \nt = dz / line . slope . z ; \n} \nreturn t ; \n} \n} \n"}
{"7570": "public class ParabolaGeneral_F64 { \npublic boolean isEquivalent ( ParabolaGeneral_F64 parabola , double tol ) { \ndouble scale = relativeScale ( parabola ) ; \nif ( tol < Math . abs ( A * scale - parabola . A ) ) return false ; \nif ( tol < Math . abs ( C * scale - parabola . C ) ) return false ; \nif ( tol < Math . abs ( D * scale - parabola . D ) ) return false ; \nif ( tol < Math . abs ( E * scale - parabola . E ) ) return false ; \nif ( tol < Math . abs ( F * scale - parabola . F ) ) return false ; \nreturn true ; \n} \n} \n"}
{"7573": "public class UtilPoint4D_F64 { \npublic static boolean isInfiniteH ( Point4D_F64 p , double tol ) { \ndouble n = Math . sqrt ( p . x * p . x + p . y * p . y + p . z * p . z ) ; \nreturn n * tol >= Math . abs ( p . w ) ; \n} \n} \n"}
{"7574": "public class UtilPoint4D_F64 { \npublic static List < Point4D_F64 > randomN ( Point3D_F64 center , double w , double stdev , int num , Random rand ) { \nList < Point4D_F64 > ret = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \nnum > i ; \ni ++ ) { \nPoint4D_F64 p = new Point4D_F64 ( ) ; \np . x = center . x + rand . nextGaussian ( ) * stdev ; \np . y = center . y + rand . nextGaussian ( ) * stdev ; \np . z = center . z + rand . nextGaussian ( ) * stdev ; \np . w = w ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7577": "public class UtilVector2D_F64 { \npublic static boolean identicalSign ( double xa , double ya , double xb , double yb , double tol ) { \ndouble dx0 = xb - xa ; \ndouble dy0 = yb - ya ; \ndouble dx1 = xb + xa ; \ndouble dy1 = yb + ya ; \ndouble error0 = dx0 * dx0 + dy0 * dy0 ; \ndouble error1 = dx1 * dx1 + dy1 * dy1 ; \nif ( error1 > error0 ) { \nreturn tol * tol >= error0 ; \n} \nelse { \nreturn tol * tol >= error1 ; \n} \n} \n} \n"}
{"7585": "public class Distance3D_F64 { \npublic static double distance ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 ) { \ndouble x = l0 . p . x - l1 . p . x ; \ndouble y = l0 . p . y - l1 . p . y ; \ndouble z = l0 . p . z - l1 . p . z ; \ndouble dv01v1 = MiscOps . dot ( x , y , z , l1 . slope ) ; \ndouble dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; \ndouble dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; \ndouble bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; \ndouble t0 ; \nif ( bottom == 0 ) { \nt0 = 0 ; \n} \nelse { \nt0 = ( dv01v1 * dv1v0 - MiscOps . dot ( x , y , z , l0 . slope ) * dv1v1 ) / bottom ; \n} \ndouble t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; \ndouble dx = ( l0 . p . x + t0 * l0 . slope . x ) - ( l1 . p . x + t1 * l1 . slope . x ) ; \ndouble dy = ( l0 . p . y + t0 * l0 . slope . y ) - ( l1 . p . y + t1 * l1 . slope . y ) ; \ndouble dz = ( l0 . p . z + t0 * l0 . slope . z ) - ( l1 . p . z + t1 * l1 . slope . z ) ; \ndouble distanceSq = dx * dx + dy * dy + dz * dz ; \nif ( 0 > distanceSq ) return 0 ; \nelse return Math . sqrt ( distanceSq ) ; \n} \n} \n"}
{"7586": "public class Distance3D_F64 { \npublic static double distance ( LineParametric3D_F64 l , Point3D_F64 p ) { \ndouble x = l . p . x - p . x ; \ndouble y = l . p . y - p . y ; \ndouble z = l . p . z - p . z ; \ndouble cc = x * x + y * y + z * z ; \ndouble b = MiscOps . dot ( x , y , z , l . slope ) / l . slope . norm ( ) ; \ndouble distanceSq = cc - b * b ; \nif ( 0 > distanceSq ) { \nreturn 0 ; \n} \nelse { \nreturn Math . sqrt ( distanceSq ) ; \n} \n} \n} \n"}
{"7587": "public class Distance3D_F64 { \npublic static double distance ( LineSegment3D_F64 l , Point3D_F64 p ) { \ndouble dx = p . x - l . a . x ; \ndouble dy = p . y - l . a . y ; \ndouble dz = p . z - l . a . z ; \ndouble cc = dx * dx + dy * dy + dz * dz ; \ndouble slope_x = l . b . x - l . a . x ; \ndouble slope_y = l . b . y - l . a . y ; \ndouble slope_z = l . b . z - l . a . z ; \ndouble n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; \ndouble d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; \nif ( 0 >= d ) return p . distance ( l . a ) ; \nelse if ( n <= d ) return p . distance ( l . b ) ; \ndouble distanceSq = cc - d * d ; \nif ( 0 > distanceSq ) { \nreturn 0 ; \n} \nelse { \nreturn Math . sqrt ( distanceSq ) ; \n} \n} \n} \n"}
{"7591": "public class Distance2D_F64 { \npublic static double distanceSq ( LineSegment2D_F64 segmentA , LineSegment2D_F64 segmentB ) { \ndouble slopeAX = segmentA . slopeX ( ) ; \ndouble slopeAY = segmentA . slopeY ( ) ; \ndouble slopeBX = segmentB . slopeX ( ) ; \ndouble slopeBY = segmentB . slopeY ( ) ; \ndouble ta = slopeBX * ( segmentA . a . y - segmentB . a . y ) - slopeBY * ( segmentA . a . x - segmentB . a . x ) ; \ndouble bottom = slopeBY * slopeAX - slopeAY * slopeBX ; \nif ( bottom != 0 ) { \nta /= bottom ; \nif ( 0 <= ta && 1.0 >= ta ) { \ndouble tb = slopeAX * ( segmentB . a . y - segmentA . a . y ) - slopeAY * ( segmentB . a . x - segmentA . a . x ) ; \ntb /= slopeAY * slopeBX - slopeBY * slopeAX ; \nif ( 0 <= tb && 1.0 >= tb ) return 0 ; \n} \n} \ndouble closest = Double . MAX_VALUE ; \nclosest = Math . min ( closest , distanceSq ( segmentA , segmentB . a ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentA , segmentB . b ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentB , segmentA . a ) ) ; \nclosest = Math . min ( closest , distanceSq ( segmentB , segmentA . b ) ) ; \nreturn closest ; \n} \n} \n"}
{"7595": "public class Distance2D_F64 { \npublic static double distanceSq ( Polygon2D_F64 poly , Point2D_F64 p , LineSegment2D_F64 storage ) { \nif ( storage == null ) storage = LineSegment2D_F64 . wrap ( null , null ) ; \ndouble minimum = Double . MAX_VALUE ; \nfor ( int i = 0 ; \npoly . size ( ) > i ; \ni ++ ) { \nint j = ( i + 1 ) % poly . size ( ) ; \nstorage . a = poly . vertexes . data [ i ] ; \nstorage . b = poly . vertexes . data [ j ] ; \ndouble d = distanceSq ( storage , p ) ; \nif ( minimum > d ) minimum = d ; \n} \nreturn minimum ; \n} \n} \n"}
{"7600": "public class ClosestPoint2D_F64 { \npublic static Point2D_F64 closestPoint ( LineSegment2D_F64 line , Point2D_F64 p , Point2D_F64 output ) { \nif ( output == null ) output = new Point2D_F64 ( ) ; \ndouble slopeX = line . b . x - line . a . x ; \ndouble slopeY = line . b . y - line . a . y ; \ndouble t = slopeX * ( p . x - line . a . x ) + slopeY * ( p . y - line . a . y ) ; \nt /= slopeX * slopeX + slopeY * slopeY ; \nif ( 0 > t ) t = 0 ; \nelse if ( 1 < t ) t = 1 ; \noutput . x = line . a . x + slopeX * t ; \noutput . y = line . a . y + slopeY * t ; \nreturn output ; \n} \n} \n"}
{"7602": "public class FitPolynomialSolverTall_F64 { \npublic boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { \nint N = length / 2 ; \nint numCoefs = output . size ( ) ; \nA . reshape ( N , numCoefs ) ; \nb . reshape ( N , 1 ) ; \nx . reshape ( numCoefs , 1 ) ; \nint end = offset + length ; \nfor ( int i = offset , idxA = 0 ; \nend > i ; \ni += 2 ) { \ndouble x = data [ i ] ; \ndouble y = data [ i + 1 ] ; \ndouble pow = 1.0 ; \nfor ( int j = 0 ; \nnumCoefs > j ; \nj ++ ) { \nA . data [ idxA ++ ] = pow ; \npow *= x ; \n} \nb . data [ i / 2 ] = y ; \n} \nif ( ! solver . setA ( A ) ) return false ; \nsolver . solve ( b , x ) ; \nfor ( int i = 0 ; \nnumCoefs > i ; \ni ++ ) { \noutput . set ( i , x . data [ i ] ) ; \n} \nreturn true ; \n} \n} \n"}
{"7604": "public class UtilVector3D_F64 { \npublic static Vector3D_F64 perpendicularCanonical ( Vector3D_F64 A , Vector3D_F64 output ) { \nif ( output == null ) output = new Vector3D_F64 ( ) ; \ndouble scale = Math . abs ( A . x ) + Math . abs ( A . y ) + Math . abs ( A . z ) ; \nif ( scale == 0 ) { \noutput . set ( 0 , 0 , 0 ) ; \n} \nelse { \ndouble x = A . x / scale ; \ndouble y = A . y / scale ; \ndouble z = A . z / scale ; \nif ( Math . abs ( y ) < Math . abs ( x ) ) { \noutput . set ( z , 0 , - x ) ; \n} \nelse { \noutput . set ( 0 , z , - y ) ; \n} \n} \nreturn output ; \n} \n} \n"}
{"7605": "public class UtilVector3D_F64 { \npublic static boolean isIdentical ( Vector3D_F64 a , Vector3D_F64 b , double tol ) { \nif ( tol < Math . abs ( a . x - b . x ) ) return false ; \nif ( tol < Math . abs ( a . y - b . y ) ) return false ; \nreturn tol >= Math . abs ( a . z - b . z ) ; \n} \n} \n"}
{"7607": "public class UtilVector3D_F64 { \npublic static DMatrixRMaj createMatrix ( DMatrixRMaj R , Vector3D_F64 ... v ) { \nif ( R == null ) { \nR = new DMatrixRMaj ( 3 , v . length ) ; \n} \nfor ( int i = 0 ; \nv . length > i ; \ni ++ ) { \nR . set ( 0 , i , v [ i ] . x ) ; \nR . set ( 1 , i , v [ i ] . y ) ; \nR . set ( 2 , i , v [ i ] . z ) ; \n} \nreturn R ; \n} \n} \n"}
{"7613": "public class Area2D_F64 { \npublic static double quadrilateral ( Quadrilateral_F64 quad ) { \ndouble bx = quad . b . x - quad . a . x ; \ndouble by = quad . b . y - quad . a . y ; \ndouble cx = quad . c . x - quad . a . x ; \ndouble cy = quad . c . y - quad . a . y ; \ndouble dx = quad . d . x - quad . a . x ; \ndouble dy = quad . d . y - quad . a . y ; \nif ( ( 0 <= bx * cy - by * cx ) == ( 0 <= cx * dy - cy * dx ) ) { \nreturn triangle ( quad . a , quad . b , quad . c ) + triangle ( quad . a , quad . c , quad . d ) ; \n} \nelse { \nreturn triangle ( quad . a , quad . b , quad . d ) + triangle ( quad . b , quad . c , quad . d ) ; \n} \n} \n} \n"}
{"7614": "public class Area2D_F64 { \npublic static double polygonSimple ( Polygon2D_F64 poly ) { \ndouble total = 0 ; \nPoint2D_F64 v0 = poly . get ( 0 ) ; \nPoint2D_F64 v1 = poly . get ( 1 ) ; \nfor ( int i = 2 ; \npoly . size ( ) > i ; \ni ++ ) { \nPoint2D_F64 v2 = poly . get ( i ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nv0 = v1 ; \nv1 = v2 ; \n} \nPoint2D_F64 v2 = poly . get ( 0 ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nv0 = v1 ; \nv1 = v2 ; \nv2 = poly . get ( 1 ) ; \ntotal += v1 . x * ( v2 . y - v0 . y ) ; \nreturn Math . abs ( total / 2.0 ) ; \n} \n} \n"}
{"7615": "public class UtilPoint2D_F64 { \npublic static Point2D_F64 mean ( Point2D_F64 [ ] list , int offset , int length , Point2D_F64 mean ) { \nif ( mean == null ) mean = new Point2D_F64 ( ) ; \ndouble x = 0 ; \ndouble y = 0 ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nPoint2D_F64 p = list [ offset + i ] ; \nx += p . getX ( ) ; \ny += p . getY ( ) ; \n} \nx /= length ; \ny /= length ; \nmean . set ( x , y ) ; \nreturn mean ; \n} \n} \n"}
{"7616": "public class UtilPoint2D_F64 { \npublic static List < Point2D_F64 > orderCCW ( List < Point2D_F64 > points ) { \nPoint2D_F64 center = mean ( points , null ) ; \ndouble angles [ ] = new double [ points . size ( ) ] ; \nfor ( int i = 0 ; \nangles . length > i ; \ni ++ ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - center . x ; \ndouble dy = p . y - center . y ; \nangles [ i ] = Math . atan2 ( dy , dx ) ; \n} \nint order [ ] = new int [ points . size ( ) ] ; \nQuickSort_F64 sorter = new QuickSort_F64 ( ) ; \nsorter . sort ( angles , 0 , points . size ( ) , order ) ; \nList < Point2D_F64 > out = new ArrayList < Point2D_F64 > ( points . size ( ) ) ; \nfor ( int i = 0 ; \npoints . size ( ) > i ; \ni ++ ) { \nout . add ( points . get ( order [ i ] ) ) ; \n} \nreturn out ; \n} \n} \n"}
{"7617": "public class UtilPoint2D_F64 { \npublic static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { \nif ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) { \nif ( covariance instanceof ReshapeMatrix ) { \n( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Must be a 2x2 matrix\" ) ; \n} \n} \nmean ( points , mean ) ; \ndouble xx = 0 , xy = 0 , yy = 0 ; \nfor ( int i = 0 ; \npoints . size ( ) > i ; \ni ++ ) { \nPoint2D_F64 p = points . get ( i ) ; \ndouble dx = p . x - mean . x ; \ndouble dy = p . y - mean . y ; \nxx += dx * dx ; \nxy += dx * dy ; \nyy += dy * dy ; \n} \nxx /= points . size ( ) ; \nxy /= points . size ( ) ; \nyy /= points . size ( ) ; \ncovariance . unsafe_set ( 0 , 0 , xx ) ; \ncovariance . unsafe_set ( 0 , 1 , xy ) ; \ncovariance . unsafe_set ( 1 , 0 , xy ) ; \ncovariance . unsafe_set ( 1 , 1 , yy ) ; \n} \n} \n"}
{"7618": "public class UtilPolygons2D_I32 { \npublic static boolean isConvex ( Polygon2D_I32 poly ) { \nfinal int N = poly . size ( ) ; \nint numPositive = 0 ; \nfor ( int i = 0 ; \nN > i ; \ni ++ ) { \nint j = ( i + 1 ) % N ; \nint k = ( i + 2 ) % N ; \nPoint2D_I32 a = poly . vertexes . data [ i ] ; \nPoint2D_I32 b = poly . vertexes . data [ j ] ; \nPoint2D_I32 c = poly . vertexes . data [ k ] ; \nint dx0 = a . x - b . x ; \nint dy0 = a . y - b . y ; \nint dx1 = c . x - b . x ; \nint dy1 = c . y - b . y ; \nint z = dx0 * dy1 - dy0 * dx1 ; \nif ( 0 < z ) numPositive ++ ; \n} \nreturn ( numPositive == 0 || numPositive == N ) ; \n} \n} \n"}
{"7620": "public class GeoTuple4D_F64 { \npublic double maxAbs ( ) { \ndouble absX = Math . abs ( x ) ; \ndouble absY = Math . abs ( y ) ; \ndouble absZ = Math . abs ( z ) ; \ndouble absW = Math . abs ( w ) ; \ndouble found = Math . max ( absX , absY ) ; \nif ( absZ > found ) found = absZ ; \nif ( absW > found ) found = absW ; \nreturn found ; \n} \n} \n"}
{"7623": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > random ( PlaneNormal3D_F64 plane , double max , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \nVector3D_F64 axisX = new Vector3D_F64 ( ) ; \nVector3D_F64 axisY = new Vector3D_F64 ( ) ; \nUtilPlane3D_F64 . selectAxis2D ( plane . n , axisX , axisY ) ; \nfor ( int i = 0 ; \nnum > i ; \ni ++ ) { \ndouble x = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; \ndouble y = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = plane . p . x + axisX . x * x + axisY . x * y ; \np . y = plane . p . y + axisX . y * x + axisY . y * y ; \np . z = plane . p . z + axisX . z * x + axisY . z * y ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7624": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > random ( Point3D_F64 mean , double minX , double maxX , double minY , double maxY , double minZ , double maxZ , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \nnum > i ; \ni ++ ) { \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = mean . x + rand . nextDouble ( ) * ( maxX - minX ) + minX ; \np . y = mean . y + rand . nextDouble ( ) * ( maxY - minY ) + minY ; \np . z = mean . z + rand . nextDouble ( ) * ( maxZ - minZ ) + minZ ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7625": "public class UtilPoint3D_F64 { \npublic static List < Point3D_F64 > randomN ( Point3D_F64 mean , double stdX , double stdY , double stdZ , int num , Random rand ) { \nList < Point3D_F64 > ret = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \nnum > i ; \ni ++ ) { \nPoint3D_F64 p = new Point3D_F64 ( ) ; \np . x = mean . x + rand . nextGaussian ( ) * stdX ; \np . y = mean . y + rand . nextGaussian ( ) * stdY ; \np . z = mean . z + rand . nextGaussian ( ) * stdZ ; \nret . add ( p ) ; \n} \nreturn ret ; \n} \n} \n"}
{"7627": "public class UtilPoint3D_F64 { \npublic static Point3D_F64 mean ( List < Point3D_F64 > points , int num , Point3D_F64 mean ) { \nif ( mean == null ) mean = new Point3D_F64 ( ) ; \ndouble x = 0 , y = 0 , z = 0 ; \nfor ( int i = 0 ; \nnum > i ; \ni ++ ) { \nPoint3D_F64 p = points . get ( i ) ; \nx += p . x ; \ny += p . y ; \nz += p . z ; \n} \nmean . x = x / num ; \nmean . y = y / num ; \nmean . z = z / num ; \nreturn mean ; \n} \n} \n"}
{"7633": "public class InstallFeatureUtil { \nprivate Set < String > getServerXmlFeatures ( Set < String > origResult , File serverFile , List < File > parsedXmls ) { \nSet < String > result = origResult ; \nList < File > updatedParsedXmls = parsedXmls != null ? parsedXmls : new ArrayList < File > ( ) ; \nFile canonicalServerFile ; \ntry { \ncanonicalServerFile = serverFile . getCanonicalFile ( ) ; \n} \ncatch ( IOException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be accessed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \nupdatedParsedXmls . add ( canonicalServerFile ) ; \nif ( canonicalServerFile . exists ( ) ) { \ntry { \nDocument doc = new XmlDocument ( ) { \npublic Document getDocument ( File file ) throws IOException , ParserConfigurationException , SAXException { \ncreateDocument ( file ) ; \nreturn doc ; \n} \n} \n. getDocument ( canonicalServerFile ) ; \nElement root = doc . getDocumentElement ( ) ; \nNodeList nodes = root . getChildNodes ( ) ; \nfor ( int i = 0 ; \nnodes . getLength ( ) > i ; \ni ++ ) { \nif ( nodes . item ( i ) instanceof Element ) { \nElement child = ( Element ) nodes . item ( i ) ; \nif ( \"featureManager\" . equals ( child . getNodeName ( ) ) ) { \nif ( result == null ) { \nresult = new HashSet < String > ( ) ; \n} \nresult . addAll ( parseFeatureManagerNode ( child ) ) ; \n} \nelse if ( \"include\" . equals ( child . getNodeName ( ) ) ) { \nresult = parseIncludeNode ( result , canonicalServerFile , child , updatedParsedXmls ) ; \n} \n} \n} \n} \ncatch ( IOException | ParserConfigurationException | SAXException e ) { \nwarn ( \"The server file \" + serverFile + \" cannot be parsed. Skipping its features.\" ) ; \ndebug ( e ) ; \nreturn result ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7635": "public class InstallFeatureUtil { \nprivate static Set < String > parseFeatureManagerNode ( Element node ) { \nSet < String > result = new HashSet < String > ( ) ; \nNodeList features = node . getElementsByTagName ( \"feature\" ) ; \nif ( features != null ) { \nfor ( int j = 0 ; \nfeatures . getLength ( ) > j ; \nj ++ ) { \nString content = features . item ( j ) . getTextContent ( ) ; \nif ( content != null ) { \nif ( content . contains ( \":\" ) ) { \nString [ ] split = content . split ( \":\" , 2 ) ; \nresult . add ( split [ 1 ] . trim ( ) . toLowerCase ( ) ) ; \n} \nelse { \nresult . add ( content . trim ( ) . toLowerCase ( ) ) ; \n} \n} \n} \n} \nreturn result ; \n} \n} \n"}
{"7637": "public class InstallFeatureUtil { \npublic static Set < String > getOpenLibertyFeatureSet ( Set < File > jsons ) throws PluginExecutionException { \nSet < String > libertyFeatures = new HashSet < String > ( ) ; \nfor ( File file : jsons ) { \nScanner s = null ; \ntry { \ns = new Scanner ( file ) ; \nwhile ( s . findWithinHorizon ( OPEN_LIBERTY_GROUP_ID + \":([^:]*):\" , 0 ) != null ) { \nMatchResult match = s . match ( ) ; \nif ( 1 <= match . groupCount ( ) ) { \nlibertyFeatures . add ( match . group ( 1 ) ) ; \n} \n} \n} \ncatch ( FileNotFoundException e ) { \nthrow new PluginExecutionException ( \"The JSON file is not found at \" + file . getAbsolutePath ( ) , e ) ; \n} \nfinally { \nif ( s != null ) { \ns . close ( ) ; \n} \n} \n} \nreturn libertyFeatures ; \n} \n} \n"}
{"7643": "public class InstallFeatureUtil { \nprivate static boolean isReplacementJar ( File file1 , File file2 ) { \nif ( file1 == null ) { \nreturn true ; \n} \nelse if ( file2 == null ) { \nreturn false ; \n} \nelse { \nString version1 = extractVersion ( file1 . getName ( ) ) ; \nString version2 = extractVersion ( file2 . getName ( ) ) ; \nreturn 0 > compare ( version1 , version2 ) ; \n} \n} \n} \n"}
{"7644": "public class InstallFeatureUtil { \nprivate static String extractVersion ( String fileName ) { \nint startIndex = INSTALL_MAP_PREFIX . length ( ) + 1 ; \nint endIndex = fileName . lastIndexOf ( INSTALL_MAP_SUFFIX ) ; \nif ( endIndex > startIndex ) { \nreturn fileName . substring ( startIndex , endIndex ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"7645": "public class InstallFeatureUtil { \nprivate static int compare ( String version1 , String version2 ) { \nif ( version1 == null && version2 == null ) { \nreturn 0 ; \n} \nelse if ( version1 == null && version2 != null ) { \nreturn - 1 ; \n} \nelse if ( version1 != null && version2 == null ) { \nreturn 1 ; \n} \nString [ ] components1 = version1 . split ( \"\\\\.\" ) ; \nString [ ] components2 = version2 . split ( \"\\\\.\" ) ; \nfor ( int i = 0 ; \ncomponents1 . length > i && components2 . length > i ; \ni ++ ) { \nint comparison ; \ntry { \ncomparison = new Integer ( components1 [ i ] ) . compareTo ( new Integer ( components2 [ i ] ) ) ; \n} \ncatch ( NumberFormatException e ) { \ncomparison = components1 [ i ] . compareTo ( components2 [ i ] ) ; \n} \nif ( comparison != 0 ) { \nreturn comparison ; \n} \n} \nreturn components1 . length - components2 . length ; \n} \n} \n"}
{"7656": "public class Puzzle { \npublic int getDistanceToGoal ( ) { \nint distance = 0 ; \nfor ( int i = 0 ; \ncells . length > i ; \ni ++ ) { \ndistance += getDistance ( i , cells [ i ] ) ; \n} \nreturn distance ; \n} \n} \n"}
{"7661": "public class StdRandom { \npublic static int uniform ( int a , int b ) { \nif ( a >= b ) throw new IllegalArgumentException ( \"Invalid range\" ) ; \nif ( Integer . MAX_VALUE <= ( long ) b - a ) throw new IllegalArgumentException ( \"Invalid range\" ) ; \nreturn a + uniform ( b - a ) ; \n} \n} \n"}
{"7662": "public class StdRandom { \npublic static double uniform ( double a , double b ) { \nif ( ! ( b > a ) ) throw new IllegalArgumentException ( \"Invalid range\" ) ; \nreturn a + uniform ( ) * ( b - a ) ; \n} \n} \n"}
{"7663": "public class StdRandom { \npublic static int poisson ( double lambda ) { \nif ( ! ( 0.0 < lambda ) ) throw new IllegalArgumentException ( \"Parameter lambda must be positive\" ) ; \nif ( Double . isInfinite ( lambda ) ) throw new IllegalArgumentException ( \"Parameter lambda must not be infinite\" ) ; \nint k = 0 ; \ndouble p = 1.0 ; \ndouble L = Math . exp ( - lambda ) ; \ndo { \nk ++ ; \np *= uniform ( ) ; \n} \nwhile ( L <= p ) ; \nreturn k - 1 ; \n} \n} \n"}
{"7664": "public class StdRandom { \npublic static int discrete ( double [ ] a ) { \nif ( a == null ) throw new NullPointerException ( \"argument array is null\" ) ; \ndouble EPSILON = 1E-14 ; \ndouble sum = 0.0 ; \nfor ( int i = 0 ; \na . length > i ; \ni ++ ) { \nif ( ! ( 0.0 <= a [ i ] ) ) throw new IllegalArgumentException ( \"array entry \" + i + \" must be nonnegative: \" + a [ i ] ) ; \nsum = sum + a [ i ] ; \n} \nif ( 1.0 + EPSILON < sum || 1.0 - EPSILON > sum ) throw new IllegalArgumentException ( \"sum of array entries does not approximately equal 1.0: \" + sum ) ; \nwhile ( true ) { \ndouble r = uniform ( ) ; \nsum = 0.0 ; \nfor ( int i = 0 ; \na . length > i ; \ni ++ ) { \nsum = sum + a [ i ] ; \nif ( r < sum ) return i ; \n} \n} \n} \n} \n"}
{"7665": "public class StdRandom { \npublic static void main ( String [ ] args ) { \nint N = Integer . parseInt ( args [ 0 ] ) ; \nif ( args . length == 2 ) StdRandom . setSeed ( Long . parseLong ( args [ 1 ] ) ) ; \ndouble [ ] t = { \n.5 , .3 , .1 , .1 } \n; \nStdOut . println ( \"seed = \" + StdRandom . getSeed ( ) ) ; \nfor ( int i = 0 ; \nN > i ; \ni ++ ) { \nStdOut . printf ( \"%2d \" , uniform ( 100 ) ) ; \nStdOut . printf ( \"%8.5f \" , uniform ( 10.0 , 99.0 ) ) ; \nStdOut . printf ( \"%5b \" , bernoulli ( .5 ) ) ; \nStdOut . printf ( \"%7.5f \" , gaussian ( 9.0 , .2 ) ) ; \nStdOut . printf ( \"%2d \" , discrete ( t ) ) ; \nStdOut . println ( ) ; \n} \nString [ ] a = \"A B C D E F G\" . split ( \" \" ) ; \nfor ( String s : a ) StdOut . print ( s + \" \" ) ; \nStdOut . println ( ) ; \n} \n} \n"}
{"7669": "public class HqlUtil { \npublic static String joinToString ( CriteriaJoin criteriaJoin ) { \nStringBuilder builder = new StringBuilder ( \"LEFT OUTER JOIN \" ) . append ( criteriaJoin . getEntityClass ( ) . getName ( ) ) . append ( \" \" ) . append ( criteriaJoin . getAlias ( ) ) . append ( \" \" ) . append ( \" ON \" ) ; \nif ( criteriaJoin . getJoinRelations ( ) . size ( ) == 0 ) { \nthrow new RuntimeException ( \"Not found any Join Relations in \" + criteriaJoin . getAlias ( ) + \" Join Criteria ! \" ) ; \n} \nStringJoiner joiner = new StringJoiner ( \" AND \" ) ; \nList < JoinRelation > relationList = criteriaJoin . getJoinRelations ( ) ; \nfor ( JoinRelation joinRelation : relationList ) { \nStringBuilder relationBuilder = new StringBuilder ( \"\\n\" ) . append ( joinRelation . getRelationCriteria ( ) . getAlias ( ) ) . append ( \".\" ) . append ( joinRelation . getRelationField ( ) ) . append ( \"=\" ) . append ( joinRelation . getJoinedCriteria ( ) . getAlias ( ) ) . append ( \".\" ) . append ( joinRelation . getJoinedField ( ) ) ; \njoiner . add ( relationBuilder . toString ( ) ) ; \n} \nif ( 0 < joiner . length ( ) ) { \nbuilder . append ( joiner . toString ( ) ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"7678": "public class JobInfoProvider { \nprivate static void setCountIntervalValues ( TriggerInfo dto , TriggerBuilder < org . quartz . Trigger > builder ) { \nSimpleScheduleBuilder builderSc = SimpleScheduleBuilder . simpleSchedule ( ) ; \nif ( dto . getRepeatCount ( ) != 0 ) builderSc . withRepeatCount ( dto . getRepeatCount ( ) ) ; \nif ( 0 < dto . getRepeatInterval ( ) ) builderSc . withIntervalInMilliseconds ( dto . getRepeatInterval ( ) ) ; \nbuilder . withSchedule ( builderSc ) ; \n} \n} \n"}
{"7679": "public class JobInfoProvider { \nprivate static void setStartEndTime ( TriggerInfo dto , TriggerBuilder < org . quartz . Trigger > builder ) { \nif ( - 1 < dto . getStartTime ( ) ) builder . startAt ( new Date ( dto . getStartTime ( ) ) ) ; \nelse builder . startNow ( ) ; \nif ( - 1 < dto . getEndTime ( ) ) builder . endAt ( new Date ( dto . getEndTime ( ) ) ) ; \n} \n} \n"}
{"7681": "public class BufferedStreamingOutput { \n@ Override public void write ( OutputStream output ) throws IOException , WebApplicationException { \nwhile ( buffer . length < bufferedInputStream . available ( ) ) { \nbufferedInputStream . read ( buffer ) ; \noutput . write ( buffer ) ; \n} \nbuffer = new byte [ bufferedInputStream . available ( ) ] ; \nbufferedInputStream . read ( buffer ) ; \noutput . write ( buffer ) ; \nbufferedInputStream . close ( ) ; \n} \n} \n"}
{"7689": "public class MailSender { \npublic void sendMessage ( MailItem item ) throws MessagingException { \ncheckNotNull ( item . getReceivers ( ) ) ; \ncheckNotNull ( item . getReceivers ( ) . get ( 0 ) ) ; \ncheckNotNull ( item . getTitle ( ) ) ; \ncheckNotNull ( item . getBody ( ) ) ; \nMessage msg = new MimeMessage ( session ) ; \nif ( item . getSender ( ) == null || item . getSender ( ) . length ( ) == 0 ) { \nitem . setSender ( configuration . getProperties ( ) . get ( configuration . getUsernameKey ( ) ) . toString ( ) ) ; \n} \nInternetAddress from = new InternetAddress ( item . getSender ( ) ) ; \nmsg . setFrom ( from ) ; \nInternetAddress [ ] to = new InternetAddress [ item . getReceivers ( ) . size ( ) ] ; \nfor ( int i = 0 ; \nitem . getReceivers ( ) . size ( ) > i ; \ni ++ ) { \nto [ i ] = new InternetAddress ( item . getReceivers ( ) . get ( i ) ) ; \n} \nmsg . setRecipients ( Message . RecipientType . TO , to ) ; \nmsg . setSubject ( item . getTitle ( ) ) ; \nMimeBodyPart body = new MimeBodyPart ( ) ; \nbody . setContent ( item . getBody ( ) , \"text/html; charset=UTF-8\" ) ; \nMultipart content = new MimeMultipart ( ) ; \ncontent . addBodyPart ( body ) ; \nif ( item . getAttachments ( ) != null && 0 < item . getAttachments ( ) . size ( ) ) { \nfor ( DataSource attachment : item . getAttachments ( ) ) { \nBodyPart itemBodyPart = new MimeBodyPart ( ) ; \nitemBodyPart . setDataHandler ( new DataHandler ( attachment ) ) ; \nitemBodyPart . setFileName ( attachment . getName ( ) ) ; \ncontent . addBodyPart ( itemBodyPart ) ; \n} \n} \nmsg . setContent ( content ) ; \nmsg . saveChanges ( ) ; \nTransport . send ( msg ) ; \nfor ( Map . Entry < String , String [ ] > entry : item . getHeaders ( ) . entrySet ( ) ) { \nString [ ] value = msg . getHeader ( entry . getKey ( ) ) ; \nif ( value != null ) { \nentry . setValue ( value ) ; \n} \n} \n} \n} \n"}
{"7700": "public class Query { \npublic static < E > Holder < E > configureFieldByName ( Criteria < E > criteria , String name ) { \nif ( Validations . isEmptyOrNull ( name ) ) return null ; \nString [ ] names = name . split ( \"\\\\.\" ) ; \nString currentName ; \nint step = 0 ; \nCriteriaParent < E > currentCriteria = criteria ; \nFieldMeta currentFieldMeta ; \nStringJoiner aliasJoiner = new StringJoiner ( \"$\" ) ; \ndo { \ncurrentName = names [ step ] ; \nif ( Validations . isEmptyOrNull ( currentName ) ) { \nthrow new RuntimeException ( currentName + \" defined name is wrong ! \" ) ; \n} \ncurrentFieldMeta = criteria . getMeta ( ) . getFieldMap ( ) . get ( currentName ) ; \nstep ++ ; \naliasJoiner . add ( currentCriteria . getAlias ( ) ) ; \nif ( names . length <= step ) { \nbreak ; \n} \nif ( currentFieldMeta . getReference ( ) == null ) { \nthrow new RuntimeException ( \"\" + currentName + \" join field of \" + name + \"'s reference target information must defined ! \" ) ; \n} \nCriteriaJoin < E > criteriaJoin = currentCriteria . getJoin ( currentName ) ; \nif ( criteriaJoin == null ) { \ncurrentCriteria . createJoin ( currentName , currentFieldMeta . getReference ( ) . getTargetEntity ( ) , currentFieldMeta . getReference ( ) . getReferenceId ( ) ) ; \n} \ncurrentCriteria = criteriaJoin ; \n} \nwhile ( names . length <= step ) ; \nHolder < E > holder = new Holder < > ( ) ; \nholder . currentFieldName = currentName ; \nholder . currentCriteria = currentCriteria ; \nholder . currentFieldMeta = currentFieldMeta ; \nreturn holder ; \n} \n} \n"}
{"7723": "public class MD4 { \nprivate void addPadding ( ) { \nint len = BLOCK_LENGTH - bufferLen ; \nif ( 9 > len ) { \nlen += BLOCK_LENGTH ; \n} \nbyte [ ] buf = new byte [ len ] ; \nbuf [ 0 ] = ( byte ) 0x80 ; \nfor ( int i = 1 ; \nlen - 8 > i ; \ni ++ ) { \nbuf [ i ] = ( byte ) 0x00 ; \n} \ncounter = ( counter + ( long ) bufferLen ) * 8L ; \nLittleEndian . encode ( counter , buf , len - 8 ) ; \nupdate ( buf ) ; \n} \n} \n"}
{"7726": "public class Passwords { \npublic static boolean verify ( String password , byte [ ] hash ) { \nbyte [ ] h = Arrays . copyOf ( hash , HASH_LENGTH + SALT_LENGTH + 3 ) ; \nint n = 1 << ( h [ HASH_LENGTH + SALT_LENGTH ] & 0xFF ) ; \nint r = h [ HASH_LENGTH + SALT_LENGTH + 1 ] & 0xFF ; \nint p = h [ HASH_LENGTH + SALT_LENGTH + 2 ] & 0xFF ; \nif ( N < n || N_MIN > n || R < r || R_MIN > r || P < p || P_MIN > p ) { \nn = N ; \nr = R ; \np = P ; \n} \nbyte [ ] salt = new byte [ SALT_LENGTH ] ; \nSystem . arraycopy ( h , HASH_LENGTH , salt , 0 , SALT_LENGTH ) ; \nbyte [ ] expected = hash ( password , salt , r , n , p ) ; \nint result = 0 ; \nfor ( int i = 0 ; \nh . length > i ; \ni ++ ) { \nresult |= h [ i ] ^ expected [ i ] ; \n} \nreturn result == 0 ; \n} \n} \n"}
{"7735": "public class Numbers { \npublic static long max ( long ... values ) { \nParameters . checkCondition ( 0 < values . length ) ; \nlong max = values [ 0 ] ; \nfor ( int i = 1 ; \nvalues . length > i ; \ni ++ ) { \nmax = Math . max ( max , values [ i ] ) ; \n} \nreturn max ; \n} \n} \n"}
{"7736": "public class Numbers { \npublic static long min ( long ... values ) { \nParameters . checkCondition ( 0 < values . length ) ; \nlong min = values [ 0 ] ; \nfor ( int i = 1 ; \nvalues . length > i ; \ni ++ ) { \nmin = Math . min ( min , values [ i ] ) ; \n} \nreturn min ; \n} \n} \n"}
{"7741": "public class LocationForecastHelper { \npublic List < MeteoExtrasForecast > findHourlyPointForecastsFromNow ( int hoursAhead ) { \nList < MeteoExtrasForecast > pointExtrasForecasts = new ArrayList < > ( ) ; \nZonedDateTime now = getNow ( ) ; \nfor ( int i = 0 ; \nhoursAhead > i ; \ni ++ ) { \nZonedDateTime ahead = now . plusHours ( i ) ; \nOptional < PointForecast > pointForecast = getIndexer ( ) . getPointForecast ( ahead ) ; \npointForecast . ifPresent ( pof -> { \nOptional < PeriodForecast > periodForecast = getIndexer ( ) . getTightestFitPeriodForecast ( pof . getFrom ( ) ) ; \nperiodForecast . ifPresent ( pef -> pointExtrasForecasts . add ( new MeteoExtrasForecast ( pof , pef ) ) ) ; \n} \n) ; \n} \nreturn pointExtrasForecasts ; \n} \n} \n"}
{"7744": "public class LongtermForecastHelper { \npublic MeteoExtrasLongTermForecast createSimpleLongTermForecast ( ) throws MeteoException { \nList < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; \nZonedDateTime dt = getNow ( ) ; \nfor ( int i = 0 ; \n6 >= i ; \ni ++ ) { \nZonedDateTime dti = dt . plusDays ( i ) ; \nif ( getIndexer ( ) . hasForecastsForDay ( dti ) ) { \nMeteoExtrasForecastDay mefd = createSimpleForcastForDay ( dti ) ; \nif ( mefd != null && 0 < mefd . getForecasts ( ) . size ( ) ) { \nforecastDays . add ( mefd ) ; \n} \n} \n} \nreturn new MeteoExtrasLongTermForecast ( forecastDays ) ; \n} \n} \n"}
{"7745": "public class LongtermForecastHelper { \npublic MeteoExtrasLongTermForecast createLongTermForecast ( ) { \nList < MeteoExtrasForecastDay > forecastDays = new ArrayList < > ( ) ; \nZonedDateTime dt = toZeroHMSN ( getLocationForecast ( ) . getCreated ( ) . plusDays ( 1 ) ) ; \nfor ( int i = 0 ; \nseries . getSeries ( ) . size ( ) > i ; \ni ++ ) { \ncreateLongTermForecastDay ( dt . plusDays ( i ) , series . getSeries ( ) . get ( i ) ) . ifPresent ( forecastDays :: add ) ; \n} \nreturn new MeteoExtrasLongTermForecast ( forecastDays ) ; \n} \n} \n"}
{"7753": "public class MeteoForecastIndexer { \nOptional < PeriodForecast > getBestFitPeriodForecast ( ZonedDateTime from , ZonedDateTime to ) { \nif ( from == null || to == null ) { \nreturn Optional . empty ( ) ; \n} \nZonedDateTime requestFrom = toZeroMSN ( from ) ; \nZonedDateTime requestTo = toZeroMSN ( to ) ; \nList < PeriodForecast > forecastsList = dayIndex . get ( new DayIndexKey ( requestFrom ) ) ; \nif ( forecastsList == null ) { \nreturn Optional . empty ( ) ; \n} \nPeriodForecast chosenForecast = null ; \nlong score = 0 ; \nlong tmpScore = 0 ; \nfor ( PeriodForecast forecast : forecastsList ) { \nZonedDateTime actualFrom = cloneZonedDateTime ( forecast . getFrom ( ) ) ; \nZonedDateTime actualTo = cloneZonedDateTime ( forecast . getTo ( ) ) ; \nif ( requestFrom . equals ( actualFrom ) && requestTo . equals ( actualTo ) ) { \nreturn Optional . of ( forecast ) ; \n} \nelse if ( ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualFrom ) ) || ( requestFrom . isAfter ( actualTo ) && requestTo . isAfter ( actualTo ) ) || actualTo . isEqual ( actualFrom ) ) { \ncontinue ; \n} \nelse if ( requestFrom . isBefore ( actualFrom ) && requestTo . isBefore ( actualTo ) ) { \ntmpScore = hoursBetween ( requestTo , actualFrom ) ; \n} \nelse if ( ( actualFrom . isBefore ( requestFrom ) || actualFrom . isEqual ( requestFrom ) ) && actualTo . isBefore ( requestTo ) ) { \ntmpScore = hoursBetween ( actualTo , requestFrom ) ; \n} \nelse if ( actualFrom . isAfter ( requestFrom ) && ( actualTo . isBefore ( requestTo ) || actualTo . isEqual ( requestTo ) ) ) { \ntmpScore = hoursBetween ( actualTo , actualFrom ) ; \n} \nelse if ( actualFrom . isBefore ( requestFrom ) && actualTo . isAfter ( requestTo ) ) { \ntmpScore = hoursBetween ( requestTo , requestFrom ) ; \n} \nelse { \nDateTimeFormatter formatter = DateTimeFormatter . ofPattern ( \"yyyy-MM-dd:HH:mm\" ) ; \nlog . warn ( \"Unhandled forecast Requested period:\" + requestFrom . format ( formatter ) + \"--\" + requestTo . format ( formatter ) + \", Actual period: \" + actualFrom . format ( formatter ) + \"--\" + actualTo . format ( formatter ) ) ; \n} \ntmpScore = Math . abs ( tmpScore ) ; \nif ( ( score == 0 && 0 < tmpScore ) || score < tmpScore ) { \nscore = tmpScore ; \nchosenForecast = forecast ; \n} \n} \nreturn Optional . ofNullable ( chosenForecast ) ; \n} \n} \n"}
{"7770": "public class Name { \npublic String getIndex ( final int index ) { \nif ( 0 > index || components . size ( ) <= index ) { \nthrow new IllegalArgumentException ( \"Index out of bounds\" ) ; \n} \nreturn components . get ( index ) ; \n} \n} \n"}
{"7771": "public class Name { \npublic Name getPrefix ( final int upperIndex ) { \nif ( 0 > upperIndex || components . size ( ) < upperIndex ) { \nthrow new IllegalArgumentException ( \"Index out of bounds\" ) ; \n} \nreturn new Name ( components . subList ( 0 , upperIndex ) ) ; \n} \n} \n"}
{"7773": "public class Runtime { \nboolean exec ( HsrePattern re , CharSequence data , EnumSet < ExecFlags > execFlags ) throws RegexException { \nif ( 0 != ( re . guts . info & Flags . REG_UIMPOSSIBLE ) ) { \nthrow new RegexException ( \"Regex marked impossible\" ) ; \n} \neflags = 0 ; \nfor ( ExecFlags ef : execFlags ) { \nswitch ( ef ) { \ncase NOTBOL : eflags |= Flags . REG_NOTBOL ; \nbreak ; \ncase NOTEOL : eflags |= Flags . REG_NOTEOL ; \nbreak ; \ncase LOOKING_AT : eflags |= Flags . REG_LOOKING_AT ; \nbreak ; \ndefault : throw new RuntimeException ( \"impossible exec flag\" ) ; \n} \n} \nthis . re = re ; \nthis . g = re . guts ; \nthis . data = data ; \nthis . dataLength = this . data . length ( ) ; \nif ( this . match != null ) { \nthis . match . clear ( ) ; \n} \nelse { \nthis . match = Lists . newArrayList ( ) ; \n} \nmatch . add ( null ) ; \nif ( 0 != ( g . info & Flags . REG_UBACKREF ) ) { \nwhile ( g . nsub + 1 > match . size ( ) ) { \nmatch . add ( null ) ; \n} \n} \nif ( mem != null && g . ntree <= mem . length ) { \nArrays . fill ( mem , 0 ) ; \n} \nelse { \nmem = new int [ g . ntree ] ; \n} \nassert g . tree != null ; \nif ( 0 != ( g . info & Flags . REG_UBACKREF ) ) { \nreturn cfind ( g . tree . machine ) ; \n} \nelse { \nreturn find ( g . tree . machine ) ; \n} \n} \n} \n"}
{"7774": "public class Runtime { \nprivate boolean cfindloop ( Dfa d , Dfa s , int [ ] coldp ) { \nint begin ; \nint end ; \nint cold ; \nint open ; \nint close ; \nint estart ; \nint estop ; \nboolean shorter = 0 != ( g . tree . flags & Subre . SHORTER ) ; \nboolean hitend [ ] = new boolean [ 1 ] ; \nboolean lookingAt = 0 != ( eflags & Flags . REG_LOOKING_AT ) ; \nassert d != null && s != null ; \nclose = 0 ; \ndo { \nint [ ] cold0 = new int [ 1 ] ; \nif ( lookingAt ) { \nclose = d . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = 0 ; \n} \nelse { \nclose = s . shortest ( close , close , data . length ( ) , cold0 , null ) ; \ncold = cold0 [ 0 ] ; \n} \nif ( close == - 1 ) { \nbreak ; \n} \nassert cold != - 1 ; \nopen = cold ; \ncold = - 1 ; \nfor ( begin = open ; \nclose >= begin ; \nbegin ++ ) { \nif ( 0 < begin && lookingAt ) { \nreturn false ; \n} \nestart = begin ; \nestop = data . length ( ) ; \nfor ( ; \n; \n) { \nif ( shorter ) { \nend = d . shortest ( begin , estart , estop , null , hitend ) ; \n} \nelse { \nend = d . longest ( begin , estop , hitend ) ; \n} \nif ( hitend [ 0 ] && cold == - 1 ) { \ncold = begin ; \n} \nif ( end == - 1 ) { \nbreak ; \n} \nfor ( int x = 0 ; \nmatch . size ( ) > x ; \nx ++ ) { \nmatch . set ( x , null ) ; \n} \nint maxsubno = getMaxSubno ( g . tree , 0 ) ; \nmem = new int [ maxsubno + 1 ] ; \nboolean matched = cdissect ( g . tree , begin , end ) ; \nif ( matched ) { \nmatch . set ( 0 , new RegMatch ( begin , end ) ) ; \ncoldp [ 0 ] = cold ; \nreturn true ; \n} \nif ( shorter ? end == estop : end == begin ) { \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \nif ( shorter ) { \nestart = end + 1 ; \n} \nelse { \nestop = end - 1 ; \n} \n} \n} \n} \nwhile ( data . length ( ) > close ) ; \ncoldp [ 0 ] = cold ; \nreturn false ; \n} \n} \n"}
{"7775": "public class Runtime { \nprivate void subset ( RuntimeSubexpression sub , int begin , int end ) { \nint n = sub . number ; \nassert 0 < n ; \nwhile ( ( n + 1 ) > match . size ( ) ) { \nmatch . add ( null ) ; \n} \nmatch . set ( n , new RegMatch ( begin , end ) ) ; \n} \n} \n"}
{"7776": "public class Runtime { \nprivate boolean crevdissect ( RuntimeSubexpression t , int begin , int end ) { \nDfa d ; \nDfa d2 ; \nint mid ; \nassert t . op == '.' ; \nassert t . left != null && 0 < t . left . machine . states . length ; \nassert t . right != null && 0 < t . right . machine . states . length ; \nassert 0 != ( t . left . flags & Subre . SHORTER ) ; \nd = new Dfa ( this , t . left . machine ) ; \nd2 = new Dfa ( this , t . right . machine ) ; \nif ( mem [ t . retry ] == 0 ) { \nmid = d . shortest ( begin , begin , end , null , null ) ; \nif ( mid == - 1 ) { \nreturn false ; \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \n} \nelse { \nmid = begin + ( mem [ t . retry ] - 1 ) ; \n} \nfor ( ; \n; \n) { \nboolean cdmatch = cdissect ( t . left , begin , mid ) ; \nif ( cdmatch && d2 . longest ( mid , end , null ) == end && ( cdissect ( t . right , mid , end ) ) ) { \nbreak ; \n} \nif ( mid == end ) { \nreturn false ; \n} \nmid = d . shortest ( begin , mid + 1 , end , null , null ) ; \nif ( mid == - 1 ) { \nreturn false ; \n} \nmem [ t . retry ] = ( mid - begin ) + 1 ; \nzapmem ( t . left ) ; \nzapmem ( t . right ) ; \n} \nreturn true ; \n} \n} \n"}
{"7777": "public class Runtime { \nprivate boolean cbrdissect ( RuntimeSubexpression t , int begin , int end ) { \nint i ; \nint n = t . number ; \nint len ; \nint paren ; \nint p ; \nint stop ; \nint min = t . min ; \nint max = t . max ; \nassert t . op == 'b' ; \nassert 0 <= n ; \nif ( match . get ( n ) == null ) { \nreturn false ; \n} \nparen = match . get ( n ) . start ; \nlen = match . get ( n ) . end - match . get ( n ) . start ; \nif ( 0 != mem [ t . retry ] ) { \nreturn false ; \n} \nmem [ t . retry ] = 1 ; \nif ( len == 0 ) { \nreturn begin == end ; \n} \nassert begin <= end ; \nif ( len > ( end - begin ) ) { \nreturn false ; \n} \nstop = end - len ; \ni = 0 ; \nfor ( p = begin ; \nstop >= p && ( max > i || max == Compiler . INFINITY ) ; \np += len ) { \nif ( g . compare . compare ( data , paren , p , len ) != 0 ) { \nbreak ; \n} \ni ++ ; \n} \nif ( p != end ) { \nreturn false ; \n} \nreturn i >= min && ( max >= i || max == Compiler . INFINITY ) ; \n} \n} \n"}
{"7786": "public class Compiler { \nprivate int scannum ( ) throws RegexException { \nint n = 0 ; \nwhile ( see ( DIGIT ) && DUPMAX > n ) { \nn = n * 10 + nextvalue ; \nlex . next ( ) ; \n} \nif ( see ( DIGIT ) || DUPMAX < n ) { \nthrow new RegexException ( \"Unvalid reference number.\" ) ; \n} \nreturn n ; \n} \n} \n"}
{"7791": "public class Compiler { \nprivate void dovec ( UnicodeSet set , State lp , State rp ) throws RegexException { \nint rangeCount = set . getRangeCount ( ) ; \nfor ( int rx = 0 ; \nrangeCount > rx ; \nrx ++ ) { \nint rangeStart = set . getRangeStart ( rx ) ; \nint rangeEnd = set . getRangeEnd ( rx ) ; \nif ( LOG . isDebugEnabled ( ) && IS_DEBUG ) { \nLOG . debug ( String . format ( \"%s %d %4x %4x\" , set , rx , rangeStart , rangeEnd ) ) ; \n} \nif ( rangeStart == rangeEnd ) { \nnfa . newarc ( PLAIN , cm . subcolor ( rangeStart ) , lp , rp ) ; \n} \ncm . subrange ( rangeStart , rangeEnd , lp , rp ) ; \n} \n} \n} \n"}
{"7795": "public class ColorMap { \nvoid okcolors ( Nfa nfa ) { \nColorDesc cd ; \nColorDesc scd ; \nArc a ; \nshort sco ; \nfor ( short co = 0 ; \ncolorDescs . size ( ) > co ; \nco ++ ) { \ncd = colorDescs . get ( co ) ; \nif ( cd == null ) { \ncontinue ; \n} \nsco = cd . sub ; \nif ( sco == Constants . NOSUB ) { \n} \nelse if ( sco == co ) { \n} \nelse if ( cd . getNChars ( ) == 0 ) { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert 0 < scd . getNChars ( ) ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nwhile ( ( a = cd . arcs ) != null ) { \nassert a . co == co ; \ncd . arcs = a . colorchain ; \na . setColor ( sco ) ; \na . colorchain = scd . arcs ; \nscd . arcs = a ; \n} \nfreecolor ( co ) ; \n} \nelse { \ncd . sub = Constants . NOSUB ; \nscd = colorDescs . get ( sco ) ; \nassert 0 < scd . getNChars ( ) ; \nassert scd . sub == sco ; \nscd . sub = Constants . NOSUB ; \nfor ( a = cd . arcs ; \na != null ; \na = a . colorchain ) { \nassert a . co == co ; \nnfa . newarc ( a . type , sco , a . from , a . to ) ; \n} \n} \n} \n} \n} \n"}
{"7798": "public class ColorMap { \nvoid dumpcolors ( ) { \nfor ( int co = 0 ; \ncolorDescs . size ( ) > co ; \nco ++ ) { \nColorDesc cd = colorDescs . get ( co ) ; \nif ( cd != null ) { \ndumpcolor ( co , cd ) ; \n} \n} \n} \n} \n"}
{"7804": "public class Dfa { \nint lastcold ( ) { \nint nopr = 0 ; \nfor ( StateSet ss : stateSets . values ( ) ) { \nif ( ss . noprogress && ss . getLastSeen ( ) > nopr ) { \nnopr = ss . getLastSeen ( ) ; \n} \n} \nreturn nopr ; \n} \n} \n"}
{"7807": "public class CnfaBuilder { \nvoid carcsort ( int first , int last ) { \nint p ; \nint q ; \nlong tmp ; \nif ( 1 >= last - first ) { \nreturn ; \n} \nfor ( p = first ; \nlast >= p ; \np ++ ) { \nfor ( q = p ; \nlast >= q ; \nq ++ ) { \nshort pco = Cnfa . carcColor ( arcs [ p ] ) ; \nshort qco = Cnfa . carcColor ( arcs [ q ] ) ; \nint pto = Cnfa . carcTarget ( arcs [ p ] ) ; \nint qto = Cnfa . carcTarget ( arcs [ q ] ) ; \nif ( qco < pco || ( pco == qco && qto < pto ) ) { \nassert p != q ; \ntmp = arcs [ p ] ; \narcs [ p ] = arcs [ q ] ; \narcs [ q ] = tmp ; \n} \n} \n} \n} \n} \n"}
{"7821": "public class Nfa { \nvoid dumparcs ( State s , StringBuilder sb ) { \nint pos ; \nassert 0 < s . nouts ; \npos = dumprarcs ( s . outs , s , 1 , sb ) ; \nif ( pos != 1 ) { \n} \n} \n} \n"}
{"7831": "public class Nfa { \nboolean unempty ( Arc a ) { \nState from = a . from ; \nState to = a . to ; \nboolean usefrom ; \nassert a . type == Compiler . EMPTY ; \nassert from != pre && to != post ; \nif ( from == to ) { \nfreearc ( a ) ; \nreturn true ; \n} \nusefrom = true ; \nif ( to . nins < from . nouts ) { \nusefrom = false ; \n} \nelse if ( from . nouts == to . nins ) { \nif ( to . nouts < from . nins ) { \nusefrom = false ; \n} \n} \nfreearc ( a ) ; \nif ( usefrom ) { \nif ( from . nouts == 0 ) { \nmoveins ( from , to ) ; \nfreestate ( from ) ; \n} \nelse { \ncopyins ( from , to ) ; \n} \n} \nelse { \nif ( to . nins == 0 ) { \nmoveouts ( to , from ) ; \nfreestate ( to ) ; \n} \nelse { \ncopyouts ( to , from ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"7862": "public class JspServletWrapper { \npublic void setServletClassLastModifiedTime ( long lastModified ) { \nif ( lastModified > this . servletClassLastModifiedTime ) { \nsynchronized ( this ) { \nif ( lastModified > this . servletClassLastModifiedTime ) { \nthis . servletClassLastModifiedTime = lastModified ; \nreload = true ; \n} \n} \n} \n} \n} \n"}
{"7865": "public class BasicAuthentication { \npublic static String [ ] parseAuthorization ( final HttpServletRequest request ) { \nfinal String auth = request . getHeader ( \"Authorization\" ) ; \nlogger . debug ( \"Auth header: {}\" , auth ) ; \nif ( auth == null || auth . isEmpty ( ) ) { \nreturn null ; \n} \nfinal String [ ] toks = auth . split ( \"\\\\s\" ) ; \nif ( 2 > toks . length ) { \nreturn null ; \n} \nif ( ! \"Basic\" . equalsIgnoreCase ( toks [ 0 ] ) ) { \nreturn null ; \n} \nfinal byte [ ] authData = Base64 . getDecoder ( ) . decode ( toks [ 1 ] ) ; \nfinal String authStr = StandardCharsets . ISO_8859_1 . decode ( ByteBuffer . wrap ( authData ) ) . toString ( ) ; \nlogger . debug ( \"Auth String: {}\" , authStr ) ; \nfinal String [ ] authToks = authStr . split ( \":\" , 2 ) ; \nlogger . debug ( \"Auth tokens: {}\" , new Object [ ] { \nauthToks } \n) ; \nif ( authToks . length != 2 ) { \nreturn null ; \n} \nreturn authToks ; \n} \n} \n"}
{"7879": "public class JSPContextFinder { \nArrayList basicFindClassLoaders ( ) { \nClass [ ] stack = contextFinder . getClassContext ( ) ; \nArrayList result = new ArrayList ( 1 ) ; \nClassLoader previousLoader = null ; \nfor ( int i = 1 ; \nstack . length > i ; \ni ++ ) { \nClassLoader tmp = stack [ i ] . getClassLoader ( ) ; \nif ( checkClass ( stack [ i ] ) && tmp != null && tmp != this ) { \nif ( checkClassLoader ( tmp ) ) { \nif ( previousLoader != tmp ) { \nresult . add ( tmp ) ; \npreviousLoader = tmp ; \n} \n} \nif ( Activator . getBundle ( stack [ i ] ) != null ) break ; \n} \n} \nreturn result ; \n} \n} \n"}
{"7883": "public class Pagination { \npublic static < T > PaginationResult < T > paginate ( final Integer startPage , final int pageSize , final List < T > fullDataSet ) { \nreturn paginate ( startPage , pageSize , ( start , length ) -> { \nfinal int len = fullDataSet . size ( ) ; \nif ( len < start ) { \nreturn Collections . emptyList ( ) ; \n} \nreturn fullDataSet . subList ( start , Math . min ( start + length , len ) ) ; \n} \n) ; \n} \n} \n"}
{"7884": "public class MetaKey { \npublic static MetaKey fromString ( final String string ) { \nfinal int idx = string . indexOf ( ':' ) ; \nif ( 1 > idx ) { \nreturn null ; \n} \nif ( string . length ( ) <= idx + 1 ) { \nreturn null ; \n} \nreturn new MetaKey ( string . substring ( 0 , idx ) , string . substring ( idx + 1 ) , true ) ; \n} \n} \n"}
{"7887": "public class ImplicitTagLibraryInfo { \nprivate void parseImplicitTld ( JspCompilationContext ctxt , String path ) throws JasperException { \nInputStream is = null ; \nTreeNode tld = null ; \ntry { \nURL uri = ctxt . getResource ( path ) ; \nif ( uri == null ) { \nreturn ; \n} \nis = uri . openStream ( ) ; \ntld = new ParserUtils ( ) . parseXMLDocument ( IMPLICIT_TLD , is , ctxt . getOptions ( ) . isValidationEnabled ( ) ) ; \n} \ncatch ( Exception ex ) { \nthrow new JasperException ( ex ) ; \n} \nfinally { \nif ( is != null ) { \ntry { \nis . close ( ) ; \n} \ncatch ( Throwable t ) { \n} \n} \n} \nthis . jspversion = tld . findAttribute ( \"version\" ) ; \nIterator list = tld . findChildren ( ) ; \nwhile ( list . hasNext ( ) ) { \nTreeNode element = ( TreeNode ) list . next ( ) ; \nString tname = element . getName ( ) ; \nif ( \"tlibversion\" . equals ( tname ) || \"tlib-version\" . equals ( tname ) ) { \nthis . tlibversion = element . getBody ( ) ; \n} \nelse if ( \"jspversion\" . equals ( tname ) || \"jsp-version\" . equals ( tname ) ) { \nthis . jspversion = element . getBody ( ) ; \n} \nelse if ( ! \"shortname\" . equals ( tname ) && ! \"short-name\" . equals ( tname ) ) { \nerr . jspError ( \"jsp.error.implicitTld.additionalElements\" , path , tname ) ; \n} \n} \nDouble jspVersionDouble = Double . valueOf ( this . jspversion ) ; \nif ( 0 > Double . compare ( jspVersionDouble , Constants . JSP_VERSION_2_0 ) ) { \nerr . jspError ( \"jsp.error.implicitTld.jspVersion\" , path , this . jspversion ) ; \n} \n} \n} \n"}
{"7891": "public class SeekableXZInputStream { \npublic void seekToBlock ( int blockNumber ) throws IOException { \nif ( in == null ) throw new XZIOException ( \"Stream closed\" ) ; \nif ( 0 > blockNumber || blockCount <= blockNumber ) throw new XZIOException ( \"Invalid XZ Block number: \" + blockNumber ) ; \nseekPos = getBlockPos ( blockNumber ) ; \nseekNeeded = true ; \n} \n} \n"}
{"7892": "public class SeekableXZInputStream { \nprivate void locateBlockByPos ( BlockInfo info , long pos ) { \nif ( 0 > pos || uncompressedSize <= pos ) throw new IndexOutOfBoundsException ( \"Invalid uncompressed position: \" + pos ) ; \nIndexDecoder index ; \nfor ( int i = 0 ; \n; \n++ i ) { \nindex = streams . get ( i ) ; \nif ( index . hasUncompressedOffset ( pos ) ) break ; \n} \nindex . locateBlock ( info , pos ) ; \nassert ( info . compressedOffset & 3 ) == 0 ; \nassert 0 < info . uncompressedSize ; \nassert info . uncompressedOffset <= pos ; \nassert info . uncompressedOffset + info . uncompressedSize > pos ; \n} \n} \n"}
{"7894": "public class LZMAEncoderNormal { \nprivate void updateOptStateAndReps ( ) { \nint optPrev = opts [ optCur ] . optPrev ; \nassert optCur > optPrev ; \nif ( opts [ optCur ] . prev1IsLiteral ) { \n-- optPrev ; \nif ( opts [ optCur ] . hasPrev2 ) { \nopts [ optCur ] . state . set ( opts [ opts [ optCur ] . optPrev2 ] . state ) ; \nif ( REPS > opts [ optCur ] . backPrev2 ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nopts [ optCur ] . state . updateLiteral ( ) ; \n} \nelse { \nopts [ optCur ] . state . set ( opts [ optPrev ] . state ) ; \n} \nif ( optPrev == optCur - 1 ) { \nassert opts [ optCur ] . backPrev == 0 || opts [ optCur ] . backPrev == - 1 ; \nif ( opts [ optCur ] . backPrev == 0 ) opts [ optCur ] . state . updateShortRep ( ) ; \nelse opts [ optCur ] . state . updateLiteral ( ) ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 0 , REPS ) ; \n} \nelse { \nint back ; \nif ( opts [ optCur ] . prev1IsLiteral && opts [ optCur ] . hasPrev2 ) { \noptPrev = opts [ optCur ] . optPrev2 ; \nback = opts [ optCur ] . backPrev2 ; \nopts [ optCur ] . state . updateLongRep ( ) ; \n} \nelse { \nback = opts [ optCur ] . backPrev ; \nif ( REPS > back ) opts [ optCur ] . state . updateLongRep ( ) ; \nelse opts [ optCur ] . state . updateMatch ( ) ; \n} \nif ( REPS > back ) { \nopts [ optCur ] . reps [ 0 ] = opts [ optPrev ] . reps [ back ] ; \nint rep ; \nfor ( rep = 1 ; \nback >= rep ; \n++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep - 1 ] ; \nfor ( ; \nREPS > rep ; \n++ rep ) opts [ optCur ] . reps [ rep ] = opts [ optPrev ] . reps [ rep ] ; \n} \nelse { \nopts [ optCur ] . reps [ 0 ] = back - REPS ; \nSystem . arraycopy ( opts [ optPrev ] . reps , 0 , opts [ optCur ] . reps , 1 , REPS - 1 ) ; \n} \n} \n} \n} \n"}
{"7895": "public class LZMAEncoderNormal { \nprivate void calc1BytePrices ( int pos , int posState , int avail , int anyRepPrice ) { \nboolean nextIsByte = false ; \nint curByte = lz . getByte ( 0 ) ; \nint matchByte = lz . getByte ( opts [ optCur ] . reps [ 0 ] + 1 ) ; \nint literalPrice = opts [ optCur ] . price + literalEncoder . getPrice ( curByte , matchByte , lz . getByte ( 1 ) , pos , opts [ optCur ] . state ) ; \nif ( opts [ optCur + 1 ] . price > literalPrice ) { \nopts [ optCur + 1 ] . set1 ( literalPrice , optCur , - 1 ) ; \nnextIsByte = true ; \n} \nif ( matchByte == curByte && ( opts [ optCur + 1 ] . optPrev == optCur || opts [ optCur + 1 ] . backPrev != 0 ) ) { \nint shortRepPrice = getShortRepPrice ( anyRepPrice , opts [ optCur ] . state , posState ) ; \nif ( opts [ optCur + 1 ] . price >= shortRepPrice ) { \nopts [ optCur + 1 ] . set1 ( shortRepPrice , optCur , 0 ) ; \nnextIsByte = true ; \n} \n} \nif ( ! nextIsByte && matchByte != curByte && MATCH_LEN_MIN < avail ) { \nint lenLimit = Math . min ( niceLen , avail - 1 ) ; \nint len = lz . getMatchLen ( 1 , opts [ optCur ] . reps [ 0 ] , lenLimit ) ; \nif ( MATCH_LEN_MIN <= len ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + 1 ) & posMask ; \nint price = literalPrice + getLongRepAndLenPrice ( 0 , len , nextState , nextPosState ) ; \nint i = optCur + 1 + len ; \nwhile ( i > optEnd ) opts [ ++ optEnd ] . reset ( ) ; \nif ( opts [ i ] . price > price ) opts [ i ] . set2 ( price , optCur , 0 ) ; \n} \n} \n} \n} \n"}
{"7896": "public class LZMAEncoderNormal { \nprivate int calcLongRepPrices ( int pos , int posState , int avail , int anyRepPrice ) { \nint startLen = MATCH_LEN_MIN ; \nint lenLimit = Math . min ( avail , niceLen ) ; \nfor ( int rep = 0 ; \nREPS > rep ; \n++ rep ) { \nint len = lz . getMatchLen ( opts [ optCur ] . reps [ rep ] , lenLimit ) ; \nif ( MATCH_LEN_MIN > len ) continue ; \nwhile ( optCur + len > optEnd ) opts [ ++ optEnd ] . reset ( ) ; \nint longRepPrice = getLongRepPrice ( anyRepPrice , rep , opts [ optCur ] . state , posState ) ; \nfor ( int i = len ; \nMATCH_LEN_MIN <= i ; \n-- i ) { \nint price = longRepPrice + repLenEncoder . getPrice ( i , posState ) ; \nif ( opts [ optCur + i ] . price > price ) opts [ optCur + i ] . set1 ( price , optCur , rep ) ; \n} \nif ( rep == 0 ) startLen = len + 1 ; \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , opts [ optCur ] . reps [ rep ] , len2Limit ) ; \nif ( MATCH_LEN_MIN <= len2 ) { \nint price = longRepPrice + repLenEncoder . getPrice ( len , posState ) ; \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateLongRep ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nprice += literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nwhile ( i > optEnd ) opts [ ++ optEnd ] . reset ( ) ; \nif ( opts [ i ] . price > price ) opts [ i ] . set3 ( price , optCur , rep , len , 0 ) ; \n} \n} \nreturn startLen ; \n} \n} \n"}
{"7897": "public class LZMAEncoderNormal { \nprivate void calcNormalMatchPrices ( int pos , int posState , int avail , int anyMatchPrice , int startLen ) { \nif ( avail < matches . len [ matches . count - 1 ] ) { \nmatches . count = 0 ; \nwhile ( avail > matches . len [ matches . count ] ) ++ matches . count ; \nmatches . len [ matches . count ++ ] = avail ; \n} \nif ( startLen > matches . len [ matches . count - 1 ] ) return ; \nwhile ( optCur + matches . len [ matches . count - 1 ] > optEnd ) opts [ ++ optEnd ] . reset ( ) ; \nint normalMatchPrice = getNormalMatchPrice ( anyMatchPrice , opts [ optCur ] . state ) ; \nint match = 0 ; \nwhile ( matches . len [ match ] < startLen ) ++ match ; \nfor ( int len = startLen ; \n; \n++ len ) { \nint dist = matches . dist [ match ] ; \nint matchAndLenPrice = getMatchAndLenPrice ( normalMatchPrice , dist , len , posState ) ; \nif ( opts [ optCur + len ] . price > matchAndLenPrice ) opts [ optCur + len ] . set1 ( matchAndLenPrice , optCur , dist + REPS ) ; \nif ( len != matches . len [ match ] ) continue ; \nint len2Limit = Math . min ( niceLen , avail - len - 1 ) ; \nint len2 = lz . getMatchLen ( len + 1 , dist , len2Limit ) ; \nif ( MATCH_LEN_MIN <= len2 ) { \nnextState . set ( opts [ optCur ] . state ) ; \nnextState . updateMatch ( ) ; \nint curByte = lz . getByte ( len , 0 ) ; \nint matchByte = lz . getByte ( 0 ) ; \nint prevByte = lz . getByte ( len , 1 ) ; \nint price = matchAndLenPrice + literalEncoder . getPrice ( curByte , matchByte , prevByte , pos + len , nextState ) ; \nnextState . updateLiteral ( ) ; \nint nextPosState = ( pos + len + 1 ) & posMask ; \nprice += getLongRepAndLenPrice ( 0 , len2 , nextState , nextPosState ) ; \nint i = optCur + len + 1 + len2 ; \nwhile ( i > optEnd ) opts [ ++ optEnd ] . reset ( ) ; \nif ( opts [ i ] . price > price ) opts [ i ] . set3 ( price , optCur , dist + REPS , len , 0 ) ; \n} \nif ( ++ match == matches . count ) break ; \n} \n} \n} \n"}
{"7916": "public class Streams { \npublic static long copy ( final InputStream in , final OutputStream out ) throws IOException { \nObjects . requireNonNull ( in ) ; \nObjects . requireNonNull ( out ) ; \nfinal byte [ ] buffer = new byte [ COPY_BUFFER_SIZE ] ; \nlong result = 0 ; \nint rc ; \nwhile ( 0 <= ( rc = in . read ( buffer ) ) ) { \nresult += rc ; \nout . write ( buffer , 0 , rc ) ; \n} \nreturn result ; \n} \n} \n"}
{"7919": "public class Parser { \nprivate String parseQuoted ( String tx ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint size = tx . length ( ) ; \nint i = 0 ; \nwhile ( size > i ) { \nchar ch = tx . charAt ( i ) ; \nif ( ch == '&' ) { \nif ( size > i + 5 && tx . charAt ( i + 1 ) == 'a' && tx . charAt ( i + 2 ) == 'p' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 's' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\\'' ) ; \ni += 6 ; \n} \nelse if ( size > i + 5 && tx . charAt ( i + 1 ) == 'q' && tx . charAt ( i + 2 ) == 'u' && tx . charAt ( i + 3 ) == 'o' && tx . charAt ( i + 4 ) == 't' && tx . charAt ( i + 5 ) == ';' ) { \nbuf . append ( '\"' ) ; \ni += 6 ; \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \n} \nelse if ( ch == '\\\\' && size > i + 1 ) { \nch = tx . charAt ( i + 1 ) ; \nif ( ch == '\\\\' || ch == '\\\"' || ch == '\\'' || ch == '>' ) { \nbuf . append ( ch ) ; \ni += 2 ; \n} \nelse { \nbuf . append ( '\\\\' ) ; \n++ i ; \n} \n} \nelse { \nbuf . append ( ch ) ; \n++ i ; \n} \n} \nreturn buf . toString ( ) ; \n} \n} \n"}
{"7938": "public class BodyContentImpl { \nprivate void reAllocBuff ( int len ) { \nif ( cb . length >= bufferSize + len ) { \nbufferSize = cb . length ; \nreturn ; \n} \nif ( cb . length > len ) { \nlen = cb . length ; \n} \nbufferSize = cb . length + len ; \nchar [ ] tmp = new char [ bufferSize ] ; \nSystem . arraycopy ( cb , 0 , tmp , 0 , cb . length ) ; \ncb = tmp ; \ntmp = null ; \n} \n} \n"}
{"7939": "public class ELFunctionMapper { \npublic static void map ( Compiler compiler , Node . Nodes page ) throws JasperException { \nELFunctionMapper map = new ELFunctionMapper ( ) ; \nmap . ds = new StringBuilder ( ) ; \nmap . ss = new StringBuilder ( ) ; \npage . visit ( map . new ELFunctionVisitor ( ) ) ; \nString ds = map . ds . toString ( ) ; \nif ( 0 < ds . length ( ) ) { \nNode root = page . getRoot ( ) ; \nnew Node . Declaration ( map . ss . toString ( ) , null , root ) ; \nnew Node . Declaration ( \"static {\\n\" + ds + \"}\\n\" , null , root ) ; \n} \n} \n} \n"}
{"7947": "public class LZMAEncoder { \npublic boolean encodeForLZMA2 ( ) { \ntry { \nif ( ! lz . isStarted ( ) && ! encodeInit ( ) ) return false ; \nwhile ( LZMA2_UNCOMPRESSED_LIMIT >= uncompressedSize && LZMA2_COMPRESSED_LIMIT >= rc . getPendingSize ( ) ) if ( ! encodeSymbol ( ) ) return false ; \n} \ncatch ( IOException e ) { \nthrow new Error ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"7957": "public class TagFileProcessor { \nprivate Class loadTagFile ( Compiler compiler , String tagFilePath , TagInfo tagInfo , PageInfo parentPageInfo ) throws JasperException { \nJspCompilationContext ctxt = compiler . getCompilationContext ( ) ; \nJspRuntimeContext rctxt = ctxt . getRuntimeContext ( ) ; \nsynchronized ( rctxt ) { \nJspServletWrapper wrapper = ( JspServletWrapper ) rctxt . getWrapper ( tagFilePath ) ; \nif ( wrapper == null ) { \nwrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; \nrctxt . addWrapper ( tagFilePath , wrapper ) ; \nwrapper . getJspEngineContext ( ) . setClassLoader ( ( URLClassLoader ) ctxt . getClassLoader ( ) ) ; \nwrapper . getJspEngineContext ( ) . setClassPath ( ctxt . getClassPath ( ) ) ; \n} \nelse { \nwrapper . getJspEngineContext ( ) . setTagInfo ( tagInfo ) ; \n} \nClass tagClazz ; \nint tripCount = wrapper . incTripCount ( ) ; \ntry { \nif ( 0 < tripCount ) { \nJspServletWrapper tempWrapper = new JspServletWrapper ( ctxt . getServletContext ( ) , ctxt . getOptions ( ) , tagFilePath , tagInfo , ctxt . getRuntimeContext ( ) , ( URL ) ctxt . getTagFileJarUrls ( ) . get ( tagFilePath ) ) ; \ntagClazz = tempWrapper . loadTagFilePrototype ( ) ; \ntempVector . add ( tempWrapper . getJspEngineContext ( ) . getCompiler ( ) ) ; \n} \nelse { \ntagClazz = wrapper . loadTagFile ( ) ; \n} \n} \nfinally { \nwrapper . decTripCount ( ) ; \n} \ntry { \nObject tagIns = tagClazz . newInstance ( ) ; \nif ( tagIns instanceof JspSourceDependent ) { \nfor ( String dependant : ( ( JspSourceDependent ) tagIns ) . getDependants ( ) ) { \nparentPageInfo . addDependant ( dependant ) ; \n} \n} \n} \ncatch ( Exception e ) { \n} \nreturn tagClazz ; \n} \n} \n} \n"}
{"7961": "public class JspC { \npublic void scanFiles ( File base ) throws JasperException { \nStack < String > dirs = new Stack < String > ( ) ; \ndirs . push ( base . toString ( ) ) ; \nif ( extensions == null ) { \nextensions = new ArrayList < String > ( ) ; \nextensions . add ( \"jsp\" ) ; \nextensions . add ( \"jspx\" ) ; \n} \nwhile ( ! dirs . isEmpty ( ) ) { \nString s = dirs . pop ( ) ; \nFile f = new File ( s ) ; \nif ( f . exists ( ) && f . isDirectory ( ) ) { \nString [ ] files = f . list ( ) ; \nString ext ; \nfor ( int i = 0 ; \n( files != null ) && files . length > i ; \ni ++ ) { \nFile f2 = new File ( s , files [ i ] ) ; \nif ( f2 . isDirectory ( ) ) { \ndirs . push ( f2 . getPath ( ) ) ; \n} \nelse { \nString path = f2 . getPath ( ) ; \nString uri = path . substring ( uriRoot . length ( ) ) ; \next = files [ i ] . substring ( files [ i ] . lastIndexOf ( '.' ) + 1 ) ; \nif ( extensions . contains ( ext ) || jspConfig . isJspPage ( uri ) ) { \npages . add ( path ) ; \n} \n} \n} \n} \n} \n} \n} \n"}
{"7965": "public class JspReader { \nboolean matches ( String string ) throws JasperException { \nMark mark = mark ( ) ; \nint ch = 0 ; \nint i = 0 ; \ndo { \nch = nextChar ( ) ; \nif ( ( ( char ) ch ) != string . charAt ( i ++ ) ) { \nreset ( mark ) ; \nreturn false ; \n} \n} \nwhile ( string . length ( ) > i ) ; \nreturn true ; \n} \n} \n"}
{"7967": "public class JspReader { \nMark skipUntil ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , ch = nextChar ( ) ) { \nif ( ch == limit . charAt ( 0 ) ) { \nMark restart = mark ( ) ; \nfor ( int i = 1 ; \nlimlen > i ; \ni ++ ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse { \nreset ( restart ) ; \ncontinue skip ; \n} \n} \nreturn ret ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7968": "public class JspReader { \nMark skipUntilIgnoreEsc ( String limit ) throws JasperException { \nMark ret = null ; \nint limlen = limit . length ( ) ; \nint ch ; \nint prev = 'x' ; \nskip : for ( ret = mark ( ) , ch = nextChar ( ) ; \nch != - 1 ; \nret = mark ( ) , prev = ch , ch = nextChar ( ) ) { \nif ( ch == '\\\\' && prev == '\\\\' ) { \nch = 0 ; \n} \nelse if ( ch == limit . charAt ( 0 ) && prev != '\\\\' ) { \nfor ( int i = 1 ; \nlimlen > i ; \ni ++ ) { \nif ( peekChar ( ) == limit . charAt ( i ) ) nextChar ( ) ; \nelse continue skip ; \n} \nreturn ret ; \n} \n} \nreturn null ; \n} \n} \n"}
{"7971": "public class JspReader { \nprivate boolean popFile ( ) throws JasperException { \nif ( current == null || 0 > currFileId ) { \nreturn false ; \n} \nString fName = getFile ( currFileId ) ; \ncurrFileId = unregisterSourceFile ( fName ) ; \nif ( - 1 > currFileId ) { \nerr . jspError ( \"jsp.error.file.not.registered\" , fName ) ; \n} \nMark previous = current . popStream ( ) ; \nif ( previous != null ) { \nmaster = current . baseDir ; \ncurrent = previous ; \nreturn true ; \n} \nreturn false ; \n} \n} \n"}
{"7975": "public class ParserUtils { \npublic static void setSchemaResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \nschemaResourcePrefix = uencode ( prefix ) ; \nisSchemaResourcePrefixFileUrl = true ; \n} \nelse { \nschemaResourcePrefix = prefix ; \nisSchemaResourcePrefixFileUrl = false ; \n} \nfor ( int i = 0 ; \nCACHED_SCHEMA_RESOURCE_PATHS . length > i ; \ni ++ ) { \nString path = DEFAULT_SCHEMA_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_SCHEMA_RESOURCE_PATHS [ i ] = schemaResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \n} \n} \n"}
{"7976": "public class ParserUtils { \npublic static void setDtdResourcePrefix ( String prefix ) { \nif ( prefix != null && prefix . startsWith ( \"file:\" ) ) { \ndtdResourcePrefix = uencode ( prefix ) ; \nisDtdResourcePrefixFileUrl = true ; \n} \nelse { \ndtdResourcePrefix = prefix ; \nisDtdResourcePrefixFileUrl = false ; \n} \nfor ( int i = 0 ; \nCACHED_DTD_RESOURCE_PATHS . length > i ; \ni ++ ) { \nString path = DEFAULT_DTD_RESOURCE_PATHS [ i ] ; \nint index = path . lastIndexOf ( '/' ) ; \nif ( index != - 1 ) { \nCACHED_DTD_RESOURCE_PATHS [ i ] = dtdResourcePrefix + path . substring ( index + 1 ) ; \n} \n} \n} \n} \n"}
{"7978": "public class ParserUtils { \nprotected TreeNode convert ( TreeNode parent , Node node ) { \nTreeNode treeNode = new TreeNode ( node . getNodeName ( ) , parent ) ; \nNamedNodeMap attributes = node . getAttributes ( ) ; \nif ( attributes != null ) { \nint n = attributes . getLength ( ) ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nNode attribute = attributes . item ( i ) ; \ntreeNode . addAttribute ( attribute . getNodeName ( ) , attribute . getNodeValue ( ) ) ; \n} \n} \nNodeList children = node . getChildNodes ( ) ; \nif ( children != null ) { \nint n = children . getLength ( ) ; \nfor ( int i = 0 ; \nn > i ; \ni ++ ) { \nNode child = children . item ( i ) ; \nif ( child instanceof Comment ) continue ; \nif ( child instanceof Text ) { \nString body = ( ( Text ) child ) . getData ( ) ; \nif ( body != null ) { \nbody = body . trim ( ) ; \nif ( 0 < body . length ( ) ) treeNode . setBody ( body ) ; \n} \n} \nelse { \nTreeNode treeChild = convert ( treeNode , child ) ; \n} \n} \n} \nreturn ( treeNode ) ; \n} \n} \n"}
{"7986": "public class AetherImporter { \npublic static AetherResult asResult ( final Collection < ArtifactResult > results , final ImportConfiguration cfg , final Optional < DependencyResult > dependencyResult ) { \nfinal AetherResult result = new AetherResult ( ) ; \nfinal Set < String > requested = new HashSet < > ( cfg . getCoordinates ( ) . size ( ) ) ; \nfor ( final MavenCoordinates mc : cfg . getCoordinates ( ) ) { \nrequested . add ( mc . toString ( ) ) ; \n} \nfinal Map < String , Boolean > optionalDeps = new HashMap < > ( ) ; \nfillOptionalDependenciesMap ( dependencyResult , optionalDeps ) ; \nfor ( final ArtifactResult ar : results ) { \nfinal AetherResult . Entry entry = new AetherResult . Entry ( ) ; \nfinal MavenCoordinates coordinates = MavenCoordinates . fromResult ( ar ) ; \nfinal String key = coordinates . toBase ( ) . toString ( ) ; \nentry . setCoordinates ( coordinates ) ; \nentry . setResolved ( ar . isResolved ( ) ) ; \nentry . setRequested ( requested . contains ( key ) ) ; \nentry . setOptional ( optionalDeps . getOrDefault ( key , Boolean . FALSE ) ) ; \nif ( ar . getExceptions ( ) != null && ! ar . getExceptions ( ) . isEmpty ( ) ) { \nfinal StringBuilder sb = new StringBuilder ( ar . getExceptions ( ) . get ( 0 ) . getMessage ( ) ) ; \nif ( 1 < ar . getExceptions ( ) . size ( ) ) { \nsb . append ( \" ...\" ) ; \n} \nentry . setError ( sb . toString ( ) ) ; \n} \nresult . getArtifacts ( ) . add ( entry ) ; \n} \nCollections . sort ( result . getArtifacts ( ) , Comparator . comparing ( AetherResult . Entry :: getCoordinates ) ) ; \nresult . setRepositoryUrl ( cfg . getRepositoryUrl ( ) ) ; \nreturn result ; \n} \n} \n"}
{"7996": "public class JspCServletContext { \npublic Set < String > getResourcePaths ( String path ) { \nSet < String > thePaths = new HashSet < String > ( ) ; \nif ( ! path . endsWith ( \"/\" ) ) path += \"/\" ; \nString basePath = getRealPath ( path ) ; \nif ( basePath == null ) return ( thePaths ) ; \nFile theBaseDir = new File ( basePath ) ; \nif ( ! theBaseDir . exists ( ) || ! theBaseDir . isDirectory ( ) ) return ( thePaths ) ; \nString theFiles [ ] = theBaseDir . list ( ) ; \nfor ( int i = 0 ; \ntheFiles . length > i ; \ni ++ ) { \nFile testFile = new File ( basePath + File . separator + theFiles [ i ] ) ; \nif ( testFile . isFile ( ) ) thePaths . add ( path + theFiles [ i ] ) ; \nelse if ( testFile . isDirectory ( ) ) thePaths . add ( path + theFiles [ i ] + \"/\" ) ; \n} \nreturn ( thePaths ) ; \n} \n} \n"}
{"8003": "public class LZEncoder { \npublic int fillWindow ( byte [ ] in , int off , int len ) { \nassert ! finishing ; \nif ( bufSize - keepSizeAfter <= readPos ) moveWindow ( ) ; \nif ( bufSize - writePos < len ) len = bufSize - writePos ; \nSystem . arraycopy ( in , off , buf , writePos , len ) ; \nwritePos += len ; \nif ( keepSizeAfter <= writePos ) readLimit = writePos - keepSizeAfter ; \nprocessPendingBytes ( ) ; \nreturn len ; \n} \n} \n"}
{"8004": "public class LZEncoder { \nprivate void processPendingBytes ( ) { \nif ( 0 < pendingSize && readLimit > readPos ) { \nreadPos -= pendingSize ; \nint oldPendingSize = pendingSize ; \npendingSize = 0 ; \nskip ( oldPendingSize ) ; \nassert oldPendingSize > pendingSize ; \n} \n} \n} \n"}
{"8005": "public class LZEncoder { \npublic int getMatchLen ( int dist , int lenLimit ) { \nint backPos = readPos - dist - 1 ; \nint len = 0 ; \nwhile ( lenLimit > len && buf [ readPos + len ] == buf [ backPos + len ] ) ++ len ; \nreturn len ; \n} \n} \n"}
{"8006": "public class LZEncoder { \npublic int getMatchLen ( int forward , int dist , int lenLimit ) { \nint curPos = readPos + forward ; \nint backPos = curPos - dist - 1 ; \nint len = 0 ; \nwhile ( lenLimit > len && buf [ curPos + len ] == buf [ backPos + len ] ) ++ len ; \nreturn len ; \n} \n} \n"}
{"8007": "public class LZEncoder { \npublic boolean verifyMatches ( Matches matches ) { \nint lenLimit = Math . min ( getAvail ( ) , matchLenMax ) ; \nfor ( int i = 0 ; \nmatches . count > i ; \n++ i ) if ( getMatchLen ( matches . dist [ i ] , lenLimit ) != matches . len [ i ] ) return false ; \nreturn true ; \n} \n} \n"}
{"8008": "public class LZEncoder { \nint movePos ( int requiredForFlushing , int requiredForFinishing ) { \nassert requiredForFinishing <= requiredForFlushing ; \n++ readPos ; \nint avail = writePos - readPos ; \nif ( requiredForFlushing > avail ) { \nif ( requiredForFinishing > avail || ! finishing ) { \n++ pendingSize ; \navail = 0 ; \n} \n} \nreturn avail ; \n} \n} \n"}
{"8015": "public class JspWriterImpl { \nprivate void allocateCharBuffer ( ) { \nif ( bufferSize == 0 ) return ; \nif ( MAX_BUFFER_SIZE < bufferSize ) { \nbuf = new CharBuffer ( new char [ bufferSize ] , 0 , bufferSize ) ; \n} \nelse { \nbuf = getCharBufferThreadLocalPool ( ) . allocate ( bufferSize ) ; \n} \n} \n} \n"}
{"8018": "public class Compiler { \nprivate void generateClass ( ) throws FileNotFoundException , JasperException , Exception { \nlong t1 = 0 ; \nif ( log . isLoggable ( Level . FINE ) ) { \nt1 = System . currentTimeMillis ( ) ; \n} \nString javaFileName = ctxt . getServletJavaFileName ( ) ; \nsetJavaCompilerOptions ( ) ; \nJavacErrorDetail [ ] javacErrors = javaCompiler . compile ( ctxt . getFullClassName ( ) , pageNodes ) ; \nif ( javacErrors != null ) { \njavaCompiler . doJavaFile ( true ) ; \nlog . severe ( \"Error compiling file: \" + javaFileName ) ; \nerrDispatcher . javacError ( javacErrors ) ; \n} \nif ( log . isLoggable ( Level . FINE ) ) { \nlong t2 = System . currentTimeMillis ( ) ; \nlog . fine ( \"Compiled \" + javaFileName + \" \" + ( t2 - t1 ) + \"ms\" ) ; \n} \njavaCompiler . doJavaFile ( ctxt . keepGenerated ( ) ) ; \nif ( ! ctxt . isPrototypeMode ( ) && ! options . isSmapSuppressed ( ) ) { \nsmapUtil . installSmap ( ) ; \n} \nif ( jsw != null && 0 >= jsw . getServletClassLastModifiedTime ( ) ) { \njsw . setServletClassLastModifiedTime ( javaCompiler . getClassLastModified ( ) ) ; \n} \nif ( options . getSaveBytecode ( ) ) { \njavaCompiler . saveClassFile ( ctxt . getFullClassName ( ) , ctxt . getClassFileName ( ) ) ; \n} \nctxt . getRuntimeContext ( ) . adjustBytecodeTime ( ctxt . getFullClassName ( ) , jspModTime ) ; \n} \n} \n"}
{"8021": "public class Compiler { \nprivate void initJavaCompiler ( ) throws JasperException { \nboolean disablejsr199 = Boolean . TRUE . toString ( ) . equals ( System . getProperty ( \"org.apache.jasper.compiler.disablejsr199\" ) ) ; \nDouble version = Double . valueOf ( System . getProperty ( \"java.specification.version\" ) ) ; \nif ( ! disablejsr199 && ( 1.6 <= version || getClassFor ( \"javax.tools.Tool\" ) != null ) ) { \njavaCompiler = new Jsr199JavaCompiler ( ) ; \n} \nelse { \nClass c = getClassFor ( \"org.eclipse.jdt.internal.compiler.Compiler\" ) ; \nif ( c != null ) { \nc = getClassFor ( \"org.apache.jasper.compiler.JDTJavaCompiler\" ) ; \nif ( c != null ) { \ntry { \njavaCompiler = ( JavaCompiler ) c . newInstance ( ) ; \n} \ncatch ( Exception ex ) { \n} \n} \n} \n} \nif ( javaCompiler == null ) { \nClass c = getClassFor ( \"org.apache.tools.ant.taskdefs.Javac\" ) ; \nif ( c != null ) { \nc = getClassFor ( \"org.apache.jasper.compiler.AntJavaCompiler\" ) ; \nif ( c != null ) { \ntry { \njavaCompiler = ( JavaCompiler ) c . newInstance ( ) ; \n} \ncatch ( Exception ex ) { \n} \n} \n} \n} \nif ( javaCompiler == null ) { \nerrDispatcher . jspError ( \"jsp.error.nojavac\" ) ; \n} \njavaCompiler . init ( ctxt , errDispatcher , jspcMode ) ; \n} \n} \n"}
{"8022": "public class Compiler { \nprivate boolean systemJarInWebinf ( String path ) { \nif ( 0 > path . indexOf ( \"/WEB-INF/\" ) ) { \nreturn false ; \n} \nBoolean useMyFaces = ( Boolean ) ctxt . getServletContext ( ) . getAttribute ( \"com.sun.faces.useMyFaces\" ) ; \nif ( useMyFaces == null || ! useMyFaces ) { \nfor ( String jar : systemJsfJars ) { \nif ( 0 < path . indexOf ( jar ) ) { \nreturn true ; \n} \n} \n} \nfor ( String jar : systemJars ) { \nif ( 0 < path . indexOf ( jar ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8025": "public class Generator { \nprivate void compileTagHandlerPoolList ( Node . Nodes page ) throws JasperException { \nclass TagHandlerPoolVisitor extends Node . Visitor { \nprivate Set < String > names = new HashSet < String > ( ) ; \nTagHandlerPoolVisitor ( Set < String > v ) { \nnames = v ; \n} \npublic void visit ( Node . CustomTag n ) throws JasperException { \nif ( ! n . implementsSimpleTag ( ) ) { \nString name = createTagHandlerPoolName ( n . getPrefix ( ) , n . getLocalName ( ) , n . getAttributes ( ) , n . hasEmptyBody ( ) ) ; \nn . setTagHandlerPoolName ( name ) ; \nif ( ! names . contains ( name ) ) { \nnames . add ( name ) ; \n} \n} \nvisitBody ( n ) ; \n} \nprivate String createTagHandlerPoolName ( String prefix , String shortName , Attributes attrs , boolean hasEmptyBody ) { \nString poolName = null ; \npoolName = \"_jspx_tagPool_\" + prefix + \"_\" + shortName ; \nif ( attrs != null ) { \nString [ ] attrNames = new String [ attrs . getLength ( ) ] ; \nfor ( int i = 0 ; \nattrNames . length > i ; \ni ++ ) { \nattrNames [ i ] = attrs . getQName ( i ) ; \n} \nArrays . sort ( attrNames , Collections . reverseOrder ( ) ) ; \nfor ( int i = 0 ; \nattrNames . length > i ; \ni ++ ) { \npoolName = poolName + \"_\" + attrNames [ i ] ; \n} \n} \nif ( hasEmptyBody ) { \npoolName = poolName + \"_nobody\" ; \n} \nreturn JspUtil . makeXmlJavaIdentifier ( poolName ) ; \n} \n} \npage . visit ( new TagHandlerPoolVisitor ( tagHandlerPoolNames ) ) ; \n} \n} \n"}
{"8027": "public class Generator { \nprivate void genCommonPostamble ( ) { \nfor ( int i = 0 ; \nmethodsBuffered . size ( ) > i ; \ni ++ ) { \nGenBuffer methodBuffer = methodsBuffered . get ( i ) ; \nmethodBuffer . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( methodBuffer . toString ( ) ) ; \n} \nif ( fragmentHelperClass . isUsed ( ) ) { \nfragmentHelperClass . generatePostamble ( ) ; \nfragmentHelperClass . adjustJavaLines ( out . getJavaLine ( ) - 1 ) ; \nout . printMultiLn ( fragmentHelperClass . toString ( ) ) ; \n} \nif ( arrayBuffer != null ) { \nout . printMultiLn ( arrayBuffer . toString ( ) ) ; \n} \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \n} \n} \n"}
{"8030": "public class Generator { \nprivate void generateTagHandlerAttributes ( TagInfo tagInfo ) throws JasperException { \nif ( tagInfo . hasDynamicAttributes ( ) ) { \nout . printil ( \"private java.util.HashMap _jspx_dynamic_attrs = new java.util.HashMap();\" ) ; \n} \nTagAttributeInfo [ ] attrInfos = tagInfo . getAttributes ( ) ; \nfor ( int i = 0 ; \nattrInfos . length > i ; \ni ++ ) { \nout . printin ( \"private \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \n} \nout . println ( ) ; \nfor ( int i = 0 ; \nattrInfos . length > i ; \ni ++ ) { \nout . printin ( \"public \" ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( toGetterMethod ( attrInfos [ i ] . getName ( ) ) ) ; \nout . println ( \" {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"return this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \nout . printin ( \"public void \" ) ; \nout . print ( toSetterMethodName ( attrInfos [ i ] . getName ( ) ) ) ; \nif ( attrInfos [ i ] . isFragment ( ) ) { \nout . print ( \"(javax.servlet.jsp.tagext.JspFragment \" ) ; \n} \nelse { \nout . print ( \"(\" ) ; \nout . print ( JspUtil . toJavaSourceType ( attrInfos [ i ] . getTypeName ( ) ) ) ; \nout . print ( \" \" ) ; \n} \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \") {\" ) ; \nout . pushIndent ( ) ; \nout . printin ( \"this.\" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . print ( \" = \" ) ; \nout . print ( attrInfos [ i ] . getName ( ) ) ; \nout . println ( \";\" ) ; \nout . popIndent ( ) ; \nout . printil ( \"}\" ) ; \nout . println ( ) ; \n} \n} \n} \n"}
{"8033": "public class Validator { \nprivate static void validateXmlView ( PageData xmlView , Compiler compiler ) throws JasperException { \nStringBuilder errMsg = null ; \nErrorDispatcher errDisp = compiler . getErrorDispatcher ( ) ; \nfor ( Iterator < TagLibraryInfo > iter = compiler . getPageInfo ( ) . getTaglibs ( ) . iterator ( ) ; \niter . hasNext ( ) ; \n) { \nTagLibraryInfo o = iter . next ( ) ; \nif ( ! ( o instanceof TagLibraryInfoImpl ) ) continue ; \nTagLibraryInfoImpl tli = ( TagLibraryInfoImpl ) o ; \nValidationMessage [ ] errors = tli . validate ( xmlView ) ; \nif ( ( errors != null ) && ( errors . length != 0 ) ) { \nif ( errMsg == null ) { \nerrMsg = new StringBuilder ( ) ; \n} \nerrMsg . append ( \"<h3>\" ) ; \nerrMsg . append ( Localizer . getMessage ( \"jsp.error.tlv.invalid.page\" , tli . getShortName ( ) ) ) ; \nerrMsg . append ( \"</h3>\" ) ; \nfor ( int i = 0 ; \nerrors . length > i ; \ni ++ ) { \nif ( errors [ i ] != null ) { \nerrMsg . append ( \"<p>\" ) ; \nerrMsg . append ( errors [ i ] . getId ( ) ) ; \nerrMsg . append ( \": \" ) ; \nerrMsg . append ( errors [ i ] . getMessage ( ) ) ; \nerrMsg . append ( \"</p>\" ) ; \n} \n} \n} \n} \nif ( errMsg != null ) { \nerrDisp . jspError ( errMsg . toString ( ) ) ; \n} \n} \n} \n"}
{"8034": "public class TagHandlerPool { \npublic < T extends JspTag > JspTag get ( Class < T > handlerClass ) throws JspException { \nsynchronized ( this ) { \nif ( 0 <= current ) { \nreturn handlers [ current -- ] ; \n} \n} \nJspTag tagHandler = null ; \ntry { \nif ( resourceInjector != null ) { \ntagHandler = resourceInjector . createTagHandlerInstance ( handlerClass ) ; \n} \nelse { \ntagHandler = handlerClass . newInstance ( ) ; \n} \n} \ncatch ( Exception e ) { \nthrow new JspException ( e . getMessage ( ) , e ) ; \n} \nreturn tagHandler ; \n} \n} \n"}
{"8035": "public class ELParser { \npublic static ELNode . Nodes parse ( String expression ) { \nELParser parser = new ELParser ( expression ) ; \nwhile ( parser . hasNextChar ( ) ) { \nString text = parser . skipUntilEL ( ) ; \nif ( 0 < text . length ( ) ) { \nparser . expr . add ( new ELNode . Text ( text ) ) ; \n} \nELNode . Nodes elexpr = parser . parseEL ( ) ; \nif ( ! elexpr . isEmpty ( ) ) { \nparser . expr . add ( new ELNode . Root ( elexpr , parser . isDollarExpr ) ) ; \n} \n} \nreturn parser . expr ; \n} \n} \n"}
{"8036": "public class JspConfig { \nprivate JspPropertyGroup selectProperty ( JspPropertyGroup prev , JspPropertyGroup curr ) { \nif ( prev == null ) { \nreturn curr ; \n} \nif ( prev . getExtension ( ) == null ) { \nreturn prev ; \n} \nif ( curr . getExtension ( ) == null ) { \nreturn curr ; \n} \nString prevPath = prev . getPath ( ) ; \nString currPath = curr . getPath ( ) ; \nif ( prevPath == null && currPath == null ) { \nreturn prev ; \n} \nif ( prevPath == null && currPath != null ) { \nreturn curr ; \n} \nif ( prevPath != null && currPath == null ) { \nreturn prev ; \n} \nif ( currPath . length ( ) <= prevPath . length ( ) ) { \nreturn prev ; \n} \nreturn curr ; \n} \n} \n"}
{"8037": "public class JspConfig { \npublic boolean isJspPage ( String uri ) throws JasperException { \ninit ( ) ; \nif ( jspProperties == null ) { \nreturn false ; \n} \nString uriPath = null ; \nint index = uri . lastIndexOf ( '/' ) ; \nif ( 0 <= index ) { \nuriPath = uri . substring ( 0 , index + 1 ) ; \n} \nString uriExtension = null ; \nindex = uri . lastIndexOf ( '.' ) ; \nif ( 0 <= index ) { \nuriExtension = uri . substring ( index + 1 ) ; \n} \nfor ( JspPropertyGroup jpg : jspProperties ) { \nJspProperty jp = jpg . getJspProperty ( ) ; \nString extension = jpg . getExtension ( ) ; \nString path = jpg . getPath ( ) ; \nif ( extension == null ) { \nif ( uri . equals ( path ) ) { \nreturn true ; \n} \n} \nelse { \nif ( ( path == null || path . equals ( uriPath ) ) && ( extension . equals ( \"*\" ) || extension . equals ( uriExtension ) ) ) { \nreturn true ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"8038": "public class ServletWriter { \npublic void printComment ( Mark start , Mark stop , char [ ] chars ) { \nif ( start != null && stop != null ) { \nprintln ( \"// from=\" + start ) ; \nprintln ( \"//   to=\" + stop ) ; \n} \nif ( chars != null ) for ( int i = 0 ; \nchars . length > i ; \n) { \nprintin ( ) ; \nprint ( \"// \" ) ; \nwhile ( chars [ i ] != '\\n' && chars . length > i ) writer . print ( chars [ i ++ ] ) ; \n} \n} \n} \n"}
{"8041": "public class ServletWriter { \npublic void printMultiLn ( String s ) { \nint index = 0 ; \nwhile ( - 1 < ( index = s . indexOf ( '\\n' , index ) ) ) { \njavaLine ++ ; \nindex ++ ; \n} \nwriter . print ( s ) ; \n} \n} \n"}
{"8044": "public class JspUtil { \npublic static String escapeXml ( String s ) { \nif ( s == null ) return null ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \ns . length ( ) > i ; \ni ++ ) { \nchar c = s . charAt ( i ) ; \nif ( c == '<' ) { \nsb . append ( \"&lt;\" ) ; \n} \nelse if ( c == '>' ) { \nsb . append ( \"&gt;\" ) ; \n} \nelse if ( c == '\\'' ) { \nsb . append ( \"&apos;\" ) ; \n} \nelse if ( c == '&' ) { \nsb . append ( \"&amp;\" ) ; \n} \nelse if ( c == '\"' ) { \nsb . append ( \"&quot;\" ) ; \n} \nelse { \nsb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8047": "public class JspUtil { \npublic static final String makeJavaPackage ( String path ) { \nString classNameComponents [ ] = split ( path , \"/\" ) ; \nStringBuilder legalClassNames = new StringBuilder ( ) ; \nfor ( int i = 0 ; \nclassNameComponents . length > i ; \ni ++ ) { \nlegalClassNames . append ( makeJavaIdentifier ( classNameComponents [ i ] ) ) ; \nif ( classNameComponents . length - 1 > i ) { \nlegalClassNames . append ( '.' ) ; \n} \n} \nreturn legalClassNames . toString ( ) ; \n} \n} \n"}
{"8048": "public class JspUtil { \nprivate static final String [ ] split ( String path , String pat ) { \nArrayList < String > comps = new ArrayList < String > ( ) ; \nint pos = path . indexOf ( pat ) ; \nint start = 0 ; \nwhile ( 0 <= pos ) { \nif ( start < pos ) { \nString comp = path . substring ( start , pos ) ; \ncomps . add ( comp ) ; \n} \nstart = pos + pat . length ( ) ; \npos = path . indexOf ( pat , start ) ; \n} \nif ( path . length ( ) > start ) { \ncomps . add ( path . substring ( start ) ) ; \n} \nString [ ] result = new String [ comps . size ( ) ] ; \nfor ( int i = 0 ; \ncomps . size ( ) > i ; \ni ++ ) { \nresult [ i ] = comps . get ( i ) ; \n} \nreturn result ; \n} \n} \n"}
{"8049": "public class JspUtil { \npublic static final String makeJavaIdentifier ( String identifier ) { \nStringBuilder modifiedIdentifier = new StringBuilder ( identifier . length ( ) ) ; \nif ( ! Character . isJavaIdentifierStart ( identifier . charAt ( 0 ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nfor ( int i = 0 ; \nidentifier . length ( ) > i ; \ni ++ ) { \nchar ch = identifier . charAt ( i ) ; \nif ( Character . isJavaIdentifierPart ( ch ) && ch != '_' ) { \nmodifiedIdentifier . append ( ch ) ; \n} \nelse if ( ch == '.' ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nelse { \nmodifiedIdentifier . append ( mangleChar ( ch ) ) ; \n} \n} \nif ( isJavaKeyword ( modifiedIdentifier . toString ( ) ) ) { \nmodifiedIdentifier . append ( '_' ) ; \n} \nreturn modifiedIdentifier . toString ( ) ; \n} \n} \n"}
{"8051": "public class JspUtil { \npublic static boolean isJavaKeyword ( String key ) { \nint i = 0 ; \nint j = javaKeywords . length ; \nwhile ( j > i ) { \nint k = ( i + j ) / 2 ; \nint result = javaKeywords [ k ] . compareTo ( key ) ; \nif ( result == 0 ) { \nreturn true ; \n} \nif ( 0 > result ) { \ni = k + 1 ; \n} \nelse { \nj = k ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8056": "public class FileNames { \npublic static String getBasename ( final String name ) { \nif ( name == null ) { \nreturn null ; \n} \nfinal String [ ] toks = name . split ( \"/\" ) ; \nif ( 1 > toks . length ) { \nreturn name ; \n} \nreturn toks [ toks . length - 1 ] ; \n} \n} \n"}
{"8083": "public class ConfigTtlProvider { \nprivate boolean put ( ImmutableTable . Builder < Granularity , RollupType , TimeValue > ttlMapBuilder , Configuration config , Granularity gran , RollupType rollupType , TtlConfig configKey ) { \nint value ; \ntry { \nvalue = config . getIntegerProperty ( configKey ) ; \nif ( 0 > value ) return false ; \n} \ncatch ( NumberFormatException ex ) { \nlog . trace ( String . format ( \"No valid TTL config set for granularity: %s, rollup type: %s\" , gran . name ( ) , rollupType . name ( ) ) , ex ) ; \nreturn false ; \n} \nttlMapBuilder . put ( gran , rollupType , new TimeValue ( value , TimeUnit . DAYS ) ) ; \nreturn true ; \n} \n} \n"}
{"8084": "public class OutputFormatter { \npublic static int [ ] computeMaximums ( String [ ] headers , OutputFormatter ... outputs ) { \nint [ ] max = new int [ headers . length ] ; \nfor ( int i = 0 ; \nheaders . length > i ; \ni ++ ) max [ i ] = headers [ i ] . length ( ) ; \nfor ( OutputFormatter output : outputs ) { \nmax [ 0 ] = Math . max ( output . host . length ( ) , max [ 0 ] ) ; \nfor ( int i = 1 ; \nheaders . length > i ; \ni ++ ) max [ i ] = Math . max ( output . results [ i - 1 ] . length ( ) , max [ i ] ) ; \n} \nreturn max ; \n} \n} \n"}
{"8085": "public class OutputFormatter { \npublic static String formatHeader ( int [ ] maximums , String [ ] headers ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \nheaders . length > i ; \ni ++ ) sb = sb . append ( formatIn ( headers [ i ] , maximums [ i ] , false ) ) . append ( GAP ) ; \nreturn sb . toString ( ) ; \n} \n} \n"}
{"8086": "public class OutputFormatter { \npublic static String [ ] format ( int [ ] maximums , OutputFormatter ... outputs ) { \nString [ ] formattedStrings = new String [ outputs . length ] ; \nint pos = 0 ; \nfor ( OutputFormatter output : outputs ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb = sb . append ( formatIn ( output . host , maximums [ 0 ] , false ) ) ; \nfor ( int i = 0 ; \noutput . results . length > i ; \ni ++ ) sb = sb . append ( GAP ) . append ( formatIn ( output . results [ i ] , maximums [ i + 1 ] , true ) ) ; \nformattedStrings [ pos ++ ] = sb . toString ( ) ; \n} \nreturn formattedStrings ; \n} \n} \n"}
{"8088": "public class ThreadPoolBuilder { \npublic ThreadPoolBuilder withName ( String name ) { \nif ( ! name . contains ( \"%d\" ) ) { \nname = name + \"-%d\" ; \n} \nnameMap . putIfAbsent ( name , new AtomicInteger ( 0 ) ) ; \nint id = nameMap . get ( name ) . incrementAndGet ( ) ; \nthis . poolName = String . format ( name , id ) ; \nif ( 1 < id ) { \nthis . threadNameFormat = name . replace ( \"%d\" , id + \"-%d\" ) ; \n} \nelse { \nthis . threadNameFormat = name ; \n} \nreturn this ; \n} \n} \n"}
{"8089": "public class MetricIndexData { \npublic void add ( String metricIndex , long docCount ) { \nfinal String [ ] tokens = metricIndex . split ( METRIC_TOKEN_SEPARATOR_REGEX ) ; \nswitch ( tokens . length - baseLevel ) { \ncase 1 : if ( 0 < baseLevel ) { \nmetricNamesWithNextLevelSet . add ( metricIndex . substring ( 0 , metricIndex . lastIndexOf ( \".\" ) ) ) ; \n} \nelse { \nmetricNamesWithNextLevelSet . add ( metricIndex . substring ( 0 , metricIndex . indexOf ( \".\" ) ) ) ; \n} \naddChildrenDocCount ( metricNameBaseLevelMap , metricIndex . substring ( 0 , metricIndex . lastIndexOf ( \".\" ) ) , docCount ) ; \nbreak ; \ncase 0 : setActualDocCount ( metricNameBaseLevelMap , metricIndex , docCount ) ; \nbreak ; \ndefault : break ; \n} \n} \n} \n"}
{"8090": "public class MetricIndexData { \nprivate Set < String > getCompleteMetricNames ( Map < String , MetricIndexDocCount > metricIndexMap ) { \nSet < String > completeMetricNames = new HashSet < String > ( ) ; \nfor ( Map . Entry < String , MetricIndexDocCount > entry : metricIndexMap . entrySet ( ) ) { \nMetricIndexDocCount metricIndexDocCount = entry . getValue ( ) ; \nif ( metricIndexDocCount != null ) { \nif ( 0 < metricIndexDocCount . actualDocCount && metricIndexDocCount . childrenTotalDocCount < metricIndexDocCount . actualDocCount ) { \ncompleteMetricNames . add ( entry . getKey ( ) ) ; \n} \n} \n} \nreturn Collections . unmodifiableSet ( completeMetricNames ) ; \n} \n} \n"}
{"8093": "public class Granularity { \npublic static Granularity granularityFromPointsInInterval ( String tenantid , long from , long to , int points , String algorithm , long assumedIntervalMillis , Clock ttlComparisonClock ) { \nif ( to <= from ) { \nthrow new RuntimeException ( \"Invalid interval specified for fromPointsInInterval\" ) ; \n} \ndouble requestedDuration = to - from ; \nif ( algorithm . startsWith ( \"GEOMETRIC\" ) ) return granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; \nelse if ( algorithm . startsWith ( \"LINEAR\" ) ) return granularityFromPointsLinear ( requestedDuration , points , assumedIntervalMillis ) ; \nelse if ( algorithm . startsWith ( \"LESSTHANEQUAL\" ) ) return granularityFromPointsLessThanEqual ( requestedDuration , points , assumedIntervalMillis ) ; \nreturn granularityFromPointsGeometric ( tenantid , from , to , requestedDuration , points , assumedIntervalMillis , ttlComparisonClock ) ; \n} \n} \n"}
{"8094": "public class Granularity { \nprivate static Granularity granularityFromPointsLessThanEqual ( double requestedDuration , int points , long assumedIntervalMillis ) { \nGranularity gran = granularityFromPointsLinear ( requestedDuration , points , assumedIntervalMillis ) ; \nif ( points < requestedDuration / gran . milliseconds ( ) ) { \ntry { \ngran = gran . coarser ( ) ; \n} \ncatch ( GranularityException e ) { \n} \n} \nreturn gran ; \n} \n} \n"}
{"8098": "public class CassandraModel { \npublic static Iterable < MetricColumnFamily > getMetricColumnFamilies ( ) { \nreturn new Iterable < MetricColumnFamily > ( ) { \n@ Override public Iterator < MetricColumnFamily > iterator ( ) { \nreturn new Iterator < MetricColumnFamily > ( ) { \nprivate int pos = 0 ; \n@ Override public boolean hasNext ( ) { \nreturn METRIC_COLUMN_FAMILES . length > pos ; \n} \n@ Override public MetricColumnFamily next ( ) { \nreturn METRIC_COLUMN_FAMILES [ pos ++ ] ; \n} \n@ Override public void remove ( ) { \nthrow new NoSuchMethodError ( \"Not implemented\" ) ; \n} \n} \n; \n} \n} \n; \n} \n} \n"}
{"8111": "public class Range { \npublic static Map < Range , Iterable < Range > > mapFinerRanges ( Granularity g , Range range ) throws GranularityException { \nif ( range . getStop ( ) <= range . getStart ( ) ) throw new IllegalArgumentException ( \"start cannot be greater than end. Start: \" + range . getStart ( ) + \" Stop:\" + range . getStop ( ) ) ; \nfinal long snappedStartMillis = g . snapMillis ( range . getStart ( ) ) ; \nfinal long snappedStopMillis = g . snapMillis ( range . getStop ( ) + g . milliseconds ( ) ) ; \nHashMap < Range , Iterable < Range > > rangeMap = new HashMap < Range , Iterable < Range > > ( ) ; \nlong tempStartMillis = snappedStartMillis ; \nint numberOfMillis = g . milliseconds ( ) ; \nwhile ( ( snappedStopMillis - numberOfMillis ) >= tempStartMillis ) { \nRange slotRange = new Range ( tempStartMillis , tempStartMillis + numberOfMillis ) ; \nrangeMap . put ( slotRange , new IntervalRangeIterator ( g . finer ( ) , slotRange . start , slotRange . stop ) ) ; \ntempStartMillis = tempStartMillis + numberOfMillis ; \n} \nreturn rangeMap ; \n} \n} \n"}
{"8115": "public class DAbstractMetricsRW { \nprotected boolean isDelayed ( IMetric metric ) { \nlong delay = clock . now ( ) . getMillis ( ) - metric . getCollectionTime ( ) ; \nreturn MAX_AGE_ALLOWED < delay ; \n} \n} \n"}
{"8122": "public class AggregatedPayload { \n@ AssertTrue ( message = \"At least one of the aggregated metrics(gauges, counters, timers, sets) are expected\" ) private boolean isValid ( ) { \nboolean isGaugePresent = gauges != null && 0 < gauges . length ; \nboolean isCounterPresent = counters != null && 0 < counters . length ; \nboolean isTimerPresent = timers != null && 0 < timers . length ; \nboolean isSetPresent = sets != null && 0 < sets . length ; \nreturn ( isGaugePresent || isCounterPresent || isTimerPresent || isSetPresent ) ; \n} \n} \n"}
{"8123": "public class DownloadService { \nprivate void doCheck ( ) { \nif ( ! running ) return ; \nif ( fileManager == null ) return ; \nif ( MAX_UNEXPECTED_ERRORS < unexpectedErrors ) { \nlog . info ( \"Terminating because of errors\" ) ; \nterminate ( false ) ; \nreturn ; \n} \nTimer . Context waitTimerContext = waitingTimer . time ( ) ; \nwhile ( downloadDir . listFiles ( ) . length != 0 ) { \nlog . debug ( \"Waiting for files in download directory to clear up. Sleeping for 1 min. If you see this persistently, it means the downloaded files are not getting merged properly/timely\" ) ; \ntry { \nThread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \n} \n} \nwaitTimerContext . stop ( ) ; \nif ( downloadLock . tryLock ( ) ) { \ntry { \nif ( fileManager . hasNewFiles ( ) ) { \nfileManager . downloadNewFiles ( downloadDir ) ; \n} \n} \ncatch ( Throwable unexpected ) { \nunexpectedErrors += 1 ; \nlog . error ( \"UNEXPECTED; WILL TRY TO RECOVER\" ) ; \nlog . error ( unexpected . getMessage ( ) , unexpected ) ; \nif ( Thread . interrupted ( ) ) { \ntry { \nthread . sleep ( 60000 ) ; \n} \ncatch ( Exception ex ) { \nlog . error ( ex . getMessage ( ) , ex ) ; \n} \n} \n} \nfinally { \ndownloadLock . unlock ( ) ; \n} \n} \nelse { \nlog . debug ( \"Download in progress\" ) ; \n} \n} \n} \n"}
{"8163": "public class NumberUtils { \npublic static boolean isNumeric ( String value , Locale locale ) { \nif ( value == null ) return false ; \nint start = 0 ; \nfinal DecimalFormatSymbols symbols = ( locale != null ) ? DecimalFormatSymbols . getInstance ( locale ) : DecimalFormatSymbols . getInstance ( ) ; \nif ( value . startsWith ( \"+\" ) || value . startsWith ( \"-\" ) ) start ++ ; \nboolean fraction = false ; \nfor ( int i = start ; \nvalue . length ( ) > i ; \ni ++ ) { \nfinal char c = value . charAt ( i ) ; \nif ( c == symbols . getDecimalSeparator ( ) && ! fraction ) { \nfraction = true ; \ncontinue ; \n} \nif ( c == symbols . getGroupingSeparator ( ) && ! fraction ) { \ncontinue ; \n} \nif ( ! Character . isDigit ( c ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"8204": "public class XmlValidationHandler { \n@ Override public boolean handleEvent ( ValidationEvent event ) { \nif ( event == null ) throw new IllegalArgumentException ( \"No validation event was provided!\" ) ; \nint line = - 1 ; \nint col = - 1 ; \nif ( event . getLocator ( ) != null ) { \nline = event . getLocator ( ) . getLineNumber ( ) ; \ncol = event . getLocator ( ) . getColumnNumber ( ) ; \n} \nif ( ValidationEvent . FATAL_ERROR == event . getSeverity ( ) ) { \nLOGGER . warn ( \"fatal validation error\" ) ; \nif ( - 1 < line && - 1 < col ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \nreturn false ; \n} \nif ( ValidationEvent . WARNING == event . getSeverity ( ) ) { \nLOGGER . warn ( \"validation warning\" ) ; \nif ( - 1 < line && - 1 < col ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \nelse { \nLOGGER . warn ( \"validation error\" ) ; \nif ( - 1 < line && - 1 < col ) LOGGER . warn ( \"> at line \" + line + \" / column \" + col ) ; \nLOGGER . warn ( \"> \" + event . getMessage ( ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"8205": "public class CsvRecord { \npublic void dump ( Writer writer , String lineSeparator ) throws IOException { \nfor ( int i = 0 ; \nthis . getRecordLenth ( ) > i ; \ni ++ ) { \nStringBuilder txt = new StringBuilder ( ) ; \ntry ( StringReader reader = new StringReader ( StringUtils . trimToEmpty ( this . get ( i ) ) ) ) { \nfor ( String line : IOUtils . readLines ( reader ) ) { \nif ( 0 < txt . length ( ) ) txt . append ( lineSeparator ) ; \ntxt . append ( line ) ; \n} \n} \nwriter . write ( i + \":\" + txt . toString ( ) ) ; \nwriter . write ( System . lineSeparator ( ) ) ; \n} \n} \n} \n"}
{"8207": "public class CsvRecord { \nprotected Iterable < String > print ( ) { \nfinal int length = this . getRecordLenth ( ) ; \nList < String > row = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nrow . add ( this . get ( i ) ) ; \n} \nreturn row ; \n} \n} \n"}
{"8349": "public class ObjectUtils { \npublic static boolean isCompatibleWithThrowsClause ( Throwable ex , Class < ? > [ ] declaredExceptions ) { \nif ( ! isCheckedException ( ex ) ) { \nreturn true ; \n} \nif ( declaredExceptions != null ) { \nint i = 0 ; \nwhile ( declaredExceptions . length > i ) { \nif ( declaredExceptions [ i ] . isAssignableFrom ( ex . getClass ( ) ) ) { \nreturn true ; \n} \ni ++ ; \n} \n} \nreturn false ; \n} \n} \n"}
{"8353": "public class XmlValidationModeDetector { \nprivate boolean hasOpeningTag ( String content ) { \nif ( this . inComment ) { \nreturn false ; \n} \nint openTagIndex = content . indexOf ( '<' ) ; \nreturn ( - 1 < openTagIndex && openTagIndex < content . length ( ) && Character . isLetter ( content . charAt ( openTagIndex + 1 ) ) ) ; \n} \n} \n"}
{"8356": "public class XmlValidationModeDetector { \nprivate int commentToken ( String line , String token , boolean inCommentIfPresent ) { \nint index = line . indexOf ( token ) ; \nif ( - 1 < index ) { \nthis . inComment = inCommentIfPresent ; \n} \nreturn ( index == - 1 ? index : index + token . length ( ) ) ; \n} \n} \n"}
{"8366": "public class CmdLineParser { \npublic final void parse ( String [ ] argv , Locale locale ) throws IllegalOptionValueException , UnknownOptionException { \nVector otherArgs = new Vector ( ) ; \nint position = 0 ; \nthis . values = new Hashtable ( 10 ) ; \nwhile ( argv . length > position ) { \nString curArg = argv [ position ] ; \nif ( curArg . startsWith ( \"-\" ) ) { \nif ( curArg . equals ( \"--\" ) ) { \nposition += 1 ; \nbreak ; \n} \nString valueArg = null ; \nif ( curArg . startsWith ( \"--\" ) ) { \nint equalsPos = curArg . indexOf ( \"=\" ) ; \nif ( equalsPos != - 1 ) { \nvalueArg = curArg . substring ( equalsPos + 1 ) ; \ncurArg = curArg . substring ( 0 , equalsPos ) ; \n} \n} \nelse if ( 2 < curArg . length ( ) ) { \nfor ( int i = 1 ; \ncurArg . length ( ) > i ; \ni ++ ) { \nOption opt = ( Option ) this . options . get ( \"-\" + curArg . charAt ( i ) ) ; \nif ( opt == null ) throw new UnknownSuboptionException ( curArg , curArg . charAt ( i ) ) ; \nif ( opt . wantsValue ( ) ) throw new NotFlagException ( curArg , curArg . charAt ( i ) ) ; \naddValue ( opt , opt . getValue ( null , locale ) ) ; \n} \nposition ++ ; \ncontinue ; \n} \nOption opt = ( Option ) this . options . get ( curArg ) ; \nif ( opt == null ) { \nthrow new UnknownOptionException ( curArg ) ; \n} \nObject value = null ; \nif ( opt . wantsValue ( ) ) { \nif ( valueArg == null ) { \nposition += 1 ; \nif ( argv . length > position ) { \nvalueArg = argv [ position ] ; \n} \n} \nvalue = opt . getValue ( valueArg , locale ) ; \n} \nelse { \nvalue = opt . getValue ( null , locale ) ; \n} \naddValue ( opt , value ) ; \nposition += 1 ; \n} \nelse { \notherArgs . addElement ( curArg ) ; \nposition += 1 ; \n} \n} \nfor ( ; \nargv . length > position ; \n++ position ) { \notherArgs . addElement ( argv [ position ] ) ; \n} \nthis . remainingArgs = new String [ otherArgs . size ( ) ] ; \notherArgs . copyInto ( remainingArgs ) ; \n} \n} \n"}
{"8367": "public class SingletonLoader { \npublic Object newInstance ( Class c ) throws InstantiationException , IllegalAccessException { \nObject ret = null ; \nMethod [ ] methods = c . getDeclaredMethods ( ) ; \nMethod m ; \nint modifiers ; \nfor ( int i = 0 ; \nmethods . length > i ; \ni ++ ) { \nm = methods [ i ] ; \nmodifiers = m . getModifiers ( ) ; \nif ( ( modifiers & Modifier . STATIC ) != 0 ) { \nif ( ( modifiers & Modifier . PUBLIC ) != 0 ) { \nif ( m . getParameterTypes ( ) . length == 0 ) { \nif ( m . getReturnType ( ) == c ) { \nif ( m . getName ( ) . toLowerCase ( ) . indexOf ( \"instance\" ) != - 1 ) { \ntry { \nret = m . invoke ( null , dummyParameters ) ; \n} \ncatch ( IllegalArgumentException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( IllegalAccessException e ) { \ne . printStackTrace ( ) ; \n} \ncatch ( InvocationTargetException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n} \n} \n} \n} \nif ( ret == null ) { \nConstructor [ ] constructors = c . getConstructors ( ) ; \nConstructor con = null ; \nfor ( int i = 0 ; \nconstructors . length > i ; \ni ++ ) { \ncon = constructors [ i ] ; \nif ( con . getParameterTypes ( ) . length == 0 ) { \nmodifiers = con . getModifiers ( ) ; \ntry { \nif ( ( modifiers & Modifier . PUBLIC ) == 0 ) { \ncon . setAccessible ( true ) ; \n} \nret = c . newInstance ( ) ; \n} \ncatch ( SecurityException se ) { \n} \n} \n} \n} \nif ( ret == null ) { \nSystem . err . println ( \"Unable to instantiate: \" + c . getName ( ) + \": no singleton method, no public default constructor.\" ) ; \n} \nreturn ret ; \n} \n} \n"}
{"8368": "public class ConcurrencyThrottleSupport { \nprotected void afterAccess ( ) { \nif ( 0 <= this . concurrencyLimit ) { \nsynchronized ( this . monitor ) { \nthis . concurrencyCount -- ; \nif ( logger . isDebugEnabled ( ) ) { \nlogger . debug ( \"Returning from throttle at concurrency count \" + this . concurrencyCount ) ; \n} \nthis . monitor . notify ( ) ; \n} \n} \n} \n} \n"}
{"8370": "public class MethodInvoker { \npublic void prepare ( ) throws ClassNotFoundException , NoSuchMethodException { \nif ( this . staticMethod != null ) { \nint lastDotIndex = this . staticMethod . lastIndexOf ( '.' ) ; \nif ( lastDotIndex == - 1 || lastDotIndex == this . staticMethod . length ( ) ) { \nthrow new IllegalArgumentException ( \"staticMethod must be a fully qualified class plus method name: \" + \"e.g. 'example.MyExampleClass.myExampleMethod'\" ) ; \n} \nString className = this . staticMethod . substring ( 0 , lastDotIndex ) ; \nString methodName = this . staticMethod . substring ( lastDotIndex + 1 ) ; \nthis . targetClass = resolveClassName ( className ) ; \nthis . targetMethod = methodName ; \n} \nClass < ? > targetClass = getTargetClass ( ) ; \nString targetMethod = getTargetMethod ( ) ; \nif ( targetClass == null ) { \nthrow new IllegalArgumentException ( \"Either 'targetClass' or 'targetObject' is required\" ) ; \n} \nif ( targetMethod == null ) { \nthrow new IllegalArgumentException ( \"Property 'targetMethod' is required\" ) ; \n} \nObject [ ] arguments = getArguments ( ) ; \nClass < ? > [ ] argTypes = new Class < ? > [ arguments . length ] ; \nfor ( int i = 0 ; \narguments . length > i ; \n++ i ) { \nargTypes [ i ] = ( arguments [ i ] != null ? arguments [ i ] . getClass ( ) : Object . class ) ; \n} \ntry { \nthis . methodObject = targetClass . getMethod ( targetMethod , argTypes ) ; \n} \ncatch ( NoSuchMethodException ex ) { \nthis . methodObject = findMatchingMethod ( ) ; \nif ( this . methodObject == null ) { \nthrow ex ; \n} \n} \n} \n} \n"}
{"8371": "public class MethodInvoker { \nprotected Method findMatchingMethod ( ) { \nString targetMethod = getTargetMethod ( ) ; \nObject [ ] arguments = getArguments ( ) ; \nint argCount = arguments . length ; \nMethod [ ] candidates = ReflectionUtils . getAllDeclaredMethods ( getTargetClass ( ) ) ; \nint minTypeDiffWeight = Integer . MAX_VALUE ; \nMethod matchingMethod = null ; \nfor ( Method candidate : candidates ) { \nif ( candidate . getName ( ) . equals ( targetMethod ) ) { \nClass < ? > [ ] paramTypes = candidate . getParameterTypes ( ) ; \nif ( paramTypes . length == argCount ) { \nint typeDiffWeight = getTypeDifferenceWeight ( paramTypes , arguments ) ; \nif ( minTypeDiffWeight > typeDiffWeight ) { \nminTypeDiffWeight = typeDiffWeight ; \nmatchingMethod = candidate ; \n} \n} \n} \n} \nreturn matchingMethod ; \n} \n} \n"}
{"8375": "public class DomUtils { \npublic static Element getChildElementByTagName ( Element ele , String childEleName ) { \nAssert . notNull ( ele , \"Element must not be null\" ) ; \nAssert . notNull ( childEleName , \"Element name must not be null\" ) ; \nNodeList nl = ele . getChildNodes ( ) ; \nfor ( int i = 0 ; \nnl . getLength ( ) > i ; \ni ++ ) { \nNode node = nl . item ( i ) ; \nif ( node instanceof Element && nodeNameMatch ( node , childEleName ) ) { \nreturn ( Element ) node ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8377": "public class DomUtils { \npublic static List < Element > getChildElements ( Element ele ) { \nAssert . notNull ( ele , \"Element must not be null\" ) ; \nNodeList nl = ele . getChildNodes ( ) ; \nList < Element > childEles = new ArrayList < Element > ( ) ; \nfor ( int i = 0 ; \nnl . getLength ( ) > i ; \ni ++ ) { \nNode node = nl . item ( i ) ; \nif ( node instanceof Element ) { \nchildEles . add ( ( Element ) node ) ; \n} \n} \nreturn childEles ; \n} \n} \n"}
{"8380": "public class StringUtil { \npublic static final String setSize ( final String s , final int length ) { \nString result = s ; \nint oldlen = s . length ( ) ; \nif ( length < oldlen ) { \nSystem . err . println ( \"greenpeace.util.setSize(String s,int length): length (\" + length + \") is smaller than s.length(\" + oldlen + \") : \" + s ) ; \n} \nelse { \nint tofill = length - oldlen ; \nresult = StringUtil . appendSpaces ( s , tofill ) ; \n} \nreturn result ; \n} \n} \n"}
{"8389": "public class HorizontalPicker { \nprivate int getTextColor ( int item ) { \nint scrollX = getScrollX ( ) ; \nint color = textColor . getDefaultColor ( ) ; \nint itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; \nif ( itemWithPadding * item - itemWithPadding / 2 < scrollX && itemWithPadding * ( item + 1 ) - itemWithPadding / 2 > scrollX ) { \nint position = scrollX - itemWithPadding / 2 ; \ncolor = getColor ( position , item ) ; \n} \nelse if ( item == pressedItem ) { \ncolor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed } \n, color ) ; \n} \nreturn color ; \n} \n} \n"}
{"8390": "public class HorizontalPicker { \npublic void setValues ( CharSequence [ ] values ) { \nif ( this . values != values ) { \nthis . values = values ; \nif ( this . values != null ) { \nlayouts = new BoringLayout [ this . values . length ] ; \nfor ( int i = 0 ; \nlayouts . length > i ; \ni ++ ) { \nlayouts [ i ] = new BoringLayout ( this . values [ i ] , textPaint , itemWidth , Layout . Alignment . ALIGN_CENTER , 1f , 1f , boringMetrics , false , ellipsize , itemWidth ) ; \n} \n} \nelse { \nlayouts = new BoringLayout [ 0 ] ; \n} \nif ( 0 < getWidth ( ) ) { \nstartMarqueeIfNeeded ( ) ; \n} \nrequestLayout ( ) ; \ninvalidate ( ) ; \n} \n} \n} \n"}
{"8391": "public class HorizontalPicker { \nprivate int getColor ( int scrollX , int position ) { \nint itemWithPadding = ( int ) ( itemWidth + dividerSize ) ; \nfloat proportion = Math . abs ( ( ( 1f * scrollX % itemWithPadding ) / 2 ) / ( itemWithPadding / 2f ) ) ; \nif ( .5 < proportion ) { \nproportion = ( proportion - .5f ) ; \n} \nelse { \nproportion = .5f - proportion ; \n} \nproportion *= 2 ; \nint defaultColor ; \nint selectedColor ; \nif ( pressedItem == position ) { \ndefaultColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed } \n, textColor . getDefaultColor ( ) ) ; \nselectedColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_pressed , android . R . attr . state_selected } \n, defaultColor ) ; \n} \nelse { \ndefaultColor = textColor . getDefaultColor ( ) ; \nselectedColor = textColor . getColorForState ( new int [ ] { \nandroid . R . attr . state_selected } \n, defaultColor ) ; \n} \nreturn ( Integer ) new ArgbEvaluator ( ) . evaluate ( proportion , selectedColor , defaultColor ) ; \n} \n} \n"}
{"8393": "public class HorizontalPicker { \nprivate int getInBoundsX ( int x ) { \nif ( 0 > x ) { \nx = 0 ; \n} \nelse if ( ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) < x ) { \nx = ( ( itemWidth + ( int ) dividerSize ) * ( values . length - 1 ) ) ; \n} \nreturn x ; \n} \n} \n"}
{"8399": "public class RemoteServer { \npublic void stop ( int timeoutMS ) throws Exception { \nlog . info ( \"Robot Framework remote server stopping\" ) ; \nif ( 0 < timeoutMS ) { \nserver . setGracefulShutdown ( timeoutMS ) ; \nThread stopper = new Thread ( ) { \n@ Override public void run ( ) { \ntry { \nserver . stop ( ) ; \n} \ncatch ( Throwable e ) { \nlog . error ( String . format ( \"Failed to stop the server: %s\" , e . getMessage ( ) ) , e ) ; \n} \n} \n} \n; \nstopper . start ( ) ; \n} \nelse { \nserver . stop ( ) ; \n} \n} \n} \n"}
{"8424": "public class CrossfadeDrawerLayout { \nprivate float calculatePercentage ( int width ) { \nint absolute = mMaxWidth - mMinWidth ; \nint current = width - mMinWidth ; \nfloat percentage = 100.0f * current / absolute ; \nmIsCrossfaded = 90 < percentage ; \nreturn percentage ; \n} \n} \n"}
{"8425": "public class CrossfadeDrawerLayout { \nprivate void overlapViews ( int width ) { \nif ( width == mWidth ) { \nreturn ; \n} \nmWidth = width ; \nfloat percentage = calculatePercentage ( width ) ; \nfloat alpha = percentage / 100 ; \nmSmallView . setAlpha ( 1 ) ; \nmSmallView . setClickable ( false ) ; \nmLargeView . bringToFront ( ) ; \nmLargeView . setAlpha ( alpha ) ; \nmLargeView . setClickable ( true ) ; \nmLargeView . setVisibility ( 0.01f < alpha ? View . VISIBLE : View . GONE ) ; \nif ( mCrossfadeListener != null ) { \nmCrossfadeListener . onCrossfade ( mContainer , calculatePercentage ( width ) , width ) ; \n} \n} \n} \n"}
{"8452": "public class GMOperation { \npublic GMOperation source ( final File file , @ CheckForNull final Integer width , @ CheckForNull final Integer height ) throws IOException { \nif ( file != null && ! file . exists ( ) ) { \nthrow new IOException ( \"Source file '\" + file + \"' does not exist\" ) ; \n} \nif ( ( width != null ) && ( height != null ) && ( 0 < width ) && ( 0 < height ) ) { \nsize ( width , height ) ; \n} \nreturn addImage ( file ) ; \n} \n} \n"}
{"8465": "public class Selector { \npublic Selector overlapVerticallyWith ( final SlideElement element , final float minOverlapRatio ) { \ncheckNotNull ( element ) ; \nfinal Rectangle r1 = element . getBounds ( ) ; \nr1 . x = 0 ; \nr1 . width = 1 ; \nelements = Collections2 . filter ( elements , new Predicate < SlideElement > ( ) { \n@ Override public boolean apply ( SlideElement e ) { \nif ( e == element ) { \nreturn false ; \n} \nif ( r1 . height == 0 ) { \nreturn false ; \n} \nRectangle r2 = e . getBounds ( ) ; \nr2 . x = 0 ; \nr2 . width = 1 ; \nRectangle intersection = r1 . intersection ( r2 ) ; \nfloat yOverlapRatio = 1f * intersection . height / r1 . height ; \nreturn minOverlapRatio < yOverlapRatio ; \n} \n} \n) ; \nreturn this ; \n} \n} \n"}
{"8484": "public class StenoSerializationHelper { \npublic static void writeKeyValuePairs ( @ Nullable final List < String > keys , @ Nullable final List < Object > values , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper , final StenoEncoder encoder ) throws IOException { \nif ( keys != null ) { \nfinal int contextValuesLength = values == null ? 0 : values . size ( ) ; \nfor ( int i = 0 ; \nkeys . size ( ) > i ; \n++ i ) { \nfinal String key = keys . get ( i ) ; \nif ( contextValuesLength <= i ) { \njsonGenerator . writeObjectField ( key , null ) ; \n} \nelse { \nfinal Object value = values . get ( i ) ; \nif ( isSimpleType ( value ) ) { \njsonGenerator . writeObjectField ( key , value ) ; \n} \nelse { \njsonGenerator . writeFieldName ( key ) ; \nobjectMapper . writeValue ( jsonGenerator , value ) ; \n} \n} \n} \n} \n} \n} \n"}
{"8485": "public class StenoSerializationHelper { \npublic static void serializeThrowable ( final IThrowableProxy throwableProxy , final JsonGenerator jsonGenerator , final ObjectMapper objectMapper ) throws IOException { \njsonGenerator . writeStringField ( \"type\" , throwableProxy . getClassName ( ) ) ; \njsonGenerator . writeStringField ( \"message\" , throwableProxy . getMessage ( ) ) ; \njsonGenerator . writeArrayFieldStart ( \"backtrace\" ) ; \nfor ( final StackTraceElementProxy ste : throwableProxy . getStackTraceElementProxyArray ( ) ) { \njsonGenerator . writeString ( ste . toString ( ) ) ; \n} \njsonGenerator . writeEndArray ( ) ; \njsonGenerator . writeObjectFieldStart ( \"data\" ) ; \nif ( throwableProxy instanceof ThrowableProxy ) { \nfinal JsonNode jsonNode = objectMapper . valueToTree ( ( ( ThrowableProxy ) throwableProxy ) . getThrowable ( ) ) ; \nfor ( final Iterator < Map . Entry < String , JsonNode > > iterator = jsonNode . fields ( ) ; \niterator . hasNext ( ) ; \n) { \nfinal Map . Entry < String , JsonNode > field = iterator . next ( ) ; \njsonGenerator . writeFieldName ( field . getKey ( ) ) ; \nobjectMapper . writeValue ( jsonGenerator , field . getValue ( ) ) ; \n} \n} \nif ( throwableProxy . getSuppressed ( ) != null && 0 < throwableProxy . getSuppressed ( ) . length ) { \njsonGenerator . writeArrayFieldStart ( \"suppressed\" ) ; \nfor ( final IThrowableProxy suppressed : throwableProxy . getSuppressed ( ) ) { \njsonGenerator . writeStartObject ( ) ; \nserializeThrowable ( suppressed , jsonGenerator , objectMapper ) ; \njsonGenerator . writeEndObject ( ) ; \n} \njsonGenerator . writeEndArray ( ) ; \n} \nif ( throwableProxy . getCause ( ) != null ) { \njsonGenerator . writeObjectFieldStart ( \"cause\" ) ; \nserializeThrowable ( throwableProxy . getCause ( ) , jsonGenerator , objectMapper ) ; \njsonGenerator . writeEndObject ( ) ; \n} \njsonGenerator . writeEndObject ( ) ; \n} \n} \n"}
{"8487": "public class AbstractStenoCallerConverter { \nprotected StackTraceElement getCallerData ( final ILoggingEvent loggingEvent ) { \nfinal StackTraceElement [ ] callerData = loggingEvent . getCallerData ( ) ; \nif ( callerData != null ) { \nfor ( int i = 0 ; \ncallerData . length > i ; \n++ i ) { \nfinal String callerClassName = callerData [ i ] . getClassName ( ) ; \nif ( ! callerClassName . startsWith ( STENO_CLASS_NAME_PREFIX ) ) { \nreturn callerData [ i ] ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8490": "public class AbsObjectPool { \nprotected void checkMappings ( int arrayPosition ) { \nfinal int index = positions . indexOfValue ( arrayPosition ) ; \nif ( 0 <= index ) { \npositions . removeAt ( index ) ; \n} \n} \n} \n"}
{"8492": "public class SaveAttrsUtility { \npublic static void saveDataToObjectInContext ( final Map < String , Object > context , final String saveAttr , final String strValue , final ExpressionEngine engine ) { \nint index = saveAttr . lastIndexOf ( '.' ) ; \nif ( 0 < index ) { \nString strObject = saveAttr . substring ( 0 , index ) ; \nString strMethod = saveAttr . substring ( index + 1 ) ; \nstrObject = TieConstants . METHOD_PREFIX + strObject + TieConstants . METHOD_END ; \nObject object = CommandUtility . evaluate ( strObject , context , engine ) ; \nCellControlsUtility . setObjectProperty ( object , strMethod , strValue , true ) ; \n} \n} \n} \n"}
{"8493": "public class SaveAttrsUtility { \npublic static void refreshSheetRowFromContext ( final Map < String , Object > context , final String fullSaveAttr , final Row row , final ExpressionEngine engine ) { \nif ( ! fullSaveAttr . startsWith ( TieConstants . CELL_ADDR_PRE_FIX ) ) { \nreturn ; \n} \nint ipos = fullSaveAttr . indexOf ( '=' ) ; \nif ( 0 < ipos ) { \nString columnIndex = fullSaveAttr . substring ( 1 , ipos ) ; \nString saveAttr = fullSaveAttr . substring ( ipos + 1 ) ; \nCell cell = row . getCell ( Integer . parseInt ( columnIndex ) ) ; \nif ( cell . getCellTypeEnum ( ) != CellType . FORMULA ) { \nCommandUtility . evaluateNormalCells ( cell , TieConstants . METHOD_PREFIX + saveAttr + TieConstants . METHOD_END , context , engine ) ; \n} \n} \n} \n} \n"}
{"8494": "public class SaveAttrsUtility { \npublic static String parseSaveAttrString ( final String strValue ) { \nif ( strValue != null ) { \nint first = strValue . indexOf ( TieConstants . METHOD_PREFIX ) ; \nint last = strValue . lastIndexOf ( TieConstants . METHOD_PREFIX ) ; \nint end = strValue . lastIndexOf ( TieConstants . METHOD_END ) ; \nif ( ( 0 <= first ) && ( first == last ) && ( 1 < end ) ) { \nreturn strValue . substring ( first + 2 , end ) ; \n} \n} \nreturn \"\" ; \n} \n} \n"}
{"8496": "public class SaveAttrsUtility { \npublic static String getSaveAttrFromList ( final int columnIndex , final String saveAttrs ) { \nif ( ( saveAttrs != null ) && ( ! saveAttrs . isEmpty ( ) ) ) { \nString str = TieConstants . CELL_ADDR_PRE_FIX + columnIndex + \"=\" ; \nint istart = saveAttrs . indexOf ( str ) ; \nif ( 0 <= istart ) { \nint iend = saveAttrs . indexOf ( ',' , istart ) ; \nif ( istart < iend ) { \nreturn saveAttrs . substring ( istart + str . length ( ) , iend ) ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8498": "public class SaveAttrsUtility { \npublic static void setSaveAttrsForSheet ( final Sheet sheet , final int minRowNum , final int maxRowNum , final Map < String , String > saveCommentsMap ) { \nfor ( Row row : sheet ) { \nint rowIndex = row . getRowNum ( ) ; \nif ( ( minRowNum <= rowIndex ) && ( maxRowNum >= rowIndex ) ) { \nsetSaveAttrsForRow ( row , saveCommentsMap ) ; \n} \n} \n} \n} \n"}
{"8499": "public class SaveAttrsUtility { \npublic static void setSaveAttrsForRow ( final Row row , final Map < String , String > saveCommentsMap ) { \nStringBuilder saveAttr = new StringBuilder ( ) ; \nfor ( Cell cell : row ) { \nString sAttr = parseSaveAttr ( cell , saveCommentsMap ) ; \nif ( ! sAttr . isEmpty ( ) ) { \nsaveAttr . append ( sAttr ) ; \n} \n} \nif ( 0 < saveAttr . length ( ) ) { \nSaveAttrsUtility . setSaveObjectsInHiddenColumn ( row , saveAttr . toString ( ) ) ; \n} \n} \n} \n"}
{"8506": "public class TieWebSheetBean { \npublic void reCalcMaxColCounts ( ) { \nif ( ( this . getSheetConfigMap ( ) == null ) || ( this . getSheetConfigMap ( ) . isEmpty ( ) ) ) { \nthis . maxColCounts = 0 ; \nreturn ; \n} \nint maxColumns = 0 ; \nfor ( SheetConfiguration sheetConfig : this . getSheetConfigMap ( ) . values ( ) ) { \nint counts = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) - sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) + 1 ; \nif ( counts > maxColumns ) { \nmaxColumns = counts ; \n} \n} \nthis . maxColCounts = maxColumns ; \n} \n} \n"}
{"8509": "public class TieWebSheetBean { \npublic int loadWorkSheetByTabName ( final String tabName ) { \ntry { \nint sheetId = this . getHelper ( ) . getWebSheetLoader ( ) . findTabIndexWithName ( tabName ) ; \nif ( ( getSheetConfigMap ( ) != null ) && ( getSheetConfigMap ( ) . size ( ) > sheetId ) ) { \nthis . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( tabName ) ; \nsetActiveTabIndex ( sheetId ) ; \n} \nreturn 1 ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"loadWorkSheetByTabName failed. error = \" + ex . getMessage ( ) , ex ) ; \n} \nreturn - 1 ; \n} \n} \n"}
{"8522": "public class ShiftFormulaUtility { \npublic static Ptg [ ] convertSharedFormulas ( final Ptg [ ] ptgs , final ShiftFormulaRef shiftFormulaRef ) { \nList < Ptg > newPtgList = new ArrayList < > ( ) ; \nObject ptg ; \nfor ( int k = 0 ; \nptgs . length > k ; \n++ k ) { \nptg = ptgs [ k ] ; \nnewPtgList . addAll ( Arrays . asList ( convertPtg ( ptgs , k , shiftFormulaRef , ptg ) ) ) ; \n} \nreturn newPtgList . toArray ( new Ptg [ newPtgList . size ( ) ] ) ; \n} \n} \n"}
{"8523": "public class ShiftFormulaUtility { \nprivate static Ptg [ ] convertPtg ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg ) { \nbyte originalOperandClass = - 1 ; \nif ( ! ( ( Ptg ) ptg ) . isBaseToken ( ) ) { \noriginalOperandClass = ( ( Ptg ) ptg ) . getPtgClass ( ) ; \n} \nint currentRow ; \ncurrentRow = getFirstSupportedRowNumFromPtg ( ptg ) ; \nif ( ( 0 <= currentRow ) && shiftFormulaRef . getWatchList ( ) . contains ( currentRow ) ) { \nreturn convertPtgForWatchList ( ptgs , position , shiftFormulaRef , ptg , originalOperandClass , currentRow ) ; \n} \nif ( ( ptg instanceof AttrPtg ) && ( 1 < shiftFormulaRef . getFormulaChanged ( ) ) ) { \nAttrPtg newPtg = ( AttrPtg ) ptg ; \nif ( newPtg . isSum ( ) ) { \nFuncVarPtg fptg = FuncVarPtg . create ( \"sum\" , shiftFormulaRef . getFormulaChanged ( ) ) ; \nreturn singlePtg ( fptg , fptg . getPtgClass ( ) , shiftFormulaRef . getFormulaChanged ( ) ) ; \n} \n} \nreturn singlePtg ( ptg , originalOperandClass , shiftFormulaRef . getFormulaChanged ( ) ) ; \n} \n} \n"}
{"8524": "public class ShiftFormulaUtility { \nprivate static Ptg [ ] convertPtgForWatchList ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg , final byte originalOperandClass , final int currentRow ) { \nList < SerialRow > rowlist = getRowsList ( currentRow , shiftFormulaRef . getCurrentRowsMappingList ( ) ) ; \nif ( ( rowlist == null ) || ( rowlist . isEmpty ( ) ) ) { \nreturn singlePtg ( ptg , originalOperandClass , - 1 ) ; \n} \nshiftFormulaRef . setFormulaChanged ( 1 ) ; \nif ( ( rowlist . size ( ) == 1 ) || ( ptgs . length <= ( position + 1 ) ) || ! ( ptgs [ position + 1 ] instanceof ParenthesisPtg ) ) { \nreturn singlePtg ( fixupRefRelativeRowOneToOne ( ptg , rowlist . get ( 0 ) . getRow ( ) ) , originalOperandClass , - 1 ) ; \n} \nshiftFormulaRef . setFormulaChanged ( rowlist . size ( ) ) ; \nreturn fixupRefRelativeRowOneToMany ( ptg , originalOperandClass , rowlist , ptgs , position ) ; \n} \n} \n"}
{"8525": "public class ShiftFormulaUtility { \nprivate static Ptg [ ] singlePtg ( final Object ptg , final byte originalOperandClass , final int formulaChanged ) { \nPtg [ ] newPtg = new Ptg [ 1 ] ; \nif ( originalOperandClass != ( - 1 ) ) { \n( ( Ptg ) ptg ) . setClass ( originalOperandClass ) ; \n} \nObject ptgAfter = ptg ; \nif ( ptg instanceof FuncVarPtg ) { \nFuncVarPtg fptg = ( FuncVarPtg ) ptg ; \nif ( ( 0 < formulaChanged ) && ( fptg . getNumberOfOperands ( ) != formulaChanged ) ) { \nptgAfter = FuncVarPtg . create ( ( ( FuncVarPtg ) ptg ) . getName ( ) , formulaChanged ) ; \n} \n} \nnewPtg [ 0 ] = ( Ptg ) ptgAfter ; \nreturn newPtg ; \n} \n} \n"}
{"8529": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForRefPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg , final boolean includeParenthesis ) { \nRefPtgBase refPtg = ( RefPtgBase ) ptg ; \nint unitSize = 1 ; \nif ( includeParenthesis ) { \nunitSize = 2 ; \n} \nfor ( int i = 0 ; \nrowList . size ( ) > i ; \ni ++ ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nif ( refPtg instanceof Ref3DPxg ) { \nRef3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; \nRef3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( row . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; \nnew3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nRefPtgBase refPtgBase = refPtg ; \nnewPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; \n} \nif ( ( unitSize == 2 ) && ( ( rowList . size ( ) - 1 ) > i ) ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \n} \n} \n"}
{"8530": "public class ShiftFormulaUtility { \nprivate static void buildDynamicRowForAreaPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg ) { \nAreaPtgBase areaPtg = ( AreaPtgBase ) ptg ; \nint originFirstRow = areaPtg . getFirstRow ( ) ; \nint originLastRow = areaPtg . getLastRow ( ) ; \nint unitSize = 2 ; \nfor ( int i = 0 ; \nrowList . size ( ) > i ; \ni ++ ) { \nRow row = rowList . get ( i ) . getRow ( ) ; \nint shiftRow = row . getRowNum ( ) - originFirstRow ; \nif ( ptg instanceof Area3DPxg ) { \nArea3DPxg area3dPxg = ( Area3DPxg ) ptg ; \nArea3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; \nnew3dpxg . setClass ( originalOperandClass ) ; \nnew3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; \nnew3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; \nnew3dpxg . setFirstRow ( originFirstRow + shiftRow ) ; \nnew3dpxg . setLastRow ( originLastRow + shiftRow ) ; \nnew3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; \nnew3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; \nnew3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; \nnewPtg [ i * unitSize ] = new3dpxg ; \n} \nelse { \nAreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; \nnewPtg [ i * unitSize ] = new AreaPtg ( originFirstRow + shiftRow , originLastRow + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; \n} \nif ( ( rowList . size ( ) - 1 ) > i ) { \nnewPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; \n} \n} \n} \n} \n"}
{"8538": "public class ColorUtility { \npublic static short [ ] getTripletFromXSSFColor ( final XSSFColor xssfColor ) { \nshort [ ] rgbfix = { \nRGB8BITS , RGB8BITS , RGB8BITS } \n; \nif ( xssfColor != null ) { \nbyte [ ] rgb = xssfColor . getRGBWithTint ( ) ; \nif ( rgb == null ) { \nrgb = xssfColor . getRGB ( ) ; \n} \nrgbfix [ 0 ] = ( short ) ( ( 0 > rgb [ 0 ] ) ? ( rgb [ 0 ] + RGB8BITS ) : rgb [ 0 ] ) ; \nrgbfix [ 1 ] = ( short ) ( ( 0 > rgb [ 1 ] ) ? ( rgb [ 1 ] + RGB8BITS ) : rgb [ 1 ] ) ; \nrgbfix [ 2 ] = ( short ) ( ( 0 > rgb [ 2 ] ) ? ( rgb [ 2 ] + RGB8BITS ) : rgb [ 2 ] ) ; \n} \nreturn rgbfix ; \n} \n} \n"}
{"8545": "public class CellControlsUtility { \npublic static void setupControlAttributes ( final int originRowIndex , final FacesCell fcell , final Cell poiCell , final SheetConfiguration sheetConfig , final CellAttributesMap cellAttributesMap ) { \nint rowIndex = originRowIndex ; \nif ( 0 > rowIndex ) { \nrowIndex = poiCell . getRowIndex ( ) ; \n} \nString skey = poiCell . getSheet ( ) . getSheetName ( ) + \"!\" + CellUtility . getCellIndexNumberKey ( poiCell . getColumnIndex ( ) , rowIndex ) ; \nMap < String , String > commentMap = cellAttributesMap . getTemplateCommentMap ( ) . get ( \"$$\" ) ; \nif ( commentMap != null ) { \nString comment = commentMap . get ( skey ) ; \nif ( comment != null ) { \nCommandUtility . createCellComment ( poiCell , comment , sheetConfig . getFinalCommentMap ( ) ) ; \n} \n} \nString widgetType = cellAttributesMap . getCellInputType ( ) . get ( skey ) ; \nif ( widgetType != null ) { \nfcell . setControl ( widgetType . toLowerCase ( ) ) ; \nfcell . setInputAttrs ( cellAttributesMap . getCellInputAttributes ( ) . get ( skey ) ) ; \nfcell . setSelectItemAttrs ( cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( skey ) ) ; \nfcell . setDatePattern ( cellAttributesMap . getCellDatePattern ( ) . get ( skey ) ) ; \n} \n} \n} \n"}
{"8555": "public class ChartHelper { \nprivate void initXSSFChartsMap ( final XSSFWorkbook wb , final ChartsData chartsData ) { \ninitAnchorsMap ( wb , chartsData ) ; \nMap < String , ClientAnchor > anchorMap = chartsData . getChartAnchorsMap ( ) ; \nMap < String , BufferedImage > chartMap = chartsData . getChartsMap ( ) ; \nMap < String , ChartData > chartDataMap = chartsData . getChartDataMap ( ) ; \nchartMap . clear ( ) ; \nchartDataMap . clear ( ) ; \nfor ( int i = 0 ; \nwb . getNumberOfSheets ( ) > i ; \ni ++ ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nList < XSSFChart > charts = drawing . getCharts ( ) ; \nif ( ( charts != null ) && ( ! charts . isEmpty ( ) ) ) { \nfor ( XSSFChart chart : charts ) { \ngenerateSingleXSSFChart ( chart , getChartIdFromParent ( chart , sheet . getSheetName ( ) ) , sheet , anchorMap , chartMap , chartDataMap ) ; \n} \n} \n} \n} \n} \n"}
{"8562": "public class ConfigurationUtility { \nprivate static void setupUpperLevelFormula ( final Cell cell , final String originFormula , final String actionFullName , final Map < String , List < RowsMapping > > rowsMap , final ConfigBuildRef configBuildRef ) { \nString fullName = getFullNameFromRow ( cell . getRow ( ) ) ; \nif ( actionFullName . startsWith ( fullName + \":\" ) ) { \nList < RowsMapping > currentRowsMappingList = rowsMap . get ( fullName ) ; \nif ( currentRowsMappingList == null ) { \ncurrentRowsMappingList = gatherRowsMappingByFullName ( configBuildRef , fullName ) ; \nrowsMap . put ( fullName , currentRowsMappingList ) ; \n} \nShiftFormulaRef shiftFormulaRef = new ShiftFormulaRef ( configBuildRef . getWatchList ( ) , currentRowsMappingList ) ; \nshiftFormulaRef . setFormulaChanged ( 0 ) ; \nbuildCellFormulaForShiftedRows ( configBuildRef . getSheet ( ) , configBuildRef . getWbWrapper ( ) , shiftFormulaRef , cell , originFormula ) ; \nif ( 0 < shiftFormulaRef . getFormulaChanged ( ) ) { \nconfigBuildRef . getCachedCells ( ) . put ( cell , originFormula ) ; \n} \n} \n} \n} \n"}
{"8563": "public class ConfigurationUtility { \npublic static void buildCellFormulaForShiftedRows ( final Sheet sheet , final XSSFEvaluationWorkbook wbWrapper , final ShiftFormulaRef shiftFormulaRef , final Cell cell , final String originFormula ) { \nif ( ( shiftFormulaRef . getWatchList ( ) != null ) && ( ! shiftFormulaRef . getWatchList ( ) . isEmpty ( ) ) ) { \nPtg [ ] ptgs = FormulaParser . parse ( originFormula , wbWrapper , FormulaType . CELL , sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ) ; \nPtg [ ] convertedFormulaPtg = ShiftFormulaUtility . convertSharedFormulas ( ptgs , shiftFormulaRef ) ; \nif ( 0 < shiftFormulaRef . getFormulaChanged ( ) ) { \ncell . setCellFormula ( FormulaRenderer . toFormulaString ( wbWrapper , convertedFormulaPtg ) ) ; \n} \n} \n} \n} \n"}
{"8566": "public class ConfigurationUtility { \npublic static void changeUpperLevelFinalLength ( final Map < String , ConfigRangeAttrs > shiftMap , final String addedFullName , final int increasedLength ) { \nString [ ] parts = addedFullName . split ( \":\" ) ; \nStringBuilder fname = new StringBuilder ( ) ; \nfor ( int i = 0 ; \n( parts . length - 1 ) > i ; \ni ++ ) { \nif ( i == 0 ) { \nfname . append ( parts [ i ] ) ; \n} \nelse { \nfname . append ( \":\" ) . append ( parts [ i ] ) ; \n} \nString sname = fname . toString ( ) ; \nshiftMap . get ( sname ) . setFinalLength ( shiftMap . get ( sname ) . getFinalLength ( ) + increasedLength ) ; \n} \n} \n} \n"}
{"8567": "public class ConfigurationUtility { \npublic static void changeIndexNumberInHiddenColumn ( final ConfigBuildRef configBuildRef , final int startRowIndex , final String fullName , final Map < String , String > changeMap , final int steps ) { \nString searchName = fullName . substring ( 0 , fullName . lastIndexOf ( '.' ) + 1 ) ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nfor ( int i = startRowIndex ; \nsheet . getLastRowNum ( ) >= i ; \ni ++ ) { \nRow row = sheet . getRow ( i ) ; \nString fname = getFullNameFromRow ( row ) ; \nif ( ( fname != null ) && ( 0 <= fname . indexOf ( searchName ) ) ) { \nint sindex = fname . indexOf ( searchName ) ; \nString snum = fname . substring ( sindex + searchName . length ( ) ) ; \nint sufindex = snum . indexOf ( ':' ) ; \nString suffix = \"\" ; \nif ( 0 < sufindex ) { \nsnum = snum . substring ( 0 , sufindex ) ; \nsuffix = \":\" ; \n} \nint increaseNum = Integer . parseInt ( snum ) + steps ; \nString realFullName = fname . substring ( sindex ) ; \nString changeName = fname . replace ( searchName + snum + suffix , searchName + increaseNum + suffix ) ; \nif ( changeMap . get ( realFullName ) == null ) { \nchangeMap . put ( realFullName , changeName . substring ( sindex ) ) ; \n} \nsetFullNameInHiddenColumn ( row , changeName ) ; \n} \nelse { \nreturn ; \n} \n} \n} \n} \n"}
{"8571": "public class ConfigurationUtility { \npublic static List < RowsMapping > findParentRowsMappingFromShiftMap ( final String [ ] parts , final Map < String , ConfigRangeAttrs > shiftMap ) { \nStringBuilder fullName = new StringBuilder ( ) ; \nList < RowsMapping > rowsMappingList = new ArrayList < > ( ) ; \nfor ( int i = 1 ; \nparts . length - 1 > i ; \ni ++ ) { \nString part = parts [ i ] ; \nif ( fullName . length ( ) == 0 ) { \nfullName . append ( part ) ; \n} \nelse { \nfullName . append ( \":\" + part ) ; \n} \nif ( 0 < fullName . length ( ) ) { \nConfigRangeAttrs rangeAttrs = shiftMap . get ( fullName . toString ( ) ) ; \nif ( rangeAttrs != null ) { \nrowsMappingList . add ( rangeAttrs . getUnitRowsMapping ( ) ) ; \n} \n} \n} \nreturn rowsMappingList ; \n} \n} \n"}
{"8573": "public class ConfigurationUtility { \n@ SuppressWarnings ( \"rawtypes\" ) public static Object findItemInCollection ( final Collection collection , final int index ) { \nif ( 0 <= index ) { \nif ( collection instanceof List ) { \nList list = ( List ) collection ; \nreturn list . get ( index ) ; \n} \nint i = 0 ; \nfor ( Object object : collection ) { \nif ( i == index ) { \nreturn object ; \n} \ni ++ ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8575": "public class ConfigurationUtility { \npublic static boolean isStaticRow ( final ConfigRange sourceConfigRange , final int rowIndex ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( int i = 0 ; \nsourceConfigRange . getCommandList ( ) . size ( ) > i ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nif ( ( command . getConfigRange ( ) . getFirstRowAddr ( ) . getRow ( ) <= rowIndex ) && ( ( command . getConfigRange ( ) . getLastRowPlusAddr ( ) . getRow ( ) ) > rowIndex ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8576": "public class ConfigurationUtility { \npublic static boolean isStaticRowRef ( final ConfigRange sourceConfigRange , final Row row ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( int i = 0 ; \nsourceConfigRange . getCommandList ( ) . size ( ) > i ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nint rowIndex = row . getRowNum ( ) ; \nif ( ( command . getTopRow ( ) <= rowIndex ) && ( ( command . getTopRow ( ) + command . getFinalLength ( ) ) > rowIndex ) ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8577": "public class ConfigurationUtility { \npublic static String replaceExpressionWithCellValue ( final String attrValue , final int rowIndex , final Sheet sheet ) { \nint ibegin = 0 ; \nint ifind ; \nint inameEnd ; \nString tempStr ; \nString findStr ; \nString replaceStr ; \nString returnStr = attrValue ; \nwhile ( 0 < ( ifind = attrValue . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , ibegin ) ) ) { \ninameEnd = ParserUtility . findFirstNonCellNamePosition ( attrValue , ifind ) ; \nif ( 0 < inameEnd ) { \nfindStr = attrValue . substring ( ifind , inameEnd ) ; \n} \nelse { \nfindStr = attrValue . substring ( ifind ) ; \n} \nif ( 0 > findStr . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , 1 ) ) { \ntempStr = findStr + TieConstants . CELL_ADDR_PRE_FIX + ( rowIndex + 1 ) ; \n} \nelse { \ntempStr = findStr ; \n} \nreplaceStr = CellUtility . getCellValueWithoutFormat ( WebSheetUtility . getCellByReference ( tempStr , sheet ) ) ; \nif ( replaceStr == null ) { \nreplaceStr = \"\" ; \n} \nreturnStr = attrValue . replace ( findStr , replaceStr ) ; \nibegin = ifind + 1 ; \n} \nreturn returnStr ; \n} \n} \n"}
{"8578": "public class ConfigurationUtility { \npublic static Map < String , CellRangeAddress > indexMergedRegion ( final Sheet sheet1 ) { \nint numRegions = sheet1 . getNumMergedRegions ( ) ; \nMap < String , CellRangeAddress > cellRangeMap = new HashMap < > ( ) ; \nfor ( int i = 0 ; \nnumRegions > i ; \ni ++ ) { \nCellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; \nif ( caddress != null ) { \ncellRangeMap . put ( CellUtility . getCellIndexNumberKey ( caddress . getFirstColumn ( ) , caddress . getFirstRow ( ) ) , caddress ) ; \n} \n} \nreturn cellRangeMap ; \n} \n} \n"}
{"8579": "public class ConfigurationUtility { \npublic static List < String > skippedRegionCells ( final Sheet sheet1 ) { \nint numRegions = sheet1 . getNumMergedRegions ( ) ; \nList < String > skipCellList = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \nnumRegions > i ; \ni ++ ) { \nCellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; \nif ( caddress != null ) { \naddSkipCellToListInTheRegion ( skipCellList , caddress ) ; \n} \n} \nreturn skipCellList ; \n} \n} \n"}
{"8580": "public class ConfigurationUtility { \nprivate static void addSkipCellToListInTheRegion ( final List < String > skipCellList , final CellRangeAddress caddress ) { \nfor ( int col = caddress . getFirstColumn ( ) ; \ncaddress . getLastColumn ( ) >= col ; \ncol ++ ) { \nfor ( int row = caddress . getFirstRow ( ) ; \ncaddress . getLastRow ( ) >= row ; \nrow ++ ) { \nif ( ( col == caddress . getFirstColumn ( ) ) && ( row == caddress . getFirstRow ( ) ) ) { \ncontinue ; \n} \nskipCellList . add ( CellUtility . getCellIndexNumberKey ( col , row ) ) ; \n} \n} \n} \n} \n"}
{"8583": "public class ConfigurationHandler { \npublic final Map < String , SheetConfiguration > buildConfiguration ( ) { \nMap < String , SheetConfiguration > sheetConfigMap = new LinkedHashMap < > ( ) ; \nList < String > sheetNames = new ArrayList < > ( ) ; \nString sname ; \nfor ( int i = 0 ; \nparent . getWb ( ) . getNumberOfSheets ( ) > i ; \ni ++ ) { \nsname = parent . getWb ( ) . getSheetName ( i ) ; \nif ( ! sname . startsWith ( org . tiefaces . common . TieConstants . COPY_SHEET_PREFIX ) ) { \nsheetNames . add ( sname ) ; \n} \n} \nfor ( String sheetName : sheetNames ) { \nSheet sheet = parent . getWb ( ) . getSheet ( sheetName ) ; \nConfigurationUtility . buildSheetCommentFromAlias ( sheet , parent . getTieCommandAliasList ( ) ) ; \nbuildSheet ( sheet , sheetConfigMap , parent . getCellAttributesMap ( ) ) ; \n} \nreturn sheetConfigMap ; \n} \n} \n"}
{"8584": "public class ConfigurationHandler { \nprivate SheetConfiguration getSheetConfiguration ( final Sheet sheet , final String formName , final int sheetRightCol ) { \nSheetConfiguration sheetConfig = new SheetConfiguration ( ) ; \nsheetConfig . setFormName ( formName ) ; \nsheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; \nint leftCol = sheet . getLeftCol ( ) ; \nint lastRow = sheet . getLastRowNum ( ) ; \nint firstRow = sheet . getFirstRowNum ( ) ; \nint rightCol = 0 ; \nint maxRow = 0 ; \nfor ( Row row : sheet ) { \nif ( TieConstants . TIE_WEB_SHEET_MAX_ROWS < row . getRowNum ( ) ) { \nbreak ; \n} \nmaxRow = row . getRowNum ( ) ; \nint firstCellNum = row . getFirstCellNum ( ) ; \nif ( 0 <= firstCellNum && leftCol > firstCellNum ) { \nleftCol = firstCellNum ; \n} \nif ( rightCol < ( row . getLastCellNum ( ) - 1 ) ) { \nint verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; \nif ( rightCol < verifiedcol ) { \nrightCol = verifiedcol ; \n} \n} \n} \nif ( lastRow > maxRow ) { \nlastRow = maxRow ; \n} \nString tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + \"0 : \" + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + \"0\" ; \nsheetConfig . setFormHeaderRange ( tempStr ) ; \nsheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; \ntempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( firstRow + 1 ) + \" : \" + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( lastRow + 1 ) ; \nsheetConfig . setFormBodyRange ( tempStr ) ; \nsheetConfig . setBodyCellRange ( new CellRange ( tempStr ) ) ; \nsheetConfig . setFormBodyType ( org . tiefaces . common . TieConstants . FORM_TYPE_FREE ) ; \nsheetConfig . setCellFormAttributes ( new HashMap < String , List < CellFormAttributes > > ( ) ) ; \nint sheetIndex = parent . getWb ( ) . getSheetIndex ( sheet ) ; \nif ( parent . getWb ( ) . isSheetHidden ( sheetIndex ) || parent . getWb ( ) . isSheetVeryHidden ( sheetIndex ) ) { \nsheetConfig . setHidden ( true ) ; \n} \nreturn sheetConfig ; \n} \n} \n"}
{"8586": "public class ConfigurationHandler { \nprivate int verifyLastCell ( final Row row , final int stoppoint , final int sheetRightCol ) { \nint lastCol = sheetRightCol ; \nint col ; \nfor ( col = lastCol ; \nstoppoint <= col ; \ncol -- ) { \nCell cell = row . getCell ( col ) ; \nif ( ( cell != null ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) { \nbreak ; \n} \n} \nreturn col ; \n} \n} \n"}
{"8587": "public class ConfigurationHandler { \npublic final void buildSheet ( final Sheet sheet , final Map < String , SheetConfiguration > sheetConfigMap , final CellAttributesMap cellAttributesMap ) { \nif ( ( 0 >= sheet . getLastRowNum ( ) ) && ( sheet . getRow ( 0 ) == null ) ) { \nreturn ; \n} \ncheckAndRepairLastRow ( sheet ) ; \nint sheetRightCol = WebSheetUtility . getSheetRightCol ( sheet ) ; \nList < ConfigCommand > commandList = buildCommandListFromSheetComment ( ( XSSFSheet ) sheet , sheetRightCol , cellAttributesMap ) ; \nboolean hasEachCommand = hasEachCommandInTheList ( commandList ) ; \nList < String > formList = new ArrayList < > ( ) ; \nbuildSheetConfigMapFromFormCommand ( sheet , sheetConfigMap , commandList , formList , sheetRightCol ) ; \nmatchParentCommand ( commandList ) ; \nmatchSheetConfigForm ( sheetConfigMap , commandList , formList ) ; \ninitTemplateForCommand ( sheet , sheetConfigMap , formList , hasEachCommand ) ; \n} \n} \n"}
{"8590": "public class ConfigurationHandler { \nprivate void setParentForChildCommand ( final List < ConfigCommand > commandList , final int i , final ConfigCommand child ) { \nint matchIndex = - 1 ; \nConfigRange matchRange = null ; \nfor ( int j = 0 ; \ncommandList . size ( ) > j ; \nj ++ ) { \nif ( j != i ) { \nCommand commandParent = commandList . get ( j ) ; \nif ( ! commandParent . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) && WebSheetUtility . insideRange ( child . getConfigRange ( ) , commandParent . getConfigRange ( ) ) && ( ( matchRange == null ) || ( WebSheetUtility . insideRange ( commandParent . getConfigRange ( ) , matchRange ) ) ) ) { \nmatchRange = commandParent . getConfigRange ( ) ; \nmatchIndex = j ; \n} \n} \n} \nif ( 0 <= matchIndex ) { \ncommandList . get ( matchIndex ) . getConfigRange ( ) . addCommand ( child ) ; \nchild . setParentFound ( true ) ; \n} \n} \n} \n"}
{"8594": "public class ConfigurationHandler { \nprivate List < ConfigCommand > buildCommandList ( final Sheet sheet , final int sheetRightCol , final Cell cell , final List < ConfigCommand > cList , final CellAttributesMap cellAttributesMap ) { \nComment comment = cell . getCellComment ( ) ; \nString text = comment . getString ( ) . getString ( ) ; \nString [ ] commentLines = text . split ( \"\\\\n\" ) ; \nStringBuilder newComment = new StringBuilder ( ) ; \nboolean changed = false ; \nfor ( String commentLine : commentLines ) { \nString line = commentLine . trim ( ) ; \nif ( ParserUtility . isCommandString ( line ) ) { \nprocessCommandLine ( sheet , cell , line , cList , sheetRightCol ) ; \nchanged = true ; \n} \nelse if ( ParserUtility . isEmptyMethodString ( line ) || ParserUtility . isMethodString ( line ) ) { \nprocessMethodLine ( cell , line , cellAttributesMap ) ; \nchanged = true ; \n} \nelse { \nif ( 0 < newComment . length ( ) ) { \nnewComment . append ( \"\\\\n\" + commentLine ) ; \n} \nelse { \nnewComment . append ( commentLine ) ; \n} \n} \n} \nif ( ! changed ) { \nmoveCommentToMap ( cell , text , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; \n} \nelse { \nif ( 0 < newComment . length ( ) ) { \nmoveCommentToMap ( cell , newComment . toString ( ) , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; \nCreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; \nRichTextString str = factory . createRichTextString ( newComment . toString ( ) ) ; \ncomment . setString ( str ) ; \n} \nelse { \ncell . removeCellComment ( ) ; \n} \n} \nreturn cList ; \n} \n} \n"}
{"8596": "public class ConfigurationHandler { \nprivate void processCommandLine ( final Sheet sheet , final Cell cell , final String line , final List < ConfigCommand > cList , final int sheetRightCol ) { \nint nameEndIndex = line . indexOf ( TieConstants . ATTR_PREFIX , TieConstants . COMMAND_PREFIX . length ( ) ) ; \nif ( 0 > nameEndIndex ) { \nString errMsg = \"Failed to parse command line [\" + line + \"]. Expected '\" + TieConstants . ATTR_PREFIX + \"' symbol.\" ; \nLOG . severe ( errMsg ) ; \nthrow new IllegalStateException ( errMsg ) ; \n} \nString commandName = line . substring ( TieConstants . COMMAND_PREFIX . length ( ) , nameEndIndex ) . trim ( ) ; \nMap < String , String > attrMap = buildAttrMap ( line , nameEndIndex ) ; \nConfigCommand configCommand = createConfigCommand ( sheet , cell , sheetRightCol , commandName , attrMap ) ; \nif ( configCommand != null ) { \ncList . add ( configCommand ) ; \n} \n} \n} \n"}
{"8599": "public class ConfigurationHandler { \nprivate Map < String , String > buildAttrMap ( final String commandLine , final int nameEndIndex ) { \nint paramsEndIndex = commandLine . lastIndexOf ( TieConstants . ATTR_SUFFIX ) ; \nif ( 0 > paramsEndIndex ) { \nString errMsg = \"Failed to parse command line [\" + commandLine + \"]. Expected '\" + TieConstants . ATTR_SUFFIX + \"' symbol.\" ; \nthrow new IllegalArgumentException ( errMsg ) ; \n} \nString attrString = commandLine . substring ( nameEndIndex + 1 , paramsEndIndex ) . trim ( ) ; \nreturn ParserUtility . parseCommandAttributes ( attrString ) ; \n} \n} \n"}
{"8600": "public class ConfigurationHandler { \nprivate SheetConfiguration getSheetConfigurationFromConfigCommand ( final Sheet sheet , final FormCommand fcommand , final int sheetRightCol ) { \nSheetConfiguration sheetConfig = new SheetConfiguration ( ) ; \nsheetConfig . setFormName ( fcommand . getName ( ) ) ; \nsheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; \nint leftCol = fcommand . getLeftCol ( ) ; \nint lastRow = fcommand . getLastRow ( ) ; \nint rightCol = 0 ; \nint maxRow = 0 ; \nfor ( Row row : sheet ) { \nif ( TieConstants . TIE_WEB_SHEET_MAX_ROWS < row . getRowNum ( ) ) { \nbreak ; \n} \nmaxRow = row . getRowNum ( ) ; \nif ( rightCol < ( row . getLastCellNum ( ) - 1 ) ) { \nint verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; \nif ( rightCol < verifiedcol ) { \nrightCol = verifiedcol ; \n} \n} \n} \nif ( lastRow > maxRow ) { \nlastRow = maxRow ; \n} \nsetHeaderOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; \nsetBodyOfSheetConfiguration ( fcommand , sheetConfig , leftCol , lastRow , rightCol ) ; \nsetFooterOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; \nString hidden = fcommand . getHidden ( ) ; \nif ( ( hidden != null ) && ( Boolean . parseBoolean ( hidden ) ) ) { \nsheetConfig . setHidden ( true ) ; \n} \nString fixedWidthStyle = fcommand . getFixedWidthStyle ( ) ; \nif ( ( fixedWidthStyle != null ) && ( Boolean . parseBoolean ( fixedWidthStyle ) ) ) { \nsheetConfig . setFixedWidthStyle ( true ) ; \n} \nsheetConfig . setFormCommand ( fcommand ) ; \nreturn sheetConfig ; \n} \n} \n"}
{"8604": "public class CommandUtility { \n@ SuppressWarnings ( { \n\"rawtypes\" } \n) public static int deleteRow ( final ConfigBuildRef configBuildRef , final int rowIndex , final Map < String , Object > dataContext , final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows ) { \nString fullName = ConfigurationUtility . getFullNameFromRow ( configBuildRef . getSheet ( ) . getRow ( rowIndex ) ) ; \nconfigBuildRef . getCellHelper ( ) . restoreDataContext ( fullName ) ; \nCollectionObject collect = configBuildRef . getCellHelper ( ) . getLastCollect ( fullName ) ; \nCollection lastCollection = collect . getLastCollection ( ) ; \nint lastCollectionIndex = collect . getLastCollectionIndex ( ) ; \nEachCommand eachCommand = collect . getEachCommand ( ) ; \nif ( 0 > lastCollectionIndex ) { \nthrow new DeleteRowException ( \"No each command found.\" ) ; \n} \nif ( 1 >= lastCollection . size ( ) ) { \nthrow new DeleteRowException ( \"Cannot delete the last record in the group.\" ) ; \n} \nCommandUtility . deleteObjectInContext ( lastCollection , eachCommand , lastCollectionIndex , dataContext ) ; \nConfigRangeAttrs currentRangeAttrs = configBuildRef . getShiftMap ( ) . get ( fullName ) ; \nif ( currentRangeAttrs == null ) { \nthrow new DeleteRowException ( \"Cannot find delete range.\" ) ; \n} \nint startRow = currentRangeAttrs . getFirstRowIndex ( ) ; \nint length = currentRangeAttrs . getFinalLength ( ) ; \nint endRow = startRow + length - 1 ; \nList < String > removeFullNameList = findRemoveFullNameList ( configBuildRef . getSheet ( ) , startRow , endRow ) ; \nremoveRangesFromShiftMap ( configBuildRef . getShiftMap ( ) , removeFullNameList ) ; \nString var = eachCommand . getVar ( ) ; \nCommandUtility . removeRowsInSheet ( configBuildRef . getSheet ( ) , startRow , endRow , configBuildRef . getCachedCells ( ) ) ; \nCommandUtility . removeRowsInBody ( sheetConfig , bodyRows , startRow , endRow ) ; \nMap < String , String > changeMap = new TreeMap < > ( ) ; \nConfigurationUtility . changeIndexNumberInHiddenColumn ( configBuildRef , startRow , fullName , changeMap , - 1 ) ; \nConfigurationUtility . changeIndexNumberInShiftMap ( configBuildRef . getShiftMap ( ) , changeMap ) ; \nConfigurationUtility . reBuildUpperLevelFormula ( configBuildRef , fullName ) ; \nConfigurationUtility . changeUpperLevelFinalLength ( configBuildRef . getShiftMap ( ) , fullName , - length ) ; \ndataContext . remove ( var ) ; \nreturn length ; \n} \n} \n"}
{"8606": "public class CommandUtility { \nprivate static List < String > findRemoveFullNameList ( final Sheet sheet , final int startRow , final int endRow ) { \nList < String > list = new ArrayList < > ( ) ; \nfor ( int rowIndex = startRow ; \nendRow >= rowIndex ; \nrowIndex ++ ) { \nString fullName = ConfigurationUtility . getFullNameFromRow ( sheet . getRow ( rowIndex ) ) ; \nif ( ! list . contains ( fullName ) ) { \nlist . add ( fullName ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"8611": "public class CommandUtility { \npublic static void indexCommandRange ( final ConfigRange sourceConfigRange , final Map < String , Command > indexMap ) { \nif ( sourceConfigRange . getCommandList ( ) != null ) { \nfor ( int i = 0 ; \nsourceConfigRange . getCommandList ( ) . size ( ) > i ; \ni ++ ) { \nCommand command = sourceConfigRange . getCommandList ( ) . get ( i ) ; \nindexMap . put ( command . getCommandName ( ) , command ) ; \ncommand . getConfigRange ( ) . indexCommandRange ( indexMap ) ; \n} \n} \n} \n} \n"}
{"8613": "public class CommandUtility { \npublic static void insertEachTemplate ( final ConfigRange sourceConfigRange , final ConfigBuildRef configBuildRef , final int index , final int insertPosition , final RowsMapping unitRowsMapping ) { \nint srcStartRow = sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; \nint srcEndRow = sourceConfigRange . getLastRowPlusAddr ( ) . getRow ( ) - 1 ; \nSheet sheet = configBuildRef . getSheet ( ) ; \nWorkbook wb = sheet . getWorkbook ( ) ; \nString copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; \nif ( TieConstants . EXCEL_SHEET_NAME_LIMIT < copyName . length ( ) ) { \ncopyName = copyName . substring ( 0 , TieConstants . EXCEL_SHEET_NAME_LIMIT ) ; \n} \nSheet srcSheet = wb . getSheet ( copyName ) ; \nif ( 0 < index ) { \nCellUtility . copyRows ( srcSheet , sheet , srcStartRow , srcEndRow , insertPosition , false , true ) ; \n} \nfor ( int rowIndex = srcStartRow ; \nsrcEndRow >= rowIndex ; \nrowIndex ++ ) { \nif ( configBuildRef . getWatchList ( ) . contains ( rowIndex ) && ( ConfigurationUtility . isStaticRow ( sourceConfigRange , rowIndex ) ) ) { \nunitRowsMapping . addRow ( rowIndex , sheet . getRow ( insertPosition + rowIndex - srcStartRow ) ) ; \n} \n} \n} \n} \n"}
{"8619": "public class CommandUtility { \npublic static void removeRowsInSheet ( final Sheet sheet , final int rowIndexStart , final int rowIndexEnd , final Map < Cell , String > cachedMap ) { \nfor ( int irow = rowIndexStart ; \nrowIndexEnd >= irow ; \nirow ++ ) { \nremoveCachedCellForRow ( sheet , irow , cachedMap ) ; \n} \nint irows = rowIndexEnd - rowIndexStart + 1 ; \nif ( ( 1 > irows ) || ( 0 > rowIndexStart ) ) { \nreturn ; \n} \nint lastRowNum = sheet . getLastRowNum ( ) ; \nif ( lastRowNum > rowIndexEnd ) { \nsheet . shiftRows ( rowIndexEnd + 1 , lastRowNum , - irows ) ; \n} \nif ( rowIndexEnd == lastRowNum ) { \nfor ( int i = rowIndexEnd ; \nrowIndexStart <= i ; \ni -- ) { \nremoveSingleRowInSheet ( sheet , rowIndexStart ) ; \n} \n} \n} \n} \n"}
{"8622": "public class CommandUtility { \npublic static void removeRowsInBody ( final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows , final int rowIndexStart , final int rowIndexEnd ) { \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nif ( ( rowIndexStart > rowIndexEnd ) || ( top > rowIndexStart ) ) { \nreturn ; \n} \nint irows = rowIndexEnd - rowIndexStart + 1 ; \nfor ( int rowIndex = rowIndexEnd ; \nrowIndexStart <= rowIndex ; \nrowIndex -- ) { \nbodyRows . remove ( rowIndex - top ) ; \n} \nfor ( int irow = rowIndexStart - top ; \nbodyRows . size ( ) > irow ; \nirow ++ ) { \nFacesRow facesrow = bodyRows . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) - irows ) ; \n} \n} \n} \n"}
{"8635": "public class CellUtility { \npublic static void copyRows ( final Sheet srcSheet , final Sheet destSheet , final int srcRowStart , final int srcRowEnd , final int destRow , final boolean checkLock , final boolean setHiddenColumn ) { \nint length = srcRowEnd - srcRowStart + 1 ; \nif ( 0 >= length ) { \nreturn ; \n} \ndestSheet . shiftRows ( destRow , destSheet . getLastRowNum ( ) , length , true , false ) ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \ncopySingleRow ( srcSheet , destSheet , srcRowStart + i , destRow + i , checkLock , setHiddenColumn ) ; \n} \nfor ( int i = 0 ; \nsrcSheet . getNumMergedRegions ( ) > i ; \ni ++ ) { \nCellRangeAddress cellRangeAddress = srcSheet . getMergedRegion ( i ) ; \nif ( ( srcRowStart <= cellRangeAddress . getFirstRow ( ) ) && ( srcRowEnd >= cellRangeAddress . getLastRow ( ) ) ) { \nint targetRowFrom = cellRangeAddress . getFirstRow ( ) - srcRowStart + destRow ; \nint targetRowTo = cellRangeAddress . getLastRow ( ) - srcRowStart + destRow ; \nCellRangeAddress newCellRangeAddress = new CellRangeAddress ( targetRowFrom , targetRowTo , cellRangeAddress . getFirstColumn ( ) , cellRangeAddress . getLastColumn ( ) ) ; \ndestSheet . addMergedRegion ( newCellRangeAddress ) ; \n} \n} \n} \n} \n"}
{"8636": "public class CellUtility { \nprivate static void copySingleRow ( final Sheet srcSheet , final Sheet destSheet , final int sourceRowNum , final int destinationRowNum , final boolean checkLock , final boolean setHiddenColumn ) { \nRow newRow = destSheet . getRow ( destinationRowNum ) ; \nRow sourceRow = srcSheet . getRow ( sourceRowNum ) ; \nif ( newRow == null ) { \nnewRow = destSheet . createRow ( destinationRowNum ) ; \n} \nnewRow . setHeight ( sourceRow . getHeight ( ) ) ; \nfor ( int i = 0 ; \nsourceRow . getLastCellNum ( ) > i ; \ni ++ ) { \ncopyCell ( destSheet , sourceRow , newRow , i , checkLock ) ; \n} \nif ( setHiddenColumn ) { \nConfigurationUtility . setOriginalRowNumInHiddenColumn ( newRow , sourceRow . getRowNum ( ) ) ; \n} \nreturn ; \n} \n} \n"}
{"8649": "public class CellUtility { \npublic static int getInitRowsFromConfig ( final SheetConfiguration sheetConfig ) { \nint initRows = 1 ; \nif ( \"Repeat\" . equalsIgnoreCase ( sheetConfig . getFormBodyType ( ) ) ) { \ninitRows = sheetConfig . getBodyInitialRows ( ) ; \nif ( 1 > initRows ) { \ninitRows = 1 ; \n} \n} \nreturn initRows ; \n} \n} \n"}
{"8655": "public class TieWebSheetBeanCurrent { \npublic final String getCurrentDataContextName ( ) { \nif ( currentDataContextName == null ) { \nStringBuilder sb = new StringBuilder ( ) ; \nList < String > list = this . getCurrentDataContextNameList ( ) ; \nfor ( int i = 0 ; \nlist . size ( ) > i ; \ni ++ ) { \nif ( 0 < i ) { \nsb . append ( \":\" + list . get ( i ) ) ; \n} \nelse { \nsb . append ( list . get ( i ) ) ; \n} \n} \nthis . setCurrentDataContextName ( sb . toString ( ) ) ; \n} \nreturn currentDataContextName ; \n} \n} \n"}
{"8666": "public class ChartUtility { \npublic static void initXSSFAnchorsMap ( final XSSFWorkbook wb , final ChartsData charsData ) { \nMap < String , ClientAnchor > anchortMap = charsData . getChartAnchorsMap ( ) ; \nMap < String , String > positionMap = charsData . getChartPositionMap ( ) ; \nanchortMap . clear ( ) ; \npositionMap . clear ( ) ; \nfor ( int i = 0 ; \nwb . getNumberOfSheets ( ) > i ; \ni ++ ) { \ninitXSSFAnchorsMapForSheet ( anchortMap , positionMap , wb . getSheetAt ( i ) ) ; \n} \n} \n} \n"}
{"8667": "public class ChartUtility { \nprivate static void initXSSFAnchorsMapForSheet ( final Map < String , ClientAnchor > anchortMap , final Map < String , String > positionMap , final XSSFSheet sheet ) { \nXSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; \nCTDrawing ctDrawing = drawing . getCTDrawing ( ) ; \nif ( 0 >= ctDrawing . sizeOfTwoCellAnchorArray ( ) ) { \nreturn ; \n} \nList < CTTwoCellAnchor > alist = ctDrawing . getTwoCellAnchorList ( ) ; \nfor ( int j = 0 ; \nalist . size ( ) > j ; \nj ++ ) { \nCTTwoCellAnchor ctanchor = alist . get ( j ) ; \nString singleChartId = getAnchorAssociateChartId ( ctanchor ) ; \nif ( singleChartId != null ) { \nString chartId = sheet . getSheetName ( ) + \"!\" + singleChartId ; \nint dx1 = ( int ) ctanchor . getFrom ( ) . getColOff ( ) ; \nint dy1 = ( int ) ctanchor . getFrom ( ) . getRowOff ( ) ; \nint dx2 = ( int ) ctanchor . getTo ( ) . getColOff ( ) ; \nint dy2 = ( int ) ctanchor . getTo ( ) . getRowOff ( ) ; \nint col1 = ctanchor . getFrom ( ) . getCol ( ) ; \nint row1 = ctanchor . getFrom ( ) . getRow ( ) ; \nint col2 = ctanchor . getTo ( ) . getCol ( ) ; \nint row2 = ctanchor . getTo ( ) . getRow ( ) ; \nanchortMap . put ( chartId , new XSSFClientAnchor ( dx1 , dy1 , dx2 , dy2 , col1 , row1 , col2 , row2 ) ) ; \npositionMap . put ( WebSheetUtility . getFullCellRefName ( sheet . getSheetName ( ) , row1 , col1 ) , chartId ) ; \n} \n} \n} \n} \n"}
{"8668": "public class ChartUtility { \nprivate static String getAnchorAssociateChartId ( final CTTwoCellAnchor ctanchor ) { \nif ( ctanchor . getGraphicFrame ( ) == null ) { \nreturn null ; \n} \nNode parentNode = ctanchor . getGraphicFrame ( ) . getGraphic ( ) . getGraphicData ( ) . getDomNode ( ) ; \nNodeList childNodes = parentNode . getChildNodes ( ) ; \nfor ( int i = 0 ; \nchildNodes . getLength ( ) > i ; \ni ++ ) { \nNode childNode = childNodes . item ( i ) ; \nif ( ( childNode != null ) && ( \"c:chart\" . equalsIgnoreCase ( childNode . getNodeName ( ) ) ) && ( childNode . hasAttributes ( ) ) ) { \nString rId = getChartIdFromChildNodeAttributes ( childNode . getAttributes ( ) ) ; \nif ( rId != null ) { \nreturn rId ; \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"8669": "public class ChartUtility { \nprivate static String getChartIdFromChildNodeAttributes ( final NamedNodeMap attrs ) { \nfor ( int j = 0 ; \nattrs . getLength ( ) > j ; \nj ++ ) { \nAttr attribute = ( Attr ) attrs . item ( j ) ; \nif ( \"r:id\" . equalsIgnoreCase ( attribute . getName ( ) ) ) { \nreturn attribute . getValue ( ) ; \n} \n} \nreturn null ; \n} \n} \n"}
{"8675": "public class CellHelper { \npublic final void restoreDataContext ( final String fullName ) { \nString [ ] parts = fullName . split ( \":\" ) ; \nif ( ! isNeedRestore ( fullName , parts ) ) { \nreturn ; \n} \nboolean stopSkip = false ; \nList < String > list = parent . getCurrent ( ) . getCurrentDataContextNameList ( ) ; \nint listSize = list . size ( ) ; \nfor ( int i = 0 ; \nparts . length > i ; \ni ++ ) { \nString part = parts [ i ] ; \nboolean skip = false ; \nif ( ( ! stopSkip ) && ( listSize > i ) ) { \nString listPart = list . get ( i ) ; \nif ( part . equalsIgnoreCase ( listPart ) ) { \nskip = true ; \n} \n} \nif ( ! skip ) { \nstopSkip = true ; \nstartRestoreDataContext ( part ) ; \n} \n} \nif ( stopSkip ) { \nparent . getCurrent ( ) . setCurrentDataContextName ( fullName ) ; \n} \nreturn ; \n} \n} \n"}
{"8677": "public class CellHelper { \nprivate boolean isNeedRestore ( final String fullName , final String [ ] parts ) { \nif ( fullName == null ) { \nreturn false ; \n} \nif ( ( parent . getCurrent ( ) . getCurrentDataContextName ( ) != null ) && ( parent . getCurrent ( ) . getCurrentDataContextName ( ) . toLowerCase ( ) . startsWith ( fullName . toLowerCase ( ) ) ) ) { \nreturn false ; \n} \nreturn ( ( parts != null ) && ( 1 < parts . length ) ) ; \n} \n} \n"}
{"8681": "public class ConfigRange { \npublic final void setLastRowPlusRef ( final Sheet sheet , final int rightCol , final int lastRow , final boolean alsoSetAddr ) { \nif ( ( 0 <= lastRow ) && ( sheet != null ) && ( 0 <= rightCol ) ) { \nRow row = sheet . getRow ( lastRow + 1 ) ; \nif ( row == null ) { \nrow = sheet . createRow ( lastRow + 1 ) ; \n} \nCell cell = row . getCell ( rightCol ) ; \nif ( cell == null ) { \ncell = row . getCell ( rightCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \nthis . attrs . setLastCellCreated ( true ) ; \n} \nelse { \nthis . attrs . setLastCellCreated ( false ) ; \n} \nthis . attrs . setLastRowPlusRef ( cell ) ; \nif ( alsoSetAddr ) { \nthis . setLastRowPlusAddr ( new SerialCellAddress ( cell ) ) ; \n} \n} \nelse { \nthis . attrs . setLastRowPlusRef ( null ) ; \nif ( alsoSetAddr ) { \nthis . attrs . setLastRowPlusAddr ( null ) ; \n} \n} \n} \n} \n"}
{"8683": "public class ConfigRange { \nprivate void buildSingleCell ( final Cell cell , final Map < String , Object > context , final ConfigBuildRef configBuildRef , final ShiftFormulaRef shiftFormulaRef ) { \ntry { \nCommandUtility . evaluate ( context , cell , configBuildRef . getEngine ( ) ) ; \nif ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { \nString originFormula = cell . getCellFormula ( ) ; \nshiftFormulaRef . setFormulaChanged ( 0 ) ; \nConfigurationUtility . buildCellFormulaForShiftedRows ( configBuildRef . getSheet ( ) , configBuildRef . getWbWrapper ( ) , shiftFormulaRef , cell , cell . getCellFormula ( ) ) ; \nif ( 0 < shiftFormulaRef . getFormulaChanged ( ) ) { \nconfigBuildRef . getCachedCells ( ) . put ( cell , originFormula ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"build cell ( row = \" + cell . getRowIndex ( ) + \" column = \" + cell . getColumnIndex ( ) + \" error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \n"}
{"8685": "public class ChartData { \npublic final void buildCategoryList ( final CTAxDataSource ctAxDs ) { \nList < ParsedCell > cells = new ArrayList < > ( ) ; \ntry { \nString fullRangeName = ctAxDs . getStrRef ( ) . getF ( ) ; \nString sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; \nCellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; \nfor ( int row = region . getFirstRow ( ) ; \nregion . getLastRow ( ) >= row ; \nrow ++ ) { \nfor ( int col = region . getFirstColumn ( ) ; \nregion . getLastColumn ( ) >= col ; \ncol ++ ) { \ncells . add ( new ParsedCell ( sheetName , row , col ) ) ; \n} \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"failed in buildCategoryList\" , ex ) ; \n} \nthis . setCategoryList ( cells ) ; \n} \n} \n"}
{"8686": "public class ChartData { \n@ SuppressWarnings ( \"rawtypes\" ) public final void buildSeriesList ( final List bsers , final ThemesTable themeTable , final ChartObject ctObj ) { \nList < ChartSeries > lseriesList = new ArrayList < > ( ) ; \ntry { \nfor ( int index = 0 ; \nbsers . size ( ) > index ; \nindex ++ ) { \nObject ctObjSer = bsers . get ( index ) ; \nChartSeries ctSer = buildChartSeriesInList ( themeTable , ctObj , ctObjSer , index ) ; \nlseriesList . add ( ctSer ) ; \n} \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . FINE , \"failed in buildSerialList\" , ex ) ; \n} \nthis . setSeriesList ( lseriesList ) ; \n} \n} \n"}
{"8687": "public class ChartData { \nprivate ChartSeries buildChartSeriesInList ( final ThemesTable themeTable , final ChartObject ctObj , final Object ctObjSer , final int index ) { \nChartSeries ctSer = new ChartSeries ( ) ; \nctSer . setSeriesLabel ( new ParsedCell ( ctObj . getSeriesLabelFromCTSer ( ctObjSer ) ) ) ; \nctSer . setSeriesColor ( ColorUtility . geColorFromSpPr ( index , ctObj . getShapePropertiesFromCTSer ( ctObjSer ) , themeTable , ctObj . isLineColor ( ) ) ) ; \nList < ParsedCell > cells = new ArrayList < > ( ) ; \nString fullRangeName = ( ctObj . getCTNumDataSourceFromCTSer ( ctObjSer ) ) . getNumRef ( ) . getF ( ) ; \nString sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; \nCellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; \nfor ( int row = region . getFirstRow ( ) ; \nregion . getLastRow ( ) >= row ; \nrow ++ ) { \nfor ( int col = region . getFirstColumn ( ) ; \nregion . getLastColumn ( ) >= col ; \ncol ++ ) { \ncells . add ( new ParsedCell ( sheetName , row , col ) ) ; \n} \n} \nctSer . setValueList ( cells ) ; \nctSer . setValueColorList ( getColorListFromDPTWithValueList ( ctObj . getDPtListFromCTSer ( ctObjSer ) , cells , themeTable , ctObj ) ) ; \nreturn ctSer ; \n} \n} \n"}
{"8688": "public class ChartData { \nprivate List < XColor > getColorListFromDPTWithValueList ( final List < CTDPt > dptList , final List < ParsedCell > cells , final ThemesTable themeTable , final ChartObject ctObj ) { \nList < XColor > colors = new ArrayList < > ( ) ; \nif ( ( dptList != null ) && ( cells != null ) ) { \nfor ( int index = 0 ; \ncells . size ( ) > index ; \nindex ++ ) { \nCTDPt dpt = getDPtFromListWithIndex ( dptList , index ) ; \nCTShapeProperties ctSpPr = null ; \nif ( dpt != null ) { \nctSpPr = dpt . getSpPr ( ) ; \n} \ncolors . add ( ColorUtility . geColorFromSpPr ( index , ctSpPr , themeTable , ctObj . isLineColor ( ) ) ) ; \n} \n} \nreturn colors ; \n} \n} \n"}
{"8692": "public class PicturesUtility { \nprivate static void getXSSFPictruesMap ( final XSSFWorkbook wb , final Map < String , Picture > picMap ) { \npicMap . clear ( ) ; \nList < XSSFPictureData > pictures = wb . getAllPictures ( ) ; \nif ( pictures . isEmpty ( ) ) { \nreturn ; \n} \nfor ( int i = 0 ; \nwb . getNumberOfSheets ( ) > i ; \ni ++ ) { \nXSSFSheet sheet = wb . getSheetAt ( i ) ; \nfor ( POIXMLDocumentPart dr : sheet . getRelations ( ) ) { \ntry { \nindexPictureInMap ( picMap , sheet , dr ) ; \n} \ncatch ( Exception ex ) { \nLOG . log ( Level . SEVERE , \"Load Picture error = \" + ex . getLocalizedMessage ( ) , ex ) ; \n} \n} \n} \nreturn ; \n} \n} \n"}
{"8696": "public class PicturesUtility { \npublic static AnchorSize getAnchorSize ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final ClientAnchor anchor ) { \nif ( ! ( sheet1 instanceof XSSFSheet ) ) { \nreturn null ; \n} \ndouble picWidth = 0.0 ; \ndouble picHeight = 0.0 ; \nint left = anchor . getDx1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint top = ( int ) ( ( double ) anchor . getDy1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \nint right = anchor . getDx2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; \nint bottom = ( int ) ( ( double ) anchor . getDy2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; \ndouble cellWidth = 0.0 ; \ndouble cellHeight = 0.0 ; \nif ( ( cell != null ) && ( fcell != null ) ) { \nfor ( int col = cell . getColumnIndex ( ) ; \ncell . getColumnIndex ( ) + fcell . getColspan ( ) > col ; \ncol ++ ) { \ncellWidth += sheet1 . getColumnWidthInPixels ( col ) ; \n} \ndouble lastCellWidth = sheet1 . getColumnWidthInPixels ( cell . getColumnIndex ( ) + fcell . getColspan ( ) - 1 ) ; \nfor ( int rowIndex = cell . getRowIndex ( ) ; \ncell . getRowIndex ( ) + fcell . getRowspan ( ) > rowIndex ; \nrowIndex ++ ) { \ncellHeight += WebSheetUtility . pointsToPixels ( sheet1 . getRow ( rowIndex ) . getHeightInPoints ( ) ) ; \n} \ndouble lastCellHeight = WebSheetUtility . pointsToPixels ( sheet1 . getRow ( cell . getRowIndex ( ) + fcell . getRowspan ( ) - 1 ) . getHeightInPoints ( ) ) ; \npicWidth = cellWidth - lastCellWidth + right - left ; \npicHeight = cellHeight - lastCellHeight + bottom - top ; \n} \nelse { \nfor ( short col = anchor . getCol1 ( ) ; \nanchor . getCol2 ( ) > col ; \ncol ++ ) { \npicWidth += sheet1 . getColumnWidthInPixels ( col ) ; \n} \nfor ( int rowindex = anchor . getRow1 ( ) ; \nanchor . getRow2 ( ) > rowindex ; \nrowindex ++ ) { \nRow row = sheet1 . getRow ( rowindex ) ; \nif ( row != null ) { \npicHeight += WebSheetUtility . pointsToPixels ( row . getHeightInPoints ( ) ) ; \n} \n} \n} \nreturn new AnchorSize ( left , top , ( int ) picWidth , ( int ) picHeight , cellWidth , cellHeight ) ; \n} \n} \n"}
{"8701": "public class CellStyleUtility { \npublic static String getCellFontStyle ( final Workbook wb , final Cell poiCell ) { \nCellStyle cellStyle = poiCell . getCellStyle ( ) ; \nStringBuilder webStyle = new StringBuilder ( ) ; \nif ( cellStyle != null ) { \nshort fontIdx = cellStyle . getFontIndex ( ) ; \nFont font = wb . getFontAt ( fontIdx ) ; \nif ( font . getItalic ( ) ) { \nwebStyle . append ( \"font-style: italic;\" ) ; \n} \nif ( font . getBold ( ) ) { \nwebStyle . append ( \"font-weight: bold;\" ) ; \n} \nwebStyle . append ( \"font-size: \" + font . getFontHeightInPoints ( ) + \"pt;\" ) ; \nString decoration = getCellFontDecoration ( font ) ; \nif ( 0 < decoration . length ( ) ) { \nwebStyle . append ( \"text-decoration:\" + decoration + \";\" ) ; \n} \nwebStyle . append ( getCellFontColor ( font ) ) ; \n} \nreturn webStyle . toString ( ) ; \n} \n} \n"}
{"8708": "public class CellStyleUtility { \npublic static int calcTotalHeight ( final Sheet sheet1 , final int firstRow , final int lastRow , final int additionalHeight ) { \nint totalHeight = additionalHeight ; \nfor ( int i = firstRow ; \nlastRow >= i ; \ni ++ ) { \ntotalHeight += sheet1 . getRow ( i ) . getHeight ( ) ; \n} \nreturn totalHeight ; \n} \n} \n"}
{"8716": "public class FacesUtility { \npublic static String strJoin ( final short [ ] aArr , final String sSep ) { \nStringBuilder sbStr = new StringBuilder ( ) ; \nfor ( int i = 0 , il = aArr . length ; \nil > i ; \ni ++ ) { \nif ( 0 < i ) { \nsbStr . append ( sSep ) ; \n} \nsbStr . append ( aArr [ i ] ) ; \n} \nreturn sbStr . toString ( ) ; \n} \n} \n"}
{"8717": "public class FacesUtility { \npublic static double round ( final double value , final int places ) { \nif ( 0 > places ) { \nthrow new IllegalArgumentException ( ) ; \n} \nBigDecimal bd = BigDecimal . valueOf ( value ) ; \nbd = bd . setScale ( places , RoundingMode . HALF_UP ) ; \nreturn bd . doubleValue ( ) ; \n} \n} \n"}
{"8718": "public class TieWebSheetView { \npublic String getTabType ( ) { \nint sheetId = webFormTabView . getActiveIndex ( ) ; \nif ( ( 0 <= sheetId ) && ( tabs != null ) ) { \nif ( tabs . size ( ) <= sheetId ) { \nsheetId = 0 ; \n} \ntabType = tabs . get ( sheetId ) . type . toLowerCase ( ) ; \n} \nelse { \ntabType = TieConstants . TAB_TYPE_NONE ; \n} \nreturn tabType ; \n} \n} \n"}
{"8719": "public class TieWebSheetView { \npublic String getTabStyle ( ) { \nString tabStyle = TieConstants . TAB_STYLE_VISIBLE ; \nint sheetId = webFormTabView . getActiveIndex ( ) ; \nif ( ( 0 <= sheetId ) && ( tabs . size ( ) > sheetId ) ) { \ntabStyle = TieConstants . TAB_STYLE_INVISIBLE ; \n} \nreturn tabStyle ; \n} \n} \n"}
{"8724": "public class FormCommand { \nprivate List < Integer > buildFormWatchList ( final XSSFEvaluationWorkbook wbWrapper , final Sheet sheet ) { \nList < Integer > watchList = new ArrayList < > ( ) ; \nConfigRange cRange = this . getConfigRange ( ) ; \nList < ConfigCommand > commandList = cRange . getCommandList ( ) ; \nif ( commandList . isEmpty ( ) ) { \nreturn watchList ; \n} \nint lastStaticRow = commandList . get ( 0 ) . getTopRow ( ) - 1 ; \nif ( 0 > lastStaticRow ) { \nlastStaticRow = this . getTopRow ( ) ; \n} \nint sheetIndex = sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ; \nfor ( int i = this . getTopRow ( ) ; \nthis . getLastRow ( ) >= i ; \ni ++ ) { \nRow row = sheet . getRow ( i ) ; \nfor ( Cell cell : row ) { \nif ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { \nbuildWatchListForCell ( wbWrapper , sheetIndex , cell , watchList , lastStaticRow ) ; \n} \n} \n} \nreturn watchList ; \n} \n} \n"}
{"8725": "public class FormCommand { \nprivate void buildWatchListForCell ( final XSSFEvaluationWorkbook wbWrapper , final int sheetIndex , final Cell cell , final List < Integer > watchList , final int lastStaticRow ) { \nString formula = cell . getCellFormula ( ) ; \nPtg [ ] ptgs = FormulaParser . parse ( formula , wbWrapper , FormulaType . CELL , sheetIndex ) ; \nfor ( int k = 0 ; \nptgs . length > k ; \nk ++ ) { \nObject ptg = ptgs [ k ] ; \nint areaInt = ShiftFormulaUtility . getFirstSupportedRowNumFromPtg ( ptg ) ; \nif ( 0 <= areaInt ) { \naddToWatchList ( areaInt , lastStaticRow , watchList ) ; \n} \n} \ncell . setCellType ( CellType . STRING ) ; \ncell . setCellValue ( TieConstants . USER_FORMULA_PREFIX + formula + TieConstants . USER_FORMULA_SUFFIX ) ; \n} \n} \n"}
{"8726": "public class FormCommand { \nprivate void addToWatchList ( final int addRow , final int lastStaticRow , final List < Integer > watchList ) { \nif ( ( lastStaticRow < addRow ) && ! ( watchList . contains ( addRow ) ) ) { \nwatchList . add ( addRow ) ; \n} \n} \n} \n"}
{"8728": "public class ParserUtility { \npublic static void parseWidgetAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { \nif ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) { \nreturn ; \n} \nint widgetStart = newComment . indexOf ( TieConstants . METHOD_WIDGET_PREFIX ) ; \nint elStart = newComment . indexOf ( TieConstants . EL_START_BRACKET ) ; \nif ( ( 0 > widgetStart ) || ( elStart <= widgetStart ) ) { \nreturn ; \n} \nString type = newComment . substring ( widgetStart + TieConstants . METHOD_WIDGET_PREFIX . length ( ) , elStart ) ; \nString values = getStringBetweenBracket ( newComment ) ; \nif ( values == null ) { \nreturn ; \n} \nString key = getAttributeKeyInMapByCell ( cell ) ; \ncellAttributesMap . getCellInputType ( ) . put ( key , type ) ; \nList < CellFormAttributes > inputs = cellAttributesMap . getCellInputAttributes ( ) . get ( key ) ; \nif ( inputs == null ) { \ninputs = new ArrayList < > ( ) ; \ncellAttributesMap . getCellInputAttributes ( ) . put ( key , inputs ) ; \n} \nparseInputAttributes ( inputs , values ) ; \nparseSpecialAttributes ( key , type , inputs , cellAttributesMap ) ; \n} \n} \n"}
{"8731": "public class ParserUtility { \nprivate static int findPairBracketPosition ( final String str , final int startPos ) { \nint bracketNum = 0 ; \nfor ( int i = startPos ; \nstr . length ( ) > i ; \ni ++ ) { \nchar current = str . charAt ( i ) ; \nif ( current == TieConstants . EL_START_BRACKET ) { \nbracketNum ++ ; \n} \nelse if ( current == TieConstants . EL_END ) { \nbracketNum -- ; \nif ( 0 >= bracketNum ) { \nreturn i ; \n} \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8733": "public class ParserUtility { \npublic static void parseInputAttributes ( final List < CellFormAttributes > clist , final String controlAttrs ) { \nclist . clear ( ) ; \nif ( controlAttrs != null ) { \nString [ ] cattrs = controlAttrs . split ( TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; \nfor ( String cattr : cattrs ) { \nString [ ] details = splitByEualSign ( cattr ) ; \nif ( 1 < details . length ) { \nCellFormAttributes attr = new CellFormAttributes ( ) ; \nattr . setType ( details [ 0 ] . trim ( ) ) ; \nattr . setValue ( details [ 1 ] . replaceAll ( \"\\\"\" , \"\" ) ) ; \nclist . add ( attr ) ; \n} \n} \n} \n} \n} \n"}
{"8735": "public class ParserUtility { \nprivate static String [ ] splitByEualSign ( final String attrData ) { \nint attrNameEndIndex = attrData . indexOf ( '=' ) ; \nif ( 0 > attrNameEndIndex ) { \nreturn new String [ 0 ] ; \n} \nString attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; \nString attrValue = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; \nString [ ] rlist = new String [ 2 ] ; \nrlist [ 0 ] = attrName ; \nrlist [ 1 ] = attrValue ; \nreturn rlist ; \n} \n} \n"}
{"8738": "public class ParserUtility { \nprivate static void processSelectItemAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { \nif ( ( sAttr . selectValues == null ) || ( sAttr . selectValues . length != sAttr . selectLabels . length ) ) { \nsAttr . selectValues = sAttr . selectLabels ; \n} \nMap < String , String > smap = cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( key ) ; \nif ( smap == null ) { \nsmap = new LinkedHashMap < > ( ) ; \n} \nsmap . clear ( ) ; \nif ( sAttr . defaultSelectLabel != null ) { \nsmap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; \n} \nfor ( int i = 0 ; \nsAttr . selectLabels . length > i ; \ni ++ ) { \nsmap . put ( sAttr . selectLabels [ i ] , sAttr . selectValues [ i ] ) ; \n} \ncellAttributesMap . getCellSelectItemsAttributes ( ) . put ( key , smap ) ; \n} \n} \n"}
{"8741": "public class ParserUtility { \npublic static int findFirstNonCellNamePosition ( String input , int startPosition ) { \nchar c ; \nfor ( int i = startPosition ; \ninput . length ( ) > i ; \ni ++ ) { \nc = input . charAt ( i ) ; \nif ( c != '$' && ! Character . isLetterOrDigit ( c ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8743": "public class WebSheetUtility { \npublic static String getExcelColumnName ( final int pnumber ) { \nStringBuilder converted = new StringBuilder ( ) ; \nint number = pnumber ; \nwhile ( 0 <= number ) { \nint remainder = number % TieConstants . EXCEL_LETTER_NUMBERS ; \nconverted . insert ( 0 , ( char ) ( remainder + 'A' ) ) ; \nnumber = ( number / TieConstants . EXCEL_LETTER_NUMBERS ) - 1 ; \n} \nreturn converted . toString ( ) ; \n} \n} \n"}
{"8744": "public class WebSheetUtility { \npublic static int convertColToInt ( final String col ) { \nString name = col . toUpperCase ( ) ; \nint number = 0 ; \nint pow = 1 ; \nfor ( int i = name . length ( ) - 1 ; \n0 <= i ; \ni -- ) { \nnumber += ( name . charAt ( i ) - 'A' + 1 ) * pow ; \npow *= TieConstants . EXCEL_LETTER_NUMBERS ; \n} \nreturn number - 1 ; \n} \n} \n"}
{"8749": "public class WebSheetUtility { \npublic static boolean isNumeric ( final String str ) { \nString s = str ; \nif ( s . startsWith ( \"-\" ) ) { \ns = s . substring ( 1 ) ; \n} \nchar c ; \nint i ; \nint sLen = s . length ( ) ; \nShouldContinueParameter sPara = new ShouldContinueParameter ( false , false , 0 ) ; \nfor ( i = 0 ; \nsLen > i ; \ni ++ ) { \nc = s . charAt ( i ) ; \nif ( '0' > c || '9' < c ) { \nif ( ! shouldContinue ( c , sPara ) ) { \nreturn false ; \n} \n} \nelse { \nif ( sPara . isCommaHit ( ) ) { \nsPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; \n} \n} \n} \nreturn true ; \n} \n} \n"}
{"8753": "public class WebSheetUtility { \npublic static boolean insideRange ( final ConfigRange child , final ConfigRange parent ) { \nreturn ( ( 0 <= cellCompareTo ( child . getFirstRowRef ( ) , parent . getFirstRowRef ( ) ) ) && ( 0 >= cellCompareTo ( child . getLastRowPlusRef ( ) , parent . getLastRowPlusRef ( ) ) ) ) ; \n} \n} \n"}
{"8754": "public class WebSheetUtility { \npublic static void clearHiddenColumns ( final Sheet sheet ) { \nfor ( Row row : sheet ) { \nif ( TieConstants . MAX_COLUMNS_IN_SHEET < row . getLastCellNum ( ) ) { \ndeleteHiddenColumnsInRow ( row ) ; \n} \n} \n} \n} \n"}
{"8765": "public class ValidationHandler { \npublic final boolean validateCurrentPage ( ) { \nboolean allpass = true ; \nint top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nfor ( int irow = 0 ; \nparent . getBodyRows ( ) . size ( ) > irow ; \nirow ++ ) { \nif ( ! validateRowInCurrentPage ( irow + top , false ) ) { \nallpass = false ; \n} \n} \nreturn allpass ; \n} \n} \n"}
{"8767": "public class ValidationHandler { \nprivate boolean validateRow ( final int irow , final SheetConfiguration sheetConfig , boolean updateGui ) { \nboolean pass = true ; \nif ( sheetConfig == null ) { \nreturn pass ; \n} \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nList < FacesCell > cellRow = parent . getBodyRows ( ) . get ( irow - top ) . getCells ( ) ; \nfor ( int index = 0 ; \ncellRow . size ( ) > index ; \nindex ++ ) { \nFacesCell fcell = cellRow . get ( index ) ; \nif ( ( fcell != null ) && ( ! validateWithRowColInCurrentPage ( irow , fcell . getColumnIndex ( ) , updateGui ) ) ) { \npass = false ; \n} \n} \nreturn pass ; \n} \n} \n"}
{"8768": "public class ValidationHandler { \nprivate void refreshCachedCellsInCurrentPage ( final FacesContext facesContext , final String tblName ) { \nUIComponent s = facesContext . getViewRoot ( ) . findComponent ( tblName ) ; \nif ( s == null ) { \nreturn ; \n} \nDataTable webDataTable = ( DataTable ) s ; \nint first = webDataTable . getFirst ( ) ; \nint rowsToRender = webDataTable . getRowsToRender ( ) ; \nint rowCounts = webDataTable . getRowCount ( ) ; \nint top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; \nint left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; \nfor ( int i = first ; \n( first + rowsToRender ) >= i ; \ni ++ ) { \nif ( rowCounts > i ) { \nrefreshCachedCellsInRow ( tblName , top , left , i ) ; \n} \n} \n} \n} \n"}
{"8769": "public class ValidationHandler { \nprivate void refreshCachedCellsInRow ( final String tblName , final int top , final int left , final int i ) { \nFacesRow dataRow = parent . getBodyRows ( ) . get ( i ) ; \nint isize = dataRow . getCells ( ) . size ( ) ; \nfor ( int index = 0 ; \nisize > index ; \nindex ++ ) { \nFacesCell fcell = dataRow . getCells ( ) . get ( index ) ; \nCell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( i + top , index + left ) ; \nif ( poiCell != null ) { \nparent . getHelper ( ) . getWebSheetLoader ( ) . refreshCachedCell ( tblName , i , index , poiCell , fcell ) ; \n} \n} \n} \n} \n"}
{"8773": "public class WebSheetLoader { \nprivate void loadHeaderRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nint top = sheetConfig . getHeaderCellRange ( ) . getTopRow ( ) ; \nint bottom = sheetConfig . getHeaderCellRange ( ) . getBottomRow ( ) ; \nint left = sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nint totalWidth = CellStyleUtility . calcTotalWidth ( sheet1 , left , right , WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) + parent . getAddRowColumnWidth ( ) ) ) ; \nRangeBuildRef rangeBuildRef = new RangeBuildRef ( left , right , totalWidth , sheet1 ) ; \nif ( sheetConfig . isFixedWidthStyle ( ) ) { \nparent . setTableWidthStyle ( \"table-layout: fixed; width:\" + WebSheetUtility . widthUnits2Pixel ( totalWidth ) + \"px;\" ) ; \n} \nparent . setLineNumberColumnWidthStyle ( getWidthStyle ( WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) ) , totalWidth ) ) ; \nparent . setAddRowColumnWidthStyle ( \"width:\" + parent . getAddRowColumnWidth ( ) + \"px;\" ) ; \nparent . getHeaderRows ( ) . clear ( ) ; \nif ( 0 > top ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , true ) ) ; \nparent . setShowLineNumber ( true ) ; \n} \nelse { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , false ) ) ; \nfor ( int i = top ; \nbottom >= i ; \ni ++ ) { \nparent . getHeaderRows ( ) . add ( loadHeaderRowWithConfigurationTab ( sheetConfig , rangeBuildRef , i , cellRangeMap , skippedRegionCells ) ) ; \n} \nparent . setShowLineNumber ( false ) ; \n} \n} \n} \n"}
{"8774": "public class WebSheetLoader { \nprivate List < HeaderCell > loadHeaderRowWithoutConfigurationTab ( final RangeBuildRef rangeBuildRef , final boolean rendered ) { \nint firstCol = rangeBuildRef . getLeft ( ) ; \nint lastCol = rangeBuildRef . getRight ( ) ; \ndouble totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; \nSheet sheet1 = rangeBuildRef . getSheet ( ) ; \nList < HeaderCell > headercells = new ArrayList < > ( ) ; \nfor ( int i = firstCol ; \nlastCol >= i ; \ni ++ ) { \nif ( ! sheet1 . isColumnHidden ( i ) ) { \nString style = getHeaderColumnStyle ( parent . getWb ( ) , null , sheet1 . getColumnWidth ( i ) , totalWidth ) ; \nheadercells . add ( new HeaderCell ( \"1\" , \"1\" , style , style , WebSheetUtility . getExcelColumnName ( i ) , rendered , true ) ) ; \n} \n} \nfillToMaxColumns ( headercells ) ; \nreturn headercells ; \n} \n} \n"}
{"8775": "public class WebSheetLoader { \nprivate void fillToMaxColumns ( final List < HeaderCell > headercells ) { \nif ( parent . getMaxColCounts ( ) > headercells . size ( ) ) { \nint fills = parent . getMaxColCounts ( ) - headercells . size ( ) ; \nfor ( int s = 0 ; \nfills > s ; \ns ++ ) { \nheadercells . add ( new HeaderCell ( \"1\" , \"1\" , \"\" , \"\" , \"\" , false , false ) ) ; \n} \n} \n} \n} \n"}
{"8778": "public class WebSheetLoader { \nprivate List < HeaderCell > loadHeaderRowWithConfigurationTab ( final SheetConfiguration sheetConfig , final RangeBuildRef rangeBuildRef , final int currentRow , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nSheet sheet1 = rangeBuildRef . getSheet ( ) ; \nint left = rangeBuildRef . getLeft ( ) ; \nint right = rangeBuildRef . getRight ( ) ; \ndouble totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; \nRow row = sheet1 . getRow ( currentRow ) ; \nList < HeaderCell > headercells = new ArrayList < > ( ) ; \nfor ( int cindex = left ; \nright >= cindex ; \ncindex ++ ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , currentRow ) ; \nif ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { \nCell cell = null ; \nif ( row != null ) { \ncell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \n} \nint originRowIndex = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; \nif ( cell != null ) { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , originRowIndex , parent . getCellAttributesMap ( ) , null ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnStyle ( fcell . getColumnStyle ( ) + getColumnWidthStyle ( sheet1 , cellRangeMap , cellindex , cindex , totalWidth ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nheadercells . add ( new HeaderCell ( Integer . toString ( fcell . getRowspan ( ) ) , Integer . toString ( fcell . getColspan ( ) ) , fcell . getStyle ( ) , fcell . getColumnStyle ( ) , CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) , true , true ) ) ; \n} \n} \n} \nfillToMaxColumns ( headercells ) ; \nreturn headercells ; \n} \n} \n"}
{"8783": "public class WebSheetLoader { \npublic void refreshData ( ) { \nif ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) { \nreturn ; \n} \nfor ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { \nfor ( int irow = sheetConfig . getFormCommand ( ) . getTopRow ( ) ; \nsheetConfig . getFormCommand ( ) . getLastRow ( ) > irow ; \nirow ++ ) { \nrefreshDataForRow ( parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) . getRow ( irow ) ) ; \n} \n} \nparent . getCellHelper ( ) . reCalc ( ) ; \n} \n} \n"}
{"8786": "public class WebSheetLoader { \npublic final int findTabIndexWithName ( final String tabname ) { \nfor ( int i = 0 ; \nparent . getTabs ( ) . size ( ) > i ; \ni ++ ) { \nif ( parent . getTabs ( ) . get ( i ) . getTitle ( ) . equalsIgnoreCase ( tabname ) ) { \nreturn i ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"8792": "public class WebSheetLoader { \nprivate void loadBodyRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint bottom = CellUtility . getBodyBottomFromConfig ( sheetConfig ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nString sheetName = sheetConfig . getSheetName ( ) ; \nSheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; \nparent . getBodyRows ( ) . clear ( ) ; \nclearCache ( ) ; \nfor ( int i = top ; \nbottom >= i ; \ni ++ ) { \nparent . getBodyRows ( ) . add ( assembleFacesBodyRow ( i , sheet1 , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \n} \nsheetConfig . setBodyPopulated ( true ) ; \nparent . getCurrent ( ) . setCurrentTopRow ( top ) ; \nparent . getCurrent ( ) . setCurrentLeftColumn ( left ) ; \n} \n} \n"}
{"8793": "public class WebSheetLoader { \nprivate FacesRow assembleFacesBodyRow ( final int rowIndex , final Sheet sheet1 , final int left , final int right , final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { \nFacesRow facesRow = new FacesRow ( rowIndex ) ; \nRow row = sheet1 . getRow ( rowIndex ) ; \nsetupRowInfo ( facesRow , sheet1 , row , rowIndex , CommandUtility . isRowAllowAdd ( row , sheetConfig ) ) ; \nString saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; \nList < FacesCell > bodycells = new ArrayList < > ( ) ; \nfor ( int cindex = left ; \nright >= cindex ; \ncindex ++ ) { \nString cellindex = CellUtility . getCellIndexNumberKey ( cindex , rowIndex ) ; \nif ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { \nCell cell = null ; \nif ( row != null ) { \ncell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; \n} \nif ( cell != null ) { \nFacesCell fcell = new FacesCell ( ) ; \nCellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , facesRow . getOriginRowIndex ( ) , parent . getCellAttributesMap ( ) , saveAttrList ) ; \nparent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; \nCellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; \nfcell . setColumnIndex ( cindex ) ; \nbodycells . add ( fcell ) ; \naddCache ( cell ) ; \n} \nelse { \nbodycells . add ( null ) ; \n} \n} \nelse { \nbodycells . add ( null ) ; \n} \n} \nfacesRow . setCells ( bodycells ) ; \nreturn facesRow ; \n} \n} \n"}
{"8796": "public class WebSheetLoader { \nprivate void createDynamicColumns ( final String tabName ) { \nSheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nparent . getColumns ( ) . clear ( ) ; \nfor ( int i = left ; \nright >= i ; \ni ++ ) { \nparent . getColumns ( ) . add ( \"column\" + ( i - left ) ) ; \n} \n} \n} \n"}
{"8798": "public class WebSheetLoader { \nprivate void refreshBodyRowsInRange ( final int insertPosition , final int length , final Sheet sheet , final SheetConfiguration sheetConfig ) { \nMap < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet ) ; \nList < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet ) ; \nint top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; \nint left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; \nint right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; \nfor ( int irow = insertPosition ; \n( insertPosition + length ) > irow ; \nirow ++ ) { \nparent . getBodyRows ( ) . add ( irow - top , assembleFacesBodyRow ( irow , sheet , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; \n} \nfor ( int irow = insertPosition + length - top ; \nparent . getBodyRows ( ) . size ( ) > irow ; \nirow ++ ) { \nFacesRow facesrow = parent . getBodyRows ( ) . get ( irow ) ; \nfacesrow . setRowIndex ( facesrow . getRowIndex ( ) + length ) ; \n} \n} \n} \n"}
{"8801": "public class Utils { \npublic static < T > Constructor < T > commonConstructor ( Class < T > type ) throws NoMethodForDependency { \nConstructor < ? > [ ] cs = type . getDeclaredConstructors ( ) ; \nif ( cs . length == 0 ) throw new NoMethodForDependency ( raw ( type ) ) ; \nConstructor < ? > mostParamsConstructor = null ; \nfor ( Constructor < ? > c : cs ) { \nif ( ! arrayContains ( c . getParameterTypes ( ) , type , ( a , b ) -> a == b ) && ( mostParamsConstructor == null || ( moreVisible ( c , mostParamsConstructor ) == c && ( moreVisible ( mostParamsConstructor , c ) == c || mostParamsConstructor . getParameterCount ( ) < c . getParameterCount ( ) ) ) ) ) { \nmostParamsConstructor = c ; \n} \n} \nif ( mostParamsConstructor == null ) throw new NoMethodForDependency ( raw ( type ) ) ; \n@ SuppressWarnings ( \"unchecked\" ) Constructor < T > c = ( Constructor < T > ) mostParamsConstructor ; \nreturn c ; \n} \n} \n"}
{"8822": "public class PoolableBufferedInputStream { \n@ Override public synchronized int read ( ) throws IOException { \nbyte [ ] localBuf = buf ; \nfinal InputStream localIn = in ; \nif ( localBuf == null || localIn == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \nif ( count <= pos && fillbuf ( localIn , localBuf ) == - 1 ) { \nreturn - 1 ; \n} \nif ( localBuf != buf ) { \nlocalBuf = buf ; \nif ( localBuf == null ) { \nthrow new IOException ( \"Stream is closed\" ) ; \n} \n} \nfinal int mask = 0xFF ; \nif ( 0 < count - pos ) { \nreturn localBuf [ pos ++ ] & mask ; \n} \nreturn - 1 ; \n} \n} \n"}
{"8830": "public class Part { \npublic static void sendParts ( final OutputStream out , final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( parts == null ) { \nthrow new IllegalArgumentException ( \"Parts may not be null\" ) ; \n} \nif ( partBoundary == null || partBoundary . length == 0 ) { \nthrow new IllegalArgumentException ( \"partBoundary may not be empty\" ) ; \n} \nfor ( int i = 0 ; \nparts . length > i ; \ni ++ ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nparts [ i ] . send ( out ) ; \n} \nout . write ( EXTRA_BYTES ) ; \nout . write ( partBoundary ) ; \nout . write ( EXTRA_BYTES ) ; \nout . write ( CRLF_BYTES ) ; \n} \n} \n"}
{"8831": "public class Part { \npublic static long getLengthOfParts ( final Part [ ] parts , final byte [ ] partBoundary ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"getLengthOfParts(Parts[])\" ) ; \n} \nif ( parts == null ) { \nthrow new IllegalArgumentException ( \"Parts may not be null\" ) ; \n} \nlong total = 0 ; \nfor ( int i = 0 ; \nparts . length > i ; \ni ++ ) { \nparts [ i ] . setPartBoundary ( partBoundary ) ; \nfinal long l = parts [ i ] . length ( ) ; \nif ( 0 > l ) { \nreturn - 1 ; \n} \ntotal += l ; \n} \ntotal += EXTRA_BYTES . length ; \ntotal += partBoundary . length ; \ntotal += EXTRA_BYTES . length ; \ntotal += CRLF_BYTES . length ; \nreturn total ; \n} \n} \n"}
{"8839": "public class FilePart { \n@ Override protected void sendData ( final OutputStream out ) throws IOException { \nif ( DEBUG ) { \nLog . v ( TAG , \"enter sendData(OutputStream out)\" ) ; \n} \nif ( lengthOfData ( ) == 0 ) { \nif ( DEBUG ) { \nLog . d ( TAG , \"No data to send.\" ) ; \n} \nreturn ; \n} \nfinal int size = 4096 ; \nfinal byte [ ] tmp = new byte [ size ] ; \nfinal InputStream instream = source . createInputStream ( ) ; \ntry { \nint len ; \nwhile ( 0 <= ( len = instream . read ( tmp ) ) ) { \nout . write ( tmp , 0 , len ) ; \n} \n} \nfinally { \ninstream . close ( ) ; \n} \n} \n} \n"}
{"8875": "public class CacheControlUrlConnection { \nprivate void connectWithWorkaround ( ) throws IOException { \nif ( Build . VERSION_CODES . GINGERBREAD_MR1 < Build . VERSION . SDK_INT ) { \nsuper . connect ( ) ; \nreturn ; \n} \nURLConnection coreConnection = UrlConnectionWrapper . unwrap ( getCore ( ) ) ; \nif ( coreConnection instanceof HttpsURLConnection ) { \ntry { \nsuper . connect ( ) ; \n} \ncatch ( NullPointerException e ) { \n} \n} \nelse { \nsuper . connect ( ) ; \n} \n} \n} \n"}
{"8876": "public class Md5 { \npublic static String getMd5 ( final String text ) { \ntry { \nfinal MessageDigest md = MessageDigest . getInstance ( \"MD5\" ) ; \nfinal byte [ ] utf8Bytes = text . getBytes ( UTF_8_NAME ) ; \nmd . update ( utf8Bytes , 0 , utf8Bytes . length ) ; \nfinal byte [ ] md5hash = md . digest ( ) ; \nfinal int radix = 16 ; \nfinal int length = 32 ; \nfinal StringBuilder result = new StringBuilder ( length ) . append ( new BigInteger ( 1 , md5hash ) . toString ( radix ) ) ; \nfinal int zeroBeginLen = length - result . length ( ) ; \nif ( 0 < zeroBeginLen ) { \nfinal char [ ] zeroBegin = new char [ zeroBeginLen ] ; \nArrays . fill ( zeroBegin , Character . forDigit ( 0 , radix ) ) ; \nresult . insert ( 0 , zeroBegin ) ; \n} \nreturn result . toString ( ) ; \n} \ncatch ( final NoSuchAlgorithmException | UnsupportedEncodingException e ) { \nthrow new AssertionError ( e ) ; \n} \n} \n} \n"}
{"8886": "public class MarkupConverter { \npublic static String toKamolsMarkup ( AttributeValues avs ) { \nStringBuilder res = toKamolsMarkup ( avs , defaulti ) ; \nif ( 1 > res . length ( ) ) return res . toString ( ) ; \nreturn res . toString ( ) ; \n} \n} \n"}
{"8887": "public class MarkupConverter { \nprivate static void verifyAndSetAVSAttribute ( String tag , FeatureStructure avs , int index , char tagValue , String attribute , String attributeValue ) { \nif ( tag . length ( ) <= index ) return ; \nif ( tag . charAt ( index ) == tagValue ) avs . addAttribute ( attribute , attributeValue ) ; \n} \n} \n"}
{"8890": "public class MetricDataRequest { \nprotected Map < String , Object > getQueryString ( ) { \nMap < String , Object > qs = new HashMap < > ( ) ; \nif ( timeParams != null ) { \nqs . put ( \"time-range-type\" , timeParams . type ) ; \nif ( 0 < timeParams . duration ) { \nqs . put ( \"duration-in-mins\" , timeParams . duration ) ; \n} \nif ( 0 < timeParams . startTime ) { \nqs . put ( \"start-time\" , timeParams . startTime ) ; \n} \nif ( 0 < timeParams . endTime ) { \nqs . put ( \"end-time\" , timeParams . endTime ) ; \n} \n} \nqs . put ( \"rollup\" , false ) ; \nif ( metricPath != null ) { \nqs . put ( \"metric-path\" , metricPath ) ; \n} \nreturn qs ; \n} \n} \n"}
{"8891": "public class MetricDataRequest { \nprotected List < MetricData > process ( JsonNode node ) { \nJSONArray dataArray = node . getArray ( ) ; \nList < MetricData > list = new LinkedList < > ( ) ; \nfor ( int i = 0 ; \ndataArray . length ( ) > i ; \ni ++ ) { \nJSONObject data = dataArray . getJSONObject ( i ) ; \nMetricData metricData = new MetricData ( data . getString ( \"frequency\" ) , data . getLong ( \"metricId\" ) , data . getString ( \"metricName\" ) , data . getString ( \"metricPath\" ) ) ; \nlist . add ( metricData ) ; \nJSONArray valueArray = data . getJSONArray ( \"metricValues\" ) ; \nfor ( int j = 0 ; \nvalueArray . length ( ) > j ; \nj ++ ) { \nJSONObject value = valueArray . getJSONObject ( j ) ; \nmetricData . metricValues . add ( new MetricValue ( value . getLong ( \"count\" ) , value . getLong ( \"value\" ) , value . getLong ( \"max\" ) , value . getLong ( \"min\" ) , value . getLong ( \"sum\" ) , value . getLong ( \"startTimeInMillis\" ) ) ) ; \n} \n} \nreturn list ; \n} \n} \n"}
{"8894": "public class ReportAppD { \npublic void perform ( List < AppInfo > apps , MetricDataRequest . TimeParams timeParams ) { \nList < SignalFxProtocolBuffers . DataPoint > dataPoints = new LinkedList < > ( ) ; \nfor ( AppInfo app : apps ) { \ndataRequest . setAppName ( app . name ) ; \nfor ( MetricInfo metricInfo : app . metrics ) { \ndataRequest . setTimeParams ( timeParams ) ; \ndataRequest . setMetricPath ( metricInfo . metricPathQuery ) ; \nList < MetricData > metricDataList ; \ntry { \nmetricDataList = dataRequest . get ( ) ; \n} \ncatch ( RequestException e ) { \nlog . error ( \"Metric query failure for \\\"{}\\\"\" , metricInfo . metricPathQuery ) ; \ncounterAppDRequestFailure . inc ( ) ; \ncontinue ; \n} \ncatch ( UnauthorizedException e ) { \nlog . error ( \"AppDynamics authentication failed\" ) ; \nreturn ; \n} \nif ( metricDataList != null && 0 < metricDataList . size ( ) ) { \nfor ( MetricData metricData : metricDataList ) { \nMetricTimeSeries mts = metricInfo . getMetricTimeSeries ( metricData . metricPath ) ; \nList < SignalFxProtocolBuffers . DataPoint > mtsDataPoints = processor . process ( mts , metricData . metricValues ) ; \ndataPoints . addAll ( mtsDataPoints ) ; \nif ( ! mtsDataPoints . isEmpty ( ) ) { \ncounterMtsReported . inc ( ) ; \n} \nelse { \ncounterMtsEmpty . inc ( ) ; \n} \n} \n} \nelse { \nlog . warn ( \"No metric found for query \\\"{}\\\"\" , metricInfo . metricPathQuery ) ; \n} \n} \n} \nif ( ! dataPoints . isEmpty ( ) ) { \ntry { \nreporter . report ( dataPoints ) ; \ncounterDataPointsReported . inc ( dataPoints . size ( ) ) ; \n} \ncatch ( Reporter . ReportException e ) { \nlog . error ( \"There were errors reporting metric\" ) ; \n} \n} \n} \n} \n"}
{"8923": "public class SendAppFeedback { \nprotected static void sendLogsToServer ( boolean setSentTime ) { \nlong timeSent = new Date ( ) . getTime ( ) ; \nString appFeedBackSummary = Utility . convertFileToString ( \"AppFeedBackSummary.json\" ) ; \nif ( \"\" . equals ( appFeedBackSummary ) || \"{}\" . equals ( appFeedBackSummary ) ) { \nreturn ; \n} \nelse { \ntry { \nJSONObject appFeedBacksummaryJSON = new JSONObject ( appFeedBackSummary ) ; \nJSONArray savedArray = ( JSONArray ) appFeedBacksummaryJSON . get ( \"saved\" ) ; \nHashMap < String , String > timeSentMap = new HashMap < > ( ) ; \nfor ( int i = 0 ; \nsavedArray . length ( ) > i ; \ni ++ ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = Utility . addAndFetchSentTimeFromScreenFeedBackJson ( screenFeedBackJsonFile , timeSent , setSentTime ) ; \nif ( actualTimeSent != null ) { \ntimeSentMap . put ( instanceName , actualTimeSent ) ; \n} \n} \nfor ( int i = 0 ; \nsavedArray . length ( ) > i ; \ni ++ ) { \nString instanceName = ( String ) savedArray . get ( i ) ; \nString screenFeedBackJsonFile = Utility . getJSONfileName ( instanceName ) ; \nString actualTimeSent = timeSentMap . get ( instanceName ) ; \nString zipFile = Utility . storageDirectory + instanceName + \"_\" + actualTimeSent + \".zip\" ; \nList < String > fileList = new ArrayList < > ( ) ; \nfileList . add ( Utility . getImageFileName ( instanceName ) ) ; \nfileList . add ( screenFeedBackJsonFile ) ; \nUtility . createZipArchive ( fileList , zipFile ) ; \nLogPersister . sendInAppFeedBackFile ( zipFile , new FeedBackUploadResponseListener ( instanceName , zipFile , actualTimeSent ) ) ; \n} \n} \ncatch ( JSONException je ) { \n} \n} \n} \n} \n"}
{"8927": "public class LogPersister { \nstatic public void setMaxLogStoreSize ( final int bytes ) { \nif ( 10000 <= bytes ) { \nlogFileMaxSize = bytes ; \n} \nif ( null != context ) { \nSharedPreferences prefs = context . getSharedPreferences ( SHARED_PREF_KEY , Context . MODE_PRIVATE ) ; \nprefs . edit ( ) . putInt ( SHARED_PREF_KEY_logFileMaxSize , logFileMaxSize ) . commit ( ) ; \n} \n} \n} \n"}
{"8936": "public class ObjectSizing { \nprivate void sizePartitionedRegion ( Region < ? , ? > region , int numEntries ) { \nRegion < ? , ? > primaryDataSet = PartitionRegionHelper . getLocalData ( region ) ; \nint regionSize = primaryDataSet . size ( ) ; \nif ( numEntries == 0 ) { \nnumEntries = primaryDataSet . size ( ) ; \n} \nelse if ( regionSize < numEntries ) { \nnumEntries = regionSize ; \n} \nint count = 0 ; \nfor ( Iterator < ? > i = primaryDataSet . entrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) { \nbreak ; \n} \nEntrySnapshot entry = ( EntrySnapshot ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8937": "public class ObjectSizing { \nprivate void sizeReplicatedOrLocalRegion ( Region < ? , ? > region , int numEntries ) { \nSet < ? > entries = region . entrySet ( ) ; \nint regionSize = entries . size ( ) ; \nif ( numEntries == 0 ) { \nnumEntries = entries . size ( ) ; \n} \nelse if ( regionSize < numEntries ) { \nnumEntries = regionSize ; \n} \nint count = 0 ; \nfor ( Iterator < ? > i = entries . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nif ( count == numEntries ) { \nbreak ; \n} \nLocalRegion . NonTXEntry entry = ( LocalRegion . NonTXEntry ) i . next ( ) ; \nRegionEntry re = entry . getRegionEntry ( ) ; \ndumpSizes ( entry , re ) ; \n} \ndumpTotalAndAverageSizes ( numEntries ) ; \nclearTotals ( ) ; \n} \n} \n"}
{"8939": "public class TimeStampSeries { \nvoid dump ( PrintWriter stream ) { \nstream . print ( \"[size=\" + count ) ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nif ( i != 0 ) { \nstream . print ( \", \" ) ; \nstream . print ( timeStamps [ i ] - timeStamps [ i - 1 ] ) ; \n} \nelse { \nstream . print ( \" \" + timeStamps [ i ] ) ; \n} \n} \nstream . println ( \"]\" ) ; \n} \n} \n"}
{"8940": "public class TimeStampSeries { \ndouble [ ] getTimeValuesSinceIdx ( int idx ) { \nint resultSize = this . count - idx ; \ndouble [ ] result = new double [ resultSize ] ; \nfor ( int i = 0 ; \nresultSize > i ; \ni ++ ) { \nresult [ i ] = getMilliTimeStamp ( idx + i ) ; \n} \nreturn result ; \n} \n} \n"}
{"8964": "public class ComboValue { \nprivate static boolean mustInsert ( int nextIdx , long [ ] valueTimeStamps , long tsAtInsertPoint ) { \nreturn ( valueTimeStamps . length > nextIdx ) && ( tsAtInsertPoint >= valueTimeStamps [ nextIdx ] ) ; \n} \n} \n"}
{"8965": "public class GfStatsReader { \npublic void close ( ) throws IOException { \nif ( ! this . closed ) { \nthis . closed = true ; \nthis . is . close ( ) ; \nthis . dataIn . close ( ) ; \nthis . is = null ; \nthis . dataIn = null ; \nint typeCount = 0 ; \nif ( this . resourceTypeTable != null ) { \nfor ( int i = 0 ; \nthis . resourceTypeTable . length > i ; \ni ++ ) { \nif ( this . resourceTypeTable [ i ] != null ) { \nif ( this . resourceTypeTable [ i ] . close ( ) ) { \nthis . resourceTypeTable [ i ] = null ; \n} \nelse { \ntypeCount ++ ; \n} \n} \n} \nResourceType [ ] newTypeTable = new ResourceType [ typeCount ] ; \ntypeCount = 0 ; \nfor ( ResourceType aResourceTypeTable : this . resourceTypeTable ) { \nif ( aResourceTypeTable != null ) { \nnewTypeTable [ typeCount ] = aResourceTypeTable ; \ntypeCount ++ ; \n} \n} \nthis . resourceTypeTable = newTypeTable ; \n} \nif ( this . resourceInstTable != null ) { \nint instCount = 0 ; \nfor ( int i = 0 ; \nthis . resourceInstTable . length > i ; \ni ++ ) { \nif ( this . resourceInstTable [ i ] != null ) { \nif ( this . resourceInstTable [ i ] . close ( ) ) { \nthis . resourceInstTable [ i ] = null ; \n} \nelse { \ninstCount ++ ; \n} \n} \n} \nResourceInst [ ] newInstTable = new ResourceInst [ instCount ] ; \ninstCount = 0 ; \nfor ( ResourceInst aResourceInstTable : this . resourceInstTable ) { \nif ( aResourceInstTable != null ) { \nnewInstTable [ instCount ] = aResourceInstTable ; \ninstCount ++ ; \n} \n} \nthis . resourceInstTable = newInstTable ; \nthis . resourceInstSize = instCount ; \n} \nthis . timeSeries . shrink ( ) ; \nthis . filters = null ; \n} \n} \n} \n"}
{"8967": "public class GfStatsReader { \npublic static void main ( String [ ] args ) { \nFile archiveFile , csvFile ; \nif ( 1 > args . length ) { \nSystem . err . println ( \"Usage: java \" + GfStatsReader . class . getName ( ) + \" archiveFile [csvFile [statName ]*]\" ) ; \nreturn ; \n} \ntry { \narchiveFile = Paths . get ( args [ 0 ] ) . toFile ( ) ; \nif ( archiveFile . isDirectory ( ) ) { \ntoCvsFiles ( archiveFile ) ; \nreturn ; \n} \nif ( 2 > args . length ) { \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . dumpCsvFiles ( ) ; \nreturn ; \n} \nString typeName = args [ 1 ] ; \ncsvFile = Paths . get ( args [ 2 ] ) . toFile ( ) ; \nGenericCsvStatsVisitor visitor = null ; \nif ( 3 < args . length ) { \nString [ ] stateNames = Arrays . copyOfRange ( args , 2 , args . length - 1 ) ; \nvisitor = new GenericCsvStatsVisitor ( csvFile , typeName , stateNames ) ; \n} \nelse visitor = new GenericCsvStatsVisitor ( csvFile , typeName ) ; \nSystem . out . println ( \"accepting\" ) ; \nGfStatsReader reader = new GfStatsReader ( archiveFile . getAbsolutePath ( ) ) ; \nreader . accept ( visitor ) ; \n} \ncatch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} \n} \n"}
{"8969": "public class GemFireMgmt { \npublic static int stopMembersOnHost ( String hostName ) { \nJMX jmx = SingletonGemFireJmx . getJmx ( ) ; \nString objectNamePattern = \"GemFire:type=Member,member=*\" ; \nQueryExp queryExp = null ; \nValueExp [ ] values = null ; \ntry { \nInetAddress [ ] addresses = InetAddress . getAllByName ( hostName ) ; \nInetAddress address = null ; \nif ( addresses != null ) { \nvalues = new ValueExp [ addresses . length ] ; \nfor ( int i = 0 ; \naddresses . length > i ; \ni ++ ) { \naddress = addresses [ i ] ; \nvalues [ i ] = Query . value ( address . getHostAddress ( ) ) ; \n} \n} \n} \ncatch ( UnknownHostException e ) { \nDebugger . println ( e . getMessage ( ) ) ; \n} \nif ( values != null ) { \nqueryExp = Query . or ( Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) , Query . in ( Query . attr ( \"Host\" ) , values ) ) ; \n} \nelse { \nqueryExp = Query . eq ( Query . attr ( \"Host\" ) , Query . value ( hostName ) ) ; \n} \nSet < ObjectName > memberObjectNames = jmx . searchObjectNames ( objectNamePattern , queryExp ) ; \nif ( memberObjectNames == null || memberObjectNames . isEmpty ( ) ) return 0 ; \nint memberCount = memberObjectNames . size ( ) ; \nMemberMXBean member = null ; \nCollection < String > locators = new ArrayList < String > ( ) ; \nfor ( ObjectName objectName : memberObjectNames ) { \nmember = GemFireJmxClient . getMember ( objectName . getKeyProperty ( \"member\" ) , SingletonGemFireJmx . getJmx ( ) ) ; \nif ( member . isLocator ( ) ) { \nlocators . add ( member . getName ( ) ) ; \n} \nelse { \nshutDownMember ( member . getName ( ) ) ; \n} \n} \nfor ( String locatorName : locators ) { \nshutDownMember ( locatorName ) ; \n} \nreturn memberCount ; \n} \n} \n"}
{"8996": "public class OneWireTemperatureSensor { \npublic float readTemperature ( ) throws IOException { \nbyte [ ] encoded = Files . readAllBytes ( new File ( deviceFile , \"w1_slave\" ) . toPath ( ) ) ; \nString tmp = new String ( encoded ) ; \nint tmpIndex = tmp . indexOf ( \"t=\" ) ; \nif ( 0 > tmpIndex ) { \nthrow new IOException ( \"Could not read temperature!\" ) ; \n} \nreturn Integer . parseInt ( tmp . substring ( tmpIndex + 2 ) . trim ( ) ) / 1000f ; \n} \n} \n"}
{"9004": "public class IntPower { \npublic static double raise ( final double px , final int pexponent ) { \ndouble x = px ; \nint exponent = pexponent ; \nif ( 0 > exponent ) return 1 / raise ( x , - exponent ) ; \ndouble power = 1 ; \nwhile ( 0 < exponent ) { \nif ( ( exponent & 1 ) == 1 ) power *= x ; \nx *= x ; \nexponent >>= 1 ; \n} \nreturn power ; \n} \n} \n"}
{"9005": "public class ColumnVector { \nprotected void set ( final float values [ ] ) { \nthis . m_nRows = values . length ; \nthis . m_nCols = 1 ; \nthis . m_aValues = new float [ m_nRows ] [ 1 ] ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nthis . m_aValues [ r ] [ 0 ] = values [ r ] ; \n} \n} \n} \n"}
{"9006": "public class BigFunctions { \npublic static BigDecimal intPower ( @ Nonnull final BigDecimal px , final long pexponent , final int scale ) { \nBigDecimal x = px ; \nlong exponent = pexponent ; \nif ( 0 > exponent ) { \nreturn BigDecimal . ONE . divide ( intPower ( x , - exponent , scale ) , scale , RoundingMode . HALF_EVEN ) ; \n} \nBigDecimal power = BigDecimal . ONE ; \nwhile ( 0 < exponent ) { \nif ( ( exponent & 1 ) == 1 ) { \npower = power . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; \n} \nx = x . multiply ( x ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; \nexponent >>= 1 ; \nThread . yield ( ) ; \n} \nreturn power ; \n} \n} \n"}
{"9007": "public class BigFunctions { \npublic static BigDecimal intRoot ( @ Nonnull final BigDecimal px , final long index , final int scale ) { \nBigDecimal x = px ; \nif ( 0 > x . signum ( ) ) { \nthrow new IllegalArgumentException ( \"x < 0: \" + x ) ; \n} \nfinal int sp1 = scale + 1 ; \nfinal BigDecimal n = x ; \nfinal BigDecimal i = BigDecimal . valueOf ( index ) ; \nfinal BigDecimal im1 = BigDecimal . valueOf ( index - 1 ) ; \nfinal BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; \nBigDecimal xPrev ; \nx = x . divide ( i , scale , RoundingMode . HALF_EVEN ) ; \ndo { \nfinal BigDecimal xToIm1 = intPower ( x , index - 1 , sp1 ) ; \nfinal BigDecimal xToI = x . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nfinal BigDecimal numerator = n . add ( im1 . multiply ( xToI ) ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nfinal BigDecimal denominator = i . multiply ( xToIm1 ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nxPrev = x ; \nx = numerator . divide ( denominator , sp1 , RoundingMode . DOWN ) ; \nThread . yield ( ) ; \n} \nwhile ( 0 < x . subtract ( xPrev ) . abs ( ) . compareTo ( tolerance ) ) ; \nreturn x ; \n} \n} \n"}
{"9009": "public class BigFunctions { \npublic static BigDecimal ln ( @ Nonnull final BigDecimal x , final int scale ) { \nif ( 0 >= x . signum ( ) ) { \nthrow new IllegalArgumentException ( \"x <= 0: \" + x ) ; \n} \nfinal int magnitude = x . toString ( ) . length ( ) - x . scale ( ) - 1 ; \nif ( 3 > magnitude ) { \nreturn _lnNewton ( x , scale ) ; \n} \nfinal BigDecimal root = intRoot ( x , magnitude , scale ) ; \nfinal BigDecimal lnRoot = _lnNewton ( root , scale ) ; \nreturn BigDecimal . valueOf ( magnitude ) . multiply ( lnRoot ) . setScale ( scale , RoundingMode . HALF_EVEN ) ; \n} \n} \n"}
{"9010": "public class BigFunctions { \nprivate static BigDecimal _lnNewton ( @ Nonnull final BigDecimal px , final int scale ) { \nBigDecimal x = px ; \nfinal int sp1 = scale + 1 ; \nfinal BigDecimal n = x ; \nBigDecimal term ; \nfinal BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; \ndo { \nfinal BigDecimal eToX = exp ( x , sp1 ) ; \nterm = eToX . subtract ( n ) . divide ( eToX , sp1 , RoundingMode . DOWN ) ; \nx = x . subtract ( term ) ; \nThread . yield ( ) ; \n} \nwhile ( 0 < term . compareTo ( tolerance ) ) ; \nreturn x . setScale ( scale , RoundingMode . HALF_EVEN ) ; \n} \n} \n"}
{"9011": "public class BigFunctions { \npublic static BigDecimal arctan ( @ Nonnull final BigDecimal x , final int scale ) { \nif ( 0 <= x . abs ( ) . compareTo ( BigDecimal . ONE ) ) { \nthrow new IllegalArgumentException ( \"|x| >= 1: \" + x ) ; \n} \nif ( x . signum ( ) == - 1 ) { \nreturn arctan ( x . negate ( ) , scale ) . negate ( ) ; \n} \nreturn _arctanTaylor ( x , scale ) ; \n} \n} \n"}
{"9012": "public class BigFunctions { \nprivate static BigDecimal _arctanTaylor ( final BigDecimal x , final int scale ) { \nfinal int sp1 = scale + 1 ; \nint i = 3 ; \nboolean addFlag = false ; \nBigDecimal power = x ; \nBigDecimal sum = x ; \nBigDecimal term ; \nfinal BigDecimal tolerance = BigDecimal . valueOf ( 5 ) . movePointLeft ( sp1 ) ; \ndo { \npower = power . multiply ( x ) . multiply ( x ) . setScale ( sp1 , RoundingMode . HALF_EVEN ) ; \nterm = power . divide ( BigDecimal . valueOf ( i ) , sp1 , RoundingMode . HALF_EVEN ) ; \nsum = addFlag ? sum . add ( term ) : sum . subtract ( term ) ; \ni += 2 ; \naddFlag = ! addFlag ; \nThread . yield ( ) ; \n} \nwhile ( 0 < term . compareTo ( tolerance ) ) ; \nreturn sum ; \n} \n} \n"}
{"9013": "public class BigFunctions { \npublic static BigDecimal sqrt ( @ Nonnull final BigDecimal x , final int scale ) { \nif ( 0 > x . signum ( ) ) { \nthrow new IllegalArgumentException ( \"x < 0: \" + x ) ; \n} \nfinal BigInteger n = x . movePointRight ( scale << 1 ) . toBigInteger ( ) ; \nfinal int bits = ( n . bitLength ( ) + 1 ) >> 1 ; \nBigInteger ix = n . shiftRight ( bits ) ; \nBigInteger ixPrev ; \ndo { \nixPrev = ix ; \nix = ix . add ( n . divide ( ix ) ) . shiftRight ( 1 ) ; \nThread . yield ( ) ; \n} \nwhile ( ix . compareTo ( ixPrev ) != 0 ) ; \nreturn new BigDecimal ( ix , scale ) ; \n} \n} \n"}
{"9014": "public class AbstractPiFormula { \nprotected void printPi ( final String piString ) { \nSystem . out . print ( \"\\npi = \" + piString . substring ( 0 , 2 ) ) ; \nint index = 2 ; \nint line = 0 ; \nint group = 0 ; \nfinal int length = piString . length ( ) ; \nwhile ( length > index + 5 ) { \nSystem . out . print ( piString . substring ( index , index + 5 ) + \" \" ) ; \nindex += 5 ; \nif ( ++ group == 10 ) { \nSystem . out . println ( ) ; \nif ( ++ line == 10 ) { \nSystem . out . println ( ) ; \nline = 0 ; \n} \nSystem . out . print ( \"       \" ) ; \ngroup = 0 ; \n} \n} \nif ( length > index ) { \nSystem . out . println ( piString . substring ( index ) ) ; \n} \n} \n} \n"}
{"9017": "public class Buckets { \npublic void put ( final float r ) { \nif ( ( m_fMin > r ) || ( m_fMax < r ) ) return ; \nfinal int i = ( int ) ( ( r - m_fMin ) / m_fWidth ) ; \n++ m_aCounters [ i ] ; \n} \n} \n"}
{"9018": "public class Buckets { \npublic void print ( ) { \nint maxCount = 0 ; \nfor ( int i = 0 ; \nm_n > i ; \n++ i ) { \nmaxCount = Math . max ( maxCount , m_aCounters [ i ] ) ; \n} \nfinal float factor = ( ( float ) MAX_BAR_SIZE ) / maxCount ; \nfor ( int i = 0 ; \nm_n > i ; \n++ i ) { \nfinal int b = m_aCounters [ i ] ; \nm_aAlignRight . print ( i , 2 ) ; \nm_aAlignRight . print ( b , 7 ) ; \nSystem . out . print ( \": \" ) ; \nfinal int length = Math . round ( factor * b ) ; \nfor ( int j = 0 ; \nlength > j ; \n++ j ) System . out . print ( \"*\" ) ; \nSystem . out . println ( ) ; \n} \n} \n} \n"}
{"9024": "public class Matrix { \npublic RowVector getRow ( final int r ) throws MatrixException { \nif ( ( 0 > r ) || ( m_nRows <= r ) ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nfinal RowVector rv = new RowVector ( m_nCols ) ; \nfor ( int c = 0 ; \nm_nCols > c ; \n++ c ) { \nrv . m_aValues [ 0 ] [ c ] = m_aValues [ r ] [ c ] ; \n} \nreturn rv ; \n} \n} \n"}
{"9025": "public class Matrix { \npublic ColumnVector getColumn ( final int c ) throws MatrixException { \nif ( ( 0 > c ) || ( m_nCols <= c ) ) { \nthrow new MatrixException ( MatrixException . INVALID_INDEX ) ; \n} \nfinal ColumnVector cv = new ColumnVector ( m_nRows ) ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \ncv . m_aValues [ r ] [ 0 ] = m_aValues [ r ] [ c ] ; \n} \nreturn cv ; \n} \n} \n"}
{"9026": "public class Matrix { \nprotected void set ( final float values [ ] [ ] ) { \nm_nRows = values . length ; \nm_nCols = values [ 0 ] . length ; \nm_aValues = values ; \nfor ( int r = 1 ; \nm_nRows > r ; \n++ r ) { \nm_nCols = Math . min ( m_nCols , values [ r ] . length ) ; \n} \n} \n} \n"}
{"9027": "public class Matrix { \npublic Matrix transpose ( ) { \nfinal float tv [ ] [ ] = new float [ m_nCols ] [ m_nRows ] ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nfor ( int c = 0 ; \nm_nCols > c ; \n++ c ) { \ntv [ c ] [ r ] = m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( tv ) ; \n} \n} \n"}
{"9028": "public class Matrix { \npublic Matrix add ( final Matrix m ) throws MatrixException { \nif ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float sv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nfor ( int c = 0 ; \nm_nCols > c ; \n++ c ) { \nsv [ r ] [ c ] = m_aValues [ r ] [ c ] + m . m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( sv ) ; \n} \n} \n"}
{"9029": "public class Matrix { \npublic Matrix subtract ( final Matrix m ) throws MatrixException { \nif ( ( m_nRows != m . m_nRows ) && ( m_nCols != m . m_nCols ) ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float dv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nfor ( int c = 0 ; \nm_nCols > c ; \n++ c ) { \ndv [ r ] [ c ] = m_aValues [ r ] [ c ] - m . m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( dv ) ; \n} \n} \n"}
{"9030": "public class Matrix { \npublic Matrix multiply ( final float k ) { \nfinal float pv [ ] [ ] = new float [ m_nRows ] [ m_nCols ] ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nfor ( int c = 0 ; \nm_nCols > c ; \n++ c ) { \npv [ r ] [ c ] = k * m_aValues [ r ] [ c ] ; \n} \n} \nreturn new Matrix ( pv ) ; \n} \n} \n"}
{"9031": "public class Matrix { \npublic Matrix multiply ( final Matrix m ) throws MatrixException { \nif ( m_nCols != m . m_nRows ) { \nthrow new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; \n} \nfinal float pv [ ] [ ] = new float [ m_nRows ] [ m . m_nCols ] ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nfor ( int c = 0 ; \nm . m_nCols > c ; \n++ c ) { \nfloat dot = 0 ; \nfor ( int k = 0 ; \nm_nCols > k ; \n++ k ) { \ndot += m_aValues [ r ] [ k ] * m . m_aValues [ k ] [ c ] ; \n} \npv [ r ] [ c ] = dot ; \n} \n} \nreturn new Matrix ( pv ) ; \n} \n} \n"}
{"9032": "public class Matrix { \npublic void print ( final int width , @ Nonnull final PrintStream aPS ) { \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( int c = 0 ; \nm_nCols > c ; \n++ c ) { \nar . print ( m_aValues [ r ] [ c ] , width ) ; \n} \nar . println ( ) ; \n} \n} \n} \n"}
{"9034": "public class RegressionLine { \nprivate void _validateCoefficients ( ) { \nif ( m_bCoefsValid ) return ; \nif ( 2 <= m_nDataPoints ) { \nfinal float xBar = ( float ) m_dSumX / m_nDataPoints ; \nfinal float yBar = ( float ) m_dSumY / m_nDataPoints ; \nm_fA1 = ( float ) ( ( m_nDataPoints * m_dSumXY - m_dSumX * m_dSumY ) / ( m_nDataPoints * m_dSumXX - m_dSumX * m_dSumX ) ) ; \nm_fA0 = yBar - m_fA1 * xBar ; \n} \nelse { \nm_fA0 = m_fA1 = Float . NaN ; \n} \nm_bCoefsValid = true ; \n} \n} \n"}
{"9044": "public class InvertibleMatrix { \npublic InvertibleMatrix inverse ( ) throws MatrixException { \nfinal InvertibleMatrix inverse = new InvertibleMatrix ( m_nRows ) ; \nfinal IdentityMatrix identity = new IdentityMatrix ( m_nRows ) ; \nfor ( int c = 0 ; \nm_nCols > c ; \n++ c ) { \nfinal ColumnVector col = solve ( identity . getColumn ( c ) , true ) ; \ninverse . setColumn ( col , c ) ; \n} \nreturn inverse ; \n} \n} \n"}
{"9045": "public class InvertibleMatrix { \npublic float determinant ( ) throws MatrixException { \ndecompose ( ) ; \nfloat determinant = ( ( m_nExchangeCount & 1 ) == 0 ) ? 1 : - 1 ; \nfor ( int i = 0 ; \nm_nRows > i ; \n++ i ) { \nfinal int pi = m_aPermutation [ i ] ; \ndeterminant *= m_aLU . at ( pi , i ) ; \n} \nreturn determinant ; \n} \n} \n"}
{"9046": "public class InvertibleMatrix { \npublic float norm ( ) { \nfloat sum = 0 ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nfor ( int c = 0 ; \nm_nCols > c ; \n++ c ) { \nfinal float v = m_aValues [ r ] [ c ] ; \nsum += v * v ; \n} \n} \nreturn ( float ) Math . sqrt ( sum ) ; \n} \n} \n"}
{"9048": "public class LinearSystem { \npublic void printDecomposed ( final int width , @ Nonnull final PrintStream aPS ) throws MatrixException { \ndecompose ( ) ; \nfinal SystemOutAlignRight ar = new SystemOutAlignRight ( aPS ) ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nar . print ( \"Row \" , 0 ) ; \nar . print ( r + 1 , 2 ) ; \nar . print ( \":\" , 0 ) ; \nfor ( int c = 0 ; \nm_nCols > c ; \n++ c ) { \nar . print ( m_aLU . m_aValues [ pr ] [ c ] , width ) ; \n} \nar . println ( ) ; \n} \n} \n} \n"}
{"9049": "public class LinearSystem { \nprivate void _forwardElimination ( final float scales [ ] ) throws MatrixException { \nfor ( int rPivot = 0 ; \nm_nRows - 1 > rPivot ; \n++ rPivot ) { \nfloat largestScaledElmt = 0 ; \nint rLargest = 0 ; \nfor ( int r = rPivot ; \nm_nRows > r ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float absElmt = Math . abs ( m_aLU . at ( pr , rPivot ) ) ; \nfinal float scaledElmt = absElmt * scales [ pr ] ; \nif ( scaledElmt > largestScaledElmt ) { \nlargestScaledElmt = scaledElmt ; \nrLargest = r ; \n} \n} \nif ( largestScaledElmt == 0 ) { \nthrow new MatrixException ( MatrixException . SINGULAR ) ; \n} \nif ( rLargest != rPivot ) { \nfinal int temp = m_aPermutation [ rPivot ] ; \nm_aPermutation [ rPivot ] = m_aPermutation [ rLargest ] ; \nm_aPermutation [ rLargest ] = temp ; \n++ m_nExchangeCount ; \n} \nfinal int prPivot = m_aPermutation [ rPivot ] ; \nfinal float pivotElmt = m_aLU . at ( prPivot , rPivot ) ; \nfor ( int r = rPivot + 1 ; \nm_nRows > r ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfinal float multiple = m_aLU . at ( pr , rPivot ) / pivotElmt ; \nm_aLU . set ( pr , rPivot , multiple ) ; \nif ( multiple != 0 ) { \nfor ( int c = rPivot + 1 ; \nm_nCols > c ; \n++ c ) { \nfloat elmt = m_aLU . at ( pr , c ) ; \nelmt -= multiple * m_aLU . at ( prPivot , c ) ; \nm_aLU . set ( pr , c , elmt ) ; \n} \n} \n} \n} \n} \n} \n"}
{"9050": "public class LinearSystem { \nprivate ColumnVector _forwardSubstitution ( final ColumnVector b ) throws MatrixException { \nfinal ColumnVector y = new ColumnVector ( m_nRows ) ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \nfor ( int c = 0 ; \nr > c ; \n++ c ) { \ndot += m_aLU . at ( pr , c ) * y . at ( c ) ; \n} \ny . set ( r , b . at ( pr ) - dot ) ; \n} \nreturn y ; \n} \n} \n"}
{"9051": "public class LinearSystem { \nprivate ColumnVector _backSubstitution ( final ColumnVector y ) throws MatrixException { \nfinal ColumnVector x = new ColumnVector ( m_nRows ) ; \nfor ( int r = m_nRows - 1 ; \n0 <= r ; \n-- r ) { \nfinal int pr = m_aPermutation [ r ] ; \nfloat dot = 0 ; \nfor ( int c = r + 1 ; \nm_nRows > c ; \n++ c ) { \ndot += m_aLU . at ( pr , c ) * x . at ( c ) ; \n} \nx . set ( r , ( y . at ( r ) - dot ) / m_aLU . at ( pr , r ) ) ; \n} \nreturn x ; \n} \n} \n"}
{"9052": "public class LinearSystem { \nprivate void _improve ( final ColumnVector b , final ColumnVector x ) throws MatrixException { \nfloat largestX = 0 ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nfinal float absX = Math . abs ( x . m_aValues [ r ] [ 0 ] ) ; \nif ( absX > largestX ) largestX = absX ; \n} \nif ( largestX == 0 ) return ; \nfinal ColumnVector residuals = new ColumnVector ( m_nRows ) ; \nfor ( int iter = 0 ; \nMAX_ITER > iter ; \n++ iter ) { \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \ndouble dot = 0 ; \nfor ( int c = 0 ; \nm_nRows > c ; \n++ c ) { \nfinal double elmt = at ( r , c ) ; \ndot += elmt * x . at ( c ) ; \n} \nfinal double value = b . at ( r ) - dot ; \nresiduals . set ( r , ( float ) value ) ; \n} \nfinal ColumnVector z = solve ( residuals , false ) ; \nfloat largestDiff = 0 ; \nfor ( int r = 0 ; \nm_nRows > r ; \n++ r ) { \nfinal float oldX = x . at ( r ) ; \nx . set ( r , oldX + z . at ( r ) ) ; \nfinal float diff = Math . abs ( x . at ( r ) - oldX ) ; \nif ( diff > largestDiff ) largestDiff = diff ; \n} \nif ( largestX * TOLERANCE > largestDiff ) return ; \n} \nthrow new MatrixException ( MatrixException . NO_CONVERGENCE ) ; \n} \n} \n"}
{"9053": "public class IdentityMatrix { \npublic static void convert ( final SquareMatrix sm ) { \nfor ( int r = 0 ; \nsm . m_nRows > r ; \n++ r ) { \nfor ( int c = 0 ; \nsm . m_nCols > c ; \n++ c ) { \nsm . m_aValues [ r ] [ c ] = ( r == c ) ? 1 : 0 ; \n} \n} \n} \n} \n"}
{"9054": "public class RandomExponential { \npublic float nextVonNeumann ( ) { \nint n ; \nint k = 0 ; \nfloat u1 ; \nfor ( ; \n; \n) { \nn = 1 ; \nu1 = GENERATOR . nextFloat ( ) ; \nfloat u = u1 ; \nfloat uPrev = Float . NaN ; \nfor ( ; \n; \n) { \nuPrev = u ; \nu = GENERATOR . nextFloat ( ) ; \nif ( uPrev < u ) { \nif ( ( n & 1 ) == 0 ) { \nreturn u1 + k ; \n} \n++ k ; \nbreak ; \n} \n++ n ; \n} \n} \n} \n} \n"}
{"9055": "public class RegulaFalsiRootFinder { \n@ Override protected void doIterationProcedure ( final int n ) { \nif ( n == 1 ) return ; \nif ( 0 > m_fFalse ) { \nm_fXNeg = m_fXFalse ; \nm_fNeg = m_fFalse ; \n} \nelse { \nm_fXPos = m_fXFalse ; \nm_fPos = m_fFalse ; \n} \n} \n} \n"}
{"9058": "public class ImprovedRegulaFalsiRootFinder { \n@ Override protected void computeNextPosition ( ) { \nm_fPrevXFalse = m_fXFalse ; \nm_fPrevFFalse = m_fFalse ; \nm_fXFalse = m_fXPos - m_fPos * ( m_fXNeg - m_fXPos ) / ( m_fNeg - m_fPos ) ; \nm_fFalse = m_aFunction . at ( m_fXFalse ) ; \nm_bDecreasePos = m_bDecreaseNeg = false ; \nif ( Float . isNaN ( m_fPrevFFalse ) || ( 0 < m_fPrevFFalse * m_fFalse ) ) { \nif ( 0 > m_fFalse ) m_bDecreasePos = true ; \nelse m_bDecreaseNeg = true ; \n} \n} \n} \n"}
{"9059": "public class AbstractRootFinder { \npublic void checkInterval ( final float x1 , final float x2 ) throws InvalidIntervalException { \nfinal float y1 = m_aFunction . at ( x1 ) ; \nfinal float y2 = m_aFunction . at ( x2 ) ; \nif ( 0 < y1 * y2 ) throw new InvalidIntervalException ( ) ; \n} \n} \n"}
{"9061": "public class ModuloArithmetic { \npublic static int multiply ( final int pa , final int pb , final int m ) { \nint a = pa ; \nint b = pb ; \nint product = 0 ; \nwhile ( 0 < a ) { \nif ( ( a & 1 ) == 1 ) { \nproduct += b ; \nproduct %= m ; \n} \nb <<= 1 ; \nb %= m ; \na >>= 1 ; \n} \nreturn product ; \n} \n} \n"}
{"9062": "public class ModuloArithmetic { \npublic static int raise ( final int pbase , final int pexponent , final int m ) { \nint base = pbase ; \nint exponent = pexponent ; \nint power = 1 ; \nwhile ( 0 < exponent ) { \nif ( ( exponent & 1 ) == 1 ) { \npower = multiply ( power , base , m ) ; \n} \nbase = multiply ( base , base , m ) ; \nexponent >>= 1 ; \n} \nreturn power ; \n} \n} \n"}
{"9065": "public class IEEE754 { \nprivate static char [ ] _toCharBitArray ( final long pvalue , final int size ) { \nlong value = pvalue ; \nfinal char bits [ ] = new char [ size ] ; \nfor ( int i = size - 1 ; \n0 <= i ; \n-- i ) { \nbits [ i ] = ( value & 1 ) == 0 ? '0' : '1' ; \nvalue >>>= 1 ; \n} \nreturn bits ; \n} \n} \n"}
{"9068": "public class IEEE754 { \npublic static void validateFloatBiasedExponent ( final int biased ) throws IEEE754Exception { \nif ( ( 0 > biased ) || ( IEEE754Constants . FLOAT_EXPONENT_RESERVED < biased ) ) { \nthrow new IEEE754Exception ( \"The biased exponent value should be \" + \"0 through \" + IEEE754Constants . FLOAT_EXPONENT_RESERVED + \".\" ) ; \n} \n} \n} \n"}
{"9069": "public class IEEE754 { \npublic static void validateFloatUnbiasedExponent ( final int unbiased ) throws IEEE754Exception { \nif ( ( - IEEE754Constants . FLOAT_EXPONENT_BIAS + 1 > unbiased ) || ( IEEE754Constants . FLOAT_EXPONENT_BIAS < unbiased ) ) { \nthrow new IEEE754Exception ( \"The unbiased exponent value should be \" + - ( IEEE754Constants . FLOAT_EXPONENT_BIAS - 1 ) + \" through \" + IEEE754Constants . FLOAT_EXPONENT_BIAS + \".\" ) ; \n} \n} \n} \n"}
{"9070": "public class IEEE754 { \npublic static void validateDoubleBiasedExponent ( final int biased ) throws IEEE754Exception { \nif ( ( 0 > biased ) || ( IEEE754Constants . DOUBLE_EXPONENT_RESERVED < biased ) ) { \nthrow new IEEE754Exception ( \"The biased exponent value should be \" + \"0 through \" + IEEE754Constants . DOUBLE_EXPONENT_RESERVED + \".\" ) ; \n} \n} \n} \n"}
{"9071": "public class IEEE754 { \npublic static void validateDoubleUnbiasedExponent ( final int unbiased ) throws IEEE754Exception { \nif ( ( - IEEE754Constants . DOUBLE_EXPONENT_BIAS + 1 > unbiased ) || ( IEEE754Constants . DOUBLE_EXPONENT_BIAS < unbiased ) ) { \nthrow new IEEE754Exception ( \"The unbiased exponent value should be \" + - ( IEEE754Constants . DOUBLE_EXPONENT_BIAS - 1 ) + \" through \" + IEEE754Constants . DOUBLE_EXPONENT_BIAS + \".\" ) ; \n} \n} \n} \n"}
{"9073": "public class RandomNormal { \npublic float nextCentral ( ) { \nfloat sum = 0.0f ; \nfor ( int j = 0 ; \n12 > j ; \n++ j ) sum += GENERATOR . nextFloat ( ) ; \nreturn m_fStddev * ( sum - 6 ) + m_fMean ; \n} \n} \n"}
{"9074": "public class RandomNormal { \npublic float nextPolar ( ) { \nif ( m_bHaveNextPolar ) { \nm_bHaveNextPolar = false ; \nreturn m_fNextPolar ; \n} \nfloat u1 , u2 , r ; \ndo { \nu1 = 2 * GENERATOR . nextFloat ( ) - 1 ; \nu2 = 2 * GENERATOR . nextFloat ( ) - 1 ; \nr = u1 * u1 + u2 * u2 ; \n} \nwhile ( 1 <= r ) ; \nfinal float factor = ( float ) ( m_fStddev * Math . sqrt ( - 2 * Math . log ( r ) / r ) ) ; \nfinal float v1 = factor * u1 + m_fMean ; \nfinal float v2 = factor * u2 + m_fMean ; \nm_fNextPolar = v1 ; \nm_bHaveNextPolar = true ; \nreturn v2 ; \n} \n} \n"}
{"9075": "public class RandomNormal { \npublic float nextRatio ( ) { \nfloat u , v , x , xx ; \ndo { \nwhile ( ( u = GENERATOR . nextFloat ( ) ) == 0 ) { \n} \nv = GENERATOR . nextFloat ( ) ; \nfinal float y = C1 * ( v - 0.5f ) ; \nx = y / u ; \nxx = x * x ; \n} \nwhile ( ( 5f - C2 * u < xx ) && ( ( C3 / u + 1.4f <= xx ) || ( ( float ) ( - 4 * Math . log ( u ) ) < xx ) ) ) ; \nreturn m_fStddev * x + m_fMean ; \n} \n} \n"}
{"9076": "public class PrimeFactors { \npublic static boolean [ ] primeSieve ( final int n ) { \nfinal int halfN = ( n + 1 ) >> 1 ; \nfinal boolean sieve [ ] = new boolean [ n + 1 ] ; \nfor ( int i = 2 ; \nn >= i ; \n++ i ) sieve [ i ] = true ; \nint prime = 2 ; \nwhile ( halfN > prime ) { \nfor ( int composite = prime << 1 ; \nn >= composite ; \ncomposite += prime ) sieve [ composite ] = false ; \nwhile ( ( halfN > ++ prime ) && ( ! sieve [ prime ] ) ) { \n} \n} \nreturn sieve ; \n} \n} \n"}
{"9077": "public class PrimeFactors { \npublic static int [ ] factorsOf ( final int pn ) { \nint n = pn ; \nfinal boolean isPrime [ ] = primeSieve ( n ) ; \nfinal ICommonsList < Integer > v = new CommonsArrayList < > ( ) ; \nfor ( int factor = 2 ; \n1 < n ; \n++ factor ) { \nif ( isPrime [ factor ] && ( n % factor == 0 ) ) { \nv . add ( Integer . valueOf ( factor ) ) ; \ndo { \nn /= factor ; \n} \nwhile ( n % factor == 0 ) ; \n} \n} \nfinal int factors [ ] = new int [ v . size ( ) ] ; \nfor ( int i = 0 ; \nv . size ( ) > i ; \n++ i ) { \nfactors [ i ] = v . get ( i ) . intValue ( ) ; \n} \nreturn factors ; \n} \n} \n"}
{"9078": "public class BisectionRootFinder { \n@ Override protected void doIterationProcedure ( final int n ) { \nif ( n == 1 ) return ; \nif ( 0 > m_fMid ) { \nm_fXNeg = m_fXMid ; \nm_fNeg = m_fMid ; \n} \nelse { \nm_fXPos = m_fXMid ; \nm_fPos = m_fMid ; \n} \n} \n} \n"}
{"9089": "public class Utils { \npublic static String sanitizeTag ( String s ) { \nif ( MAX_TAG_LENGTH < s . length ( ) ) { \ns = s . substring ( s . length ( ) - MAX_TAG_LENGTH ) ; \n} \nreturn s ; \n} \n} \n"}
{"9123": "public class SQLFormUtil { \nprivate Form mapFormContainerTo ( Map < Long , String > definitionAndTitleParam , ResultSet resultSetParam ) throws SQLException { \nLong formId = resultSetParam . getLong ( SQLColumnIndex . _01_FORM_ID ) ; \nString formType = definitionAndTitleParam . get ( resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) ) ; \nString title = resultSetParam . getString ( SQLColumnIndex . _03_TITLE ) ; \nDate created = resultSetParam . getDate ( SQLColumnIndex . _04_CREATED ) ; \nDate lastUpdated = resultSetParam . getDate ( SQLColumnIndex . _05_LAST_UPDATED ) ; \nLong currentUserId = resultSetParam . getLong ( SQLColumnIndex . _06_CURRENT_USER_ID ) ; \nif ( formType == null ) { \nthrow new SQLException ( \"No mapping found for Form Type '\" + resultSetParam . getLong ( SQLColumnIndex . _02_FORM_TYPE ) + \"'.\" ) ; \n} \nForm toAdd = new Form ( formType ) ; \ntoAdd . setId ( formId ) ; \ntoAdd . setTitle ( title ) ; \nif ( created != null ) { \ntoAdd . setDateCreated ( new Date ( created . getTime ( ) ) ) ; \n} \nif ( lastUpdated != null ) { \ntoAdd . setDateLastUpdated ( new Date ( lastUpdated . getTime ( ) ) ) ; \n} \nif ( currentUserId != null && 0 < currentUserId . longValue ( ) ) { \nUser currentUser = new User ( ) ; \ncurrentUser . setId ( currentUserId ) ; \ntoAdd . setCurrentUser ( currentUser ) ; \n} \nreturn toAdd ; \n} \n} \n"}
{"9135": "public class DocumentToPDFConvert { \npublic File convertDocumentToPDF ( File inputDocumentParam ) { \nif ( inputDocumentParam == null || ! inputDocumentParam . exists ( ) ) { \nthrow new UtilException ( \"Input document to convert not provided or does not exist.\" , UtilException . ErrorCode . COMMAND ) ; \n} \nif ( ! inputDocumentParam . isFile ( ) ) { \nthrow new UtilException ( \"Input document '' is not a file.\" , UtilException . ErrorCode . COMMAND ) ; \n} \nFile parentFolder = inputDocumentParam . getParentFile ( ) ; \nString inputFilenameWithoutExt = inputDocumentParam . getName ( ) ; \nint indexOfDot = - 1 ; \nif ( - 1 < ( indexOfDot = inputFilenameWithoutExt . indexOf ( '.' ) ) ) { \ninputFilenameWithoutExt = inputFilenameWithoutExt . substring ( 0 , indexOfDot ) ; \n} \nFile generatedPdfFileOut = new File ( parentFolder . getAbsolutePath ( ) . concat ( File . separator ) . concat ( inputFilenameWithoutExt ) . concat ( \".pdf\" ) ) ; \nString completeOutputPath = generatedPdfFileOut . getAbsolutePath ( ) ; \ntry { \nCommandUtil . CommandResult commandResult = this . commandUtil . executeCommand ( CommandUtil . FLUID_CLI , COMMAND_CONVERT_DOC_TO_PDF , \"-i\" , inputDocumentParam . getAbsolutePath ( ) , \"-o\" , completeOutputPath ) ; \nif ( commandResult . getExitCode ( ) != 0 ) { \nthrow new UtilException ( \"Unable to convert '\" + inputDocumentParam . getName ( ) + \"' to PDF. \" + commandResult . toString ( ) , UtilException . ErrorCode . COMMAND ) ; \n} \nFile returnVal = new File ( completeOutputPath ) ; \nif ( ! returnVal . exists ( ) ) { \nthrow new UtilException ( \"Command executed, but no output file. Expected PDF at '\" + completeOutputPath + \"'.\" , UtilException . ErrorCode . GENERAL ) ; \n} \nreturn returnVal ; \n} \ncatch ( IOException eParam ) { \nthrow new UtilException ( \"Problem executing command. \" + eParam . getMessage ( ) , eParam , UtilException . ErrorCode . GENERAL ) ; \n} \n} \n} \n"}
{"9136": "public class SQLUtilWebSocketRESTWrapper { \nprivate List < Field > getFieldValuesForFormFromCache ( Long formIdParam , List < FormFieldListing > listingReturnFieldValsPopulatedParam , Form [ ] formsToFetchForLocalCacheArrParam ) { \nif ( formIdParam == null || 1 > formIdParam . longValue ( ) ) { \nreturn null ; \n} \nif ( listingReturnFieldValsPopulatedParam == null || listingReturnFieldValsPopulatedParam . isEmpty ( ) ) { \nreturn null ; \n} \nif ( formsToFetchForLocalCacheArrParam == null || formsToFetchForLocalCacheArrParam . length == 0 ) { \nreturn null ; \n} \nfor ( Form formIter : formsToFetchForLocalCacheArrParam ) { \nif ( formIdParam . equals ( formIter . getId ( ) ) ) { \nString echoToUse = formIter . getEcho ( ) ; \nfor ( FormFieldListing fieldListing : listingReturnFieldValsPopulatedParam ) { \nif ( echoToUse . equals ( fieldListing . getEcho ( ) ) ) { \nreturn fieldListing . getListing ( ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"9178": "public class SQLFormDefinitionUtil { \npublic Map < Long , String > getFormDefinitionIdAndTitle ( ) { \nif ( ! LOCAL_MAPPING . isEmpty ( ) ) { \nMap < Long , String > returnVal = new HashMap < > ( LOCAL_MAPPING ) ; \nif ( timeToUpdateAgain < System . currentTimeMillis ( ) ) { \nsynchronized ( LOCAL_MAPPING ) { \nLOCAL_MAPPING . clear ( ) ; \n} \n} \nreturn returnVal ; \n} \nsynchronized ( LOCAL_MAPPING ) { \nif ( ! LOCAL_MAPPING . isEmpty ( ) ) { \nreturn new HashMap < > ( LOCAL_MAPPING ) ; \n} \nPreparedStatement preparedStatement = null ; \nResultSet resultSet = null ; \ntry { \nISyntax syntax = SyntaxFactory . getInstance ( ) . getSyntaxFor ( this . getSQLTypeFromConnection ( ) , ISyntax . ProcedureMapping . FormDefinition . GetFormDefinitions ) ; \npreparedStatement = this . getConnection ( ) . prepareStatement ( syntax . getPreparedStatement ( ) ) ; \nresultSet = preparedStatement . executeQuery ( ) ; \nwhile ( resultSet . next ( ) ) { \nLong id = resultSet . getLong ( 1 ) ; \nString title = resultSet . getString ( 2 ) ; \nLOCAL_MAPPING . put ( id , title ) ; \n} \ntimeToUpdateAgain = ( System . currentTimeMillis ( ) + TimeUnit . MINUTES . toMillis ( 10 ) ) ; \n} \ncatch ( SQLException sqlError ) { \nthrow new FluidSQLException ( sqlError ) ; \n} \nfinally { \nthis . closeStatement ( preparedStatement , resultSet ) ; \n} \nreturn new HashMap < > ( LOCAL_MAPPING ) ; \n} \n} \n} \n"}
{"9188": "public class ABaseClientWS { \nprivate ResponseHandler < String > getJsonResponseHandler ( final String urlCalledParam ) { \nResponseHandler < String > responseHandler = new ResponseHandler < String > ( ) { \npublic String handleResponse ( final HttpResponse responseParam ) throws IOException { \nint status = responseParam . getStatusLine ( ) . getStatusCode ( ) ; \nif ( status == 404 ) { \nthrow new FluidClientException ( \"Endpoint for Service not found. URL [\" + urlCalledParam + \"].\" , FluidClientException . ErrorCode . CONNECT_ERROR ) ; \n} \nelse if ( 200 <= status && 300 > status ) { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; \nreturn responseJsonString ; \n} \nelse if ( status == 400 ) { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseJsonString = ( entity == null ) ? null : EntityUtils . toString ( entity ) ; \nreturn responseJsonString ; \n} \nelse { \nHttpEntity entity = responseParam . getEntity ( ) ; \nString responseString = ( entity != null ) ? EntityUtils . toString ( entity ) : null ; \nthrow new FluidClientException ( \"Unexpected response status: \" + status + \". \" + responseParam . getStatusLine ( ) . getReasonPhrase ( ) + \". \\nResponse Text [\" + responseString + \"]\" , FluidClientException . ErrorCode . IO_ERROR ) ; \n} \n} \n} \n; \nreturn responseHandler ; \n} \n} \n"}
{"9234": "public class HeaderGridView { \npublic boolean removeFooterView ( View v ) { \nif ( 0 < mFooterViewInfos . size ( ) ) { \nboolean result = false ; \nif ( mAdapter != null && ( ( FooterViewGridAdapter ) mAdapter ) . removeFooter ( v ) ) { \nnotifiyChanged ( ) ; \nresult = true ; \n} \nremoveFixedViewInfo ( v , mFooterViewInfos ) ; \nreturn result ; \n} \nreturn false ; \n} \n} \n"}
{"9262": "public class BasicTaskWrapper { \npublic void run ( ) { \nthis . runThread = Thread . currentThread ( ) ; \nlong runTime = getElapsedTime ( ) ; \nif ( 0l < startTimeout && startTimeout <= runTime ) { \ntaskRejected ( new StartTimeoutException ( \"Start Timeout exceeded for task \" + taskString ) ) ; \nreturn ; \n} \nboolean stopped = false ; \nsynchronized ( stateLock ) { \nif ( state == TASK_STOPPED ) { \nstopped = true ; \n} \nelse { \nstate = TASK_STARTED ; \ntaskStarted ( ) ; \nif ( waitType == Task . WAIT_FOR_START ) stateLock . notifyAll ( ) ; \n} \n} \nif ( stopped ) { \ntaskRejected ( new TaskStoppedException ( \"Task stopped for task \" + taskString ) ) ; \nreturn ; \n} \nThrowable throwable = null ; \ntry { \ntask . execute ( ) ; \n} \ncatch ( Throwable t ) { \nthrowable = t ; \n} \ntaskCompleted ( throwable ) ; \nsynchronized ( stateLock ) { \nstate = TASK_COMPLETED ; \nif ( waitType == Task . WAIT_FOR_COMPLETE ) stateLock . notifyAll ( ) ; \n} \n} \n} \n"}
{"9275": "public class Catalog { \nprotected void copyReaders ( Catalog newCatalog ) { \nVector mapArr = new Vector ( readerMap . size ( ) ) ; \nfor ( int count = 0 ; \nreaderMap . size ( ) > count ; \ncount ++ ) { \nmapArr . add ( null ) ; \n} \nEnumeration enumt = readerMap . keys ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nString mimeType = ( String ) enumt . nextElement ( ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nmapArr . set ( pos . intValue ( ) , mimeType ) ; \n} \nfor ( int count = 0 ; \nmapArr . size ( ) > count ; \ncount ++ ) { \nString mimeType = ( String ) mapArr . get ( count ) ; \nInteger pos = ( Integer ) readerMap . get ( mimeType ) ; \nnewCatalog . addReader ( mimeType , ( CatalogReader ) readerArr . get ( pos . intValue ( ) ) ) ; \n} \n} \n} \n"}
{"9277": "public class Catalog { \npublic void loadSystemCatalogs ( ) throws MalformedURLException , IOException { \nVector catalogs = catalogManager . getCatalogFiles ( ) ; \nif ( catalogs != null ) { \nfor ( int count = 0 ; \ncatalogs . size ( ) > count ; \ncount ++ ) { \ncatalogFiles . addElement ( catalogs . elementAt ( count ) ) ; \n} \n} \nif ( 0 < catalogFiles . size ( ) ) { \nString catfile = ( String ) catalogFiles . lastElement ( ) ; \ncatalogFiles . removeElement ( catfile ) ; \nparseCatalog ( catfile ) ; \n} \n} \n} \n"}
{"9278": "public class Catalog { \npublic synchronized void parseCatalog ( URL aUrl ) throws IOException { \ncatalogCwd = aUrl ; \nbase = aUrl ; \ndefault_override = catalogManager . getPreferPublic ( ) ; \ncatalogManager . debug . message ( 4 , \"Parse catalog: \" + aUrl . toString ( ) ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nfor ( int count = 0 ; \n! parsed && readerArr . size ( ) > count ; \ncount ++ ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \ninStream = new DataInputStream ( aUrl . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { \nbreak ; \n} \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( parsed ) parsePendingCatalogs ( ) ; \n} \n} \n"}
{"9279": "public class Catalog { \nprotected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncatalogFiles . size ( ) > curCat ; \ncurCat ++ ) { \nString catfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \nwhile ( ! catalogFiles . isEmpty ( ) ) { \nString catfile = ( String ) catalogFiles . elementAt ( 0 ) ; \ntry { \ncatalogFiles . remove ( 0 ) ; \n} \ncatch ( ArrayIndexOutOfBoundsException e ) { \n} \nif ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) { \ntry { \nparseCatalogFile ( catfile ) ; \n} \ncatch ( CatalogException ce ) { \nSystem . out . println ( \"FIXME: \" + ce . toString ( ) ) ; \n} \n} \nelse { \ncatalogs . addElement ( catfile ) ; \n} \nif ( ! localCatalogFiles . isEmpty ( ) ) { \nVector newQueue = new Vector ( ) ; \nEnumeration q = localCatalogFiles . elements ( ) ; \nwhile ( q . hasMoreElements ( ) ) { \nnewQueue . addElement ( q . nextElement ( ) ) ; \n} \nfor ( int curCat = 0 ; \ncatalogFiles . size ( ) > curCat ; \ncurCat ++ ) { \ncatfile = ( String ) catalogFiles . elementAt ( curCat ) ; \nnewQueue . addElement ( catfile ) ; \n} \ncatalogFiles = newQueue ; \nlocalCatalogFiles . clear ( ) ; \n} \nif ( ! localDelegate . isEmpty ( ) ) { \nEnumeration e = localDelegate . elements ( ) ; \nwhile ( e . hasMoreElements ( ) ) { \ncatalogEntries . addElement ( e . nextElement ( ) ) ; \n} \nlocalDelegate . clear ( ) ; \n} \n} \ncatalogFiles . clear ( ) ; \n} \n} \n"}
{"9280": "public class Catalog { \nprotected synchronized void parseCatalogFile ( String fileName ) throws MalformedURLException , IOException , CatalogException { \ntry { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogCwd = new URL ( \"file:\" + userdir + \"/basename\" ) ; \n} \ncatch ( MalformedURLException e ) { \nString userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; \ncatalogManager . debug . message ( 1 , \"Malformed URL on cwd\" , userdir ) ; \ncatalogCwd = null ; \n} \ntry { \nbase = new URL ( catalogCwd , fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e ) { \ntry { \nbase = new URL ( \"file:\" + fixSlashes ( fileName ) ) ; \n} \ncatch ( MalformedURLException e2 ) { \ncatalogManager . debug . message ( 1 , \"Malformed URL on catalog filename\" , fixSlashes ( fileName ) ) ; \nbase = null ; \n} \n} \ncatalogManager . debug . message ( 2 , \"Loading catalog\" , fileName ) ; \ncatalogManager . debug . message ( 4 , \"Default BASE\" , base . toString ( ) ) ; \nfileName = base . toString ( ) ; \nDataInputStream inStream = null ; \nboolean parsed = false ; \nboolean notFound = false ; \nfor ( int count = 0 ; \n! parsed && readerArr . size ( ) > count ; \ncount ++ ) { \nCatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; \ntry { \nnotFound = false ; \ninStream = new DataInputStream ( base . openStream ( ) ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \nnotFound = true ; \nbreak ; \n} \ntry { \nreader . readCatalog ( this , inStream ) ; \nparsed = true ; \n} \ncatch ( CatalogException ce ) { \nif ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { \nbreak ; \n} \nelse { \n} \n} \ntry { \ninStream . close ( ) ; \n} \ncatch ( IOException e ) { \n} \n} \nif ( ! parsed ) { \nif ( notFound ) { \ncatalogManager . debug . message ( 3 , \"Catalog does not exist\" , fileName ) ; \n} \nelse { \ncatalogManager . debug . message ( 1 , \"Failed to parse catalog\" , fileName ) ; \n} \n} \n} \n} \n"}
{"9281": "public class Catalog { \npublic void unknownEntry ( Vector strings ) { \nif ( strings != null && 0 < strings . size ( ) ) { \nString keyword = ( String ) strings . elementAt ( 0 ) ; \ncatalogManager . debug . message ( 2 , \"Unrecognized token parsing catalog\" , keyword ) ; \n} \n} \n} \n"}
{"9282": "public class Catalog { \npublic void parseAllCatalogs ( ) throws MalformedURLException , IOException { \nfor ( int catPos = 0 ; \ncatalogs . size ( ) > catPos ; \ncatPos ++ ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \nc . parseCatalog ( catfile ) ; \ncatalogs . setElementAt ( c , catPos ) ; \nc . parseAllCatalogs ( ) ; \n} \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DELEGATE_PUBLIC || e . getEntryType ( ) == DELEGATE_SYSTEM || e . getEntryType ( ) == DELEGATE_URI ) { \nCatalog dcat = newCatalog ( ) ; \ndcat . parseCatalog ( e . getEntryArg ( 1 ) ) ; \n} \n} \n} \n} \n"}
{"9286": "public class Catalog { \nprotected String resolveLocalURI ( String uri ) throws MalformedURLException , IOException { \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == URI && ( e . getEntryArg ( 0 ) . equals ( uri ) ) ) { \nreturn e . getEntryArg ( 1 ) ; \n} \n} \nenumt = catalogEntries . elements ( ) ; \nString startString = null ; \nString prefix = null ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == REWRITE_URI ) { \nString p = e . getEntryArg ( 0 ) ; \nif ( uri . length ( ) >= p . length ( ) && p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) { \nif ( startString == null || startString . length ( ) < p . length ( ) ) { \nstartString = p ; \nprefix = e . getEntryArg ( 1 ) ; \n} \n} \n} \nif ( prefix != null ) { \nreturn prefix + uri . substring ( startString . length ( ) ) ; \n} \n} \nenumt = catalogEntries . elements ( ) ; \nVector delCats = new Vector ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == DELEGATE_URI ) { \nString p = e . getEntryArg ( 0 ) ; \nif ( uri . length ( ) >= p . length ( ) && p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) { \ndelCats . addElement ( e . getEntryArg ( 1 ) ) ; \n} \n} \n} \nif ( 0 < delCats . size ( ) ) { \nEnumeration enumCats = delCats . elements ( ) ; \nif ( 1 < catalogManager . debug . getDebug ( ) ) { \ncatalogManager . debug . message ( 2 , \"Switching to delegated catalog(s):\" ) ; \nwhile ( enumCats . hasMoreElements ( ) ) { \nString delegatedCatalog = ( String ) enumCats . nextElement ( ) ; \ncatalogManager . debug . message ( 2 , \"\\t\" + delegatedCatalog ) ; \n} \n} \nCatalog dcat = newCatalog ( ) ; \nenumCats = delCats . elements ( ) ; \nwhile ( enumCats . hasMoreElements ( ) ) { \nString delegatedCatalog = ( String ) enumCats . nextElement ( ) ; \ndcat . parseCatalog ( delegatedCatalog ) ; \n} \nreturn dcat . resolveURI ( uri ) ; \n} \nreturn null ; \n} \n} \n"}
{"9287": "public class Catalog { \nprotected synchronized String resolveSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nfor ( int catPos = 0 ; \ncatalogs . size ( ) > catPos ; \ncatPos ++ ) { \nCatalog c = null ; \ntry { \nc = ( Catalog ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == DOCUMENT ) { \nresolved = c . resolveDocument ( ) ; \n} \nelse if ( entityType == ENTITY ) { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == NOTATION ) { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \n} \nelse if ( entityType == PUBLIC ) { \nresolved = c . resolvePublic ( publicId , systemId ) ; \n} \nelse if ( entityType == SYSTEM ) { \nresolved = c . resolveSystem ( systemId ) ; \n} \nelse if ( entityType == URI ) { \nresolved = c . resolveURI ( systemId ) ; \n} \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9289": "public class Catalog { \nprotected String normalizeURI ( String uriref ) { \nString newRef = \"\" ; \nbyte [ ] bytes ; \nif ( uriref == null ) { \nreturn null ; \n} \ntry { \nbytes = uriref . getBytes ( \"UTF-8\" ) ; \n} \ncatch ( UnsupportedEncodingException uee ) { \ncatalogManager . debug . message ( 1 , \"UTF-8 is an unsupported encoding!?\" ) ; \nreturn uriref ; \n} \nfor ( int count = 0 ; \nbytes . length > count ; \ncount ++ ) { \nint ch = bytes [ count ] & 0xFF ; \nif ( ( 0x20 >= ch ) || ( 0x7F < ch ) || ( ch == 0x22 ) || ( ch == 0x3C ) || ( ch == 0x3E ) || ( ch == 0x5C ) || ( ch == 0x5E ) || ( ch == 0x60 ) || ( ch == 0x7B ) || ( ch == 0x7C ) || ( ch == 0x7D ) || ( ch == 0x7F ) ) { \nnewRef += encodedByte ( ch ) ; \n} \nelse { \nnewRef += ( char ) bytes [ count ] ; \n} \n} \nreturn newRef ; \n} \n} \n"}
{"9290": "public class Catalog { \nprotected String encodedByte ( int b ) { \nString hex = Integer . toHexString ( b ) . toUpperCase ( ) ; \nif ( 2 > hex . length ( ) ) { \nreturn \"%0\" + hex ; \n} \nelse { \nreturn \"%\" + hex ; \n} \n} \n} \n"}
{"9291": "public class Catalog { \nprotected void addDelegate ( CatalogEntry entry ) { \nint pos = 0 ; \nString partial = entry . getEntryArg ( 0 ) ; \nEnumeration local = localDelegate . elements ( ) ; \nwhile ( local . hasMoreElements ( ) ) { \nCatalogEntry dpe = ( CatalogEntry ) local . nextElement ( ) ; \nString dp = dpe . getEntryArg ( 0 ) ; \nif ( dp . equals ( partial ) ) { \nreturn ; \n} \nif ( partial . length ( ) < dp . length ( ) ) { \npos ++ ; \n} \nif ( partial . length ( ) > dp . length ( ) ) { \nbreak ; \n} \n} \nif ( localDelegate . size ( ) == 0 ) { \nlocalDelegate . addElement ( entry ) ; \n} \nelse { \nlocalDelegate . insertElementAt ( entry , pos ) ; \n} \n} \n} \n"}
{"9293": "public class ThrowableHandler { \nprotected static void fireOnThrowable ( int type , Throwable t ) { \nObject [ ] list = listeners . toArray ( ) ; \nfor ( int i = 0 ; \nlist . length > i ; \ni ++ ) { \n( ( ThrowableListener ) list [ i ] ) . onThrowable ( type , t ) ; \n} \n} \n} \n"}
{"9307": "public class TimeoutPriorityQueueImpl { \nprivate TimeoutExtImpl removeNode ( int index ) { \nTimeoutExtImpl res = queue [ index ] ; \nif ( index == size ) { \n-- size ; \nqueue [ index ] = null ; \nreturn res ; \n} \nswap ( index , size ) ; \n-- size ; \nqueue [ res . index ] = null ; \nif ( normalizeUp ( index ) ) return res ; \nlong t = queue [ index ] . time ; \nint c = index << 1 ; \nwhile ( size >= c ) { \nTimeoutExtImpl l = queue [ c ] ; \nif ( size >= c + 1 ) { \nTimeoutExtImpl r = queue [ c + 1 ] ; \nif ( r . time >= l . time ) { \nif ( l . time >= t ) break ; \nswap ( index , c ) ; \nindex = c ; \n} \nelse { \nif ( r . time >= t ) break ; \nswap ( index , c + 1 ) ; \nindex = c + 1 ; \n} \n} \nelse { \nif ( l . time >= t ) break ; \nswap ( index , c ) ; \nindex = c ; \n} \nc = index << 1 ; \n} \nreturn res ; \n} \n} \n"}
{"9310": "public class URLStreamHandlerFactory { \n@ SuppressWarnings ( \"unused\" ) public static void preload ( ) { \nfor ( int i = 0 ; \nPROTOCOLS . length > i ; \ni ++ ) { \ntry { \nURL url = new URL ( PROTOCOLS [ i ] , \"\" , - 1 , \"\" ) ; \nlog . trace ( \"Loaded protocol: \" + PROTOCOLS [ i ] ) ; \n} \ncatch ( Exception e ) { \nlog . warn ( \"Failed to load protocol: \" + PROTOCOLS [ i ] , e ) ; \n} \n} \n} \n} \n"}
{"9311": "public class URLStreamHandlerFactory { \npublic URLStreamHandler createURLStreamHandler ( final String protocol ) { \nURLStreamHandler handler = ( URLStreamHandler ) handlerMap . get ( protocol ) ; \nif ( handler != null ) return handler ; \nString prevProtocol = ( String ) createURLStreamHandlerProtocol . get ( ) ; \nif ( prevProtocol != null && prevProtocol . equals ( protocol ) ) return null ; \ncreateURLStreamHandlerProtocol . set ( protocol ) ; \ncheckHandlerPkgs ( ) ; \nClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; \nfor ( int p = 0 ; \nhandlerPkgs . length > p ; \np ++ ) { \ntry { \nString classname = handlerPkgs [ p ] + \".\" + protocol + \".Handler\" ; \nClass < ? > type = null ; \ntry { \ntype = ctxLoader . loadClass ( classname ) ; \n} \ncatch ( ClassNotFoundException e ) { \ntype = Class . forName ( classname ) ; \n} \nif ( type != null ) { \nhandler = ( URLStreamHandler ) type . newInstance ( ) ; \nhandlerMap . put ( protocol , handler ) ; \nlog . trace ( \"Found protocol:\" + protocol + \" handler:\" + handler ) ; \n} \n} \ncatch ( Throwable ignore ) { \n} \n} \ncreateURLStreamHandlerProtocol . set ( null ) ; \nreturn handler ; \n} \n} \n"}
{"9318": "public class NotifyingBufferedOutputStream { \npublic void checkNotification ( int result ) { \nchunk += result ; \nif ( chunkSize <= chunk ) { \nif ( listener != null ) listener . onStreamNotification ( this , chunk ) ; \nchunk = 0 ; \n} \n} \n} \n"}
{"9319": "public class NonSerializableFactory { \npublic static synchronized void rebind ( Name name , Object target , boolean createSubcontexts ) throws NamingException { \nString key = name . toString ( ) ; \nInitialContext ctx = new InitialContext ( ) ; \nif ( createSubcontexts == true && 1 < name . size ( ) ) { \nint size = name . size ( ) - 1 ; \nUtil . createSubcontext ( ctx , name . getPrefix ( size ) ) ; \n} \nrebind ( ctx , key , target ) ; \n} \n} \n"}
{"9322": "public class Strings { \npublic static String [ ] split ( final String string , final String delim , final int limit ) { \nint count = count ( string , delim ) + 1 ; \nif ( 0 < limit && limit < count ) { \ncount = limit ; \n} \nString strings [ ] = new String [ count ] ; \nint begin = 0 ; \nfor ( int i = 0 ; \ncount > i ; \ni ++ ) { \nint end = string . indexOf ( delim , begin ) ; \nif ( end == - 1 || i + 1 == count ) end = string . length ( ) ; \nif ( end == 0 ) strings [ i ] = EMPTY ; \nelse strings [ i ] = string . substring ( begin , end ) ; \nbegin = end + 1 ; \n} \nreturn strings ; \n} \n} \n"}
{"9323": "public class Strings { \npublic static String join ( final byte array [ ] ) { \nByte bytes [ ] = new Byte [ array . length ] ; \nfor ( int i = 0 ; \nbytes . length > i ; \ni ++ ) { \nbytes [ i ] = new Byte ( array [ i ] ) ; \n} \nreturn join ( bytes , null ) ; \n} \n} \n"}
{"9332": "public class TimedCachePolicy { \npublic synchronized void setResolution ( int resolution ) { \nif ( 0 >= resolution ) resolution = 60 ; \nif ( resolution != this . resolution ) { \nthis . resolution = resolution ; \ntheTimer . cancel ( ) ; \ntheTimer = new ResolutionTimer ( ) ; \nresolutionTimer . scheduleAtFixedRate ( theTimer , 0 , 1000 * resolution ) ; \n} \n} \n} \n"}
{"9334": "public class XmlHelper { \npublic static Iterator getChildrenByTagName ( Element element , String tagName ) { \nif ( element == null ) return null ; \nNodeList children = element . getChildNodes ( ) ; \nArrayList goodChildren = new ArrayList ( ) ; \nfor ( int i = 0 ; \nchildren . getLength ( ) > i ; \ni ++ ) { \nNode currentChild = children . item ( i ) ; \nif ( currentChild . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) currentChild ) . getTagName ( ) . equals ( tagName ) ) { \ngoodChildren . add ( currentChild ) ; \n} \n} \nreturn goodChildren . iterator ( ) ; \n} \n} \n"}
{"9337": "public class XmlHelper { \npublic static String getElementContent ( Element element , String defaultStr ) throws Exception { \nif ( element == null ) return defaultStr ; \nNodeList children = element . getChildNodes ( ) ; \nString result = \"\" ; \nfor ( int i = 0 ; \nchildren . getLength ( ) > i ; \ni ++ ) { \nif ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { \nresult += children . item ( i ) . getNodeValue ( ) ; \n} \nelse if ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { \n} \n} \nreturn result . trim ( ) ; \n} \n} \n"}
{"9344": "public class Resolver { \npublic String resolveSystem ( String systemId ) throws MalformedURLException , IOException { \nString resolved = super . resolveSystem ( systemId ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == RESOLVER ) { \nresolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; \nif ( resolved != null ) { \nreturn resolved ; \n} \n} \nelse if ( e . getEntryType ( ) == SYSTEMSUFFIX ) { \nString suffix = e . getEntryArg ( 0 ) ; \nString result = e . getEntryArg ( 1 ) ; \nif ( systemId . length ( ) >= suffix . length ( ) && systemId . substring ( systemId . length ( ) - suffix . length ( ) ) . equals ( suffix ) ) { \nreturn result ; \n} \n} \n} \nreturn resolveSubordinateCatalogs ( Catalog . SYSTEM , null , null , systemId ) ; \n} \n} \n"}
{"9348": "public class Resolver { \nprotected Resolver queryResolver ( String resolver , String command , String arg1 , String arg2 ) { \nString RFC2483 = resolver + \"?command=\" + command + \"&format=tr9401&uri=\" + arg1 + \"&uri2=\" + arg2 ; \ntry { \nURL url = new URL ( RFC2483 ) ; \nURLConnection urlCon = url . openConnection ( ) ; \nurlCon . setUseCaches ( false ) ; \nResolver r = ( Resolver ) newCatalog ( ) ; \nString cType = urlCon . getContentType ( ) ; \nif ( 0 < cType . indexOf ( \";\" ) ) { \ncType = cType . substring ( 0 , cType . indexOf ( \";\" ) ) ; \n} \nr . parseCatalog ( cType , urlCon . getInputStream ( ) ) ; \nreturn r ; \n} \ncatch ( CatalogException cex ) { \nif ( cex . getExceptionType ( ) == CatalogException . UNPARSEABLE ) { \ncatalogManager . debug . message ( 1 , \"Unparseable catalog: \" + RFC2483 ) ; \n} \nelse if ( cex . getExceptionType ( ) == CatalogException . UNKNOWN_FORMAT ) { \ncatalogManager . debug . message ( 1 , \"Unknown catalog format: \" + RFC2483 ) ; \n} \nreturn null ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed resolver URL: \" + RFC2483 ) ; \nreturn null ; \n} \ncatch ( IOException ie ) { \ncatalogManager . debug . message ( 1 , \"I/O Exception opening resolver: \" + RFC2483 ) ; \nreturn null ; \n} \n} \n} \n"}
{"9349": "public class Resolver { \nprivate Vector appendVector ( Vector vec , Vector appvec ) { \nif ( appvec != null ) { \nfor ( int count = 0 ; \nappvec . size ( ) > count ; \ncount ++ ) { \nvec . addElement ( appvec . elementAt ( count ) ) ; \n} \n} \nreturn vec ; \n} \n} \n"}
{"9351": "public class Resolver { \npublic String resolveSystemReverse ( String systemId ) throws MalformedURLException , IOException { \nVector resolved = resolveAllSystemReverse ( systemId ) ; \nif ( resolved != null && 0 < resolved . size ( ) ) { \nreturn ( String ) resolved . elementAt ( 0 ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"9352": "public class Resolver { \npublic Vector resolveAllSystem ( String systemId ) throws MalformedURLException , IOException { \nVector resolutions = new Vector ( ) ; \nif ( systemId != null ) { \nVector localResolutions = resolveAllLocalSystem ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \n} \nVector subResolutions = resolveAllSubordinateCatalogs ( SYSTEM , null , null , systemId ) ; \nresolutions = appendVector ( resolutions , subResolutions ) ; \nif ( 0 < resolutions . size ( ) ) { \nreturn resolutions ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"9353": "public class Resolver { \nprivate Vector resolveAllLocalSystem ( String systemId ) { \nVector map = new Vector ( ) ; \nString osname = System . getProperty ( \"os.name\" ) ; \nboolean windows = ( 0 <= osname . indexOf ( \"Windows\" ) ) ; \nEnumeration enumt = catalogEntries . elements ( ) ; \nwhile ( enumt . hasMoreElements ( ) ) { \nCatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; \nif ( e . getEntryType ( ) == SYSTEM && ( e . getEntryArg ( 0 ) . equals ( systemId ) || ( windows && e . getEntryArg ( 0 ) . equalsIgnoreCase ( systemId ) ) ) ) { \nmap . addElement ( e . getEntryArg ( 1 ) ) ; \n} \n} \nif ( map . size ( ) == 0 ) { \nreturn null ; \n} \nelse { \nreturn map ; \n} \n} \n} \n"}
{"9354": "public class Resolver { \nprivate synchronized Vector resolveAllSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { \nVector resolutions = new Vector ( ) ; \nfor ( int catPos = 0 ; \ncatalogs . size ( ) > catPos ; \ncatPos ++ ) { \nResolver c = null ; \ntry { \nc = ( Resolver ) catalogs . elementAt ( catPos ) ; \n} \ncatch ( ClassCastException e ) { \nString catfile = ( String ) catalogs . elementAt ( catPos ) ; \nc = ( Resolver ) newCatalog ( ) ; \ntry { \nc . parseCatalog ( catfile ) ; \n} \ncatch ( MalformedURLException mue ) { \ncatalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; \n} \ncatch ( FileNotFoundException fnfe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; \n} \ncatch ( IOException ioe ) { \ncatalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; \n} \ncatalogs . setElementAt ( c , catPos ) ; \n} \nString resolved = null ; \nif ( entityType == DOCTYPE ) { \nresolved = c . resolveDoctype ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == DOCUMENT ) { \nresolved = c . resolveDocument ( ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == ENTITY ) { \nresolved = c . resolveEntity ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == NOTATION ) { \nresolved = c . resolveNotation ( entityName , publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == PUBLIC ) { \nresolved = c . resolvePublic ( publicId , systemId ) ; \nif ( resolved != null ) { \nresolutions . addElement ( resolved ) ; \nreturn resolutions ; \n} \n} \nelse if ( entityType == SYSTEM ) { \nVector localResolutions = c . resolveAllSystem ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \nbreak ; \n} \nelse if ( entityType == SYSTEMREVERSE ) { \nVector localResolutions = c . resolveAllSystemReverse ( systemId ) ; \nresolutions = appendVector ( resolutions , localResolutions ) ; \n} \n} \nif ( resolutions != null ) { \nreturn resolutions ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"9370": "public class Objects { \npublic static Constructor getCompatibleConstructor ( final Class type , final Class valueType ) { \ntry { \nreturn type . getConstructor ( new Class [ ] { \nvalueType } \n) ; \n} \ncatch ( Exception ignore ) { \nClass [ ] types = type . getClasses ( ) ; \nfor ( int i = 0 ; \ntypes . length > i ; \ni ++ ) { \ntry { \nreturn type . getConstructor ( new Class [ ] { \ntypes [ i ] } \n) ; \n} \ncatch ( Exception ignore2 ) { \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"9378": "public class PropertyMap { \nprivate void firePropertyAdded ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \nfor ( int i = 0 ; \nsize > i ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyAdded ( event ) ; \n} \n} \n} \n"}
{"9379": "public class PropertyMap { \nprivate void firePropertyRemoved ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \nfor ( int i = 0 ; \nsize > i ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyRemoved ( event ) ; \n} \n} \n} \n"}
{"9380": "public class PropertyMap { \nprivate void firePropertyChanged ( List list , PropertyEvent event ) { \nif ( list == null ) return ; \nint size = list . size ( ) ; \nfor ( int i = 0 ; \nsize > i ; \ni ++ ) { \nPropertyListener listener = ( PropertyListener ) list . get ( i ) ; \nlistener . propertyChanged ( event ) ; \n} \n} \n} \n"}
{"9389": "public class JBossEntityResolver { \nprotected InputSource resolveClasspathName ( String systemId , boolean trace ) { \nif ( systemId == null ) return null ; \nif ( trace ) log . trace ( \"resolveClasspathName, systemId=\" + systemId ) ; \nString filename = systemId ; \ntry { \nURI url = new URI ( systemId ) ; \nString path = url . getPath ( ) ; \nif ( path == null ) path = url . getSchemeSpecificPart ( ) ; \nint slash = path . lastIndexOf ( '/' ) ; \nif ( 0 <= slash ) filename = path . substring ( slash + 1 ) ; \nelse filename = path ; \nif ( filename . length ( ) == 0 ) return null ; \nif ( trace ) log . trace ( \"Mapped systemId to filename: \" + filename ) ; \n} \ncatch ( URISyntaxException e ) { \nif ( trace ) log . trace ( \"systemId: is not a URI, using systemId as resource\" , e ) ; \n} \nInputStream is = loadClasspathResource ( filename , trace ) ; \nInputSource inputSource = null ; \nif ( is != null ) { \ninputSource = new InputSource ( is ) ; \ninputSource . setSystemId ( systemId ) ; \n} \nreturn inputSource ; \n} \n} \n"}
{"9391": "public class PublicId { \npublic static String normalize ( String publicId ) { \nString normal = publicId . replace ( '\\t' , ' ' ) ; \nnormal = normal . replace ( '\\r' , ' ' ) ; \nnormal = normal . replace ( '\\n' , ' ' ) ; \nnormal = normal . trim ( ) ; \nint pos ; \nwhile ( 0 <= ( pos = normal . indexOf ( \"  \" ) ) ) { \nnormal = normal . substring ( 0 , pos ) + normal . substring ( pos + 1 ) ; \n} \nreturn normal ; \n} \n} \n"}
{"9394": "public class PublicId { \nprivate static String stringReplace ( String str , String oldStr , String newStr ) { \nString result = \"\" ; \nint pos = str . indexOf ( oldStr ) ; \nwhile ( 0 <= pos ) { \nresult += str . substring ( 0 , pos ) ; \nresult += newStr ; \nstr = str . substring ( pos + 1 ) ; \npos = str . indexOf ( oldStr ) ; \n} \nreturn result + str ; \n} \n} \n"}
{"9399": "public class HashCode { \npublic static int generate ( final byte [ ] bytes ) { \nint hashcode = 0 ; \nfor ( int i = 0 ; \nbytes . length > i ; \ni ++ ) { \nhashcode <<= 1 ; \nhashcode ^= bytes [ i ] ; \n} \nreturn hashcode ; \n} \n} \n"}
{"9400": "public class HashCode { \npublic static int generate ( final Object array [ ] , final boolean deep ) { \nint hashcode = 0 ; \nfor ( int i = 0 ; \narray . length > i ; \ni ++ ) { \nif ( deep && ( array [ i ] instanceof Object [ ] ) ) { \nhashcode ^= generate ( ( Object [ ] ) array [ i ] , true ) ; \n} \nelse { \nhashcode ^= array [ i ] . hashCode ( ) ; \n} \n} \nreturn hashcode ; \n} \n} \n"}
{"9403": "public class TextCatalogReader { \nprotected String nextToken ( ) throws IOException { \nString token = \"\" ; \nint ch , nextch ; \nif ( ! tokenStack . empty ( ) ) { \nreturn ( String ) tokenStack . pop ( ) ; \n} \nwhile ( true ) { \nch = catfile . read ( ) ; \nwhile ( ' ' >= ch ) { \nch = catfile . read ( ) ; \nif ( 0 > ch ) { \nreturn null ; \n} \n} \nnextch = catfile . read ( ) ; \nif ( 0 > nextch ) { \nreturn null ; \n} \nif ( ch == '-' && nextch == '-' ) { \nch = ' ' ; \nnextch = nextChar ( ) ; \nwhile ( ch != '-' || nextch != '-' ) { \nch = nextch ; \nnextch = nextChar ( ) ; \n} \n} \nelse { \nstack [ ++ top ] = nextch ; \nstack [ ++ top ] = ch ; \nbreak ; \n} \n} \nch = nextChar ( ) ; \nif ( ch == '\"' || ch == '\\'' ) { \nint quote = ch ; \nwhile ( ( ch = nextChar ( ) ) != quote ) { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \n} \nreturn token ; \n} \nelse { \nwhile ( ' ' < ch ) { \nnextch = nextChar ( ) ; \nif ( ch == '-' && nextch == '-' ) { \nstack [ ++ top ] = ch ; \nstack [ ++ top ] = nextch ; \nreturn token ; \n} \nelse { \nchar [ ] chararr = new char [ 1 ] ; \nchararr [ 0 ] = ( char ) ch ; \nString s = new String ( chararr ) ; \ntoken = token . concat ( s ) ; \nch = nextch ; \n} \n} \nreturn token ; \n} \n} \n} \n"}
{"9407": "public class Graph { \npublic boolean removeVertex ( Vertex < T > v ) { \nif ( ! verticies . containsValue ( v ) ) return false ; \nverticies . remove ( v . getName ( ) ) ; \nif ( v == rootVertex ) rootVertex = null ; \nfor ( int n = 0 ; \nv . getOutgoingEdgeCount ( ) > n ; \nn ++ ) { \nEdge < T > e = v . getOutgoingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > to = e . getTo ( ) ; \nto . remove ( e ) ; \nedges . remove ( e ) ; \n} \nfor ( int n = 0 ; \nv . getIncomingEdgeCount ( ) > n ; \nn ++ ) { \nEdge < T > e = v . getIncomingEdge ( n ) ; \nv . remove ( e ) ; \nVertex < T > predecessor = e . getFrom ( ) ; \npredecessor . remove ( e ) ; \n} \nreturn true ; \n} \n} \n"}
{"9409": "public class Graph { \npublic void dfsSpanningTree ( Vertex < T > v , DFSVisitor < T > visitor ) { \nv . visit ( ) ; \nif ( visitor != null ) visitor . visit ( this , v ) ; \nfor ( int i = 0 ; \nv . getOutgoingEdgeCount ( ) > i ; \ni ++ ) { \nEdge < T > e = v . getOutgoingEdge ( i ) ; \nif ( ! e . getTo ( ) . visited ( ) ) { \nif ( visitor != null ) visitor . visit ( this , v , e ) ; \ne . mark ( ) ; \ndfsSpanningTree ( e . getTo ( ) , visitor ) ; \n} \n} \n} \n} \n"}
{"9411": "public class Graph { \npublic Edge < T > [ ] findCycles ( ) { \nArrayList < Edge < T > > cycleEdges = new ArrayList < Edge < T > > ( ) ; \nfor ( int n = 0 ; \nverticies . size ( ) > n ; \nn ++ ) { \nVertex < T > v = getVertex ( n ) ; \nv . setMarkState ( VISIT_COLOR_WHITE ) ; \n} \nfor ( int n = 0 ; \nverticies . size ( ) > n ; \nn ++ ) { \nVertex < T > v = getVertex ( n ) ; \nvisit ( v , cycleEdges ) ; \n} \nEdge < T > [ ] cycles = new Edge [ cycleEdges . size ( ) ] ; \ncycleEdges . toArray ( cycles ) ; \nreturn cycles ; \n} \n} \n"}
{"9412": "public class DOMWriter { \npublic static String normalize ( String s , boolean canonical ) { \nStringBuffer str = new StringBuffer ( ) ; \nint len = ( s != null ) ? s . length ( ) : 0 ; \nfor ( int i = 0 ; \nlen > i ; \ni ++ ) { \nchar ch = s . charAt ( i ) ; \nswitch ( ch ) { \ncase '<' : { \nstr . append ( \"&lt;\" ) ; \nbreak ; \n} \ncase '>' : { \nstr . append ( \"&gt;\" ) ; \nbreak ; \n} \ncase '&' : { \nstr . append ( \"&amp;\" ) ; \nbreak ; \n} \ncase '\"' : { \nstr . append ( \"&quot;\" ) ; \nbreak ; \n} \ncase '\\'' : { \nstr . append ( \"&apos;\" ) ; \nbreak ; \n} \ncase '\\r' : case '\\n' : { \nif ( canonical ) { \nstr . append ( \"&#\" ) ; \nstr . append ( Integer . toString ( ch ) ) ; \nstr . append ( ';' ) ; \nbreak ; \n} \n} \ndefault : { \nstr . append ( ch ) ; \n} \n} \n} \nreturn ( str . toString ( ) ) ; \n} \n} \n"}
{"9417": "public class DOMUtils { \npublic static QName resolveQName ( Element el , String qualifiedName ) { \nQName qname ; \nString prefix = \"\" ; \nString namespaceURI = \"\" ; \nString localPart = qualifiedName ; \nint colIndex = qualifiedName . indexOf ( \":\" ) ; \nif ( 0 < colIndex ) { \nprefix = qualifiedName . substring ( 0 , colIndex ) ; \nlocalPart = qualifiedName . substring ( colIndex + 1 ) ; \nif ( \"xmlns\" . equals ( prefix ) ) { \nnamespaceURI = \"URI:XML_PREDEFINED_NAMESPACE\" ; \n} \nelse { \nElement nsElement = el ; \nwhile ( namespaceURI . equals ( \"\" ) && nsElement != null ) { \nnamespaceURI = nsElement . getAttribute ( \"xmlns:\" + prefix ) ; \nif ( namespaceURI . equals ( \"\" ) ) nsElement = getParentElement ( nsElement ) ; \n} \n} \nif ( namespaceURI . equals ( \"\" ) ) throw new IllegalArgumentException ( \"Cannot find namespace uri for: \" + qualifiedName ) ; \n} \nqname = new QName ( namespaceURI , localPart , prefix ) ; \nreturn qname ; \n} \n} \n"}
{"9418": "public class DOMUtils { \npublic static void copyAttributes ( Element destElement , Element srcElement ) { \nNamedNodeMap attribs = srcElement . getAttributes ( ) ; \nfor ( int i = 0 ; \nattribs . getLength ( ) > i ; \ni ++ ) { \nAttr attr = ( Attr ) attribs . item ( i ) ; \nString uri = attr . getNamespaceURI ( ) ; \nString qname = attr . getName ( ) ; \nString value = attr . getNodeValue ( ) ; \nif ( uri == null && qname . startsWith ( \"xmlns\" ) ) { \nlog . trace ( \"Ignore attribute: [uri=\" + uri + \",qname=\" + qname + \",value=\" + value + \"]\" ) ; \n} \nelse { \ndestElement . setAttributeNS ( uri , qname , value ) ; \n} \n} \n} \n} \n"}
{"9419": "public class DOMUtils { \npublic static boolean hasChildElements ( Node node ) { \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( int i = 0 ; \nnlist . getLength ( ) > i ; \ni ++ ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . ELEMENT_NODE ) return true ; \n} \nreturn false ; \n} \n} \n"}
{"9420": "public class DOMUtils { \npublic static Iterator getChildElements ( Node node ) { \nArrayList list = new ArrayList ( ) ; \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( int i = 0 ; \nnlist . getLength ( ) > i ; \ni ++ ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . ELEMENT_NODE ) list . add ( child ) ; \n} \nreturn list . iterator ( ) ; \n} \n} \n"}
{"9421": "public class DOMUtils { \npublic static String getTextContent ( Node node , boolean replaceProps ) { \nboolean hasTextContent = false ; \nStringBuffer buffer = new StringBuffer ( ) ; \nNodeList nlist = node . getChildNodes ( ) ; \nfor ( int i = 0 ; \nnlist . getLength ( ) > i ; \ni ++ ) { \nNode child = nlist . item ( i ) ; \nif ( child . getNodeType ( ) == Node . TEXT_NODE ) { \nbuffer . append ( child . getNodeValue ( ) ) ; \nhasTextContent = true ; \n} \n} \nString text = ( hasTextContent ? buffer . toString ( ) : null ) ; \nif ( text != null && replaceProps ) text = StringPropertyReplacer . replaceProperties ( text ) ; \nreturn text ; \n} \n} \n"}
{"9430": "public class Classes { \npublic static void displayClassInfo ( Class clazz , StringBuffer results ) { \nClassLoader cl = clazz . getClassLoader ( ) ; \nresults . append ( \"\\n\" ) ; \nresults . append ( clazz . getName ( ) ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( clazz . hashCode ( ) ) ) ; \nresults . append ( \").ClassLoader=\" ) ; \nresults . append ( cl ) ; \nClassLoader parent = cl ; \nwhile ( parent != null ) { \nresults . append ( \"\\n..\" ) ; \nresults . append ( parent ) ; \nURL [ ] urls = getClassLoaderURLs ( parent ) ; \nint length = urls != null ? urls . length : 0 ; \nfor ( int u = 0 ; \nlength > u ; \nu ++ ) { \nresults . append ( \"\\n....\" ) ; \nresults . append ( urls [ u ] ) ; \n} \nif ( parent != null ) parent = parent . getParent ( ) ; \n} \nCodeSource clazzCS = clazz . getProtectionDomain ( ) . getCodeSource ( ) ; \nif ( clazzCS != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( clazzCS ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \nresults . append ( \"\\nImplemented Interfaces:\" ) ; \nClass [ ] ifaces = clazz . getInterfaces ( ) ; \nfor ( int i = 0 ; \nifaces . length > i ; \ni ++ ) { \nClass iface = ifaces [ i ] ; \nresults . append ( \"\\n++\" ) ; \nresults . append ( iface ) ; \nresults . append ( \"(\" ) ; \nresults . append ( Integer . toHexString ( iface . hashCode ( ) ) ) ; \nresults . append ( \")\" ) ; \nClassLoader loader = ifaces [ i ] . getClassLoader ( ) ; \nresults . append ( \"\\n++++ClassLoader: \" ) ; \nresults . append ( loader ) ; \nProtectionDomain pd = ifaces [ i ] . getProtectionDomain ( ) ; \nCodeSource cs = pd . getCodeSource ( ) ; \nif ( cs != null ) { \nresults . append ( \"\\n++++CodeSource: \" ) ; \nresults . append ( cs ) ; \n} \nelse results . append ( \"\\n++++Null CodeSource\" ) ; \n} \n} \n} \n"}
{"9431": "public class Classes { \npublic static void describe ( StringBuffer buffer , Class clazz ) { \nif ( clazz == null ) buffer . append ( \"**null**\" ) ; \nelse { \nbuffer . append ( \"{class=\" ) . append ( clazz . getName ( ) ) ; \nClass [ ] intfs = clazz . getInterfaces ( ) ; \nif ( 0 < intfs . length ) { \nbuffer . append ( \" intfs=\" ) ; \nfor ( int i = 0 ; \nintfs . length > i ; \n++ i ) { \nbuffer . append ( intfs [ i ] . getName ( ) ) ; \nif ( intfs . length - 1 > i ) buffer . append ( \", \" ) ; \n} \n} \nbuffer . append ( \"}\" ) ; \n} \n} \n} \n"}
{"9434": "public class Classes { \npublic static void forceLoad ( final Class type ) { \nif ( type == null ) throw new NullArgumentException ( \"type\" ) ; \nif ( type . isPrimitive ( ) ) return ; \nString packageName = Classes . getPackageName ( type ) ; \nif ( packageName . startsWith ( \"java.\" ) || packageName . startsWith ( \"javax.\" ) ) { \nreturn ; \n} \ntry { \nMethod methods [ ] = type . getDeclaredMethods ( ) ; \nMethod method = null ; \nfor ( int i = 0 ; \nmethods . length > i ; \ni ++ ) { \nint modifiers = methods [ i ] . getModifiers ( ) ; \nif ( Modifier . isStatic ( modifiers ) ) { \nmethod = methods [ i ] ; \nbreak ; \n} \n} \nif ( method != null ) { \nmethod . invoke ( null , ( Object [ ] ) null ) ; \n} \nelse { \ntype . newInstance ( ) ; \n} \n} \ncatch ( Exception ignore ) { \nThrowableHandler . add ( ignore ) ; \n} \n} \n} \n"}
{"9435": "public class Classes { \npublic static Class getPrimitiveWrapper ( final Class type ) { \nif ( ! type . isPrimitive ( ) ) { \nthrow new IllegalArgumentException ( \"type is not a primitive class\" ) ; \n} \nfor ( int i = 0 ; \nPRIMITIVE_WRAPPER_MAP . length > i ; \ni += 2 ) { \nif ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i ] ) ) return PRIMITIVE_WRAPPER_MAP [ i + 1 ] ; \n} \nthrow new UnreachableStatementException ( ) ; \n} \n} \n"}
{"9436": "public class Classes { \npublic static void getAllInterfaces ( List allIfaces , Class c ) { \nwhile ( c != null ) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \nfor ( int n = 0 ; \nifaces . length > n ; \nn ++ ) { \nallIfaces . add ( ifaces [ n ] ) ; \n} \nc = c . getSuperclass ( ) ; \n} \n} \n} \n"}
{"9437": "public class Classes { \npublic static Class [ ] getAllUniqueInterfaces ( Class c ) { \nSet uniqueIfaces = new HashSet ( ) ; \nwhile ( c != null ) { \nClass [ ] ifaces = c . getInterfaces ( ) ; \nfor ( int n = 0 ; \nifaces . length > n ; \nn ++ ) { \nuniqueIfaces . add ( ifaces [ n ] ) ; \n} \nc = c . getSuperclass ( ) ; \n} \nreturn ( Class [ ] ) uniqueIfaces . toArray ( new Class [ uniqueIfaces . size ( ) ] ) ; \n} \n} \n"}
{"9438": "public class Classes { \npublic static boolean isPrimitiveWrapper ( final Class type ) { \nfor ( int i = 0 ; \nPRIMITIVE_WRAPPER_MAP . length > i ; \ni += 2 ) { \nif ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i + 1 ] ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9442": "public class Classes { \nprivate final static Class convertToJavaClass ( String name , ClassLoader cl ) throws ClassNotFoundException { \nint arraySize = 0 ; \nwhile ( name . endsWith ( \"[]\" ) ) { \nname = name . substring ( 0 , name . length ( ) - 2 ) ; \narraySize ++ ; \n} \nClass c = ( Class ) PRIMITIVE_NAME_TYPE_MAP . get ( name ) ; \nif ( c == null ) { \ntry { \nc = cl . loadClass ( name ) ; \n} \ncatch ( ClassNotFoundException cnfe ) { \nthrow new ClassNotFoundException ( \"Parameter class not found: \" + name ) ; \n} \n} \nif ( 0 < arraySize ) { \nint [ ] dims = new int [ arraySize ] ; \nfor ( int i = 0 ; \narraySize > i ; \ni ++ ) { \ndims [ i ] = 1 ; \n} \nc = Array . newInstance ( c , dims ) . getClass ( ) ; \n} \nreturn c ; \n} \n} \n"}
{"9457": "public class TimeoutFactory { \npublic Timeout schedule ( long time , TimeoutTarget target ) { \nif ( cancelled . get ( ) ) throw new IllegalStateException ( \"TimeoutFactory has been cancelled\" ) ; \nif ( 0 > time ) throw new IllegalArgumentException ( \"Negative time\" ) ; \nif ( target == null ) throw new IllegalArgumentException ( \"Null timeout target\" ) ; \nreturn queue . offer ( time , target ) ; \n} \n} \n"}
{"9462": "public class Util { \nprotected static void appendClassInfo ( StringBuffer buffer , Class clazz ) { \nbuffer . append ( \"[class=\" ) . append ( clazz . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( clazz . getClassLoader ( ) ) ; \nbuffer . append ( \" interfaces={\" ) ; \nClass [ ] interfaces = clazz . getInterfaces ( ) ; \nfor ( int i = 0 ; \ninterfaces . length > i ; \n++ i ) { \nif ( 0 < i ) buffer . append ( \", \" ) ; \nbuffer . append ( \"interface=\" ) . append ( interfaces [ i ] . getName ( ) ) ; \nbuffer . append ( \" classloader=\" ) . append ( interfaces [ i ] . getClassLoader ( ) ) ; \n} \nbuffer . append ( \"}]\" ) ; \n} \n} \n"}
{"9472": "public class BootstrapResolver { \npublic Source resolve ( String href , String base ) throws TransformerException { \nString uri = href ; \nint hashPos = href . indexOf ( \"#\" ) ; \nif ( 0 <= hashPos ) { \nuri = href . substring ( 0 , hashPos ) ; \n} \nString result = null ; \nif ( href != null && uriMap . containsKey ( href ) ) { \nresult = ( String ) uriMap . get ( href ) ; \n} \nif ( result == null ) { \ntry { \nURL url = null ; \nif ( base == null ) { \nurl = new URL ( uri ) ; \nresult = url . toString ( ) ; \n} \nelse { \nURL baseURL = new URL ( base ) ; \nurl = ( href . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; \nresult = url . toString ( ) ; \n} \n} \ncatch ( java . net . MalformedURLException mue ) { \nString absBase = makeAbsolute ( base ) ; \nif ( ! absBase . equals ( base ) ) { \nreturn resolve ( href , absBase ) ; \n} \nelse { \nthrow new TransformerException ( \"Malformed URL \" + href + \"(base \" + base + \")\" , mue ) ; \n} \n} \n} \nSAXSource source = new SAXSource ( ) ; \nsource . setInputSource ( new InputSource ( result ) ) ; \nreturn source ; \n} \n} \n"}
{"9476": "public class Namespaces { \npublic static String getLocalName ( Element element ) { \nString name = element . getTagName ( ) ; \nif ( 0 < name . indexOf ( ':' ) ) { \nname = name . substring ( name . indexOf ( ':' ) + 1 ) ; \n} \nreturn name ; \n} \n} \n"}
{"9482": "public class FilePropertyReader { \npublic Map readProperties ( ) throws PropertyException , IOException { \nProperties props = new Properties ( ) ; \nfor ( int i = 0 ; \nfilenames . length > i ; \ni ++ ) { \nloadProperties ( props , filenames [ i ] ) ; \n} \nreturn props ; \n} \n} \n"}
{"9491": "public class JarUtils { \nprivate static void jar ( File src , String prefix , JarInfo info ) throws IOException { \nJarOutputStream jout = info . out ; \nif ( src . isDirectory ( ) ) { \nprefix = prefix + src . getName ( ) + \"/\" ; \nZipEntry entry = new ZipEntry ( prefix ) ; \nentry . setTime ( src . lastModified ( ) ) ; \nentry . setMethod ( JarOutputStream . STORED ) ; \nentry . setSize ( 0L ) ; \nentry . setCrc ( 0L ) ; \njout . putNextEntry ( entry ) ; \njout . closeEntry ( ) ; \nFile [ ] files = src . listFiles ( info . filter ) ; \nfor ( int i = 0 ; \nfiles . length > i ; \ni ++ ) { \njar ( files [ i ] , prefix , info ) ; \n} \n} \nelse if ( src . isFile ( ) ) { \nbyte [ ] buffer = info . buffer ; \nZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; \nentry . setTime ( src . lastModified ( ) ) ; \njout . putNextEntry ( entry ) ; \nFileInputStream in = new FileInputStream ( src ) ; \nint len ; \nwhile ( ( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ) { \njout . write ( buffer , 0 , len ) ; \n} \nin . close ( ) ; \njout . closeEntry ( ) ; \n} \n} \n} \n"}
{"9492": "public class CompoundIterator { \npublic boolean hasNext ( ) { \nfor ( ; \niters . length > index ; \nindex ++ ) { \nif ( iters [ index ] != null && iters [ index ] . hasNext ( ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9495": "public class StructsBatchCompiler { \nprotected static boolean cleanFolder ( File parentFolder , FileFilter filter , boolean continueOnError , boolean deleteParentFolder ) { \nif ( ! parentFolder . exists ( ) ) { \nreturn true ; \n} \nif ( filter == null ) filter = ACCEPT_ALL_FILTER ; \nlog . debug ( \"Cleaning folder \" + parentFolder . toString ( ) ) ; \nfinal File [ ] contents = parentFolder . listFiles ( filter ) ; \nfor ( int j = 0 ; \ncontents . length > j ; \nj ++ ) { \nfinal File file = contents [ j ] ; \nif ( file . isDirectory ( ) ) { \nif ( ! cleanFolder ( file , filter , continueOnError , true ) && ! continueOnError ) return false ; \n} \nelse { \nif ( ! file . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + file . getAbsolutePath ( ) ) ; \nif ( ! continueOnError ) return false ; \n} \n} \n} \nif ( deleteParentFolder ) { \nif ( parentFolder . list ( ) . length == 0 && ! parentFolder . delete ( ) ) { \nlog . warn ( \"Couldn't delete \" + parentFolder . getAbsolutePath ( ) ) ; \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9505": "public class Effect { \npublic static void main ( String [ ] args ) throws Exception { \nint n = 1 ; \nif ( 1 > args . length ) { \nusage ( ) ; \nreturn ; \n} \nProperties analyzers = new Properties ( ) ; \nanalyzers . load ( new FileInputStream ( new File ( \"analyzer.properties\" ) ) ) ; \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nString a = System . getProperty ( \"analyzer\" , \"mmseg4j\" ) ; \nAnalyzer analyzer = null ; \nString an = ( String ) analyzers . get ( a ) ; \nif ( an != null ) { \nanalyzer = ( Analyzer ) Class . forName ( an ) . newInstance ( ) ; \nmode = a ; \n} \nelse { \nusage ( ) ; \nreturn ; \n} \nif ( 1 < args . length ) { \ntry { \nn = Integer . parseInt ( args [ 1 ] ) ; \n} \ncatch ( NumberFormatException e ) { \n} \n} \nFile path = new File ( args [ 0 ] ) ; \nSystem . out . println ( \"analyzer=\" + analyzer . getClass ( ) . getName ( ) ) ; \nEffect ef = new Effect ( path , analyzer ) ; \nef . run ( mode , n ) ; \n} \n} \n"}
{"9506": "public class Performance { \npublic static void main ( String [ ] args ) throws IOException { \nif ( 1 > args . length ) { \nSystem . out . println ( \"Usage:\" ) ; \nSystem . out . println ( \"\\t-Dmode=simple, defalut is complex\" ) ; \nSystem . out . println ( \"\\tPerformance <txt path> - is a directory that contain *.txt\" ) ; \nreturn ; \n} \nString mode = System . getProperty ( \"mode\" , \"complex\" ) ; \nSeg seg = null ; \nDictionary dic = Dictionary . getInstance ( ) ; \nif ( \"simple\" . equals ( mode ) ) { \nseg = new SimpleSeg ( dic ) ; \n} \nelse { \nseg = new ComplexSeg ( dic ) ; \n} \nFile path = new File ( args [ 0 ] ) ; \nFile [ ] txts = path . listFiles ( new FilenameFilter ( ) { \npublic boolean accept ( File dir , String name ) { \nreturn name . endsWith ( \".txt\" ) ; \n} \n} \n) ; \nlong time = 0 ; \nfor ( File txt : txts ) { \nMMSeg mmSeg = new MMSeg ( new InputStreamReader ( new FileInputStream ( txt ) ) , seg ) ; \nWord word = null ; \nOutputStreamWriter osw = new OutputStreamWriter ( new FileOutputStream ( new File ( txt . getAbsoluteFile ( ) + \".\" + mode + \".word\" ) ) ) ; \nBufferedWriter bw = new BufferedWriter ( osw ) ; \nlong start = System . currentTimeMillis ( ) ; \nwhile ( ( word = mmSeg . next ( ) ) != null ) { \nbw . append ( new String ( word . getString ( ) ) ) . append ( \"\\r\\n\" ) ; \n} \ntime += System . currentTimeMillis ( ) - start ; \nbw . close ( ) ; \n} \nSystem . out . println ( \"use \" + time + \"ms\" ) ; \n} \n} \n"}
{"9507": "public class Chunk { \npublic int getSumDegree ( ) { \nif ( 0 > sumDegree ) { \nint sum = 0 ; \nfor ( Word word : words ) { \nif ( word != null && - 1 < word . getDegree ( ) ) { \nsum += word . getDegree ( ) ; \n} \n} \nsumDegree = sum ; \n} \nreturn sumDegree ; \n} \n} \n"}
{"9524": "public class UBValue { \npublic boolean [ ] asBoolArray ( ) { \nboolean [ ] retval ; \nUBArray array = asArray ( ) ; \nswitch ( array . getStrongType ( ) ) { \ncase Int8 : { \nbyte [ ] data = ( ( UBInt8Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ndata . length > i ; \ni ++ ) { \nretval [ i ] = 0 < data [ i ] ; \n} \nbreak ; \n} \ncase Int16 : { \nshort [ ] data = ( ( UBInt16Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ndata . length > i ; \ni ++ ) { \nretval [ i ] = 0 < data [ i ] ; \n} \nbreak ; \n} \ncase Int32 : { \nint [ ] data = ( ( UBInt32Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ndata . length > i ; \ni ++ ) { \nretval [ i ] = 0 < data [ i ] ; \n} \nbreak ; \n} \ncase Int64 : { \nlong [ ] data = ( ( UBInt64Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ndata . length > i ; \ni ++ ) { \nretval [ i ] = 0 < data [ i ] ; \n} \nbreak ; \n} \ncase Float32 : { \nfloat [ ] data = ( ( UBFloat32Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ndata . length > i ; \ni ++ ) { \nretval [ i ] = 0 < data [ i ] ; \n} \nbreak ; \n} \ncase Float64 : { \ndouble [ ] data = ( ( UBFloat64Array ) array ) . getValues ( ) ; \nretval = new boolean [ data . length ] ; \nfor ( int i = 0 ; \ndata . length > i ; \ni ++ ) { \nretval [ i ] = 0 < data [ i ] ; \n} \nbreak ; \n} \ndefault : throw new RuntimeException ( \"not an int32[] type\" ) ; \n} \nreturn retval ; \n} \n} \n"}
{"9535": "public class StringUtils { \npublic static String join ( final List < String > list ) { \nif ( list == null ) { \nreturn null ; \n} \nelse if ( list . size ( ) == 0 ) { \nreturn \"\" ; \n} \nelse if ( list . size ( ) == 1 ) { \nreturn list . get ( 0 ) ; \n} \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( String item : list ) { \nif ( 0 < builder . length ( ) ) { \nbuilder . append ( \", \" ) ; \n} \nbuilder . append ( item ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"9536": "public class StringUtils { \npublic static String join ( final String [ ] list ) { \nif ( list == null ) { \nreturn null ; \n} \nelse if ( list . length == 0 ) { \nreturn \"\" ; \n} \nelse if ( list . length == 1 ) { \nreturn list [ 0 ] ; \n} \nfinal StringBuilder builder = new StringBuilder ( ) ; \nfor ( String item : list ) { \nif ( 0 < builder . length ( ) ) { \nbuilder . append ( \", \" ) ; \n} \nbuilder . append ( item ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"9558": "public class PlanBindings { \nprivate Plan selectPlanAtRandom ( ) { \nPlan plan = null ; \nSet < Belief > vars = null ; \nint index = rand . nextInt ( size ( ) ) ; \nint idx = 0 ; \nboolean bindingsExist = false ; \nfor ( Plan p : bindings . keySet ( ) ) { \nvars = bindings . get ( p ) ; \nbindingsExist = ( vars != null && ! vars . isEmpty ( ) ) ; \nidx += bindingsExist ? vars . size ( ) : 1 ; \nif ( index < idx ) { \nplan = p ; \nif ( bindingsExist ) { \nindex = index - ( idx - vars . size ( ) ) ; \nsetPlanVariables ( plan . getAgent ( ) , plan , vars , index ) ; \n} \nbreak ; \n} \n} \nreturn plan ; \n} \n} \n"}
{"9560": "public class PlanBindings { \nprivate Belief getResultAtIndex ( Set < Belief > results , int index ) { \nBelief belief = null ; \nif ( ! ( results == null || 0 > index || results . size ( ) <= index ) ) { \nint idx = 0 ; \nfor ( Belief b : results ) { \nif ( idx == index ) { \nbelief = b ; \nbreak ; \n} \nidx ++ ; \n} \n} \nreturn belief ; \n} \n} \n"}
{"9565": "public class Plan { \npublic void step ( ) { \nif ( body == null || body . length == 0 || 0 > index || body . length <= index ) { \nreturn ; \n} \nbody [ index ++ ] . step ( ) ; \n} \n} \n"}
{"9568": "public class Program { \npublic static void initIntentionSelectionPools ( int nagents , int ncores ) { \nMain . poolsize = ( ncores < nagents ) ? ( nagents / ncores ) : 1 ; \nMain . npools = ( ncores < nagents ) ? ncores : nagents ; \n} \n} \n"}
{"9569": "public class Program { \nstatic void initIntentionSelectionThreads ( Config config ) { \nint ncores = config . getNumThreads ( ) ; \nMain . intentionSelectors = new IntentionSelector [ ncores ] ; \nfor ( int i = 0 ; \nMain . npools > i ; \ni ++ ) { \nMain . intentionSelectors [ i ] = new IntentionSelector ( i , config . getRandomSeed ( ) ) ; \n} \n} \n} \n"}
{"9570": "public class Program { \nstatic void startIntentionSelectionThreads ( ) { \nfor ( int i = 0 ; \nMain . npools > i ; \ni ++ ) { \nThread thread = new Thread ( Main . intentionSelectors [ i ] ) ; \nthread . setName ( \"jill-\" + i ) ; \nthread . start ( ) ; \n} \n} \n} \n"}
{"9571": "public class Program { \nstatic void shutdownIntentionSelectionThreads ( ) { \nfor ( int i = 0 ; \nMain . npools > i ; \ni ++ ) { \nMain . intentionSelectors [ i ] . shutdown ( ) ; \n} \n} \n} \n"}
{"9575": "public class ProgramLoader { \nprivate static boolean processPlansForGoal ( GoalType gtype , String [ ] plans ) { \nfor ( int j = 0 ; \nplans . length > j ; \nj ++ ) { \nClass < ? > pclass = loadClass ( plans [ j ] , Plan . class ) ; \nif ( pclass == null ) { \nreturn false ; \n} \nlogger . info ( \"Found Plan \" + pclass . getName ( ) + \" that handles Goal \" + gtype . getName ( ) ) ; \nPlanType ptype = new PlanType ( pclass . getName ( ) ) ; \nptype . setPlanClass ( pclass ) ; \nGlobalState . planTypes . push ( ptype ) ; \nptype . addParent ( ( byte ) gtype . getId ( ) ) ; \ngtype . addChild ( ( byte ) ptype . getId ( ) ) ; \n} \nreturn true ; \n} \n} \n"}
{"9576": "public class ProgramLoader { \nprivate static void createAgentsInCatalog ( AObjectCatalog agents , AgentType atype , Class < ? > aclass , int num ) { \nint added = 0 ; \ntry { \nfor ( int i = 0 ; \nnum > i ; \ni ++ ) { \nAgent agent = ( Agent ) ( aclass . getConstructor ( String . class ) . newInstance ( \"a\" + Integer . toString ( i ) ) ) ; \nagent . setGoals ( atype . getGoals ( ) ) ; \nagents . push ( agent ) ; \nadded ++ ; \n} \nlogger . info ( \"Finished loading {} agents\" , added ) ; \n} \ncatch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nlogger . error ( \"Could not create instance of class \" + aclass . getName ( ) ) ; \n} \n} \n} \n"}
{"9579": "public class AObject { \npublic static boolean isNameEqual ( AObject obj1 , AObject obj2 ) { \nif ( obj1 . name == null || obj2 . name == null || obj1 . name . length != obj2 . name . length || obj1 . name . length == 0 ) { \nreturn false ; \n} \nfor ( int i = 0 ; \nobj1 . name . length > i ; \ni ++ ) { \nif ( obj1 . name [ i ] != obj2 . name [ i ] ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9581": "public class ArgumentsLoader { \npublic static void parse ( String [ ] args ) { \nfor ( int i = 0 ; \nargs != null && args . length > i ; \ni ++ ) { \nif ( \"--help\" . equals ( args [ i ] ) ) { \nabort ( null ) ; \n} \nif ( args . length > i + 1 ) { \nparseArgumentWithOption ( args [ i ] , args [ ++ i ] ) ; \n} \n} \nif ( config == null ) { \nabort ( \"Configuration file or string was not given\" ) ; \n} \nelse if ( config . getAgents ( ) == null || config . getAgents ( ) . isEmpty ( ) ) { \nabort ( \"Configuration is missing agents specification\" ) ; \n} \n} \n} \n"}
{"9584": "public class AObjectCatalog { \npublic AObject get ( int index ) { \nif ( 0 <= index && objects . length > index ) { \nreturn objects [ index ] ; \n} \nreturn null ; \n} \n} \n"}
{"9585": "public class AObjectCatalog { \npublic AObject find ( String name ) { \nfor ( int i = 0 ; \nnextid > i ; \ni ++ ) { \nif ( objects [ i ] . getName ( ) . equals ( name ) ) { \nreturn objects [ i ] ; \n} \n} \nreturn null ; \n} \n} \n"}
{"9587": "public class Stack255 { \npublic Object get ( int idx ) { \nint index = idx & 0xff ; \nif ( isEmpty ( ) ) { \nreturn null ; \n} \nelse if ( 0 > index || size <= index ) { \nreturn null ; \n} \nreturn objects [ index ] ; \n} \n} \n"}
{"9602": "public class BeliefSet { \npublic BeliefSetField getFieldByName ( String name ) { \nBeliefSetField field = null ; \nfor ( int i = 0 ; \nfields . length > i ; \ni ++ ) { \nif ( name . equals ( fields [ i ] . getName ( ) ) ) { \nfield = fields [ i ] ; \nbreak ; \n} \n} \nreturn field ; \n} \n} \n"}
{"9603": "public class Greeter { \nprivate void registerNeighbours ( Random rand , int count ) throws BeliefBaseException { \nint size = ( 0 > count ) ? 0 : count ; \nfor ( int i = 0 ; \nsize > i ; \ni ++ ) { \nboolean male = ( 0.5 > rand . nextDouble ( ) ) ? true : false ; \nthis . addBelief ( beliefset , buildName ( male ) , male ? \"male\" : \"female\" ) ; \n} \n} \n} \n"}
{"9606": "public class IntentionSelector { \nprivate boolean isStackValid ( Agent agent , Stack255 agentExecutionStack ) { \nif ( agentExecutionStack == null ) { \nreturn false ; \n} \nfinal int esSize = agentExecutionStack . size ( ) ; \nlogger . trace ( \"{} execution stack is {}/255 full\" , Log . logPrefix ( agent . getId ( ) ) , esSize ) ; \nif ( esSize == 0 ) { \nreturn false ; \n} \nif ( 255 <= esSize ) { \nlogger . error ( \"{} execution stack reached size limit of 255. Cannot continue.\" , Log . logPrefix ( agent . getId ( ) ) ) ; \nreturn false ; \n} \nreturn true ; \n} \n} \n"}
{"9608": "public class IntentionSelector { \nprivate boolean manageGoal ( int agentIndex , Agent agent , Stack255 agentExecutionStack , Goal node ) { \nGoalType gtype = ( GoalType ) GlobalState . goalTypes . find ( node . getClass ( ) . getName ( ) ) ; \nbyte [ ] ptypes = gtype . getChildren ( ) ; \nassert ( ptypes != null ) ; \nbindings . clear ( ) ; \nfor ( int p = 0 ; \nptypes . length > p ; \np ++ ) { \nPlanType ptype = ( PlanType ) GlobalState . planTypes . get ( ptypes [ p ] ) ; \ntry { \nPlan planInstance = ( Plan ) ( ptype . getPlanClass ( ) . getConstructor ( Agent . class , Goal . class , String . class ) . newInstance ( GlobalState . agents . get ( agentIndex ) , node , \"p\" ) ) ; \nagent . clearLastResults ( ) ; \nif ( planInstance . context ( ) ) { \nSet < Belief > results = agent . getLastResults ( ) ; \nbindings . add ( planInstance , ( results == null ) ? null : new LinkedHashSet < Belief > ( results ) ) ; \n} \n} \ncatch ( NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { \nlogger . error ( \"Could not create plan object of type \" + ptype . getClass ( ) . getName ( ) , e ) ; \n} \n} \nint numBindings = bindings . size ( ) ; \nif ( numBindings == 0 ) { \nlogger . debug ( Log . logPrefix ( agent . getId ( ) ) + \" has no applicable plans for goal \" + gtype + \" and will continue to wait indefinitely\" ) ; \nreturn false ; \n} \nagent . notifyAgentPrePlanSelection ( bindings ) ; \nPlan planInstance = bindings . selectPlan ( GlobalConstant . PLAN_SELECTION_POLICY ) ; \nsynchronized ( agentExecutionStack ) { \nlogger . debug ( Log . logPrefix ( agent . getId ( ) ) + \" choose an instance of plan \" + planInstance . getClass ( ) . getSimpleName ( ) + \" to handle goal \" + node . getClass ( ) . getSimpleName ( ) ) ; \nagentExecutionStack . push ( planInstance ) ; \n} \nreturn true ; \n} \n} \n"}
{"9611": "public class Board { \npublic boolean move ( int pinA , int pinB ) { \nif ( 0 > pinA || pins . length <= pinA || 0 > pinB || pins . length <= pinB ) { \nLog . warn ( \"Invalid board pin specified \" + pinA + \". Should be between 0..\" + ( pins . length - 1 ) + \" (inclusive).\" ) ; \nreturn false ; \n} \nelse if ( pins [ pinA ] . isEmpty ( ) ) { \nLog . warn ( \"No disc on pin\" + pinA ) ; \nreturn false ; \n} \nelse if ( pinA == pinB ) { \nLog . info ( \"Moving disc from pin\" + pinA + \" on to itself (means the board will not change)\" ) ; \nreturn true ; \n} \nint discOnA = pins [ pinA ] . get ( pins [ pinA ] . size ( ) - 1 ) ; \nint discOnB = ( pins [ pinB ] . isEmpty ( ) ) ? Integer . MAX_VALUE : pins [ pinB ] . get ( pins [ pinB ] . size ( ) - 1 ) ; \nif ( discOnA > discOnB ) { \nLog . warn ( \"Cannot move disc\" + discOnA + \" (pin\" + pinA + \") on to smaller disc\" + discOnB + \" (pin\" + pinB + \")\" ) ; \nreturn false ; \n} \npins [ pinB ] . add ( pins [ pinA ] . remove ( pins [ pinA ] . size ( ) - 1 ) ) ; \nreturn true ; \n} \n} \n"}
{"9614": "public class Main { \npublic static void finish ( ) { \nfor ( JillExtension extension : GlobalState . eventHandlers ) { \nextension . finish ( ) ; \n} \nProgram . shutdownIntentionSelectionThreads ( ) ; \nlong t0 = System . currentTimeMillis ( ) ; \nfor ( int i = 0 ; \nGlobalState . agents . size ( ) > i ; \ni ++ ) { \nAgent agent = ( Agent ) GlobalState . agents . get ( i ) ; \nagent . finish ( ) ; \n} \nif ( writer != null ) { \nwriter . close ( ) ; \n} \nlong t1 = System . currentTimeMillis ( ) ; \nlogger . info ( \"Terminated \" + GlobalState . agents . size ( ) + agentsIn + Log . formattedDuration ( t0 , t1 ) ) ; \n} \n} \n"}
{"9615": "public class Main { \npublic static boolean arePoolsIdle ( ) { \nboolean idle = true ; \nfor ( int i = 0 ; \nnpools > i ; \ni ++ ) { \nidle &= ( intentionSelectors [ i ] == null ) || intentionSelectors [ i ] . isIdle ( ) ; \n} \nreturn idle ; \n} \n} \n"}
{"9616": "public class Main { \npublic static int poolid ( int agentid ) { \nint poolid = agentid / poolsize ; \nif ( npools < poolid + 1 ) { \npoolid = npools - 1 ; \n} \nreturn poolid ; \n} \n} \n"}
{"9619": "public class JpaUtils { \npublic static Expression < ? > join ( String attribute , From < ? , ? > from ) { \nExpression < ? > path ; \ntry { \nString [ ] properties = attribute . split ( \"\\\\.\" ) ; \nif ( 1 < properties . length ) { \npath = joinRecursively ( properties , findOrCreateJoin ( properties [ 0 ] , from ) , 1 ) . get ( properties [ properties . length - 1 ] ) ; \n} \nelse { \npath = from . get ( properties [ 0 ] ) ; \n} \n} \ncatch ( IllegalArgumentException e ) { \nthrow SeedException . wrap ( e , JpaErrorCode . UNABLE_TO_CREATE_JPA_JOIN_FOR_SPECIFICATION ) . put ( \"property\" , attribute ) ; \n} \nreturn path ; \n} \n} \n"}
{"9620": "public class JpaUtils { \nprivate static Join < ? , ? > joinRecursively ( String [ ] properties , Join < ? , ? > join , int index ) { \nif ( properties . length - 1 > index ) { \nreturn joinRecursively ( properties , findOrCreateJoin ( properties [ index ] , join ) , index + 1 ) ; \n} \nelse { \nreturn join ; \n} \n} \n} \n"}
{"9660": "public class AbstractStreamEndpoint { \nStoppableObservable < TEntity > getObservable ( final long startIndex , Scheduler scheduler ) { \nreturn runAsync ( scheduler , ( rx . Observer < ? super TEntity > observer , Subscription subscription ) -> { \nlong currentStartIndex = startIndex ; \nwhile ( ! subscription . isUnsubscribed ( ) ) { \nPartialResponse < TEntity > response ; \ntry { \nresponse = ( 0 <= currentStartIndex ) ? readRange ( currentStartIndex , null ) : readRange ( null , - currentStartIndex ) ; \n} \ncatch ( IllegalStateException ex ) { \ncontinue ; \n} \ncatch ( IOException | IllegalArgumentException | IllegalAccessException error ) { \nobserver . onError ( error ) ; \nreturn ; \n} \nresponse . getElements ( ) . stream ( ) . forEach ( observer :: onNext ) ; \nif ( response . isEndReached ( ) ) { \nobserver . onCompleted ( ) ; \nreturn ; \n} \ncurrentStartIndex = response . getTo ( ) + 1 ; \n} \n} \n) ; \n} \n} \n"}
{"9677": "public class StatementImpl { \npublic void setStringArray ( String parameterName , String ... values ) throws java . sql . SQLException { \nint arrayLen = this . getSql ( ) . getArrayLen ( parameterName ) ; \nAssertUtils . assertTrue ( arrayLen >= values . length ) ; \nfor ( int i = 0 ; \narrayLen > i ; \ni ++ ) { \nsetString2 ( Sql . toParamName ( parameterName , i ) , ( values . length > i ) ? values [ i ] : null ) ; \n} \n} \n} \n"}
{"9699": "public class FileSystemDirectoryHelper { \npublic File getCommonDir ( final File dir1 , final File dir2 ) throws IOException { \nList < File > parts1 = getParentDirs ( dir1 ) ; \nList < File > parts2 = getParentDirs ( dir2 ) ; \nFile matched = null ; \nfinal int maxCommonSize = Math . min ( parts1 . size ( ) , parts2 . size ( ) ) ; \nfor ( int i = 0 ; \nmaxCommonSize > i ; \n++ i ) { \nif ( parts1 . get ( i ) . equals ( parts2 . get ( i ) ) ) { \nmatched = parts1 . get ( i ) ; \n} \nelse { \nbreak ; \n} \n} \nreturn matched ; \n} \n} \n"}
{"9700": "public class FileSystemDirectoryHelper { \npublic String abs2rel ( final String basePath , final String absPath ) { \nif ( ! isAbsolutePath ( absPath ) ) { \nreturn absPath ; \n} \nif ( isWindowsDrive ( absPath ) && isWindowsDrive ( basePath ) && absPath . charAt ( 0 ) != basePath . charAt ( 0 ) ) { \nreturn absPath ; \n} \nStringBuilder result = new StringBuilder ( ) ; \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] absParts = getParts ( absPath ) ; \nint start = 0 ; \nfor ( int i = 0 ; \nMath . min ( baseParts . length , absParts . length ) > i ; \n++ i ) { \nif ( baseParts [ i ] . equals ( absParts [ i ] ) ) { \nstart = i + 1 ; \n} \n} \nfor ( int i = start ; \nbaseParts . length > i ; \n++ i ) { \nif ( 0 < result . length ( ) ) { \nresult . append ( File . separator ) ; \n} \nresult . append ( \"..\" ) ; \n} \nfor ( int i = start ; \nabsParts . length > i ; \n++ i ) { \nif ( 0 < result . length ( ) ) { \nresult . append ( File . separator ) ; \n} \nresult . append ( absParts [ i ] ) ; \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"9701": "public class FileSystemDirectoryHelper { \npublic File rel2abs ( final String basePath , final String relPath ) { \nString [ ] baseParts = getParts ( basePath ) ; \nString [ ] relParts = getParts ( relPath ) ; \nif ( isAbsolutePath ( relPath ) ) { \nreturn new File ( relPath ) ; \n} \nList < String > parts = new ArrayList < > ( ) ; \nfor ( int i = 0 ; \nbaseParts . length > i ; \n++ i ) { \nif ( 0 < i || ! isWindowsDrive ( basePath ) ) { \nparts . add ( baseParts [ i ] ) ; \n} \n} \nfor ( String part : relParts ) { \nif ( part . equals ( \"..\" ) && 0 < parts . size ( ) ) { \nparts . remove ( parts . size ( ) - 1 ) ; \n} \nelse if ( ! part . equals ( \".\" ) && ! part . equals ( \"..\" ) ) { \nparts . add ( part ) ; \n} \n} \nStringBuilder result = new StringBuilder ( ) ; \nif ( isWindowsDrive ( basePath ) ) { \nresult . append ( baseParts [ 0 ] ) ; \n} \nfor ( String part : parts ) { \nresult . append ( File . separator ) ; \nresult . append ( part ) ; \n} \nreturn new File ( result . toString ( ) ) ; \n} \n} \n"}
{"9717": "public class ServiceInstanceFactory { \n@ SuppressWarnings ( \"unchecked\" ) @ Override public < I > I newInstance ( ManagedClassSPI managedClass , Object ... args ) { \nif ( 0 < args . length ) { \nthrow new IllegalArgumentException ( \"Service instances factory does not support arguments.\" ) ; \n} \nClass < ? > [ ] interfaceClasses = managedClass . getInterfaceClasses ( ) ; \nif ( interfaceClasses == null ) { \nthrow new BugError ( \"Invalid managed class. Null interface classes.\" ) ; \n} \nif ( interfaceClasses . length != 1 ) { \nthrow new BugError ( \"Invalid managed class. It should have exactly one interface class.\" ) ; \n} \nreturn ( I ) Classes . loadService ( interfaceClasses [ 0 ] ) ; \n} \n} \n"}
{"9762": "public class RequestPreprocessor { \nprivate static boolean startsWith ( String requestPath , String pathComponent ) { \nif ( requestPath . charAt ( 0 ) != '/' ) { \nreturn false ; \n} \nint i = 1 ; \nfor ( int j = 0 ; \nrequestPath . length ( ) > i ; \n++ i , ++ j ) { \nif ( requestPath . charAt ( i ) == '/' ) { \nreturn j == pathComponent . length ( ) ; \n} \nif ( j == pathComponent . length ( ) ) { \nreturn false ; \n} \nif ( Character . toLowerCase ( requestPath . charAt ( i ) ) != Character . toLowerCase ( pathComponent . charAt ( j ) ) ) { \nreturn false ; \n} \n} \nreturn false ; \n} \n} \n"}
{"9778": "public class RecursiveFileSelector { \n@ Override public final File next ( ) { \nif ( files == null || files . length <= fileIndex ) { \nif ( ! cacheNext ( ) ) { \nthrow new NoSuchElementException ( ) ; \n} \n} \nreturn files [ fileIndex ++ ] ; \n} \n} \n"}
{"9877": "public class BlockLocks { \npublic int nextClearBit ( int index ) { \nint i = index >> 6 ; \nif ( wlen <= i ) return - 1 ; \nint subIndex = index & 0x3f ; \nlong word = ~ bits . get ( i ) >> subIndex ; \nif ( word != 0 ) { \nreturn ( i << 6 ) + subIndex + Long . numberOfTrailingZeros ( word ) ; \n} \nwhile ( wlen > ++ i ) { \nword = ~ bits . get ( i ) ; \nif ( word != 0 ) { \nreturn ( i << 6 ) + Long . numberOfTrailingZeros ( word ) ; \n} \n} \nreturn - 1 ; \n} \n} \n"}
{"9882": "public class PolymerElements { \npublic String toHELM2 ( ) { \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \nlistMonomerNotations . size ( ) > i ; \ni ++ ) { \nnotation . append ( listMonomerNotations . get ( i ) . toHELM2 ( ) + \".\" ) ; \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9893": "public class StateMachineParser { \npublic boolean isPeptideOrRna ( ) throws SimplePolymerSectionException { \nif ( 1 <= polymerElements . size ( ) ) { \nif ( polymerElements . get ( polymerElements . size ( ) - 1 ) . matches ( \"(PEPTIDE[1-9][0-9]*+|RNA[1-9][0-9]*)\" ) ) { \nreturn true ; \n} \nreturn false ; \n} \nelse { \nthrow new SimplePolymerSectionException ( \"No Polymer Id is found\" ) ; \n} \n} \n} \n"}
{"9898": "public class HELM2Notation { \npublic String polymerToHELM2 ( ) { \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \nlistOfPolymers . size ( ) > i ; \ni ++ ) { \nif ( listOfPolymers . get ( i ) . isAnnotationHere ( ) ) { \nnotation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\\\"\" + listOfPolymers . get ( i ) . getAnnotation ( ) + \"\\\"|\" ) ; \n} \nelse { \nnotation . append ( listOfPolymers . get ( i ) . getPolymerID ( ) + \"{\" + listOfPolymers . get ( i ) . toHELM2 ( ) + \"}\" + \"|\" ) ; \n} \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9899": "public class HELM2Notation { \npublic String connectionToHELM2 ( ) { \nif ( listOfConnections . size ( ) == 0 ) { \nreturn \"\" ; \n} \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \nlistOfConnections . size ( ) > i ; \ni ++ ) { \nnotation . append ( listOfConnections . get ( i ) . toHELM2 ( ) + \"|\" ) ; \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9900": "public class HELM2Notation { \npublic String groupingToHELM2 ( ) { \nif ( listOfGroupings . size ( ) == 0 ) { \nreturn \"\" ; \n} \nStringBuilder notation = new StringBuilder ( ) ; \nfor ( int i = 0 ; \nlistOfGroupings . size ( ) > i ; \ni ++ ) { \nnotation . append ( listOfGroupings . get ( i ) . toHELM2 ( ) + \"|\" ) ; \n} \nnotation . setLength ( notation . length ( ) - 1 ) ; \nreturn notation . toString ( ) ; \n} \n} \n"}
{"9901": "public class HELM2Notation { \npublic String annotationToHELM2 ( ) { \nif ( ! ( annotationSection . isEmpty ( ) ) ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 0 ; \nannotationSection . size ( ) > i ; \ni ++ ) { \nsb . append ( annotationSection . get ( i ) . toHELM2 ( ) + \"|\" ) ; \n} \nsb . setLength ( sb . length ( ) - 1 ) ; \nreturn sb . toString ( ) ; \n} \nreturn \"\" ; \n} \n} \n"}
{"9905": "public class ConverterHELM1ToHELM2 { \npublic String doConvert ( String str ) { \nParserHELM2 parser = new ParserHELM2 ( ) ; \ntry { \nparser . parse ( str + \"V2.0\" ) ; \nreturn str + \"V2.0\" ; \n} \ncatch ( Exception e ) { \nString helm1 = str + \"f\" ; \nStringBuilder helm2 = new StringBuilder ( ) ; \nString [ ] sections = helm1 . split ( \"}\\\\$\" ) ; \nhelm2 . append ( sections [ 0 ] + \"}$\" ) ; \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( int i = 1 ; \nsections . length > i ; \ni ++ ) { \nsb . append ( sections [ i ] + \"}$\" ) ; \n} \nhelm1 = \"$\" + sb . toString ( ) ; \nsections = helm1 . split ( \"\\\\$\" ) ; \nif ( 2 <= sections . length ) { \nif ( ! ( sections [ 1 ] . isEmpty ( ) ) ) { \nhelm2 . append ( sections [ 1 ] ) ; \n} \n} \nif ( 3 <= sections . length ) { \nif ( ! ( sections [ 2 ] . isEmpty ( ) ) ) { \nif ( ! ( sections [ 1 ] . isEmpty ( ) ) ) { \nhelm2 . append ( \"|\" + sections [ 2 ] ) ; \n} \nelse { \nhelm2 . append ( sections [ 2 ] ) ; \n} \n} \nhelm2 . append ( \"$\" ) ; \nhelm2 . append ( \"$\" ) ; \nif ( 4 <= sections . length ) { \nif ( ! ( sections [ 3 ] . isEmpty ( ) ) ) { \nhelm2 . append ( sections [ 3 ] ) ; \n} \n} \n} \nhelm2 . append ( \"$V2.0\" ) ; \nreturn helm2 . toString ( ) ; \n} \n} \n} \n"}
{"9908": "public class ValidationMethod { \npublic static MonomerNotation decideWhichMonomerNotation ( String str , String type ) throws NotationException { \nMonomerNotation mon ; \nif ( str . startsWith ( \"(\" ) && str . endsWith ( \")\" ) ) { \nString str2 = str . substring ( 1 , str . length ( ) - 1 ) ; \nPattern patternAND = Pattern . compile ( \"\\\\+\" ) ; \nPattern patternOR = Pattern . compile ( \",\" ) ; \nif ( patternAND . matcher ( str ) . find ( ) ) { \nmon = new MonomerNotationGroupMixture ( str2 , type ) ; \n} \nelse if ( patternOR . matcher ( str ) . find ( ) ) { \nmon = new MonomerNotationGroupOr ( str2 , type ) ; \n} \nelse { \nif ( str . contains ( \".\" ) ) { \nmon = new MonomerNotationList ( str2 , type ) ; \n} \nelse { \nif ( type == \"RNA\" ) { \nmon = new MonomerNotationUnitRNA ( str2 , type ) ; \n} \nelse { \nif ( 1 < str2 . length ( ) ) { \nif ( ! ( str2 . startsWith ( \"[\" ) && str2 . endsWith ( \"]\" ) ) ) { \nthrow new NotationException ( \"Monomers have to be in brackets: \" + str ) ; \n} \n} \nmon = new MonomerNotationUnit ( str2 , type ) ; \n} \n} \n} \n} \nelse { \nif ( type == \"RNA\" ) { \nmon = new MonomerNotationUnitRNA ( str , type ) ; \n} \nelse if ( type != \"BLOB\" ) { \nif ( 1 < str . length ( ) ) { \nif ( ! ( str . startsWith ( \"[\" ) && str . endsWith ( \"]\" ) ) ) { \nthrow new NotationException ( \"Monomers have to be in brackets: \" + str ) ; \n} \n} \nmon = new MonomerNotationUnit ( str , type ) ; \n} \nelse { \nmon = new MonomerNotationUnit ( str , type ) ; \n} \n} \nreturn mon ; \n} \n} \n"}
{"9912": "public class ParserHELM2 { \npublic void parse ( String test ) throws ExceptionState { \nparser = new StateMachineParser ( ) ; \ntest = test . trim ( ) ; \nif ( test . substring ( test . length ( ) - 4 ) . matches ( \"V2\\\\.0\" ) || test . substring ( test . length ( ) - 4 ) . matches ( \"v2\\\\.0\" ) ) { \nfor ( int i = 0 ; \ntest . length ( ) - 4 > i ; \ni ++ ) { \nparser . doAction ( test . charAt ( i ) ) ; \n} \nif ( ! ( parser . getState ( ) instanceof FinalState ) ) { \nLOG . error ( \"Invalid input: Final State was not reached:\" ) ; \nthrow new FinalStateException ( \"Invalid input: Final State was not reached\" ) ; \n} \n} \nelse { \nLOG . error ( \"Invalid input: HELM2 standard is missing:\" ) ; \nthrow new NotValidHELM2Exception ( \"Invalid input: HELM2 standard is missing\" ) ; \n} \n} \n} \n"}
{"9913": "public class MonomerNotationUnitRNA { \nprivate void setRNAContents ( String str ) throws NotationException { \nString [ ] list ; \nList < String > items = extractContents ( str ) ; \nfor ( String item : items ) { \nif ( 1 < item . length ( ) ) { \nif ( ! ( item . startsWith ( \"[\" ) && item . endsWith ( \"]\" ) ) ) { \nthrow new NotationException ( \"Monomers have to be in brackets \" + item ) ; \n} \n} \ncontents . add ( new MonomerNotationUnit ( item , type ) ) ; \n} \n} \n} \n"}
{"9918": "public class ADiGraph { \nprivate void initPathsInternal ( ) { \nsynchronized ( LOCK ) { \nif ( _incomingPathsInternal == null ) { \nAMap < N , AList < AEdgePath < N , E > > > incomingPaths = AHashMap . empty ( ) ; \nincomingPaths = incomingPaths . withDefaultValue ( AList . nil ) ; \nAMap < N , AList < AEdgePath < N , E > > > outgoingPaths = AHashMap . empty ( ) ; \noutgoingPaths = outgoingPaths . withDefaultValue ( AList . nil ) ; \nAList < AEdgePath < N , E > > cycles = AList . nil ( ) ; \nfor ( N curNode : nodes ( ) ) { \nfinal Iterable < E > curIncoming = incomingEdges ( curNode ) ; \nList < AEdgePath < N , E > > unfinishedBusiness = new ArrayList < > ( ) ; \nfor ( E incomingEdge : curIncoming ) { \nunfinishedBusiness . add ( AEdgePath . create ( incomingEdge ) ) ; \n} \nAList < AEdgePath < N , E > > nonCycles = AList . nil ( ) ; \nwhile ( 0 < unfinishedBusiness . size ( ) ) { \nfinal List < AEdgePath < N , E > > curBusiness = unfinishedBusiness ; \nfor ( AEdgePath < N , E > p : unfinishedBusiness ) { \nif ( ! p . hasCycle ( ) || p . isMinimalCycle ( ) ) nonCycles = nonCycles . cons ( p ) ; \nif ( p . isMinimalCycle ( ) ) cycles = cycles . cons ( p ) ; \n} \nunfinishedBusiness = new ArrayList < > ( ) ; \nfor ( AEdgePath < N , E > curPath : curBusiness ) { \nfinal Iterable < E > l = incomingEdges ( curPath . getFrom ( ) ) ; \nfor ( E newEdge : l ) { \nfinal AEdgePath < N , E > pathCandidate = curPath . prepend ( newEdge ) ; \nif ( ! pathCandidate . hasNonMinimalCycle ( ) ) { \nunfinishedBusiness . add ( pathCandidate ) ; \n} \n} \n} \n} \nincomingPaths = incomingPaths . updated ( curNode , nonCycles ) ; \nfor ( AEdgePath < N , E > p : nonCycles ) { \noutgoingPaths = outgoingPaths . updated ( p . getFrom ( ) , outgoingPaths . getRequired ( p . getFrom ( ) ) . cons ( p ) ) ; \n} \n} \n_incomingPathsInternal = incomingPaths ; \n_outgoingPathsInternal = outgoingPaths ; \n_cyclesInternal = cycles ; \n} \n} \n} \n} \n"}
{"9931": "public class ForkJoinPool { \nfinal WorkQueue registerWorker ( ForkJoinWorkerThread wt ) { \nUncaughtExceptionHandler handler ; \nwt . setDaemon ( true ) ; \nif ( ( handler = ueh ) != null ) wt . setUncaughtExceptionHandler ( handler ) ; \nWorkQueue w = new WorkQueue ( this , wt ) ; \nint i = 0 ; \nint mode = config & MODE_MASK ; \nint rs = lockRunState ( ) ; \ntry { \nWorkQueue [ ] ws ; \nint n ; \nif ( ( ws = workQueues ) != null && 0 < ( n = ws . length ) ) { \nint s = indexSeed += SEED_INCREMENT ; \nint m = n - 1 ; \ni = ( ( s << 1 ) | 1 ) & m ; \nif ( ws [ i ] != null ) { \nint probes = 0 ; \nint step = ( 4 >= n ) ? 2 : ( ( n >>> 1 ) & EVENMASK ) + 2 ; \nwhile ( ws [ i = ( i + step ) & m ] != null ) { \nif ( n <= ++ probes ) { \nworkQueues = ws = Arrays . copyOf ( ws , n <<= 1 ) ; \nm = n - 1 ; \nprobes = 0 ; \n} \n} \n} \nw . hint = s ; \nw . config = i | mode ; \nw . scanState = i ; \nws [ i ] = w ; \n} \n} \nfinally { \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nwt . setName ( workerNamePrefix . concat ( Integer . toString ( i >>> 1 ) ) ) ; \nreturn w ; \n} \n} \n"}
{"9932": "public class ForkJoinPool { \nfinal void deregisterWorker ( ForkJoinWorkerThread wt , Throwable ex ) { \nWorkQueue w = null ; \nif ( wt != null && ( w = wt . workQueue ) != null ) { \nWorkQueue [ ] ws ; \nint idx = w . config & SMASK ; \nint rs = lockRunState ( ) ; \nif ( ( ws = workQueues ) != null && idx < ws . length && ws [ idx ] == w ) ws [ idx ] = null ; \nunlockRunState ( rs , rs & ~ RSLOCK ) ; \n} \nlong c ; \ndo { \n} \nwhile ( ! U . compareAndSwapLong ( this , CTL , c = ctl , ( ( AC_MASK & ( c - AC_UNIT ) ) | ( TC_MASK & ( c - TC_UNIT ) ) | ( SP_MASK & c ) ) ) ) ; \nif ( w != null ) { \nw . qlock = - 1 ; \nw . transferStealCount ( this ) ; \nw . cancelAll ( ) ; \n} \nfor ( ; \n; \n) { \nWorkQueue [ ] ws ; \nint m , sp ; \nif ( tryTerminate ( false , false ) || w == null || w . array == null || ( runState & STOP ) != 0 || ( ws = workQueues ) == null || 0 > ( m = ws . length - 1 ) ) break ; \nif ( ( sp = ( int ) ( c = ctl ) ) != 0 ) { \nif ( tryRelease ( c , ws [ sp & m ] , AC_UNIT ) ) break ; \n} \nelse if ( ex != null && ( c & ADD_WORKER ) != 0L ) { \ntryAddWorker ( c ) ; \nbreak ; \n} \nelse break ; \n} \nif ( ex == null ) ForkJoinTask . helpExpungeStaleExceptions ( ) ; \nelse ForkJoinTask . rethrow ( ex ) ; \n} \n} \n"}
{"9933": "public class ForkJoinPool { \nfinal void signalWork ( WorkQueue [ ] ws , WorkQueue q ) { \nlong c ; \nint sp , i ; \nWorkQueue v ; \nThread p ; \nwhile ( 0L > ( c = ctl ) ) { \nif ( ( sp = ( int ) c ) == 0 ) { \nif ( ( c & ADD_WORKER ) != 0L ) tryAddWorker ( c ) ; \nbreak ; \n} \nif ( ws == null ) break ; \nif ( ( i = sp & SMASK ) >= ws . length ) break ; \nif ( ( v = ws [ i ] ) == null ) break ; \nint vs = ( sp + SS_SEQ ) & ~ INACTIVE ; \nint d = sp - v . scanState ; \nlong nc = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & v . stackPred ) ; \nif ( d == 0 && U . compareAndSwapLong ( this , CTL , c , nc ) ) { \nv . scanState = vs ; \nif ( ( p = v . parker ) != null ) U . unpark ( p ) ; \nbreak ; \n} \nif ( q != null && q . base == q . top ) break ; \n} \n} \n} \n"}
{"9935": "public class ForkJoinPool { \nprivate boolean awaitWork ( WorkQueue w , int r ) { \nif ( w == null || 0 > w . qlock ) return false ; \nfor ( int pred = w . stackPred , spins = SPINS , ss ; \n; \n) { \nif ( 0 <= ( ss = w . scanState ) ) break ; \nelse if ( 0 < spins ) { \nr ^= r << 6 ; \nr ^= r >>> 21 ; \nr ^= r << 7 ; \nif ( 0 <= r && -- spins == 0 ) { \nWorkQueue v ; \nWorkQueue [ ] ws ; \nint s , j ; \nAtomicLong sc ; \nif ( pred != 0 && ( ws = workQueues ) != null && ws . length > ( j = pred & SMASK ) && ( v = ws [ j ] ) != null && ( v . parker == null || 0 <= v . scanState ) ) spins = SPINS ; \n} \n} \nelse if ( 0 > w . qlock ) return false ; \nelse if ( ! Thread . interrupted ( ) ) { \nlong c , prevctl , parkTime , deadline ; \nint ac = ( int ) ( ( c = ctl ) >> AC_SHIFT ) + ( config & SMASK ) ; \nif ( ( 0 >= ac && tryTerminate ( false , false ) ) || ( runState & STOP ) != 0 ) return false ; \nif ( 0 >= ac && ss == ( int ) c ) { \nprevctl = ( UC_MASK & ( c + AC_UNIT ) ) | ( SP_MASK & pred ) ; \nint t = ( short ) ( c >>> TC_SHIFT ) ; \nif ( 2 < t && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \nparkTime = IDLE_TIMEOUT * ( ( 0 <= t ) ? 1 : 1 - t ) ; \ndeadline = System . nanoTime ( ) + parkTime - TIMEOUT_SLOP ; \n} \nelse prevctl = parkTime = deadline = 0L ; \nThread wt = Thread . currentThread ( ) ; \nU . putObject ( wt , PARKBLOCKER , this ) ; \nw . parker = wt ; \nif ( 0 > w . scanState && ctl == c ) U . park ( false , parkTime ) ; \nU . putOrderedObject ( w , QPARKER , null ) ; \nU . putObject ( wt , PARKBLOCKER , null ) ; \nif ( 0 <= w . scanState ) break ; \nif ( parkTime != 0L && ctl == c && 0L >= deadline - System . nanoTime ( ) && U . compareAndSwapLong ( this , CTL , c , prevctl ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"9936": "public class ForkJoinPool { \nstatic int getSurplusQueuedTaskCount ( ) { \nThread t ; \nForkJoinWorkerThread wt ; \nForkJoinPool pool ; \nWorkQueue q ; \nif ( ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) ) { \nint p = ( pool = ( wt = ( ForkJoinWorkerThread ) t ) . pool ) . config & SMASK ; \nint n = ( q = wt . workQueue ) . top - q . base ; \nint a = ( int ) ( pool . ctl >> AC_SHIFT ) + p ; \nreturn n - ( ( p >>>= 1 ) < a ? 0 : ( p >>>= 1 ) < a ? 1 : ( p >>>= 1 ) < a ? 2 : ( p >>>= 1 ) < a ? 4 : 8 ) ; \n} \nreturn 0 ; \n} \n} \n"}
{"9937": "public class ForkJoinPool { \nstatic WorkQueue commonSubmitterQueue ( ) { \nForkJoinPool p = common ; \nint r = ThreadLocalRandomHelper . getProbe ( ) ; \nWorkQueue [ ] ws ; \nint m ; \nreturn ( p != null && ( ws = p . workQueues ) != null && 0 <= ( m = ws . length - 1 ) ) ? ws [ m & r & SQMASK ] : null ; \n} \n} \n"}
{"9940": "public class ForkJoinPool { \nprivate static ForkJoinPool makeCommonPool ( ) { \nint parallelism = - 1 ; \nForkJoinWorkerThreadFactory factory = null ; \nUncaughtExceptionHandler handler = null ; \ntry { \nString pp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.parallelism\" ) ; \nString fp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.threadFactory\" ) ; \nString hp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.exceptionHandler\" ) ; \nString mp = System . getProperty ( \"java.util.concurrent.ForkJoinPool.common.maximumSpares\" ) ; \nif ( pp != null ) parallelism = Integer . parseInt ( pp ) ; \nif ( fp != null ) factory = ( ( ForkJoinWorkerThreadFactory ) ClassLoader . getSystemClassLoader ( ) . loadClass ( fp ) . newInstance ( ) ) ; \nif ( hp != null ) handler = ( ( UncaughtExceptionHandler ) ClassLoader . getSystemClassLoader ( ) . loadClass ( hp ) . newInstance ( ) ) ; \nif ( mp != null ) commonMaxSpares = Integer . parseInt ( mp ) ; \n} \ncatch ( Exception ignore ) { \n} \nif ( factory == null ) { \nif ( System . getSecurityManager ( ) == null ) factory = defaultForkJoinWorkerThreadFactory ; \nelse factory = new InnocuousForkJoinWorkerThreadFactory ( ) ; \n} \nif ( 0 > parallelism && 0 >= ( parallelism = Runtime . getRuntime ( ) . availableProcessors ( ) - 1 ) ) parallelism = 1 ; \nif ( MAX_CAP < parallelism ) parallelism = MAX_CAP ; \nreturn new ForkJoinPool ( parallelism , factory , handler , LIFO_QUEUE , \"ForkJoinPool.commonPool-worker-\" ) ; \n} \n} \n"}
{"9941": "public class ForkJoinTask { \npublic final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { \nint s ; \nlong nanos = unit . toNanos ( timeout ) ; \nif ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; \nif ( 0 <= ( s = status ) && 0L < nanos ) { \nlong d = System . nanoTime ( ) + nanos ; \nlong deadline = ( d == 0L ) ? 1L : d ; \nThread t = Thread . currentThread ( ) ; \nif ( t instanceof ForkJoinWorkerThread ) { \nForkJoinWorkerThread wt = ( ForkJoinWorkerThread ) t ; \ns = wt . pool . awaitJoin ( wt . workQueue , this , deadline ) ; \n} \nelse if ( 0 <= ( s = ( ( this instanceof CountedCompleter ) ? ForkJoinPool . common . externalHelpComplete ( ( CountedCompleter < ? > ) this , 0 ) : ForkJoinPool . common . tryExternalUnpush ( this ) ? doExec ( ) : 0 ) ) ) { \nlong ns , ms ; \nwhile ( 0 <= ( s = status ) && 0L < ( ns = deadline - System . nanoTime ( ) ) ) { \nif ( 0L < ( ms = TimeUnit . NANOSECONDS . toMillis ( ns ) ) && U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { \nsynchronized ( this ) { \nif ( 0 <= status ) wait ( ms ) ; \nelse notifyAll ( ) ; \n} \n} \n} \n} \n} \nif ( 0 <= s ) s = status ; \nif ( ( s &= DONE_MASK ) != NORMAL ) { \nThrowable ex ; \nif ( s == CANCELLED ) throw new CancellationException ( ) ; \nif ( s != EXCEPTIONAL ) throw new TimeoutException ( ) ; \nif ( ( ex = getThrowableException ( ) ) != null ) throw new ExecutionException ( ex ) ; \n} \nreturn getRawResult ( ) ; \n} \n} \n"}
{"9943": "public class AThreadPoolImpl { \n@ Override public AThreadPoolStatistics getStatistics ( ) { \nfinal AWorkerThreadStatistics [ ] workerStats = new AWorkerThreadStatistics [ localQueues . length ] ; \nfor ( int i = 0 ; \nlocalQueues . length > i ; \ni ++ ) { \nworkerStats [ i ] = localQueues [ i ] . thread . getStatistics ( ) ; \n} \nfinal ASharedQueueStatistics [ ] sharedQueueStats = new ASharedQueueStatistics [ sharedQueues . length ] ; \nfor ( int i = 0 ; \nsharedQueues . length > i ; \ni ++ ) { \nsharedQueueStats [ i ] = new ASharedQueueStatistics ( sharedQueues [ i ] . approximateSize ( ) ) ; \n} \nreturn new AThreadPoolStatistics ( workerStats , sharedQueueStats ) ; \n} \n} \n"}
{"9949": "public class LocalQueue { \nvoid push ( Runnable task ) { \nfinal long _base = UNSAFE . getLongVolatile ( this , OFFS_BASE ) ; \nfinal long _top = top ; \nif ( _top == _base + mask ) { \nthrow new RejectedExecutionExceptionWithoutStacktrace ( \"local queue overflow\" ) ; \n} \ntasks [ asArrayindex ( _top ) ] = task ; \nUNSAFE . putLongVolatile ( this , OFFS_TOP , _top + 1 ) ; \nif ( 1 >= _top - _base ) { \npool . onAvailableTask ( ) ; \n} \n} \n} \n"}
{"9956": "public class UriLoader { \nprivate String normalizeResourceName ( String name ) { \nif ( name . startsWith ( \"//\" ) ) { \nreturn \"classpath:\" + name ; \n} \nfinal int firstProtocol = name . indexOf ( \"://\" ) ; \nfinal int secondProtocol = name . indexOf ( \"://\" , firstProtocol + 1 ) ; \nfinal int protocol = 0 > secondProtocol ? firstProtocol : secondProtocol ; \nfinal int endOfFirst = name . lastIndexOf ( \"/\" , protocol ) ; \nif ( 0 <= endOfFirst ) { \nreturn name . substring ( endOfFirst + 1 ) ; \n} \nreturn name ; \n} \n} \n"}
{"9966": "public class DataKit { \npublic static int getInt ( Long l ) { \nreturn ( l == null || Integer . MAX_VALUE < l ) ? 0 : l . intValue ( ) ; \n} \n} \n"}
{"9982": "public class CharKit { \npublic static byte [ ] toSimpleByteArray ( char [ ] carr ) { \nbyte [ ] barr = new byte [ carr . length ] ; \nfor ( int i = 0 ; \ncarr . length > i ; \ni ++ ) { \nbarr [ i ] = ( byte ) carr [ i ] ; \n} \nreturn barr ; \n} \n} \n"}
{"9983": "public class CharKit { \npublic static byte [ ] toSimpleByteArray ( CharSequence charSequence ) { \nbyte [ ] barr = new byte [ charSequence . length ( ) ] ; \nfor ( int i = 0 ; \nbarr . length > i ; \ni ++ ) { \nbarr [ i ] = ( byte ) charSequence . charAt ( i ) ; \n} \nreturn barr ; \n} \n} \n"}
{"9984": "public class CharKit { \npublic static char [ ] toSimpleCharArray ( byte [ ] barr ) { \nchar [ ] carr = new char [ barr . length ] ; \nfor ( int i = 0 ; \nbarr . length > i ; \ni ++ ) { \ncarr [ i ] = ( char ) ( barr [ i ] & 0xFF ) ; \n} \nreturn carr ; \n} \n} \n"}
{"9985": "public class CharKit { \npublic static byte [ ] toAsciiByteArray ( CharSequence charSequence ) { \nbyte [ ] barr = new byte [ charSequence . length ( ) ] ; \nfor ( int i = 0 ; \nbarr . length > i ; \ni ++ ) { \nchar c = charSequence . charAt ( i ) ; \nbarr [ i ] = ( byte ) ( ( int ) ( 0xFF >= c ? c : 0x3F ) ) ; \n} \nreturn barr ; \n} \n} \n"}
{"9999": "public class Redirect { \npublic void to ( WebContext context ) { \nHttpServletResponse response = context . response ( ) ; \nif ( ! mediaType . isEmpty ( ) ) { \nresponse . setHeader ( \"Content-Type\" , mediaType ) ; \n} \nif ( 0 < status ) { \nresponse . setStatus ( status ) ; \n} \ntry { \nresponse . sendRedirect ( response . encodeRedirectURL ( url ) ) ; \n} \ncatch ( IOException e ) { \nthrow new UncheckedException ( e ) ; \n} \n} \n} \n"}
{"10001": "public class RuntimeKit { \npublic static String currentMethod ( ) { \nStackTraceElement [ ] ste = new Exception ( ) . getStackTrace ( ) ; \nint ndx = ( 1 < ste . length ) ? 1 : 0 ; \nreturn new Exception ( ) . getStackTrace ( ) [ ndx ] . toString ( ) ; \n} \n} \n"}
{"10004": "public class LogUtil { \npublic static String encodeString ( String value ) { \nint estimatedSize = 0 ; \nfinal int len = value . length ( ) ; \nfor ( int i = 0 ; \nlen > i ; \n++ i ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ' ' >= ch || ch == ',' ) { \nestimatedSize += 3 ; \ncontinue ; \n} \n++ estimatedSize ; \n} \nif ( value . length ( ) == estimatedSize ) { \nreturn value ; \n} \nfinal StringBuilder builder = new StringBuilder ( estimatedSize ) ; \nfor ( int i = 0 ; \nlen > i ; \n++ i ) { \nfinal char ch = value . charAt ( i ) ; \nif ( ' ' >= ch ) { \nbuilder . append ( \"%20\" ) ; \ncontinue ; \n} \nif ( ch == ',' ) { \nbuilder . append ( \"%2c\" ) ; \ncontinue ; \n} \nbuilder . append ( ch ) ; \n} \nreturn builder . toString ( ) ; \n} \n} \n"}
{"10007": "public class StreamUtil { \npublic static int copy ( InputStream input , OutputStream output , int byteCount ) throws IOException { \nbyte buffer [ ] = new byte [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( 0 < byteCount ) { \nif ( ioBufferSize > byteCount ) { \nread = input . read ( buffer , 0 , byteCount ) ; \n} \nelse { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \n} \nif ( read == - 1 ) { \nbreak ; \n} \nbyteCount -= read ; \ncount += read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10009": "public class StreamUtil { \npublic static int copy ( Reader input , Writer output ) throws IOException { \nchar [ ] buffer = new char [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( 0 <= ( read = input . read ( buffer , 0 , ioBufferSize ) ) ) { \noutput . write ( buffer , 0 , read ) ; \ncount += read ; \n} \noutput . flush ( ) ; \nreturn count ; \n} \n} \n"}
{"10010": "public class StreamUtil { \npublic static int copy ( Reader input , Writer output , int charCount ) throws IOException { \nchar buffer [ ] = new char [ ioBufferSize ] ; \nint count = 0 ; \nint read ; \nwhile ( 0 < charCount ) { \nif ( ioBufferSize > charCount ) { \nread = input . read ( buffer , 0 , charCount ) ; \n} \nelse { \nread = input . read ( buffer , 0 , ioBufferSize ) ; \n} \nif ( read == - 1 ) { \nbreak ; \n} \ncharCount -= read ; \ncount += read ; \noutput . write ( buffer , 0 , read ) ; \n} \nreturn count ; \n} \n} \n"}
{"10015": "public class Pipeline { \n@ SuppressWarnings ( \"unchecked\" ) public T apply ( T io ) { \nlogger . debug ( \"Pipeline began\" ) ; \ntry { \nfor ( int i = 0 ; \nstages . size ( ) > i ; \ni ++ ) { \nObject stage = stages . get ( i ) ; \nString name = names . get ( stage ) ; \nlogger . debug ( \"Stage-\" + i + ( ( name != null && ! name . isEmpty ( ) ) ? \" [\" + name + \"] \" : \" \" ) + \"processing\" ) ; \nif ( stage instanceof Function ) { \nif ( ( io = ( ( Function < T , T > ) stage ) . apply ( io ) ) == null ) { \nreturn io ; \n} \n} \nelse if ( stage instanceof Predicate ) { \nif ( ! ( ( Predicate < T > ) stage ) . apply ( io ) ) { \nreturn io ; \n} \n} \n} \nreturn io ; \n} \nfinally { \nlogger . debug ( \"Pipeline ended\" ) ; \n} \n} \n} \n"}
{"10018": "public class ZipKit { \npublic static void unzip ( File zipFile , File destDir , String ... patterns ) throws IOException { \nZipFile zip = new ZipFile ( zipFile ) ; \nEnumeration zipEntries = zip . entries ( ) ; \nwhile ( zipEntries . hasMoreElements ( ) ) { \nZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nif ( patterns != null && 0 < patterns . length ) { \nif ( Wildcard . matchPathOne ( entryName , patterns ) == - 1 ) { \ncontinue ; \n} \n} \nFile file = ( destDir != null ) ? new File ( destDir , entryName ) : new File ( entryName ) ; \nif ( entry . isDirectory ( ) ) { \nif ( ! file . mkdirs ( ) ) { \nif ( ! file . isDirectory ( ) ) { \nthrow new IOException ( \"Failed to create directory: \" + file ) ; \n} \n} \n} \nelse { \nFile parent = file . getParentFile ( ) ; \nif ( parent != null && ! parent . exists ( ) ) { \nif ( ! parent . mkdirs ( ) ) { \nif ( ! file . isDirectory ( ) ) { \nthrow new IOException ( \"Failed to create directory: \" + parent ) ; \n} \n} \n} \nInputStream in = zip . getInputStream ( entry ) ; \nOutputStream out = null ; \ntry { \nout = new FileOutputStream ( file ) ; \nStreamUtil . copy ( in , out ) ; \n} \nfinally { \nStreamUtil . close ( out ) ; \nStreamUtil . close ( in ) ; \n} \n} \n} \nclose ( zip ) ; \n} \n} \n"}
{"10025": "public class Validator { \npublic static boolean isBirthDay ( String value ) { \nString check = \"(\\\\d{4})(/|-|\\\\.)(\\\\d{1,2})(/|-|\\\\.)(\\\\d{1,2})$\" ; \nif ( match ( check , Pattern . CASE_INSENSITIVE , value ) ) { \nint year = Integer . parseInt ( value . substring ( 0 , 4 ) ) ; \nint month = Integer . parseInt ( value . substring ( 5 , 7 ) ) ; \nint day = Integer . parseInt ( value . substring ( 8 , 10 ) ) ; \nif ( 1 > month || 12 < month ) { \nreturn false ; \n} \nif ( 1 > day || 31 < day ) { \nreturn false ; \n} \nif ( ( month == 4 || month == 6 || month == 9 || month == 11 ) && day == 31 ) { \nreturn false ; \n} \nif ( month == 2 ) { \nboolean isleap = ( year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) ; \nif ( 29 < day || ( day == 29 && ! isleap ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"10052": "public class URITemplate { \npublic Map < String , String > variables ( String uri ) { \nMap < String , String > variables = new HashMap < String , String > ( ) ; \nMatcher matcher = pattern . matcher ( uri ) ; \nif ( matcher . matches ( ) ) { \nfor ( int i = 0 ; \nmatcher . groupCount ( ) > i ; \ni ++ ) { \nvariables . put ( this . variables . get ( i ) , matcher . group ( i + 1 ) ) ; \n} \n} \nreturn variables ; \n} \n} \n"}
{"10072": "public class Dao { \npublic static < M extends Model > boolean isNew ( M m , String pk_column ) { \nfinal Object val = m . get ( pk_column ) ; \nreturn val == null || val instanceof Number && 0 >= ( ( Number ) val ) . intValue ( ) ; \n} \n} \n"}
{"10077": "public class ArgumentHandler { \npublic static < A > A readArguments ( Class < A > interfaceClass , String [ ] args ) { \nA result = null ; \ntry { \nfinal ArgumentHandler argumentHandler = new ArgumentHandler ( args ) ; \nresult = argumentHandler . getInstance ( interfaceClass ) ; \nargumentHandler . processArguments ( new ArgumentProcessor ( ) { \n@ Override public void process ( List < String > remaining ) throws InvalidArgumentsException { \nif ( 0 < remaining . size ( ) ) { \nthrow new InvalidArgumentsException ( \"The following arguments could not be understood: \" + remaining ) ; \n} \n} \n} \n) ; \n} \ncatch ( InvalidArgumentsException e ) { \nSystem . out . println ( e . getMessage ( ) ) ; \nshowUsage ( interfaceClass ) ; \nresult = null ; \n} \nif ( result instanceof ArgumentsWithHelp ) { \nif ( ( ( ArgumentsWithHelp ) result ) . getHelp ( ) ) { \nshowUsage ( interfaceClass ) ; \nresult = null ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10100": "public class URI { \nprivate void initializeScheme ( String p_uriSpec ) throws MalformedURIException { \nint uriSpecLen = p_uriSpec . length ( ) ; \nint index = p_uriSpec . indexOf ( ':' ) ; \nif ( 1 > index ) throw new MalformedURIException ( \"No scheme found in URI.\" ) ; \nif ( index == uriSpecLen - 1 ) throw new MalformedURIException ( \"A bare scheme name is not a URI.\" ) ; \nsetScheme ( p_uriSpec . substring ( 0 , index ) ) ; \n} \n} \n"}
{"10101": "public class URI { \nprivate void initializePath ( String p_uriSpec ) throws MalformedURIException { \nif ( p_uriSpec == null ) { \nthrow new MalformedURIException ( \"Cannot initialize path from null string!\" ) ; \n} \nint index = 0 ; \nint start = 0 ; \nint end = p_uriSpec . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( end > index ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '?' || testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( end <= index + 2 || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Path contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Path contains invalid character: \" + testChar ) ; \n} \nindex ++ ; \n} \nm_path = p_uriSpec . substring ( start , index ) ; \nif ( testChar == '?' ) { \nindex ++ ; \nstart = index ; \nwhile ( end > index ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '#' ) { \nbreak ; \n} \nif ( testChar == '%' ) { \nif ( end <= index + 2 || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Query string contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \nm_queryString = p_uriSpec . substring ( start , index ) ; \n} \nif ( testChar == '#' ) { \nindex ++ ; \nstart = index ; \nwhile ( end > index ) { \ntestChar = p_uriSpec . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( end <= index + 2 || ! isHex ( p_uriSpec . charAt ( index + 1 ) ) || ! isHex ( p_uriSpec . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isReservedCharacter ( testChar ) && ! isUnreservedCharacter ( testChar ) ) { \nthrow new MalformedURIException ( \"Fragment contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \nm_fragment = p_uriSpec . substring ( start , index ) ; \n} \n} \n} \n"}
{"10103": "public class URI { \nprivate void setUserinfo ( String p_userinfo ) throws MalformedURIException { \nif ( p_userinfo == null ) { \nm_userinfo = null ; \n} \nelse { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Userinfo cannot be set when host is null!\" ) ; \n} \nint index = 0 ; \nint end = p_userinfo . length ( ) ; \nchar testChar = '\\0' ; \nwhile ( end > index ) { \ntestChar = p_userinfo . charAt ( index ) ; \nif ( testChar == '%' ) { \nif ( end <= index + 2 || ! isHex ( p_userinfo . charAt ( index + 1 ) ) || ! isHex ( p_userinfo . charAt ( index + 2 ) ) ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid escape sequence!\" ) ; \n} \n} \nelse if ( ! isUnreservedCharacter ( testChar ) && USERINFO_CHARACTERS . indexOf ( testChar ) == - 1 ) { \nthrow new MalformedURIException ( \"Userinfo contains invalid character:\" + testChar ) ; \n} \nindex ++ ; \n} \n} \nm_userinfo = p_userinfo ; \n} \n} \n"}
{"10105": "public class URI { \nprivate void setPort ( int p_port ) throws MalformedURIException { \nif ( 0 <= p_port && 65535 >= p_port ) { \nif ( m_host == null ) { \nthrow new MalformedURIException ( \"Port cannot be set when host is null!\" ) ; \n} \n} \nelse if ( p_port != - 1 ) { \nthrow new MalformedURIException ( \"Invalid port number!\" ) ; \n} \nn_port = p_port ; \n} \n} \n"}
{"10112": "public class MuffinManager { \npublic String getMuffin ( String strParam ) { \ntry { \nURL url = new URL ( m_strCodeBase + strParam ) ; \nFileContents fc = m_ps . get ( url ) ; \nif ( fc == null ) return null ; \nbyte [ ] buf = new byte [ ( int ) fc . getLength ( ) ] ; \nInputStream is = fc . getInputStream ( ) ; \nint pos = 0 ; \nwhile ( 0 < ( pos = is . read ( buf , pos , buf . length - pos ) ) ) { \n} \nis . close ( ) ; \nString strValue = new String ( buf , ENCODING ) ; \nreturn strValue ; \n} \ncatch ( Exception ex ) { \n} \nreturn null ; \n} \n} \n"}
{"10123": "public class FastBuffer { \n@ Override public Iterator < E > iterator ( ) { \nreturn new Iterator < E > ( ) { \nint iteratorIndex ; \nint iteratorBufferIndex ; \nint iteratorOffset ; \n@ Override public boolean hasNext ( ) { \nreturn size > iteratorIndex ; \n} \n@ Override public E next ( ) { \nif ( size <= iteratorIndex ) { \nthrow new NoSuchElementException ( ) ; \n} \nE [ ] buf = buffers [ iteratorBufferIndex ] ; \nE result = buf [ iteratorOffset ] ; \niteratorIndex ++ ; \niteratorOffset ++ ; \nif ( buf . length <= iteratorOffset ) { \niteratorOffset = 0 ; \niteratorBufferIndex ++ ; \n} \nreturn result ; \n} \n@ Override public void remove ( ) { \nthrow new UnsupportedOperationException ( ) ; \n} \n} \n; \n} \n} \n"}
{"10138": "public class ObjectQueryPreparer { \npublic ObjectQueryInfo prepareObjectQuery ( Object obj ) throws MalformedObjectNameException { \nObjectQueryInfo result ; \nString onamePattern = MBeanAnnotationUtil . getLocationONamePattern ( obj ) ; \nif ( onamePattern != null ) { \nMap < String , Method > attributeSetters = MBeanAnnotationUtil . getAttributes ( obj ) ; \nif ( 0 < attributeSetters . size ( ) ) { \nString onameString ; \nif ( obj instanceof MBeanLocationParameterSource ) { \nonameString = this . parameterReplacer . replaceObjectNameParameters ( onamePattern , ( MBeanLocationParameterSource ) obj ) ; \n} \nelse { \nonameString = onamePattern ; \n} \nObjectName oname = new ObjectName ( onameString ) ; \nresult = new ObjectQueryInfo ( obj , oname , attributeSetters ) ; \n} \nelse { \nthis . logNoAttributeThrottle . warn ( log , \"ignoring attempt to prepare to poll an MBean object with no attributes: onamePattern={}\" , onamePattern ) ; \nresult = null ; \n} \n} \nelse { \nlog . warn ( \"ignoring attempt to prepare to poll object that has no MBeanLocation\" ) ; \nresult = null ; \n} \nreturn result ; \n} \n} \n"}
{"10139": "public class Util { \npublic static String replaceSlashWithHyphen ( String origin ) { \nchar [ ] resulltChars = origin . toCharArray ( ) ; \nfor ( int i = 0 ; \nresulltChars . length - 1 > i ; \ni ++ ) { \nif ( resulltChars [ i ] == '/' ) { \nresulltChars [ i ] = '-' ; \n} \n} \nreturn new String ( resulltChars , 0 , resulltChars . length - 1 ) ; \n} \n} \n"}
{"10140": "public class Util { \npublic static String bytes2HexString ( byte [ ] bytes ) { \nStringBuffer resultBuffer = new StringBuffer ( ) ; \nfor ( int i = 0 ; \nbytes . length > i ; \ni ++ ) { \nresultBuffer . append ( byte2Hex ( bytes [ i ] ) ) ; \n} \nreturn resultBuffer . toString ( ) ; \n} \n} \n"}
{"10142": "public class NamedParameterStatement { \nprivate static String parseNamedSql ( String sql , Map < String , List < Integer > > nameIndexMap ) { \nint length = sql . length ( ) ; \nStringBuffer parsedSql = new StringBuffer ( length ) ; \nboolean inSingleQuote = false ; \nboolean inDoubleQuote = false ; \nint index = 1 ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nchar c = sql . charAt ( i ) ; \nif ( inSingleQuote ) { \nif ( c == '\\'' ) { \ninSingleQuote = false ; \n} \n} \nelse if ( inDoubleQuote ) { \nif ( c == '\"' ) { \ninDoubleQuote = false ; \n} \n} \nelse { \nif ( c == '\\'' ) { \ninSingleQuote = true ; \n} \nelse if ( c == '\"' ) { \ninDoubleQuote = true ; \n} \nelse if ( c == ':' && length > i + 1 && Character . isJavaIdentifierStart ( sql . charAt ( i + 1 ) ) ) { \nint j = i + 2 ; \nwhile ( length > j && Character . isJavaIdentifierPart ( sql . charAt ( j ) ) ) { \nj ++ ; \n} \nString name = sql . substring ( i + 1 , j ) ; \nc = '?' ; \ni += name . length ( ) ; \nList < Integer > indexList = nameIndexMap . get ( name ) ; \nif ( indexList == null ) { \nindexList = new LinkedList < Integer > ( ) ; \nnameIndexMap . put ( name , indexList ) ; \n} \nindexList . add ( index ) ; \nindex ++ ; \n} \n} \nparsedSql . append ( c ) ; \n} \nreturn parsedSql . toString ( ) ; \n} \n} \n"}
{"10146": "public class FileExtensionFilter { \npublic boolean accept ( File pathname ) { \nString name = pathname . getName ( ) ; \nint iLastDot = name . lastIndexOf ( '.' ) ; \nString strExtension = \"\" ; \nif ( ( iLastDot != - 1 ) && ( iLastDot != name . length ( ) - 1 ) ) strExtension = name . substring ( iLastDot + 1 ) ; \nif ( m_rgstrIncludeExtensions != null ) { \nfor ( int i = 0 ; \nm_rgstrIncludeExtensions . length > i ; \ni ++ ) { \nif ( m_rgstrIncludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return true ; \n} \nreturn false ; \n} \nif ( m_rgstrExcludeExtensions != null ) { \nfor ( int i = 0 ; \nm_rgstrExcludeExtensions . length > i ; \ni ++ ) { \nif ( m_rgstrExcludeExtensions [ i ] . equalsIgnoreCase ( strExtension ) ) return false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10148": "public class StateParser { \nprivate static Map < ExpectedLabels , Integer > mapLabels ( final List < String > labels ) { \nfinal Map < ExpectedLabels , Integer > map = new EnumMap < > ( ExpectedLabels . class ) ; \nfinal List < ExpectedLabels > unusedLabels = new ArrayList < > ( Arrays . asList ( ExpectedLabels . values ( ) ) ) ; \nfor ( int index = 0 ; \nlabels . size ( ) > index ; \nindex ++ ) { \nfinal String next = labels . get ( index ) ; \nExpectedLabels labelValue ; \ntry { \nlabelValue = ExpectedLabels . valueOf ( next ) ; \nunusedLabels . remove ( labelValue ) ; \nif ( map . containsKey ( labelValue ) ) { \nLOGGER . warn ( \"Duplicate state label: {} ({})\" , next , labels ) ; \n} \nmap . put ( labelValue , index ) ; \n} \ncatch ( final IllegalArgumentException e ) { \nLOGGER . warn ( \"Unexpected state label: {}\" , next ) ; \n} \n} \nfor ( final ExpectedLabels label : unusedLabels ) { \nLOGGER . warn ( \"Unused label: {}\" , label ) ; \n} \nreturn map ; \n} \n} \n"}
{"10154": "public class ClassUtil { \npublic static Method [ ] getDeclaredMethods ( Class < ? > clazz , boolean recursively ) { \nList < Method > methods = new LinkedList < Method > ( ) ; \nMethod [ ] declaredMethods = clazz . getDeclaredMethods ( ) ; \nCollections . addAll ( methods , declaredMethods ) ; \nClass < ? > superClass = clazz . getSuperclass ( ) ; \nif ( superClass != null && recursively ) { \nMethod [ ] declaredMethodsOfSuper = getDeclaredMethods ( superClass , true ) ; \nif ( 0 < declaredMethodsOfSuper . length ) Collections . addAll ( methods , declaredMethodsOfSuper ) ; \n} \nreturn methods . toArray ( new Method [ methods . size ( ) ] ) ; \n} \n} \n"}
{"10158": "public class DebugOutputStream { \nprotected void dumpByte ( int b ) { \nif ( passThrough == true ) { \nSystem . out . print ( '\\t' ) ; \n} \nif ( 0 > b ) { \nb += 128 ; \n} \nif ( 0x10 > b ) { \nSystem . out . print ( '0' ) ; \n} \nSystem . out . print ( ' ' ) ; \nSystem . out . print ( Integer . toHexString ( b ) . toUpperCase ( ) ) ; \n} \n} \n"}
{"10159": "public class StringUtils { \npublic static int indexOfIgnoreCase ( String s , String substr , int startIndex , int endIndex ) { \nif ( 0 > startIndex ) { \nstartIndex = 0 ; \n} \nint srclen = s . length ( ) ; \nif ( srclen < endIndex ) { \nendIndex = srclen ; \n} \nint sublen = substr . length ( ) ; \nif ( sublen == 0 ) { \nreturn srclen < startIndex ? srclen : startIndex ; \n} \nsubstr = substr . toLowerCase ( ) ; \nint total = endIndex - sublen + 1 ; \nchar c = substr . charAt ( 0 ) ; \nmainloop : for ( int i = startIndex ; \ntotal > i ; \ni ++ ) { \nif ( Character . toLowerCase ( s . charAt ( i ) ) != c ) { \ncontinue ; \n} \nint j = 1 ; \nint k = i + 1 ; \nwhile ( sublen > j ) { \nchar source = Character . toLowerCase ( s . charAt ( k ) ) ; \nif ( substr . charAt ( j ) != source ) { \ncontinue mainloop ; \n} \nj ++ ; \nk ++ ; \n} \nreturn i ; \n} \nreturn - 1 ; \n} \n} \n"}
{"10160": "public class StringUtils { \npublic static String removeChars ( String s , String chars ) { \nint i = s . length ( ) ; \nStringBuilder sb = new StringBuilder ( i ) ; \nfor ( int j = 0 ; \ni > j ; \nj ++ ) { \nchar c = s . charAt ( j ) ; \nif ( chars . indexOf ( c ) == - 1 ) { \nsb . append ( c ) ; \n} \n} \nreturn sb . toString ( ) ; \n} \n} \n"}
{"10169": "public class ArrayStack { \npublic void clear ( ) { \nint i = size ; \nObject [ ] els = elements ; \nwhile ( 0 < i -- ) { \nels [ i ] = null ; \n} \nthis . size = 0 ; \n} \n} \n"}
{"10170": "public class ArrayStack { \npublic T push ( T element ) { \nint i ; \nObject [ ] els ; \nif ( ( els = elements ) . length <= ( i = size ++ ) ) { \nSystem . arraycopy ( els , 0 , els = elements = new Object [ i << 1 ] , 0 , i ) ; \n} \nels [ i ] = element ; \nreturn element ; \n} \n} \n"}
{"10171": "public class ArrayStack { \n@ SuppressWarnings ( \"unchecked\" ) public T pop ( ) throws EmptyStackException { \nint i ; \nif ( 0 <= ( i = -- size ) ) { \nT element = ( T ) elements [ i ] ; \nelements [ i ] = null ; \nreturn element ; \n} \nelse { \nsize = 0 ; \nthrow new EmptyStackException ( ) ; \n} \n} \n} \n"}
{"10173": "public class AppUtilities { \npublic static Properties parseArgs ( Properties properties , String [ ] args ) { \nif ( properties == null ) properties = new Properties ( ) ; \nif ( args == null ) return properties ; \nfor ( int i = 0 ; \nargs . length > i ; \ni ++ ) AppUtilities . addParam ( properties , args [ i ] , false ) ; \nreturn properties ; \n} \n} \n"}
{"10174": "public class WildcharPathUtils { \nprotected static boolean matchTokens ( String [ ] tokens , String [ ] patterns ) { \nint patNdxStart = 0 ; \nint patNdxEnd = patterns . length - 1 ; \nint tokNdxStart = 0 ; \nint tokNdxEnd = tokens . length - 1 ; \nwhile ( patNdxEnd >= patNdxStart && tokNdxEnd >= tokNdxStart ) { \nString patDir = patterns [ patNdxStart ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxStart ] , patDir ) ) { \nreturn false ; \n} \npatNdxStart ++ ; \ntokNdxStart ++ ; \n} \nif ( tokNdxEnd < tokNdxStart ) { \nfor ( int i = patNdxStart ; \npatNdxEnd >= i ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nif ( patNdxEnd < patNdxStart ) { \nreturn false ; \n} \nwhile ( patNdxEnd >= patNdxStart && tokNdxEnd >= tokNdxStart ) { \nString patDir = patterns [ patNdxEnd ] ; \nif ( patDir . equals ( PATH_MATCH ) ) { \nbreak ; \n} \nif ( ! WildcharUtils . match ( tokens [ tokNdxEnd ] , patDir ) ) { \nreturn false ; \n} \npatNdxEnd -- ; \ntokNdxEnd -- ; \n} \nif ( tokNdxEnd < tokNdxStart ) { \nfor ( int i = patNdxStart ; \npatNdxEnd >= i ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nwhile ( ( patNdxStart != patNdxEnd ) && ( tokNdxEnd >= tokNdxStart ) ) { \nint patIdxTmp = - 1 ; \nfor ( int i = patNdxStart + 1 ; \npatNdxEnd >= i ; \ni ++ ) { \nif ( patterns [ i ] . equals ( PATH_MATCH ) ) { \npatIdxTmp = i ; \nbreak ; \n} \n} \nif ( patIdxTmp == patNdxStart + 1 ) { \npatNdxStart ++ ; \ncontinue ; \n} \nint patLength = ( patIdxTmp - patNdxStart - 1 ) ; \nint strLength = ( tokNdxEnd - tokNdxStart + 1 ) ; \nint ndx = - 1 ; \nstrLoop : for ( int i = 0 ; \nstrLength - patLength >= i ; \ni ++ ) { \nfor ( int j = 0 ; \npatLength > j ; \nj ++ ) { \nString subPat = patterns [ patNdxStart + j + 1 ] ; \nString subStr = tokens [ tokNdxStart + i + j ] ; \nif ( ! WildcharUtils . match ( subStr , subPat ) ) { \ncontinue strLoop ; \n} \n} \nndx = tokNdxStart + i ; \nbreak ; \n} \nif ( ndx == - 1 ) { \nreturn false ; \n} \npatNdxStart = patIdxTmp ; \ntokNdxStart = ndx + patLength ; \n} \nfor ( int i = patNdxStart ; \npatNdxEnd >= i ; \ni ++ ) { \nif ( ! patterns [ i ] . equals ( PATH_MATCH ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10176": "public class Rectangular { \npublic boolean encloses ( Rectangular other ) { \nreturn other . x1 >= x1 && other . y1 >= y1 && other . x2 <= x2 && other . y2 <= y2 ; \n} \n} \n"}
{"10177": "public class Rectangular { \npublic boolean contains ( int x , int y ) { \nreturn x >= x1 && y >= y1 && x <= x2 && y <= y2 ; \n} \n} \n"}
{"10182": "public class AreaGrid { \npublic int getColOfs ( int col ) throws ArrayIndexOutOfBoundsException { \nif ( width > col ) { \nint ofs = 0 ; \nfor ( int i = 0 ; \ncol > i ; \ni ++ ) ofs += cols [ i ] ; \nreturn ofs ; \n} \nelse if ( col == width ) return abspos . getWidth ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( col + \">\" + width ) ; \n} \n} \n"}
{"10183": "public class AreaGrid { \npublic int getRowOfs ( int row ) throws ArrayIndexOutOfBoundsException { \nif ( height > row ) { \nint ofs = 0 ; \nfor ( int i = 0 ; \nrow > i ; \ni ++ ) ofs += rows [ i ] ; \nreturn ofs ; \n} \nelse if ( row == height ) return abspos . getHeight ( ) ; \nelse throw new ArrayIndexOutOfBoundsException ( row + \">\" + height ) ; \n} \n} \n"}
{"10185": "public class AreaGrid { \nprivate void calculateColumns ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getX1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getX2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \npoints . length > i ; \ni ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cnt ++ ; \nwidth = cnt ; \nmaxindent = 0 ; \nminindent = - 1 ; \ncols = new int [ width ] ; \ncnt = 0 ; \nlast = abspos . getX1 ( ) ; \nfor ( int i = 0 ; \npoints . length > i ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \ncols [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setX1 ( cnt ) ; \nmaxindent = cnt ; \nif ( minindent == - 1 ) minindent = maxindent ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setX2 ( cnt - 1 ) ; \nif ( pos . getX1 ( ) > pos . getX2 ( ) ) pos . setX2 ( pos . getX1 ( ) ) ; \n} \n} \nif ( ! theSame ( last , abspos . getX2 ( ) ) ) cols [ cnt ] = abspos . getX2 ( ) - last ; \nif ( minindent == - 1 ) minindent = 0 ; \n} \n} \n"}
{"10186": "public class AreaGrid { \nprivate void calculateRows ( ) { \nGridPoint points [ ] = new GridPoint [ areas . size ( ) * 2 ] ; \nint pi = 0 ; \nfor ( Area area : areas ) { \npoints [ pi ] = new GridPoint ( area . getY1 ( ) , area , true ) ; \npoints [ pi + 1 ] = new GridPoint ( area . getY2 ( ) + 1 , area , false ) ; \npi += 2 ; \n} \nArrays . sort ( points ) ; \nint cnt = 0 ; \nint last = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \npoints . length > i ; \ni ++ ) if ( ! theSame ( points [ i ] . value , last ) ) { \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) cnt ++ ; \nheight = cnt ; \nrows = new int [ height ] ; \ncnt = 0 ; \nlast = abspos . getY1 ( ) ; \nfor ( int i = 0 ; \npoints . length > i ; \ni ++ ) { \nif ( ! theSame ( points [ i ] . value , last ) ) { \nrows [ cnt ] = points [ i ] . value - last ; \nlast = points [ i ] . value ; \ncnt ++ ; \n} \nif ( points [ i ] . begin ) { \ntarget . getPosition ( points [ i ] . area ) . setY1 ( cnt ) ; \n} \nelse { \nRectangular pos = target . getPosition ( points [ i ] . area ) ; \npos . setY2 ( cnt - 1 ) ; \nif ( pos . getY1 ( ) > pos . getY2 ( ) ) pos . setY2 ( pos . getY1 ( ) ) ; \n} \n} \nif ( ! theSame ( last , abspos . getY2 ( ) ) ) rows [ cnt ] = abspos . getY2 ( ) - last ; \n} \n} \n"}
{"10190": "public class ByteCodeMonitor { \nprivate void copyAndResizeCodeBuffer ( ByteBuffer codeBuffer , int start , int length ) { \nint max = start + length ; \nif ( max >= this . codeBuffer . limit ( ) ) { \nByteBuffer newCodeBuffer = ByteBuffer . allocate ( max * 2 ) ; \nnewCodeBuffer . put ( this . codeBuffer . array ( ) , 0 , this . codeBuffer . limit ( ) ) ; \nlog . fine ( \"Re-sized code buffer to \" + ( max * 2 ) ) ; \n} \ncodeBuffer . position ( start ) ; \ncodeBuffer . get ( this . codeBuffer . array ( ) , start , length ) ; \n} \n} \n"}
{"10191": "public class ByteCodeMonitor { \nprivate void renderInstructions ( Iterable < WAMInstruction > instructions , int row , int address ) { \nfor ( WAMInstruction instruction : instructions ) { \nWAMLabel label = instruction . getLabel ( ) ; \nlabeledTable . put ( ADDRESS , row , String . format ( \"%08X\" , address ) ) ; \nlabeledTable . put ( LABEL , row , ( label == null ) ? \"\" : ( label . toPrettyString ( ) + \":\" ) ) ; \nlabeledTable . put ( MNEMONIC , row , instruction . getMnemonic ( ) . getPretty ( ) ) ; \nint fieldMask = instruction . getMnemonic ( ) . getFieldMask ( ) ; \nString arg = \"\" ; \nfor ( int i = 2 ; \n32 > i ; \ni = i * 2 ) { \nif ( ( fieldMask & i ) != 0 ) { \nif ( ! \"\" . equals ( arg ) ) { \narg += \", \" ; \n} \nswitch ( i ) { \ncase 2 : arg += Integer . toString ( instruction . getReg1 ( ) ) ; \nbreak ; \ncase 4 : arg += Integer . toString ( instruction . getReg2 ( ) ) ; \nbreak ; \ncase 8 : FunctorName fn = instruction . getFn ( ) ; \nif ( fn != null ) { \narg += fn . getName ( ) + \"/\" + fn . getArity ( ) ; \n} \nbreak ; \ncase 16 : WAMLabel target1 = instruction . getTarget1 ( ) ; \nif ( target1 != null ) { \narg += target1 . getName ( ) + \"/\" + target1 . getArity ( ) + \"_\" + target1 . getId ( ) ; \n} \nbreak ; \n} \n} \n} \nlabeledTable . put ( ARG_1 , row , arg ) ; \nrow ++ ; \naddress += instruction . sizeof ( ) ; \n} \n} \n} \n"}
{"10205": "public class LexicographicalCollectionComparator { \npublic int compare ( Collection < T > c1 , Collection < T > c2 ) { \nIterator < T > i1 = c1 . iterator ( ) ; \nIterator < T > i2 = c2 . iterator ( ) ; \nwhile ( i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nT t1 = i1 . next ( ) ; \nT t2 = i2 . next ( ) ; \nint comp = comparator . compare ( t1 , t2 ) ; \nif ( 0 > comp ) { \nreturn - 1 ; \n} \nelse if ( 0 < comp ) { \nreturn 1 ; \n} \n} \nif ( ! i1 . hasNext ( ) && i2 . hasNext ( ) ) { \nreturn - 1 ; \n} \nif ( i1 . hasNext ( ) && ! i2 . hasNext ( ) ) { \nreturn 1 ; \n} \nreturn 0 ; \n} \n} \n"}
{"10207": "public class PageControlTag { \npublic int doStartTag ( ) throws JspException { \nlog . fine ( \"public int doStartTag(): called\" ) ; \nTagUtils tagUtils = TagUtils . getInstance ( ) ; \nPagedList list = ( PagedList ) tagUtils . lookup ( pageContext , name , property , scope ) ; \nlog . fine ( \"list = \" + list ) ; \nString url ; \ntry { \nurl = tagUtils . computeURL ( pageContext , null , null , null , action , null , null , null , false ) ; \n} \ncatch ( MalformedURLException e ) { \nthrow new JspException ( \"Got malformed URL exception: \" , e ) ; \n} \nrenderButton ( renderFirst , 0 , 0 , openDelimFirst , url , firstText , list . getCurrentPage ( ) != 0 ) ; \nrenderButton ( renderBack , list . getCurrentPage ( ) - 1 , ( list . getCurrentIndex ( ) > ( list . getCurrentPage ( ) - 1 ) ) ? ( list . getCurrentIndex ( ) - maxPages ) : list . getCurrentIndex ( ) , openDelimBack , url , backText , 0 <= ( list . getCurrentPage ( ) - 1 ) ) ; \nint from = list . getCurrentIndex ( ) ; \nint to = list . getCurrentIndex ( ) + maxPages ; \nfor ( int i = from ; \n( list . size ( ) > i ) && ( to > i ) ; \ni ++ ) { \nrenderButton ( true , i , list . getCurrentIndex ( ) , ( i == list . getCurrentPage ( ) ) ? openDelimCurrent : openDelimNumber , url , \"\" + ( i + 1 ) , i != list . getCurrentPage ( ) ) ; \n} \nrenderButton ( list . size ( ) > ( list . getCurrentIndex ( ) + maxPages ) , list . getCurrentPage ( ) + maxPages , list . getCurrentPage ( ) + maxPages , openDelimMore , url , moreText , true ) ; \nrenderButton ( renderForward , list . getCurrentPage ( ) + 1 , ( ( list . getCurrentIndex ( ) + maxPages ) <= ( list . getCurrentPage ( ) + 1 ) ) ? ( list . getCurrentIndex ( ) + maxPages ) : list . getCurrentIndex ( ) , openDelimForward , url , forwardText , list . size ( ) > ( list . getCurrentPage ( ) + 1 ) ) ; \nrenderButton ( renderLast , list . size ( ) - 1 , ( list . size ( ) / maxPages ) * maxPages , openDelimLast , url , lastText , list . getCurrentPage ( ) != ( list . size ( ) - 1 ) ) ; \nreturn SKIP_BODY ; \n} \n} \n"}
{"10213": "public class HashArray { \npublic V set ( int index , V value ) throws IndexOutOfBoundsException { \nif ( data . size ( ) <= index ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nreturn data . set ( index , value ) ; \n} \n} \n"}
{"10214": "public class HashArray { \npublic V remove ( Object key ) { \nInteger index = keyToIndex . get ( key ) ; \nif ( index == null ) { \nreturn null ; \n} \nkeyToIndex . remove ( key ) ; \nkeySet . remove ( key ) ; \nV removedValue = data . remove ( index . intValue ( ) ) ; \nfor ( K nextKey : keyToIndex . keySet ( ) ) { \nInteger nextIndex = keyToIndex . get ( nextKey ) ; \nif ( index < nextIndex ) { \nkeyToIndex . put ( nextKey , nextIndex - 1 ) ; \n} \n} \nreturn removedValue ; \n} \n} \n"}
{"10215": "public class HashArray { \npublic V remove ( int index ) throws IndexOutOfBoundsException { \nif ( data . size ( ) <= index ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nfor ( K nextKey : keyToIndex . keySet ( ) ) { \nint nextIndex = keyToIndex . get ( nextKey ) ; \nif ( index == nextIndex ) { \nreturn remove ( nextKey ) ; \n} \n} \nthrow new IndexOutOfBoundsException ( ) ; \n} \n} \n"}
{"10220": "public class PropertyIntrospectorBase { \nprivate void initialize ( Object callee ) { \nMap < String , List < Method > > settersTemp = new HashMap < String , List < Method > > ( ) ; \nMethod [ ] methods = callee . getClass ( ) . getMethods ( ) ; \nfor ( Method nextMethod : methods ) { \nString methodName = nextMethod . getName ( ) ; \nif ( methodName . startsWith ( \"get\" ) && ( 4 <= methodName . length ( ) ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 0 ) ) { \nString propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; \ngetters . put ( propertyName , nextMethod ) ; \n} \nelse if ( methodName . startsWith ( \"set\" ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 1 ) ) { \nString propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; \nList < Method > setterMethodsForName = settersTemp . get ( propertyName ) ; \nif ( setterMethodsForName == null ) { \nsetterMethodsForName = new ArrayList < Method > ( ) ; \nsettersTemp . put ( propertyName , setterMethodsForName ) ; \n} \nsetterMethodsForName . add ( nextMethod ) ; \n} \n} \nfor ( Map . Entry < String , List < Method > > entries : settersTemp . entrySet ( ) ) { \nString nextPropertyName = entries . getKey ( ) ; \nList < Method > nextMethodList = entries . getValue ( ) ; \nMethod [ ] methodArray = nextMethodList . toArray ( new Method [ nextMethodList . size ( ) ] ) ; \nsetters . put ( nextPropertyName , methodArray ) ; \n} \ninitialized = true ; \n} \n} \n"}
{"10224": "public class PrologUnifier { \npublic boolean unifyInternal ( Term left , Term right , List < Variable > leftTrail , List < Variable > rightTrail ) { \nif ( left == right ) { \nreturn true ; \n} \nif ( ! left . isVar ( ) && ! right . isVar ( ) && left . isConstant ( ) && right . isConstant ( ) && left . equals ( right ) ) { \nreturn true ; \n} \nelse if ( left . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) left , right , leftTrail , rightTrail ) ; \n} \nelse if ( right . isVar ( ) ) { \nreturn unifyVar ( ( Variable ) right , left , rightTrail , leftTrail ) ; \n} \nelse if ( left . isFunctor ( ) && right . isFunctor ( ) ) { \nFunctor leftFunctor = ( Functor ) left ; \nFunctor rightFunctor = ( Functor ) right ; \nif ( ! left . equals ( right ) ) { \nreturn false ; \n} \nint arity = leftFunctor . getArity ( ) ; \nfor ( int i = 0 ; \narity > i ; \ni ++ ) { \nTerm leftArgument = leftFunctor . getArgument ( i ) ; \nTerm rightArgument = rightFunctor . getArgument ( i ) ; \nboolean result = unifyInternal ( leftArgument , rightArgument , leftTrail , rightTrail ) ; \nif ( ! result ) { \nreturn false ; \n} \n} \nreturn true ; \n} \nelse { \nreturn false ; \n} \n} \n} \n"}
{"10226": "public class InstructionCompiler { \nprivate void compileQuery ( Clause clause ) throws SourceCodeException { \nWAMCompiledQuery result ; \nMap < Byte , Integer > varNames = new TreeMap < Byte , Integer > ( ) ; \nseenRegisters = new TreeSet < Integer > ( ) ; \nlastAllocatedTempReg = findMaxArgumentsInClause ( clause ) ; \nnumPermanentVars = 0 ; \ncutLevelVarSlot = - 1 ; \nSizeableList < WAMInstruction > preFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSizeableList < WAMInstruction > postFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; \nSet < Variable > freeVars = TermUtils . findFreeNonAnonymousVariables ( clause ) ; \nSet < Integer > freeVarNames = new TreeSet < Integer > ( ) ; \nfor ( Variable var : freeVars ) { \nfreeVarNames . add ( var . getName ( ) ) ; \n} \nallocatePermanentQueryRegisters ( clause , varNames ) ; \ngatherPositionAndOccurrenceInfo ( clause ) ; \nresult = new WAMCompiledQuery ( varNames , freeVarNames ) ; \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . AllocateN , REG_ADDR , ( byte ) ( numPermanentVars & 0xff ) ) ) ; \nif ( 0 <= cutLevelVarSlot ) { \npreFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . GetLevel , STACK_ADDR , ( byte ) cutLevelVarSlot ) ) ; \n} \nresult . addInstructions ( preFixInstructions ) ; \nFunctor [ ] expressions = clause . getBody ( ) ; \nFunctorName fn = new FunctorName ( \"tq\" , 0 ) ; \nfor ( int i = 0 ; \nexpressions . length > i ; \ni ++ ) { \nFunctor expression = expressions [ i ] ; \nboolean isFirstBody = i == 0 ; \nBuiltIn builtIn ; \nif ( expression instanceof BuiltIn ) { \nbuiltIn = ( BuiltIn ) expression ; \n} \nelse { \nbuiltIn = this ; \n} \nSizeableLinkedList < WAMInstruction > instructions = builtIn . compileBodyArguments ( expression , false , fn , i ) ; \nresult . addInstructions ( expression , instructions ) ; \ninstructions = builtIn . compileBodyCall ( expression , isFirstBody , false , false , numPermanentVars ) ; \nresult . addInstructions ( expression , instructions ) ; \n} \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Suspend ) ) ; \npostFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Deallocate ) ) ; \nresult . addInstructions ( postFixInstructions ) ; \nresult = optimizer . apply ( result ) ; \ndisplayCompiledQuery ( result ) ; \nobserver . onQueryCompilation ( result ) ; \n} \n} \n"}
{"10227": "public class InstructionCompiler { \nprivate int findMaxArgumentsInClause ( Clause clause ) { \nint result = 0 ; \nFunctor head = clause . getHead ( ) ; \nif ( head != null ) { \nresult = head . getArity ( ) ; \n} \nFunctor [ ] body = clause . getBody ( ) ; \nif ( body != null ) { \nfor ( int i = 0 ; \nbody . length > i ; \ni ++ ) { \nint arity = body [ i ] . getArity ( ) ; \nresult = ( result < arity ) ? arity : result ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10232": "public class ByteBufferUtils { \npublic static ByteBuffer putPaddedInt32AsString ( ByteBuffer buffer , int value , int length ) { \nint charsRequired = BitHackUtils . getCharacterCountInt32 ( value ) ; \nlength = ( length > charsRequired ) ? length : charsRequired ; \nint index = buffer . position ( ) + length - 1 ; \nint start = buffer . position ( ) ; \nbuffer . position ( buffer . position ( ) + length ) ; \nif ( 0 > value ) { \nbuffer . put ( MINUS_ASCII ) ; \nstart ++ ; \n} \nelse { \nvalue = - value ; \n} \ndo { \nint remainder = value % 10 ; \nvalue = value / 10 ; \nbuffer . put ( index -- , ( ( byte ) ( ZERO_ASCII - remainder ) ) ) ; \n} \nwhile ( value != 0 ) ; \nwhile ( start <= index ) { \nbuffer . put ( index -- , ZERO_ASCII ) ; \n} \nreturn buffer ; \n} \n} \n"}
{"10233": "public class ByteBufferUtils { \npublic static String asString ( ByteBuffer buffer , int length ) { \nchar [ ] chars = new char [ length ] ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) { \nchars [ i ] = ( char ) buffer . get ( i ) ; \n} \nreturn String . valueOf ( chars ) ; \n} \n} \n"}
{"10245": "public class ReflectionUtils { \npublic static Object callMethod ( Object o , String method , Object [ ] params ) { \nClass cls = o . getClass ( ) ; \nClass [ ] paramClasses = new Class [ params . length ] ; \nfor ( int i = 0 ; \nparams . length > i ; \ni ++ ) { \nparamClasses [ i ] = params [ i ] . getClass ( ) ; \n} \ntry { \nMethod m = cls . getMethod ( method , paramClasses ) ; \nreturn m . invoke ( o , params ) ; \n} \ncatch ( NoSuchMethodException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n"}
{"10254": "public class IntRangeType { \npublic static Type createInstance ( String name , int min , int max ) { \nif ( max < min ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( INT_RANGE_TYPES ) { \nIntRangeType newType = new IntRangeType ( name , min , max ) ; \nIntRangeType oldType = INT_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nINT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10260": "public class GreedyComparator { \npublic int compare ( SearchNode object1 , SearchNode object2 ) { \nfloat h1 = ( ( HeuristicSearchNode ) object1 ) . getH ( ) ; \nfloat h2 = ( ( HeuristicSearchNode ) object2 ) . getH ( ) ; \nreturn ( h2 < h1 ) ? 1 : ( ( h2 > h1 ) ? - 1 : 0 ) ; \n} \n} \n"}
{"10264": "public class TraceIndenter { \npublic String generateTraceIndent ( int delta ) { \nif ( ! useIndent ) { \nreturn \"\" ; \n} \nelse { \nif ( 1 <= delta ) { \nindentStack . push ( delta ) ; \n} \nelse if ( 0 > delta ) { \nindentStack . pop ( ) ; \n} \nStringBuffer result = new StringBuffer ( ) ; \ntraceIndent += ( 0 > delta ) ? delta : 0 ; \nfor ( int i = 0 ; \ntraceIndent > i ; \ni ++ ) { \nresult . append ( \" \" ) ; \n} \ntraceIndent += ( 0 < delta ) ? delta : 0 ; \nreturn result . toString ( ) ; \n} \n} \n} \n"}
{"10265": "public class DefaultBuiltIn { \nprotected void allocateArgumentRegisters ( Functor expression ) { \nint reg = 0 ; \nfor ( ; \nexpression . getArity ( ) > reg ; \nreg ++ ) { \nTerm term = expression . getArgument ( reg ) ; \nif ( term instanceof Functor ) { \nint allocation = ( reg & 0xff ) | ( REG_ADDR << 8 ) ; \nsymbolTable . put ( term . getSymbolKey ( ) , SymbolTableKeys . SYMKEY_ALLOCATION , allocation ) ; \n} \n} \n} \n} \n"}
{"10267": "public class ProtoDTLearningMethod { \nprivate OrdinalAttribute getMajorityClassification ( String property , Iterable < State > examples ) throws LearningFailureException { \nMap < OrdinalAttribute , Integer > countMap = null ; \nint biggestCount = 0 ; \nOrdinalAttribute biggestAttribute = null ; \nfor ( State example : examples ) { \nOrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; \nif ( countMap == null ) { \ncountMap = new HashMap < OrdinalAttribute , Integer > ( ) ; \n} \nint count ; \nif ( ! countMap . containsKey ( nextAttribute ) ) { \ncount = 1 ; \ncountMap . put ( nextAttribute , count ) ; \n} \nelse { \ncount = countMap . get ( nextAttribute ) ; \ncountMap . put ( nextAttribute , count ++ ) ; \n} \nif ( biggestCount < count ) { \nbiggestCount = count ; \nbiggestAttribute = nextAttribute ; \n} \n} \nreturn biggestAttribute ; \n} \n} \n"}
{"10269": "public class ProtoDTLearningMethod { \nprivate String chooseBestPropertyToDecideOn ( String outputProperty , Iterable < State > examples , Iterable < String > inputProperties ) { \nint numOutputValues = examples . iterator ( ) . next ( ) . getComponentType ( ) . getPropertyType ( outputProperty ) . getNumPossibleValues ( ) ; \ndouble largestGain = 0.0d ; \nString largestGainProperty = null ; \nfor ( String inputProperty : inputProperties ) { \nint numInputValues = examples . iterator ( ) . next ( ) . getComponentType ( ) . getPropertyType ( inputProperty ) . getNumPossibleValues ( ) ; \nint [ ] outputCounts = new int [ numOutputValues ] ; \nint [ ] inputCounts = new int [ numInputValues ] ; \nint [ ] [ ] jointCounts = new int [ numInputValues ] [ numOutputValues ] ; \nfor ( State example : examples ) { \nOrdinalAttribute outputAttribute = ( OrdinalAttribute ) example . getProperty ( outputProperty ) ; \nOrdinalAttribute inputAttribute = ( OrdinalAttribute ) example . getProperty ( inputProperty ) ; \noutputCounts [ outputAttribute . ordinal ( ) ] ++ ; \ninputCounts [ inputAttribute . ordinal ( ) ] ++ ; \njointCounts [ inputAttribute . ordinal ( ) ] [ outputAttribute . ordinal ( ) ] ++ ; \n} \ndouble [ ] pForG = InformationTheory . pForDistribution ( outputCounts ) ; \ndouble [ ] pForA = InformationTheory . pForDistribution ( inputCounts ) ; \ndouble [ ] [ ] pForGGivenA = InformationTheory . pForJointDistribution ( jointCounts ) ; \ndouble gain = InformationTheory . gain ( pForG , pForA , pForGGivenA ) ; \nif ( largestGain < gain ) { \nlargestGain = gain ; \nlargestGainProperty = inputProperty ; \n} \n} \nreturn largestGainProperty ; \n} \n} \n"}
{"10273": "public class PagedList { \npublic List < E > get ( int index ) { \nint originalSize = original . size ( ) ; \nint size = ( originalSize / pageSize ) + ( ( ( originalSize % pageSize ) == 0 ) ? 0 : 1 ) ; \nif ( ( index == 0 ) && ( originalSize == 0 ) ) { \nreturn new ArrayList < E > ( ) ; \n} \nif ( ( size <= index ) || ( 0 > index ) ) { \nthrow new IndexOutOfBoundsException ( \"Index \" + index + \" is less than zero or more than the number of pages: \" + size ) ; \n} \nList < E > result = original . subList ( pageSize * index , ( originalSize <= ( pageSize * ( index + 1 ) ) ) ? originalSize : ( pageSize * ( index + 1 ) ) ) ; \nreturn result ; \n} \n} \n"}
{"10276": "public class Surface { \nprotected BufferedImage createBufferedImage ( int w , int h , int imgType ) { \nBufferedImage bi = null ; \nif ( imgType == 0 ) { \nbi = ( BufferedImage ) createImage ( w , h ) ; \n} \nelse if ( ( 0 < imgType ) && ( 14 > imgType ) ) { \nbi = new BufferedImage ( w , h , imgType ) ; \n} \nelse if ( imgType == 14 ) { \nbi = createBinaryImage ( w , h , 2 ) ; \n} \nelse if ( imgType == 15 ) { \nbi = createBinaryImage ( w , h , 4 ) ; \n} \nelse if ( imgType == 16 ) { \nbi = createSGISurface ( w , h , 32 ) ; \n} \nelse if ( imgType == 17 ) { \nbi = createSGISurface ( w , h , 16 ) ; \n} \nbiw = w ; \nbih = h ; \nreturn bi ; \n} \n} \n"}
{"10282": "public class MaxStepsAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nQueue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; \nUnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; \nwhile ( ! queue . isEmpty ( ) ) { \nSearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; \nif ( ! headNode . isExpanded ( ) ) { \nheadNode . expandSuccessors ( queue , reverseEnqueue ) ; \n} \nSearchNode < O , T > currentNode = peekAtHead ? queue . peek ( ) : headNode ; \nif ( currentNode . isExpanded ( ) ) { \ncurrentNode = peekAtHead ? queue . remove ( ) : headNode ; \nif ( goalPredicate . evaluate ( currentNode . getState ( ) ) ) { \nreturn currentNode ; \n} \n} \nif ( 0 < maxSteps ) { \nsearchSteps ++ ; \ninitSearch . setStepsTaken ( searchSteps ) ; \nif ( maxSteps <= searchSteps ) { \nif ( queue . isEmpty ( ) ) { \nreturn null ; \n} \nelse { \nthrow new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; \n} \n} \n} \n} \nreturn null ; \n} \n} \n"}
{"10287": "public class PrologParser { \npublic Term listFunctor ( ) throws SourceCodeException { \nint nilId = interner . internFunctorName ( \"nil\" , 0 ) ; \nint consId = interner . internFunctorName ( \"cons\" , 2 ) ; \nToken leftDelim = consumeToken ( LSQPAREN ) ; \nTerm [ ] args = null ; \nToken nextToken = tokenSource . peek ( ) ; \nswitch ( nextToken . kind ) { \ncase LPAREN : case LSQPAREN : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case STRING_LITERAL : case VAR : case FUNCTOR : case ATOM : args = arglist ( ) ; \nbreak ; \ndefault : } \nTerm accumulator ; \nif ( tokenSource . peek ( ) . kind == CONS ) { \nif ( args == null ) { \nthrow new SourceCodeException ( \"Was expecting one of \" + BEGIN_TERM_TOKENS + \" but got \" + tokenImage [ nextToken . kind ] + \".\" , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; \n} \nconsumeToken ( CONS ) ; \naccumulator = term ( ) ; \n} \nelse { \naccumulator = new Nil ( nilId , null ) ; \n} \nToken rightDelim = consumeToken ( RSQPAREN ) ; \nif ( args != null ) { \nfor ( int i = args . length - 1 ; \n0 <= i ; \ni -- ) { \nTerm previousAccumulator = accumulator ; \naccumulator = new Cons ( consId , new Term [ ] { \nargs [ i ] , previousAccumulator } \n) ; \n} \n} \nSourceCodePosition position = new SourceCodePositionImpl ( leftDelim . beginLine , leftDelim . beginColumn , rightDelim . endLine , rightDelim . endColumn ) ; \naccumulator . setSourceCodePosition ( position ) ; \nreturn ( Functor ) accumulator ; \n} \n} \n"}
{"10303": "public class TimeUtils { \npublic static int ticksToYears ( long ticks ) { \nlong unitMillis = MILLIS_PER_YEAR / 2 ; \nlong i2 = ( ticks >> 1 ) + ( ( 1970L * MILLIS_PER_YEAR ) / 2 ) ; \nif ( 0 > i2 ) { \ni2 = i2 - unitMillis + 1 ; \n} \nint year = ( int ) ( i2 / unitMillis ) ; \nlong yearStart = millisToYearStart ( year ) ; \nlong diff = ticks - yearStart ; \nif ( 0 > diff ) { \nyear -- ; \n} \nelse if ( ( MILLIS_PER_DAY * 365L ) <= diff ) { \nlong oneYear ; \nif ( isLeapYear ( year ) ) { \noneYear = MILLIS_PER_DAY * 366L ; \n} \nelse { \noneYear = MILLIS_PER_DAY * 365L ; \n} \nyearStart += oneYear ; \nif ( ticks >= yearStart ) { \nyear ++ ; \n} \n} \nreturn year ; \n} \n} \n"}
{"10310": "public class TimeUtils { \npublic static long millisToYearStart ( int year ) { \nint leapYears = year / 100 ; \nif ( 0 > year ) { \nleapYears = ( ( year + 3 ) >> 2 ) - leapYears + ( ( leapYears + 3 ) >> 2 ) - 1 ; \n} \nelse { \nleapYears = ( year >> 2 ) - leapYears + ( leapYears >> 2 ) ; \nif ( isLeapYear ( year ) ) { \nleapYears -- ; \n} \n} \nreturn ( ( year * 365L ) + leapYears - DAYS_TO_1970 ) * MILLIS_PER_DAY ; \n} \n} \n"}
{"10311": "public class TimeUtils { \nprivate static int getMonthOfYear ( long ticks , int year ) { \nint i = ( int ) ( ( ticks - millisToYearStart ( year ) ) >> 10 ) ; \nreturn ( isLeapYear ( year ) ) ? ( ( ( 182 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? ( ( ( 91 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? ( ( ( 31 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 1 : ( ( ( 60 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 2 : 3 ) ) : ( ( ( 121 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 4 : ( ( ( 152 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 5 : 6 ) ) ) : ( ( ( 274 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? ( ( ( 213 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 7 : ( ( ( 244 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 8 : 9 ) ) : ( ( ( 305 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 10 : ( ( ( 335 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 11 : 12 ) ) ) ) : ( ( ( 181 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? ( ( ( 90 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? ( ( ( 31 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 1 : ( ( ( 59 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 2 : 3 ) ) : ( ( ( 120 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 4 : ( ( ( 151 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 5 : 6 ) ) ) : ( ( ( 273 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? ( ( ( 212 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 7 : ( ( ( 243 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 8 : 9 ) ) : ( ( ( 304 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 10 : ( ( ( 334 * MILLIS_PER_DAY_OVER_1024 ) > i ) ? 11 : 12 ) ) ) ) ; \n} \n} \n"}
{"10315": "public class SequentialCuckooFunction { \nprivate Entry < K > cuckoo ( Entry < K > entry ) { \nEntry < K > currentEntry = entry ; \nint hash = entry . hash1 ; \nint index = indexFor ( hash ) ; \nEntry < K > nextEntry = hashTable [ index ] ; \nint previousFlag = 0 ; \nint [ ] previousIndex = new int [ 2 ] ; \nint [ ] previousSeq = new int [ 2 ] ; \nfor ( int i = 0 ; \nhashTableSize > i ; \ni ++ ) { \nif ( nextEntry == null ) { \nhashTable [ index ] = currentEntry ; \nreturn null ; \n} \nhashTable [ index ] = currentEntry ; \ncurrentEntry = nextEntry ; \nint firstPosition = indexFor ( currentEntry . hash1 ) ; \nhash = ( index == firstPosition ) ? currentEntry . hash2 : currentEntry . hash1 ; \nindex = indexFor ( hash ) ; \npreviousIndex [ previousFlag ] = index ; \npreviousSeq [ previousFlag ] = nextEntry . seq ; \npreviousFlag = ( previousFlag == 1 ) ? 0 : 1 ; \nnextEntry = hashTable [ index ] ; \nif ( ( nextEntry != null ) && ( index == previousIndex [ previousFlag ] ) && ( nextEntry . seq == previousSeq [ previousFlag ] ) ) { \nbreak ; \n} \n} \nreturn currentEntry ; \n} \n} \n"}
{"10316": "public class SequentialCuckooFunction { \nprivate void rehash ( ) { \nint newSize = hashTableSize ; \nif ( ( count * 2 ) > hashTableSize ) { \nnewSize = hashTableSize * 2 ; \nif ( maxSize < newSize ) { \nthrow new IllegalStateException ( \"'newSize' of \" + newSize + \" would put the table over the maximum size limit of \" + maxSize ) ; \n} \n} \nEntry < K > [ ] oldTable = hashTable ; \nhashTableSize = newSize ; \nlength = hashTable . length ; \nboolean rehashedOk ; \ndo { \nrehashedOk = true ; \nchangeHashFunctions ( ) ; \nhashTable = ( Entry < K > [ ] ) new Entry [ hashTableSize ] ; \nfor ( Entry < K > entry : oldTable ) { \nif ( entry != null ) { \nif ( applyWithEntry ( entry . key , entry , false ) == null ) { \nrehashedOk = false ; \nbreak ; \n} \n} \n} \n} \nwhile ( ! rehashedOk ) ; \n} \n} \n"}
{"10323": "public class InformationTheory { \npublic static double expectedI ( double [ ] probabilities ) { \ndouble result = 0.0d ; \nfor ( double p : probabilities ) { \nif ( 0.0d < p ) { \nresult -= p * Math . log ( p ) ; \n} \n} \nreturn result / LN2 ; \n} \n} \n"}
{"10324": "public class InformationTheory { \npublic static double [ ] pForDistribution ( int [ ] counts ) { \ndouble [ ] probabilities = new double [ counts . length ] ; \nint total = 0 ; \nfor ( int c : counts ) { \ntotal += c ; \n} \nfor ( int i = 0 ; \nprobabilities . length > i ; \ni ++ ) { \nif ( 0 < total ) { \nprobabilities [ i ] = ( ( double ) counts [ i ] ) / total ; \n} \nelse { \nprobabilities [ i ] = 0.0d ; \n} \n} \nreturn probabilities ; \n} \n} \n"}
{"10330": "public class DebugTag { \npublic String getCookies ( ) { \nMap info = new TreeMap ( ) ; \nHttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nCookie [ ] cookies = req . getCookies ( ) ; \nif ( cookies != null ) { \nfor ( int i = 0 ; \ncookies . length > i ; \ni ++ ) { \nCookie cooky = cookies [ i ] ; \ninfo . put ( cooky . getName ( ) , cooky . getValue ( ) ) ; \n} \n} \nreturn toHTMLTable ( \"cookies\" , info ) ; \n} \n} \n"}
{"10331": "public class DebugTag { \npublic String getParameters ( ) { \nMap info = new TreeMap ( ) ; \nServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; \nEnumeration names = req . getParameterNames ( ) ; \nwhile ( names . hasMoreElements ( ) ) { \nString name = ( String ) names . nextElement ( ) ; \nString [ ] values = req . getParameterValues ( name ) ; \nStringBuffer sb = new StringBuffer ( ) ; \nfor ( int i = 0 ; \nvalues . length > i ; \ni ++ ) { \nif ( i != 0 ) { \nsb . append ( \" | \" ) ; \n} \nsb . append ( values [ i ] ) ; \n} \ninfo . put ( name , sb . toString ( ) ) ; \n} \nreturn toHTMLTable ( \"request parameters\" , info ) ; \n} \n} \n"}
{"10339": "public class BoundedAlgorithm { \npublic SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { \nQueue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; \nUnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; \nboolean beyondFringe = false ; \nminBeyondBound = Float . POSITIVE_INFINITY ; \nwhile ( ! queue . isEmpty ( ) ) { \nSearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; \nQueue < SearchNode < O , T > > successors = new LinkedList < SearchNode < O , T > > ( ) ; \nheadNode . expandSuccessors ( successors , reverseEnqueue ) ; \nfor ( SearchNode < O , T > successor : successors ) { \nfloat boundProperty = boundPropertyExtractor . getBoundProperty ( successor ) ; \nif ( maxBound >= boundProperty ) { \nqueue . offer ( successor ) ; \n} \nelse { \nbeyondFringe = true ; \nminBeyondBound = ( minBeyondBound > boundProperty ) ? boundProperty : minBeyondBound ; \n} \n} \nSearchNode < O , T > currentNode = peekAtHead ? queue . remove ( ) : headNode ; \nif ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( currentNode . getState ( ) ) ) { \nreturn currentNode ; \n} \nif ( 0 < maxSteps ) { \nsearchSteps ++ ; \ninitSearch . setStepsTaken ( searchSteps ) ; \nif ( maxSteps <= searchSteps ) { \nif ( queue . isEmpty ( ) ) { \nreturn null ; \n} \nelse { \nthrow new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; \n} \n} \n} \n} \nif ( beyondFringe ) { \nthrow new MaxBoundException ( \"Max bound reached.\" , null ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"10342": "public class AStarComparator { \npublic int compare ( SearchNode object1 , SearchNode object2 ) { \nfloat f1 = ( ( HeuristicSearchNode ) object1 ) . getF ( ) ; \nfloat f2 = ( ( HeuristicSearchNode ) object2 ) . getF ( ) ; \nreturn ( f2 < f1 ) ? 1 : ( ( f2 > f1 ) ? - 1 : 0 ) ; \n} \n} \n"}
{"10347": "public class AbstractHeap { \npublic < T > T [ ] toArray ( T [ ] a ) { \nint size = size ( ) ; \nif ( size > a . length ) { \na = ( T [ ] ) java . lang . reflect . Array . newInstance ( a . getClass ( ) . getComponentType ( ) , size ) ; \n} \nIterator < E > it = iterator ( ) ; \nObject [ ] result = a ; \nfor ( int i = 0 ; \nsize > i ; \ni ++ ) { \nresult [ i ] = it . next ( ) ; \n} \nif ( size < a . length ) { \na [ size ] = null ; \n} \nreturn a ; \n} \n} \n"}
{"10348": "public class OpSymbol { \npublic void setArguments ( Term [ ] arguments ) { \nif ( ( arguments == null ) || ( 1 > arguments . length ) || ( 2 < arguments . length ) ) { \nthrow new IllegalArgumentException ( \"An operator has minimum 1 and maximum 2 arguments.\" ) ; \n} \nthis . arguments = arguments ; \nthis . arity = arguments . length ; \n} \n} \n"}
{"10351": "public class OpSymbol { \npublic int compareTo ( Object o ) { \nOpSymbol opSymbol = ( OpSymbol ) o ; \nreturn ( opSymbol . priority > priority ) ? - 1 : ( ( opSymbol . priority < priority ) ? 1 : 0 ) ; \n} \n} \n"}
{"10358": "public class AttributeGridImpl { \nprivate void setColumnAttribute ( AttributeSet attributes , int c ) { \nif ( columnAttributes . size ( ) <= c ) { \nfor ( int i = columnAttributes . size ( ) ; \nc >= i ; \ni ++ ) { \ncolumnAttributes . add ( null ) ; \n} \n} \ncolumnAttributes . set ( c , attributes ) ; \n} \n} \n"}
{"10359": "public class AttributeGridImpl { \nprivate void setRowAttribute ( AttributeSet attributes , int r ) { \nif ( rowAttributes . size ( ) <= r ) { \nfor ( int i = rowAttributes . size ( ) ; \nr >= i ; \ni ++ ) { \nrowAttributes . add ( null ) ; \n} \n} \nrowAttributes . set ( r , attributes ) ; \n} \n} \n"}
{"10360": "public class AttributeGridImpl { \nprivate AttributeSet getColumnAttributeOrNull ( int c ) { \nif ( ( 0 <= c ) && ( columnAttributes . size ( ) > c ) ) { \nreturn columnAttributes . get ( c ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"10361": "public class AttributeGridImpl { \nprivate AttributeSet getRowAttributeOrNull ( int r ) { \nif ( ( 0 <= r ) && ( rowAttributes . size ( ) > r ) ) { \nreturn rowAttributes . get ( r ) ; \n} \nelse { \nreturn null ; \n} \n} \n} \n"}
{"10363": "public class TimeRangeType { \npublic static Type createInstance ( String name , TimeOnly min , TimeOnly max ) { \nif ( ( min != null ) && ( max != null ) && ( 0 < min . compareTo ( max ) ) ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( INT_RANGE_TYPES ) { \nTimeRangeType newType = new TimeRangeType ( name , min , max ) ; \nTimeRangeType oldType = INT_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nINT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10365": "public class StringPatternType { \npublic boolean isInstance ( CharSequence value ) { \nreturn ( ( 0 >= maxLength ) || ( maxLength >= value . length ( ) ) ) && compiledPattern . matcher ( value ) . matches ( ) ; \n} \n} \n"}
{"10389": "public class StringUtils { \npublic static String arrayToList ( String [ ] array , String delim ) { \nString result = \"\" ; \nfor ( int i = 0 ; \narray . length > i ; \ni ++ ) { \nresult += array [ i ] + ( ( i == ( array . length - 1 ) ) ? \"\" : delim ) ; \n} \nreturn result ; \n} \n} \n"}
{"10390": "public class StringUtils { \npublic static String toCamelCase ( String name ) { \nString [ ] parts = name . split ( \"_\" ) ; \nString result = parts [ 0 ] ; \nfor ( int i = 1 ; \nparts . length > i ; \ni ++ ) { \nif ( 0 < parts [ i ] . length ( ) ) { \nresult += upperFirstChar ( parts [ i ] ) ; \n} \n} \nreturn result ; \n} \n} \n"}
{"10391": "public class StringUtils { \npublic static String convertCase ( String value , String separator , boolean firstLetterUpper , boolean firstLetterOfWordUpper ) { \nfinal StringBuffer result = new StringBuffer ( ) ; \nboolean firstWord = true ; \nboolean firstLetter = true ; \nboolean upper = false ; \nWordMachineState state = WordMachineState . Initial ; \nFunction2 < Character , Boolean , StringBuffer > writeChar = new Function2 < Character , Boolean , StringBuffer > ( ) { \npublic StringBuffer apply ( Character nextChar , Boolean upper ) { \nif ( upper ) result . append ( Character . toUpperCase ( nextChar ) ) ; \nelse result . append ( Character . toLowerCase ( nextChar ) ) ; \nreturn result ; \n} \n} \n; \nfor ( int i = 0 ; \nvalue . length ( ) > i ; \ni ++ ) { \nchar nextChar = value . charAt ( i ) ; \nif ( Character . isUpperCase ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordCaps : state = WordMachineState . ContinueWordCaps ; \nupper = false ; \nbreak ; \ncase ContinueWordLower : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nresult . append ( separator ) ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse if ( Character . isLetterOrDigit ( nextChar ) ) { \nswitch ( state ) { \ncase Initial : state = WordMachineState . StartWord ; \nupper = firstLetterOfWordUpper ; \nif ( ! firstWord ) { \nresult . append ( separator ) ; \n} \nfirstWord = false ; \nbreak ; \ncase StartWord : case ContinueWordLower : case ContinueWordCaps : state = WordMachineState . ContinueWordLower ; \nupper = false ; \nbreak ; \n} \nwriteChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; \nfirstLetter = false ; \n} \nelse { \nswitch ( state ) { \ncase Initial : state = WordMachineState . Initial ; \nbreak ; \ncase StartWord : case ContinueWordCaps : case ContinueWordLower : state = WordMachineState . Initial ; \nbreak ; \n} \nupper = false ; \n} \n} \nreturn result . toString ( ) ; \n} \n} \n"}
{"10396": "public class HierarchyAttribute { \npublic boolean isSubCategory ( HierarchyAttribute comp ) { \nif ( ! comp . attributeClass . attributeClassName . equals ( attributeClass . attributeClassName ) ) { \nreturn false ; \n} \nList < String > otherPath = comp . getPathValue ( ) ; \nList < String > path = getPathValue ( ) ; \nif ( path . size ( ) >= otherPath . size ( ) ) { \nreturn false ; \n} \nboolean subcat = true ; \nfor ( int i = 0 ; \npath . size ( ) > i ; \ni ++ ) { \nif ( ! otherPath . get ( i ) . equals ( path . get ( i ) ) ) { \nsubcat = false ; \nbreak ; \n} \n} \nreturn subcat ; \n} \n} \n"}
{"10402": "public class ManhattanHeuristic { \npublic float computeH ( EightPuzzleState state , HeuristicSearchNode searchNode ) { \nHeuristicSearchNode parentNode = ( HeuristicSearchNode ) searchNode . getParent ( ) ; \nif ( parentNode == null ) { \nint h = 0 ; \nfor ( int j = 0 ; \n3 > j ; \nj ++ ) { \nfor ( int i = 0 ; \n3 > i ; \ni ++ ) { \nchar nextTile = state . getTileAt ( i , j ) ; \nint goalX = state . getGoalXForTile ( nextTile ) ; \nint goalY = state . getGoalYForTile ( nextTile ) ; \nint diffX = goalX - i ; \ndiffX = ( 0 > diffX ) ? - diffX : diffX ; \nint diffY = goalY - j ; \ndiffY = ( 0 > diffY ) ? - diffY : diffY ; \nh += diffX + diffY ; \n} \n} \nreturn ( float ) h ; \n} \nelse { \nEightPuzzleState parentState = ( EightPuzzleState ) parentNode . getState ( ) ; \nfloat h = parentNode . getH ( ) ; \nchar playedMove = ( ( String ) searchNode . getAppliedOp ( ) . getOp ( ) ) . charAt ( 0 ) ; \nint emptyX = parentState . getEmptyX ( ) ; \nint emptyY = parentState . getEmptyY ( ) ; \nchar movedTile = state . getTileAt ( emptyX , emptyY ) ; \nint oldX = 0 ; \nint oldY = 0 ; \nswitch ( playedMove ) { \ncase 'L' : { \noldX = emptyX - 1 ; \nbreak ; \n} \ncase 'R' : { \noldX = emptyX + 1 ; \nbreak ; \n} \ncase 'U' : { \noldY = emptyY - 1 ; \nbreak ; \n} \ncase 'D' : { \noldY = emptyY + 1 ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nint change = 0 ; \nswitch ( playedMove ) { \ncase 'L' : case 'R' : { \nint goalX = state . getGoalXForTile ( movedTile ) ; \nint newX = emptyX ; \nint oldDiffX = oldX - goalX ; \noldDiffX = ( 0 > oldDiffX ) ? - oldDiffX : oldDiffX ; \nint newDiffX = newX - goalX ; \nnewDiffX = ( 0 > newDiffX ) ? - newDiffX : newDiffX ; \nchange = newDiffX - oldDiffX ; \nbreak ; \n} \ncase 'U' : case 'D' : { \nint goalY = state . getGoalYForTile ( movedTile ) ; \nint newY = emptyY ; \nint oldDiffY = oldY - goalY ; \noldDiffY = ( 0 > oldDiffY ) ? - oldDiffY : oldDiffY ; \nint newDiffY = newY - goalY ; \nnewDiffY = ( 0 > newDiffY ) ? - newDiffY : newDiffY ; \nchange = newDiffY - oldDiffY ; \nbreak ; \n} \ndefault : { \nthrow new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; \n} \n} \nreturn ( 0 < change ) ? ( h + 1.0f ) : ( h - 1.0f ) ; \n} \n} \n} \n"}
{"10403": "public class HashMapXY { \nprivate int mod ( long c , int bucketSize ) { \nreturn ( int ) ( ( 0 > c ) ? ( ( bucketSize + ( c % bucketSize ) ) % bucketSize ) : ( c % bucketSize ) ) ; \n} \n} \n"}
{"10410": "public class BitHackUtils { \npublic static int intLogBase2 ( int value ) { \nint temp1 ; \nint temp2 = value >> 16 ; \nif ( 0 < temp2 ) { \ntemp1 = temp2 >> 8 ; \nreturn ( 0 < temp1 ) ? ( 24 + LOG_TABLE_256 [ temp1 ] ) : ( 16 + LOG_TABLE_256 [ temp2 ] ) ; \n} \nelse { \ntemp1 = value >> 8 ; \nreturn ( 0 < temp1 ) ? ( 8 + LOG_TABLE_256 [ temp1 ] ) : LOG_TABLE_256 [ value ] ; \n} \n} \n} \n"}
{"10411": "public class BitHackUtils { \npublic static int intLogBase2v2 ( int value ) { \nint temp ; \nif ( 0 < ( temp = value >> 24 ) ) { \nreturn 24 + LOG_TABLE_256 [ temp ] ; \n} \nelse if ( 0 < ( temp = value >> 16 ) ) { \nreturn 16 + LOG_TABLE_256 [ temp ] ; \n} \nelse if ( 0 < ( temp = value >> 8 ) ) { \nreturn 8 + LOG_TABLE_256 [ temp ] ; \n} \nelse { \nreturn LOG_TABLE_256 [ value ] ; \n} \n} \n} \n"}
{"10412": "public class BitHackUtils { \npublic static int intLogBase10v2 ( int value ) { \nreturn ( 1000000000 <= value ) ? 9 : ( ( 100000000 <= value ) ? 8 : ( ( 10000000 <= value ) ? 7 : ( ( 1000000 <= value ) ? 6 : ( ( 100000 <= value ) ? 5 : ( ( 10000 <= value ) ? 4 : ( ( 1000 <= value ) ? 3 : ( ( 100 <= value ) ? 2 : ( ( 10 <= value ) ? 1 : 0 ) ) ) ) ) ) ) ) ; \n} \n} \n"}
{"10413": "public class BitHackUtils { \npublic static int intLogBase10v3 ( int value ) { \nreturn ( 10 > value ) ? 0 : ( ( 100 > value ) ? 1 : ( ( 1000 > value ) ? 2 : ( ( 10000 > value ) ? 3 : ( ( 100000 > value ) ? 4 : ( ( 1000000 > value ) ? 5 : ( ( 10000000 > value ) ? 6 : ( ( 100000000 > value ) ? 7 : ( ( 1000000000 > value ) ? 8 : 9 ) ) ) ) ) ) ) ) ; \n} \n} \n"}
{"10414": "public class BitHackUtils { \npublic static int intLogBase10 ( long value ) { \nreturn ( 1000000000000000000L <= value ) ? 18 : ( ( 100000000000000000L <= value ) ? 17 : ( ( 10000000000000000L <= value ) ? 16 : ( ( 1000000000000000L <= value ) ? 15 : ( ( 100000000000000L <= value ) ? 14 : ( ( 10000000000000L <= value ) ? 13 : ( ( 1000000000000L <= value ) ? 12 : ( ( 100000000000L <= value ) ? 11 : ( ( 10000000000L <= value ) ? 10 : ( ( 1000000000L <= value ) ? 9 : ( ( 100000000L <= value ) ? 8 : ( ( 10000000L <= value ) ? 7 : ( ( 1000000L <= value ) ? 6 : ( ( 100000L <= value ) ? 5 : ( ( 10000L <= value ) ? 4 : ( ( 1000L <= value ) ? 3 : ( ( 100L <= value ) ? 2 : ( ( 10L <= value ) ? 1 : 0 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ; \n} \n} \n"}
{"10415": "public class BitHackUtils { \npublic static int intLogBase10v2 ( long value ) { \nreturn ( 10 > value ) ? 0 : ( ( 100 > value ) ? 1 : ( ( 1000 > value ) ? 2 : ( ( 10000 > value ) ? 3 : ( ( 100000 > value ) ? 4 : ( ( 1000000 > value ) ? 5 : ( ( 10000000 > value ) ? 6 : ( ( 100000000 > value ) ? 7 : ( ( 1000000000L > value ) ? 8 : ( ( 10000000000L > value ) ? 9 : ( ( 100000000000L > value ) ? 10 : ( ( 1000000000000L > value ) ? 11 : ( ( 10000000000000L > value ) ? 12 : ( ( 100000000000000L > value ) ? 13 : ( ( 1000000000000000L > value ) ? 14 : ( ( 10000000000000000L > value ) ? 15 : ( ( 100000000000000000L > value ) ? 16 : ( ( 1000000000000000000L > value ) ? 17 : 18 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ; \n} \n} \n"}
{"10416": "public class BitHackUtils { \npublic static int getCharacterCountInt32 ( int value ) { \nif ( 0 <= value ) { \nreturn getCharacterCountUInt32 ( value ) ; \n} \nelse if ( value == Integer . MIN_VALUE ) { \nreturn getCharacterCountUInt32 ( Integer . MAX_VALUE ) + 1 ; \n} \nelse { \nreturn getCharacterCountUInt32 ( - value ) + 1 ; \n} \n} \n} \n"}
{"10417": "public class BitHackUtils { \npublic static int getCharacterCountInt64 ( long value ) { \nif ( 0 <= value ) { \nreturn getCharacterCountUInt64 ( value ) ; \n} \nelse if ( value == Long . MIN_VALUE ) { \nreturn getCharacterCountUInt64 ( Long . MAX_VALUE ) + 1 ; \n} \nelse { \nreturn getCharacterCountUInt64 ( - value ) + 1 ; \n} \n} \n} \n"}
{"10418": "public class BitHackUtils { \npublic static int getCharacterCountDecimal ( long integerValue , int scale ) { \nboolean isNeg = 0 > integerValue ; \nint totalDigits = BitHackUtils . getCharacterCountInt64 ( integerValue ) ; \nint totalLength = totalDigits ; \nif ( isNeg ) { \ntotalDigits -- ; \n} \nif ( 0 < scale ) { \ntotalLength ++ ; \nif ( totalDigits <= scale ) { \ntotalLength += ( scale - totalDigits ) + 1 ; \n} \n} \nelse { \ntotalLength -= scale ; \n} \nreturn totalLength ; \n} \n} \n"}
{"10420": "public class WAMCompiledQuery { \npublic void emmitCode ( ByteBuffer buffer , WAMMachine machine , WAMCallPoint callPoint ) throws LinkageException { \nif ( Integer . MAX_VALUE < sizeof ( ) ) { \nthrow new IllegalStateException ( \"The instruction listing size exceeds Integer.MAX_VALUE.\" ) ; \n} \nint length = 0 ; \nfor ( WAMInstruction instruction : instructions ) { \ninstruction . emmitCode ( buffer , machine ) ; \nlength += instruction . sizeof ( ) ; \n} \nthis . machine = machine ; \nthis . callPoint = callPoint ; \nthis . status = LinkStatus . Linked ; \n} \n} \n"}
{"10423": "public class ContextualProperties { \npublic String getProperty ( String key ) { \nString className = null ; \nString methodName = null ; \nStackTraceElement [ ] stack = Thread . currentThread ( ) . getStackTrace ( ) ; \nif ( 2 <= stack . length ) { \nclassName = stack [ 1 ] . getClassName ( ) ; \nmethodName = stack [ 1 ] . getMethodName ( ) ; \n} \nreturn getProperty ( className , methodName , key ) ; \n} \n} \n"}
{"10425": "public class ContextualProperties { \nprotected Iterator getKeyIterator ( final String base , final String modifier , final String key ) { \nreturn new Iterator ( ) { \nprivate int i ; \npublic boolean hasNext ( ) { \nreturn ( useDefaults ? ( ( ORDER . length > i ) && ( ENVIRONMENT_DEFAULTS_CUTOFF < ORDER [ i ] ) ) : ( ORDER . length > i ) ) ; \n} \npublic Object next ( ) { \nif ( ! hasNext ( ) ) { \nreturn null ; \n} \nint o = ORDER [ i ] ; \nString result = ( ( ( o & E ) != 0 ) ? ( environment + \".\" ) : \"\" ) + ( ( ( o & B ) != 0 ) ? ( base + \".\" ) : \"\" ) + ( ( ( o & M ) != 0 ) ? ( modifier + \".\" ) : \"\" ) + key ; \ni ++ ; \nreturn result ; \n} \npublic void remove ( ) { \nthrow new UnsupportedOperationException ( \"remove() is not supported on this key order iterator as \" + \"the ordering cannot be changed\" ) ; \n} \n} \n; \n} \n} \n"}
{"10427": "public class BaseThrottle { \npublic void setRate ( float hertz ) { \nif ( 0.0f >= hertz ) { \nthrow new IllegalArgumentException ( \"The throttle rate must be above zero.\" ) ; \n} \ncycleTimeNanos = ( long ) ( 1000000000f / hertz ) ; \nfirstCall = false ; \nfirstCheckCall = false ; \n} \n} \n"}
{"10433": "public class BuiltInTransformVisitor { \nprotected void leaveFunctor ( Functor functor ) { \nint pos = traverser . getPosition ( ) ; \nif ( ! traverser . isInHead ( ) && ( 0 <= pos ) ) { \nFunctor transformed = builtInTransform . apply ( functor ) ; \nif ( functor != transformed ) { \nBuiltInFunctor builtInFunctor = ( BuiltInFunctor ) transformed ; \nTerm parentTerm = traverser . getParentContext ( ) . getTerm ( ) ; \nif ( parentTerm instanceof Clause ) { \nClause parentClause = ( Clause ) parentTerm ; \nparentClause . getBody ( ) [ pos ] = builtInFunctor ; \n} \nelse if ( parentTerm instanceof Functor ) { \nFunctor parentFunctor = ( Functor ) parentTerm ; \nparentFunctor . getArguments ( ) [ pos ] = builtInFunctor ; \n} \n} \n} \n} \n} \n"}
{"10438": "public class SilentFailSocketAppender { \npublic void append ( LoggingEvent event ) { \nif ( event == null ) { \nreturn ; \n} \nif ( address == null ) { \nerrorHandler . error ( \"No remote host is set for SocketAppender named \\\"\" + this . name + \"\\\".\" ) ; \nreturn ; \n} \nif ( oos != null ) { \ntry { \nif ( locationInfo ) { \nevent . getLocationInformation ( ) ; \n} \noos . writeObject ( event ) ; \noos . flush ( ) ; \nif ( RESET_FREQUENCY <= ++ counter ) { \ncounter = 0 ; \noos . reset ( ) ; \n} \n} \ncatch ( IOException e ) { \noos = null ; \nLogLog . warn ( \"Detected problem with connection: \" + e ) ; \nif ( 0 < reconnectionDelay ) { \nfireConnector ( ) ; \n} \n} \n} \n} \n} \n"}
{"10443": "public class GlobalWriteLockWithWriteBehindTxMethod { \npublic void requestWriteOperation ( TxOperation op ) { \nTxId txId = null ; \nif ( 0 < getIsolationLevel ( ) . compareTo ( IsolationLevel . None ) ) { \ntxId = TxManager . getTxIdFromThread ( ) ; \nenlistWithSession ( ) ; \n} \nif ( getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) { \nop . execute ( ) ; \n} \nelse { \naddCachedOperation ( txId , op ) ; \n} \n} \n} \n"}
{"10448": "public class NestedMediaQueries { \n@ Override public boolean enter ( RuleSetNode ruleSetNode ) { \nScopeNode scopeNode = NodeTreeUtils . getFirstChild ( ruleSetNode , ScopeNode . class ) ; \nSelectorGroupNode selectorGroupNode = NodeTreeUtils . getFirstChild ( ruleSetNode , SelectorGroupNode . class ) ; \nif ( selectorGroupNode == null ) { \nreturn true ; \n} \nList < SelectorNode > selectorNodes = NodeTreeUtils . getChildren ( selectorGroupNode , SelectorNode . class ) ; \nif ( 0 > selectorNodes . size ( ) ) { \nreturn true ; \n} \nList < MediaQueryNode > mediaQueryNodes = NodeTreeUtils . getAndRemoveChildren ( scopeNode , MediaQueryNode . class ) ; \nfor ( MediaQueryNode mediaQueryNode : mediaQueryNodes ) { \nScopeNode mediaScopeNode = NodeTreeUtils . getFirstChild ( mediaQueryNode , ScopeNode . class ) ; \nList < RuleSetNode > nestedRuleSets = NodeTreeUtils . getAndRemoveChildren ( mediaScopeNode , RuleSetNode . class ) ; \nif ( NodeTreeUtils . getChildren ( mediaScopeNode , WhiteSpaceCollectionNode . class ) . size ( ) < mediaScopeNode . getChildren ( ) . size ( ) ) { \nRuleSetNode newRuleSetNode = new RuleSetNode ( ) ; \nScopeNode newScopeNode = new ScopeNode ( ) ; \nnewRuleSetNode . addChild ( selectorGroupNode . clone ( ) ) ; \nnewRuleSetNode . addChild ( newScopeNode ) ; \nNodeTreeUtils . moveChildren ( mediaScopeNode , newScopeNode ) ; \nmediaScopeNode . clearChildren ( ) ; \nmediaScopeNode . addChild ( newRuleSetNode ) ; \n} \nfor ( RuleSetNode nestedRuleSet : nestedRuleSets ) { \nList < SelectorGroupNode > nestedSelectorGroupNodes = NodeTreeUtils . getChildren ( nestedRuleSet , SelectorGroupNode . class ) ; \nfor ( SelectorGroupNode nestedSelectorGroupNode : nestedSelectorGroupNodes ) { \nList < SelectorNode > nestedSelectorNodes = NodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SelectorNode . class ) ; \nNodeTreeUtils . getAndRemoveChildren ( nestedSelectorGroupNode , SpacingNode . class ) ; \nfor ( SelectorNode selectorNode : selectorNodes ) { \nfor ( SelectorNode nestedSelectorNode : nestedSelectorNodes ) { \nif ( nestedSelectorNode . getChildren ( ) . get ( 0 ) != null ) { \nif ( nestedSelectorNode . getChildren ( ) . get ( 0 ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) nestedSelectorNode . getChildren ( ) . get ( 0 ) ; \nselectorSegmentNode . setCombinator ( \" \" ) ; \n} \n} \nfor ( int j = selectorNode . getChildren ( ) . size ( ) - 1 ; \n0 <= j ; \nj -- ) { \nif ( selectorNode . getChildren ( ) . get ( j ) instanceof SelectorSegmentNode ) { \nSelectorSegmentNode selectorSegmentNode = ( SelectorSegmentNode ) selectorNode . getChildren ( ) . get ( j ) . clone ( ) ; \nnestedSelectorNode . addChild ( 0 , selectorSegmentNode ) ; \n} \n} \nnestedSelectorGroupNode . addChild ( nestedSelectorNode ) ; \nnestedSelectorGroupNode . addChild ( new SpacingNode ( \" \" ) ) ; \n} \n} \n} \nmediaScopeNode . addChild ( nestedRuleSet ) ; \n} \nif ( ruleSetNode . getParent ( ) != null ) { \nruleSetNode . getParent ( ) . addChild ( new SpacingNode ( \"\\n\" ) ) ; \nruleSetNode . getParent ( ) . addChild ( mediaQueryNode ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10449": "public class BatchSynchQueueBase { \npublic boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { \nif ( e == null ) { \nthrow new IllegalArgumentException ( \"The 'e' parameter may not be null.\" ) ; \n} \nReentrantLock lock = this . lock ; \nlock . lockInterruptibly ( ) ; \nlong nanos = unit . toNanos ( timeout ) ; \ntry { \ndo { \nif ( insert ( e , false ) ) { \nreturn true ; \n} \ntry { \nnanos = notFull . awaitNanos ( nanos ) ; \n} \ncatch ( InterruptedException ie ) { \nnotFull . signal ( ) ; \nthrow ie ; \n} \n} \nwhile ( 0 < nanos ) ; \nreturn false ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"10450": "public class BatchSynchQueueBase { \npublic E poll ( long timeout , TimeUnit unit ) throws InterruptedException { \nReentrantLock lock = this . lock ; \nlock . lockInterruptibly ( ) ; \ntry { \nlong nanos = unit . toNanos ( timeout ) ; \ndo { \nif ( count != 0 ) { \nreturn extract ( true , true ) . getElement ( ) ; \n} \ntry { \nnanos = notEmpty . awaitNanos ( nanos ) ; \n} \ncatch ( InterruptedException ie ) { \nnotEmpty . signal ( ) ; \nthrow ie ; \n} \n} \nwhile ( 0 < nanos ) ; \nreturn null ; \n} \nfinally { \nlock . unlock ( ) ; \n} \n} \n} \n"}
{"10457": "public class ScopeNode { \npublic ScopeNode callMixin ( String name , ArgumentsNode arguments ) { \nList < ExpressionGroupNode > argumentList = ( arguments != null ) ? NodeTreeUtils . getChildren ( arguments , ExpressionGroupNode . class ) : Collections . < ExpressionGroupNode > emptyList ( ) ; \nif ( _parameterDefinitions . size ( ) < argumentList . size ( ) ) { \nthrow new IllegalMixinArgumentException ( name , _parameterDefinitions . size ( ) ) ; \n} \nScopeNode mixinScope = clone ( ) ; \nNodeTreeUtils . filterLineBreaks ( mixinScope ) ; \nfor ( int i = 0 ; \nargumentList . size ( ) > i ; \ni ++ ) { \nExpressionGroupNode argument = argumentList . get ( i ) ; \nVariableDefinitionNode parameter = mixinScope . _parameterDefinitions . get ( i ) ; \nparameter . clearChildren ( ) ; \nparameter . addChild ( argument ) ; \n} \ngetParent ( ) . setVisible ( false ) ; \nreturn mixinScope ; \n} \n} \n"}
{"10462": "public class WAMResolvingMachine { \nprotected Term decodeHeap ( int start , Map < Integer , Variable > variableContext ) { \nTerm result = null ; \nint addr = deref ( start ) ; \nbyte tag = getDerefTag ( ) ; \nint val = getDerefVal ( ) ; \nswitch ( tag ) { \ncase REF : { \nVariable var = variableContext . get ( val ) ; \nif ( var == null ) { \nvar = new Variable ( varNameId . decrementAndGet ( ) , null , false ) ; \nvariableContext . put ( val , var ) ; \n} \nresult = var ; \nbreak ; \n} \ncase STR : { \nint fn = getHeap ( val ) ; \nint f = fn & 0x00ffffff ; \nFunctorName functorName = getDeinternedFunctorName ( f ) ; \nint arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \nfor ( int i = 0 ; \narity > i ; \ni ++ ) { \narguments [ i ] = decodeHeap ( val + 1 + i , variableContext ) ; \n} \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ncase WAMInstruction . CON : { \nint f = val & 0x3fffffff ; \nresult = new Functor ( f , null ) ; \nbreak ; \n} \ncase WAMInstruction . LIS : { \nFunctorName functorName = new FunctorName ( \"cons\" , 2 ) ; \nint f = internFunctorName ( functorName ) ; \nint arity = functorName . getArity ( ) ; \nTerm [ ] arguments = new Term [ arity ] ; \nfor ( int i = 0 ; \narity > i ; \ni ++ ) { \narguments [ i ] = decodeHeap ( val + i , variableContext ) ; \n} \nresult = new Functor ( f , arguments ) ; \nbreak ; \n} \ndefault : throw new IllegalStateException ( \"Encountered unknown tag type on the heap.\" ) ; \n} \nreturn result ; \n} \n} \n"}
{"10470": "public class LockFreeNQueue { \npublic E poll ( ) { \nint currentLevel = 0 ; \nwhile ( true ) { \nMarker < E > h = null ; \nNode < E > first = null ; \nNode < E > second = null ; \nfor ( ; \nn > currentLevel ; \ncurrentLevel ++ ) { \nh = markers [ currentLevel ] ; \nfirst = h . getNext ( ) ; \nsecond = first . getNext ( ) ; \nif ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nbreak ; \n} \nelse if ( currentLevel == ( n - 1 ) ) { \nreturn null ; \n} \n} \nNode < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; \nif ( first == h . getNext ( ) ) { \nif ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) { \nif ( first == null ) { \nreturn null ; \n} \nelse { \nmarkers [ currentLevel + 1 ] . casTail ( t , first ) ; \n} \n} \nelse if ( h . casNext ( first , second ) ) { \nDataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; \nE item = firstDataNode . getItem ( ) ; \nif ( item != null ) { \nfirstDataNode . setItem ( null ) ; \ncount . decrementAndGet ( ) ; \nreturn item ; \n} \n} \n} \n} \n} \n} \n"}
{"10488": "public class DoubleRangeType { \npublic static Type createInstance ( String name , double min , double max ) { \nif ( max < min ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( DOUBLE_RANGE_TYPES ) { \nDoubleRangeType newType = new DoubleRangeType ( name , min , max ) ; \nDoubleRangeType oldType = DOUBLE_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nDOUBLE_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10494": "public class BaseUnaryCondition { \npublic void await ( T t ) throws InterruptedException { \nsynchronized ( monitor ) { \nlong waitNanos = evaluateWithWaitTimeNanos ( t ) ; \nwhile ( 0 < waitNanos ) { \nlong milliPause = waitNanos / 1000000 ; \nint nanoPause = ( int ) ( waitNanos % 1000000 ) ; \nmonitor . wait ( milliPause , nanoPause ) ; \nwaitNanos = evaluateWithWaitTimeNanos ( t ) ; \n} \n} \n} \n} \n"}
{"10495": "public class BaseUnaryCondition { \npublic boolean await ( T t , long timeout , TimeUnit unit ) throws InterruptedException { \nsynchronized ( monitor ) { \nlong expiryTimeNanos = System . nanoTime ( ) + unit . toNanos ( timeout ) ; \nlong waitNanos = evaluateWithWaitTimeNanos ( t ) ; \nwhile ( 0 < waitNanos ) { \nlong remainingTimeNanos = expiryTimeNanos - System . nanoTime ( ) ; \nif ( 0 >= remainingTimeNanos ) { \nreturn false ; \n} \nlong timeToPauseNanos = ( remainingTimeNanos > waitNanos ) ? waitNanos : remainingTimeNanos ; \nlong milliPause = timeToPauseNanos / 1000000 ; \nint nanoPause = ( int ) ( timeToPauseNanos % 1000000 ) ; \nmonitor . wait ( milliPause , nanoPause ) ; \nwaitNanos = evaluateWithWaitTimeNanos ( t ) ; \n} \n} \nreturn true ; \n} \n} \n"}
{"10498": "public class DateRangeType { \npublic static Type createInstance ( String name , DateOnly from , DateOnly to ) { \nif ( ( from != null ) && ( to != null ) && ( 0 < from . compareTo ( to ) ) ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( DATE_RANGE_TYPES ) { \nDateRangeType newType = new DateRangeType ( name , from , to ) ; \nDateRangeType oldType = DATE_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nDATE_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10515": "public class CircularArrayMap { \npublic void clearUpTo ( int key ) { \nif ( ( ( key >= start ) && ( ( end - 1 ) > key ) ) ) { \nint newStart ; \nfor ( newStart = start ; \n( end >= newStart ) && ( key >= newStart ) ; \nnewStart ++ ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \n} \nfor ( ; \nend >= newStart ; \nnewStart ++ ) { \nif ( data [ offset ( newStart ) ] != null ) { \nbreak ; \n} \n} \nstart = newStart ; \n} \nelse { \nint newStart ; \nfor ( newStart = start ; \n( end >= newStart ) ; \nnewStart ++ ) { \nint offset = offset ( newStart ) ; \nif ( data [ offset ] != null ) { \ndata [ offset ] = null ; \ncount -- ; \n} \n} \nstart = newStart ; \noffset = - start ; \n} \n} \n} \n"}
{"10516": "public class CircularArrayMap { \nprivate void expand ( int key ) { \nint newFactorSize = ( ( length * 3 ) / 2 ) + 1 ; \nint newSpaceSize = spaceRequired ( key ) ; \nint newSize = ( newFactorSize < newSpaceSize ) ? newSpaceSize : newFactorSize ; \nObject [ ] oldData = data ; \ndata = new Object [ newSize ] ; \nint offsetStart = offset ( start ) ; \nint offsetEnd = offset ( end ) ; \nif ( offsetEnd > offsetStart ) { \nSystem . arraycopy ( oldData , offsetStart , data , 0 , end - start ) ; \n} \nelse { \nSystem . arraycopy ( oldData , offsetStart , data , 0 , length - offsetStart ) ; \nSystem . arraycopy ( oldData , 0 , data , length - offsetStart , offsetEnd ) ; \n} \noffset = - start ; \nlength = newSize ; \n} \n} \n"}
{"10517": "public class TextGridImpl { \nprivate void internalInsert ( char character , int c , int r ) { \nmaxColumn = ( maxColumn < c ) ? c : maxColumn ; \nmaxRow = ( maxRow < r ) ? r : maxRow ; \ndata . put ( ( long ) c , ( long ) r , character ) ; \n} \n} \n"}
{"10518": "public class UniformCostComparator { \npublic int compare ( SearchNode object1 , SearchNode object2 ) { \nfloat cost1 = object1 . getPathCost ( ) ; \nfloat cost2 = object2 . getPathCost ( ) ; \nreturn ( cost2 < cost1 ) ? 1 : ( ( cost2 > cost1 ) ? - 1 : 0 ) ; \n} \n} \n"}
{"10519": "public class DynamicOperatorParser { \npublic Term parseOperators ( Term [ ] terms ) throws SourceCodeException { \nstack . offer ( 0 ) ; \nstate = 0 ; \nposition = 0 ; \nnextTerm = null ; \nfor ( position = 0 ; \nterms . length >= position ; \n) { \nSymbol nextSymbol ; \nif ( terms . length > position ) { \nnextTerm = terms [ position ] ; \nif ( nextTerm instanceof CandidateOpSymbol ) { \nnextSymbol = Symbol . Op ; \n} \nelse { \nnextSymbol = Symbol . Term ; \n} \n} \nelse { \nnextSymbol = Symbol . Final ; \n} \nAction action = actionTable [ state ] [ nextSymbol . ordinal ( ) ] ; \naction . apply ( ) ; \n} \nreturn ( Functor ) outputStack . poll ( ) ; \n} \n} \n"}
{"10523": "public class CommandLineParser { \npublic static String rightPad ( String stringToPad , String padder , int size ) { \nif ( padder . length ( ) == 0 ) { \nreturn stringToPad ; \n} \nStringBuffer strb = new StringBuffer ( stringToPad ) ; \nCharacterIterator sci = new StringCharacterIterator ( padder ) ; \nwhile ( size > strb . length ( ) ) { \nfor ( char ch = sci . first ( ) ; \nch != CharacterIterator . DONE ; \nch = sci . next ( ) ) { \nif ( size > strb . length ( ) ) { \nstrb . append ( String . valueOf ( ch ) ) ; \n} \n} \n} \nreturn strb . toString ( ) ; \n} \n} \n"}
{"10526": "public class CommandLineParser { \npublic String getUsage ( ) { \nString result = \"Options:\\n\" ; \nint optionWidth = 0 ; \nint argumentWidth = 0 ; \nfor ( CommandLineOption optionInfo : optionMap . values ( ) ) { \nint oWidth = optionInfo . option . length ( ) ; \nint aWidth = ( optionInfo . argument != null ) ? ( optionInfo . argument . length ( ) ) : 0 ; \noptionWidth = ( optionWidth < oWidth ) ? oWidth : optionWidth ; \nargumentWidth = ( argumentWidth < aWidth ) ? aWidth : argumentWidth ; \n} \nfor ( CommandLineOption optionInfo : optionMap . values ( ) ) { \nString argString = ( ( optionInfo . argument != null ) ? ( optionInfo . argument ) : \"\" ) ; \nString optionString = optionInfo . option ; \nargString = rightPad ( argString , \" \" , argumentWidth ) ; \noptionString = rightPad ( optionString , \" \" , optionWidth ) ; \nresult += \"-\" + optionString + \" \" + argString + \" \" + optionInfo . comment + \"\\n\" ; \n} \nreturn result ; \n} \n} \n"}
{"10533": "public class PTStemmer { \npublic Enumeration listOptions ( ) { \nVector < Option > result ; \nString desc ; \nSelectedTag tag ; \nint i ; \nresult = new Vector < Option > ( ) ; \ndesc = \"\" ; \nfor ( i = 0 ; \nTAGS_STEMMERS . length > i ; \ni ++ ) { \ntag = new SelectedTag ( TAGS_STEMMERS [ i ] . getID ( ) , TAGS_STEMMERS ) ; \ndesc += \"\\t\" + tag . getSelectedTag ( ) . getIDStr ( ) + \" = \" + tag . getSelectedTag ( ) . getReadable ( ) + \"\\n\" ; \n} \nresult . addElement ( new Option ( \"\\tThe type of stemmer algorithm to use:\\n\" + desc + \"\\t(default: \" + new SelectedTag ( STEMMER_ORENGO , TAGS_STEMMERS ) + \")\" , \"S\" , 1 , \"-S \" + Tag . toOptionList ( TAGS_STEMMERS ) ) ) ; \nresult . addElement ( new Option ( \"\\tThe file with the named entities to ignore (optional).\\n\" + \"\\tFile format: simple text file with one entity per line.\\n\" + \"\\t(default: none)\\n\" , \"N\" , 1 , \"-N <file>\" ) ) ; \nresult . addElement ( new Option ( \"\\tThe file with the stopwords (optional).\\n\" + \"\\tFile format: simple text file with one stopword per line.\\n\" + \"\\t(default: none)\\n\" , \"W\" , 1 , \"-W <file>\" ) ) ; \nresult . addElement ( new Option ( \"\\tThe size of the cache. Disable with 0.\\n\" + \"\\t(default: 1000)\\n\" , \"C\" , 1 , \"-C <int>\" ) ) ; \nreturn result . elements ( ) ; \n} \n} \n"}
{"10536": "public class PTStemmer { \nprotected synchronized ptstemmer . Stemmer getActualStemmer ( ) throws PTStemmerException { \nif ( m_ActualStemmer == null ) { \nif ( m_Stemmer == STEMMER_ORENGO ) m_ActualStemmer = new OrengoStemmer ( ) ; \nelse if ( m_Stemmer == STEMMER_PORTER ) m_ActualStemmer = new PorterStemmer ( ) ; \nelse if ( m_Stemmer == STEMMER_SAVOY ) m_ActualStemmer = new SavoyStemmer ( ) ; \nelse throw new IllegalStateException ( \"Unhandled stemmer type: \" + m_Stemmer ) ; \nif ( ! m_NamedEntities . isDirectory ( ) ) m_ActualStemmer . ignore ( PTStemmerUtilities . fileToSet ( m_NamedEntities . getAbsolutePath ( ) ) ) ; \nif ( ! m_Stopwords . isDirectory ( ) ) m_ActualStemmer . ignore ( PTStemmerUtilities . fileToSet ( m_Stopwords . getAbsolutePath ( ) ) ) ; \nif ( 0 < m_Cache ) m_ActualStemmer . enableCaching ( m_Cache ) ; \nelse m_ActualStemmer . disableCaching ( ) ; \n} \nreturn m_ActualStemmer ; \n} \n} \n"}
{"10539": "public class FloatRangeType { \npublic static Type createInstance ( String name , float min , float max ) { \nif ( max < min ) { \nthrow new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; \n} \nsynchronized ( FLOAT_RANGE_TYPES ) { \nFloatRangeType newType = new FloatRangeType ( name , min , max ) ; \nFloatRangeType oldType = FLOAT_RANGE_TYPES . get ( name ) ; \nif ( ( oldType != null ) && ! oldType . equals ( newType ) ) { \nthrow new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; \n} \nelse if ( ( oldType != null ) && oldType . equals ( newType ) ) { \nreturn oldType ; \n} \nelse { \nFLOAT_RANGE_TYPES . put ( name , newType ) ; \nreturn newType ; \n} \n} \n} \n} \n"}
{"10544": "public class WAMResolvingJavaMachine { \nprivate int nextStackFrame ( ) { \nif ( ep == bp ) { \nreturn STACK_BASE ; \n} \nelse if ( bp < ep ) { \nreturn ep + data . get ( ep + 2 ) + 3 ; \n} \nelse { \nreturn bp + data . get ( bp ) + 8 ; \n} \n} \n} \n"}
{"10546": "public class WAMResolvingJavaMachine { \nprivate void trail ( int addr ) { \nif ( ( hbp > addr ) || ( ( addr > hp ) && ( bp > addr ) ) ) { \ndata . put ( trp , addr ) ; \ntrp ++ ; \n} \n} \n} \n"}
{"10547": "public class WAMResolvingJavaMachine { \nprivate void unwindTrail ( int a1 , int a2 ) { \nfor ( int addr = a1 ; \na2 > addr ; \naddr ++ ) { \nint tmp = data . get ( addr ) ; \ndata . put ( tmp , refTo ( tmp ) ) ; \n} \n} \n} \n"}
{"10548": "public class WAMResolvingJavaMachine { \nprivate void tidyTrail ( ) { \nint i ; \nif ( bp == 0 ) { \ni = TRAIL_BASE ; \n} \nelse { \ni = data . get ( bp + data . get ( bp ) + 5 ) ; \n} \nwhile ( trp > i ) { \nint addr = data . get ( i ) ; \nif ( ( hbp > addr ) || ( ( addr > hp ) && ( bp > addr ) ) ) { \ni ++ ; \n} \nelse { \ndata . put ( i , data . get ( trp - 1 ) ) ; \ntrp -- ; \n} \n} \n} \n} \n"}
{"10549": "public class WAMResolvingJavaMachine { \nprivate boolean unify ( int a1 , int a2 ) { \nuPush ( a1 ) ; \nuPush ( a2 ) ; \nboolean fail = false ; \nwhile ( ! uEmpty ( ) && ! fail ) { \nint d1 = deref ( uPop ( ) ) ; \nint t1 = derefTag ; \nint v1 = derefVal ; \nint d2 = deref ( uPop ( ) ) ; \nint t2 = derefTag ; \nint v2 = derefVal ; \nif ( d1 != d2 ) { \nif ( ( t1 == WAMInstruction . REF ) ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . REF ) { \nbind ( d1 , d2 ) ; \n} \nelse if ( t2 == WAMInstruction . STR ) { \nint fn1 = data . get ( v1 ) ; \nint fn2 = data . get ( v2 ) ; \nbyte n1 = ( byte ) ( fn1 >>> 24 ) ; \nif ( fn1 == fn2 ) { \nfor ( int i = 1 ; \nn1 >= i ; \ni ++ ) { \nuPush ( v1 + i ) ; \nuPush ( v2 + i ) ; \n} \n} \nelse { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . CON ) { \nif ( ( t1 != WAMInstruction . CON ) || ( v1 != v2 ) ) { \nfail = true ; \n} \n} \nelse if ( t2 == WAMInstruction . LIS ) { \nif ( t1 != WAMInstruction . LIS ) { \nfail = true ; \n} \nelse { \nuPush ( v1 ) ; \nuPush ( v2 ) ; \nuPush ( v1 + 1 ) ; \nuPush ( v2 + 1 ) ; \n} \n} \n} \n} \nreturn ! fail ; \n} \n} \n"}
{"10553": "public class EightPuzzleState { \npublic static boolean isSolvable ( EightPuzzleState state ) { \nEightPuzzleState checkState ; \ntry { \ncheckState = ( EightPuzzleState ) state . clone ( ) ; \n} \ncatch ( CloneNotSupportedException e ) { \nthrow new IllegalStateException ( \"Puzzle state could not be cloned.\" , e ) ; \n} \nEightPuzzleState goalState = getGoalState ( ) ; \nint illegalSwaps = 0 ; \nfor ( int j = 0 ; \n3 > j ; \nj ++ ) { \nfor ( int i = 0 ; \n3 > i ; \ni ++ ) { \nchar t = goalState . getTileAt ( i , j ) ; \nillegalSwaps += checkState . swapTileToLocationCountingIllegal ( t , i , j ) ; \n} \n} \nreturn ( illegalSwaps % 2 ) == 0 ; \n} \n} \n"}
{"10556": "public class EightPuzzleState { \npublic String prettyPrint ( ) { \nString result = \"\" ; \nfor ( int j = 0 ; \n3 > j ; \nj ++ ) { \nresult += new String ( board [ j ] ) + \"\\n\" ; \n} \nresult = result . replace ( 'E' , ' ' ) ; \nreturn result ; \n} \n} \n"}
{"10557": "public class EightPuzzleState { \nprotected int swapTileToLocationCountingIllegal ( char t , int x , int y ) { \nint illegal = 0 ; \nint tileX = getXForTile ( t ) ; \nint tileY = getYForTile ( t ) ; \nwhile ( tileX != x ) { \nif ( 0 < ( tileX - x ) ) { \nif ( swapTiles ( tileX , tileY , tileX - 1 , tileY ) ) { \nillegal ++ ; \n} \ntileX -- ; \n} \nelse { \nif ( swapTiles ( tileX , tileY , tileX + 1 , tileY ) ) { \nillegal ++ ; \n} \ntileX ++ ; \n} \n} \nwhile ( tileY != y ) { \nif ( swapTiles ( tileX , tileY , tileX , tileY - 1 ) ) { \nillegal ++ ; \n} \ntileY -- ; \n} \nreturn illegal ; \n} \n} \n"}
{"10559": "public class EightPuzzleState { \nprivate static List < Character > stringToCharList ( String boardString ) { \nchar [ ] chars = new char [ 9 ] ; \nboardString . getChars ( 0 , 9 , chars , 0 ) ; \nList < Character > charList = new ArrayList < Character > ( ) ; \nfor ( int l = 0 ; \n9 > l ; \nl ++ ) { \ncharList . add ( chars [ l ] ) ; \n} \nreturn charList ; \n} \n} \n"}
{"10560": "public class EightPuzzleState { \nprivate static EightPuzzleState charListToState ( List < Character > charList ) { \nEightPuzzleState newState = new EightPuzzleState ( ) ; \nIterator < Character > k = charList . iterator ( ) ; \nfor ( int j = 0 ; \n3 > j ; \nj ++ ) { \nfor ( int i = 0 ; \n3 > i ; \ni ++ ) { \nchar nextChar = k . next ( ) ; \nif ( nextChar == 'E' ) { \nnewState . emptyX = i ; \nnewState . emptyY = j ; \n} \nnewState . board [ j ] [ i ] = nextChar ; \n} \n} \nreturn newState ; \n} \n} \n"}
{"10561": "public class LoggingToLog4JHandler { \nprivate String toLog4jMessage ( LogRecord record ) { \nString message = record . getMessage ( ) ; \nObject [ ] parameters = record . getParameters ( ) ; \nif ( ( parameters != null ) && ( parameters . length != 0 ) ) { \nif ( ( 0 <= message . indexOf ( \"{0}\" ) ) || ( 0 <= message . indexOf ( \"{1}\" ) ) || ( 0 <= message . indexOf ( \"{2}\" ) ) || ( 0 <= message . indexOf ( \"{3}\" ) ) ) { \nmessage = MessageFormat . format ( message , parameters ) ; \n} \n} \nreturn message ; \n} \n} \n"}
{"10567": "public class WrapperQueue { \nprivate void signalOnSizeThresholdCrossing ( long oldSize , long newSize ) { \nif ( signalable != null ) { \nif ( ( lowWaterSizeThreshold <= oldSize ) && ( lowWaterSizeThreshold > newSize ) ) { \nsignalable . signalAll ( ) ; \n} \nelse if ( ( highWaterSizeThreshold <= oldSize ) && ( highWaterSizeThreshold > newSize ) ) { \nsignalable . signal ( ) ; \n} \n} \n} \n} \n"}
{"10572": "public class Sizeof { \nprivate static void runGCTillStable ( ) { \nlong usedMem1 = usedMemory ( ) ; \nlong usedMem2 = Long . MAX_VALUE ; \nfor ( int i = 0 ; \n( usedMem2 > usedMem1 ) && ( 500 > i ) ; \ni ++ ) { \nRUNTIME . runFinalization ( ) ; \nRUNTIME . gc ( ) ; \nThread . currentThread ( ) . yield ( ) ; \nusedMem2 = usedMem1 ; \nusedMem1 = usedMemory ( ) ; \n} \n} \n} \n"}
{"10576": "public class TextTableImpl { \npublic void setMaxRowHeight ( int row , int height ) { \nInteger previousValue = maxRowSizes . get ( row ) ; \nif ( previousValue == null ) { \nmaxRowSizes . put ( row , height ) ; \n} \nelse if ( height > previousValue ) { \nmaxRowSizes . put ( row , height ) ; \n} \n} \n} \n"}
{"10577": "public class TextTableImpl { \nprivate void updateMaxColumnWidth ( int column , int width ) { \nInteger previousValue = maxColumnSizes . get ( column ) ; \nif ( previousValue == null ) { \nmaxColumnSizes . put ( column , width ) ; \n} \nelse if ( width > previousValue ) { \nmaxColumnSizes . put ( column , width ) ; \n} \n} \n} \n"}
{"10585": "public class LessThan { \nprotected boolean evaluate ( NumericType firstNumber , NumericType secondNumber ) { \nif ( firstNumber . isInteger ( ) && secondNumber . isInteger ( ) ) { \nreturn secondNumber . intValue ( ) > firstNumber . intValue ( ) ; \n} \nelse { \nreturn secondNumber . doubleValue ( ) > firstNumber . doubleValue ( ) ; \n} \n} \n} \n"}
{"10590": "public class FibonacciHeap { \nprivate static int ceilingLog2 ( int n ) { \nint oa ; \nint i ; \nint b ; \noa = n ; \nb = 32 / 2 ; \ni = 0 ; \nwhile ( b != 0 ) { \ni = ( i << 1 ) ; \nif ( ( 1 << b ) <= n ) { \nn /= ( 1 << b ) ; \ni = i | 1 ; \n} \nelse { \nn &= ( 1 << b ) - 1 ; \n} \nb /= 2 ; \n} \nif ( ( 1 << i ) == oa ) { \nreturn i ; \n} \nelse { \nreturn i + 1 ; \n} \n} \n} \n"}
{"10591": "public class FibonacciHeap { \nprivate void updateMinimum ( Node node ) { \nif ( entryComparator != null ) { \nif ( 0 > entryComparator . compare ( node . element , minNode . element ) ) { \nminNode = node ; \n} \n} \nelse { \nif ( 0 > ( ( Comparable ) node . element ) . compareTo ( minNode . element ) ) { \nminNode = node ; \n} \n} \n} \n} \n"}
{"10603": "public class BeanMemento { \nprivate void capture ( boolean ignoreNull ) { \nClass cls = ob . getClass ( ) ; \nMethod [ ] methods = cls . getMethods ( ) ; \nfor ( Method nextMethod : methods ) { \nString methodName = nextMethod . getName ( ) ; \nif ( methodName . startsWith ( \"get\" ) && ( 4 <= methodName . length ( ) ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 0 ) ) { \nString propName = Character . toLowerCase ( methodName . charAt ( 3 ) ) + methodName . substring ( 4 ) ; \ntry { \nObject [ ] params = new Object [ ] { \n} \n; \nObject value = nextMethod . invoke ( ob , params ) ; \nif ( ! ignoreNull || ( value != null ) ) { \nvalues . put ( propName , value ) ; \n} \n} \ncatch ( IllegalAccessException e ) { \nthrow new IllegalStateException ( e ) ; \n} \ncatch ( InvocationTargetException e ) { \nthrow new IllegalStateException ( e ) ; \n} \n} \n} \n} \n} \n"}
{"10618": "public class Functor { \npublic Term getArgument ( int index ) { \nif ( ( arguments == null ) || ( ( arguments . length - 1 ) < index ) ) { \nreturn null ; \n} \nelse { \nreturn arguments [ index ] ; \n} \n} \n} \n"}
{"10619": "public class Functor { \npublic Iterator < Operator < Term > > getChildren ( boolean reverse ) { \nif ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) { \nreturn ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; \n} \nelse { \nif ( arguments == null ) { \nreturn new LinkedList < Operator < Term > > ( ) . iterator ( ) ; \n} \nelse if ( ! reverse ) { \nreturn Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; \n} \nelse { \nList < Operator < Term > > argList = new LinkedList < Operator < Term > > ( ) ; \nfor ( int i = arity - 1 ; \n0 <= i ; \ni -- ) { \nargList . add ( arguments [ i ] ) ; \n} \nreturn argList . iterator ( ) ; \n} \n} \n} \n} \n"}
{"10620": "public class Functor { \nprotected String toStringArguments ( ) { \nString result = \"\" ; \nif ( 0 < arity ) { \nresult += \"[ \" ; \nfor ( int i = 0 ; \narity > i ; \ni ++ ) { \nTerm nextArg = arguments [ i ] ; \nresult += ( ( nextArg != null ) ? nextArg . toString ( ) : \"<null>\" ) + ( ( ( arity - 1 ) > i ) ? \", \" : \" \" ) ; \n} \nresult += \" ]\" ; \n} \nreturn result ; \n} \n} \n"}
{"10621": "public class SqlQueryEngine { \npublic < T extends MeasureAppender > T retrieveSummary ( SchemaDefinition schemaDefinition , Class < T > resultClazz , QueryParameter queryParameter ) throws NovieRuntimeException { \nfinal SqlQueryBuilder < T > sqlQueryBuilder = new SqlQueryBuilder < T > ( schemaDefinition , resultClazz , queryParameter . partialCopy ( QueryParameterKind . GROUPS , QueryParameterKind . PAGE ) ) ; \nList < T > result = executeQuery ( sqlQueryBuilder ) ; \nif ( result . isEmpty ( ) ) { \nthrow new NovieRuntimeException ( \"Summary doesn't return any result.\" ) ; \n} \nif ( 1 < result . size ( ) ) { \nthrow new NovieRuntimeException ( \"Summary returns more than one result.\" ) ; \n} \nreturn result . get ( 0 ) ; \n} \n} \n"}
{"10623": "public class SqlQueryEngine { \nprivate < T extends MeasureAppender > List < T > executeQuery ( final SqlQueryBuilder < T > sqlQueryBuilder ) throws NovieRuntimeException { \nsqlQueryBuilder . buildQuery ( ) ; \nfinal String queryString = sqlQueryBuilder . getQueryString ( ) ; \nLOG . debug ( queryString ) ; \nlong beforeQuery = System . currentTimeMillis ( ) ; \nList < T > returnValue = jdbcTemplate . query ( queryString , sqlQueryBuilder . getMapSqlParameterSource ( ) , sqlQueryBuilder ) ; \nif ( LOG . isInfoEnabled ( ) ) { \nLOG . info ( \"SQL query successfully ran in \" + ( System . currentTimeMillis ( ) - beforeQuery ) + \"ms.\" ) ; \n} \nif ( LOG . isDebugEnabled ( ) ) { \nStringBuilder sb = new StringBuilder ( ) ; \nfor ( Entry < String , Object > e : sqlQueryBuilder . getMapSqlParameterSource ( ) . getValues ( ) . entrySet ( ) ) { \nif ( 0 < sb . length ( ) ) { \nsb . append ( \",\" ) ; \n} \nsb . append ( e . getKey ( ) ) ; \nsb . append ( \"=\" ) ; \nsb . append ( e . getValue ( ) ) ; \n} \nsb . insert ( 0 , \"Parameters [\" ) ; \nsb . append ( \"]\" ) ; \nLOG . debug ( sb . toString ( ) ) ; \n} \nreturn returnValue ; \n} \n} \n"}
{"10631": "public class Type1UUID { \nstatic long getTime ( ) { \nif ( RANDOM == null ) initializeForType1 ( ) ; \nlong newTime = getUUIDTime ( ) ; \nif ( _lastMillis >= newTime ) { \nincrementSequence ( ) ; \nnewTime = getUUIDTime ( ) ; \n} \n_lastMillis = newTime ; \nreturn newTime ; \n} \n} \n"}
{"10632": "public class Type1UUID { \nprivate static long getUUIDTime ( ) { \nif ( _currentMillis != System . currentTimeMillis ( ) ) { \n_currentMillis = System . currentTimeMillis ( ) ; \n_counter = 0 ; \n} \nif ( MILLI_MULT <= _counter + 1 ) { \n_currentMillis ++ ; \n_counter = 0 ; \n} \nlong currentTime = ( _currentMillis + GREG_OFFSET ) * MILLI_MULT ; \nreturn currentTime + _counter ++ ; \n} \n} \n"}
{"10650": "public class OrFilter { \npublic void addFilter ( PacketFilter filter ) { \nif ( filter == null ) { \nthrow new IllegalArgumentException ( \"Parameter cannot be null.\" ) ; \n} \nif ( size == filters . length ) { \nPacketFilter [ ] newFilters = new PacketFilter [ filters . length + 2 ] ; \nfor ( int i = 0 ; \nfilters . length > i ; \ni ++ ) { \nnewFilters [ i ] = filters [ i ] ; \n} \nfilters = newFilters ; \n} \nfilters [ size ] = filter ; \nsize ++ ; \n} \n} \n"}
{"10661": "public class Files { \npublic static Boolean contentEquals ( Path file1 , Path file2 ) throws IOException { \nif ( ! java . nio . file . Files . isRegularFile ( file1 ) ) throw new IllegalArgumentException ( file1 + \"is not a regular file\" ) ; \nif ( ! java . nio . file . Files . isRegularFile ( file2 ) ) throw new IllegalArgumentException ( file2 + \"is not a regular file\" ) ; \nFileChannel channel1 = null ; \nFileChannel channel2 = null ; \nMappedByteBuffer buffer1 = null ; \nMappedByteBuffer buffer2 = null ; \ntry { \nlong size1 = java . nio . file . Files . size ( file1 ) ; \nlong size2 = java . nio . file . Files . size ( file2 ) ; \nif ( size1 != size2 ) return false ; \nlong position = 0 ; \nlong length = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \nchannel1 = FileChannel . open ( file1 ) ; \nchannel2 = FileChannel . open ( file2 ) ; \nwhile ( 0 < length ) { \nbuffer1 = channel1 . map ( MapMode . READ_ONLY , position , length ) ; \nbuffer2 = channel2 . map ( MapMode . READ_ONLY , position , length ) ; \nfor ( int i = 0 ; \nlength > i ; \ni ++ ) if ( buffer1 . get ( ) != buffer2 . get ( ) ) return false ; \nposition += length ; \nlength = Math . min ( Integer . MAX_VALUE , size1 - position ) ; \ncleanDirectByteBuffer ( buffer1 ) ; \nbuffer1 = null ; \ncleanDirectByteBuffer ( buffer2 ) ; \nbuffer2 = null ; \n} \n} \nfinally { \ncleanDirectByteBuffer ( buffer1 ) ; \ncleanDirectByteBuffer ( buffer2 ) ; \nif ( channel1 != null ) try { \nchannel1 . close ( ) ; \n} \ncatch ( IOException e ) { \nif ( channel2 != null ) channel2 . close ( ) ; \nthrow e ; \n} \nif ( channel2 != null ) channel2 . close ( ) ; \n} \nreturn true ; \n} \n} \n"}
{"10668": "public class TransactionalHashMap { \n@ Override public void putAll ( Map < ? extends K , ? extends V > m ) { \nint numKeysToBeAdded = m . size ( ) ; \nif ( numKeysToBeAdded == 0 ) return ; \nif ( threshold < numKeysToBeAdded ) { \nint targetCapacity = ( int ) ( numKeysToBeAdded / loadFactor + 1 ) ; \nif ( MAXIMUM_CAPACITY < targetCapacity ) targetCapacity = MAXIMUM_CAPACITY ; \nint newCapacity = table . length ; \nwhile ( targetCapacity > newCapacity ) newCapacity <<= 1 ; \nif ( table . length < newCapacity ) resize ( newCapacity ) ; \n} \nfor ( Iterator < ? extends Map . Entry < ? extends K , ? extends V > > i = m . entrySet ( ) . iterator ( ) ; \ni . hasNext ( ) ; \n) { \nMap . Entry < ? extends K , ? extends V > e = i . next ( ) ; \nput ( e . getKey ( ) , e . getValue ( ) ) ; \n} \n} \n} \n"}
{"10672": "public class TransactionalHashMap { \nvoid addEntry ( int hash , K key , V value , int bucketIndex ) { \ntable [ bucketIndex ] = new Entry < K , V > ( hash , key , value , table [ bucketIndex ] ) ; \nif ( ! auto_commit ) table [ bucketIndex ] . setStatus ( Entry . ADDED , getCurrentThreadId ( ) ) ; \nif ( threshold <= size ++ ) resize ( 2 * table . length ) ; \n} \n} \n"}
{"10674": "public class StringUtils { \nprivate static String xmlAttribEncodeBinary ( String value ) { \nStringBuilder s = new StringBuilder ( ) ; \nchar buf [ ] = value . toCharArray ( ) ; \nfor ( char c : buf ) { \nswitch ( c ) { \ncase '<' : s . append ( \"&lt;\" ) ; \nbreak ; \ncase '>' : s . append ( \"&gt;\" ) ; \nbreak ; \ncase '&' : s . append ( \"&amp;\" ) ; \nbreak ; \ncase '\"' : s . append ( \"&quot;\" ) ; \nbreak ; \ncase '\\'' : s . append ( \"&apos;\" ) ; \nbreak ; \ndefault : if ( 0x1f >= c || ( c >= 0x7f && 0x9f >= c ) ) { \ns . append ( \"&#x\" ) ; \ns . append ( String . format ( \"%X\" , ( int ) c ) ) ; \ns . append ( ';' ) ; \n} \nelse { \ns . append ( c ) ; \n} \n} \n} \nreturn s . toString ( ) ; \n} \n} \n"}
{"10675": "public class StringUtils { \npublic static String encodeHex ( byte [ ] bytes ) { \nStringBuilder hex = new StringBuilder ( bytes . length * 2 ) ; \nfor ( byte aByte : bytes ) { \nif ( 0x10 > ( ( int ) aByte & 0xff ) ) { \nhex . append ( \"0\" ) ; \n} \nhex . append ( Integer . toString ( ( int ) aByte & 0xff , 16 ) ) ; \n} \nreturn hex . toString ( ) ; \n} \n} \n"}
{"10696": "public class AbstractDao { \n@ Override public void updateOne ( E object , String ... properties ) { \nif ( object . getId ( ) == null ) { \nthrow new RuntimeException ( \"Not a Persisted entity\" ) ; \n} \nif ( properties == null || properties . length == 0 ) { \nentityManager . merge ( object ) ; \nreturn ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"Update \" + clazz . getName ( ) + \" SET \" ) ; \nMap < String , Object > cache = new HashMap < String , Object > ( ) ; \nfor ( String prop : properties ) { \ntry { \nField field = object . getClass ( ) . getDeclaredField ( prop ) ; \nfield . setAccessible ( true ) ; \nObject value = field . get ( object ) ; \nif ( value instanceof Collection ) { \nthrow new RuntimeException ( \"Collection property is not suppotred.\" ) ; \n} \ncache . put ( prop , value ) ; \nif ( 1 < cache . size ( ) ) { \nsb . append ( \" ,\" ) ; \n} \nsb . append ( prop ) ; \nsb . append ( \" = :\" ) ; \nsb . append ( prop ) ; \n} \ncatch ( Exception e ) { \nthrow new RuntimeException ( e ) ; \n} \n} \nif ( cache . size ( ) == 0 ) return ; \nsb . append ( \" WHERE id = \" + object . getId ( ) ) ; \nQuery query = entityManager . createQuery ( sb . toString ( ) ) ; \nfor ( Entry < String , Object > entry : cache . entrySet ( ) ) { \nquery . setParameter ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \nquery . executeUpdate ( ) ; \n} \n} \n"}
{"10697": "public class KeepAliveManager { \npublic void setPingInterval ( long newPingInterval ) { \nif ( pingInterval == newPingInterval ) return ; \nif ( 0 < newPingInterval ) enableExecutorService ( ) ; \npingInterval = newPingInterval ; \nif ( 0 > pingInterval ) { \nstopPinging ( ) ; \n} \nelse { \nschedulePingServerTask ( ) ; \n} \n} \n} \n"}
{"10698": "public class KeepAliveManager { \nprivate synchronized void schedulePingServerTask ( ) { \nenableExecutorService ( ) ; \nstopPingServerTask ( ) ; \nif ( 0 < pingInterval ) { \nperiodicPingTask = periodicPingExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nPing ping = new Ping ( ) ; \nPacketFilter responseFilter = new PacketIDFilter ( ping . getID ( ) ) ; \nConnection connection = weakRefConnection . get ( ) ; \nfinal PacketCollector response = pingFailedListeners . isEmpty ( ) ? null : connection . createPacketCollector ( responseFilter ) ; \nconnection . sendPacket ( ping ) ; \nif ( response != null ) { \nperiodicPingExecutorService . schedule ( new Runnable ( ) { \n@ Override public void run ( ) { \nPacket result = response . nextResult ( 1 ) ; \nresponse . cancel ( ) ; \nif ( result == null ) { \nfor ( PingFailedListener listener : pingFailedListeners ) { \nlistener . pingFailed ( ) ; \n} \n} \n} \n} \n, SmackConfiguration . getPacketReplyTimeout ( ) , TimeUnit . MILLISECONDS ) ; \n} \n} \n} \n, getPingInterval ( ) , TimeUnit . MILLISECONDS ) ; \n} \n} \n} \n"}
{"10719": "public class ObservableWriter { \nprivate void notifyListeners ( String str ) { \nWriterListener [ ] writerListeners = null ; \nsynchronized ( listeners ) { \nwriterListeners = new WriterListener [ listeners . size ( ) ] ; \nlisteners . toArray ( writerListeners ) ; \n} \nfor ( int i = 0 ; \nwriterListeners . length > i ; \ni ++ ) { \nwriterListeners [ i ] . write ( str ) ; \n} \n} \n} \n"}
{"10729": "public class CF_Locator { \nprotected final void include ( String name , File file ) { \nif ( ! file . exists ( ) ) { \nreturn ; \n} \nif ( ! file . isDirectory ( ) ) { \nif ( 0 < this . jarFilter . size ( ) ) { \nboolean ok = false ; \nfor ( String s : this . jarFilter ) { \nif ( file . getName ( ) . startsWith ( s ) ) { \nok = true ; \n} \n} \nif ( ok == false ) { \nreturn ; \n} \n} \nthis . includeJar ( file ) ; \nreturn ; \n} \nif ( name == null ) { \nname = \"\" ; \n} \nelse { \nname += \".\" ; \n} \nFile [ ] dirs = file . listFiles ( CF_Utils . DIRECTORIES_ONLY ) ; \nfor ( int i = 0 ; \ndirs . length > i ; \ni ++ ) { \ntry { \nthis . locationMap . put ( new URI ( \"file://\" + dirs [ i ] . getCanonicalPath ( ) ) , name + dirs [ i ] . getName ( ) ) ; \n} \ncatch ( IOException ignore ) { \nreturn ; \n} \ncatch ( URISyntaxException ignore ) { \nreturn ; \n} \nthis . include ( name + dirs [ i ] . getName ( ) , dirs [ i ] ) ; \n} \n} \n} \n"}
{"10772": "public class CF { \npublic Set < Class < ? > > getSubclasses ( Class < ? > clazz ) { \nSet < Class < ? > > ret = new HashSet < Class < ? > > ( ) ; \nSet < Class < ? > > w = null ; \nif ( clazz != null ) { \nthis . clear ( ) ; \nMap < URI , String > locations = this . locator . getCfLocations ( ) ; \nfor ( Entry < URI , String > entry : locations . entrySet ( ) ) { \ntry { \nw = search ( clazz , entry . getKey ( ) , locations . get ( entry . getKey ( ) ) ) ; \nif ( w != null && ( 0 < w . size ( ) ) ) { \nret . addAll ( w ) ; \n} \n} \ncatch ( MalformedURLException ex ) { \n} \n} \n} \nreturn ret ; \n} \n} \n"}
{"10775": "public class CF { \nprotected final Map < Class < ? > , URI > searchDirectory ( Class < ? > clazz , File directory , URI location , String packageName ) { \nMap < Class < ? > , URI > ret = new HashMap < > ( ) ; \nString [ ] files = directory . list ( ) ; \nfor ( int i = 0 ; \nfiles . length > i ; \ni ++ ) { \nif ( files [ i ] . endsWith ( \".class\" ) ) { \nString classname = files [ i ] . substring ( 0 , files [ i ] . length ( ) - 6 ) ; \ntry { \nClass < ? > c = Class . forName ( packageName + \".\" + classname ) ; \nif ( clazz . isAssignableFrom ( c ) && ! clazz . getName ( ) . equals ( packageName + \".\" + classname ) ) { \nret . put ( c , location ) ; \n} \n} \ncatch ( Exception ex ) { \nerrors . add ( ex ) ; \n} \n} \n} \nreturn ret ; \n} \n} \n"}
{"10791": "public class RSMUtils { \npublic static List < Identifiable > filterRSMResponse ( List < Identifiable > objects , RSM rsm ) throws IllegalArgumentException { \nString after = rsm . getAfter ( ) ; \nString before = rsm . getBefore ( ) ; \nint initialIndex = rsm . getIndex ( ) ; \nint lastIndex = objects . size ( ) ; \nif ( after != null || ( before != null && ! before . isEmpty ( ) ) ) { \nboolean afterItemFound = false ; \nboolean beforeItemFound = false ; \nint i = 0 ; \nfor ( Identifiable object : objects ) { \nif ( after != null && after . equals ( object . getId ( ) ) ) { \ninitialIndex = i + 1 ; \nafterItemFound = true ; \n} \nif ( before != null && before . equals ( object . getId ( ) ) ) { \nlastIndex = i ; \nbeforeItemFound = true ; \n} \ni ++ ; \n} \nif ( after != null && ! afterItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \nif ( before != null && ! before . isEmpty ( ) && ! beforeItemFound ) { \nthrow new IllegalArgumentException ( ) ; \n} \n} \nif ( rsm . getMax ( ) != null ) { \nif ( before != null ) { \ninitialIndex = lastIndex - rsm . getMax ( ) ; \n} \nelse { \nlastIndex = initialIndex + rsm . getMax ( ) ; \n} \n} \nboolean outOfRange = lastIndex < initialIndex || 0 > initialIndex || objects . size ( ) < lastIndex ; \nList < Identifiable > filteredList = outOfRange ? new LinkedList < Identifiable > ( ) : objects . subList ( initialIndex , lastIndex ) ; \nrsm . setCount ( objects . size ( ) ) ; \nrsm . setIndex ( initialIndex ) ; \nif ( ! filteredList . isEmpty ( ) ) { \nrsm . setFirst ( filteredList . get ( 0 ) . getId ( ) ) ; \nrsm . setLast ( filteredList . get ( filteredList . size ( ) - 1 ) . getId ( ) ) ; \n} \nreturn filteredList ; \n} \n} \n"}
{"10822": "public class PresenceConstant { \n@ Override public boolean controlEvents ( EventModel eventModel ) { \nif ( 0 <= level . compareTo ( PresenceIndicatorLevel . WEAK ) ) { \nreturn present ; \n} \nelse if ( 0 > level . compareTo ( PresenceIndicatorLevel . WEAK ) && mostVague . get ( ) ) { \nreturn present ; \n} \nelse { \nreturn true ; \n} \n} \n} \n"}
{"10824": "public class PresenceConstant { \nprivate void updateVague ( ) { \ngenerateResource ( PresenceResource . ID ) . orElse ( CompletableFuture . completedFuture ( new ArrayList < > ( ) ) ) . thenAccept ( list -> mostVague . set ( list . stream ( ) . map ( Presence :: importPresence ) . filter ( Optional :: isPresent ) . map ( Optional :: get ) . map ( Presence :: getLevel ) . noneMatch ( level -> 0 < level . compareTo ( getLevel ( ) ) ) ) ) ; \n} \n} \n"}
{"10844": "public class RequestUtils { \npublic static Object toValue ( String name , Object value ) { \nString [ ] parts = StringUtils . split ( name , \"@\" , 2 ) ; \nString fieldName = null ; \nString fieldType = \"String\" ; \nif ( parts . length == 2 ) { \nfieldType = parts [ 1 ] ; \nfieldName = parts [ 0 ] ; \n} \nelse if ( parts . length == 1 ) { \nfieldName = parts [ 0 ] ; \n} \nelse { \nthrow new IllegalArgumentException ( \"Invalid property name\" ) ; \n} \ntry { \nint l = Array . getLength ( value ) ; \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nif ( ! fieldName . endsWith ( \"[]\" ) && l == 1 ) { \nreturn rpt . newInstance ( Array . get ( value , 0 ) ) ; \n} \nClass < ? > componentType = rpt . getComponentType ( ) ; \nObject [ ] a = ( Object [ ] ) Array . newInstance ( componentType , l ) ; \nfor ( int i = 0 ; \nl > i ; \ni ++ ) { \na [ i ] = rpt . newInstance ( Array . get ( value , i ) ) ; \n} \nreturn a ; \n} \ncatch ( IllegalArgumentException e ) { \nRequestParameterType < ? > rpt = TYPES . get ( fieldType ) ; \nif ( rpt == null ) { \nrpt = TYPES . get ( RequestParameterType . STRING ) ; \n} \nreturn rpt . newInstance ( value ) ; \n} \n} \n} \n"}
{"10851": "public class TransactionalBidiTreeMap { \nprivate Node < K , V > lookup ( final Object data , final int index ) { \nNode < K , V > rval = null ; \nNode < K , V > node = rootNode [ index ] ; \nwhile ( node != null ) { \nint cmp = compare ( Node . NO_CHANGE , data , node . getStatus ( ) , node . getData ( index ) , index ) ; \nif ( cmp == 0 ) { \nrval = node ; \nbreak ; \n} \nelse { \nnode = ( 0 > cmp ) ? node . getLeft ( index ) : node . getRight ( index ) ; \n} \n} \nreturn rval ; \n} \n} \n"}
{"10868": "public class TransactionalBidiTreeMap { \nprivate void doRedBlackDelete ( final Node < K , V > deletedNode ) { \nfor ( int index = FIRST_INDEX ; \nNUMBER_OF_INDICES > index ; \nindex ++ ) { \nif ( ( deletedNode . getLeft ( index ) != null ) && ( deletedNode . getRight ( index ) != null ) ) { \nswapPosition ( nextGreater ( deletedNode , index ) , deletedNode , index ) ; \n} \nNode < K , V > replacement = ( ( deletedNode . getLeft ( index ) != null ) ? deletedNode . getLeft ( index ) : deletedNode . getRight ( index ) ) ; \nif ( replacement != null ) { \nreplacement . setParent ( deletedNode . getParent ( index ) , index ) ; \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = replacement ; \n} \nelse if ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( replacement , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( replacement , index ) ; \n} \ndeletedNode . setLeft ( null , index ) ; \ndeletedNode . setRight ( null , index ) ; \ndeletedNode . setParent ( null , index ) ; \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( replacement , index ) ; \n} \n} \nelse { \nif ( deletedNode . getParent ( index ) == null ) { \nrootNode [ index ] = null ; \n} \nelse { \nif ( isBlack ( deletedNode , index ) ) { \ndoRedBlackDeleteFixup ( deletedNode , index ) ; \n} \nif ( deletedNode . getParent ( index ) != null ) { \nif ( deletedNode == deletedNode . getParent ( index ) . getLeft ( index ) ) { \ndeletedNode . getParent ( index ) . setLeft ( null , index ) ; \n} \nelse { \ndeletedNode . getParent ( index ) . setRight ( null , index ) ; \n} \ndeletedNode . setParent ( null , index ) ; \n} \n} \n} \n} \nshrink ( ) ; \n} \n} \n"}
{"10870": "public class TransactionalBidiTreeMap { \nprivate void insertValue ( final Node < K , V > newNode , final String thread_id ) throws IllegalArgumentException { \nNode < K , V > node = rootNode [ VALUE ] ; \nwhile ( true ) { \nint cmp = compare ( Node . ADDED , newNode . getData ( VALUE ) , node . getStatus ( ) , node . getData ( VALUE ) , VALUE ) ; \nif ( cmp == 0 ) { \nif ( nextEqualValid ( getFloorEqualNode ( node , VALUE ) , VALUE , thread_id ) != null ) { \nString debug_message = \"Cannot store a duplicate value (\\\"\" + newNode . getData ( VALUE ) + \"\\\") in this Map. Value already exists for key \" + node . getKey ( ) ; \nlog . debug ( debug_message ) ; \nthrow new IllegalArgumentException ( debug_message ) ; \n} \nif ( node . is ( Node . ADDED , null ) ) throw new ConcurrentModificationException ( ) ; \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse if ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse if ( 0 > cmp ) { \nif ( node . getLeft ( VALUE ) != null ) { \nnode = node . getLeft ( VALUE ) ; \n} \nelse { \nnode . setLeft ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \nelse { \nif ( node . getRight ( VALUE ) != null ) { \nnode = node . getRight ( VALUE ) ; \n} \nelse { \nnode . setRight ( newNode , VALUE ) ; \nnewNode . setParent ( node , VALUE ) ; \ndoRedBlackInsert ( newNode , VALUE ) ; \nbreak ; \n} \n} \n} \n} \n} \n"}
{"10880": "public class Cache { \nprotected synchronized void deleteExpiredEntries ( ) { \nif ( 0 >= maxLifetime ) { \nreturn ; \n} \nLinkedListNode node = ageList . getLast ( ) ; \nif ( node == null ) { \nreturn ; \n} \nlong expireTime = System . currentTimeMillis ( ) - maxLifetime ; \nwhile ( node . timestamp < expireTime ) { \nif ( remove ( node . object , true ) == null ) { \nlog . warn ( \"Error attempting to remove(\" + node . object . toString ( ) + \") - cacheObject not found in cache!\" ) ; \nnode . remove ( ) ; \n} \nnode = ageList . getLast ( ) ; \nif ( node == null ) { \nreturn ; \n} \n} \n} \n} \n"}
{"10881": "public class Cache { \nprotected synchronized void cullCache ( ) { \nif ( 0 > maxCacheSize ) { \nreturn ; \n} \nif ( maxCacheSize < map . size ( ) ) { \ndeleteExpiredEntries ( ) ; \nint desiredSize = ( int ) ( maxCacheSize * .90 ) ; \nfor ( int i = map . size ( ) ; \ndesiredSize < i ; \ni -- ) { \nif ( remove ( lastAccessedList . getLast ( ) . object , true ) == null ) { \nlog . warn ( \"Error attempting to cullCache with remove(\" + lastAccessedList . getLast ( ) . object . toString ( ) + \") - cacheObject not found in cache!\" ) ; \nlastAccessedList . getLast ( ) . remove ( ) ; \n} \n} \n} \n} \n} \n"}
{"10887": "public class IPv4Scanner { \npublic static InetAddress subnetAddress0 ( InetAddress addr , int subnetBits ) { \nif ( 1 > subnetBits || subnetBits >= 32 ) { \nthrow new FireRESTException ( \"Expected subnetBits 1..31\" ) ; \n} \nlong mask = 1 ; \nfor ( int i = 0 ; \n32 > i ; \ni ++ ) { \nmask <<= 1 ; \nmask |= subnetBits > i ? 1 : 0 ; \n} \nlong host0 = asLongAddress ( addr ) & mask ; \ntry { \nreturn asInetAddress ( host0 ) ; \n} \ncatch ( UnknownHostException e ) { \nthrow new FireRESTException ( e ) ; \n} \n} \n} \n"}
{"10892": "public class ExecS { \nprotected final void printList ( ) { \nST list = this . stg . getInstanceOf ( \"list\" ) ; \nlist . add ( \"appName\" , this . appName ) ; \nif ( 0 < this . classmap . size ( ) ) { \nList < Map < String , String > > l = new ArrayList < > ( ) ; \nfor ( String key : this . classmap . keySet ( ) ) { \nMap < String , String > m = new HashMap < > ( ) ; \nm . put ( \"key\" , key ) ; \nm . put ( \"val\" , this . classmap . get ( key ) . getName ( ) ) ; \nl . add ( m ) ; \n} \nlist . add ( \"classMap\" , l ) ; \n} \nlist . add ( \"className\" , this . classNames ) ; \nSystem . out . println ( list . render ( ) ) ; \n} \n} \n"}
{"10922": "public class Playlist { \npublic Playlist shuffle ( ) { \nint position = getPosition ( ) ; \nlong seed = System . nanoTime ( ) ; \nif ( 0 <= position && queue . size ( ) > position ) { \nList < TrackInfo > trackInfos = queue . subList ( 0 , position ) ; \nList < TrackInfo > notPlayed = queue . subList ( position , queue . size ( ) ) ; \nList < TrackInfo > shuffledNotPlayed = new ArrayList < > ( notPlayed ) ; \nCollections . shuffle ( shuffledNotPlayed , new Random ( seed ) ) ; \ntrackInfos . addAll ( shuffledNotPlayed ) ; \nreturn new Playlist ( trackInfos ) ; \n} \nelse { \nList < TrackInfo > trackInfos = new ArrayList < > ( queue ) ; \nCollections . shuffle ( trackInfos , new Random ( seed ) ) ; \nreturn new Playlist ( trackInfos ) ; \n} \n} \n} \n"}
{"10924": "public class Playlist { \npublic HashMap < String , Object > export ( ) { \nHashMap < String , Object > data = new HashMap < > ( ) ; \nfor ( int i = 0 ; \nqueue . size ( ) > i ; \ni ++ ) { \ndata . put ( QUEUE_DESCRIPTOR + i , queue . get ( i ) . export ( ) ) ; \n} \nfor ( int i = 0 ; \nplaybackModes . size ( ) > i ; \ni ++ ) { \ndata . put ( PLAYBACK_MODE_DESCRIPTOR + i , playbackModes . get ( i ) . name ( ) ) ; \n} \ndata . put ( NAME_DESCRIPTOR , name ) ; \ndata . put ( POSITION_DESCRIPTOR , position ) ; \ndata . put ( DATA_DESCRIPTOR , this . data ) ; \nreturn data ; \n} \n} \n"}
{"10925": "public class StringUtils { \npublic static final String escapeForXML ( String string ) { \nif ( string == null ) { \nreturn null ; \n} \nchar ch ; \nint i = 0 ; \nint last = 0 ; \nchar [ ] input = string . toCharArray ( ) ; \nint len = input . length ; \nStringBuffer out = new StringBuffer ( ( int ) ( len * 1.3 ) ) ; \nfor ( ; \nlen > i ; \ni ++ ) { \nch = input [ i ] ; \nif ( '>' < ch ) { \ncontinue ; \n} \nelse if ( ch == '<' ) { \nif ( last < i ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( LT_ENCODE ) ; \n} \nelse if ( ch == '>' ) { \nif ( last < i ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( GT_ENCODE ) ; \n} \nelse if ( ch == '&' ) { \nif ( last < i ) { \nout . append ( input , last , i - last ) ; \n} \nif ( ! ( i + 5 < len && input [ i + 1 ] == '#' && Character . isDigit ( input [ i + 2 ] ) && Character . isDigit ( input [ i + 3 ] ) && Character . isDigit ( input [ i + 4 ] ) && input [ i + 5 ] == ';' ) ) { \nlast = i + 1 ; \nout . append ( AMP_ENCODE ) ; \n} \n} \nelse if ( ch == '\"' ) { \nif ( last < i ) { \nout . append ( input , last , i - last ) ; \n} \nlast = i + 1 ; \nout . append ( QUOTE_ENCODE ) ; \n} \n} \nif ( last == 0 ) { \nreturn string ; \n} \nif ( last < i ) { \nout . append ( input , last , i - last ) ; \n} \nreturn out . toString ( ) ; \n} \n} \n"}
{"10929": "public class ContentEventListener { \npublic void handleEvent ( Event event ) { \nString topic = event . getTopic ( ) ; \nLOGGER . debug ( \"Got Event {} {} \" , event , handlers ) ; \nCollection < IndexingHandler > contentIndexHandler = handlers . get ( topic ) ; \nif ( contentIndexHandler != null && 0 < contentIndexHandler . size ( ) ) { \ntry { \nint ttl = Utils . toInt ( event . getProperty ( TopicIndexer . TTL ) , Integer . MAX_VALUE ) ; \nfor ( IndexingHandler indexingHandler : contentIndexHandler ) { \nif ( indexingHandler instanceof QoSIndexHandler ) { \nttl = Math . min ( ttl , Utils . defaultMax ( ( ( QoSIndexHandler ) indexingHandler ) . getTtl ( event ) ) ) ; \n} \n} \nQueueManager q = null ; \nif ( queues [ 0 ] . batchDelay > ttl ) { \nLOGGER . warn ( \"Unable to satisfy TTL of {} on event {}, posting to the highest priority queue. \" + \"If this message is logged a lot please adjust the queues or change the event ttl to something that can be satisfied. \" + \"Filling the highest priority queue is counter productive. \" , ttl , event ) ; \nqueues [ 0 ] . saveEvent ( event ) ; \n} \nelse { \nfor ( QueueManager qm : queues ) { \nif ( qm . batchDelay > ttl ) { \nq . saveEvent ( event ) ; \nq = null ; \nbreak ; \n} \nq = qm ; \n} \nif ( q != null ) { \nq . saveEvent ( event ) ; \n} \n} \n} \ncatch ( IOException e ) { \nLOGGER . warn ( e . getMessage ( ) , e ) ; \n} \n} \n} \n} \n"}
{"10941": "public class AbstractHashedMap { \npublic boolean containsValue ( Object value ) { \nif ( value == null ) { \nfor ( int i = 0 , isize = data . length ; \nisize > i ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( entry . getValue ( ) == null ) { \nreturn true ; \n} \nentry = entry . next ; \n} \n} \n} \nelse { \nfor ( int i = 0 , isize = data . length ; \nisize > i ; \ni ++ ) { \nHashEntry entry = data [ i ] ; \nwhile ( entry != null ) { \nif ( isEqualValue ( value , entry . getValue ( ) ) ) { \nreturn true ; \n} \nentry = entry . next ; \n} \n} \n} \nreturn false ; \n} \n} \n"}
{"10943": "public class AbstractHashedMap { \npublic void clear ( ) { \nmodCount ++ ; \nHashEntry [ ] data = this . data ; \nfor ( int i = data . length - 1 ; \n0 <= i ; \ni -- ) { \ndata [ i ] = null ; \n} \nsize = 0 ; \n} \n} \n"}
{"10947": "public class AbstractHashedMap { \nprotected void ensureCapacity ( int newCapacity ) { \nint oldCapacity = data . length ; \nif ( oldCapacity >= newCapacity ) { \nreturn ; \n} \nif ( size == 0 ) { \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = new HashEntry [ newCapacity ] ; \n} \nelse { \nHashEntry < K , V > oldEntries [ ] = data ; \nHashEntry < K , V > newEntries [ ] = new HashEntry [ newCapacity ] ; \nmodCount ++ ; \nfor ( int i = oldCapacity - 1 ; \n0 <= i ; \ni -- ) { \nHashEntry < K , V > entry = oldEntries [ i ] ; \nif ( entry != null ) { \noldEntries [ i ] = null ; \ndo { \nHashEntry < K , V > next = entry . next ; \nint index = hashIndex ( entry . hashCode , newCapacity ) ; \nentry . next = newEntries [ index ] ; \nnewEntries [ index ] = entry ; \nentry = next ; \n} \nwhile ( entry != null ) ; \n} \n} \nthreshold = calculateThreshold ( newCapacity , loadFactor ) ; \ndata = newEntries ; \n} \n} \n} \n"}
{"10948": "public class AbstractHashedMap { \nprotected int calculateNewCapacity ( int proposedCapacity ) { \nint newCapacity = 1 ; \nif ( MAXIMUM_CAPACITY < proposedCapacity ) { \nnewCapacity = MAXIMUM_CAPACITY ; \n} \nelse { \nwhile ( proposedCapacity > newCapacity ) { \nnewCapacity <<= 1 ; \n} \nif ( MAXIMUM_CAPACITY < newCapacity ) { \nnewCapacity = MAXIMUM_CAPACITY ; \n} \n} \nreturn newCapacity ; \n} \n} \n"}
